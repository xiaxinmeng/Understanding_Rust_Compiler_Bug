{"sha": "d349e32fc70da197918256c29a0858fe7e1a6588", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzNDllMzJmYzcwZGExOTc5MTgyNTZjMjlhMDg1OGZlN2UxYTY1ODg=", "commit": {"author": {"name": "Stefan Lankes", "email": "slankes@eonerc.rwth-aachen.de", "date": "2019-10-25T07:09:55Z"}, "committer": {"name": "Stefan Lankes", "email": "slankes@eonerc.rwth-aachen.de", "date": "2019-10-25T07:09:55Z"}, "message": "Merge branch 'master' into rusty-hermit, resolve conflicts", "tree": {"sha": "17f268176d32a172c84e84c30303a4794f4513b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17f268176d32a172c84e84c30303a4794f4513b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d349e32fc70da197918256c29a0858fe7e1a6588", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d349e32fc70da197918256c29a0858fe7e1a6588", "html_url": "https://github.com/rust-lang/rust/commit/d349e32fc70da197918256c29a0858fe7e1a6588", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d349e32fc70da197918256c29a0858fe7e1a6588/comments", "author": {"login": "stlankes", "id": 5888473, "node_id": "MDQ6VXNlcjU4ODg0NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/5888473?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stlankes", "html_url": "https://github.com/stlankes", "followers_url": "https://api.github.com/users/stlankes/followers", "following_url": "https://api.github.com/users/stlankes/following{/other_user}", "gists_url": "https://api.github.com/users/stlankes/gists{/gist_id}", "starred_url": "https://api.github.com/users/stlankes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stlankes/subscriptions", "organizations_url": "https://api.github.com/users/stlankes/orgs", "repos_url": "https://api.github.com/users/stlankes/repos", "events_url": "https://api.github.com/users/stlankes/events{/privacy}", "received_events_url": "https://api.github.com/users/stlankes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "stlankes", "id": 5888473, "node_id": "MDQ6VXNlcjU4ODg0NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/5888473?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stlankes", "html_url": "https://github.com/stlankes", "followers_url": "https://api.github.com/users/stlankes/followers", "following_url": "https://api.github.com/users/stlankes/following{/other_user}", "gists_url": "https://api.github.com/users/stlankes/gists{/gist_id}", "starred_url": "https://api.github.com/users/stlankes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stlankes/subscriptions", "organizations_url": "https://api.github.com/users/stlankes/orgs", "repos_url": "https://api.github.com/users/stlankes/repos", "events_url": "https://api.github.com/users/stlankes/events{/privacy}", "received_events_url": "https://api.github.com/users/stlankes/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddcd157d03a067419d7f5b4375cfaff5a474856a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddcd157d03a067419d7f5b4375cfaff5a474856a", "html_url": "https://github.com/rust-lang/rust/commit/ddcd157d03a067419d7f5b4375cfaff5a474856a"}, {"sha": "d54111afc061ef398cd8ce28984f9e8d70001b24", "url": "https://api.github.com/repos/rust-lang/rust/commits/d54111afc061ef398cd8ce28984f9e8d70001b24", "html_url": "https://github.com/rust-lang/rust/commit/d54111afc061ef398cd8ce28984f9e8d70001b24"}], "stats": {"total": 6318, "additions": 3582, "deletions": 2736}, "files": [{"sha": "37a217d2a04523fb53a3cc1c1ed6031ca2ff787b", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -128,6 +128,14 @@ the master branch to your feature branch.\n Also, please make sure that fixup commits are squashed into other related\n commits with meaningful commit messages.\n \n+GitHub allows [closing issues using keywords][closing-keywords]. This feature\n+should be used to keep the issue tracker tidy. However, it is generally preferred\n+to put the \"closes #123\" text in the PR description rather than the issue commit;\n+particularly during rebasing, citing the issue number in the commit can \"spam\"\n+the issue in question.\n+\n+[closing-keywords]: https://help.github.com/en/articles/closing-issues-using-keywords\n+\n Please make sure your pull request is in compliance with Rust's style\n guidelines by running\n "}, {"sha": "a8fc36063fb22f592bb921ef89616e8cbd10b8f5", "filename": "Cargo.lock", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -556,9 +556,9 @@ dependencies = [\n \n [[package]]\n name = \"compiletest_rs\"\n-version = \"0.3.24\"\n+version = \"0.3.25\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"676a74b493d50ac33cacd83fd536597e6b52c0b46b9856f7b9c809d82fef4ac0\"\n+checksum = \"f75b10a18fb53549fdd090846eb01c7f8593914494d1faabc4d3005c436e417a\"\n dependencies = [\n  \"diff\",\n  \"filetime\",\n@@ -1297,9 +1297,9 @@ dependencies = [\n \n [[package]]\n name = \"hashbrown\"\n-version = \"0.6.1\"\n+version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6587d09be37fb98a11cb08b9000a3f592451c1b1b613ca69d949160e313a430a\"\n+checksum = \"3cd9867f119b19fecb08cd5c326ad4488d7a1da4bf75b4d95d71db742525aaab\"\n dependencies = [\n  \"autocfg\",\n  \"compiler_builtins\",\n@@ -3494,6 +3494,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_interface\",\n+ \"rustc_lint\",\n  \"rustc_metadata\",\n  \"rustc_mir\",\n  \"rustc_plugin\",\n@@ -4156,9 +4157,8 @@ dependencies = [\n  \"core\",\n  \"dlmalloc\",\n  \"fortanix-sgx-abi\",\n- \"hashbrown 0.6.1\",\n+ \"hashbrown 0.6.2\",\n  \"hermit-abi\",\n- \"libc\",\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"profiler_builtins\","}, {"sha": "2748903f2d4756b34b5623ae324f0319f6977345", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -443,6 +443,7 @@ impl<'a> Builder<'a> {\n                 dist::Rustc,\n                 dist::DebuggerScripts,\n                 dist::Std,\n+                dist::RustcDev,\n                 dist::Analysis,\n                 dist::Src,\n                 dist::PlainSourceTarball,"}, {"sha": "df1c72575846b0a69e17944473805299af834649", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -55,6 +55,7 @@ impl Step for Std {\n                   cargo,\n                   args(builder.kind),\n                   &libstd_stamp(builder, compiler, target),\n+                  vec![],\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n@@ -103,6 +104,7 @@ impl Step for Rustc {\n                   cargo,\n                   args(builder.kind),\n                   &librustc_stamp(builder, compiler, target),\n+                  vec![],\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n@@ -155,6 +157,7 @@ impl Step for CodegenBackend {\n                   cargo,\n                   args(builder.kind),\n                   &codegen_backend_stamp(builder, compiler, target, backend),\n+                  vec![],\n                   true);\n     }\n }\n@@ -199,6 +202,7 @@ impl Step for Rustdoc {\n                   cargo,\n                   args(builder.kind),\n                   &rustdoc_stamp(builder, compiler, target),\n+                  vec![],\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);"}, {"sha": "da8d43ed49b7f34895523e3f7fc1d716ca35a08a", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 41, "deletions": 22, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -69,7 +69,7 @@ impl Step for Std {\n             return;\n         }\n \n-        builder.ensure(StartupObjects { compiler, target });\n+        let mut target_deps = builder.ensure(StartupObjects { compiler, target });\n \n         let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n         if compiler_to_use != compiler {\n@@ -91,7 +91,7 @@ impl Step for Std {\n             return;\n         }\n \n-        copy_third_party_objects(builder, &compiler, target);\n+        target_deps.extend(copy_third_party_objects(builder, &compiler, target).into_iter());\n \n         let mut cargo = builder.cargo(compiler, Mode::Std, target, \"build\");\n         std_cargo(builder, &compiler, target, &mut cargo);\n@@ -102,6 +102,7 @@ impl Step for Std {\n                   cargo,\n                   vec![],\n                   &libstd_stamp(builder, compiler, target),\n+                  target_deps,\n                   false);\n \n         builder.ensure(StdLink {\n@@ -113,29 +114,36 @@ impl Step for Std {\n }\n \n /// Copies third pary objects needed by various targets.\n-fn copy_third_party_objects(builder: &Builder<'_>, compiler: &Compiler, target: Interned<String>) {\n+fn copy_third_party_objects(builder: &Builder<'_>, compiler: &Compiler, target: Interned<String>)\n+    -> Vec<PathBuf>\n+{\n     let libdir = builder.sysroot_libdir(*compiler, target);\n \n+    let mut target_deps = vec![];\n+\n+    let mut copy_and_stamp = |sourcedir: &Path, name: &str| {\n+        let target = libdir.join(name);\n+        builder.copy(\n+            &sourcedir.join(name),\n+            &target,\n+        );\n+        target_deps.push(target);\n+    };\n+\n     // Copies the crt(1,i,n).o startup objects\n     //\n     // Since musl supports fully static linking, we can cross link for it even\n     // with a glibc-targeting toolchain, given we have the appropriate startup\n     // files. As those shipped with glibc won't work, copy the ones provided by\n     // musl so we have them on linux-gnu hosts.\n     if target.contains(\"musl\") {\n+        let srcdir = builder.musl_root(target).unwrap().join(\"lib\");\n         for &obj in &[\"crt1.o\", \"crti.o\", \"crtn.o\"] {\n-            builder.copy(\n-                &builder.musl_root(target).unwrap().join(\"lib\").join(obj),\n-                &libdir.join(obj),\n-            );\n+            copy_and_stamp(&srcdir, obj);\n         }\n     } else if target.ends_with(\"-wasi\") {\n-        for &obj in &[\"crt1.o\"] {\n-            builder.copy(\n-                &builder.wasi_root(target).unwrap().join(\"lib/wasm32-wasi\").join(obj),\n-                &libdir.join(obj),\n-            );\n-        }\n+        let srcdir = builder.wasi_root(target).unwrap().join(\"lib/wasm32-wasi\");\n+        copy_and_stamp(&srcdir, \"crt1.o\");\n     }\n \n     // Copies libunwind.a compiled to be linked wit x86_64-fortanix-unknown-sgx.\n@@ -145,11 +153,11 @@ fn copy_third_party_objects(builder: &Builder<'_>, compiler: &Compiler, target:\n     // which is provided by std for this target.\n     if target == \"x86_64-fortanix-unknown-sgx\" {\n         let src_path_env = \"X86_FORTANIX_SGX_LIBS\";\n-        let obj = \"libunwind.a\";\n         let src = env::var(src_path_env).expect(&format!(\"{} not found in env\", src_path_env));\n-        let src = Path::new(&src).join(obj);\n-        builder.copy(&src, &libdir.join(obj));\n+        copy_and_stamp(Path::new(&src), \"libunwind.a\");\n     }\n+\n+    target_deps\n }\n \n /// Configure cargo to compile the standard library, adding appropriate env vars\n@@ -306,7 +314,7 @@ pub struct StartupObjects {\n }\n \n impl Step for StartupObjects {\n-    type Output = ();\n+    type Output = Vec<PathBuf>;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/rtstartup\")\n@@ -325,13 +333,15 @@ impl Step for StartupObjects {\n     /// They don't require any library support as they're just plain old object\n     /// files, so we just use the nightly snapshot compiler to always build them (as\n     /// no other compilers are guaranteed to be available).\n-    fn run(self, builder: &Builder<'_>) {\n+    fn run(self, builder: &Builder<'_>) -> Vec<PathBuf> {\n         let for_compiler = self.compiler;\n         let target = self.target;\n         if !target.contains(\"windows-gnu\") {\n-            return\n+            return vec![]\n         }\n \n+        let mut target_deps = vec![];\n+\n         let src_dir = &builder.src.join(\"src/rtstartup\");\n         let dst_dir = &builder.native_dir(target).join(\"rtstartup\");\n         let sysroot_dir = &builder.sysroot_libdir(for_compiler, target);\n@@ -350,16 +360,22 @@ impl Step for StartupObjects {\n                             .arg(src_file));\n             }\n \n-            builder.copy(dst_file, &sysroot_dir.join(file.to_string() + \".o\"));\n+            let target = sysroot_dir.join(file.to_string() + \".o\");\n+            builder.copy(dst_file, &target);\n+            target_deps.push(target);\n         }\n \n         for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n             let src = compiler_file(builder,\n                                     builder.cc(target),\n                                     target,\n                                     obj);\n-            builder.copy(&src, &sysroot_dir.join(obj));\n+            let target = sysroot_dir.join(obj);\n+            builder.copy(&src, &target);\n+            target_deps.push(target);\n         }\n+\n+        target_deps\n     }\n }\n \n@@ -437,6 +453,7 @@ impl Step for Rustc {\n                   cargo,\n                   vec![],\n                   &librustc_stamp(builder, compiler, target),\n+                  vec![],\n                   false);\n \n         builder.ensure(RustcLink {\n@@ -585,7 +602,7 @@ impl Step for CodegenBackend {\n \n         let tmp_stamp = out_dir.join(\".tmp.stamp\");\n \n-        let files = run_cargo(builder, cargo, vec![], &tmp_stamp, false);\n+        let files = run_cargo(builder, cargo, vec![], &tmp_stamp, vec![], false);\n         if builder.config.dry_run {\n             return;\n         }\n@@ -941,6 +958,7 @@ pub fn run_cargo(builder: &Builder<'_>,\n                  cargo: Cargo,\n                  tail_args: Vec<String>,\n                  stamp: &Path,\n+                 additional_target_deps: Vec<PathBuf>,\n                  is_check: bool)\n     -> Vec<PathBuf>\n {\n@@ -1057,6 +1075,7 @@ pub fn run_cargo(builder: &Builder<'_>,\n         deps.push((path_to_add.into(), false));\n     }\n \n+    deps.extend(additional_target_deps.into_iter().map(|d| (d, false)));\n     deps.sort();\n     let mut new_contents = Vec::new();\n     for (dep, proc_macro) in deps.iter() {"}, {"sha": "93143570b0fe173fa474d3a8f1a3e5e2c3ab6f55", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 96, "deletions": 33, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -637,6 +637,28 @@ impl Step for DebuggerScripts {\n     }\n }\n \n+fn skip_host_target_lib(builder: &Builder<'_>, compiler: Compiler) -> bool {\n+    // The only true set of target libraries came from the build triple, so\n+    // let's reduce redundant work by only producing archives from that host.\n+    if compiler.host != builder.config.build {\n+        builder.info(\"\\tskipping, not a build host\");\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Copy stamped files into an image's `target/lib` directory.\n+fn copy_target_libs(builder: &Builder<'_>, target: &str, image: &Path, stamp: &Path) {\n+    let dst = image.join(\"lib/rustlib\").join(target).join(\"lib\");\n+    t!(fs::create_dir_all(&dst));\n+    for (path, host) in builder.read_stamp_file(stamp) {\n+        if !host || builder.config.build == target {\n+            builder.copy(&path, &dst.join(path.file_name().unwrap()));\n+        }\n+    }\n+}\n+\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Std {\n     pub compiler: Compiler,\n@@ -667,44 +689,19 @@ impl Step for Std {\n         let target = self.target;\n \n         let name = pkgname(builder, \"rust-std\");\n-\n-        // The only true set of target libraries came from the build triple, so\n-        // let's reduce redundant work by only producing archives from that host.\n-        if compiler.host != builder.config.build {\n-            builder.info(\"\\tskipping, not a build host\");\n-            return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target));\n+        let archive = distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target));\n+        if skip_host_target_lib(builder, compiler) {\n+            return archive;\n         }\n \n-        // We want to package up as many target libraries as possible\n-        // for the `rust-std` package, so if this is a host target we\n-        // depend on librustc and otherwise we just depend on libtest.\n-        if builder.hosts.iter().any(|t| t == target) {\n-            builder.ensure(compile::Rustc { compiler, target });\n-        } else {\n-            builder.ensure(compile::Std { compiler, target });\n-        }\n+        builder.ensure(compile::Std { compiler, target });\n \n         let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target));\n         let _ = fs::remove_dir_all(&image);\n \n-        let dst = image.join(\"lib/rustlib\").join(target);\n-        t!(fs::create_dir_all(&dst));\n-        let mut src = builder.sysroot_libdir(compiler, target).to_path_buf();\n-        src.pop(); // Remove the trailing /lib folder from the sysroot_libdir\n-        builder.cp_filtered(&src, &dst, &|path| {\n-            if let Some(name) = path.file_name().and_then(|s| s.to_str()) {\n-                if name == builder.config.rust_codegen_backends_dir.as_str() {\n-                    return false\n-                }\n-                if name == \"bin\" {\n-                    return false\n-                }\n-                if name.contains(\"LLVM\") {\n-                    return false\n-                }\n-            }\n-            true\n-        });\n+        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n+        let stamp = compile::libstd_stamp(builder, compiler_to_use, target);\n+        copy_target_libs(builder, &target, &image, &stamp);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n@@ -723,7 +720,73 @@ impl Step for Std {\n         let _time = timeit(builder);\n         builder.run(&mut cmd);\n         builder.remove_dir(&image);\n-        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target))\n+        archive\n+    }\n+}\n+\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct RustcDev {\n+    pub compiler: Compiler,\n+    pub target: Interned<String>,\n+}\n+\n+impl Step for RustcDev {\n+    type Output = PathBuf;\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"rustc-dev\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(RustcDev {\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n+            target: run.target,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+        let compiler = self.compiler;\n+        let target = self.target;\n+\n+        let name = pkgname(builder, \"rustc-dev\");\n+        let archive = distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target));\n+        if skip_host_target_lib(builder, compiler) {\n+            return archive;\n+        }\n+\n+        builder.ensure(compile::Rustc { compiler, target });\n+\n+        let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target));\n+        let _ = fs::remove_dir_all(&image);\n+\n+        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n+        let stamp = compile::librustc_stamp(builder, compiler_to_use, target);\n+        copy_target_libs(builder, &target, &image, &stamp);\n+\n+        let mut cmd = rust_installer(builder);\n+        cmd.arg(\"generate\")\n+           .arg(\"--product-name=Rust\")\n+           .arg(\"--rel-manifest-dir=rustlib\")\n+           .arg(\"--success-message=Rust-is-ready-to-develop.\")\n+           .arg(\"--image-dir\").arg(&image)\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n+           .arg(format!(\"--package-name={}-{}\", name, target))\n+           .arg(format!(\"--component-name=rustc-dev-{}\", target))\n+           .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+\n+        builder.info(&format!(\"Dist rustc-dev stage{} ({} -> {})\",\n+            compiler.stage, &compiler.host, target));\n+        let _time = timeit(builder);\n+        builder.run(&mut cmd);\n+        builder.remove_dir(&image);\n+        archive\n     }\n }\n "}, {"sha": "cbdb174c02d97cbcccf09ac9a5c50f1b42b69a47", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1137,6 +1137,7 @@ impl Build {\n     pub fn copy(&self, src: &Path, dst: &Path) {\n         if self.config.dry_run { return; }\n         self.verbose_than(1, &format!(\"Copy {:?} to {:?}\", src, dst));\n+        if src == dst { return; }\n         let _ = fs::remove_file(&dst);\n         let metadata = t!(src.symlink_metadata());\n         if metadata.file_type().is_symlink() {"}, {"sha": "812339900fe427452249700dd0cb65cd908d20af", "filename": "src/ci/azure-pipelines/steps/install-windows-build-deps.yml", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -84,6 +84,17 @@ steps:\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'), ne(variables['MINGW_URL'],''))\n   displayName: Download custom MinGW\n \n+# FIXME(#65767): workaround msys bug, step 1\n+- bash: |\n+    set -e\n+    arch=i686\n+    if [ \"$MSYS_BITS\" = \"64\" ]; then\n+      arch=x86_64\n+    fi\n+    curl -O https://ci-mirrors.rust-lang.org/rustc/msys2-repo/mingw/$arch/mingw-w64-$arch-ca-certificates-20180409-1-any.pkg.tar.xz\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n+  displayName: Download working ca-certificates for msys\n+\n # Otherwise install MinGW through `pacman`\n - bash: |\n     set -e\n@@ -96,6 +107,18 @@ steps:\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'), eq(variables['MINGW_URL'],''))\n   displayName: Download standard MinGW\n \n+# FIXME(#65767): workaround msys bug, step 2\n+- bash: |\n+    set -e\n+    arch=i686\n+    if [ \"$MSYS_BITS\" = \"64\" ]; then\n+      arch=x86_64\n+    fi\n+    pacman -U --noconfirm --noprogressbar mingw-w64-$arch-ca-certificates-20180409-1-any.pkg.tar.xz\n+    rm mingw-w64-$arch-ca-certificates-20180409-1-any.pkg.tar.xz\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n+  displayName: Install working ca-certificates for msys\n+\n # Make sure we use the native python interpreter instead of some msys equivalent\n # one way or another. The msys interpreters seem to have weird path conversions\n # baked in which break LLVM's build system one way or another, so let's use the"}, {"sha": "b603c7b231e68471aacb58fe47a4349f52e80226", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -14,6 +14,7 @@\n - [Targets](targets/index.md)\n     - [Built-in Targets](targets/built-in.md)\n     - [Custom Targets](targets/custom.md)\n+    - [Known Issues](targets/known-issues.md)\n - [Profile-guided Optimization](profile-guided-optimization.md)\n - [Linker-plugin based LTO](linker-plugin-lto.md)\n - [Contributing to `rustc`](contributing.md)"}, {"sha": "f5d5f2089d7e76901c0f5a84912e8d02aaa26c84", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -61,6 +61,8 @@ enabling or disabling a feature.\n To see the valid options and an example of use, run `rustc --print\n target-features`.\n \n+Using this flag is unsafe and might result in [undefined runtime behavior](../targets/known-issues.md).\n+\n ## passes\n \n This flag can be used to add extra LLVM passes to the compilation."}, {"sha": "bdb3c5196585e09df6fc73d44116e4509603bea1", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -145,7 +145,7 @@ of print values are:\n   target CPU may be selected with the `-C target-cpu=val` flag.\n - `target-features` \u2014 List of available target features for the current\n   target. Target features may be enabled with the `-C target-feature=val`\n-  flag.\n+  flag. This flag is unsafe. See [known issues](targets/known-issues.md) for more details.\n - `relocation-models` \u2014 List of relocation models. Relocation models may be\n   selected with the `-C relocation-model=val` flag.\n - `code-models` \u2014 List of code models. Code models may be selected with the"}, {"sha": "5859df83f645bc8ea5e3cc4fd4e6057a29fad440", "filename": "src/doc/rustc/src/targets/index.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Findex.md?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -11,3 +11,9 @@ To compile to a particular target, use the `--target` flag:\n ```bash\n $ rustc src/main.rs --target=wasm32-unknown-unknown\n ```\n+## Target Features\n+`x86`,  and `ARMv8` are two popular CPU architectures. Their instruction sets form a common baseline across most CPUs. However, some CPUs extend these with custom instruction sets, e.g. vector (`AVX`), bitwise manipulation (`BMI`) or cryptographic (`AES`).\n+\n+Developers, who know on which CPUs their compiled code is going to run can choose to add (or remove) CPU specific instruction sets via the `-C target-feature=val` flag.\n+\n+Please note, that this flag is generally considered as unsafe. More details can be found in [this section](known-issues.md)."}, {"sha": "89fd8ea6d32e96f1b3869eb9e5d091a16d0c3821", "filename": "src/doc/rustc/src/targets/known-issues.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fknown-issues.md", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fknown-issues.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fknown-issues.md?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,13 @@\n+# Known Issues\n+This section informs you about known \"gotchas\". Keep in mind, that this section is (and always will be) incomplete. For suggestions and amendments, feel free to [contribute](../contributing.md) to this guide.\n+\n+## Target Features\n+Most target-feature problems arise, when mixing code that have the target-feature _enabled_ with code that have it _disabled_. If you want to avoid undefined behavior, it is recommended to build _all code_ (including the standard library and imported crates) with a common set of target-features.\n+\n+By default, compiling your code with the `-C target-feature` flag will not recompile the entire standard library and/or imported crates with matching target features. Therefore, target features are generally considered as unsafe. Using `#[target_feature]` on individual functions makes the function unsafe.\n+\n+Examples:\n+\n+| Target-Feature | Issue | Seen on | Description | Details |\n+| -------------- | ----- | ------- | ----------- | ------- |\n+| `+soft-float` <br> and <br> `-sse` | Segfaults and ABI mismatches | `x86` and `x86-64` | The `x86` and `x86_64` architecture uses SSE registers (aka `xmm`) for floating point operations. Using software emulated floats (\"soft-floats\") disables usage of `xmm` registers, but parts of Rust's core libraries (e.g. `std::f32` or `std::f64`) are compiled without soft-floats and expect parameters to be passed in `xmm` registers. This leads to ABI mismatches. <br><br>  Attempting to compile with disabled SSE causes the same error, too. | [#63466](https://github.com/rust-lang/rust/issues/63466) |"}, {"sha": "d2bdda83fa998ae4e8e195d955627c7c88887fba", "filename": "src/liballoc/borrow.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fliballoc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fliballoc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fborrow.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -207,6 +207,47 @@ impl<B: ?Sized + ToOwned> Clone for Cow<'_, B> {\n }\n \n impl<B: ?Sized + ToOwned> Cow<'_, B> {\n+    /// Returns true if the data is borrowed, i.e. if `to_mut` would require additional work.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(cow_is_borrowed)]\n+    /// use std::borrow::Cow;\n+    ///\n+    /// let cow = Cow::Borrowed(\"moo\");\n+    /// assert!(cow.is_borrowed());\n+    ///\n+    /// let bull: Cow<'_, str> = Cow::Owned(\"...moo?\".to_string());\n+    /// assert!(!bull.is_borrowed());\n+    /// ```\n+    #[unstable(feature = \"cow_is_borrowed\", issue = \"65143\")]\n+    pub fn is_borrowed(&self) -> bool {\n+        match *self {\n+            Borrowed(_) => true,\n+            Owned(_) => false,\n+        }\n+    }\n+\n+    /// Returns true if the data is owned, i.e. if `to_mut` would be a no-op.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(cow_is_borrowed)]\n+    /// use std::borrow::Cow;\n+    ///\n+    /// let cow: Cow<'_, str> = Cow::Owned(\"moo\".to_string());\n+    /// assert!(cow.is_owned());\n+    ///\n+    /// let bull = Cow::Borrowed(\"...moo?\");\n+    /// assert!(!bull.is_owned());\n+    /// ```\n+    #[unstable(feature = \"cow_is_borrowed\", issue = \"65143\")]\n+    pub fn is_owned(&self) -> bool {\n+        !self.is_borrowed()\n+    }\n+\n     /// Acquires a mutable reference to the owned form of the data.\n     ///\n     /// Clones the data if it is not already owned."}, {"sha": "8f3dfabd8886d6286ae8949ddfd8bf1c1e00ffe9", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1817,7 +1817,7 @@ impl<T> VecDeque<T> {\n             }\n         }\n \n-        return elem;\n+        elem\n     }\n \n     /// Splits the `VecDeque` into two at the given index."}, {"sha": "94379afc2bd454e1071243647cbd7b77c790f279", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -85,6 +85,7 @@\n #![feature(const_generic_impls_guard)]\n #![feature(const_generics)]\n #![feature(const_in_array_repeat_expressions)]\n+#![feature(cow_is_borrowed)]\n #![feature(dispatch_from_dyn)]\n #![feature(core_intrinsics)]\n #![feature(container_error_extra)]"}, {"sha": "83816d8b954c4dbbd7e3e0ccf3c76185319a5fc8", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -456,7 +456,7 @@ impl str {\n                 }\n             }\n         }\n-        return s;\n+        s\n     }\n \n     /// Converts a [`Box<str>`] into a [`String`] without copying or allocating."}, {"sha": "80d6c6e0d43907bbdf936a9e8f1a34a7b5efaa3f", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1638,7 +1638,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n             }\n         }\n \n-        return Weak { ptr: self.ptr };\n+        Weak { ptr: self.ptr }\n     }\n }\n "}, {"sha": "0e83a282b18f717d056b70a3efbccc24b2e56da4", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -2025,7 +2025,7 @@ impl<T: ?Sized> Pointer for *const T {\n         if f.alternate() {\n             f.flags |= 1 << (FlagV1::SignAwareZeroPad as u32);\n \n-            if let None = f.width {\n+            if f.width.is_none() {\n                 f.width = Some(((mem::size_of::<usize>() * 8) / 4) + 2);\n             }\n         }"}, {"sha": "35558e3abcdddcba3e920b4f49b0b1d86074d265", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -238,6 +238,33 @@ macro_rules! debug_assert_ne {\n     ($($arg:tt)*) => (if $crate::cfg!(debug_assertions) { $crate::assert_ne!($($arg)*); })\n }\n \n+/// Returns whether the given expression matches any of the given patterns.\n+///\n+/// Like in a `match` expression, the pattern can be optionally followed by `if`\n+/// and a guard expression that has access to names bound by the pattern.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(matches_macro)]\n+///\n+/// let foo = 'f';\n+/// assert!(matches!(foo, 'A'..='Z' | 'a'..='z'));\n+///\n+/// let bar = Some(4);\n+/// assert!(matches!(bar, Some(x) if x > 2));\n+/// ```\n+#[macro_export]\n+#[unstable(feature = \"matches_macro\", issue = \"65721\")]\n+macro_rules! matches {\n+    ($expression:expr, $( $pattern:pat )|+ $( if $guard: expr )?) => {\n+        match $expression {\n+            $( $pattern )|+ $( if $guard )? => true,\n+            _ => false\n+        }\n+    }\n+}\n+\n /// Unwraps a result or propagates its error.\n ///\n /// The `?` operator was added to replace `try!` and should be used instead."}, {"sha": "ed89852dc48da63010be52885842dbac543a2a82", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -143,13 +143,12 @@ pub fn fast_path<T: RawFloat>(integral: &[u8], fractional: &[u8], e: i64) -> Opt\n /// > not a bound for the true error, but bounds the difference between the approximation z and\n /// > the best possible approximation that uses p bits of significand.)\n pub fn bellerophon<T: RawFloat>(f: &Big, e: i16) -> T {\n-    let slop;\n-    if f <= &Big::from_u64(T::MAX_SIG) {\n+    let slop = if f <= &Big::from_u64(T::MAX_SIG) {\n         // The cases abs(e) < log5(2^N) are in fast_path()\n-        slop = if e >= 0 { 0 } else { 3 };\n+        if e >= 0 { 0 } else { 3 }\n     } else {\n-        slop = if e >= 0 { 1 } else { 4 };\n-    }\n+        if e >= 0 { 1 } else { 4 }\n+    };\n     let z = rawfp::big_to_fp(f).mul(&power_of_ten(e)).normalize();\n     let exp_p_n = 1 << (P - T::SIG_BITS as u32);\n     let lowbits: i64 = (z.f % exp_p_n) as i64;"}, {"sha": "89f2d7ab29c9374e7751ec4821d44562160a09d9", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -837,9 +837,8 @@ impl<T> Option<T> {\n     #[inline]\n     #[stable(feature = \"option_entry\", since = \"1.20.0\")]\n     pub fn get_or_insert_with<F: FnOnce() -> T>(&mut self, f: F) -> &mut T {\n-        match *self {\n-            None => *self = Some(f()),\n-            _ => (),\n+        if let None = *self {\n+            *self = Some(f());\n         }\n \n         match *self {"}, {"sha": "a35847c85fc206476f78174e406781cca340c90b", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -156,21 +156,21 @@ unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n     if actions as i32 & uw::_UA_SEARCH_PHASE as i32 != 0 {\n         match eh_action {\n             EHAction::None |\n-            EHAction::Cleanup(_) => return uw::_URC_CONTINUE_UNWIND,\n-            EHAction::Catch(_) => return uw::_URC_HANDLER_FOUND,\n-            EHAction::Terminate => return uw::_URC_FATAL_PHASE1_ERROR,\n+            EHAction::Cleanup(_) => uw::_URC_CONTINUE_UNWIND,\n+            EHAction::Catch(_) => uw::_URC_HANDLER_FOUND,\n+            EHAction::Terminate => uw::_URC_FATAL_PHASE1_ERROR,\n         }\n     } else {\n         match eh_action {\n-            EHAction::None => return uw::_URC_CONTINUE_UNWIND,\n+            EHAction::None => uw::_URC_CONTINUE_UNWIND,\n             EHAction::Cleanup(lpad) |\n             EHAction::Catch(lpad) => {\n                 uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0, exception_object as uintptr_t);\n                 uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n                 uw::_Unwind_SetIP(context, lpad);\n-                return uw::_URC_INSTALL_CONTEXT;\n+                uw::_URC_INSTALL_CONTEXT\n             }\n-            EHAction::Terminate => return uw::_URC_FATAL_PHASE2_ERROR,\n+            EHAction::Terminate => uw::_URC_FATAL_PHASE2_ERROR,\n         }\n     }\n }"}, {"sha": "16b699a44379979f7eda4031937e072e7b8d4d8c", "filename": "src/libpanic_unwind/seh64_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh64_gnu.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -46,7 +46,7 @@ pub fn payload() -> *mut u8 {\n \n pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n     let panic_ctx = Box::from_raw(ptr as *mut PanicData);\n-    return panic_ctx.data;\n+    panic_ctx.data\n }\n \n // SEH doesn't support resuming unwinds after calling a landing pad like"}, {"sha": "dea8d70aaf4e6a4a0c6ebd855bacf8e5bf294991", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -59,7 +59,7 @@ use crate::ich::{Fingerprint, StableHashingContext};\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use std::fmt;\n use std::hash::Hash;\n-use syntax_pos::symbol::InternedString;\n+use syntax_pos::symbol::Symbol;\n use crate::traits;\n use crate::traits::query::{\n     CanonicalProjectionGoal, CanonicalTyGoal, CanonicalTypeOpAscribeUserTypeGoal,\n@@ -426,7 +426,7 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n \n     [anon] TraitSelect,\n \n-    [] CompileCodegenUnit(InternedString),\n+    [] CompileCodegenUnit(Symbol),\n \n     [eval_always] Analysis(CrateNum),\n ]);"}, {"sha": "122ae4a6cf66f6a65a20ad8ae900eb0ed800c82b", "filename": "src/librustc/error_codes.rs", "status": "modified", "additions": 80, "deletions": 3, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -2045,8 +2045,8 @@ so that a generator can then be constructed:\n async fn bar<T>() -> () {}\n \n async fn foo() {\n-  bar::<String>().await;\n-  //   ^^^^^^^^ specify type explicitly\n+    bar::<String>().await;\n+    //   ^^^^^^^^ specify type explicitly\n }\n ```\n \"##,\n@@ -2126,6 +2126,84 @@ static X: u32 = 42;\n ```\n \"##,\n \n+E0728: r##\"\n+[`await`] has been used outside [`async`] function or block.\n+\n+Erroneous code examples:\n+\n+```edition2018,compile_fail,E0728\n+# use std::pin::Pin;\n+# use std::future::Future;\n+# use std::task::{Context, Poll};\n+#\n+# struct WakeOnceThenComplete(bool);\n+#\n+# fn wake_and_yield_once() -> WakeOnceThenComplete {\n+#     WakeOnceThenComplete(false)\n+# }\n+#\n+# impl Future for WakeOnceThenComplete {\n+#     type Output = ();\n+#     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {\n+#         if self.0 {\n+#             Poll::Ready(())\n+#         } else {\n+#             cx.waker().wake_by_ref();\n+#             self.0 = true;\n+#             Poll::Pending\n+#         }\n+#     }\n+# }\n+#\n+fn foo() {\n+    wake_and_yield_once().await // `await` is used outside `async` context\n+}\n+```\n+\n+[`await`] is used to suspend the current computation until the given\n+future is ready to produce a value. So it is legal only within\n+an [`async`] context, like an `async fn` or an `async` block.\n+\n+```edition2018\n+# use std::pin::Pin;\n+# use std::future::Future;\n+# use std::task::{Context, Poll};\n+#\n+# struct WakeOnceThenComplete(bool);\n+#\n+# fn wake_and_yield_once() -> WakeOnceThenComplete {\n+#     WakeOnceThenComplete(false)\n+# }\n+#\n+# impl Future for WakeOnceThenComplete {\n+#     type Output = ();\n+#     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {\n+#         if self.0 {\n+#             Poll::Ready(())\n+#         } else {\n+#             cx.waker().wake_by_ref();\n+#             self.0 = true;\n+#             Poll::Pending\n+#         }\n+#     }\n+# }\n+#\n+async fn foo() {\n+    wake_and_yield_once().await // `await` is used within `async` function\n+}\n+\n+fn bar(x: u8) -> impl Future<Output = u8> {\n+    async move {\n+        wake_and_yield_once().await; // `await` is used within `async` block\n+        x\n+    }\n+}\n+```\n+\n+[`async`]: https://doc.rust-lang.org/std/keyword.async.html\n+[`await`]: https://doc.rust-lang.org/std/keyword.await.html\n+\"##,\n+\n E0734: r##\"\n A stability attribute has been used outside of the standard library.\n \n@@ -2218,6 +2296,5 @@ See [RFC 2091] for details on this and other limitations.\n //  E0702, // replaced with a generic attribute input check\n     E0726, // non-explicit (not `'_`) elided lifetime in unsupported position\n     E0727, // `async` generators are not yet supported\n-    E0728, // `await` must be in an `async` function or block\n     E0739, // invalid track_caller application/syntax\n }"}, {"sha": "002e6874466bbd12321c6256411c24d1499879c2", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -83,8 +83,6 @@ pub struct LoweringContext<'a> {\n     /// Used to assign IDs to HIR nodes that do not directly correspond to AST nodes.\n     sess: &'a Session,\n \n-    cstore: &'a dyn CrateStore,\n-\n     resolver: &'a mut dyn Resolver,\n \n     /// HACK(Centril): there is a cyclic dependency between the parser and lowering\n@@ -160,6 +158,8 @@ pub struct LoweringContext<'a> {\n }\n \n pub trait Resolver {\n+    fn cstore(&self) -> &dyn CrateStore;\n+\n     /// Obtains resolution for a `NodeId` with a single resolution.\n     fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes>;\n \n@@ -240,7 +240,6 @@ impl<'a> ImplTraitContext<'a> {\n \n pub fn lower_crate(\n     sess: &Session,\n-    cstore: &dyn CrateStore,\n     dep_graph: &DepGraph,\n     krate: &Crate,\n     resolver: &mut dyn Resolver,\n@@ -256,7 +255,6 @@ pub fn lower_crate(\n     LoweringContext {\n         crate_root: sess.parse_sess.injected_crate_name.try_get().copied(),\n         sess,\n-        cstore,\n         resolver,\n         nt_to_tokenstream,\n         items: BTreeMap::new(),\n@@ -792,15 +790,15 @@ impl<'a> LoweringContext<'a> {\n         // really show up for end-user.\n         let (str_name, kind) = match hir_name {\n             ParamName::Plain(ident) => (\n-                ident.as_interned_str(),\n+                ident.name,\n                 hir::LifetimeParamKind::InBand,\n             ),\n             ParamName::Fresh(_) => (\n-                kw::UnderscoreLifetime.as_interned_str(),\n+                kw::UnderscoreLifetime,\n                 hir::LifetimeParamKind::Elided,\n             ),\n             ParamName::Error => (\n-                kw::UnderscoreLifetime.as_interned_str(),\n+                kw::UnderscoreLifetime,\n                 hir::LifetimeParamKind::Error,\n             ),\n         };\n@@ -980,7 +978,7 @@ impl<'a> LoweringContext<'a> {\n         if id.is_local() {\n             self.resolver.definitions().def_key(id.index)\n         } else {\n-            self.cstore.def_key(id)\n+            self.resolver.cstore().def_key(id)\n         }\n     }\n \n@@ -1590,7 +1588,7 @@ impl<'a> LoweringContext<'a> {\n                     self.context.resolver.definitions().create_def_with_parent(\n                         self.parent,\n                         def_node_id,\n-                        DefPathData::LifetimeNs(name.ident().as_interned_str()),\n+                        DefPathData::LifetimeNs(name.ident().name),\n                         ExpnId::root(),\n                         lifetime.span);\n \n@@ -1727,8 +1725,8 @@ impl<'a> LoweringContext<'a> {\n                             return n;\n                         }\n                         assert!(!def_id.is_local());\n-                        let item_generics =\n-                            self.cstore.item_generics_cloned_untracked(def_id, self.sess);\n+                        let item_generics = self.resolver.cstore()\n+                            .item_generics_cloned_untracked(def_id, self.sess);\n                         let n = item_generics.own_counts().lifetimes;\n                         self.type_def_lifetime_params.insert(def_id, n);\n                         n"}, {"sha": "307dbe7dab080a4aa6348b0dcb75d9b059205d53", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -186,13 +186,13 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             });\n \n         let mut upstream_crates: Vec<_> = cstore.crates_untracked().iter().map(|&cnum| {\n-            let name = cstore.crate_name_untracked(cnum).as_interned_str();\n+            let name = cstore.crate_name_untracked(cnum);\n             let disambiguator = cstore.crate_disambiguator_untracked(cnum).to_fingerprint();\n             let hash = cstore.crate_hash_untracked(cnum);\n             (name, disambiguator, hash)\n         }).collect();\n \n-        upstream_crates.sort_unstable_by_key(|&(name, dis, _)| (name, dis));\n+        upstream_crates.sort_unstable_by_key(|&(name, dis, _)| (name.as_str(), dis));\n \n         // We hash the final, remapped names of all local source files so we\n         // don't have to include the path prefix remapping commandline args."}, {"sha": "7c8fdcc8b12e9795b9ab9bd642a073d88ec841c4", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -57,7 +57,7 @@ impl<'a> DefCollector<'a> {\n \n         // For async functions, we need to create their inner defs inside of a\n         // closure to match their desugared representation.\n-        let fn_def_data = DefPathData::ValueNs(name.as_interned_str());\n+        let fn_def_data = DefPathData::ValueNs(name);\n         let fn_def = self.create_def(id, fn_def_data, span);\n         return self.with_parent(fn_def, |this| {\n             this.create_def(return_impl_trait_id, DefPathData::ImplTrait, span);\n@@ -83,8 +83,7 @@ impl<'a> DefCollector<'a> {\n                 .unwrap_or_else(|| {\n                     let node_id = NodeId::placeholder_from_expn_id(self.expansion);\n                     sym::integer(self.definitions.placeholder_field_indices[&node_id])\n-                })\n-                .as_interned_str();\n+                });\n             let def = self.create_def(field.id, DefPathData::ValueNs(name), field.span);\n             self.with_parent(def, |this| visit::walk_struct_field(this, field));\n         }\n@@ -109,7 +108,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ItemKind::Mod(..) | ItemKind::Trait(..) | ItemKind::TraitAlias(..) |\n             ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) |\n             ItemKind::OpaqueTy(..) | ItemKind::ExternCrate(..) | ItemKind::ForeignMod(..) |\n-            ItemKind::TyAlias(..) => DefPathData::TypeNs(i.ident.as_interned_str()),\n+            ItemKind::TyAlias(..) => DefPathData::TypeNs(i.ident.name),\n             ItemKind::Fn(\n                 ref decl,\n                 ref header,\n@@ -127,8 +126,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                 )\n             }\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n-                DefPathData::ValueNs(i.ident.as_interned_str()),\n-            ItemKind::MacroDef(..) => DefPathData::MacroNs(i.ident.as_interned_str()),\n+                DefPathData::ValueNs(i.ident.name),\n+            ItemKind::MacroDef(..) => DefPathData::MacroNs(i.ident.name),\n             ItemKind::Mac(..) => return self.visit_macro_invoc(i.id),\n             ItemKind::GlobalAsm(..) => DefPathData::Misc,\n             ItemKind::Use(..) => {\n@@ -162,7 +161,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         }\n \n         let def = self.create_def(foreign_item.id,\n-                                  DefPathData::ValueNs(foreign_item.ident.as_interned_str()),\n+                                  DefPathData::ValueNs(foreign_item.ident.name),\n                                   foreign_item.span);\n \n         self.with_parent(def, |this| {\n@@ -175,7 +174,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             return self.visit_macro_invoc(v.id);\n         }\n         let def = self.create_def(v.id,\n-                                  DefPathData::TypeNs(v.ident.as_interned_str()),\n+                                  DefPathData::TypeNs(v.ident.name),\n                                   v.span);\n         self.with_parent(def, |this| {\n             if let Some(ctor_hir_id) = v.data.ctor_id() {\n@@ -202,7 +201,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             self.visit_macro_invoc(param.id);\n             return;\n         }\n-        let name = param.ident.as_interned_str();\n+        let name = param.ident.name;\n         let def_path_data = match param.kind {\n             GenericParamKind::Lifetime { .. } => DefPathData::LifetimeNs(name),\n             GenericParamKind::Type { .. } => DefPathData::TypeNs(name),\n@@ -216,9 +215,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n         let def_data = match ti.kind {\n             TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n-                DefPathData::ValueNs(ti.ident.as_interned_str()),\n+                DefPathData::ValueNs(ti.ident.name),\n             TraitItemKind::Type(..) => {\n-                DefPathData::TypeNs(ti.ident.as_interned_str())\n+                DefPathData::TypeNs(ti.ident.name)\n             },\n             TraitItemKind::Macro(..) => return self.visit_macro_invoc(ti.id),\n         };\n@@ -243,12 +242,10 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     body,\n                 )\n             }\n-            ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n-                DefPathData::ValueNs(ii.ident.as_interned_str()),\n+            ImplItemKind::Method(..) |\n+            ImplItemKind::Const(..) => DefPathData::ValueNs(ii.ident.name),\n             ImplItemKind::TyAlias(..) |\n-            ImplItemKind::OpaqueTy(..) => {\n-                DefPathData::TypeNs(ii.ident.as_interned_str())\n-            },\n+            ImplItemKind::OpaqueTy(..) => DefPathData::TypeNs(ii.ident.name),\n             ImplItemKind::Macro(..) => return self.visit_macro_invoc(ii.id),\n         };\n "}, {"sha": "5993a97c40d6a8b9f924a779ccefbf0329300771", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -18,7 +18,7 @@ use std::fmt::Write;\n use std::hash::Hash;\n use syntax::ast;\n use syntax_expand::hygiene::ExpnId;\n-use syntax::symbol::{Symbol, sym, InternedString};\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::{Span, DUMMY_SP};\n \n /// The `DefPathTable` maps `DefIndex`es to `DefKey`s and vice versa.\n@@ -136,7 +136,9 @@ impl DefKey {\n \n         ::std::mem::discriminant(data).hash(&mut hasher);\n         if let Some(name) = data.get_opt_name() {\n-            name.hash(&mut hasher);\n+            // Get a stable hash by considering the symbol chars rather than\n+            // the symbol index.\n+            name.as_str().hash(&mut hasher);\n         }\n \n         disambiguator.hash(&mut hasher);\n@@ -218,7 +220,7 @@ impl DefPath {\n         for component in &self.data {\n             write!(s,\n                    \"::{}[{}]\",\n-                   component.data.as_interned_str(),\n+                   component.data.as_symbol(),\n                    component.disambiguator)\n                 .unwrap();\n         }\n@@ -238,11 +240,11 @@ impl DefPath {\n \n         for component in &self.data {\n             if component.disambiguator == 0 {\n-                write!(s, \"::{}\", component.data.as_interned_str()).unwrap();\n+                write!(s, \"::{}\", component.data.as_symbol()).unwrap();\n             } else {\n                 write!(s,\n                        \"{}[{}]\",\n-                       component.data.as_interned_str(),\n+                       component.data.as_symbol(),\n                        component.disambiguator)\n                        .unwrap();\n             }\n@@ -262,11 +264,11 @@ impl DefPath {\n             opt_delimiter.map(|d| s.push(d));\n             opt_delimiter = Some('-');\n             if component.disambiguator == 0 {\n-                write!(s, \"{}\", component.data.as_interned_str()).unwrap();\n+                write!(s, \"{}\", component.data.as_symbol()).unwrap();\n             } else {\n                 write!(s,\n                        \"{}[{}]\",\n-                       component.data.as_interned_str(),\n+                       component.data.as_symbol(),\n                        component.disambiguator)\n                        .unwrap();\n             }\n@@ -290,13 +292,13 @@ pub enum DefPathData {\n     /// An impl.\n     Impl,\n     /// Something in the type namespace.\n-    TypeNs(InternedString),\n+    TypeNs(Symbol),\n     /// Something in the value namespace.\n-    ValueNs(InternedString),\n+    ValueNs(Symbol),\n     /// Something in the macro namespace.\n-    MacroNs(InternedString),\n+    MacroNs(Symbol),\n     /// Something in the lifetime namespace.\n-    LifetimeNs(InternedString),\n+    LifetimeNs(Symbol),\n     /// A closure expression.\n     ClosureExpr,\n \n@@ -311,7 +313,7 @@ pub enum DefPathData {\n     /// Identifies a piece of crate metadata that is global to a whole crate\n     /// (as opposed to just one item). `GlobalMetaData` components are only\n     /// supposed to show up right below the crate root.\n-    GlobalMetaData(InternedString),\n+    GlobalMetaData(Symbol),\n }\n \n #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug,\n@@ -545,7 +547,7 @@ impl Definitions {\n }\n \n impl DefPathData {\n-    pub fn get_opt_name(&self) -> Option<InternedString> {\n+    pub fn get_opt_name(&self) -> Option<Symbol> {\n         use self::DefPathData::*;\n         match *self {\n             TypeNs(name) |\n@@ -564,15 +566,15 @@ impl DefPathData {\n         }\n     }\n \n-    pub fn as_interned_str(&self) -> InternedString {\n+    pub fn as_symbol(&self) -> Symbol {\n         use self::DefPathData::*;\n-        let s = match *self {\n+        match *self {\n             TypeNs(name) |\n             ValueNs(name) |\n             MacroNs(name) |\n             LifetimeNs(name) |\n             GlobalMetaData(name) => {\n-                return name\n+                name\n             }\n             // Note that this does not show up in user print-outs.\n             CrateRoot => sym::double_braced_crate,\n@@ -582,13 +584,11 @@ impl DefPathData {\n             Ctor => sym::double_braced_constructor,\n             AnonConst => sym::double_braced_constant,\n             ImplTrait => sym::double_braced_opaque,\n-        };\n-\n-        s.as_interned_str()\n+        }\n     }\n \n     pub fn to_string(&self) -> String {\n-        self.as_interned_str().to_string()\n+        self.as_symbol().to_string()\n     }\n }\n \n@@ -610,7 +610,7 @@ macro_rules! define_global_metadata_kind {\n                     definitions.create_def_with_parent(\n                         CRATE_DEF_INDEX,\n                         ast::DUMMY_NODE_ID,\n-                        DefPathData::GlobalMetaData(instance.name().as_interned_str()),\n+                        DefPathData::GlobalMetaData(instance.name()),\n                         ExpnId::root(),\n                         DUMMY_SP\n                     );\n@@ -624,7 +624,7 @@ macro_rules! define_global_metadata_kind {\n                 let def_key = DefKey {\n                     parent: Some(CRATE_DEF_INDEX),\n                     disambiguated_data: DisambiguatedDefPathData {\n-                        data: DefPathData::GlobalMetaData(self.name().as_interned_str()),\n+                        data: DefPathData::GlobalMetaData(self.name()),\n                         disambiguator: 0,\n                     }\n                 };"}, {"sha": "38c84ad33478bc3de8428cc0b768fd79109641f2", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -19,7 +19,7 @@ use crate::ty::query::Providers;\n use crate::util::nodemap::{NodeMap, FxHashSet};\n \n use errors::FatalError;\n-use syntax_pos::{Span, DUMMY_SP, symbol::InternedString, MultiSpan};\n+use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use syntax::source_map::Spanned;\n use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, AsmDialect};\n use syntax::ast::{Attribute, Label, LitKind, StrStyle, FloatTy, IntTy, UintTy};\n@@ -628,9 +628,9 @@ impl Generics {\n         own_counts\n     }\n \n-    pub fn get_named(&self, name: InternedString) -> Option<&GenericParam> {\n+    pub fn get_named(&self, name: Symbol) -> Option<&GenericParam> {\n         for param in &self.params {\n-            if name == param.name.ident().as_interned_str() {\n+            if name == param.name.ident().name {\n                 return Some(param);\n             }\n         }"}, {"sha": "dc1f6fd3131bd61dc2ec486baab6b1fdfca852bd", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -9,7 +9,7 @@ use std::mem;\n use syntax::ast;\n use syntax::feature_gate;\n use syntax::parse::token;\n-use syntax::symbol::InternedString;\n+use syntax::symbol::LocalInternedString;\n use syntax::tokenstream;\n use syntax_pos::SourceFile;\n \n@@ -18,20 +18,21 @@ use crate::hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n use smallvec::SmallVec;\n use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey, StableHasher};\n \n-impl<'a> HashStable<StableHashingContext<'a>> for InternedString {\n+impl<'a> HashStable<StableHashingContext<'a>> for LocalInternedString {\n     #[inline]\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        self.with(|s| s.hash_stable(hcx, hasher))\n+        let str = self as &str;\n+        str.hash_stable(hcx, hasher)\n     }\n }\n \n-impl<'a> ToStableHashKey<StableHashingContext<'a>> for InternedString {\n-    type KeyType = InternedString;\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for LocalInternedString {\n+    type KeyType = LocalInternedString;\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n                           _: &StableHashingContext<'a>)\n-                          -> InternedString {\n+                          -> LocalInternedString {\n         self.clone()\n     }\n }\n@@ -44,13 +45,13 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::Name {\n }\n \n impl<'a> ToStableHashKey<StableHashingContext<'a>> for ast::Name {\n-    type KeyType = InternedString;\n+    type KeyType = LocalInternedString;\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n                           _: &StableHashingContext<'a>)\n-                          -> InternedString {\n-        self.as_interned_str()\n+                          -> LocalInternedString {\n+        self.as_str()\n     }\n }\n "}, {"sha": "51ae4e49493f7c17565b5224cc218f7f7086f487", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -494,7 +494,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                 if sub_vid == self.for_vid_sub_root {\n                     // If sub-roots are equal, then `for_vid` and\n                     // `vid` are related via subtyping.\n-                    return Err(TypeError::CyclicTy(self.root_ty));\n+                    Err(TypeError::CyclicTy(self.root_ty))\n                 } else {\n                     match variables.probe(vid) {\n                         TypeVariableValue::Known { value: u } => {\n@@ -527,7 +527,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                             let u = self.tcx().mk_ty_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\",\n                                    vid, u);\n-                            return Ok(u);\n+                            Ok(u)\n                         }\n                     }\n                 }\n@@ -602,19 +602,26 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n         assert_eq!(c, c2); // we are abusing TypeRelation here; both LHS and RHS ought to be ==\n \n-        match c {\n-            ty::Const { val: ConstValue::Infer(InferConst::Var(vid)), .. } => {\n+        match c.val {\n+            ConstValue::Infer(InferConst::Var(vid)) => {\n                 let mut variable_table = self.infcx.const_unification_table.borrow_mut();\n-                match variable_table.probe_value(*vid).val.known() {\n-                    Some(u) => {\n-                        self.relate(&u, &u)\n+                let var_value = variable_table.probe_value(vid);\n+                match var_value.val {\n+                    ConstVariableValue::Known { value: u } => self.relate(&u, &u),\n+                    ConstVariableValue::Unknown { universe } => {\n+                        if self.for_universe.can_name(universe) {\n+                            Ok(c)\n+                        } else {\n+                            let new_var_id = variable_table.new_key(ConstVarValue {\n+                                origin: var_value.origin,\n+                                val: ConstVariableValue::Unknown { universe: self.for_universe },\n+                            });\n+                            Ok(self.tcx().mk_const_var(new_var_id, c.ty))\n+                        }\n                     }\n-                    None => Ok(c),\n                 }\n             }\n-            _ => {\n-                relate::super_relate_consts(self, c, c)\n-            }\n+            _ => relate::super_relate_consts(self, c, c),\n         }\n     }\n }"}, {"sha": "a50cc86862e57903983608ab6aa4cb5db1958244", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -542,7 +542,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 disambiguated_data: &DisambiguatedDefPathData,\n             ) -> Result<Self::Path, Self::Error> {\n                 let mut path = print_prefix(self)?;\n-                path.push(disambiguated_data.data.as_interned_str().to_string());\n+                path.push(disambiguated_data.data.as_symbol().to_string());\n                 Ok(path)\n             }\n             fn path_generic_args(\n@@ -1146,10 +1146,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         let span = cause.span(self.tcx);\n \n-        diag.span_label(span, terr.to_string());\n-        if let Some((sp, msg)) = secondary_span {\n-            diag.span_label(sp, msg);\n-        }\n+        // Ignore msg for object safe coercion\n+        // since E0038 message will be printed\n+        match terr {\n+            TypeError::ObjectUnsafeCoercion(_) => {}\n+            _ => {\n+                diag.span_label(span, terr.to_string());\n+                if let Some((sp, msg)) = secondary_span {\n+                    diag.span_label(sp, msg);\n+                }\n+            }\n+        };\n \n         if let Some((expected, found)) = expected_found {\n             match (terr, is_simple_error, expected == found) {\n@@ -1169,6 +1176,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         &sort_string(values.found),\n                     );\n                 }\n+                (TypeError::ObjectUnsafeCoercion(_), ..) => {\n+                    diag.note_unsuccessfull_coercion(found, expected);\n+                }\n                 (_, false, _) => {\n                     if let Some(exp_found) = exp_found {\n                         self.suggest_as_ref_where_appropriate(span, &exp_found, diag);\n@@ -1267,6 +1277,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let span = trace.cause.span(self.tcx);\n         let failure_code = trace.cause.as_failure_code(terr);\n         let mut diag = match failure_code {\n+            FailureCode::Error0038(did) => {\n+                let violations = self.tcx.object_safety_violations(did);\n+                self.tcx.report_object_safety_error(span, did, violations)\n+            }\n             FailureCode::Error0317(failure_str) => {\n                 struct_span_err!(self.tcx.sess, span, E0317, \"{}\", failure_str)\n             }\n@@ -1628,6 +1642,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n }\n \n enum FailureCode {\n+    Error0038(DefId),\n     Error0317(&'static str),\n     Error0580(&'static str),\n     Error0308(&'static str),\n@@ -1666,6 +1681,7 @@ impl<'tcx> ObligationCause<'tcx> {\n                 TypeError::IntrinsicCast => {\n                     Error0308(\"cannot coerce intrinsics to function pointers\")\n                 }\n+                TypeError::ObjectUnsafeCoercion(did) => Error0038(did.clone()),\n                 _ => Error0308(\"mismatched types\"),\n             },\n         }"}, {"sha": "e385d576b8ceb025049ab85a86e1057d3bc28777", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -32,7 +32,7 @@ use std::cell::{Cell, Ref, RefCell, RefMut};\n use std::collections::BTreeMap;\n use std::fmt;\n use syntax::ast;\n-use syntax_pos::symbol::InternedString;\n+use syntax_pos::symbol::Symbol;\n use syntax_pos::Span;\n \n use self::combine::CombineFields;\n@@ -392,7 +392,7 @@ pub enum RegionVariableOrigin {\n     Coercion(Span),\n \n     /// Region variables created as the values for early-bound regions\n-    EarlyBoundRegion(Span, InternedString),\n+    EarlyBoundRegion(Span, Symbol),\n \n     /// Region variables created for bound regions\n     /// in a function or method that is called"}, {"sha": "d6f76e9ee346c6f669308872cfae6a54f59e13f2", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 39, "deletions": 19, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -27,7 +27,8 @@ use crate::ty::error::TypeError;\n use crate::ty::fold::{TypeFoldable, TypeVisitor};\n use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use crate::ty::subst::GenericArg;\n-use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{self, Ty, TyCtxt, InferConst};\n+use crate::infer::{ConstVariableValue, ConstVarValue};\n use crate::mir::interpret::ConstValue;\n use rustc_data_structures::fx::FxHashMap;\n use std::fmt::Debug;\n@@ -324,7 +325,7 @@ where\n         let vid = pair.vid();\n         let value_ty = pair.value_ty();\n \n-        // FIXME -- this logic assumes invariance, but that is wrong.\n+        // FIXME(invariance) -- this logic assumes invariance, but that is wrong.\n         // This only presently applies to chalk integration, as NLL\n         // doesn't permit type variables to appear on both sides (and\n         // doesn't use lazy norm).\n@@ -616,15 +617,21 @@ where\n     fn consts(\n         &mut self,\n         a: &'tcx ty::Const<'tcx>,\n-        b: &'tcx ty::Const<'tcx>,\n+        mut b: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        if let ty::Const { val: ConstValue::Bound(..), .. } = a {\n-            // FIXME(const_generics): I'm unsure how this branch should actually be handled,\n-            // so this is probably not correct.\n-            self.infcx.super_combine_consts(self, a, b)\n-        } else {\n-            debug!(\"consts(a={:?}, b={:?}, variance={:?})\", a, b, self.ambient_variance);\n-            relate::super_relate_consts(self, a, b)\n+        let a = self.infcx.shallow_resolve(a);\n+\n+        if !D::forbid_inference_vars() {\n+            b = self.infcx.shallow_resolve(b);\n+        }\n+\n+        match b.val {\n+            ConstValue::Infer(InferConst::Var(_)) if D::forbid_inference_vars() => {\n+                // Forbid inference variables in the RHS.\n+                bug!(\"unexpected inference var {:?}\", b)\n+            }\n+            // FIXME(invariance): see the related FIXME above.\n+            _ => self.infcx.super_combine_consts(self, a, b)\n         }\n     }\n \n@@ -991,15 +998,28 @@ where\n         a: &'tcx ty::Const<'tcx>,\n         _: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        debug!(\"TypeGeneralizer::consts(a={:?})\", a);\n-\n-        if let ty::Const { val: ConstValue::Bound(..), .. } = a {\n-            bug!(\n-                \"unexpected inference variable encountered in NLL generalization: {:?}\",\n-                a\n-            );\n-        } else {\n-            relate::super_relate_consts(self, a, a)\n+        match a.val {\n+            ConstValue::Infer(InferConst::Var(_)) if D::forbid_inference_vars() => {\n+                bug!(\n+                    \"unexpected inference variable encountered in NLL generalization: {:?}\",\n+                    a\n+                );\n+            }\n+            ConstValue::Infer(InferConst::Var(vid)) => {\n+                let mut variable_table = self.infcx.const_unification_table.borrow_mut();\n+                let var_value = variable_table.probe_value(vid);\n+                match var_value.val.known() {\n+                    Some(u) => self.relate(&u, &u),\n+                    None => {\n+                        let new_var_id = variable_table.new_key(ConstVarValue {\n+                            origin: var_value.origin,\n+                            val: ConstVariableValue::Unknown { universe: self.universe },\n+                        });\n+                        Ok(self.tcx().mk_const_var(new_var_id, a.ty))\n+                    }\n+                }\n+            }\n+            _ => relate::super_relate_consts(self, a, a),\n         }\n     }\n "}, {"sha": "f79a30c7ae8f3cdbbf04631b209c3818cfe2ebac", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,4 +1,4 @@\n-use syntax::symbol::InternedString;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use crate::ty::{self, Ty, TyVid};\n \n@@ -49,7 +49,7 @@ pub enum TypeVariableOriginKind {\n     MiscVariable,\n     NormalizeProjectionType,\n     TypeInference,\n-    TypeParameterDefinition(InternedString),\n+    TypeParameterDefinition(Symbol),\n \n     /// One of the upvars or closure kind parameters in a `ClosureSubsts`\n     /// (before it has been determined)."}, {"sha": "b0b6d971c6087e572ece48f73b846fb4121c80b8", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -3,7 +3,7 @@ use crate::mir::interpret::ConstValue;\n use rustc_data_structures::unify::{NoError, EqUnifyValue, UnifyKey, UnifyValue, UnificationTable};\n use rustc_data_structures::unify::InPlace;\n use syntax_pos::{Span, DUMMY_SP};\n-use syntax::symbol::InternedString;\n+use syntax::symbol::Symbol;\n \n use std::cmp;\n use std::marker::PhantomData;\n@@ -90,7 +90,7 @@ pub struct ConstVariableOrigin {\n pub enum ConstVariableOriginKind {\n     MiscVariable,\n     ConstInference,\n-    ConstParameterDefinition(InternedString),\n+    ConstParameterDefinition(Symbol),\n     SubstitutionPlaceholder,\n }\n "}, {"sha": "15598b60f5c0bb4cd749bd5aa7eb18638713aa33", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 138, "deletions": 31, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -4,11 +4,12 @@\n //! compiler code, rather than using their own custom pass. Those\n //! lints are all available in `rustc_lint::builtin`.\n \n-use crate::lint::{LintPass, LateLintPass, LintArray};\n+use crate::lint::{LintPass, LateLintPass, LintArray, FutureIncompatibleInfo};\n use crate::middle::stability;\n use crate::session::Session;\n use errors::{Applicability, DiagnosticBuilder, pluralise};\n use syntax::ast;\n+use syntax::edition::Edition;\n use syntax::source_map::Span;\n use syntax::symbol::Symbol;\n \n@@ -22,7 +23,7 @@ declare_lint! {\n     pub CONST_ERR,\n     Deny,\n     \"constant evaluation detected erroneous expression\",\n-    report_in_external_macro: true\n+    report_in_external_macro\n }\n \n declare_lint! {\n@@ -71,7 +72,7 @@ declare_lint! {\n     pub UNREACHABLE_CODE,\n     Warn,\n     \"detects unreachable code paths\",\n-    report_in_external_macro: true\n+    report_in_external_macro\n }\n \n declare_lint! {\n@@ -131,7 +132,11 @@ declare_lint! {\n declare_lint! {\n     pub PRIVATE_IN_PUBLIC,\n     Warn,\n-    \"detect private items in public interfaces not caught by the old implementation\"\n+    \"detect private items in public interfaces not caught by the old implementation\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #34537 <https://github.com/rust-lang/rust/issues/34537>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n@@ -143,13 +148,21 @@ declare_lint! {\n declare_lint! {\n     pub PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n     Deny,\n-    \"detect public re-exports of private extern crates\"\n+    \"detect public re-exports of private extern crates\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #34537 <https://github.com/rust-lang/rust/issues/34537>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub INVALID_TYPE_PARAM_DEFAULT,\n     Deny,\n-    \"type parameter default erroneously allowed in invalid location\"\n+    \"type parameter default erroneously allowed in invalid location\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #36887 <https://github.com/rust-lang/rust/issues/36887>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n@@ -161,63 +174,99 @@ declare_lint! {\n declare_lint! {\n     pub SAFE_EXTERN_STATICS,\n     Deny,\n-    \"safe access to extern statics was erroneously allowed\"\n+    \"safe access to extern statics was erroneously allowed\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #36247 <https://github.com/rust-lang/rust/issues/36247>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub SAFE_PACKED_BORROWS,\n     Warn,\n-    \"safe borrows of fields of packed structs were was erroneously allowed\"\n+    \"safe borrows of fields of packed structs were was erroneously allowed\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #46043 <https://github.com/rust-lang/rust/issues/46043>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub PATTERNS_IN_FNS_WITHOUT_BODY,\n     Warn,\n-    \"patterns in functions without body were erroneously allowed\"\n+    \"patterns in functions without body were erroneously allowed\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #35203 <https://github.com/rust-lang/rust/issues/35203>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub LEGACY_DIRECTORY_OWNERSHIP,\n     Deny,\n     \"non-inline, non-`#[path]` modules (e.g., `mod foo;`) were erroneously allowed in some files \\\n-     not named `mod.rs`\"\n+     not named `mod.rs`\",\n+     @future_incompatible = FutureIncompatibleInfo {\n+         reference: \"issue #37872 <https://github.com/rust-lang/rust/issues/37872>\",\n+         edition: None,\n+     };\n }\n \n declare_lint! {\n     pub LEGACY_CONSTRUCTOR_VISIBILITY,\n     Deny,\n-    \"detects use of struct constructors that would be invisible with new visibility rules\"\n+    \"detects use of struct constructors that would be invisible with new visibility rules\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #39207 <https://github.com/rust-lang/rust/issues/39207>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub MISSING_FRAGMENT_SPECIFIER,\n     Deny,\n-    \"detects missing fragment specifiers in unused `macro_rules!` patterns\"\n+    \"detects missing fragment specifiers in unused `macro_rules!` patterns\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #40107 <https://github.com/rust-lang/rust/issues/40107>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n     Deny,\n-    \"detects parenthesized generic parameters in type and module names\"\n+    \"detects parenthesized generic parameters in type and module names\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #42238 <https://github.com/rust-lang/rust/issues/42238>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub LATE_BOUND_LIFETIME_ARGUMENTS,\n     Warn,\n-    \"detects generic lifetime arguments in path segments with late bound lifetime parameters\"\n+    \"detects generic lifetime arguments in path segments with late bound lifetime parameters\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #42868 <https://github.com/rust-lang/rust/issues/42868>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub ORDER_DEPENDENT_TRAIT_OBJECTS,\n     Deny,\n-    \"trait-object types were treated as different depending on marker-trait order\"\n+    \"trait-object types were treated as different depending on marker-trait order\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #56484 <https://github.com/rust-lang/rust/issues/56484>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub DEPRECATED,\n     Warn,\n     \"detects use of deprecated items\",\n-    report_in_external_macro: true\n+    report_in_external_macro\n }\n \n declare_lint! {\n@@ -253,7 +302,11 @@ declare_lint! {\n declare_lint! {\n     pub TYVAR_BEHIND_RAW_POINTER,\n     Warn,\n-    \"raw pointer to an inference variable\"\n+    \"raw pointer to an inference variable\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #46906 <https://github.com/rust-lang/rust/issues/46906>\",\n+        edition: Some(Edition::Edition2018),\n+    };\n }\n \n declare_lint! {\n@@ -272,19 +325,33 @@ declare_lint! {\n     pub ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n     Allow,\n     \"fully qualified paths that start with a module name \\\n-     instead of `crate`, `self`, or an extern crate name\"\n+     instead of `crate`, `self`, or an extern crate name\",\n+     @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #53130 <https://github.com/rust-lang/rust/issues/53130>\",\n+        edition: Some(Edition::Edition2018),\n+     };\n }\n \n declare_lint! {\n     pub ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n     Warn,\n-    \"floating-point literals cannot be used in patterns\"\n+    \"floating-point literals cannot be used in patterns\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #41620 <https://github.com/rust-lang/rust/issues/41620>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub UNSTABLE_NAME_COLLISIONS,\n     Warn,\n-    \"detects name collision with an existing but unstable method\"\n+    \"detects name collision with an existing but unstable method\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #48919 <https://github.com/rust-lang/rust/issues/48919>\",\n+        edition: None,\n+        // Note: this item represents future incompatibility of all unstable functions in the\n+        //       standard library, and thus should never be removed or changed to an error.\n+    };\n }\n \n declare_lint! {\n@@ -302,7 +369,11 @@ declare_lint! {\n declare_lint! {\n     pub DUPLICATE_MACRO_EXPORTS,\n     Deny,\n-    \"detects duplicate macro exports\"\n+    \"detects duplicate macro exports\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #35896 <https://github.com/rust-lang/rust/issues/35896>\",\n+        edition: Some(Edition::Edition2018),\n+    };\n }\n \n declare_lint! {\n@@ -326,13 +397,21 @@ declare_lint! {\n declare_lint! {\n     pub WHERE_CLAUSES_OBJECT_SAFETY,\n     Warn,\n-    \"checks the object safety of where clauses\"\n+    \"checks the object safety of where clauses\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #51443 <https://github.com/rust-lang/rust/issues/51443>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n     Warn,\n-    \"detects proc macro derives using inaccessible names from parent modules\"\n+    \"detects proc macro derives using inaccessible names from parent modules\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #50504 <https://github.com/rust-lang/rust/issues/50504>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n@@ -346,7 +425,11 @@ declare_lint! {\n     pub MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS,\n     Deny,\n     \"macro-expanded `macro_export` macros from the current crate \\\n-     cannot be referred to by absolute paths\"\n+     cannot be referred to by absolute paths\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #52234 <https://github.com/rust-lang/rust/issues/52234>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n@@ -359,15 +442,23 @@ declare_lint! {\n     pub INDIRECT_STRUCTURAL_MATCH,\n     // defaulting to allow until rust-lang/rust#62614 is fixed.\n     Allow,\n-    \"pattern with const indirectly referencing non-`#[structural_match]` type\"\n+    \"pattern with const indirectly referencing non-`#[structural_match]` type\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #62411 <https://github.com/rust-lang/rust/issues/62411>\",\n+        edition: None,\n+    };\n }\n \n /// Some lints that are buffered from `libsyntax`. See `syntax::early_buffered_lints`.\n pub mod parser {\n     declare_lint! {\n         pub ILL_FORMED_ATTRIBUTE_INPUT,\n         Warn,\n-        \"ill-formed attribute inputs that were previously accepted and used in practice\"\n+        \"ill-formed attribute inputs that were previously accepted and used in practice\",\n+        @future_incompatible = super::FutureIncompatibleInfo {\n+            reference: \"issue #57571 <https://github.com/rust-lang/rust/issues/57571>\",\n+            edition: None,\n+        };\n     }\n \n     declare_lint! {\n@@ -387,31 +478,47 @@ declare_lint! {\n     pub DEPRECATED_IN_FUTURE,\n     Allow,\n     \"detects use of items that will be deprecated in a future version\",\n-    report_in_external_macro: true\n+    report_in_external_macro\n }\n \n declare_lint! {\n     pub AMBIGUOUS_ASSOCIATED_ITEMS,\n     Deny,\n-    \"ambiguous associated items\"\n+    \"ambiguous associated items\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #57644 <https://github.com/rust-lang/rust/issues/57644>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub NESTED_IMPL_TRAIT,\n     Warn,\n-    \"nested occurrence of `impl Trait` type\"\n+    \"nested occurrence of `impl Trait` type\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #59014 <https://github.com/rust-lang/rust/issues/59014>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub MUTABLE_BORROW_RESERVATION_CONFLICT,\n     Warn,\n-    \"reservation of a two-phased borrow conflicts with other shared borrows\"\n+    \"reservation of a two-phased borrow conflicts with other shared borrows\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #59159 <https://github.com/rust-lang/rust/issues/59159>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub SOFT_UNSTABLE,\n     Deny,\n-    \"a feature gate that doesn't break dependent crates\"\n+    \"a feature gate that doesn't break dependent crates\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #64266 <https://github.com/rust-lang/rust/issues/64266>\",\n+        edition: None,\n+    };\n }\n \n declare_lint_pass! {"}, {"sha": "1cb53d754dcd3891357e0b48e63dadc7ba3336f0", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 85, "deletions": 155, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -22,11 +22,11 @@ use crate::hir::intravisit as hir_visit;\n use crate::hir::intravisit::Visitor;\n use crate::hir::map::{definitions::DisambiguatedDefPathData, DefPathData};\n use crate::lint::{EarlyLintPass, LateLintPass, EarlyLintPassObject, LateLintPassObject};\n-use crate::lint::{LintArray, Level, Lint, LintId, LintPass, LintBuffer};\n+use crate::lint::{Level, Lint, LintId, LintPass, LintBuffer, FutureIncompatibleInfo};\n use crate::lint::builtin::BuiltinLintDiagnostics;\n use crate::lint::levels::{LintLevelSets, LintLevelsBuilder};\n use crate::middle::privacy::AccessLevels;\n-use crate::session::{config, early_error, Session};\n+use crate::session::Session;\n use crate::ty::{self, print::Printer, subst::GenericArg, TyCtxt, Ty};\n use crate::ty::layout::{LayoutError, LayoutOf, TyLayout};\n use crate::util::nodemap::FxHashMap;\n@@ -35,10 +35,9 @@ use crate::util::common::time;\n use errors::DiagnosticBuilder;\n use std::slice;\n use std::default::Default as StdDefault;\n-use rustc_data_structures::sync::{ReadGuard, Lock, ParallelIterator, join, par_iter};\n+use rustc_data_structures::sync::{self, ParallelIterator, join, par_iter};\n use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use syntax::ast;\n-use syntax::edition;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit as ast_visit;\n use syntax_pos::{MultiSpan, Span, symbol::Symbol};\n@@ -50,24 +49,25 @@ use syntax_pos::{MultiSpan, Span, symbol::Symbol};\n pub struct LintStore {\n     /// Registered lints. The bool is true if the lint was\n     /// added by a plugin.\n-    lints: Vec<(&'static Lint, bool)>,\n+    lints: Vec<&'static Lint>,\n \n-    /// Trait objects for each lint pass.\n-    /// This is only `None` while performing a lint pass.\n-    pre_expansion_passes: Option<Vec<EarlyLintPassObject>>,\n-    early_passes: Option<Vec<EarlyLintPassObject>>,\n-    late_passes: Lock<Option<Vec<LateLintPassObject>>>,\n-    late_module_passes: Vec<LateLintPassObject>,\n+    /// Constructor functions for each variety of lint pass.\n+    ///\n+    /// These should only be called once, but since we want to avoid locks or\n+    /// interior mutability, we don't enforce this (and lints should, in theory,\n+    /// be compatible with being constructed more than once, though not\n+    /// necessarily in a sane manner. This is safe though.)\n+    pre_expansion_passes: Vec<Box<dyn Fn() -> EarlyLintPassObject + sync::Send + sync::Sync>>,\n+    early_passes: Vec<Box<dyn Fn() -> EarlyLintPassObject + sync::Send + sync::Sync>>,\n+    late_passes: Vec<Box<dyn Fn() -> LateLintPassObject + sync::Send + sync::Sync>>,\n+    /// This is unique in that we construct them per-module, so not once.\n+    late_module_passes: Vec<Box<dyn Fn() -> LateLintPassObject + sync::Send + sync::Sync>>,\n \n     /// Lints indexed by name.\n     by_name: FxHashMap<String, TargetLint>,\n \n     /// Map of registered lint groups to what lints they expand to.\n     lint_groups: FxHashMap<&'static str, LintGroup>,\n-\n-    /// Extra info for future incompatibility lints, describing the\n-    /// issue or RFC that caused the incompatibility.\n-    future_incompatible: FxHashMap<LintId, FutureIncompatibleInfo>,\n }\n \n /// Lints that are buffered up early on in the `Session` before the\n@@ -81,18 +81,6 @@ pub struct BufferedEarlyLint {\n     pub diagnostic: BuiltinLintDiagnostics,\n }\n \n-/// Extra information for a future incompatibility lint. See the call\n-/// to `register_future_incompatible` in `librustc_lint/lib.rs` for\n-/// guidelines.\n-pub struct FutureIncompatibleInfo {\n-    pub id: LintId,\n-    /// e.g., a URL for an issue/PR/RFC or error code\n-    pub reference: &'static str,\n-    /// If this is an edition fixing lint, the edition in which\n-    /// this lint becomes obsolete\n-    pub edition: Option<edition::Edition>,\n-}\n-\n /// The target of the `by_name` map, which accounts for renaming/deprecation.\n enum TargetLint {\n     /// A direct lint target\n@@ -142,17 +130,16 @@ impl LintStore {\n     pub fn new() -> LintStore {\n         LintStore {\n             lints: vec![],\n-            pre_expansion_passes: Some(vec![]),\n-            early_passes: Some(vec![]),\n-            late_passes: Lock::new(Some(vec![])),\n+            pre_expansion_passes: vec![],\n+            early_passes: vec![],\n+            late_passes: vec![],\n             late_module_passes: vec![],\n             by_name: Default::default(),\n-            future_incompatible: Default::default(),\n             lint_groups: Default::default(),\n         }\n     }\n \n-    pub fn get_lints<'t>(&'t self) -> &'t [(&'static Lint, bool)] {\n+    pub fn get_lints<'t>(&'t self) -> &'t [&'static Lint] {\n         &self.lints\n     }\n \n@@ -168,99 +155,64 @@ impl LintStore {\n             .collect()\n     }\n \n-    pub fn register_early_pass(&mut self,\n-                               sess: Option<&Session>,\n-                               from_plugin: bool,\n-                               register_only: bool,\n-                               pass: EarlyLintPassObject) {\n-        self.push_pass(sess, from_plugin, &pass);\n-        if !register_only {\n-            self.early_passes.as_mut().unwrap().push(pass);\n-        }\n+    pub fn register_early_pass(\n+        &mut self,\n+        pass: impl Fn() -> EarlyLintPassObject + 'static + sync::Send + sync::Sync\n+    ) {\n+        self.early_passes.push(Box::new(pass));\n     }\n \n     pub fn register_pre_expansion_pass(\n         &mut self,\n-        sess: Option<&Session>,\n-        from_plugin: bool,\n-        register_only: bool,\n-        pass: EarlyLintPassObject,\n+        pass: impl Fn() -> EarlyLintPassObject + 'static + sync::Send + sync::Sync,\n     ) {\n-        self.push_pass(sess, from_plugin, &pass);\n-        if !register_only {\n-            self.pre_expansion_passes.as_mut().unwrap().push(pass);\n-        }\n+        self.pre_expansion_passes.push(Box::new(pass));\n     }\n \n-    pub fn register_late_pass(&mut self,\n-                              sess: Option<&Session>,\n-                              from_plugin: bool,\n-                              register_only: bool,\n-                              per_module: bool,\n-                              pass: LateLintPassObject) {\n-        self.push_pass(sess, from_plugin, &pass);\n-        if !register_only {\n-            if per_module {\n-                self.late_module_passes.push(pass);\n-            } else {\n-                self.late_passes.lock().as_mut().unwrap().push(pass);\n-            }\n-        }\n+    pub fn register_late_pass(\n+        &mut self,\n+        pass: impl Fn() -> LateLintPassObject + 'static + sync::Send + sync::Sync,\n+    ) {\n+        self.late_passes.push(Box::new(pass));\n+    }\n+\n+    pub fn register_late_mod_pass(\n+        &mut self,\n+        pass: impl Fn() -> LateLintPassObject + 'static + sync::Send + sync::Sync,\n+    ) {\n+        self.late_module_passes.push(Box::new(pass));\n     }\n \n     // Helper method for register_early/late_pass\n-    fn push_pass<P: LintPass + ?Sized + 'static>(&mut self,\n-                                        sess: Option<&Session>,\n-                                        from_plugin: bool,\n-                                        pass: &Box<P>) {\n-        for lint in pass.get_lints() {\n-            self.lints.push((lint, from_plugin));\n+    pub fn register_lints(&mut self, lints: &[&'static Lint]) {\n+        for lint in lints {\n+            self.lints.push(lint);\n \n             let id = LintId::of(lint);\n             if self.by_name.insert(lint.name_lower(), Id(id)).is_some() {\n-                let msg = format!(\"duplicate specification of lint {}\", lint.name_lower());\n-                match (sess, from_plugin) {\n-                    // We load builtin lints first, so a duplicate is a compiler bug.\n-                    // Use early_error when handling -W help with no crate.\n-                    (None, _) => early_error(config::ErrorOutputType::default(), &msg[..]),\n-                    (Some(_), false) => bug!(\"{}\", msg),\n-\n-                    // A duplicate name from a plugin is a user error.\n-                    (Some(sess), true)  => sess.err(&msg[..]),\n-                }\n+                bug!(\"duplicate specification of lint {}\", lint.name_lower())\n             }\n-        }\n-    }\n \n-    pub fn register_future_incompatible(&mut self,\n-                                        sess: Option<&Session>,\n-                                        lints: Vec<FutureIncompatibleInfo>) {\n+            if let Some(FutureIncompatibleInfo { edition, .. }) = lint.future_incompatible {\n+                if let Some(edition) = edition {\n+                    self.lint_groups.entry(edition.lint_name())\n+                        .or_insert(LintGroup {\n+                            lint_ids: vec![],\n+                            from_plugin: lint.is_plugin,\n+                            depr: None,\n+                        })\n+                        .lint_ids.push(id);\n+                }\n \n-        for edition in edition::ALL_EDITIONS {\n-            let lints = lints.iter().filter(|f| f.edition == Some(*edition)).map(|f| f.id)\n-                             .collect::<Vec<_>>();\n-            if !lints.is_empty() {\n-                self.register_group(sess, false, edition.lint_name(), None, lints)\n+                self.lint_groups.entry(\"future_incompatible\")\n+                    .or_insert(LintGroup {\n+                        lint_ids: vec![],\n+                        from_plugin: lint.is_plugin,\n+                        depr: None,\n+                    })\n+                    .lint_ids.push(id);\n             }\n         }\n-\n-        let mut future_incompatible = Vec::with_capacity(lints.len());\n-        for lint in lints {\n-            future_incompatible.push(lint.id);\n-            self.future_incompatible.insert(lint.id, lint);\n-        }\n-\n-        self.register_group(\n-            sess,\n-            false,\n-            \"future_incompatible\",\n-            None,\n-            future_incompatible,\n-        );\n-    }\n-\n-    pub fn future_incompatible(&self, id: LintId) -> Option<&FutureIncompatibleInfo> {\n-        self.future_incompatible.get(&id)\n     }\n \n     pub fn register_group_alias(\n@@ -277,7 +229,6 @@ impl LintStore {\n \n     pub fn register_group(\n         &mut self,\n-        sess: Option<&Session>,\n         from_plugin: bool,\n         name: &'static str,\n         deprecated_name: Option<&'static str>,\n@@ -300,16 +251,7 @@ impl LintStore {\n         }\n \n         if !new {\n-            let msg = format!(\"duplicate specification of lint group {}\", name);\n-            match (sess, from_plugin) {\n-                // We load builtin lints first, so a duplicate is a compiler bug.\n-                // Use early_error when handling -W help with no crate.\n-                (None, _) => early_error(config::ErrorOutputType::default(), &msg[..]),\n-                (Some(_), false) => bug!(\"{}\", msg),\n-\n-                // A duplicate name from a plugin is a user error.\n-                (Some(sess), true)  => sess.err(&msg[..]),\n-            }\n+            bug!(\"duplicate specification of lint group {}\", name);\n         }\n     }\n \n@@ -522,7 +464,7 @@ pub struct LateContext<'a, 'tcx> {\n     pub access_levels: &'a AccessLevels,\n \n     /// The store of registered lints and the lint levels.\n-    lint_store: ReadGuard<'a, LintStore>,\n+    lint_store: &'tcx LintStore,\n \n     last_node_with_lint_attrs: hir::HirId,\n \n@@ -550,7 +492,7 @@ pub struct EarlyContext<'a> {\n     builder: LintLevelsBuilder<'a>,\n \n     /// The store of registered lints and the lint levels.\n-    lint_store: ReadGuard<'a, LintStore>,\n+    lint_store: &'a LintStore,\n \n     buffered: LintBuffer,\n }\n@@ -639,14 +581,15 @@ pub trait LintContext: Sized {\n impl<'a> EarlyContext<'a> {\n     fn new(\n         sess: &'a Session,\n+        lint_store: &'a LintStore,\n         krate: &'a ast::Crate,\n         buffered: LintBuffer,\n     ) -> EarlyContext<'a> {\n         EarlyContext {\n             sess,\n             krate,\n-            lint_store: sess.lint_store.borrow(),\n-            builder: LintLevelSets::builder(sess),\n+            lint_store,\n+            builder: LintLevelSets::builder(sess, lint_store),\n             buffered,\n         }\n     }\n@@ -681,7 +624,7 @@ impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n                           f: F)\n         where F: FnOnce(&mut Self)\n     {\n-        let push = self.context.builder.push(attrs);\n+        let push = self.context.builder.push(attrs, &self.context.lint_store);\n         self.check_id(id);\n         self.enter_attrs(attrs);\n         f(self);\n@@ -875,7 +818,7 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n                     _ => {}\n                 }\n \n-                path.push(disambiguated_data.data.as_interned_str().as_symbol());\n+                path.push(disambiguated_data.data.as_symbol());\n                 Ok(path)\n             }\n \n@@ -1355,10 +1298,6 @@ impl LintPass for LateLintPassObjects<'_> {\n     fn name(&self) -> &'static str {\n         panic!()\n     }\n-\n-    fn get_lints(&self) -> LintArray {\n-        panic!()\n-    }\n }\n \n macro_rules! expand_late_lint_pass_impl_methods {\n@@ -1393,7 +1332,7 @@ fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n         tables: &ty::TypeckTables::empty(None),\n         param_env: ty::ParamEnv::empty(),\n         access_levels,\n-        lint_store: tcx.sess.lint_store.borrow(),\n+        lint_store: &tcx.lint_store,\n         last_node_with_lint_attrs: tcx.hir().as_local_hir_id(module_def_id).unwrap(),\n         generics: None,\n         only_module: true,\n@@ -1425,8 +1364,8 @@ pub fn late_lint_mod<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n \n     late_lint_mod_pass(tcx, module_def_id, builtin_lints);\n \n-    let mut passes: Vec<_> = tcx.sess.lint_store.borrow().late_module_passes\n-                                .iter().map(|pass| pass.fresh_late_pass()).collect();\n+    let mut passes: Vec<_> = tcx.lint_store.late_module_passes\n+                                .iter().map(|pass| (pass)()).collect();\n \n     if !passes.is_empty() {\n         late_lint_mod_pass(tcx, module_def_id, LateLintPassObjects { lints: &mut passes[..] });\n@@ -1443,7 +1382,7 @@ fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tc\n         tables: &ty::TypeckTables::empty(None),\n         param_env: ty::ParamEnv::empty(),\n         access_levels,\n-        lint_store: tcx.sess.lint_store.borrow(),\n+        lint_store: &tcx.lint_store,\n         last_node_with_lint_attrs: hir::CRATE_HIR_ID,\n         generics: None,\n         only_module: false,\n@@ -1467,7 +1406,8 @@ fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tc\n }\n \n fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, builtin_lints: T) {\n-    let mut passes = tcx.sess.lint_store.borrow().late_passes.lock().take().unwrap();\n+    let mut passes = tcx.lint_store\n+        .late_passes.iter().map(|p| (p)()).collect::<Vec<_>>();\n \n     if !tcx.sess.opts.debugging_opts.no_interleave_lints {\n         if !passes.is_empty() {\n@@ -1482,18 +1422,15 @@ fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, b\n             });\n         }\n \n-        let mut passes: Vec<_> = tcx.sess.lint_store.borrow().late_module_passes\n-                                    .iter().map(|pass| pass.fresh_late_pass()).collect();\n+        let mut passes: Vec<_> = tcx.lint_store.late_module_passes\n+                                    .iter().map(|pass| (pass)()).collect();\n \n         for pass in &mut passes {\n             time(tcx.sess, &format!(\"running late module lint: {}\", pass.name()), || {\n                 late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n             });\n         }\n     }\n-\n-    // Put the passes back in the session.\n-    *tcx.sess.lint_store.borrow().late_passes.lock() = Some(passes);\n }\n \n /// Performs lint checking on a crate.\n@@ -1525,10 +1462,6 @@ impl LintPass for EarlyLintPassObjects<'_> {\n     fn name(&self) -> &'static str {\n         panic!()\n     }\n-\n-    fn get_lints(&self) -> LintArray {\n-        panic!()\n-    }\n }\n \n macro_rules! expand_early_lint_pass_impl_methods {\n@@ -1553,12 +1486,13 @@ early_lint_methods!(early_lint_pass_impl, []);\n \n fn early_lint_crate<T: EarlyLintPass>(\n     sess: &Session,\n+    lint_store: &LintStore,\n     krate: &ast::Crate,\n     pass: T,\n     buffered: LintBuffer,\n ) -> LintBuffer {\n     let mut cx = EarlyContextAndPass {\n-        context: EarlyContext::new(sess, krate, buffered),\n+        context: EarlyContext::new(sess, lint_store, krate, buffered),\n         pass,\n     };\n \n@@ -1577,28 +1511,30 @@ fn early_lint_crate<T: EarlyLintPass>(\n \n pub fn check_ast_crate<T: EarlyLintPass>(\n     sess: &Session,\n+    lint_store: &LintStore,\n     krate: &ast::Crate,\n     pre_expansion: bool,\n     builtin_lints: T,\n ) {\n-    let (mut passes, mut buffered) = if pre_expansion {\n+    let (mut passes, mut buffered): (Vec<_>, _) = if pre_expansion {\n         (\n-            sess.lint_store.borrow_mut().pre_expansion_passes.take().unwrap(),\n+            lint_store.pre_expansion_passes.iter().map(|p| (p)()).collect(),\n             LintBuffer::default(),\n         )\n     } else {\n         (\n-            sess.lint_store.borrow_mut().early_passes.take().unwrap(),\n+            lint_store.early_passes.iter().map(|p| (p)()).collect(),\n             sess.buffered_lints.borrow_mut().take().unwrap(),\n         )\n     };\n \n     if !sess.opts.debugging_opts.no_interleave_lints {\n-        buffered = early_lint_crate(sess, krate, builtin_lints, buffered);\n+        buffered = early_lint_crate(sess, lint_store, krate, builtin_lints, buffered);\n \n         if !passes.is_empty() {\n             buffered = early_lint_crate(\n                 sess,\n+                lint_store,\n                 krate,\n                 EarlyLintPassObjects { lints: &mut passes[..] },\n                 buffered,\n@@ -1609,6 +1545,7 @@ pub fn check_ast_crate<T: EarlyLintPass>(\n             buffered = time(sess, &format!(\"running lint: {}\", pass.name()), || {\n                 early_lint_crate(\n                     sess,\n+                    lint_store,\n                     krate,\n                     EarlyLintPassObjects { lints: slice::from_mut(pass) },\n                     buffered,\n@@ -1617,13 +1554,6 @@ pub fn check_ast_crate<T: EarlyLintPass>(\n         }\n     }\n \n-    // Put the lint store levels and passes back in the session.\n-    if pre_expansion {\n-        sess.lint_store.borrow_mut().pre_expansion_passes = Some(passes);\n-    } else {\n-        sess.lint_store.borrow_mut().early_passes = Some(passes);\n-    }\n-\n     // All of the buffered lints should have been emitted at this point.\n     // If not, that means that we somehow buffered a lint for a node id\n     // that was not lint-checked (perhaps it doesn't exist?). This is a bug.\n@@ -1653,7 +1583,7 @@ impl Decodable for LintId {\n     fn decode<D: Decoder>(d: &mut D) -> Result<LintId, D::Error> {\n         let s = d.read_str()?;\n         ty::tls::with(|tcx| {\n-            match tcx.sess.lint_store.borrow().find_lints(&s) {\n+            match tcx.lint_store.find_lints(&s) {\n                 Ok(ids) => {\n                     if ids.len() != 0 {\n                         panic!(\"invalid lint-id `{}`\", s);"}, {"sha": "4c60492e470c2ebd12694a9da05e69db30155719", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -3,7 +3,7 @@ use std::cmp;\n use crate::hir::HirId;\n use crate::ich::StableHashingContext;\n use crate::lint::builtin;\n-use crate::lint::context::CheckLintNameResult;\n+use crate::lint::context::{LintStore, CheckLintNameResult};\n use crate::lint::{self, Lint, LintId, Level, LintSource};\n use crate::session::Session;\n use crate::util::nodemap::FxHashMap;\n@@ -35,21 +35,20 @@ enum LintSet {\n }\n \n impl LintLevelSets {\n-    pub fn new(sess: &Session) -> LintLevelSets {\n+    pub fn new(sess: &Session, lint_store: &LintStore) -> LintLevelSets {\n         let mut me = LintLevelSets {\n             list: Vec::new(),\n             lint_cap: Level::Forbid,\n         };\n-        me.process_command_line(sess);\n+        me.process_command_line(sess, lint_store);\n         return me\n     }\n \n-    pub fn builder(sess: &Session) -> LintLevelsBuilder<'_> {\n-        LintLevelsBuilder::new(sess, LintLevelSets::new(sess))\n+    pub fn builder<'a>(sess: &'a Session, store: &LintStore) -> LintLevelsBuilder<'a> {\n+        LintLevelsBuilder::new(sess, LintLevelSets::new(sess, store))\n     }\n \n-    fn process_command_line(&mut self, sess: &Session) {\n-        let store = sess.lint_store.borrow();\n+    fn process_command_line(&mut self, sess: &Session, store: &LintStore) {\n         let mut specs = FxHashMap::default();\n         self.lint_cap = sess.opts.lint_cap.unwrap_or(Level::Forbid);\n \n@@ -186,9 +185,8 @@ impl<'a> LintLevelsBuilder<'a> {\n     ///   #[allow]\n     ///\n     /// Don't forget to call `pop`!\n-    pub fn push(&mut self, attrs: &[ast::Attribute]) -> BuilderPush {\n+    pub fn push(&mut self, attrs: &[ast::Attribute], store: &LintStore) -> BuilderPush {\n         let mut specs = FxHashMap::default();\n-        let store = self.sess.lint_store.borrow();\n         let sess = self.sess;\n         let bad_attr = |span| {\n             struct_span_err!(sess, span, E0452, \"malformed lint attribute input\")"}, {"sha": "3c35bdae66e9d5ab2f9721d53f50104be82459bc", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 64, "deletions": 39, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -45,7 +45,7 @@ use syntax_pos::Span;\n \n pub use crate::lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n                         check_crate, check_ast_crate, late_lint_mod, CheckLintNameResult,\n-                        FutureIncompatibleInfo, BufferedEarlyLint,};\n+                        BufferedEarlyLint,};\n \n /// Specification of a single lint.\n #[derive(Copy, Clone, Debug)]\n@@ -76,9 +76,35 @@ pub struct Lint {\n \n     /// `true` if this lint is reported even inside expansions of external macros.\n     pub report_in_external_macro: bool,\n+\n+    pub future_incompatible: Option<FutureIncompatibleInfo>,\n+\n+    pub is_plugin: bool,\n+}\n+\n+/// Extra information for a future incompatibility lint.\n+#[derive(Copy, Clone, Debug)]\n+pub struct FutureIncompatibleInfo {\n+    /// e.g., a URL for an issue/PR/RFC or error code\n+    pub reference: &'static str,\n+    /// If this is an edition fixing lint, the edition in which\n+    /// this lint becomes obsolete\n+    pub edition: Option<Edition>,\n }\n \n impl Lint {\n+    pub const fn default_fields_for_macro() -> Self {\n+        Lint {\n+            name: \"\",\n+            default_level: Level::Forbid,\n+            desc: \"\",\n+            edition_lint_opts: None,\n+            is_plugin: false,\n+            report_in_external_macro: false,\n+            future_incompatible: None,\n+        }\n+    }\n+\n     /// Returns the `rust::lint::Lint` for a `syntax::early_buffered_lints::BufferedEarlyLintId`.\n     pub fn from_parser_lint_id(lint_id: BufferedEarlyLintId) -> &'static Self {\n         match lint_id {\n@@ -105,18 +131,21 @@ impl Lint {\n #[macro_export]\n macro_rules! declare_lint {\n     ($vis: vis $NAME: ident, $Level: ident, $desc: expr) => (\n-        declare_lint!{$vis $NAME, $Level, $desc, false}\n-    );\n-    ($vis: vis $NAME: ident, $Level: ident, $desc: expr, report_in_external_macro: $rep: expr) => (\n-        declare_lint!{$vis $NAME, $Level, $desc, $rep}\n+        declare_lint!(\n+            $vis $NAME, $Level, $desc,\n+        );\n     );\n-    ($vis: vis $NAME: ident, $Level: ident, $desc: expr, $external: expr) => (\n+    ($vis: vis $NAME: ident, $Level: ident, $desc: expr,\n+     $(@future_incompatible = $fi:expr;)? $($v:ident),*) => (\n         $vis static $NAME: &$crate::lint::Lint = &$crate::lint::Lint {\n             name: stringify!($NAME),\n             default_level: $crate::lint::$Level,\n             desc: $desc,\n             edition_lint_opts: None,\n-            report_in_external_macro: $external,\n+            is_plugin: false,\n+            $($v: true,)*\n+            $(future_incompatible: Some($fi),)*\n+            ..$crate::lint::Lint::default_fields_for_macro()\n         };\n     );\n     ($vis: vis $NAME: ident, $Level: ident, $desc: expr,\n@@ -128,6 +157,7 @@ macro_rules! declare_lint {\n             desc: $desc,\n             edition_lint_opts: Some(($lint_edition, $crate::lint::Level::$edition_level)),\n             report_in_external_macro: false,\n+            is_plugin: false,\n         };\n     );\n }\n@@ -156,6 +186,8 @@ macro_rules! declare_tool_lint {\n             desc: $desc,\n             edition_lint_opts: None,\n             report_in_external_macro: $external,\n+            future_incompatible: None,\n+            is_plugin: true,\n         };\n     );\n }\n@@ -173,14 +205,6 @@ pub type LintArray = Vec<&'static Lint>;\n \n pub trait LintPass {\n     fn name(&self) -> &'static str;\n-\n-    /// Gets descriptions of the lints this `LintPass` object can emit.\n-    ///\n-    /// N.B., there is no enforcement that the object only emits lints it registered.\n-    /// And some `rustc` internal `LintPass`es register lints to be emitted by other\n-    /// parts of the compiler. If you want enforced access restrictions for your\n-    /// `Lint`, make it a private `static` item in its own module.\n-    fn get_lints(&self) -> LintArray;\n }\n \n /// Implements `LintPass for $name` with the given list of `Lint` statics.\n@@ -189,7 +213,9 @@ macro_rules! impl_lint_pass {\n     ($name:ident => [$($lint:expr),* $(,)?]) => {\n         impl LintPass for $name {\n             fn name(&self) -> &'static str { stringify!($name) }\n-            fn get_lints(&self) -> LintArray { $crate::lint_array!($($lint),*) }\n+        }\n+        impl $name {\n+            pub fn get_lints() -> LintArray { $crate::lint_array!($($lint),*) }\n         }\n     };\n }\n@@ -287,9 +313,6 @@ macro_rules! expand_lint_pass_methods {\n macro_rules! declare_late_lint_pass {\n     ([], [$hir:tt], [$($methods:tt)*]) => (\n         pub trait LateLintPass<'a, $hir>: LintPass {\n-            fn fresh_late_pass(&self) -> LateLintPassObject {\n-                panic!()\n-            }\n             expand_lint_pass_methods!(&LateContext<'a, $hir>, [$($methods)*]);\n         }\n     )\n@@ -327,6 +350,12 @@ macro_rules! declare_combined_late_lint_pass {\n                     $($passes: $constructor,)*\n                 }\n             }\n+\n+            $v fn get_lints() -> LintArray {\n+                let mut lints = Vec::new();\n+                $(lints.extend_from_slice(&$passes::get_lints());)*\n+                lints\n+            }\n         }\n \n         impl<'a, 'tcx> LateLintPass<'a, 'tcx> for $name {\n@@ -337,12 +366,6 @@ macro_rules! declare_combined_late_lint_pass {\n             fn name(&self) -> &'static str {\n                 panic!()\n             }\n-\n-            fn get_lints(&self) -> LintArray {\n-                let mut lints = Vec::new();\n-                $(lints.extend_from_slice(&self.$passes.get_lints());)*\n-                lints\n-            }\n         }\n     )\n }\n@@ -454,6 +477,12 @@ macro_rules! declare_combined_early_lint_pass {\n                     $($passes: $constructor,)*\n                 }\n             }\n+\n+            $v fn get_lints() -> LintArray {\n+                let mut lints = Vec::new();\n+                $(lints.extend_from_slice(&$passes::get_lints());)*\n+                lints\n+            }\n         }\n \n         impl EarlyLintPass for $name {\n@@ -464,12 +493,6 @@ macro_rules! declare_combined_early_lint_pass {\n             fn name(&self) -> &'static str {\n                 panic!()\n             }\n-\n-            fn get_lints(&self) -> LintArray {\n-                let mut lints = Vec::new();\n-                $(lints.extend_from_slice(&self.$passes.get_lints());)*\n-                lints\n-            }\n         }\n     )\n }\n@@ -649,9 +672,8 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n     };\n \n     // Check for future incompatibility lints and issue a stronger warning.\n-    let lints = sess.lint_store.borrow();\n     let lint_id = LintId::of(lint);\n-    let future_incompatible = lints.future_incompatible(lint_id);\n+    let future_incompatible = lint.future_incompatible;\n \n     // If this code originates in a foreign macro, aka something that this crate\n     // did not itself author, then it's likely that there's nothing this crate\n@@ -755,13 +777,15 @@ pub fn maybe_lint_level_root(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n \n fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> &LintLevelMap {\n     assert_eq!(cnum, LOCAL_CRATE);\n+    let store = &tcx.lint_store;\n     let mut builder = LintLevelMapBuilder {\n-        levels: LintLevelSets::builder(tcx.sess),\n+        levels: LintLevelSets::builder(tcx.sess, &store),\n         tcx: tcx,\n+        store: store,\n     };\n     let krate = tcx.hir().krate();\n \n-    let push = builder.levels.push(&krate.attrs);\n+    let push = builder.levels.push(&krate.attrs, &store);\n     builder.levels.register_id(hir::CRATE_HIR_ID);\n     for macro_def in &krate.exported_macros {\n        builder.levels.register_id(macro_def.hir_id);\n@@ -772,19 +796,20 @@ fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> &LintLevelMap {\n     tcx.arena.alloc(builder.levels.build_map())\n }\n \n-struct LintLevelMapBuilder<'tcx> {\n+struct LintLevelMapBuilder<'a, 'tcx> {\n     levels: levels::LintLevelsBuilder<'tcx>,\n     tcx: TyCtxt<'tcx>,\n+    store: &'a LintStore,\n }\n \n-impl LintLevelMapBuilder<'tcx> {\n+impl LintLevelMapBuilder<'_, '_> {\n     fn with_lint_attrs<F>(&mut self,\n                           id: hir::HirId,\n                           attrs: &[ast::Attribute],\n                           f: F)\n         where F: FnOnce(&mut Self)\n     {\n-        let push = self.levels.push(attrs);\n+        let push = self.levels.push(attrs, self.store);\n         if push.changed {\n             self.levels.register_id(id);\n         }\n@@ -793,7 +818,7 @@ impl LintLevelMapBuilder<'tcx> {\n     }\n }\n \n-impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'tcx> {\n+impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n         intravisit::NestedVisitorMap::All(&self.tcx.hir())\n     }"}, {"sha": "d5558db2397e797cd14f4297ebc0bc1a07fa2eb1", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -16,7 +16,7 @@ use syntax::ast;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc_target::spec::Target;\n-use rustc_data_structures::sync::{self, MetadataRef, Lrc};\n+use rustc_data_structures::sync::{self, MetadataRef};\n use rustc_macros::HashStable;\n \n pub use self::NativeLibraryKind::*;\n@@ -191,6 +191,8 @@ pub trait MetadataLoader {\n                           -> Result<MetadataRef, String>;\n }\n \n+pub type MetadataLoaderDyn = dyn MetadataLoader + Sync;\n+\n /// A store of Rust crates, through which their metadata can be accessed.\n ///\n /// Note that this trait should probably not be expanding today. All new\n@@ -201,13 +203,13 @@ pub trait MetadataLoader {\n /// (it'd break incremental compilation) and should only be called pre-HIR (e.g.\n /// during resolve)\n pub trait CrateStore {\n-    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Lrc<dyn Any>;\n+    fn crate_data_as_any(&self, cnum: CrateNum) -> &dyn Any;\n \n     // resolve\n     fn def_key(&self, def: DefId) -> DefKey;\n     fn def_path(&self, def: DefId) -> hir_map::DefPath;\n     fn def_path_hash(&self, def: DefId) -> hir_map::DefPathHash;\n-    fn def_path_table(&self, cnum: CrateNum) -> Lrc<DefPathTable>;\n+    fn def_path_table(&self, cnum: CrateNum) -> &DefPathTable;\n \n     // \"queries\" used in resolve that aren't tracked for incremental compilation\n     fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol;"}, {"sha": "aa8ac4902a8947bc758d8404fe771a490ef73480", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -353,11 +353,14 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n-        src: impl IntoIterator<Item=u8, IntoIter: iter::ExactSizeIterator>,\n+        src: impl IntoIterator<Item=u8>,\n     ) -> InterpResult<'tcx>\n     {\n         let mut src = src.into_iter();\n-        let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(src.len() as u64))?;\n+        let (lower, upper) = src.size_hint();\n+        let len = upper.expect(\"can only write bounded iterators\");\n+        assert_eq!(lower, len, \"can only write iterators with a precise length\");\n+        let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(len as u64))?;\n         // `zip` would stop when the first iterator ends; we want to definitely\n         // cover all of `bytes`.\n         for dest in bytes {"}, {"sha": "08e7001681c290f89ca569b13f91880cdca4571a", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -37,7 +37,7 @@ use std::slice;\n use std::vec::IntoIter;\n use std::{iter, mem, option, u32};\n use syntax::ast::Name;\n-use syntax::symbol::{InternedString, Symbol};\n+use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n \n pub use crate::mir::interpret::AssertMessage;\n@@ -2736,8 +2736,8 @@ pub enum UnsafetyViolationKind {\n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UnsafetyViolation {\n     pub source_info: SourceInfo,\n-    pub description: InternedString,\n-    pub details: InternedString,\n+    pub description: Symbol,\n+    pub details: Symbol,\n     pub kind: UnsafetyViolationKind,\n }\n "}, {"sha": "58f99667cb3a417d6dd7606d787600b83c371a81", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,6 +1,6 @@\n use crate::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use crate::hir::HirId;\n-use syntax::symbol::InternedString;\n+use syntax::symbol::Symbol;\n use syntax::attr::InlineAttr;\n use syntax::source_map::Span;\n use crate::ty::{Instance, InstanceDef, TyCtxt, SymbolName, subst::InternalSubsts};\n@@ -80,7 +80,7 @@ impl<'tcx> MonoItem<'tcx> {\n             MonoItem::GlobalAsm(hir_id) => {\n                 let def_id = tcx.hir().local_def_id(hir_id);\n                 SymbolName {\n-                    name: InternedString::intern(&format!(\"global_asm_{:?}\", def_id))\n+                    name: Symbol::intern(&format!(\"global_asm_{:?}\", def_id))\n                 }\n             }\n         }\n@@ -246,7 +246,7 @@ pub struct CodegenUnit<'tcx> {\n     /// name be unique amongst **all** crates. Therefore, it should\n     /// contain something unique to this crate (e.g., a module path)\n     /// as well as the crate name and disambiguator.\n-    name: InternedString,\n+    name: Symbol,\n     items: FxHashMap<MonoItem<'tcx>, (Linkage, Visibility)>,\n     size_estimate: Option<usize>,\n }\n@@ -294,19 +294,19 @@ impl_stable_hash_for!(enum self::Visibility {\n });\n \n impl<'tcx> CodegenUnit<'tcx> {\n-    pub fn new(name: InternedString) -> CodegenUnit<'tcx> {\n+    pub fn new(name: Symbol) -> CodegenUnit<'tcx> {\n         CodegenUnit {\n             name: name,\n             items: Default::default(),\n             size_estimate: None,\n         }\n     }\n \n-    pub fn name(&self) -> &InternedString {\n-        &self.name\n+    pub fn name(&self) -> Symbol {\n+        self.name\n     }\n \n-    pub fn set_name(&mut self, name: InternedString) {\n+    pub fn set_name(&mut self, name: Symbol) {\n         self.name = name;\n     }\n \n@@ -474,7 +474,7 @@ impl CodegenUnitNameBuilder<'tcx> {\n                                    cnum: CrateNum,\n                                    components: I,\n                                    special_suffix: Option<S>)\n-                                   -> InternedString\n+                                   -> Symbol\n         where I: IntoIterator<Item=C>,\n               C: fmt::Display,\n               S: fmt::Display,\n@@ -487,7 +487,7 @@ impl CodegenUnitNameBuilder<'tcx> {\n             cgu_name\n         } else {\n             let cgu_name = &cgu_name.as_str()[..];\n-            InternedString::intern(&CodegenUnit::mangle_name(cgu_name))\n+            Symbol::intern(&CodegenUnit::mangle_name(cgu_name))\n         }\n     }\n \n@@ -497,7 +497,7 @@ impl CodegenUnitNameBuilder<'tcx> {\n                                              cnum: CrateNum,\n                                              components: I,\n                                              special_suffix: Option<S>)\n-                                             -> InternedString\n+                                             -> Symbol\n         where I: IntoIterator<Item=C>,\n               C: fmt::Display,\n               S: fmt::Display,\n@@ -543,6 +543,6 @@ impl CodegenUnitNameBuilder<'tcx> {\n             write!(cgu_name, \".{}\", special_suffix).unwrap();\n         }\n \n-        InternedString::intern(&cgu_name[..])\n+        Symbol::intern(&cgu_name[..])\n     }\n }"}, {"sha": "fdca6d0e17a1d03a1d49793ce4bd0f3cae1849f9", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -15,7 +15,7 @@ use crate::traits::query::{\n };\n \n use std::borrow::Cow;\n-use syntax_pos::symbol::InternedString;\n+use syntax_pos::symbol::Symbol;\n \n // Each of these queries corresponds to a function pointer field in the\n // `Providers` struct for requesting a value of that type, and a method\n@@ -924,7 +924,7 @@ rustc_queries! {\n             desc { \"collect_and_partition_mono_items\" }\n         }\n         query is_codegened_item(_: DefId) -> bool {}\n-        query codegen_unit(_: InternedString) -> Arc<CodegenUnit<'tcx>> {\n+        query codegen_unit(_: Symbol) -> Arc<CodegenUnit<'tcx>> {\n             no_force\n             desc { \"codegen_unit\" }\n         }"}, {"sha": "33b9ddaa622303f2c553810f0f686e29699a28ca", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1149,7 +1149,8 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n     target_cpu: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"select target processor (`rustc --print target-cpus` for details)\"),\n     target_feature: String = (String::new(), parse_string, [TRACKED],\n-        \"target specific attributes (`rustc --print target-features` for details)\"),\n+        \"target specific attributes. (`rustc --print target-features` for details). \\\n+        This feature is unsafe.\"),\n     passes: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n         \"a list of extra LLVM passes to run (space separated)\"),\n     llvm_args: Vec<String> = (Vec::new(), parse_list, [TRACKED],"}, {"sha": "bd2460cfab116ed3b17de3c7c591ce2f78495aae", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -14,7 +14,7 @@ use crate::util::common::{duration_to_secs_str, ErrorReported};\n \n use rustc_data_structures::base_n;\n use rustc_data_structures::sync::{\n-    self, Lrc, Lock, OneThread, Once, RwLock, AtomicU64, AtomicUsize, Ordering,\n+    self, Lrc, Lock, OneThread, Once, AtomicU64, AtomicUsize, Ordering,\n     Ordering::SeqCst,\n };\n \n@@ -77,9 +77,11 @@ pub struct Session {\n     /// if the value stored here has been affected by path remapping.\n     pub working_dir: (PathBuf, bool),\n \n-    // FIXME: `lint_store` and `buffered_lints` are not thread-safe,\n-    // but are only used in a single thread.\n-    pub lint_store: RwLock<lint::LintStore>,\n+    /// This is intended to be used from a single thread.\n+    ///\n+    /// FIXME: there was a previous comment about this not being thread safe,\n+    /// but it's not clear how or why that's the case. The LintBuffer itself is certainly thread\n+    /// safe at least from a \"Rust safety\" standpoint.\n     pub buffered_lints: Lock<Option<lint::LintBuffer>>,\n \n     /// Set of `(DiagnosticId, Option<Span>, message)` tuples tracking\n@@ -1213,7 +1215,6 @@ fn build_session_(\n         sysroot,\n         local_crate_source_file,\n         working_dir,\n-        lint_store: RwLock::new(lint::LintStore::new()),\n         buffered_lints: Lock::new(Some(Default::default())),\n         one_time_diagnostics: Default::default(),\n         plugin_llvm_passes: OneThread::new(RefCell::new(Vec::new())),"}, {"sha": "e684cdc0a3872d530432ece240fa7ef694649165", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -406,7 +406,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 },\n                 GenericParamDefKind::Lifetime => continue,\n             };\n-            let name = param.name.as_symbol();\n+            let name = param.name;\n             flags.push((name, Some(value)));\n         }\n \n@@ -793,15 +793,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                     ty::Predicate::ObjectSafe(trait_def_id) => {\n                         let violations = self.tcx.object_safety_violations(trait_def_id);\n-                        if let Some(err) = self.tcx.report_object_safety_error(\n+                        self.tcx.report_object_safety_error(\n                             span,\n                             trait_def_id,\n                             violations,\n-                        ) {\n-                            err\n-                        } else {\n-                            return;\n-                        }\n+                        )\n                     }\n \n                     ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n@@ -937,11 +933,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n             TraitNotObjectSafe(did) => {\n                 let violations = self.tcx.object_safety_violations(did);\n-                if let Some(err) = self.tcx.report_object_safety_error(span, did, violations) {\n-                    err\n-                } else {\n-                    return;\n-                }\n+                self.tcx.report_object_safety_error(span, did, violations)\n             }\n \n             // already reported in the query\n@@ -1665,11 +1657,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         span: Span,\n         trait_def_id: DefId,\n         violations: Vec<ObjectSafetyViolation>,\n-    ) -> Option<DiagnosticBuilder<'tcx>> {\n-        if self.sess.trait_methods_not_found.borrow().contains(&span) {\n-            // Avoid emitting error caused by non-existing method (#58734)\n-            return None;\n-        }\n+    ) -> DiagnosticBuilder<'tcx> {\n         let trait_str = self.def_path_str(trait_def_id);\n         let span = self.sess.source_map().def_span(span);\n         let mut err = struct_span_err!(\n@@ -1687,7 +1675,13 @@ impl<'tcx> TyCtxt<'tcx> {\n                 };\n             }\n         }\n-        Some(err)\n+\n+        if self.sess.trait_methods_not_found.borrow().contains(&span) {\n+            // Avoid emitting error caused by non-existing method (#58734)\n+            err.cancel();\n+        }\n+\n+        err\n     }\n }\n \n@@ -2098,6 +2092,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 err.note(&format!(\"required for the cast to the object type `{}`\",\n                                   self.ty_to_string(object_ty)));\n             }\n+            ObligationCauseCode::Coercion { source: _, target } => {\n+                err.note(&format!(\"required by cast to type `{}`\",\n+                                  self.ty_to_string(target)));\n+            }\n             ObligationCauseCode::RepeatVec => {\n                 err.note(\"the `Copy` trait is required because the \\\n                           repeated element will be copied\");"}, {"sha": "eb4b114eb301ca5db79a4d5a6ab2625bae3913a7", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -188,6 +188,9 @@ pub enum ObligationCauseCode<'tcx> {\n     /// Obligation incurred due to an object cast.\n     ObjectCastObligation(/* Object type */ Ty<'tcx>),\n \n+    /// Obligation incurred due to a coercion.\n+    Coercion { source: Ty<'tcx>, target: Ty<'tcx> },\n+\n     // Various cases where expressions must be sized/copy/etc:\n     /// L = X implies that L is Sized\n     AssignmentLhsSized,"}, {"sha": "e42c3a63541ccdea8ccdc4f16360329452e84d3c", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -19,7 +19,7 @@ use crate::ty::subst::{Subst, InternalSubsts};\n use std::borrow::Cow;\n use std::iter::{self};\n use syntax::ast::{self};\n-use syntax::symbol::InternedString;\n+use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n@@ -560,7 +560,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // are implemented\n         let unsized_self_ty: Ty<'tcx> = self.mk_ty_param(\n             ::std::u32::MAX,\n-            InternedString::intern(\"RustaceansAreAwesome\"),\n+            Symbol::intern(\"RustaceansAreAwesome\"),\n         );\n \n         // `Receiver[Self => U]`"}, {"sha": "c1c814f9b0371218a0415b78d2b8479cd394cd4e", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -250,7 +250,7 @@ impl<'tcx> OnUnimplementedFormatString {\n                     Position::ArgumentNamed(s) if s == sym::from_desugaring => (),\n                     // So is `{A}` if A is a type parameter\n                     Position::ArgumentNamed(s) => match generics.params.iter().find(|param| {\n-                        param.name.as_symbol() == s\n+                        param.name == s\n                     }) {\n                         Some(_) => (),\n                         None => {\n@@ -289,7 +289,7 @@ impl<'tcx> OnUnimplementedFormatString {\n                 },\n                 GenericParamDefKind::Lifetime => return None\n             };\n-            let name = param.name.as_symbol();\n+            let name = param.name;\n             Some((name, value))\n         }).collect::<FxHashMap<Symbol, String>>();\n         let empty_string = String::new();"}, {"sha": "d8a27f1e04051726e1c3c86f5936f9bf8b74ab61", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -2246,7 +2246,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     }\n \n                     if let Some(principal) = data.principal() {\n-                        principal.with_self_ty(self.tcx(), self_ty)\n+                        if !self.infcx.tcx.features().object_safe_for_dispatch {\n+                            principal.with_self_ty(self.tcx(), self_ty)\n+                        } else if self.tcx().is_object_safe(principal.def_id()) {\n+                            principal.with_self_ty(self.tcx(), self_ty)\n+                        } else {\n+                            return;\n+                        }\n                     } else {\n                         // Only auto-trait bounds exist.\n                         return;"}, {"sha": "18db3c8d10b7c3d6bda4289fb9433dc0ce06f502", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -4,7 +4,7 @@ use crate::traits;\n use crate::traits::project::Normalized;\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::{self, Lift, Ty, TyCtxt};\n-use syntax::symbol::InternedString;\n+use syntax::symbol::Symbol;\n \n use std::fmt;\n use std::rc::Rc;\n@@ -261,11 +261,11 @@ impl fmt::Display for traits::QuantifierKind {\n /// for debug output in tests anyway.\n struct BoundNamesCollector {\n     // Just sort by name because `BoundRegion::BrNamed` does not have a `BoundVar` index anyway.\n-    regions: BTreeSet<InternedString>,\n+    regions: BTreeSet<Symbol>,\n \n     // Sort by `BoundVar` index, so usually this should be equivalent to the order given\n     // by the list of type parameters.\n-    types: BTreeMap<u32, InternedString>,\n+    types: BTreeMap<u32, Symbol>,\n \n     binder_index: ty::DebruijnIndex,\n }\n@@ -319,7 +319,7 @@ impl<'tcx> TypeVisitor<'tcx> for BoundNamesCollector {\n                     match bound_ty.kind {\n                         ty::BoundTyKind::Param(name) => name,\n                         ty::BoundTyKind::Anon =>\n-                            InternedString::intern(&format!(\"^{}\", bound_ty.var.as_u32()),\n+                            Symbol::intern(&format!(\"^{}\", bound_ty.var.as_u32()),\n                         ),\n                     }\n                 );\n@@ -340,7 +340,7 @@ impl<'tcx> TypeVisitor<'tcx> for BoundNamesCollector {\n                     }\n \n                     ty::BoundRegion::BrAnon(var) => {\n-                        self.regions.insert(InternedString::intern(&format!(\"'^{}\", var)));\n+                        self.regions.insert(Symbol::intern(&format!(\"'^{}\", var)));\n                     }\n \n                     _ => (),\n@@ -481,6 +481,10 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n                    .and_then(|r| Some(super::ObjectTypeBound(ty, r)))\n             ),\n             super::ObjectCastObligation(ty) => tcx.lift(&ty).map(super::ObjectCastObligation),\n+            super::Coercion { source, target } => Some(super::Coercion {\n+                source: tcx.lift(&source)?,\n+                target: tcx.lift(&target)?,\n+            }),\n             super::AssignmentLhsSized => Some(super::AssignmentLhsSized),\n             super::TupleInitializerSized => Some(super::TupleInitializerSized),\n             super::StructInitializerSized => Some(super::StructInitializerSized),"}, {"sha": "f99298281fecc5e5b7e203d5827ca148e955a4e8", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -72,7 +72,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::source_map::MultiSpan;\n use syntax::feature_gate;\n-use syntax::symbol::{Symbol, InternedString, kw, sym};\n+use syntax::symbol::{Symbol, kw, sym};\n use syntax_pos::Span;\n \n pub struct AllArenas {\n@@ -949,7 +949,7 @@ impl<'tcx> CommonTypes<'tcx> {\n             f64: mk(Float(ast::FloatTy::F64)),\n             self_param: mk(ty::Param(ty::ParamTy {\n                 index: 0,\n-                name: kw::SelfUpper.as_interned_str(),\n+                name: kw::SelfUpper,\n             })),\n \n             trait_object_dummy_self: mk(Infer(ty::FreshTy(0))),\n@@ -1027,10 +1027,12 @@ pub struct GlobalCtxt<'tcx> {\n \n     interners: CtxtInterners<'tcx>,\n \n-    cstore: &'tcx CrateStoreDyn,\n+    cstore: Box<CrateStoreDyn>,\n \n     pub sess: &'tcx Session,\n \n+    pub lint_store: Lrc<lint::LintStore>,\n+\n     pub dep_graph: DepGraph,\n \n     pub prof: SelfProfilerRef,\n@@ -1192,11 +1194,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// reference to the context, to allow formatting values that need it.\n     pub fn create_global_ctxt(\n         s: &'tcx Session,\n-        cstore: &'tcx CrateStoreDyn,\n+        lint_store: Lrc<lint::LintStore>,\n         local_providers: ty::query::Providers<'tcx>,\n         extern_providers: ty::query::Providers<'tcx>,\n         arenas: &'tcx AllArenas,\n-        resolutions: ty::Resolutions,\n+        resolutions: ty::ResolverOutputs,\n         hir: hir_map::Map<'tcx>,\n         on_disk_query_result_cache: query::OnDiskCache<'tcx>,\n         crate_name: &str,\n@@ -1210,34 +1212,28 @@ impl<'tcx> TyCtxt<'tcx> {\n         let common_lifetimes = CommonLifetimes::new(&interners);\n         let common_consts = CommonConsts::new(&interners, &common_types);\n         let dep_graph = hir.dep_graph.clone();\n-        let max_cnum = cstore.crates_untracked().iter().map(|c| c.as_usize()).max().unwrap_or(0);\n+        let cstore = resolutions.cstore;\n+        let crates = cstore.crates_untracked();\n+        let max_cnum = crates.iter().map(|c| c.as_usize()).max().unwrap_or(0);\n         let mut providers = IndexVec::from_elem_n(extern_providers, max_cnum + 1);\n         providers[LOCAL_CRATE] = local_providers;\n \n         let def_path_hash_to_def_id = if s.opts.build_dep_graph() {\n-            let upstream_def_path_tables: Vec<(CrateNum, Lrc<_>)> = cstore\n-                .crates_untracked()\n+            let def_path_tables = crates\n                 .iter()\n                 .map(|&cnum| (cnum, cstore.def_path_table(cnum)))\n-                .collect();\n-\n-            let def_path_tables = || {\n-                upstream_def_path_tables\n-                    .iter()\n-                    .map(|&(cnum, ref rc)| (cnum, &**rc))\n-                    .chain(iter::once((LOCAL_CRATE, hir.definitions().def_path_table())))\n-            };\n+                .chain(iter::once((LOCAL_CRATE, hir.definitions().def_path_table())));\n \n             // Precompute the capacity of the hashmap so we don't have to\n             // re-allocate when populating it.\n-            let capacity = def_path_tables().map(|(_, t)| t.size()).sum::<usize>();\n+            let capacity = def_path_tables.clone().map(|(_, t)| t.size()).sum::<usize>();\n \n             let mut map: FxHashMap<_, _> = FxHashMap::with_capacity_and_hasher(\n                 capacity,\n                 ::std::default::Default::default()\n             );\n \n-            for (cnum, def_path_table) in def_path_tables() {\n+            for (cnum, def_path_table) in def_path_tables {\n                 def_path_table.add_def_path_hashes_to(cnum, &mut map);\n             }\n \n@@ -1255,6 +1251,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         GlobalCtxt {\n             sess: s,\n+            lint_store,\n             cstore,\n             arena: WorkerLocal::new(|_| Arena::default()),\n             interners,\n@@ -1413,8 +1410,8 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     // Note that this is *untracked* and should only be used within the query\n     // system if the result is otherwise tracked through queries\n-    pub fn crate_data_as_rc_any(self, cnum: CrateNum) -> Lrc<dyn Any> {\n-        self.cstore.crate_data_as_rc_any(cnum)\n+    pub fn crate_data_as_any(self, cnum: CrateNum) -> &'tcx dyn Any {\n+        self.cstore.crate_data_as_any(cnum)\n     }\n \n     #[inline(always)]\n@@ -1424,7 +1421,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         StableHashingContext::new(self.sess,\n                                   krate,\n                                   self.hir().definitions(),\n-                                  self.cstore)\n+                                  &*self.cstore)\n     }\n \n     // This method makes sure that we have a DepNode and a Fingerprint for\n@@ -2552,15 +2549,15 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_ty_param(self, index: u32, name: InternedString) -> Ty<'tcx> {\n+    pub fn mk_ty_param(self, index: u32, name: Symbol) -> Ty<'tcx> {\n         self.mk_ty(Param(ParamTy { index, name: name }))\n     }\n \n     #[inline]\n     pub fn mk_const_param(\n         self,\n         index: u32,\n-        name: InternedString,\n+        name: Symbol,\n         ty: Ty<'tcx>\n     ) -> &'tcx Const<'tcx> {\n         self.mk_const(ty::Const {"}, {"sha": "77613b548cfdb438b55b6f9796dd71abc4d82934", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -45,7 +45,7 @@ pub enum TypeError<'tcx> {\n     ProjectionMismatched(ExpectedFound<DefId>),\n     ProjectionBoundsLength(ExpectedFound<usize>),\n     ExistentialMismatch(ExpectedFound<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>),\n-\n+    ObjectUnsafeCoercion(DefId),\n     ConstMismatch(ExpectedFound<&'tcx ty::Const<'tcx>>),\n \n     IntrinsicCast,\n@@ -178,6 +178,7 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             IntrinsicCast => {\n                 write!(f, \"cannot coerce intrinsics to function pointers\")\n             }\n+            ObjectUnsafeCoercion(_) => write!(f, \"coercion to object-unsafe trait object\"),\n         }\n     }\n }"}, {"sha": "4660e8025d48ef9a1a0a048121b646dff50be094", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 149, "deletions": 11, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -4,7 +4,7 @@ pub use self::Variance::*;\n pub use self::AssocItemContainer::*;\n pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n-pub use self::fold::TypeFoldable;\n+pub use self::fold::{TypeFoldable, TypeVisitor};\n \n use crate::hir::{map as hir_map, GlobMap, TraitMap};\n use crate::hir::Node;\n@@ -15,6 +15,7 @@ use rustc_macros::HashStable;\n use crate::ich::Fingerprint;\n use crate::ich::StableHashingContext;\n use crate::infer::canonical::Canonical;\n+use crate::middle::cstore::CrateStoreDyn;\n use crate::middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n use crate::mir::Body;\n@@ -46,11 +47,11 @@ use std::ops::Range;\n use syntax::ast::{self, Name, Ident, NodeId};\n use syntax::attr;\n use syntax_expand::hygiene::ExpnId;\n-use syntax::symbol::{kw, sym, Symbol, InternedString};\n+use syntax::symbol::{kw, sym, Symbol};\n use syntax_pos::Span;\n \n use smallvec;\n-use rustc_data_structures::fx::FxIndexMap;\n+use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use rustc_index::vec::{Idx, IndexVec};\n \n@@ -119,8 +120,9 @@ mod sty;\n \n // Data types\n \n-#[derive(Clone)]\n-pub struct Resolutions {\n+pub struct ResolverOutputs {\n+    pub definitions: hir_map::Definitions,\n+    pub cstore: Box<CrateStoreDyn>,\n     pub extern_crate_map: NodeMap<CrateNum>,\n     pub trait_map: TraitMap,\n     pub maybe_unused_trait_imports: NodeSet,\n@@ -849,7 +851,7 @@ impl ty::EarlyBoundRegion {\n     /// Does this early bound region have a name? Early bound regions normally\n     /// always have names except when using anonymous lifetimes (`'_`).\n     pub fn has_name(&self) -> bool {\n-        self.name != kw::UnderscoreLifetime.as_interned_str()\n+        self.name != kw::UnderscoreLifetime\n     }\n }\n \n@@ -866,7 +868,7 @@ pub enum GenericParamDefKind {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct GenericParamDef {\n-    pub name: InternedString,\n+    pub name: Symbol,\n     pub def_id: DefId,\n     pub index: u32,\n \n@@ -3019,7 +3021,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     }),\n                 _ => def_key.disambiguated_data.data.get_opt_name().unwrap_or_else(|| {\n                     bug!(\"item_name: no name for {:?}\", self.def_path(id));\n-                }).as_symbol(),\n+                }),\n             }\n         }\n     }\n@@ -3393,6 +3395,129 @@ fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n     fn_like.asyncness()\n }\n \n+pub enum NonStructuralMatchTy<'tcx> {\n+    Adt(&'tcx AdtDef),\n+    Param,\n+}\n+\n+/// This method traverses the structure of `ty`, trying to find an\n+/// instance of an ADT (i.e. struct or enum) that was declared without\n+/// the `#[structural_match]` attribute, or a generic type parameter\n+/// (which cannot be determined to be `structural_match`).\n+///\n+/// The \"structure of a type\" includes all components that would be\n+/// considered when doing a pattern match on a constant of that\n+/// type.\n+///\n+///  * This means this method descends into fields of structs/enums,\n+///    and also descends into the inner type `T` of `&T` and `&mut T`\n+///\n+///  * The traversal doesn't dereference unsafe pointers (`*const T`,\n+///    `*mut T`), and it does not visit the type arguments of an\n+///    instantiated generic like `PhantomData<T>`.\n+///\n+/// The reason we do this search is Rust currently require all ADTs\n+/// reachable from a constant's type to be annotated with\n+/// `#[structural_match]`, an attribute which essentially says that\n+/// the implementation of `PartialEq::eq` behaves *equivalently* to a\n+/// comparison against the unfolded structure.\n+///\n+/// For more background on why Rust has this requirement, and issues\n+/// that arose when the requirement was not enforced completely, see\n+/// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n+pub fn search_for_structural_match_violation<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Option<NonStructuralMatchTy<'tcx>> {\n+    let mut search = Search { tcx, found: None, seen: FxHashSet::default() };\n+    ty.visit_with(&mut search);\n+    return search.found;\n+\n+    struct Search<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+\n+        // Records the first ADT or type parameter we find without `#[structural_match`.\n+        found: Option<NonStructuralMatchTy<'tcx>>,\n+\n+        // Tracks ADTs previously encountered during search, so that\n+        // we will not recurse on them again.\n+        seen: FxHashSet<hir::def_id::DefId>,\n+    }\n+\n+    impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n+        fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+            debug!(\"Search visiting ty: {:?}\", ty);\n+\n+            let (adt_def, substs) = match ty.kind {\n+                ty::Adt(adt_def, substs) => (adt_def, substs),\n+                ty::Param(_) => {\n+                    self.found = Some(NonStructuralMatchTy::Param);\n+                    return true; // Stop visiting.\n+                }\n+                ty::RawPtr(..) => {\n+                    // `#[structural_match]` ignores substructure of\n+                    // `*const _`/`*mut _`, so skip super_visit_with\n+                    //\n+                    // (But still tell caller to continue search.)\n+                    return false;\n+                }\n+                ty::FnDef(..) | ty::FnPtr(..) => {\n+                    // types of formals and return in `fn(_) -> _` are also irrelevant\n+                    //\n+                    // (But still tell caller to continue search.)\n+                    return false;\n+                }\n+                ty::Array(_, n) if n.try_eval_usize(self.tcx, ty::ParamEnv::reveal_all()) == Some(0)\n+                => {\n+                    // rust-lang/rust#62336: ignore type of contents\n+                    // for empty array.\n+                    return false;\n+                }\n+                _ => {\n+                    ty.super_visit_with(self);\n+                    return false;\n+                }\n+            };\n+\n+            if !self.tcx.has_attr(adt_def.did, sym::structural_match) {\n+                self.found = Some(NonStructuralMatchTy::Adt(&adt_def));\n+                debug!(\"Search found adt_def: {:?}\", adt_def);\n+                return true; // Stop visiting.\n+            }\n+\n+            if !self.seen.insert(adt_def.did) {\n+                debug!(\"Search already seen adt_def: {:?}\", adt_def);\n+                // let caller continue its search\n+                return false;\n+            }\n+\n+            // `#[structural_match]` does not care about the\n+            // instantiation of the generics in an ADT (it\n+            // instead looks directly at its fields outside\n+            // this match), so we skip super_visit_with.\n+            //\n+            // (Must not recur on substs for `PhantomData<T>` cf\n+            // rust-lang/rust#55028 and rust-lang/rust#55837; but also\n+            // want to skip substs when only uses of generic are\n+            // behind unsafe pointers `*const T`/`*mut T`.)\n+\n+            // even though we skip super_visit_with, we must recur on\n+            // fields of ADT.\n+            let tcx = self.tcx;\n+            for field_ty in adt_def.all_fields().map(|field| field.ty(tcx, substs)) {\n+                if field_ty.visit_with(self) {\n+                    // found an ADT without `#[structural_match]`; halt visiting!\n+                    assert!(self.found.is_some());\n+                    return true;\n+                }\n+            }\n+\n+            // Even though we do not want to recur on substs, we do\n+            // want our caller to continue its own search.\n+            false\n+        }\n+    }\n+}\n \n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     context::provide(providers);\n@@ -3429,11 +3554,11 @@ pub struct CrateInherentImpls {\n     pub inherent_impls: DefIdMap<Vec<DefId>>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub struct SymbolName {\n     // FIXME: we don't rely on interning or equality here - better have\n     // this be a `&'tcx str`.\n-    pub name: InternedString\n+    pub name: Symbol\n }\n \n impl_stable_hash_for!(struct self::SymbolName {\n@@ -3443,11 +3568,24 @@ impl_stable_hash_for!(struct self::SymbolName {\n impl SymbolName {\n     pub fn new(name: &str) -> SymbolName {\n         SymbolName {\n-            name: InternedString::intern(name)\n+            name: Symbol::intern(name)\n         }\n     }\n }\n \n+impl PartialOrd for SymbolName {\n+    fn partial_cmp(&self, other: &SymbolName) -> Option<Ordering> {\n+        self.name.as_str().partial_cmp(&other.name.as_str())\n+    }\n+}\n+\n+/// Ordering must use the chars to ensure reproducible builds.\n+impl Ord for SymbolName {\n+    fn cmp(&self, other: &SymbolName) -> Ordering {\n+        self.name.as_str().cmp(&other.name.as_str())\n+    }\n+}\n+\n impl fmt::Display for SymbolName {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(&self.name, fmt)"}, {"sha": "e72916de6a9c7a0311c6d3065084b79d27dfba36", "filename": "src/librustc/ty/print/obsolete.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -218,9 +218,9 @@ impl DefPathBasedNames<'tcx> {\n         // foo::bar::ItemName::\n         for part in self.tcx.def_path(def_id).data {\n             if self.omit_disambiguators {\n-                write!(output, \"{}::\", part.data.as_interned_str()).unwrap();\n+                write!(output, \"{}::\", part.data.as_symbol()).unwrap();\n             } else {\n-                write!(output, \"{}[{}]::\", part.data.as_interned_str(), part.disambiguator)\n+                write!(output, \"{}[{}]::\", part.data.as_symbol(), part.disambiguator)\n                     .unwrap();\n             }\n         }"}, {"sha": "8a98a5d83615fbf4e2d8985afd7f0ffbf6adc4c7", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -14,7 +14,7 @@ use rustc_apfloat::Float;\n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n use syntax::attr::{SignedInt, UnsignedInt};\n-use syntax::symbol::{kw, InternedString};\n+use syntax::symbol::{kw, Symbol};\n \n use std::cell::Cell;\n use std::fmt::{self, Write as _};\n@@ -384,15 +384,15 @@ pub trait PrettyPrinter<'tcx>:\n                 let reexport = self.tcx().item_children(visible_parent)\n                     .iter()\n                     .find(|child| child.res.def_id() == def_id)\n-                    .map(|child| child.ident.as_interned_str());\n+                    .map(|child| child.ident.name);\n                 if let Some(reexport) = reexport {\n                     *name = reexport;\n                 }\n             }\n             // Re-exported `extern crate` (#43189).\n             DefPathData::CrateRoot => {\n                 data = DefPathData::TypeNs(\n-                    self.tcx().original_crate_name(def_id.krate).as_interned_str(),\n+                    self.tcx().original_crate_name(def_id.krate),\n                 );\n             }\n             _ => {}\n@@ -992,7 +992,7 @@ pub struct FmtPrinterData<'a, 'tcx, F> {\n     empty_path: bool,\n     in_value: bool,\n \n-    used_region_names: FxHashSet<InternedString>,\n+    used_region_names: FxHashSet<Symbol>,\n     region_index: usize,\n     binder_depth: usize,\n \n@@ -1222,7 +1222,7 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n \n         // FIXME(eddyb) `name` should never be empty, but it\n         // currently is for `extern { ... }` \"foreign modules\".\n-        let name = disambiguated_data.data.as_interned_str().as_str();\n+        let name = disambiguated_data.data.as_symbol().as_str();\n         if !name.is_empty() {\n             if !self.empty_path {\n                 write!(self, \"::\")?;\n@@ -1332,16 +1332,16 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n \n         match *region {\n             ty::ReEarlyBound(ref data) => {\n-                data.name.as_symbol() != kw::Invalid &&\n-                data.name.as_symbol() != kw::UnderscoreLifetime\n+                data.name != kw::Invalid &&\n+                data.name != kw::UnderscoreLifetime\n             }\n \n             ty::ReLateBound(_, br) |\n             ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n             ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n                 if let ty::BrNamed(_, name) = br {\n-                    if name.as_symbol() != kw::Invalid &&\n-                       name.as_symbol() != kw::UnderscoreLifetime {\n+                    if name != kw::Invalid &&\n+                       name != kw::UnderscoreLifetime {\n                         return true;\n                     }\n                 }\n@@ -1397,7 +1397,7 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n         // `explain_region()` or `note_and_explain_region()`.\n         match *region {\n             ty::ReEarlyBound(ref data) => {\n-                if data.name.as_symbol() != kw::Invalid {\n+                if data.name != kw::Invalid {\n                     p!(write(\"{}\", data.name));\n                     return Ok(self);\n                 }\n@@ -1406,8 +1406,8 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n             ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n             ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n                 if let ty::BrNamed(_, name) = br {\n-                    if name.as_symbol() != kw::Invalid &&\n-                       name.as_symbol() != kw::UnderscoreLifetime {\n+                    if name != kw::Invalid &&\n+                       name != kw::UnderscoreLifetime {\n                         p!(write(\"{}\", name));\n                         return Ok(self);\n                     }\n@@ -1474,11 +1474,11 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n     where\n         T: Print<'tcx, Self, Output = Self, Error = fmt::Error> + TypeFoldable<'tcx>,\n     {\n-        fn name_by_region_index(index: usize) -> InternedString {\n+        fn name_by_region_index(index: usize) -> Symbol {\n             match index {\n-                0 => InternedString::intern(\"'r\"),\n-                1 => InternedString::intern(\"'s\"),\n-                i => InternedString::intern(&format!(\"'t{}\", i-2)),\n+                0 => Symbol::intern(\"'r\"),\n+                1 => Symbol::intern(\"'s\"),\n+                i => Symbol::intern(&format!(\"'t{}\", i-2)),\n             }\n         }\n \n@@ -1541,7 +1541,7 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n         where T: TypeFoldable<'tcx>\n     {\n \n-        struct LateBoundRegionNameCollector<'a>(&'a mut FxHashSet<InternedString>);\n+        struct LateBoundRegionNameCollector<'a>(&'a mut FxHashSet<Symbol>);\n         impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector<'_> {\n             fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n                 match *r {"}, {"sha": "0a217e9ae666dd42191a885ce6aabb7411e6bea3", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -9,7 +9,7 @@ use crate::ty::fast_reject::SimplifiedType;\n use crate::mir;\n \n use syntax_pos::{Span, DUMMY_SP};\n-use syntax_pos::symbol::InternedString;\n+use syntax_pos::symbol::Symbol;\n \n /// The `Key` trait controls what types can legally be used as the key\n /// for a query.\n@@ -188,7 +188,7 @@ impl<'tcx> Key for traits::Environment<'tcx> {\n     }\n }\n \n-impl Key for InternedString {\n+impl Key for Symbol {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }"}, {"sha": "9b15ad560b5d25f751eea19788be91b410aafbae", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -55,7 +55,6 @@ use std::ops::Deref;\n use std::sync::Arc;\n use std::any::type_name;\n use syntax_pos::{Span, DUMMY_SP};\n-use syntax_pos::symbol::InternedString;\n use syntax::attr;\n use syntax::ast;\n use syntax::feature_gate;"}, {"sha": "f0d1639f72f59cf3cafbb826c9419703e41dcd8a", "filename": "src/librustc/ty/query/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,7 +1,7 @@\n use crate::ty::{self, Ty, TyCtxt, AdtSizedConstraint};\n use crate::ty::util::NeedsDrop;\n \n-use syntax::symbol::InternedString;\n+use syntax::symbol::Symbol;\n \n pub(super) trait Value<'tcx>: Sized {\n     fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Self;\n@@ -22,7 +22,7 @@ impl<'tcx> Value<'tcx> for Ty<'tcx> {\n \n impl<'tcx> Value<'tcx> for ty::SymbolName {\n     fn from_cycle_error(_: TyCtxt<'tcx>) -> Self {\n-        ty::SymbolName { name: InternedString::intern(\"<error>\") }\n+        ty::SymbolName { name: Symbol::intern(\"<error>\") }\n     }\n }\n "}, {"sha": "1da65f4b51d36d083e7697d5cc6c135c61e3ba7c", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -557,10 +557,9 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n         x.val\n     };\n \n-    // Currently, the values that can be unified are those that\n-    // implement both `PartialEq` and `Eq`, corresponding to\n-    // `structural_match` types.\n-    // FIXME(const_generics): check for `structural_match` synthetic attribute.\n+    // Currently, the values that can be unified are primitive types,\n+    // and those that derive both `PartialEq` and `Eq`, corresponding\n+    // to `structural_match` types.\n     let new_const_val = match (eagerly_eval(a), eagerly_eval(b)) {\n         (ConstValue::Infer(_), _) | (_, ConstValue::Infer(_)) => {\n             // The caller should handle these cases!"}, {"sha": "5d78d563e9a4b0aa53fb473489d6948b7817477c", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -749,6 +749,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             ExistentialMismatch(ref x) => return tcx.lift(x).map(ExistentialMismatch),\n             ConstMismatch(ref x) => return tcx.lift(x).map(ConstMismatch),\n             IntrinsicCast => IntrinsicCast,\n+            ObjectUnsafeCoercion(ref x) => return tcx.lift(x).map(ObjectUnsafeCoercion),\n         })\n     }\n }\n@@ -1350,6 +1351,7 @@ EnumTypeFoldableImpl! {\n         (ty::error::TypeError::ExistentialMismatch)(x),\n         (ty::error::TypeError::ConstMismatch)(x),\n         (ty::error::TypeError::IntrinsicCast),\n+        (ty::error::TypeError::ObjectUnsafeCoercion)(x),\n     }\n }\n "}, {"sha": "3a9994ac64c77e9d2c0bdcb16e11cf01a08c5824", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -24,7 +24,7 @@ use std::marker::PhantomData;\n use std::ops::Range;\n use rustc_target::spec::abi;\n use syntax::ast::{self, Ident};\n-use syntax::symbol::{kw, InternedString};\n+use syntax::symbol::{kw, Symbol};\n \n use self::InferTy::*;\n use self::TyKind::*;\n@@ -55,7 +55,7 @@ pub enum BoundRegion {\n     ///\n     /// The `DefId` is needed to distinguish free regions in\n     /// the event of shadowing.\n-    BrNamed(DefId, InternedString),\n+    BrNamed(DefId, Symbol),\n \n     /// Anonymous region for the implicit env pointer parameter\n     /// to a closure\n@@ -1121,16 +1121,16 @@ pub type CanonicalPolyFnSig<'tcx> = Canonical<'tcx, Binder<FnSig<'tcx>>>;\n          Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ParamTy {\n     pub index: u32,\n-    pub name: InternedString,\n+    pub name: Symbol,\n }\n \n impl<'tcx> ParamTy {\n-    pub fn new(index: u32, name: InternedString) -> ParamTy {\n+    pub fn new(index: u32, name: Symbol) -> ParamTy {\n         ParamTy { index, name: name }\n     }\n \n     pub fn for_self() -> ParamTy {\n-        ParamTy::new(0, kw::SelfUpper.as_interned_str())\n+        ParamTy::new(0, kw::SelfUpper)\n     }\n \n     pub fn for_def(def: &ty::GenericParamDef) -> ParamTy {\n@@ -1146,11 +1146,11 @@ impl<'tcx> ParamTy {\n          Eq, PartialEq, Ord, PartialOrd, HashStable)]\n pub struct ParamConst {\n     pub index: u32,\n-    pub name: InternedString,\n+    pub name: Symbol,\n }\n \n impl<'tcx> ParamConst {\n-    pub fn new(index: u32, name: InternedString) -> ParamConst {\n+    pub fn new(index: u32, name: Symbol) -> ParamConst {\n         ParamConst { index, name }\n     }\n \n@@ -1323,7 +1323,7 @@ impl<'tcx> rustc_serialize::UseSpecializedDecodable for Region<'tcx> {}\n pub struct EarlyBoundRegion {\n     pub def_id: DefId,\n     pub index: u32,\n-    pub name: InternedString,\n+    pub name: Symbol,\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n@@ -1387,7 +1387,7 @@ pub struct BoundTy {\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum BoundTyKind {\n     Anon,\n-    Param(InternedString),\n+    Param(Symbol),\n }\n \n impl_stable_hash_for!(struct BoundTy { var, kind });"}, {"sha": "b50e819c956e0dd710d262f032c322273a42dcbb", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -380,16 +380,21 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     // obligations that don't refer to Self and\n                     // checking those\n \n-                    let cause = self.cause(traits::MiscObligation);\n-                    let component_traits =\n-                        data.auto_traits().chain(data.principal_def_id());\n-                    self.out.extend(\n-                        component_traits.map(|did| traits::Obligation::new(\n-                            cause.clone(),\n-                            param_env,\n-                            ty::Predicate::ObjectSafe(did)\n-                        ))\n-                    );\n+                    let defer_to_coercion =\n+                        self.infcx.tcx.features().object_safe_for_dispatch;\n+\n+                    if !defer_to_coercion {\n+                        let cause = self.cause(traits::MiscObligation);\n+                        let component_traits =\n+                            data.auto_traits().chain(data.principal_def_id());\n+                        self.out.extend(\n+                            component_traits.map(|did| traits::Obligation::new(\n+                                cause.clone(),\n+                                param_env,\n+                                ty::Predicate::ObjectSafe(did)\n+                            ))\n+                        );\n+                    }\n                 }\n \n                 // Inference variables are the complicated case, since we don't"}, {"sha": "edd34b52eade7703687020c9a5f97ad7e693dd71", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -36,7 +36,7 @@ use rustc_codegen_ssa::back::write::submit_codegened_module_to_llvm;\n \n use std::ffi::CString;\n use std::time::Instant;\n-use syntax_pos::symbol::InternedString;\n+use syntax_pos::symbol::Symbol;\n use rustc::hir::CodegenFnAttrs;\n \n use crate::value::Value;\n@@ -105,7 +105,7 @@ pub fn iter_globals(llmod: &'ll llvm::Module) -> ValueIter<'ll> {\n \n pub fn compile_codegen_unit(\n     tcx: TyCtxt<'tcx>,\n-    cgu_name: InternedString,\n+    cgu_name: Symbol,\n     tx_to_llvm_workers: &std::sync::mpsc::Sender<Box<dyn std::any::Any + Send>>,\n ) {\n     let prof_timer = tcx.prof.generic_activity(\"codegen_module\");\n@@ -131,7 +131,7 @@ pub fn compile_codegen_unit(\n \n     fn module_codegen(\n         tcx: TyCtxt<'_>,\n-        cgu_name: InternedString,\n+        cgu_name: Symbol,\n     ) -> ModuleCodegen<ModuleLlvm> {\n         let cgu = tcx.codegen_unit(cgu_name);\n         // Instantiate monomorphizations without filling out definitions yet..."}, {"sha": "fd7054a5a0ada777f9547420412aaf6e43c84154", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -221,7 +221,7 @@ impl CodegenCx<'ll, 'tcx> {\n                  def_id);\n \n         let ty = instance.ty(self.tcx);\n-        let sym = self.tcx.symbol_name(instance).name.as_symbol();\n+        let sym = self.tcx.symbol_name(instance).name;\n \n         debug!(\"get_static: sym={} instance={:?}\", sym, instance);\n "}, {"sha": "f0148a21ae67064e2ceba0e750f7dd1473f5ce39", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -46,7 +46,7 @@ use std::iter;\n use std::ptr;\n use std::path::{Path, PathBuf};\n use syntax::ast;\n-use syntax::symbol::{Interner, InternedString};\n+use syntax::symbol::{Interner, Symbol};\n use syntax_pos::{self, Span, FileName};\n \n impl PartialEq for llvm::Metadata {\n@@ -2125,7 +2125,7 @@ fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> Option<&'\n \n     fn get_parameter_names(cx: &CodegenCx<'_, '_>,\n                            generics: &ty::Generics)\n-                           -> Vec<InternedString> {\n+                           -> Vec<Symbol> {\n         let mut names = generics.parent.map_or(vec![], |def_id| {\n             get_parameter_names(cx, cx.tcx.generics_of(def_id))\n         });"}, {"sha": "5b59f4c28de205248fe789f0e312daf5bd54ff74", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -36,7 +36,7 @@ use std::ffi::{CStr, CString};\n \n use syntax_pos::{self, Span, Pos};\n use syntax::ast;\n-use syntax::symbol::InternedString;\n+use syntax::symbol::Symbol;\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt};\n use rustc_codegen_ssa::traits::*;\n \n@@ -490,7 +490,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n         fn get_parameter_names(cx: &CodegenCx<'_, '_>,\n                                generics: &ty::Generics)\n-                               -> Vec<InternedString> {\n+                               -> Vec<Symbol> {\n             let mut names = generics.parent.map_or(vec![], |def_id| {\n                 get_parameter_names(cx, cx.tcx.generics_of(def_id))\n             });"}, {"sha": "628d1372b5702ecc0ab8e6e1973a3ef6afae7259", "filename": "src/librustc_codegen_llvm/debuginfo/namespace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -35,7 +35,7 @@ pub fn item_namespace(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll DIScope {\n \n     let namespace_name = match def_key.disambiguated_data.data {\n         DefPathData::CrateRoot => cx.tcx.crate_name(def_id.krate).as_str(),\n-        data => data.as_interned_str().as_str()\n+        data => data.as_symbol().as_str()\n     };\n \n     let namespace_name = SmallCStr::new(&namespace_name);"}, {"sha": "e09b600afd4e5a4955bc76e0ef6a78f5f2de877d", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -50,14 +50,13 @@ use rustc_codegen_ssa::CompiledModule;\n use errors::{FatalError, Handler};\n use rustc::dep_graph::WorkProduct;\n use syntax_expand::allocator::AllocatorKind;\n-use syntax_pos::symbol::InternedString;\n pub use llvm_util::target_features;\n use std::any::Any;\n use std::sync::Arc;\n use std::ffi::CStr;\n \n use rustc::dep_graph::DepGraph;\n-use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n+use rustc::middle::cstore::{EncodedMetadata, MetadataLoaderDyn};\n use rustc::session::Session;\n use rustc::session::config::{OutputFilenames, OutputType, PrintRequest, OptLevel};\n use rustc::ty::{self, TyCtxt};\n@@ -123,7 +122,7 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n     }\n     fn compile_codegen_unit(\n         &self, tcx: TyCtxt<'_>,\n-        cgu_name: InternedString,\n+        cgu_name: Symbol,\n         tx: &std::sync::mpsc::Sender<Box<dyn Any + Send>>,\n     ) {\n         base::compile_codegen_unit(tcx, cgu_name, tx);\n@@ -261,7 +260,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n         target_features(sess)\n     }\n \n-    fn metadata_loader(&self) -> Box<dyn MetadataLoader + Sync> {\n+    fn metadata_loader(&self) -> Box<MetadataLoaderDyn> {\n         box metadata::LlvmMetadataLoader\n     }\n "}, {"sha": "762b50f1659ccd7b00a536aa78ecbe482c227eda", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -259,7 +259,7 @@ fn generate_lto_work<B: ExtraBackendMethods>(\n     needs_thin_lto: Vec<(String, B::ThinBuffer)>,\n     import_only_modules: Vec<(SerializedModule<B::ModuleBuffer>, WorkProduct)>\n ) -> Vec<(WorkItem<B>, u64)> {\n-    let _prof_timer = cgcx.prof.generic_activity(\"codegen_run_lto\");\n+    let _prof_timer = cgcx.prof.generic_activity(\"codegen_generate_lto_work\");\n \n     let (lto_modules, copy_jobs) = if !needs_fat_lto.is_empty() {\n         assert!(needs_thin_lto.is_empty());\n@@ -674,11 +674,11 @@ impl<B: WriteBackendMethods> WorkItem<B> {\n         }\n     }\n \n-    pub fn name(&self) -> String {\n+    fn profiling_event_id(&self) -> &'static str {\n         match *self {\n-            WorkItem::Optimize(ref m) => format!(\"optimize: {}\", m.name),\n-            WorkItem::CopyPostLtoArtifacts(ref m) => format!(\"copy post LTO artifacts: {}\", m.name),\n-            WorkItem::LTO(ref m) => format!(\"lto: {}\", m.name()),\n+            WorkItem::Optimize(_) => \"codegen_module_optimize\",\n+            WorkItem::CopyPostLtoArtifacts(_) => \"codegen_copy_artifacts_from_incr_cache\",\n+            WorkItem::LTO(_) => \"codegen_module_perform_lto\",\n         }\n     }\n }\n@@ -1587,7 +1587,7 @@ fn spawn_work<B: ExtraBackendMethods>(\n         // as a diagnostic was already sent off to the main thread - just\n         // surface that there was an error in this worker.\n         bomb.result = {\n-            let _prof_timer = cgcx.prof.generic_activity(&work.name());\n+            let _prof_timer = cgcx.prof.generic_activity(work.profiling_event_id());\n             execute_work_item(&cgcx, work).ok()\n         };\n     });"}, {"sha": "bf687f846357e7c8fe0814830fc33702a10955f0", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -406,6 +406,8 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(cx: &'\n         rust_main_def_id: DefId,\n         use_start_lang_item: bool,\n     ) {\n+        // The entry function is either `int main(void)` or `int main(int argc, char **argv)`,\n+        // depending on whether the target needs `argc` and `argv` to be passed in.\n         let llfty = if cx.sess().target.target.options.main_needs_argc_argv {\n             cx.type_func(&[cx.type_int(), cx.type_ptr_to(cx.type_i8p())], cx.type_int())\n         } else {\n@@ -440,19 +442,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(cx: &'\n \n         bx.insert_reference_to_gdb_debug_scripts_section_global();\n \n-        let (arg_argc, arg_argv) = if cx.sess().target.target.options.main_needs_argc_argv {\n-            // Params from native main() used as args for rust start function\n-            let param_argc = bx.get_param(0);\n-            let param_argv = bx.get_param(1);\n-            let arg_argc = bx.intcast(param_argc, cx.type_isize(), true);\n-            let arg_argv = param_argv;\n-            (arg_argc, arg_argv)\n-        } else {\n-            // The Rust start function doesn't need argc and argv, so just pass zeros.\n-            let arg_argc = bx.const_int(cx.type_int(), 0);\n-            let arg_argv = bx.const_null(cx.type_ptr_to(cx.type_i8p()));\n-            (arg_argc, arg_argv)\n-        };\n+        let (arg_argc, arg_argv) = get_argc_argv(cx, &mut bx);\n \n         let (start_fn, args) = if use_start_lang_item {\n             let start_def_id = cx.tcx().require_lang_item(StartFnLangItem, None);\n@@ -477,6 +467,27 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(cx: &'\n     }\n }\n \n+/// Obtain the `argc` and `argv` values to pass to the rust start function.\n+fn get_argc_argv<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n+    cx: &'a Bx::CodegenCx,\n+    bx: &mut Bx\n+) -> (Bx::Value, Bx::Value)\n+{\n+    if cx.sess().target.target.options.main_needs_argc_argv {\n+        // Params from native `main()` used as args for rust start function\n+        let param_argc = bx.get_param(0);\n+        let param_argv = bx.get_param(1);\n+        let arg_argc = bx.intcast(param_argc, cx.type_isize(), true);\n+        let arg_argv = param_argv;\n+        (arg_argc, arg_argv)\n+    } else {\n+        // The Rust start function doesn't need `argc` and `argv`, so just pass zeros.\n+        let arg_argc = bx.const_int(cx.type_int(), 0);\n+        let arg_argv = bx.const_null(cx.type_ptr_to(cx.type_i8p()));\n+        (arg_argc, arg_argv)\n+    }\n+}\n+\n pub const CODEGEN_WORKER_ID: usize = ::std::usize::MAX;\n \n pub fn codegen_crate<B: ExtraBackendMethods>(\n@@ -515,7 +526,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     // unnecessarily.\n     if tcx.dep_graph.is_fully_enabled() {\n         for cgu in &codegen_units {\n-            tcx.codegen_unit(cgu.name().clone());\n+            tcx.codegen_unit(cgu.name());\n         }\n     }\n \n@@ -603,7 +614,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         match cgu_reuse {\n             CguReuse::No => {\n                 let start_time = Instant::now();\n-                backend.compile_codegen_unit(tcx, *cgu.name(), &ongoing_codegen.coordinator_send);\n+                backend.compile_codegen_unit(tcx, cgu.name(), &ongoing_codegen.coordinator_send);\n                 total_codegen_time += start_time.elapsed();\n                 false\n             }"}, {"sha": "166a74fe48795adcfc7582fc060111570f228024", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -221,7 +221,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n             output.push_str(&tcx.crate_name(def_id.krate).as_str());\n             for path_element in tcx.def_path(def_id).data {\n                 output.push_str(\"::\");\n-                output.push_str(&path_element.data.as_interned_str().as_str());\n+                output.push_str(&path_element.data.as_symbol().as_str());\n             }\n         } else {\n             output.push_str(&tcx.item_name(def_id).as_str());"}, {"sha": "1fff740d7403fee1bf7e026cbb683b87dd0ad0e8", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -10,7 +10,7 @@ use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use std::sync::Arc;\n use std::sync::mpsc;\n use syntax_expand::allocator::AllocatorKind;\n-use syntax_pos::symbol::InternedString;\n+use syntax_pos::symbol::Symbol;\n \n pub trait BackendTypes {\n     type Value: CodegenObject;\n@@ -50,7 +50,7 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n     fn compile_codegen_unit(\n         &self,\n         tcx: TyCtxt<'_>,\n-        cgu_name: InternedString,\n+        cgu_name: Symbol,\n         tx_to_llvm_workers: &mpsc::Sender<Box<dyn std::any::Any + Send>>,\n     );\n     // If find_features is true this won't access `sess.crate_types` by assuming"}, {"sha": "0e2c3731eae6d23b10751fc51a08779eb63c5960", "filename": "src/librustc_codegen_utils/codegen_backend.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -14,7 +14,7 @@ use rustc::util::common::ErrorReported;\n use rustc::session::config::{OutputFilenames, PrintRequest};\n use rustc::ty::TyCtxt;\n use rustc::ty::query::Providers;\n-use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n+use rustc::middle::cstore::{EncodedMetadata, MetadataLoaderDyn};\n use rustc::dep_graph::DepGraph;\n \n pub use rustc_data_structures::sync::MetadataRef;\n@@ -26,7 +26,7 @@ pub trait CodegenBackend {\n     fn print_passes(&self) {}\n     fn print_version(&self) {}\n \n-    fn metadata_loader(&self) -> Box<dyn MetadataLoader + Sync>;\n+    fn metadata_loader(&self) -> Box<MetadataLoaderDyn>;\n     fn provide(&self, _providers: &mut Providers<'_>);\n     fn provide_extern(&self, _providers: &mut Providers<'_>);\n     fn codegen_crate<'tcx>("}, {"sha": "c52c6cfa83c917c64ce7d3b1902927805d6f4218", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -95,7 +95,7 @@ use rustc::ty::query::Providers;\n use rustc::ty::{self, TyCtxt, Instance};\n use rustc::mir::mono::{MonoItem, InstantiationMode};\n \n-use syntax_pos::symbol::InternedString;\n+use syntax_pos::symbol::Symbol;\n \n use log::debug;\n \n@@ -112,7 +112,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn symbol_name(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> InternedString {\n+fn symbol_name(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Symbol {\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n@@ -123,13 +123,11 @@ fn symbol_name(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> InternedString {\n     if def_id.is_local() {\n         if tcx.plugin_registrar_fn(LOCAL_CRATE) == Some(def_id) {\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n-            return\n-                InternedString::intern(&tcx.sess.generate_plugin_registrar_symbol(disambiguator));\n+            return Symbol::intern(&tcx.sess.generate_plugin_registrar_symbol(disambiguator));\n         }\n         if tcx.proc_macro_decls_static(LOCAL_CRATE) == Some(def_id) {\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n-            return\n-                InternedString::intern(&tcx.sess.generate_proc_macro_decls_symbol(disambiguator));\n+            return Symbol::intern(&tcx.sess.generate_proc_macro_decls_symbol(disambiguator));\n         }\n     }\n \n@@ -146,23 +144,22 @@ fn symbol_name(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> InternedString {\n     let attrs = tcx.codegen_fn_attrs(def_id);\n     if is_foreign {\n         if let Some(name) = attrs.link_name {\n-            return name.as_interned_str();\n+            return name;\n         }\n         // Don't mangle foreign items.\n-        return tcx.item_name(def_id).as_interned_str();\n+        return tcx.item_name(def_id);\n     }\n \n-    if let Some(name) = &attrs.export_name {\n+    if let Some(name) = attrs.export_name {\n         // Use provided name\n-        return name.as_interned_str();\n+        return name;\n     }\n \n     if attrs.flags.contains(CodegenFnAttrFlags::NO_MANGLE) {\n         // Don't mangle\n-        return tcx.item_name(def_id).as_interned_str();\n+        return tcx.item_name(def_id);\n     }\n \n-\n     let is_generic = substs.non_erasable_generics().next().is_some();\n     let avoid_cross_crate_conflicts =\n         // If this is an instance of a generic function, we also hash in\n@@ -222,5 +219,5 @@ fn symbol_name(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> InternedString {\n         SymbolManglingVersion::V0 => v0::mangle(tcx, instance, instantiating_crate),\n     };\n \n-    InternedString::intern(&mangled)\n+    Symbol::intern(&mangled)\n }"}, {"sha": "601a33a66bb32f383db6fcea8ef968422060817b", "filename": "src/librustc_codegen_utils/symbol_names/legacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -335,7 +335,7 @@ impl Printer<'tcx> for SymbolPrinter<'tcx> {\n             self.path.finalize_pending_component();\n         }\n \n-        self.write_str(&disambiguated_data.data.as_interned_str().as_str())?;\n+        self.write_str(&disambiguated_data.data.as_symbol().as_str())?;\n         Ok(self)\n     }\n     fn path_generic_args("}, {"sha": "444463c08e55715ee82ce8ad3174c9d11fa675a4", "filename": "src/librustc_data_structures/graph/dominators/mod.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -17,7 +17,7 @@ pub fn dominators<G: ControlFlowGraph>(graph: &G) -> Dominators<G::Node> {\n     dominators_given_rpo(graph, &rpo)\n }\n \n-pub fn dominators_given_rpo<G: ControlFlowGraph>(\n+fn dominators_given_rpo<G: ControlFlowGraph>(\n     graph: &G,\n     rpo: &[G::Node],\n ) -> Dominators<G::Node> {\n@@ -43,14 +43,12 @@ pub fn dominators_given_rpo<G: ControlFlowGraph>(\n             let mut new_idom = None;\n             for pred in graph.predecessors(node) {\n                 if immediate_dominators[pred].is_some() {\n-                    // (*)\n                     // (*) dominators for `pred` have been calculated\n-                    new_idom = intersect_opt(\n-                        &post_order_rank,\n-                        &immediate_dominators,\n-                        new_idom,\n-                        Some(pred),\n-                    );\n+                    new_idom = Some(if let Some(new_idom) = new_idom {\n+                        intersect(&post_order_rank, &immediate_dominators, new_idom, pred)\n+                    } else {\n+                        pred\n+                    });\n                 }\n             }\n \n@@ -67,19 +65,6 @@ pub fn dominators_given_rpo<G: ControlFlowGraph>(\n     }\n }\n \n-fn intersect_opt<Node: Idx>(\n-    post_order_rank: &IndexVec<Node, usize>,\n-    immediate_dominators: &IndexVec<Node, Option<Node>>,\n-    node1: Option<Node>,\n-    node2: Option<Node>,\n-) -> Option<Node> {\n-    match (node1, node2) {\n-        (None, None) => None,\n-        (Some(n), None) | (None, Some(n)) => Some(n),\n-        (Some(n1), Some(n2)) => Some(intersect(post_order_rank, immediate_dominators, n1, n2)),\n-    }\n-}\n-\n fn intersect<Node: Idx>(\n     post_order_rank: &IndexVec<Node, usize>,\n     immediate_dominators: &IndexVec<Node, Option<Node>>,"}, {"sha": "a9e4e6db1c75f1d238c3b7f951d1492cc6c2cdce", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -16,6 +16,7 @@ log = \"0.4\"\n env_logger = { version = \"0.7\", default-features = false }\n rustc = { path = \"../librustc\" }\n rustc_target = { path = \"../librustc_target\" }\n+rustc_lint = { path = \"../librustc_lint\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n rustc_metadata = { path = \"../librustc_metadata\" }"}, {"sha": "15adf7e4add73ac640d0514729ca8e9a4043a82f", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -36,11 +36,11 @@ use rustc::session::config::nightly_options;\n use rustc::session::{early_error, early_warn};\n use rustc::lint::Lint;\n use rustc::lint;\n+use rustc::middle::cstore::MetadataLoader;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::ty::TyCtxt;\n use rustc::util::common::{set_time_depth, time, print_time_passes_entry, ErrorReported};\n use rustc_metadata::locator;\n-use rustc_metadata::cstore::CStore;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_interface::interface;\n use rustc_interface::util::get_codegen_sysroot;\n@@ -106,6 +106,8 @@ pub fn abort_on_err<T>(result: Result<T, ErrorReported>, sess: &Session) -> T {\n pub trait Callbacks {\n     /// Called before creating the compiler instance\n     fn config(&mut self, _config: &mut interface::Config) {}\n+    /// Called early during compilation to allow other drivers to easily register lints.\n+    fn extra_lints(&mut self, _ls: &mut lint::LintStore) {}\n     /// Called after parsing. Return value instructs the compiler whether to\n     /// continue the compilation afterwards (defaults to `Compilation::Continue`)\n     fn after_parsing(&mut self, _compiler: &interface::Compiler) -> Compilation {\n@@ -182,6 +184,7 @@ pub fn run_compiler(\n             stderr: None,\n             crate_name: None,\n             lint_caps: Default::default(),\n+            register_lints: None,\n         };\n         callbacks.config(&mut config);\n         config\n@@ -202,9 +205,13 @@ pub fn run_compiler(\n                     interface::run_compiler(config, |compiler| {\n                         let sopts = &compiler.session().opts;\n                         if sopts.describe_lints {\n+                            let lint_store = rustc_lint::new_lint_store(\n+                                sopts.debugging_opts.no_interleave_lints,\n+                                compiler.session().unstable_options(),\n+                            );\n                             describe_lints(\n                                 compiler.session(),\n-                                &*compiler.session().lint_store.borrow(),\n+                                &lint_store,\n                                 false\n                             );\n                             return;\n@@ -255,6 +262,7 @@ pub fn run_compiler(\n         stderr: None,\n         crate_name: None,\n         lint_caps: Default::default(),\n+        register_lints: None,\n     };\n \n     callbacks.config(&mut config);\n@@ -269,7 +277,7 @@ pub fn run_compiler(\n             compiler.output_file(),\n         ).and_then(|| RustcDefaultCalls::list_metadata(\n             sess,\n-            compiler.cstore(),\n+            &*compiler.codegen_backend().metadata_loader(),\n             &matches,\n             compiler.input()\n         ));\n@@ -321,12 +329,14 @@ pub fn run_compiler(\n             return sess.compile_status();\n         }\n \n-        compiler.register_plugins()?;\n+        {\n+            let (_, _, lint_store) = &*compiler.register_plugins()?.peek();\n \n-        // Lint plugins are registered; now we can process command line flags.\n-        if sess.opts.describe_lints {\n-            describe_lints(&sess, &sess.lint_store.borrow(), true);\n-            return sess.compile_status();\n+            // Lint plugins are registered; now we can process command line flags.\n+            if sess.opts.describe_lints {\n+                describe_lints(&sess, &lint_store, true);\n+                return sess.compile_status();\n+            }\n         }\n \n         compiler.expansion()?;\n@@ -604,7 +614,7 @@ fn show_content_with_pager(content: &String) {\n \n impl RustcDefaultCalls {\n     pub fn list_metadata(sess: &Session,\n-                         cstore: &CStore,\n+                         metadata_loader: &dyn MetadataLoader,\n                          matches: &getopts::Matches,\n                          input: &Input)\n                          -> Compilation {\n@@ -616,7 +626,7 @@ impl RustcDefaultCalls {\n                     let mut v = Vec::new();\n                     locator::list_file_metadata(&sess.target.target,\n                                                 path,\n-                                                cstore,\n+                                                metadata_loader,\n                                                 &mut v)\n                             .unwrap();\n                     println!(\"{}\", String::from_utf8(v).unwrap());\n@@ -835,8 +845,7 @@ Available lint options:\n \n \");\n \n-    fn sort_lints(sess: &Session, lints: Vec<(&'static Lint, bool)>) -> Vec<&'static Lint> {\n-        let mut lints: Vec<_> = lints.into_iter().map(|(x, _)| x).collect();\n+    fn sort_lints(sess: &Session, mut lints: Vec<&'static Lint>) -> Vec<&'static Lint> {\n         // The sort doesn't case-fold but it's doubtful we care.\n         lints.sort_by_cached_key(|x: &&Lint| (x.default_level(sess), x.name));\n         lints\n@@ -852,7 +861,7 @@ Available lint options:\n     let (plugin, builtin): (Vec<_>, _) = lint_store.get_lints()\n                                                    .iter()\n                                                    .cloned()\n-                                                   .partition(|&(_, p)| p);\n+                                                   .partition(|&lint| lint.is_plugin);\n     let plugin = sort_lints(sess, plugin);\n     let builtin = sort_lints(sess, builtin);\n "}, {"sha": "1781f2e165033976daadb9b3fed123a8aa68451f", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -152,6 +152,32 @@ impl Diagnostic {\n         self.note_expected_found_extra(label, expected, found, &\"\", &\"\")\n     }\n \n+    pub fn note_unsuccessfull_coercion(&mut self,\n+                                       expected: DiagnosticStyledString,\n+                                       found: DiagnosticStyledString)\n+                                       -> &mut Self\n+    {\n+        let mut msg: Vec<_> =\n+            vec![(format!(\"required when trying to coerce from type `\"),\n+                  Style::NoStyle)];\n+        msg.extend(expected.0.iter()\n+                   .map(|x| match *x {\n+                       StringPart::Normal(ref s) => (s.to_owned(), Style::NoStyle),\n+                       StringPart::Highlighted(ref s) => (s.to_owned(), Style::Highlight),\n+                   }));\n+        msg.push((format!(\"` to type '\"), Style::NoStyle));\n+        msg.extend(found.0.iter()\n+                   .map(|x| match *x {\n+                       StringPart::Normal(ref s) => (s.to_owned(), Style::NoStyle),\n+                       StringPart::Highlighted(ref s) => (s.to_owned(), Style::Highlight),\n+                   }));\n+        msg.push((format!(\"`\"), Style::NoStyle));\n+\n+        // For now, just attach these as notes\n+        self.highlighted_note(msg);\n+        self\n+    }\n+\n     pub fn note_expected_found_extra(&mut self,\n                                      label: &dyn fmt::Display,\n                                      expected: DiagnosticStyledString,"}, {"sha": "40642dd14b8f7c7ce75ed81ed4d3de98ef66dc42", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -209,6 +209,11 @@ impl<'a> DiagnosticBuilder<'a> {\n                                               found_extra: &dyn fmt::Display,\n                                               ) -> &mut Self);\n \n+    forward!(pub fn note_unsuccessfull_coercion(&mut self,\n+                                                expected: DiagnosticStyledString,\n+                                                found: DiagnosticStyledString,\n+                                                ) -> &mut Self);\n+\n     forward!(pub fn note(&mut self, msg: &str) -> &mut Self);\n     forward!(pub fn span_note<S: Into<MultiSpan>>(&mut self,\n                                                   sp: S,"}, {"sha": "ca035d0cdcb19d434700732e3b428b4d4a5e7d5f", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -27,7 +27,7 @@ use rustc::mir::mono::CodegenUnitNameBuilder;\n use rustc::ty::TyCtxt;\n use std::collections::BTreeSet;\n use syntax::ast;\n-use syntax::symbol::{InternedString, Symbol, sym};\n+use syntax::symbol::{Symbol, sym};\n use rustc::ich::{ATTR_PARTITION_REUSED, ATTR_PARTITION_CODEGENED,\n                  ATTR_EXPECTED_CGU_REUSE};\n \n@@ -45,8 +45,8 @@ pub fn assert_module_sources(tcx: TyCtxt<'_>) {\n             .collect_and_partition_mono_items(LOCAL_CRATE)\n             .1\n             .iter()\n-            .map(|cgu| *cgu.name())\n-            .collect::<BTreeSet<InternedString>>();\n+            .map(|cgu| cgu.name())\n+            .collect::<BTreeSet<Symbol>>();\n \n         let ams = AssertModuleSource {\n             tcx,\n@@ -61,7 +61,7 @@ pub fn assert_module_sources(tcx: TyCtxt<'_>) {\n \n struct AssertModuleSource<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    available_cgus: BTreeSet<InternedString>,\n+    available_cgus: BTreeSet<Symbol>,\n }\n \n impl AssertModuleSource<'tcx> {"}, {"sha": "e014e4ed0fdc1cbe6fdb960fc012f2f2e2c1a3c7", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -11,7 +11,6 @@ use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_data_structures::OnDrop;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n-use rustc_metadata::cstore::CStore;\n use std::path::PathBuf;\n use std::result;\n use std::sync::{Arc, Mutex};\n@@ -37,8 +36,8 @@ pub struct Compiler {\n     pub(crate) output_dir: Option<PathBuf>,\n     pub(crate) output_file: Option<PathBuf>,\n     pub(crate) queries: Queries,\n-    pub(crate) cstore: Lrc<CStore>,\n     pub(crate) crate_name: Option<String>,\n+    pub(crate) register_lints: Option<Box<dyn Fn(&Session, &mut lint::LintStore) + Send + Sync>>,\n }\n \n impl Compiler {\n@@ -48,9 +47,6 @@ impl Compiler {\n     pub fn codegen_backend(&self) -> &Lrc<Box<dyn CodegenBackend>> {\n         &self.codegen_backend\n     }\n-    pub fn cstore(&self) -> &Lrc<CStore> {\n-        &self.cstore\n-    }\n     pub fn source_map(&self) -> &Lrc<SourceMap> {\n         &self.source_map\n     }\n@@ -137,6 +133,13 @@ pub struct Config {\n \n     pub crate_name: Option<String>,\n     pub lint_caps: FxHashMap<lint::LintId, lint::Level>,\n+\n+    /// This is a callback from the driver that is called when we're registering lints;\n+    /// it is called during plugin registration when we have the LintStore in a non-shared state.\n+    ///\n+    /// Note that if you find a Some here you probably want to call that function in the new\n+    /// function being registered.\n+    pub register_lints: Option<Box<dyn Fn(&Session, &mut lint::LintStore) + Send + Sync>>,\n }\n \n pub fn run_compiler_in_existing_thread_pool<F, R>(config: Config, f: F) -> R\n@@ -152,19 +155,17 @@ where\n         config.lint_caps,\n     );\n \n-    let cstore = Lrc::new(CStore::new(codegen_backend.metadata_loader()));\n-\n     let compiler = Compiler {\n         sess,\n         codegen_backend,\n         source_map,\n-        cstore,\n         input: config.input,\n         input_path: config.input_path,\n         output_dir: config.output_dir,\n         output_file: config.output_file,\n         queries: Default::default(),\n         crate_name: config.crate_name,\n+        register_lints: config.register_lints,\n     };\n \n     let _sess_abort_error = OnDrop(|| {"}, {"sha": "58936172c5bcec0cd73a73b4d16528caf0046f5d", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 65, "deletions": 116, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -9,8 +9,8 @@ use rustc::hir::lowering::lower_crate;\n use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc::lint;\n use rustc::middle::{self, reachable, resolve_lifetime, stability};\n-use rustc::middle::cstore::CrateStore;\n-use rustc::ty::{self, AllArenas, Resolutions, TyCtxt, GlobalCtxt};\n+use rustc::middle::cstore::{CrateStore, MetadataLoader, MetadataLoaderDyn};\n+use rustc::ty::{self, AllArenas, ResolverOutputs, TyCtxt, GlobalCtxt};\n use rustc::ty::steal::Steal;\n use rustc::traits;\n use rustc::util::common::{time, ErrorReported};\n@@ -23,8 +23,7 @@ use rustc_codegen_utils::link::filename_for_metadata;\n use rustc_data_structures::{box_region_allow_access, declare_box_region_type, parallel};\n use rustc_data_structures::sync::{Lrc, ParallelIterator, par_iter};\n use rustc_incremental;\n-use rustc_metadata::creader::CrateLoader;\n-use rustc_metadata::cstore::{self, CStore};\n+use rustc_metadata::cstore;\n use rustc_mir as mir;\n use rustc_passes::{self, ast_validation, hir_stats, layout_test};\n use rustc_plugin as plugin;\n@@ -46,12 +45,10 @@ use syntax_ext;\n use rustc_serialize::json;\n use tempfile::Builder as TempFileBuilder;\n \n+use std::{env, fs, iter, mem};\n use std::any::Any;\n-use std::env;\n use std::ffi::OsString;\n-use std::fs;\n use std::io::{self, Write};\n-use std::iter;\n use std::path::PathBuf;\n use std::cell::RefCell;\n use std::rc::Rc;\n@@ -105,7 +102,7 @@ fn count_nodes(krate: &ast::Crate) -> usize {\n declare_box_region_type!(\n     pub BoxedResolver,\n     for(),\n-    (&mut Resolver<'_>) -> (Result<ast::Crate>, ExpansionResult)\n+    (&mut Resolver<'_>) -> (Result<ast::Crate>, ResolverOutputs)\n );\n \n /// Runs the \"early phases\" of the compiler: initial `cfg` processing,\n@@ -117,7 +114,8 @@ declare_box_region_type!(\n /// Returns `None` if we're aborting after handling -W help.\n pub fn configure_and_expand(\n     sess: Lrc<Session>,\n-    cstore: Lrc<CStore>,\n+    lint_store: Lrc<lint::LintStore>,\n+    metadata_loader: Box<MetadataLoaderDyn>,\n     krate: ast::Crate,\n     crate_name: &str,\n     plugin_info: PluginInfo,\n@@ -130,15 +128,14 @@ pub fn configure_and_expand(\n     let crate_name = crate_name.to_string();\n     let (result, resolver) = BoxedResolver::new(static move || {\n         let sess = &*sess;\n-        let crate_loader = CrateLoader::new(sess, &*cstore, &crate_name);\n         let resolver_arenas = Resolver::arenas();\n         let res = configure_and_expand_inner(\n             sess,\n-            &*cstore,\n+            &lint_store,\n             krate,\n             &crate_name,\n             &resolver_arenas,\n-            &crate_loader,\n+            &*metadata_loader,\n             plugin_info,\n         );\n         let mut resolver = match res {\n@@ -152,68 +149,16 @@ pub fn configure_and_expand(\n             }\n         };\n         box_region_allow_access!(for(), (&mut Resolver<'_>), (&mut resolver));\n-        ExpansionResult::from_owned_resolver(resolver)\n+        resolver.into_outputs()\n     });\n     result.map(|k| (k, resolver))\n }\n \n-pub struct ExpansionResult {\n-    pub defs: Steal<hir::map::Definitions>,\n-    pub resolutions: Steal<Resolutions>,\n-}\n-\n-impl ExpansionResult {\n-    fn from_owned_resolver(\n-        resolver: Resolver<'_>,\n-    ) -> Self {\n-        ExpansionResult {\n-            defs: Steal::new(resolver.definitions),\n-            resolutions: Steal::new(Resolutions {\n-                extern_crate_map: resolver.extern_crate_map,\n-                export_map: resolver.export_map,\n-                trait_map: resolver.trait_map,\n-                glob_map: resolver.glob_map,\n-                maybe_unused_trait_imports: resolver.maybe_unused_trait_imports,\n-                maybe_unused_extern_crates: resolver.maybe_unused_extern_crates,\n-                extern_prelude: resolver.extern_prelude.iter().map(|(ident, entry)| {\n-                    (ident.name, entry.introduced_by_item)\n-                }).collect(),\n-            }),\n-        }\n-    }\n-\n-    pub fn from_resolver_ref(\n-        resolver: &Resolver<'_>,\n-    ) -> Self {\n-        ExpansionResult {\n-            defs: Steal::new(resolver.definitions.clone()),\n-            resolutions: Steal::new(Resolutions {\n-                extern_crate_map: resolver.extern_crate_map.clone(),\n-                export_map: resolver.export_map.clone(),\n-                trait_map: resolver.trait_map.clone(),\n-                glob_map: resolver.glob_map.clone(),\n-                maybe_unused_trait_imports: resolver.maybe_unused_trait_imports.clone(),\n-                maybe_unused_extern_crates: resolver.maybe_unused_extern_crates.clone(),\n-                extern_prelude: resolver.extern_prelude.iter().map(|(ident, entry)| {\n-                    (ident.name, entry.introduced_by_item)\n-                }).collect(),\n-            }),\n-        }\n-    }\n-}\n-\n impl BoxedResolver {\n-    pub fn to_expansion_result(\n-        resolver: Rc<RefCell<BoxedResolver>>,\n-    ) -> ExpansionResult {\n+    pub fn to_resolver_outputs(resolver: Rc<RefCell<BoxedResolver>>) -> ResolverOutputs {\n         match Rc::try_unwrap(resolver) {\n             Ok(resolver) => resolver.into_inner().complete(),\n-            Err(resolver) => {\n-                let resolver = &*resolver;\n-                resolver.borrow_mut().access(|resolver| {\n-                    ExpansionResult::from_resolver_ref(resolver)\n-                })\n-            }\n+            Err(resolver) => resolver.borrow_mut().access(|resolver| resolver.clone_outputs()),\n         }\n     }\n }\n@@ -224,10 +169,11 @@ pub struct PluginInfo {\n \n pub fn register_plugins<'a>(\n     sess: &'a Session,\n-    cstore: &'a CStore,\n+    metadata_loader: &'a dyn MetadataLoader,\n+    register_lints: impl Fn(&Session, &mut lint::LintStore),\n     mut krate: ast::Crate,\n     crate_name: &str,\n-) -> Result<(ast::Crate, PluginInfo)> {\n+) -> Result<(ast::Crate, PluginInfo, Lrc<lint::LintStore>)> {\n     krate = time(sess, \"attributes injection\", || {\n         syntax_ext::cmdline_attrs::inject(\n             krate, &sess.parse_sess, &sess.opts.debugging_opts.crate_attr\n@@ -271,14 +217,20 @@ pub fn register_plugins<'a>(\n     let registrars = time(sess, \"plugin loading\", || {\n         plugin::load::load_plugins(\n             sess,\n-            &cstore,\n+            metadata_loader,\n             &krate,\n-            crate_name,\n             Some(sess.opts.debugging_opts.extra_plugins.clone()),\n         )\n     });\n \n-    let mut registry = Registry::new(sess, krate.span);\n+    let mut lint_store = rustc_lint::new_lint_store(\n+        sess.opts.debugging_opts.no_interleave_lints,\n+        sess.unstable_options(),\n+    );\n+\n+    (register_lints)(&sess, &mut lint_store);\n+\n+    let mut registry = Registry::new(sess, &mut lint_store, krate.span);\n \n     time(sess, \"plugin registration\", || {\n         for registrar in registrars {\n@@ -289,55 +241,40 @@ pub fn register_plugins<'a>(\n \n     let Registry {\n         syntax_exts,\n-        early_lint_passes,\n-        late_lint_passes,\n-        lint_groups,\n         llvm_passes,\n         attributes,\n         ..\n     } = registry;\n \n-    let mut ls = sess.lint_store.borrow_mut();\n-    for pass in early_lint_passes {\n-        ls.register_early_pass(Some(sess), true, false, pass);\n-    }\n-    for pass in late_lint_passes {\n-        ls.register_late_pass(Some(sess), true, false, false, pass);\n-    }\n-\n-    for (name, (to, deprecated_name)) in lint_groups {\n-        ls.register_group(Some(sess), true, name, deprecated_name, to);\n-    }\n-\n     *sess.plugin_llvm_passes.borrow_mut() = llvm_passes;\n     *sess.plugin_attributes.borrow_mut() = attributes;\n \n-    Ok((krate, PluginInfo { syntax_exts }))\n+    Ok((krate, PluginInfo { syntax_exts }, Lrc::new(lint_store)))\n }\n \n fn configure_and_expand_inner<'a>(\n     sess: &'a Session,\n-    cstore: &'a CStore,\n+    lint_store: &'a lint::LintStore,\n     mut krate: ast::Crate,\n     crate_name: &str,\n     resolver_arenas: &'a ResolverArenas<'a>,\n-    crate_loader: &'a CrateLoader<'a>,\n+    metadata_loader: &'a MetadataLoaderDyn,\n     plugin_info: PluginInfo,\n ) -> Result<(ast::Crate, Resolver<'a>)> {\n     time(sess, \"pre-AST-expansion lint checks\", || {\n         lint::check_ast_crate(\n             sess,\n+            lint_store,\n             &krate,\n             true,\n             rustc_lint::BuiltinCombinedPreExpansionLintPass::new());\n     });\n \n     let mut resolver = Resolver::new(\n         sess,\n-        cstore,\n         &krate,\n         crate_name,\n-        crate_loader,\n+        metadata_loader,\n         &resolver_arenas,\n     );\n     syntax_ext::register_builtin_macros(&mut resolver, sess.edition());\n@@ -536,15 +473,15 @@ fn configure_and_expand_inner<'a>(\n \n pub fn lower_to_hir(\n     sess: &Session,\n-    cstore: &CStore,\n+    lint_store: &lint::LintStore,\n     resolver: &mut Resolver<'_>,\n     dep_graph: &DepGraph,\n     krate: &ast::Crate,\n ) -> Result<hir::map::Forest> {\n     // Lower AST to HIR.\n     let hir_forest = time(sess, \"lowering AST -> HIR\", || {\n         let nt_to_tokenstream = syntax::parse::nt_to_tokenstream;\n-        let hir_crate = lower_crate(sess, cstore, &dep_graph, &krate, resolver, nt_to_tokenstream);\n+        let hir_crate = lower_crate(sess, &dep_graph, &krate, resolver, nt_to_tokenstream);\n \n         if sess.opts.debugging_opts.hir_stats {\n             hir_stats::print_hir_stats(&hir_crate);\n@@ -554,7 +491,13 @@ pub fn lower_to_hir(\n     });\n \n     time(sess, \"early lint checks\", || {\n-        lint::check_ast_crate(sess, &krate, false, rustc_lint::BuiltinCombinedEarlyLintPass::new())\n+        lint::check_ast_crate(\n+            sess,\n+            lint_store,\n+            &krate,\n+            false,\n+            rustc_lint::BuiltinCombinedEarlyLintPass::new(),\n+        )\n     });\n \n     // Discard hygiene data, which isn't required after lowering to HIR.\n@@ -644,8 +587,12 @@ fn escape_dep_filename(filename: &FileName) -> String {\n     filename.to_string().replace(\" \", \"\\\\ \")\n }\n \n-fn write_out_deps(compiler: &Compiler, outputs: &OutputFilenames, out_filenames: &[PathBuf]) {\n-    let sess = &compiler.sess;\n+fn write_out_deps(\n+    sess: &Session,\n+    boxed_resolver: &Steal<Rc<RefCell<BoxedResolver>>>,\n+    outputs: &OutputFilenames,\n+    out_filenames: &[PathBuf],\n+) {\n     // Write out dependency rules to the dep-info file if requested\n     if !sess.opts.output_types.contains_key(&OutputType::DepInfo) {\n         return;\n@@ -664,18 +611,20 @@ fn write_out_deps(compiler: &Compiler, outputs: &OutputFilenames, out_filenames:\n             .collect();\n \n         if sess.binary_dep_depinfo() {\n-            for cnum in compiler.cstore.crates_untracked() {\n-                let source = compiler.cstore.crate_source_untracked(cnum);\n-                if let Some((path, _)) = source.dylib {\n-                    files.push(escape_dep_filename(&FileName::Real(path)));\n-                }\n-                if let Some((path, _)) = source.rlib {\n-                    files.push(escape_dep_filename(&FileName::Real(path)));\n+            boxed_resolver.borrow().borrow_mut().access(|resolver| {\n+                for cnum in resolver.cstore().crates_untracked() {\n+                    let source = resolver.cstore().crate_source_untracked(cnum);\n+                    if let Some((path, _)) = source.dylib {\n+                        files.push(escape_dep_filename(&FileName::Real(path)));\n+                    }\n+                    if let Some((path, _)) = source.rlib {\n+                        files.push(escape_dep_filename(&FileName::Real(path)));\n+                    }\n+                    if let Some((path, _)) = source.rmeta {\n+                        files.push(escape_dep_filename(&FileName::Real(path)));\n+                    }\n                 }\n-                if let Some((path, _)) = source.rmeta {\n-                    files.push(escape_dep_filename(&FileName::Real(path)));\n-                }\n-            }\n+            });\n         }\n \n         let mut file = fs::File::create(&deps_filename)?;\n@@ -713,6 +662,7 @@ pub fn prepare_outputs(\n     sess: &Session,\n     compiler: &Compiler,\n     krate: &ast::Crate,\n+    boxed_resolver: &Steal<Rc<RefCell<BoxedResolver>>>,\n     crate_name: &str\n ) -> Result<OutputFilenames> {\n     // FIXME: rustdoc passes &[] instead of &krate.attrs here\n@@ -754,7 +704,7 @@ pub fn prepare_outputs(\n         }\n     }\n \n-    write_out_deps(compiler, &outputs, &output_paths);\n+    write_out_deps(sess, boxed_resolver, &outputs, &output_paths);\n \n     let only_dep_info = sess.opts.output_types.contains_key(&OutputType::DepInfo)\n         && sess.opts.output_types.len() == 1;\n@@ -817,27 +767,26 @@ impl BoxedGlobalCtxt {\n \n pub fn create_global_ctxt(\n     compiler: &Compiler,\n+    lint_store: Lrc<lint::LintStore>,\n     mut hir_forest: hir::map::Forest,\n-    defs: hir::map::Definitions,\n-    resolutions: Resolutions,\n+    mut resolver_outputs: ResolverOutputs,\n     outputs: OutputFilenames,\n     crate_name: &str,\n ) -> BoxedGlobalCtxt {\n     let sess = compiler.session().clone();\n-    let cstore = compiler.cstore.clone();\n     let codegen_backend = compiler.codegen_backend().clone();\n     let crate_name = crate_name.to_string();\n+    let defs = mem::take(&mut resolver_outputs.definitions);\n \n     let ((), result) = BoxedGlobalCtxt::new(static move || {\n         let sess = &*sess;\n-        let cstore = &*cstore;\n \n         let global_ctxt: Option<GlobalCtxt<'_>>;\n         let arenas = AllArenas::new();\n \n         // Construct the HIR map.\n         let hir_map = time(sess, \"indexing HIR\", || {\n-            hir::map::map_crate(sess, cstore, &mut hir_forest, &defs)\n+            hir::map::map_crate(sess, &*resolver_outputs.cstore, &mut hir_forest, &defs)\n         });\n \n         let query_result_on_disk_cache = time(sess, \"load query result cache\", || {\n@@ -854,11 +803,11 @@ pub fn create_global_ctxt(\n \n         let gcx = TyCtxt::create_global_ctxt(\n             sess,\n-            cstore,\n+            lint_store,\n             local_providers,\n             extern_providers,\n             &arenas,\n-            resolutions,\n+            resolver_outputs,\n             hir_map,\n             query_result_on_disk_cache,\n             &crate_name,"}, {"sha": "ea51e63725ea2f117ec4c0b7354fb6660374fca3", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,12 +1,17 @@\n use crate::interface::{Compiler, Result};\n-use crate::passes::{self, BoxedResolver, ExpansionResult, BoxedGlobalCtxt, PluginInfo};\n+use crate::passes::{self, BoxedResolver, BoxedGlobalCtxt, PluginInfo};\n \n use rustc_incremental::DepGraphFuture;\n+use rustc_data_structures::sync::Lrc;\n use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::util::common::{time, ErrorReported};\n use rustc::hir;\n+use rustc::lint;\n+use rustc::session::Session;\n+use rustc::lint::LintStore;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::ty::steal::Steal;\n+use rustc::ty::ResolverOutputs;\n use rustc::dep_graph::DepGraph;\n use std::cell::{Ref, RefMut, RefCell};\n use std::rc::Rc;\n@@ -74,10 +79,10 @@ pub(crate) struct Queries {\n     dep_graph_future: Query<Option<DepGraphFuture>>,\n     parse: Query<ast::Crate>,\n     crate_name: Query<String>,\n-    register_plugins: Query<(ast::Crate, PluginInfo)>,\n-    expansion: Query<(ast::Crate, Steal<Rc<RefCell<BoxedResolver>>>)>,\n+    register_plugins: Query<(ast::Crate, PluginInfo, Lrc<LintStore>)>,\n+    expansion: Query<(ast::Crate, Steal<Rc<RefCell<BoxedResolver>>>, Lrc<LintStore>)>,\n     dep_graph: Query<DepGraph>,\n-    lower_to_hir: Query<(Steal<hir::map::Forest>, ExpansionResult)>,\n+    lower_to_hir: Query<(Steal<hir::map::Forest>, Steal<ResolverOutputs>)>,\n     prepare_outputs: Query<OutputFilenames>,\n     global_ctxt: Query<BoxedGlobalCtxt>,\n     ongoing_codegen: Query<Box<dyn Any>>,\n@@ -106,14 +111,19 @@ impl Compiler {\n         })\n     }\n \n-    pub fn register_plugins(&self) -> Result<&Query<(ast::Crate, PluginInfo)>> {\n+    pub fn register_plugins(&self) -> Result<&Query<(ast::Crate, PluginInfo, Lrc<LintStore>)>> {\n         self.queries.register_plugins.compute(|| {\n             let crate_name = self.crate_name()?.peek().clone();\n             let krate = self.parse()?.take();\n \n+            let empty: &(dyn Fn(&Session, &mut lint::LintStore) + Sync + Send) = &|_, _| {};\n             let result = passes::register_plugins(\n                 self.session(),\n-                self.cstore(),\n+                &*self.codegen_backend().metadata_loader(),\n+                self.register_lints\n+                    .as_ref()\n+                    .map(|p| &**p)\n+                    .unwrap_or_else(|| empty),\n                 krate,\n                 &crate_name,\n             );\n@@ -148,17 +158,20 @@ impl Compiler {\n \n     pub fn expansion(\n         &self\n-    ) -> Result<&Query<(ast::Crate, Steal<Rc<RefCell<BoxedResolver>>>)>> {\n+    ) -> Result<&Query<(ast::Crate, Steal<Rc<RefCell<BoxedResolver>>>, Lrc<LintStore>)>> {\n         self.queries.expansion.compute(|| {\n             let crate_name = self.crate_name()?.peek().clone();\n-            let (krate, plugin_info) = self.register_plugins()?.take();\n+            let (krate, plugin_info, lint_store) = self.register_plugins()?.take();\n             passes::configure_and_expand(\n                 self.sess.clone(),\n-                self.cstore().clone(),\n+                lint_store.clone(),\n+                self.codegen_backend().metadata_loader(),\n                 krate,\n                 &crate_name,\n                 plugin_info,\n-            ).map(|(krate, resolver)| (krate, Steal::new(Rc::new(RefCell::new(resolver)))))\n+            ).map(|(krate, resolver)| {\n+                (krate, Steal::new(Rc::new(RefCell::new(resolver))), lint_store)\n+            })\n         })\n     }\n \n@@ -179,47 +192,51 @@ impl Compiler {\n         })\n     }\n \n-    pub fn lower_to_hir(&self) -> Result<&Query<(Steal<hir::map::Forest>, ExpansionResult)>> {\n+    pub fn lower_to_hir(\n+        &self,\n+    ) -> Result<&Query<(Steal<hir::map::Forest>, Steal<ResolverOutputs>)>> {\n         self.queries.lower_to_hir.compute(|| {\n             let expansion_result = self.expansion()?;\n             let peeked = expansion_result.peek();\n             let krate = &peeked.0;\n             let resolver = peeked.1.steal();\n+            let lint_store = &peeked.2;\n             let hir = Steal::new(resolver.borrow_mut().access(|resolver| {\n                 passes::lower_to_hir(\n                     self.session(),\n-                    self.cstore(),\n+                    lint_store,\n                     resolver,\n                     &*self.dep_graph()?.peek(),\n                     &krate\n                 )\n             })?);\n-            Ok((hir, BoxedResolver::to_expansion_result(resolver)))\n+            Ok((hir, Steal::new(BoxedResolver::to_resolver_outputs(resolver))))\n         })\n     }\n \n     pub fn prepare_outputs(&self) -> Result<&Query<OutputFilenames>> {\n         self.queries.prepare_outputs.compute(|| {\n-            let krate = self.expansion()?;\n-            let krate = krate.peek();\n+            let expansion_result = self.expansion()?;\n+            let (krate, boxed_resolver, _) = &*expansion_result.peek();\n             let crate_name = self.crate_name()?;\n             let crate_name = crate_name.peek();\n-            passes::prepare_outputs(self.session(), self, &krate.0, &*crate_name)\n+            passes::prepare_outputs(self.session(), self, &krate, &boxed_resolver, &crate_name)\n         })\n     }\n \n     pub fn global_ctxt(&self) -> Result<&Query<BoxedGlobalCtxt>> {\n         self.queries.global_ctxt.compute(|| {\n             let crate_name = self.crate_name()?.peek().clone();\n             let outputs = self.prepare_outputs()?.peek().clone();\n+            let lint_store = self.expansion()?.peek().2.clone();\n             let hir = self.lower_to_hir()?;\n             let hir = hir.peek();\n-            let (ref hir_forest, ref expansion) = *hir;\n+            let (hir_forest, resolver_outputs) = &*hir;\n             Ok(passes::create_global_ctxt(\n                 self,\n+                lint_store,\n                 hir_forest.steal(),\n-                expansion.defs.steal(),\n-                expansion.resolutions.steal(),\n+                resolver_outputs.steal(),\n                 outputs,\n                 &crate_name))\n         })"}, {"sha": "8f11dc93727280c2345cbffca81cab15c0f4ff9d", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -13,7 +13,6 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc_errors::registry::Registry;\n-use rustc_lint;\n use rustc_metadata::dynamic_lib::DynamicLibrary;\n use rustc_mir;\n use rustc_passes;\n@@ -108,11 +107,6 @@ pub fn create_session(\n \n     let codegen_backend = get_codegen_backend(&sess);\n \n-    rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-    if sess.unstable_options() {\n-        rustc_lint::register_internals(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-    }\n-\n     let mut cfg = config::build_configuration(&sess, config::to_crate_config(cfg));\n     add_configuration(&mut cfg, &sess, &*codegen_backend);\n     sess.parse_sess.config = cfg;"}, {"sha": "ad674911e6f332c79f7b1b480fb579eb40fcbb8a", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -27,6 +27,7 @@ use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::ty::{self, Ty, TyCtxt, layout::VariantIdx};\n use rustc::{lint, util};\n+use rustc::lint::FutureIncompatibleInfo;\n use hir::Node;\n use util::nodemap::HirIdSet;\n use lint::{LateContext, LintContext, LintArray};\n@@ -280,7 +281,7 @@ declare_lint! {\n     pub MISSING_DOCS,\n     Allow,\n     \"detects missing documentation for public members\",\n-    report_in_external_macro: true\n+    report_in_external_macro\n }\n \n pub struct MissingDoc {\n@@ -601,7 +602,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n declare_lint! {\n     pub ANONYMOUS_PARAMETERS,\n     Allow,\n-    \"detects anonymous parameters\"\n+    \"detects anonymous parameters\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #41686 <https://github.com/rust-lang/rust/issues/41686>\",\n+        edition: Some(Edition::Edition2018),\n+    };\n }\n \n declare_lint_pass!(\n@@ -1344,7 +1349,7 @@ declare_lint! {\n     UNNAMEABLE_TEST_ITEMS,\n     Warn,\n     \"detects an item that cannot be named being marked as `#[test_case]`\",\n-    report_in_external_macro: true\n+    report_in_external_macro\n }\n \n pub struct UnnameableTestItems {\n@@ -1393,7 +1398,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n declare_lint! {\n     pub KEYWORD_IDENTS,\n     Allow,\n-    \"detects edition keywords being used as an identifier\"\n+    \"detects edition keywords being used as an identifier\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #49716 <https://github.com/rust-lang/rust/issues/49716>\",\n+        edition: Some(Edition::Edition2018),\n+    };\n }\n \n declare_lint_pass!("}, {"sha": "b1beef04c5929bd3b26ac49ede799df78c704628", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 39, "deletions": 197, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -33,27 +33,21 @@ use rustc::lint;\n use rustc::lint::{EarlyContext, LateContext, LateLintPass, EarlyLintPass, LintPass, LintArray};\n use rustc::lint::builtin::{\n     BARE_TRAIT_OBJECTS,\n-    ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n     ELIDED_LIFETIMES_IN_PATHS,\n     EXPLICIT_OUTLIVES_REQUIREMENTS,\n     INTRA_DOC_LINK_RESOLUTION_FAILURE,\n     MISSING_DOC_CODE_EXAMPLES,\n     PRIVATE_DOC_TESTS,\n-    parser::ILL_FORMED_ATTRIBUTE_INPUT,\n };\n-use rustc::session;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::ty::query::Providers;\n use rustc::ty::TyCtxt;\n \n use syntax::ast;\n-use syntax::edition::Edition;\n use syntax_pos::Span;\n \n-use session::Session;\n use lint::LintId;\n-use lint::FutureIncompatibleInfo;\n \n use redundant_semicolon::*;\n use nonstandard_style::*;\n@@ -192,59 +186,60 @@ late_lint_passes!(declare_combined_late_pass, [pub BuiltinCombinedLateLintPass])\n \n late_lint_mod_passes!(declare_combined_late_pass, [BuiltinCombinedModuleLateLintPass]);\n \n+pub fn new_lint_store(no_interleave_lints: bool, internal_lints: bool) -> lint::LintStore {\n+    let mut lint_store = lint::LintStore::new();\n+\n+    register_builtins(&mut lint_store, no_interleave_lints);\n+    if internal_lints {\n+        register_internals(&mut lint_store);\n+    }\n+\n+    lint_store\n+}\n+\n /// Tell the `LintStore` about all the built-in lints (the ones\n /// defined in this crate and the ones defined in\n /// `rustc::lint::builtin`).\n-pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n+fn register_builtins(store: &mut lint::LintStore, no_interleave_lints: bool) {\n     macro_rules! add_lint_group {\n-        ($sess:ident, $name:expr, $($lint:ident),*) => (\n-            store.register_group($sess, false, $name, None, vec![$(LintId::of($lint)),*]);\n+        ($name:expr, $($lint:ident),*) => (\n+            store.register_group(false, $name, None, vec![$(LintId::of($lint)),*]);\n         )\n     }\n \n     macro_rules! register_pass {\n-        ($method:ident, $constructor:expr, [$($args:expr),*]) => (\n-            store.$method(sess, false, false, $($args,)* box $constructor);\n+        ($method:ident, $ty:ident, $constructor:expr) => (\n+            store.register_lints(&$ty::get_lints());\n+            store.$method(|| box $constructor);\n         )\n     }\n \n     macro_rules! register_passes {\n-        ([$method:ident, $args:tt], [$($passes:ident: $constructor:expr,)*]) => (\n+        ($method:ident, [$($passes:ident: $constructor:expr,)*]) => (\n             $(\n-                register_pass!($method, $constructor, $args);\n+                register_pass!($method, $passes, $constructor);\n             )*\n         )\n     }\n \n-    if sess.map(|sess| sess.opts.debugging_opts.no_interleave_lints).unwrap_or(false) {\n-        pre_expansion_lint_passes!(register_passes, [register_pre_expansion_pass, []]);\n-        early_lint_passes!(register_passes, [register_early_pass, []]);\n-        late_lint_passes!(register_passes, [register_late_pass, [false]]);\n-        late_lint_mod_passes!(register_passes, [register_late_pass, [true]]);\n+    if no_interleave_lints {\n+        pre_expansion_lint_passes!(register_passes, register_pre_expansion_pass);\n+        early_lint_passes!(register_passes, register_early_pass);\n+        late_lint_passes!(register_passes, register_late_pass);\n+        late_lint_mod_passes!(register_passes, register_late_mod_pass);\n     } else {\n-        store.register_pre_expansion_pass(\n-            sess,\n-            false,\n-            true,\n-            box BuiltinCombinedPreExpansionLintPass::new()\n-        );\n-        store.register_early_pass(sess, false, true, box BuiltinCombinedEarlyLintPass::new());\n-        store.register_late_pass(\n-            sess, false, true, true, box BuiltinCombinedModuleLateLintPass::new()\n-        );\n-        store.register_late_pass(\n-            sess, false, true, false, box BuiltinCombinedLateLintPass::new()\n-        );\n+        store.register_lints(&BuiltinCombinedPreExpansionLintPass::get_lints());\n+        store.register_lints(&BuiltinCombinedEarlyLintPass::get_lints());\n+        store.register_lints(&BuiltinCombinedModuleLateLintPass::get_lints());\n+        store.register_lints(&BuiltinCombinedLateLintPass::get_lints());\n     }\n \n-    add_lint_group!(sess,\n-                    \"nonstandard_style\",\n+    add_lint_group!(\"nonstandard_style\",\n                     NON_CAMEL_CASE_TYPES,\n                     NON_SNAKE_CASE,\n                     NON_UPPER_CASE_GLOBALS);\n \n-    add_lint_group!(sess,\n-                    \"unused\",\n+    add_lint_group!(\"unused\",\n                     UNUSED_IMPORTS,\n                     UNUSED_VARIABLES,\n                     UNUSED_ASSIGNMENTS,\n@@ -265,8 +260,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                     UNUSED_LABELS,\n                     UNUSED_PARENS);\n \n-    add_lint_group!(sess,\n-                    \"rust_2018_idioms\",\n+    add_lint_group!(\"rust_2018_idioms\",\n                     BARE_TRAIT_OBJECTS,\n                     UNUSED_EXTERN_CRATES,\n                     ELLIPSIS_INCLUSIVE_RANGE_PATTERNS,\n@@ -282,165 +276,11 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                     // MACRO_USE_EXTERN_CRATE,\n                     );\n \n-    add_lint_group!(sess,\n-                    \"rustdoc\",\n+    add_lint_group!(\"rustdoc\",\n                     INTRA_DOC_LINK_RESOLUTION_FAILURE,\n                     MISSING_DOC_CODE_EXAMPLES,\n                     PRIVATE_DOC_TESTS);\n \n-    // Guidelines for creating a future incompatibility lint:\n-    //\n-    // - Create a lint defaulting to warn as normal, with ideally the same error\n-    //   message you would normally give\n-    // - Add a suitable reference, typically an RFC or tracking issue. Go ahead\n-    //   and include the full URL, sort items in ascending order of issue numbers.\n-    // - Later, change lint to error\n-    // - Eventually, remove lint\n-    store.register_future_incompatible(sess, vec![\n-        FutureIncompatibleInfo {\n-            id: LintId::of(PRIVATE_IN_PUBLIC),\n-            reference: \"issue #34537 <https://github.com/rust-lang/rust/issues/34537>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(PUB_USE_OF_PRIVATE_EXTERN_CRATE),\n-            reference: \"issue #34537 <https://github.com/rust-lang/rust/issues/34537>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(PATTERNS_IN_FNS_WITHOUT_BODY),\n-            reference: \"issue #35203 <https://github.com/rust-lang/rust/issues/35203>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(DUPLICATE_MACRO_EXPORTS),\n-            reference: \"issue #35896 <https://github.com/rust-lang/rust/issues/35896>\",\n-            edition: Some(Edition::Edition2018),\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(KEYWORD_IDENTS),\n-            reference: \"issue #49716 <https://github.com/rust-lang/rust/issues/49716>\",\n-            edition: Some(Edition::Edition2018),\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(SAFE_EXTERN_STATICS),\n-            reference: \"issue #36247 <https://github.com/rust-lang/rust/issues/36247>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(INVALID_TYPE_PARAM_DEFAULT),\n-            reference: \"issue #36887 <https://github.com/rust-lang/rust/issues/36887>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(LEGACY_DIRECTORY_OWNERSHIP),\n-            reference: \"issue #37872 <https://github.com/rust-lang/rust/issues/37872>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(LEGACY_CONSTRUCTOR_VISIBILITY),\n-            reference: \"issue #39207 <https://github.com/rust-lang/rust/issues/39207>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(MISSING_FRAGMENT_SPECIFIER),\n-            reference: \"issue #40107 <https://github.com/rust-lang/rust/issues/40107>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(ILLEGAL_FLOATING_POINT_LITERAL_PATTERN),\n-            reference: \"issue #41620 <https://github.com/rust-lang/rust/issues/41620>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(ANONYMOUS_PARAMETERS),\n-            reference: \"issue #41686 <https://github.com/rust-lang/rust/issues/41686>\",\n-            edition: Some(Edition::Edition2018),\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES),\n-            reference: \"issue #42238 <https://github.com/rust-lang/rust/issues/42238>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(LATE_BOUND_LIFETIME_ARGUMENTS),\n-            reference: \"issue #42868 <https://github.com/rust-lang/rust/issues/42868>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(SAFE_PACKED_BORROWS),\n-            reference: \"issue #46043 <https://github.com/rust-lang/rust/issues/46043>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(ORDER_DEPENDENT_TRAIT_OBJECTS),\n-            reference: \"issue #56484 <https://github.com/rust-lang/rust/issues/56484>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(TYVAR_BEHIND_RAW_POINTER),\n-            reference: \"issue #46906 <https://github.com/rust-lang/rust/issues/46906>\",\n-            edition: Some(Edition::Edition2018),\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(UNSTABLE_NAME_COLLISIONS),\n-            reference: \"issue #48919 <https://github.com/rust-lang/rust/issues/48919>\",\n-            edition: None,\n-            // Note: this item represents future incompatibility of all unstable functions in the\n-            //       standard library, and thus should never be removed or changed to an error.\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE),\n-            reference: \"issue #53130 <https://github.com/rust-lang/rust/issues/53130>\",\n-            edition: Some(Edition::Edition2018),\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(WHERE_CLAUSES_OBJECT_SAFETY),\n-            reference: \"issue #51443 <https://github.com/rust-lang/rust/issues/51443>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(PROC_MACRO_DERIVE_RESOLUTION_FALLBACK),\n-            reference: \"issue #50504 <https://github.com/rust-lang/rust/issues/50504>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS),\n-            reference: \"issue #52234 <https://github.com/rust-lang/rust/issues/52234>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(ILL_FORMED_ATTRIBUTE_INPUT),\n-            reference: \"issue #57571 <https://github.com/rust-lang/rust/issues/57571>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(AMBIGUOUS_ASSOCIATED_ITEMS),\n-            reference: \"issue #57644 <https://github.com/rust-lang/rust/issues/57644>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(NESTED_IMPL_TRAIT),\n-            reference: \"issue #59014 <https://github.com/rust-lang/rust/issues/59014>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(MUTABLE_BORROW_RESERVATION_CONFLICT),\n-            reference: \"issue #59159 <https://github.com/rust-lang/rust/issues/59159>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(INDIRECT_STRUCTURAL_MATCH),\n-            reference: \"issue #62411 <https://github.com/rust-lang/rust/issues/62411>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(SOFT_UNSTABLE),\n-            reference: \"issue #64266 <https://github.com/rust-lang/rust/issues/64266>\",\n-            edition: None,\n-        },\n-        ]);\n-\n     // Register renamed and removed lints.\n     store.register_renamed(\"single_use_lifetime\", \"single_use_lifetimes\");\n     store.register_renamed(\"elided_lifetime_in_path\", \"elided_lifetimes_in_paths\");\n@@ -496,12 +336,14 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n         \"converted into hard error, see https://github.com/rust-lang/rust/issues/46205\");\n }\n \n-pub fn register_internals(store: &mut lint::LintStore, sess: Option<&Session>) {\n-    store.register_early_pass(sess, false, false, box DefaultHashTypes::new());\n-    store.register_early_pass(sess, false, false, box LintPassImpl);\n-    store.register_late_pass(sess, false, false, false, box TyTyKind);\n+fn register_internals(store: &mut lint::LintStore) {\n+    store.register_lints(&DefaultHashTypes::get_lints());\n+    store.register_early_pass(|| box DefaultHashTypes::new());\n+    store.register_lints(&LintPassImpl::get_lints());\n+    store.register_early_pass(|| box LintPassImpl);\n+    store.register_lints(&TyTyKind::get_lints());\n+    store.register_late_pass(|| box TyTyKind);\n     store.register_group(\n-        sess,\n         false,\n         \"rustc::internal\",\n         None,"}, {"sha": "61b8cbe369aab20fef07c0e036447e90d94b6e19", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -25,7 +25,7 @@ declare_lint! {\n     pub UNUSED_MUST_USE,\n     Warn,\n     \"unused result of a type flagged as `#[must_use]`\",\n-    report_in_external_macro: true\n+    report_in_external_macro\n }\n \n declare_lint! {"}, {"sha": "f0a68058de8ca89e414d553f6669d509c1134bb5", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 57, "deletions": 160, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -3,7 +3,7 @@\n use crate::cstore::{self, CStore, MetadataBlob};\n use crate::locator::{self, CratePaths};\n use crate::schema::{CrateRoot, CrateDep};\n-use rustc_data_structures::sync::{Lrc, RwLock, Lock, AtomicCell};\n+use rustc_data_structures::sync::{RwLock, Lock, AtomicCell};\n \n use rustc::hir::def_id::CrateNum;\n use rustc_data_structures::svh::Svh;\n@@ -14,21 +14,20 @@ use rustc::session::{Session, CrateDisambiguator};\n use rustc::session::config::{Sanitizer, self};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n use rustc::session::search_paths::PathKind;\n-use rustc::middle::cstore::{CrateSource, ExternCrate, ExternCrateSource};\n+use rustc::middle::cstore::{CrateSource, ExternCrate, ExternCrateSource, MetadataLoaderDyn};\n use rustc::util::common::record_time;\n use rustc::util::nodemap::FxHashSet;\n use rustc::hir::map::Definitions;\n use rustc::hir::def_id::LOCAL_CRATE;\n \n-use std::ops::Deref;\n-use std::path::{Path, PathBuf};\n+use std::path::Path;\n use std::{cmp, fs};\n \n use syntax::ast;\n use syntax::attr;\n use syntax_expand::allocator::{global_allocator_spans, AllocatorKind};\n use syntax::symbol::{Symbol, sym};\n-use syntax::{span_err, span_fatal};\n+use syntax::span_fatal;\n use syntax_pos::{Span, DUMMY_SP};\n use log::{debug, info, log_enabled};\n use proc_macro::bridge::client::ProcMacro;\n@@ -39,9 +38,12 @@ crate struct Library {\n }\n \n pub struct CrateLoader<'a> {\n+    // Immutable configuration.\n     sess: &'a Session,\n-    cstore: &'a CStore,\n+    metadata_loader: &'a MetadataLoaderDyn,\n     local_crate_name: Symbol,\n+    // Mutable output.\n+    cstore: CStore,\n }\n \n fn dump_crates(cstore: &CStore) {\n@@ -58,29 +60,6 @@ fn dump_crates(cstore: &CStore) {\n     });\n }\n \n-// Extra info about a crate loaded for plugins or exported macros.\n-struct ExtensionCrate {\n-    metadata: PMDSource,\n-    dylib: Option<PathBuf>,\n-    target_only: bool,\n-}\n-\n-enum PMDSource {\n-    Registered(Lrc<cstore::CrateMetadata>),\n-    Owned(Library),\n-}\n-\n-impl Deref for PMDSource {\n-    type Target = MetadataBlob;\n-\n-    fn deref(&self) -> &MetadataBlob {\n-        match *self {\n-            PMDSource::Registered(ref cmd) => &cmd.blob,\n-            PMDSource::Owned(ref lib) => &lib.metadata\n-        }\n-    }\n-}\n-\n enum LoadResult {\n     Previous(CrateNum),\n     Loaded(Library),\n@@ -99,14 +78,27 @@ impl<'a> LoadError<'a> {\n }\n \n impl<'a> CrateLoader<'a> {\n-    pub fn new(sess: &'a Session, cstore: &'a CStore, local_crate_name: &str) -> Self {\n+    pub fn new(\n+        sess: &'a Session,\n+        metadata_loader: &'a MetadataLoaderDyn,\n+        local_crate_name: &str,\n+    ) -> Self {\n         CrateLoader {\n             sess,\n-            cstore,\n+            metadata_loader,\n             local_crate_name: Symbol::intern(local_crate_name),\n+            cstore: Default::default(),\n         }\n     }\n \n+    pub fn cstore(&self) -> &CStore {\n+        &self.cstore\n+    }\n+\n+    pub fn into_cstore(self) -> CStore {\n+        self.cstore\n+    }\n+\n     fn existing_match(&self, name: Symbol, hash: Option<&Svh>, kind: PathKind)\n                       -> Option<CrateNum> {\n         let mut ret = None;\n@@ -187,14 +179,14 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn register_crate(\n-        &self,\n+        &mut self,\n         host_lib: Option<Library>,\n         root: Option<&CratePaths>,\n         span: Span,\n         lib: Library,\n         dep_kind: DepKind,\n         name: Symbol\n-    ) -> (CrateNum, Lrc<cstore::CrateMetadata>) {\n+    ) -> CrateNum {\n         let _prof_timer = self.sess.prof.generic_activity(\"metadata_register_crate\");\n \n         let Library { source, metadata } = lib;\n@@ -248,9 +240,9 @@ impl<'a> CrateLoader<'a> {\n             crate_root.def_path_table.decode((&metadata, self.sess))\n         });\n \n-        let cmeta = cstore::CrateMetadata {\n+        self.cstore.set_crate_data(cnum, cstore::CrateMetadata {\n             extern_crate: Lock::new(None),\n-            def_path_table: Lrc::new(def_path_table),\n+            def_path_table,\n             trait_impls,\n             root: crate_root,\n             blob: metadata,\n@@ -264,11 +256,9 @@ impl<'a> CrateLoader<'a> {\n             private_dep,\n             raw_proc_macros,\n             dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n-        };\n+        });\n \n-        let cmeta = Lrc::new(cmeta);\n-        self.cstore.set_crate_data(cnum, cmeta.clone());\n-        (cnum, cmeta)\n+        cnum\n     }\n \n     fn load_proc_macro<'b>(\n@@ -327,22 +317,22 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn resolve_crate<'b>(\n-        &'b self,\n+        &'b mut self,\n         name: Symbol,\n         span: Span,\n         dep_kind: DepKind,\n         dep: Option<(&'b CratePaths, &'b CrateDep)>,\n-    ) -> (CrateNum, Lrc<cstore::CrateMetadata>) {\n+    ) -> CrateNum {\n         self.maybe_resolve_crate(name, span, dep_kind, dep).unwrap_or_else(|err| err.report())\n     }\n \n     fn maybe_resolve_crate<'b>(\n-        &'b self,\n+        &'b mut self,\n         name: Symbol,\n         span: Span,\n         mut dep_kind: DepKind,\n         dep: Option<(&'b CratePaths, &'b CrateDep)>,\n-    ) -> Result<(CrateNum, Lrc<cstore::CrateMetadata>), LoadError<'b>> {\n+    ) -> Result<CrateNum, LoadError<'b>> {\n         info!(\"resolving crate `{}`\", name);\n         let (root, hash, extra_filename, path_kind) = match dep {\n             Some((root, dep)) =>\n@@ -370,7 +360,7 @@ impl<'a> CrateLoader<'a> {\n                 rejected_via_filename: vec![],\n                 should_match_name: true,\n                 is_proc_macro: Some(false),\n-                metadata_loader: &*self.cstore.metadata_loader,\n+                metadata_loader: self.metadata_loader,\n             };\n \n             self.load(&mut locate_ctxt).map(|r| (r, None)).or_else(|| {\n@@ -388,7 +378,7 @@ impl<'a> CrateLoader<'a> {\n                 data.dep_kind.with_lock(|data_dep_kind| {\n                     *data_dep_kind = cmp::max(*data_dep_kind, dep_kind);\n                 });\n-                Ok((cnum, data))\n+                Ok(cnum)\n             }\n             (LoadResult::Loaded(library), host_library) => {\n                 Ok(self.register_crate(host_library, root, span, library, dep_kind, name))\n@@ -466,7 +456,7 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     // Go through the crate metadata and load any crates that it references\n-    fn resolve_crate_deps(&self,\n+    fn resolve_crate_deps(&mut self,\n                           root: &CratePaths,\n                           crate_root: &CrateRoot<'_>,\n                           metadata: &MetadataBlob,\n@@ -492,73 +482,10 @@ impl<'a> CrateLoader<'a> {\n                 DepKind::MacrosOnly => DepKind::MacrosOnly,\n                 _ => dep.kind,\n             };\n-            self.resolve_crate(dep.name, span, dep_kind, Some((root, &dep))).0\n+            self.resolve_crate(dep.name, span, dep_kind, Some((root, &dep)))\n         })).collect()\n     }\n \n-    fn read_extension_crate(&self, name: Symbol, span: Span) -> ExtensionCrate {\n-        info!(\"read extension crate `{}`\", name);\n-        let target_triple = self.sess.opts.target_triple.clone();\n-        let host_triple = TargetTriple::from_triple(config::host_triple());\n-        let is_cross = target_triple != host_triple;\n-        let mut target_only = false;\n-        let mut locate_ctxt = locator::Context {\n-            sess: self.sess,\n-            span,\n-            crate_name: name,\n-            hash: None,\n-            extra_filename: None,\n-            filesearch: self.sess.host_filesearch(PathKind::Crate),\n-            target: &self.sess.host,\n-            triple: host_triple,\n-            root: None,\n-            rejected_via_hash: vec![],\n-            rejected_via_triple: vec![],\n-            rejected_via_kind: vec![],\n-            rejected_via_version: vec![],\n-            rejected_via_filename: vec![],\n-            should_match_name: true,\n-            is_proc_macro: None,\n-            metadata_loader: &*self.cstore.metadata_loader,\n-        };\n-        let library = self.load(&mut locate_ctxt).or_else(|| {\n-            if !is_cross {\n-                return None\n-            }\n-            // Try loading from target crates. This will abort later if we\n-            // try to load a plugin registrar function,\n-            target_only = true;\n-\n-            locate_ctxt.target = &self.sess.target.target;\n-            locate_ctxt.triple = target_triple;\n-            locate_ctxt.filesearch = self.sess.target_filesearch(PathKind::Crate);\n-\n-            self.load(&mut locate_ctxt)\n-        });\n-        let library = match library {\n-            Some(l) => l,\n-            None => locate_ctxt.report_errs(),\n-        };\n-\n-        let (dylib, metadata) = match library {\n-            LoadResult::Previous(cnum) => {\n-                let data = self.cstore.get_crate_data(cnum);\n-                (data.source.dylib.clone(), PMDSource::Registered(data))\n-            }\n-            LoadResult::Loaded(library) => {\n-                let dylib = library.source.dylib.clone();\n-                let metadata = PMDSource::Owned(library);\n-                (dylib, metadata)\n-            }\n-        };\n-\n-        ExtensionCrate {\n-            metadata,\n-            dylib: dylib.map(|p| p.0),\n-            target_only,\n-        }\n-    }\n-\n     fn dlsym_proc_macros(&self,\n                          path: &Path,\n                          disambiguator: CrateDisambiguator,\n@@ -590,42 +517,7 @@ impl<'a> CrateLoader<'a> {\n         decls\n     }\n \n-    /// Look for a plugin registrar. Returns library path, crate\n-    /// SVH and DefIndex of the registrar function.\n-    pub fn find_plugin_registrar(&self,\n-                                 span: Span,\n-                                 name: Symbol)\n-                                 -> Option<(PathBuf, CrateDisambiguator)> {\n-        let ekrate = self.read_extension_crate(name, span);\n-\n-        if ekrate.target_only {\n-            // Need to abort before syntax expansion.\n-            let message = format!(\"plugin `{}` is not available for triple `{}` \\\n-                                   (only found {})\",\n-                                  name,\n-                                  config::host_triple(),\n-                                  self.sess.opts.target_triple);\n-            span_fatal!(self.sess, span, E0456, \"{}\", &message);\n-        }\n-\n-        let root = ekrate.metadata.get_root();\n-        match ekrate.dylib.as_ref() {\n-            Some(dylib) => {\n-                Some((dylib.to_path_buf(), root.disambiguator))\n-            }\n-            None => {\n-                span_err!(self.sess, span, E0457,\n-                          \"plugin `{}` only found in rlib format, but must be available \\\n-                           in dylib format\",\n-                          name);\n-                // No need to abort because the loading code will just ignore this\n-                // empty dylib.\n-                None\n-            }\n-        }\n-    }\n-\n-    fn inject_panic_runtime(&self, krate: &ast::Crate) {\n+    fn inject_panic_runtime(&mut self, krate: &ast::Crate) {\n         // If we're only compiling an rlib, then there's no need to select a\n         // panic runtime, so we just skip this section entirely.\n         let any_non_rlib = self.sess.crate_types.borrow().iter().any(|ct| {\n@@ -687,7 +579,8 @@ impl<'a> CrateLoader<'a> {\n         };\n         info!(\"panic runtime not found -- loading {}\", name);\n \n-        let (cnum, data) = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None);\n+        let cnum = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None);\n+        let data = self.cstore.get_crate_data(cnum);\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n@@ -706,7 +599,7 @@ impl<'a> CrateLoader<'a> {\n                                   &|data| data.root.needs_panic_runtime);\n     }\n \n-    fn inject_sanitizer_runtime(&self) {\n+    fn inject_sanitizer_runtime(&mut self) {\n         if let Some(ref sanitizer) = self.sess.opts.debugging_opts.sanitizer {\n             // Sanitizers can only be used on some tested platforms with\n             // executables linked to `std`\n@@ -791,7 +684,8 @@ impl<'a> CrateLoader<'a> {\n                 });\n                 info!(\"loading sanitizer: {}\", name);\n \n-                let data = self.resolve_crate(name, DUMMY_SP, DepKind::Explicit, None).1;\n+                let cnum = self.resolve_crate(name, DUMMY_SP, DepKind::Explicit, None);\n+                let data = self.cstore.get_crate_data(cnum);\n \n                 // Sanity check the loaded crate to ensure it is indeed a sanitizer runtime\n                 if !data.root.sanitizer_runtime {\n@@ -804,14 +698,15 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn inject_profiler_runtime(&self) {\n+    fn inject_profiler_runtime(&mut self) {\n         if self.sess.opts.debugging_opts.profile ||\n            self.sess.opts.cg.profile_generate.enabled()\n         {\n             info!(\"loading profiler\");\n \n             let name = Symbol::intern(\"profiler_builtins\");\n-            let data = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None).1;\n+            let cnum = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None);\n+            let data = self.cstore.get_crate_data(cnum);\n \n             // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n             if !data.root.profiler_runtime {\n@@ -957,10 +852,8 @@ impl<'a> CrateLoader<'a> {\n             data.dependencies.borrow_mut().push(krate);\n         });\n     }\n-}\n \n-impl<'a> CrateLoader<'a> {\n-    pub fn postprocess(&self, krate: &ast::Crate) {\n+    pub fn postprocess(&mut self, krate: &ast::Crate) {\n         self.inject_sanitizer_runtime();\n         self.inject_profiler_runtime();\n         self.inject_allocator_crate(krate);\n@@ -971,7 +864,11 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    pub fn process_extern_crate(&self, item: &ast::Item, definitions: &Definitions) -> CrateNum {\n+    pub fn process_extern_crate(\n+        &mut self,\n+        item: &ast::Item,\n+        definitions: &Definitions,\n+    ) -> CrateNum {\n         match item.kind {\n             ast::ItemKind::ExternCrate(orig_name) => {\n                 debug!(\"resolving extern crate stmt. ident: {} orig_name: {:?}\",\n@@ -990,7 +887,7 @@ impl<'a> CrateLoader<'a> {\n                     DepKind::Explicit\n                 };\n \n-                let cnum = self.resolve_crate(name, item.span, dep_kind, None).0;\n+                let cnum = self.resolve_crate(name, item.span, dep_kind, None);\n \n                 let def_id = definitions.opt_local_def_id(item.id).unwrap();\n                 let path_len = definitions.def_path(def_id.index).data.len();\n@@ -1010,8 +907,8 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    pub fn process_path_extern(&self, name: Symbol, span: Span) -> CrateNum {\n-        let cnum = self.resolve_crate(name, span, DepKind::Explicit, None).0;\n+    pub fn process_path_extern(&mut self, name: Symbol, span: Span) -> CrateNum {\n+        let cnum = self.resolve_crate(name, span, DepKind::Explicit, None);\n \n         self.update_extern_crate(\n             cnum,\n@@ -1028,8 +925,8 @@ impl<'a> CrateLoader<'a> {\n         cnum\n     }\n \n-    pub fn maybe_process_path_extern(&self, name: Symbol, span: Span) -> Option<CrateNum> {\n-        let cnum = self.maybe_resolve_crate(name, span, DepKind::Explicit, None).ok()?.0;\n+    pub fn maybe_process_path_extern(&mut self, name: Symbol, span: Span) -> Option<CrateNum> {\n+        let cnum = self.maybe_resolve_crate(name, span, DepKind::Explicit, None).ok()?;\n \n         self.update_extern_crate(\n             cnum,"}, {"sha": "6b06cf575edcf5557aeddaf70335f4f4e7e809de", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -5,12 +5,13 @@ use crate::schema;\n use rustc::dep_graph::DepNodeIndex;\n use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::map::definitions::DefPathTable;\n-use rustc::middle::cstore::{CrateSource, DepKind, ExternCrate, MetadataLoader};\n+use rustc::middle::cstore::{CrateSource, DepKind, ExternCrate};\n use rustc::mir::interpret::AllocDecodingState;\n use rustc_index::vec::IndexVec;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::sync::{Lrc, RwLock, Lock, MetadataRef, AtomicCell};\n use syntax::ast;\n+use syntax::edition::Edition;\n use syntax_expand::base::SyntaxExtension;\n use syntax_pos;\n use proc_macro::bridge::client::ProcMacro;\n@@ -36,7 +37,7 @@ crate struct ImportedSourceFile {\n     pub translated_source_file: Lrc<syntax_pos::SourceFile>,\n }\n \n-pub struct CrateMetadata {\n+crate struct CrateMetadata {\n     /// The primary crate data - binary metadata blob.\n     crate blob: MetadataBlob,\n \n@@ -53,7 +54,7 @@ pub struct CrateMetadata {\n     /// hashmap, which gives the reverse mapping. This allows us to\n     /// quickly retrace a `DefPath`, which is needed for incremental\n     /// compilation support.\n-    crate def_path_table: Lrc<DefPathTable>,\n+    crate def_path_table: DefPathTable,\n     /// Trait impl data.\n     /// FIXME: Used only from queries and can use query cache,\n     /// so pre-decoding can probably be avoided.\n@@ -94,50 +95,48 @@ pub struct CrateMetadata {\n     crate extern_crate: Lock<Option<ExternCrate>>,\n }\n \n+#[derive(Clone)]\n pub struct CStore {\n-    metas: RwLock<IndexVec<CrateNum, Option<Lrc<CrateMetadata>>>>,\n-    crate metadata_loader: Box<dyn MetadataLoader + Sync>,\n+    metas: IndexVec<CrateNum, Option<Lrc<CrateMetadata>>>,\n }\n \n pub enum LoadedMacro {\n-    MacroDef(ast::Item),\n+    MacroDef(ast::Item, Edition),\n     ProcMacro(SyntaxExtension),\n }\n \n-impl CStore {\n-    pub fn new(metadata_loader: Box<dyn MetadataLoader + Sync>) -> CStore {\n+impl Default for CStore {\n+    fn default() -> Self {\n         CStore {\n             // We add an empty entry for LOCAL_CRATE (which maps to zero) in\n             // order to make array indices in `metas` match with the\n             // corresponding `CrateNum`. This first entry will always remain\n             // `None`.\n-            metas: RwLock::new(IndexVec::from_elem_n(None, 1)),\n-            metadata_loader,\n+            metas: IndexVec::from_elem_n(None, 1),\n         }\n     }\n+}\n \n-    crate fn alloc_new_crate_num(&self) -> CrateNum {\n-        let mut metas = self.metas.borrow_mut();\n-        let cnum = CrateNum::new(metas.len());\n-        metas.push(None);\n-        cnum\n+impl CStore {\n+    crate fn alloc_new_crate_num(&mut self) -> CrateNum {\n+        self.metas.push(None);\n+        CrateNum::new(self.metas.len() - 1)\n     }\n \n-    crate fn get_crate_data(&self, cnum: CrateNum) -> Lrc<CrateMetadata> {\n-        self.metas.borrow()[cnum].clone()\n+    crate fn get_crate_data(&self, cnum: CrateNum) -> &CrateMetadata {\n+        self.metas[cnum].as_ref()\n             .unwrap_or_else(|| panic!(\"Failed to get crate data for {:?}\", cnum))\n     }\n \n-    crate fn set_crate_data(&self, cnum: CrateNum, data: Lrc<CrateMetadata>) {\n-        let mut metas = self.metas.borrow_mut();\n-        assert!(metas[cnum].is_none(), \"Overwriting crate metadata entry\");\n-        metas[cnum] = Some(data);\n+    crate fn set_crate_data(&mut self, cnum: CrateNum, data: CrateMetadata) {\n+        assert!(self.metas[cnum].is_none(), \"Overwriting crate metadata entry\");\n+        self.metas[cnum] = Some(Lrc::new(data));\n     }\n \n     crate fn iter_crate_data<I>(&self, mut i: I)\n-        where I: FnMut(CrateNum, &Lrc<CrateMetadata>)\n+        where I: FnMut(CrateNum, &CrateMetadata)\n     {\n-        for (k, v) in self.metas.borrow().iter_enumerated() {\n+        for (k, v) in self.metas.iter_enumerated() {\n             if let &Some(ref v) = v {\n                 i(k, v);\n             }\n@@ -168,7 +167,7 @@ impl CStore {\n \n     crate fn do_postorder_cnums_untracked(&self) -> Vec<CrateNum> {\n         let mut ordering = Vec::new();\n-        for (num, v) in self.metas.borrow().iter_enumerated() {\n+        for (num, v) in self.metas.iter_enumerated() {\n             if let &Some(_) = v {\n                 self.push_dependencies_in_postorder(&mut ordering, num);\n             }"}, {"sha": "d942a19194a1443d69a35a34a52daf3502f0c152", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -29,7 +29,6 @@ use std::sync::Arc;\n use syntax::ast;\n use syntax::attr;\n use syntax::source_map;\n-use syntax::edition::Edition;\n use syntax::parse::source_file_to_stream;\n use syntax::parse::parser::emit_unclosed_delims;\n use syntax::source_map::Spanned;\n@@ -54,7 +53,7 @@ macro_rules! provide {\n                 let ($def_id, $other) = def_id_arg.into_args();\n                 assert!(!$def_id.is_local());\n \n-                let $cdata = $tcx.crate_data_as_rc_any($def_id.krate);\n+                let $cdata = $tcx.crate_data_as_any($def_id.krate);\n                 let $cdata = $cdata.downcast_ref::<cstore::CrateMetadata>()\n                     .expect(\"CrateStore created data is not a CrateMetadata\");\n \n@@ -411,10 +410,6 @@ impl cstore::CStore {\n         }\n     }\n \n-    pub fn crate_edition_untracked(&self, cnum: CrateNum) -> Edition {\n-        self.get_crate_data(cnum).root.edition\n-    }\n-\n     pub fn struct_field_names_untracked(&self, def: DefId, sess: &Session) -> Vec<Spanned<Symbol>> {\n         self.get_crate_data(def.krate).get_struct_field_names(def.index, sess)\n     }\n@@ -460,7 +455,7 @@ impl cstore::CStore {\n \n         LoadedMacro::MacroDef(ast::Item {\n             // FIXME: cross-crate hygiene\n-            ident: ast::Ident::with_dummy_span(name.as_symbol()),\n+            ident: ast::Ident::with_dummy_span(name),\n             id: ast::DUMMY_NODE_ID,\n             span: local_span,\n             attrs: attrs.iter().cloned().collect(),\n@@ -470,7 +465,7 @@ impl cstore::CStore {\n             }),\n             vis: source_map::respan(local_span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n             tokens: None,\n-        })\n+        }, data.root.edition)\n     }\n \n     pub fn associated_item_cloned_untracked(&self, def: DefId) -> ty::AssocItem {\n@@ -483,8 +478,8 @@ impl cstore::CStore {\n }\n \n impl CrateStore for cstore::CStore {\n-    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Lrc<dyn Any> {\n-        self.get_crate_data(krate)\n+    fn crate_data_as_any(&self, cnum: CrateNum) -> &dyn Any {\n+        self.get_crate_data(cnum)\n     }\n \n     fn item_generics_cloned_untracked(&self, def: DefId, sess: &Session) -> ty::Generics {\n@@ -525,8 +520,8 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(def.krate).def_path_hash(def.index)\n     }\n \n-    fn def_path_table(&self, cnum: CrateNum) -> Lrc<DefPathTable> {\n-        self.get_crate_data(cnum).def_path_table.clone()\n+    fn def_path_table(&self, cnum: CrateNum) -> &DefPathTable {\n+        &self.get_crate_data(cnum).def_path_table\n     }\n \n     fn crates_untracked(&self) -> Vec<CrateNum>"}, {"sha": "8c52168b418fd40819fc938c79346d9bd917cfa6", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 12, "deletions": 28, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -35,7 +35,7 @@ use syntax::ast::{self, Ident};\n use syntax::source_map::{self, respan, Spanned};\n use syntax::symbol::{Symbol, sym};\n use syntax_expand::base::{MacroKind, SyntaxExtensionKind, SyntaxExtension};\n-use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, symbol::{InternedString}};\n+use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP};\n use log::debug;\n use proc_macro::bridge::client::ProcMacro;\n use syntax_expand::proc_macro::{AttrProcMacro, ProcMacroDerive, BangProcMacro};\n@@ -448,7 +448,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Mod(_) => DefKind::Mod,\n             EntryKind::Variant(_) => DefKind::Variant,\n             EntryKind::Trait(_) => DefKind::Trait,\n-            EntryKind::TraitAlias(_) => DefKind::TraitAlias,\n+            EntryKind::TraitAlias => DefKind::TraitAlias,\n             EntryKind::Enum(..) => DefKind::Enum,\n             EntryKind::MacroDef(_) => DefKind::Macro(MacroKind::Bang),\n             EntryKind::ForeignType => DefKind::ForeignTy,\n@@ -458,7 +458,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Impl(_) |\n             EntryKind::Field |\n             EntryKind::Generator(_) |\n-            EntryKind::Closure(_) => return None,\n+            EntryKind::Closure => return None,\n         })\n     }\n }\n@@ -514,7 +514,6 @@ impl<'a, 'tcx> CrateMetadata {\n                 .data\n                 .get_opt_name()\n                 .expect(\"no name in item_name\")\n-                .as_symbol()\n         } else {\n             Symbol::intern(self.raw_proc_macro(item_index).name())\n         }\n@@ -575,7 +574,7 @@ impl<'a, 'tcx> CrateMetadata {\n                                   data.is_marker,\n                                   self.def_path_table.def_path_hash(item_id))\n             },\n-            EntryKind::TraitAlias(_) => {\n+            EntryKind::TraitAlias => {\n                 ty::TraitDef::new(self.local_def_id(item_id),\n                                   hir::Unsafety::Normal,\n                                   false,\n@@ -680,13 +679,7 @@ impl<'a, 'tcx> CrateMetadata {\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n-        let super_predicates = match self.kind(item_id) {\n-            EntryKind::Trait(data) => data.decode(self).super_predicates,\n-            EntryKind::TraitAlias(data) => data.decode(self).super_predicates,\n-            _ => bug!(\"def-index does not refer to trait or trait alias\"),\n-        };\n-\n-        super_predicates.decode((self, tcx))\n+        self.root.per_def.super_predicates.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n     crate fn get_generics(&self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n@@ -717,7 +710,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    fn get_impl_data(&self, id: DefIndex) -> ImplData<'tcx> {\n+    fn get_impl_data(&self, id: DefIndex) -> ImplData {\n         match self.kind(id) {\n             EntryKind::Impl(data) => data.decode(self),\n             _ => bug!(),\n@@ -744,7 +737,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn get_impl_trait(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n-        self.get_impl_data(id).trait_ref.map(|tr| tr.decode((self, tcx)))\n+        self.root.per_def.impl_trait_ref.get(self, id).map(|tr| tr.decode((self, tcx)))\n     }\n \n     /// Iterates over all the stability attributes in the given crate.\n@@ -864,7 +857,7 @@ impl<'a, 'tcx> CrateMetadata {\n                 let span = self.get_span(child_index, sess);\n                 if let (Some(kind), Some(name)) =\n                     (self.def_kind(child_index), def_key.disambiguated_data.data.get_opt_name()) {\n-                    let ident = Ident::from_interned_str(name);\n+                    let ident = Ident::with_dummy_span(name);\n                     let vis = self.get_visibility(child_index);\n                     let def_id = self.local_def_id(child_index);\n                     let res = Res::Def(kind, def_id);\n@@ -987,7 +980,7 @@ impl<'a, 'tcx> CrateMetadata {\n         };\n \n         ty::AssocItem {\n-            ident: Ident::from_interned_str(name),\n+            ident: Ident::with_dummy_span(name),\n             kind,\n             vis: self.get_visibility(id),\n             defaultness: container.defaultness(),\n@@ -1118,7 +1111,7 @@ impl<'a, 'tcx> CrateMetadata {\n         def_key.parent.and_then(|parent_index| {\n             match self.kind(parent_index) {\n                 EntryKind::Trait(_) |\n-                EntryKind::TraitAlias(_) => Some(self.local_def_id(parent_index)),\n+                EntryKind::TraitAlias => Some(self.local_def_id(parent_index)),\n                 _ => None,\n             }\n         })\n@@ -1245,24 +1238,15 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n-        let sig = match self.kind(id) {\n-            EntryKind::Fn(data) |\n-            EntryKind::ForeignFn(data) => data.decode(self).sig,\n-            EntryKind::Method(data) => data.decode(self).fn_data.sig,\n-            EntryKind::Variant(data) |\n-            EntryKind::Struct(data, _) => data.decode(self).ctor_sig.unwrap(),\n-            EntryKind::Closure(data) => data.decode(self).sig,\n-            _ => bug!(),\n-        };\n-        sig.decode((self, tcx))\n+        self.root.per_def.fn_sig.get(self, id).unwrap().decode((self, tcx))\n     }\n \n     #[inline]\n     crate fn def_key(&self, index: DefIndex) -> DefKey {\n         let mut key = self.def_path_table.def_key(index);\n         if self.is_proc_macro(index) {\n             let name = self.raw_proc_macro(index).name();\n-            key.disambiguated_data.data = DefPathData::MacroNs(InternedString::intern(name));\n+            key.disambiguated_data.data = DefPathData::MacroNs(Symbol::intern(name));\n         }\n         key\n     }"}, {"sha": "0dc9f91ae00e1c78bdc7f89a3304af52ca8e3eea", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 46, "deletions": 38, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -71,11 +71,14 @@ struct PerDefTables<'tcx> {\n     deprecation: PerDefTable<Lazy<attr::Deprecation>>,\n \n     ty: PerDefTable<Lazy<Ty<'tcx>>>,\n+    fn_sig: PerDefTable<Lazy<ty::PolyFnSig<'tcx>>>,\n+    impl_trait_ref: PerDefTable<Lazy<ty::TraitRef<'tcx>>>,\n     inherent_impls: PerDefTable<Lazy<[DefIndex]>>,\n     variances: PerDefTable<Lazy<[ty::Variance]>>,\n     generics: PerDefTable<Lazy<ty::Generics>>,\n     predicates: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n     predicates_defined_on: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n+    super_predicates: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n \n     mir: PerDefTable<Lazy<mir::Body<'tcx>>>,\n     promoted_mir: PerDefTable<Lazy<IndexVec<mir::Promoted, mir::Body<'tcx>>>>,\n@@ -508,11 +511,14 @@ impl<'tcx> EncodeContext<'tcx> {\n             deprecation: self.per_def.deprecation.encode(&mut self.opaque),\n \n             ty: self.per_def.ty.encode(&mut self.opaque),\n+            fn_sig: self.per_def.fn_sig.encode(&mut self.opaque),\n+            impl_trait_ref: self.per_def.impl_trait_ref.encode(&mut self.opaque),\n             inherent_impls: self.per_def.inherent_impls.encode(&mut self.opaque),\n             variances: self.per_def.variances.encode(&mut self.opaque),\n             generics: self.per_def.generics.encode(&mut self.opaque),\n             predicates: self.per_def.predicates.encode(&mut self.opaque),\n             predicates_defined_on: self.per_def.predicates_defined_on.encode(&mut self.opaque),\n+            super_predicates: self.per_def.super_predicates.encode(&mut self.opaque),\n \n             mir: self.per_def.mir.encode(&mut self.opaque),\n             promoted_mir: self.per_def.promoted_mir.encode(&mut self.opaque),\n@@ -635,13 +641,7 @@ impl EncodeContext<'tcx> {\n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n-            // FIXME(eddyb) deduplicate these with `encode_enum_variant_ctor`.\n             ctor: variant.ctor_def_id.map(|did| did.index),\n-            ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n-                variant.ctor_def_id.map(|ctor_def_id| self.lazy(&tcx.fn_sig(ctor_def_id)))\n-            } else {\n-                None\n-            },\n         };\n \n         let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n@@ -660,6 +660,11 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n+            // FIXME(eddyb) encode signature only in `encode_enum_variant_ctor`.\n+            if let Some(ctor_def_id) = variant.ctor_def_id {\n+                record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(ctor_def_id));\n+            }\n+            // FIXME(eddyb) is this ever used?\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -679,15 +684,11 @@ impl EncodeContext<'tcx> {\n         let def_id = variant.ctor_def_id.unwrap();\n         debug!(\"EncodeContext::encode_enum_variant_ctor({:?})\", def_id);\n \n+        // FIXME(eddyb) encode only the `CtorKind` for constructors.\n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n             ctor: Some(def_id.index),\n-            ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n-                Some(self.lazy(tcx.fn_sig(def_id)))\n-            } else {\n-                None\n-            }\n         };\n \n         // Variant constructors have the same visibility as the parent enums, unless marked as\n@@ -706,6 +707,7 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -780,11 +782,6 @@ impl EncodeContext<'tcx> {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n             ctor: Some(def_id.index),\n-            ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n-                Some(self.lazy(tcx.fn_sig(def_id)))\n-            } else {\n-                None\n-            }\n         };\n \n         let struct_id = tcx.hir().as_local_hir_id(adt_def_id).unwrap();\n@@ -811,6 +808,7 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -835,6 +833,11 @@ impl EncodeContext<'tcx> {\n             self.tcx.predicates_defined_on(def_id))\n     }\n \n+    fn encode_super_predicates(&mut self, def_id: DefId) {\n+        debug!(\"EncodeContext::encode_super_predicates({:?})\", def_id);\n+        record!(self.per_def.super_predicates[def_id] <- self.tcx.super_predicates_of(def_id));\n+    }\n+\n     fn encode_info_for_trait_item(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n@@ -874,7 +877,6 @@ impl EncodeContext<'tcx> {\n                         asyncness: m_sig.header.asyncness,\n                         constness: hir::Constness::NotConst,\n                         param_names,\n-                        sig: self.lazy(tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -906,6 +908,7 @@ impl EncodeContext<'tcx> {\n             ty::AssocKind::OpaqueTy => unreachable!(),\n         }\n         if trait_item.kind == ty::AssocKind::Method {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -952,7 +955,6 @@ impl EncodeContext<'tcx> {\n                         asyncness: sig.header.asyncness,\n                         constness: sig.header.constness,\n                         param_names: self.encode_fn_param_names_for_body(body),\n-                        sig: self.lazy(tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -973,6 +975,7 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if impl_item.kind == ty::AssocKind::Method {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -1081,7 +1084,6 @@ impl EncodeContext<'tcx> {\n                     asyncness: header.asyncness,\n                     constness: header.constness,\n                     param_names: self.encode_fn_param_names_for_body(body),\n-                    sig: self.lazy(tcx.fn_sig(def_id)),\n                 };\n \n                 EntryKind::Fn(self.lazy(data))\n@@ -1109,7 +1111,6 @@ impl EncodeContext<'tcx> {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor,\n-                    ctor_sig: None,\n                 }), adt_def.repr)\n             }\n             hir::ItemKind::Union(..) => {\n@@ -1120,7 +1121,6 @@ impl EncodeContext<'tcx> {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor: None,\n-                    ctor_sig: None,\n                 }), adt_def.repr)\n             }\n             hir::ItemKind::Impl(_, _, defaultness, ..) => {\n@@ -1154,7 +1154,6 @@ impl EncodeContext<'tcx> {\n                     defaultness,\n                     parent_impl: parent,\n                     coerce_unsized_info,\n-                    trait_ref: trait_ref.map(|trait_ref| self.lazy(trait_ref)),\n                 };\n \n                 EntryKind::Impl(self.lazy(data))\n@@ -1166,18 +1165,11 @@ impl EncodeContext<'tcx> {\n                     paren_sugar: trait_def.paren_sugar,\n                     has_auto_impl: self.tcx.trait_is_auto(def_id),\n                     is_marker: trait_def.is_marker,\n-                    super_predicates: self.lazy(tcx.super_predicates_of(def_id)),\n                 };\n \n                 EntryKind::Trait(self.lazy(data))\n             }\n-            hir::ItemKind::TraitAlias(..) => {\n-                let data = TraitAliasData {\n-                    super_predicates: self.lazy(tcx.super_predicates_of(def_id)),\n-                };\n-\n-                EntryKind::TraitAlias(self.lazy(data))\n-            }\n+            hir::ItemKind::TraitAlias(..) => EntryKind::TraitAlias,\n             hir::ItemKind::ExternCrate(_) |\n             hir::ItemKind::Use(..) => bug!(\"cannot encode info for item {:?}\", item),\n         });\n@@ -1232,6 +1224,14 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::Impl(..) => self.encode_item_type(def_id),\n             _ => {}\n         }\n+        if let hir::ItemKind::Fn(..) = item.kind {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n+        }\n+        if let hir::ItemKind::Impl(..) = item.kind {\n+            if let Some(trait_ref) = self.tcx.impl_trait_ref(def_id) {\n+                record!(self.per_def.impl_trait_ref[def_id] <- trait_ref);\n+            }\n+        }\n         self.encode_inherent_implementations(def_id);\n         match item.kind {\n             hir::ItemKind::Enum(..) |\n@@ -1269,6 +1269,13 @@ impl EncodeContext<'tcx> {\n             }\n             _ => {} // not *wrong* for other kinds of items, but not needed\n         }\n+        match item.kind {\n+            hir::ItemKind::Trait(..) |\n+            hir::ItemKind::TraitAlias(..) => {\n+                self.encode_super_predicates(def_id);\n+            }\n+            _ => {}\n+        }\n \n         let mir = match item.kind {\n             hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => true,\n@@ -1321,10 +1328,12 @@ impl EncodeContext<'tcx> {\n     fn encode_info_for_closure(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_closure({:?})\", def_id);\n \n-        let tables = self.tcx.typeck_tables_of(def_id);\n+        // NOTE(eddyb) `tcx.type_of(def_id)` isn't used because it's fully generic,\n+        // including on the signature, which is inferred in `typeck_tables_of.\n         let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let ty = self.tcx.typeck_tables_of(def_id).node_type(hir_id);\n \n-        record!(self.per_def.kind[def_id] <- match tables.node_type(hir_id).kind {\n+        record!(self.per_def.kind[def_id] <- match ty.kind {\n             ty::Generator(def_id, ..) => {\n                 let layout = self.tcx.generator_layout(def_id);\n                 let data = GeneratorData {\n@@ -1333,18 +1342,17 @@ impl EncodeContext<'tcx> {\n                 EntryKind::Generator(self.lazy(data))\n             }\n \n-            ty::Closure(def_id, substs) => {\n-                let sig = substs.as_closure().sig(def_id, self.tcx);\n-                let data = ClosureData { sig: self.lazy(sig) };\n-                EntryKind::Closure(self.lazy(data))\n-            }\n+            ty::Closure(..) => EntryKind::Closure,\n \n             _ => bug!(\"closure that is neither generator nor closure\"),\n         });\n         record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n         record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.per_def.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n         self.encode_item_type(def_id);\n+        if let ty::Closure(def_id, substs) = ty.kind {\n+            record!(self.per_def.fn_sig[def_id] <- substs.as_closure().sig(def_id, self.tcx));\n+        }\n         self.encode_generics(def_id);\n         self.encode_optimized_mir(def_id);\n         self.encode_promoted_mir(def_id);\n@@ -1553,7 +1561,6 @@ impl EncodeContext<'tcx> {\n                     asyncness: hir::IsAsync::NotAsync,\n                     constness: hir::Constness::NotConst,\n                     param_names: self.encode_fn_param_names(names),\n-                    sig: self.lazy(tcx.fn_sig(def_id)),\n                 };\n                 EntryKind::ForeignFn(self.lazy(data))\n             }\n@@ -1569,6 +1576,7 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if let hir::ForeignItemKind::Fn(..) = nitem.kind {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);"}, {"sha": "a5298402dd4115b95839ce89a65d2704d422bf92", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 82, "deletions": 4, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -212,20 +212,21 @@\n //! no means all of the necessary details. Take a look at the rest of\n //! metadata::locator or metadata::creader for all the juicy details!\n \n-use crate::cstore::{MetadataBlob, CStore};\n+use crate::cstore::MetadataBlob;\n use crate::creader::Library;\n use crate::schema::{METADATA_HEADER, rustc_version};\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n use rustc::middle::cstore::{CrateSource, MetadataLoader};\n-use rustc::session::{config, Session};\n+use rustc::session::{config, Session, CrateDisambiguator};\n use rustc::session::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n use rustc::session::search_paths::PathKind;\n use rustc::util::nodemap::FxHashMap;\n \n use errors::DiagnosticBuilder;\n+use syntax::{span_err, span_fatal};\n use syntax::symbol::{Symbol, sym};\n use syntax::struct_span_err;\n use syntax_pos::Span;\n@@ -911,10 +912,87 @@ fn get_metadata_section_imp(target: &Target,\n     }\n }\n \n+/// Look for a plugin registrar. Returns its library path and crate disambiguator.\n+pub fn find_plugin_registrar(\n+    sess: &Session,\n+    metadata_loader: &dyn MetadataLoader,\n+    span: Span,\n+    name: Symbol,\n+) -> Option<(PathBuf, CrateDisambiguator)> {\n+    info!(\"find plugin registrar `{}`\", name);\n+    let target_triple = sess.opts.target_triple.clone();\n+    let host_triple = TargetTriple::from_triple(config::host_triple());\n+    let is_cross = target_triple != host_triple;\n+    let mut target_only = false;\n+    let mut locate_ctxt = Context {\n+        sess,\n+        span,\n+        crate_name: name,\n+        hash: None,\n+        extra_filename: None,\n+        filesearch: sess.host_filesearch(PathKind::Crate),\n+        target: &sess.host,\n+        triple: host_triple,\n+        root: None,\n+        rejected_via_hash: vec![],\n+        rejected_via_triple: vec![],\n+        rejected_via_kind: vec![],\n+        rejected_via_version: vec![],\n+        rejected_via_filename: vec![],\n+        should_match_name: true,\n+        is_proc_macro: None,\n+        metadata_loader,\n+    };\n+\n+    let library = locate_ctxt.maybe_load_library_crate().or_else(|| {\n+        if !is_cross {\n+            return None\n+        }\n+        // Try loading from target crates. This will abort later if we\n+        // try to load a plugin registrar function,\n+        target_only = true;\n+\n+        locate_ctxt.target = &sess.target.target;\n+        locate_ctxt.triple = target_triple;\n+        locate_ctxt.filesearch = sess.target_filesearch(PathKind::Crate);\n+\n+        locate_ctxt.maybe_load_library_crate()\n+    });\n+    let library = match library {\n+        Some(l) => l,\n+        None => locate_ctxt.report_errs(),\n+    };\n+\n+    if target_only {\n+        // Need to abort before syntax expansion.\n+        let message = format!(\"plugin `{}` is not available for triple `{}` \\\n+                                (only found {})\",\n+                                name,\n+                                config::host_triple(),\n+                                sess.opts.target_triple);\n+        span_fatal!(sess, span, E0456, \"{}\", &message);\n+    }\n+\n+    match library.source.dylib {\n+        Some(dylib) => {\n+            Some((dylib.0, library.metadata.get_root().disambiguator))\n+        }\n+        None => {\n+            span_err!(sess, span, E0457,\n+                        \"plugin `{}` only found in rlib format, but must be available \\\n+                        in dylib format\",\n+                        name);\n+            // No need to abort because the loading code will just ignore this\n+            // empty dylib.\n+            None\n+        }\n+    }\n+}\n+\n /// A diagnostic function for dumping crate metadata to an output stream.\n pub fn list_file_metadata(target: &Target,\n                           path: &Path,\n-                          cstore: &CStore,\n+                          metadata_loader: &dyn MetadataLoader,\n                           out: &mut dyn io::Write)\n                           -> io::Result<()> {\n     let filename = path.file_name().unwrap().to_str().unwrap();\n@@ -925,7 +1003,7 @@ pub fn list_file_metadata(target: &Target,\n     } else {\n         CrateFlavor::Dylib\n     };\n-    match get_metadata_section(target, flavor, path, &*cstore.metadata_loader) {\n+    match get_metadata_section(target, flavor, path, metadata_loader) {\n         Ok(metadata) => metadata.list_crate_metadata(out),\n         Err(msg) => write!(out, \"{}\\n\", msg),\n     }"}, {"sha": "ad39aa34fd5c8d3f1695d4936ad1749518bed1d8", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -238,11 +238,14 @@ crate struct LazyPerDefTables<'tcx> {\n     pub deprecation: Lazy!(PerDefTable<Lazy<attr::Deprecation>>),\n \n     pub ty: Lazy!(PerDefTable<Lazy!(Ty<'tcx>)>),\n+    pub fn_sig: Lazy!(PerDefTable<Lazy!(ty::PolyFnSig<'tcx>)>),\n+    pub impl_trait_ref: Lazy!(PerDefTable<Lazy!(ty::TraitRef<'tcx>)>),\n     pub inherent_impls: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n     pub variances: Lazy!(PerDefTable<Lazy<[ty::Variance]>>),\n     pub generics: Lazy!(PerDefTable<Lazy<ty::Generics>>),\n     pub predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n     pub predicates_defined_on: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n+    pub super_predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n \n     pub mir: Lazy!(PerDefTable<Lazy!(mir::Body<'tcx>)>),\n     pub promoted_mir: Lazy!(PerDefTable<Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>),\n@@ -264,22 +267,22 @@ crate enum EntryKind<'tcx> {\n     OpaqueTy,\n     Enum(ReprOptions),\n     Field,\n-    Variant(Lazy!(VariantData<'tcx>)),\n-    Struct(Lazy!(VariantData<'tcx>), ReprOptions),\n-    Union(Lazy!(VariantData<'tcx>), ReprOptions),\n-    Fn(Lazy!(FnData<'tcx>)),\n-    ForeignFn(Lazy!(FnData<'tcx>)),\n+    Variant(Lazy<VariantData>),\n+    Struct(Lazy<VariantData>, ReprOptions),\n+    Union(Lazy<VariantData>, ReprOptions),\n+    Fn(Lazy<FnData>),\n+    ForeignFn(Lazy<FnData>),\n     Mod(Lazy<ModData>),\n     MacroDef(Lazy<MacroDef>),\n-    Closure(Lazy!(ClosureData<'tcx>)),\n+    Closure,\n     Generator(Lazy!(GeneratorData<'tcx>)),\n-    Trait(Lazy!(TraitData<'tcx>)),\n-    Impl(Lazy!(ImplData<'tcx>)),\n-    Method(Lazy!(MethodData<'tcx>)),\n+    Trait(Lazy<TraitData>),\n+    Impl(Lazy<ImplData>),\n+    Method(Lazy<MethodData>),\n     AssocType(AssocContainer),\n     AssocOpaqueTy(AssocContainer),\n     AssocConst(AssocContainer, ConstQualif, Lazy<RenderedConst>),\n-    TraitAlias(Lazy!(TraitAliasData<'tcx>)),\n+    TraitAlias,\n }\n \n /// Additional data for EntryKind::Const and EntryKind::AssocConst\n@@ -305,47 +308,37 @@ crate struct MacroDef {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct FnData<'tcx> {\n+crate struct FnData {\n     pub asyncness: hir::IsAsync,\n     pub constness: hir::Constness,\n     pub param_names: Lazy<[ast::Name]>,\n-    pub sig: Lazy!(ty::PolyFnSig<'tcx>),\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct VariantData<'tcx> {\n+crate struct VariantData {\n     pub ctor_kind: CtorKind,\n     pub discr: ty::VariantDiscr,\n     /// If this is unit or tuple-variant/struct, then this is the index of the ctor id.\n     pub ctor: Option<DefIndex>,\n-    /// If this is a tuple struct or variant\n-    /// ctor, this is its \"function\" signature.\n-    pub ctor_sig: Option<Lazy!(ty::PolyFnSig<'tcx>)>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct TraitData<'tcx> {\n+crate struct TraitData {\n     pub unsafety: hir::Unsafety,\n     pub paren_sugar: bool,\n     pub has_auto_impl: bool,\n     pub is_marker: bool,\n-    pub super_predicates: Lazy!(ty::GenericPredicates<'tcx>),\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct TraitAliasData<'tcx> {\n-    pub super_predicates: Lazy!(ty::GenericPredicates<'tcx>),\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-crate struct ImplData<'tcx> {\n+crate struct ImplData {\n     pub polarity: ty::ImplPolarity,\n     pub defaultness: hir::Defaultness,\n     pub parent_impl: Option<DefId>,\n \n     /// This is `Some` only for impls of `CoerceUnsized`.\n+    // FIXME(eddyb) perhaps compute this on the fly if cheap enough?\n     pub coerce_unsized_info: Option<ty::adjustment::CoerceUnsizedInfo>,\n-    pub trait_ref: Option<Lazy!(ty::TraitRef<'tcx>)>,\n }\n \n \n@@ -388,17 +381,12 @@ impl AssocContainer {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct MethodData<'tcx> {\n-    pub fn_data: FnData<'tcx>,\n+crate struct MethodData {\n+    pub fn_data: FnData,\n     pub container: AssocContainer,\n     pub has_self: bool,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n-crate struct ClosureData<'tcx> {\n-    pub sig: Lazy!(ty::PolyFnSig<'tcx>),\n-}\n-\n #[derive(RustcEncodable, RustcDecodable)]\n crate struct GeneratorData<'tcx> {\n     pub layout: mir::GeneratorLayout<'tcx>,"}, {"sha": "d6e84940291a575627377d7e88106d43afcb55b3", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -18,14 +18,14 @@ use rustc::ty::print::RegionHighlightMode;\n use rustc_errors::DiagnosticBuilder;\n use syntax::symbol::kw;\n use rustc_data_structures::fx::FxHashMap;\n-use syntax_pos::{Span, symbol::InternedString};\n+use syntax_pos::{Span, symbol::Symbol};\n \n /// A name for a particular region used in emitting diagnostics. This name could be a generated\n /// name like `'1`, a name used by the user like `'a`, or a name like `'static`.\n #[derive(Debug, Clone)]\n crate struct RegionName {\n     /// The name of the region (interned).\n-    crate name: InternedString,\n+    crate name: Symbol,\n     /// Where the region comes from.\n     crate source: RegionNameSource,\n }\n@@ -109,7 +109,7 @@ impl RegionName {\n     }\n \n     #[allow(dead_code)]\n-    crate fn name(&self) -> InternedString {\n+    crate fn name(&self) -> Symbol {\n         self.name\n     }\n \n@@ -273,7 +273,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n \n             ty::ReStatic => Some(RegionName {\n-                name: kw::StaticLifetime.as_interned_str(),\n+                name: kw::StaticLifetime,\n                 source: RegionNameSource::Static\n             }),\n \n@@ -360,7 +360,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         tcx: TyCtxt<'tcx>,\n         error_region: &RegionKind,\n-        name: InternedString,\n+        name: Symbol,\n     ) -> Span {\n         let scope = error_region.free_region_binding_scope(tcx);\n         let node = tcx.hir().as_local_hir_id(scope).unwrap_or(hir::DUMMY_HIR_ID);\n@@ -837,10 +837,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Creates a synthetic region named `'1`, incrementing the counter.\n-    fn synthesize_region_name(&self, renctx: &mut RegionErrorNamingCtx) -> InternedString {\n+    fn synthesize_region_name(&self, renctx: &mut RegionErrorNamingCtx) -> Symbol {\n         let c = renctx.counter;\n         renctx.counter += 1;\n \n-        InternedString::intern(&format!(\"'{:?}\", c))\n+        Symbol::intern(&format!(\"'{:?}\", c))\n     }\n }"}, {"sha": "b876fd83ec983797ce04cbaa8c7759c7fe1149da", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -790,7 +790,7 @@ fn for_each_late_bound_region_defined_on<'tcx>(\n                 owner: fn_def_id.index,\n                 local_id: *late_bound,\n             };\n-            let name = tcx.hir().name(hir_id).as_interned_str();\n+            let name = tcx.hir().name(hir_id);\n             let region_def_id = tcx.hir().local_def_id(hir_id);\n             let liberated_region = tcx.mk_region(ty::ReFree(ty::FreeRegion {\n                 scope: fn_def_id,"}, {"sha": "7bb96661bb746a9c462a8faf414b28172d320fb4", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -908,7 +908,7 @@ fn convert_path_expr<'a, 'tcx>(\n             let generics = cx.tcx.generics_of(item_def_id);\n             let local_def_id = cx.tcx.hir().local_def_id(hir_id);\n             let index = generics.param_def_id_to_index[&local_def_id];\n-            let name = cx.tcx.hir().name(hir_id).as_interned_str();\n+            let name = cx.tcx.hir().name(hir_id);\n             let val = ConstValue::Param(ty::ParamConst::new(index, name));\n             ExprKind::Literal {\n                 literal: cx.tcx.mk_const("}, {"sha": "98e286e61e942d54c7e293f34ebf2e01680da233", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 15, "deletions": 129, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -25,7 +25,6 @@ use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::hir::ptr::P;\n \n use rustc_index::vec::Idx;\n-use rustc_data_structures::fx::FxHashSet;\n \n use std::cmp::Ordering;\n use std::fmt;\n@@ -1000,15 +999,21 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         if self.include_lint_checks && !saw_error {\n             // If we were able to successfully convert the const to some pat, double-check\n             // that the type of the const obeys `#[structural_match]` constraint.\n-            if let Some(adt_def) = search_for_adt_without_structural_match(self.tcx, cv.ty) {\n-\n-                let path = self.tcx.def_path_str(adt_def.did);\n-                let msg = format!(\n-                    \"to use a constant of type `{}` in a pattern, \\\n-                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                    path,\n-                    path,\n-                );\n+            if let Some(non_sm_ty) = ty::search_for_structural_match_violation(self.tcx, cv.ty) {\n+                let msg = match non_sm_ty {\n+                    ty::NonStructuralMatchTy::Adt(adt_def) => {\n+                        let path = self.tcx.def_path_str(adt_def.did);\n+                        format!(\n+                            \"to use a constant of type `{}` in a pattern, \\\n+                             `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+                            path,\n+                            path,\n+                        )\n+                    }\n+                    ty::NonStructuralMatchTy::Param => {\n+                        bug!(\"use of constant whose type is a parameter inside a pattern\");\n+                    }\n+                };\n \n                 // before issuing lint, double-check there even *is* a\n                 // semantic PartialEq for us to dispatch to.\n@@ -1169,125 +1174,6 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     }\n }\n \n-/// This method traverses the structure of `ty`, trying to find an\n-/// instance of an ADT (i.e. struct or enum) that was declared without\n-/// the `#[structural_match]` attribute.\n-///\n-/// The \"structure of a type\" includes all components that would be\n-/// considered when doing a pattern match on a constant of that\n-/// type.\n-///\n-///  * This means this method descends into fields of structs/enums,\n-///    and also descends into the inner type `T` of `&T` and `&mut T`\n-///\n-///  * The traversal doesn't dereference unsafe pointers (`*const T`,\n-///    `*mut T`), and it does not visit the type arguments of an\n-///    instantiated generic like `PhantomData<T>`.\n-///\n-/// The reason we do this search is Rust currently require all ADT's\n-/// reachable from a constant's type to be annotated with\n-/// `#[structural_match]`, an attribute which essentially says that\n-/// the implementation of `PartialEq::eq` behaves *equivalently* to a\n-/// comparison against the unfolded structure.\n-///\n-/// For more background on why Rust has this requirement, and issues\n-/// that arose when the requirement was not enforced completely, see\n-/// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n-fn search_for_adt_without_structural_match<'tcx>(tcx: TyCtxt<'tcx>,\n-                                                 ty: Ty<'tcx>)\n-                                                 -> Option<&'tcx AdtDef>\n-{\n-    // Import here (not mod level), because `TypeFoldable::fold_with`\n-    // conflicts with `PatternFoldable::fold_with`\n-    use crate::rustc::ty::fold::TypeVisitor;\n-    use crate::rustc::ty::TypeFoldable;\n-\n-    let mut search = Search { tcx, found: None, seen: FxHashSet::default() };\n-    ty.visit_with(&mut search);\n-    return search.found;\n-\n-    struct Search<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-\n-        // records the first ADT we find without `#[structural_match`\n-        found: Option<&'tcx AdtDef>,\n-\n-        // tracks ADT's previously encountered during search, so that\n-        // we will not recur on them again.\n-        seen: FxHashSet<hir::def_id::DefId>,\n-    }\n-\n-    impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n-        fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n-            debug!(\"Search visiting ty: {:?}\", ty);\n-\n-            let (adt_def, substs) = match ty.kind {\n-                ty::Adt(adt_def, substs) => (adt_def, substs),\n-                ty::RawPtr(..) => {\n-                    // `#[structural_match]` ignores substructure of\n-                    // `*const _`/`*mut _`, so skip super_visit_with\n-                    //\n-                    // (But still tell caller to continue search.)\n-                    return false;\n-                }\n-                ty::FnDef(..) | ty::FnPtr(..) => {\n-                    // types of formals and return in `fn(_) -> _` are also irrelevant\n-                    //\n-                    // (But still tell caller to continue search.)\n-                    return false;\n-                }\n-                ty::Array(_, n) if n.try_eval_usize(self.tcx, ty::ParamEnv::reveal_all()) == Some(0)\n-                => {\n-                    // rust-lang/rust#62336: ignore type of contents\n-                    // for empty array.\n-                    return false;\n-                }\n-                _ => {\n-                    ty.super_visit_with(self);\n-                    return false;\n-                }\n-            };\n-\n-            if !self.tcx.has_attr(adt_def.did, sym::structural_match) {\n-                self.found = Some(&adt_def);\n-                debug!(\"Search found adt_def: {:?}\", adt_def);\n-                return true // Halt visiting!\n-            }\n-\n-            if !self.seen.insert(adt_def.did) {\n-                debug!(\"Search already seen adt_def: {:?}\", adt_def);\n-                // let caller continue its search\n-                return false;\n-            }\n-\n-            // `#[structural_match]` does not care about the\n-            // instantiation of the generics in an ADT (it\n-            // instead looks directly at its fields outside\n-            // this match), so we skip super_visit_with.\n-            //\n-            // (Must not recur on substs for `PhantomData<T>` cf\n-            // rust-lang/rust#55028 and rust-lang/rust#55837; but also\n-            // want to skip substs when only uses of generic are\n-            // behind unsafe pointers `*const T`/`*mut T`.)\n-\n-            // even though we skip super_visit_with, we must recur on\n-            // fields of ADT.\n-            let tcx = self.tcx;\n-            for field_ty in adt_def.all_fields().map(|field| field.ty(tcx, substs)) {\n-                if field_ty.visit_with(self) {\n-                    // found an ADT without `#[structural_match]`; halt visiting!\n-                    assert!(self.found.is_some());\n-                    return true;\n-                }\n-            }\n-\n-            // Even though we do not want to recur on substs, we do\n-            // want our caller to continue its own search.\n-            false\n-        }\n-    }\n-}\n-\n impl UserAnnotatedTyHelpers<'tcx> for PatCtxt<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx"}, {"sha": "d929e958f05d0944b3faaa1b2ca164cb827a95f4", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -91,7 +91,7 @@ pub struct Frame<'mir, 'tcx, Tag=(), Extra=()> {\n     pub extra: Extra,\n }\n \n-#[derive(Clone, Eq, PartialEq)]\n+#[derive(Clone, Eq, PartialEq, Debug)] // Miri debug-prints these\n pub enum StackPopCleanup {\n     /// Jump to the next block in the caller, or cause UB if None (that's a function\n     /// that may never return). Also store layout of return place so\n@@ -113,7 +113,7 @@ pub struct LocalState<'tcx, Tag=(), Id=AllocId> {\n }\n \n /// Current value of a local variable\n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq, Debug)] // Miri debug-prints these\n pub enum LocalValue<Tag=(), Id=AllocId> {\n     /// This local is not currently alive, and cannot be used at all.\n     Dead,"}, {"sha": "f1f9fac08ca3a83c8a106e335832b19be25f348e", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -148,7 +148,7 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n \n         self.path.push_str(\"::\");\n \n-        self.path.push_str(&disambiguated_data.data.as_interned_str().as_str());\n+        self.path.push_str(&disambiguated_data.data.as_symbol().as_str());\n         Ok(self)\n     }\n "}, {"sha": "d113ee33162d26114c92c64d0995e013d1a26ff0", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -7,7 +7,7 @@\n //! short-circuiting the empty case!\n \n use std::collections::VecDeque;\n-use std::{ptr, iter};\n+use std::ptr;\n use std::borrow::Cow;\n \n use rustc::ty::{self, Instance, ParamEnv, query::TyCtxtAt};\n@@ -791,11 +791,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn write_bytes(\n         &mut self,\n         ptr: Scalar<M::PointerTag>,\n-        src: impl IntoIterator<Item=u8, IntoIter: iter::ExactSizeIterator>,\n+        src: impl IntoIterator<Item=u8>,\n     ) -> InterpResult<'tcx>\n     {\n         let src = src.into_iter();\n-        let size = Size::from_bytes(src.len() as u64);\n+        let size = Size::from_bytes(src.size_hint().0 as u64);\n+        // `write_bytes` checks that this lower bound matches the upper bound matches reality.\n         let ptr = match self.check_ptr_access(ptr, size, Align::from_bytes(1).unwrap())? {\n             Some(ptr) => ptr,\n             None => return Ok(()), // zero-sized access"}, {"sha": "42f08771f866d57b32b1f4242ec8b3ddc05017f1", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -96,7 +96,7 @@ use std::collections::hash_map::Entry;\n use std::cmp;\n use std::sync::Arc;\n \n-use syntax::symbol::InternedString;\n+use syntax::symbol::Symbol;\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def::DefKind;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE, CRATE_DEF_INDEX};\n@@ -121,7 +121,7 @@ pub enum PartitioningStrategy {\n }\n \n // Anything we can't find a proper codegen unit for goes into this.\n-fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_>) -> InternedString {\n+fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_>) -> Symbol {\n     name_builder.build_cgu_name(LOCAL_CRATE, &[\"fallback\"], Some(\"cgu\"))\n }\n \n@@ -185,9 +185,7 @@ where\n         internalization_candidates: _,\n     } = post_inlining;\n \n-    result.sort_by(|cgu1, cgu2| {\n-        cgu1.name().cmp(cgu2.name())\n-    });\n+    result.sort_by_cached_key(|cgu| cgu.name().as_str());\n \n     result\n }\n@@ -203,7 +201,7 @@ struct PreInliningPartitioning<'tcx> {\n /// to keep track of that.\n #[derive(Clone, PartialEq, Eq, Debug)]\n enum MonoItemPlacement {\n-    SingleCgu { cgu_name: InternedString },\n+    SingleCgu { cgu_name: Symbol },\n     MultipleCgus,\n }\n \n@@ -251,8 +249,8 @@ where\n             None => fallback_cgu_name(cgu_name_builder),\n         };\n \n-        let codegen_unit = codegen_units.entry(codegen_unit_name.clone())\n-            .or_insert_with(|| CodegenUnit::new(codegen_unit_name.clone()));\n+        let codegen_unit = codegen_units.entry(codegen_unit_name)\n+            .or_insert_with(|| CodegenUnit::new(codegen_unit_name));\n \n         let mut can_be_internalized = true;\n         let (linkage, visibility) = mono_item_linkage_and_visibility(\n@@ -273,8 +271,7 @@ where\n     // crate with just types (for example), we could wind up with no CGU.\n     if codegen_units.is_empty() {\n         let codegen_unit_name = fallback_cgu_name(cgu_name_builder);\n-        codegen_units.insert(codegen_unit_name.clone(),\n-                             CodegenUnit::new(codegen_unit_name.clone()));\n+        codegen_units.insert(codegen_unit_name, CodegenUnit::new(codegen_unit_name));\n     }\n \n     PreInliningPartitioning {\n@@ -492,7 +489,7 @@ fn merge_codegen_units<'tcx>(\n     // smallest into each other) we're sure to start off with a deterministic\n     // order (sorted by name). This'll mean that if two cgus have the same size\n     // the stable sort below will keep everything nice and deterministic.\n-    codegen_units.sort_by_key(|cgu| *cgu.name());\n+    codegen_units.sort_by_cached_key(|cgu| cgu.name().as_str());\n \n     // Merge the two smallest codegen units until the target size is reached.\n     while codegen_units.len() > target_cgu_count {\n@@ -537,7 +534,7 @@ fn place_inlined_mono_items<'tcx>(initial_partitioning: PreInliningPartitioning<\n             follow_inlining(*root, inlining_map, &mut reachable);\n         }\n \n-        let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name().clone());\n+        let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n \n         // Add all monomorphizations that are not already there.\n         for mono_item in reachable {\n@@ -564,16 +561,16 @@ fn place_inlined_mono_items<'tcx>(initial_partitioning: PreInliningPartitioning<\n                     Entry::Occupied(e) => {\n                         let placement = e.into_mut();\n                         debug_assert!(match *placement {\n-                            MonoItemPlacement::SingleCgu { ref cgu_name } => {\n-                                *cgu_name != *new_codegen_unit.name()\n+                            MonoItemPlacement::SingleCgu { cgu_name } => {\n+                                cgu_name != new_codegen_unit.name()\n                             }\n                             MonoItemPlacement::MultipleCgus => true,\n                         });\n                         *placement = MonoItemPlacement::MultipleCgus;\n                     }\n                     Entry::Vacant(e) => {\n                         e.insert(MonoItemPlacement::SingleCgu {\n-                            cgu_name: new_codegen_unit.name().clone()\n+                            cgu_name: new_codegen_unit.name()\n                         });\n                     }\n                 }\n@@ -638,7 +635,7 @@ fn internalize_symbols<'tcx>(\n     // accessed from outside its defining codegen unit.\n     for cgu in &mut partitioning.codegen_units {\n         let home_cgu = MonoItemPlacement::SingleCgu {\n-            cgu_name: cgu.name().clone()\n+            cgu_name: cgu.name()\n         };\n \n         for (accessee, linkage_and_visibility) in cgu.items_mut() {\n@@ -717,15 +714,15 @@ fn characteristic_def_id_of_mono_item<'tcx>(\n     }\n }\n \n-type CguNameCache = FxHashMap<(DefId, bool), InternedString>;\n+type CguNameCache = FxHashMap<(DefId, bool), Symbol>;\n \n fn compute_codegen_unit_name(\n     tcx: TyCtxt<'_>,\n     name_builder: &mut CodegenUnitNameBuilder<'_>,\n     def_id: DefId,\n     volatile: bool,\n     cache: &mut CguNameCache,\n-) -> InternedString {\n+) -> Symbol {\n     // Find the innermost module that is not nested within a function.\n     let mut current_def_id = def_id;\n     let mut cgu_def_id = None;\n@@ -762,7 +759,7 @@ fn compute_codegen_unit_name(\n         let components = def_path\n             .data\n             .iter()\n-            .map(|part| part.data.as_interned_str());\n+            .map(|part| part.data.as_symbol());\n \n         let volatile_suffix = if volatile {\n             Some(\"volatile\")\n@@ -777,7 +774,7 @@ fn compute_codegen_unit_name(\n fn numbered_codegen_unit_name(\n     name_builder: &mut CodegenUnitNameBuilder<'_>,\n     index: usize,\n-) -> InternedString {\n+) -> Symbol {\n     name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index))\n }\n \n@@ -929,7 +926,7 @@ fn collect_and_partition_mono_items(\n             for (&mono_item, &linkage) in cgu.items() {\n                 item_to_cgus.entry(mono_item)\n                             .or_default()\n-                            .push((cgu.name().clone(), linkage));\n+                            .push((cgu.name(), linkage));\n             }\n         }\n \n@@ -991,7 +988,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     providers.codegen_unit = |tcx, name| {\n         let (_, all) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n         all.iter()\n-            .find(|cgu| *cgu.name() == name)\n+            .find(|cgu| cgu.name() == name)\n             .cloned()\n             .unwrap_or_else(|| panic!(\"failed to find cgu with name {:?}\", name))\n     };"}, {"sha": "3ff36e01275b9b461a3bf3d91664eeed2512e4ef", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -12,7 +12,7 @@ use rustc::lint::builtin::{SAFE_EXTERN_STATICS, SAFE_PACKED_BORROWS, UNUSED_UNSA\n use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext};\n \n-use syntax::symbol::{InternedString, sym};\n+use syntax::symbol::{Symbol, sym};\n \n use std::ops::Bound;\n \n@@ -167,9 +167,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     (CastTy::FnPtr, CastTy::Int(_)) => {\n                         self.register_violations(&[UnsafetyViolation {\n                             source_info: self.source_info,\n-                            description: InternedString::intern(\"cast of pointer to int\"),\n-                            details: InternedString::intern(\n-                                \"casting pointers to integers in constants\"),\n+                            description: Symbol::intern(\"cast of pointer to int\"),\n+                            details: Symbol::intern(\"casting pointers to integers in constants\"),\n                             kind: UnsafetyViolationKind::General,\n                         }], &[]);\n                     },\n@@ -185,8 +184,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n                     self.register_violations(&[UnsafetyViolation {\n                         source_info: self.source_info,\n-                        description: InternedString::intern(\"pointer operation\"),\n-                        details: InternedString::intern(\"operations on pointers in constants\"),\n+                        description: Symbol::intern(\"pointer operation\"),\n+                        details: Symbol::intern(\"operations on pointers in constants\"),\n                         kind: UnsafetyViolationKind::General,\n                     }], &[]);\n                 }\n@@ -219,8 +218,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                         self.source_scope_local_data[source_info.scope].lint_root;\n                     self.register_violations(&[UnsafetyViolation {\n                         source_info,\n-                        description: InternedString::intern(\"use of extern static\"),\n-                        details: InternedString::intern(\n+                        description: Symbol::intern(\"use of extern static\"),\n+                        details: Symbol::intern(\n                             \"extern statics are not controlled by the Rust type system: \\\n                             invalid data, aliasing violations or data races will cause \\\n                             undefined behavior\"),\n@@ -240,8 +239,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                         self.source_scope_local_data[source_info.scope].lint_root;\n                     self.register_violations(&[UnsafetyViolation {\n                         source_info,\n-                        description: InternedString::intern(\"borrow of packed field\"),\n-                        details: InternedString::intern(\n+                        description: Symbol::intern(\"borrow of packed field\"),\n+                        details: Symbol::intern(\n                             \"fields of packed structs might be misaligned: dereferencing a \\\n                             misaligned pointer or even just creating a misaligned reference \\\n                             is undefined behavior\"),\n@@ -334,8 +333,8 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n         let source_info = self.source_info;\n         self.register_violations(&[UnsafetyViolation {\n             source_info,\n-            description: InternedString::intern(description),\n-            details: InternedString::intern(details),\n+            description: Symbol::intern(description),\n+            details: Symbol::intern(details),\n             kind,\n         }], &[]);\n     }\n@@ -438,8 +437,8 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                                 let source_info = self.source_info;\n                                 self.register_violations(&[UnsafetyViolation {\n                                     source_info,\n-                                    description: InternedString::intern(description),\n-                                    details: InternedString::intern(details),\n+                                    description: Symbol::intern(description),\n+                                    details: Symbol::intern(details),\n                                     kind: UnsafetyViolationKind::GeneralAndConstFn,\n                                 }], &[]);\n                             }"}, {"sha": "8ceb56b0fd2b4c4004f2d809664499e95bbf133a", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,8 +1,8 @@\n //! Used by `rustc` when loading a plugin.\n \n+use rustc::middle::cstore::MetadataLoader;\n use rustc::session::Session;\n-use rustc_metadata::creader::CrateLoader;\n-use rustc_metadata::cstore::CStore;\n+use rustc_metadata::locator;\n use crate::registry::Registry;\n \n use std::borrow::ToOwned;\n@@ -25,7 +25,7 @@ pub struct PluginRegistrar {\n \n struct PluginLoader<'a> {\n     sess: &'a Session,\n-    reader: CrateLoader<'a>,\n+    metadata_loader: &'a dyn MetadataLoader,\n     plugins: Vec<PluginRegistrar>,\n }\n \n@@ -37,11 +37,10 @@ fn call_malformed_plugin_attribute(sess: &Session, span: Span) {\n \n /// Read plugin metadata and dynamically load registrar functions.\n pub fn load_plugins(sess: &Session,\n-                    cstore: &CStore,\n+                    metadata_loader: &dyn MetadataLoader,\n                     krate: &ast::Crate,\n-                    crate_name: &str,\n                     addl_plugins: Option<Vec<String>>) -> Vec<PluginRegistrar> {\n-    let mut loader = PluginLoader::new(sess, cstore, crate_name);\n+    let mut loader = PluginLoader { sess, metadata_loader, plugins: Vec::new() };\n \n     // do not report any error now. since crate attributes are\n     // not touched by expansion, every use of plugin without\n@@ -80,16 +79,8 @@ pub fn load_plugins(sess: &Session,\n }\n \n impl<'a> PluginLoader<'a> {\n-    fn new(sess: &'a Session, cstore: &'a CStore, crate_name: &str) -> Self {\n-        PluginLoader {\n-            sess,\n-            reader: CrateLoader::new(sess, cstore, crate_name),\n-            plugins: vec![],\n-        }\n-    }\n-\n     fn load_plugin(&mut self, span: Span, name: Symbol, args: Vec<ast::NestedMetaItem>) {\n-        let registrar = self.reader.find_plugin_registrar(span, name);\n+        let registrar = locator::find_plugin_registrar(self.sess, self.metadata_loader, span, name);\n \n         if let Some((lib, disambiguator)) = registrar {\n             let symbol = self.sess.generate_plugin_registrar_symbol(disambiguator);"}, {"sha": "2e23b8c870cfcbb68d0609fec81ec3f5793a661a", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,8 +1,7 @@\n //! Used by plugin crates to tell `rustc` about the plugins they provide.\n \n-use rustc::lint::{EarlyLintPassObject, LateLintPassObject, LintId, Lint};\n+use rustc::lint::LintStore;\n use rustc::session::Session;\n-use rustc::util::nodemap::FxHashMap;\n \n use syntax_expand::base::{SyntaxExtension, SyntaxExtensionKind, NamedSyntaxExtension};\n use syntax_expand::base::MacroExpanderFn;\n@@ -26,6 +25,9 @@ pub struct Registry<'a> {\n     /// from the plugin registrar.\n     pub sess: &'a Session,\n \n+    /// The `LintStore` allows plugins to register new lints.\n+    pub lint_store: &'a mut LintStore,\n+\n     #[doc(hidden)]\n     pub args_hidden: Option<Vec<ast::NestedMetaItem>>,\n \n@@ -35,15 +37,6 @@ pub struct Registry<'a> {\n     #[doc(hidden)]\n     pub syntax_exts: Vec<NamedSyntaxExtension>,\n \n-    #[doc(hidden)]\n-    pub early_lint_passes: Vec<EarlyLintPassObject>,\n-\n-    #[doc(hidden)]\n-    pub late_lint_passes: Vec<LateLintPassObject>,\n-\n-    #[doc(hidden)]\n-    pub lint_groups: FxHashMap<&'static str, (Vec<LintId>, Option<&'static str>)>,\n-\n     #[doc(hidden)]\n     pub llvm_passes: Vec<String>,\n \n@@ -53,15 +46,13 @@ pub struct Registry<'a> {\n \n impl<'a> Registry<'a> {\n     #[doc(hidden)]\n-    pub fn new(sess: &'a Session, krate_span: Span) -> Registry<'a> {\n+    pub fn new(sess: &'a Session, lint_store: &'a mut LintStore, krate_span: Span) -> Registry<'a> {\n         Registry {\n             sess,\n+            lint_store,\n             args_hidden: None,\n             krate_span,\n             syntax_exts: vec![],\n-            early_lint_passes: vec![],\n-            late_lint_passes: vec![],\n-            lint_groups: FxHashMap::default(),\n             llvm_passes: vec![],\n             attributes: vec![],\n         }\n@@ -99,27 +90,6 @@ impl<'a> Registry<'a> {\n         self.register_syntax_extension(Symbol::intern(name), ext);\n     }\n \n-    /// Register a compiler lint pass.\n-    pub fn register_early_lint_pass(&mut self, lint_pass: EarlyLintPassObject) {\n-        self.early_lint_passes.push(lint_pass);\n-    }\n-\n-    /// Register a compiler lint pass.\n-    pub fn register_late_lint_pass(&mut self, lint_pass: LateLintPassObject) {\n-        self.late_lint_passes.push(lint_pass);\n-    }\n-    /// Register a lint group.\n-    pub fn register_lint_group(\n-        &mut self,\n-        name: &'static str,\n-        deprecated_name: Option<&'static str>,\n-        to: Vec<&'static Lint>\n-    ) {\n-        self.lint_groups.insert(name,\n-                                (to.into_iter().map(|x| LintId::of(x)).collect(),\n-                                 deprecated_name));\n-    }\n-\n     /// Register an LLVM pass.\n     ///\n     /// Registration with LLVM itself is handled through static C++ objects with"}, {"sha": "c0fb8e33a819eb6ec0bc6313a20e9c4447edbe52", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -110,14 +110,14 @@ impl<'a> Resolver<'a> {\n         }\n \n         let (name, parent) = if def_id.index == CRATE_DEF_INDEX {\n-            (self.cstore.crate_name_untracked(def_id.krate).as_interned_str(), None)\n+            (self.cstore().crate_name_untracked(def_id.krate), None)\n         } else {\n-            let def_key = self.cstore.def_key(def_id);\n+            let def_key = self.cstore().def_key(def_id);\n             (def_key.disambiguated_data.data.get_opt_name().unwrap(),\n              Some(self.get_module(DefId { index: def_key.parent.unwrap(), ..def_id })))\n         };\n \n-        let kind = ModuleKind::Def(DefKind::Mod, def_id, name.as_symbol());\n+        let kind = ModuleKind::Def(DefKind::Mod, def_id, name);\n         let module = self.arenas.alloc_module(ModuleData::new(\n             parent, kind, def_id, ExpnId::root(), DUMMY_SP\n         ));\n@@ -153,9 +153,8 @@ impl<'a> Resolver<'a> {\n             return Some(ext.clone());\n         }\n \n-        let ext = Lrc::new(match self.cstore.load_macro_untracked(def_id, &self.session) {\n-            LoadedMacro::MacroDef(item) =>\n-                self.compile_macro(&item, self.cstore.crate_edition_untracked(def_id.krate)),\n+        let ext = Lrc::new(match self.cstore().load_macro_untracked(def_id, &self.session) {\n+            LoadedMacro::MacroDef(item, edition) => self.compile_macro(&item, edition),\n             LoadedMacro::ProcMacro(ext) => ext,\n         });\n \n@@ -177,7 +176,7 @@ impl<'a> Resolver<'a> {\n \n     crate fn build_reduced_graph_external(&mut self, module: Module<'a>) {\n         let def_id = module.def_id().expect(\"unpopulated module without a def-id\");\n-        for child in self.cstore.item_children_untracked(def_id, self.session) {\n+        for child in self.cstore().item_children_untracked(def_id, self.session) {\n             let child = child.map_id(|_| panic!(\"unexpected id\"));\n             BuildReducedGraphVisitor { r: self, parent_scope: ParentScope::module(module) }\n                 .build_reduced_graph_for_external_crate_res(child);\n@@ -885,19 +884,19 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 bug!(\"unexpected resolution: {:?}\", res)\n         }\n         // Record some extra data for better diagnostics.\n+        let cstore = self.r.cstore();\n         match res {\n             Res::Def(DefKind::Struct, def_id) | Res::Def(DefKind::Union, def_id) => {\n-                let field_names =\n-                    self.r.cstore.struct_field_names_untracked(def_id, self.r.session);\n+                let field_names = cstore.struct_field_names_untracked(def_id, self.r.session);\n                 self.insert_field_names(def_id, field_names);\n             }\n             Res::Def(DefKind::Method, def_id) => {\n-                if self.r.cstore.associated_item_cloned_untracked(def_id).method_has_self_argument {\n+                if cstore.associated_item_cloned_untracked(def_id).method_has_self_argument {\n                     self.r.has_self.insert(def_id);\n                 }\n             }\n             Res::Def(DefKind::Ctor(CtorOf::Struct, ..), def_id) => {\n-                let parent = self.r.cstore.def_key(def_id).parent;\n+                let parent = cstore.def_key(def_id).parent;\n                 if let Some(struct_def_id) = parent.map(|index| DefId { index, ..def_id }) {\n                     self.r.struct_constructors.insert(struct_def_id, (res, vis));\n                 }"}, {"sha": "7634093fbefbac29bbbb8f0336bc92a40ed95011", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -367,16 +367,6 @@ impl<'a> Resolver<'a> {\n                     span, \"`Self` in type parameter default\".to_string());\n                 err\n             }\n-            ResolutionError::ConstParamDependentOnTypeParam => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0671,\n-                    \"const parameters cannot depend on type parameters\"\n-                );\n-                err.span_label(span, format!(\"const parameter depends on type parameter\"));\n-                err\n-            }\n         }\n     }\n "}, {"sha": "9883a64a1e896e6600b26fad803a275bfeaa7d8d", "filename": "src/librustc_resolve/error_codes.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_resolve%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_resolve%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_codes.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1831,7 +1831,7 @@ An item usage is ambiguous.\n \n Erroneous code example:\n \n-```compile_fail,E0659\n+```compile_fail,edition2018,E0659\n pub mod moon {\n     pub fn foo() {}\n }\n@@ -1841,12 +1841,12 @@ pub mod earth {\n }\n \n mod collider {\n-    pub use moon::*;\n-    pub use earth::*;\n+    pub use crate::moon::*;\n+    pub use crate::earth::*;\n }\n \n fn main() {\n-    collider::foo(); // ERROR: `foo` is ambiguous\n+    crate::collider::foo(); // ERROR: `foo` is ambiguous\n }\n ```\n \n@@ -1858,7 +1858,7 @@ functions collide.\n To solve this error, the best solution is generally to keep the path before the\n item when using it. Example:\n \n-```\n+```edition2018\n pub mod moon {\n     pub fn foo() {}\n }\n@@ -1868,25 +1868,26 @@ pub mod earth {\n }\n \n mod collider {\n-    pub use moon;\n-    pub use earth;\n+    pub use crate::moon;\n+    pub use crate::earth;\n }\n \n fn main() {\n-    collider::moon::foo(); // ok!\n-    collider::earth::foo(); // ok!\n+    crate::collider::moon::foo(); // ok!\n+    crate::collider::earth::foo(); // ok!\n }\n ```\n \"##,\n \n E0671: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n Const parameters cannot depend on type parameters.\n The following is therefore invalid:\n-```compile_fail,E0671\n+```compile_fail,E0741\n #![feature(const_generics)]\n \n-fn const_id<T, const N: T>() -> T { // error: const parameter\n-                                    // depends on type parameter\n+fn const_id<T, const N: T>() -> T { // error\n     N\n }\n ```"}, {"sha": "136ab1f0444fa87cc334f1d77b862042e32bf51a", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -111,9 +111,6 @@ crate enum RibKind<'a> {\n     /// from the default of a type parameter because they're not declared\n     /// before said type parameter. Also see the `visit_generics` override.\n     ForwardTyParamBanRibKind,\n-\n-    /// We forbid the use of type parameters as the types of const parameters.\n-    TyParamAsConstParamTy,\n }\n \n impl RibKind<'_> {\n@@ -128,8 +125,7 @@ impl RibKind<'_> {\n             | MacroDefinition(_) => false,\n             AssocItemRibKind\n             | ItemRibKind(_)\n-            | ForwardTyParamBanRibKind\n-            | TyParamAsConstParamTy => true,\n+            | ForwardTyParamBanRibKind => true,\n         }\n     }\n }\n@@ -483,18 +479,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n             default_ban_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), Res::Err);\n         }\n \n-        // We also ban access to type parameters for use as the types of const parameters.\n-        let mut const_ty_param_ban_rib = Rib::new(TyParamAsConstParamTy);\n-        const_ty_param_ban_rib.bindings.extend(generics.params.iter()\n-            .filter(|param| {\n-                if let GenericParamKind::Type { .. } = param.kind {\n-                    true\n-                } else {\n-                    false\n-                }\n-            })\n-            .map(|param| (Ident::with_dummy_span(param.ident.name), Res::Err)));\n-\n         for param in &generics.params {\n             match param.kind {\n                 GenericParamKind::Lifetime { .. } => self.visit_generic_param(param),\n@@ -513,15 +497,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n                     default_ban_rib.bindings.remove(&Ident::with_dummy_span(param.ident.name));\n                 }\n                 GenericParamKind::Const { ref ty } => {\n-                    self.ribs[TypeNS].push(const_ty_param_ban_rib);\n-\n                     for bound in &param.bounds {\n                         self.visit_param_bound(bound);\n                     }\n-\n                     self.visit_ty(ty);\n-\n-                    const_ty_param_ban_rib = self.ribs[TypeNS].pop().unwrap();\n                 }\n             }\n         }"}, {"sha": "92392806347244ce9e65f93f4b61b85494b04afd", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 68, "deletions": 33, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -21,14 +21,14 @@ use Determinacy::*;\n \n use rustc::hir::map::Definitions;\n use rustc::hir::{self, PrimTy, Bool, Char, Float, Int, Uint, Str};\n-use rustc::middle::cstore::CrateStore;\n+use rustc::middle::cstore::{CrateStore, MetadataLoaderDyn};\n use rustc::session::Session;\n use rustc::lint;\n use rustc::hir::def::{self, DefKind, PartialRes, CtorKind, CtorOf, NonMacroAttrKind, ExportMap};\n use rustc::hir::def::Namespace::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefId};\n use rustc::hir::{TraitMap, GlobMap};\n-use rustc::ty::{self, DefIdTree};\n+use rustc::ty::{self, DefIdTree, ResolverOutputs};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n use rustc::span_bug;\n \n@@ -215,8 +215,6 @@ enum ResolutionError<'a> {\n     ForwardDeclaredTyParam, // FIXME(const_generics:defaults)\n     /// Error E0735: type parameters with a default cannot use `Self`\n     SelfInTyParamDefault,\n-    /// Error E0671: const parameter cannot depend on type parameter.\n-    ConstParamDependentOnTypeParam,\n }\n \n // A minimal representation of a path segment. We use this in resolve because\n@@ -829,14 +827,13 @@ pub struct ExternPreludeEntry<'a> {\n /// This is the visitor that walks the whole crate.\n pub struct Resolver<'a> {\n     session: &'a Session,\n-    cstore: &'a CStore,\n \n-    pub definitions: Definitions,\n+    definitions: Definitions,\n \n-    pub graph_root: Module<'a>,\n+    graph_root: Module<'a>,\n \n     prelude: Option<Module<'a>>,\n-    pub extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'a>>,\n+    extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'a>>,\n \n     /// N.B., this is used only for better diagnostics, not name resolution itself.\n     has_self: FxHashSet<DefId>,\n@@ -869,9 +866,9 @@ pub struct Resolver<'a> {\n     label_res_map: NodeMap<NodeId>,\n \n     /// `CrateNum` resolutions of `extern crate` items.\n-    pub extern_crate_map: NodeMap<CrateNum>,\n-    pub export_map: ExportMap<NodeId>,\n-    pub trait_map: TraitMap,\n+    extern_crate_map: NodeMap<CrateNum>,\n+    export_map: ExportMap<NodeId>,\n+    trait_map: TraitMap,\n \n     /// A map from nodes to anonymous modules.\n     /// Anonymous modules are pseudo-modules that are implicitly created around items\n@@ -898,11 +895,11 @@ pub struct Resolver<'a> {\n     underscore_disambiguator: u32,\n \n     /// Maps glob imports to the names of items actually imported.\n-    pub glob_map: GlobMap,\n+    glob_map: GlobMap,\n \n     used_imports: FxHashSet<(NodeId, Namespace)>,\n-    pub maybe_unused_trait_imports: NodeSet,\n-    pub maybe_unused_extern_crates: Vec<(NodeId, Span)>,\n+    maybe_unused_trait_imports: NodeSet,\n+    maybe_unused_extern_crates: Vec<(NodeId, Span)>,\n \n     /// Privacy errors are delayed until the end in order to deduplicate them.\n     privacy_errors: Vec<PrivacyError<'a>>,\n@@ -916,11 +913,11 @@ pub struct Resolver<'a> {\n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n \n-    crate_loader: &'a CrateLoader<'a>,\n+    crate_loader: CrateLoader<'a>,\n     macro_names: FxHashSet<Ident>,\n     builtin_macros: FxHashMap<Name, SyntaxExtension>,\n     macro_use_prelude: FxHashMap<Name, &'a NameBinding<'a>>,\n-    pub all_macros: FxHashMap<Name, Res>,\n+    all_macros: FxHashMap<Name, Res>,\n     macro_map: FxHashMap<DefId, Lrc<SyntaxExtension>>,\n     dummy_ext_bang: Lrc<SyntaxExtension>,\n     dummy_ext_derive: Lrc<SyntaxExtension>,\n@@ -1015,14 +1012,18 @@ impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n     fn parent(self, id: DefId) -> Option<DefId> {\n         match id.krate {\n             LOCAL_CRATE => self.definitions.def_key(id.index).parent,\n-            _ => self.cstore.def_key(id).parent,\n+            _ => self.cstore().def_key(id).parent,\n         }.map(|index| DefId { index, ..id })\n     }\n }\n \n /// This interface is used through the AST\u2192HIR step, to embed full paths into the HIR. After that\n /// the resolver is no longer needed as all the relevant information is inline.\n impl<'a> hir::lowering::Resolver for Resolver<'a> {\n+    fn cstore(&self) -> &dyn CrateStore {\n+        self.cstore()\n+    }\n+\n     fn resolve_str_path(\n         &mut self,\n         span: Span,\n@@ -1083,10 +1084,9 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n \n impl<'a> Resolver<'a> {\n     pub fn new(session: &'a Session,\n-               cstore: &'a CStore,\n                krate: &Crate,\n                crate_name: &str,\n-               crate_loader: &'a CrateLoader<'a>,\n+               metadata_loader: &'a MetadataLoaderDyn,\n                arenas: &'a ResolverArenas<'a>)\n                -> Resolver<'a> {\n         let root_def_id = DefId::local(CRATE_DEF_INDEX);\n@@ -1147,8 +1147,6 @@ impl<'a> Resolver<'a> {\n         Resolver {\n             session,\n \n-            cstore,\n-\n             definitions,\n \n             // The outermost module has def ID 0; this is not reflected in the\n@@ -1202,7 +1200,7 @@ impl<'a> Resolver<'a> {\n                 vis: ty::Visibility::Public,\n             }),\n \n-            crate_loader,\n+            crate_loader: CrateLoader::new(session, metadata_loader, crate_name),\n             macro_names: FxHashSet::default(),\n             builtin_macros: Default::default(),\n             macro_use_prelude: FxHashMap::default(),\n@@ -1236,6 +1234,42 @@ impl<'a> Resolver<'a> {\n         Default::default()\n     }\n \n+    pub fn into_outputs(self) -> ResolverOutputs {\n+        ResolverOutputs {\n+            definitions: self.definitions,\n+            cstore: Box::new(self.crate_loader.into_cstore()),\n+            extern_crate_map: self.extern_crate_map,\n+            export_map: self.export_map,\n+            trait_map: self.trait_map,\n+            glob_map: self.glob_map,\n+            maybe_unused_trait_imports: self.maybe_unused_trait_imports,\n+            maybe_unused_extern_crates: self.maybe_unused_extern_crates,\n+            extern_prelude: self.extern_prelude.iter().map(|(ident, entry)| {\n+                (ident.name, entry.introduced_by_item)\n+            }).collect(),\n+        }\n+    }\n+\n+    pub fn clone_outputs(&self) -> ResolverOutputs {\n+        ResolverOutputs {\n+            definitions: self.definitions.clone(),\n+            cstore: Box::new(self.cstore().clone()),\n+            extern_crate_map: self.extern_crate_map.clone(),\n+            export_map: self.export_map.clone(),\n+            trait_map: self.trait_map.clone(),\n+            glob_map: self.glob_map.clone(),\n+            maybe_unused_trait_imports: self.maybe_unused_trait_imports.clone(),\n+            maybe_unused_extern_crates: self.maybe_unused_extern_crates.clone(),\n+            extern_prelude: self.extern_prelude.iter().map(|(ident, entry)| {\n+                (ident.name, entry.introduced_by_item)\n+            }).collect(),\n+        }\n+    }\n+\n+    pub fn cstore(&self) -> &CStore {\n+        self.crate_loader.cstore()\n+    }\n+\n     fn non_macro_attr(&self, mark_used: bool) -> Lrc<SyntaxExtension> {\n         self.non_macro_attrs[mark_used as usize].clone()\n     }\n@@ -2169,15 +2203,6 @@ impl<'a> Resolver<'a> {\n             return Res::Err;\n         }\n \n-        // An invalid use of a type parameter as the type of a const parameter.\n-        if let TyParamAsConstParamTy = all_ribs[rib_index].kind {\n-            if record_used {\n-                self.report_error(span, ResolutionError::ConstParamDependentOnTypeParam);\n-            }\n-            assert_eq!(res, Res::Err);\n-            return Res::Err;\n-        }\n-\n         match res {\n             Res::Local(_) => {\n                 use ResolutionError::*;\n@@ -2186,7 +2211,7 @@ impl<'a> Resolver<'a> {\n                 for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind | ModuleRibKind(..) | MacroDefinition(..) |\n-                        ForwardTyParamBanRibKind | TyParamAsConstParamTy => {\n+                        ForwardTyParamBanRibKind => {\n                             // Nothing to do. Continue.\n                         }\n                         ItemRibKind(_) | FnItemRibKind | AssocItemRibKind => {\n@@ -2220,7 +2245,7 @@ impl<'a> Resolver<'a> {\n                     let has_generic_params = match rib.kind {\n                         NormalRibKind | AssocItemRibKind |\n                         ModuleRibKind(..) | MacroDefinition(..) | ForwardTyParamBanRibKind |\n-                        ConstantItemRibKind | TyParamAsConstParamTy => {\n+                        ConstantItemRibKind => {\n                             // Nothing to do. Continue.\n                             continue;\n                         }\n@@ -2808,6 +2833,16 @@ impl<'a> Resolver<'a> {\n         seg.id = self.session.next_node_id();\n         seg\n     }\n+\n+    // For rustdoc.\n+    pub fn graph_root(&self) -> Module<'a> {\n+        self.graph_root\n+    }\n+\n+    // For rustdoc.\n+    pub fn all_macros(&self) -> &FxHashMap<Name, Res> {\n+        &self.all_macros\n+    }\n }\n \n fn names_to_string(names: &[Name]) -> String {"}, {"sha": "31340ddd68372f18455ab587247f4eaea20d3d69", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1344,7 +1344,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 if res != Res::Err {\n                     if let Some(def_id) = res.opt_def_id() {\n                         if !def_id.is_local() {\n-                            this.cstore.export_macros_untracked(def_id.krate);\n+                            this.cstore().export_macros_untracked(def_id.krate);\n                         }\n                     }\n                     reexports.push(Export {"}, {"sha": "79dc4f7e1361320f40460db460b3a495ac136054", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -131,7 +131,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     {\n         let tcx = self.tcx();\n         let lifetime_name = |def_id| {\n-            tcx.hir().name(tcx.hir().as_local_hir_id(def_id).unwrap()).as_interned_str()\n+            tcx.hir().name(tcx.hir().as_local_hir_id(def_id).unwrap())\n         };\n \n         let r = match tcx.named_region(lifetime.hir_id) {\n@@ -1274,8 +1274,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     span,\n                     item.trait_ref().def_id(),\n                     object_safety_violations\n-                )\n-                    .map(|mut err| err.emit());\n+                ).emit();\n                 return tcx.types.err;\n             }\n         }\n@@ -2023,7 +2022,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let item_def_id = tcx.hir().local_def_id(item_id);\n                 let generics = tcx.generics_of(item_def_id);\n                 let index = generics.param_def_id_to_index[&def_id];\n-                tcx.mk_ty_param(index, tcx.hir().name(hir_id).as_interned_str())\n+                tcx.mk_ty_param(index, tcx.hir().name(hir_id))\n             }\n             Res::SelfTy(Some(_), None) => {\n                 // `Self` in trait or type alias.\n@@ -2204,7 +2203,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             let item_def_id = tcx.hir().local_def_id(item_id);\n             let generics = tcx.generics_of(item_def_id);\n             let index = generics.param_def_id_to_index[&tcx.hir().local_def_id(hir_id)];\n-            let name = tcx.hir().name(hir_id).as_interned_str();\n+            let name = tcx.hir().name(hir_id);\n             const_.val = ConstValue::Param(ty::ParamConst::new(index, name));\n         }\n "}, {"sha": "9cbde276ae97ce1d933423d5b5413eb4d1310c80", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -428,21 +428,36 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             self.report_cast_to_unsized_type(fcx);\n         } else if self.expr_ty.references_error() || self.cast_ty.references_error() {\n             // No sense in giving duplicate error messages\n-        } else if self.try_coercion_cast(fcx) {\n-            self.trivial_cast_lint(fcx);\n-            debug!(\" -> CoercionCast\");\n-            fcx.tables.borrow_mut().set_coercion_cast(self.expr.hir_id.local_id);\n-\n         } else {\n-            match self.do_check(fcx) {\n-                Ok(k) => {\n-                    debug!(\" -> {:?}\", k);\n+            match self.try_coercion_cast(fcx) {\n+                Ok(()) => {\n+                    self.trivial_cast_lint(fcx);\n+                    debug!(\" -> CoercionCast\");\n+                    fcx.tables.borrow_mut()\n+                        .set_coercion_cast(self.expr.hir_id.local_id);\n+                }\n+                Err(ty::error::TypeError::ObjectUnsafeCoercion(did)) => {\n+                    self.report_object_unsafe_cast(&fcx, did);\n+                }\n+                Err(_) => {\n+                    match self.do_check(fcx) {\n+                        Ok(k) => {\n+                            debug!(\" -> {:?}\", k);\n+                        }\n+                        Err(e) => self.report_cast_error(fcx, e),\n+                    };\n                 }\n-                Err(e) => self.report_cast_error(fcx, e),\n             };\n         }\n     }\n \n+    fn report_object_unsafe_cast(&self, fcx: &FnCtxt<'a, 'tcx>, did: DefId) {\n+        let violations = fcx.tcx.object_safety_violations(did);\n+        let mut err = fcx.tcx.report_object_safety_error(self.cast_span, did, violations);\n+        err.note(&format!(\"required by cast to type '{}'\", fcx.ty_to_string(self.cast_ty)));\n+        err.emit();\n+    }\n+\n     /// Checks a cast, and report an error if one exists. In some cases, this\n     /// can return Ok and create type errors in the fcx rather than returning\n     /// directly. coercion-cast is handled in check instead of here.\n@@ -646,8 +661,14 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn try_coercion_cast(&self, fcx: &FnCtxt<'a, 'tcx>) -> bool {\n-        fcx.try_coerce(self.expr, self.expr_ty, self.cast_ty, AllowTwoPhase::No).is_ok()\n+    fn try_coercion_cast(\n+        &self,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+    ) -> Result<(), ty::error::TypeError<'_>> {\n+        match fcx.try_coerce(self.expr, self.expr_ty, self.cast_ty, AllowTwoPhase::No) {\n+            Ok(_) => Ok(()),\n+            Err(err) => Err(err),\n+        }\n     }\n }\n "}, {"sha": "f79351dc903106cd1d89d6edd0a5119253e078f4", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -61,10 +61,11 @@ use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n use rustc::ty::adjustment::{\n     Adjustment, Adjust, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast\n };\n-use rustc::ty::{self, TypeAndMut, Ty, subst::SubstsRef};\n+use rustc::ty::{self, TypeAndMut, Ty};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::error::TypeError;\n use rustc::ty::relate::RelateResult;\n+use rustc::ty::subst::SubstsRef;\n use smallvec::{smallvec, SmallVec};\n use std::ops::Deref;\n use syntax::feature_gate;\n@@ -196,9 +197,16 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // a \"spurious\" type variable, and we don't want to have that\n         // type variable in memory if the coercion fails.\n         let unsize = self.commit_if_ok(|_| self.coerce_unsized(a, b));\n-        if unsize.is_ok() {\n-            debug!(\"coerce: unsize successful\");\n-            return unsize;\n+        match unsize {\n+            Ok(_) => {\n+                debug!(\"coerce: unsize successful\");\n+                return unsize;\n+            }\n+            Err(TypeError::ObjectUnsafeCoercion(did)) => {\n+                debug!(\"coerce: unsize not object safe\");\n+                return Err(TypeError::ObjectUnsafeCoercion(did));\n+            }\n+            Err(_) => {}\n         }\n         debug!(\"coerce: unsize failed\");\n \n@@ -539,7 +547,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let mut selcx = traits::SelectionContext::new(self);\n \n         // Create an obligation for `Source: CoerceUnsized<Target>`.\n-        let cause = ObligationCause::misc(self.cause.span, self.body_id);\n+        let cause = ObligationCause::new(\n+            self.cause.span,\n+            self.body_id,\n+            ObligationCauseCode::Coercion { source, target },\n+        );\n \n         // Use a FIFO queue for this custom fulfillment procedure.\n         //\n@@ -566,14 +578,15 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             let obligation = queue.remove(0);\n             debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n             let trait_ref = match obligation.predicate {\n-                ty::Predicate::Trait(ref t) if traits.contains(&t.def_id()) => {\n-                    if unsize_did == t.def_id() {\n-                        if let ty::Tuple(..) = &t.skip_binder().input_types().nth(1).unwrap().kind {\n+                ty::Predicate::Trait(ref tr) if traits.contains(&tr.def_id()) => {\n+                    if unsize_did == tr.def_id() {\n+                        let sty = &tr.skip_binder().input_types().nth(1).unwrap().kind;\n+                        if let ty::Tuple(..) = sty {\n                             debug!(\"coerce_unsized: found unsized tuple coercion\");\n                             has_unsized_tuple_coercion = true;\n                         }\n                     }\n-                    t.clone()\n+                    tr.clone()\n                 }\n                 _ => {\n                     coercion.obligations.push(obligation);"}, {"sha": "8668dd99a8cf44b07baa34ed8496f21b5fee8563", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -566,7 +566,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // the `enclosing_loops` field and let's coerce the\n             // type of `expr_opt` into what is expected.\n             let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-            let ctxt = enclosing_breakables.find_breakable(target_id);\n+            let ctxt = match enclosing_breakables.opt_find_breakable(target_id) {\n+                Some(ctxt) => ctxt,\n+                None => { // Avoid ICE when `break` is inside a closure (#65383).\n+                    self.tcx.sess.delay_span_bug(\n+                        expr.span,\n+                        \"break was outside loop, but no error was emitted\",\n+                    );\n+                    return tcx.types.err;\n+                }\n+            };\n+\n             if let Some(ref mut coerce) = ctxt.coerce {\n                 if let Some(ref e) = expr_opt {\n                     coerce.coerce(self, &cause, e, e_ty);\n@@ -592,7 +602,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             } else {\n                 // If `ctxt.coerce` is `None`, we can just ignore\n-                // the type of the expresison.  This is because\n+                // the type of the expression.  This is because\n                 // either this was a break *without* a value, in\n                 // which case it is always a legal type (`()`), or\n                 // else an error would have been flagged by the"}, {"sha": "72a0fe887b9646fc8df95be922e43fbd55bc906e", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::subst::Subst;\n use crate::require_same_types;\n \n use rustc_target::spec::abi::Abi;\n-use syntax::symbol::InternedString;\n+use syntax::symbol::Symbol;\n \n use rustc::hir;\n \n@@ -80,7 +80,7 @@ pub fn intrinsic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n /// Remember to add all intrinsics here, in librustc_codegen_llvm/intrinsic.rs,\n /// and in libcore/intrinsics.rs\n pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n-    let param = |n| tcx.mk_ty_param(n, InternedString::intern(&format!(\"P{}\", n)));\n+    let param = |n| tcx.mk_ty_param(n, Symbol::intern(&format!(\"P{}\", n)));\n     let name = it.ident.as_str();\n \n     let mk_va_list_ty = |mutbl| {\n@@ -387,7 +387,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n /// Type-check `extern \"platform-intrinsic\" { ... }` functions.\n pub fn check_platform_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n     let param = |n| {\n-        let name = InternedString::intern(&format!(\"P{}\", n));\n+        let name = Symbol::intern(&format!(\"P{}\", n));\n         tcx.mk_ty_param(n, name)\n     };\n "}, {"sha": "59636d32bc037b84dcee5d97e5fcfa36f39bffd5", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -141,14 +141,24 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // ADJUSTMENTS\n \n-    fn adjust_self_ty(&mut self,\n-                      unadjusted_self_ty: Ty<'tcx>,\n-                      pick: &probe::Pick<'tcx>)\n-                      -> Ty<'tcx> {\n+    fn adjust_self_ty(\n+        &mut self,\n+        unadjusted_self_ty: Ty<'tcx>,\n+        pick: &probe::Pick<'tcx>,\n+    ) -> Ty<'tcx> {\n         // Commit the autoderefs by calling `autoderef` again, but this\n         // time writing the results into the various tables.\n         let mut autoderef = self.autoderef(self.span, unadjusted_self_ty);\n-        let (_, n) = autoderef.nth(pick.autoderefs).unwrap();\n+        let (_, n) = match autoderef.nth(pick.autoderefs) {\n+            Some(n) => n,\n+            None => {\n+                self.tcx.sess.delay_span_bug(\n+                    syntax_pos::DUMMY_SP,\n+                    &format!(\"failed autoderef {}\", pick.autoderefs),\n+                );\n+                return self.tcx.types.err;\n+            }\n+        };\n         assert_eq!(n, pick.autoderefs);\n \n         let mut adjustments = autoderef.adjust_steps(self, Needs::None);"}, {"sha": "96a097695fa1f00d9269d551b6f38d1148661a87", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -536,10 +536,16 @@ pub struct EnclosingBreakables<'tcx> {\n \n impl<'tcx> EnclosingBreakables<'tcx> {\n     fn find_breakable(&mut self, target_id: hir::HirId) -> &mut BreakableCtxt<'tcx> {\n-        let ix = *self.by_id.get(&target_id).unwrap_or_else(|| {\n+        self.opt_find_breakable(target_id).unwrap_or_else(|| {\n             bug!(\"could not find enclosing breakable with id {}\", target_id);\n-        });\n-        &mut self.stack[ix]\n+        })\n+    }\n+\n+    fn opt_find_breakable(&mut self, target_id: hir::HirId) -> Option<&mut BreakableCtxt<'tcx>> {\n+        match self.by_id.get(&target_id) {\n+            Some(ix) => Some(&mut self.stack[*ix]),\n+            None => None,\n+        }\n     }\n }\n \n@@ -2761,8 +2767,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let mut opaque_types = self.opaque_types.borrow_mut();\n         for (ty, decl) in opaque_type_map {\n-            let old_value = opaque_types.insert(ty, decl);\n-            assert!(old_value.is_none(), \"instantiated twice: {:?}/{:?}\", ty, decl);\n+            let _ = opaque_types.insert(ty, decl);\n         }\n \n         value"}, {"sha": "8adf4bb94a898c66d88f63157e6a206f55122f0f", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -183,8 +183,11 @@ fn check_impl_overlap<'tcx>(tcx: TyCtxt<'tcx>, hir_id: HirId) {\n \n         for component_def_id in component_def_ids {\n             if !tcx.is_object_safe(component_def_id) {\n-                // This is an error, but it will be reported by wfcheck.  Ignore it here.\n+                // Without the 'object_safe_for_dispatch' feature this is an error\n+                // which will be reported by wfcheck.  Ignore it here.\n                 // This is tested by `coherence-impl-trait-for-trait-object-safe.rs`.\n+                // With the feature enabled, the trait is not implemented automatically,\n+                // so this is valid.\n             } else {\n                 let mut supertrait_def_ids =\n                     traits::supertrait_def_ids(tcx, component_def_id);"}, {"sha": "00435d67184a356b9ae6835769163c3171b1a182", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -36,7 +36,7 @@ use syntax::ast;\n use syntax::ast::{Ident, MetaItemKind};\n use syntax::attr::{InlineAttr, OptimizeAttr, list_contains_name, mark_used};\n use syntax::feature_gate;\n-use syntax::symbol::{InternedString, kw, Symbol, sym};\n+use syntax::symbol::{kw, Symbol, sym};\n use syntax_pos::{Span, DUMMY_SP};\n \n use rustc::hir::def::{CtorKind, Res, DefKind};\n@@ -265,7 +265,7 @@ fn type_param_predicates(\n     let param_owner_def_id = tcx.hir().local_def_id(param_owner);\n     let generics = tcx.generics_of(param_owner_def_id);\n     let index = generics.param_def_id_to_index[&def_id];\n-    let ty = tcx.mk_ty_param(index, tcx.hir().ty_param_name(param_id).as_interned_str());\n+    let ty = tcx.mk_ty_param(index, tcx.hir().ty_param_name(param_id));\n \n     // Don't look for bounds where the type parameter isn't in scope.\n     let parent = if item_def_id == param_owner_def_id {\n@@ -961,7 +961,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n \n                     opt_self = Some(ty::GenericParamDef {\n                         index: 0,\n-                        name: kw::SelfUpper.as_interned_str(),\n+                        name: kw::SelfUpper,\n                         def_id: tcx.hir().local_def_id(param_id),\n                         pure_wrt_drop: false,\n                         kind: ty::GenericParamDefKind::Type {\n@@ -1006,7 +1006,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n         early_lifetimes\n             .enumerate()\n             .map(|(i, param)| ty::GenericParamDef {\n-                name: param.name.ident().as_interned_str(),\n+                name: param.name.ident().name,\n                 index: own_start + i as u32,\n                 def_id: tcx.hir().local_def_id(param.hir_id),\n                 pure_wrt_drop: param.pure_wrt_drop,\n@@ -1060,7 +1060,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n \n                 let param_def = ty::GenericParamDef {\n                     index: type_start + i as u32,\n-                    name: param.name.ident().as_interned_str(),\n+                    name: param.name.ident().name,\n                     def_id: tcx.hir().local_def_id(param.hir_id),\n                     pure_wrt_drop: param.pure_wrt_drop,\n                     kind,\n@@ -1090,7 +1090,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                 .enumerate()\n                 .map(|(i, &arg)| ty::GenericParamDef {\n                     index: type_start + i as u32,\n-                    name: InternedString::intern(arg),\n+                    name: Symbol::intern(arg),\n                     def_id,\n                     pure_wrt_drop: false,\n                     kind: ty::GenericParamDefKind::Type {\n@@ -1105,7 +1105,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             params.extend(upvars.iter().zip((dummy_args.len() as u32)..).map(|(_, i)| {\n                 ty::GenericParamDef {\n                     index: type_start + i,\n-                    name: InternedString::intern(\"<upvar>\"),\n+                    name: Symbol::intern(\"<upvar>\"),\n                     def_id,\n                     pure_wrt_drop: false,\n                     kind: ty::GenericParamDefKind::Type {\n@@ -1532,6 +1532,17 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                         );\n                     };\n                 }\n+                if ty::search_for_structural_match_violation(tcx, ty).is_some() {\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        hir_ty.span,\n+                        E0741,\n+                        \"the types of const generic parameters must derive `PartialEq` and `Eq`\",\n+                    ).span_label(\n+                        hir_ty.span,\n+                        format!(\"`{}` doesn't derive both `PartialEq` and `Eq`\", ty),\n+                    ).emit();\n+                }\n                 ty\n             }\n             x => {\n@@ -2198,7 +2209,7 @@ fn explicit_predicates_of(\n         let region = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n             def_id: tcx.hir().local_def_id(param.hir_id),\n             index,\n-            name: param.name.ident().as_interned_str(),\n+            name: param.name.ident().name,\n         }));\n         index += 1;\n \n@@ -2221,7 +2232,7 @@ fn explicit_predicates_of(\n     // type parameter (e.g., `<T: Foo>`).\n     for param in &ast_generics.params {\n         if let GenericParamKind::Type { .. } = param.kind {\n-            let name = param.name.ident().as_interned_str();\n+            let name = param.name.ident().name;\n             let param_ty = ty::ParamTy::new(index, name).to_ty(tcx);\n             index += 1;\n "}, {"sha": "75b508a1bbf0ff6961d2631aabbb7229b143cf3a", "filename": "src/librustc_typeck/error_codes.rs", "status": "modified", "additions": 56, "deletions": 6, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_typeck%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustc_typeck%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Ferror_codes.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -194,7 +194,7 @@ a guard.\n ```compile_fail,E0029\n let string = \"salutations !\";\n \n-// The ordering relation for strings can't be evaluated at compile time,\n+// The ordering relation for strings cannot be evaluated at compile time,\n // so this doesn't work:\n match string {\n     \"hello\" ..= \"world\" => {}\n@@ -348,7 +348,7 @@ fn main() {\n \"##,\n \n E0044: r##\"\n-You can't use type or const parameters on foreign items.\n+You cannot use type or const parameters on foreign items.\n Example of erroneous code:\n \n ```compile_fail,E0044\n@@ -788,7 +788,7 @@ fn some_other_func() {}\n fn some_function() {\n     SOME_CONST = 14; // error : a constant value cannot be changed!\n     1 = 3; // error : 1 isn't a valid place!\n-    some_other_func() = 4; // error : we can't assign value to a function!\n+    some_other_func() = 4; // error : we cannot assign value to a function!\n     SomeStruct.x = 12; // error : SomeStruct a structure name but it is used\n                        // like a variable!\n }\n@@ -3891,6 +3891,33 @@ details.\n [issue #33685]: https://github.com/rust-lang/rust/issues/33685\n \"##,\n \n+E0588: r##\"\n+A type with `packed` representation hint has a field with `align`\n+representation hint.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0588\n+#[repr(align(16))]\n+struct Aligned(i32);\n+\n+#[repr(packed)] // error!\n+struct Packed(Aligned);\n+```\n+\n+Just like you cannot have both `align` and `packed` representation hints on a\n+same type, a `packed` type cannot contain another type with the `align`\n+representation hint. However, you can do the opposite:\n+\n+```\n+#[repr(packed)]\n+struct Packed(i32);\n+\n+#[repr(align(16))] // ok!\n+struct Aligned(Packed);\n+```\n+\"##,\n+\n E0592: r##\"\n This error occurs when you defined methods or associated functions with same\n name.\n@@ -4299,7 +4326,7 @@ extern {\n \n unsafe {\n     printf(::std::ptr::null(), 0f32);\n-    // error: can't pass an `f32` to variadic function, cast to `c_double`\n+    // error: cannot pass an `f32` to variadic function, cast to `c_double`\n }\n ```\n \n@@ -4978,6 +5005,30 @@ the future, [RFC 2091] prohibits their implementation without a follow-up RFC.\n [RFC 2091]: https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md\n \"##,\n \n+E0741: r##\"\n+Only `structural_match` types (that is, types that derive `PartialEq` and `Eq`)\n+may be used as the types of const generic parameters.\n+\n+```compile_fail,E0741\n+#![feature(const_generics)]\n+\n+struct A;\n+\n+struct B<const X: A>; // error!\n+```\n+\n+To fix this example, we derive `PartialEq` and `Eq`.\n+\n+```\n+#![feature(const_generics)]\n+\n+#[derive(PartialEq, Eq)]\n+struct A;\n+\n+struct B<const X: A>; // ok!\n+```\n+\"##,\n+\n ;\n //  E0035, merged into E0087/E0089\n //  E0036, merged into E0087/E0089\n@@ -5000,7 +5051,7 @@ the future, [RFC 2091] prohibits their implementation without a follow-up RFC.\n //  E0174,\n //  E0182, // merged into E0229\n     E0183,\n-//  E0187, // can't infer the kind of the closure\n+//  E0187, // cannot infer the kind of the closure\n //  E0188, // can not cast an immutable reference to a mutable pointer\n //  E0189, // deprecated: can only cast a boxed pointer to a boxed object\n //  E0190, // deprecated: can only cast a &-pointer to an &-object\n@@ -5047,7 +5098,6 @@ the future, [RFC 2091] prohibits their implementation without a follow-up RFC.\n //  E0564, // only named lifetimes are allowed in `impl Trait`,\n            // but `{}` was found in the type `{}`\n     E0587, // type has conflicting packed and align representation hints\n-    E0588, // packed type cannot transitively contain a `[repr(align)]` type\n //  E0611, // merged into E0616\n //  E0612, // merged into E0609\n //  E0613, // Removed (merged with E0609)"}, {"sha": "a6a8fec429e20ec80030a282350a18e6bf274738", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -479,8 +479,8 @@ fn build_static(cx: &DocContext<'_>, did: DefId, mutable: bool) -> clean::Static\n \n fn build_macro(cx: &DocContext<'_>, did: DefId, name: ast::Name) -> clean::ItemEnum {\n     let imported_from = cx.tcx.original_crate_name(did.krate);\n-    match cx.cstore.load_macro_untracked(did, cx.sess()) {\n-        LoadedMacro::MacroDef(def) => {\n+    match cx.enter_resolver(|r| r.cstore().load_macro_untracked(did, cx.sess())) {\n+        LoadedMacro::MacroDef(def, _) => {\n             let matchers: hir::HirVec<Span> = if let ast::ItemKind::MacroDef(ref def) = def.kind {\n                 let tts: Vec<_> = def.stream().into_trees().collect();\n                 tts.chunks(4).map(|arm| arm[0].span()).collect()"}, {"sha": "abc8b83144941d3309d1499451da25bbc6ba5314", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -31,7 +31,6 @@ use syntax::attr;\n use syntax_expand::base::MacroKind;\n use syntax::source_map::DUMMY_SP;\n use syntax::symbol::{Symbol, kw, sym};\n-use syntax::symbol::InternedString;\n use syntax_pos::{self, Pos, FileName};\n \n use std::collections::hash_map::Entry;\n@@ -1682,7 +1681,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n             .filter_map(|param| match param.kind {\n                 ty::GenericParamDefKind::Lifetime => None,\n                 ty::GenericParamDefKind::Type { synthetic, .. } => {\n-                    if param.name.as_symbol() == kw::SelfUpper {\n+                    if param.name == kw::SelfUpper {\n                         assert_eq!(param.index, 0);\n                         return None;\n                     }\n@@ -3701,13 +3700,6 @@ impl Clean<String> for ast::Name {\n     }\n }\n \n-impl Clean<String> for InternedString {\n-    #[inline]\n-    fn clean(&self, _: &DocContext<'_>) -> String {\n-        self.to_string()\n-    }\n-}\n-\n #[derive(Clone, Debug)]\n pub struct Typedef {\n     pub type_: Type,"}, {"sha": "b227f432a4e98d3b0b24ec111f7fdfd8208831d6", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -5,14 +5,13 @@ use rustc::hir::HirId;\n use rustc::middle::cstore::CrateStore;\n use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{Ty, TyCtxt};\n-use rustc::lint::{self, LintPass};\n+use rustc::lint;\n use rustc::session::config::ErrorOutputType;\n use rustc::session::DiagnosticOutput;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_interface::interface;\n use rustc_driver::abort_on_err;\n use rustc_resolve as resolve;\n-use rustc_metadata::cstore::CStore;\n \n use syntax::source_map;\n use syntax::attr;\n@@ -43,7 +42,6 @@ pub struct DocContext<'tcx> {\n \n     pub tcx: TyCtxt<'tcx>,\n     pub resolver: Rc<RefCell<interface::BoxedResolver>>,\n-    pub cstore: Lrc<CStore>,\n     /// Later on moved into `html::render::CACHE_KEY`\n     pub renderinfo: RefCell<RenderInfo>,\n     /// Later on moved through `clean::Crate` into `html::render::CACHE_KEY`\n@@ -117,9 +115,7 @@ impl<'tcx> DocContext<'tcx> {\n                     .def_path_table()\n                     .next_id()\n             } else {\n-                self.cstore\n-                    .def_path_table(crate_num)\n-                    .next_id()\n+                self.enter_resolver(|r| r.cstore().def_path_table(crate_num).next_id())\n             };\n \n             DefId {\n@@ -273,10 +269,9 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n     whitelisted_lints.extend(lint_opts.iter().map(|(lint, _)| lint).cloned());\n \n     let lints = || {\n-        lint::builtin::HardwiredLints\n-            .get_lints()\n+        lint::builtin::HardwiredLints::get_lints()\n             .into_iter()\n-            .chain(rustc_lint::SoftLints.get_lints().into_iter())\n+            .chain(rustc_lint::SoftLints::get_lints().into_iter())\n     };\n \n     let lint_opts = lints().filter_map(|lint| {\n@@ -339,6 +334,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         stderr: None,\n         crate_name,\n         lint_caps,\n+        register_lints: None,\n     };\n \n     interface::run_compiler_in_existing_thread_pool(config, |compiler| {\n@@ -376,7 +372,6 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n             let mut ctxt = DocContext {\n                 tcx,\n                 resolver,\n-                cstore: compiler.cstore().clone(),\n                 external_traits: Default::default(),\n                 active_extern_traits: Default::default(),\n                 renderinfo: RefCell::new(renderinfo),"}, {"sha": "bbc00147ee14eff21943d41dd838c0268c7df1cd", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -59,7 +59,7 @@ impl Module<'hir> {\n             fns        :   Vec::new(),\n             mods       :   Vec::new(),\n             typedefs   :   Vec::new(),\n-            opaque_tys :  Vec::new(),\n+            opaque_tys :   Vec::new(),\n             statics    :   Vec::new(),\n             constants  :   Vec::new(),\n             traits     :   Vec::new(),"}, {"sha": "414c3137376a95f2d45c1dc7c12090aa9508a2f1", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1241,6 +1241,7 @@ fn settings(root_path: &str, suffix: &str) -> String {\n         (\"go-to-only-result\", \"Directly go to item in search if there is only one result\",\n             false),\n         (\"line-numbers\", \"Show line numbers on code examples\", false),\n+        (\"disable-shortcuts\", \"Disable keyboard shortcuts\", false),\n     ];\n     format!(\n \"<h1 class='fqn'>\\"}, {"sha": "f0104c9156ded8b9ba93effd5bf223cf4c72acf8", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -79,6 +79,7 @@ function getSearchElement() {\n                      \"derive\",\n                      \"traitalias\"];\n \n+    var disableShortcuts = getCurrentValue(\"rustdoc-disable-shortcuts\") !== \"true\";\n     var search_input = getSearchInput();\n \n     // On the search screen, so you remain on the last tab you opened.\n@@ -294,7 +295,7 @@ function getSearchElement() {\n \n     function handleShortcut(ev) {\n         // Don't interfere with browser shortcuts\n-        if (ev.ctrlKey || ev.altKey || ev.metaKey) {\n+        if (ev.ctrlKey || ev.altKey || ev.metaKey || disableShortcuts === true) {\n             return;\n         }\n "}, {"sha": "caa7f08f68cffb3fb15840ab08108ab8ba229e7b", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -432,13 +432,13 @@ fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n     let path = ast::Path::from_ident(Ident::from_str(path_str));\n     cx.enter_resolver(|resolver| {\n         if let Ok((Some(ext), res)) = resolver.resolve_macro_path(\n-            &path, None, &ParentScope::module(resolver.graph_root), false, false\n+            &path, None, &ParentScope::module(resolver.graph_root()), false, false\n         ) {\n             if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n                 return Some(res.map_id(|_| panic!(\"unexpected id\")));\n             }\n         }\n-        if let Some(res) = resolver.all_macros.get(&Symbol::intern(path_str)) {\n+        if let Some(res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n             return Some(res.map_id(|_| panic!(\"unexpected id\")));\n         }\n         None"}, {"sha": "07dc1e4e9157a46e9dda972d5251093e6c656f7b", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -77,6 +77,7 @@ pub fn run(options: Options) -> i32 {\n         stderr: None,\n         crate_name: options.crate_name.clone(),\n         lint_caps: Default::default(),\n+        register_lints: None,\n     };\n \n     let mut test_args = options.test_args.clone();"}, {"sha": "c55911a33f5242cd7fa69a7b1d11bc39ff50a798", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -23,7 +23,7 @@ libc = { version = \"0.2.51\", default-features = false, features = ['rustc-dep-of\n compiler_builtins = { version = \"0.1.16\" }\n profiler_builtins = { path = \"../libprofiler_builtins\", optional = true }\n unwind = { path = \"../libunwind\" }\n-hashbrown = { version = \"0.6.1\", default-features = false, features = ['rustc-dep-of-std'] }\n+hashbrown = { version = \"0.6.2\", default-features = false, features = ['rustc-dep-of-std'] }\n \n [dependencies.backtrace_rs]\n package = \"backtrace\""}, {"sha": "d0cb0104f6cbad23d2058345d3397041a07b48e8", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -276,6 +276,7 @@\n #![feature(linkage)]\n #![feature(log_syntax)]\n #![feature(manually_drop_take)]\n+#![feature(matches_macro)]\n #![feature(maybe_uninit_ref)]\n #![feature(maybe_uninit_slice)]\n #![feature(needs_panic_runtime)]\n@@ -527,6 +528,7 @@ pub use core::{\n     writeln,\n     // Unstable\n     todo,\n+    matches,\n };\n \n // Re-export built-in macros defined through libcore."}, {"sha": "619b182019081fd8e3094e98d9b390b3d8371934", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -217,7 +217,7 @@ pub fn update_panic_count(amt: isize) -> usize {\n     PANIC_COUNT.with(|c| {\n         let next = (c.get() as isize + amt) as usize;\n         c.set(next);\n-        return next\n+        next\n     })\n }\n "}, {"sha": "be112f6fc032923f75b2069e5bcd741d8f109a05", "filename": "src/libstd/sys/unix/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frand.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -8,7 +8,7 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n                                              mem::size_of_val(&v));\n         imp::fill_bytes(view);\n     }\n-    return v\n+    v\n }\n \n #[cfg(all(unix,"}, {"sha": "6ce41420284e56c9d5ea8871b66b8f8a9072a018", "filename": "src/libstd/sys/wasi/thread.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2Fsys%2Fwasi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2Fsys%2Fwasi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fthread.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -31,18 +31,18 @@ impl Thread {\n         let nanos = dur.as_nanos();\n         assert!(nanos <= u64::max_value() as u128);\n \n-        const CLOCK_ID: wasi::Userdata = 0x0123_45678;\n+        const USERDATA: wasi::Userdata = 0x0123_45678;\n \n         let clock = wasi::raw::__wasi_subscription_u_clock_t {\n-            identifier: CLOCK_ID,\n+            identifier: 0,\n             clock_id: wasi::CLOCK_MONOTONIC,\n             timeout: nanos as u64,\n             precision: 0,\n             flags: 0,\n         };\n \n         let in_ = [wasi::Subscription {\n-            userdata: 0,\n+            userdata: USERDATA,\n             type_: wasi::EVENTTYPE_CLOCK,\n             u: wasi::raw::__wasi_subscription_u { clock: clock },\n         }];\n@@ -53,7 +53,7 @@ impl Thread {\n         };\n         match (res, event) {\n             (Ok(1), wasi::Event {\n-                userdata: CLOCK_ID,\n+                userdata: USERDATA,\n                 error: 0,\n                 type_: wasi::EVENTTYPE_CLOCK,\n                 .."}, {"sha": "3986cda1a50477e01839c4601c6877b394679f9a", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -46,7 +46,7 @@ impl Handle {\n     pub fn into_raw(self) -> c::HANDLE {\n         let ret = self.raw();\n         mem::forget(self);\n-        return ret;\n+        ret\n     }\n }\n "}, {"sha": "79dec1adf4bc8a9e194bd8acbbb1f85f1341f5db", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -144,7 +144,7 @@ fn kind() -> Kind {\n         Some(..) => Kind::SRWLock,\n     };\n     KIND.store(ret as usize, Ordering::SeqCst);\n-    return ret;\n+    ret\n }\n \n pub struct ReentrantMutex { inner: UnsafeCell<MaybeUninit<c::CRITICAL_SECTION>> }"}, {"sha": "096b7bea8a5f16bc8fc9f0eb8245f738d16b8127", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -257,7 +257,7 @@ impl Stdio {\n                         let ret = io.duplicate(0, true,\n                                                c::DUPLICATE_SAME_ACCESS);\n                         io.into_raw();\n-                        return ret\n+                        ret\n                     }\n                     Err(..) => Ok(Handle::new(c::INVALID_HANDLE_VALUE)),\n                 }\n@@ -472,9 +472,8 @@ fn make_command_line(prog: &OsStr, args: &[OsString]) -> io::Result<Vec<u16>> {\n             cmd.push('\"' as u16);\n         }\n \n-        let mut iter = arg.encode_wide();\n         let mut backslashes: usize = 0;\n-        while let Some(x) = iter.next() {\n+        for x in arg.encode_wide() {\n             if x == '\\\\' as u16 {\n                 backslashes += 1;\n             } else {"}, {"sha": "993831bec188698d85939205e5aa74a208323c62", "filename": "src/libstd/sys/windows/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2Fsys%2Fwindows%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2Fsys%2Fwindows%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Frand.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -13,7 +13,7 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n         panic!(\"couldn't generate random bytes: {}\",\n                io::Error::last_os_error());\n     }\n-    return v\n+    v\n }\n \n #[cfg(target_vendor = \"uwp\")]"}, {"sha": "728257cdd4bb14517efa588da53b2f5b189e8cbc", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -52,7 +52,7 @@ pub unsafe fn create(dtor: Option<Dtor>) -> Key {\n     if let Some(f) = dtor {\n         register_dtor(key, f);\n     }\n-    return key;\n+    key\n }\n \n #[inline]"}, {"sha": "bd533c93d434c5420cc494aa489413515e56ea53", "filename": "src/libstd/sys/windows/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -80,7 +80,7 @@ impl SystemTime {\n         unsafe {\n             let mut t: SystemTime = mem::zeroed();\n             c::GetSystemTimeAsFileTime(&mut t.t);\n-            return t\n+            t\n         }\n     }\n \n@@ -228,7 +228,7 @@ mod perf_counter {\n                 FREQUENCY = frequency;\n                 STATE.store(2, SeqCst);\n             }\n-            return frequency;\n+            frequency\n         }\n     }\n "}, {"sha": "cfaab4e22e9cf9a2d5d51b44139b3f31639f4ef4", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -509,9 +509,8 @@ pub mod os {\n         pub unsafe fn get(&'static self, init: fn() -> T) -> Option<&'static T> {\n             let ptr = self.os.get() as *mut Value<T>;\n             if ptr as usize > 1 {\n-                match (*ptr).inner.get() {\n-                    Some(ref value) => return Some(value),\n-                    None => {},\n+                if let Some(ref value) = (*ptr).inner.get() {\n+                    return Some(value);\n                 }\n             }\n             self.try_initialize(init)"}, {"sha": "51a62cd065843b2ff508444caf58224430874101", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1305,7 +1305,8 @@ impl MacroDef {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+// Clippy uses Hash and PartialEq\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, Hash, PartialEq)]\n pub enum StrStyle {\n     /// A regular string, like `\"foo\"`.\n     Cooked,\n@@ -1327,7 +1328,8 @@ pub struct Lit {\n     pub span: Span,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+// Clippy uses Hash and PartialEq\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, Hash, PartialEq)]\n pub enum LitIntType {\n     Signed(IntTy),\n     Unsigned(UintTy),\n@@ -1337,7 +1339,8 @@ pub enum LitIntType {\n /// Literal kind.\n ///\n /// E.g., `\"foo\"`, `42`, `12.34`, or `bool`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+// Clippy uses Hash and PartialEq\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Hash, PartialEq)]\n pub enum LitKind {\n     /// A string literal (`\"foo\"`).\n     Str(Symbol, StrStyle),"}, {"sha": "1386eac48dae2ca09b527a184b5c0a82ef5ce325", "filename": "src/libsyntax/feature_gate/active.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibsyntax%2Ffeature_gate%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibsyntax%2Ffeature_gate%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Factive.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -528,6 +528,9 @@ declare_features! (\n     /// Enable accurate caller location reporting during panic (RFC 2091).\n     (active, track_caller, \"1.40.0\", Some(47809), None),\n \n+    /// Non-object safe trait objects safe to use but cannot be created in safe rust\n+    (active, object_safe_for_dispatch, \"1.40.0\", Some(43561), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "2ce0046ca276c1ab4286754afc9385e8b571538b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -86,13 +86,6 @@ macro_rules! maybe_recover_from_interpolated_ty_qpath {\n     }\n }\n \n-fn maybe_append(mut lhs: Vec<Attribute>, mut rhs: Option<Vec<Attribute>>) -> Vec<Attribute> {\n-    if let Some(ref mut rhs) = rhs {\n-        lhs.append(rhs);\n-    }\n-    lhs\n-}\n-\n #[derive(Debug, Clone, Copy, PartialEq)]\n enum PrevTokenKind {\n     DocComment,"}, {"sha": "73bd80e2a21f7b9e5a4fccbcd3ac13da53176a07", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -10,7 +10,6 @@ use crate::ast::{Visibility, VisibilityKind, Mutability, FnHeader, ForeignItem,\n use crate::ast::{Ty, TyKind, Generics, GenericBounds, TraitRef, EnumDef, VariantData, StructField};\n use crate::ast::{Mac, MacDelimiter, Block, BindingMode, FnDecl, MethodSig, SelfKind, Param};\n use crate::parse::token;\n-use crate::parse::parser::maybe_append;\n use crate::tokenstream::{TokenTree, TokenStream};\n use crate::symbol::{kw, sym};\n use crate::source_map::{self, respan, Span};\n@@ -416,10 +415,17 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, Option<P<Item>>> {\n         let (ident, item, extra_attrs) = info;\n         let span = lo.to(self.prev_span);\n-        let attrs = maybe_append(attrs, extra_attrs);\n+        let attrs = Self::maybe_append(attrs, extra_attrs);\n         Ok(Some(self.mk_item(span, ident, item, vis, attrs)))\n     }\n \n+    fn maybe_append<T>(mut lhs: Vec<T>, mut rhs: Option<Vec<T>>) -> Vec<T> {\n+        if let Some(ref mut rhs) = rhs {\n+            lhs.append(rhs);\n+        }\n+        lhs\n+    }\n+\n     /// This is the fall-through for parsing items.\n     fn parse_macro_use_or_failure(\n         &mut self,"}, {"sha": "0559f224f1f4bf30306767ed59a1ce161e9e3016", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -19,7 +19,6 @@ use syntax_pos::{BytePos, Span, DUMMY_SP};\n #[cfg(target_arch = \"x86_64\")]\n use rustc_data_structures::static_assert_size;\n use rustc_data_structures::sync::Lrc;\n-use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use smallvec::{SmallVec, smallvec};\n \n use std::{iter, mem};\n@@ -136,7 +135,7 @@ impl TokenTree {\n /// The goal is for procedural macros to work with `TokenStream`s and `TokenTree`s\n /// instead of a representation of the abstract syntax tree.\n /// Today's `TokenTree`s can still contain AST via `token::Interpolated` for back-compat.\n-#[derive(Clone, Debug, Default)]\n+#[derive(Clone, Debug, Default, RustcEncodable, RustcDecodable)]\n pub struct TokenStream(pub Lrc<Vec<TreeAndJoint>>);\n \n pub type TreeAndJoint = (TokenTree, IsJoint);\n@@ -145,7 +144,7 @@ pub type TreeAndJoint = (TokenTree, IsJoint);\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(TokenStream, 8);\n \n-#[derive(Clone, Copy, Debug, PartialEq)]\n+#[derive(Clone, Copy, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum IsJoint {\n     Joint,\n     NonJoint\n@@ -460,18 +459,6 @@ impl Cursor {\n     }\n }\n \n-impl Encodable for TokenStream {\n-    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), E::Error> {\n-        self.trees().collect::<Vec<_>>().encode(encoder)\n-    }\n-}\n-\n-impl Decodable for TokenStream {\n-    fn decode<D: Decoder>(decoder: &mut D) -> Result<TokenStream, D::Error> {\n-        Vec::<TokenTree>::decode(decoder).map(|vec| vec.into_iter().collect())\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub struct DelimSpan {\n     pub open: Span,"}, {"sha": "37310f46f7eed7c4a93fca9b99306fd0ab610593", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -278,7 +278,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// format string.\n     fn report_invalid_references(&self, numbered_position_args: bool) {\n         let mut e;\n-        let sp = if self.is_literal {\n+        let sp = if self.is_literal { // Point at the formatting arguments.\n             MultiSpan::from_spans(self.arg_spans.clone())\n         } else {\n             MultiSpan::from_span(self.fmtsp)\n@@ -304,6 +304,9 @@ impl<'a, 'b> Context<'a, 'b> {\n                     self.describe_num_args(),\n                 ),\n             );\n+            for arg in &self.args { // Point at the arguments that will be formatted.\n+                e.span_label(arg.span, \"\");\n+            }\n         } else {\n             let (mut refs, spans): (Vec<_>, Vec<_>) = refs.unzip();\n             // Avoid `invalid reference to positional arguments 7 and 7 (there is 1 argument)`"}, {"sha": "377d2f877b3ad7cc2ec95adcaa22e598bd65e6c1", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 6, "deletions": 115, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -9,7 +9,7 @@ use rustc_macros::symbols;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_serialize::{UseSpecializedDecodable, UseSpecializedEncodable};\n \n-use std::cmp::{PartialEq, Ordering, PartialOrd, Ord};\n+use std::cmp::{PartialEq, PartialOrd, Ord};\n use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::str;\n@@ -459,6 +459,7 @@ symbols! {\n         no_std,\n         not,\n         note,\n+        object_safe_for_dispatch,\n         Ok,\n         omit_gdb_pretty_printer_section,\n         on,\n@@ -766,11 +767,6 @@ impl Ident {\n         Ident::with_dummy_span(kw::Invalid)\n     }\n \n-    /// Maps an interned string to an identifier with an empty syntax context.\n-    pub fn from_interned_str(string: InternedString) -> Ident {\n-        Ident::with_dummy_span(string.as_symbol())\n-    }\n-\n     /// Maps a string to an identifier with a dummy span.\n     pub fn from_str(string: &str) -> Ident {\n         Ident::with_dummy_span(Symbol::intern(string))\n@@ -813,11 +809,6 @@ impl Ident {\n     pub fn as_str(self) -> LocalInternedString {\n         self.name.as_str()\n     }\n-\n-    /// Convert the name to an `InternedString`.\n-    pub fn as_interned_str(self) -> InternedString {\n-        self.name.as_interned_str()\n-    }\n }\n \n impl PartialEq for Ident {\n@@ -903,15 +894,6 @@ impl Symbol {\n         })\n     }\n \n-    /// Access two symbols' chars. This is a slowish operation because it\n-    /// requires locking the symbol interner, but it is faster than calling\n-    /// `with()` twice.\n-    fn with2<F: FnOnce(&str, &str) -> R, R>(self, other: Symbol, f: F) -> R {\n-        with_interner(|interner| {\n-            f(interner.get(self), interner.get(other))\n-        })\n-    }\n-\n     /// Convert to a `LocalInternedString`. This is a slowish operation because\n     /// it requires locking the symbol interner.\n     pub fn as_str(self) -> LocalInternedString {\n@@ -922,11 +904,6 @@ impl Symbol {\n         })\n     }\n \n-    /// Convert to an `InternedString`.\n-    pub fn as_interned_str(self) -> InternedString {\n-        InternedString { symbol: self }\n-    }\n-\n     pub fn as_u32(self) -> u32 {\n         self.0.as_u32()\n     }\n@@ -1105,9 +1082,9 @@ fn with_interner<T, F: FnOnce(&mut Interner) -> T>(f: F) -> T {\n     GLOBALS.with(|globals| f(&mut *globals.symbol_interner.lock()))\n }\n \n-/// An alternative to `Symbol` and `InternedString`, useful when the chars\n-/// within the symbol need to be accessed. It deliberately has limited\n-/// functionality and should only be used for temporary values.\n+/// An alternative to `Symbol`, useful when the chars within the symbol need to\n+/// be accessed. It deliberately has limited functionality and should only be\n+/// used for temporary values.\n ///\n /// Because the interner outlives any thread which uses this type, we can\n /// safely treat `string` which points to interner data, as an immortal string,\n@@ -1116,7 +1093,7 @@ fn with_interner<T, F: FnOnce(&mut Interner) -> T>(f: F) -> T {\n // FIXME: ensure that the interner outlives any thread which uses\n // `LocalInternedString`, by creating a new thread right after constructing the\n // interner.\n-#[derive(Eq, PartialOrd, Ord)]\n+#[derive(Clone, Eq, PartialOrd, Ord)]\n pub struct LocalInternedString {\n     string: &'static str,\n }\n@@ -1157,89 +1134,3 @@ impl fmt::Display for LocalInternedString {\n         fmt::Display::fmt(self.string, f)\n     }\n }\n-\n-/// An alternative to `Symbol` that is focused on string contents.\n-///\n-/// Its implementations of `Hash`, `PartialOrd` and `Ord` work with the\n-/// string chars rather than the symbol integer. This is useful when hash\n-/// stability is required across compile sessions, or a guaranteed sort\n-/// ordering is required.\n-#[derive(Clone, Copy, PartialEq, Eq)]\n-pub struct InternedString {\n-    symbol: Symbol,\n-}\n-\n-impl InternedString {\n-    /// Maps a string to its interned representation.\n-    pub fn intern(string: &str) -> Self {\n-        InternedString {\n-            symbol: Symbol::intern(string)\n-        }\n-    }\n-\n-    pub fn with<F: FnOnce(&str) -> R, R>(self, f: F) -> R {\n-        self.symbol.with(f)\n-    }\n-\n-    fn with2<F: FnOnce(&str, &str) -> R, R>(self, other: &InternedString, f: F) -> R {\n-        self.symbol.with2(other.symbol, f)\n-    }\n-\n-    pub fn as_symbol(self) -> Symbol {\n-        self.symbol\n-    }\n-\n-    /// Convert to a `LocalInternedString`. This is a slowish operation because it\n-    /// requires locking the symbol interner.\n-    pub fn as_str(self) -> LocalInternedString {\n-        self.symbol.as_str()\n-    }\n-}\n-\n-impl Hash for InternedString {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.with(|str| str.hash(state))\n-    }\n-}\n-\n-impl PartialOrd<InternedString> for InternedString {\n-    fn partial_cmp(&self, other: &InternedString) -> Option<Ordering> {\n-        if self.symbol == other.symbol {\n-            return Some(Ordering::Equal);\n-        }\n-        self.with2(other, |self_str, other_str| self_str.partial_cmp(other_str))\n-    }\n-}\n-\n-impl Ord for InternedString {\n-    fn cmp(&self, other: &InternedString) -> Ordering {\n-        if self.symbol == other.symbol {\n-            return Ordering::Equal;\n-        }\n-        self.with2(other, |self_str, other_str| self_str.cmp(other_str))\n-    }\n-}\n-\n-impl fmt::Debug for InternedString {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.with(|str| fmt::Debug::fmt(&str, f))\n-    }\n-}\n-\n-impl fmt::Display for InternedString {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.with(|str| fmt::Display::fmt(&str, f))\n-    }\n-}\n-\n-impl Decodable for InternedString {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<InternedString, D::Error> {\n-        Ok(InternedString::intern(&d.read_str()?))\n-    }\n-}\n-\n-impl Encodable for InternedString {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        self.with(|string| s.emit_str(string))\n-    }\n-}"}, {"sha": "c86bfd16c21b185dc4250fe56315fecbdbd844ec", "filename": "src/libtest/bench.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibtest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibtest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fbench.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -48,7 +48,7 @@ impl Bencher {\n         F: FnMut(&mut Bencher),\n     {\n         f(self);\n-        return self.summary;\n+        self.summary\n     }\n }\n \n@@ -116,7 +116,7 @@ where\n     for _ in 0..k {\n         black_box(inner());\n     }\n-    return ns_from_dur(start.elapsed());\n+    ns_from_dur(start.elapsed())\n }\n \n pub fn iter<T, F>(inner: &mut F) -> stats::Summary"}, {"sha": "a34426305be2e82a87ac6d209b973f78a86bff1d", "filename": "src/libtest/cli.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibtest%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibtest%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fcli.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -149,7 +149,7 @@ fn optgroups() -> getopts::Options {\n             `CRITICAL_TIME` here means the limit that should not be exceeded by test.\n             \"\n         );\n-    return opts;\n+    opts\n }\n \n fn usage(binary: &str, options: &getopts::Options) {"}, {"sha": "244cbd2cf5fe807b702c836d44e022f881800914", "filename": "src/libtest/console.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibtest%2Fconsole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibtest%2Fconsole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fconsole.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -296,7 +296,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n \n     assert!(st.current_test_count() == st.total);\n \n-    return out.write_run_finish(&st);\n+    out.write_run_finish(&st)\n }\n \n // Calculates padding for given test description."}, {"sha": "8c1e9f1722a267a990625330973473f9bb61a153", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -34,8 +34,10 @@\n pub use self::ColorConfig::*;\n pub use self::types::*;\n pub use self::types::TestName::*;\n-pub use self::options::{Options, ShouldPanic};\n+pub use self::options::{ColorConfig, Options, OutputFormat, RunIgnored, ShouldPanic};\n pub use self::bench::{Bencher, black_box};\n+pub use self::console::run_tests_console;\n+pub use cli::TestOpts;\n \n // Module to be used by rustc to compile tests in libtest\n pub mod test {\n@@ -84,9 +86,8 @@ mod tests;\n \n use test_result::*;\n use time::TestExecTime;\n-use options::{RunStrategy, Concurrent, RunIgnored, ColorConfig};\n+use options::{RunStrategy, Concurrent};\n use event::{CompletedTest, TestEvent};\n-use cli::TestOpts;\n use helpers::sink::Sink;\n use helpers::concurrency::get_concurrency;\n use helpers::exit_code::get_exit_code;"}, {"sha": "eb96c61060b391d1baa4597258aa3bd75161a9d0", "filename": "src/test/run-make-fulldeps/hotplug_codegen_backend/the_backend.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -9,14 +9,14 @@ extern crate rustc_target;\n extern crate rustc_driver;\n \n use std::any::Any;\n-use std::sync::{Arc, mpsc};\n+use std::sync::Arc;\n use std::path::Path;\n use syntax::symbol::Symbol;\n use rustc::session::Session;\n use rustc::session::config::OutputFilenames;\n use rustc::ty::TyCtxt;\n use rustc::ty::query::Providers;\n-use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n+use rustc::middle::cstore::{EncodedMetadata, MetadataLoader, MetadataLoaderDyn};\n use rustc::dep_graph::DepGraph;\n use rustc::util::common::ErrorReported;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n@@ -41,7 +41,7 @@ impl MetadataLoader for NoLlvmMetadataLoader {\n struct TheBackend;\n \n impl CodegenBackend for TheBackend {\n-    fn metadata_loader(&self) -> Box<dyn MetadataLoader + Sync> {\n+    fn metadata_loader(&self) -> Box<MetadataLoaderDyn> {\n         Box::new(NoLlvmMetadataLoader)\n     }\n "}, {"sha": "9582137eae91c0c4e71ae73011598f66494a2abf", "filename": "src/test/run-make-fulldeps/issue-19371/foo.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -59,6 +59,7 @@ fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n         stderr: None,\n         crate_name: None,\n         lint_caps: Default::default(),\n+        register_lints: None,\n     };\n \n     interface::run_compiler(config, |compiler| {"}, {"sha": "2d506787b3b8038a6269bc2a6a92157ec67a8321", "filename": "src/test/rustdoc/const-generics/const-impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-impl.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -4,6 +4,7 @@\n \n #![crate_name = \"foo\"]\n \n+#[derive(PartialEq, Eq)]\n pub enum Order {\n     Sorted,\n     Unsorted,"}, {"sha": "6b914f501ca79a735456b635a5beabad7a3267a4", "filename": "src/test/ui-fulldeps/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -15,15 +15,14 @@ use syntax::symbol::Symbol;\n \n use rustc::hir;\n use rustc::hir::intravisit;\n-use rustc::hir::map as hir_map;\n use hir::Node;\n use rustc::lint::{LateContext, LintPass, LintArray, LateLintPass, LintContext};\n-use rustc::ty;\n-use syntax::{ast, source_map};\n+use syntax::source_map;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_late_lint_pass(box MissingWhitelistedAttrPass);\n+    reg.lint_store.register_lints(&[&MISSING_WHITELISTED_ATTR]);\n+    reg.lint_store.register_late_pass(|| box MissingWhitelistedAttrPass);\n     reg.register_attribute(Symbol::intern(\"whitelisted_attr\"), Whitelisted);\n }\n "}, {"sha": "6874c921c1cc1c26fadcfd8ee90ecfb243b6dcde", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate-rpass.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -7,24 +7,20 @@\n extern crate rustc_driver;\n extern crate syntax;\n \n-use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPassObject, LintArray};\n+use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass};\n use rustc_driver::plugin::Registry;\n use rustc::hir;\n use syntax::attr;\n use syntax::symbol::Symbol;\n \n macro_rules! fake_lint_pass {\n-    ($struct:ident, $lints:expr, $($attr:expr),*) => {\n+    ($struct:ident, $($attr:expr),*) => {\n         struct $struct;\n \n         impl LintPass for $struct {\n             fn name(&self) -> &'static str {\n                 stringify!($struct)\n             }\n-\n-            fn get_lints(&self) -> LintArray {\n-                $lints\n-            }\n         }\n \n         impl<'a, 'tcx> LateLintPass<'a, 'tcx> for $struct {\n@@ -49,25 +45,29 @@ declare_lint!(CRATE_NOT_GREEN, Warn, \"crate not marked with #![crate_green]\");\n \n fake_lint_pass! {\n     PassOkay,\n-    lint_array!(CRATE_NOT_OKAY), // Single lint\n     Symbol::intern(\"rustc_crate_okay\")\n }\n \n fake_lint_pass! {\n     PassRedBlue,\n-    lint_array!(CRATE_NOT_RED, CRATE_NOT_BLUE), // Multiple lints\n     Symbol::intern(\"rustc_crate_red\"), Symbol::intern(\"rustc_crate_blue\")\n }\n \n fake_lint_pass! {\n     PassGreyGreen,\n-    lint_array!(CRATE_NOT_GREY, CRATE_NOT_GREEN, ), // Trailing comma\n     Symbol::intern(\"rustc_crate_grey\"), Symbol::intern(\"rustc_crate_green\")\n }\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_late_lint_pass(box PassOkay);\n-    reg.register_late_lint_pass(box PassRedBlue);\n-    reg.register_late_lint_pass(box PassGreyGreen);\n+    reg.lint_store.register_lints(&[\n+        &CRATE_NOT_OKAY,\n+        &CRATE_NOT_RED,\n+        &CRATE_NOT_BLUE,\n+        &CRATE_NOT_GREY,\n+        &CRATE_NOT_GREEN,\n+    ]);\n+    reg.lint_store.register_late_pass(|| box PassOkay);\n+    reg.lint_store.register_late_pass(|| box PassRedBlue);\n+    reg.lint_store.register_late_pass(|| box PassGreyGreen);\n }"}, {"sha": "1cd3e7b28dba7bd3d48578e9cf91ecc278935a52", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -7,7 +7,7 @@\n extern crate rustc_driver;\n extern crate syntax;\n \n-use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPassObject, LintArray};\n+use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LintArray};\n use rustc_driver::plugin::Registry;\n use rustc::hir;\n use syntax::attr;\n@@ -32,5 +32,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_late_lint_pass(box Pass);\n+    reg.lint_store.register_lints(&[&CRATE_NOT_OKAY]);\n+    reg.lint_store.register_late_pass(|| box Pass);\n }"}, {"sha": "cb793b43498859aa9008832352a9d929dbc324f4", "filename": "src/test/ui-fulldeps/auxiliary/lint-group-plugin-test.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -9,7 +9,7 @@ extern crate rustc;\n extern crate rustc_driver;\n \n use rustc::hir;\n-use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPassObject, LintArray};\n+use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LintArray, LintId};\n use rustc_driver::plugin::Registry;\n \n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");\n@@ -30,6 +30,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_late_lint_pass(box Pass);\n-    reg.register_lint_group(\"lint_me\", None, vec![TEST_LINT, PLEASE_LINT]);\n+    reg.lint_store.register_lints(&[&TEST_LINT, &PLEASE_LINT]);\n+    reg.lint_store.register_late_pass(|| box Pass);\n+    reg.lint_store.register_group(true, \"lint_me\", None,\n+        vec![LintId::of(&TEST_LINT), LintId::of(&PLEASE_LINT)]);\n }"}, {"sha": "40c37eb570e2d6435f20856b9a10a2b56345db19", "filename": "src/test/ui-fulldeps/auxiliary/lint-plugin-test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -10,8 +10,7 @@ extern crate syntax;\n extern crate rustc;\n extern crate rustc_driver;\n \n-use rustc::lint::{EarlyContext, LintContext, LintPass, EarlyLintPass,\n-                  EarlyLintPassObject, LintArray};\n+use rustc::lint::{EarlyContext, LintContext, LintPass, EarlyLintPass, LintArray};\n use rustc_driver::plugin::Registry;\n use syntax::ast;\n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");\n@@ -28,5 +27,6 @@ impl EarlyLintPass for Pass {\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_early_lint_pass(box Pass as EarlyLintPassObject);\n+    reg.lint_store.register_lints(&[&TEST_LINT]);\n+    reg.lint_store.register_early_pass(|| box Pass);\n }"}, {"sha": "67135d595f448a53ed1e1a6c777216ad8ce7787c", "filename": "src/test/ui-fulldeps/auxiliary/lint-tool-test.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -8,7 +8,7 @@ extern crate syntax;\n extern crate rustc;\n extern crate rustc_driver;\n \n-use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass};\n+use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass, LintId};\n use rustc_driver::plugin::Registry;\n use syntax::ast;\n declare_tool_lint!(pub clippy::TEST_LINT, Warn, \"Warn about stuff\");\n@@ -40,6 +40,8 @@ impl EarlyLintPass for Pass {\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_early_lint_pass(box Pass);\n-    reg.register_lint_group(\"clippy::group\", Some(\"clippy_group\"), vec![TEST_LINT, TEST_GROUP]);\n+    reg.lint_store.register_lints(&[&TEST_RUSTC_TOOL_LINT, &TEST_LINT, &TEST_GROUP]);\n+    reg.lint_store.register_early_pass(|| box Pass);\n+    reg.lint_store.register_group(true, \"clippy::group\", Some(\"clippy_group\"),\n+        vec![LintId::of(&TEST_LINT), LintId::of(&TEST_GROUP)]);\n }"}, {"sha": "0bfb32c6dc43b812d551f3d1a51e3126ce1b7feb", "filename": "src/test/ui-fulldeps/internal-lints/lint_pass_impl_without_macro.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Flint_pass_impl_without_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Flint_pass_impl_without_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Flint_pass_impl_without_macro.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -6,7 +6,7 @@\n extern crate rustc;\n \n use rustc::lint::{LintArray, LintPass};\n-use rustc::{declare_lint, declare_lint_pass, impl_lint_pass, lint_array};\n+use rustc::{declare_lint, declare_lint_pass, impl_lint_pass};\n \n declare_lint! {\n     pub TEST_LINT,\n@@ -17,10 +17,6 @@ declare_lint! {\n struct Foo;\n \n impl LintPass for Foo { //~ERROR implementing `LintPass` by hand\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(TEST_LINT)\n-    }\n-\n     fn name(&self) -> &'static str {\n         \"Foo\"\n     }\n@@ -31,10 +27,6 @@ macro_rules! custom_lint_pass_macro {\n         struct Custom;\n \n         impl LintPass for Custom { //~ERROR implementing `LintPass` by hand\n-            fn get_lints(&self) -> LintArray {\n-                lint_array!(TEST_LINT)\n-            }\n-\n             fn name(&self) -> &'static str {\n                 \"Custom\"\n             }"}, {"sha": "0dbdf4f5aa9e21abac0d0ce2475aa524474f27dd", "filename": "src/test/ui-fulldeps/internal-lints/lint_pass_impl_without_macro.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Flint_pass_impl_without_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Flint_pass_impl_without_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Flint_pass_impl_without_macro.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -12,7 +12,7 @@ LL | #![deny(rustc::lint_pass_impl_without_macro)]\n    = help: try using `declare_lint_pass!` or `impl_lint_pass!` instead\n \n error: implementing `LintPass` by hand\n-  --> $DIR/lint_pass_impl_without_macro.rs:33:14\n+  --> $DIR/lint_pass_impl_without_macro.rs:29:14\n    |\n LL |         impl LintPass for Custom {\n    |              ^^^^^^^^"}, {"sha": "d29c31fafc2868232b9ced4cd2d913992e4dba06", "filename": "src/test/ui/asm/issue-51431.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fasm%2Fissue-51431.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fasm%2Fissue-51431.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fissue-51431.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,10 @@\n+// ignore-emscripten no asm! support\n+\n+#![feature(asm)]\n+\n+fn main() {\n+    unsafe {\n+        asm! {\"mov $0,$1\"::\"0\"(\"bx\"),\"1\"(0x00)}\n+        //~^ ERROR: invalid value for constraint in inline assembly\n+    }\n+}"}, {"sha": "132eea126d64250c074ef332cfa66b44e3512d6c", "filename": "src/test/ui/asm/issue-51431.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fasm%2Fissue-51431.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fasm%2Fissue-51431.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fissue-51431.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,8 @@\n+error[E0669]: invalid value for constraint in inline assembly\n+  --> $DIR/issue-51431.rs:7:32\n+   |\n+LL |         asm! {\"mov $0,$1\"::\"0\"(\"bx\"),\"1\"(0x00)}\n+   |                                ^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "311c48b5e48c5ef500347d7162574a1c58263e0b", "filename": "src/test/ui/associated-const/issue-63496.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fassociated-const%2Fissue-63496.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fassociated-const%2Fissue-63496.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-const%2Fissue-63496.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,9 @@\n+trait A {\n+    const C: usize;\n+\n+    fn f() -> ([u8; A::C], [u8; A::C]);\n+    //~^ ERROR: type annotations needed: cannot resolve\n+    //~| ERROR: type annotations needed: cannot resolve\n+}\n+\n+fn main() {}"}, {"sha": "70bb12de1fb723a2487212ce5b6a24aed7d9a27d", "filename": "src/test/ui/associated-const/issue-63496.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fassociated-const%2Fissue-63496.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fassociated-const%2Fissue-63496.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-const%2Fissue-63496.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,21 @@\n+error[E0283]: type annotations needed: cannot resolve `_: A`\n+  --> $DIR/issue-63496.rs:4:21\n+   |\n+LL |     const C: usize;\n+   |     --------------- required by `A::C`\n+LL | \n+LL |     fn f() -> ([u8; A::C], [u8; A::C]);\n+   |                     ^^^^\n+\n+error[E0283]: type annotations needed: cannot resolve `_: A`\n+  --> $DIR/issue-63496.rs:4:33\n+   |\n+LL |     const C: usize;\n+   |     --------------- required by `A::C`\n+LL | \n+LL |     fn f() -> ([u8; A::C], [u8; A::C]);\n+   |                                 ^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0283`."}, {"sha": "64c9f69311582cfd8dfe7e59a2968f62f880d90d", "filename": "src/test/ui/ast-json/ast-json-output.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1 +1 @@\n-{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"items\":[{\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"attrs\":[],\"id\":0,\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"span\":{\"lo\":0,\"hi\":0},\"tokens\":[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"extern\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"core\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Semi\",\"span\":{\"lo\":0,\"hi\":0}}]}]}],\"inline\":true},\"attrs\":[],\"span\":{\"lo\":0,\"hi\":0}}\n+{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"items\":[{\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"attrs\":[],\"id\":0,\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"span\":{\"lo\":0,\"hi\":0},\"tokens\":{\"_field0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"extern\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"core\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Semi\",\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"]]}}],\"inline\":true},\"attrs\":[],\"span\":{\"lo\":0,\"hi\":0}}"}, {"sha": "4b5e2d59e38c999e6c89eed59fddcd429b92e13e", "filename": "src/test/ui/async-await/await-keyword/incorrect-syntax-suggestions.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -244,4 +244,5 @@ LL |     let _ = await bar()?;\n \n error: aborting due to 35 previous errors\n \n-For more information about this error, try `rustc --explain E0277`.\n+Some errors have detailed explanations: E0277, E0728.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "5b9adb253d968450ede33800bd85b3b46da05510", "filename": "src/test/ui/async-await/issues/issue-51719.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51719.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51719.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51719.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -8,3 +8,4 @@ LL |     let _gen = || foo().await;\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0728`."}, {"sha": "f120bd119c540296f25ba3ae4fb1878d34567d62", "filename": "src/test/ui/async-await/issues/issue-51751.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51751.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51751.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51751.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -9,3 +9,4 @@ LL |     let finished = result.await;\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0728`."}, {"sha": "538430290d299ba4c9681ff5ec7d25bffa4b81e8", "filename": "src/test/ui/async-await/issues/issue-62009-1.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-1.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -40,4 +40,5 @@ LL |     F: Future\n \n error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0277`.\n+Some errors have detailed explanations: E0277, E0728.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "47b74b5574fea57e240acefd77849261fbf64adf", "filename": "src/test/ui/async-await/issues/issue-62009-2.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-2.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -8,3 +8,4 @@ LL |     (async || 2333)().await;\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0728`."}, {"sha": "f826a86f089853d4ea27609aae7a8254efd2ecc0", "filename": "src/test/ui/async-await/issues/non-async-enclosing-span.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fnon-async-enclosing-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fnon-async-enclosing-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fnon-async-enclosing-span.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -9,3 +9,4 @@ LL |     let y = do_the_thing().await;\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0728`."}, {"sha": "a6f9d0423d082e201104f3b71a0eca98078ce22e", "filename": "src/test/ui/break-outside-loop.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fbreak-outside-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fbreak-outside-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbreak-outside-loop.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -22,4 +22,12 @@ fn main() {\n     let rs: Foo = Foo{t: pth};\n \n     let unconstrained = break; //~ ERROR: `break` outside of a loop\n+\n+    // This used to ICE because `target_id` passed to `check_expr_break` would be the closure and\n+    // not the `loop`, which failed in the call to `find_breakable`. (#65383)\n+    'lab: loop {\n+        || {\n+            break 'lab; //~ ERROR `break` inside of a closure\n+        };\n+    }\n }"}, {"sha": "8e300fd848dab3d9357e896f1e4aa69746614cc0", "filename": "src/test/ui/break-outside-loop.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fbreak-outside-loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fbreak-outside-loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbreak-outside-loop.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -33,7 +33,15 @@ error[E0268]: `break` outside of a loop\n LL |     let unconstrained = break;\n    |                         ^^^^^ cannot `break` outside of a loop\n \n-error: aborting due to 5 previous errors\n+error[E0267]: `break` inside of a closure\n+  --> $DIR/break-outside-loop.rs:30:13\n+   |\n+LL |         || {\n+   |         -- enclosing closure\n+LL |             break 'lab;\n+   |             ^^^^^^^^^^ cannot `break` inside of a closure\n+\n+error: aborting due to 6 previous errors\n \n Some errors have detailed explanations: E0267, E0268.\n For more information about an error, try `rustc --explain E0267`."}, {"sha": "5cae0e76d1acbcfa263754ace0d2fc65729b411e", "filename": "src/test/ui/closures/issue-41366.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,13 @@\n+trait T<'x> {\n+    type V;\n+}\n+\n+impl<'g> T<'g> for u32 {\n+    type V = u16;\n+}\n+\n+fn main() {\n+    (&|_|()) as &dyn for<'x> Fn(<u32 as T<'x>>::V);\n+    //~^ ERROR: type mismatch in closure arguments\n+    //~| ERROR: type mismatch resolving\n+}"}, {"sha": "91d26efbc4f35309af98332c449cfc6d7348bed1", "filename": "src/test/ui/closures/issue-41366.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,22 @@\n+error[E0631]: type mismatch in closure arguments\n+  --> $DIR/issue-41366.rs:10:5\n+   |\n+LL |     (&|_|()) as &dyn for<'x> Fn(<u32 as T<'x>>::V);\n+   |     ^^-----^\n+   |     | |\n+   |     | found signature of `fn(_) -> _`\n+   |     expected signature of `for<'x> fn(<u32 as T<'x>>::V) -> _`\n+   |\n+   = note: required for the cast to the object type `dyn for<'x> std::ops::Fn(<u32 as T<'x>>::V)`\n+\n+error[E0271]: type mismatch resolving `for<'x> <[closure@$DIR/issue-41366.rs:10:7: 10:12] as std::ops::FnOnce<(<u32 as T<'x>>::V,)>>::Output == ()`\n+  --> $DIR/issue-41366.rs:10:5\n+   |\n+LL |     (&|_|()) as &dyn for<'x> Fn(<u32 as T<'x>>::V);\n+   |     ^^^^^^^^ expected bound lifetime parameter 'x, found concrete lifetime\n+   |\n+   = note: required for the cast to the object type `dyn for<'x> std::ops::Fn(<u32 as T<'x>>::V)`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "6ac5380a5aa23b0dcd7161a40741f9c639b29902", "filename": "src/test/ui/closures/issue-52437.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    [(); &(&'static: loop { |x| {}; }) as *const _ as usize]\n+    //~^ ERROR: invalid label name `'static`\n+    //~| ERROR: type annotations needed\n+}"}, {"sha": "e76f942e9ba575d0e865f418a4cbfaedc16985d2", "filename": "src/test/ui/closures/issue-52437.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,15 @@\n+error: invalid label name `'static`\n+  --> $DIR/issue-52437.rs:2:13\n+   |\n+LL |     [(); &(&'static: loop { |x| {}; }) as *const _ as usize]\n+   |             ^^^^^^^\n+\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-52437.rs:2:30\n+   |\n+LL |     [(); &(&'static: loop { |x| {}; }) as *const _ as usize]\n+   |                              ^ consider giving this closure parameter a type\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "9859a226efd0074b24491988e808cc48d8c46916", "filename": "src/test/ui/coherence/coherence-unsafe-trait-object-impl.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-unsafe-trait-object-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-unsafe-trait-object-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-unsafe-trait-object-impl.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,18 @@\n+// Check that unsafe trait object do not implement themselves\n+// automatically\n+\n+#![feature(object_safe_for_dispatch)]\n+\n+trait Trait: Sized {\n+    fn call(&self);\n+}\n+\n+fn takes_t<S: Trait>(s: S) {\n+    s.call();\n+}\n+\n+fn takes_t_obj(t: &dyn Trait) {\n+    takes_t(t); //~ ERROR E0277\n+}\n+\n+fn main() {}"}, {"sha": "b5a86acfb978f2e1a6e596b321aeba797032c9c0", "filename": "src/test/ui/coherence/coherence-unsafe-trait-object-impl.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-unsafe-trait-object-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-unsafe-trait-object-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-unsafe-trait-object-impl.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,12 @@\n+error[E0277]: the trait bound `&dyn Trait: Trait` is not satisfied\n+  --> $DIR/coherence-unsafe-trait-object-impl.rs:15:13\n+   |\n+LL | fn takes_t<S: Trait>(s: S) {\n+   |    -------    ----- required by this bound in `takes_t`\n+...\n+LL |     takes_t(t);\n+   |             ^ the trait `Trait` is not implemented for `&dyn Trait`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "de0b66a35eb01151a0d6fac92c6b8f7a8d36f296", "filename": "src/test/ui/coherence/impl-foreign-for-foreign.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-foreign.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,17 @@\n+#![feature(re_rebalance_coherence)]\n+\n+// compile-flags:--crate-name=test\n+// aux-build:coherence_lib.rs\n+\n+extern crate coherence_lib as lib;\n+use lib::*;\n+use std::rc::Rc;\n+\n+struct Local;\n+\n+impl Remote for i32 {\n+    //~^ ERROR only traits defined in the current crate\n+    // | can be implemented for arbitrary types [E0117]\n+}\n+\n+fn main() {}"}, {"sha": "b03a75a77c3460708d2beb5644071ec48ba22632", "filename": "src/test/ui/coherence/impl-foreign-for-foreign.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-foreign.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-foreign.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-foreign.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,12 @@\n+error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n+  --> $DIR/impl-foreign-for-foreign.rs:12:1\n+   |\n+LL | impl Remote for i32 {\n+   | ^^^^^^^^^^^^^^^^^^^ impl doesn't use types inside crate\n+   |\n+   = note: the impl does not reference only types defined in this crate\n+   = note: define and implement a trait or new type instead\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0117`."}, {"sha": "5146263d9911423d513923d33a1c09d34dd6b4f1", "filename": "src/test/ui/coherence/impl-foreign-for-foreign[foreign].rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-foreign%5Bforeign%5D.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-foreign%5Bforeign%5D.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-foreign%5Bforeign%5D.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,25 @@\n+#![feature(re_rebalance_coherence)]\n+\n+// compile-flags:--crate-name=test\n+// aux-build:coherence_lib.rs\n+\n+extern crate coherence_lib as lib;\n+use lib::*;\n+use std::rc::Rc;\n+\n+struct Local;\n+\n+impl Remote1<Rc<i32>> for i32 {\n+    //~^ ERROR only traits defined in the current crate\n+    // | can be implemented for arbitrary types [E0117]\n+}\n+impl Remote1<Rc<Local>> for f64 {\n+    //~^ ERROR only traits defined in the current crate\n+    // | can be implemented for arbitrary types [E0117]\n+}\n+impl<T> Remote1<Rc<T>> for f32 {\n+    //~^ ERROR only traits defined in the current crate\n+    // | can be implemented for arbitrary types [E0117]\n+}\n+\n+fn main() {}"}, {"sha": "bfaec790b20a66f90e2a37d42348fd3dd94bddca", "filename": "src/test/ui/coherence/impl-foreign-for-foreign[foreign].stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-foreign%5Bforeign%5D.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-foreign%5Bforeign%5D.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-foreign%5Bforeign%5D.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,30 @@\n+error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n+  --> $DIR/impl-foreign-for-foreign[foreign].rs:12:1\n+   |\n+LL | impl Remote1<Rc<i32>> for i32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl doesn't use types inside crate\n+   |\n+   = note: the impl does not reference only types defined in this crate\n+   = note: define and implement a trait or new type instead\n+\n+error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n+  --> $DIR/impl-foreign-for-foreign[foreign].rs:16:1\n+   |\n+LL | impl Remote1<Rc<Local>> for f64 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl doesn't use types inside crate\n+   |\n+   = note: the impl does not reference only types defined in this crate\n+   = note: define and implement a trait or new type instead\n+\n+error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n+  --> $DIR/impl-foreign-for-foreign[foreign].rs:20:1\n+   |\n+LL | impl<T> Remote1<Rc<T>> for f32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl doesn't use types inside crate\n+   |\n+   = note: the impl does not reference only types defined in this crate\n+   = note: define and implement a trait or new type instead\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0117`."}, {"sha": "050769dcf4ce8809d965de97ae0e6526dfcbba82", "filename": "src/test/ui/coherence/impl-foreign-for-foreign[local].rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-foreign%5Blocal%5D.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-foreign%5Blocal%5D.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-foreign%5Blocal%5D.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,16 @@\n+#![feature(re_rebalance_coherence)]\n+\n+// compile-flags:--crate-name=test\n+// aux-build:coherence_lib.rs\n+// check-pass\n+\n+extern crate coherence_lib as lib;\n+use lib::*;\n+use std::rc::Rc;\n+\n+struct Local<T>(Rc<T>);\n+\n+impl Remote1<Local<i32>> for i32 {}\n+impl<T> Remote1<Local<T>> for f32 {}\n+\n+fn main() {}"}, {"sha": "03b11edf98b416f1678950e2be4e3d9548adaa9c", "filename": "src/test/ui/coherence/impl-foreign-for-fundamental[foreign].rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-fundamental%5Bforeign%5D.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-fundamental%5Bforeign%5D.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-fundamental%5Bforeign%5D.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,21 @@\n+#![feature(re_rebalance_coherence)]\n+\n+// compile-flags:--crate-name=test\n+// aux-build:coherence_lib.rs\n+\n+extern crate coherence_lib as lib;\n+use lib::*;\n+use std::rc::Rc;\n+\n+struct Local;\n+\n+impl Remote for Box<i32> {\n+    //~^ ERROR only traits defined in the current crate\n+    // | can be implemented for arbitrary types [E0117]\n+}\n+impl<T> Remote for Box<Rc<T>> {\n+    //~^ ERROR only traits defined in the current crate\n+    // | can be implemented for arbitrary types [E0117]\n+}\n+\n+fn main() {}"}, {"sha": "2ce4921cf938f44a18ebb141c94e610574f4273e", "filename": "src/test/ui/coherence/impl-foreign-for-fundamental[foreign].stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-fundamental%5Bforeign%5D.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-fundamental%5Bforeign%5D.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-fundamental%5Bforeign%5D.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,21 @@\n+error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n+  --> $DIR/impl-foreign-for-fundamental[foreign].rs:12:1\n+   |\n+LL | impl Remote for Box<i32> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^ impl doesn't use types inside crate\n+   |\n+   = note: the impl does not reference only types defined in this crate\n+   = note: define and implement a trait or new type instead\n+\n+error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n+  --> $DIR/impl-foreign-for-fundamental[foreign].rs:16:1\n+   |\n+LL | impl<T> Remote for Box<Rc<T>> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl doesn't use types inside crate\n+   |\n+   = note: the impl does not reference only types defined in this crate\n+   = note: define and implement a trait or new type instead\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0117`."}, {"sha": "ae03ce6a440dc7d380a84f3f0581a8e9cae67fbf", "filename": "src/test/ui/coherence/impl-foreign-for-fundamental[local].rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-fundamental%5Blocal%5D.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-fundamental%5Blocal%5D.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-fundamental%5Blocal%5D.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,17 @@\n+#![feature(re_rebalance_coherence)]\n+\n+// compile-flags:--crate-name=test\n+// aux-build:coherence_lib.rs\n+// check-pass\n+\n+extern crate coherence_lib as lib;\n+use lib::*;\n+use std::rc::Rc;\n+\n+struct Local;\n+struct Local1<T>(Rc<T>);\n+\n+impl Remote for Box<Local> {}\n+impl<T> Remote for Box<Local1<T>> {}\n+\n+fn main() {}"}, {"sha": "c9dddeba18dc5a6f7e251b0cb16d14f260f93013", "filename": "src/test/ui/coherence/impl-foreign-for-local.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-local.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,15 @@\n+#![feature(re_rebalance_coherence)]\n+\n+// compile-flags:--crate-name=test\n+// aux-build:coherence_lib.rs\n+// check-pass\n+\n+extern crate coherence_lib as lib;\n+use lib::*;\n+use std::rc::Rc;\n+\n+struct Local;\n+\n+impl Remote for Local {}\n+\n+fn main() {}"}, {"sha": "06efb6c2ad75e4ae4dfaeb4796560865c2f9a815", "filename": "src/test/ui/coherence/impl-foreign[fundemental[foreign]]-for-foreign.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign%5Bfundemental%5Bforeign%5D%5D-for-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign%5Bfundemental%5Bforeign%5D%5D-for-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign%5Bfundemental%5Bforeign%5D%5D-for-foreign.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,26 @@\n+#![feature(re_rebalance_coherence)]\n+\n+// compile-flags:--crate-name=test\n+// aux-build:coherence_lib.rs\n+\n+extern crate coherence_lib as lib;\n+use lib::*;\n+use std::rc::Rc;\n+\n+struct Local;\n+struct Local1<T>(Rc<T>);\n+\n+impl Remote1<Box<String>> for i32 {\n+    //~^ ERROR only traits defined in the current crate\n+    // | can be implemented for arbitrary types [E0117]\n+}\n+impl Remote1<Box<Rc<i32>>> for f64 {\n+    //~^ ERROR only traits defined in the current crate\n+    // | can be implemented for arbitrary types [E0117]\n+}\n+impl<T> Remote1<Box<Rc<T>>> for f32 {\n+    //~^ ERROR only traits defined in the current crate\n+    // | can be implemented for arbitrary types [E0117]\n+}\n+\n+fn main() {}"}, {"sha": "bf2361a1718afe94f5a067f9ba09979fd93aea57", "filename": "src/test/ui/coherence/impl-foreign[fundemental[foreign]]-for-foreign.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign%5Bfundemental%5Bforeign%5D%5D-for-foreign.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign%5Bfundemental%5Bforeign%5D%5D-for-foreign.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign%5Bfundemental%5Bforeign%5D%5D-for-foreign.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,30 @@\n+error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n+  --> $DIR/impl-foreign[fundemental[foreign]]-for-foreign.rs:13:1\n+   |\n+LL | impl Remote1<Box<String>> for i32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl doesn't use types inside crate\n+   |\n+   = note: the impl does not reference only types defined in this crate\n+   = note: define and implement a trait or new type instead\n+\n+error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n+  --> $DIR/impl-foreign[fundemental[foreign]]-for-foreign.rs:17:1\n+   |\n+LL | impl Remote1<Box<Rc<i32>>> for f64 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl doesn't use types inside crate\n+   |\n+   = note: the impl does not reference only types defined in this crate\n+   = note: define and implement a trait or new type instead\n+\n+error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n+  --> $DIR/impl-foreign[fundemental[foreign]]-for-foreign.rs:21:1\n+   |\n+LL | impl<T> Remote1<Box<Rc<T>>> for f32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl doesn't use types inside crate\n+   |\n+   = note: the impl does not reference only types defined in this crate\n+   = note: define and implement a trait or new type instead\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0117`."}, {"sha": "d47e0a36a565959f90a92a347e8c11eb4c7bfd2f", "filename": "src/test/ui/coherence/impl-foreign[fundemental[local]]-for-foreign.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign%5Bfundemental%5Blocal%5D%5D-for-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign%5Bfundemental%5Blocal%5D%5D-for-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign%5Bfundemental%5Blocal%5D%5D-for-foreign.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,18 @@\n+#![feature(re_rebalance_coherence)]\n+\n+// compile-flags:--crate-name=test\n+// aux-build:coherence_lib.rs\n+// check-pass\n+\n+extern crate coherence_lib as lib;\n+use lib::*;\n+use std::rc::Rc;\n+\n+struct Local;\n+struct Local1<T>(Rc<T>);\n+\n+impl Remote1<Box<Local>> for i32 {}\n+impl Remote1<Box<Local1<i32>>> for f64 {}\n+impl<T> Remote1<Box<Local1<T>>> for f32 {}\n+\n+fn main() {}"}, {"sha": "db7a2ae8076a3aa8e7fea020214e93d89c35d7b6", "filename": "src/test/ui/coherence/impl[t]-foreign-for-foreign[t].rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign-for-foreign%5Bt%5D.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign-for-foreign%5Bt%5D.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign-for-foreign%5Bt%5D.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,23 @@\n+#![feature(re_rebalance_coherence)]\n+\n+// compile-flags:--crate-name=test\n+// aux-build:coherence_lib.rs\n+\n+extern crate coherence_lib as lib;\n+use lib::*;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+struct Local;\n+\n+impl Remote for Rc<Local> {\n+    //~^ ERROR only traits defined in the current crate\n+    // | can be implemented for arbitrary types [E0117]\n+}\n+\n+impl<T> Remote for Arc<T> {\n+    //~^ ERROR only traits defined in the current crate\n+    // | can be implemented for arbitrary types [E0117]\n+}\n+\n+fn main() {}"}, {"sha": "d7ffcaf76f9a2a9b56f95cc5b381b8a704ea42ae", "filename": "src/test/ui/coherence/impl[t]-foreign-for-foreign[t].stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign-for-foreign%5Bt%5D.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign-for-foreign%5Bt%5D.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign-for-foreign%5Bt%5D.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,21 @@\n+error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n+  --> $DIR/impl[t]-foreign-for-foreign[t].rs:13:1\n+   |\n+LL | impl Remote for Rc<Local> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^ impl doesn't use types inside crate\n+   |\n+   = note: the impl does not reference only types defined in this crate\n+   = note: define and implement a trait or new type instead\n+\n+error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n+  --> $DIR/impl[t]-foreign-for-foreign[t].rs:18:1\n+   |\n+LL | impl<T> Remote for Arc<T> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^ impl doesn't use types inside crate\n+   |\n+   = note: the impl does not reference only types defined in this crate\n+   = note: define and implement a trait or new type instead\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0117`."}, {"sha": "4cc19e1a526cabcb05a22e07104dfa925bd15ab6", "filename": "src/test/ui/coherence/impl[t]-foreign-for-fundamental[t].rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign-for-fundamental%5Bt%5D.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign-for-fundamental%5Bt%5D.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign-for-fundamental%5Bt%5D.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,17 @@\n+#![feature(re_rebalance_coherence)]\n+\n+// compile-flags:--crate-name=test\n+// aux-build:coherence_lib.rs\n+\n+extern crate coherence_lib as lib;\n+use lib::*;\n+use std::rc::Rc;\n+\n+struct Local;\n+\n+impl<T> Remote for Box<T> {\n+    //~^ ERROR type parameter `T` must be used as the type parameter for\n+    // | some local type (e.g., `MyStruct<T>`)\n+}\n+\n+fn main() {}"}, {"sha": "20ce11ef9759e183414d1be0f7a5bd890dc97ebd", "filename": "src/test/ui/coherence/impl[t]-foreign-for-fundamental[t].stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign-for-fundamental%5Bt%5D.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign-for-fundamental%5Bt%5D.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign-for-fundamental%5Bt%5D.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,11 @@\n+error[E0210]: type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\n+  --> $DIR/impl[t]-foreign-for-fundamental[t].rs:12:1\n+   |\n+LL | impl<T> Remote for Box<T> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^ type parameter `T` must be used as the type parameter for some local type\n+   |\n+   = note: only traits defined in the current crate can be implemented for a type parameter\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0210`."}, {"sha": "914680f191ac9e10f6b608dab7f628f6b921f964", "filename": "src/test/ui/coherence/impl[t]-foreign[fundemental[local]]-for-foreign[t].rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundemental%5Blocal%5D%5D-for-foreign%5Bt%5D.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundemental%5Blocal%5D%5D-for-foreign%5Bt%5D.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundemental%5Blocal%5D%5D-for-foreign%5Bt%5D.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,17 @@\n+#![feature(re_rebalance_coherence)]\n+\n+// compile-flags:--crate-name=test\n+// aux-build:coherence_lib.rs\n+// check-pass\n+\n+extern crate coherence_lib as lib;\n+use lib::*;\n+use std::rc::Rc;\n+\n+struct Local;\n+struct Local1<S>(Rc<S>);\n+\n+impl<T> Remote1<Box<Local>> for Rc<T> {}\n+impl<S, T> Remote1<Box<Local1<S>>> for Rc<T> {}\n+\n+fn main() {}"}, {"sha": "1e84ff40c6227e97c3796190c1b398c76289609d", "filename": "src/test/ui/coherence/impl[t]-foreign[local]-for-foreign[t].rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-foreign%5Bt%5D.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-foreign%5Bt%5D.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-foreign%5Bt%5D.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,17 @@\n+#![feature(re_rebalance_coherence)]\n+\n+// compile-flags:--crate-name=test\n+// aux-build:coherence_lib.rs\n+// check-pass\n+\n+extern crate coherence_lib as lib;\n+use lib::*;\n+use std::rc::Rc;\n+\n+struct Local;\n+struct Local1<S>(Rc<S>);\n+\n+impl<T> Remote1<Local> for Rc<T> {}\n+impl<T, S> Remote1<Local1<S>> for Rc<T> {}\n+\n+fn main() {}"}, {"sha": "ea6aa101d209c1e2647c1c069fb7f3b263d89046", "filename": "src/test/ui/coherence/impl[t]-foreign[local]-for-fundamental[foreign[t]].rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-fundamental%5Bforeign%5Bt%5D%5D.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-fundamental%5Bforeign%5Bt%5D%5D.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-fundamental%5Bforeign%5Bt%5D%5D.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,19 @@\n+#![feature(re_rebalance_coherence)]\n+\n+// compile-flags:--crate-name=test\n+// aux-build:coherence_lib.rs\n+// check-pass\n+\n+extern crate coherence_lib as lib;\n+use lib::*;\n+use std::rc::Rc;\n+\n+struct Local;\n+struct Local1<S>(Rc<S>);\n+\n+impl<T> Remote1<Local> for Box<Rc<T>> {}\n+impl<T, S> Remote1<Local1<S>> for Box<Rc<T>> {}\n+impl<T> Remote1<Box<Local>> for Box<Rc<T>> {}\n+impl<T, S> Remote1<Box<Local1<S>>> for Box<Rc<T>> {}\n+\n+fn main() {}"}, {"sha": "78bd549ba791a456739aa62a60d2462aa4d8082f", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param-ungated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,6 +1,6 @@\n use std::marker::PhantomData;\n \n struct B<T, const N: T>(PhantomData<[T; N]>); //~ ERROR const generics are unstable\n-//~^ ERROR const parameters cannot depend on type parameters\n+//~^ ERROR the types of const generic parameters must derive `PartialEq` and `Eq`\n \n fn main() {}"}, {"sha": "a2872ab982da49ed13519285ddc23608e86c2405", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param-ungated.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,9 +1,3 @@\n-error[E0671]: const parameters cannot depend on type parameters\n-  --> $DIR/const-param-type-depends-on-type-param-ungated.rs:3:22\n-   |\n-LL | struct B<T, const N: T>(PhantomData<[T; N]>);\n-   |                      ^ const parameter depends on type parameter\n-\n error[E0658]: const generics are unstable\n   --> $DIR/const-param-type-depends-on-type-param-ungated.rs:3:19\n    |\n@@ -13,7 +7,13 @@ LL | struct B<T, const N: T>(PhantomData<[T; N]>);\n    = note: for more information, see https://github.com/rust-lang/rust/issues/44580\n    = help: add `#![feature(const_generics)]` to the crate attributes to enable\n \n+error[E0741]: the types of const generic parameters must derive `PartialEq` and `Eq`\n+  --> $DIR/const-param-type-depends-on-type-param-ungated.rs:3:22\n+   |\n+LL | struct B<T, const N: T>(PhantomData<[T; N]>);\n+   |                      ^ `T` doesn't derive both `PartialEq` and `Eq`\n+\n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0658, E0671.\n+Some errors have detailed explanations: E0658, E0741.\n For more information about an error, try `rustc --explain E0658`."}, {"sha": "b76209571b05cba8633f4f2606ee23bcc1071d5a", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -7,7 +7,6 @@\n // details.\n \n pub struct Dependent<T, const X: T>([(); X]);\n-//~^ ERROR const parameters cannot depend on type parameters\n-//~^^ ERROR parameter `T` is never used\n+//~^ ERROR the types of const generic parameters must derive `PartialEq` and `Eq`\n \n fn main() {}"}, {"sha": "c9d6db7e2c2200928a1462015bdda3918cd752a0", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param.stderr", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,9 +1,3 @@\n-error[E0671]: const parameters cannot depend on type parameters\n-  --> $DIR/const-param-type-depends-on-type-param.rs:9:34\n-   |\n-LL | pub struct Dependent<T, const X: T>([(); X]);\n-   |                                  ^ const parameter depends on type parameter\n-\n warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n   --> $DIR/const-param-type-depends-on-type-param.rs:1:12\n    |\n@@ -12,15 +6,12 @@ LL | #![feature(const_generics)]\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n \n-error[E0392]: parameter `T` is never used\n-  --> $DIR/const-param-type-depends-on-type-param.rs:9:22\n+error[E0741]: the types of const generic parameters must derive `PartialEq` and `Eq`\n+  --> $DIR/const-param-type-depends-on-type-param.rs:9:34\n    |\n LL | pub struct Dependent<T, const X: T>([(); X]);\n-   |                      ^ unused parameter\n-   |\n-   = help: consider removing `T`, referring to it in a field, or using a marker such as `std::marker::PhantomData`\n+   |                                  ^ `T` doesn't derive both `PartialEq` and `Eq`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0392, E0671.\n-For more information about an error, try `rustc --explain E0392`.\n+For more information about this error, try `rustc --explain E0741`."}, {"sha": "7bc4f3986eb754ba7160739f6dadc49142f7282b", "filename": "src/test/ui/const-generics/forbid-non-structural_match-types.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,13 @@\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+#[derive(PartialEq, Eq)]\n+struct A;\n+\n+struct B<const X: A>; // ok\n+\n+struct C;\n+\n+struct D<const X: C>; //~ ERROR the types of const generic parameters must derive\n+\n+fn main() {}"}, {"sha": "0fd9e0599e80e47c91e987687af38b0f160810ce", "filename": "src/test/ui/const-generics/forbid-non-structural_match-types.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,17 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/forbid-non-structural_match-types.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0741]: the types of const generic parameters must derive `PartialEq` and `Eq`\n+  --> $DIR/forbid-non-structural_match-types.rs:11:19\n+   |\n+LL | struct D<const X: C>;\n+   |                   ^ `C` doesn't derive both `PartialEq` and `Eq`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0741`."}, {"sha": "0ff7ddc41fe4c1c724e1e1b792ce908a55be583d", "filename": "src/test/ui/const-generics/issues/issue-62579-no-match.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62579-no-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62579-no-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62579-no-match.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,15 @@\n+// run-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+#[derive(PartialEq, Eq)]\n+struct NoMatch;\n+\n+fn foo<const T: NoMatch>() -> bool {\n+    true\n+}\n+\n+fn main() {\n+    foo::<{NoMatch}>();\n+}"}, {"sha": "759d5fdeb4c16e5c2d2b60cecf30f74dddbdd1e6", "filename": "src/test/ui/const-generics/issues/issue-62579-no-match.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62579-no-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62579-no-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62579-no-match.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,8 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/issue-62579-no-match.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+"}, {"sha": "3ca527313f93f9f38c3acb8a1201e83e504f1314", "filename": "src/test/ui/const-generics/issues/issue-65675.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-65675.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-65675.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-65675.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,10 @@\n+// run-pass\n+// compile-flags: -Z chalk\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+pub struct Foo<T, const N: usize>([T; N]);\n+impl<T, const N: usize> Foo<T, {N}> {}\n+\n+fn main() {}"}, {"sha": "60b388e62783e9da22f85f155b03fb2db61a09b7", "filename": "src/test/ui/const-generics/issues/issue-65675.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-65675.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-65675.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-65675.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,8 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/issue-65675.rs:4:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+"}, {"sha": "8945360b7be6d4d86d2b94410eb4366d7d445971", "filename": "src/test/ui/feature-gates/feature-gate-object_safe_for_dispatch.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-object_safe_for_dispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-object_safe_for_dispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-object_safe_for_dispatch.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,41 @@\n+// Test that the use of the non object-safe trait objects\n+// are gated by `object_safe_for_dispatch` feature gate.\n+\n+trait NonObjectSafe1: Sized {}\n+\n+trait NonObjectSafe2 {\n+    fn static_fn() {}\n+}\n+\n+trait NonObjectSafe3 {\n+    fn foo<T>(&self);\n+}\n+\n+trait NonObjectSafe4 {\n+    fn foo(&self, &Self);\n+}\n+\n+fn takes_non_object_safe_ref<T>(obj: &dyn NonObjectSafe1) {\n+    //~^ ERROR E0038\n+}\n+\n+fn return_non_object_safe_ref() -> &'static dyn NonObjectSafe2 {\n+    //~^ ERROR E0038\n+    loop {}\n+}\n+\n+fn takes_non_object_safe_box(obj: Box<dyn NonObjectSafe3>) {\n+    //~^ ERROR E0038\n+}\n+\n+fn return_non_object_safe_rc() -> std::rc::Rc<dyn NonObjectSafe4> {\n+    //~^ ERROR E0038\n+    loop {}\n+}\n+\n+trait Trait {}\n+\n+impl Trait for dyn NonObjectSafe1 {}\n+//~^ ERROR E0038\n+\n+fn main() {}"}, {"sha": "54e64e2fc1bd4b9716f5473cb09d4352a33395fb", "filename": "src/test/ui/feature-gates/feature-gate-object_safe_for_dispatch.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-object_safe_for_dispatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-object_safe_for_dispatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-object_safe_for_dispatch.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,46 @@\n+error[E0038]: the trait `NonObjectSafe1` cannot be made into an object\n+  --> $DIR/feature-gate-object_safe_for_dispatch.rs:18:1\n+   |\n+LL | fn takes_non_object_safe_ref<T>(obj: &dyn NonObjectSafe1) {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `NonObjectSafe1` cannot be made into an object\n+   |\n+   = note: the trait cannot require that `Self : Sized`\n+\n+error[E0038]: the trait `NonObjectSafe2` cannot be made into an object\n+  --> $DIR/feature-gate-object_safe_for_dispatch.rs:22:1\n+   |\n+LL |     fn static_fn() {}\n+   |        --------- associated function `static_fn` has no `self` parameter\n+...\n+LL | fn return_non_object_safe_ref() -> &'static dyn NonObjectSafe2 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `NonObjectSafe2` cannot be made into an object\n+\n+error[E0038]: the trait `NonObjectSafe3` cannot be made into an object\n+  --> $DIR/feature-gate-object_safe_for_dispatch.rs:27:1\n+   |\n+LL |     fn foo<T>(&self);\n+   |        --- method `foo` has generic type parameters\n+...\n+LL | fn takes_non_object_safe_box(obj: Box<dyn NonObjectSafe3>) {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `NonObjectSafe3` cannot be made into an object\n+\n+error[E0038]: the trait `NonObjectSafe4` cannot be made into an object\n+  --> $DIR/feature-gate-object_safe_for_dispatch.rs:31:1\n+   |\n+LL |     fn foo(&self, &Self);\n+   |        --- method `foo` references the `Self` type in its parameters or return type\n+...\n+LL | fn return_non_object_safe_rc() -> std::rc::Rc<dyn NonObjectSafe4> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `NonObjectSafe4` cannot be made into an object\n+\n+error[E0038]: the trait `NonObjectSafe1` cannot be made into an object\n+  --> $DIR/feature-gate-object_safe_for_dispatch.rs:38:6\n+   |\n+LL | impl Trait for dyn NonObjectSafe1 {}\n+   |      ^^^^^ the trait `NonObjectSafe1` cannot be made into an object\n+   |\n+   = note: the trait cannot require that `Self : Sized`\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0038`."}, {"sha": "691c06a2402c5352ec39c4650ff3d82bb0d76505", "filename": "src/test/ui/fmt/format-string-error.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -48,4 +48,6 @@ fn main() {\n \n \"###);\n     //~^^^ ERROR invalid format string: unmatched `}` found\n+    println!(\"{} {} {}\", 1, 2);\n+    //~^ ERROR 3 positional arguments in format string, but there are 2 arguments\n }"}, {"sha": "32119b18774b25585c1f00395a2a80b5fd04dbf0", "filename": "src/test/ui/fmt/format-string-error.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -107,5 +107,11 @@ LL |         }\n    |\n    = note: if you intended to print `}`, you can escape it using `}}`\n \n-error: aborting due to 12 previous errors\n+error: 3 positional arguments in format string, but there are 2 arguments\n+  --> $DIR/format-string-error.rs:51:15\n+   |\n+LL |     println!(\"{} {} {}\", 1, 2);\n+   |               ^^ ^^ ^^   -  -\n+\n+error: aborting due to 13 previous errors\n "}, {"sha": "c58cbc312335a6588553ec4967cd721672eb074d", "filename": "src/test/ui/if/ifmt-bad-arg.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -224,8 +224,9 @@ error: 4 positional arguments in format string, but there are 3 arguments\n   --> $DIR/ifmt-bad-arg.rs:78:15\n    |\n LL |     println!(\"{} {:.*} {}\", 1, 3.2, 4);\n-   |               ^^ ^^--^ ^^      --- this parameter corresponds to the precision flag\n-   |                    |\n+   |               ^^ ^^--^ ^^   -  ---  -\n+   |                    |           |\n+   |                    |           this parameter corresponds to the precision flag\n    |                    this precision flag adds an extra required argument at position 1, which is why there are 4 arguments expected\n    |\n    = note: positional arguments are zero-based\n@@ -235,8 +236,9 @@ error: 4 positional arguments in format string, but there are 3 arguments\n   --> $DIR/ifmt-bad-arg.rs:81:15\n    |\n LL |     println!(\"{} {:07$.*} {}\", 1, 3.2, 4);\n-   |               ^^ ^^^----^ ^^      --- this parameter corresponds to the precision flag\n-   |                     | |\n+   |               ^^ ^^^----^ ^^   -  ---  -\n+   |                     | |           |\n+   |                     | |           this parameter corresponds to the precision flag\n    |                     | this precision flag adds an extra required argument at position 1, which is why there are 4 arguments expected\n    |                     this width flag expects an `usize` argument at position 7, but there are 3 arguments\n    |"}, {"sha": "02e3139d2944483fc4300eabf2211b335b5b008b", "filename": "src/test/ui/intrinsics/intrinsic-alignment.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-alignment.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -19,7 +19,8 @@ mod rusti {\n           target_os = \"macos\",\n           target_os = \"netbsd\",\n           target_os = \"openbsd\",\n-          target_os = \"solaris\"))]\n+          target_os = \"solaris\",\n+          target_os = \"vxworks\"))]\n mod m {\n     #[main]\n     #[cfg(target_arch = \"x86\")]"}, {"sha": "83c03b514ddcc8dd919d23ad82002acb46676d4a", "filename": "src/test/ui/issues/issue-19538.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fissues%2Fissue-19538.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fissues%2Fissue-19538.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-19538.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -17,6 +17,7 @@ LL |     let test: &mut dyn Bar = &mut thing;\n    |                              ^^^^^^^^^^ the trait `Bar` cannot be made into an object\n    |\n    = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<&mut dyn Bar>` for `&mut Thing`\n+   = note: required by cast to type `&mut dyn Bar`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "06c83f65be26c7b01fd3e26d9a11533097a44eca", "filename": "src/test/ui/issues/issue-20692.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fissues%2Fissue-20692.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fissues%2Fissue-20692.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20692.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -14,6 +14,7 @@ LL |     let _ = x\n    |\n    = note: the trait cannot require that `Self : Sized`\n    = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<&dyn Array>` for `&T`\n+   = note: required by cast to type `&dyn Array`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "8b923a2c6b23f45c1cba0739eb1dfe4bb51866e8", "filename": "src/test/ui/issues/issue-38604.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fissues%2Fissue-38604.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fissues%2Fissue-38604.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-38604.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -14,6 +14,7 @@ LL |         Box::new(());\n    |\n    = note: the trait cannot use `Self` as a type parameter in the supertraits or where-clauses\n    = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<std::boxed::Box<dyn Foo>>` for `std::boxed::Box<()>`\n+   = note: required by cast to type `std::boxed::Box<dyn Foo>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "b74ee1b0c6e54b6ffae430f3a7b8a0f2054dd29b", "filename": "src/test/ui/issues/issue-65611.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fissues%2Fissue-65611.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fissues%2Fissue-65611.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-65611.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,63 @@\n+use std::mem::MaybeUninit;\n+use std::ops::Deref;\n+\n+pub unsafe trait Array {\n+    /// The array\u2019s element type\n+    type Item;\n+    #[doc(hidden)]\n+    /// The smallest index type that indexes the array.\n+    type Index: Index;\n+    #[doc(hidden)]\n+    fn as_ptr(&self) -> *const Self::Item;\n+    #[doc(hidden)]\n+    fn as_mut_ptr(&mut self) -> *mut Self::Item;\n+    #[doc(hidden)]\n+    fn capacity() -> usize;\n+}\n+\n+pub trait Index : PartialEq + Copy {\n+    fn to_usize(self) -> usize;\n+    fn from(usize) -> Self;\n+}\n+\n+impl Index for usize {\n+    fn to_usize(self) -> usize { self }\n+    fn from(val: usize) -> Self {\n+        val\n+    }\n+}\n+\n+unsafe impl<T> Array for [T; 1] {\n+    type Item = T;\n+    type Index = usize;\n+    fn as_ptr(&self) -> *const T { self as *const _ as *const _ }\n+    fn as_mut_ptr(&mut self) -> *mut T { self as *mut _ as *mut _}\n+    fn capacity() -> usize { 1 }\n+}\n+\n+impl<A: Array> Deref for ArrayVec<A> {\n+    type Target = [A::Item];\n+    #[inline]\n+    fn deref(&self) -> &[A::Item] {\n+        panic!()\n+    }\n+}\n+\n+pub struct ArrayVec<A: Array> {\n+    xs: MaybeUninit<A>,\n+    len: usize,\n+}\n+\n+impl<A: Array> ArrayVec<A> {\n+    pub fn new() -> ArrayVec<A> {\n+        panic!()\n+    }\n+}\n+\n+fn main() {\n+    let mut buffer = ArrayVec::new();\n+    let x = buffer.last().unwrap().0.clone();\n+    //~^ ERROR type annotations needed\n+    //~| ERROR no field `0` on type `&_`\n+    buffer.reverse();\n+}"}, {"sha": "cb441c13c6b9e9e1329eca7ee117b72f96ab9238", "filename": "src/test/ui/issues/issue-65611.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fissues%2Fissue-65611.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fissues%2Fissue-65611.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-65611.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,18 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-65611.rs:59:20\n+   |\n+LL |     let x = buffer.last().unwrap().0.clone();\n+   |                    ^^^^ cannot infer type for `T`\n+   |\n+   = note: type must be known at this point\n+\n+error[E0609]: no field `0` on type `&_`\n+  --> $DIR/issue-65611.rs:59:36\n+   |\n+LL |     let x = buffer.last().unwrap().0.clone();\n+   |                                    ^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0282, E0609.\n+For more information about an error, try `rustc --explain E0282`."}, {"sha": "a93f4686496ac6c6a307227839fc582ddcc210fe", "filename": "src/test/ui/kindck/kindck-inherited-copy-bound.curr.stderr", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fkindck%2Fkindck-inherited-copy-bound.curr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fkindck%2Fkindck-inherited-copy-bound.curr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkindck%2Fkindck-inherited-copy-bound.curr.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the trait bound `std::boxed::Box<{integer}>: std::marker::Copy` is not satisfied\n-  --> $DIR/kindck-inherited-copy-bound.rs:18:16\n+  --> $DIR/kindck-inherited-copy-bound.rs:21:16\n    |\n LL | fn take_param<T:Foo>(foo: &T) { }\n    |    ----------   --- required by this bound in `take_param`\n@@ -10,21 +10,22 @@ LL |     take_param(&x);\n    = note: required because of the requirements on the impl of `Foo` for `std::boxed::Box<{integer}>`\n \n error[E0038]: the trait `Foo` cannot be made into an object\n-  --> $DIR/kindck-inherited-copy-bound.rs:24:19\n+  --> $DIR/kindck-inherited-copy-bound.rs:28:19\n    |\n LL |     let z = &x as &dyn Foo;\n    |                   ^^^^^^^^ the trait `Foo` cannot be made into an object\n    |\n    = note: the trait cannot require that `Self : Sized`\n \n error[E0038]: the trait `Foo` cannot be made into an object\n-  --> $DIR/kindck-inherited-copy-bound.rs:24:13\n+  --> $DIR/kindck-inherited-copy-bound.rs:28:13\n    |\n LL |     let z = &x as &dyn Foo;\n    |             ^^ the trait `Foo` cannot be made into an object\n    |\n    = note: the trait cannot require that `Self : Sized`\n    = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<&dyn Foo>` for `&std::boxed::Box<{integer}>`\n+   = note: required by cast to type `&dyn Foo`\n \n error: aborting due to 3 previous errors\n ", "previous_filename": "src/test/ui/kindck/kindck-inherited-copy-bound.stderr"}, {"sha": "7c67c5f9e9596dd5610f0c5073ec2db33027c3da", "filename": "src/test/ui/kindck/kindck-inherited-copy-bound.object_safe_for_dispatch.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fkindck%2Fkindck-inherited-copy-bound.object_safe_for_dispatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fkindck%2Fkindck-inherited-copy-bound.object_safe_for_dispatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkindck%2Fkindck-inherited-copy-bound.object_safe_for_dispatch.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,25 @@\n+error[E0277]: the trait bound `std::boxed::Box<{integer}>: std::marker::Copy` is not satisfied\n+  --> $DIR/kindck-inherited-copy-bound.rs:21:16\n+   |\n+LL | fn take_param<T:Foo>(foo: &T) { }\n+   |    ----------   --- required by this bound in `take_param`\n+...\n+LL |     take_param(&x);\n+   |                ^^ the trait `std::marker::Copy` is not implemented for `std::boxed::Box<{integer}>`\n+   |\n+   = note: required because of the requirements on the impl of `Foo` for `std::boxed::Box<{integer}>`\n+\n+error[E0038]: the trait `Foo` cannot be made into an object\n+  --> $DIR/kindck-inherited-copy-bound.rs:28:13\n+   |\n+LL |     let z = &x as &dyn Foo;\n+   |             ^^ the trait `Foo` cannot be made into an object\n+   |\n+   = note: the trait cannot require that `Self : Sized`\n+   = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<&dyn Foo>` for `&std::boxed::Box<i32>`\n+   = note: required by cast to type `&dyn Foo`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0038, E0277.\n+For more information about an error, try `rustc --explain E0038`."}, {"sha": "aad693e5b193708149bf63f1d1aa968e5634c134", "filename": "src/test/ui/kindck/kindck-inherited-copy-bound.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fkindck%2Fkindck-inherited-copy-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fkindck%2Fkindck-inherited-copy-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkindck%2Fkindck-inherited-copy-bound.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,5 +1,8 @@\n // Test that Copy bounds inherited by trait are checked.\n+//\n+// revisions: curr object_safe_for_dispatch\n \n+#![cfg_attr(object_safe_for_dispatch, feature(object_safe_for_dispatch))]\n #![feature(box_syntax)]\n \n use std::any::Any;\n@@ -15,15 +18,17 @@ fn take_param<T:Foo>(foo: &T) { }\n \n fn a() {\n     let x: Box<_> = box 3;\n-    take_param(&x); //~ ERROR E0277\n+    take_param(&x); //[curr]~ ERROR E0277\n+    //[object_safe_for_dispatch]~^ ERROR E0277\n }\n \n fn b() {\n     let x: Box<_> = box 3;\n     let y = &x;\n     let z = &x as &dyn Foo;\n-    //~^ ERROR E0038\n-    //~| ERROR E0038\n+    //[curr]~^ ERROR E0038\n+    //[curr]~| ERROR E0038\n+    //[object_safe_for_dispatch]~^^^ ERROR E0038\n }\n \n fn main() { }"}, {"sha": "15ee19755bffc504ab84086542be1f91912eb7f3", "filename": "src/test/ui/lint/unused_parens_json_suggestion.fixed", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Flint%2Funused_parens_json_suggestion.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Flint%2Funused_parens_json_suggestion.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_parens_json_suggestion.fixed?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,5 +1,4 @@\n-// compile-flags: --error-format pretty-json -Zunstable-options\n-// build-pass (FIXME(62277): could be check-pass?)\n+// compile-flags: --error-format json -Zunstable-options\n // run-rustfix\n \n // The output for humans should just highlight the whole span without showing\n@@ -8,13 +7,13 @@\n // stripping away any starting or ending parenthesis characters\u2014hence this\n // test of the JSON error format.\n \n-#![warn(unused_parens)]\n+#![deny(unused_parens)]\n #![allow(unreachable_code)]\n \n fn main() {\n     // We want to suggest the properly-balanced expression `1 / (2 + 3)`, not\n     // the malformed `1 / (2 + 3`\n-    let _a = 1 / (2 + 3);\n+    let _a = 1 / (2 + 3); //~ERROR unnecessary parentheses\n     f();\n }\n "}, {"sha": "d72df21e09ae264c8a253850b77f15b65401bdba", "filename": "src/test/ui/lint/unused_parens_json_suggestion.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Flint%2Funused_parens_json_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Flint%2Funused_parens_json_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_parens_json_suggestion.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,5 +1,4 @@\n-// compile-flags: --error-format pretty-json -Zunstable-options\n-// build-pass (FIXME(62277): could be check-pass?)\n+// compile-flags: --error-format json -Zunstable-options\n // run-rustfix\n \n // The output for humans should just highlight the whole span without showing\n@@ -8,13 +7,13 @@\n // stripping away any starting or ending parenthesis characters\u2014hence this\n // test of the JSON error format.\n \n-#![warn(unused_parens)]\n+#![deny(unused_parens)]\n #![allow(unreachable_code)]\n \n fn main() {\n     // We want to suggest the properly-balanced expression `1 / (2 + 3)`, not\n     // the malformed `1 / (2 + 3`\n-    let _a = (1 / (2 + 3));\n+    let _a = (1 / (2 + 3)); //~ERROR unnecessary parentheses\n     f();\n }\n "}, {"sha": "c503c100808dbee414637cf99e29ecb73d5a8e32", "filename": "src/test/ui/lint/unused_parens_json_suggestion.stderr", "status": "modified", "additions": 8, "deletions": 98, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Flint%2Funused_parens_json_suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Flint%2Funused_parens_json_suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_parens_json_suggestion.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,106 +1,16 @@\n-{\n-  \"message\": \"unnecessary parentheses around assigned value\",\n-  \"code\": {\n-    \"code\": \"unused_parens\",\n-    \"explanation\": null\n-  },\n-  \"level\": \"warning\",\n-  \"spans\": [\n-    {\n-      \"file_name\": \"$DIR/unused_parens_json_suggestion.rs\",\n-      \"byte_start\": 654,\n-      \"byte_end\": 667,\n-      \"line_start\": 17,\n-      \"line_end\": 17,\n-      \"column_start\": 14,\n-      \"column_end\": 27,\n-      \"is_primary\": true,\n-      \"text\": [\n-        {\n-          \"text\": \"    let _a = (1 / (2 + 3));\",\n-          \"highlight_start\": 14,\n-          \"highlight_end\": 27\n-        }\n-      ],\n-      \"label\": null,\n-      \"suggested_replacement\": null,\n-      \"suggestion_applicability\": null,\n-      \"expansion\": null\n-    }\n-  ],\n-  \"children\": [\n-    {\n-      \"message\": \"lint level defined here\",\n-      \"code\": null,\n-      \"level\": \"note\",\n-      \"spans\": [\n-        {\n-          \"file_name\": \"$DIR/unused_parens_json_suggestion.rs\",\n-          \"byte_start\": 472,\n-          \"byte_end\": 485,\n-          \"line_start\": 11,\n-          \"line_end\": 11,\n-          \"column_start\": 9,\n-          \"column_end\": 22,\n-          \"is_primary\": true,\n-          \"text\": [\n-            {\n-              \"text\": \"#![warn(unused_parens)]\",\n-              \"highlight_start\": 9,\n-              \"highlight_end\": 22\n-            }\n-          ],\n-          \"label\": null,\n-          \"suggested_replacement\": null,\n-          \"suggestion_applicability\": null,\n-          \"expansion\": null\n-        }\n-      ],\n-      \"children\": [],\n-      \"rendered\": null\n-    },\n-    {\n-      \"message\": \"remove these parentheses\",\n-      \"code\": null,\n-      \"level\": \"help\",\n-      \"spans\": [\n-        {\n-          \"file_name\": \"$DIR/unused_parens_json_suggestion.rs\",\n-          \"byte_start\": 654,\n-          \"byte_end\": 667,\n-          \"line_start\": 17,\n-          \"line_end\": 17,\n-          \"column_start\": 14,\n-          \"column_end\": 27,\n-          \"is_primary\": true,\n-          \"text\": [\n-            {\n-              \"text\": \"    let _a = (1 / (2 + 3));\",\n-              \"highlight_start\": 14,\n-              \"highlight_end\": 27\n-            }\n-          ],\n-          \"label\": null,\n-          \"suggested_replacement\": \"1 / (2 + 3)\",\n-          \"suggestion_applicability\": \"MachineApplicable\",\n-          \"expansion\": null\n-        }\n-      ],\n-      \"children\": [],\n-      \"rendered\": null\n-    }\n-  ],\n-  \"rendered\": \"warning: unnecessary parentheses around assigned value\n-  --> $DIR/unused_parens_json_suggestion.rs:17:14\n+{\"message\":\"unnecessary parentheses around assigned value\",\"code\":{\"code\":\"unused_parens\",\"explanation\":null},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/unused_parens_json_suggestion.rs\",\"byte_start\":596,\"byte_end\":609,\"line_start\":16,\"line_end\":16,\"column_start\":14,\"column_end\":27,\"is_primary\":true,\"text\":[{\"text\":\"    let _a = (1 / (2 + 3));\n+  --> $DIR/unused_parens_json_suggestion.rs:16:14\n    |\n LL |     let _a = (1 / (2 + 3));\n    |              ^^^^^^^^^^^^^ help: remove these parentheses\n    |\n note: lint level defined here\n-  --> $DIR/unused_parens_json_suggestion.rs:11:9\n+  --> $DIR/unused_parens_json_suggestion.rs:10:9\n    |\n-LL | #![warn(unused_parens)]\n+LL | #![deny(unused_parens)]\n    |         ^^^^^^^^^^^^^\n \n-\"\n-}\n+\"}\n+{\"message\":\"aborting due to previous error\",\"code\":null,\"level\":\"error\",\"spans\":[],\"children\":[],\"rendered\":\"error: aborting due to previous error\n+\n+\"}"}, {"sha": "1d891d328dd5ab3123026c7a3c5e4154c9c9066d", "filename": "src/test/ui/lint/unused_parens_remove_json_suggestion.fixed", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Flint%2Funused_parens_remove_json_suggestion.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Flint%2Funused_parens_remove_json_suggestion.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_parens_remove_json_suggestion.fixed?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,5 +1,4 @@\n-// compile-flags: --error-format pretty-json -Zunstable-options\n-// build-pass\n+// compile-flags: --error-format json -Zunstable-options\n // run-rustfix\n \n // The output for humans should just highlight the whole span without showing\n@@ -8,14 +7,14 @@\n // stripping away any starting or ending parenthesis characters\u2014hence this\n // test of the JSON error format.\n \n-#![warn(unused_parens)]\n+#![deny(unused_parens)]\n #![allow(unreachable_code)]\n \n fn main() {\n \n     let _b = false;\n \n-    if _b {\n+    if _b { //~ ERROR unnecessary parentheses\n         println!(\"hello\");\n     }\n \n@@ -26,29 +25,29 @@ fn main() {\n fn f() -> bool {\n     let c = false;\n \n-    if c {\n+    if c { //~ ERROR unnecessary parentheses\n         println!(\"next\");\n     }\n \n-    if c {\n+    if c { //~ ERROR unnecessary parentheses\n         println!(\"prev\");\n     }\n \n     while false && true {\n-        if c {\n+        if c { //~ ERROR unnecessary parentheses\n             println!(\"norm\");\n         }\n \n     }\n \n-    while true && false {\n-        for _ in 0 .. 3 {\n+    while true && false { //~ ERROR unnecessary parentheses\n+        for _ in 0 .. 3 { //~ ERROR unnecessary parentheses\n             println!(\"e~\")\n         }\n     }\n \n-    for _ in 0 .. 3 {\n-        while true && false {\n+    for _ in 0 .. 3 { //~ ERROR unnecessary parentheses\n+        while true && false { //~ ERROR unnecessary parentheses\n             println!(\"e~\")\n         }\n     }"}, {"sha": "494cd1845063012aa507356732dab1e076c23786", "filename": "src/test/ui/lint/unused_parens_remove_json_suggestion.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Flint%2Funused_parens_remove_json_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Flint%2Funused_parens_remove_json_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_parens_remove_json_suggestion.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,5 +1,4 @@\n-// compile-flags: --error-format pretty-json -Zunstable-options\n-// build-pass\n+// compile-flags: --error-format json -Zunstable-options\n // run-rustfix\n \n // The output for humans should just highlight the whole span without showing\n@@ -8,14 +7,14 @@\n // stripping away any starting or ending parenthesis characters\u2014hence this\n // test of the JSON error format.\n \n-#![warn(unused_parens)]\n+#![deny(unused_parens)]\n #![allow(unreachable_code)]\n \n fn main() {\n \n     let _b = false;\n \n-    if (_b) {\n+    if (_b) { //~ ERROR unnecessary parentheses\n         println!(\"hello\");\n     }\n \n@@ -26,29 +25,29 @@ fn main() {\n fn f() -> bool {\n     let c = false;\n \n-    if(c) {\n+    if(c) { //~ ERROR unnecessary parentheses\n         println!(\"next\");\n     }\n \n-    if (c){\n+    if (c){ //~ ERROR unnecessary parentheses\n         println!(\"prev\");\n     }\n \n     while (false && true){\n-        if (c) {\n+        if (c) { //~ ERROR unnecessary parentheses\n             println!(\"norm\");\n         }\n \n     }\n \n-    while(true && false) {\n-        for _ in (0 .. 3){\n+    while(true && false) { //~ ERROR unnecessary parentheses\n+        for _ in (0 .. 3){ //~ ERROR unnecessary parentheses\n             println!(\"e~\")\n         }\n     }\n \n-    for _ in (0 .. 3) {\n-        while (true && false) {\n+    for _ in (0 .. 3) { //~ ERROR unnecessary parentheses\n+        while (true && false) { //~ ERROR unnecessary parentheses\n             println!(\"e~\")\n         }\n     }"}, {"sha": "873f105435e089ac7566f371def087695aaaab06", "filename": "src/test/ui/lint/unused_parens_remove_json_suggestion.stderr", "status": "modified", "additions": 32, "deletions": 626, "changes": 658, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Flint%2Funused_parens_remove_json_suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Flint%2Funused_parens_remove_json_suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_parens_remove_json_suggestion.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,666 +1,72 @@\n-{\n-  \"message\": \"unnecessary parentheses around `if` condition\",\n-  \"code\": {\n-    \"code\": \"unused_parens\",\n-    \"explanation\": null\n-  },\n-  \"level\": \"warning\",\n-  \"spans\": [\n-    {\n-      \"file_name\": \"$DIR/unused_parens_remove_json_suggestion.rs\",\n-      \"byte_start\": 521,\n-      \"byte_end\": 525,\n-      \"line_start\": 18,\n-      \"line_end\": 18,\n-      \"column_start\": 8,\n-      \"column_end\": 12,\n-      \"is_primary\": true,\n-      \"text\": [\n-        {\n-          \"text\": \"    if (_b) {\",\n-          \"highlight_start\": 8,\n-          \"highlight_end\": 12\n-        }\n-      ],\n-      \"label\": null,\n-      \"suggested_replacement\": null,\n-      \"suggestion_applicability\": null,\n-      \"expansion\": null\n-    }\n-  ],\n-  \"children\": [\n-    {\n-      \"message\": \"lint level defined here\",\n-      \"code\": null,\n-      \"level\": \"note\",\n-      \"spans\": [\n-        {\n-          \"file_name\": \"$DIR/unused_parens_remove_json_suggestion.rs\",\n-          \"byte_start\": 435,\n-          \"byte_end\": 448,\n-          \"line_start\": 11,\n-          \"line_end\": 11,\n-          \"column_start\": 9,\n-          \"column_end\": 22,\n-          \"is_primary\": true,\n-          \"text\": [\n-            {\n-              \"text\": \"#![warn(unused_parens)]\",\n-              \"highlight_start\": 9,\n-              \"highlight_end\": 22\n-            }\n-          ],\n-          \"label\": null,\n-          \"suggested_replacement\": null,\n-          \"suggestion_applicability\": null,\n-          \"expansion\": null\n-        }\n-      ],\n-      \"children\": [],\n-      \"rendered\": null\n-    },\n-    {\n-      \"message\": \"remove these parentheses\",\n-      \"code\": null,\n-      \"level\": \"help\",\n-      \"spans\": [\n-        {\n-          \"file_name\": \"$DIR/unused_parens_remove_json_suggestion.rs\",\n-          \"byte_start\": 521,\n-          \"byte_end\": 525,\n-          \"line_start\": 18,\n-          \"line_end\": 18,\n-          \"column_start\": 8,\n-          \"column_end\": 12,\n-          \"is_primary\": true,\n-          \"text\": [\n-            {\n-              \"text\": \"    if (_b) {\",\n-              \"highlight_start\": 8,\n-              \"highlight_end\": 12\n-            }\n-          ],\n-          \"label\": null,\n-          \"suggested_replacement\": \"_b\",\n-          \"suggestion_applicability\": \"MachineApplicable\",\n-          \"expansion\": null\n-        }\n-      ],\n-      \"children\": [],\n-      \"rendered\": null\n-    }\n-  ],\n-  \"rendered\": \"warning: unnecessary parentheses around `if` condition\n-  --> $DIR/unused_parens_remove_json_suggestion.rs:18:8\n+{\"message\":\"unnecessary parentheses around `if` condition\",\"code\":{\"code\":\"unused_parens\",\"explanation\":null},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/unused_parens_remove_json_suggestion.rs\",\"byte_start\":500,\"byte_end\":504,\"line_start\":17,\"line_end\":17,\"column_start\":8,\"column_end\":12,\"is_primary\":true,\"text\":[{\"text\":\"    if (_b) {\n+  --> $DIR/unused_parens_remove_json_suggestion.rs:17:8\n    |\n LL |     if (_b) {\n    |        ^^^^ help: remove these parentheses\n    |\n note: lint level defined here\n-  --> $DIR/unused_parens_remove_json_suggestion.rs:11:9\n+  --> $DIR/unused_parens_remove_json_suggestion.rs:10:9\n    |\n-LL | #![warn(unused_parens)]\n+LL | #![deny(unused_parens)]\n    |         ^^^^^^^^^^^^^\n \n-\"\n-}\n-{\n-  \"message\": \"unnecessary parentheses around `if` condition\",\n-  \"code\": {\n-    \"code\": \"unused_parens\",\n-    \"explanation\": null\n-  },\n-  \"level\": \"warning\",\n-  \"spans\": [\n-    {\n-      \"file_name\": \"$DIR/unused_parens_remove_json_suggestion.rs\",\n-      \"byte_start\": 618,\n-      \"byte_end\": 621,\n-      \"line_start\": 29,\n-      \"line_end\": 29,\n-      \"column_start\": 7,\n-      \"column_end\": 10,\n-      \"is_primary\": true,\n-      \"text\": [\n-        {\n-          \"text\": \"    if(c) {\",\n-          \"highlight_start\": 7,\n-          \"highlight_end\": 10\n-        }\n-      ],\n-      \"label\": null,\n-      \"suggested_replacement\": null,\n-      \"suggestion_applicability\": null,\n-      \"expansion\": null\n-    }\n-  ],\n-  \"children\": [\n-    {\n-      \"message\": \"remove these parentheses\",\n-      \"code\": null,\n-      \"level\": \"help\",\n-      \"spans\": [\n-        {\n-          \"file_name\": \"$DIR/unused_parens_remove_json_suggestion.rs\",\n-          \"byte_start\": 618,\n-          \"byte_end\": 621,\n-          \"line_start\": 29,\n-          \"line_end\": 29,\n-          \"column_start\": 7,\n-          \"column_end\": 10,\n-          \"is_primary\": true,\n-          \"text\": [\n-            {\n-              \"text\": \"    if(c) {\",\n-              \"highlight_start\": 7,\n-              \"highlight_end\": 10\n-            }\n-          ],\n-          \"label\": null,\n-          \"suggested_replacement\": \" c\",\n-          \"suggestion_applicability\": \"MachineApplicable\",\n-          \"expansion\": null\n-        }\n-      ],\n-      \"children\": [],\n-      \"rendered\": null\n-    }\n-  ],\n-  \"rendered\": \"warning: unnecessary parentheses around `if` condition\n-  --> $DIR/unused_parens_remove_json_suggestion.rs:29:7\n+\"}\n+{\"message\":\"unnecessary parentheses around `if` condition\",\"code\":{\"code\":\"unused_parens\",\"explanation\":null},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/unused_parens_remove_json_suggestion.rs\",\"byte_start\":631,\"byte_end\":634,\"line_start\":28,\"line_end\":28,\"column_start\":7,\"column_end\":10,\"is_primary\":true,\"text\":[{\"text\":\"    if(c) {\n+  --> $DIR/unused_parens_remove_json_suggestion.rs:28:7\n    |\n LL |     if(c) {\n    |       ^^^ help: remove these parentheses\n \n-\"\n-}\n-{\n-  \"message\": \"unnecessary parentheses around `if` condition\",\n-  \"code\": {\n-    \"code\": \"unused_parens\",\n-    \"explanation\": null\n-  },\n-  \"level\": \"warning\",\n-  \"spans\": [\n-    {\n-      \"file_name\": \"$DIR/unused_parens_remove_json_suggestion.rs\",\n-      \"byte_start\": 664,\n-      \"byte_end\": 667,\n-      \"line_start\": 33,\n-      \"line_end\": 33,\n-      \"column_start\": 8,\n-      \"column_end\": 11,\n-      \"is_primary\": true,\n-      \"text\": [\n-        {\n-          \"text\": \"    if (c){\",\n-          \"highlight_start\": 8,\n-          \"highlight_end\": 11\n-        }\n-      ],\n-      \"label\": null,\n-      \"suggested_replacement\": null,\n-      \"suggestion_applicability\": null,\n-      \"expansion\": null\n-    }\n-  ],\n-  \"children\": [\n-    {\n-      \"message\": \"remove these parentheses\",\n-      \"code\": null,\n-      \"level\": \"help\",\n-      \"spans\": [\n-        {\n-          \"file_name\": \"$DIR/unused_parens_remove_json_suggestion.rs\",\n-          \"byte_start\": 664,\n-          \"byte_end\": 667,\n-          \"line_start\": 33,\n-          \"line_end\": 33,\n-          \"column_start\": 8,\n-          \"column_end\": 11,\n-          \"is_primary\": true,\n-          \"text\": [\n-            {\n-              \"text\": \"    if (c){\",\n-              \"highlight_start\": 8,\n-              \"highlight_end\": 11\n-            }\n-          ],\n-          \"label\": null,\n-          \"suggested_replacement\": \"c \",\n-          \"suggestion_applicability\": \"MachineApplicable\",\n-          \"expansion\": null\n-        }\n-      ],\n-      \"children\": [],\n-      \"rendered\": null\n-    }\n-  ],\n-  \"rendered\": \"warning: unnecessary parentheses around `if` condition\n-  --> $DIR/unused_parens_remove_json_suggestion.rs:33:8\n+\"}\n+{\"message\":\"unnecessary parentheses around `if` condition\",\"code\":{\"code\":\"unused_parens\",\"explanation\":null},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/unused_parens_remove_json_suggestion.rs\",\"byte_start\":711,\"byte_end\":714,\"line_start\":32,\"line_end\":32,\"column_start\":8,\"column_end\":11,\"is_primary\":true,\"text\":[{\"text\":\"    if (c){\n+  --> $DIR/unused_parens_remove_json_suggestion.rs:32:8\n    |\n LL |     if (c){\n    |        ^^^ help: remove these parentheses\n \n-\"\n-}\n-{\n-  \"message\": \"unnecessary parentheses around `while` condition\",\n-  \"code\": {\n-    \"code\": \"unused_parens\",\n-    \"explanation\": null\n-  },\n-  \"level\": \"warning\",\n-  \"spans\": [\n-    {\n-      \"file_name\": \"$DIR/unused_parens_remove_json_suggestion.rs\",\n-      \"byte_start\": 712,\n-      \"byte_end\": 727,\n-      \"line_start\": 37,\n-      \"line_end\": 37,\n-      \"column_start\": 11,\n-      \"column_end\": 26,\n-      \"is_primary\": true,\n-      \"text\": [\n-        {\n-          \"text\": \"    while (false && true){\",\n-          \"highlight_start\": 11,\n-          \"highlight_end\": 26\n-        }\n-      ],\n-      \"label\": null,\n-      \"suggested_replacement\": null,\n-      \"suggestion_applicability\": null,\n-      \"expansion\": null\n-    }\n-  ],\n-  \"children\": [\n-    {\n-      \"message\": \"remove these parentheses\",\n-      \"code\": null,\n-      \"level\": \"help\",\n-      \"spans\": [\n-        {\n-          \"file_name\": \"$DIR/unused_parens_remove_json_suggestion.rs\",\n-          \"byte_start\": 712,\n-          \"byte_end\": 727,\n-          \"line_start\": 37,\n-          \"line_end\": 37,\n-          \"column_start\": 11,\n-          \"column_end\": 26,\n-          \"is_primary\": true,\n-          \"text\": [\n-            {\n-              \"text\": \"    while (false && true){\",\n-              \"highlight_start\": 11,\n-              \"highlight_end\": 26\n-            }\n-          ],\n-          \"label\": null,\n-          \"suggested_replacement\": \"false && true \",\n-          \"suggestion_applicability\": \"MachineApplicable\",\n-          \"expansion\": null\n-        }\n-      ],\n-      \"children\": [],\n-      \"rendered\": null\n-    }\n-  ],\n-  \"rendered\": \"warning: unnecessary parentheses around `while` condition\n-  --> $DIR/unused_parens_remove_json_suggestion.rs:37:11\n+\"}\n+{\"message\":\"unnecessary parentheses around `while` condition\",\"code\":{\"code\":\"unused_parens\",\"explanation\":null},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/unused_parens_remove_json_suggestion.rs\",\"byte_start\":793,\"byte_end\":808,\"line_start\":36,\"line_end\":36,\"column_start\":11,\"column_end\":26,\"is_primary\":true,\"text\":[{\"text\":\"    while (false && true){\",\"highlight_start\":11,\"highlight_end\":26}],\"label\":null,\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"remove these parentheses\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/unused_parens_remove_json_suggestion.rs\",\"byte_start\":793,\"byte_end\":808,\"line_start\":36,\"line_end\":36,\"column_start\":11,\"column_end\":26,\"is_primary\":true,\"text\":[{\"text\":\"    while (false && true){\",\"highlight_start\":11,\"highlight_end\":26}],\"label\":null,\"suggested_replacement\":\"false && true \",\"suggestion_applicability\":\"MachineApplicable\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"error: unnecessary parentheses around `while` condition\n+  --> $DIR/unused_parens_remove_json_suggestion.rs:36:11\n    |\n LL |     while (false && true){\n    |           ^^^^^^^^^^^^^^^ help: remove these parentheses\n \n-\"\n-}\n-{\n-  \"message\": \"unnecessary parentheses around `if` condition\",\n-  \"code\": {\n-    \"code\": \"unused_parens\",\n-    \"explanation\": null\n-  },\n-  \"level\": \"warning\",\n-  \"spans\": [\n-    {\n-      \"file_name\": \"$DIR/unused_parens_remove_json_suggestion.rs\",\n-      \"byte_start\": 740,\n-      \"byte_end\": 743,\n-      \"line_start\": 38,\n-      \"line_end\": 38,\n-      \"column_start\": 12,\n-      \"column_end\": 15,\n-      \"is_primary\": true,\n-      \"text\": [\n-        {\n-          \"text\": \"        if (c) {\",\n-          \"highlight_start\": 12,\n-          \"highlight_end\": 15\n-        }\n-      ],\n-      \"label\": null,\n-      \"suggested_replacement\": null,\n-      \"suggestion_applicability\": null,\n-      \"expansion\": null\n-    }\n-  ],\n-  \"children\": [\n-    {\n-      \"message\": \"remove these parentheses\",\n-      \"code\": null,\n-      \"level\": \"help\",\n-      \"spans\": [\n-        {\n-          \"file_name\": \"$DIR/unused_parens_remove_json_suggestion.rs\",\n-          \"byte_start\": 740,\n-          \"byte_end\": 743,\n-          \"line_start\": 38,\n-          \"line_end\": 38,\n-          \"column_start\": 12,\n-          \"column_end\": 15,\n-          \"is_primary\": true,\n-          \"text\": [\n-            {\n-              \"text\": \"        if (c) {\",\n-              \"highlight_start\": 12,\n-              \"highlight_end\": 15\n-            }\n-          ],\n-          \"label\": null,\n-          \"suggested_replacement\": \"c\",\n-          \"suggestion_applicability\": \"MachineApplicable\",\n-          \"expansion\": null\n-        }\n-      ],\n-      \"children\": [],\n-      \"rendered\": null\n-    }\n-  ],\n-  \"rendered\": \"warning: unnecessary parentheses around `if` condition\n-  --> $DIR/unused_parens_remove_json_suggestion.rs:38:12\n+\"}\n+{\"message\":\"unnecessary parentheses around `if` condition\",\"code\":{\"code\":\"unused_parens\",\"explanation\":null},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/unused_parens_remove_json_suggestion.rs\",\"byte_start\":821,\"byte_end\":824,\"line_start\":37,\"line_end\":37,\"column_start\":12,\"column_end\":15,\"is_primary\":true,\"text\":[{\"text\":\"        if (c) {\n+  --> $DIR/unused_parens_remove_json_suggestion.rs:37:12\n    |\n LL |         if (c) {\n    |            ^^^ help: remove these parentheses\n \n-\"\n-}\n-{\n-  \"message\": \"unnecessary parentheses around `while` condition\",\n-  \"code\": {\n-    \"code\": \"unused_parens\",\n-    \"explanation\": null\n-  },\n-  \"level\": \"warning\",\n-  \"spans\": [\n-    {\n-      \"file_name\": \"$DIR/unused_parens_remove_json_suggestion.rs\",\n-      \"byte_start\": 803,\n-      \"byte_end\": 818,\n-      \"line_start\": 44,\n-      \"line_end\": 44,\n-      \"column_start\": 10,\n-      \"column_end\": 25,\n-      \"is_primary\": true,\n-      \"text\": [\n-        {\n-          \"text\": \"    while(true && false) {\",\n-          \"highlight_start\": 10,\n-          \"highlight_end\": 25\n-        }\n-      ],\n-      \"label\": null,\n-      \"suggested_replacement\": null,\n-      \"suggestion_applicability\": null,\n-      \"expansion\": null\n-    }\n-  ],\n-  \"children\": [\n-    {\n-      \"message\": \"remove these parentheses\",\n-      \"code\": null,\n-      \"level\": \"help\",\n-      \"spans\": [\n-        {\n-          \"file_name\": \"$DIR/unused_parens_remove_json_suggestion.rs\",\n-          \"byte_start\": 803,\n-          \"byte_end\": 818,\n-          \"line_start\": 44,\n-          \"line_end\": 44,\n-          \"column_start\": 10,\n-          \"column_end\": 25,\n-          \"is_primary\": true,\n-          \"text\": [\n-            {\n-              \"text\": \"    while(true && false) {\",\n-              \"highlight_start\": 10,\n-              \"highlight_end\": 25\n-            }\n-          ],\n-          \"label\": null,\n-          \"suggested_replacement\": \" true && false\",\n-          \"suggestion_applicability\": \"MachineApplicable\",\n-          \"expansion\": null\n-        }\n-      ],\n-      \"children\": [],\n-      \"rendered\": null\n-    }\n-  ],\n-  \"rendered\": \"warning: unnecessary parentheses around `while` condition\n-  --> $DIR/unused_parens_remove_json_suggestion.rs:44:10\n+\"}\n+{\"message\":\"unnecessary parentheses around `while` condition\",\"code\":{\"code\":\"unused_parens\",\"explanation\":null},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/unused_parens_remove_json_suggestion.rs\",\"byte_start\":918,\"byte_end\":933,\"line_start\":43,\"line_end\":43,\"column_start\":10,\"column_end\":25,\"is_primary\":true,\"text\":[{\"text\":\"    while(true && false) {\n+  --> $DIR/unused_parens_remove_json_suggestion.rs:43:10\n    |\n LL |     while(true && false) {\n    |          ^^^^^^^^^^^^^^^ help: remove these parentheses\n \n-\"\n-}\n-{\n-  \"message\": \"unnecessary parentheses around `for` head expression\",\n-  \"code\": {\n-    \"code\": \"unused_parens\",\n-    \"explanation\": null\n-  },\n-  \"level\": \"warning\",\n-  \"spans\": [\n-    {\n-      \"file_name\": \"$DIR/unused_parens_remove_json_suggestion.rs\",\n-      \"byte_start\": 838,\n-      \"byte_end\": 846,\n-      \"line_start\": 45,\n-      \"line_end\": 45,\n-      \"column_start\": 18,\n-      \"column_end\": 26,\n-      \"is_primary\": true,\n-      \"text\": [\n-        {\n-          \"text\": \"        for _ in (0 .. 3){\",\n-          \"highlight_start\": 18,\n-          \"highlight_end\": 26\n-        }\n-      ],\n-      \"label\": null,\n-      \"suggested_replacement\": null,\n-      \"suggestion_applicability\": null,\n-      \"expansion\": null\n-    }\n-  ],\n-  \"children\": [\n-    {\n-      \"message\": \"remove these parentheses\",\n-      \"code\": null,\n-      \"level\": \"help\",\n-      \"spans\": [\n-        {\n-          \"file_name\": \"$DIR/unused_parens_remove_json_suggestion.rs\",\n-          \"byte_start\": 838,\n-          \"byte_end\": 846,\n-          \"line_start\": 45,\n-          \"line_end\": 45,\n-          \"column_start\": 18,\n-          \"column_end\": 26,\n-          \"is_primary\": true,\n-          \"text\": [\n-            {\n-              \"text\": \"        for _ in (0 .. 3){\",\n-              \"highlight_start\": 18,\n-              \"highlight_end\": 26\n-            }\n-          ],\n-          \"label\": null,\n-          \"suggested_replacement\": \"0 .. 3 \",\n-          \"suggestion_applicability\": \"MachineApplicable\",\n-          \"expansion\": null\n-        }\n-      ],\n-      \"children\": [],\n-      \"rendered\": null\n-    }\n-  ],\n-  \"rendered\": \"warning: unnecessary parentheses around `for` head expression\n-  --> $DIR/unused_parens_remove_json_suggestion.rs:45:18\n+\"}\n+{\"message\":\"unnecessary parentheses around `for` head expression\",\"code\":{\"code\":\"unused_parens\",\"explanation\":null},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/unused_parens_remove_json_suggestion.rs\",\"byte_start\":987,\"byte_end\":995,\"line_start\":44,\"line_end\":44,\"column_start\":18,\"column_end\":26,\"is_primary\":true,\"text\":[{\"text\":\"        for _ in (0 .. 3){\n+  --> $DIR/unused_parens_remove_json_suggestion.rs:44:18\n    |\n LL |         for _ in (0 .. 3){\n    |                  ^^^^^^^^ help: remove these parentheses\n \n-\"\n-}\n-{\n-  \"message\": \"unnecessary parentheses around `for` head expression\",\n-  \"code\": {\n-    \"code\": \"unused_parens\",\n-    \"explanation\": null\n-  },\n-  \"level\": \"warning\",\n-  \"spans\": [\n-    {\n-      \"file_name\": \"$DIR/unused_parens_remove_json_suggestion.rs\",\n-      \"byte_start\": 905,\n-      \"byte_end\": 913,\n-      \"line_start\": 50,\n-      \"line_end\": 50,\n-      \"column_start\": 14,\n-      \"column_end\": 22,\n-      \"is_primary\": true,\n-      \"text\": [\n-        {\n-          \"text\": \"    for _ in (0 .. 3) {\",\n-          \"highlight_start\": 14,\n-          \"highlight_end\": 22\n-        }\n-      ],\n-      \"label\": null,\n-      \"suggested_replacement\": null,\n-      \"suggestion_applicability\": null,\n-      \"expansion\": null\n-    }\n-  ],\n-  \"children\": [\n-    {\n-      \"message\": \"remove these parentheses\",\n-      \"code\": null,\n-      \"level\": \"help\",\n-      \"spans\": [\n-        {\n-          \"file_name\": \"$DIR/unused_parens_remove_json_suggestion.rs\",\n-          \"byte_start\": 905,\n-          \"byte_end\": 913,\n-          \"line_start\": 50,\n-          \"line_end\": 50,\n-          \"column_start\": 14,\n-          \"column_end\": 22,\n-          \"is_primary\": true,\n-          \"text\": [\n-            {\n-              \"text\": \"    for _ in (0 .. 3) {\",\n-              \"highlight_start\": 14,\n-              \"highlight_end\": 22\n-            }\n-          ],\n-          \"label\": null,\n-          \"suggested_replacement\": \"0 .. 3\",\n-          \"suggestion_applicability\": \"MachineApplicable\",\n-          \"expansion\": null\n-        }\n-      ],\n-      \"children\": [],\n-      \"rendered\": null\n-    }\n-  ],\n-  \"rendered\": \"warning: unnecessary parentheses around `for` head expression\n-  --> $DIR/unused_parens_remove_json_suggestion.rs:50:14\n+\"}\n+{\"message\":\"unnecessary parentheses around `for` head expression\",\"code\":{\"code\":\"unused_parens\",\"explanation\":null},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/unused_parens_remove_json_suggestion.rs\",\"byte_start\":1088,\"byte_end\":1096,\"line_start\":49,\"line_end\":49,\"column_start\":14,\"column_end\":22,\"is_primary\":true,\"text\":[{\"text\":\"    for _ in (0 .. 3) {\n+  --> $DIR/unused_parens_remove_json_suggestion.rs:49:14\n    |\n LL |     for _ in (0 .. 3) {\n    |              ^^^^^^^^ help: remove these parentheses\n \n-\"\n-}\n-{\n-  \"message\": \"unnecessary parentheses around `while` condition\",\n-  \"code\": {\n-    \"code\": \"unused_parens\",\n-    \"explanation\": null\n-  },\n-  \"level\": \"warning\",\n-  \"spans\": [\n-    {\n-      \"file_name\": \"$DIR/unused_parens_remove_json_suggestion.rs\",\n-      \"byte_start\": 930,\n-      \"byte_end\": 945,\n-      \"line_start\": 51,\n-      \"line_end\": 51,\n-      \"column_start\": 15,\n-      \"column_end\": 30,\n-      \"is_primary\": true,\n-      \"text\": [\n-        {\n-          \"text\": \"        while (true && false) {\",\n-          \"highlight_start\": 15,\n-          \"highlight_end\": 30\n-        }\n-      ],\n-      \"label\": null,\n-      \"suggested_replacement\": null,\n-      \"suggestion_applicability\": null,\n-      \"expansion\": null\n-    }\n-  ],\n-  \"children\": [\n-    {\n-      \"message\": \"remove these parentheses\",\n-      \"code\": null,\n-      \"level\": \"help\",\n-      \"spans\": [\n-        {\n-          \"file_name\": \"$DIR/unused_parens_remove_json_suggestion.rs\",\n-          \"byte_start\": 930,\n-          \"byte_end\": 945,\n-          \"line_start\": 51,\n-          \"line_end\": 51,\n-          \"column_start\": 15,\n-          \"column_end\": 30,\n-          \"is_primary\": true,\n-          \"text\": [\n-            {\n-              \"text\": \"        while (true && false) {\",\n-              \"highlight_start\": 15,\n-              \"highlight_end\": 30\n-            }\n-          ],\n-          \"label\": null,\n-          \"suggested_replacement\": \"true && false\",\n-          \"suggestion_applicability\": \"MachineApplicable\",\n-          \"expansion\": null\n-        }\n-      ],\n-      \"children\": [],\n-      \"rendered\": null\n-    }\n-  ],\n-  \"rendered\": \"warning: unnecessary parentheses around `while` condition\n-  --> $DIR/unused_parens_remove_json_suggestion.rs:51:15\n+\"}\n+{\"message\":\"unnecessary parentheses around `while` condition\",\"code\":{\"code\":\"unused_parens\",\"explanation\":null},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/unused_parens_remove_json_suggestion.rs\",\"byte_start\":1147,\"byte_end\":1162,\"line_start\":50,\"line_end\":50,\"column_start\":15,\"column_end\":30,\"is_primary\":true,\"text\":[{\"text\":\"        while (true && false) {\n+  --> $DIR/unused_parens_remove_json_suggestion.rs:50:15\n    |\n LL |         while (true && false) {\n    |               ^^^^^^^^^^^^^^^ help: remove these parentheses\n \n-\"\n-}\n+\"}\n+{\"message\":\"aborting due to 9 previous errors\",\"code\":null,\"level\":\"error\",\"spans\":[],\"children\":[],\"rendered\":\"error: aborting due to 9 previous errors\n+\n+\"}"}, {"sha": "67ef7a62f1052453537d23a7f73a9aa7a6a955f5", "filename": "src/test/ui/object-safety/object-safety-associated-consts.curr.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-associated-consts.curr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-associated-consts.curr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-associated-consts.curr.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,5 +1,5 @@\n error[E0038]: the trait `Bar` cannot be made into an object\n-  --> $DIR/object-safety-associated-consts.rs:9:1\n+  --> $DIR/object-safety-associated-consts.rs:12:1\n    |\n LL |     const X: usize;\n    |           - the trait cannot contain associated consts like `X`", "previous_filename": "src/test/ui/object-safety/object-safety-associated-consts.stderr"}, {"sha": "20993a680ba48d52768bd64590ea7ce84b676b61", "filename": "src/test/ui/object-safety/object-safety-associated-consts.object_safe_for_dispatch.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-associated-consts.object_safe_for_dispatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-associated-consts.object_safe_for_dispatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-associated-consts.object_safe_for_dispatch.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,15 @@\n+error[E0038]: the trait `Bar` cannot be made into an object\n+  --> $DIR/object-safety-associated-consts.rs:14:5\n+   |\n+LL |     const X: usize;\n+   |           - the trait cannot contain associated consts like `X`\n+...\n+LL |     t\n+   |     ^ the trait `Bar` cannot be made into an object\n+   |\n+   = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<&dyn Bar>` for `&T`\n+   = note: required by cast to type `&dyn Bar`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0038`."}, {"sha": "e1a772e5ab2f32e2da2d32059098aa4f3fde5d67", "filename": "src/test/ui/object-safety/object-safety-associated-consts.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-associated-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-associated-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-associated-consts.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,14 +1,18 @@\n // Check that we correctly prevent users from making trait objects\n // from traits with associated consts.\n+//\n+// revisions: curr object_safe_for_dispatch\n \n+#![cfg_attr(object_safe_for_dispatch, feature(object_safe_for_dispatch))]\n \n trait Bar {\n     const X: usize;\n }\n \n fn make_bar<T:Bar>(t: &T) -> &dyn Bar {\n-    //~^ ERROR E0038\n+    //[curr]~^ ERROR E0038\n     t\n+    //[object_safe_for_dispatch]~^ ERROR E0038\n }\n \n fn main() {"}, {"sha": "8ae9236a5c3228d2a0e01cb3640801896352bd61", "filename": "src/test/ui/object-safety/object-safety-generics.curr.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-generics.curr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-generics.curr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-generics.curr.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,5 +1,5 @@\n error[E0038]: the trait `Bar` cannot be made into an object\n-  --> $DIR/object-safety-generics.rs:14:1\n+  --> $DIR/object-safety-generics.rs:18:1\n    |\n LL |     fn bar<T>(&self, t: T);\n    |        --- method `bar` has generic type parameters\n@@ -8,7 +8,7 @@ LL | fn make_bar<T:Bar>(t: &T) -> &dyn Bar {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Bar` cannot be made into an object\n \n error[E0038]: the trait `Bar` cannot be made into an object\n-  --> $DIR/object-safety-generics.rs:19:1\n+  --> $DIR/object-safety-generics.rs:24:1\n    |\n LL |     fn bar<T>(&self, t: T);\n    |        --- method `bar` has generic type parameters", "previous_filename": "src/test/ui/object-safety/object-safety-generics.stderr"}, {"sha": "d3d8d36888836bb11ace8fa71d387115d98123af", "filename": "src/test/ui/object-safety/object-safety-generics.object_safe_for_dispatch.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-generics.object_safe_for_dispatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-generics.object_safe_for_dispatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-generics.object_safe_for_dispatch.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,27 @@\n+error[E0038]: the trait `Bar` cannot be made into an object\n+  --> $DIR/object-safety-generics.rs:20:5\n+   |\n+LL |     fn bar<T>(&self, t: T);\n+   |        --- method `bar` has generic type parameters\n+...\n+LL |     t\n+   |     ^ the trait `Bar` cannot be made into an object\n+   |\n+   = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<&dyn Bar>` for `&T`\n+   = note: required by cast to type `&dyn Bar`\n+\n+error[E0038]: the trait `Bar` cannot be made into an object\n+  --> $DIR/object-safety-generics.rs:26:5\n+   |\n+LL |     fn bar<T>(&self, t: T);\n+   |        --- method `bar` has generic type parameters\n+...\n+LL |     t as &dyn Bar\n+   |     ^ the trait `Bar` cannot be made into an object\n+   |\n+   = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<&dyn Bar>` for `&T`\n+   = note: required by cast to type `&dyn Bar`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0038`."}, {"sha": "63dcd169925e411a05e03558c224b808d5fddcd4", "filename": "src/test/ui/object-safety/object-safety-generics.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-generics.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,6 +1,10 @@\n // Check that we correctly prevent users from making trait objects\n // from traits with generic methods, unless `where Self : Sized` is\n // present.\n+// revisions: curr object_safe_for_dispatch\n+\n+#![cfg_attr(object_safe_for_dispatch, feature(object_safe_for_dispatch))]\n+\n \n trait Bar {\n     fn bar<T>(&self, t: T);\n@@ -12,13 +16,15 @@ trait Quux {\n }\n \n fn make_bar<T:Bar>(t: &T) -> &dyn Bar {\n-        //~^ ERROR E0038\n+    //[curr]~^ ERROR E0038\n     t\n+    //[object_safe_for_dispatch]~^ ERROR E0038\n }\n \n fn make_bar_explicit<T:Bar>(t: &T) -> &dyn Bar {\n-    //~^ ERROR E0038\n+    //[curr]~^ ERROR E0038\n     t as &dyn Bar\n+    //[object_safe_for_dispatch]~^ ERROR E0038\n }\n \n fn make_quux<T:Quux>(t: &T) -> &dyn Quux {"}, {"sha": "297cd876187fe077aefd9ae27d870d1d192413eb", "filename": "src/test/ui/object-safety/object-safety-mentions-Self.curr.stderr", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-mentions-Self.curr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-mentions-Self.curr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-mentions-Self.curr.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,5 +1,5 @@\n error[E0038]: the trait `Bar` cannot be made into an object\n-  --> $DIR/object-safety-mentions-Self.rs:17:1\n+  --> $DIR/object-safety-mentions-Self.rs:22:1\n    |\n LL |     fn bar(&self, x: &Self);\n    |        --- method `bar` references the `Self` type in its parameters or return type\n@@ -8,10 +8,10 @@ LL | fn make_bar<T:Bar>(t: &T) -> &dyn Bar {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Bar` cannot be made into an object\n \n error[E0038]: the trait `Baz` cannot be made into an object\n-  --> $DIR/object-safety-mentions-Self.rs:22:1\n+  --> $DIR/object-safety-mentions-Self.rs:28:1\n    |\n-LL |     fn bar(&self) -> Self;\n-   |        --- method `bar` references the `Self` type in its parameters or return type\n+LL |     fn baz(&self) -> Self;\n+   |        --- method `baz` references the `Self` type in its parameters or return type\n ...\n LL | fn make_baz<T:Baz>(t: &T) -> &dyn Baz {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Baz` cannot be made into an object", "previous_filename": "src/test/ui/object-safety/object-safety-mentions-Self.stderr"}, {"sha": "03b2b8da07533b8b30738f2d7d3544d4eb505235", "filename": "src/test/ui/object-safety/object-safety-mentions-Self.object_safe_for_dispatch.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-mentions-Self.object_safe_for_dispatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-mentions-Self.object_safe_for_dispatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-mentions-Self.object_safe_for_dispatch.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,27 @@\n+error[E0038]: the trait `Bar` cannot be made into an object\n+  --> $DIR/object-safety-mentions-Self.rs:24:5\n+   |\n+LL |     fn bar(&self, x: &Self);\n+   |        --- method `bar` references the `Self` type in its parameters or return type\n+...\n+LL |     t\n+   |     ^ the trait `Bar` cannot be made into an object\n+   |\n+   = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<&dyn Bar>` for `&T`\n+   = note: required by cast to type `&dyn Bar`\n+\n+error[E0038]: the trait `Baz` cannot be made into an object\n+  --> $DIR/object-safety-mentions-Self.rs:30:5\n+   |\n+LL |     fn baz(&self) -> Self;\n+   |        --- method `baz` references the `Self` type in its parameters or return type\n+...\n+LL |     t\n+   |     ^ the trait `Baz` cannot be made into an object\n+   |\n+   = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<&dyn Baz>` for `&T`\n+   = note: required by cast to type `&dyn Baz`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0038`."}, {"sha": "412d16ff3c7ce6dd3fed5faf636d541c7cf7f904", "filename": "src/test/ui/object-safety/object-safety-mentions-Self.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-mentions-Self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-mentions-Self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-mentions-Self.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,27 +1,34 @@\n // Check that we correctly prevent users from making trait objects\n // form traits that make use of `Self` in an argument or return\n // position, unless `where Self : Sized` is present..\n+//\n+// revisions: curr object_safe_for_dispatch\n+\n+#![cfg_attr(object_safe_for_dispatch, feature(object_safe_for_dispatch))]\n+\n \n trait Bar {\n     fn bar(&self, x: &Self);\n }\n \n trait Baz {\n-    fn bar(&self) -> Self;\n+    fn baz(&self) -> Self;\n }\n \n trait Quux {\n-    fn get(&self, s: &Self) -> Self where Self : Sized;\n+    fn quux(&self, s: &Self) -> Self where Self : Sized;\n }\n \n fn make_bar<T:Bar>(t: &T) -> &dyn Bar {\n-        //~^ ERROR E0038\n-    loop { }\n+    //[curr]~^ ERROR E0038\n+    t\n+    //[object_safe_for_dispatch]~^ ERROR E0038\n }\n \n fn make_baz<T:Baz>(t: &T) -> &dyn Baz {\n-        //~^ ERROR E0038\n+    //[curr]~^ ERROR E0038\n     t\n+    //[object_safe_for_dispatch]~^ ERROR E0038\n }\n \n fn make_quux<T:Quux>(t: &T) -> &dyn Quux {\n@@ -32,5 +39,4 @@ fn make_quux_explicit<T:Quux>(t: &T) -> &dyn Quux {\n     t as &dyn Quux\n }\n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "1641ce577719e80b22bf45e273c1a43cf0b52e76", "filename": "src/test/ui/object-safety/object-safety-no-static.curr.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-no-static.curr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-no-static.curr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-no-static.curr.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,12 @@\n+error[E0038]: the trait `Foo` cannot be made into an object\n+  --> $DIR/object-safety-no-static.rs:12:1\n+   |\n+LL |     fn foo() {}\n+   |        --- associated function `foo` has no `self` parameter\n+...\n+LL | fn diverges() -> Box<dyn Foo> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Foo` cannot be made into an object\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0038`."}, {"sha": "91a9285b63cccf01cad52bd05e4245b300429764", "filename": "src/test/ui/object-safety/object-safety-no-static.object_safe_for_dispatch.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-no-static.object_safe_for_dispatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-no-static.object_safe_for_dispatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-no-static.object_safe_for_dispatch.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,15 @@\n+error[E0038]: the trait `Foo` cannot be made into an object\n+  --> $DIR/object-safety-no-static.rs:22:27\n+   |\n+LL |     fn foo() {}\n+   |        --- associated function `foo` has no `self` parameter\n+...\n+LL |     let b: Box<dyn Foo> = Box::new(Bar);\n+   |                           ^^^^^^^^^^^^^ the trait `Foo` cannot be made into an object\n+   |\n+   = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<std::boxed::Box<dyn Foo>>` for `std::boxed::Box<Bar>`\n+   = note: required by cast to type `std::boxed::Box<dyn Foo>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0038`."}, {"sha": "03b6221748388622375091b35e177791040f6e85", "filename": "src/test/ui/object-safety/object-safety-no-static.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-no-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-no-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-no-static.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,14 +1,24 @@\n // Check that we correctly prevent users from making trait objects\n // from traits with static methods.\n+//\n+// revisions: curr object_safe_for_dispatch\n+\n+#![cfg_attr(object_safe_for_dispatch, feature(object_safe_for_dispatch))]\n \n trait Foo {\n-    fn foo();\n+    fn foo() {}\n }\n \n-fn foo_implicit<T:Foo+'static>(b: Box<T>) -> Box<dyn Foo + 'static> {\n-    //~^ ERROR E0038\n+fn diverges() -> Box<dyn Foo> {\n+    //[curr]~^ ERROR E0038\n     loop { }\n }\n \n+struct Bar;\n+\n+impl Foo for Bar {}\n+\n fn main() {\n+    let b: Box<dyn Foo> = Box::new(Bar);\n+    //[object_safe_for_dispatch]~^ ERROR E0038\n }"}, {"sha": "1e1d2bf64c42740da3a8facbfb9a1ec3d9708ebf", "filename": "src/test/ui/object-safety/object-safety-sized-2.curr.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized-2.curr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized-2.curr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized-2.curr.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,5 +1,5 @@\n error[E0038]: the trait `Bar` cannot be made into an object\n-  --> $DIR/object-safety-sized-2.rs:10:1\n+  --> $DIR/object-safety-sized-2.rs:14:1\n    |\n LL | fn make_bar<T:Bar>(t: &T) -> &dyn Bar {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Bar` cannot be made into an object", "previous_filename": "src/test/ui/object-safety/object-safety-sized-2.stderr"}, {"sha": "06ecfd019c841b7fcc8e4883f59bb7773ec29b69", "filename": "src/test/ui/object-safety/object-safety-sized-2.object_safe_for_dispatch.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized-2.object_safe_for_dispatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized-2.object_safe_for_dispatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized-2.object_safe_for_dispatch.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,13 @@\n+error[E0038]: the trait `Bar` cannot be made into an object\n+  --> $DIR/object-safety-sized-2.rs:16:5\n+   |\n+LL |     t\n+   |     ^ the trait `Bar` cannot be made into an object\n+   |\n+   = note: the trait cannot require that `Self : Sized`\n+   = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<&dyn Bar>` for `&T`\n+   = note: required by cast to type `&dyn Bar`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0038`."}, {"sha": "1e79b8cd917c7f07a09040b0fc600378b0b82954", "filename": "src/test/ui/object-safety/object-safety-sized-2.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized-2.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,5 +1,9 @@\n // Check that we correctly prevent users from making trait objects\n // from traits where `Self : Sized`.\n+//\n+// revisions: curr object_safe_for_dispatch\n+\n+#![cfg_attr(object_safe_for_dispatch, feature(object_safe_for_dispatch))]\n \n trait Bar\n     where Self : Sized\n@@ -8,8 +12,9 @@ trait Bar\n }\n \n fn make_bar<T:Bar>(t: &T) -> &dyn Bar {\n-        //~^ ERROR E0038\n-    loop { }\n+    //[curr]~^ ERROR E0038\n+    t\n+    //[object_safe_for_dispatch]~^ ERROR E0038\n }\n \n fn main() {"}, {"sha": "1a67e79e83d32d4ce9fd65252f9f98f1cb43d86c", "filename": "src/test/ui/object-safety/object-safety-sized.curr.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized.curr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized.curr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized.curr.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,5 +1,5 @@\n error[E0038]: the trait `Bar` cannot be made into an object\n-  --> $DIR/object-safety-sized.rs:8:1\n+  --> $DIR/object-safety-sized.rs:12:1\n    |\n LL | fn make_bar<T:Bar>(t: &T) -> &dyn Bar {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Bar` cannot be made into an object", "previous_filename": "src/test/ui/object-safety/object-safety-sized.stderr"}, {"sha": "3d88dfc40ed385eb40eda611c9f8d7e6744b0740", "filename": "src/test/ui/object-safety/object-safety-sized.object_safe_for_dispatch.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized.object_safe_for_dispatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized.object_safe_for_dispatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized.object_safe_for_dispatch.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,13 @@\n+error[E0038]: the trait `Bar` cannot be made into an object\n+  --> $DIR/object-safety-sized.rs:14:5\n+   |\n+LL |     t\n+   |     ^ the trait `Bar` cannot be made into an object\n+   |\n+   = note: the trait cannot require that `Self : Sized`\n+   = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<&dyn Bar>` for `&T`\n+   = note: required by cast to type `&dyn Bar`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0038`."}, {"sha": "b424b892d3b4525cb4b7b4b295b77e70d2a9e571", "filename": "src/test/ui/object-safety/object-safety-sized.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,13 +1,18 @@\n // Check that we correctly prevent users from making trait objects\n // from traits where `Self : Sized`.\n+//\n+// revisions: curr object_safe_for_dispatch\n+\n+#![cfg_attr(object_safe_for_dispatch, feature(object_safe_for_dispatch))]\n \n trait Bar : Sized {\n     fn bar<T>(&self, t: T);\n }\n \n fn make_bar<T:Bar>(t: &T) -> &dyn Bar {\n-        //~^ ERROR E0038\n+    //[curr]~^ ERROR E0038\n     t\n+    //[object_safe_for_dispatch]~^ ERROR E0038\n }\n \n fn main() {"}, {"sha": "df001d6b5f2a4c0ed8b40bcd22914a506747f35b", "filename": "src/test/ui/repr/repr-packed-contains-align.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Frepr%2Frepr-packed-contains-align.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Frepr%2Frepr-packed-contains-align.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepr%2Frepr-packed-contains-align.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -56,3 +56,4 @@ LL | | }\n \n error: aborting due to 8 previous errors\n \n+For more information about this error, try `rustc --explain E0588`."}, {"sha": "fa04f4b12d5fe603f1b455c7467f3ba1a4518b31", "filename": "src/test/ui/rfc-2027-object-safe-for-dispatch/downcast-unsafe-trait-objects.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Frfc-2027-object-safe-for-dispatch%2Fdowncast-unsafe-trait-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Frfc-2027-object-safe-for-dispatch%2Fdowncast-unsafe-trait-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2027-object-safe-for-dispatch%2Fdowncast-unsafe-trait-objects.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,23 @@\n+// Check that we if we get ahold of an object unsafe trait\n+// object with auto traits and lifetimes, we can downcast it\n+//\n+// check-pass\n+\n+#![feature(object_safe_for_dispatch)]\n+\n+trait Trait: Sized {}\n+\n+fn downcast_auto(t: &(dyn Trait + Send)) -> &dyn Trait {\n+    t\n+}\n+\n+fn downcast_lifetime<'a, 'b, 't>(t: &'a (dyn Trait + 't))\n+                                 -> &'b (dyn Trait + 't)\n+where\n+    'a: 'b,\n+    't: 'a + 'b,\n+{\n+    t\n+}\n+\n+fn main() {}"}, {"sha": "1dea40122656927d57648b81983b3c7757f342a5", "filename": "src/test/ui/rfc-2027-object-safe-for-dispatch/manual-self-impl-for-unsafe-obj.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Frfc-2027-object-safe-for-dispatch%2Fmanual-self-impl-for-unsafe-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Frfc-2027-object-safe-for-dispatch%2Fmanual-self-impl-for-unsafe-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2027-object-safe-for-dispatch%2Fmanual-self-impl-for-unsafe-obj.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,69 @@\n+// Check that we can manually implement an object\n+// unsafe trait for its trait object\n+//\n+// run-pass\n+\n+#![feature(object_safe_for_dispatch)]\n+\n+trait Bad {\n+    fn stat() -> char {\n+        'A'\n+    }\n+    fn virt(&self) -> char {\n+        'B'\n+    }\n+    fn indirect(&self) -> char {\n+        Self::stat()\n+    }\n+}\n+\n+trait Good {\n+    fn good_virt(&self) -> char {\n+        panic!()\n+    }\n+    fn good_indirect(&self) -> char {\n+        panic!()\n+    }\n+}\n+\n+impl<'a> Bad for dyn Bad + 'a {\n+    fn stat() -> char {\n+        'C'\n+    }\n+    fn virt(&self) -> char {\n+        'D'\n+    }\n+}\n+\n+struct Struct {}\n+\n+impl Bad for Struct {}\n+\n+impl Good for Struct {}\n+\n+fn main() {\n+    let s = Struct {};\n+\n+    let mut res = String::new();\n+\n+    // Directly call static\n+    res.push(Struct::stat()); // \"A\"\n+    res.push(<dyn Bad>::stat()); // \"AC\"\n+\n+    let good: &dyn Good = &s;\n+\n+    // These look similar enough...\n+    let bad = unsafe { std::mem::transmute::<&dyn Good, &dyn Bad>(good) };\n+\n+    // Call virtual\n+    res.push(s.virt()); // \"ACB\"\n+    res.push(bad.virt()); // \"ACBD\"\n+\n+    // Indirectly call static\n+    res.push(s.indirect()); // \"ACBDA\"\n+    res.push(bad.indirect()); // \"ACBDAC\"\n+\n+    if &res != \"ACBDAC\" {\n+        panic!();\n+    }\n+}"}, {"sha": "df97d2c13278e941005d900ab4b5af0db3b49beb", "filename": "src/test/ui/rfc-2027-object-safe-for-dispatch/static-dispatch-unsafe-object.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Frfc-2027-object-safe-for-dispatch%2Fstatic-dispatch-unsafe-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Frfc-2027-object-safe-for-dispatch%2Fstatic-dispatch-unsafe-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2027-object-safe-for-dispatch%2Fstatic-dispatch-unsafe-object.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,37 @@\n+// Check that we can statically dispatch methods for object\n+// unsafe trait objects, directly and indirectly\n+//\n+// check-pass\n+\n+#![feature(object_safe_for_dispatch)]\n+\n+trait Statics {\n+    fn plain() {}\n+    fn generic<T>() {}\n+}\n+\n+trait Trait: Sized {}\n+\n+impl<'a> Statics for dyn Trait + 'a {}\n+\n+fn static_poly<T: Statics + ?Sized>() {\n+    T::plain();\n+    T::generic::<usize>();\n+}\n+\n+fn inferred_poly<T: Statics + ?Sized>(t: &T) {\n+    static_poly::<T>();\n+    T::plain();\n+    T::generic::<usize>();\n+}\n+\n+fn call(t: &dyn Trait) {\n+    static_poly::<dyn Trait>();\n+    inferred_poly(t);\n+}\n+\n+fn main() {\n+    static_poly::<dyn Trait>();\n+    <dyn Trait>::plain();\n+    <dyn Trait>::generic::<usize>()\n+}"}, {"sha": "cdffc1d86edfb965bde49898d41a014587c446a1", "filename": "src/test/ui/self/arbitrary-self-types-not-object-safe.curr.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fself%2Farbitrary-self-types-not-object-safe.curr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fself%2Farbitrary-self-types-not-object-safe.curr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary-self-types-not-object-safe.curr.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,24 @@\n+error[E0038]: the trait `Foo` cannot be made into an object\n+  --> $DIR/arbitrary-self-types-not-object-safe.rs:34:32\n+   |\n+LL |     fn foo(self: &Rc<Self>) -> usize;\n+   |        --- method `foo`'s `self` parameter cannot be dispatched on\n+...\n+LL |     let x = Rc::new(5usize) as Rc<dyn Foo>;\n+   |                                ^^^^^^^^^^^ the trait `Foo` cannot be made into an object\n+\n+error[E0038]: the trait `Foo` cannot be made into an object\n+  --> $DIR/arbitrary-self-types-not-object-safe.rs:34:13\n+   |\n+LL |     fn foo(self: &Rc<Self>) -> usize;\n+   |        --- method `foo`'s `self` parameter cannot be dispatched on\n+...\n+LL |     let x = Rc::new(5usize) as Rc<dyn Foo>;\n+   |             ^^^^^^^^^^^^^^^ the trait `Foo` cannot be made into an object\n+   |\n+   = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<std::rc::Rc<dyn Foo>>` for `std::rc::Rc<usize>`\n+   = note: required by cast to type `std::rc::Rc<dyn Foo>`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0038`."}, {"sha": "725632a12126e5e6ab538030229646895f1056e4", "filename": "src/test/ui/self/arbitrary-self-types-not-object-safe.object_safe_for_dispatch.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fself%2Farbitrary-self-types-not-object-safe.object_safe_for_dispatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fself%2Farbitrary-self-types-not-object-safe.object_safe_for_dispatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary-self-types-not-object-safe.object_safe_for_dispatch.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,15 @@\n+error[E0038]: the trait `Foo` cannot be made into an object\n+  --> $DIR/arbitrary-self-types-not-object-safe.rs:34:13\n+   |\n+LL |     fn foo(self: &Rc<Self>) -> usize;\n+   |        --- method `foo`'s `self` parameter cannot be dispatched on\n+...\n+LL |     let x = Rc::new(5usize) as Rc<dyn Foo>;\n+   |             ^^^^^^^^^^^^^^^ the trait `Foo` cannot be made into an object\n+   |\n+   = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<std::rc::Rc<dyn Foo>>` for `std::rc::Rc<usize>`\n+   = note: required by cast to type `std::rc::Rc<dyn Foo>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0038`."}, {"sha": "2eeabad28db0202507f3706b2c15a411e9f8a276", "filename": "src/test/ui/self/arbitrary-self-types-not-object-safe.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fself%2Farbitrary-self-types-not-object-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fself%2Farbitrary-self-types-not-object-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary-self-types-not-object-safe.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1,3 +1,6 @@\n+// revisions: curr object_safe_for_dispatch\n+\n+#![cfg_attr(object_safe_for_dispatch, feature(object_safe_for_dispatch))]\n #![feature(arbitrary_self_types)]\n \n use std::rc::Rc;\n@@ -29,8 +32,9 @@ impl Bar for usize {\n \n fn make_foo() {\n     let x = Rc::new(5usize) as Rc<dyn Foo>;\n-    //~^ ERROR E0038\n-    //~| ERROR E0038\n+    //[curr]~^ ERROR E0038\n+    //[curr]~| ERROR E0038\n+    //[object_safe_for_dispatch]~^^^ ERROR E0038\n }\n \n fn make_bar() {"}, {"sha": "8fef66eac8de208d568ce678af9b4af32831383e", "filename": "src/test/ui/signal-alternate-stack-cleanup.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fsignal-alternate-stack-cleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fsignal-alternate-stack-cleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsignal-alternate-stack-cleanup.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -7,6 +7,7 @@\n // ignore-wasm32-bare no libc\n // ignore-windows\n // ignore-sgx no libc\n+// ignore-vxworks no SIGWINCH in user space\n \n #![feature(rustc_private)]\n extern crate libc;"}, {"sha": "680a690ba34e32a4d58077e26988a69f6e16a700", "filename": "src/test/ui/structs-enums/rec-align-u64.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fstructs-enums%2Frec-align-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fstructs-enums%2Frec-align-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Frec-align-u64.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -40,7 +40,8 @@ struct Outer {\n           target_os = \"macos\",\n           target_os = \"netbsd\",\n           target_os = \"openbsd\",\n-          target_os = \"solaris\"))]\n+          target_os = \"solaris\",\n+          target_os = \"vxworks\"))]\n mod m {\n     #[cfg(target_arch = \"x86\")]\n     pub mod m {"}, {"sha": "028e9eedd641a227cd11e60ee2bf952c260d8aa0", "filename": "src/test/ui/traits/trait-object-safety.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-safety.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-safety.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-safety.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -8,6 +8,7 @@ LL |     let _: &dyn Tr = &St;\n    |                      ^^^ the trait `Tr` cannot be made into an object\n    |\n    = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<&dyn Tr>` for `&St`\n+   = note: required by cast to type `&dyn Tr`\n \n error[E0038]: the trait `Tr` cannot be made into an object\n   --> $DIR/trait-object-safety.rs:15:12"}, {"sha": "9b750d382ec962b227c4b4735ef48b1932ca9632", "filename": "src/test/ui/traits/trait-test-2.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Ftraits%2Ftrait-test-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Ftraits%2Ftrait-test-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-test-2.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -33,6 +33,7 @@ LL |     (box 10 as Box<dyn bar>).dup();\n    |      ^^^^^^ the trait `bar` cannot be made into an object\n    |\n    = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<std::boxed::Box<dyn bar>>` for `std::boxed::Box<{integer}>`\n+   = note: required by cast to type `std::boxed::Box<dyn bar>`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "12eb75ae4c019d4b07987ef38c35109e8696d7fc", "filename": "src/test/ui/type-alias-impl-trait/issue-65679-inst-opaque-ty-from-val-twice.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65679-inst-opaque-ty-from-val-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65679-inst-opaque-ty-from-val-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65679-inst-opaque-ty-from-val-twice.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,17 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+type T = impl Sized;\n+// The concrete type referred by impl-trait-type-alias(`T`) is guaranteed\n+// to be the same as where it occurs, whereas `impl Trait`'s instance is location sensitive;\n+// so difference assertion should not be declared on impl-trait-type-alias's instances.\n+// for details, check RFC-2515:\n+// https://github.com/rust-lang/rfcs/blob/master/text/2515-type_alias_impl_trait.md\n+\n+fn take(_: fn() -> T) {}\n+\n+fn main() {\n+    take(|| {});\n+    take(|| {});\n+}"}, {"sha": "ffdb49a3be5c7219a59d786754b7e528c389f896", "filename": "src/test/ui/wf/wf-convert-unsafe-trait-obj-box.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fwf%2Fwf-convert-unsafe-trait-obj-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fwf%2Fwf-convert-unsafe-trait-obj-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-convert-unsafe-trait-obj-box.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,18 @@\n+// Check that we do not allow casts or coercions\n+// to object unsafe trait objects inside a Box\n+\n+#![feature(object_safe_for_dispatch)]\n+\n+trait Trait: Sized {}\n+\n+struct S;\n+\n+impl Trait for S {}\n+\n+fn takes_box(t: Box<dyn Trait>) {}\n+\n+fn main() {\n+    Box::new(S) as Box<dyn Trait>; //~ ERROR E0038\n+    let t_box: Box<dyn Trait> = Box::new(S); //~ ERROR E0038\n+    takes_box(Box::new(S)); //~ ERROR E0038\n+}"}, {"sha": "0b63aef2bce1077110a722478c4f15c60b0124f1", "filename": "src/test/ui/wf/wf-convert-unsafe-trait-obj-box.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fwf%2Fwf-convert-unsafe-trait-obj-box.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fwf%2Fwf-convert-unsafe-trait-obj-box.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-convert-unsafe-trait-obj-box.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,33 @@\n+error[E0038]: the trait `Trait` cannot be made into an object\n+  --> $DIR/wf-convert-unsafe-trait-obj-box.rs:16:33\n+   |\n+LL |     let t_box: Box<dyn Trait> = Box::new(S);\n+   |                                 ^^^^^^^^^^^ the trait `Trait` cannot be made into an object\n+   |\n+   = note: the trait cannot require that `Self : Sized`\n+   = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<std::boxed::Box<dyn Trait>>` for `std::boxed::Box<S>`\n+   = note: required by cast to type `std::boxed::Box<dyn Trait>`\n+\n+error[E0038]: the trait `Trait` cannot be made into an object\n+  --> $DIR/wf-convert-unsafe-trait-obj-box.rs:17:15\n+   |\n+LL |     takes_box(Box::new(S));\n+   |               ^^^^^^^^^^^ the trait `Trait` cannot be made into an object\n+   |\n+   = note: the trait cannot require that `Self : Sized`\n+   = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<std::boxed::Box<dyn Trait>>` for `std::boxed::Box<S>`\n+   = note: required by cast to type `std::boxed::Box<(dyn Trait + 'static)>`\n+\n+error[E0038]: the trait `Trait` cannot be made into an object\n+  --> $DIR/wf-convert-unsafe-trait-obj-box.rs:15:5\n+   |\n+LL |     Box::new(S) as Box<dyn Trait>;\n+   |     ^^^^^^^^^^^ the trait `Trait` cannot be made into an object\n+   |\n+   = note: the trait cannot require that `Self : Sized`\n+   = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<std::boxed::Box<dyn Trait>>` for `std::boxed::Box<S>`\n+   = note: required by cast to type `std::boxed::Box<dyn Trait>`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0038`."}, {"sha": "143b854ed6b2d344a8b2c73c56d55086264fad01", "filename": "src/test/ui/wf/wf-convert-unsafe-trait-obj.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fwf%2Fwf-convert-unsafe-trait-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fwf%2Fwf-convert-unsafe-trait-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-convert-unsafe-trait-obj.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,18 @@\n+// Check that we do not allow casts or coercions\n+// to object unsafe trait objects by ref\n+\n+#![feature(object_safe_for_dispatch)]\n+\n+trait Trait: Sized {}\n+\n+struct S;\n+\n+impl Trait for S {}\n+\n+fn takes_trait(t: &dyn Trait) {}\n+\n+fn main() {\n+    &S as &dyn Trait; //~ ERROR E0038\n+    let t: &dyn Trait = &S; //~ ERROR E0038\n+    takes_trait(&S); //~ ERROR E0038\n+}"}, {"sha": "7aeefd731fb28d6afbcbb997201edf4612167e6b", "filename": "src/test/ui/wf/wf-convert-unsafe-trait-obj.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fwf%2Fwf-convert-unsafe-trait-obj.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fwf%2Fwf-convert-unsafe-trait-obj.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-convert-unsafe-trait-obj.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,33 @@\n+error[E0038]: the trait `Trait` cannot be made into an object\n+  --> $DIR/wf-convert-unsafe-trait-obj.rs:16:25\n+   |\n+LL |     let t: &dyn Trait = &S;\n+   |                         ^^ the trait `Trait` cannot be made into an object\n+   |\n+   = note: the trait cannot require that `Self : Sized`\n+   = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<&dyn Trait>` for `&S`\n+   = note: required by cast to type `&dyn Trait`\n+\n+error[E0038]: the trait `Trait` cannot be made into an object\n+  --> $DIR/wf-convert-unsafe-trait-obj.rs:17:17\n+   |\n+LL |     takes_trait(&S);\n+   |                 ^^ the trait `Trait` cannot be made into an object\n+   |\n+   = note: the trait cannot require that `Self : Sized`\n+   = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<&dyn Trait>` for `&S`\n+   = note: required by cast to type `&dyn Trait`\n+\n+error[E0038]: the trait `Trait` cannot be made into an object\n+  --> $DIR/wf-convert-unsafe-trait-obj.rs:15:5\n+   |\n+LL |     &S as &dyn Trait;\n+   |     ^^ the trait `Trait` cannot be made into an object\n+   |\n+   = note: the trait cannot require that `Self : Sized`\n+   = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<&dyn Trait>` for `&S`\n+   = note: required by cast to type `&dyn Trait`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0038`."}, {"sha": "c8731a8ecafa4fb57eac79fe31970082ccdf5376", "filename": "src/test/ui/wf/wf-unsafe-trait-obj-match.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fwf%2Fwf-unsafe-trait-obj-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fwf%2Fwf-unsafe-trait-obj-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-unsafe-trait-obj-match.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,29 @@\n+// Check that we do not allow coercions to object\n+// unsafe trait objects in match arms\n+\n+#![feature(object_safe_for_dispatch)]\n+\n+trait Trait: Sized {}\n+\n+struct S;\n+\n+impl Trait for S {}\n+\n+struct R;\n+\n+impl Trait for R {}\n+\n+fn opt() -> Option<()> {\n+    Some(())\n+}\n+\n+fn main() {\n+    match opt() {\n+        Some(()) => &S,\n+        None => &R,  //~ ERROR E0308\n+    }\n+    let t: &dyn Trait = match opt() { //~ ERROR E0038\n+        Some(()) => &S, //~ ERROR E0038\n+        None => &R,\n+    };\n+}"}, {"sha": "185b1e6c36b5569068fdbb77ef0d4248daeb15fa", "filename": "src/test/ui/wf/wf-unsafe-trait-obj-match.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fwf%2Fwf-unsafe-trait-obj-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftest%2Fui%2Fwf%2Fwf-unsafe-trait-obj-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-unsafe-trait-obj-match.stderr?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -0,0 +1,38 @@\n+error[E0308]: match arms have incompatible types\n+  --> $DIR/wf-unsafe-trait-obj-match.rs:23:17\n+   |\n+LL | /     match opt() {\n+LL | |         Some(()) => &S,\n+   | |                     -- this is found to be of type `&S`\n+LL | |         None => &R,\n+   | |                 ^^ expected struct `S`, found struct `R`\n+LL | |     }\n+   | |_____- `match` arms have incompatible types\n+   |\n+   = note: expected type `&S`\n+              found type `&R`\n+\n+error[E0038]: the trait `Trait` cannot be made into an object\n+  --> $DIR/wf-unsafe-trait-obj-match.rs:26:21\n+   |\n+LL |         Some(()) => &S,\n+   |                     ^^ the trait `Trait` cannot be made into an object\n+   |\n+   = note: the trait cannot require that `Self : Sized`\n+   = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<&dyn Trait>` for `&S`\n+   = note: required by cast to type `&dyn Trait`\n+\n+error[E0038]: the trait `Trait` cannot be made into an object\n+  --> $DIR/wf-unsafe-trait-obj-match.rs:25:25\n+   |\n+LL |     let t: &dyn Trait = match opt() {\n+   |                         ^^^^^^^^^^^ the trait `Trait` cannot be made into an object\n+   |\n+   = note: the trait cannot require that `Self : Sized`\n+   = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<&dyn Trait>` for `&R`\n+   = note: required by cast to type `&dyn Trait`\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0038, E0308.\n+For more information about an error, try `rustc --explain E0038`."}, {"sha": "2a189a92f4b129825aafed07a8e0103aaf5b9253", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -401,6 +401,7 @@ impl Builder {\n     fn add_packages_to(&mut self, manifest: &mut Manifest) {\n         let mut package = |name, targets| self.package(name, &mut manifest.pkg, targets);\n         package(\"rustc\", HOSTS);\n+        package(\"rustc-dev\", HOSTS);\n         package(\"cargo\", HOSTS);\n         package(\"rust-mingw\", MINGW);\n         package(\"rust-std\", TARGETS);\n@@ -428,6 +429,13 @@ impl Builder {\n             \"rls-preview\", \"rust-src\", \"llvm-tools-preview\",\n             \"lldb-preview\", \"rust-analysis\", \"miri-preview\"\n         ]);\n+\n+        // The compiler libraries are not stable for end users, but `rustc-dev` was only recently\n+        // split out of `rust-std`. We'll include it by default as a transition for nightly users.\n+        if self.rust_release == \"nightly\" {\n+            self.extend_profile(\"default\", &mut manifest.profiles, &[\"rustc-dev\"]);\n+            self.extend_profile(\"complete\", &mut manifest.profiles, &[\"rustc-dev\"]);\n+        }\n     }\n \n     fn add_renames_to(&self, manifest: &mut Manifest) {\n@@ -483,6 +491,15 @@ impl Builder {\n             components.push(host_component(\"rust-mingw\"));\n         }\n \n+        // The compiler libraries are not stable for end users, but `rustc-dev` was only recently\n+        // split out of `rust-std`. We'll include it by default as a transition for nightly users,\n+        // but ship it as an optional component on the beta and stable channels.\n+        if self.rust_release == \"nightly\" {\n+            components.push(host_component(\"rustc-dev\"));\n+        } else {\n+            extensions.push(host_component(\"rustc-dev\"));\n+        }\n+\n         // Tools are always present in the manifest,\n         // but might be marked as unavailable if they weren't built.\n         extensions.extend(vec![\n@@ -500,6 +517,11 @@ impl Builder {\n                 .filter(|&&target| target != host)\n                 .map(|target| Component::from_str(\"rust-std\", target))\n         );\n+        extensions.extend(\n+            HOSTS.iter()\n+                .filter(|&&target| target != host)\n+                .map(|target| Component::from_str(\"rustc-dev\", target))\n+        );\n         extensions.push(Component::from_str(\"rust-src\", \"*\"));\n \n         // If the components/extensions don't actually exist for this\n@@ -536,6 +558,14 @@ impl Builder {\n         dst.insert(profile_name.to_owned(), pkgs.iter().map(|s| (*s).to_owned()).collect());\n     }\n \n+    fn extend_profile(&mut self,\n+               profile_name: &str,\n+               dst: &mut BTreeMap<String, Vec<String>>,\n+               pkgs: &[&str]) {\n+        dst.get_mut(profile_name).expect(\"existing profile\")\n+            .extend(pkgs.iter().map(|s| (*s).to_owned()));\n+    }\n+\n     fn package(&mut self,\n                pkgname: &str,\n                dst: &mut BTreeMap<String, Package>,"}, {"sha": "3ba5f27170db10af7a92f2b682e049397197b8fa", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1 +1 @@\n-Subproject commit 3a9abe3f065554a7fbc59f440df2baba4a6e47ee\n+Subproject commit 3ba5f27170db10af7a92f2b682e049397197b8fa"}, {"sha": "e8d5a9e95c145a3a9be89c582d8a6f88d4ea7037", "filename": "src/tools/clippy", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -1 +1 @@\n-Subproject commit cbedd97b3a58023eff365a2fa74700d06115144a\n+Subproject commit e8d5a9e95c145a3a9be89c582d8a6f88d4ea7037"}, {"sha": "79c98b780eb65ba1fb0904159379e5e71f7c9b63", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d349e32fc70da197918256c29a0858fe7e1a6588/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=d349e32fc70da197918256c29a0858fe7e1a6588", "patch": "@@ -126,7 +126,6 @@ fn check(cache: &mut Cache,\n     // FIXME(#32129)\n     if file.ends_with(\"std/string/struct.String.html\") ||\n        file.ends_with(\"interpret/struct.ImmTy.html\") ||\n-       file.ends_with(\"symbol/struct.InternedString.html\") ||\n        file.ends_with(\"ast/struct.ThinVec.html\") ||\n        file.ends_with(\"util/struct.ThinVec.html\") ||\n        file.ends_with(\"layout/struct.TyLayout.html\") ||"}]}