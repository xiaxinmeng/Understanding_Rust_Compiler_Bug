{"sha": "8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmYWUyZGQzYzFiZmVkMTNiZGQ2YzBjZmQ0MTcwZGQxMzYzZjI1Zjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-14T17:33:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-14T17:33:30Z"}, "message": "Auto merge of #4560 - rust-lang:must-use-pure, r=phansch\n\nnew lints around`#[must_use]`\n\nchangelog: Add `must_use_candidate` lint,  add `must-use-unit` lint, add `double_must_use` lint\n\nThe first one checks if an public function or method has no mutable argument and mutates no non-local data and lints if it has no `#[must_use]` attribute. It will skip inner functions, because those are usually highly local and the attribute doesn't have as much benefit there.\n\nThe second lints `#[must_use]` attributes on functions and methods that return unit. Those attributes are likely a remnant from a refactoring that removed the return value.\n\nThe last one lints for `#[must_use]` attributrs without text on functions that return a type which is already marked `#[must_use]`. This has no auto-suggestion, because while it would be easy to do, there may be value in writing a detailed text for the attribute instead.\n\nThis fixes #4526", "tree": {"sha": "5191a1ef86462ec213300758e44a6ee6f25fdd55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5191a1ef86462ec213300758e44a6ee6f25fdd55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "html_url": "https://github.com/rust-lang/rust/commit/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c40d7db6ed04ce0a2f8ce5b0e057615850d69f48", "url": "https://api.github.com/repos/rust-lang/rust/commits/c40d7db6ed04ce0a2f8ce5b0e057615850d69f48", "html_url": "https://github.com/rust-lang/rust/commit/c40d7db6ed04ce0a2f8ce5b0e057615850d69f48"}, {"sha": "cc622608db7318b1c0fe3ccd541558436c7c6c4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc622608db7318b1c0fe3ccd541558436c7c6c4c", "html_url": "https://github.com/rust-lang/rust/commit/cc622608db7318b1c0fe3ccd541558436c7c6c4c"}], "stats": {"total": 1012, "additions": 924, "deletions": 88}, "files": [{"sha": "dd67bc3cdc1815dfdde505a669bad33598616b38", "filename": "CHANGELOG.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -976,6 +976,7 @@ Released 2018-09-13\n [`diverging_sub_expression`]: https://rust-lang.github.io/rust-clippy/master/index.html#diverging_sub_expression\n [`doc_markdown`]: https://rust-lang.github.io/rust-clippy/master/index.html#doc_markdown\n [`double_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#double_comparisons\n+[`double_must_use`]: https://rust-lang.github.io/rust-clippy/master/index.html#double_must_use\n [`double_neg`]: https://rust-lang.github.io/rust-clippy/master/index.html#double_neg\n [`double_parens`]: https://rust-lang.github.io/rust-clippy/master/index.html#double_parens\n [`drop_bounds`]: https://rust-lang.github.io/rust-clippy/master/index.html#drop_bounds\n@@ -1095,6 +1096,8 @@ Released 2018-09-13\n [`modulo_one`]: https://rust-lang.github.io/rust-clippy/master/index.html#modulo_one\n [`multiple_crate_versions`]: https://rust-lang.github.io/rust-clippy/master/index.html#multiple_crate_versions\n [`multiple_inherent_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#multiple_inherent_impl\n+[`must_use_candidate`]: https://rust-lang.github.io/rust-clippy/master/index.html#must_use_candidate\n+[`must_use_unit`]: https://rust-lang.github.io/rust-clippy/master/index.html#must_use_unit\n [`mut_from_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#mut_from_ref\n [`mut_mut`]: https://rust-lang.github.io/rust-clippy/master/index.html#mut_mut\n [`mut_range_bound`]: https://rust-lang.github.io/rust-clippy/master/index.html#mut_range_bound"}, {"sha": "a84ab0e8c252b11e11769d1cefdd217f2f164048", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -6,7 +6,7 @@\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are 321 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n+[There are 324 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n \n We have a bunch of lint categories to allow you to choose how much Clippy is supposed to ~~annoy~~ help you:\n "}, {"sha": "84b2814a7ce07528b92bc2743b96cd9557b44839", "filename": "clippy_dev/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flib.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -42,6 +42,7 @@ pub struct Lint {\n }\n \n impl Lint {\n+    #[must_use]\n     pub fn new(name: &str, group: &str, desc: &str, deprecation: Option<&str>, module: &str) -> Self {\n         Self {\n             name: name.to_lowercase(),\n@@ -58,19 +59,22 @@ impl Lint {\n     }\n \n     /// Returns the lints in a `HashMap`, grouped by the different lint groups\n+    #[must_use]\n     pub fn by_lint_group(lints: &[Self]) -> HashMap<String, Vec<Self>> {\n         lints\n             .iter()\n             .map(|lint| (lint.group.to_string(), lint.clone()))\n             .into_group_map()\n     }\n \n+    #[must_use]\n     pub fn is_internal(&self) -> bool {\n         self.group.starts_with(\"internal\")\n     }\n }\n \n /// Generates the Vec items for `register_lint_group` calls in `clippy_lints/src/lib.rs`.\n+#[must_use]\n pub fn gen_lint_group_list(lints: Vec<Lint>) -> Vec<String> {\n     lints\n         .into_iter()\n@@ -86,6 +90,7 @@ pub fn gen_lint_group_list(lints: Vec<Lint>) -> Vec<String> {\n }\n \n /// Generates the `pub mod module_name` list in `clippy_lints/src/lib.rs`.\n+#[must_use]\n pub fn gen_modules_list(lints: Vec<Lint>) -> Vec<String> {\n     lints\n         .into_iter()\n@@ -103,6 +108,7 @@ pub fn gen_modules_list(lints: Vec<Lint>) -> Vec<String> {\n }\n \n /// Generates the list of lint links at the bottom of the README\n+#[must_use]\n pub fn gen_changelog_lint_list(lints: Vec<Lint>) -> Vec<String> {\n     let mut lint_list_sorted: Vec<Lint> = lints;\n     lint_list_sorted.sort_by_key(|l| l.name.clone());\n@@ -119,6 +125,7 @@ pub fn gen_changelog_lint_list(lints: Vec<Lint>) -> Vec<String> {\n }\n \n /// Generates the `register_removed` code in `./clippy_lints/src/lib.rs`.\n+#[must_use]\n pub fn gen_deprecated(lints: &[Lint]) -> Vec<String> {\n     lints\n         .iter()"}, {"sha": "2d7d119f3ff125fe558d19c142eca19f5aa22513", "filename": "clippy_dev/src/stderr_length_check.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_dev%2Fsrc%2Fstderr_length_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_dev%2Fsrc%2Fstderr_length_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fstderr_length_check.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -42,6 +42,7 @@ fn stderr_files() -> impl Iterator<Item = walkdir::DirEntry> {\n         .filter(|f| f.path().extension() == Some(OsStr::new(\"stderr\")))\n }\n \n+#[must_use]\n fn count_linenumbers(filepath: &str) -> usize {\n     if let Ok(mut file) = File::open(filepath) {\n         let mut content = String::new();"}, {"sha": "04530542ef8d130b1a03819ece0f1181aa1580cd", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -93,6 +93,7 @@ fn check_known_consts(cx: &LateContext<'_, '_>, e: &Expr, s: symbol::Symbol, mod\n /// Returns `false` if the number of significant figures in `value` are\n /// less than `min_digits`; otherwise, returns true if `value` is equal\n /// to `constant`, rounded to the number of digits present in `value`.\n+#[must_use]\n fn is_approx_const(constant: f64, value: &str, min_digits: usize) -> bool {\n     if value.len() <= min_digits {\n         false"}, {"sha": "3d12bb347aa9fd404ae2fc94afd6ced59317e362", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -229,6 +229,7 @@ fn lint_misrefactored_assign_op(\n     );\n }\n \n+#[must_use]\n fn is_commutative(op: hir::BinOpKind) -> bool {\n     use rustc::hir::BinOpKind::*;\n     match op {"}, {"sha": "6d68c319f4c3a1f39d781dbe9df98f81db7a1181", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -100,6 +100,7 @@ pub struct BitMask {\n }\n \n impl BitMask {\n+    #[must_use]\n     pub fn new(verbose_bit_mask_threshold: u64) -> Self {\n         Self {\n             verbose_bit_mask_threshold,\n@@ -150,6 +151,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BitMask {\n     }\n }\n \n+#[must_use]\n fn invert_cmp(cmp: BinOpKind) -> BinOpKind {\n     match cmp {\n         BinOpKind::Eq => BinOpKind::Eq,"}, {"sha": "dfd497f909b74278792bfa6f1beb025f0c1d6a00", "filename": "clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -160,6 +160,7 @@ impl<'a> Conversion<'a> {\n \n impl ConversionType {\n     /// Creates a conversion type if the type is allowed & conversion is valid\n+    #[must_use]\n     fn try_new(from: &str, to: &str) -> Option<Self> {\n         if UINTS.contains(&from) {\n             Some(Self::FromUnsigned)"}, {"sha": "370421190cb4706f379481ff9568c3fd1ca69215", "filename": "clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -29,6 +29,7 @@ pub struct CognitiveComplexity {\n }\n \n impl CognitiveComplexity {\n+    #[must_use]\n     pub fn new(limit: u64) -> Self {\n         Self {\n             limit: LimitStack::new(limit),"}, {"sha": "726a044f9ed9ec947843f7db72c17acab119bb1c", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -191,6 +191,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DocMarkdown {\n /// need to keep track of\n /// the spans but this function is inspired from the later.\n #[allow(clippy::cast_possible_truncation)]\n+#[must_use]\n pub fn strip_doc_comment_decoration(comment: &str, span: Span) -> (String, Vec<(usize, Span)>) {\n     // one-line comments lose their prefix\n     const ONELINERS: &[&str] = &[\"///!\", \"///\", \"//!\", \"//\"];"}, {"sha": "b64e97fba5ca47ab66f727bc0da50a611f9a755f", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -107,6 +107,7 @@ pub struct EnumVariantNames {\n }\n \n impl EnumVariantNames {\n+    #[must_use]\n     pub fn new(threshold: u64) -> Self {\n         Self {\n             modules: Vec::new(),\n@@ -123,13 +124,15 @@ impl_lint_pass!(EnumVariantNames => [\n ]);\n \n /// Returns the number of chars that match from the start\n+#[must_use]\n fn partial_match(pre: &str, name: &str) -> usize {\n     let mut name_iter = name.chars();\n     let _ = name_iter.next_back(); // make sure the name is never fully matched\n     pre.chars().zip(name_iter).take_while(|&(l, r)| l == r).count()\n }\n \n /// Returns the number of chars that match from the end\n+#[must_use]\n fn partial_rmatch(post: &str, name: &str) -> usize {\n     let mut name_iter = name.chars();\n     let _ = name_iter.next(); // make sure the name is never fully matched\n@@ -211,6 +214,7 @@ fn check_variant(\n     );\n }\n \n+#[must_use]\n fn to_camel_case(item_name: &str) -> String {\n     let mut s = String::new();\n     let mut up = true;"}, {"sha": "763770c74efd3fb4714a4ff7726191de6467a1f9", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -62,6 +62,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExcessivePrecision {\n \n impl ExcessivePrecision {\n     // None if nothing to lint, Some(suggestion) if lint necessary\n+    #[must_use]\n     fn check(self, sym: Symbol, fty: FloatTy) -> Option<String> {\n         let max = max_digits(fty);\n         let sym_str = sym.as_str();\n@@ -97,6 +98,7 @@ impl ExcessivePrecision {\n /// Should we exclude the float because it has a `.0` or `.` suffix\n /// Ex `1_000_000_000.0`\n /// Ex `1_000_000_000.`\n+#[must_use]\n fn dot_zero_exclusion(s: &str) -> bool {\n     s.split('.').nth(1).map_or(false, |after_dec| {\n         let mut decpart = after_dec.chars().take_while(|c| *c != 'e' || *c != 'E');\n@@ -109,6 +111,7 @@ fn dot_zero_exclusion(s: &str) -> bool {\n     })\n }\n \n+#[must_use]\n fn max_digits(fty: FloatTy) -> u32 {\n     match fty {\n         FloatTy::F32 => f32::DIGITS,\n@@ -117,6 +120,7 @@ fn max_digits(fty: FloatTy) -> u32 {\n }\n \n /// Counts the digits excluding leading zeros\n+#[must_use]\n fn count_digits(s: &str) -> usize {\n     // Note that s does not contain the f32/64 suffix, and underscores have been stripped\n     s.chars()\n@@ -138,6 +142,7 @@ enum FloatFormat {\n     Normal,\n }\n impl FloatFormat {\n+    #[must_use]\n     fn new(s: &str) -> Self {\n         s.chars()\n             .find_map(|x| match x {"}, {"sha": "62606257498ec634ad459fd8cd51fda16b2d32f3", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -235,6 +235,7 @@ fn check_else(cx: &EarlyContext<'_>, expr: &Expr) {\n     }\n }\n \n+#[must_use]\n fn has_unary_equivalent(bin_op: BinOpKind) -> bool {\n     // &, *, -\n     bin_op == BinOpKind::And || bin_op == BinOpKind::Mul || bin_op == BinOpKind::Sub"}, {"sha": "6052f936109120af9102c5b2fd46fb6ce5748918", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 384, "deletions": 28, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -1,16 +1,17 @@\n-use std::convert::TryFrom;\n-\n-use crate::utils::{iter_input_pats, qpath_res, snippet, snippet_opt, span_lint, type_is_unsafe_function};\n+use crate::utils::{\n+    iter_input_pats, match_def_path, qpath_res, return_ty, snippet, snippet_opt, span_help_and_lint, span_lint,\n+    span_lint_and_then, type_is_unsafe_function,\n+};\n use matches::matches;\n-use rustc::hir;\n-use rustc::hir::def::Res;\n-use rustc::hir::intravisit;\n+use rustc::hir::{self, def::Res, def_id::DefId, intravisit};\n use rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::{declare_tool_lint, impl_lint_pass};\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n use rustc_target::spec::abi::Abi;\n-use syntax::source_map::{BytePos, Span};\n+use syntax::ast::Attribute;\n+use syntax::source_map::Span;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for functions with too many parameters.\n@@ -84,6 +85,80 @@ declare_clippy_lint! {\n     \"public functions dereferencing raw pointer arguments but not marked `unsafe`\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for a [`#[must_use]`] attribute on\n+    /// unit-returning functions and methods.\n+    ///\n+    /// [`#[must_use]`]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n+    ///\n+    /// **Why is this bad?** Unit values are useless. The attribute is likely\n+    /// a remnant of a refactoring that removed the return type.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    /// #[must_use]\n+    /// fn useless() { }\n+    /// ```\n+    pub MUST_USE_UNIT,\n+    style,\n+    \"`#[must_use]` attribute on a unit-returning function / method\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for a [`#[must_use]`] attribute without\n+    /// further information on functions and methods that return a type already\n+    /// marked as `#[must_use]`.\n+    ///\n+    /// [`#[must_use]`]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n+    ///\n+    /// **Why is this bad?** The attribute isn't needed. Not using the result\n+    /// will already be reported. Alternatively, one can add some text to the\n+    /// attribute to improve the lint message.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    /// #[must_use]\n+    /// fn double_must_use() -> Result<(), ()> {\n+    ///     unimplemented!();\n+    /// }\n+    /// ```\n+    pub DOUBLE_MUST_USE,\n+    style,\n+    \"`#[must_use]` attribute on a `#[must_use]`-returning function / method\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for public functions that have no\n+    /// [`#[must_use]`] attribute, but return something not already marked\n+    /// must-use, have no mutable arg and mutate no statics.\n+    ///\n+    /// [`#[must_use]`]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n+    ///\n+    /// **Why is this bad?** Not bad at all, this lint just shows places where\n+    /// you could add the attribute.\n+    ///\n+    /// **Known problems:** The lint only checks the arguments for mutable\n+    /// types without looking if they are actually changed. On the other hand,\n+    /// it also ignores a broad range of potentially interesting side effects,\n+    /// because we cannot decide whether the programmer intends the function to\n+    /// be called for the side effect or the result. Expect many false\n+    /// positives. At least we don't lint if the result type is unit or already\n+    /// `#[must_use]`.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    /// // this could be annotated with `#[must_use]`.\n+    /// fn id<T>(t: T) -> T { t }\n+    /// ```\n+    pub MUST_USE_CANDIDATE,\n+    pedantic,\n+    \"function or method that could take a `#[must_use]` attribute\"\n+}\n+\n #[derive(Copy, Clone)]\n pub struct Functions {\n     threshold: u64,\n@@ -96,7 +171,14 @@ impl Functions {\n     }\n }\n \n-impl_lint_pass!(Functions => [TOO_MANY_ARGUMENTS, TOO_MANY_LINES, NOT_UNSAFE_PTR_ARG_DEREF]);\n+impl_lint_pass!(Functions => [\n+    TOO_MANY_ARGUMENTS,\n+    TOO_MANY_LINES,\n+    NOT_UNSAFE_PTR_ARG_DEREF,\n+    MUST_USE_UNIT,\n+    DOUBLE_MUST_USE,\n+    MUST_USE_CANDIDATE,\n+]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n     fn check_fn(\n@@ -134,7 +216,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n                     _,\n                 )\n                 | hir::intravisit::FnKind::ItemFn(_, _, hir::FnHeader { abi: Abi::Rust, .. }, _, _) => {\n-                    self.check_arg_number(cx, decl, span)\n+                    self.check_arg_number(cx, decl, span.with_hi(decl.output.span().hi()))\n                 },\n                 _ => {},\n             }\n@@ -144,42 +226,88 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n         self.check_line_number(cx, span, body);\n     }\n \n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n+        let attr = must_use_attr(&item.attrs);\n+        if let hir::ItemKind::Fn(ref decl, ref _header, ref _generics, ref body_id) = item.kind {\n+            if let Some(attr) = attr {\n+                let fn_header_span = item.span.with_hi(decl.output.span().hi());\n+                check_needless_must_use(cx, decl, item.hir_id, item.span, fn_header_span, attr);\n+                return;\n+            }\n+            if cx.access_levels.is_exported(item.hir_id) {\n+                check_must_use_candidate(\n+                    cx,\n+                    decl,\n+                    cx.tcx.hir().body(*body_id),\n+                    item.span,\n+                    item.hir_id,\n+                    item.span.with_hi(decl.output.span().hi()),\n+                    \"this function could have a `#[must_use]` attribute\",\n+                );\n+            }\n+        }\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ImplItem) {\n+        if let hir::ImplItemKind::Method(ref sig, ref body_id) = item.kind {\n+            let attr = must_use_attr(&item.attrs);\n+            if let Some(attr) = attr {\n+                let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+                check_needless_must_use(cx, &sig.decl, item.hir_id, item.span, fn_header_span, attr);\n+            } else if cx.access_levels.is_exported(item.hir_id) {\n+                check_must_use_candidate(\n+                    cx,\n+                    &sig.decl,\n+                    cx.tcx.hir().body(*body_id),\n+                    item.span,\n+                    item.hir_id,\n+                    item.span.with_hi(sig.decl.output.span().hi()),\n+                    \"this method could have a `#[must_use]` attribute\",\n+                );\n+            }\n+        }\n+    }\n+\n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem) {\n         if let hir::TraitItemKind::Method(ref sig, ref eid) = item.kind {\n             // don't lint extern functions decls, it's not their fault\n             if sig.header.abi == Abi::Rust {\n-                self.check_arg_number(cx, &sig.decl, item.span);\n+                self.check_arg_number(cx, &sig.decl, item.span.with_hi(sig.decl.output.span().hi()));\n             }\n \n+            let attr = must_use_attr(&item.attrs);\n+            if let Some(attr) = attr {\n+                let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+                check_needless_must_use(cx, &sig.decl, item.hir_id, item.span, fn_header_span, attr);\n+            }\n             if let hir::TraitMethod::Provided(eid) = *eid {\n                 let body = cx.tcx.hir().body(eid);\n                 self.check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.hir_id);\n+\n+                if attr.is_none() && cx.access_levels.is_exported(item.hir_id) {\n+                    check_must_use_candidate(\n+                        cx,\n+                        &sig.decl,\n+                        body,\n+                        item.span,\n+                        item.hir_id,\n+                        item.span.with_hi(sig.decl.output.span().hi()),\n+                        \"this method could have a `#[must_use]` attribute\",\n+                    );\n+                }\n             }\n         }\n     }\n }\n \n impl<'a, 'tcx> Functions {\n-    fn check_arg_number(self, cx: &LateContext<'_, '_>, decl: &hir::FnDecl, span: Span) {\n-        // Remove the function body from the span. We can't use `SourceMap::def_span` because the\n-        // argument list might span multiple lines.\n-        let span = if let Some(snippet) = snippet_opt(cx, span) {\n-            let snippet = snippet.split('{').nth(0).unwrap_or(\"\").trim_end();\n-            if snippet.is_empty() {\n-                span\n-            } else {\n-                span.with_hi(BytePos(span.lo().0 + u32::try_from(snippet.len()).unwrap()))\n-            }\n-        } else {\n-            span\n-        };\n-\n+    fn check_arg_number(self, cx: &LateContext<'_, '_>, decl: &hir::FnDecl, fn_span: Span) {\n         let args = decl.inputs.len() as u64;\n         if args > self.threshold {\n             span_lint(\n                 cx,\n                 TOO_MANY_ARGUMENTS,\n-                span,\n+                fn_span,\n                 &format!(\"this function has too many arguments ({}/{})\", args, self.threshold),\n             );\n         }\n@@ -268,6 +396,164 @@ impl<'a, 'tcx> Functions {\n     }\n }\n \n+fn check_needless_must_use(\n+    cx: &LateContext<'_, '_>,\n+    decl: &hir::FnDecl,\n+    item_id: hir::HirId,\n+    item_span: Span,\n+    fn_header_span: Span,\n+    attr: &Attribute,\n+) {\n+    if in_external_macro(cx.sess(), item_span) {\n+        return;\n+    }\n+    if returns_unit(decl) {\n+        span_lint_and_then(\n+            cx,\n+            MUST_USE_UNIT,\n+            fn_header_span,\n+            \"this unit-returning function has a `#[must_use]` attribute\",\n+            |db| {\n+                db.span_suggestion(\n+                    attr.span,\n+                    \"remove the attribute\",\n+                    \"\".into(),\n+                    Applicability::MachineApplicable,\n+                );\n+            },\n+        );\n+    } else if !attr.is_value_str() && is_must_use_ty(cx, return_ty(cx, item_id)) {\n+        span_help_and_lint(\n+            cx,\n+            DOUBLE_MUST_USE,\n+            fn_header_span,\n+            \"this function has an empty `#[must_use]` attribute, but returns a type already marked as `#[must_use]`\",\n+            \"either add some descriptive text or remove the attribute\",\n+        );\n+    }\n+}\n+\n+fn check_must_use_candidate<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    decl: &'tcx hir::FnDecl,\n+    body: &'tcx hir::Body,\n+    item_span: Span,\n+    item_id: hir::HirId,\n+    fn_span: Span,\n+    msg: &str,\n+) {\n+    if has_mutable_arg(cx, body)\n+        || mutates_static(cx, body)\n+        || in_external_macro(cx.sess(), item_span)\n+        || returns_unit(decl)\n+        || is_must_use_ty(cx, return_ty(cx, item_id))\n+    {\n+        return;\n+    }\n+    span_lint_and_then(cx, MUST_USE_CANDIDATE, fn_span, msg, |db| {\n+        if let Some(snippet) = snippet_opt(cx, fn_span) {\n+            db.span_suggestion(\n+                fn_span,\n+                \"add the attribute\",\n+                format!(\"#[must_use] {}\", snippet),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    });\n+}\n+\n+fn must_use_attr(attrs: &[Attribute]) -> Option<&Attribute> {\n+    attrs\n+        .iter()\n+        .find(|attr| attr.ident().map_or(false, |ident| \"must_use\" == &ident.as_str()))\n+}\n+\n+fn returns_unit(decl: &hir::FnDecl) -> bool {\n+    match decl.output {\n+        hir::FunctionRetTy::DefaultReturn(_) => true,\n+        hir::FunctionRetTy::Return(ref ty) => match ty.kind {\n+            hir::TyKind::Tup(ref tys) => tys.is_empty(),\n+            hir::TyKind::Never => true,\n+            _ => false,\n+        },\n+    }\n+}\n+\n+fn is_must_use_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n+    use ty::TyKind::*;\n+    match ty.kind {\n+        Adt(ref adt, _) => must_use_attr(&cx.tcx.get_attrs(adt.did)).is_some(),\n+        Foreign(ref did) => must_use_attr(&cx.tcx.get_attrs(*did)).is_some(),\n+        Slice(ref ty) | Array(ref ty, _) | RawPtr(ty::TypeAndMut { ref ty, .. }) | Ref(_, ref ty, _) => {\n+            // for the Array case we don't need to care for the len == 0 case\n+            // because we don't want to lint functions returning empty arrays\n+            is_must_use_ty(cx, *ty)\n+        },\n+        Tuple(ref substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n+        Opaque(ref def_id, _) => {\n+            for (predicate, _) in &cx.tcx.predicates_of(*def_id).predicates {\n+                if let ty::Predicate::Trait(ref poly_trait_predicate) = predicate {\n+                    if must_use_attr(&cx.tcx.get_attrs(poly_trait_predicate.skip_binder().trait_ref.def_id)).is_some() {\n+                        return true;\n+                    }\n+                }\n+            }\n+            false\n+        },\n+        Dynamic(binder, _) => {\n+            for predicate in binder.skip_binder().iter() {\n+                if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate {\n+                    if must_use_attr(&cx.tcx.get_attrs(trait_ref.def_id)).is_some() {\n+                        return true;\n+                    }\n+                }\n+            }\n+            false\n+        },\n+        _ => false,\n+    }\n+}\n+\n+fn has_mutable_arg(cx: &LateContext<'_, '_>, body: &hir::Body) -> bool {\n+    let mut tys = FxHashSet::default();\n+    body.params.iter().any(|param| is_mutable_pat(cx, &param.pat, &mut tys))\n+}\n+\n+fn is_mutable_pat(cx: &LateContext<'_, '_>, pat: &hir::Pat, tys: &mut FxHashSet<DefId>) -> bool {\n+    if let hir::PatKind::Wild = pat.kind {\n+        return false; // ignore `_` patterns\n+    }\n+    let def_id = pat.hir_id.owner_def_id();\n+    if cx.tcx.has_typeck_tables(def_id) {\n+        is_mutable_ty(cx, &cx.tcx.typeck_tables_of(def_id).pat_ty(pat), pat.span, tys)\n+    } else {\n+        false\n+    }\n+}\n+\n+static KNOWN_WRAPPER_TYS: &[&[&str]] = &[&[\"alloc\", \"rc\", \"Rc\"], &[\"std\", \"sync\", \"Arc\"]];\n+\n+fn is_mutable_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>, span: Span, tys: &mut FxHashSet<DefId>) -> bool {\n+    use ty::TyKind::*;\n+    match ty.kind {\n+        // primitive types are never mutable\n+        Bool | Char | Int(_) | Uint(_) | Float(_) | Str => false,\n+        Adt(ref adt, ref substs) => {\n+            tys.insert(adt.did) && !ty.is_freeze(cx.tcx, cx.param_env, span)\n+                || KNOWN_WRAPPER_TYS.iter().any(|path| match_def_path(cx, adt.did, path))\n+                    && substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys))\n+        },\n+        Tuple(ref substs) => substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys)),\n+        Array(ty, _) | Slice(ty) => is_mutable_ty(cx, ty, span, tys),\n+        RawPtr(ty::TypeAndMut { ty, mutbl }) | Ref(_, ty, mutbl) => {\n+            mutbl == hir::Mutability::MutMutable || is_mutable_ty(cx, ty, span, tys)\n+        },\n+        // calling something constitutes a side effect, so return true on all callables\n+        // also never calls need not be used, so return true for them, too\n+        _ => true,\n+    }\n+}\n+\n fn raw_ptr_arg(arg: &hir::Param, ty: &hir::Ty) -> Option<hir::HirId> {\n     if let (&hir::PatKind::Binding(_, id, _, _), &hir::TyKind::Ptr(_)) = (&arg.pat.kind, &ty.kind) {\n         Some(id)\n@@ -282,7 +568,7 @@ struct DerefVisitor<'a, 'tcx> {\n     tables: &'a ty::TypeckTables<'tcx>,\n }\n \n-impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.kind {\n             hir::ExprKind::Call(ref f, ref args) => {\n@@ -308,8 +594,9 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n             _ => (),\n         }\n \n-        hir::intravisit::walk_expr(self, expr);\n+        intravisit::walk_expr(self, expr);\n     }\n+\n     fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n         intravisit::NestedVisitorMap::None\n     }\n@@ -331,3 +618,72 @@ impl<'a, 'tcx> DerefVisitor<'a, 'tcx> {\n         }\n     }\n }\n+\n+struct StaticMutVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    mutates_static: bool,\n+}\n+\n+impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+        use hir::ExprKind::*;\n+\n+        if self.mutates_static {\n+            return;\n+        }\n+        match expr.kind {\n+            Call(_, ref args) | MethodCall(_, _, ref args) => {\n+                let mut tys = FxHashSet::default();\n+                for arg in args {\n+                    let def_id = arg.hir_id.owner_def_id();\n+                    if self.cx.tcx.has_typeck_tables(def_id)\n+                        && is_mutable_ty(\n+                            self.cx,\n+                            self.cx.tcx.typeck_tables_of(def_id).expr_ty(arg),\n+                            arg.span,\n+                            &mut tys,\n+                        )\n+                        && is_mutated_static(self.cx, arg)\n+                    {\n+                        self.mutates_static = true;\n+                        return;\n+                    }\n+                    tys.clear();\n+                }\n+            },\n+            Assign(ref target, _) | AssignOp(_, ref target, _) | AddrOf(hir::Mutability::MutMutable, ref target) => {\n+                self.mutates_static |= is_mutated_static(self.cx, target)\n+            },\n+            _ => {},\n+        }\n+    }\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n+        intravisit::NestedVisitorMap::None\n+    }\n+}\n+\n+fn is_mutated_static(cx: &LateContext<'_, '_>, e: &hir::Expr) -> bool {\n+    use hir::ExprKind::*;\n+\n+    match e.kind {\n+        Path(ref qpath) => {\n+            if let Res::Local(_) = qpath_res(cx, qpath, e.hir_id) {\n+                false\n+            } else {\n+                true\n+            }\n+        },\n+        Field(ref inner, _) | Index(ref inner, _) => is_mutated_static(cx, inner),\n+        _ => false,\n+    }\n+}\n+\n+fn mutates_static<'a, 'tcx>(cx: &'a LateContext<'a, 'tcx>, body: &'tcx hir::Body) -> bool {\n+    let mut v = StaticMutVisitor {\n+        cx,\n+        mutates_static: false,\n+    };\n+    intravisit::walk_expr(&mut v, &body.value);\n+    v.mutates_static\n+}"}, {"sha": "e6af8e8c7fc0f41eacb3a7741faca684b45ed96b", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -67,6 +67,7 @@ enum Finiteness {\n use self::Finiteness::{Finite, Infinite, MaybeInfinite};\n \n impl Finiteness {\n+    #[must_use]\n     fn and(self, b: Self) -> Self {\n         match (self, b) {\n             (Finite, _) | (_, Finite) => Finite,\n@@ -75,6 +76,7 @@ impl Finiteness {\n         }\n     }\n \n+    #[must_use]\n     fn or(self, b: Self) -> Self {\n         match (self, b) {\n             (Infinite, _) | (_, Infinite) => Infinite,\n@@ -85,6 +87,7 @@ impl Finiteness {\n }\n \n impl From<bool> for Finiteness {\n+    #[must_use]\n     fn from(b: bool) -> Self {\n         if b {\n             Infinite"}, {"sha": "d612a4326fe4ed9ca660c90a75250680121f7d88", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -35,6 +35,7 @@ pub struct LargeEnumVariant {\n }\n \n impl LargeEnumVariant {\n+    #[must_use]\n     pub fn new(maximum_size_difference_allowed: u64) -> Self {\n         Self {\n             maximum_size_difference_allowed,"}, {"sha": "5d428221e69937ddeac6dfe827770583715af52f", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -6,7 +6,7 @@\n #![feature(rustc_private)]\n #![feature(slice_patterns)]\n #![feature(stmt_expr_attributes)]\n-#![allow(clippy::missing_docs_in_private_items)]\n+#![allow(clippy::missing_docs_in_private_items, clippy::must_use_candidate)]\n #![recursion_limit = \"512\"]\n #![warn(rust_2018_idioms, trivial_casts, trivial_numeric_casts)]\n #![deny(rustc::internal)]\n@@ -648,6 +648,7 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         enum_variants::MODULE_NAME_REPETITIONS,\n         enum_variants::PUB_ENUM_VARIANT_NAMES,\n         eta_reduction::REDUNDANT_CLOSURE_FOR_METHOD_CALLS,\n+        functions::MUST_USE_CANDIDATE,\n         functions::TOO_MANY_LINES,\n         if_not_else::IF_NOT_ELSE,\n         infinite_iter::MAYBE_INFINITE_ITER,\n@@ -744,6 +745,8 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING,\n         formatting::SUSPICIOUS_ELSE_FORMATTING,\n         formatting::SUSPICIOUS_UNARY_OP_FORMATTING,\n+        functions::DOUBLE_MUST_USE,\n+        functions::MUST_USE_UNIT,\n         functions::NOT_UNSAFE_PTR_ARG_DEREF,\n         functions::TOO_MANY_ARGUMENTS,\n         get_last_with_len::GET_LAST_WITH_LEN,\n@@ -955,6 +958,8 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING,\n         formatting::SUSPICIOUS_ELSE_FORMATTING,\n         formatting::SUSPICIOUS_UNARY_OP_FORMATTING,\n+        functions::DOUBLE_MUST_USE,\n+        functions::MUST_USE_UNIT,\n         infallible_destructuring_match::INFALLIBLE_DESTRUCTURING_MATCH,\n         inherent_to_string::INHERENT_TO_STRING,\n         len_zero::LEN_WITHOUT_IS_EMPTY,"}, {"sha": "be1e65fc17c42190dc186082bba30546828100fb", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -270,6 +270,7 @@ fn lts_from_bounds<'a, T: Iterator<Item = &'a Lifetime>>(mut vec: Vec<RefLt>, bo\n }\n \n /// Number of unique lifetimes in the given vector.\n+#[must_use]\n fn unique_lifetimes(lts: &[RefLt]) -> usize {\n     lts.iter().collect::<FxHashSet<_>>().len()\n }"}, {"sha": "4b2bb69fa794062829ca91ead2abc06d1437a4ba", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -113,6 +113,7 @@ pub(super) enum Radix {\n \n impl Radix {\n     /// Returns a reasonable digit group size for this radix.\n+    #[must_use]\n     crate fn suggest_grouping(&self) -> usize {\n         match *self {\n             Self::Binary | Self::Hexadecimal => 4,\n@@ -136,6 +137,7 @@ pub(super) struct DigitInfo<'a> {\n }\n \n impl<'a> DigitInfo<'a> {\n+    #[must_use]\n     crate fn new(lit: &'a str, float: bool) -> Self {\n         // Determine delimiter for radix prefix, if present, and radix.\n         let radix = if lit.starts_with(\"0x\") {\n@@ -422,6 +424,7 @@ impl LiteralDigitGrouping {\n     /// Given the sizes of the digit groups of both integral and fractional\n     /// parts, and the length\n     /// of both parts, determine if the digits have been grouped consistently.\n+    #[must_use]\n     fn parts_consistent(int_group_size: usize, frac_group_size: usize, int_size: usize, frac_size: usize) -> bool {\n         match (int_group_size, frac_group_size) {\n             // No groups on either side of decimal point - trivially consistent.\n@@ -499,6 +502,7 @@ impl EarlyLintPass for DecimalLiteralRepresentation {\n }\n \n impl DecimalLiteralRepresentation {\n+    #[must_use]\n     pub fn new(threshold: u64) -> Self {\n         Self { threshold }\n     }\n@@ -573,22 +577,27 @@ impl DecimalLiteralRepresentation {\n     }\n }\n \n+#[must_use]\n fn is_mistyped_suffix(suffix: &str) -> bool {\n     [\"_8\", \"_16\", \"_32\", \"_64\"].contains(&suffix)\n }\n \n+#[must_use]\n fn is_possible_suffix_index(lit: &str, idx: usize, len: usize) -> bool {\n     ((len > 3 && idx == len - 3) || (len > 2 && idx == len - 2)) && is_mistyped_suffix(lit.split_at(idx).1)\n }\n \n+#[must_use]\n fn is_mistyped_float_suffix(suffix: &str) -> bool {\n     [\"_32\", \"_64\"].contains(&suffix)\n }\n \n+#[must_use]\n fn is_possible_float_suffix_index(lit: &str, idx: usize, len: usize) -> bool {\n     (len > 3 && idx == len - 3) && is_mistyped_float_suffix(lit.split_at(idx).1)\n }\n \n+#[must_use]\n fn has_possible_float_suffix(lit: &str) -> bool {\n     lit.ends_with(\"_32\") || lit.ends_with(\"_64\")\n }"}, {"sha": "22821e02fe2949cb35fd0ba82da561b7d1ebf39e", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -610,6 +610,7 @@ enum NeverLoopResult {\n     Otherwise,\n }\n \n+#[must_use]\n fn absorb_break(arg: &NeverLoopResult) -> NeverLoopResult {\n     match *arg {\n         NeverLoopResult::AlwaysBreak | NeverLoopResult::Otherwise => NeverLoopResult::Otherwise,\n@@ -618,6 +619,7 @@ fn absorb_break(arg: &NeverLoopResult) -> NeverLoopResult {\n }\n \n // Combine two results for parts that are called in order.\n+#[must_use]\n fn combine_seq(first: NeverLoopResult, second: NeverLoopResult) -> NeverLoopResult {\n     match first {\n         NeverLoopResult::AlwaysBreak | NeverLoopResult::MayContinueMainLoop => first,\n@@ -626,6 +628,7 @@ fn combine_seq(first: NeverLoopResult, second: NeverLoopResult) -> NeverLoopResu\n }\n \n // Combine two results where both parts are called but not necessarily in order.\n+#[must_use]\n fn combine_both(left: NeverLoopResult, right: NeverLoopResult) -> NeverLoopResult {\n     match (left, right) {\n         (NeverLoopResult::MayContinueMainLoop, _) | (_, NeverLoopResult::MayContinueMainLoop) => {\n@@ -637,6 +640,7 @@ fn combine_both(left: NeverLoopResult, right: NeverLoopResult) -> NeverLoopResul\n }\n \n // Combine two results where only one of the part may have been executed.\n+#[must_use]\n fn combine_branches(b1: NeverLoopResult, b2: NeverLoopResult) -> NeverLoopResult {\n     match (b1, b2) {\n         (NeverLoopResult::AlwaysBreak, NeverLoopResult::AlwaysBreak) => NeverLoopResult::AlwaysBreak,"}, {"sha": "8b2bcce471c00b241c931af30f03f9a540d78380", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -195,6 +195,7 @@ fn let_binding_name(cx: &LateContext<'_, '_>, var_arg: &hir::Expr) -> String {\n     }\n }\n \n+#[must_use]\n fn suggestion_msg(function_type: &str, map_type: &str) -> String {\n     format!(\n         \"called `map(f)` on an {0} value where `f` is a unit {1}\","}, {"sha": "848e3bcb881f644a45258c3b459fbefb06ad0951", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -2898,6 +2898,7 @@ impl SelfKind {\n         }\n     }\n \n+    #[must_use]\n     fn description(self) -> &'static str {\n         match self {\n             Self::Value => \"self by value\",\n@@ -2909,6 +2910,7 @@ impl SelfKind {\n }\n \n impl Convention {\n+    #[must_use]\n     fn check(&self, other: &str) -> bool {\n         match *self {\n             Self::Eq(this) => this == other,"}, {"sha": "c06eec9502814432e749240242641e7514a739a6", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -253,6 +253,7 @@ struct ReturnVisitor {\n }\n \n impl ReturnVisitor {\n+    #[must_use]\n     fn new() -> Self {\n         Self { found_return: false }\n     }"}, {"sha": "d97e3ed880693f41c934f0dca65969eb2b420dbb", "filename": "clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -128,6 +128,7 @@ fn method_accepts_dropable(cx: &LateContext<'_, '_>, param_tys: &HirVec<hir::Ty>\n }\n \n // We don't have to lint on something that's already `const`\n+#[must_use]\n fn already_const(header: hir::FnHeader) -> bool {\n     header.constness == Constness::Const\n }"}, {"sha": "949bd4bce279b6d1c77e006d69894818522a1738", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -37,12 +37,14 @@ pub struct MissingDoc {\n }\n \n impl ::std::default::Default for MissingDoc {\n+    #[must_use]\n     fn default() -> Self {\n         Self::new()\n     }\n }\n \n impl MissingDoc {\n+    #[must_use]\n     pub fn new() -> Self {\n         Self {\n             doc_hidden_stack: vec![false],"}, {"sha": "8fa30f6827ca509fa6a981e82182635d09a2b5f1", "filename": "clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_continue.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -405,6 +405,7 @@ fn check_and_warn<'a>(ctx: &EarlyContext<'_>, expr: &'a ast::Expr) {\n ///\n /// NOTE: when there is no closing brace in `s`, `s` is _not_ preserved, i.e.,\n /// an empty string will be returned in that case.\n+#[must_use]\n pub fn erode_from_back(s: &str) -> String {\n     let mut ret = String::from(s);\n     while ret.pop().map_or(false, |c| c != '}') {}\n@@ -435,6 +436,7 @@ pub fn erode_from_back(s: &str) -> String {\n ///             inside_a_block();\n ///         }\n /// ```\n+#[must_use]\n pub fn erode_from_front(s: &str) -> String {\n     s.chars()\n         .skip_while(|c| c.is_whitespace())\n@@ -447,6 +449,7 @@ pub fn erode_from_front(s: &str) -> String {\n /// tries to get the contents of the block. If there is no closing brace\n /// present,\n /// an empty string is returned.\n+#[must_use]\n pub fn erode_block(s: &str) -> String {\n     erode_from_back(&erode_from_front(s))\n }"}, {"sha": "9cddd812b523da15b1fa7b9011525fea953aec26", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -92,6 +92,7 @@ enum Source {\n }\n \n impl Source {\n+    #[must_use]\n     fn lint(&self) -> (&'static Lint, &'static str, Span) {\n         match self {\n             Self::Item { item } | Self::Assoc { item, .. } => ("}, {"sha": "08a78b784ba5ad7ba7303911fc0ff56faa57cb43", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -148,6 +148,7 @@ impl<'a, 'tcx, 'b> Visitor<'tcx> for SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n     }\n }\n \n+#[must_use]\n fn get_whitelist(interned_name: &str) -> Option<&'static [&'static str]> {\n     for &allow in WHITELIST {\n         if whitelisted(interned_name, allow) {\n@@ -157,6 +158,7 @@ fn get_whitelist(interned_name: &str) -> Option<&'static [&'static str]> {\n     None\n }\n \n+#[must_use]\n fn whitelisted(interned_name: &str, list: &[&str]) -> bool {\n     list.iter()\n         .any(|&name| interned_name.starts_with(name) || interned_name.ends_with(name))\n@@ -383,6 +385,7 @@ fn do_check(lint: &mut NonExpressiveNames, cx: &EarlyContext<'_>, attrs: &[Attri\n }\n \n /// Precondition: `a_name.chars().count() < b_name.chars().count()`.\n+#[must_use]\n fn levenstein_not_1(a_name: &str, b_name: &str) -> bool {\n     debug_assert!(a_name.chars().count() < b_name.chars().count());\n     let mut a_chars = a_name.chars();"}, {"sha": "a2d054c1de42d52eb27cfd7b0815ba294e37fd11", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -121,6 +121,7 @@ fn is_arith_expr(expr: &Expr) -> bool {\n     }\n }\n \n+#[must_use]\n fn is_bit_op(op: BinOpKind) -> bool {\n     use syntax::ast::BinOpKind::*;\n     match op {\n@@ -129,6 +130,7 @@ fn is_bit_op(op: BinOpKind) -> bool {\n     }\n }\n \n+#[must_use]\n fn is_arith_op(op: BinOpKind) -> bool {\n     use syntax::ast::BinOpKind::*;\n     match op {"}, {"sha": "5c50915812808ecb90f240dc05eb84e15abf64bc", "filename": "clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -131,6 +131,7 @@ enum Method {\n }\n \n impl Method {\n+    #[must_use]\n     fn suggestion(self) -> &'static str {\n         match self {\n             Self::Offset => \"add\","}, {"sha": "54220f1107b7376e71f1251d480a58160f3bf767", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -129,6 +129,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Regex {\n }\n \n #[allow(clippy::cast_possible_truncation)] // truncation very unlikely here\n+#[must_use]\n fn str_span(base: Span, c: regex_syntax::ast::Span, offset: u16) -> Span {\n     let offset = u32::from(offset);\n     let end = base.lo() + BytePos(u32::try_from(c.end.offset).expect(\"offset too large\") + offset);"}, {"sha": "a53235012077e040e07a48896d06beb4671e5fd0", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -318,6 +318,7 @@ fn attr_is_cfg(attr: &ast::Attribute) -> bool {\n }\n \n // get the def site\n+#[must_use]\n fn get_def(span: Span) -> Option<Span> {\n     if span.from_expansion() {\n         Some(span.ctxt().outer_expn_data().def_site)"}, {"sha": "be8165d51f50ab4b6461a37f89482d624e649761", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -1372,6 +1372,7 @@ pub struct TypeComplexity {\n }\n \n impl TypeComplexity {\n+    #[must_use]\n     pub fn new(threshold: u64) -> Self {\n         Self { threshold }\n     }\n@@ -1780,6 +1781,7 @@ enum FullInt {\n \n impl FullInt {\n     #[allow(clippy::cast_sign_loss)]\n+    #[must_use]\n     fn cmp_s_u(s: i128, u: u128) -> Ordering {\n         if s < 0 {\n             Ordering::Less\n@@ -1792,12 +1794,14 @@ impl FullInt {\n }\n \n impl PartialEq for FullInt {\n+    #[must_use]\n     fn eq(&self, other: &Self) -> bool {\n         self.partial_cmp(other).expect(\"partial_cmp only returns Some(_)\") == Ordering::Equal\n     }\n }\n \n impl PartialOrd for FullInt {\n+    #[must_use]\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n         Some(match (self, other) {\n             (&Self::S(s), &Self::S(o)) => s.cmp(&o),\n@@ -1808,6 +1812,7 @@ impl PartialOrd for FullInt {\n     }\n }\n impl Ord for FullInt {\n+    #[must_use]\n     fn cmp(&self, other: &Self) -> Ordering {\n         self.partial_cmp(other)\n             .expect(\"partial_cmp for FullInt can never return None\")"}, {"sha": "528a1915be84708ff71ec94e49eabdd229eec9de", "filename": "clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -72,6 +72,7 @@ fn unsafe_to_safe_check(old_name: Ident, new_name: Ident, cx: &EarlyContext<'_>,\n     }\n }\n \n+#[must_use]\n fn contains_unsafe(name: &LocalInternedString) -> bool {\n     name.contains(\"Unsafe\") || name.contains(\"unsafe\")\n }"}, {"sha": "11340f69aa21c2e92dfcaca66e2ffdbe2c2d8f94", "filename": "clippy_lints/src/utils/attrs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Futils%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Futils%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fattrs.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -34,6 +34,7 @@ impl Drop for LimitStack {\n }\n \n impl LimitStack {\n+    #[must_use]\n     pub fn new(limit: u64) -> Self {\n         Self { stack: vec![limit] }\n     }"}, {"sha": "a424c09ef40897fdc0144e3c025f423f3b4240a4", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -146,6 +146,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Author {\n }\n \n impl PrintVisitor {\n+    #[must_use]\n     fn new(s: &'static str) -> Self {\n         Self {\n             ids: FxHashMap::default(),\n@@ -683,6 +684,7 @@ fn has_attr(sess: &Session, attrs: &[Attribute]) -> bool {\n     get_attr(sess, attrs, \"author\").count() > 0\n }\n \n+#[must_use]\n fn desugaring_name(des: hir::MatchSource) -> String {\n     match des {\n         hir::MatchSource::ForLoopDesugar => \"MatchSource::ForLoopDesugar\".to_string(),\n@@ -702,6 +704,7 @@ fn desugaring_name(des: hir::MatchSource) -> String {\n     }\n }\n \n+#[must_use]\n fn loop_desugaring_name(des: hir::LoopSource) -> &'static str {\n     match des {\n         hir::LoopSource::ForLoop => \"LoopSource::ForLoop\","}, {"sha": "4192a26d3c80040ed440dd74f355db993cf39e67", "filename": "clippy_lints/src/utils/camel_case.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Futils%2Fcamel_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Futils%2Fcamel_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fcamel_case.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -1,4 +1,5 @@\n /// Returns the index of the character after the first camel-case component of `s`.\n+#[must_use]\n pub fn until(s: &str) -> usize {\n     let mut iter = s.char_indices();\n     if let Some((_, first)) = iter.next() {\n@@ -32,6 +33,7 @@ pub fn until(s: &str) -> usize {\n }\n \n /// Returns index of the last camel-case component of `s`.\n+#[must_use]\n pub fn from(s: &str) -> usize {\n     let mut iter = s.char_indices().rev();\n     if let Some((_, first)) = iter.next() {"}, {"sha": "734b689ab1a6cebb54f4599764682b2f732846e2", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -90,6 +90,7 @@ macro_rules! define_Conf {\n                     }\n                 }\n \n+                #[must_use]\n                 fn $rust_name() -> define_Conf!(TY $($ty)+) {\n                     define_Conf!(DEFAULT $($ty)+, $default)\n                 }\n@@ -153,6 +154,7 @@ define_Conf! {\n }\n \n impl Default for Conf {\n+    #[must_use]\n     fn default() -> Self {\n         toml::from_str(\"\").expect(\"we never error on empty config files\")\n     }"}, {"sha": "63e9a27c5459d13c3684b97ff887214ea12e3731", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -10,6 +10,7 @@ use rustc::{hir, ty};\n use syntax::ast;\n \n /// Converts a hir binary operator to the corresponding `ast` type.\n+#[must_use]\n pub fn binop(op: hir::BinOpKind) -> ast::BinOpKind {\n     match op {\n         hir::BinOpKind::Eq => ast::BinOpKind::Eq,"}, {"sha": "96b00eb154aee275d6be760e0659c2b2b218495e", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -239,6 +239,7 @@ pub struct CompilerLintFunctions {\n }\n \n impl CompilerLintFunctions {\n+    #[must_use]\n     pub fn new() -> Self {\n         let mut map = FxHashMap::default();\n         map.insert(\"span_lint\", \"utils::span_lint\");"}, {"sha": "a5e2f3dc4b4392b590151efbd9c04a29c3f77878", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -52,6 +52,7 @@ use crate::reexport::*;\n \n /// Returns `true` if the two spans come from differing expansions (i.e., one is\n /// from a macro and one isn't).\n+#[must_use]\n pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n     rhs.ctxt() != lhs.ctxt()\n }\n@@ -98,6 +99,7 @@ pub fn in_constant(cx: &LateContext<'_, '_>, id: HirId) -> bool {\n }\n \n /// Returns `true` if this `span` was expanded by any macro.\n+#[must_use]\n pub fn in_macro(span: Span) -> bool {\n     if span.from_expansion() {\n         if let ExpnKind::Desugaring(..) = span.ctxt().outer_expn_data().kind {\n@@ -721,6 +723,7 @@ pub fn is_adjusted(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n /// Returns the pre-expansion span if is this comes from an expansion of the\n /// macro `name`.\n /// See also `is_direct_expn_of`.\n+#[must_use]\n pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n     loop {\n         if span.from_expansion() {\n@@ -748,6 +751,7 @@ pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n /// `42` is considered expanded from `foo!` and `bar!` by `is_expn_of` but only\n /// `bar!` by\n /// `is_direct_expn_of`.\n+#[must_use]\n pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n     if span.from_expansion() {\n         let data = span.ctxt().outer_expn_data();"}, {"sha": "0675c60334107bb5483a6fc8252eac0433a70500", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -417,6 +417,7 @@ enum Associativity {\n /// Chained `as` and explicit `:` type coercion never need inner parenthesis so\n /// they are considered\n /// associative.\n+#[must_use]\n fn associativity(op: &AssocOp) -> Associativity {\n     use syntax::util::parser::AssocOp::*;\n "}, {"sha": "36b58a398dc4964bee34d1248f307d1286d35ecd", "filename": "rustc_tools_util/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/rustc_tools_util%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/rustc_tools_util%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustc_tools_util%2Fsrc%2Flib.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -79,6 +79,7 @@ impl std::fmt::Debug for VersionInfo {\n     }\n }\n \n+#[must_use]\n pub fn get_commit_hash() -> Option<String> {\n     std::process::Command::new(\"git\")\n         .args(&[\"rev-parse\", \"--short\", \"HEAD\"])\n@@ -87,6 +88,7 @@ pub fn get_commit_hash() -> Option<String> {\n         .and_then(|r| String::from_utf8(r.stdout).ok())\n }\n \n+#[must_use]\n pub fn get_commit_date() -> Option<String> {\n     std::process::Command::new(\"git\")\n         .args(&[\"log\", \"-1\", \"--date=short\", \"--pretty=format:%cd\"])\n@@ -95,6 +97,7 @@ pub fn get_commit_date() -> Option<String> {\n         .and_then(|r| String::from_utf8(r.stdout).ok())\n }\n \n+#[must_use]\n pub fn get_channel() -> Option<String> {\n     match env::var(\"CFG_RELEASE_CHANNEL\") {\n         Ok(channel) => Some(channel),"}, {"sha": "66ee41402eab719c58a0f03b4d899a02b9bfa802", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -6,7 +6,7 @@ pub use lint::Lint;\n pub use lint::LINT_LEVELS;\n \n // begin lint list, do not remove this comment, it\u2019s used in `update_lints`\n-pub const ALL_LINTS: [Lint; 321] = [\n+pub const ALL_LINTS: [Lint; 324] = [\n     Lint {\n         name: \"absurd_extreme_comparisons\",\n         group: \"correctness\",\n@@ -350,6 +350,13 @@ pub const ALL_LINTS: [Lint; 321] = [\n         deprecation: None,\n         module: \"double_comparison\",\n     },\n+    Lint {\n+        name: \"double_must_use\",\n+        group: \"style\",\n+        desc: \"`#[must_use]` attribute on a `#[must_use]`-returning function / method\",\n+        deprecation: None,\n+        module: \"functions\",\n+    },\n     Lint {\n         name: \"double_neg\",\n         group: \"style\",\n@@ -1155,6 +1162,20 @@ pub const ALL_LINTS: [Lint; 321] = [\n         deprecation: None,\n         module: \"inherent_impl\",\n     },\n+    Lint {\n+        name: \"must_use_candidate\",\n+        group: \"pedantic\",\n+        desc: \"function or method that could take a `#[must_use]` attribute\",\n+        deprecation: None,\n+        module: \"functions\",\n+    },\n+    Lint {\n+        name: \"must_use_unit\",\n+        group: \"style\",\n+        desc: \"`#[must_use]` attribute on a unit-returning function / method\",\n+        deprecation: None,\n+        module: \"functions\",\n+    },\n     Lint {\n         name: \"mut_from_ref\",\n         group: \"correctness\","}, {"sha": "b5cd2860e8117b9b4d9f70aae0f404507b4953fc", "filename": "tests/compile-test.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -9,6 +9,7 @@ use std::fs;\n use std::io;\n use std::path::{Path, PathBuf};\n \n+#[must_use]\n fn clippy_driver_path() -> PathBuf {\n     if let Some(path) = option_env!(\"CLIPPY_DRIVER_PATH\") {\n         PathBuf::from(path)\n@@ -17,6 +18,7 @@ fn clippy_driver_path() -> PathBuf {\n     }\n }\n \n+#[must_use]\n fn host_libs() -> PathBuf {\n     if let Some(path) = option_env!(\"HOST_LIBS\") {\n         PathBuf::from(path)\n@@ -25,10 +27,12 @@ fn host_libs() -> PathBuf {\n     }\n }\n \n+#[must_use]\n fn rustc_test_suite() -> Option<PathBuf> {\n     option_env!(\"RUSTC_TEST_SUITE\").map(PathBuf::from)\n }\n \n+#[must_use]\n fn rustc_lib_path() -> PathBuf {\n     option_env!(\"RUSTC_LIB_PATH\").unwrap().into()\n }"}, {"sha": "b717afd0b27b5a33a92563abee45a94bce1f4bff", "filename": "tests/ui/auxiliary/macro_rules.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -1,9 +1,18 @@\n #![allow(dead_code)]\n \n-/// Used to test that certain lints don't trigger in imported external macros\n+//! Used to test that certain lints don't trigger in imported external macros\n+\n #[macro_export]\n macro_rules! foofoo {\n     () => {\n         loop {}\n     };\n }\n+\n+#[macro_export]\n+macro_rules! must_use_unit {\n+    () => {\n+        #[must_use]\n+        fn foo() {}\n+    };\n+}"}, {"sha": "a48e675e4ea23e543bf54c53417d5af9a3dcb26d", "filename": "tests/ui/double_must_use.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fdouble_must_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fdouble_must_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdouble_must_use.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -0,0 +1,27 @@\n+#![warn(clippy::double_must_use)]\n+\n+#[must_use]\n+pub fn must_use_result() -> Result<(), ()> {\n+    unimplemented!();\n+}\n+\n+#[must_use]\n+pub fn must_use_tuple() -> (Result<(), ()>, u8) {\n+    unimplemented!();\n+}\n+\n+#[must_use]\n+pub fn must_use_array() -> [Result<(), ()>; 1] {\n+    unimplemented!();\n+}\n+\n+#[must_use = \"With note\"]\n+pub fn must_use_with_note() -> Result<(), ()> {\n+    unimplemented!();\n+}\n+\n+fn main() {\n+    must_use_result();\n+    must_use_tuple();\n+    must_use_with_note();\n+}"}, {"sha": "bc37785294fca6f9c4b863eea4a7bf0d2be2931c", "filename": "tests/ui/double_must_use.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fdouble_must_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fdouble_must_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdouble_must_use.stderr?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -0,0 +1,27 @@\n+error: this function has an empty `#[must_use]` attribute, but returns a type already marked as `#[must_use]`\n+  --> $DIR/double_must_use.rs:4:1\n+   |\n+LL | pub fn must_use_result() -> Result<(), ()> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::double-must-use` implied by `-D warnings`\n+   = help: either add some descriptive text or remove the attribute\n+\n+error: this function has an empty `#[must_use]` attribute, but returns a type already marked as `#[must_use]`\n+  --> $DIR/double_must_use.rs:9:1\n+   |\n+LL | pub fn must_use_tuple() -> (Result<(), ()>, u8) {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: either add some descriptive text or remove the attribute\n+\n+error: this function has an empty `#[must_use]` attribute, but returns a type already marked as `#[must_use]`\n+  --> $DIR/double_must_use.rs:14:1\n+   |\n+LL | pub fn must_use_array() -> [Result<(), ()>; 1] {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: either add some descriptive text or remove the attribute\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "0a86568b18de9f09016db3b3f27c18ea66bb8825", "filename": "tests/ui/functions.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Ffunctions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Ffunctions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffunctions.stderr?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -2,7 +2,7 @@ error: this function has too many arguments (8/7)\n   --> $DIR/functions.rs:8:1\n    |\n LL | fn bad(_one: u32, _two: u32, _three: &str, _four: bool, _five: f32, _six: f32, _seven: bool, _eight: ()) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::too-many-arguments` implied by `-D warnings`\n \n@@ -16,19 +16,19 @@ LL | |     three: &str,\n ...  |\n LL | |     eight: ()\n LL | | ) {\n-   | |_^\n+   | |__^\n \n error: this function has too many arguments (8/7)\n   --> $DIR/functions.rs:45:5\n    |\n LL |     fn bad(_one: u32, _two: u32, _three: &str, _four: bool, _five: f32, _six: f32, _seven: bool, _eight: ());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this function has too many arguments (8/7)\n   --> $DIR/functions.rs:54:5\n    |\n LL |     fn bad_method(_one: u32, _two: u32, _three: &str, _four: bool, _five: f32, _six: f32, _seven: bool, _eight: ()) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this public function dereferences a raw pointer but is not marked `unsafe`\n   --> $DIR/functions.rs:63:34"}, {"sha": "e5a6cba9a2531e640cbae6c88526e8baf3ce0f43", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -4,16 +4,17 @@\n #![warn(clippy::all, clippy::pedantic, clippy::option_unwrap_used)]\n #![allow(\n     clippy::blacklisted_name,\n-    unused,\n-    clippy::print_stdout,\n+    clippy::default_trait_access,\n+    clippy::missing_docs_in_private_items,\n     clippy::non_ascii_literal,\n     clippy::new_without_default,\n-    clippy::missing_docs_in_private_items,\n     clippy::needless_pass_by_value,\n-    clippy::default_trait_access,\n+    clippy::print_stdout,\n+    clippy::must_use_candidate,\n     clippy::use_self,\n     clippy::useless_format,\n-    clippy::wrong_self_convention\n+    clippy::wrong_self_convention,\n+    unused\n )]\n \n #[macro_use]"}, {"sha": "28da35bff3e0d87c22b0c602a02e548e846313cf", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -1,5 +1,5 @@\n error: defining a method called `add` on this type; consider implementing the `std::ops::Add` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:36:5\n+  --> $DIR/methods.rs:37:5\n    |\n LL | /     pub fn add(self, other: T) -> T {\n LL | |         self\n@@ -9,7 +9,7 @@ LL | |     }\n    = note: `-D clippy::should-implement-trait` implied by `-D warnings`\n \n error: methods called `new` usually return `Self`\n-  --> $DIR/methods.rs:152:5\n+  --> $DIR/methods.rs:153:5\n    |\n LL | /     fn new() -> i32 {\n LL | |         0\n@@ -19,7 +19,7 @@ LL | |     }\n    = note: `-D clippy::new-ret-no-self` implied by `-D warnings`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:174:13\n+  --> $DIR/methods.rs:175:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -31,7 +31,7 @@ LL | |                .unwrap_or(0);\n    = note: replace `map(|x| x + 1).unwrap_or(0)` with `map_or(0, |x| x + 1)`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:178:13\n+  --> $DIR/methods.rs:179:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -41,7 +41,7 @@ LL | |               ).unwrap_or(0);\n    | |____________________________^\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:182:13\n+  --> $DIR/methods.rs:183:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -51,15 +51,15 @@ LL | |                 });\n    | |__________________^\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:187:13\n+  --> $DIR/methods.rs:188:13\n    |\n LL |     let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:189:13\n+  --> $DIR/methods.rs:190:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -69,7 +69,7 @@ LL | |     ).unwrap_or(None);\n    | |_____________________^\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:193:13\n+  --> $DIR/methods.rs:194:13\n    |\n LL |       let _ = opt\n    |  _____________^\n@@ -80,15 +80,15 @@ LL | |         .unwrap_or(None);\n    = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:204:13\n+  --> $DIR/methods.rs:205:13\n    |\n LL |     let _ = Some(\"prefix\").map(|p| format!(\"{}.\", p)).unwrap_or(id);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `map(|p| format!(\"{}.\", p)).unwrap_or(id)` with `map_or(id, |p| format!(\"{}.\", p))`\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:208:13\n+  --> $DIR/methods.rs:209:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -100,7 +100,7 @@ LL | |                .unwrap_or_else(|| 0);\n    = note: replace `map(|x| x + 1).unwrap_or_else(|| 0)` with `map_or_else(|| 0, |x| x + 1)`\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:212:13\n+  --> $DIR/methods.rs:213:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -110,7 +110,7 @@ LL | |               ).unwrap_or_else(|| 0);\n    | |____________________________________^\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:216:13\n+  --> $DIR/methods.rs:217:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -120,7 +120,7 @@ LL | |                 );\n    | |_________________^\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:246:13\n+  --> $DIR/methods.rs:247:13\n    |\n LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -129,7 +129,7 @@ LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    = note: replace `filter(|&x| *x < 0).next()` with `find(|&x| *x < 0)`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:249:13\n+  --> $DIR/methods.rs:250:13\n    |\n LL |       let _ = v.iter().filter(|&x| {\n    |  _____________^\n@@ -139,33 +139,33 @@ LL | |                    ).next();\n    | |___________________________^\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:266:22\n+  --> $DIR/methods.rs:267:22\n    |\n LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| *x < 0)`\n    |\n    = note: `-D clippy::search-is-some` implied by `-D warnings`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:267:20\n+  --> $DIR/methods.rs:268:20\n    |\n LL |     let _ = (0..1).find(|x| **y == *x).is_some(); // one dereference less\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| **y == x)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:268:20\n+  --> $DIR/methods.rs:269:20\n    |\n LL |     let _ = (0..1).find(|x| *x == 0).is_some();\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| x == 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:269:22\n+  --> $DIR/methods.rs:270:22\n    |\n LL |     let _ = v.iter().find(|x| **x == 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| *x == 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:272:13\n+  --> $DIR/methods.rs:273:13\n    |\n LL |       let _ = v.iter().find(|&x| {\n    |  _____________^\n@@ -175,13 +175,13 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:278:22\n+  --> $DIR/methods.rs:279:22\n    |\n LL |     let _ = v.iter().position(|&x| x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:281:13\n+  --> $DIR/methods.rs:282:13\n    |\n LL |       let _ = v.iter().position(|&x| {\n    |  _____________^\n@@ -191,13 +191,13 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:287:22\n+  --> $DIR/methods.rs:288:22\n    |\n LL |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:290:13\n+  --> $DIR/methods.rs:291:13\n    |\n LL |       let _ = v.iter().rposition(|&x| {\n    |  _____________^\n@@ -207,7 +207,7 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: used unwrap() on an Option value. If you don't want to handle the None case gracefully, consider using expect() to provide a better panic message\n-  --> $DIR/methods.rs:305:13\n+  --> $DIR/methods.rs:306:13\n    |\n LL |     let _ = opt.unwrap();\n    |             ^^^^^^^^^^^^"}, {"sha": "dded5321af83f953fc29d36a3e482898d2f90d5f", "filename": "tests/ui/must_use_candidates.fixed", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fmust_use_candidates.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fmust_use_candidates.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmust_use_candidates.fixed?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -0,0 +1,88 @@\n+// run-rustfix\n+#![feature(never_type)]\n+#![allow(unused_mut)]\n+#![warn(clippy::must_use_candidate)]\n+use std::rc::Rc;\n+use std::sync::atomic::{AtomicBool, Ordering};\n+use std::sync::Arc;\n+\n+pub struct MyAtomic(AtomicBool);\n+pub struct MyPure;\n+\n+#[must_use] pub fn pure(i: u8) -> u8 {\n+    i\n+}\n+\n+impl MyPure {\n+    #[must_use] pub fn inherent_pure(&self) -> u8 {\n+        0\n+    }\n+}\n+\n+pub trait MyPureTrait {\n+    fn trait_pure(&self, i: u32) -> u32 {\n+        self.trait_impl_pure(i) + 1\n+    }\n+\n+    fn trait_impl_pure(&self, i: u32) -> u32;\n+}\n+\n+impl MyPureTrait for MyPure {\n+    #[must_use] fn trait_impl_pure(&self, i: u32) -> u32 {\n+        i\n+    }\n+}\n+\n+pub fn without_result() {\n+    // OK\n+}\n+\n+pub fn impure_primitive(i: &mut u8) -> u8 {\n+    *i\n+}\n+\n+pub fn with_callback<F: Fn(u32) -> bool>(f: &F) -> bool {\n+    f(0)\n+}\n+\n+#[must_use] pub fn with_marker(_d: std::marker::PhantomData<&mut u32>) -> bool {\n+    true\n+}\n+\n+pub fn quoth_the_raven(_more: !) -> u32 {\n+    unimplemented!();\n+}\n+\n+pub fn atomics(b: &AtomicBool) -> bool {\n+    b.load(Ordering::SeqCst)\n+}\n+\n+#[must_use] pub fn rcd(_x: Rc<u32>) -> bool {\n+    true\n+}\n+\n+pub fn rcmut(_x: Rc<&mut u32>) -> bool {\n+    true\n+}\n+\n+#[must_use] pub fn arcd(_x: Arc<u32>) -> bool {\n+    false\n+}\n+\n+pub fn inner_types(_m: &MyAtomic) -> bool {\n+    true\n+}\n+\n+static mut COUNTER: usize = 0;\n+\n+/// # Safety\n+///\n+/// Don't ever call this from multiple threads\n+pub unsafe fn mutates_static() -> usize {\n+    COUNTER += 1;\n+    COUNTER\n+}\n+\n+fn main() {\n+    assert_eq!(1, pure(1));\n+}"}, {"sha": "29c0752994af0586a4657e8c014609002d321fa8", "filename": "tests/ui/must_use_candidates.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fmust_use_candidates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fmust_use_candidates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmust_use_candidates.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -0,0 +1,88 @@\n+// run-rustfix\n+#![feature(never_type)]\n+#![allow(unused_mut)]\n+#![warn(clippy::must_use_candidate)]\n+use std::rc::Rc;\n+use std::sync::atomic::{AtomicBool, Ordering};\n+use std::sync::Arc;\n+\n+pub struct MyAtomic(AtomicBool);\n+pub struct MyPure;\n+\n+pub fn pure(i: u8) -> u8 {\n+    i\n+}\n+\n+impl MyPure {\n+    pub fn inherent_pure(&self) -> u8 {\n+        0\n+    }\n+}\n+\n+pub trait MyPureTrait {\n+    fn trait_pure(&self, i: u32) -> u32 {\n+        self.trait_impl_pure(i) + 1\n+    }\n+\n+    fn trait_impl_pure(&self, i: u32) -> u32;\n+}\n+\n+impl MyPureTrait for MyPure {\n+    fn trait_impl_pure(&self, i: u32) -> u32 {\n+        i\n+    }\n+}\n+\n+pub fn without_result() {\n+    // OK\n+}\n+\n+pub fn impure_primitive(i: &mut u8) -> u8 {\n+    *i\n+}\n+\n+pub fn with_callback<F: Fn(u32) -> bool>(f: &F) -> bool {\n+    f(0)\n+}\n+\n+pub fn with_marker(_d: std::marker::PhantomData<&mut u32>) -> bool {\n+    true\n+}\n+\n+pub fn quoth_the_raven(_more: !) -> u32 {\n+    unimplemented!();\n+}\n+\n+pub fn atomics(b: &AtomicBool) -> bool {\n+    b.load(Ordering::SeqCst)\n+}\n+\n+pub fn rcd(_x: Rc<u32>) -> bool {\n+    true\n+}\n+\n+pub fn rcmut(_x: Rc<&mut u32>) -> bool {\n+    true\n+}\n+\n+pub fn arcd(_x: Arc<u32>) -> bool {\n+    false\n+}\n+\n+pub fn inner_types(_m: &MyAtomic) -> bool {\n+    true\n+}\n+\n+static mut COUNTER: usize = 0;\n+\n+/// # Safety\n+///\n+/// Don't ever call this from multiple threads\n+pub unsafe fn mutates_static() -> usize {\n+    COUNTER += 1;\n+    COUNTER\n+}\n+\n+fn main() {\n+    assert_eq!(1, pure(1));\n+}"}, {"sha": "f3a4421023739cb185a5e2e0656ab8f0cc90aadf", "filename": "tests/ui/must_use_candidates.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fmust_use_candidates.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fmust_use_candidates.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmust_use_candidates.stderr?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -0,0 +1,40 @@\n+error: this function could have a `#[must_use]` attribute\n+  --> $DIR/must_use_candidates.rs:12:1\n+   |\n+LL | pub fn pure(i: u8) -> u8 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^ help: add the attribute: `#[must_use] pub fn pure(i: u8) -> u8`\n+   |\n+   = note: `-D clippy::must-use-candidate` implied by `-D warnings`\n+\n+error: this method could have a `#[must_use]` attribute\n+  --> $DIR/must_use_candidates.rs:17:5\n+   |\n+LL |     pub fn inherent_pure(&self) -> u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: add the attribute: `#[must_use] pub fn inherent_pure(&self) -> u8`\n+\n+error: this method could have a `#[must_use]` attribute\n+  --> $DIR/must_use_candidates.rs:31:5\n+   |\n+LL |     fn trait_impl_pure(&self, i: u32) -> u32 {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: add the attribute: `#[must_use] fn trait_impl_pure(&self, i: u32) -> u32`\n+\n+error: this function could have a `#[must_use]` attribute\n+  --> $DIR/must_use_candidates.rs:48:1\n+   |\n+LL | pub fn with_marker(_d: std::marker::PhantomData<&mut u32>) -> bool {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: add the attribute: `#[must_use] pub fn with_marker(_d: std::marker::PhantomData<&mut u32>) -> bool`\n+\n+error: this function could have a `#[must_use]` attribute\n+  --> $DIR/must_use_candidates.rs:60:1\n+   |\n+LL | pub fn rcd(_x: Rc<u32>) -> bool {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: add the attribute: `#[must_use] pub fn rcd(_x: Rc<u32>) -> bool`\n+\n+error: this function could have a `#[must_use]` attribute\n+  --> $DIR/must_use_candidates.rs:68:1\n+   |\n+LL | pub fn arcd(_x: Arc<u32>) -> bool {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: add the attribute: `#[must_use] pub fn arcd(_x: Arc<u32>) -> bool`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "6c9aa434ac016f5eab268dacec51ff8ca0b0ca88", "filename": "tests/ui/must_use_unit.fixed", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fmust_use_unit.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fmust_use_unit.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmust_use_unit.fixed?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -0,0 +1,26 @@\n+//run-rustfix\n+// aux-build:macro_rules.rs\n+\n+#![warn(clippy::must_use_unit)]\n+#![allow(clippy::unused_unit)]\n+\n+#[macro_use]\n+extern crate macro_rules;\n+\n+\n+pub fn must_use_default() {}\n+\n+\n+pub fn must_use_unit() -> () {}\n+\n+\n+pub fn must_use_with_note() {}\n+\n+fn main() {\n+    must_use_default();\n+    must_use_unit();\n+    must_use_with_note();\n+\n+    // We should not lint in external macros\n+    must_use_unit!();\n+}"}, {"sha": "8a395dc284db4f38b2c7c4e2002b1a9704f942a5", "filename": "tests/ui/must_use_unit.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fmust_use_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fmust_use_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmust_use_unit.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -0,0 +1,26 @@\n+//run-rustfix\n+// aux-build:macro_rules.rs\n+\n+#![warn(clippy::must_use_unit)]\n+#![allow(clippy::unused_unit)]\n+\n+#[macro_use]\n+extern crate macro_rules;\n+\n+#[must_use]\n+pub fn must_use_default() {}\n+\n+#[must_use]\n+pub fn must_use_unit() -> () {}\n+\n+#[must_use = \"With note\"]\n+pub fn must_use_with_note() {}\n+\n+fn main() {\n+    must_use_default();\n+    must_use_unit();\n+    must_use_with_note();\n+\n+    // We should not lint in external macros\n+    must_use_unit!();\n+}"}, {"sha": "15e0906b66b5ec986eaa5a7df700401c4b54e4b8", "filename": "tests/ui/must_use_unit.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fmust_use_unit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fmust_use_unit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmust_use_unit.stderr?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -0,0 +1,28 @@\n+error: this unit-returning function has a `#[must_use]` attribute\n+  --> $DIR/must_use_unit.rs:11:1\n+   |\n+LL | #[must_use]\n+   | ----------- help: remove the attribute\n+LL | pub fn must_use_default() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::must-use-unit` implied by `-D warnings`\n+\n+error: this unit-returning function has a `#[must_use]` attribute\n+  --> $DIR/must_use_unit.rs:14:1\n+   |\n+LL | #[must_use]\n+   | ----------- help: remove the attribute\n+LL | pub fn must_use_unit() -> () {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: this unit-returning function has a `#[must_use]` attribute\n+  --> $DIR/must_use_unit.rs:17:1\n+   |\n+LL | #[must_use = \"With note\"]\n+   | ------------------------- help: remove the attribute\n+LL | pub fn must_use_with_note() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "bd91ae4e9340cf9a15d67f4c57d075fa933807e1", "filename": "tests/ui/shadow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshadow.rs?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -16,6 +16,7 @@ fn id<T>(x: T) -> T {\n     x\n }\n \n+#[must_use]\n fn first(x: (isize, isize)) -> isize {\n     x.0\n }"}, {"sha": "7fa58cf76499b8016b9c062a647ef041cc5d2444", "filename": "tests/ui/shadow.stderr", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fshadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7/tests%2Fui%2Fshadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshadow.stderr?ref=8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "patch": "@@ -1,135 +1,135 @@\n error: `x` is shadowed by itself in `&mut x`\n-  --> $DIR/shadow.rs:25:5\n+  --> $DIR/shadow.rs:26:5\n    |\n LL |     let x = &mut x;\n    |     ^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::shadow-same` implied by `-D warnings`\n note: previous binding is here\n-  --> $DIR/shadow.rs:24:13\n+  --> $DIR/shadow.rs:25:13\n    |\n LL |     let mut x = 1;\n    |             ^\n \n error: `x` is shadowed by itself in `{ x }`\n-  --> $DIR/shadow.rs:26:5\n+  --> $DIR/shadow.rs:27:5\n    |\n LL |     let x = { x };\n    |     ^^^^^^^^^^^^^^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:25:9\n+  --> $DIR/shadow.rs:26:9\n    |\n LL |     let x = &mut x;\n    |         ^\n \n error: `x` is shadowed by itself in `(&*x)`\n-  --> $DIR/shadow.rs:27:5\n+  --> $DIR/shadow.rs:28:5\n    |\n LL |     let x = (&*x);\n    |     ^^^^^^^^^^^^^^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:26:9\n+  --> $DIR/shadow.rs:27:9\n    |\n LL |     let x = { x };\n    |         ^\n \n error: `x` is shadowed by `{ *x + 1 }` which reuses the original value\n-  --> $DIR/shadow.rs:28:9\n+  --> $DIR/shadow.rs:29:9\n    |\n LL |     let x = { *x + 1 };\n    |         ^\n    |\n    = note: `-D clippy::shadow-reuse` implied by `-D warnings`\n note: initialization happens here\n-  --> $DIR/shadow.rs:28:13\n+  --> $DIR/shadow.rs:29:13\n    |\n LL |     let x = { *x + 1 };\n    |             ^^^^^^^^^^\n note: previous binding is here\n-  --> $DIR/shadow.rs:27:9\n+  --> $DIR/shadow.rs:28:9\n    |\n LL |     let x = (&*x);\n    |         ^\n \n error: `x` is shadowed by `id(x)` which reuses the original value\n-  --> $DIR/shadow.rs:29:9\n+  --> $DIR/shadow.rs:30:9\n    |\n LL |     let x = id(x);\n    |         ^\n    |\n note: initialization happens here\n-  --> $DIR/shadow.rs:29:13\n+  --> $DIR/shadow.rs:30:13\n    |\n LL |     let x = id(x);\n    |             ^^^^^\n note: previous binding is here\n-  --> $DIR/shadow.rs:28:9\n+  --> $DIR/shadow.rs:29:9\n    |\n LL |     let x = { *x + 1 };\n    |         ^\n \n error: `x` is shadowed by `(1, x)` which reuses the original value\n-  --> $DIR/shadow.rs:30:9\n+  --> $DIR/shadow.rs:31:9\n    |\n LL |     let x = (1, x);\n    |         ^\n    |\n note: initialization happens here\n-  --> $DIR/shadow.rs:30:13\n+  --> $DIR/shadow.rs:31:13\n    |\n LL |     let x = (1, x);\n    |             ^^^^^^\n note: previous binding is here\n-  --> $DIR/shadow.rs:29:9\n+  --> $DIR/shadow.rs:30:9\n    |\n LL |     let x = id(x);\n    |         ^\n \n error: `x` is shadowed by `first(x)` which reuses the original value\n-  --> $DIR/shadow.rs:31:9\n+  --> $DIR/shadow.rs:32:9\n    |\n LL |     let x = first(x);\n    |         ^\n    |\n note: initialization happens here\n-  --> $DIR/shadow.rs:31:13\n+  --> $DIR/shadow.rs:32:13\n    |\n LL |     let x = first(x);\n    |             ^^^^^^^^\n note: previous binding is here\n-  --> $DIR/shadow.rs:30:9\n+  --> $DIR/shadow.rs:31:9\n    |\n LL |     let x = (1, x);\n    |         ^\n \n error: `x` is shadowed by `y`\n-  --> $DIR/shadow.rs:33:9\n+  --> $DIR/shadow.rs:34:9\n    |\n LL |     let x = y;\n    |         ^\n    |\n    = note: `-D clippy::shadow-unrelated` implied by `-D warnings`\n note: initialization happens here\n-  --> $DIR/shadow.rs:33:13\n+  --> $DIR/shadow.rs:34:13\n    |\n LL |     let x = y;\n    |             ^\n note: previous binding is here\n-  --> $DIR/shadow.rs:31:9\n+  --> $DIR/shadow.rs:32:9\n    |\n LL |     let x = first(x);\n    |         ^\n \n error: `x` shadows a previous declaration\n-  --> $DIR/shadow.rs:35:5\n+  --> $DIR/shadow.rs:36:5\n    |\n LL |     let x;\n    |     ^^^^^^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:33:9\n+  --> $DIR/shadow.rs:34:9\n    |\n LL |     let x = y;\n    |         ^"}]}