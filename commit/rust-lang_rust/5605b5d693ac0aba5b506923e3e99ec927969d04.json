{"sha": "5605b5d693ac0aba5b506923e3e99ec927969d04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2MDViNWQ2OTNhYzBhYmE1YjUwNjkyM2UzZTk5ZWM5Mjc5NjlkMDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-05T14:52:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-05T14:52:57Z"}, "message": "Auto merge of #81257 - pnkfelix:issue-80949-short-term-resolution-via-revert-of-pr-78373, r=matthewjasper\n\nRevert 78373 (\"dont leak return value after panic in drop\")\n\nShort term resolution for issue #80949.\n\nReopen #47949 after this lands.\n\n(We plan to fine-tune PR #78373 to not run into this problem.)", "tree": {"sha": "be4779b0e78186f842ef170469a6a2925a583454", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be4779b0e78186f842ef170469a6a2925a583454"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5605b5d693ac0aba5b506923e3e99ec927969d04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5605b5d693ac0aba5b506923e3e99ec927969d04", "html_url": "https://github.com/rust-lang/rust/commit/5605b5d693ac0aba5b506923e3e99ec927969d04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5605b5d693ac0aba5b506923e3e99ec927969d04/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9435f4c92651d67d5dbaba13c5606c4c4fc1327", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9435f4c92651d67d5dbaba13c5606c4c4fc1327", "html_url": "https://github.com/rust-lang/rust/commit/f9435f4c92651d67d5dbaba13c5606c4c4fc1327"}, {"sha": "dce5e9e1bf1972791bf2d5a4fe0a3202ddb2a87e", "url": "https://api.github.com/repos/rust-lang/rust/commits/dce5e9e1bf1972791bf2d5a4fe0a3202ddb2a87e", "html_url": "https://github.com/rust-lang/rust/commit/dce5e9e1bf1972791bf2d5a4fe0a3202ddb2a87e"}], "stats": {"total": 21947, "additions": 10904, "deletions": 11043}, "files": [{"sha": "d5f72e6f22dfa29af8a3c5870d9ab593a17428b7", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -3,7 +3,6 @@ use crate::build::ForGuard::OutsideGuard;\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n use crate::thir::*;\n use rustc_hir as hir;\n-use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n use rustc_session::lint::builtin::UNSAFE_OP_IN_UNSAFE_FN;\n use rustc_session::lint::Level;\n@@ -13,7 +12,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn ast_block(\n         &mut self,\n         destination: Place<'tcx>,\n-        scope: Option<region::Scope>,\n         block: BasicBlock,\n         ast_block: &'tcx hir::Block<'tcx>,\n         source_info: SourceInfo,\n@@ -30,10 +28,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.in_opt_scope(opt_destruction_scope.map(|de| (de, source_info)), move |this| {\n             this.in_scope((region_scope, source_info), LintLevel::Inherited, move |this| {\n                 if targeted_by_break {\n-                    this.in_breakable_scope(None, destination, scope, span, |this| {\n+                    this.in_breakable_scope(None, destination, span, |this| {\n                         Some(this.ast_block_stmts(\n                             destination,\n-                            scope,\n                             block,\n                             span,\n                             stmts,\n@@ -42,7 +39,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         ))\n                     })\n                 } else {\n-                    this.ast_block_stmts(destination, scope, block, span, stmts, expr, safety_mode)\n+                    this.ast_block_stmts(destination, block, span, stmts, expr, safety_mode)\n                 }\n             })\n         })\n@@ -51,7 +48,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn ast_block_stmts(\n         &mut self,\n         destination: Place<'tcx>,\n-        scope: Option<region::Scope>,\n         mut block: BasicBlock,\n         span: Span,\n         stmts: Vec<StmtRef<'tcx>>,\n@@ -186,7 +182,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             };\n             this.block_context.push(BlockFrame::TailExpr { tail_result_is_ignored, span });\n \n-            unpack!(block = this.into(destination, scope, block, expr));\n+            unpack!(block = this.into(destination, block, expr));\n             let popped = this.block_context.pop();\n \n             assert!(popped.map_or(false, |bf| bf.is_tail_expr()));"}, {"sha": "e602f4dd71d2570ad2fcb3d3e4ac0cf16c0f883d", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -12,8 +12,6 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::{self, Ty, UpvarSubsts};\n use rustc_span::Span;\n \n-use std::slice;\n-\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Returns an rvalue suitable for use until the end of the current\n     /// scope expression.\n@@ -115,19 +113,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let box_ = Rvalue::NullaryOp(NullOp::Box, value.ty);\n                 this.cfg.push_assign(block, source_info, Place::from(result), box_);\n \n-                // Initialize the box contents. No scope is needed since the\n-                // `Box` is already scheduled to be dropped.\n+                // initialize the box contents:\n                 unpack!(\n-                    block = this.into(\n-                        this.hir.tcx().mk_place_deref(Place::from(result)),\n-                        None,\n-                        block,\n-                        value,\n-                    )\n+                    block =\n+                        this.into(this.hir.tcx().mk_place_deref(Place::from(result)), block, value)\n                 );\n-                let result_operand = Operand::Move(Place::from(result));\n-                this.record_operands_moved(slice::from_ref(&result_operand));\n-                block.and(Rvalue::Use(result_operand))\n+                block.and(Rvalue::Use(Operand::Move(Place::from(result))))\n             }\n             ExprKind::Cast { source } => {\n                 let source = unpack!(block = this.as_operand(block, scope, source));\n@@ -171,7 +162,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     .map(|f| unpack!(block = this.as_operand(block, scope, f)))\n                     .collect();\n \n-                this.record_operands_moved(&fields);\n                 block.and(Rvalue::Aggregate(box AggregateKind::Array(el_ty), fields))\n             }\n             ExprKind::Tuple { fields } => {\n@@ -182,7 +172,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     .map(|f| unpack!(block = this.as_operand(block, scope, f)))\n                     .collect();\n \n-                this.record_operands_moved(&fields);\n                 block.and(Rvalue::Aggregate(box AggregateKind::Tuple, fields))\n             }\n             ExprKind::Closure { closure_id, substs, upvars, movability } => {\n@@ -234,7 +223,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     }\n                     UpvarSubsts::Closure(substs) => box AggregateKind::Closure(closure_id, substs),\n                 };\n-                this.record_operands_moved(&operands);\n                 block.and(Rvalue::Aggregate(result, operands))\n             }\n             ExprKind::Assign { .. } | ExprKind::AssignOp { .. } => {"}, {"sha": "9984b527ffdb4c00611c8e0b843f6ab5b25c072a", "filename": "compiler/rustc_mir_build/src/build/expr/as_temp.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -114,7 +114,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n \n-        unpack!(block = this.into(temp_place, temp_lifetime, block, expr));\n+        unpack!(block = this.into(temp_place, block, expr));\n+\n+        if let Some(temp_lifetime) = temp_lifetime {\n+            this.schedule_drop(expr_span, temp_lifetime, temp, DropKind::Value);\n+        }\n \n         block.and(temp)\n     }"}, {"sha": "235fe14cbf9fdd3ed395c65d7fa0a12242828242", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 27, "deletions": 63, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -1,35 +1,25 @@\n //! See docs in build/expr/mod.rs\n \n use crate::build::expr::category::{Category, RvalueFunc};\n-use crate::build::scope::DropKind;\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n use crate::thir::*;\n use rustc_ast::InlineAsmOptions;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir as hir;\n-use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n use rustc_middle::ty::CanonicalUserTypeAnnotation;\n \n-use std::slice;\n-\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n     /// is assumed to be uninitialized.\n-    /// If a `drop_scope` is provided, `destination` is scheduled to be dropped\n-    /// in `scope` once it has been initialized.\n     crate fn into_expr(\n         &mut self,\n         destination: Place<'tcx>,\n-        scope: Option<region::Scope>,\n         mut block: BasicBlock,\n         expr: Expr<'tcx>,\n     ) -> BlockAnd<()> {\n-        debug!(\n-            \"into_expr(destination={:?}, scope={:?}, block={:?}, expr={:?})\",\n-            destination, scope, block, expr\n-        );\n+        debug!(\"into_expr(destination={:?}, block={:?}, expr={:?})\", destination, block, expr);\n \n         // since we frequently have to reference `self` from within a\n         // closure, where `self` would be shadowed, it's easier to\n@@ -41,14 +31,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let expr_is_block_or_scope =\n             matches!(expr.kind, ExprKind::Block { .. } | ExprKind::Scope { .. });\n \n-        let schedule_drop = move |this: &mut Self| {\n-            if let Some(drop_scope) = scope {\n-                let local =\n-                    destination.as_local().expect(\"cannot schedule drop of non-Local place\");\n-                this.schedule_drop(expr_span, drop_scope, local, DropKind::Value);\n-            }\n-        };\n-\n         if !expr_is_block_or_scope {\n             this.block_context.push(BlockFrame::SubExpr);\n         }\n@@ -58,15 +40,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let region_scope = (region_scope, source_info);\n                 ensure_sufficient_stack(|| {\n                     this.in_scope(region_scope, lint_level, |this| {\n-                        this.into(destination, scope, block, value)\n+                        this.into(destination, block, value)\n                     })\n                 })\n             }\n             ExprKind::Block { body: ast_block } => {\n-                this.ast_block(destination, scope, block, ast_block, source_info)\n+                this.ast_block(destination, block, ast_block, source_info)\n             }\n             ExprKind::Match { scrutinee, arms } => {\n-                this.match_expr(destination, scope, expr_span, block, scrutinee, arms)\n+                this.match_expr(destination, expr_span, block, scrutinee, arms)\n             }\n             ExprKind::If { cond, then, else_opt } => {\n                 let place = unpack!(\n@@ -79,9 +61,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let term = TerminatorKind::if_(this.hir.tcx(), operand, then_block, else_block);\n                 this.cfg.terminate(block, source_info, term);\n \n-                unpack!(then_block = this.into(destination, scope, then_block, then));\n+                unpack!(then_block = this.into(destination, then_block, then));\n                 else_block = if let Some(else_opt) = else_opt {\n-                    unpack!(this.into(destination, None, else_block, else_opt))\n+                    unpack!(this.into(destination, else_block, else_opt))\n                 } else {\n                     // Body of the `if` expression without an `else` clause must return `()`, thus\n                     // we implicitly generate a `else {}` if it is not specified.\n@@ -117,7 +99,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 // This is an optimization. If the expression was a call then we already have an\n                 // unreachable block. Don't bother to terminate it and create a new one.\n-                schedule_drop(this);\n                 if is_call {\n                     block.unit()\n                 } else {\n@@ -193,35 +174,26 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // Start the loop.\n                 this.cfg.goto(block, source_info, loop_block);\n \n-                this.in_breakable_scope(\n-                    Some(loop_block),\n-                    destination,\n-                    scope,\n-                    expr_span,\n-                    move |this| {\n-                        // conduct the test, if necessary\n-                        let body_block = this.cfg.start_new_block();\n-                        this.cfg.terminate(\n-                            loop_block,\n-                            source_info,\n-                            TerminatorKind::FalseUnwind { real_target: body_block, unwind: None },\n-                        );\n-                        this.diverge_from(loop_block);\n-\n-                        // The \u201creturn\u201d value of the loop body must always be an unit. We therefore\n-                        // introduce a unit temporary as the destination for the loop body.\n-                        let tmp = this.get_unit_temp();\n-                        // Execute the body, branching back to the test.\n-                        // We don't need to provide a drop scope because `tmp`\n-                        // has type `()`.\n-                        let body_block_end = unpack!(this.into(tmp, None, body_block, body));\n-                        this.cfg.goto(body_block_end, source_info, loop_block);\n-                        schedule_drop(this);\n-\n-                        // Loops are only exited by `break` expressions.\n-                        None\n-                    },\n-                )\n+                this.in_breakable_scope(Some(loop_block), destination, expr_span, move |this| {\n+                    // conduct the test, if necessary\n+                    let body_block = this.cfg.start_new_block();\n+                    this.cfg.terminate(\n+                        loop_block,\n+                        source_info,\n+                        TerminatorKind::FalseUnwind { real_target: body_block, unwind: None },\n+                    );\n+                    this.diverge_from(loop_block);\n+\n+                    // The \u201creturn\u201d value of the loop body must always be an unit. We therefore\n+                    // introduce a unit temporary as the destination for the loop body.\n+                    let tmp = this.get_unit_temp();\n+                    // Execute the body, branching back to the test.\n+                    let body_block_end = unpack!(this.into(tmp, body_block, body));\n+                    this.cfg.goto(body_block_end, source_info, loop_block);\n+\n+                    // Loops are only exited by `break` expressions.\n+                    None\n+                })\n             }\n             ExprKind::Call { ty: _, fun, args, from_hir_call, fn_span } => {\n                 let fun = unpack!(block = this.as_local_operand(block, fun));\n@@ -256,10 +228,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     },\n                 );\n                 this.diverge_from(block);\n-                schedule_drop(this);\n                 success.unit()\n             }\n-            ExprKind::Use { source } => this.into(destination, scope, block, source),\n+            ExprKind::Use { source } => this.into(destination, block, source),\n             ExprKind::Borrow { arg, borrow_kind } => {\n                 // We don't do this in `as_rvalue` because we use `as_place`\n                 // for borrow expressions, so we cannot create an `RValue` that\n@@ -341,14 +312,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     user_ty,\n                     active_field_index,\n                 );\n-                this.record_operands_moved(&fields);\n                 this.cfg.push_assign(\n                     block,\n                     source_info,\n                     destination,\n                     Rvalue::Aggregate(adt, fields),\n                 );\n-                schedule_drop(this);\n                 block.unit()\n             }\n             ExprKind::InlineAsm { template, operands, options, line_spans } => {\n@@ -445,7 +414,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let place = unpack!(block = this.as_place(block, expr));\n                 let rvalue = Rvalue::Use(this.consume_by_copy_or_move(place));\n                 this.cfg.push_assign(block, source_info, destination, rvalue);\n-                schedule_drop(this);\n                 block.unit()\n             }\n             ExprKind::Index { .. } | ExprKind::Deref { .. } | ExprKind::Field { .. } => {\n@@ -463,22 +431,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let place = unpack!(block = this.as_place(block, expr));\n                 let rvalue = Rvalue::Use(this.consume_by_copy_or_move(place));\n                 this.cfg.push_assign(block, source_info, destination, rvalue);\n-                schedule_drop(this);\n                 block.unit()\n             }\n \n             ExprKind::Yield { value } => {\n                 let scope = this.local_scope();\n                 let value = unpack!(block = this.as_operand(block, Some(scope), value));\n                 let resume = this.cfg.start_new_block();\n-                this.record_operands_moved(slice::from_ref(&value));\n                 this.cfg.terminate(\n                     block,\n                     source_info,\n                     TerminatorKind::Yield { value, resume, resume_arg: destination, drop: None },\n                 );\n                 this.generator_drop_cleanup(block);\n-                schedule_drop(this);\n                 resume.unit()\n             }\n \n@@ -510,7 +475,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 let rvalue = unpack!(block = this.as_local_rvalue(block, expr));\n                 this.cfg.push_assign(block, source_info, destination, rvalue);\n-                schedule_drop(this);\n                 block.unit()\n             }\n         };"}, {"sha": "f117689d940fd7a210183b1d0a526c8032912d46", "filename": "compiler/rustc_mir_build/src/build/expr/stmt.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -3,7 +3,6 @@ use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n use crate::thir::*;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n-use std::slice;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Builds a block of MIR statements to evaluate the THIR `expr`.\n@@ -47,7 +46,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 if this.hir.needs_drop(lhs.ty) {\n                     let rhs = unpack!(block = this.as_local_operand(block, rhs));\n                     let lhs = unpack!(block = this.as_place(block, lhs));\n-                    this.record_operands_moved(slice::from_ref(&rhs));\n                     unpack!(block = this.build_drop_and_replace(block, lhs_span, lhs, rhs));\n                 } else {\n                     let rhs = unpack!(block = this.as_local_rvalue(block, rhs));"}, {"sha": "7264e495b84fd0dc6026c67f156f4cb25c40a428", "filename": "compiler/rustc_mir_build/src/build/into.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Finto.rs?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -6,15 +6,13 @@\n \n use crate::build::{BlockAnd, Builder};\n use crate::thir::*;\n-use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n \n pub(in crate::build) trait EvalInto<'tcx> {\n     fn eval_into(\n         self,\n         builder: &mut Builder<'_, 'tcx>,\n         destination: Place<'tcx>,\n-        scope: Option<region::Scope>,\n         block: BasicBlock,\n     ) -> BlockAnd<()>;\n }\n@@ -23,14 +21,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn into<E>(\n         &mut self,\n         destination: Place<'tcx>,\n-        scope: Option<region::Scope>,\n         block: BasicBlock,\n         expr: E,\n     ) -> BlockAnd<()>\n     where\n         E: EvalInto<'tcx>,\n     {\n-        expr.eval_into(self, destination, scope, block)\n+        expr.eval_into(self, destination, block)\n     }\n }\n \n@@ -39,11 +36,10 @@ impl<'tcx> EvalInto<'tcx> for ExprRef<'tcx> {\n         self,\n         builder: &mut Builder<'_, 'tcx>,\n         destination: Place<'tcx>,\n-        scope: Option<region::Scope>,\n         block: BasicBlock,\n     ) -> BlockAnd<()> {\n         let expr = builder.hir.mirror(self);\n-        builder.into_expr(destination, scope, block, expr)\n+        builder.into_expr(destination, block, expr)\n     }\n }\n \n@@ -52,9 +48,8 @@ impl<'tcx> EvalInto<'tcx> for Expr<'tcx> {\n         self,\n         builder: &mut Builder<'_, 'tcx>,\n         destination: Place<'tcx>,\n-        scope: Option<region::Scope>,\n         block: BasicBlock,\n     ) -> BlockAnd<()> {\n-        builder.into_expr(destination, scope, block, self)\n+        builder.into_expr(destination, block, self)\n     }\n }"}, {"sha": "fde007ec011bae21348890a40dd259b8c1cd88ba", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 69, "deletions": 9, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -87,7 +87,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn match_expr(\n         &mut self,\n         destination: Place<'tcx>,\n-        destination_scope: Option<region::Scope>,\n         span: Span,\n         mut block: BasicBlock,\n         scrutinee: ExprRef<'tcx>,\n@@ -108,7 +107,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         self.lower_match_arms(\n             destination,\n-            destination_scope,\n             scrutinee_place,\n             scrutinee_span,\n             arm_candidates,\n@@ -215,13 +213,76 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    /// Lower the bindings, guards and arm bodies of a `match` expression.\n+    ///\n+    /// The decision tree should have already been created\n+    /// (by [Builder::lower_match_tree]).\n+    ///\n+    /// `outer_source_info` is the SourceInfo for the whole match.\n+    fn lower_match_arms(\n+        &mut self,\n+        destination: Place<'tcx>,\n+        scrutinee_place: Place<'tcx>,\n+        scrutinee_span: Span,\n+        arm_candidates: Vec<(&'_ Arm<'tcx>, Candidate<'_, 'tcx>)>,\n+        outer_source_info: SourceInfo,\n+        fake_borrow_temps: Vec<(Place<'tcx>, Local)>,\n+    ) -> BlockAnd<()> {\n+        let arm_end_blocks: Vec<_> = arm_candidates\n+            .into_iter()\n+            .map(|(arm, candidate)| {\n+                debug!(\"lowering arm {:?}\\ncandidate = {:?}\", arm, candidate);\n+\n+                let arm_source_info = self.source_info(arm.span);\n+                let arm_scope = (arm.scope, arm_source_info);\n+                self.in_scope(arm_scope, arm.lint_level, |this| {\n+                    let body = this.hir.mirror(arm.body.clone());\n+                    let scope = this.declare_bindings(\n+                        None,\n+                        arm.span,\n+                        &arm.pattern,\n+                        ArmHasGuard(arm.guard.is_some()),\n+                        Some((Some(&scrutinee_place), scrutinee_span)),\n+                    );\n+\n+                    let arm_block = this.bind_pattern(\n+                        outer_source_info,\n+                        candidate,\n+                        arm.guard.as_ref(),\n+                        &fake_borrow_temps,\n+                        scrutinee_span,\n+                        Some(arm.span),\n+                        Some(arm.scope),\n+                    );\n+\n+                    if let Some(source_scope) = scope {\n+                        this.source_scope = source_scope;\n+                    }\n+\n+                    this.into(destination, arm_block, body)\n+                })\n+            })\n+            .collect();\n+\n+        // all the arm blocks will rejoin here\n+        let end_block = self.cfg.start_new_block();\n+\n+        for arm_block in arm_end_blocks {\n+            self.cfg.goto(unpack!(arm_block), outer_source_info, end_block);\n+        }\n+\n+        self.source_scope = outer_source_info.scope;\n+\n+        end_block.unit()\n+    }\n+\n     /// Binds the variables and ascribes types for a given `match` arm or\n     /// `let` binding.\n     ///\n     /// Also check if the guard matches, if it's provided.\n     /// `arm_scope` should be `Some` if and only if this is called for a\n     /// `match` arm.\n-    crate fn bind_pattern(\n+    fn bind_pattern(\n         &mut self,\n         outer_source_info: SourceInfo,\n         candidate: Candidate<'_, 'tcx>,\n@@ -308,14 +369,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             PatKind::Binding { mode: BindingMode::ByValue, var, subpattern: None, .. } => {\n                 let place =\n                     self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard, true);\n-                let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n-\n-                unpack!(block = self.into(place, Some(region_scope), block, initializer));\n+                unpack!(block = self.into(place, block, initializer));\n \n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n                 let source_info = self.source_info(irrefutable_pat.span);\n                 self.cfg.push_fake_read(block, source_info, FakeReadCause::ForLet, place);\n \n+                self.schedule_drop_for_binding(var, irrefutable_pat.span, OutsideGuard);\n                 block.unit()\n             }\n \n@@ -342,10 +402,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 ascription:\n                     thir::pattern::Ascription { user_ty: pat_ascription_ty, variance: _, user_ty_span },\n             } => {\n-                let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n                 let place =\n                     self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard, true);\n-                unpack!(block = self.into(place, Some(region_scope), block, initializer));\n+                unpack!(block = self.into(place, block, initializer));\n \n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n                 let pattern_source_info = self.source_info(irrefutable_pat.span);\n@@ -383,6 +442,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     },\n                 );\n \n+                self.schedule_drop_for_binding(var, irrefutable_pat.span, OutsideGuard);\n                 block.unit()\n             }\n \n@@ -629,7 +689,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n }\n \n #[derive(Debug)]\n-pub(super) struct Candidate<'pat, 'tcx> {\n+struct Candidate<'pat, 'tcx> {\n     /// [`Span`] of the original pattern that gave rise to this candidate.\n     span: Span,\n "}, {"sha": "5f6c8d26402eddc3af3bebaed00d41f59a8913cd", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -618,12 +618,8 @@ where\n         let arg_scope_s = (arg_scope, source_info);\n         // Attribute epilogue to function's closing brace\n         let fn_end = span_with_body.shrink_to_hi();\n-        let return_block = unpack!(builder.in_breakable_scope(\n-            None,\n-            Place::return_place(),\n-            Some(call_site_scope),\n-            fn_end,\n-            |builder| {\n+        let return_block =\n+            unpack!(builder.in_breakable_scope(None, Place::return_place(), fn_end, |builder| {\n                 Some(builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n                     builder.args_and_body(\n                         START_BLOCK,\n@@ -633,13 +629,11 @@ where\n                         &body.value,\n                     )\n                 }))\n-            },\n-        ));\n+            }));\n         let source_info = builder.source_info(fn_end);\n         builder.cfg.terminate(return_block, source_info, TerminatorKind::Return);\n         let should_abort = should_abort_on_panic(tcx, fn_def_id, abi);\n         builder.build_drop_trees(should_abort);\n-        builder.unschedule_return_place_drop();\n         return_block.unit()\n     }));\n \n@@ -672,9 +666,7 @@ fn construct_const<'a, 'tcx>(\n     let mut block = START_BLOCK;\n     let ast_expr = &tcx.hir().body(body_id).value;\n     let expr = builder.hir.mirror(ast_expr);\n-    // We don't provide a scope because we can't unwind in constants, so won't\n-    // need to drop the return place.\n-    unpack!(block = builder.into_expr(Place::return_place(), None, block, expr));\n+    unpack!(block = builder.into_expr(Place::return_place(), block, expr));\n \n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(block, source_info, TerminatorKind::Return);\n@@ -953,9 +945,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         let body = self.hir.mirror(ast_body);\n-        let call_site =\n-            region::Scope { id: ast_body.hir_id.local_id, data: region::ScopeData::CallSite };\n-        self.into(Place::return_place(), Some(call_site), block, body)\n+        self.into(Place::return_place(), block, body)\n     }\n \n     fn set_correct_source_scope_for_arg("}, {"sha": "5e9d780d1797752d17fd8e4ea671bff61435746c", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 42, "deletions": 174, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -81,10 +81,9 @@ that contains only loops and breakable blocks. It tracks where a `break`,\n \n */\n \n-use crate::build::matches::{ArmHasGuard, Candidate};\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder, CFG};\n-use crate::thir::{Arm, Expr, ExprRef, LintLevel};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use crate::thir::{Expr, ExprRef, LintLevel};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::IndexVec;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n@@ -121,6 +120,8 @@ struct Scope {\n     /// end of the vector (top of the stack) first.\n     drops: Vec<DropData>,\n \n+    moved_locals: Vec<Local>,\n+\n     /// The drop index that will drop everything in and below this scope on an\n     /// unwind path.\n     cached_unwind_block: Option<DropIdx>,\n@@ -156,8 +157,6 @@ struct BreakableScope<'tcx> {\n     /// The destination of the loop/block expression itself (i.e., where to put\n     /// the result of a `break` or `return` expression)\n     break_destination: Place<'tcx>,\n-    /// The scope that the destination should have its drop scheduled in.\n-    destination_scope: Option<region::Scope>,\n     /// Drops that happen on the `break`/`return` path.\n     break_drops: DropTree,\n     /// Drops that happen on the `continue` path.\n@@ -406,6 +405,7 @@ impl<'tcx> Scopes<'tcx> {\n             region_scope: region_scope.0,\n             region_scope_span: region_scope.1.span,\n             drops: vec![],\n+            moved_locals: vec![],\n             cached_unwind_block: None,\n             cached_generator_drop_block: None,\n         });\n@@ -440,7 +440,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         loop_block: Option<BasicBlock>,\n         break_destination: Place<'tcx>,\n-        destination_scope: Option<region::Scope>,\n         span: Span,\n         f: F,\n     ) -> BlockAnd<()>\n@@ -451,19 +450,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let scope = BreakableScope {\n             region_scope,\n             break_destination,\n-            destination_scope,\n             break_drops: DropTree::new(),\n             continue_drops: loop_block.map(|_| DropTree::new()),\n         };\n-        let continue_block = loop_block.map(|block| (block, self.diverge_cleanup()));\n         self.scopes.breakable_scopes.push(scope);\n         let normal_exit_block = f(self);\n         let breakable_scope = self.scopes.breakable_scopes.pop().unwrap();\n         assert!(breakable_scope.region_scope == region_scope);\n+        let break_block = self.build_exit_tree(breakable_scope.break_drops, None);\n         if let Some(drops) = breakable_scope.continue_drops {\n-            self.build_exit_tree(drops, continue_block);\n+            self.build_exit_tree(drops, loop_block);\n         }\n-        let break_block = self.build_exit_tree(breakable_scope.break_drops, None);\n         match (normal_exit_block, break_block) {\n             (Some(block), None) | (None, Some(block)) => block,\n             (None, None) => self.cfg.start_new_block().unit(),\n@@ -592,33 +589,30 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 .rposition(|breakable_scope| breakable_scope.region_scope == scope)\n                 .unwrap_or_else(|| span_bug!(span, \"no enclosing breakable scope found\"))\n         };\n-        let (break_index, destination, dest_scope) = match target {\n+        let (break_index, destination) = match target {\n             BreakableTarget::Return => {\n                 let scope = &self.scopes.breakable_scopes[0];\n                 if scope.break_destination != Place::return_place() {\n                     span_bug!(span, \"`return` in item with no return scope\");\n                 }\n-                (0, Some(scope.break_destination), scope.destination_scope)\n+                (0, Some(scope.break_destination))\n             }\n             BreakableTarget::Break(scope) => {\n                 let break_index = get_scope_index(scope);\n                 let scope = &self.scopes.breakable_scopes[break_index];\n-                (break_index, Some(scope.break_destination), scope.destination_scope)\n+                (break_index, Some(scope.break_destination))\n             }\n             BreakableTarget::Continue(scope) => {\n                 let break_index = get_scope_index(scope);\n-                (break_index, None, None)\n+                (break_index, None)\n             }\n         };\n \n         if let Some(destination) = destination {\n             if let Some(value) = value {\n                 debug!(\"stmt_expr Break val block_context.push(SubExpr)\");\n                 self.block_context.push(BlockFrame::SubExpr);\n-                unpack!(block = self.into(destination, dest_scope, block, value));\n-                if let Some(scope) = dest_scope {\n-                    self.unschedule_drop(scope, destination.as_local().unwrap())\n-                };\n+                unpack!(block = self.into(destination, block, value));\n                 self.block_context.pop();\n             } else {\n                 self.cfg.push_assign_unit(block, source_info, destination, self.hir.tcx())\n@@ -858,47 +852,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         span_bug!(span, \"region scope {:?} not in scope to drop {:?}\", region_scope, local);\n     }\n \n-    /// Unschedule a drop. Used for `break`, `return` and `match` expressions,\n-    /// where `record_operands_moved` is not powerful enough.\n-    ///\n-    /// The given local is expected to have a value drop scheduled in the given\n-    /// scope and for that drop to be the most recent thing scheduled in that\n-    /// scope.\n-    fn unschedule_drop(&mut self, region_scope: region::Scope, local: Local) {\n-        if !self.hir.needs_drop(self.local_decls[local].ty) {\n-            return;\n-        }\n-        for scope in self.scopes.scopes.iter_mut().rev() {\n-            scope.invalidate_cache();\n-\n-            if scope.region_scope == region_scope {\n-                let drop = scope.drops.pop();\n-\n-                match drop {\n-                    Some(DropData { local: removed_local, kind: DropKind::Value, .. })\n-                        if removed_local == local =>\n-                    {\n-                        return;\n-                    }\n-                    _ => bug!(\n-                        \"found wrong drop, expected value drop of {:?}, found {:?}\",\n-                        local,\n-                        drop,\n-                    ),\n-                }\n-            }\n-        }\n-\n-        bug!(\"region scope {:?} not in scope to unschedule drop of {:?}\", region_scope, local);\n-    }\n-\n-    /// Indicates that the \"local operands\" stored in `local` is\n+    /// Indicates that the \"local operand\" stored in `local` is\n     /// *moved* at some point during execution (see `local_scope` for\n     /// more information about what a \"local operand\" is -- in short,\n     /// it's an intermediate operand created as part of preparing some\n     /// MIR instruction). We use this information to suppress\n-    /// redundant drops. This results in less MIR, but also avoids spurious\n-    /// borrow check errors (c.f. #64391).\n+    /// redundant drops on the non-unwind paths. This results in less\n+    /// MIR, but also avoids spurious borrow check errors\n+    /// (c.f. #64391).\n     ///\n     /// Example: when compiling the call to `foo` here:\n     ///\n@@ -934,19 +895,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         assert_eq!(scope.region_scope, local_scope, \"local scope is not the topmost scope!\",);\n \n         // look for moves of a local variable, like `MOVE(_X)`\n-        let locals_moved = operands\n-            .iter()\n-            .filter_map(|operand| match operand {\n-                Operand::Copy(_) | Operand::Constant(_) => None,\n-                Operand::Move(place) => place.as_local(),\n-            })\n-            .collect::<FxHashSet<_>>();\n+        let locals_moved = operands.iter().flat_map(|operand| match operand {\n+            Operand::Copy(_) | Operand::Constant(_) => None,\n+            Operand::Move(place) => place.as_local(),\n+        });\n \n-        // Remove the drops for the moved operands.\n-        scope\n-            .drops\n-            .retain(|drop| drop.kind == DropKind::Storage || !locals_moved.contains(&drop.local));\n-        scope.invalidate_cache();\n+        for local in locals_moved {\n+            // check if we have a Drop for this operand and -- if so\n+            // -- add it to the list of moved operands. Note that this\n+            // local might not have been an operand created for this\n+            // call, it could come from other places too.\n+            if scope.drops.iter().any(|drop| drop.local == local && drop.kind == DropKind::Value) {\n+                scope.moved_locals.push(local);\n+            }\n+        }\n     }\n \n     // Other\n@@ -1133,116 +1095,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         success_block\n     }\n \n-    /// Lower the arms and guards of a match.\n-    ///\n-    /// The decision tree should have already been created (by\n-    /// [Builder::lower_match_tree]).\n-    ///\n-    /// This is this module, and not in `build::matches` because we have to do\n-    /// some careful scope manipulation to have the drop of the destination be\n-    /// scheduled at the end of each arm and then cleared for the next arm.\n-    crate fn lower_match_arms(\n-        &mut self,\n-        destination: Place<'tcx>,\n-        destination_scope: Option<region::Scope>,\n-        scrutinee_place: Place<'tcx>,\n-        scrutinee_span: Span,\n-        arm_candidates: Vec<(&'_ Arm<'tcx>, Candidate<'_, 'tcx>)>,\n-        outer_source_info: SourceInfo,\n-        fake_borrow_temps: Vec<(Place<'tcx>, Local)>,\n-    ) -> BlockAnd<()> {\n-        if arm_candidates.is_empty() {\n-            // If there are no arms to schedule drops, then we have to do it\n-            // manually.\n-            if let Some(scope) = destination_scope {\n-                self.schedule_drop(\n-                    outer_source_info.span,\n-                    scope,\n-                    destination.as_local().unwrap(),\n-                    DropKind::Value,\n-                );\n-            }\n-            return self.cfg.start_new_block().unit();\n-        }\n-        let mut first_arm = true;\n-        let arm_end_blocks: Vec<_> = arm_candidates\n-            .into_iter()\n-            .map(|(arm, candidate)| {\n-                debug!(\"lowering arm {:?}\\ncandidate = {:?}\", arm, candidate);\n-\n-                if first_arm {\n-                    first_arm = false;\n-                } else if let Some(scope) = destination_scope {\n-                    self.unschedule_drop(scope, destination.as_local().unwrap());\n-                }\n-\n-                let arm_source_info = self.source_info(arm.span);\n-                let arm_scope = (arm.scope, arm_source_info);\n-                self.in_scope(arm_scope, arm.lint_level, |this| {\n-                    let body = this.hir.mirror(arm.body.clone());\n-                    let scope = this.declare_bindings(\n-                        None,\n-                        arm.span,\n-                        &arm.pattern,\n-                        ArmHasGuard(arm.guard.is_some()),\n-                        Some((Some(&scrutinee_place), scrutinee_span)),\n-                    );\n-\n-                    let arm_block = this.bind_pattern(\n-                        outer_source_info,\n-                        candidate,\n-                        arm.guard.as_ref(),\n-                        &fake_borrow_temps,\n-                        scrutinee_span,\n-                        Some(arm.span),\n-                        Some(arm.scope),\n-                    );\n-\n-                    if let Some(source_scope) = scope {\n-                        this.source_scope = source_scope;\n-                    }\n-\n-                    this.into(destination, destination_scope, arm_block, body)\n-                })\n-            })\n-            .collect();\n-\n-        // all the arm blocks will rejoin here\n-        let end_block = self.cfg.start_new_block();\n-\n-        for arm_block in arm_end_blocks {\n-            self.cfg.goto(unpack!(arm_block), outer_source_info, end_block);\n-        }\n-\n-        self.source_scope = outer_source_info.scope;\n-\n-        end_block.unit()\n-    }\n-\n     /// Unschedules any drops in the top scope.\n     ///\n     /// This is only needed for `match` arm scopes, because they have one\n     /// entrance per pattern, but only one exit.\n-    pub(super) fn clear_top_scope(&mut self, region_scope: region::Scope) {\n+    crate fn clear_top_scope(&mut self, region_scope: region::Scope) {\n         let top_scope = self.scopes.scopes.last_mut().unwrap();\n \n         assert_eq!(top_scope.region_scope, region_scope);\n \n         top_scope.drops.clear();\n         top_scope.invalidate_cache();\n     }\n-\n-    /// Unschedules the drop of the return place.\n-    ///\n-    /// If the return type of a function requires drop, then we schedule it\n-    /// in the outermost scope so that it's dropped if there's a panic while\n-    /// we drop any local variables. But we don't want to drop it if we\n-    /// return normally.\n-    crate fn unschedule_return_place_drop(&mut self) {\n-        assert_eq!(self.scopes.scopes.len(), 1);\n-        assert!(self.scopes.scopes[0].drops.len() <= 1);\n-        self.scopes.scopes[0].drops.clear();\n-    }\n }\n \n /// Builds drops for `pop_scope` and `leave_top_scope`.\n@@ -1289,6 +1153,14 @@ fn build_scope_drops<'tcx>(\n                 debug_assert_eq!(unwind_drops.drops[unwind_to].0.kind, drop_data.kind);\n                 unwind_to = unwind_drops.drops[unwind_to].1;\n \n+                // If the operand has been moved, and we are not on an unwind\n+                // path, then don't generate the drop. (We only take this into\n+                // account for non-unwind paths so as not to disturb the\n+                // caching mechanism.)\n+                if scope.moved_locals.iter().any(|&o| o == local) {\n+                    continue;\n+                }\n+\n                 unwind_drops.add_entry(block, unwind_to);\n \n                 let next = cfg.start_new_block();\n@@ -1318,24 +1190,20 @@ impl<'a, 'tcx: 'a> Builder<'a, 'tcx> {\n     /// Build a drop tree for a breakable scope.\n     ///\n     /// If `continue_block` is `Some`, then the tree is for `continue` inside a\n-    /// loop. Otherwise this is for `break` or `return`. The `DropIdx` is the\n-    /// next drop in the case that the drop tree unwinds. This is needed\n-    /// because the drop of the break destination has already been scheduled\n-    /// but it hasn't been initialized on the `continue` paths.\n+    /// loop. Otherwise this is for `break` or `return`.\n     fn build_exit_tree(\n         &mut self,\n         mut drops: DropTree,\n-        continue_block: Option<(BasicBlock, DropIdx)>,\n+        continue_block: Option<BasicBlock>,\n     ) -> Option<BlockAnd<()>> {\n         let mut blocks = IndexVec::from_elem(None, &drops.drops);\n-        blocks[ROOT_NODE] = continue_block.map(|(block, _)| block);\n+        blocks[ROOT_NODE] = continue_block;\n \n         drops.build_mir::<ExitScopes>(&mut self.cfg, &mut blocks);\n \n         // Link the exit drop tree to unwind drop tree.\n         if drops.drops.iter().any(|(drop, _)| drop.kind == DropKind::Value) {\n-            let unwind_target = continue_block\n-                .map_or_else(|| self.diverge_cleanup(), |(_, unwind_target)| unwind_target);\n+            let unwind_target = self.diverge_cleanup();\n             let mut unwind_indices = IndexVec::from_elem_n(unwind_target, 1);\n             for (drop_idx, drop_data) in drops.drops.iter_enumerated().skip(1) {\n                 match drop_data.0.kind {"}, {"sha": "cf6bf7c7c99ed746e83da011876e8369de340484", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -1882,7 +1882,7 @@ fn test_append_drop_leak() {\n \n     catch_unwind(move || left.append(&mut right)).unwrap_err();\n \n-    assert_eq!(DROPS.load(SeqCst), 5);\n+    assert_eq!(DROPS.load(SeqCst), 4); // Rust issue #47949 ate one little piggy\n }\n \n #[test]"}, {"sha": "7e0ca3dea4b71aafe350344b65ab54fe88890b60", "filename": "src/test/mir-opt/basic_assignment.main.SimplifyCfg-initial.after.mir", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fmir-opt%2Fbasic_assignment.main.SimplifyCfg-initial.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fmir-opt%2Fbasic_assignment.main.SimplifyCfg-initial.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbasic_assignment.main.SimplifyCfg-initial.after.mir?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -41,36 +41,44 @@ fn main() -> () {\n         StorageLive(_5);                 // scope 3 at $DIR/basic_assignment.rs:19:9: 19:15\n         StorageLive(_6);                 // scope 4 at $DIR/basic_assignment.rs:23:14: 23:20\n         _6 = move _4;                    // scope 4 at $DIR/basic_assignment.rs:23:14: 23:20\n-        replace(_5 <- move _6) -> [return: bb1, unwind: bb4]; // scope 4 at $DIR/basic_assignment.rs:23:5: 23:11\n+        replace(_5 <- move _6) -> [return: bb1, unwind: bb5]; // scope 4 at $DIR/basic_assignment.rs:23:5: 23:11\n     }\n \n     bb1: {\n+        drop(_6) -> [return: bb2, unwind: bb6]; // scope 4 at $DIR/basic_assignment.rs:23:19: 23:20\n+    }\n+\n+    bb2: {\n         StorageDead(_6);                 // scope 4 at $DIR/basic_assignment.rs:23:19: 23:20\n         _0 = const ();                   // scope 0 at $DIR/basic_assignment.rs:10:11: 24:2\n-        drop(_5) -> [return: bb2, unwind: bb5]; // scope 3 at $DIR/basic_assignment.rs:24:1: 24:2\n+        drop(_5) -> [return: bb3, unwind: bb7]; // scope 3 at $DIR/basic_assignment.rs:24:1: 24:2\n     }\n \n-    bb2: {\n+    bb3: {\n         StorageDead(_5);                 // scope 3 at $DIR/basic_assignment.rs:24:1: 24:2\n-        drop(_4) -> [return: bb3, unwind: bb6]; // scope 2 at $DIR/basic_assignment.rs:24:1: 24:2\n+        drop(_4) -> [return: bb4, unwind: bb8]; // scope 2 at $DIR/basic_assignment.rs:24:1: 24:2\n     }\n \n-    bb3: {\n+    bb4: {\n         StorageDead(_4);                 // scope 2 at $DIR/basic_assignment.rs:24:1: 24:2\n         StorageDead(_2);                 // scope 1 at $DIR/basic_assignment.rs:24:1: 24:2\n         StorageDead(_1);                 // scope 0 at $DIR/basic_assignment.rs:24:1: 24:2\n         return;                          // scope 0 at $DIR/basic_assignment.rs:24:2: 24:2\n     }\n \n-    bb4 (cleanup): {\n-        drop(_5) -> bb5;                 // scope 3 at $DIR/basic_assignment.rs:24:1: 24:2\n-    }\n-\n     bb5 (cleanup): {\n-        drop(_4) -> bb6;                 // scope 2 at $DIR/basic_assignment.rs:24:1: 24:2\n+        drop(_6) -> bb6;                 // scope 4 at $DIR/basic_assignment.rs:23:19: 23:20\n     }\n \n     bb6 (cleanup): {\n+        drop(_5) -> bb7;                 // scope 3 at $DIR/basic_assignment.rs:24:1: 24:2\n+    }\n+\n+    bb7 (cleanup): {\n+        drop(_4) -> bb8;                 // scope 2 at $DIR/basic_assignment.rs:24:1: 24:2\n+    }\n+\n+    bb8 (cleanup): {\n         resume;                          // scope 0 at $DIR/basic_assignment.rs:10:1: 24:2\n     }\n }"}, {"sha": "cfbd3a58637c0edd08c958bf59739c1b9841d761", "filename": "src/test/mir-opt/box_expr.main.ElaborateDrops.before.mir", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fmir-opt%2Fbox_expr.main.ElaborateDrops.before.mir", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fmir-opt%2Fbox_expr.main.ElaborateDrops.before.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbox_expr.main.ElaborateDrops.before.mir?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -14,45 +14,53 @@ fn main() -> () {\n         StorageLive(_1);                 // scope 0 at $DIR/box_expr.rs:7:9: 7:10\n         StorageLive(_2);                 // scope 0 at $DIR/box_expr.rs:7:13: 7:25\n         _2 = Box(S);                     // scope 0 at $DIR/box_expr.rs:7:13: 7:25\n-        (*_2) = S::new() -> [return: bb1, unwind: bb5]; // scope 0 at $DIR/box_expr.rs:7:17: 7:25\n+        (*_2) = S::new() -> [return: bb1, unwind: bb7]; // scope 0 at $DIR/box_expr.rs:7:17: 7:25\n                                          // mir::Constant\n                                          // + span: $DIR/box_expr.rs:7:17: 7:23\n                                          // + literal: Const { ty: fn() -> S {S::new}, val: Value(Scalar(<ZST>)) }\n     }\n \n     bb1: {\n         _1 = move _2;                    // scope 0 at $DIR/box_expr.rs:7:13: 7:25\n+        drop(_2) -> bb2;                 // scope 0 at $DIR/box_expr.rs:7:24: 7:25\n+    }\n+\n+    bb2: {\n         StorageDead(_2);                 // scope 0 at $DIR/box_expr.rs:7:24: 7:25\n         StorageLive(_3);                 // scope 1 at $DIR/box_expr.rs:8:5: 8:12\n         StorageLive(_4);                 // scope 1 at $DIR/box_expr.rs:8:10: 8:11\n         _4 = move _1;                    // scope 1 at $DIR/box_expr.rs:8:10: 8:11\n-        _3 = std::mem::drop::<Box<S>>(move _4) -> [return: bb2, unwind: bb4]; // scope 1 at $DIR/box_expr.rs:8:5: 8:12\n+        _3 = std::mem::drop::<Box<S>>(move _4) -> [return: bb3, unwind: bb5]; // scope 1 at $DIR/box_expr.rs:8:5: 8:12\n                                          // mir::Constant\n                                          // + span: $DIR/box_expr.rs:8:5: 8:9\n                                          // + literal: Const { ty: fn(std::boxed::Box<S>) {std::mem::drop::<std::boxed::Box<S>>}, val: Value(Scalar(<ZST>)) }\n     }\n \n-    bb2: {\n+    bb3: {\n         StorageDead(_4);                 // scope 1 at $DIR/box_expr.rs:8:11: 8:12\n         StorageDead(_3);                 // scope 1 at $DIR/box_expr.rs:8:12: 8:13\n         _0 = const ();                   // scope 0 at $DIR/box_expr.rs:6:11: 9:2\n-        drop(_1) -> bb3;                 // scope 0 at $DIR/box_expr.rs:9:1: 9:2\n+        drop(_1) -> bb4;                 // scope 0 at $DIR/box_expr.rs:9:1: 9:2\n     }\n \n-    bb3: {\n+    bb4: {\n         StorageDead(_1);                 // scope 0 at $DIR/box_expr.rs:9:1: 9:2\n         return;                          // scope 0 at $DIR/box_expr.rs:9:2: 9:2\n     }\n \n-    bb4 (cleanup): {\n-        drop(_1) -> bb6;                 // scope 0 at $DIR/box_expr.rs:9:1: 9:2\n-    }\n-\n     bb5 (cleanup): {\n-        drop(_2) -> bb6;                 // scope 0 at $DIR/box_expr.rs:7:24: 7:25\n+        drop(_4) -> bb6;                 // scope 1 at $DIR/box_expr.rs:8:11: 8:12\n     }\n \n     bb6 (cleanup): {\n+        drop(_1) -> bb8;                 // scope 0 at $DIR/box_expr.rs:9:1: 9:2\n+    }\n+\n+    bb7 (cleanup): {\n+        drop(_2) -> bb8;                 // scope 0 at $DIR/box_expr.rs:7:24: 7:25\n+    }\n+\n+    bb8 (cleanup): {\n         resume;                          // scope 0 at $DIR/box_expr.rs:6:1: 9:2\n     }\n }"}, {"sha": "07994eb3c16613170e83220a715df13a0c14d475", "filename": "src/test/mir-opt/inline/inline_diverging.h.Inline.diff", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -5,19 +5,18 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/inline-diverging.rs:21:12: 21:12\n       let _1: (!, !);                      // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n +     let mut _2: fn() -> ! {sleep};       // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n++     let mut _7: ();                      // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n +     let mut _8: ();                      // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n-+     let mut _9: ();                      // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n +     scope 1 (inlined call_twice::<!, fn() -> ! {sleep}>) { // at $DIR/inline-diverging.rs:22:5: 22:22\n +         debug f => _2;                   // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n +         let _3: !;                       // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n +         let mut _4: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n +         let mut _5: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n +         let mut _6: !;                   // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n-+         let mut _7: !;                   // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n +         scope 2 {\n +             debug a => _3;               // in scope 2 at $DIR/inline-diverging.rs:22:5: 22:22\n +             scope 3 {\n-+                 debug b => _7;           // in scope 3 at $DIR/inline-diverging.rs:22:5: 22:22\n++                 debug b => _6;           // in scope 3 at $DIR/inline-diverging.rs:22:5: 22:22\n +             }\n +             scope 6 (inlined <fn() -> ! {sleep} as Fn<()>>::call - shim(fn() -> ! {sleep})) { // at $DIR/inline-diverging.rs:22:5: 22:22\n +                 scope 7 (inlined sleep) { // at $DIR/inline-diverging.rs:22:5: 22:22\n@@ -41,12 +40,12 @@\n -                                          // mir::Constant\n                                            // + span: $DIR/inline-diverging.rs:22:16: 22:21\n                                            // + literal: Const { ty: fn() -> ! {sleep}, val: Value(Scalar(<ZST>)) }\n-+         StorageLive(_7);                 // scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n++         StorageLive(_6);                 // scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n +         StorageLive(_3);                 // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n +         StorageLive(_4);                 // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n +         _4 = &_2;                        // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n-+         StorageLive(_8);                 // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n-+         _8 = const ();                   // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         StorageLive(_7);                 // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         _7 = const ();                   // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n +         goto -> bb1;                     // scope 5 at $DIR/inline-diverging.rs:22:5: 22:22\n       }\n   "}, {"sha": "7113c42b9c77f97088ae3ab70be33c53fdb48e96", "filename": "src/test/mir-opt/issue_41110.main.ElaborateDrops.after.mir", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fmir-opt%2Fissue_41110.main.ElaborateDrops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fmir-opt%2Fissue_41110.main.ElaborateDrops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_41110.main.ElaborateDrops.after.mir?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -6,44 +6,65 @@ fn main() -> () {\n     let mut _2: S;                       // in scope 0 at $DIR/issue-41110.rs:8:13: 8:14\n     let mut _3: S;                       // in scope 0 at $DIR/issue-41110.rs:8:21: 8:27\n     let mut _4: S;                       // in scope 0 at $DIR/issue-41110.rs:8:21: 8:22\n+    let mut _5: bool;                    // in scope 0 at $DIR/issue-41110.rs:8:27: 8:28\n     scope 1 {\n         debug x => _1;                   // in scope 1 at $DIR/issue-41110.rs:8:9: 8:10\n     }\n \n     bb0: {\n+        _5 = const false;                // scope 0 at $DIR/issue-41110.rs:8:9: 8:10\n         StorageLive(_1);                 // scope 0 at $DIR/issue-41110.rs:8:9: 8:10\n         StorageLive(_2);                 // scope 0 at $DIR/issue-41110.rs:8:13: 8:14\n+        _5 = const true;                 // scope 0 at $DIR/issue-41110.rs:8:13: 8:14\n         _2 = S;                          // scope 0 at $DIR/issue-41110.rs:8:13: 8:14\n         StorageLive(_3);                 // scope 0 at $DIR/issue-41110.rs:8:21: 8:27\n         StorageLive(_4);                 // scope 0 at $DIR/issue-41110.rs:8:21: 8:22\n         _4 = S;                          // scope 0 at $DIR/issue-41110.rs:8:21: 8:22\n-        _3 = S::id(move _4) -> [return: bb1, unwind: bb3]; // scope 0 at $DIR/issue-41110.rs:8:21: 8:27\n+        _3 = S::id(move _4) -> [return: bb1, unwind: bb4]; // scope 0 at $DIR/issue-41110.rs:8:21: 8:27\n                                          // mir::Constant\n                                          // + span: $DIR/issue-41110.rs:8:23: 8:25\n                                          // + literal: Const { ty: fn(S) -> S {S::id}, val: Value(Scalar(<ZST>)) }\n     }\n \n     bb1: {\n         StorageDead(_4);                 // scope 0 at $DIR/issue-41110.rs:8:26: 8:27\n-        _1 = S::other(move _2, move _3) -> bb2; // scope 0 at $DIR/issue-41110.rs:8:13: 8:28\n+        _5 = const false;                // scope 0 at $DIR/issue-41110.rs:8:13: 8:28\n+        _1 = S::other(move _2, move _3) -> [return: bb2, unwind: bb3]; // scope 0 at $DIR/issue-41110.rs:8:13: 8:28\n                                          // mir::Constant\n                                          // + span: $DIR/issue-41110.rs:8:15: 8:20\n                                          // + literal: Const { ty: fn(S, S) {S::other}, val: Value(Scalar(<ZST>)) }\n     }\n \n     bb2: {\n         StorageDead(_3);                 // scope 0 at $DIR/issue-41110.rs:8:27: 8:28\n+        _5 = const false;                // scope 0 at $DIR/issue-41110.rs:8:27: 8:28\n         StorageDead(_2);                 // scope 0 at $DIR/issue-41110.rs:8:27: 8:28\n         _0 = const ();                   // scope 0 at $DIR/issue-41110.rs:7:11: 9:2\n         StorageDead(_1);                 // scope 0 at $DIR/issue-41110.rs:9:1: 9:2\n         return;                          // scope 0 at $DIR/issue-41110.rs:9:2: 9:2\n     }\n \n     bb3 (cleanup): {\n-        drop(_2) -> bb4;                 // scope 0 at $DIR/issue-41110.rs:8:27: 8:28\n+        goto -> bb5;                     // scope 0 at $DIR/issue-41110.rs:8:27: 8:28\n     }\n \n     bb4 (cleanup): {\n+        goto -> bb5;                     // scope 0 at $DIR/issue-41110.rs:8:26: 8:27\n+    }\n+\n+    bb5 (cleanup): {\n+        goto -> bb8;                     // scope 0 at $DIR/issue-41110.rs:8:27: 8:28\n+    }\n+\n+    bb6 (cleanup): {\n         resume;                          // scope 0 at $DIR/issue-41110.rs:7:1: 9:2\n     }\n+\n+    bb7 (cleanup): {\n+        drop(_2) -> bb6;                 // scope 0 at $DIR/issue-41110.rs:8:27: 8:28\n+    }\n+\n+    bb8 (cleanup): {\n+        switchInt(_5) -> [false: bb6, otherwise: bb7]; // scope 0 at $DIR/issue-41110.rs:8:27: 8:28\n+    }\n }"}, {"sha": "c4e852ca3212a5d9eddf51c4476cfcfedf6335e3", "filename": "src/test/mir-opt/issue_41110.test.ElaborateDrops.after.mir", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fmir-opt%2Fissue_41110.test.ElaborateDrops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fmir-opt%2Fissue_41110.test.ElaborateDrops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_41110.test.ElaborateDrops.after.mir?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -25,7 +25,7 @@ fn test() -> () {\n         StorageLive(_3);                 // scope 2 at $DIR/issue-41110.rs:17:5: 17:12\n         StorageLive(_4);                 // scope 2 at $DIR/issue-41110.rs:17:10: 17:11\n         _4 = move _2;                    // scope 2 at $DIR/issue-41110.rs:17:10: 17:11\n-        _3 = std::mem::drop::<S>(move _4) -> [return: bb1, unwind: bb5]; // scope 2 at $DIR/issue-41110.rs:17:5: 17:12\n+        _3 = std::mem::drop::<S>(move _4) -> [return: bb1, unwind: bb7]; // scope 2 at $DIR/issue-41110.rs:17:5: 17:12\n                                          // mir::Constant\n                                          // + span: $DIR/issue-41110.rs:17:5: 17:9\n                                          // + literal: Const { ty: fn(S) {std::mem::drop::<S>}, val: Value(Scalar(<ZST>)) }\n@@ -37,53 +37,65 @@ fn test() -> () {\n         StorageLive(_5);                 // scope 2 at $DIR/issue-41110.rs:18:9: 18:10\n         _6 = const false;                // scope 2 at $DIR/issue-41110.rs:18:9: 18:10\n         _5 = move _1;                    // scope 2 at $DIR/issue-41110.rs:18:9: 18:10\n-        goto -> bb9;                     // scope 2 at $DIR/issue-41110.rs:18:5: 18:6\n+        goto -> bb12;                    // scope 2 at $DIR/issue-41110.rs:18:5: 18:6\n     }\n \n     bb2: {\n+        goto -> bb3;                     // scope 2 at $DIR/issue-41110.rs:18:9: 18:10\n+    }\n+\n+    bb3: {\n         StorageDead(_5);                 // scope 2 at $DIR/issue-41110.rs:18:9: 18:10\n         _0 = const ();                   // scope 0 at $DIR/issue-41110.rs:14:15: 19:2\n-        drop(_2) -> [return: bb3, unwind: bb6]; // scope 1 at $DIR/issue-41110.rs:19:1: 19:2\n+        drop(_2) -> [return: bb4, unwind: bb9]; // scope 1 at $DIR/issue-41110.rs:19:1: 19:2\n     }\n \n-    bb3: {\n+    bb4: {\n         StorageDead(_2);                 // scope 1 at $DIR/issue-41110.rs:19:1: 19:2\n-        goto -> bb4;                     // scope 0 at $DIR/issue-41110.rs:19:1: 19:2\n+        goto -> bb5;                     // scope 0 at $DIR/issue-41110.rs:19:1: 19:2\n     }\n \n-    bb4: {\n+    bb5: {\n         _6 = const false;                // scope 0 at $DIR/issue-41110.rs:19:1: 19:2\n         StorageDead(_1);                 // scope 0 at $DIR/issue-41110.rs:19:1: 19:2\n         return;                          // scope 0 at $DIR/issue-41110.rs:19:2: 19:2\n     }\n \n-    bb5 (cleanup): {\n-        goto -> bb6;                     // scope 1 at $DIR/issue-41110.rs:19:1: 19:2\n-    }\n-\n     bb6 (cleanup): {\n-        goto -> bb11;                    // scope 0 at $DIR/issue-41110.rs:19:1: 19:2\n+        goto -> bb8;                     // scope 2 at $DIR/issue-41110.rs:18:9: 18:10\n     }\n \n     bb7 (cleanup): {\n-        resume;                          // scope 0 at $DIR/issue-41110.rs:14:1: 19:2\n+        goto -> bb8;                     // scope 2 at $DIR/issue-41110.rs:17:11: 17:12\n     }\n \n     bb8 (cleanup): {\n+        goto -> bb9;                     // scope 1 at $DIR/issue-41110.rs:19:1: 19:2\n+    }\n+\n+    bb9 (cleanup): {\n+        goto -> bb14;                    // scope 0 at $DIR/issue-41110.rs:19:1: 19:2\n+    }\n+\n+    bb10 (cleanup): {\n+        resume;                          // scope 0 at $DIR/issue-41110.rs:14:1: 19:2\n+    }\n+\n+    bb11 (cleanup): {\n         _2 = move _5;                    // scope 2 at $DIR/issue-41110.rs:18:5: 18:6\n-        goto -> bb5;                     // scope 2 at $DIR/issue-41110.rs:18:5: 18:6\n+        goto -> bb6;                     // scope 2 at $DIR/issue-41110.rs:18:5: 18:6\n     }\n \n-    bb9: {\n+    bb12: {\n         _2 = move _5;                    // scope 2 at $DIR/issue-41110.rs:18:5: 18:6\n         goto -> bb2;                     // scope 2 at $DIR/issue-41110.rs:18:5: 18:6\n     }\n \n-    bb10 (cleanup): {\n-        drop(_1) -> bb7;                 // scope 0 at $DIR/issue-41110.rs:19:1: 19:2\n+    bb13 (cleanup): {\n+        drop(_1) -> bb10;                // scope 0 at $DIR/issue-41110.rs:19:1: 19:2\n     }\n \n-    bb11 (cleanup): {\n-        switchInt(_6) -> [false: bb7, otherwise: bb10]; // scope 0 at $DIR/issue-41110.rs:19:1: 19:2\n+    bb14 (cleanup): {\n+        switchInt(_6) -> [false: bb10, otherwise: bb13]; // scope 0 at $DIR/issue-41110.rs:19:1: 19:2\n     }\n }"}, {"sha": "488fcb5dd70e8df89f34734b59f910a12311e1ea", "filename": "src/test/mir-opt/issue_41888.main.ElaborateDrops.after.mir", "status": "modified", "additions": 41, "deletions": 33, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fmir-opt%2Fissue_41888.main.ElaborateDrops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fmir-opt%2Fissue_41888.main.ElaborateDrops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_41888.main.ElaborateDrops.after.mir?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -26,7 +26,7 @@ fn main() -> () {\n         _8 = const false;                // scope 0 at $DIR/issue-41888.rs:7:9: 7:10\n         StorageLive(_1);                 // scope 0 at $DIR/issue-41888.rs:7:9: 7:10\n         StorageLive(_2);                 // scope 1 at $DIR/issue-41888.rs:8:8: 8:14\n-        _2 = cond() -> [return: bb1, unwind: bb9]; // scope 1 at $DIR/issue-41888.rs:8:8: 8:14\n+        _2 = cond() -> [return: bb1, unwind: bb11]; // scope 1 at $DIR/issue-41888.rs:8:8: 8:14\n                                          // mir::Constant\n                                          // + span: $DIR/issue-41888.rs:8:8: 8:12\n                                          // + literal: Const { ty: fn() -> bool {cond}, val: Value(Scalar(<ZST>)) }\n@@ -42,103 +42,111 @@ fn main() -> () {\n         _4 = K;                          // scope 1 at $DIR/issue-41888.rs:9:18: 9:19\n         _3 = E::F(move _4);              // scope 1 at $DIR/issue-41888.rs:9:13: 9:20\n         StorageDead(_4);                 // scope 1 at $DIR/issue-41888.rs:9:19: 9:20\n-        goto -> bb12;                    // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n+        goto -> bb14;                    // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n     }\n \n     bb3: {\n         _0 = const ();                   // scope 1 at $DIR/issue-41888.rs:14:6: 14:6\n-        goto -> bb7;                     // scope 1 at $DIR/issue-41888.rs:8:5: 14:6\n+        goto -> bb8;                     // scope 1 at $DIR/issue-41888.rs:8:5: 14:6\n     }\n \n     bb4: {\n+        goto -> bb5;                     // scope 1 at $DIR/issue-41888.rs:9:19: 9:20\n+    }\n+\n+    bb5: {\n         StorageDead(_3);                 // scope 1 at $DIR/issue-41888.rs:9:19: 9:20\n         _5 = discriminant(_1);           // scope 1 at $DIR/issue-41888.rs:10:16: 10:24\n-        switchInt(move _5) -> [0_isize: bb6, otherwise: bb5]; // scope 1 at $DIR/issue-41888.rs:10:16: 10:24\n+        switchInt(move _5) -> [0_isize: bb7, otherwise: bb6]; // scope 1 at $DIR/issue-41888.rs:10:16: 10:24\n     }\n \n-    bb5: {\n+    bb6: {\n         _0 = const ();                   // scope 1 at $DIR/issue-41888.rs:13:10: 13:10\n-        goto -> bb7;                     // scope 1 at $DIR/issue-41888.rs:10:9: 13:10\n+        goto -> bb8;                     // scope 1 at $DIR/issue-41888.rs:10:9: 13:10\n     }\n \n-    bb6: {\n+    bb7: {\n         StorageLive(_6);                 // scope 1 at $DIR/issue-41888.rs:10:21: 10:23\n         _9 = const false;                // scope 1 at $DIR/issue-41888.rs:10:21: 10:23\n         _6 = move ((_1 as F).0: K);      // scope 1 at $DIR/issue-41888.rs:10:21: 10:23\n         _0 = const ();                   // scope 2 at $DIR/issue-41888.rs:10:29: 13:10\n         StorageDead(_6);                 // scope 1 at $DIR/issue-41888.rs:13:9: 13:10\n-        goto -> bb7;                     // scope 1 at $DIR/issue-41888.rs:10:9: 13:10\n+        goto -> bb8;                     // scope 1 at $DIR/issue-41888.rs:10:9: 13:10\n     }\n \n-    bb7: {\n+    bb8: {\n         StorageDead(_2);                 // scope 1 at $DIR/issue-41888.rs:14:5: 14:6\n-        goto -> bb18;                    // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n+        goto -> bb20;                    // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n     }\n \n-    bb8: {\n+    bb9: {\n         _7 = const false;                // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n         _8 = const false;                // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n         _9 = const false;                // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n         StorageDead(_1);                 // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n         return;                          // scope 0 at $DIR/issue-41888.rs:15:2: 15:2\n     }\n \n-    bb9 (cleanup): {\n-        goto -> bb10;                    // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n+    bb10 (cleanup): {\n+        goto -> bb11;                    // scope 1 at $DIR/issue-41888.rs:9:19: 9:20\n+    }\n+\n+    bb11 (cleanup): {\n+        goto -> bb12;                    // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n     }\n \n-    bb10 (cleanup): {\n+    bb12 (cleanup): {\n         resume;                          // scope 0 at $DIR/issue-41888.rs:6:1: 15:2\n     }\n \n-    bb11 (cleanup): {\n+    bb13 (cleanup): {\n         _7 = const true;                 // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n         _8 = const true;                 // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n         _9 = const true;                 // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n         _1 = move _3;                    // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n-        goto -> bb9;                     // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n+        goto -> bb10;                    // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n     }\n \n-    bb12: {\n+    bb14: {\n         _7 = const true;                 // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n         _8 = const true;                 // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n         _9 = const true;                 // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n         _1 = move _3;                    // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n         goto -> bb4;                     // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n     }\n \n-    bb13: {\n+    bb15: {\n         _7 = const false;                // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n-        goto -> bb8;                     // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n+        goto -> bb9;                     // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n     }\n \n-    bb14 (cleanup): {\n-        goto -> bb10;                    // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n+    bb16 (cleanup): {\n+        goto -> bb12;                    // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n     }\n \n-    bb15: {\n-        drop(_1) -> [return: bb13, unwind: bb10]; // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n+    bb17: {\n+        drop(_1) -> [return: bb15, unwind: bb12]; // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n     }\n \n-    bb16 (cleanup): {\n-        drop(_1) -> bb10;                // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n+    bb18 (cleanup): {\n+        drop(_1) -> bb12;                // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n     }\n \n-    bb17: {\n+    bb19: {\n         _10 = discriminant(_1);          // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n-        switchInt(move _10) -> [0_isize: bb13, otherwise: bb15]; // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n+        switchInt(move _10) -> [0_isize: bb15, otherwise: bb17]; // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n     }\n \n-    bb18: {\n-        switchInt(_7) -> [false: bb13, otherwise: bb17]; // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n+    bb20: {\n+        switchInt(_7) -> [false: bb15, otherwise: bb19]; // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n     }\n \n-    bb19 (cleanup): {\n+    bb21 (cleanup): {\n         _11 = discriminant(_1);          // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n-        switchInt(move _11) -> [0_isize: bb14, otherwise: bb16]; // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n+        switchInt(move _11) -> [0_isize: bb16, otherwise: bb18]; // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n     }\n \n-    bb20 (cleanup): {\n-        switchInt(_7) -> [false: bb10, otherwise: bb19]; // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n+    bb22 (cleanup): {\n+        switchInt(_7) -> [false: bb12, otherwise: bb21]; // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n     }\n }"}, {"sha": "c1421f20a0ba23da67f9e3203b958aa58bc4cd3c", "filename": "src/test/mir-opt/issue_62289.test.ElaborateDrops.before.mir", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fmir-opt%2Fissue_62289.test.ElaborateDrops.before.mir", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fmir-opt%2Fissue_62289.test.ElaborateDrops.before.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_62289.test.ElaborateDrops.before.mir?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -30,7 +30,7 @@ fn test() -> Option<Box<u32>> {\n         StorageLive(_3);                 // scope 0 at $DIR/issue-62289.rs:9:15: 9:20\n         StorageLive(_4);                 // scope 0 at $DIR/issue-62289.rs:9:15: 9:19\n         _4 = Option::<u32>::None;        // scope 0 at $DIR/issue-62289.rs:9:15: 9:19\n-        _3 = <Option<u32> as Try>::into_result(move _4) -> [return: bb1, unwind: bb10]; // scope 0 at $DIR/issue-62289.rs:9:15: 9:20\n+        _3 = <Option<u32> as Try>::into_result(move _4) -> [return: bb1, unwind: bb12]; // scope 0 at $DIR/issue-62289.rs:9:15: 9:20\n                                          // mir::Constant\n                                          // + span: $DIR/issue-62289.rs:9:15: 9:20\n                                          // + literal: Const { ty: fn(std::option::Option<u32>) -> std::result::Result<<std::option::Option<u32> as std::ops::Try>::Ok, <std::option::Option<u32> as std::ops::Try>::Error> {<std::option::Option<u32> as std::ops::Try>::into_result}, val: Value(Scalar(<ZST>)) }\n@@ -48,11 +48,7 @@ fn test() -> Option<Box<u32>> {\n         (*_2) = _10;                     // scope 4 at $DIR/issue-62289.rs:9:15: 9:20\n         StorageDead(_10);                // scope 0 at $DIR/issue-62289.rs:9:19: 9:20\n         _1 = move _2;                    // scope 0 at $DIR/issue-62289.rs:9:10: 9:21\n-        StorageDead(_2);                 // scope 0 at $DIR/issue-62289.rs:9:20: 9:21\n-        _0 = Option::<Box<u32>>::Some(move _1); // scope 0 at $DIR/issue-62289.rs:9:5: 9:22\n-        StorageDead(_1);                 // scope 0 at $DIR/issue-62289.rs:9:21: 9:22\n-        StorageDead(_3);                 // scope 0 at $DIR/issue-62289.rs:10:1: 10:2\n-        goto -> bb8;                     // scope 0 at $DIR/issue-62289.rs:10:2: 10:2\n+        drop(_2) -> [return: bb7, unwind: bb11]; // scope 0 at $DIR/issue-62289.rs:9:20: 9:21\n     }\n \n     bb3: {\n@@ -65,15 +61,15 @@ fn test() -> Option<Box<u32>> {\n         StorageLive(_8);                 // scope 2 at $DIR/issue-62289.rs:9:19: 9:20\n         StorageLive(_9);                 // scope 2 at $DIR/issue-62289.rs:9:19: 9:20\n         _9 = _6;                         // scope 2 at $DIR/issue-62289.rs:9:19: 9:20\n-        _8 = <NoneError as From<NoneError>>::from(move _9) -> [return: bb5, unwind: bb10]; // scope 2 at $DIR/issue-62289.rs:9:19: 9:20\n+        _8 = <NoneError as From<NoneError>>::from(move _9) -> [return: bb5, unwind: bb12]; // scope 2 at $DIR/issue-62289.rs:9:19: 9:20\n                                          // mir::Constant\n                                          // + span: $DIR/issue-62289.rs:9:19: 9:20\n                                          // + literal: Const { ty: fn(std::option::NoneError) -> std::option::NoneError {<std::option::NoneError as std::convert::From<std::option::NoneError>>::from}, val: Value(Scalar(<ZST>)) }\n     }\n \n     bb5: {\n         StorageDead(_9);                 // scope 2 at $DIR/issue-62289.rs:9:19: 9:20\n-        _0 = <Option<Box<u32>> as Try>::from_error(move _8) -> [return: bb6, unwind: bb10]; // scope 2 at $DIR/issue-62289.rs:9:15: 9:20\n+        _0 = <Option<Box<u32>> as Try>::from_error(move _8) -> [return: bb6, unwind: bb12]; // scope 2 at $DIR/issue-62289.rs:9:15: 9:20\n                                          // mir::Constant\n                                          // + span: $DIR/issue-62289.rs:9:15: 9:20\n                                          // + literal: Const { ty: fn(<std::option::Option<std::boxed::Box<u32>> as std::ops::Try>::Error) -> std::option::Option<std::boxed::Box<u32>> {<std::option::Option<std::boxed::Box<u32>> as std::ops::Try>::from_error}, val: Value(Scalar(<ZST>)) }\n@@ -82,29 +78,41 @@ fn test() -> Option<Box<u32>> {\n     bb6: {\n         StorageDead(_8);                 // scope 2 at $DIR/issue-62289.rs:9:19: 9:20\n         StorageDead(_6);                 // scope 0 at $DIR/issue-62289.rs:9:19: 9:20\n-        drop(_2) -> [return: bb7, unwind: bb9]; // scope 0 at $DIR/issue-62289.rs:9:20: 9:21\n+        drop(_2) -> bb9;                 // scope 0 at $DIR/issue-62289.rs:9:20: 9:21\n     }\n \n     bb7: {\n+        StorageDead(_2);                 // scope 0 at $DIR/issue-62289.rs:9:20: 9:21\n+        _0 = Option::<Box<u32>>::Some(move _1); // scope 0 at $DIR/issue-62289.rs:9:5: 9:22\n+        drop(_1) -> bb8;                 // scope 0 at $DIR/issue-62289.rs:9:21: 9:22\n+    }\n+\n+    bb8: {\n+        StorageDead(_1);                 // scope 0 at $DIR/issue-62289.rs:9:21: 9:22\n+        StorageDead(_3);                 // scope 0 at $DIR/issue-62289.rs:10:1: 10:2\n+        goto -> bb10;                    // scope 0 at $DIR/issue-62289.rs:10:2: 10:2\n+    }\n+\n+    bb9: {\n         StorageDead(_2);                 // scope 0 at $DIR/issue-62289.rs:9:20: 9:21\n         StorageDead(_1);                 // scope 0 at $DIR/issue-62289.rs:9:21: 9:22\n         StorageDead(_3);                 // scope 0 at $DIR/issue-62289.rs:10:1: 10:2\n-        goto -> bb8;                     // scope 0 at $DIR/issue-62289.rs:10:2: 10:2\n+        goto -> bb10;                    // scope 0 at $DIR/issue-62289.rs:10:2: 10:2\n     }\n \n-    bb8: {\n+    bb10: {\n         return;                          // scope 0 at $DIR/issue-62289.rs:10:2: 10:2\n     }\n \n-    bb9 (cleanup): {\n-        drop(_0) -> bb11;                // scope 0 at $DIR/issue-62289.rs:10:1: 10:2\n+    bb11 (cleanup): {\n+        drop(_1) -> bb13;                // scope 0 at $DIR/issue-62289.rs:9:21: 9:22\n     }\n \n-    bb10 (cleanup): {\n-        drop(_2) -> bb11;                // scope 0 at $DIR/issue-62289.rs:9:20: 9:21\n+    bb12 (cleanup): {\n+        drop(_2) -> bb13;                // scope 0 at $DIR/issue-62289.rs:9:20: 9:21\n     }\n \n-    bb11 (cleanup): {\n+    bb13 (cleanup): {\n         resume;                          // scope 0 at $DIR/issue-62289.rs:8:1: 10:2\n     }\n }"}, {"sha": "bbb433dbe25c787203525dbe6561d0ff04946023", "filename": "src/test/mir-opt/no_spurious_drop_after_call.main.ElaborateDrops.before.mir", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fmir-opt%2Fno_spurious_drop_after_call.main.ElaborateDrops.before.mir", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fmir-opt%2Fno_spurious_drop_after_call.main.ElaborateDrops.before.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fno_spurious_drop_after_call.main.ElaborateDrops.before.mir?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -28,7 +28,7 @@ fn main() -> () {\n \n     bb1: {\n         StorageDead(_3);                 // scope 0 at $DIR/no-spurious-drop-after-call.rs:9:33: 9:34\n-        _1 = std::mem::drop::<String>(move _2) -> bb2; // scope 0 at $DIR/no-spurious-drop-after-call.rs:9:5: 9:35\n+        _1 = std::mem::drop::<String>(move _2) -> [return: bb2, unwind: bb3]; // scope 0 at $DIR/no-spurious-drop-after-call.rs:9:5: 9:35\n                                          // mir::Constant\n                                          // + span: $DIR/no-spurious-drop-after-call.rs:9:5: 9:19\n                                          // + literal: Const { ty: fn(std::string::String) {std::mem::drop::<std::string::String>}, val: Value(Scalar(<ZST>)) }\n@@ -41,4 +41,12 @@ fn main() -> () {\n         _0 = const ();                   // scope 0 at $DIR/no-spurious-drop-after-call.rs:8:11: 10:2\n         return;                          // scope 0 at $DIR/no-spurious-drop-after-call.rs:10:2: 10:2\n     }\n+\n+    bb3 (cleanup): {\n+        drop(_2) -> bb4;                 // scope 0 at $DIR/no-spurious-drop-after-call.rs:9:34: 9:35\n+    }\n+\n+    bb4 (cleanup): {\n+        resume;                          // scope 0 at $DIR/no-spurious-drop-after-call.rs:8:1: 10:2\n+    }\n }"}, {"sha": "d18f6308ded84e93308851faf27a822ff1b8e3c3", "filename": "src/test/mir-opt/uniform_array_move_out.move_out_by_subslice.mir_map.0.mir", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.move_out_by_subslice.mir_map.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.move_out_by_subslice.mir_map.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.move_out_by_subslice.mir_map.0.mir?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -22,38 +22,62 @@ fn move_out_by_subslice() -> () {\n         _3 = Box(i32);                   // scope 0 at $DIR/uniform_array_move_out.rs:11:14: 11:19\n         (*_3) = const 1_i32;             // scope 0 at $DIR/uniform_array_move_out.rs:11:18: 11:19\n         _2 = move _3;                    // scope 0 at $DIR/uniform_array_move_out.rs:11:14: 11:19\n+        drop(_3) -> [return: bb1, unwind: bb9]; // scope 0 at $DIR/uniform_array_move_out.rs:11:18: 11:19\n+    }\n+\n+    bb1: {\n         StorageDead(_3);                 // scope 0 at $DIR/uniform_array_move_out.rs:11:18: 11:19\n         StorageLive(_4);                 // scope 0 at $DIR/uniform_array_move_out.rs:11:21: 11:26\n         StorageLive(_5);                 // scope 0 at $DIR/uniform_array_move_out.rs:11:21: 11:26\n         _5 = Box(i32);                   // scope 0 at $DIR/uniform_array_move_out.rs:11:21: 11:26\n         (*_5) = const 2_i32;             // scope 0 at $DIR/uniform_array_move_out.rs:11:25: 11:26\n         _4 = move _5;                    // scope 0 at $DIR/uniform_array_move_out.rs:11:21: 11:26\n+        drop(_5) -> [return: bb2, unwind: bb8]; // scope 0 at $DIR/uniform_array_move_out.rs:11:25: 11:26\n+    }\n+\n+    bb2: {\n         StorageDead(_5);                 // scope 0 at $DIR/uniform_array_move_out.rs:11:25: 11:26\n         _1 = [move _2, move _4];         // scope 0 at $DIR/uniform_array_move_out.rs:11:13: 11:27\n+        drop(_4) -> [return: bb3, unwind: bb9]; // scope 0 at $DIR/uniform_array_move_out.rs:11:26: 11:27\n+    }\n+\n+    bb3: {\n         StorageDead(_4);                 // scope 0 at $DIR/uniform_array_move_out.rs:11:26: 11:27\n+        drop(_2) -> [return: bb4, unwind: bb10]; // scope 0 at $DIR/uniform_array_move_out.rs:11:26: 11:27\n+    }\n+\n+    bb4: {\n         StorageDead(_2);                 // scope 0 at $DIR/uniform_array_move_out.rs:11:26: 11:27\n         FakeRead(ForLet, _1);            // scope 0 at $DIR/uniform_array_move_out.rs:11:9: 11:10\n         StorageLive(_6);                 // scope 1 at $DIR/uniform_array_move_out.rs:12:10: 12:17\n         _6 = move _1[0..2];              // scope 1 at $DIR/uniform_array_move_out.rs:12:10: 12:17\n         _0 = const ();                   // scope 0 at $DIR/uniform_array_move_out.rs:10:27: 13:2\n-        drop(_6) -> [return: bb1, unwind: bb3]; // scope 1 at $DIR/uniform_array_move_out.rs:13:1: 13:2\n+        drop(_6) -> [return: bb5, unwind: bb7]; // scope 1 at $DIR/uniform_array_move_out.rs:13:1: 13:2\n     }\n \n-    bb1: {\n+    bb5: {\n         StorageDead(_6);                 // scope 1 at $DIR/uniform_array_move_out.rs:13:1: 13:2\n-        drop(_1) -> [return: bb2, unwind: bb4]; // scope 0 at $DIR/uniform_array_move_out.rs:13:1: 13:2\n+        drop(_1) -> [return: bb6, unwind: bb10]; // scope 0 at $DIR/uniform_array_move_out.rs:13:1: 13:2\n     }\n \n-    bb2: {\n+    bb6: {\n         StorageDead(_1);                 // scope 0 at $DIR/uniform_array_move_out.rs:13:1: 13:2\n         return;                          // scope 0 at $DIR/uniform_array_move_out.rs:13:2: 13:2\n     }\n \n-    bb3 (cleanup): {\n-        drop(_1) -> bb4;                 // scope 0 at $DIR/uniform_array_move_out.rs:13:1: 13:2\n+    bb7 (cleanup): {\n+        drop(_1) -> bb10;                // scope 0 at $DIR/uniform_array_move_out.rs:13:1: 13:2\n+    }\n+\n+    bb8 (cleanup): {\n+        drop(_4) -> bb9;                 // scope 0 at $DIR/uniform_array_move_out.rs:11:26: 11:27\n+    }\n+\n+    bb9 (cleanup): {\n+        drop(_2) -> bb10;                // scope 0 at $DIR/uniform_array_move_out.rs:11:26: 11:27\n     }\n \n-    bb4 (cleanup): {\n+    bb10 (cleanup): {\n         resume;                          // scope 0 at $DIR/uniform_array_move_out.rs:10:1: 13:2\n     }\n }"}, {"sha": "eda8e5fd3afe7939f056584cb5d88b753a4afc51", "filename": "src/test/mir-opt/uniform_array_move_out.move_out_from_end.mir_map.0.mir", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.move_out_from_end.mir_map.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.move_out_from_end.mir_map.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.move_out_from_end.mir_map.0.mir?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -22,38 +22,62 @@ fn move_out_from_end() -> () {\n         _3 = Box(i32);                   // scope 0 at $DIR/uniform_array_move_out.rs:5:14: 5:19\n         (*_3) = const 1_i32;             // scope 0 at $DIR/uniform_array_move_out.rs:5:18: 5:19\n         _2 = move _3;                    // scope 0 at $DIR/uniform_array_move_out.rs:5:14: 5:19\n+        drop(_3) -> [return: bb1, unwind: bb9]; // scope 0 at $DIR/uniform_array_move_out.rs:5:18: 5:19\n+    }\n+\n+    bb1: {\n         StorageDead(_3);                 // scope 0 at $DIR/uniform_array_move_out.rs:5:18: 5:19\n         StorageLive(_4);                 // scope 0 at $DIR/uniform_array_move_out.rs:5:21: 5:26\n         StorageLive(_5);                 // scope 0 at $DIR/uniform_array_move_out.rs:5:21: 5:26\n         _5 = Box(i32);                   // scope 0 at $DIR/uniform_array_move_out.rs:5:21: 5:26\n         (*_5) = const 2_i32;             // scope 0 at $DIR/uniform_array_move_out.rs:5:25: 5:26\n         _4 = move _5;                    // scope 0 at $DIR/uniform_array_move_out.rs:5:21: 5:26\n+        drop(_5) -> [return: bb2, unwind: bb8]; // scope 0 at $DIR/uniform_array_move_out.rs:5:25: 5:26\n+    }\n+\n+    bb2: {\n         StorageDead(_5);                 // scope 0 at $DIR/uniform_array_move_out.rs:5:25: 5:26\n         _1 = [move _2, move _4];         // scope 0 at $DIR/uniform_array_move_out.rs:5:13: 5:27\n+        drop(_4) -> [return: bb3, unwind: bb9]; // scope 0 at $DIR/uniform_array_move_out.rs:5:26: 5:27\n+    }\n+\n+    bb3: {\n         StorageDead(_4);                 // scope 0 at $DIR/uniform_array_move_out.rs:5:26: 5:27\n+        drop(_2) -> [return: bb4, unwind: bb10]; // scope 0 at $DIR/uniform_array_move_out.rs:5:26: 5:27\n+    }\n+\n+    bb4: {\n         StorageDead(_2);                 // scope 0 at $DIR/uniform_array_move_out.rs:5:26: 5:27\n         FakeRead(ForLet, _1);            // scope 0 at $DIR/uniform_array_move_out.rs:5:9: 5:10\n         StorageLive(_6);                 // scope 1 at $DIR/uniform_array_move_out.rs:6:14: 6:16\n         _6 = move _1[1 of 2];            // scope 1 at $DIR/uniform_array_move_out.rs:6:14: 6:16\n         _0 = const ();                   // scope 0 at $DIR/uniform_array_move_out.rs:4:24: 7:2\n-        drop(_6) -> [return: bb1, unwind: bb3]; // scope 1 at $DIR/uniform_array_move_out.rs:7:1: 7:2\n+        drop(_6) -> [return: bb5, unwind: bb7]; // scope 1 at $DIR/uniform_array_move_out.rs:7:1: 7:2\n     }\n \n-    bb1: {\n+    bb5: {\n         StorageDead(_6);                 // scope 1 at $DIR/uniform_array_move_out.rs:7:1: 7:2\n-        drop(_1) -> [return: bb2, unwind: bb4]; // scope 0 at $DIR/uniform_array_move_out.rs:7:1: 7:2\n+        drop(_1) -> [return: bb6, unwind: bb10]; // scope 0 at $DIR/uniform_array_move_out.rs:7:1: 7:2\n     }\n \n-    bb2: {\n+    bb6: {\n         StorageDead(_1);                 // scope 0 at $DIR/uniform_array_move_out.rs:7:1: 7:2\n         return;                          // scope 0 at $DIR/uniform_array_move_out.rs:7:2: 7:2\n     }\n \n-    bb3 (cleanup): {\n-        drop(_1) -> bb4;                 // scope 0 at $DIR/uniform_array_move_out.rs:7:1: 7:2\n+    bb7 (cleanup): {\n+        drop(_1) -> bb10;                // scope 0 at $DIR/uniform_array_move_out.rs:7:1: 7:2\n+    }\n+\n+    bb8 (cleanup): {\n+        drop(_4) -> bb9;                 // scope 0 at $DIR/uniform_array_move_out.rs:5:26: 5:27\n+    }\n+\n+    bb9 (cleanup): {\n+        drop(_2) -> bb10;                // scope 0 at $DIR/uniform_array_move_out.rs:5:26: 5:27\n     }\n \n-    bb4 (cleanup): {\n+    bb10 (cleanup): {\n         resume;                          // scope 0 at $DIR/uniform_array_move_out.rs:4:1: 7:2\n     }\n }"}, {"sha": "e14e733fff6d4cbe55f76924985cb802434c4a49", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.uses_crate.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -19,12 +19,12 @@\n    18|      2|    println!(\"used_only_from_bin_crate_generic_function with {:?}\", arg);\n    19|      2|}\n   ------------------\n-  | used_crate::used_only_from_bin_crate_generic_function::<&alloc::vec::Vec<i32>>:\n+  | used_crate::used_only_from_bin_crate_generic_function::<&str>:\n   |   17|      1|pub fn used_only_from_bin_crate_generic_function<T: Debug>(arg: T) {\n   |   18|      1|    println!(\"used_only_from_bin_crate_generic_function with {:?}\", arg);\n   |   19|      1|}\n   ------------------\n-  | used_crate::used_only_from_bin_crate_generic_function::<&str>:\n+  | used_crate::used_only_from_bin_crate_generic_function::<&alloc::vec::Vec<i32>>:\n   |   17|      1|pub fn used_only_from_bin_crate_generic_function<T: Debug>(arg: T) {\n   |   18|      1|    println!(\"used_only_from_bin_crate_generic_function with {:?}\", arg);\n   |   19|      1|}"}, {"sha": "81310c8cb25aa9c55d2cf1f37ad616fdb7f78bf2", "filename": "src/test/run-make-fulldeps/coverage-spanview/expected_mir_dump.async/async.executor-block_on.-------.InstrumentCoverage.0.html", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.async%2Fasync.executor-block_on.-------.InstrumentCoverage.0.html", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.async%2Fasync.executor-block_on.-------.InstrumentCoverage.0.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.async%2Fasync.executor-block_on.-------.InstrumentCoverage.0.html?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -70,166 +70,166 @@\n </head>\n <body>\n <div class=\"code\" style=\"counter-reset: line 109\"><span class=\"line\">    <span><span class=\"code even\" style=\"--layer: 1\" title=\"111:54-111:65: @0[2]: _3 = &amp;mut _1\n-111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb23]\n+111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb20]\n 111:13-111:23: @1[1]: FakeRead(ForLet, _2)\n-119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb23]\n+119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb20]\n 119:80-119:86: @2[3]: _9 = const {alloc0: &amp;RawWakerVTable}\n 119:79-119:86: @2[4]: _8 = &amp;(*_9)\n 119:79-119:86: @2[5]: _7 = &amp;(*_8)\n-119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb23]\n-119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb23]\n+119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb20]\n+119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb20]\n 119:13-119:18: @4[1]: FakeRead(ForLet, _4)\n 120:47-120:53: @4[7]: _12 = &amp;_4\n 120:47-120:53: @4[8]: _11 = &amp;(*_12)\n-120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb22]\n+120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb19]\n 120:13-120:24: @5[1]: FakeRead(ForLet, _10)\"><span class=\"annotation\">@0,1,2,3,4,5\u298a</span>pub fn block_on&lt;F: Future&gt;(mut future: F) -&gt; F::Output {</span></span>\n <span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"111:54-111:65: @0[2]: _3 = &amp;mut _1\n-111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb23]\n+111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb20]\n 111:13-111:23: @1[1]: FakeRead(ForLet, _2)\n-119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb23]\n+119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb20]\n 119:80-119:86: @2[3]: _9 = const {alloc0: &amp;RawWakerVTable}\n 119:79-119:86: @2[4]: _8 = &amp;(*_9)\n 119:79-119:86: @2[5]: _7 = &amp;(*_8)\n-119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb23]\n-119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb23]\n+119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb20]\n+119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb20]\n 119:13-119:18: @4[1]: FakeRead(ForLet, _4)\n 120:47-120:53: @4[7]: _12 = &amp;_4\n 120:47-120:53: @4[8]: _11 = &amp;(*_12)\n-120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb22]\n+120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb19]\n 120:13-120:24: @5[1]: FakeRead(ForLet, _10)\">        let mut future = unsafe { Pin::new_unchecked(&amp;mut future) };</span></span>\n <span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"111:54-111:65: @0[2]: _3 = &amp;mut _1\n-111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb23]\n+111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb20]\n 111:13-111:23: @1[1]: FakeRead(ForLet, _2)\n-119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb23]\n+119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb20]\n 119:80-119:86: @2[3]: _9 = const {alloc0: &amp;RawWakerVTable}\n 119:79-119:86: @2[4]: _8 = &amp;(*_9)\n 119:79-119:86: @2[5]: _7 = &amp;(*_8)\n-119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb23]\n-119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb23]\n+119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb20]\n+119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb20]\n 119:13-119:18: @4[1]: FakeRead(ForLet, _4)\n 120:47-120:53: @4[7]: _12 = &amp;_4\n 120:47-120:53: @4[8]: _11 = &amp;(*_12)\n-120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb22]\n+120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb19]\n 120:13-120:24: @5[1]: FakeRead(ForLet, _10)\"></span></span>\n <span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"111:54-111:65: @0[2]: _3 = &amp;mut _1\n-111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb23]\n+111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb20]\n 111:13-111:23: @1[1]: FakeRead(ForLet, _2)\n-119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb23]\n+119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb20]\n 119:80-119:86: @2[3]: _9 = const {alloc0: &amp;RawWakerVTable}\n 119:79-119:86: @2[4]: _8 = &amp;(*_9)\n 119:79-119:86: @2[5]: _7 = &amp;(*_8)\n-119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb23]\n-119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb23]\n+119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb20]\n+119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb20]\n 119:13-119:18: @4[1]: FakeRead(ForLet, _4)\n 120:47-120:53: @4[7]: _12 = &amp;_4\n 120:47-120:53: @4[8]: _11 = &amp;(*_12)\n-120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb22]\n+120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb19]\n 120:13-120:24: @5[1]: FakeRead(ForLet, _10)\">        static VTABLE: RawWakerVTable = RawWakerVTable::new(</span></span>\n <span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"111:54-111:65: @0[2]: _3 = &amp;mut _1\n-111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb23]\n+111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb20]\n 111:13-111:23: @1[1]: FakeRead(ForLet, _2)\n-119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb23]\n+119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb20]\n 119:80-119:86: @2[3]: _9 = const {alloc0: &amp;RawWakerVTable}\n 119:79-119:86: @2[4]: _8 = &amp;(*_9)\n 119:79-119:86: @2[5]: _7 = &amp;(*_8)\n-119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb23]\n-119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb23]\n+119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb20]\n+119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb20]\n 119:13-119:18: @4[1]: FakeRead(ForLet, _4)\n 120:47-120:53: @4[7]: _12 = &amp;_4\n 120:47-120:53: @4[8]: _11 = &amp;(*_12)\n-120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb22]\n+120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb19]\n 120:13-120:24: @5[1]: FakeRead(ForLet, _10)\">            |_| unimplemented!(\"clone\"),</span></span>\n <span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"111:54-111:65: @0[2]: _3 = &amp;mut _1\n-111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb23]\n+111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb20]\n 111:13-111:23: @1[1]: FakeRead(ForLet, _2)\n-119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb23]\n+119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb20]\n 119:80-119:86: @2[3]: _9 = const {alloc0: &amp;RawWakerVTable}\n 119:79-119:86: @2[4]: _8 = &amp;(*_9)\n 119:79-119:86: @2[5]: _7 = &amp;(*_8)\n-119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb23]\n-119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb23]\n+119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb20]\n+119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb20]\n 119:13-119:18: @4[1]: FakeRead(ForLet, _4)\n 120:47-120:53: @4[7]: _12 = &amp;_4\n 120:47-120:53: @4[8]: _11 = &amp;(*_12)\n-120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb22]\n+120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb19]\n 120:13-120:24: @5[1]: FakeRead(ForLet, _10)\">            |_| unimplemented!(\"wake\"),</span></span>\n <span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"111:54-111:65: @0[2]: _3 = &amp;mut _1\n-111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb23]\n+111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb20]\n 111:13-111:23: @1[1]: FakeRead(ForLet, _2)\n-119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb23]\n+119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb20]\n 119:80-119:86: @2[3]: _9 = const {alloc0: &amp;RawWakerVTable}\n 119:79-119:86: @2[4]: _8 = &amp;(*_9)\n 119:79-119:86: @2[5]: _7 = &amp;(*_8)\n-119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb23]\n-119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb23]\n+119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb20]\n+119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb20]\n 119:13-119:18: @4[1]: FakeRead(ForLet, _4)\n 120:47-120:53: @4[7]: _12 = &amp;_4\n 120:47-120:53: @4[8]: _11 = &amp;(*_12)\n-120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb22]\n+120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb19]\n 120:13-120:24: @5[1]: FakeRead(ForLet, _10)\">            |_| unimplemented!(\"wake_by_ref\"),</span></span>\n <span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"111:54-111:65: @0[2]: _3 = &amp;mut _1\n-111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb23]\n+111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb20]\n 111:13-111:23: @1[1]: FakeRead(ForLet, _2)\n-119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb23]\n+119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb20]\n 119:80-119:86: @2[3]: _9 = const {alloc0: &amp;RawWakerVTable}\n 119:79-119:86: @2[4]: _8 = &amp;(*_9)\n 119:79-119:86: @2[5]: _7 = &amp;(*_8)\n-119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb23]\n-119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb23]\n+119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb20]\n+119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb20]\n 119:13-119:18: @4[1]: FakeRead(ForLet, _4)\n 120:47-120:53: @4[7]: _12 = &amp;_4\n 120:47-120:53: @4[8]: _11 = &amp;(*_12)\n-120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb22]\n+120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb19]\n 120:13-120:24: @5[1]: FakeRead(ForLet, _10)\">            |_| (),</span></span>\n <span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"111:54-111:65: @0[2]: _3 = &amp;mut _1\n-111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb23]\n+111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb20]\n 111:13-111:23: @1[1]: FakeRead(ForLet, _2)\n-119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb23]\n+119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb20]\n 119:80-119:86: @2[3]: _9 = const {alloc0: &amp;RawWakerVTable}\n 119:79-119:86: @2[4]: _8 = &amp;(*_9)\n 119:79-119:86: @2[5]: _7 = &amp;(*_8)\n-119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb23]\n-119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb23]\n+119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb20]\n+119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb20]\n 119:13-119:18: @4[1]: FakeRead(ForLet, _4)\n 120:47-120:53: @4[7]: _12 = &amp;_4\n 120:47-120:53: @4[8]: _11 = &amp;(*_12)\n-120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb22]\n+120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb19]\n 120:13-120:24: @5[1]: FakeRead(ForLet, _10)\">        );</span></span>\n <span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"111:54-111:65: @0[2]: _3 = &amp;mut _1\n-111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb23]\n+111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb20]\n 111:13-111:23: @1[1]: FakeRead(ForLet, _2)\n-119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb23]\n+119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb20]\n 119:80-119:86: @2[3]: _9 = const {alloc0: &amp;RawWakerVTable}\n 119:79-119:86: @2[4]: _8 = &amp;(*_9)\n 119:79-119:86: @2[5]: _7 = &amp;(*_8)\n-119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb23]\n-119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb23]\n+119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb20]\n+119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb20]\n 119:13-119:18: @4[1]: FakeRead(ForLet, _4)\n 120:47-120:53: @4[7]: _12 = &amp;_4\n 120:47-120:53: @4[8]: _11 = &amp;(*_12)\n-120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb22]\n+120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb19]\n 120:13-120:24: @5[1]: FakeRead(ForLet, _10)\">        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &amp;VTABLE)) };</span></span>\n <span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"111:54-111:65: @0[2]: _3 = &amp;mut _1\n-111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb23]\n+111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb20]\n 111:13-111:23: @1[1]: FakeRead(ForLet, _2)\n-119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb23]\n+119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb20]\n 119:80-119:86: @2[3]: _9 = const {alloc0: &amp;RawWakerVTable}\n 119:79-119:86: @2[4]: _8 = &amp;(*_9)\n 119:79-119:86: @2[5]: _7 = &amp;(*_8)\n-119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb23]\n-119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb23]\n+119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb20]\n+119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb20]\n 119:13-119:18: @4[1]: FakeRead(ForLet, _4)\n 120:47-120:53: @4[7]: _12 = &amp;_4\n 120:47-120:53: @4[8]: _11 = &amp;(*_12)\n-120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb22]\n+120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb19]\n 120:13-120:24: @5[1]: FakeRead(ForLet, _10)\">        let mut context = Context::from_waker(&amp;waker)<span class=\"annotation\">\u2989@0,1,2,3,4,5</span></span></span><span class=\"code\" style=\"--layer: 0\">;</span></span>\n <span class=\"line\"><span class=\"code\" style=\"--layer: 0\"></span></span>\n <span class=\"line\"><span class=\"code\" style=\"--layer: 0\">        loop {</span></span>\n <span class=\"line\"><span class=\"code\" style=\"--layer: 0\">            if let Poll::Ready(</span><span><span class=\"code odd\" style=\"--layer: 1\" title=\"123:32-123:35: @12[1]: _20 = move ((_14 as Ready).0: &lt;F as std::future::Future&gt;::Output)\"><span class=\"annotation\">@10,12,14,15,16,17\u298a</span>val<span class=\"annotation\">\u2989@10,12,14,15,16,17</span></span></span><span class=\"code\" style=\"--layer: 0\">) = </span><span><span class=\"code even\" style=\"--layer: 1\" title=\"123:39-123:45: @7[3]: _16 = &amp;mut _2\n-123:39-123:54: @7.Call: _15 = Pin::&lt;&amp;mut F&gt;::as_mut(move _16) -&gt; [return: bb8, unwind: bb22]\n+123:39-123:54: @7.Call: _15 = Pin::&lt;&amp;mut F&gt;::as_mut(move _16) -&gt; [return: bb8, unwind: bb19]\n 123:60-123:72: @8[3]: _18 = &amp;mut _10\n 123:60-123:72: @8[4]: _17 = &amp;mut (*_18)\n-123:39-123:73: @8.Call: _14 = &lt;F as Future&gt;::poll(move _15, move _17) -&gt; [return: bb9, unwind: bb22]\n+123:39-123:73: @8.Call: _14 = &lt;F as Future&gt;::poll(move _15, move _17) -&gt; [return: bb9, unwind: bb19]\n 123:39-123:73: @9[2]: FakeRead(ForMatchedPlace, _14)\"><span class=\"annotation\">@6,7,8,9\u298a</span>future.as_mut().poll(&amp;mut context)<span class=\"annotation\">\u2989@6,7,8,9</span></span></span><span class=\"code\" style=\"--layer: 0\"> {</span></span>\n <span class=\"line\"><span class=\"code\" style=\"--layer: 0\">                break </span><span><span class=\"code odd\" style=\"--layer: 1\" title=\"124:23-124:26: @12[2]: _0 = move _20\"><span class=\"annotation\">@10,12,14,15,16,17\u298a</span>val<span class=\"annotation\">\u2989@10,12,14,15,16,17</span></span></span><span class=\"code\" style=\"--layer: 0\">;</span></span>\n <span class=\"line\"><span class=\"code\" style=\"--layer: 0\">            }</span><span><span class=\"code even\" style=\"--layer: 1\" title=\"125:14-125:14: @11[0]: _13 = const ()\"><span class=\"annotation\">@11,13\u298a</span>\u2038<span class=\"annotation\">\u2989@11,13</span></span></span><span class=\"code\" style=\"--layer: 0\"></span></span>"}, {"sha": "313a36ed6c2f27192ed8704f63bd88bf5b4567d1", "filename": "src/test/run-make-fulldeps/coverage-spanview/expected_mir_dump.async/async.main.-------.InstrumentCoverage.0.html", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.async%2Fasync.main.-------.InstrumentCoverage.0.html", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.async%2Fasync.main.-------.InstrumentCoverage.0.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.async%2Fasync.main.-------.InstrumentCoverage.0.html?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -69,9 +69,9 @@\n </style>\n </head>\n <body>\n-<div class=\"code\" style=\"counter-reset: line 92\"><span class=\"line\"><span><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb15]\n-95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb15]\n-96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb15]\n+<div class=\"code\" style=\"counter-reset: line 92\"><span class=\"line\"><span><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb16]\n+95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb16]\n+96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb16]\n 96:22-96:36: @5.Call: _3 = Box::&lt;impl Future&gt;::pin(move _4) -&gt; [return: bb6, unwind: bb15]\n 96:9-96:19: @6[1]: FakeRead(ForLet, _3)\n 97:5-97:9: @6.Call: _5 = j(const 7_u8) -&gt; [return: bb7, unwind: bb14]\n@@ -82,9 +82,9 @@\n 100:5-100:40: @11.Call: _8 = block_on::&lt;Pin&lt;&amp;mut impl Future&gt;&gt;(move _9) -&gt; [return: bb12, unwind: bb14]\n 93:11-101:2: @12[2]: _0 = const ()\n 101:2-101:2: @13.Return: return\"><span class=\"annotation\">@0,1,2,3,4,5,6,7,8,9,10,11,12,13\u298a</span>fn main() {</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb15]\n-95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb15]\n-96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb15]\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb16]\n+95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb16]\n+96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb16]\n 96:22-96:36: @5.Call: _3 = Box::&lt;impl Future&gt;::pin(move _4) -&gt; [return: bb6, unwind: bb15]\n 96:9-96:19: @6[1]: FakeRead(ForLet, _3)\n 97:5-97:9: @6.Call: _5 = j(const 7_u8) -&gt; [return: bb7, unwind: bb14]\n@@ -95,9 +95,9 @@\n 100:5-100:40: @11.Call: _8 = block_on::&lt;Pin&lt;&amp;mut impl Future&gt;&gt;(move _9) -&gt; [return: bb12, unwind: bb14]\n 93:11-101:2: @12[2]: _0 = const ()\n 101:2-101:2: @13.Return: return\">    let _ = g(10);</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb15]\n-95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb15]\n-96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb15]\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb16]\n+95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb16]\n+96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb16]\n 96:22-96:36: @5.Call: _3 = Box::&lt;impl Future&gt;::pin(move _4) -&gt; [return: bb6, unwind: bb15]\n 96:9-96:19: @6[1]: FakeRead(ForLet, _3)\n 97:5-97:9: @6.Call: _5 = j(const 7_u8) -&gt; [return: bb7, unwind: bb14]\n@@ -108,9 +108,9 @@\n 100:5-100:40: @11.Call: _8 = block_on::&lt;Pin&lt;&amp;mut impl Future&gt;&gt;(move _9) -&gt; [return: bb12, unwind: bb14]\n 93:11-101:2: @12[2]: _0 = const ()\n 101:2-101:2: @13.Return: return\">    let _ = h(9);</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb15]\n-95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb15]\n-96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb15]\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb16]\n+95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb16]\n+96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb16]\n 96:22-96:36: @5.Call: _3 = Box::&lt;impl Future&gt;::pin(move _4) -&gt; [return: bb6, unwind: bb15]\n 96:9-96:19: @6[1]: FakeRead(ForLet, _3)\n 97:5-97:9: @6.Call: _5 = j(const 7_u8) -&gt; [return: bb7, unwind: bb14]\n@@ -121,9 +121,9 @@\n 100:5-100:40: @11.Call: _8 = block_on::&lt;Pin&lt;&amp;mut impl Future&gt;&gt;(move _9) -&gt; [return: bb12, unwind: bb14]\n 93:11-101:2: @12[2]: _0 = const ()\n 101:2-101:2: @13.Return: return\">    let mut future = Box::pin(i(8));</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb15]\n-95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb15]\n-96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb15]\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb16]\n+95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb16]\n+96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb16]\n 96:22-96:36: @5.Call: _3 = Box::&lt;impl Future&gt;::pin(move _4) -&gt; [return: bb6, unwind: bb15]\n 96:9-96:19: @6[1]: FakeRead(ForLet, _3)\n 97:5-97:9: @6.Call: _5 = j(const 7_u8) -&gt; [return: bb7, unwind: bb14]\n@@ -134,9 +134,9 @@\n 100:5-100:40: @11.Call: _8 = block_on::&lt;Pin&lt;&amp;mut impl Future&gt;&gt;(move _9) -&gt; [return: bb12, unwind: bb14]\n 93:11-101:2: @12[2]: _0 = const ()\n 101:2-101:2: @13.Return: return\">    j(7);</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb15]\n-95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb15]\n-96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb15]\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb16]\n+95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb16]\n+96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb16]\n 96:22-96:36: @5.Call: _3 = Box::&lt;impl Future&gt;::pin(move _4) -&gt; [return: bb6, unwind: bb15]\n 96:9-96:19: @6[1]: FakeRead(ForLet, _3)\n 97:5-97:9: @6.Call: _5 = j(const 7_u8) -&gt; [return: bb7, unwind: bb14]\n@@ -147,9 +147,9 @@\n 100:5-100:40: @11.Call: _8 = block_on::&lt;Pin&lt;&amp;mut impl Future&gt;&gt;(move _9) -&gt; [return: bb12, unwind: bb14]\n 93:11-101:2: @12[2]: _0 = const ()\n 101:2-101:2: @13.Return: return\">    l(6);</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb15]\n-95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb15]\n-96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb15]\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb16]\n+95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb16]\n+96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb16]\n 96:22-96:36: @5.Call: _3 = Box::&lt;impl Future&gt;::pin(move _4) -&gt; [return: bb6, unwind: bb15]\n 96:9-96:19: @6[1]: FakeRead(ForLet, _3)\n 97:5-97:9: @6.Call: _5 = j(const 7_u8) -&gt; [return: bb7, unwind: bb14]\n@@ -160,9 +160,9 @@\n 100:5-100:40: @11.Call: _8 = block_on::&lt;Pin&lt;&amp;mut impl Future&gt;&gt;(move _9) -&gt; [return: bb12, unwind: bb14]\n 93:11-101:2: @12[2]: _0 = const ()\n 101:2-101:2: @13.Return: return\">    let _ = m(5);</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb15]\n-95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb15]\n-96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb15]\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb16]\n+95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb16]\n+96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb16]\n 96:22-96:36: @5.Call: _3 = Box::&lt;impl Future&gt;::pin(move _4) -&gt; [return: bb6, unwind: bb15]\n 96:9-96:19: @6[1]: FakeRead(ForLet, _3)\n 97:5-97:9: @6.Call: _5 = j(const 7_u8) -&gt; [return: bb7, unwind: bb14]\n@@ -173,9 +173,9 @@\n 100:5-100:40: @11.Call: _8 = block_on::&lt;Pin&lt;&amp;mut impl Future&gt;&gt;(move _9) -&gt; [return: bb12, unwind: bb14]\n 93:11-101:2: @12[2]: _0 = const ()\n 101:2-101:2: @13.Return: return\">    executor::block_on(future.as_mut());</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb15]\n-95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb15]\n-96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb15]\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb16]\n+95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb16]\n+96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb16]\n 96:22-96:36: @5.Call: _3 = Box::&lt;impl Future&gt;::pin(move _4) -&gt; [return: bb6, unwind: bb15]\n 96:9-96:19: @6[1]: FakeRead(ForLet, _3)\n 97:5-97:9: @6.Call: _5 = j(const 7_u8) -&gt; [return: bb7, unwind: bb14]"}, {"sha": "5071842aa1e9de60f1ea3b93b578ce6d573a501c", "filename": "src/test/run-make-fulldeps/coverage-spanview/expected_mir_dump.closure/closure.main-{closure#2}.-------.InstrumentCoverage.0.html", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.closure%2Fclosure.main-%7Bclosure%232%7D.-------.InstrumentCoverage.0.html", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.closure%2Fclosure.main-%7Bclosure%232%7D.-------.InstrumentCoverage.0.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.closure%2Fclosure.main-%7Bclosure%232%7D.-------.InstrumentCoverage.0.html?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -94,13 +94,13 @@\n 103:9-103:29: @3[23]: _18 = (_16.0: &amp;&amp;str)\n 103:9-103:29: @3[26]: _20 = &amp;(*_18)\n 103:9-103:29: @3[28]: _21 = &lt;&amp;str as std::fmt::Display&gt;::fmt as for&lt;&#39;r, &#39;s, &#39;t0&gt; fn(&amp;&#39;r &amp;str, &amp;&#39;s mut std::fmt::Formatter&lt;&#39;t0&gt;) -&gt; std::result::Result&lt;(), std::fmt::Error&gt; (Pointer(ReifyFnPointer))\n-103:9-103:29: @3.Call: _19 = ArgumentV1::new::&lt;&amp;str&gt;(move _20, move _21) -&gt; [return: bb4, unwind: bb9]\n+103:9-103:29: @3.Call: _19 = ArgumentV1::new::&lt;&amp;str&gt;(move _20, move _21) -&gt; [return: bb4, unwind: bb8]\n 103:9-103:29: @4[2]: _15 = [move _19]\n 103:9-103:29: @4[5]: _14 = &amp;_15\n 103:9-103:29: @4[6]: _13 = &amp;(*_14)\n 103:9-103:29: @4[7]: _12 = move _13 as &amp;[std::fmt::ArgumentV1] (Pointer(Unsize))\n-103:9-103:29: @4.Call: _7 = Arguments::new_v1(move _8, move _12) -&gt; [return: bb5, unwind: bb9]\n-103:9-103:29: @5.Call: _6 = format(move _7) -&gt; [return: bb6, unwind: bb9]\n+103:9-103:29: @4.Call: _7 = Arguments::new_v1(move _8, move _12) -&gt; [return: bb5, unwind: bb8]\n+103:9-103:29: @5.Call: _6 = format(move _7) -&gt; [return: bb6, unwind: bb8]\n 103:9-103:29: @6[1]: FakeRead(ForLet, _6)\n 103:9-103:29: @6[6]: _0 = move _6\n 104:6-104:6: @7.Return: return\"><span class=\"annotation\">@3,4,5,6,7\u298a</span>format!(\"'{}'\", val)</span></span>\n@@ -114,13 +114,13 @@\n 103:9-103:29: @3[23]: _18 = (_16.0: &amp;&amp;str)\n 103:9-103:29: @3[26]: _20 = &amp;(*_18)\n 103:9-103:29: @3[28]: _21 = &lt;&amp;str as std::fmt::Display&gt;::fmt as for&lt;&#39;r, &#39;s, &#39;t0&gt; fn(&amp;&#39;r &amp;str, &amp;&#39;s mut std::fmt::Formatter&lt;&#39;t0&gt;) -&gt; std::result::Result&lt;(), std::fmt::Error&gt; (Pointer(ReifyFnPointer))\n-103:9-103:29: @3.Call: _19 = ArgumentV1::new::&lt;&amp;str&gt;(move _20, move _21) -&gt; [return: bb4, unwind: bb9]\n+103:9-103:29: @3.Call: _19 = ArgumentV1::new::&lt;&amp;str&gt;(move _20, move _21) -&gt; [return: bb4, unwind: bb8]\n 103:9-103:29: @4[2]: _15 = [move _19]\n 103:9-103:29: @4[5]: _14 = &amp;_15\n 103:9-103:29: @4[6]: _13 = &amp;(*_14)\n 103:9-103:29: @4[7]: _12 = move _13 as &amp;[std::fmt::ArgumentV1] (Pointer(Unsize))\n-103:9-103:29: @4.Call: _7 = Arguments::new_v1(move _8, move _12) -&gt; [return: bb5, unwind: bb9]\n-103:9-103:29: @5.Call: _6 = format(move _7) -&gt; [return: bb6, unwind: bb9]\n+103:9-103:29: @4.Call: _7 = Arguments::new_v1(move _8, move _12) -&gt; [return: bb5, unwind: bb8]\n+103:9-103:29: @5.Call: _6 = format(move _7) -&gt; [return: bb6, unwind: bb8]\n 103:9-103:29: @6[1]: FakeRead(ForLet, _6)\n 103:9-103:29: @6[6]: _0 = move _6\n 104:6-104:6: @7.Return: return\">    }<span class=\"annotation\">\u2989@3,4,5,6,7</span></span></span></span></div>"}, {"sha": "702c7937064b75ed351bb47be067793841436f5b", "filename": "src/test/run-make-fulldeps/coverage-spanview/expected_mir_dump.closure/closure.main.-------.InstrumentCoverage.0.html", "status": "modified", "additions": 9996, "deletions": 9996, "changes": 19992, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.closure%2Fclosure.main.-------.InstrumentCoverage.0.html", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.closure%2Fclosure.main.-------.InstrumentCoverage.0.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.closure%2Fclosure.main.-------.InstrumentCoverage.0.html?ref=5605b5d693ac0aba5b506923e3e99ec927969d04"}, {"sha": "bed5e7bb7ce888f49489df085f81d52a8e85412a", "filename": "src/test/run-make-fulldeps/coverage-spanview/expected_mir_dump.used_crate/used_crate.use_this_lib_crate.-------.InstrumentCoverage.0.html", "status": "modified", "additions": 81, "deletions": 81, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.used_crate%2Fused_crate.use_this_lib_crate.-------.InstrumentCoverage.0.html", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.used_crate%2Fused_crate.use_this_lib_crate.-------.InstrumentCoverage.0.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.used_crate%2Fused_crate.use_this_lib_crate.-------.InstrumentCoverage.0.html?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -69,122 +69,122 @@\n </style>\n </head>\n <body>\n-<div class=\"code\" style=\"counter-reset: line 52\"><span class=\"line\"><span><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb10]\n-55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb10]\n+<div class=\"code\" style=\"counter-reset: line 52\"><span class=\"line\"><span><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb13]\n+55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb13]\n 58:20-58:36: @2[5]: _6 = Box([i32; 4])\n 58:20-58:36: @2[6]: (*_6) = [const 5_i32, const 6_i32, const 7_i32, const 8_i32]\n 58:20-58:36: @2[7]: _5 = move _6\n 58:20-58:36: @2[8]: _4 = move _5 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-58:20-58:36: @3.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb4, unwind: bb10]\n-58:9-58:17: @4[1]: FakeRead(ForLet, _3)\n-59:52-59:60: @4[4]: _8 = move _3\n-59:5-59:61: @4.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb5, unwind: bb8]\n-60:5-60:91: @5.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb6, unwind: bb8]\n-53:25-61:2: @6[1]: _0 = const ()\n-61:2-61:2: @7.Return: return\"><span class=\"annotation\">@0,1,2,3,4,5,6,7\u298a</span>fn use_this_lib_crate() {</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb10]\n-55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb10]\n+58:20-58:36: @4.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb5, unwind: bb12]\n+58:9-58:17: @5[1]: FakeRead(ForLet, _3)\n+59:52-59:60: @5[4]: _8 = move _3\n+59:5-59:61: @5.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb6, unwind: bb9]\n+60:5-60:91: @6.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb7, unwind: bb10]\n+53:25-61:2: @7[1]: _0 = const ()\n+61:2-61:2: @8.Return: return\"><span class=\"annotation\">@0,1,2,3,4,5,6,7,8\u298a</span>fn use_this_lib_crate() {</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb13]\n+55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb13]\n 58:20-58:36: @2[5]: _6 = Box([i32; 4])\n 58:20-58:36: @2[6]: (*_6) = [const 5_i32, const 6_i32, const 7_i32, const 8_i32]\n 58:20-58:36: @2[7]: _5 = move _6\n 58:20-58:36: @2[8]: _4 = move _5 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-58:20-58:36: @3.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb4, unwind: bb10]\n-58:9-58:17: @4[1]: FakeRead(ForLet, _3)\n-59:52-59:60: @4[4]: _8 = move _3\n-59:5-59:61: @4.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb5, unwind: bb8]\n-60:5-60:91: @5.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb6, unwind: bb8]\n-53:25-61:2: @6[1]: _0 = const ()\n-61:2-61:2: @7.Return: return\">    used_from_bin_crate_and_lib_crate_generic_function(\"used from library used_crate.rs\");</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb10]\n-55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb10]\n+58:20-58:36: @4.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb5, unwind: bb12]\n+58:9-58:17: @5[1]: FakeRead(ForLet, _3)\n+59:52-59:60: @5[4]: _8 = move _3\n+59:5-59:61: @5.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb6, unwind: bb9]\n+60:5-60:91: @6.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb7, unwind: bb10]\n+53:25-61:2: @7[1]: _0 = const ()\n+61:2-61:2: @8.Return: return\">    used_from_bin_crate_and_lib_crate_generic_function(\"used from library used_crate.rs\");</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb13]\n+55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb13]\n 58:20-58:36: @2[5]: _6 = Box([i32; 4])\n 58:20-58:36: @2[6]: (*_6) = [const 5_i32, const 6_i32, const 7_i32, const 8_i32]\n 58:20-58:36: @2[7]: _5 = move _6\n 58:20-58:36: @2[8]: _4 = move _5 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-58:20-58:36: @3.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb4, unwind: bb10]\n-58:9-58:17: @4[1]: FakeRead(ForLet, _3)\n-59:52-59:60: @4[4]: _8 = move _3\n-59:5-59:61: @4.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb5, unwind: bb8]\n-60:5-60:91: @5.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb6, unwind: bb8]\n-53:25-61:2: @6[1]: _0 = const ()\n-61:2-61:2: @7.Return: return\">    used_with_same_type_from_bin_crate_and_lib_crate_generic_function(</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb10]\n-55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb10]\n+58:20-58:36: @4.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb5, unwind: bb12]\n+58:9-58:17: @5[1]: FakeRead(ForLet, _3)\n+59:52-59:60: @5[4]: _8 = move _3\n+59:5-59:61: @5.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb6, unwind: bb9]\n+60:5-60:91: @6.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb7, unwind: bb10]\n+53:25-61:2: @7[1]: _0 = const ()\n+61:2-61:2: @8.Return: return\">    used_with_same_type_from_bin_crate_and_lib_crate_generic_function(</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb13]\n+55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb13]\n 58:20-58:36: @2[5]: _6 = Box([i32; 4])\n 58:20-58:36: @2[6]: (*_6) = [const 5_i32, const 6_i32, const 7_i32, const 8_i32]\n 58:20-58:36: @2[7]: _5 = move _6\n 58:20-58:36: @2[8]: _4 = move _5 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-58:20-58:36: @3.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb4, unwind: bb10]\n-58:9-58:17: @4[1]: FakeRead(ForLet, _3)\n-59:52-59:60: @4[4]: _8 = move _3\n-59:5-59:61: @4.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb5, unwind: bb8]\n-60:5-60:91: @5.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb6, unwind: bb8]\n-53:25-61:2: @6[1]: _0 = const ()\n-61:2-61:2: @7.Return: return\">        \"used from library used_crate.rs\",</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb10]\n-55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb10]\n+58:20-58:36: @4.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb5, unwind: bb12]\n+58:9-58:17: @5[1]: FakeRead(ForLet, _3)\n+59:52-59:60: @5[4]: _8 = move _3\n+59:5-59:61: @5.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb6, unwind: bb9]\n+60:5-60:91: @6.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb7, unwind: bb10]\n+53:25-61:2: @7[1]: _0 = const ()\n+61:2-61:2: @8.Return: return\">        \"used from library used_crate.rs\",</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb13]\n+55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb13]\n 58:20-58:36: @2[5]: _6 = Box([i32; 4])\n 58:20-58:36: @2[6]: (*_6) = [const 5_i32, const 6_i32, const 7_i32, const 8_i32]\n 58:20-58:36: @2[7]: _5 = move _6\n 58:20-58:36: @2[8]: _4 = move _5 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-58:20-58:36: @3.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb4, unwind: bb10]\n-58:9-58:17: @4[1]: FakeRead(ForLet, _3)\n-59:52-59:60: @4[4]: _8 = move _3\n-59:5-59:61: @4.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb5, unwind: bb8]\n-60:5-60:91: @5.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb6, unwind: bb8]\n-53:25-61:2: @6[1]: _0 = const ()\n-61:2-61:2: @7.Return: return\">    );</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb10]\n-55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb10]\n+58:20-58:36: @4.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb5, unwind: bb12]\n+58:9-58:17: @5[1]: FakeRead(ForLet, _3)\n+59:52-59:60: @5[4]: _8 = move _3\n+59:5-59:61: @5.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb6, unwind: bb9]\n+60:5-60:91: @6.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb7, unwind: bb10]\n+53:25-61:2: @7[1]: _0 = const ()\n+61:2-61:2: @8.Return: return\">    );</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb13]\n+55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb13]\n 58:20-58:36: @2[5]: _6 = Box([i32; 4])\n 58:20-58:36: @2[6]: (*_6) = [const 5_i32, const 6_i32, const 7_i32, const 8_i32]\n 58:20-58:36: @2[7]: _5 = move _6\n 58:20-58:36: @2[8]: _4 = move _5 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-58:20-58:36: @3.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb4, unwind: bb10]\n-58:9-58:17: @4[1]: FakeRead(ForLet, _3)\n-59:52-59:60: @4[4]: _8 = move _3\n-59:5-59:61: @4.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb5, unwind: bb8]\n-60:5-60:91: @5.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb6, unwind: bb8]\n-53:25-61:2: @6[1]: _0 = const ()\n-61:2-61:2: @7.Return: return\">    let some_vec = vec![5, 6, 7, 8];</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb10]\n-55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb10]\n+58:20-58:36: @4.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb5, unwind: bb12]\n+58:9-58:17: @5[1]: FakeRead(ForLet, _3)\n+59:52-59:60: @5[4]: _8 = move _3\n+59:5-59:61: @5.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb6, unwind: bb9]\n+60:5-60:91: @6.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb7, unwind: bb10]\n+53:25-61:2: @7[1]: _0 = const ()\n+61:2-61:2: @8.Return: return\">    let some_vec = vec![5, 6, 7, 8];</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb13]\n+55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb13]\n 58:20-58:36: @2[5]: _6 = Box([i32; 4])\n 58:20-58:36: @2[6]: (*_6) = [const 5_i32, const 6_i32, const 7_i32, const 8_i32]\n 58:20-58:36: @2[7]: _5 = move _6\n 58:20-58:36: @2[8]: _4 = move _5 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-58:20-58:36: @3.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb4, unwind: bb10]\n-58:9-58:17: @4[1]: FakeRead(ForLet, _3)\n-59:52-59:60: @4[4]: _8 = move _3\n-59:5-59:61: @4.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb5, unwind: bb8]\n-60:5-60:91: @5.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb6, unwind: bb8]\n-53:25-61:2: @6[1]: _0 = const ()\n-61:2-61:2: @7.Return: return\">    used_only_from_this_lib_crate_generic_function(some_vec);</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb10]\n-55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb10]\n+58:20-58:36: @4.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb5, unwind: bb12]\n+58:9-58:17: @5[1]: FakeRead(ForLet, _3)\n+59:52-59:60: @5[4]: _8 = move _3\n+59:5-59:61: @5.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb6, unwind: bb9]\n+60:5-60:91: @6.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb7, unwind: bb10]\n+53:25-61:2: @7[1]: _0 = const ()\n+61:2-61:2: @8.Return: return\">    used_only_from_this_lib_crate_generic_function(some_vec);</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb13]\n+55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb13]\n 58:20-58:36: @2[5]: _6 = Box([i32; 4])\n 58:20-58:36: @2[6]: (*_6) = [const 5_i32, const 6_i32, const 7_i32, const 8_i32]\n 58:20-58:36: @2[7]: _5 = move _6\n 58:20-58:36: @2[8]: _4 = move _5 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-58:20-58:36: @3.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb4, unwind: bb10]\n-58:9-58:17: @4[1]: FakeRead(ForLet, _3)\n-59:52-59:60: @4[4]: _8 = move _3\n-59:5-59:61: @4.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb5, unwind: bb8]\n-60:5-60:91: @5.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb6, unwind: bb8]\n-53:25-61:2: @6[1]: _0 = const ()\n-61:2-61:2: @7.Return: return\">    used_only_from_this_lib_crate_generic_function(\"used ONLY from library used_crate.rs\");</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb10]\n-55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb10]\n+58:20-58:36: @4.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb5, unwind: bb12]\n+58:9-58:17: @5[1]: FakeRead(ForLet, _3)\n+59:52-59:60: @5[4]: _8 = move _3\n+59:5-59:61: @5.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb6, unwind: bb9]\n+60:5-60:91: @6.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb7, unwind: bb10]\n+53:25-61:2: @7[1]: _0 = const ()\n+61:2-61:2: @8.Return: return\">    used_only_from_this_lib_crate_generic_function(\"used ONLY from library used_crate.rs\");</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb13]\n+55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb13]\n 58:20-58:36: @2[5]: _6 = Box([i32; 4])\n 58:20-58:36: @2[6]: (*_6) = [const 5_i32, const 6_i32, const 7_i32, const 8_i32]\n 58:20-58:36: @2[7]: _5 = move _6\n 58:20-58:36: @2[8]: _4 = move _5 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-58:20-58:36: @3.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb4, unwind: bb10]\n-58:9-58:17: @4[1]: FakeRead(ForLet, _3)\n-59:52-59:60: @4[4]: _8 = move _3\n-59:5-59:61: @4.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb5, unwind: bb8]\n-60:5-60:91: @5.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb6, unwind: bb8]\n-53:25-61:2: @6[1]: _0 = const ()\n-61:2-61:2: @7.Return: return\">}<span class=\"annotation\">\u2989@0,1,2,3,4,5,6,7</span></span></span></span></div>\n+58:20-58:36: @4.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb5, unwind: bb12]\n+58:9-58:17: @5[1]: FakeRead(ForLet, _3)\n+59:52-59:60: @5[4]: _8 = move _3\n+59:5-59:61: @5.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb6, unwind: bb9]\n+60:5-60:91: @6.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb7, unwind: bb10]\n+53:25-61:2: @7[1]: _0 = const ()\n+61:2-61:2: @8.Return: return\">}<span class=\"annotation\">\u2989@0,1,2,3,4,5,6,7,8</span></span></span></span></div>\n </body>\n </html>"}, {"sha": "acb2c7d63f51b3b383a83d59579298852f66d8d0", "filename": "src/test/run-make-fulldeps/coverage-spanview/expected_mir_dump.uses_crate/uses_crate.main.-------.InstrumentCoverage.0.html", "status": "modified", "additions": 88, "deletions": 88, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.uses_crate%2Fuses_crate.main.-------.InstrumentCoverage.0.html", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.uses_crate%2Fuses_crate.main.-------.InstrumentCoverage.0.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.uses_crate%2Fuses_crate.main.-------.InstrumentCoverage.0.html?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -69,125 +69,125 @@\n </style>\n </head>\n <body>\n-<div class=\"code\" style=\"counter-reset: line 4\"><span class=\"line\"><span><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb11]\n+<div class=\"code\" style=\"counter-reset: line 4\"><span class=\"line\"><span><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb14]\n 7:20-7:36: @1[5]: _5 = Box([i32; 4])\n 7:20-7:36: @1[6]: (*_5) = [const 1_i32, const 2_i32, const 3_i32, const 4_i32]\n 7:20-7:36: @1[7]: _4 = move _5\n 7:20-7:36: @1[8]: _3 = move _4 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-7:20-7:36: @2.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb3, unwind: bb11]\n-7:9-7:17: @3[1]: FakeRead(ForLet, _2)\n-8:59-8:68: @3[4]: _7 = &amp;_2\n-8:5-8:69: @3.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb4, unwind: bb9]\n-9:5-9:89: @4.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb5, unwind: bb9]\n-10:68-10:76: @5[3]: _10 = move _2\n-10:5-10:77: @5.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb6, unwind: bb9]\n-11:5-11:98: @6.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb7, unwind: bb9]\n-5:11-12:2: @7[1]: _0 = const ()\n-12:2-12:2: @8.Return: return\"><span class=\"annotation\">@0,1,2,3,4,5,6,7,8\u298a</span>fn main() {</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb11]\n+7:20-7:36: @3.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb4, unwind: bb13]\n+7:9-7:17: @4[1]: FakeRead(ForLet, _2)\n+8:59-8:68: @4[4]: _7 = &amp;_2\n+8:5-8:69: @4.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb5, unwind: bb11]\n+9:5-9:89: @5.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb6, unwind: bb11]\n+10:68-10:76: @6[3]: _10 = move _2\n+10:5-10:77: @6.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb7, unwind: bb10]\n+11:5-11:98: @7.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb8, unwind: bb11]\n+5:11-12:2: @8[1]: _0 = const ()\n+12:2-12:2: @9.Return: return\"><span class=\"annotation\">@0,1,2,3,4,5,6,7,8,9\u298a</span>fn main() {</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb14]\n 7:20-7:36: @1[5]: _5 = Box([i32; 4])\n 7:20-7:36: @1[6]: (*_5) = [const 1_i32, const 2_i32, const 3_i32, const 4_i32]\n 7:20-7:36: @1[7]: _4 = move _5\n 7:20-7:36: @1[8]: _3 = move _4 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-7:20-7:36: @2.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb3, unwind: bb11]\n-7:9-7:17: @3[1]: FakeRead(ForLet, _2)\n-8:59-8:68: @3[4]: _7 = &amp;_2\n-8:5-8:69: @3.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb4, unwind: bb9]\n-9:5-9:89: @4.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb5, unwind: bb9]\n-10:68-10:76: @5[3]: _10 = move _2\n-10:5-10:77: @5.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb6, unwind: bb9]\n-11:5-11:98: @6.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb7, unwind: bb9]\n-5:11-12:2: @7[1]: _0 = const ()\n-12:2-12:2: @8.Return: return\">    used_crate::used_function();</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb11]\n+7:20-7:36: @3.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb4, unwind: bb13]\n+7:9-7:17: @4[1]: FakeRead(ForLet, _2)\n+8:59-8:68: @4[4]: _7 = &amp;_2\n+8:5-8:69: @4.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb5, unwind: bb11]\n+9:5-9:89: @5.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb6, unwind: bb11]\n+10:68-10:76: @6[3]: _10 = move _2\n+10:5-10:77: @6.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb7, unwind: bb10]\n+11:5-11:98: @7.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb8, unwind: bb11]\n+5:11-12:2: @8[1]: _0 = const ()\n+12:2-12:2: @9.Return: return\">    used_crate::used_function();</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb14]\n 7:20-7:36: @1[5]: _5 = Box([i32; 4])\n 7:20-7:36: @1[6]: (*_5) = [const 1_i32, const 2_i32, const 3_i32, const 4_i32]\n 7:20-7:36: @1[7]: _4 = move _5\n 7:20-7:36: @1[8]: _3 = move _4 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-7:20-7:36: @2.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb3, unwind: bb11]\n-7:9-7:17: @3[1]: FakeRead(ForLet, _2)\n-8:59-8:68: @3[4]: _7 = &amp;_2\n-8:5-8:69: @3.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb4, unwind: bb9]\n-9:5-9:89: @4.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb5, unwind: bb9]\n-10:68-10:76: @5[3]: _10 = move _2\n-10:5-10:77: @5.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb6, unwind: bb9]\n-11:5-11:98: @6.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb7, unwind: bb9]\n-5:11-12:2: @7[1]: _0 = const ()\n-12:2-12:2: @8.Return: return\">    let some_vec = vec![1, 2, 3, 4];</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb11]\n+7:20-7:36: @3.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb4, unwind: bb13]\n+7:9-7:17: @4[1]: FakeRead(ForLet, _2)\n+8:59-8:68: @4[4]: _7 = &amp;_2\n+8:5-8:69: @4.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb5, unwind: bb11]\n+9:5-9:89: @5.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb6, unwind: bb11]\n+10:68-10:76: @6[3]: _10 = move _2\n+10:5-10:77: @6.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb7, unwind: bb10]\n+11:5-11:98: @7.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb8, unwind: bb11]\n+5:11-12:2: @8[1]: _0 = const ()\n+12:2-12:2: @9.Return: return\">    let some_vec = vec![1, 2, 3, 4];</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb14]\n 7:20-7:36: @1[5]: _5 = Box([i32; 4])\n 7:20-7:36: @1[6]: (*_5) = [const 1_i32, const 2_i32, const 3_i32, const 4_i32]\n 7:20-7:36: @1[7]: _4 = move _5\n 7:20-7:36: @1[8]: _3 = move _4 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-7:20-7:36: @2.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb3, unwind: bb11]\n-7:9-7:17: @3[1]: FakeRead(ForLet, _2)\n-8:59-8:68: @3[4]: _7 = &amp;_2\n-8:5-8:69: @3.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb4, unwind: bb9]\n-9:5-9:89: @4.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb5, unwind: bb9]\n-10:68-10:76: @5[3]: _10 = move _2\n-10:5-10:77: @5.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb6, unwind: bb9]\n-11:5-11:98: @6.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb7, unwind: bb9]\n-5:11-12:2: @7[1]: _0 = const ()\n-12:2-12:2: @8.Return: return\">    used_crate::used_only_from_bin_crate_generic_function(&amp;some_vec);</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb11]\n+7:20-7:36: @3.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb4, unwind: bb13]\n+7:9-7:17: @4[1]: FakeRead(ForLet, _2)\n+8:59-8:68: @4[4]: _7 = &amp;_2\n+8:5-8:69: @4.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb5, unwind: bb11]\n+9:5-9:89: @5.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb6, unwind: bb11]\n+10:68-10:76: @6[3]: _10 = move _2\n+10:5-10:77: @6.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb7, unwind: bb10]\n+11:5-11:98: @7.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb8, unwind: bb11]\n+5:11-12:2: @8[1]: _0 = const ()\n+12:2-12:2: @9.Return: return\">    used_crate::used_only_from_bin_crate_generic_function(&amp;some_vec);</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb14]\n 7:20-7:36: @1[5]: _5 = Box([i32; 4])\n 7:20-7:36: @1[6]: (*_5) = [const 1_i32, const 2_i32, const 3_i32, const 4_i32]\n 7:20-7:36: @1[7]: _4 = move _5\n 7:20-7:36: @1[8]: _3 = move _4 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-7:20-7:36: @2.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb3, unwind: bb11]\n-7:9-7:17: @3[1]: FakeRead(ForLet, _2)\n-8:59-8:68: @3[4]: _7 = &amp;_2\n-8:5-8:69: @3.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb4, unwind: bb9]\n-9:5-9:89: @4.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb5, unwind: bb9]\n-10:68-10:76: @5[3]: _10 = move _2\n-10:5-10:77: @5.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb6, unwind: bb9]\n-11:5-11:98: @6.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb7, unwind: bb9]\n-5:11-12:2: @7[1]: _0 = const ()\n-12:2-12:2: @8.Return: return\">    used_crate::used_only_from_bin_crate_generic_function(\"used from bin uses_crate.rs\");</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb11]\n+7:20-7:36: @3.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb4, unwind: bb13]\n+7:9-7:17: @4[1]: FakeRead(ForLet, _2)\n+8:59-8:68: @4[4]: _7 = &amp;_2\n+8:5-8:69: @4.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb5, unwind: bb11]\n+9:5-9:89: @5.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb6, unwind: bb11]\n+10:68-10:76: @6[3]: _10 = move _2\n+10:5-10:77: @6.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb7, unwind: bb10]\n+11:5-11:98: @7.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb8, unwind: bb11]\n+5:11-12:2: @8[1]: _0 = const ()\n+12:2-12:2: @9.Return: return\">    used_crate::used_only_from_bin_crate_generic_function(\"used from bin uses_crate.rs\");</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb14]\n 7:20-7:36: @1[5]: _5 = Box([i32; 4])\n 7:20-7:36: @1[6]: (*_5) = [const 1_i32, const 2_i32, const 3_i32, const 4_i32]\n 7:20-7:36: @1[7]: _4 = move _5\n 7:20-7:36: @1[8]: _3 = move _4 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-7:20-7:36: @2.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb3, unwind: bb11]\n-7:9-7:17: @3[1]: FakeRead(ForLet, _2)\n-8:59-8:68: @3[4]: _7 = &amp;_2\n-8:5-8:69: @3.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb4, unwind: bb9]\n-9:5-9:89: @4.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb5, unwind: bb9]\n-10:68-10:76: @5[3]: _10 = move _2\n-10:5-10:77: @5.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb6, unwind: bb9]\n-11:5-11:98: @6.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb7, unwind: bb9]\n-5:11-12:2: @7[1]: _0 = const ()\n-12:2-12:2: @8.Return: return\">    used_crate::used_from_bin_crate_and_lib_crate_generic_function(some_vec);</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb11]\n+7:20-7:36: @3.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb4, unwind: bb13]\n+7:9-7:17: @4[1]: FakeRead(ForLet, _2)\n+8:59-8:68: @4[4]: _7 = &amp;_2\n+8:5-8:69: @4.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb5, unwind: bb11]\n+9:5-9:89: @5.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb6, unwind: bb11]\n+10:68-10:76: @6[3]: _10 = move _2\n+10:5-10:77: @6.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb7, unwind: bb10]\n+11:5-11:98: @7.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb8, unwind: bb11]\n+5:11-12:2: @8[1]: _0 = const ()\n+12:2-12:2: @9.Return: return\">    used_crate::used_from_bin_crate_and_lib_crate_generic_function(some_vec);</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb14]\n 7:20-7:36: @1[5]: _5 = Box([i32; 4])\n 7:20-7:36: @1[6]: (*_5) = [const 1_i32, const 2_i32, const 3_i32, const 4_i32]\n 7:20-7:36: @1[7]: _4 = move _5\n 7:20-7:36: @1[8]: _3 = move _4 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-7:20-7:36: @2.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb3, unwind: bb11]\n-7:9-7:17: @3[1]: FakeRead(ForLet, _2)\n-8:59-8:68: @3[4]: _7 = &amp;_2\n-8:5-8:69: @3.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb4, unwind: bb9]\n-9:5-9:89: @4.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb5, unwind: bb9]\n-10:68-10:76: @5[3]: _10 = move _2\n-10:5-10:77: @5.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb6, unwind: bb9]\n-11:5-11:98: @6.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb7, unwind: bb9]\n-5:11-12:2: @7[1]: _0 = const ()\n-12:2-12:2: @8.Return: return\">    used_crate::used_with_same_type_from_bin_crate_and_lib_crate_generic_function(\"interesting?\");</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb11]\n+7:20-7:36: @3.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb4, unwind: bb13]\n+7:9-7:17: @4[1]: FakeRead(ForLet, _2)\n+8:59-8:68: @4[4]: _7 = &amp;_2\n+8:5-8:69: @4.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb5, unwind: bb11]\n+9:5-9:89: @5.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb6, unwind: bb11]\n+10:68-10:76: @6[3]: _10 = move _2\n+10:5-10:77: @6.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb7, unwind: bb10]\n+11:5-11:98: @7.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb8, unwind: bb11]\n+5:11-12:2: @8[1]: _0 = const ()\n+12:2-12:2: @9.Return: return\">    used_crate::used_with_same_type_from_bin_crate_and_lib_crate_generic_function(\"interesting?\");</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb14]\n 7:20-7:36: @1[5]: _5 = Box([i32; 4])\n 7:20-7:36: @1[6]: (*_5) = [const 1_i32, const 2_i32, const 3_i32, const 4_i32]\n 7:20-7:36: @1[7]: _4 = move _5\n 7:20-7:36: @1[8]: _3 = move _4 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-7:20-7:36: @2.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb3, unwind: bb11]\n-7:9-7:17: @3[1]: FakeRead(ForLet, _2)\n-8:59-8:68: @3[4]: _7 = &amp;_2\n-8:5-8:69: @3.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb4, unwind: bb9]\n-9:5-9:89: @4.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb5, unwind: bb9]\n-10:68-10:76: @5[3]: _10 = move _2\n-10:5-10:77: @5.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb6, unwind: bb9]\n-11:5-11:98: @6.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb7, unwind: bb9]\n-5:11-12:2: @7[1]: _0 = const ()\n-12:2-12:2: @8.Return: return\">}<span class=\"annotation\">\u2989@0,1,2,3,4,5,6,7,8</span></span></span></span></div>\n+7:20-7:36: @3.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb4, unwind: bb13]\n+7:9-7:17: @4[1]: FakeRead(ForLet, _2)\n+8:59-8:68: @4[4]: _7 = &amp;_2\n+8:5-8:69: @4.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb5, unwind: bb11]\n+9:5-9:89: @5.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb6, unwind: bb11]\n+10:68-10:76: @6[3]: _10 = move _2\n+10:5-10:77: @6.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb7, unwind: bb10]\n+11:5-11:98: @7.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb8, unwind: bb11]\n+5:11-12:2: @8[1]: _0 = const ()\n+12:2-12:2: @9.Return: return\">}<span class=\"annotation\">\u2989@0,1,2,3,4,5,6,7,8,9</span></span></span></span></div>\n </body>\n </html>"}, {"sha": "c0bf0bdf731e69ee56144a6a67d55d55dcea2fa4", "filename": "src/test/ui/drop/dynamic-drop-async.rs", "status": "modified", "additions": 54, "deletions": 111, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -43,7 +43,6 @@ impl<T: Unpin> Future for Defer<T> {\n /// The `failing_op`-th operation will panic.\n struct Allocator {\n     data: RefCell<Vec<bool>>,\n-    name: &'static str,\n     failing_op: usize,\n     cur_ops: Cell<usize>,\n }\n@@ -55,28 +54,23 @@ impl Drop for Allocator {\n     fn drop(&mut self) {\n         let data = self.data.borrow();\n         if data.iter().any(|d| *d) {\n-            panic!(\"missing free in {:?}: {:?}\", self.name, data);\n+            panic!(\"missing free: {:?}\", data);\n         }\n     }\n }\n \n impl Allocator {\n-    fn new(failing_op: usize, name: &'static str) -> Self {\n-        Allocator {\n-            failing_op,\n-            name,\n-            cur_ops: Cell::new(0),\n-            data: RefCell::new(vec![]),\n-        }\n+    fn new(failing_op: usize) -> Self {\n+        Allocator { failing_op, cur_ops: Cell::new(0), data: RefCell::new(vec![]) }\n     }\n-    fn alloc(self: &Rc<Allocator>) -> impl Future<Output = Ptr> + 'static {\n+    fn alloc(&self) -> impl Future<Output = Ptr<'_>> + '_ {\n         self.fallible_operation();\n \n         let mut data = self.data.borrow_mut();\n \n         let addr = data.len();\n         data.push(true);\n-        Defer { ready: false, value: Some(Ptr(addr, self.clone())) }\n+        Defer { ready: false, value: Some(Ptr(addr, self)) }\n     }\n     fn fallible_operation(&self) {\n         self.cur_ops.set(self.cur_ops.get() + 1);\n@@ -89,11 +83,11 @@ impl Allocator {\n \n // Type that tracks whether it was dropped and can panic when it's created or\n // destroyed.\n-struct Ptr(usize, Rc<Allocator>);\n-impl Drop for Ptr {\n+struct Ptr<'a>(usize, &'a Allocator);\n+impl<'a> Drop for Ptr<'a> {\n     fn drop(&mut self) {\n         match self.1.data.borrow_mut()[self.0] {\n-            false => panic!(\"double free in {:?} at index {:?}\", self.1.name, self.0),\n+            false => panic!(\"double free at index {:?}\", self.0),\n             ref mut d => *d = false,\n         }\n \n@@ -117,7 +111,7 @@ async fn dynamic_drop(a: Rc<Allocator>, c: bool) {\n     };\n }\n \n-struct TwoPtrs(Ptr, Ptr);\n+struct TwoPtrs<'a>(Ptr<'a>, Ptr<'a>);\n async fn struct_dynamic_drop(a: Rc<Allocator>, c0: bool, c1: bool, c: bool) {\n     for i in 0..2 {\n         let x;\n@@ -238,62 +232,21 @@ async fn move_ref_pattern(a: Rc<Allocator>) {\n     a.alloc().await;\n }\n \n-async fn panic_after_return(a: Rc<Allocator>, c: bool) -> (Ptr,) {\n-    a.alloc().await;\n-    let p = a.alloc().await;\n-    if c {\n-        a.alloc().await;\n-        let q = a.alloc().await;\n-        // We use a return type that isn't used anywhere else to make sure that\n-        // the return place doesn't incorrectly end up in the generator state.\n-        return (a.alloc().await,);\n-    }\n-    (a.alloc().await,)\n-}\n-\n-\n-async fn panic_after_init_by_loop(a: Rc<Allocator>) {\n-    a.alloc().await;\n-    let p = a.alloc().await;\n-    let q = loop {\n-        a.alloc().await;\n-        let r = a.alloc().await;\n-        break a.alloc().await;\n-    };\n-}\n-\n-async fn panic_after_init_by_match_with_bindings_and_guard(a: Rc<Allocator>, b: bool) {\n-    a.alloc().await;\n-    let p = a.alloc().await;\n-    let q = match a.alloc().await {\n-        ref _x if b => {\n-            a.alloc().await;\n-            let r = a.alloc().await;\n-            a.alloc().await\n-        }\n-        _x => {\n-            a.alloc().await;\n-            let r = a.alloc().await;\n-            a.alloc().await\n-        },\n-    };\n-}\n-\n-fn run_test<F, G, O>(cx: &mut Context<'_>, ref f: F, name: &'static str)\n+fn run_test<F, G>(cx: &mut Context<'_>, ref f: F)\n where\n     F: Fn(Rc<Allocator>) -> G,\n-    G: Future<Output = O>,\n+    G: Future<Output = ()>,\n {\n     for polls in 0.. {\n         // Run without any panics to find which operations happen after the\n         // penultimate `poll`.\n-        let first_alloc = Rc::new(Allocator::new(usize::MAX, name));\n+        let first_alloc = Rc::new(Allocator::new(usize::MAX));\n         let mut fut = Box::pin(f(first_alloc.clone()));\n         let mut ops_before_last_poll = 0;\n         let mut completed = false;\n         for _ in 0..polls {\n             ops_before_last_poll = first_alloc.cur_ops.get();\n-            if let Poll::Ready(_) = fut.as_mut().poll(cx) {\n+            if let Poll::Ready(()) = fut.as_mut().poll(cx) {\n                 completed = true;\n             }\n         }\n@@ -302,7 +255,7 @@ where\n         // Start at `ops_before_last_poll` so that we will always be able to\n         // `poll` the expected number of times.\n         for failing_op in ops_before_last_poll..first_alloc.cur_ops.get() {\n-            let alloc = Rc::new(Allocator::new(failing_op + 1, name));\n+            let alloc = Rc::new(Allocator::new(failing_op + 1));\n             let f = &f;\n             let cx = &mut *cx;\n             let result = panic::catch_unwind(panic::AssertUnwindSafe(move || {\n@@ -332,58 +285,48 @@ fn clone_waker(data: *const ()) -> RawWaker {\n     RawWaker::new(data, &RawWakerVTable::new(clone_waker, drop, drop, drop))\n }\n \n-macro_rules! run_test {\n-    ($ctxt:expr, $e:expr) => { run_test($ctxt, $e, stringify!($e)); };\n-}\n-\n fn main() {\n     let waker = unsafe { Waker::from_raw(clone_waker(ptr::null())) };\n     let context = &mut Context::from_waker(&waker);\n \n-    run_test!(context, |a| dynamic_init(a, false));\n-    run_test!(context, |a| dynamic_init(a, true));\n-    run_test!(context, |a| dynamic_drop(a, false));\n-    run_test!(context, |a| dynamic_drop(a, true));\n-\n-    run_test!(context, |a| assignment(a, false, false));\n-    run_test!(context, |a| assignment(a, false, true));\n-    run_test!(context, |a| assignment(a, true, false));\n-    run_test!(context, |a| assignment(a, true, true));\n-\n-    run_test!(context, |a| array_simple(a));\n-    run_test!(context, |a| vec_simple(a));\n-    run_test!(context, |a| vec_unreachable(a));\n-\n-    run_test!(context, |a| struct_dynamic_drop(a, false, false, false));\n-    run_test!(context, |a| struct_dynamic_drop(a, false, false, true));\n-    run_test!(context, |a| struct_dynamic_drop(a, false, true, false));\n-    run_test!(context, |a| struct_dynamic_drop(a, false, true, true));\n-    run_test!(context, |a| struct_dynamic_drop(a, true, false, false));\n-    run_test!(context, |a| struct_dynamic_drop(a, true, false, true));\n-    run_test!(context, |a| struct_dynamic_drop(a, true, true, false));\n-    run_test!(context, |a| struct_dynamic_drop(a, true, true, true));\n-\n-    run_test!(context, |a| field_assignment(a, false));\n-    run_test!(context, |a| field_assignment(a, true));\n-\n-    run_test!(context, |a| mixed_drop_and_nondrop(a));\n-\n-    run_test!(context, |a| slice_pattern_one_of(a, 0));\n-    run_test!(context, |a| slice_pattern_one_of(a, 1));\n-    run_test!(context, |a| slice_pattern_one_of(a, 2));\n-    run_test!(context, |a| slice_pattern_one_of(a, 3));\n-\n-    run_test!(context, |a| subslice_pattern_from_end_with_drop(a, true, true));\n-    run_test!(context, |a| subslice_pattern_from_end_with_drop(a, true, false));\n-    run_test!(context, |a| subslice_pattern_from_end_with_drop(a, false, true));\n-    run_test!(context, |a| subslice_pattern_from_end_with_drop(a, false, false));\n-    run_test!(context, |a| subslice_pattern_reassign(a));\n-\n-    run_test!(context, |a| move_ref_pattern(a));\n-\n-    run_test!(context, |a| panic_after_return(a, false));\n-    run_test!(context, |a| panic_after_return(a, true));\n-    run_test!(context, |a| panic_after_init_by_loop(a));\n-    run_test!(context, |a| panic_after_init_by_match_with_bindings_and_guard(a, false));\n-    run_test!(context, |a| panic_after_init_by_match_with_bindings_and_guard(a, true));\n+    run_test(context, |a| dynamic_init(a, false));\n+    run_test(context, |a| dynamic_init(a, true));\n+    run_test(context, |a| dynamic_drop(a, false));\n+    run_test(context, |a| dynamic_drop(a, true));\n+\n+    run_test(context, |a| assignment(a, false, false));\n+    run_test(context, |a| assignment(a, false, true));\n+    run_test(context, |a| assignment(a, true, false));\n+    run_test(context, |a| assignment(a, true, true));\n+\n+    run_test(context, |a| array_simple(a));\n+    run_test(context, |a| vec_simple(a));\n+    run_test(context, |a| vec_unreachable(a));\n+\n+    run_test(context, |a| struct_dynamic_drop(a, false, false, false));\n+    run_test(context, |a| struct_dynamic_drop(a, false, false, true));\n+    run_test(context, |a| struct_dynamic_drop(a, false, true, false));\n+    run_test(context, |a| struct_dynamic_drop(a, false, true, true));\n+    run_test(context, |a| struct_dynamic_drop(a, true, false, false));\n+    run_test(context, |a| struct_dynamic_drop(a, true, false, true));\n+    run_test(context, |a| struct_dynamic_drop(a, true, true, false));\n+    run_test(context, |a| struct_dynamic_drop(a, true, true, true));\n+\n+    run_test(context, |a| field_assignment(a, false));\n+    run_test(context, |a| field_assignment(a, true));\n+\n+    run_test(context, |a| mixed_drop_and_nondrop(a));\n+\n+    run_test(context, |a| slice_pattern_one_of(a, 0));\n+    run_test(context, |a| slice_pattern_one_of(a, 1));\n+    run_test(context, |a| slice_pattern_one_of(a, 2));\n+    run_test(context, |a| slice_pattern_one_of(a, 3));\n+\n+    run_test(context, |a| subslice_pattern_from_end_with_drop(a, true, true));\n+    run_test(context, |a| subslice_pattern_from_end_with_drop(a, true, false));\n+    run_test(context, |a| subslice_pattern_from_end_with_drop(a, false, true));\n+    run_test(context, |a| subslice_pattern_from_end_with_drop(a, false, false));\n+    run_test(context, |a| subslice_pattern_reassign(a));\n+\n+    run_test(context, |a| move_ref_pattern(a));\n }"}, {"sha": "e90ea1c55b0c1707c58f9f7b04b7f178f6259491", "filename": "src/test/ui/drop/dynamic-drop.rs", "status": "modified", "additions": 169, "deletions": 268, "changes": 437, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -3,6 +3,7 @@\n \n #![feature(generators, generator_trait)]\n #![feature(bindings_after_at)]\n+\n #![allow(unused_assignments)]\n #![allow(unused_variables)]\n \n@@ -16,7 +17,6 @@ struct InjectedFailure;\n \n struct Allocator {\n     data: RefCell<Vec<bool>>,\n-    name: &'static str,\n     failing_op: usize,\n     cur_ops: Cell<usize>,\n }\n@@ -28,18 +28,17 @@ impl Drop for Allocator {\n     fn drop(&mut self) {\n         let data = self.data.borrow();\n         if data.iter().any(|d| *d) {\n-            panic!(\"missing free in {:?}: {:?}\", self.name, data);\n+            panic!(\"missing free: {:?}\", data);\n         }\n     }\n }\n \n impl Allocator {\n-    fn new(failing_op: usize, name: &'static str) -> Self {\n+    fn new(failing_op: usize) -> Self {\n         Allocator {\n             failing_op: failing_op,\n             cur_ops: Cell::new(0),\n-            data: RefCell::new(vec![]),\n-            name,\n+            data: RefCell::new(vec![])\n         }\n     }\n     fn alloc(&self) -> Ptr<'_> {\n@@ -54,17 +53,33 @@ impl Allocator {\n         data.push(true);\n         Ptr(addr, self)\n     }\n+    // FIXME(#47949) Any use of this indicates a bug in rustc: we should never\n+    // be leaking values in the cases here.\n+    //\n+    // Creates a `Ptr<'_>` and checks that the allocated value is leaked if the\n+    // `failing_op` is in the list of exception.\n+    fn alloc_leaked(&self, exceptions: Vec<usize>) -> Ptr<'_> {\n+        let ptr = self.alloc();\n+\n+        if exceptions.iter().any(|operation| *operation == self.failing_op) {\n+            let mut data = self.data.borrow_mut();\n+            data[ptr.0] = false;\n+        }\n+        ptr\n+    }\n }\n \n struct Ptr<'a>(usize, &'a Allocator);\n impl<'a> Drop for Ptr<'a> {\n     fn drop(&mut self) {\n         match self.1.data.borrow_mut()[self.0] {\n-            false => panic!(\"double free in {:?} at index {:?}\", self.1.name, self.0),\n-            ref mut d => *d = false,\n+            false => {\n+                panic!(\"double free at index {:?}\", self.0)\n+            }\n+            ref mut d => *d = false\n         }\n \n-        self.1.cur_ops.set(self.1.cur_ops.get() + 1);\n+        self.1.cur_ops.set(self.1.cur_ops.get()+1);\n \n         if self.1.cur_ops.get() == self.1.failing_op {\n             panic::panic_any(InjectedFailure);\n@@ -162,7 +177,11 @@ fn generator(a: &Allocator, run_count: usize) {\n     assert!(run_count < 4);\n \n     let mut gen = || {\n-        (a.alloc(), yield a.alloc(), a.alloc(), yield a.alloc());\n+        (a.alloc(),\n+         yield a.alloc(),\n+         a.alloc(),\n+         yield a.alloc()\n+         );\n     };\n     for _ in 0..run_count {\n         Pin::new(&mut gen).resume(());\n@@ -186,50 +205,38 @@ fn vec_unreachable(a: &Allocator) {\n }\n \n fn slice_pattern_first(a: &Allocator) {\n-    let [_x, ..] = [a.alloc(), a.alloc(), a.alloc()];\n+    let[_x, ..] = [a.alloc(), a.alloc(), a.alloc()];\n }\n \n fn slice_pattern_middle(a: &Allocator) {\n-    let [_, _x, _] = [a.alloc(), a.alloc(), a.alloc()];\n+    let[_, _x, _] = [a.alloc(), a.alloc(), a.alloc()];\n }\n \n fn slice_pattern_two(a: &Allocator) {\n-    let [_x, _, _y, _] = [a.alloc(), a.alloc(), a.alloc(), a.alloc()];\n+    let[_x, _, _y, _] = [a.alloc(), a.alloc(), a.alloc(), a.alloc()];\n }\n \n fn slice_pattern_last(a: &Allocator) {\n-    let [.., _y] = [a.alloc(), a.alloc(), a.alloc(), a.alloc()];\n+    let[.., _y] = [a.alloc(), a.alloc(), a.alloc(), a.alloc()];\n }\n \n fn slice_pattern_one_of(a: &Allocator, i: usize) {\n     let array = [a.alloc(), a.alloc(), a.alloc(), a.alloc()];\n     let _x = match i {\n-        0 => {\n-            let [a, ..] = array;\n-            a\n-        }\n-        1 => {\n-            let [_, a, ..] = array;\n-            a\n-        }\n-        2 => {\n-            let [_, _, a, _] = array;\n-            a\n-        }\n-        3 => {\n-            let [_, _, _, a] = array;\n-            a\n-        }\n+        0 => { let [a, ..] = array; a }\n+        1 => { let [_, a, ..] = array; a }\n+        2 => { let [_, _, a, _] = array; a }\n+        3 => { let [_, _, _, a] = array; a }\n         _ => panic!(\"unmatched\"),\n     };\n }\n \n fn subslice_pattern_from_end(a: &Allocator, arg: bool) {\n     let a = [a.alloc(), a.alloc(), a.alloc()];\n     if arg {\n-        let [.., _x, _] = a;\n+        let[.., _x, _] = a;\n     } else {\n-        let [_, _y @ ..] = a;\n+        let[_, _y @ ..] = a;\n     }\n }\n \n@@ -241,61 +248,45 @@ fn subslice_pattern_from_end_with_drop(a: &Allocator, arg: bool, arg2: bool) {\n     }\n \n     if arg {\n-        let [.., _x, _] = a;\n+        let[.., _x, _] = a;\n     } else {\n-        let [_, _y @ ..] = a;\n+        let[_, _y @ ..] = a;\n     }\n }\n \n fn slice_pattern_reassign(a: &Allocator) {\n     let mut ar = [a.alloc(), a.alloc()];\n-    let [_, _x] = ar;\n+    let[_, _x] = ar;\n     ar = [a.alloc(), a.alloc()];\n-    let [.., _y] = ar;\n+    let[.., _y] = ar;\n }\n \n fn subslice_pattern_reassign(a: &Allocator) {\n     let mut ar = [a.alloc(), a.alloc(), a.alloc()];\n-    let [_, _, _x] = ar;\n+    let[_, _, _x] = ar;\n     ar = [a.alloc(), a.alloc(), a.alloc()];\n-    let [_, _y @ ..] = ar;\n+    let[_, _y @ ..] = ar;\n }\n \n fn index_field_mixed_ends(a: &Allocator) {\n     let ar = [(a.alloc(), a.alloc()), (a.alloc(), a.alloc())];\n-    let [(_x, _), ..] = ar;\n-    let [(_, _y), _] = ar;\n-    let [_, (_, _w)] = ar;\n-    let [.., (_z, _)] = ar;\n+    let[(_x, _), ..] = ar;\n+    let[(_, _y), _] = ar;\n+    let[_, (_, _w)] = ar;\n+    let[.., (_z, _)] = ar;\n }\n \n fn subslice_mixed_min_lengths(a: &Allocator, c: i32) {\n     let ar = [(a.alloc(), a.alloc()), (a.alloc(), a.alloc())];\n     match c {\n-        0 => {\n-            let [_x, ..] = ar;\n-        }\n-        1 => {\n-            let [_x, _, ..] = ar;\n-        }\n-        2 => {\n-            let [_x, _] = ar;\n-        }\n-        3 => {\n-            let [(_x, _), _, ..] = ar;\n-        }\n-        4 => {\n-            let [.., (_x, _)] = ar;\n-        }\n-        5 => {\n-            let [.., (_x, _), _] = ar;\n-        }\n-        6 => {\n-            let [_y @ ..] = ar;\n-        }\n-        _ => {\n-            let [_y @ .., _] = ar;\n-        }\n+        0 => { let[_x, ..] = ar; }\n+        1 => { let[_x, _, ..] = ar; }\n+        2 => { let[_x, _] = ar; }\n+        3 => { let[(_x, _), _, ..] = ar; }\n+        4 => { let[.., (_x, _)] = ar; }\n+        5 => { let[.., (_x, _), _] = ar; }\n+        6 => { let [_y @ ..] = ar; }\n+        _ => { let [_y @ .., _] = ar; }\n     }\n }\n \n@@ -343,160 +334,87 @@ fn move_ref_pattern(a: &Allocator) {\n }\n \n fn panic_after_return(a: &Allocator) -> Ptr<'_> {\n+    // Panic in the drop of `p` or `q` can leak\n+    let exceptions = vec![8, 9];\n     a.alloc();\n     let p = a.alloc();\n     {\n         a.alloc();\n         let p = a.alloc();\n-        a.alloc()\n+        // FIXME (#47949) We leak values when we panic in a destructor after\n+        // evaluating an expression with `rustc_mir::build::Builder::into`.\n+        a.alloc_leaked(exceptions)\n     }\n }\n \n fn panic_after_return_expr(a: &Allocator) -> Ptr<'_> {\n+    // Panic in the drop of `p` or `q` can leak\n+    let exceptions = vec![8, 9];\n     a.alloc();\n     let p = a.alloc();\n     {\n         a.alloc();\n         let q = a.alloc();\n-        return a.alloc();\n+        // FIXME (#47949)\n+        return a.alloc_leaked(exceptions);\n     }\n }\n \n fn panic_after_init(a: &Allocator) {\n+    // Panic in the drop of `r` can leak\n+    let exceptions = vec![8];\n     a.alloc();\n     let p = a.alloc();\n     let q = {\n         a.alloc();\n         let r = a.alloc();\n-        a.alloc()\n+        // FIXME (#47949)\n+        a.alloc_leaked(exceptions)\n     };\n }\n \n fn panic_after_init_temp(a: &Allocator) {\n+    // Panic in the drop of `r` can leak\n+    let exceptions = vec![8];\n     a.alloc();\n     let p = a.alloc();\n     {\n         a.alloc();\n         let r = a.alloc();\n-        a.alloc()\n+        // FIXME (#47949)\n+        a.alloc_leaked(exceptions)\n     };\n }\n \n fn panic_after_init_by_loop(a: &Allocator) {\n+    // Panic in the drop of `r` can leak\n+    let exceptions = vec![8];\n     a.alloc();\n     let p = a.alloc();\n     let q = loop {\n         a.alloc();\n         let r = a.alloc();\n-        break a.alloc();\n-    };\n-}\n-\n-fn panic_after_init_by_match(a: &Allocator, b: bool) {\n-    a.alloc();\n-    let p = a.alloc();\n-    let _ = loop {\n-        let q = match b {\n-            true => {\n-                a.alloc();\n-                let r = a.alloc();\n-                a.alloc()\n-            }\n-            false => {\n-                a.alloc();\n-                let r = a.alloc();\n-                break a.alloc();\n-            }\n-        };\n-        return;\n-    };\n-}\n-\n-fn panic_after_init_by_match_with_guard(a: &Allocator, b: bool) {\n-    a.alloc();\n-    let p = a.alloc();\n-    let q = match a.alloc() {\n-        _ if b => {\n-            a.alloc();\n-            let r = a.alloc();\n-            a.alloc()\n-        }\n-        _ => {\n-            a.alloc();\n-            let r = a.alloc();\n-            a.alloc()\n-        }\n-    };\n-}\n-\n-fn panic_after_init_by_match_with_bindings_and_guard(a: &Allocator, b: bool) {\n-    a.alloc();\n-    let p = a.alloc();\n-    let q = match a.alloc() {\n-        _x if b => {\n-            a.alloc();\n-            let r = a.alloc();\n-            a.alloc()\n-        }\n-        _x => {\n-            a.alloc();\n-            let r = a.alloc();\n-            a.alloc()\n-        }\n-    };\n-}\n-\n-fn panic_after_init_by_match_with_ref_bindings_and_guard(a: &Allocator, b: bool) {\n-    a.alloc();\n-    let p = a.alloc();\n-    let q = match a.alloc() {\n-        ref _x if b => {\n-            a.alloc();\n-            let r = a.alloc();\n-            a.alloc()\n-        }\n-        ref _x => {\n-            a.alloc();\n-            let r = a.alloc();\n-            a.alloc()\n-        }\n-    };\n-}\n-\n-fn panic_after_init_by_break_if(a: &Allocator, b: bool) {\n-    a.alloc();\n-    let p = a.alloc();\n-    let q = loop {\n-        let r = a.alloc();\n-        break if b {\n-            let s = a.alloc();\n-            a.alloc()\n-        } else {\n-            a.alloc()\n-        };\n+        // FIXME (#47949)\n+        break a.alloc_leaked(exceptions);\n     };\n }\n \n-fn run_test<F>(mut f: F, name: &'static str)\n-where\n-    F: FnMut(&Allocator),\n+fn run_test<F>(mut f: F)\n+    where F: FnMut(&Allocator)\n {\n-    let first_alloc = Allocator::new(usize::MAX, name);\n+    let first_alloc = Allocator::new(usize::MAX);\n     f(&first_alloc);\n \n-    for failing_op in 1..first_alloc.cur_ops.get() + 1 {\n-        let alloc = Allocator::new(failing_op, name);\n+    for failing_op in 1..first_alloc.cur_ops.get()+1 {\n+        let alloc = Allocator::new(failing_op);\n         let alloc = &alloc;\n         let f = panic::AssertUnwindSafe(&mut f);\n         let result = panic::catch_unwind(move || {\n             f.0(alloc);\n         });\n         match result {\n-            Ok(..) => panic!(\n-                \"test executed {} ops but now {}\",\n-                first_alloc.cur_ops.get(),\n-                alloc.cur_ops.get()\n-            ),\n+            Ok(..) => panic!(\"test executed {} ops but now {}\",\n+                             first_alloc.cur_ops.get(), alloc.cur_ops.get()),\n             Err(e) => {\n                 if e.downcast_ref::<InjectedFailure>().is_none() {\n                     panic::resume_unwind(e);\n@@ -506,115 +424,98 @@ where\n     }\n }\n \n-fn run_test_nopanic<F>(mut f: F, name: &'static str)\n-where\n-    F: FnMut(&Allocator),\n+fn run_test_nopanic<F>(mut f: F)\n+    where F: FnMut(&Allocator)\n {\n-    let first_alloc = Allocator::new(usize::MAX, name);\n+    let first_alloc = Allocator::new(usize::MAX);\n     f(&first_alloc);\n }\n \n-macro_rules! run_test {\n-    ($e:expr) => {\n-        run_test($e, stringify!($e));\n-    };\n-}\n-\n fn main() {\n-    run_test!(|a| dynamic_init(a, false));\n-    run_test!(|a| dynamic_init(a, true));\n-    run_test!(|a| dynamic_drop(a, false));\n-    run_test!(|a| dynamic_drop(a, true));\n-\n-    run_test!(|a| assignment2(a, false, false));\n-    run_test!(|a| assignment2(a, false, true));\n-    run_test!(|a| assignment2(a, true, false));\n-    run_test!(|a| assignment2(a, true, true));\n-\n-    run_test!(|a| assignment1(a, false));\n-    run_test!(|a| assignment1(a, true));\n-\n-    run_test!(|a| array_simple(a));\n-    run_test!(|a| vec_simple(a));\n-    run_test!(|a| vec_unreachable(a));\n-\n-    run_test!(|a| struct_dynamic_drop(a, false, false, false));\n-    run_test!(|a| struct_dynamic_drop(a, false, false, true));\n-    run_test!(|a| struct_dynamic_drop(a, false, true, false));\n-    run_test!(|a| struct_dynamic_drop(a, false, true, true));\n-    run_test!(|a| struct_dynamic_drop(a, true, false, false));\n-    run_test!(|a| struct_dynamic_drop(a, true, false, true));\n-    run_test!(|a| struct_dynamic_drop(a, true, true, false));\n-    run_test!(|a| struct_dynamic_drop(a, true, true, true));\n-\n-    run_test!(|a| field_assignment(a, false));\n-    run_test!(|a| field_assignment(a, true));\n-\n-    run_test!(|a| generator(a, 0));\n-    run_test!(|a| generator(a, 1));\n-    run_test!(|a| generator(a, 2));\n-    run_test!(|a| generator(a, 3));\n-\n-    run_test!(|a| mixed_drop_and_nondrop(a));\n-\n-    run_test!(|a| slice_pattern_first(a));\n-    run_test!(|a| slice_pattern_middle(a));\n-    run_test!(|a| slice_pattern_two(a));\n-    run_test!(|a| slice_pattern_last(a));\n-    run_test!(|a| slice_pattern_one_of(a, 0));\n-    run_test!(|a| slice_pattern_one_of(a, 1));\n-    run_test!(|a| slice_pattern_one_of(a, 2));\n-    run_test!(|a| slice_pattern_one_of(a, 3));\n-\n-    run_test!(|a| subslice_pattern_from_end(a, true));\n-    run_test!(|a| subslice_pattern_from_end(a, false));\n-    run_test!(|a| subslice_pattern_from_end_with_drop(a, true, true));\n-    run_test!(|a| subslice_pattern_from_end_with_drop(a, true, false));\n-    run_test!(|a| subslice_pattern_from_end_with_drop(a, false, true));\n-    run_test!(|a| subslice_pattern_from_end_with_drop(a, false, false));\n-    run_test!(|a| slice_pattern_reassign(a));\n-    run_test!(|a| subslice_pattern_reassign(a));\n-\n-    run_test!(|a| index_field_mixed_ends(a));\n-    run_test!(|a| subslice_mixed_min_lengths(a, 0));\n-    run_test!(|a| subslice_mixed_min_lengths(a, 1));\n-    run_test!(|a| subslice_mixed_min_lengths(a, 2));\n-    run_test!(|a| subslice_mixed_min_lengths(a, 3));\n-    run_test!(|a| subslice_mixed_min_lengths(a, 4));\n-    run_test!(|a| subslice_mixed_min_lengths(a, 5));\n-    run_test!(|a| subslice_mixed_min_lengths(a, 6));\n-    run_test!(|a| subslice_mixed_min_lengths(a, 7));\n-\n-    run_test!(|a| move_ref_pattern(a));\n-\n-    run_test!(|a| {\n+    run_test(|a| dynamic_init(a, false));\n+    run_test(|a| dynamic_init(a, true));\n+    run_test(|a| dynamic_drop(a, false));\n+    run_test(|a| dynamic_drop(a, true));\n+\n+    run_test(|a| assignment2(a, false, false));\n+    run_test(|a| assignment2(a, false, true));\n+    run_test(|a| assignment2(a, true, false));\n+    run_test(|a| assignment2(a, true, true));\n+\n+    run_test(|a| assignment1(a, false));\n+    run_test(|a| assignment1(a, true));\n+\n+    run_test(|a| array_simple(a));\n+    run_test(|a| vec_simple(a));\n+    run_test(|a| vec_unreachable(a));\n+\n+    run_test(|a| struct_dynamic_drop(a, false, false, false));\n+    run_test(|a| struct_dynamic_drop(a, false, false, true));\n+    run_test(|a| struct_dynamic_drop(a, false, true, false));\n+    run_test(|a| struct_dynamic_drop(a, false, true, true));\n+    run_test(|a| struct_dynamic_drop(a, true, false, false));\n+    run_test(|a| struct_dynamic_drop(a, true, false, true));\n+    run_test(|a| struct_dynamic_drop(a, true, true, false));\n+    run_test(|a| struct_dynamic_drop(a, true, true, true));\n+\n+    run_test(|a| field_assignment(a, false));\n+    run_test(|a| field_assignment(a, true));\n+\n+    run_test(|a| generator(a, 0));\n+    run_test(|a| generator(a, 1));\n+    run_test(|a| generator(a, 2));\n+    run_test(|a| generator(a, 3));\n+\n+    run_test(|a| mixed_drop_and_nondrop(a));\n+\n+    run_test(|a| slice_pattern_first(a));\n+    run_test(|a| slice_pattern_middle(a));\n+    run_test(|a| slice_pattern_two(a));\n+    run_test(|a| slice_pattern_last(a));\n+    run_test(|a| slice_pattern_one_of(a, 0));\n+    run_test(|a| slice_pattern_one_of(a, 1));\n+    run_test(|a| slice_pattern_one_of(a, 2));\n+    run_test(|a| slice_pattern_one_of(a, 3));\n+\n+    run_test(|a| subslice_pattern_from_end(a, true));\n+    run_test(|a| subslice_pattern_from_end(a, false));\n+    run_test(|a| subslice_pattern_from_end_with_drop(a, true, true));\n+    run_test(|a| subslice_pattern_from_end_with_drop(a, true, false));\n+    run_test(|a| subslice_pattern_from_end_with_drop(a, false, true));\n+    run_test(|a| subslice_pattern_from_end_with_drop(a, false, false));\n+    run_test(|a| slice_pattern_reassign(a));\n+    run_test(|a| subslice_pattern_reassign(a));\n+\n+    run_test(|a| index_field_mixed_ends(a));\n+    run_test(|a| subslice_mixed_min_lengths(a, 0));\n+    run_test(|a| subslice_mixed_min_lengths(a, 1));\n+    run_test(|a| subslice_mixed_min_lengths(a, 2));\n+    run_test(|a| subslice_mixed_min_lengths(a, 3));\n+    run_test(|a| subslice_mixed_min_lengths(a, 4));\n+    run_test(|a| subslice_mixed_min_lengths(a, 5));\n+    run_test(|a| subslice_mixed_min_lengths(a, 6));\n+    run_test(|a| subslice_mixed_min_lengths(a, 7));\n+\n+    run_test(|a| move_ref_pattern(a));\n+\n+    run_test(|a| {\n         panic_after_return(a);\n     });\n-    run_test!(|a| {\n+    run_test(|a| {\n         panic_after_return_expr(a);\n     });\n-    run_test!(|a| panic_after_init(a));\n-    run_test!(|a| panic_after_init_temp(a));\n-    run_test!(|a| panic_after_init_by_loop(a));\n-    run_test!(|a| panic_after_init_by_match(a, false));\n-    run_test!(|a| panic_after_init_by_match(a, true));\n-    run_test!(|a| panic_after_init_by_match_with_guard(a, false));\n-    run_test!(|a| panic_after_init_by_match_with_guard(a, true));\n-    run_test!(|a| panic_after_init_by_match_with_bindings_and_guard(a, false));\n-    run_test!(|a| panic_after_init_by_match_with_bindings_and_guard(a, true));\n-    run_test!(|a| panic_after_init_by_match_with_ref_bindings_and_guard(a, false));\n-    run_test!(|a| panic_after_init_by_match_with_ref_bindings_and_guard(a, true));\n-    run_test!(|a| panic_after_init_by_break_if(a, false));\n-    run_test!(|a| panic_after_init_by_break_if(a, true));\n-\n-    run_test!(|a| bindings_after_at_dynamic_init_move(a, true));\n-    run_test!(|a| bindings_after_at_dynamic_init_move(a, false));\n-    run_test!(|a| bindings_after_at_dynamic_init_ref(a, true));\n-    run_test!(|a| bindings_after_at_dynamic_init_ref(a, false));\n-    run_test!(|a| bindings_after_at_dynamic_drop_move(a, true));\n-    run_test!(|a| bindings_after_at_dynamic_drop_move(a, false));\n-    run_test!(|a| bindings_after_at_dynamic_drop_ref(a, true));\n-    run_test!(|a| bindings_after_at_dynamic_drop_ref(a, false));\n-\n-    run_test_nopanic(|a| union1(a), \"|a| union1(a)\");\n+    run_test(|a| panic_after_init(a));\n+    run_test(|a| panic_after_init_temp(a));\n+    run_test(|a| panic_after_init_by_loop(a));\n+\n+    run_test(|a| bindings_after_at_dynamic_init_move(a, true));\n+    run_test(|a| bindings_after_at_dynamic_init_move(a, false));\n+    run_test(|a| bindings_after_at_dynamic_init_ref(a, true));\n+    run_test(|a| bindings_after_at_dynamic_init_ref(a, false));\n+    run_test(|a| bindings_after_at_dynamic_drop_move(a, true));\n+    run_test(|a| bindings_after_at_dynamic_drop_move(a, false));\n+    run_test(|a| bindings_after_at_dynamic_drop_ref(a, true));\n+    run_test(|a| bindings_after_at_dynamic_drop_ref(a, false));\n+\n+    run_test_nopanic(|a| union1(a));\n }"}, {"sha": "7e34a4f5c2737aee7459bcf642ea667920160308", "filename": "src/test/ui/mir/issue-80949.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fui%2Fmir%2Fissue-80949.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5605b5d693ac0aba5b506923e3e99ec927969d04/src%2Ftest%2Fui%2Fmir%2Fissue-80949.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fissue-80949.rs?ref=5605b5d693ac0aba5b506923e3e99ec927969d04", "patch": "@@ -0,0 +1,34 @@\n+// build-pass\n+\n+trait Trait { type Item; }\n+\n+impl<'a, X> Trait for &'a Vec<X> {\n+    type Item = &'a X;\n+}\n+\n+impl<X> Trait for Box<dyn Trait<Item = X>> {\n+    type Item = X;\n+}\n+\n+fn make_dyn_trait(_: &()) -> Box<dyn Trait<Item = &()>> {\n+    todo!()\n+}\n+\n+fn diff<'a, M, N, S>(_: N, _: S)\n+where\n+    M: 'a,\n+    N: Trait<Item = &'a M>,\n+    S: Trait<Item = &'a M>,\n+{\n+    todo!()\n+}\n+\n+fn may_panic<X>(_: X) { }\n+\n+fn main() {\n+    let dyn_trait = make_dyn_trait(&());\n+    let storage = vec![()];\n+    let _x = may_panic(());\n+    let storage_ref = &storage;\n+    diff(dyn_trait, storage_ref);\n+}"}]}