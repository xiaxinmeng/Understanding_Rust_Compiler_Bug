{"sha": "3046ac217fbc8c8962ee83025b47cdf4048c39f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwNDZhYzIxN2ZiYzhjODk2MmVlODMwMjViNDdjZGY0MDQ4YzM5ZjA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-01-09T02:41:37Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-01-16T10:22:32Z"}, "message": "Detect cycles and specialize error reporting for Sized. It is important\nto get the `Sized` error usable, since that hits new users\nfrequently. Further work is needed for the error reporting for non-Sized\ncycle cases; those currently just fallback to the old path. Also adjust tests.", "tree": {"sha": "85e3402da08722ddbb6231793988c34441744aa3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85e3402da08722ddbb6231793988c34441744aa3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3046ac217fbc8c8962ee83025b47cdf4048c39f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3046ac217fbc8c8962ee83025b47cdf4048c39f0", "html_url": "https://github.com/rust-lang/rust/commit/3046ac217fbc8c8962ee83025b47cdf4048c39f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3046ac217fbc8c8962ee83025b47cdf4048c39f0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bbe532737630eb2a5e07b73f01875c936e2ec57", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bbe532737630eb2a5e07b73f01875c936e2ec57", "html_url": "https://github.com/rust-lang/rust/commit/4bbe532737630eb2a5e07b73f01875c936e2ec57"}], "stats": {"total": 383, "additions": 291, "deletions": 92}, "files": [{"sha": "2a2936e73631638e4158378ffaeecdc689449324", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -712,6 +712,43 @@ There's no easy fix for this, generally code will need to be refactored so that\n you no longer need to derive from `Super<Self>`.\n \"####,\n \n+E0072: r##\"\n+When defining a recursive struct or enum, any use of the type being defined\n+from inside the definition must occur behind a pointer (like `Box` or `&`).\n+This is because structs and enums must have a well-defined size, and without\n+the pointer the size of the type would need to be unbounded.\n+\n+Consider the following erroneous definition of a type for a list of bytes:\n+\n+```\n+// error, invalid recursive struct type\n+struct ListNode {\n+    head: u8,\n+    tail: Option<ListNode>,\n+}\n+```\n+\n+This type cannot have a well-defined size, because it needs to be arbitrarily\n+large (since we would be able to nest `ListNode`s to any depth). Specifically,\n+\n+```plain\n+size of `ListNode` = 1 byte for `head`\n+                   + 1 byte for the discriminant of the `Option`\n+                   + size of `ListNode`\n+```\n+\n+One way to fix this is by wrapping `ListNode` in a `Box`, like so:\n+\n+```\n+struct ListNode {\n+    head: u8,\n+    tail: Option<Box<ListNode>>,\n+}\n+```\n+\n+This works because `Box` is a pointer, so its size is well-known.\n+\"##,\n+\n E0109: r##\"\n You tried to give a type parameter to a type which doesn't need it. Erroneous\n code example:"}, {"sha": "ef97c4c8a12a901a4650473c23bdd57280d4e7a8", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 140, "deletions": 2, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -182,7 +182,8 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n /// if the program type checks or not -- and they are unusual\n /// occurrences in any case.\n pub fn report_overflow_error<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n-                                          obligation: &Obligation<'tcx, T>)\n+                                          obligation: &Obligation<'tcx, T>,\n+                                          suggest_increasing_limit: bool)\n                                           -> !\n     where T: fmt::Display + TypeFoldable<'tcx>\n {\n@@ -192,7 +193,9 @@ pub fn report_overflow_error<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                                    \"overflow evaluating the requirement `{}`\",\n                                    predicate);\n \n-    suggest_new_overflow_limit(infcx.tcx, &mut err, obligation.cause.span);\n+    if suggest_increasing_limit {\n+        suggest_new_overflow_limit(infcx.tcx, &mut err, obligation.cause.span);\n+    }\n \n     note_obligation_cause(infcx, &mut err, obligation);\n \n@@ -201,6 +204,141 @@ pub fn report_overflow_error<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n     unreachable!();\n }\n \n+/// Reports that a cycle was detected which led to overflow and halts\n+/// compilation. This is equivalent to `report_overflow_error` except\n+/// that we can give a more helpful error message (and, in particular,\n+/// we do not suggest increasing the overflow limit, which is not\n+/// going to help).\n+pub fn report_overflow_error_cycle<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                             cycle: &Vec<PredicateObligation<'tcx>>)\n+                                             -> !\n+{\n+    assert!(cycle.len() > 1);\n+\n+    debug!(\"report_overflow_error_cycle(cycle length = {})\", cycle.len());\n+\n+    let cycle = infcx.resolve_type_vars_if_possible(cycle);\n+\n+    debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n+\n+    assert_eq!(&cycle[0].predicate, &cycle.last().unwrap().predicate);\n+\n+    try_report_overflow_error_type_of_infinite_size(infcx, &cycle);\n+    report_overflow_error(infcx, &cycle[0], false);\n+}\n+\n+/// If a cycle results from evaluated whether something is Sized, that\n+/// is a particular special case that always results from a struct or\n+/// enum definition that lacks indirection (e.g., `struct Foo { x: Foo\n+/// }`). We wish to report a targeted error for this case.\n+pub fn try_report_overflow_error_type_of_infinite_size<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    cycle: &[PredicateObligation<'tcx>])\n+{\n+    let sized_trait = match infcx.tcx.lang_items.sized_trait() {\n+        Some(v) => v,\n+        None => return,\n+    };\n+    let top_is_sized = {\n+        match cycle[0].predicate {\n+            ty::Predicate::Trait(ref data) => data.def_id() == sized_trait,\n+            _ => false,\n+        }\n+    };\n+    if !top_is_sized {\n+        return;\n+    }\n+\n+    // The only way to have a type of infinite size is to have,\n+    // somewhere, a struct/enum type involved. Identify all such types\n+    // and report the cycle to the user.\n+\n+    let struct_enum_tys: Vec<_> =\n+        cycle.iter()\n+             .flat_map(|obligation| match obligation.predicate {\n+                 ty::Predicate::Trait(ref data) => {\n+                     assert_eq!(data.def_id(), sized_trait);\n+                     let self_ty = data.skip_binder().trait_ref.self_ty(); // (*)\n+                     // (*) ok to skip binder because this is just\n+                     // error reporting and regions don't really\n+                     // matter\n+                     match self_ty.sty {\n+                         ty::TyEnum(..) | ty::TyStruct(..) => Some(self_ty),\n+                         _ => None,\n+                     }\n+                 }\n+                 _ => {\n+                     infcx.tcx.sess.span_bug(obligation.cause.span,\n+                                             &format!(\"Sized cycle involving non-trait-ref: {:?}\",\n+                                                      obligation.predicate));\n+                 }\n+             })\n+             .collect();\n+\n+    assert!(!struct_enum_tys.is_empty());\n+\n+    // This is a bit tricky. We want to pick a \"main type\" in the\n+    // listing that is local to the current crate, so we can give a\n+    // good span to the user. But it might not be the first one in our\n+    // cycle list. So find the first one that is local and then\n+    // rotate.\n+    let (main_index, main_def_id) =\n+        struct_enum_tys.iter()\n+                       .enumerate()\n+                       .filter_map(|(index, ty)| match ty.sty {\n+                           ty::TyEnum(adt_def, _) | ty::TyStruct(adt_def, _) if adt_def.did.is_local() =>\n+                               Some((index, adt_def.did)),\n+                           _ =>\n+                               None,\n+                       })\n+                       .next()\n+                       .unwrap(); // should always be SOME local type involved!\n+\n+    // Rotate so that the \"main\" type is at index 0.\n+    let struct_enum_tys: Vec<_> =\n+        struct_enum_tys.iter()\n+                       .cloned()\n+                       .skip(main_index)\n+                       .chain(struct_enum_tys.iter().cloned().take(main_index))\n+                       .collect();\n+\n+    let tcx = infcx.tcx;\n+    let mut err = recursive_type_with_infinite_size_error(tcx, main_def_id);\n+    let len = struct_enum_tys.len();\n+    if len > 2 {\n+        let span = tcx.map.span_if_local(main_def_id).unwrap();\n+        err.fileline_note(span,\n+                          &format!(\"type `{}` is embedded within `{}`...\",\n+                                   struct_enum_tys[0],\n+                                   struct_enum_tys[1]));\n+        for &next_ty in &struct_enum_tys[1..len-1] {\n+            err.fileline_note(span,\n+                              &format!(\"...which in turn is embedded within `{}`...\", next_ty));\n+        }\n+        err.fileline_note(span,\n+                          &format!(\"...which in turn is embedded within `{}`, \\\n+                                    completing the cycle.\",\n+                                   struct_enum_tys[len-1]));\n+    }\n+    err.emit();\n+    infcx.tcx.sess.abort_if_errors();\n+    unreachable!();\n+}\n+\n+pub fn recursive_type_with_infinite_size_error<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                                     type_def_id: DefId)\n+                                                     -> DiagnosticBuilder<'tcx>\n+{\n+    assert!(type_def_id.is_local());\n+    let span = tcx.map.span_if_local(type_def_id).unwrap();\n+    let mut err = struct_span_err!(tcx.sess, span, E0072, \"recursive type `{}` has infinite size\",\n+                                   tcx.item_path_str(type_def_id));\n+    err.fileline_help(span, &format!(\"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n+                                      at some point to make `{}` representable\",\n+                                     tcx.item_path_str(type_def_id)));\n+    err\n+}\n+\n pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                         obligation: &PredicateObligation<'tcx>,\n                                         error: &SelectionError<'tcx>)"}, {"sha": "2fdf93e6e35dea903d0da0d50639d1d22f551382", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -11,10 +11,10 @@\n use middle::infer::InferCtxt;\n use middle::ty::{self, Ty, TypeFoldable};\n use rustc_data_structures::obligation_forest::{Backtrace, ObligationForest, Error};\n-\n+use std::iter;\n use syntax::ast;\n use util::common::ErrorReported;\n-use util::nodemap::{FnvHashSet, NodeMap};\n+use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n \n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n@@ -25,6 +25,7 @@ use super::FulfillmentErrorCode;\n use super::ObligationCause;\n use super::PredicateObligation;\n use super::project;\n+use super::report_overflow_error_cycle;\n use super::select::SelectionContext;\n use super::Unimplemented;\n use super::util::predicate_for_builtin_bound;\n@@ -357,6 +358,17 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n     }\n \n     let obligation = &pending_obligation.obligation;\n+\n+    // If we exceed the recursion limit, take a moment to look for a\n+    // cycle so we can give a better error report from here, where we\n+    // have more context.\n+    let recursion_limit = selcx.tcx().sess.recursion_limit.get();\n+    if obligation.recursion_depth >= recursion_limit {\n+        if let Some(cycle) = scan_for_cycle(obligation, &backtrace) {\n+            report_overflow_error_cycle(selcx.infcx(), &cycle);\n+        }\n+    }\n+\n     match obligation.predicate {\n         ty::Predicate::Trait(ref data) => {\n             if coinductive_match(selcx, obligation, data, &backtrace) {\n@@ -488,11 +500,15 @@ fn coinductive_match<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                               -> bool\n {\n     if selcx.tcx().trait_has_default_impl(top_data.def_id()) {\n+        debug!(\"coinductive_match: top_data={:?}\", top_data);\n         for bt_obligation in backtrace.clone() {\n+            debug!(\"coinductive_match: bt_obligation={:?}\", bt_obligation);\n+\n             // *Everything* in the backtrace must be a defaulted trait.\n             match bt_obligation.obligation.predicate {\n                 ty::Predicate::Trait(ref data) => {\n                     if !selcx.tcx().trait_has_default_impl(data.def_id()) {\n+                        debug!(\"coinductive_match: trait does not have default impl\");\n                         break;\n                     }\n                 }\n@@ -501,7 +517,7 @@ fn coinductive_match<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n \n             // And we must find a recursive match.\n             if bt_obligation.obligation.predicate == top_obligation.predicate {\n-                debug!(\"process_predicate: found a match in the backtrace\");\n+                debug!(\"coinductive_match: found a match in the backtrace\");\n                 return true;\n             }\n         }\n@@ -510,6 +526,27 @@ fn coinductive_match<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n     false\n }\n \n+fn scan_for_cycle<'a,'tcx>(top_obligation: &PredicateObligation<'tcx>,\n+                           backtrace: &Backtrace<PendingPredicateObligation<'tcx>>)\n+                           -> Option<Vec<PredicateObligation<'tcx>>>\n+{\n+    let mut map = FnvHashMap();\n+    let all_obligations =\n+        || iter::once(top_obligation)\n+               .chain(backtrace.clone()\n+                               .map(|p| &p.obligation));\n+    for (index, bt_obligation) in all_obligations().enumerate() {\n+        if let Some(&start) = map.get(&bt_obligation.predicate) {\n+            // Found a cycle starting at position `start` and running\n+            // until the current position (`index`).\n+            return Some(all_obligations().skip(start).take(index - start + 1).cloned().collect());\n+        } else {\n+            map.insert(bt_obligation.predicate.clone(), index);\n+        }\n+    }\n+    None\n+}\n+\n fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n                                     r_b: ty::Region,\n                                     cause: ObligationCause<'tcx>,"}, {"sha": "8fecffcea9fe446269f7b927bea4bbb32c41070e", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -28,8 +28,10 @@ use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n \n pub use self::error_reporting::TraitErrorKey;\n+pub use self::error_reporting::recursive_type_with_infinite_size_error;\n pub use self::error_reporting::report_fulfillment_errors;\n pub use self::error_reporting::report_overflow_error;\n+pub use self::error_reporting::report_overflow_error_cycle;\n pub use self::error_reporting::report_selection_error;\n pub use self::error_reporting::report_object_safety_error;\n pub use self::coherence::orphan_check;"}, {"sha": "c363425db85b09e68dcad9ab8d8a76c40dde9758", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -479,7 +479,7 @@ fn project_type<'cx,'tcx>(\n     let recursion_limit = selcx.tcx().sess.recursion_limit.get();\n     if obligation.recursion_depth >= recursion_limit {\n         debug!(\"project: overflow!\");\n-        report_overflow_error(selcx.infcx(), &obligation);\n+        report_overflow_error(selcx.infcx(), &obligation, true);\n     }\n \n     let obligation_trait_ref ="}, {"sha": "75992b6849b017193adc53aacfe73e92c4b684fa", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -711,7 +711,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // not update) the cache.\n         let recursion_limit = self.infcx.tcx.sess.recursion_limit.get();\n         if stack.obligation.recursion_depth >= recursion_limit {\n-            report_overflow_error(self.infcx(), &stack.obligation);\n+            report_overflow_error(self.infcx(), &stack.obligation, true);\n         }\n \n         // Check the cache. Note that we skolemize the trait-ref\n@@ -2124,6 +2124,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                            nested: ty::Binder<Vec<Ty<'tcx>>>)\n                            -> VtableBuiltinData<PredicateObligation<'tcx>>\n     {\n+        debug!(\"vtable_builtin_data(obligation={:?}, bound={:?}, nested={:?})\",\n+               obligation, bound, nested);\n+\n         let trait_def = match self.tcx().lang_items.from_builtin_kind(bound) {\n             Ok(def_id) => def_id,\n             Err(_) => {"}, {"sha": "eafa1e4304d41207881d631565474202615a067c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -4132,7 +4132,7 @@ fn check_const_with_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n pub fn check_representable(tcx: &ty::ctxt,\n                            sp: Span,\n                            item_id: ast::NodeId,\n-                           designation: &str) -> bool {\n+                           _designation: &str) -> bool {\n     let rty = tcx.node_id_to_type(item_id);\n \n     // Check that it is possible to represent this type. This call identifies\n@@ -4142,9 +4142,7 @@ pub fn check_representable(tcx: &ty::ctxt,\n     // caught by case 1.\n     match rty.is_representable(tcx, sp) {\n         Representability::SelfRecursive => {\n-            struct_span_err!(tcx.sess, sp, E0072, \"invalid recursive {} type\", designation)\n-                .fileline_help(sp, \"wrap the inner value in a box to make it representable\")\n-                .emit();\n+            traits::recursive_type_with_infinite_size_error(tcx, tcx.map.local_def_id(item_id)).emit();\n             return false\n         }\n         Representability::Representable | Representability::ContainsRecursive => (),"}, {"sha": "55a1021f0fb9418ca3357292b586d25ec4b27881", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -869,43 +869,6 @@ fn main() {\n ```\n \"##,\n \n-E0072: r##\"\n-When defining a recursive struct or enum, any use of the type being defined\n-from inside the definition must occur behind a pointer (like `Box` or `&`).\n-This is because structs and enums must have a well-defined size, and without\n-the pointer the size of the type would need to be unbounded.\n-\n-Consider the following erroneous definition of a type for a list of bytes:\n-\n-```\n-// error, invalid recursive struct type\n-struct ListNode {\n-    head: u8,\n-    tail: Option<ListNode>,\n-}\n-```\n-\n-This type cannot have a well-defined size, because it needs to be arbitrarily\n-large (since we would be able to nest `ListNode`s to any depth). Specifically,\n-\n-```plain\n-size of `ListNode` = 1 byte for `head`\n-                   + 1 byte for the discriminant of the `Option`\n-                   + size of `ListNode`\n-```\n-\n-One way to fix this is by wrapping `ListNode` in a `Box`, like so:\n-\n-```\n-struct ListNode {\n-    head: u8,\n-    tail: Option<Box<ListNode>>,\n-}\n-```\n-\n-This works because `Box` is a pointer, so its size is well-known.\n-\"##,\n-\n E0073: r##\"\n You cannot define a struct (or enum) `Foo` that requires an instance of `Foo`\n in order to make a new `Foo` value. This is because there would be no way a"}, {"sha": "bfe9d7403399d10cf1dbc705c3de3c5d8ceba898", "filename": "src/test/compile-fail/bad-sized.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -13,5 +13,6 @@ trait Trait {}\n pub fn main() {\n     let x: Vec<Trait + Sized> = Vec::new();\n     //~^ ERROR the trait `core::marker::Sized` is not implemented\n-    //~^^ ERROR the trait `core::marker::Sized` is not implemented\n+    //~| ERROR the trait `core::marker::Sized` is not implemented\n+    //~| ERROR the trait `core::marker::Sized` is not implemented\n }"}, {"sha": "c9a7f731aea08a0f2f6ce427977d2751d9f18ab3", "filename": "src/test/compile-fail/infinite-tag-type-recursion.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Finfinite-tag-type-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Finfinite-tag-type-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-tag-type-recursion.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-// error-pattern: invalid recursive enum type\n-\n enum mlist { cons(isize, mlist), nil, }\n+//~^ ERROR recursive type `mlist` has infinite size\n \n fn main() { let a = mlist::cons(10, mlist::cons(11, mlist::nil)); }"}, {"sha": "260cc366fae08a1cca39a36b4654568e904479c8", "filename": "src/test/compile-fail/issue-17431-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-17431-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-17431-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-1.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct Foo { foo: Option<Option<Foo>> }\n-//~^ ERROR invalid recursive struct type\n+//~^ ERROR recursive type `Foo` has infinite size\n \n impl Foo { fn bar(&self) {} }\n "}, {"sha": "edbc8c82432e0331b38cdae55603dfbddeff877b", "filename": "src/test/compile-fail/issue-17431-2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-17431-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-17431-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-2.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -9,10 +9,9 @@\n // except according to those terms.\n \n struct Baz { q: Option<Foo> }\n-//~^ ERROR invalid recursive struct type\n \n struct Foo { q: Option<Baz> }\n-//~^ ERROR invalid recursive struct type\n+//~^ ERROR recursive type `Foo` has infinite size\n \n impl Foo { fn bar(&self) {} }\n "}, {"sha": "9ba085591f08bb3f8dd877d1f02e6294e19800d5", "filename": "src/test/compile-fail/issue-17431-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-17431-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-17431-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-3.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -11,7 +11,7 @@\n use std::sync::Mutex;\n \n struct Foo { foo: Mutex<Option<Foo>> }\n-//~^ ERROR invalid recursive struct type\n+//~^ ERROR recursive type `Foo` has infinite size\n \n impl Foo { fn bar(&self) {} }\n "}, {"sha": "665c3cf8fe6391cbe2d92f789b1c305bcf7193ae", "filename": "src/test/compile-fail/issue-17431-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-17431-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-17431-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-4.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -11,7 +11,7 @@\n use std::marker;\n \n struct Foo<T> { foo: Option<Option<Foo<T>>>, marker: marker::PhantomData<T> }\n-//~^ ERROR invalid recursive struct type\n+//~^ ERROR recursive type `Foo` has infinite size\n \n impl<T> Foo<T> { fn bar(&self) {} }\n "}, {"sha": "85ed4d5d634dbf09bbe419c7f534d8f7800b0952", "filename": "src/test/compile-fail/issue-17431-5.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-17431-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-17431-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-5.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -11,8 +11,9 @@\n use std::marker;\n \n struct Foo { foo: Bar<Foo> }\n+\n struct Bar<T> { x: Bar<Foo> , marker: marker::PhantomData<T> }\n-//~^ ERROR invalid recursive struct type\n+//~^ ERROR recursive type `Bar` has infinite size\n \n impl Foo { fn foo(&self) {} }\n "}, {"sha": "4c1e82c3d6ae48b533e25100ef24e681fd66f3bd", "filename": "src/test/compile-fail/issue-17431-6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-17431-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-17431-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-6.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -11,7 +11,7 @@\n use std::sync::Mutex;\n \n enum Foo { X(Mutex<Option<Foo>>) }\n-//~^ ERROR invalid recursive enum type\n+//~^ ERROR recursive type `Foo` has infinite size\n \n impl Foo { fn bar(self) {} }\n "}, {"sha": "71b85da29fc717cd4f588f73a462624763a69515", "filename": "src/test/compile-fail/issue-17431-7.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-17431-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-17431-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-7.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n enum Foo { Voo(Option<Option<Foo>>) }\n-//~^ ERROR invalid recursive enum type\n+//~^ ERROR recursive type `Foo` has infinite size\n \n impl Foo { fn bar(&self) {} }\n "}, {"sha": "09044b5b5055ddad3fb8a855d52719033e399842", "filename": "src/test/compile-fail/issue-20261.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-20261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-20261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20261.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    for (ref i,) in [].iter() { //~ ERROR: type mismatch resolving\n+    for (ref i,) in [].iter() { //~ ERROR mismatched types\n         i.clone();\n         //~^ ERROR: the type of this value must be known in this context\n     }"}, {"sha": "48ea344c7c24caa3a45f11fcdc6447ed5c9fcb91", "filename": "src/test/compile-fail/issue-20831-debruijn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-20831-debruijn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-20831-debruijn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20831-debruijn.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -40,6 +40,7 @@ impl<'a> Publisher<'a> for MyStruct<'a> {\n         //~^^ ERROR cannot infer\n         //~|  ERROR cannot infer\n         //~|  ERROR cannot infer\n+        //~|  ERROR cannot infer\n         //\n         // The fact that `Publisher` is using an implicit lifetime is\n         // what was causing the debruijn accounting to be off, so"}, {"sha": "28080ae09e51bb87d82a608986c753e81a78fd24", "filename": "src/test/compile-fail/issue-26548.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: overflow representing the type `S`\n-\n-trait Mirror { type It; }\n-impl<T> Mirror for T { type It = Self; }\n+trait Mirror { type It: ?Sized; }\n+impl<T: ?Sized> Mirror for T { type It = Self; }\n struct S(Option<<S as Mirror>::It>);\n+//~^ ERROR recursive type `S` has infinite size\n \n fn main() {\n     let _s = S(None);"}, {"sha": "6de28cbbf357ca3c109f04e0d80be7dc658b01c4", "filename": "src/test/compile-fail/issue-2718-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-2718-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-2718-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2718-a.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -16,7 +16,7 @@ mod pingpong {\n     use send_packet;\n     pub type ping = send_packet<pong>;\n     pub struct pong(send_packet<ping>);\n-    //~^ ERROR invalid recursive struct type\n+    //~^ ERROR recursive type `pingpong::pong` has infinite size\n }\n \n fn main() {}"}, {"sha": "d3c15763eb00e57ca85b1877706bfca6f95f1af3", "filename": "src/test/compile-fail/issue-3008-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-3008-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-3008-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3008-1.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -10,7 +10,7 @@\n \n enum foo { foo_(bar) }\n enum bar { bar_none, bar_some(bar) }\n-//~^ ERROR invalid recursive enum type\n+//~^ ERROR recursive type `bar` has infinite size\n \n fn main() {\n }"}, {"sha": "e6cc29634a1e8ebaf696f54192e82775336323a2", "filename": "src/test/compile-fail/issue-3008-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -12,7 +12,7 @@\n \n enum foo { foo_(bar) }\n struct bar { x: bar }\n-//~^ ERROR invalid recursive struct type\n+//~^ ERROR E0072\n \n fn main() {\n }"}, {"sha": "66bfab003e9cf2640c10ec0b99c0c63870d3b963", "filename": "src/test/compile-fail/issue-3008-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-3008-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-3008-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3008-3.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -12,7 +12,7 @@ use std::marker;\n \n enum E1 { V1(E2<E1>), }\n enum E2<T> { V2(E2<E1>, marker::PhantomData<T>), }\n-//~^ ERROR invalid recursive enum type\n+//~^ ERROR recursive type `E2` has infinite size\n \n impl E1 { fn foo(&self) {} }\n "}, {"sha": "d96b1a1cbe35b1cd4f08bf56fa391ea88b25f733", "filename": "src/test/compile-fail/issue-3779.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-3779.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-3779.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3779.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct S {\n-    //~^ ERROR invalid recursive struct type\n+struct S { //~ ERROR E0072\n     element: Option<S>\n }\n "}, {"sha": "87b7b73d57dbd41b18b560199588bb21b0339b64", "filename": "src/test/compile-fail/issue-7364.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -17,6 +17,5 @@ use std::cell::RefCell;\n static boxed: Box<RefCell<isize>> = box RefCell::new(0);\n //~^ ERROR allocations are not allowed in statics\n //~| ERROR the trait `core::marker::Sync` is not implemented for the type\n-//~| ERROR the trait `core::marker::Sync` is not implemented for the type\n \n fn main() { }"}, {"sha": "aec40c1a73a806f488acac21c3077c4da8d7c803", "filename": "src/test/compile-fail/kindck-impl-type-params.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -27,14 +27,12 @@ fn f<T>(val: T) {\n     let t: S<T> = S(marker::PhantomData);\n     let a = &t as &Gettable<T>;\n     //~^ ERROR the trait `core::marker::Send` is not implemented\n-    //~^^ ERROR the trait `core::marker::Copy` is not implemented\n }\n \n fn g<T>(val: T) {\n     let t: S<T> = S(marker::PhantomData);\n     let a: &Gettable<T> = &t;\n     //~^ ERROR the trait `core::marker::Send` is not implemented\n-    //~^^ ERROR the trait `core::marker::Copy` is not implemented\n }\n \n fn foo<'a>() {"}, {"sha": "731c1edbfc00b7fdf0f70f0b9c1f1cc26b9bbe57", "filename": "src/test/compile-fail/lint-ctypes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -13,8 +13,8 @@\n \n extern crate libc;\n \n-trait Mirror { type It; }\n-impl<T> Mirror for T { type It = Self; }\n+trait Mirror { type It: ?Sized; }\n+impl<T: ?Sized> Mirror for T { type It = Self; }\n #[repr(C)]\n pub struct StructWithProjection(*mut <StructWithProjection as Mirror>::It);\n #[repr(C)]"}, {"sha": "db19132b2c454738a19133d13e563fed724d4ba8", "filename": "src/test/compile-fail/mut-not-freeze.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -16,5 +16,4 @@ fn main() {\n     let x = RefCell::new(0);\n     f(x);\n     //~^ ERROR `core::marker::Sync` is not implemented\n-    //~^^ ERROR `core::marker::Sync` is not implemented\n }"}, {"sha": "922d70b8013dc73f1ae93ef69365ca54e8e81307", "filename": "src/test/compile-fail/not-panic-safe-2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-2.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -18,7 +18,6 @@ use std::cell::RefCell;\n fn assert<T: RecoverSafe + ?Sized>() {}\n \n fn main() {\n-    assert::<Rc<RefCell<i32>>>(); //~ ERROR: is not implemented\n-    //~^ ERROR: is not implemented\n+    assert::<Rc<RefCell<i32>>>(); //~ ERROR E0277\n }\n "}, {"sha": "50a69543f7d04fbfaa77a0d4cea3ef2d46f6457e", "filename": "src/test/compile-fail/not-panic-safe-3.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-3.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -19,5 +19,4 @@ fn assert<T: RecoverSafe + ?Sized>() {}\n \n fn main() {\n     assert::<Arc<RefCell<i32>>>(); //~ ERROR: is not implemented\n-    //~^ ERROR: is not implemented\n }"}, {"sha": "c50e4b9d87e063cd295e971d841d66b5be2914da", "filename": "src/test/compile-fail/not-panic-safe-4.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-4.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -17,6 +17,5 @@ use std::cell::RefCell;\n fn assert<T: RecoverSafe + ?Sized>() {}\n \n fn main() {\n-    assert::<&RefCell<i32>>(); //~ ERROR: is not implemented\n-    //~^ ERROR is not implemented\n+    assert::<&RefCell<i32>>(); //~ ERROR E0277\n }"}, {"sha": "0fc912dc95fab8eeeb43b991b875643610404c65", "filename": "src/test/compile-fail/not-panic-safe-6.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-6.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -17,7 +17,6 @@ use std::cell::RefCell;\n fn assert<T: RecoverSafe + ?Sized>() {}\n \n fn main() {\n-    assert::<*mut RefCell<i32>>(); //~ ERROR: is not implemented\n-    //~^ ERROR is not implemented\n+    assert::<*mut RefCell<i32>>(); //~ ERROR E0277\n }\n "}, {"sha": "8e3161ef884be5b83410291364cc2678c9b8ddf0", "filename": "src/test/compile-fail/object-safety-generics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -28,6 +28,7 @@ fn make_bar<T:Bar>(t: &T) -> &Bar {\n }\n \n fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n+    //~^ ERROR E0038\n     t as &Bar\n }\n "}, {"sha": "b839902c6832ab16eeeaa9c77ef57513348d8966", "filename": "src/test/compile-fail/range-1.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-1.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -17,12 +17,11 @@ pub fn main() {\n \n     // Bool => does not implement iterator.\n     for i in false..true {}\n-    //~^ ERROR the trait\n-    //~^^ ERROR the trait\n-    //~^^^ ERROR the trait\n+    //~^ ERROR E0277\n \n     // Unsized type.\n     let arr: &[_] = &[1, 2, 3];\n     let range = *arr..;\n     //~^ ERROR the trait `core::marker::Sized` is not implemented\n+    //~| ERROR the trait `core::marker::Sized` is not implemented\n }"}, {"sha": "555755cdb96eadfbb7dd664a0cbfeba20865e7af", "filename": "src/test/compile-fail/recursive-enum.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Frecursive-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Frecursive-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursive-enum.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: invalid recursive enum type\n-\n enum list<T> { cons(T, list<T>), nil }\n+//~^ ERROR recursive type `list` has infinite size\n \n fn main() {}"}, {"sha": "bb1ab2eafb355efc4d0871172a0e544b41a471ae", "filename": "src/test/compile-fail/sized-cycle-note.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fsized-cycle-note.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Fsized-cycle-note.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsized-cycle-note.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test the error message resulting from a cycle in solving `Foo:\n+// Sized`. The specifics of the message will of course but the main\n+// thing we want to preserve is that:\n+//\n+// 1. the message should appear attached to one of the structs\n+//    defined in this file;\n+// 2. it should elaborate the steps that led to the cycle.\n+\n+struct Baz { q: Option<Foo> }\n+\n+struct Foo { q: Option<Baz> }\n+//~^ ERROR recursive type `Foo` has infinite size\n+//~| type `Foo` is embedded within `core::option::Option<Foo>`...\n+//~| ...which in turn is embedded within `core::option::Option<Foo>`...\n+//~| ...which in turn is embedded within `Baz`...\n+//~| ...which in turn is embedded within `core::option::Option<Baz>`...\n+//~| ...which in turn is embedded within `Foo`, completing the cycle.\n+\n+impl Foo { fn bar(&self) {} }\n+\n+fn main() {}"}, {"sha": "520691fbecc481b34985c4bb65c40cd6074609a1", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums-locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-locals.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -22,6 +22,6 @@ fn main() {\n         x: 3\n     };\n \n-    let baz: Foo<usize> = panic!();\n+    let baz: Foo<usize> = loop { };\n     //~^ ERROR not implemented\n }"}, {"sha": "0cfcf6bb3f907084617231fcb3b29e923453eee5", "filename": "src/test/compile-fail/trait-test-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -21,5 +21,7 @@ fn main() {\n     (box 10 as Box<bar>).dup();\n     //~^ ERROR E0038\n     //~| ERROR E0038\n+    //~| ERROR E0038\n+    //~| ERROR E0038\n     //~| ERROR E0277\n }"}, {"sha": "4bb739800df368821aacde032015d05231cc3ea8", "filename": "src/test/compile-fail/type-recursive.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3046ac217fbc8c8962ee83025b47cdf4048c39f0/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs?ref=3046ac217fbc8c8962ee83025b47cdf4048c39f0", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:invalid recursive struct type\n-struct t1 {\n+struct t1 { //~ ERROR E0072\n     foo: isize,\n     foolish: t1\n }"}]}