{"sha": "8038489357b5262645760a24673597486d71c1df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwMzg0ODkzNTdiNTI2MjY0NTc2MGEyNDY3MzU5NzQ4NmQ3MWMxZGY=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-01-01T22:50:15Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-01-04T18:35:33Z"}, "message": "Use LvalueRef instead of MaybeSizedValue", "tree": {"sha": "66409e03700f6cf66b0558a702158eebafb13958", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66409e03700f6cf66b0558a702158eebafb13958"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8038489357b5262645760a24673597486d71c1df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8038489357b5262645760a24673597486d71c1df", "html_url": "https://github.com/rust-lang/rust/commit/8038489357b5262645760a24673597486d71c1df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8038489357b5262645760a24673597486d71c1df/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c9995a3f9e7c9aa23fe3c1513904746c571b90b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c9995a3f9e7c9aa23fe3c1513904746c571b90b", "html_url": "https://github.com/rust-lang/rust/commit/4c9995a3f9e7c9aa23fe3c1513904746c571b90b"}], "stats": {"total": 242, "additions": 119, "deletions": 123}, "files": [{"sha": "14882dd433ba7987b885613049595b6321c203b3", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 12, "deletions": 37, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8038489357b5262645760a24673597486d71c1df/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8038489357b5262645760a24673597486d71c1df/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=8038489357b5262645760a24673597486d71c1df", "patch": "@@ -48,6 +48,7 @@ use std;\n use llvm::{ValueRef, True, IntEQ, IntNE};\n use rustc::ty::layout;\n use rustc::ty::{self, Ty, AdtKind};\n+use mir::lvalue::LvalueRef;\n use common::*;\n use builder::Builder;\n use glue;\n@@ -64,32 +65,6 @@ pub enum BranchKind {\n     Single\n }\n \n-#[derive(Copy, Clone)]\n-pub struct MaybeSizedValue {\n-    pub value: ValueRef,\n-    pub meta: ValueRef,\n-}\n-\n-impl MaybeSizedValue {\n-    pub fn sized(value: ValueRef) -> MaybeSizedValue {\n-        MaybeSizedValue {\n-            value: value,\n-            meta: std::ptr::null_mut()\n-        }\n-    }\n-\n-    pub fn unsized_(value: ValueRef, meta: ValueRef) -> MaybeSizedValue {\n-        MaybeSizedValue {\n-            value: value,\n-            meta: meta\n-        }\n-    }\n-\n-    pub fn has_meta(&self) -> bool {\n-        !self.meta.is_null()\n-    }\n-}\n-\n /// Given an enum, struct, closure, or tuple, extracts fields.\n /// Treats closures as a struct with one variant.\n /// `empty_if_no_variants` is a switch to deal with empty enums.\n@@ -500,11 +475,11 @@ fn assert_discr_in_range(min: Disr, max: Disr, discr: Disr) {\n /// Access a field, at a point when the value's case is known.\n pub fn trans_field_ptr<'a, 'tcx>(\n     bcx: &Builder<'a, 'tcx>,\n-    t: Ty<'tcx>,\n-    val: MaybeSizedValue,\n+    val: LvalueRef<'tcx>,\n     discr: Disr,\n     ix: usize\n ) -> ValueRef {\n+    let t = val.ty.to_ty(bcx.tcx());\n     let l = bcx.ccx.layout_of(t);\n     debug!(\"trans_field_ptr on {} represented as {:#?}\", t, l);\n     // Note: if this ever needs to generate conditionals (e.g., if we\n@@ -520,7 +495,7 @@ pub fn trans_field_ptr<'a, 'tcx>(\n         layout::Vector { count, .. } => {\n             assert_eq!(discr.0, 0);\n             assert!((ix as u64) < count);\n-            bcx.struct_gep(val.value, ix)\n+            bcx.struct_gep(val.llval, ix)\n         }\n         layout::General { discr: d, ref variants, .. } => {\n             let mut fields = compute_fields(bcx.ccx, t, discr.0 as usize, false);\n@@ -532,7 +507,7 @@ pub fn trans_field_ptr<'a, 'tcx>(\n         layout::UntaggedUnion { .. } => {\n             let fields = compute_fields(bcx.ccx, t, 0, false);\n             let ty = type_of::in_memory_type_of(bcx.ccx, fields[ix]);\n-            bcx.pointercast(val.value, ty.ptr_to())\n+            bcx.pointercast(val.llval, ty.ptr_to())\n         }\n         layout::RawNullablePointer { nndiscr, .. } |\n         layout::StructWrappedNullablePointer { nndiscr,  .. } if discr.0 != nndiscr => {\n@@ -541,14 +516,14 @@ pub fn trans_field_ptr<'a, 'tcx>(\n             // (e.d., Result of Either with (), as one side.)\n             let ty = type_of::type_of(bcx.ccx, nullfields[ix]);\n             assert_eq!(machine::llsize_of_alloc(bcx.ccx, ty), 0);\n-            bcx.pointercast(val.value, ty.ptr_to())\n+            bcx.pointercast(val.llval, ty.ptr_to())\n         }\n         layout::RawNullablePointer { nndiscr, .. } => {\n             let nnty = compute_fields(bcx.ccx, t, nndiscr as usize, false)[0];\n             assert_eq!(ix, 0);\n             assert_eq!(discr.0, nndiscr);\n             let ty = type_of::type_of(bcx.ccx, nnty);\n-            bcx.pointercast(val.value, ty.ptr_to())\n+            bcx.pointercast(val.llval, ty.ptr_to())\n         }\n         layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n             assert_eq!(discr.0, nndiscr);\n@@ -564,7 +539,7 @@ fn struct_field_ptr<'a, 'tcx>(\n     bcx: &Builder<'a, 'tcx>,\n     st: &layout::Struct,\n     fields: &Vec<Ty<'tcx>>,\n-    val: MaybeSizedValue,\n+    val: LvalueRef,\n     ix: usize,\n     needs_cast: bool\n ) -> ValueRef {\n@@ -576,9 +551,9 @@ fn struct_field_ptr<'a, 'tcx>(\n             type_of::in_memory_type_of(ccx, fields[i])\n         }).collect::<Vec<_>>();\n         let real_ty = Type::struct_(ccx, &fields[..], st.packed);\n-        bcx.pointercast(val.value, real_ty.ptr_to())\n+        bcx.pointercast(val.llval, real_ty.ptr_to())\n     } else {\n-        val.value\n+        val.llval\n     };\n \n     // Simple case - we can just GEP the field\n@@ -600,7 +575,7 @@ fn struct_field_ptr<'a, 'tcx>(\n     }\n \n     // There's no metadata available, log the case and just do the GEP.\n-    if !val.has_meta() {\n+    if !val.has_extra() {\n         debug!(\"Unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n                ix, Value(ptr_val));\n         return bcx.struct_gep(ptr_val, ix);\n@@ -621,7 +596,7 @@ fn struct_field_ptr<'a, 'tcx>(\n     // The type Foo<Foo<Trait>> is represented in LLVM as { u16, { u16, u8 }}, meaning that\n     // the `y` field has 16-bit alignment.\n \n-    let meta = val.meta;\n+    let meta = val.llextra;\n \n \n     let offset = st.offsets[ix].bytes();"}, {"sha": "a329b01cc160821f1aa031c7a600edc97f40b9db", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8038489357b5262645760a24673597486d71c1df/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8038489357b5262645760a24673597486d71c1df/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=8038489357b5262645760a24673597486d71c1df", "patch": "@@ -47,6 +47,7 @@ use session::config::{self, NoDebugInfo};\n use rustc_incremental::IncrementalHashesMap;\n use session::{self, DataTypeKind, Session};\n use abi::{self, Abi, FnType};\n+use mir::lvalue::LvalueRef;\n use adt;\n use attributes;\n use builder::Builder;\n@@ -278,17 +279,17 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 monomorphize::field_ty(bcx.tcx(), substs_b, f)\n             });\n \n-            let src = adt::MaybeSizedValue::sized(src);\n-            let dst = adt::MaybeSizedValue::sized(dst);\n+            let src = LvalueRef::new_sized_ty(src, src_ty);\n+            let dst = LvalueRef::new_sized_ty(dst, dst_ty);\n \n             let iter = src_fields.zip(dst_fields).enumerate();\n             for (i, (src_fty, dst_fty)) in iter {\n                 if type_is_zero_size(bcx.ccx, dst_fty) {\n                     continue;\n                 }\n \n-                let src_f = adt::trans_field_ptr(bcx, src_ty, src, Disr(0), i);\n-                let dst_f = adt::trans_field_ptr(bcx, dst_ty, dst, Disr(0), i);\n+                let src_f = adt::trans_field_ptr(bcx, src, Disr(0), i);\n+                let dst_f = adt::trans_field_ptr(bcx, dst, Disr(0), i);\n                 if src_fty == dst_fty {\n                     memcpy_ty(bcx, dst_f, src_f, src_fty, None);\n                 } else {\n@@ -620,11 +621,12 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // final ret value\n             bcx.alloca(fn_ty.ret.memory_ty(ccx), \"sret_slot\")\n         };\n-        let dest_val = adt::MaybeSizedValue::sized(dest); // Can return unsized value\n+        // Can return unsized value\n+        let dest_val = LvalueRef::new_sized_ty(dest, sig.output());\n         let mut llarg_idx = fn_ty.ret.is_indirect() as usize;\n         let mut arg_idx = 0;\n         for (i, arg_ty) in sig.inputs().iter().enumerate() {\n-            let lldestptr = adt::trans_field_ptr(&bcx, sig.output(), dest_val, Disr::from(disr), i);\n+            let lldestptr = adt::trans_field_ptr(&bcx, dest_val, Disr::from(disr), i);\n             let arg = &fn_ty.args[arg_idx];\n             arg_idx += 1;\n             if common::type_is_fat_ptr(bcx.ccx, arg_ty) {"}, {"sha": "c99dc7ee5ef4b9f70464d520d8440ad9336857a4", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8038489357b5262645760a24673597486d71c1df/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8038489357b5262645760a24673597486d71c1df/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=8038489357b5262645760a24673597486d71c1df", "patch": "@@ -26,7 +26,7 @@ use base;\n use builder::Builder;\n use common::{self, CrateContext, SharedCrateContext};\n use cleanup::CleanupScope;\n-use adt::MaybeSizedValue;\n+use mir::lvalue::LvalueRef;\n use consts;\n use declare;\n use value::Value;\n@@ -364,7 +364,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     // Call the by-ref closure body with `self` in a cleanup scope,\n     // to drop `self` when the body returns, or in case it unwinds.\n     let self_scope = CleanupScope::schedule_drop_mem(\n-        &bcx, MaybeSizedValue::sized(llenv), closure_ty\n+        &bcx, LvalueRef::new_sized_ty(llenv, closure_ty)\n     );\n \n     let llfn = callee.reify(bcx.ccx);"}, {"sha": "d7ac5bee6d85a70c097ba354ead05af1f23243aa", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8038489357b5262645760a24673597486d71c1df/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8038489357b5262645760a24673597486d71c1df/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=8038489357b5262645760a24673597486d71c1df", "patch": "@@ -20,12 +20,12 @@\n \n use llvm::BasicBlockRef;\n use base;\n-use adt::MaybeSizedValue;\n+use mir::lvalue::LvalueRef;\n+use rustc::mir::tcx::LvalueTy;\n use builder::Builder;\n use common::Funclet;\n use glue;\n use type_::Type;\n-use rustc::ty::Ty;\n \n pub struct CleanupScope<'tcx> {\n     // Cleanup to run upon scope exit.\n@@ -37,14 +37,13 @@ pub struct CleanupScope<'tcx> {\n \n #[derive(Copy, Clone)]\n pub struct DropValue<'tcx> {\n-    val: MaybeSizedValue,\n-    ty: Ty<'tcx>,\n+    val: LvalueRef<'tcx>,\n     skip_dtor: bool,\n }\n \n impl<'tcx> DropValue<'tcx> {\n     fn trans<'a>(&self, funclet: Option<&'a Funclet>, bcx: &Builder<'a, 'tcx>) {\n-        glue::call_drop_glue(bcx, self.val, self.ty, self.skip_dtor, funclet)\n+        glue::call_drop_glue(bcx, self.val, self.skip_dtor, funclet)\n     }\n \n     /// Creates a landing pad for the top scope. The landing pad will perform all cleanups necessary\n@@ -96,12 +95,16 @@ impl<'tcx> DropValue<'tcx> {\n impl<'a, 'tcx> CleanupScope<'tcx> {\n     /// Schedules a (deep) drop of `val`, which is a pointer to an instance of `ty`\n     pub fn schedule_drop_mem(\n-        bcx: &Builder<'a, 'tcx>, val: MaybeSizedValue, ty: Ty<'tcx>\n+        bcx: &Builder<'a, 'tcx>, val: LvalueRef<'tcx>\n     ) -> CleanupScope<'tcx> {\n-        if !bcx.ccx.shared().type_needs_drop(ty) { return CleanupScope::noop(); }\n+        if let LvalueTy::Downcast { .. } = val.ty {\n+            bug!(\"Cannot drop downcast ty yet\");\n+        }\n+        if !bcx.ccx.shared().type_needs_drop(val.ty.to_ty(bcx.tcx())) {\n+            return CleanupScope::noop();\n+        }\n         let drop = DropValue {\n             val: val,\n-            ty: ty,\n             skip_dtor: false,\n         };\n \n@@ -114,15 +117,19 @@ impl<'a, 'tcx> CleanupScope<'tcx> {\n     /// and dropping the contents associated with that variant\n     /// *without* executing any associated drop implementation.\n     pub fn schedule_drop_adt_contents(\n-        bcx: &Builder<'a, 'tcx>, val: MaybeSizedValue, ty: Ty<'tcx>\n+        bcx: &Builder<'a, 'tcx>, val: LvalueRef<'tcx>\n     ) -> CleanupScope<'tcx> {\n+        if let LvalueTy::Downcast { .. } = val.ty {\n+            bug!(\"Cannot drop downcast ty yet\");\n+        }\n         // `if` below could be \"!contents_needs_drop\"; skipping drop\n         // is just an optimization, so sound to be conservative.\n-        if !bcx.ccx.shared().type_needs_drop(ty) { return CleanupScope::noop(); }\n+        if !bcx.ccx.shared().type_needs_drop(val.ty.to_ty(bcx.tcx())) {\n+            return CleanupScope::noop();\n+        }\n \n         let drop = DropValue {\n             val: val,\n-            ty: ty,\n             skip_dtor: true,\n         };\n "}, {"sha": "f3977004b336dd285b07b06219ba25aec2b83759", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 45, "deletions": 50, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/8038489357b5262645760a24673597486d71c1df/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8038489357b5262645760a24673597486d71c1df/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=8038489357b5262645760a24673597486d71c1df", "patch": "@@ -22,7 +22,8 @@ use rustc::ty::subst::{Substs};\n use rustc::traits;\n use rustc::ty::{self, AdtKind, Ty, TypeFoldable};\n use rustc::ty::subst::Kind;\n-use adt::{self, MaybeSizedValue};\n+use mir::lvalue::LvalueRef;\n+use adt;\n use base::*;\n use callee::Callee;\n use cleanup::CleanupScope;\n@@ -39,19 +40,16 @@ use builder::Builder;\n \n use syntax_pos::DUMMY_SP;\n \n-pub fn trans_exchange_free_ty<'a, 'tcx>(\n-    bcx: &Builder<'a, 'tcx>,\n-    ptr: MaybeSizedValue,\n-    content_ty: Ty<'tcx>\n-) {\n+pub fn trans_exchange_free_ty<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, ptr: LvalueRef<'tcx>) {\n+    let content_ty = ptr.ty.to_ty(bcx.tcx());\n     let def_id = langcall(bcx.tcx(), None, \"\", BoxFreeFnLangItem);\n     let substs = bcx.tcx().mk_substs(iter::once(Kind::from(content_ty)));\n     let callee = Callee::def(bcx.ccx, def_id, substs);\n \n     let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n \n     let llret = bcx.call(callee.reify(bcx.ccx),\n-        &[ptr.value, ptr.meta][..1 + ptr.has_meta() as usize], None);\n+        &[ptr.llval, ptr.llextra][..1 + ptr.has_extra() as usize], None);\n     fn_ty.apply_attrs_callsite(llret);\n }\n \n@@ -94,17 +92,17 @@ pub fn get_drop_glue_type<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>, t: Ty<'t\n     }\n }\n \n-fn drop_ty<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, args: MaybeSizedValue, t: Ty<'tcx>) {\n-    call_drop_glue(bcx, args, t, false, None)\n+fn drop_ty<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, args: LvalueRef<'tcx>) {\n+    call_drop_glue(bcx, args, false, None)\n }\n \n pub fn call_drop_glue<'a, 'tcx>(\n     bcx: &Builder<'a, 'tcx>,\n-    mut args: MaybeSizedValue,\n-    t: Ty<'tcx>,\n+    mut args: LvalueRef<'tcx>,\n     skip_dtor: bool,\n     funclet: Option<&'a Funclet>,\n ) {\n+    let t = args.ty.to_ty(bcx.tcx());\n     // NB: v is an *alias* of type t here, not a direct value.\n     debug!(\"call_drop_glue(t={:?}, skip_dtor={})\", t, skip_dtor);\n     if bcx.ccx.shared().type_needs_drop(t) {\n@@ -117,11 +115,11 @@ pub fn call_drop_glue<'a, 'tcx>(\n         let glue = get_drop_glue_core(ccx, g);\n         let glue_type = get_drop_glue_type(ccx.shared(), t);\n         if glue_type != t {\n-            args.value = bcx.pointercast(args.value, type_of(ccx, glue_type).ptr_to());\n+            args.llval = bcx.pointercast(args.llval, type_of(ccx, glue_type).ptr_to());\n         }\n \n         // No drop-hint ==> call standard drop glue\n-        bcx.call(glue, &[args.value, args.meta][..1 + args.has_meta() as usize],\n+        bcx.call(glue, &[args.llval, args.llextra][..1 + args.has_extra() as usize],\n             funclet.map(|b| b.bundle()));\n     }\n }\n@@ -194,9 +192,9 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n \n     let value = get_param(llfn, 0);\n     let ptr = if ccx.shared().type_is_sized(t) {\n-        MaybeSizedValue::sized(value)\n+        LvalueRef::new_sized_ty(value, t)\n     } else {\n-        MaybeSizedValue::unsized_(value, get_param(llfn, 1))\n+        LvalueRef::new_unsized_ty(value, get_param(llfn, 1), t)\n     };\n \n     let skip_dtor = match g {\n@@ -211,23 +209,23 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n             // a safe-guard, assert TyBox not used with TyContents.\n             assert!(!skip_dtor);\n             let ptr = if !bcx.ccx.shared().type_is_sized(content_ty) {\n-                let llbox = bcx.load(get_dataptr(&bcx, ptr.value));\n-                let info = bcx.load(get_meta(&bcx, ptr.value));\n-                MaybeSizedValue::unsized_(llbox, info)\n+                let llbox = bcx.load(get_dataptr(&bcx, ptr.llval));\n+                let info = bcx.load(get_meta(&bcx, ptr.llval));\n+                LvalueRef::new_unsized_ty(llbox, info, content_ty)\n             } else {\n-                MaybeSizedValue::sized(bcx.load(ptr.value))\n+                LvalueRef::new_sized_ty(bcx.load(ptr.llval), content_ty)\n             };\n-            drop_ty(&bcx, ptr, content_ty);\n-            trans_exchange_free_ty(&bcx, ptr, content_ty);\n+            drop_ty(&bcx, ptr);\n+            trans_exchange_free_ty(&bcx, ptr);\n             bcx\n         }\n         ty::TyDynamic(..) => {\n             // No support in vtable for distinguishing destroying with\n             // versus without calling Drop::drop. Assert caller is\n             // okay with always calling the Drop impl, if any.\n             assert!(!skip_dtor);\n-            let dtor = bcx.load(ptr.meta);\n-            bcx.call(dtor, &[ptr.value], None);\n+            let dtor = bcx.load(ptr.llextra);\n+            bcx.call(dtor, &[ptr.llval], None);\n             bcx\n         }\n         ty::TyAdt(def, ..) if def.dtor_kind().is_present() && !skip_dtor => {\n@@ -245,7 +243,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n             // Issue #23611: schedule cleanup of contents, re-inspecting the\n             // discriminant (if any) in case of variant swap in drop code.\n             let contents_scope = if !shallow_drop {\n-                CleanupScope::schedule_drop_adt_contents(&bcx, ptr, t)\n+                CleanupScope::schedule_drop_adt_contents(&bcx, ptr)\n             } else {\n                 CleanupScope::noop()\n             };\n@@ -262,7 +260,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n             let callee = Callee::def(bcx.ccx, dtor_did, vtbl.substs);\n             let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n             let llret;\n-            let args = &[ptr.value, ptr.meta][..1 + ptr.has_meta() as usize];\n+            let args = &[ptr.llval, ptr.llextra][..1 + ptr.has_extra() as usize];\n             if let Some(landing_pad) = contents_scope.landing_pad {\n                 let normal_bcx = bcx.build_new_block(\"normal-return\");\n                 llret = bcx.invoke(callee.reify(ccx), args, normal_bcx.llbb(), landing_pad, None);\n@@ -279,7 +277,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n         }\n         _ => {\n             if bcx.ccx.shared().type_needs_drop(t) {\n-                drop_structural_ty(bcx, ptr, t)\n+                drop_structural_ty(bcx, ptr)\n             } else {\n                 bcx\n             }\n@@ -396,60 +394,57 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n }\n \n // Iterates through the elements of a structural type, dropping them.\n-fn drop_structural_ty<'a, 'tcx>(cx: Builder<'a, 'tcx>,\n-                                ptr: MaybeSizedValue,\n-                                t: Ty<'tcx>)\n-                                -> Builder<'a, 'tcx> {\n+fn drop_structural_ty<'a, 'tcx>(cx: Builder<'a, 'tcx>, ptr: LvalueRef<'tcx>) -> Builder<'a, 'tcx> {\n     fn iter_variant<'a, 'tcx>(cx: &Builder<'a, 'tcx>,\n-                              t: Ty<'tcx>,\n-                              av: adt::MaybeSizedValue,\n+                              av: LvalueRef<'tcx>,\n                               variant: &'tcx ty::VariantDef,\n                               substs: &Substs<'tcx>) {\n         let tcx = cx.tcx();\n         for (i, field) in variant.fields.iter().enumerate() {\n             let arg = monomorphize::field_ty(tcx, substs, field);\n-            let field_ptr = adt::trans_field_ptr(&cx, t, av, Disr::from(variant.disr_val), i);\n-            drop_ty(&cx, MaybeSizedValue::sized(field_ptr), arg);\n+            let field_ptr = adt::trans_field_ptr(&cx, av, Disr::from(variant.disr_val), i);\n+            drop_ty(&cx, LvalueRef::new_sized_ty(field_ptr, arg));\n         }\n     }\n \n     let mut cx = cx;\n+    let t = ptr.ty.to_ty(cx.tcx());\n     match t.sty {\n         ty::TyClosure(def_id, substs) => {\n             for (i, upvar_ty) in substs.upvar_tys(def_id, cx.tcx()).enumerate() {\n-                let llupvar = adt::trans_field_ptr(&cx, t, ptr, Disr(0), i);\n-                drop_ty(&cx, MaybeSizedValue::sized(llupvar), upvar_ty);\n+                let llupvar = adt::trans_field_ptr(&cx, ptr, Disr(0), i);\n+                drop_ty(&cx, LvalueRef::new_sized_ty(llupvar, upvar_ty));\n             }\n         }\n         ty::TyArray(_, n) => {\n-            let base = get_dataptr(&cx, ptr.value);\n+            let base = get_dataptr(&cx, ptr.llval);\n             let len = C_uint(cx.ccx, n);\n             let unit_ty = t.sequence_element_type(cx.tcx());\n             cx = tvec::slice_for_each(&cx, base, unit_ty, len,\n-                |bb, vv| drop_ty(bb, MaybeSizedValue::sized(vv), unit_ty));\n+                |bb, vv| drop_ty(bb, LvalueRef::new_sized_ty(vv, unit_ty)));\n         }\n         ty::TySlice(_) | ty::TyStr => {\n             let unit_ty = t.sequence_element_type(cx.tcx());\n-            cx = tvec::slice_for_each(&cx, ptr.value, unit_ty, ptr.meta,\n-                |bb, vv| drop_ty(bb, MaybeSizedValue::sized(vv), unit_ty));\n+            cx = tvec::slice_for_each(&cx, ptr.llval, unit_ty, ptr.llextra,\n+                |bb, vv| drop_ty(bb, LvalueRef::new_sized_ty(vv, unit_ty)));\n         }\n         ty::TyTuple(ref args) => {\n             for (i, arg) in args.iter().enumerate() {\n-                let llfld_a = adt::trans_field_ptr(&cx, t, ptr, Disr(0), i);\n-                drop_ty(&cx, MaybeSizedValue::sized(llfld_a), *arg);\n+                let llfld_a = adt::trans_field_ptr(&cx, ptr, Disr(0), i);\n+                drop_ty(&cx, LvalueRef::new_sized_ty(llfld_a, *arg));\n             }\n         }\n         ty::TyAdt(adt, substs) => match adt.adt_kind() {\n             AdtKind::Struct => {\n                 let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n                 for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n-                    let llfld_a = adt::trans_field_ptr(&cx, t, ptr, Disr::from(discr), i);\n+                    let llfld_a = adt::trans_field_ptr(&cx, ptr, Disr::from(discr), i);\n                     let ptr = if cx.ccx.shared().type_is_sized(field_ty) {\n-                        MaybeSizedValue::sized(llfld_a)\n+                        LvalueRef::new_sized_ty(llfld_a, field_ty)\n                     } else {\n-                        MaybeSizedValue::unsized_(llfld_a, ptr.meta)\n+                        LvalueRef::new_unsized_ty(llfld_a, ptr.llextra, field_ty)\n                     };\n-                    drop_ty(&cx, ptr, field_ty);\n+                    drop_ty(&cx, ptr);\n                 }\n             }\n             AdtKind::Union => {\n@@ -461,16 +456,16 @@ fn drop_structural_ty<'a, 'tcx>(cx: Builder<'a, 'tcx>,\n                 // NB: we must hit the discriminant first so that structural\n                 // comparison know not to proceed when the discriminants differ.\n \n-                match adt::trans_switch(&cx, t, ptr.value, false) {\n+                match adt::trans_switch(&cx, t, ptr.llval, false) {\n                     (adt::BranchKind::Single, None) => {\n                         if n_variants != 0 {\n                             assert!(n_variants == 1);\n-                            iter_variant(&cx, t, ptr, &adt.variants[0], substs);\n+                            iter_variant(&cx, ptr, &adt.variants[0], substs);\n                         }\n                     }\n                     (adt::BranchKind::Switch, Some(lldiscrim_a)) => {\n                         let tcx = cx.tcx();\n-                        drop_ty(&cx, MaybeSizedValue::sized(lldiscrim_a), tcx.types.isize);\n+                        drop_ty(&cx, LvalueRef::new_sized_ty(lldiscrim_a, tcx.types.isize));\n \n                         // Create a fall-through basic block for the \"else\" case of\n                         // the switch instruction we're about to generate. Note that\n@@ -496,7 +491,7 @@ fn drop_structural_ty<'a, 'tcx>(cx: Builder<'a, 'tcx>,\n                             let variant_cx = cx.build_new_block(&variant_cx_name);\n                             let case_val = adt::trans_case(&cx, t, Disr::from(variant.disr_val));\n                             variant_cx.add_case(llswitch, case_val, variant_cx.llbb());\n-                            iter_variant(&variant_cx, t, ptr, variant, substs);\n+                            iter_variant(&variant_cx, ptr, variant, substs);\n                             variant_cx.br(next_cx.llbb());\n                         }\n                         cx = next_cx;"}, {"sha": "b80c707f37697c3d00879d96071c4c49f1cf1abb", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8038489357b5262645760a24673597486d71c1df/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8038489357b5262645760a24673597486d71c1df/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=8038489357b5262645760a24673597486d71c1df", "patch": "@@ -16,6 +16,7 @@ use llvm;\n use llvm::{ValueRef};\n use abi::{Abi, FnType};\n use adt;\n+use mir::lvalue::LvalueRef;\n use base::*;\n use common::*;\n use declare;\n@@ -549,10 +550,10 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         // destructors, and the contents are SIMD\n                         // etc.\n                         assert!(!bcx.ccx.shared().type_needs_drop(arg_type));\n-                        let arg = adt::MaybeSizedValue::sized(llarg);\n+                        let arg = LvalueRef::new_sized_ty(llarg, arg_type);\n                         (0..contents.len())\n                             .map(|i| {\n-                                bcx.load(adt::trans_field_ptr(bcx, arg_type, arg, Disr(0), i))\n+                                bcx.load(adt::trans_field_ptr(bcx, arg, Disr(0), i))\n                             })\n                             .collect()\n                     }"}, {"sha": "77ce17006baa0d81b64f105794dabce93bfb74fa", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8038489357b5262645760a24673597486d71c1df/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8038489357b5262645760a24673597486d71c1df/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=8038489357b5262645760a24673597486d71c1df", "patch": "@@ -14,7 +14,7 @@ use rustc::middle::lang_items;\n use rustc::ty::{self, layout};\n use rustc::mir;\n use abi::{Abi, FnType, ArgType};\n-use adt::{self, MaybeSizedValue};\n+use adt;\n use base::{self, Lifetime};\n use callee::{Callee, CalleeData, Fn, Intrinsic, NamedTupleConstructor, Virtual};\n use builder::Builder;\n@@ -37,7 +37,7 @@ use std::cmp;\n use super::{MirContext, LocalRef};\n use super::analyze::CleanupKind;\n use super::constant::Const;\n-use super::lvalue::{LvalueRef};\n+use super::lvalue::LvalueRef;\n use super::operand::OperandRef;\n use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n@@ -251,11 +251,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     } else {\n                         lvalue.llval\n                     };\n-                    MaybeSizedValue::sized(value)\n+                    LvalueRef::new_sized_ty(value, ty)\n                 } else {\n-                    MaybeSizedValue::unsized_(lvalue.llval, lvalue.llextra)\n+                    LvalueRef::new_unsized_ty(lvalue.llval, lvalue.llextra, ty)\n                 };\n-                let args = &[ptr.value, ptr.meta][..1 + ptr.has_meta() as usize];\n+                let args = &[ptr.llval, ptr.llextra][..1 + ptr.has_extra() as usize];\n                 if let Some(unwind) = unwind {\n                     bcx.invoke(\n                         drop_fn,\n@@ -707,9 +707,10 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         // Handle both by-ref and immediate tuples.\n         match tuple.val {\n             Ref(llval) => {\n-                let base = adt::MaybeSizedValue::sized(llval);\n                 for (n, &ty) in arg_types.iter().enumerate() {\n-                    let ptr = adt::trans_field_ptr(bcx, tuple.ty, base, Disr(0), n);\n+                    let ptr = adt::trans_field_ptr(\n+                        bcx, LvalueRef::new_sized_ty(llval, tuple.ty), Disr(0), n\n+                    );\n                     let val = if common::type_is_fat_ptr(bcx.ccx, ty) {\n                         let (lldata, llextra) = base::load_fat_ptr(bcx, ptr, ty);\n                         Pair(lldata, llextra)"}, {"sha": "fe8f92c679801141c034b7031cb4932cf60823ab", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8038489357b5262645760a24673597486d71c1df/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8038489357b5262645760a24673597486d71c1df/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=8038489357b5262645760a24673597486d71c1df", "patch": "@@ -44,6 +44,18 @@ impl<'tcx> LvalueRef<'tcx> {\n         LvalueRef { llval: llval, llextra: ptr::null_mut(), ty: lvalue_ty }\n     }\n \n+    pub fn new_sized_ty(llval: ValueRef, ty: Ty<'tcx>) -> LvalueRef<'tcx> {\n+        LvalueRef::new_sized(llval, LvalueTy::from_ty(ty))\n+    }\n+\n+    pub fn new_unsized_ty(llval: ValueRef, llextra: ValueRef, ty: Ty<'tcx>) -> LvalueRef<'tcx> {\n+        LvalueRef {\n+            llval: llval,\n+            llextra: llextra,\n+            ty: LvalueTy::from_ty(ty),\n+        }\n+    }\n+\n     pub fn len<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n         let ty = self.ty.to_ty(ccx.tcx());\n         match ty.sty {\n@@ -55,6 +67,10 @@ impl<'tcx> LvalueRef<'tcx> {\n             _ => bug!(\"unexpected type `{}` in LvalueRef::len\", ty)\n         }\n     }\n+\n+    pub fn has_extra(&self) -> bool {\n+        !self.llextra.is_null()\n+    }\n }\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n@@ -132,11 +148,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let discr = discr as u64;\n                         let is_sized = self.ccx.shared().type_is_sized(projected_ty.to_ty(tcx));\n                         let base = if is_sized {\n-                            adt::MaybeSizedValue::sized(tr_base.llval)\n+                            LvalueRef::new_sized_ty(tr_base.llval, base_ty)\n                         } else {\n-                            adt::MaybeSizedValue::unsized_(tr_base.llval, tr_base.llextra)\n+                            LvalueRef::new_unsized_ty(tr_base.llval, tr_base.llextra, base_ty)\n                         };\n-                        let llprojected = adt::trans_field_ptr(bcx, base_ty, base, Disr(discr),\n+                        let llprojected = adt::trans_field_ptr(bcx, base, Disr(discr),\n                             field.index());\n                         let llextra = if is_sized {\n                             ptr::null_mut()"}, {"sha": "01fd7979be116f79f7cbbf67dccc3697f3b86771", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8038489357b5262645760a24673597486d71c1df/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8038489357b5262645760a24673597486d71c1df/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=8038489357b5262645760a24673597486d71c1df", "patch": "@@ -38,7 +38,7 @@ use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n pub use self::constant::trans_static_initializer;\n \n use self::analyze::CleanupKind;\n-use self::lvalue::{LvalueRef};\n+use self::lvalue::LvalueRef;\n use rustc::mir::traversal;\n \n use self::operand::{OperandRef, OperandValue};\n@@ -578,7 +578,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n mod analyze;\n mod block;\n mod constant;\n-mod lvalue;\n+pub mod lvalue;\n mod operand;\n mod rvalue;\n mod statement;"}, {"sha": "9a3d63f18e8b40565dba954aee93148737f56ecb", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8038489357b5262645760a24673597486d71c1df/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8038489357b5262645760a24673597486d71c1df/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=8038489357b5262645760a24673597486d71c1df", "patch": "@@ -110,10 +110,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields.\n                             if !common::type_is_zero_size(bcx.ccx, op.ty) {\n-                                let val = adt::MaybeSizedValue::sized(dest.llval);\n+                                let val = LvalueRef::new_sized_ty(dest.llval, dest_ty);\n                                 let field_index = active_field_index.unwrap_or(i);\n-                                let lldest_i = adt::trans_field_ptr(&bcx, dest_ty, val, disr,\n-                                    field_index);\n+                                let lldest_i = adt::trans_field_ptr(&bcx, val, disr, field_index);\n                                 self.store_operand(&bcx, lldest_i, op, None);\n                             }\n                         }"}]}