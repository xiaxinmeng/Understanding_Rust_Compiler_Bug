{"sha": "ecc12953dbe401b3e8cb663ce6529706c50cbf8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjYzEyOTUzZGJlNDAxYjNlOGNiNjYzY2U2NTI5NzA2YzUwY2JmOGQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-07-20T11:55:45Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-07-20T14:26:25Z"}, "message": "trans: Make base::internalize_symbols() respect explicit linkage directives.", "tree": {"sha": "ae5fc233e0535676c6245c439862f16c21d8d63f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae5fc233e0535676c6245c439862f16c21d8d63f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecc12953dbe401b3e8cb663ce6529706c50cbf8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecc12953dbe401b3e8cb663ce6529706c50cbf8d", "html_url": "https://github.com/rust-lang/rust/commit/ecc12953dbe401b3e8cb663ce6529706c50cbf8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecc12953dbe401b3e8cb663ce6529706c50cbf8d/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7820888daeb961339643dd142ba032847181555", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7820888daeb961339643dd142ba032847181555", "html_url": "https://github.com/rust-lang/rust/commit/f7820888daeb961339643dd142ba032847181555"}], "stats": {"total": 72, "additions": 57, "deletions": 15}, "files": [{"sha": "ea8c248d0239fb2fd842c8f5af9e913f5fbf31d3", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 57, "deletions": 15, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ecc12953dbe401b3e8cb663ce6529706c50cbf8d/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecc12953dbe401b3e8cb663ce6529706c50cbf8d/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=ecc12953dbe401b3e8cb663ce6529706c50cbf8d", "patch": "@@ -89,13 +89,14 @@ use value::Value;\n use Disr;\n use util::common::indenter;\n use util::sha2::Sha256;\n-use util::nodemap::{NodeMap, NodeSet};\n+use util::nodemap::{NodeMap, NodeSet, FnvHashSet};\n \n use arena::TypedArena;\n use libc::c_uint;\n use std::ffi::{CStr, CString};\n+use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n-use std::collections::{HashMap, HashSet};\n+use std::collections::HashMap;\n use std::ptr;\n use std::rc::Rc;\n use std::str;\n@@ -2256,12 +2257,20 @@ fn write_metadata(cx: &SharedCrateContext,\n \n /// Find any symbols that are defined in one compilation unit, but not declared\n /// in any other compilation unit.  Give these symbols internal linkage.\n-fn internalize_symbols(cx: &CrateContextList, reachable: &HashSet<&str>) {\n+fn internalize_symbols<'a, 'tcx>(ccxs: &CrateContextList<'a, 'tcx>,\n+                                 symbol_map: &SymbolMap<'tcx>,\n+                                 reachable: &FnvHashSet<&str>) {\n+    let scx = ccxs.shared();\n+    let tcx = scx.tcx();\n+\n+    // 'unsafe' because we are holding on to CStr's from the LLVM module within\n+    // this block.\n     unsafe {\n-        let mut declared = HashSet::new();\n+        let mut referenced_somewhere = FnvHashSet();\n \n-        // Collect all external declarations in all compilation units.\n-        for ccx in cx.iter() {\n+        // Collect all symbols that need to stay externally visible because they\n+        // are referenced via a declaration in some other codegen unit.\n+        for ccx in ccxs.iter() {\n             for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n                 let linkage = llvm::LLVMGetLinkage(val);\n                 // We only care about external declarations (not definitions)\n@@ -2270,16 +2279,43 @@ fn internalize_symbols(cx: &CrateContextList, reachable: &HashSet<&str>) {\n                 let is_decl = llvm::LLVMIsDeclaration(val) != 0;\n \n                 if is_decl || is_available_externally {\n-                    let name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n-                    declared.insert(name);\n+                    let symbol_name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n+                    referenced_somewhere.insert(symbol_name);\n                 }\n             }\n         }\n \n+        // Also collect all symbols for which we cannot adjust linkage, because\n+        // it is fixed by some directive in the source code (e.g. #[no_mangle]).\n+        let linkage_fixed_explicitly: FnvHashSet<_> = scx\n+            .translation_items()\n+            .borrow()\n+            .iter()\n+            .cloned()\n+            .filter(|trans_item|{\n+                let def_id = match *trans_item {\n+                    TransItem::DropGlue(..) => {\n+                        return false\n+                    },\n+                    TransItem::Fn(ref instance) => {\n+                        instance.def\n+                    }\n+                    TransItem::Static(node_id) => {\n+                        tcx.map.local_def_id(node_id)\n+                    }\n+                };\n+\n+                trans_item.explicit_linkage(tcx).is_some() ||\n+                attr::contains_extern_indicator(tcx.sess.diagnostic(),\n+                                                &tcx.get_attrs(def_id))\n+            })\n+            .map(|trans_item| symbol_map.get_or_compute(scx, trans_item))\n+            .collect();\n+\n         // Examine each external definition.  If the definition is not used in\n         // any other compilation unit, and is not reachable from other crates,\n         // then give it internal linkage.\n-        for ccx in cx.iter() {\n+        for ccx in ccxs.iter() {\n             for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n                 let linkage = llvm::LLVMGetLinkage(val);\n \n@@ -2293,16 +2329,17 @@ fn internalize_symbols(cx: &CrateContextList, reachable: &HashSet<&str>) {\n                 if is_definition && is_externally_visible {\n                     let name_cstr = CStr::from_ptr(llvm::LLVMGetValueName(val));\n                     let name_str = name_cstr.to_str().unwrap();\n+                    let name_cow = Cow::Borrowed(name_str);\n \n-                    let is_referenced_somewhere = declared.contains(&name_cstr);\n-                    let is_reachable = reachable.contains(name_str);\n+                    let is_referenced_somewhere = referenced_somewhere.contains(&name_cstr);\n+                    let is_reachable = reachable.contains(&name_str);\n+                    let has_fixed_linkage = linkage_fixed_explicitly.contains(&name_cow);\n \n-                    if !is_referenced_somewhere && !is_reachable {\n+                    if !is_referenced_somewhere && !is_reachable && !has_fixed_linkage {\n                         llvm::SetLinkage(val, llvm::InternalLinkage);\n                         llvm::SetDLLStorageClass(val, llvm::DefaultStorageClass);\n                         llvm::UnsetComdat(val);\n                     }\n-\n                 }\n             }\n         }\n@@ -2616,8 +2653,13 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }));\n     }\n \n-    internalize_symbols(&crate_context_list,\n-                        &reachable_symbols.iter().map(|x| &x[..]).collect());\n+    time(shared_ccx.sess().time_passes(), \"internalize symbols\", || {\n+        internalize_symbols(&crate_context_list,\n+                            &symbol_map,\n+                            &reachable_symbols.iter()\n+                                              .map(|s| &s[..])\n+                                              .collect())\n+    });\n \n     if sess.target.target.options.is_like_msvc &&\n        sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {"}]}