{"sha": "8c37fdf2d702ff1fc805f1bbc5de634e1101a4da", "node_id": "C_kwDOAAsO6NoAKDhjMzdmZGYyZDcwMmZmMWZjODA1ZjFiYmM1ZGU2MzRlMTEwMWE0ZGE", "commit": {"author": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-09-03T12:05:28Z"}, "committer": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-09-03T12:05:28Z"}, "message": "std: make `ReentrantMutex` movable and `const`; simplify `Stdout` initialization", "tree": {"sha": "f8e7a1b7ba19ea1468795fdba6f085bc7e9befc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8e7a1b7ba19ea1468795fdba6f085bc7e9befc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEVuz3PwcqDyifNyYbcE4BSbAZSzwFAmMTQwgACgkQcE4BSbAZ\nSzyFXA/+LjteFRUb0ML0DKUS8kuIgbGyKIAo9+Pi9S5Pv/xe3koZtNNM2f2EiL/2\npA26snJ87BcICW6DT6t6vVHeQ0/y/vJ9m26zz42FGHjHf9MCCrOOdJpPiRokWMF/\nvZYJ0XezwxT0lYRs5beX9Pa4W5gFeuhgHGedNqgi7sWAD8zmONEfbR7xF44QcojA\noI/p13/CNjouuyiPaqdhWHufVKNGOjck/J/oupISWYg4Odfx8bDjo5ssCR+HgpI0\n51INmkXLzJDQovAv8zicLQvacCUnN2x/mCHIsDCNpZ1LGebJMuNbf0v+K2/h3S1x\n7xHYV7TfIsD6tkl+7C2UXqPLs7qITmMhlITc4aqKR9N+g3F8twkm2lByA47XwCVX\nQNi1G8unC8Ju+QRifch/4Udl9kYXbpoyPNIJIO9KbhqVwLpm0AiHWL7b4zckDG8u\nVkguj3PmxVwhekLRNeI3rcWUus+t2drUGtJGubl8Ri3C+xXoE6/0WmjB2qckjnJd\nuvKaPF4KljaVXHcKhA8ofBt0R8oMJ7oDaotnFMM4PU81Ii7nygEGQbZcLIi/ybbC\nXKJJN2GJCL1OnFQ8t3QGI3CAQe+js/46zoOZQimZt6gE7Xpi9n7wwhPLUgmB9qZ6\ncnrsiVQd0oC7czIfiUN1wSzjAusyClvhvT2LykGObtdbG+WxkPQ=\n=1oYg\n-----END PGP SIGNATURE-----", "payload": "tree f8e7a1b7ba19ea1468795fdba6f085bc7e9befc3\nparent 75b7e52e92c3b00fc891b47f5b2efdff0a2be55a\nauthor joboet <jonasboettiger@icloud.com> 1662206728 +0200\ncommitter joboet <jonasboettiger@icloud.com> 1662206728 +0200\n\nstd: make `ReentrantMutex` movable and `const`; simplify `Stdout` initialization\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da", "html_url": "https://github.com/rust-lang/rust/commit/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/comments", "author": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75b7e52e92c3b00fc891b47f5b2efdff0a2be55a", "url": "https://api.github.com/repos/rust-lang/rust/commits/75b7e52e92c3b00fc891b47f5b2efdff0a2be55a", "html_url": "https://github.com/rust-lang/rust/commit/75b7e52e92c3b00fc891b47f5b2efdff0a2be55a"}], "stats": {"total": 204, "additions": 39, "deletions": 165}, "files": [{"sha": "5d0ac690f815d37f276ef559a5cbc75fe3767b1c", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=8c37fdf2d702ff1fc805f1bbc5de634e1101a4da", "patch": "@@ -8,7 +8,6 @@ use crate::io::prelude::*;\n use crate::cell::{Cell, RefCell};\n use crate::fmt;\n use crate::io::{self, BufReader, IoSlice, IoSliceMut, LineWriter, Lines};\n-use crate::pin::Pin;\n use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sync::{Arc, Mutex, MutexGuard, OnceLock};\n use crate::sys::stdio;\n@@ -526,7 +525,7 @@ pub struct Stdout {\n     // FIXME: this should be LineWriter or BufWriter depending on the state of\n     //        stdout (tty or not). Note that if this is not line buffered it\n     //        should also flush-on-panic or some form of flush-on-abort.\n-    inner: Pin<&'static ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>>,\n+    inner: &'static ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>,\n }\n \n /// A locked reference to the [`Stdout`] handle.\n@@ -603,24 +602,20 @@ static STDOUT: OnceLock<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> = OnceLo\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdout() -> Stdout {\n     Stdout {\n-        inner: Pin::static_ref(&STDOUT).get_or_init_pin(\n-            || unsafe { ReentrantMutex::new(RefCell::new(LineWriter::new(stdout_raw()))) },\n-            |mutex| unsafe { mutex.init() },\n-        ),\n+        inner: STDOUT\n+            .get_or_init(|| ReentrantMutex::new(RefCell::new(LineWriter::new(stdout_raw())))),\n     }\n }\n \n pub fn cleanup() {\n-    if let Some(instance) = STDOUT.get() {\n-        // Flush the data and disable buffering during shutdown\n-        // by replacing the line writer by one with zero\n-        // buffering capacity.\n-        // We use try_lock() instead of lock(), because someone\n-        // might have leaked a StdoutLock, which would\n-        // otherwise cause a deadlock here.\n-        if let Some(lock) = Pin::static_ref(instance).try_lock() {\n-            *lock.borrow_mut() = LineWriter::with_capacity(0, stdout_raw());\n-        }\n+    // Flush the data and disable buffering during shutdown\n+    // by replacing the line writer by one with zero\n+    // buffering capacity.\n+    // We use try_lock() instead of lock(), because someone\n+    // might have leaked a StdoutLock, which would\n+    // otherwise cause a deadlock here.\n+    if let Some(lock) = STDOUT.get().and_then(ReentrantMutex::try_lock) {\n+        *lock.borrow_mut() = LineWriter::with_capacity(0, stdout_raw());\n     }\n }\n \n@@ -761,7 +756,7 @@ impl fmt::Debug for StdoutLock<'_> {\n /// standard library or via raw Windows API calls, will fail.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Stderr {\n-    inner: Pin<&'static ReentrantMutex<RefCell<StderrRaw>>>,\n+    inner: &'static ReentrantMutex<RefCell<StderrRaw>>,\n }\n \n /// A locked reference to the [`Stderr`] handle.\n@@ -834,16 +829,12 @@ pub struct StderrLock<'a> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stderr() -> Stderr {\n     // Note that unlike `stdout()` we don't use `at_exit` here to register a\n-    // destructor. Stderr is not buffered , so there's no need to run a\n+    // destructor. Stderr is not buffered, so there's no need to run a\n     // destructor for flushing the buffer\n-    static INSTANCE: OnceLock<ReentrantMutex<RefCell<StderrRaw>>> = OnceLock::new();\n+    static INSTANCE: ReentrantMutex<RefCell<StderrRaw>> =\n+        ReentrantMutex::new(RefCell::new(stderr_raw()));\n \n-    Stderr {\n-        inner: Pin::static_ref(&INSTANCE).get_or_init_pin(\n-            || unsafe { ReentrantMutex::new(RefCell::new(stderr_raw())) },\n-            |mutex| unsafe { mutex.init() },\n-        ),\n-    }\n+    Stderr { inner: &INSTANCE }\n }\n \n impl Stderr {"}, {"sha": "37413ec62a717aae1c3009696db643df59d09403", "filename": "library/std/src/sync/once_lock.rs", "status": "modified", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock.rs?ref=8c37fdf2d702ff1fc805f1bbc5de634e1101a4da", "patch": "@@ -3,7 +3,6 @@ use crate::fmt;\n use crate::marker::PhantomData;\n use crate::mem::MaybeUninit;\n use crate::panic::{RefUnwindSafe, UnwindSafe};\n-use crate::pin::Pin;\n use crate::sync::Once;\n \n /// A synchronization primitive which can be written to only once.\n@@ -223,60 +222,6 @@ impl<T> OnceLock<T> {\n         Ok(unsafe { self.get_unchecked() })\n     }\n \n-    /// Internal-only API that gets the contents of the cell, initializing it\n-    /// in two steps with `f` and `g` if the cell was empty.\n-    ///\n-    /// `f` is called to construct the value, which is then moved into the cell\n-    /// and given as a (pinned) mutable reference to `g` to finish\n-    /// initialization.\n-    ///\n-    /// This allows `g` to inspect an manipulate the value after it has been\n-    /// moved into its final place in the cell, but before the cell is\n-    /// considered initialized.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `f` or `g` panics, the panic is propagated to the caller, and the\n-    /// cell remains uninitialized.\n-    ///\n-    /// With the current implementation, if `g` panics, the value from `f` will\n-    /// not be dropped. This should probably be fixed if this is ever used for\n-    /// a type where this matters.\n-    ///\n-    /// It is an error to reentrantly initialize the cell from `f`. The exact\n-    /// outcome is unspecified. Current implementation deadlocks, but this may\n-    /// be changed to a panic in the future.\n-    pub(crate) fn get_or_init_pin<F, G>(self: Pin<&Self>, f: F, g: G) -> Pin<&T>\n-    where\n-        F: FnOnce() -> T,\n-        G: FnOnce(Pin<&mut T>),\n-    {\n-        if let Some(value) = self.get_ref().get() {\n-            // SAFETY: The inner value was already initialized, and will not be\n-            // moved anymore.\n-            return unsafe { Pin::new_unchecked(value) };\n-        }\n-\n-        let slot = &self.value;\n-\n-        // Ignore poisoning from other threads\n-        // If another thread panics, then we'll be able to run our closure\n-        self.once.call_once_force(|_| {\n-            let value = f();\n-            // SAFETY: We use the Once (self.once) to guarantee unique access\n-            // to the UnsafeCell (slot).\n-            let value: &mut T = unsafe { (&mut *slot.get()).write(value) };\n-            // SAFETY: The value has been written to its final place in\n-            // self.value. We do not to move it anymore, which we promise here\n-            // with a Pin<&mut T>.\n-            g(unsafe { Pin::new_unchecked(value) });\n-        });\n-\n-        // SAFETY: The inner value has been initialized, and will not be moved\n-        // anymore.\n-        unsafe { Pin::new_unchecked(self.get_ref().get_unchecked()) }\n-    }\n-\n     /// Consumes the `OnceLock`, returning the wrapped value. Returns\n     /// `None` if the cell was empty.\n     ///"}, {"sha": "e0184eb5baf69b03195945e0b385dbdcfcde5d7d", "filename": "library/std/src/sys/hermit/mutex.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs?ref=8c37fdf2d702ff1fc805f1bbc5de634e1101a4da", "patch": "@@ -174,9 +174,6 @@ impl Mutex {\n         Mutex { inner: Spinlock::new(MutexInner::new()) }\n     }\n \n-    #[inline]\n-    pub unsafe fn init(&mut self) {}\n-\n     #[inline]\n     pub unsafe fn lock(&self) {\n         loop {"}, {"sha": "085662e6d44b86f55755a8c58b70a9e1d346bf44", "filename": "library/std/src/sys/itron/mutex.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fmutex.rs?ref=8c37fdf2d702ff1fc805f1bbc5de634e1101a4da", "patch": "@@ -31,12 +31,6 @@ impl Mutex {\n         Mutex { mtx: SpinIdOnceCell::new() }\n     }\n \n-    pub unsafe fn init(&mut self) {\n-        // Initialize `self.mtx` eagerly\n-        let id = new_mtx().unwrap_or_else(|e| fail(e, &\"acre_mtx\"));\n-        unsafe { self.mtx.set_unchecked((id, ())) };\n-    }\n-\n     /// Get the inner mutex's ID, which is lazily created.\n     fn raw(&self) -> abi::ID {\n         match self.mtx.get_or_try_init(|| new_mtx().map(|id| (id, ()))) {"}, {"sha": "aa747d56b0d3bf2b353ee3683c323e2f2e6ef12f", "filename": "library/std/src/sys/sgx/mutex.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmutex.rs?ref=8c37fdf2d702ff1fc805f1bbc5de634e1101a4da", "patch": "@@ -20,9 +20,6 @@ impl Mutex {\n         Mutex { inner: SpinMutex::new(WaitVariable::new(false)) }\n     }\n \n-    #[inline]\n-    pub unsafe fn init(&mut self) {}\n-\n     #[inline]\n     pub unsafe fn lock(&self) {\n         let mut guard = self.inner.lock();"}, {"sha": "41379f50c36c9f85c19bdca4667bd7c6f8a618b5", "filename": "library/std/src/sys/unix/locks/fuchsia_mutex.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffuchsia_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffuchsia_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffuchsia_mutex.rs?ref=8c37fdf2d702ff1fc805f1bbc5de634e1101a4da", "patch": "@@ -85,9 +85,6 @@ impl Mutex {\n         Mutex { futex: AtomicU32::new(UNLOCKED) }\n     }\n \n-    #[inline]\n-    pub unsafe fn init(&mut self) {}\n-\n     #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n         let thread_self = zx_thread_self();"}, {"sha": "198754a28ef152e36d61de845732a9174c1a6a4b", "filename": "library/std/src/sys/unix/locks/futex_mutex.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_mutex.rs?ref=8c37fdf2d702ff1fc805f1bbc5de634e1101a4da", "patch": "@@ -19,9 +19,6 @@ impl Mutex {\n         Self { futex: AtomicU32::new(0) }\n     }\n \n-    #[inline]\n-    pub unsafe fn init(&mut self) {}\n-\n     #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n         self.futex.compare_exchange(0, 1, Acquire, Relaxed).is_ok()"}, {"sha": "5964935ddb541527c783f9fc551584d873f67d42", "filename": "library/std/src/sys/unix/locks/pthread_mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_mutex.rs?ref=8c37fdf2d702ff1fc805f1bbc5de634e1101a4da", "patch": "@@ -52,7 +52,7 @@ impl Mutex {\n         Mutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n     }\n     #[inline]\n-    pub unsafe fn init(&mut self) {\n+    unsafe fn init(&mut self) {\n         // Issue #33770\n         //\n         // A pthread mutex initialized with PTHREAD_MUTEX_INITIALIZER will have"}, {"sha": "2be0b34b985b9eeace983e7d7b0110c24b4deca2", "filename": "library/std/src/sys/unsupported/locks/mutex.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fmutex.rs?ref=8c37fdf2d702ff1fc805f1bbc5de634e1101a4da", "patch": "@@ -16,9 +16,6 @@ impl Mutex {\n         Mutex { locked: Cell::new(false) }\n     }\n \n-    #[inline]\n-    pub unsafe fn init(&mut self) {}\n-\n     #[inline]\n     pub unsafe fn lock(&self) {\n         assert_eq!(self.locked.replace(true), false, \"cannot recursively acquire mutex\");"}, {"sha": "91207f5f4665894349d4595a919e56ff8ee75cb8", "filename": "library/std/src/sys/windows/locks/mutex.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Flocks%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Flocks%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Flocks%2Fmutex.rs?ref=8c37fdf2d702ff1fc805f1bbc5de634e1101a4da", "patch": "@@ -37,8 +37,6 @@ impl Mutex {\n     pub const fn new() -> Mutex {\n         Mutex { srwlock: UnsafeCell::new(c::SRWLOCK_INIT) }\n     }\n-    #[inline]\n-    pub unsafe fn init(&mut self) {}\n \n     #[inline]\n     pub unsafe fn lock(&self) {"}, {"sha": "b448ae3a99777162c35f930b64833baf34733427", "filename": "library/std/src/sys_common/remutex.rs", "status": "modified", "additions": 12, "deletions": 34, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex.rs?ref=8c37fdf2d702ff1fc805f1bbc5de634e1101a4da", "patch": "@@ -1,13 +1,11 @@\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests;\n \n+use super::mutex as sys;\n use crate::cell::UnsafeCell;\n-use crate::marker::PhantomPinned;\n use crate::ops::Deref;\n use crate::panic::{RefUnwindSafe, UnwindSafe};\n-use crate::pin::Pin;\n use crate::sync::atomic::{AtomicUsize, Ordering::Relaxed};\n-use crate::sys::locks as sys;\n \n /// A re-entrant mutual exclusion\n ///\n@@ -41,11 +39,10 @@ use crate::sys::locks as sys;\n /// synchronization is left to the mutex, making relaxed memory ordering for\n /// the `owner` field fine in all cases.\n pub struct ReentrantMutex<T> {\n-    mutex: sys::Mutex,\n+    mutex: sys::MovableMutex,\n     owner: AtomicUsize,\n     lock_count: UnsafeCell<u32>,\n     data: T,\n-    _pinned: PhantomPinned,\n }\n \n unsafe impl<T: Send> Send for ReentrantMutex<T> {}\n@@ -68,39 +65,22 @@ impl<T> RefUnwindSafe for ReentrantMutex<T> {}\n /// guarded data.\n #[must_use = \"if unused the ReentrantMutex will immediately unlock\"]\n pub struct ReentrantMutexGuard<'a, T: 'a> {\n-    lock: Pin<&'a ReentrantMutex<T>>,\n+    lock: &'a ReentrantMutex<T>,\n }\n \n impl<T> !Send for ReentrantMutexGuard<'_, T> {}\n \n impl<T> ReentrantMutex<T> {\n     /// Creates a new reentrant mutex in an unlocked state.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This function is unsafe because it is required that `init` is called\n-    /// once this mutex is in its final resting place, and only then are the\n-    /// lock/unlock methods safe.\n-    pub const unsafe fn new(t: T) -> ReentrantMutex<T> {\n+    pub const fn new(t: T) -> ReentrantMutex<T> {\n         ReentrantMutex {\n-            mutex: sys::Mutex::new(),\n+            mutex: sys::MovableMutex::new(),\n             owner: AtomicUsize::new(0),\n             lock_count: UnsafeCell::new(0),\n             data: t,\n-            _pinned: PhantomPinned,\n         }\n     }\n \n-    /// Initializes this mutex so it's ready for use.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// Unsafe to call more than once, and must be called after this will no\n-    /// longer move in memory.\n-    pub unsafe fn init(self: Pin<&mut Self>) {\n-        self.get_unchecked_mut().mutex.init()\n-    }\n-\n     /// Acquires a mutex, blocking the current thread until it is able to do so.\n     ///\n     /// This function will block the caller until it is available to acquire the mutex.\n@@ -113,15 +93,14 @@ impl<T> ReentrantMutex<T> {\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return failure if the mutex would otherwise be\n     /// acquired.\n-    pub fn lock(self: Pin<&Self>) -> ReentrantMutexGuard<'_, T> {\n+    pub fn lock(&self) -> ReentrantMutexGuard<'_, T> {\n         let this_thread = current_thread_unique_ptr();\n-        // Safety: We only touch lock_count when we own the lock,\n-        // and since self is pinned we can safely call the lock() on the mutex.\n+        // Safety: We only touch lock_count when we own the lock.\n         unsafe {\n             if self.owner.load(Relaxed) == this_thread {\n                 self.increment_lock_count();\n             } else {\n-                self.mutex.lock();\n+                self.mutex.raw_lock();\n                 self.owner.store(this_thread, Relaxed);\n                 debug_assert_eq!(*self.lock_count.get(), 0);\n                 *self.lock_count.get() = 1;\n@@ -142,10 +121,9 @@ impl<T> ReentrantMutex<T> {\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return failure if the mutex would otherwise be\n     /// acquired.\n-    pub fn try_lock(self: Pin<&Self>) -> Option<ReentrantMutexGuard<'_, T>> {\n+    pub fn try_lock(&self) -> Option<ReentrantMutexGuard<'_, T>> {\n         let this_thread = current_thread_unique_ptr();\n-        // Safety: We only touch lock_count when we own the lock,\n-        // and since self is pinned we can safely call the try_lock on the mutex.\n+        // Safety: We only touch lock_count when we own the lock.\n         unsafe {\n             if self.owner.load(Relaxed) == this_thread {\n                 self.increment_lock_count();\n@@ -179,12 +157,12 @@ impl<T> Deref for ReentrantMutexGuard<'_, T> {\n impl<T> Drop for ReentrantMutexGuard<'_, T> {\n     #[inline]\n     fn drop(&mut self) {\n-        // Safety: We own the lock, and the lock is pinned.\n+        // Safety: We own the lock.\n         unsafe {\n             *self.lock.lock_count.get() -= 1;\n             if *self.lock.lock_count.get() == 0 {\n                 self.lock.owner.store(0, Relaxed);\n-                self.lock.mutex.unlock();\n+                self.lock.mutex.raw_unlock();\n             }\n         }\n     }"}, {"sha": "8e97ce11c34f5ed198b29044afa67049268f3e20", "filename": "library/std/src/sys_common/remutex/tests.rs", "status": "modified", "additions": 10, "deletions": 27, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c37fdf2d702ff1fc805f1bbc5de634e1101a4da/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex%2Ftests.rs?ref=8c37fdf2d702ff1fc805f1bbc5de634e1101a4da", "patch": "@@ -1,18 +1,11 @@\n-use crate::boxed::Box;\n use crate::cell::RefCell;\n-use crate::pin::Pin;\n use crate::sync::Arc;\n use crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n use crate::thread;\n \n #[test]\n fn smoke() {\n-    let m = unsafe {\n-        let mut m = Box::pin(ReentrantMutex::new(()));\n-        m.as_mut().init();\n-        m\n-    };\n-    let m = m.as_ref();\n+    let m = ReentrantMutex::new(());\n     {\n         let a = m.lock();\n         {\n@@ -29,20 +22,15 @@ fn smoke() {\n \n #[test]\n fn is_mutex() {\n-    let m = unsafe {\n-        // FIXME: Simplify this if Arc gets an Arc::get_pin_mut.\n-        let mut m = Arc::new(ReentrantMutex::new(RefCell::new(0)));\n-        Pin::new_unchecked(Arc::get_mut_unchecked(&mut m)).init();\n-        Pin::new_unchecked(m)\n-    };\n+    let m = Arc::new(ReentrantMutex::new(RefCell::new(0)));\n     let m2 = m.clone();\n-    let lock = m.as_ref().lock();\n+    let lock = m.lock();\n     let child = thread::spawn(move || {\n-        let lock = m2.as_ref().lock();\n+        let lock = m2.lock();\n         assert_eq!(*lock.borrow(), 4950);\n     });\n     for i in 0..100 {\n-        let lock = m.as_ref().lock();\n+        let lock = m.lock();\n         *lock.borrow_mut() += i;\n     }\n     drop(lock);\n@@ -51,22 +39,17 @@ fn is_mutex() {\n \n #[test]\n fn trylock_works() {\n-    let m = unsafe {\n-        // FIXME: Simplify this if Arc gets an Arc::get_pin_mut.\n-        let mut m = Arc::new(ReentrantMutex::new(()));\n-        Pin::new_unchecked(Arc::get_mut_unchecked(&mut m)).init();\n-        Pin::new_unchecked(m)\n-    };\n+    let m = Arc::new(ReentrantMutex::new(()));\n     let m2 = m.clone();\n-    let _lock = m.as_ref().try_lock();\n-    let _lock2 = m.as_ref().try_lock();\n+    let _lock = m.try_lock();\n+    let _lock2 = m.try_lock();\n     thread::spawn(move || {\n-        let lock = m2.as_ref().try_lock();\n+        let lock = m2.try_lock();\n         assert!(lock.is_none());\n     })\n     .join()\n     .unwrap();\n-    let _lock3 = m.as_ref().try_lock();\n+    let _lock3 = m.try_lock();\n }\n \n pub struct Answer<'a>(pub ReentrantMutexGuard<'a, RefCell<u32>>);"}]}