{"sha": "419b5a1bee3424b646991530f31b617a08c8375c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxOWI1YTFiZWUzNDI0YjY0Njk5MTUzMGYzMWI2MTdhMDhjODM3NWM=", "commit": {"author": {"name": "Daniel McNab", "email": "36049421+DJMcNab@users.noreply.github.com", "date": "2021-03-07T12:59:15Z"}, "committer": {"name": "Daniel McNab", "email": "36049421+DJMcNab@users.noreply.github.com", "date": "2021-03-07T12:59:15Z"}, "message": "Extract the large nested block into a function\n\nAlso add some more detailed comments\nExtract into function deleted the previous comments", "tree": {"sha": "9d9e29368e577896cb4657c27719146bdd18d3ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d9e29368e577896cb4657c27719146bdd18d3ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/419b5a1bee3424b646991530f31b617a08c8375c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/419b5a1bee3424b646991530f31b617a08c8375c", "html_url": "https://github.com/rust-lang/rust/commit/419b5a1bee3424b646991530f31b617a08c8375c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/419b5a1bee3424b646991530f31b617a08c8375c/comments", "author": {"login": "DJMcNab", "id": 36049421, "node_id": "MDQ6VXNlcjM2MDQ5NDIx", "avatar_url": "https://avatars.githubusercontent.com/u/36049421?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DJMcNab", "html_url": "https://github.com/DJMcNab", "followers_url": "https://api.github.com/users/DJMcNab/followers", "following_url": "https://api.github.com/users/DJMcNab/following{/other_user}", "gists_url": "https://api.github.com/users/DJMcNab/gists{/gist_id}", "starred_url": "https://api.github.com/users/DJMcNab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DJMcNab/subscriptions", "organizations_url": "https://api.github.com/users/DJMcNab/orgs", "repos_url": "https://api.github.com/users/DJMcNab/repos", "events_url": "https://api.github.com/users/DJMcNab/events{/privacy}", "received_events_url": "https://api.github.com/users/DJMcNab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DJMcNab", "id": 36049421, "node_id": "MDQ6VXNlcjM2MDQ5NDIx", "avatar_url": "https://avatars.githubusercontent.com/u/36049421?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DJMcNab", "html_url": "https://github.com/DJMcNab", "followers_url": "https://api.github.com/users/DJMcNab/followers", "following_url": "https://api.github.com/users/DJMcNab/following{/other_user}", "gists_url": "https://api.github.com/users/DJMcNab/gists{/gist_id}", "starred_url": "https://api.github.com/users/DJMcNab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DJMcNab/subscriptions", "organizations_url": "https://api.github.com/users/DJMcNab/orgs", "repos_url": "https://api.github.com/users/DJMcNab/repos", "events_url": "https://api.github.com/users/DJMcNab/events{/privacy}", "received_events_url": "https://api.github.com/users/DJMcNab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9246df669ae67556b66119c8a6e3416c9534ca45", "url": "https://api.github.com/repos/rust-lang/rust/commits/9246df669ae67556b66119c8a6e3416c9534ca45", "html_url": "https://github.com/rust-lang/rust/commit/9246df669ae67556b66119c8a6e3416c9534ca45"}], "stats": {"total": 170, "additions": 98, "deletions": 72}, "files": [{"sha": "b2ca7a4d25ef4f0e9219d77239e3b888df990dd9", "filename": "crates/project_model/src/workspace.rs", "status": "modified", "additions": 98, "deletions": 72, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/419b5a1bee3424b646991530f31b617a08c8375c/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419b5a1bee3424b646991530f31b617a08c8375c/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fworkspace.rs?ref=419b5a1bee3424b646991530f31b617a08c8375c", "patch": "@@ -376,6 +376,7 @@ fn cargo_to_crate_graph(\n     cfg_options.insert_atom(\"debug_assertions\".into());\n \n     let mut pkg_crates = FxHashMap::default();\n+    // Does any crate signal to rust-analyzer that they need the rustc_private crates?\n     let mut has_private = false;\n     // Next, create crates for each package, target pair\n     for pkg in cargo.packages() {\n@@ -440,92 +441,117 @@ fn cargo_to_crate_graph(\n         }\n     }\n \n-    let mut rustc_pkg_crates = FxHashMap::default();\n-\n     if has_private {\n         // If the user provided a path to rustc sources, we add all the rustc_private crates\n         // and create dependencies on them for the crates which opt-in to that\n         if let Some(rustc_workspace) = rustc {\n-            // rustc-dev crates start from 'rustc_driver'\n-            // We want to collect all crates which are transitive dependencies of rustc_driver\n-            if let Some(root_pkg) = rustc_workspace\n-                .packages()\n-                .find(|package| rustc_workspace[*package].name == \"rustc_driver\")\n-            {\n-                let mut queue = VecDeque::new();\n-                queue.push_back(root_pkg);\n-                while let Some(pkg) = queue.pop_front() {\n-                    // Don't duplicate packages\n-                    if rustc_pkg_crates.contains_key(&pkg) {\n-                        continue;\n-                    }\n-                    for dep in &rustc_workspace[pkg].dependencies {\n-                        queue.push_back(dep.pkg);\n-                    }\n-                    for &tgt in rustc_workspace[pkg].targets.iter() {\n-                        if rustc_workspace[tgt].kind != TargetKind::Lib {\n-                            continue;\n-                        }\n-                        if let Some(file_id) = load(&rustc_workspace[tgt].root) {\n-                            let crate_id = add_target_crate_root(\n-                                &mut crate_graph,\n-                                &rustc_workspace[pkg],\n-                                rustc_build_data_map\n-                                    .and_then(|it| it.get(&rustc_workspace[pkg].id)),\n-                                &cfg_options,\n-                                proc_macro_loader,\n-                                file_id,\n-                            );\n-                            pkg_to_lib_crate.insert(pkg, crate_id);\n-                            // Add dependencies on the core / std / alloc for rustc\n-                            for (name, krate) in public_deps.iter() {\n-                                add_dep(&mut crate_graph, crate_id, name.clone(), *krate);\n-                            }\n-                            rustc_pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n-                        }\n+            handle_rustc_crates(\n+                rustc_workspace,\n+                load,\n+                &mut crate_graph,\n+                rustc_build_data_map,\n+                &cfg_options,\n+                proc_macro_loader,\n+                &mut pkg_to_lib_crate,\n+                &public_deps,\n+                cargo,\n+                &pkg_crates,\n+            );\n+        }\n+    }\n+    crate_graph\n+}\n+\n+fn handle_rustc_crates(\n+    rustc_workspace: &CargoWorkspace,\n+    load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n+    crate_graph: &mut CrateGraph,\n+    rustc_build_data_map: Option<&FxHashMap<String, BuildData>>,\n+    cfg_options: &CfgOptions,\n+    proc_macro_loader: &dyn Fn(&Path) -> Vec<ProcMacro>,\n+    pkg_to_lib_crate: &mut FxHashMap<la_arena::Idx<crate::PackageData>, CrateId>,\n+    public_deps: &[(CrateName, CrateId)],\n+    cargo: &CargoWorkspace,\n+    pkg_crates: &FxHashMap<la_arena::Idx<crate::PackageData>, Vec<CrateId>>,\n+) {\n+    let mut rustc_pkg_crates = FxHashMap::default();\n+    // The root package of the rustc-dev component is rustc_driver, so we match that\n+    let root_pkg =\n+        rustc_workspace.packages().find(|package| rustc_workspace[*package].name == \"rustc_driver\");\n+    // The rustc workspace might be incomplete (such as if rustc-dev is not installed for the current toolchain)\n+    // and `rustcSource` is set to discover.\n+    if let Some(root_pkg) = root_pkg {\n+        // Iterate through every crate in the dependency subtree of rustc_driver using BFS\n+        let mut queue = VecDeque::new();\n+        queue.push_back(root_pkg);\n+        while let Some(pkg) = queue.pop_front() {\n+            // Don't duplicate packages if they are dependended on a diamond pattern\n+            // N.B. if this line is ommitted, we try and analyse either 48_000 or 480_000 crates\n+            // neither of which makes\n+            if rustc_pkg_crates.contains_key(&pkg) {\n+                continue;\n+            }\n+            for dep in &rustc_workspace[pkg].dependencies {\n+                queue.push_back(dep.pkg);\n+            }\n+            for &tgt in rustc_workspace[pkg].targets.iter() {\n+                if rustc_workspace[tgt].kind != TargetKind::Lib {\n+                    continue;\n+                }\n+                if let Some(file_id) = load(&rustc_workspace[tgt].root) {\n+                    let crate_id = add_target_crate_root(\n+                        crate_graph,\n+                        &rustc_workspace[pkg],\n+                        rustc_build_data_map.and_then(|it| it.get(&rustc_workspace[pkg].id)),\n+                        &cfg_options,\n+                        proc_macro_loader,\n+                        file_id,\n+                    );\n+                    pkg_to_lib_crate.insert(pkg, crate_id);\n+                    // Add dependencies on core / std / alloc for this crate\n+                    for (name, krate) in public_deps.iter() {\n+                        add_dep(crate_graph, crate_id, name.clone(), *krate);\n                     }\n+                    rustc_pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n                 }\n             }\n-            // Now add a dep edge from all targets of upstream to the lib\n-            // target of downstream.\n-            for pkg in rustc_pkg_crates.keys().copied() {\n-                for dep in rustc_workspace[pkg].dependencies.iter() {\n-                    let name = CrateName::new(&dep.name).unwrap();\n-                    if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n-                        for &from in rustc_pkg_crates.get(&pkg).into_iter().flatten() {\n-                            add_dep(&mut crate_graph, from, name.clone(), to);\n-                        }\n-                    }\n+        }\n+    }\n+    // Now add a dep edge from all targets of upstream to the lib\n+    // target of downstream.\n+    for pkg in rustc_pkg_crates.keys().copied() {\n+        for dep in rustc_workspace[pkg].dependencies.iter() {\n+            let name = CrateName::new(&dep.name).unwrap();\n+            if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n+                for &from in rustc_pkg_crates.get(&pkg).into_iter().flatten() {\n+                    add_dep(crate_graph, from, name.clone(), to);\n                 }\n             }\n-\n-            // Add dependencies for all crates which opt in to rustc_private libraries\n-            for dep in rustc_workspace.packages() {\n-                let name = CrateName::normalize_dashes(&rustc_workspace[dep].name);\n-\n-                if let Some(&to) = pkg_to_lib_crate.get(&dep) {\n-                    for pkg in cargo.packages() {\n-                        let package = &cargo[pkg];\n-                        if !package.metadata.rustc_private {\n-                            continue;\n-                        }\n-                        for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n-                            // Avoid creating duplicate dependencies\n-                            if !crate_graph[from].dependencies.iter().any(|d| d.name == name) {\n-                                add_dep(&mut crate_graph, from, name.clone(), to);\n-                            } else {\n-                                eprintln!(\n-                                    \"Skipped {} for {:?}\",\n-                                    &name, &crate_graph[from].display_name\n-                                );\n-                            }\n-                        }\n+        }\n+    }\n+    // Add a dependency on the rustc_private crates for all targets of each package\n+    // which opts in\n+    for dep in rustc_workspace.packages() {\n+        let name = CrateName::normalize_dashes(&rustc_workspace[dep].name);\n+\n+        if let Some(&to) = pkg_to_lib_crate.get(&dep) {\n+            for pkg in cargo.packages() {\n+                let package = &cargo[pkg];\n+                if !package.metadata.rustc_private {\n+                    continue;\n+                }\n+                for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n+                    // Avoid creating duplicate dependencies\n+                    // This avoids the situation where `from` depends on e.g. `arrayvec`, but\n+                    // `rust_analyzer` thinks that it should use the one from the `rustcSource`\n+                    // instead of the one from `crates.io`\n+                    if !crate_graph[from].dependencies.iter().any(|d| d.name == name) {\n+                        add_dep(crate_graph, from, name.clone(), to);\n                     }\n                 }\n             }\n         }\n     }\n-    crate_graph\n }\n \n fn add_target_crate_root("}]}