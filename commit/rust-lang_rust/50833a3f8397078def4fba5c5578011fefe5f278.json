{"sha": "50833a3f8397078def4fba5c5578011fefe5f278", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwODMzYTNmODM5NzA3OGRlZjRmYmE1YzU1NzgwMTFmZWZlNWYyNzg=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-24T04:14:16Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-24T13:51:12Z"}, "message": "Rollup merge of #24523 - GuillaumeGomez:clean-error-codes, r=Manishearth", "tree": {"sha": "51b3cd440ddead4a9f30ed6b847fc74c693cabff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51b3cd440ddead4a9f30ed6b847fc74c693cabff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50833a3f8397078def4fba5c5578011fefe5f278", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50833a3f8397078def4fba5c5578011fefe5f278", "html_url": "https://github.com/rust-lang/rust/commit/50833a3f8397078def4fba5c5578011fefe5f278", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50833a3f8397078def4fba5c5578011fefe5f278/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d439b41777103b8b349635e68e9ccd3648aabc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d439b41777103b8b349635e68e9ccd3648aabc2", "html_url": "https://github.com/rust-lang/rust/commit/9d439b41777103b8b349635e68e9ccd3648aabc2"}, {"sha": "2ddc8f5eb53a1966f17991a3920295e080b09097", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ddc8f5eb53a1966f17991a3920295e080b09097", "html_url": "https://github.com/rust-lang/rust/commit/2ddc8f5eb53a1966f17991a3920295e080b09097"}], "stats": {"total": 36, "additions": 33, "deletions": 3}, "files": [{"sha": "182405a640dbcfb2d506607c6c6194f355c5c06e", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/50833a3f8397078def4fba5c5578011fefe5f278/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50833a3f8397078def4fba5c5578011fefe5f278/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=50833a3f8397078def4fba5c5578011fefe5f278", "patch": "@@ -75,11 +75,13 @@ the following is invalid as it requires the entire Option<String> to be moved\n into a variable called `op_string` while simultaneously requiring the inner\n String to be moved into a variable called `s`.\n \n+```\n let x = Some(\"s\".to_string());\n match x {\n     op_string @ Some(s) => ...\n     None => ...\n }\n+```\n \n See also Error 303.\n \"##,\n@@ -90,10 +92,12 @@ name is bound by move in a pattern, it should also be moved to wherever it is\n referenced in the pattern guard code. Doing so however would prevent the name\n from being available in the body of the match arm. Consider the following:\n \n+```\n match Some(\"hi\".to_string()) {\n     Some(s) if s.len() == 0 => // use s.\n     ...\n }\n+```\n \n The variable `s` has type String, and its use in the guard is as a variable of\n type String. The guard code effectively executes in a separate scope to the body\n@@ -102,11 +106,13 @@ become unavailable in the body of the arm. Although this example seems\n innocuous, the problem is most clear when considering functions that take their\n argument by value.\n \n+```\n match Some(\"hi\".to_string()) {\n     Some(s) if { drop(s); false } => (),\n     Some(s) => // use s.\n     ...\n }\n+```\n \n The value would be dropped in the guard then become unavailable not only in the\n body of that arm but also in all subsequent arms! The solution is to bind by\n@@ -219,8 +225,10 @@ them yourself.\n You can build a free-standing crate by adding `#![no_std]` to the crate\n attributes:\n \n+```\n #![feature(no_std)]\n #![no_std]\n+```\n \n See also https://doc.rust-lang.org/book/no-stdlib.html\n \"##,\n@@ -236,11 +244,13 @@ mutex can be declared `static` as well.\n \n If you want to match against a `static`, consider using a guard instead:\n \n+```\n static FORTY_TWO: i32 = 42;\n match Some(42) {\n     Some(x) if x == FORTY_TWO => ...\n     ...\n }\n+```\n \"##,\n \n E0161: r##\"\n@@ -256,6 +266,7 @@ An if-let pattern attempts to match the pattern, and enters the body if the\n match was succesful. If the match is irrefutable (when it cannot fail to match),\n use a regular `let`-binding instead. For instance:\n \n+```\n struct Irrefutable(i32);\n let irr = Irrefutable(0);\n \n@@ -268,13 +279,15 @@ if let Irrefutable(x) = irr {\n // Try this instead:\n let Irrefutable(x) = irr;\n foo(x);\n+```\n \"##,\n \n E0165: r##\"\n A while-let pattern attempts to match the pattern, and enters the body if the\n match was succesful. If the match is irrefutable (when it cannot fail to match),\n use a regular `let`-binding inside a `loop` instead. For instance:\n \n+```\n struct Irrefutable(i32);\n let irr = Irrefutable(0);\n \n@@ -288,22 +301,27 @@ loop {\n     let Irrefutable(x) = irr;\n     ...\n }\n+```\n \"##,\n \n E0170: r##\"\n Enum variants are qualified by default. For example, given this type:\n \n+```\n enum Method {\n     GET,\n     POST\n }\n+```\n \n you would match it using:\n \n+```\n match m {\n     Method::GET => ...\n     Method::POST => ...\n }\n+```\n \n If you don't qualify the names, the code will bind new variables named \"GET\" and\n \"POST\" instead. This behavior is likely not what you want, so rustc warns when\n@@ -312,8 +330,10 @@ that happens.\n Qualified names are good practice, and most code works well with them. But if\n you prefer them unqualified, you can import the variants into scope:\n \n+```\n use Method::*;\n enum Method { GET, POST }\n+```\n \"##,\n \n E0267: r##\"\n@@ -333,7 +353,9 @@ E0296: r##\"\n This error indicates that the given recursion limit could not be parsed. Ensure\n that the value provided is a positive integer between quotes, like so:\n \n+```\n #![recursion_limit=\"1000\"]\n+```\n \"##,\n \n E0297: r##\"\n@@ -342,6 +364,7 @@ that a name will be extracted in all cases. Instead of pattern matching the\n loop variable, consider using a `match` or `if let` inside the loop body. For\n instance:\n \n+```\n // This fails because `None` is not covered.\n for Some(x) in xs {\n     ...\n@@ -361,6 +384,7 @@ for item in xs {\n         ...\n     }\n }\n+```\n \"##,\n \n E0301: r##\"\n@@ -370,11 +394,13 @@ on which the match depends in such a way, that the match would not be\n exhaustive. For instance, the following would not match any arm if mutable\n borrows were allowed:\n \n+```\n match Some(()) {\n     None => { },\n     option if option.take().is_none() => { /* impossible, option is `Some` */ },\n     Some(_) => { } // When the previous match failed, the option became `None`.\n }\n+```\n \"##,\n \n E0302: r##\"\n@@ -384,21 +410,24 @@ on which the match depends in such a way, that the match would not be\n exhaustive. For instance, the following would not match any arm if assignments\n were allowed:\n \n+```\n match Some(()) {\n     None => { },\n     option if { option = None; false } { },\n     Some(_) => { } // When the previous match failed, the option became `None`.\n }\n+```\n \"##,\n \n E0303: r##\"\n In certain cases it is possible for sub-bindings to violate memory safety.\n Updates to the borrow checker in a future version of Rust may remove this\n restriction, but for now patterns must be rewritten without sub-bindings.\n \n-// Before.\n-match Some(\"hi\".to_string()) {\n-    ref op_string_ref @ Some(ref s) => ...\n+```\n+// Code like this...\n+match Some(5) {\n+    ref op_num @ Some(num) => ...\n     None => ...\n }\n \n@@ -410,6 +439,7 @@ match Some(\"hi\".to_string()) {\n     }\n     None => ...\n }\n+```\n \n The `op_string_ref` binding has type &Option<&String> in both cases.\n "}]}