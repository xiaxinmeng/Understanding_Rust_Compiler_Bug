{"sha": "aa05a153630b64a6928128dae333714c0814c4ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMDVhMTUzNjMwYjY0YTY5MjgxMjhkYWUzMzM3MTRjMDgxNGM0Y2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-28T04:20:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-28T04:20:28Z"}, "message": "Auto merge of #36027 - eddyb:unsized-prefix, r=nagisa\n\nrustc_trans: don't round up the DST prefix size to its alignment.\n\nFixes #35815 by using `ty::layout` and `min_size` to compute the size of the DST prefix.\n`ty::layout::Struct::min_size` is not rounded up to alignment, which could be smaller for the DST field.", "tree": {"sha": "d7e8b807331eab89ab5e6beccd59e0307adbd874", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7e8b807331eab89ab5e6beccd59e0307adbd874"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa05a153630b64a6928128dae333714c0814c4ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa05a153630b64a6928128dae333714c0814c4ca", "html_url": "https://github.com/rust-lang/rust/commit/aa05a153630b64a6928128dae333714c0814c4ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa05a153630b64a6928128dae333714c0814c4ca/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e17d6db80a6baeb43cf37b784e58128c81d5a462", "url": "https://api.github.com/repos/rust-lang/rust/commits/e17d6db80a6baeb43cf37b784e58128c81d5a462", "html_url": "https://github.com/rust-lang/rust/commit/e17d6db80a6baeb43cf37b784e58128c81d5a462"}, {"sha": "3e313d9528adc64042012a19cc9a700bff11f19d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e313d9528adc64042012a19cc9a700bff11f19d", "html_url": "https://github.com/rust-lang/rust/commit/3e313d9528adc64042012a19cc9a700bff11f19d"}], "stats": {"total": 118, "additions": 70, "deletions": 48}, "files": [{"sha": "d5dcae5f6b0a47ad1b207ff6292ebec0d6da1865", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aa05a153630b64a6928128dae333714c0814c4ca/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa05a153630b64a6928128dae333714c0814c4ca/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=aa05a153630b64a6928128dae333714c0814c4ca", "patch": "@@ -124,18 +124,7 @@ pub fn type_pair_fields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n /// Returns true if the type is represented as a pair of immediates.\n pub fn type_is_imm_pair<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n                                   -> bool {\n-    let tcx = ccx.tcx();\n-    let layout = tcx.normalizing_infer_ctxt(Reveal::All).enter(|infcx| {\n-        match ty.layout(&infcx) {\n-            Ok(layout) => layout,\n-            Err(err) => {\n-                bug!(\"type_is_imm_pair: layout for `{:?}` failed: {}\",\n-                     ty, err);\n-            }\n-        }\n-    });\n-\n-    match *layout {\n+    match *ccx.layout_of(ty) {\n         Layout::FatPointer { .. } => true,\n         Layout::Univariant { ref variant, .. } => {\n             // There must be only 2 fields."}, {"sha": "7c1a607015de95b714730d37f7e74f776b00069a", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa05a153630b64a6928128dae333714c0814c4ca/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa05a153630b64a6928128dae333714c0814c4ca/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=aa05a153630b64a6928128dae333714c0814c4ca", "patch": "@@ -949,6 +949,14 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         TypeOfDepthLock(self.local())\n     }\n \n+    pub fn layout_of(&self, ty: Ty<'tcx>) -> &'tcx ty::layout::Layout {\n+        self.tcx().normalizing_infer_ctxt(traits::Reveal::All).enter(|infcx| {\n+            ty.layout(&infcx).unwrap_or_else(|e| {\n+                bug!(\"failed to get layout for `{}`: {}\", ty, e);\n+            })\n+        })\n+    }\n+\n     pub fn check_overflow(&self) -> bool {\n         self.shared.check_overflow\n     }"}, {"sha": "8d182a95a1ab87e961dc92a839474421508c5857", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/aa05a153630b64a6928128dae333714c0814c4ca/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa05a153630b64a6928128dae333714c0814c4ca/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=aa05a153630b64a6928128dae333714c0814c4ca", "patch": "@@ -338,13 +338,22 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n         ty::TyStruct(def, substs) => {\n             let ccx = bcx.ccx();\n             // First get the size of all statically known fields.\n-            // Don't use type_of::sizing_type_of because that expects t to be sized.\n+            // Don't use type_of::sizing_type_of because that expects t to be sized,\n+            // and it also rounds up to alignment, which we want to avoid,\n+            // as the unsized field's alignment could be smaller.\n             assert!(!t.is_simd());\n-            let repr = adt::represent_type(ccx, t);\n-            let sizing_type = adt::sizing_type_of(ccx, &repr, true);\n-            debug!(\"DST {} sizing_type: {:?}\", t, sizing_type);\n-            let sized_size = llsize_of_alloc(ccx, sizing_type);\n-            let sized_align = llalign_of_min(ccx, sizing_type);\n+            let layout = ccx.layout_of(t);\n+            debug!(\"DST {} layout: {:?}\", t, layout);\n+\n+            let (sized_size, sized_align) = match *layout {\n+                ty::layout::Layout::Univariant { ref variant, .. } => {\n+                    (variant.min_size().bytes(), variant.align.abi())\n+                }\n+                _ => {\n+                    bug!(\"size_and_align_of_dst: expcted Univariant for `{}`, found {:#?}\",\n+                         t, layout);\n+                }\n+            };\n             debug!(\"DST {} statically sized prefix size: {} align: {}\",\n                    t, sized_size, sized_align);\n             let sized_size = C_uint(ccx, sized_size);"}, {"sha": "6605d12e2e127b3c27f497015bae54e4c0944598", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/aa05a153630b64a6928128dae333714c0814c4ca/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa05a153630b64a6928128dae333714c0814c4ca/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=aa05a153630b64a6928128dae333714c0814c4ca", "patch": "@@ -15,7 +15,6 @@ use abi::FnType;\n use adt;\n use common::*;\n use machine;\n-use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::subst::Substs;\n \n@@ -125,37 +124,31 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n     cx.llsizingtypes().borrow_mut().insert(t, llsizingty);\n \n     // FIXME(eddyb) Temporary sanity check for ty::layout.\n-    let layout = cx.tcx().normalizing_infer_ctxt(Reveal::All).enter(|infcx| {\n-        t.layout(&infcx)\n-    });\n-    match layout {\n-        Ok(layout) => {\n-            if !type_is_sized(cx.tcx(), t) {\n-                if !layout.is_unsized() {\n-                    bug!(\"layout should be unsized for type `{}` / {:#?}\",\n-                         t, layout);\n-                }\n-\n-                // Unsized types get turned into a fat pointer for LLVM.\n-                return llsizingty;\n-            }\n-            let r = layout.size(&cx.tcx().data_layout).bytes();\n-            let l = machine::llsize_of_alloc(cx, llsizingty);\n-            if r != l {\n-                bug!(\"size differs (rustc: {}, llvm: {}) for type `{}` / {:#?}\",\n-                     r, l, t, layout);\n-            }\n-            let r = layout.align(&cx.tcx().data_layout).abi();\n-            let l = machine::llalign_of_min(cx, llsizingty) as u64;\n-            if r != l {\n-                bug!(\"align differs (rustc: {}, llvm: {}) for type `{}` / {:#?}\",\n-                     r, l, t, layout);\n-            }\n-        }\n-        Err(e) => {\n-            bug!(\"failed to get layout for `{}`: {}\", t, e);\n+    let layout = cx.layout_of(t);\n+    if !type_is_sized(cx.tcx(), t) {\n+        if !layout.is_unsized() {\n+            bug!(\"layout should be unsized for type `{}` / {:#?}\",\n+                 t, layout);\n         }\n+\n+        // Unsized types get turned into a fat pointer for LLVM.\n+        return llsizingty;\n+    }\n+\n+    let r = layout.size(&cx.tcx().data_layout).bytes();\n+    let l = machine::llsize_of_alloc(cx, llsizingty);\n+    if r != l {\n+        bug!(\"size differs (rustc: {}, llvm: {}) for type `{}` / {:#?}\",\n+             r, l, t, layout);\n     }\n+\n+    let r = layout.align(&cx.tcx().data_layout).abi();\n+    let l = machine::llalign_of_min(cx, llsizingty) as u64;\n+    if r != l {\n+        bug!(\"align differs (rustc: {}, llvm: {}) for type `{}` / {:#?}\",\n+             r, l, t, layout);\n+    }\n+\n     llsizingty\n }\n "}, {"sha": "619542926500ba03ed1c4cb0138bb1599608f4ca", "filename": "src/test/run-pass/issue-35815.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/aa05a153630b64a6928128dae333714c0814c4ca/src%2Ftest%2Frun-pass%2Fissue-35815.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa05a153630b64a6928128dae333714c0814c4ca/src%2Ftest%2Frun-pass%2Fissue-35815.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-35815.rs?ref=aa05a153630b64a6928128dae333714c0814c4ca", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem;\n+\n+struct Foo<T: ?Sized> {\n+    a: i64,\n+    b: bool,\n+    c: T,\n+}\n+\n+fn main() {\n+    let foo: &Foo<i32> = &Foo { a: 1, b: false, c: 2i32 };\n+    let foo_unsized: &Foo<Send> = foo;\n+    assert_eq!(mem::size_of_val(foo), mem::size_of_val(foo_unsized));\n+}"}]}