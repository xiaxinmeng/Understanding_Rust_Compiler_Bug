{"sha": "e24d1dd6f54b454b206bb2df79d277e77d818442", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyNGQxZGQ2ZjU0YjQ1NGIyMDZiYjJkZjc5ZDI3N2U3N2Q4MTg0NDI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-11-08T01:19:29Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-11-09T05:11:47Z"}, "message": "rewrite so that memory allocations have 0 overhead by default", "tree": {"sha": "3fe389cab1d4f63c55b2624ed301f22537dee811", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fe389cab1d4f63c55b2624ed301f22537dee811"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e24d1dd6f54b454b206bb2df79d277e77d818442", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e24d1dd6f54b454b206bb2df79d277e77d818442", "html_url": "https://github.com/rust-lang/rust/commit/e24d1dd6f54b454b206bb2df79d277e77d818442", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e24d1dd6f54b454b206bb2df79d277e77d818442/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75b98a9076e89b3cfc0883948e61d06ad881434c", "url": "https://api.github.com/repos/rust-lang/rust/commits/75b98a9076e89b3cfc0883948e61d06ad881434c", "html_url": "https://github.com/rust-lang/rust/commit/75b98a9076e89b3cfc0883948e61d06ad881434c"}], "stats": {"total": 84, "additions": 59, "deletions": 25}, "files": [{"sha": "82821f32222e21c3d1da6493c7bea06b127f772b", "filename": "src/rt/memory_region.cpp", "status": "modified", "additions": 44, "deletions": 23, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e24d1dd6f54b454b206bb2df79d277e77d818442/src%2Frt%2Fmemory_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e24d1dd6f54b454b206bb2df79d277e77d818442/src%2Frt%2Fmemory_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.cpp?ref=e24d1dd6f54b454b206bb2df79d277e77d818442", "patch": "@@ -1,22 +1,20 @@\n #include \"rust_internal.h\"\n #include \"memory_region.h\"\n \n-// NB: please do not commit code with this uncommented. It's\n-// hugely expensive and should only be used as a last resort.\n-//\n-// #define TRACK_ALLOCATIONS\n-\n-#define PTR_SIZE (sizeof(void*))\n-#define ALIGN_PTR(x) (((x)+PTR_SIZE-1)/PTR_SIZE*PTR_SIZE)\n-#define HEADER_SIZE ALIGN_PTR(sizeof(alloc_header))\n-#define MAGIC 0xbadc0ffe\n+#if RUSTRT_TRACK_ALLOCATIONS >= 1\n+#  define PTR_SIZE (sizeof(void*))\n+#  define ALIGN_PTR(x) (((x)+PTR_SIZE-1)/PTR_SIZE*PTR_SIZE)\n+#  define HEADER_SIZE ALIGN_PTR(sizeof(alloc_header))\n+#  define MAGIC 0xbadc0ffe\n+#else\n+#  define HEADER_SIZE 0\n+#endif\n \n memory_region::alloc_header *memory_region::get_header(void *mem) {\n     return (alloc_header *)((char *)mem - HEADER_SIZE);\n }\n \n void *memory_region::get_data(alloc_header *ptr) {\n-    assert(ptr->magic == MAGIC);\n     return (void*)((char *)ptr + HEADER_SIZE);\n }\n \n@@ -46,7 +44,11 @@ void memory_region::free(void *mem) {\n     // printf(\"free: ptr 0x%\" PRIxPTR\" region=%p\\n\", (uintptr_t) mem, this);\n     if (!mem) { return; }\n     alloc_header *alloc = get_header(mem);\n+\n+#   if RUSTRT_TRACK_ALLOCATIONS >= 1\n     assert(alloc->magic == MAGIC);\n+#   endif\n+\n     if (_live_allocations < 1) {\n         _srv->fatal(\"live_allocs < 1\", __FILE__, __LINE__, \"\");\n     }\n@@ -56,18 +58,22 @@ void memory_region::free(void *mem) {\n }\n \n void *\n-memory_region::realloc(void *mem, size_t size) {\n+memory_region::realloc(void *mem, size_t orig_size) {\n     if (_synchronized) { _lock.lock(); }\n     if (!mem) {\n         add_alloc();\n     }\n-    size_t old_size = size;\n-    size += HEADER_SIZE;\n+\n     alloc_header *alloc = get_header(mem);\n-    assert(alloc->magic == MAGIC);\n-    alloc->size = old_size;\n+    size_t size = orig_size + HEADER_SIZE;\n     alloc_header *newMem = (alloc_header *)_srv->realloc(alloc, size);\n-#ifdef TRACK_ALLOCATIONS\n+\n+#   if RUSTRT_TRACK_ALLOCATIONS >= 1\n+    assert(alloc->magic == MAGIC);\n+    newMem->size = orig_size;\n+#   endif\n+\n+#   if RUSTRT_TRACK_ALLOCATIONS >= 2\n     if (_allocation_list[newMem->index] != alloc) {\n         printf(\"at index %d, found %p, expected %p\\n\",\n                alloc->index, _allocation_list[alloc->index], alloc);\n@@ -80,7 +86,8 @@ memory_region::realloc(void *mem, size_t size) {\n         // printf(\"realloc: stored %p at index %d, replacing %p\\n\",\n         //        newMem, index, mem);\n     }\n-#endif\n+#   endif\n+\n     if (_synchronized) { _lock.unlock(); }\n     return get_data(newMem);\n }\n@@ -90,10 +97,13 @@ memory_region::malloc(size_t size, const char *tag, bool zero) {\n     size_t old_size = size;\n     size += HEADER_SIZE;\n     alloc_header *mem = (alloc_header *)_srv->malloc(size);\n+\n+#   if RUSTRT_TRACK_ALLOCATIONS >= 1\n     mem->magic = MAGIC;\n     mem->tag = tag;\n     mem->index = -1;\n     mem->size = old_size;\n+#   endif\n \n     void *data = get_data(mem);\n     claim_alloc(data);\n@@ -122,7 +132,8 @@ memory_region::~memory_region() {\n                  \"leaked memory in rust main loop (%d objects)\",\n                  _live_allocations);\n     }\n-#ifdef TRACK_ALLOCATIONS\n+\n+#   if RUSTRT_TRACK_ALLOCATIONS >= 2\n     if (_detailed_leaks) {\n         int leak_count = 0;\n         for (size_t i = 0; i < _allocation_list.size(); i++) {\n@@ -136,7 +147,8 @@ memory_region::~memory_region() {\n         }\n         assert(leak_count == _live_allocations);\n     }\n-#endif\n+#   endif\n+\n     if (_live_allocations > 0) {\n         _srv->fatal(msg, __FILE__, __LINE__,\n                     \"%d objects\", _live_allocations);\n@@ -146,10 +158,12 @@ memory_region::~memory_region() {\n \n void\n memory_region::release_alloc(void *mem) {\n+#   if RUSTRT_TRACK_ALLOCATIONS >= 1\n     alloc_header *alloc = get_header(mem);\n     assert(alloc->magic == MAGIC);\n+#   endif\n \n-#ifdef TRACK_ALLOCATIONS\n+#   if RUSTRT_TRACK_ALLOCATIONS >= 2\n     if (_synchronized) { _lock.lock(); }\n     if (_allocation_list[alloc->index] != alloc) {\n         printf(\"free: ptr 0x%\" PRIxPTR \" (%s) is not in allocation_list\\n\",\n@@ -162,19 +176,24 @@ memory_region::release_alloc(void *mem) {\n         alloc->index = -1;\n     }\n     if (_synchronized) { _lock.unlock(); }\n-#endif\n+#   endif\n+\n     dec_alloc();\n }\n \n void\n memory_region::claim_alloc(void *mem) {\n+#   if RUSTRT_TRACK_ALLOCATIONS >= 1\n     alloc_header *alloc = get_header(mem);\n     assert(alloc->magic == MAGIC);\n-#ifdef TRACK_ALLOCATIONS\n+#   endif\n+\n+#   if RUSTRT_TRACK_ALLOCATIONS >= 2\n     if (_synchronized) { _lock.lock(); }\n     alloc->index = _allocation_list.append(alloc);\n     if (_synchronized) { _lock.unlock(); }\n-#endif\n+#   endif\n+\n     add_alloc();\n }\n \n@@ -190,8 +209,10 @@ memory_region::maybe_poison(void *mem) {\n     if (!poison)\n         return;\n \n+#   if RUSTRT_TRACK_ALLOCATIONS >= 1\n     alloc_header *alloc = get_header(mem);\n     memset(mem, '\\xcd', alloc->size);\n+#   endif\n }\n \n //"}, {"sha": "75f3f9be941a3a609de40d3ebe1b4f7dd7e78d4f", "filename": "src/rt/memory_region.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e24d1dd6f54b454b206bb2df79d277e77d818442/src%2Frt%2Fmemory_region.h", "raw_url": "https://github.com/rust-lang/rust/raw/e24d1dd6f54b454b206bb2df79d277e77d818442/src%2Frt%2Fmemory_region.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.h?ref=e24d1dd6f54b454b206bb2df79d277e77d818442", "patch": "@@ -11,19 +11,32 @@\n \n #include \"sync/lock_and_signal.h\"\n \n+// There are three levels of debugging:\n+//\n+// 0 --- no headers, no debugging support\n+// 1 --- support poison, but do not track allocations\n+// 2 --- track allocations in deatil\n+//\n+// NB: please do not commit code with level 2. It's\n+// hugely expensive and should only be used as a last resort.\n+#define RUSTRT_TRACK_ALLOCATIONS 0\n+\n class rust_srv;\n \n class memory_region {\n private:\n     struct alloc_header {\n+#       if RUSTRT_TRACK_ALLOCATIONS > 0\n         uint32_t magic;\n         int index;\n         const char *tag;\n         uint32_t size;\n+#       endif\n     };\n \n-    alloc_header *get_header(void *mem);\n-    void *get_data(alloc_header *);\n+    inline alloc_header *get_header(void *mem);\n+    inline void *get_data(alloc_header *);\n+    \n \n     rust_srv *_srv;\n     memory_region *_parent;"}]}