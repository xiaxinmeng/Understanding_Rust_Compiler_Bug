{"sha": "57f39ee79bf11a563277ed8b700ceda0b8ee1390", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3ZjM5ZWU3OWJmMTFhNTYzMjc3ZWQ4YjcwMGNlZGEwYjhlZTEzOTA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-20T20:44:48Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-27T17:57:55Z"}, "message": "kill dead code from `util/liveness`", "tree": {"sha": "5b9447d275e31aa05c318404f36b4cf1dc7872d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b9447d275e31aa05c318404f36b4cf1dc7872d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57f39ee79bf11a563277ed8b700ceda0b8ee1390", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57f39ee79bf11a563277ed8b700ceda0b8ee1390", "html_url": "https://github.com/rust-lang/rust/commit/57f39ee79bf11a563277ed8b700ceda0b8ee1390", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57f39ee79bf11a563277ed8b700ceda0b8ee1390/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af3ff10c7d1d325bef400a2a385fc34ef05c375c", "url": "https://api.github.com/repos/rust-lang/rust/commits/af3ff10c7d1d325bef400a2a385fc34ef05c375c", "html_url": "https://github.com/rust-lang/rust/commit/af3ff10c7d1d325bef400a2a385fc34ef05c375c"}], "stats": {"total": 180, "additions": 9, "deletions": 171}, "files": [{"sha": "e9afa7df5c4f23d7536c8c445e576e7342c32414", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/57f39ee79bf11a563277ed8b700ceda0b8ee1390/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f39ee79bf11a563277ed8b700ceda0b8ee1390/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=57f39ee79bf11a563277ed8b700ceda0b8ee1390", "patch": "@@ -66,7 +66,7 @@ use rustc::mir::visit::{PlaceContext, Visitor, MutVisitor};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty};\n use rustc::ty::subst::Substs;\n use util::dump_mir;\n-use util::liveness::{self, IdentityMap, LivenessMode};\n+use util::liveness::{self, IdentityMap};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_set::IdxSet;\n use std::collections::HashMap;\n@@ -402,10 +402,6 @@ fn locals_live_across_suspend_points<'a, 'tcx,>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut set = liveness::LiveVarSet::new_empty(mir.local_decls.len());\n     let mut liveness = liveness::liveness_of_locals(\n         mir,\n-        LivenessMode {\n-            include_regular_use: true,\n-            include_drops: true,\n-        },\n         &IdentityMap::new(mir),\n     );\n     liveness::dump_mir("}, {"sha": "3ae470e1d4bbd113f00d04297b60629c352804aa", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 8, "deletions": 166, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/57f39ee79bf11a563277ed8b700ceda0b8ee1390/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f39ee79bf11a563277ed8b700ceda0b8ee1390/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=57f39ee79bf11a563277ed8b700ceda0b8ee1390", "patch": "@@ -33,7 +33,6 @@\n //! generator yield points, all pre-existing references are invalidated, so this\n //! doesn't matter).\n \n-use rustc::mir::visit::MirVisitable;\n use rustc::mir::visit::{PlaceContext, Visitor};\n use rustc::mir::Local;\n use rustc::mir::*;\n@@ -50,17 +49,13 @@ use util::pretty::{dump_enabled, write_basic_block, write_mir_intro};\n pub type LiveVarSet<V> = IdxSet<V>;\n \n /// This gives the result of the liveness analysis at the boundary of\n-/// basic blocks. You can use `simulate_block` to obtain the\n-/// intra-block results.\n+/// basic blocks.\n ///\n /// The `V` type defines the set of variables that we computed\n /// liveness for. This is often `Local`, in which case we computed\n /// liveness for all variables -- but it can also be some other type,\n /// which indicates a subset of the variables within the graph.\n pub struct LivenessResult<V: Idx> {\n-    /// Liveness mode in use when these results were computed.\n-    pub mode: LivenessMode,\n-\n     /// Live variables on exit to each basic block. This is equal to\n     /// the union of the `ins` for each successor.\n     pub outs: IndexVec<BasicBlock, LiveVarSet<V>>,\n@@ -104,78 +99,23 @@ impl<'a, 'tcx> LiveVariableMap for IdentityMap<'a, 'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub struct LivenessMode {\n-    /// If true, then we will consider \"regular uses\" of a variable to be live.\n-    /// For example, if the user writes `foo(x)`, then this is a regular use of\n-    /// the variable `x`.\n-    pub include_regular_use: bool,\n-\n-    /// If true, then we will consider (implicit) drops of a variable\n-    /// to be live.  For example, if the user writes `{ let x =\n-    /// vec![...]; .. }`, then the drop at the end of the block is an\n-    /// implicit drop.\n-    ///\n-    /// NB. Despite its name, a call like `::std::mem::drop(x)` is\n-    /// **not** considered a drop for this purposes, but rather a\n-    /// regular use.\n-    pub include_drops: bool,\n-}\n-\n-/// A combination of liveness results, used in NLL.\n-pub struct LivenessResults<V: Idx> {\n-    /// Liveness results where a regular use makes a variable X live,\n-    /// but not a drop.\n-    pub regular: LivenessResult<V>,\n-\n-    /// Liveness results where a drop makes a variable X live,\n-    /// but not a regular use.\n-    pub drop: LivenessResult<V>,\n-}\n-\n-impl<V: Idx> LivenessResults<V> {\n-    pub fn compute<'tcx>(\n-        mir: &Mir<'tcx>,\n-        map: &impl LiveVariableMap<LiveVar = V>,\n-    ) -> LivenessResults<V> {\n-        LivenessResults {\n-            regular: liveness_of_locals(\n-                &mir,\n-                LivenessMode {\n-                    include_regular_use: true,\n-                    include_drops: false,\n-                },\n-                map,\n-            ),\n-\n-            drop: liveness_of_locals(\n-                &mir,\n-                LivenessMode {\n-                    include_regular_use: false,\n-                    include_drops: true,\n-                },\n-                map,\n-            ),\n-        }\n-    }\n-}\n-\n /// Compute which local variables are live within the given function\n /// `mir`. The liveness mode `mode` determines what sorts of uses are\n /// considered to make a variable live (e.g., do drops count?).\n pub fn liveness_of_locals<'tcx, V: Idx>(\n     mir: &Mir<'tcx>,\n-    mode: LivenessMode,\n     map: &impl LiveVariableMap<LiveVar = V>,\n ) -> LivenessResult<V> {\n     let num_live_vars = map.num_variables();\n \n-    let def_use: IndexVec<_, DefsUses<V>> = mir.basic_blocks()\n+    let def_use: IndexVec<_, DefsUses<V>> = mir\n+        .basic_blocks()\n         .iter()\n-        .map(|b| block(mode, map, b, num_live_vars))\n+        .map(|b| block(map, b, num_live_vars))\n         .collect();\n \n-    let mut outs: IndexVec<_, LiveVarSet<V>> = mir.basic_blocks()\n+    let mut outs: IndexVec<_, LiveVarSet<V>> = mir\n+        .basic_blocks()\n         .indices()\n         .map(|_| LiveVarSet::new_empty(num_live_vars))\n         .collect();\n@@ -206,71 +146,7 @@ pub fn liveness_of_locals<'tcx, V: Idx>(\n         }\n     }\n \n-    LivenessResult { mode, outs }\n-}\n-\n-impl<V: Idx> LivenessResult<V> {\n-    /// Walks backwards through the statements/terminator in the given\n-    /// basic block `block`.  At each point within `block`, invokes\n-    /// the callback `op` with the current location and the set of\n-    /// variables that are live on entry to that location.\n-    pub fn simulate_block<'tcx, OP>(\n-        &self,\n-        mir: &Mir<'tcx>,\n-        block: BasicBlock,\n-        map: &impl LiveVariableMap<LiveVar = V>,\n-        mut callback: OP,\n-    ) where\n-        OP: FnMut(Location, &LiveVarSet<V>),\n-    {\n-        let data = &mir[block];\n-\n-        // Get a copy of the bits on exit from the block.\n-        let mut bits = self.outs[block].clone();\n-\n-        // Start with the maximal statement index -- i.e., right before\n-        // the terminator executes.\n-        let mut statement_index = data.statements.len();\n-\n-        // Compute liveness right before terminator and invoke callback.\n-        let terminator_location = Location {\n-            block,\n-            statement_index,\n-        };\n-        let num_live_vars = map.num_variables();\n-        let mut visitor = DefsUsesVisitor {\n-            mode: self.mode,\n-            map,\n-            defs_uses: DefsUses {\n-                defs: LiveVarSet::new_empty(num_live_vars),\n-                uses: LiveVarSet::new_empty(num_live_vars),\n-            },\n-        };\n-        // Visit the various parts of the basic block in reverse. If we go\n-        // forward, the logic in `add_def` and `add_use` would be wrong.\n-        visitor.update_bits_and_do_callback(\n-            terminator_location,\n-            &data.terminator,\n-            &mut bits,\n-            &mut callback,\n-        );\n-\n-        // Compute liveness before each statement (in rev order) and invoke callback.\n-        for statement in data.statements.iter().rev() {\n-            statement_index -= 1;\n-            let statement_location = Location {\n-                block,\n-                statement_index,\n-            };\n-            visitor.defs_uses.clear();\n-            visitor.update_bits_and_do_callback(\n-                statement_location,\n-                statement,\n-                &mut bits,\n-                &mut callback,\n-            );\n-        }\n-    }\n+    LivenessResult { outs }\n }\n \n #[derive(Eq, PartialEq, Clone)]\n@@ -342,7 +218,6 @@ where\n     V: Idx,\n     M: LiveVariableMap<LiveVar = V> + 'lv,\n {\n-    mode: LivenessMode,\n     map: &'lv M,\n     defs_uses: DefsUses<V>,\n }\n@@ -354,11 +229,6 @@ struct DefsUses<V: Idx> {\n }\n \n impl<V: Idx> DefsUses<V> {\n-    fn clear(&mut self) {\n-        self.uses.clear();\n-        self.defs.clear();\n-    }\n-\n     fn apply(&self, bits: &mut LiveVarSet<V>) -> bool {\n         bits.subtract(&self.defs) | bits.union(&self.uses)\n     }\n@@ -393,29 +263,6 @@ impl<V: Idx> DefsUses<V> {\n     }\n }\n \n-impl<'lv, V, M> DefsUsesVisitor<'lv, V, M>\n-where\n-    V: Idx,\n-    M: LiveVariableMap<LiveVar = V>,\n-{\n-    /// Update `bits` with the effects of `value` and call `callback`. We\n-    /// should always visit in reverse order. This method assumes that we have\n-    /// not visited anything before; if you have, clear `bits` first.\n-    fn update_bits_and_do_callback<'tcx, OP>(\n-        &mut self,\n-        location: Location,\n-        value: &impl MirVisitable<'tcx>,\n-        bits: &mut LiveVarSet<V>,\n-        callback: &mut OP,\n-    ) where\n-        OP: FnMut(Location, &LiveVarSet<V>),\n-    {\n-        value.apply(location, self);\n-        self.defs_uses.apply(bits);\n-        callback(location, bits);\n-    }\n-}\n-\n impl<'tcx, 'lv, V, M> Visitor<'tcx> for DefsUsesVisitor<'lv, V, M>\n where\n     V: Idx,\n@@ -425,24 +272,19 @@ where\n         if let Some(v_index) = self.map.from_local(local) {\n             match categorize(context) {\n                 Some(DefUse::Def) => self.defs_uses.add_def(v_index),\n-                Some(DefUse::Use) if self.mode.include_regular_use => {\n-                    self.defs_uses.add_use(v_index)\n-                }\n-                Some(DefUse::Drop) if self.mode.include_drops => self.defs_uses.add_use(v_index),\n+                Some(DefUse::Use) | Some(DefUse::Drop) => self.defs_uses.add_use(v_index),\n                 _ => (),\n             }\n         }\n     }\n }\n \n fn block<'tcx, V: Idx>(\n-    mode: LivenessMode,\n     map: &impl LiveVariableMap<LiveVar = V>,\n     b: &BasicBlockData<'tcx>,\n     locals: usize,\n ) -> DefsUses<V> {\n     let mut visitor = DefsUsesVisitor {\n-        mode,\n         map,\n         defs_uses: DefsUses {\n             defs: LiveVarSet::new_empty(locals),"}]}