{"sha": "ddab91a5debadfda47c057117c8b498a31abaae7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkYWI5MWE1ZGViYWRmZGE0N2MwNTcxMTdjOGI0OThhMzFhYmFhZTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-28T07:10:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-28T07:10:05Z"}, "message": "Auto merge of #48056 - ExpHP:macro-commas, r=dtolnay\n\nComprehensively support trailing commas in std/core macros\n\nI carefully organized the changes into four commits:\n\n* Test cases\n* Fixes for `macro_rules!` macros\n* Fixes for builtin macros\n* Docs for builtins\n\n**I can easily scale this back to just the first two commits for now if such is desired.**\n\n### Breaking (?) changes\n\n* This fixes #48042, which is a breaking change that I hope people can agree is just a bugfix for an extremely dark corner case.\n\n* To fix five of the builtins, this changes `syntax::ext::base::get_single_str_from_tts` to accept a trailing comma, and revises the documentation so that this aspect is not surprising. **I made this change under the (hopefully correct) understanding that `libsyntax` is private rustc implementation detail.** After reviewing all call sites (which were, you guessed it, *precisely those five macros*), I believe the revised semantics are closer to the intended spirit of the function.\n\n### Changes which may require concensus\n\nUp until now, it could be argued that some or all the following macros did not conceptually take a comma-separated list, because they only took one argument:\n\n  * **`cfg(unix,)`** (most notable since cfg! is unique in taking a meta tag)\n  * **`include{,_bytes,_str}(\"file.rs\",)`**  (in item form this might be written as \"`include!{\"file.rs\",}`\" which is even slightly more odd)\n  * **`compile_error(\"message\",);`**\n  * **`option_env!(\"PATH\",)`**\n  * **`try!(Ok(()),)`**\n\nSo I think these particular changes may require some sort of consensus.  **All of the fixes for builtins are included this list, so if we want to defer these decisions to later then I can scale this PR back to just the first two commits.**\n\n### Other notes/general requests for comment\n\n* Do we have a big checklist somewhere of \"things to do when adding macros?\" My hope is for `run-pass/macro-comma-support.rs` to remain comprehensive.\n* Originally I wanted the tests to also comprehensively forbid double trailing commas.  However, this didn't work out too well: [see this gist and the giant FIXME in it](https://gist.github.com/ExpHP/6fc40e82f3d73267c4e590a9a94966f1#file-compile-fail_macro-comma-support-rs-L33-L50)\n* I did not touch `select!`. It appears to me to be a complete mess, and its trailing comma mishaps are only the tip of the iceberg.\n* There are [some compile-fail test cases](https://github.com/ExpHP/rust/blob/5fa97c35da2f0ee/src/test/compile-fail/macro-comma-behavior.rs#L49-L52) that didn't seem to work (rustc emits errors, but compile-fail doesn't acknowledge them), so they are disabled. Any clues? (Possibly related: These happen to be precisely the set of errors which are tagged by rustc as \"this error originates in a macro outside of the current crate\".)\n\n---\n\nFixes #48042\nCloses #46241", "tree": {"sha": "edc968b35701226774a6865271ee8bdcee15093e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edc968b35701226774a6865271ee8bdcee15093e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddab91a5debadfda47c057117c8b498a31abaae7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddab91a5debadfda47c057117c8b498a31abaae7", "html_url": "https://github.com/rust-lang/rust/commit/ddab91a5debadfda47c057117c8b498a31abaae7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddab91a5debadfda47c057117c8b498a31abaae7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89e5a0796e0c5de52cd1d6c7541e5c2c7c47f2cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/89e5a0796e0c5de52cd1d6c7541e5c2c7c47f2cd", "html_url": "https://github.com/rust-lang/rust/commit/89e5a0796e0c5de52cd1d6c7541e5c2c7c47f2cd"}, {"sha": "af503be3685ae925edefe96d0f160369520e7b5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/af503be3685ae925edefe96d0f160369520e7b5a", "html_url": "https://github.com/rust-lang/rust/commit/af503be3685ae925edefe96d0f160369520e7b5a"}], "stats": {"total": 667, "additions": 653, "deletions": 14}, "files": [{"sha": "52eb9f29d57a1856ad66023fee7d68e65f4ceca5", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=ddab91a5debadfda47c057117c8b498a31abaae7", "patch": "@@ -19,7 +19,10 @@ macro_rules! panic {\n     ($msg:expr) => ({\n         $crate::panicking::panic(&($msg, file!(), line!(), __rust_unstable_column!()))\n     });\n-    ($fmt:expr, $($arg:tt)*) => ({\n+    ($msg:expr,) => (\n+        panic!($msg)\n+    );\n+    ($fmt:expr, $($arg:tt)+) => ({\n         $crate::panicking::panic_fmt(format_args!($fmt, $($arg)*),\n                                      &(file!(), line!(), __rust_unstable_column!()))\n     });\n@@ -79,6 +82,9 @@ macro_rules! assert {\n             panic!(concat!(\"assertion failed: \", stringify!($cond)))\n         }\n     );\n+    ($cond:expr,) => (\n+        assert!($cond)\n+    );\n     ($cond:expr, $($arg:tt)+) => (\n         if !$cond {\n             panic!($($arg)+)\n@@ -359,7 +365,8 @@ macro_rules! try {\n         $crate::result::Result::Err(err) => {\n             return $crate::result::Result::Err($crate::convert::From::from(err))\n         }\n-    })\n+    });\n+    ($expr:expr,) => (try!($expr));\n }\n \n /// Write formatted data into a buffer.\n@@ -456,6 +463,9 @@ macro_rules! writeln {\n     ($dst:expr) => (\n         write!($dst, \"\\n\")\n     );\n+    ($dst:expr,) => (\n+        writeln!($dst)\n+    );\n     ($dst:expr, $fmt:expr) => (\n         write!($dst, concat!($fmt, \"\\n\"))\n     );\n@@ -524,6 +534,9 @@ macro_rules! unreachable {\n     ($msg:expr) => ({\n         unreachable!(\"{}\", $msg)\n     });\n+    ($msg:expr,) => ({\n+        unreachable!($msg)\n+    });\n     ($fmt:expr, $($arg:tt)*) => ({\n         panic!(concat!(\"internal error: entered unreachable code: \", $fmt), $($arg)*)\n     });\n@@ -603,7 +616,10 @@ mod builtin {\n     #[stable(feature = \"compile_error_macro\", since = \"1.20.0\")]\n     #[macro_export]\n     #[cfg(dox)]\n-    macro_rules! compile_error { ($msg:expr) => ({ /* compiler built-in */ }) }\n+    macro_rules! compile_error {\n+        ($msg:expr) => ({ /* compiler built-in */ });\n+        ($msg:expr,) => ({ /* compiler built-in */ });\n+    }\n \n     /// The core macro for formatted string creation & output.\n     ///\n@@ -639,7 +655,10 @@ mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n     #[cfg(dox)]\n-    macro_rules! option_env { ($name:expr) => ({ /* compiler built-in */ }) }\n+    macro_rules! option_env {\n+        ($name:expr) => ({ /* compiler built-in */ });\n+        ($name:expr,) => ({ /* compiler built-in */ });\n+    }\n \n     /// Concatenate identifiers into one identifier.\n     ///\n@@ -715,7 +734,10 @@ mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n     #[cfg(dox)]\n-    macro_rules! include_str { ($file:expr) => ({ /* compiler built-in */ }) }\n+    macro_rules! include_str {\n+        ($file:expr) => ({ /* compiler built-in */ });\n+        ($file:expr,) => ({ /* compiler built-in */ });\n+    }\n \n     /// Includes a file as a reference to a byte array.\n     ///\n@@ -725,7 +747,10 @@ mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n     #[cfg(dox)]\n-    macro_rules! include_bytes { ($file:expr) => ({ /* compiler built-in */ }) }\n+    macro_rules! include_bytes {\n+        ($file:expr) => ({ /* compiler built-in */ });\n+        ($file:expr,) => ({ /* compiler built-in */ });\n+    }\n \n     /// Expands to a string that represents the current module path.\n     ///\n@@ -755,5 +780,8 @@ mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n     #[cfg(dox)]\n-    macro_rules! include { ($file:expr) => ({ /* compiler built-in */ }) }\n+    macro_rules! include {\n+        ($file:expr) => ({ /* compiler built-in */ });\n+        ($file:expr,) => ({ /* compiler built-in */ });\n+    }\n }"}, {"sha": "a18c811d19634bfa789e732e7c65d9ca64b364f6", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=ddab91a5debadfda47c057117c8b498a31abaae7", "patch": "@@ -68,6 +68,9 @@ macro_rules! panic {\n     ($msg:expr) => ({\n         $crate::rt::begin_panic($msg, &(file!(), line!(), __rust_unstable_column!()))\n     });\n+    ($msg:expr,) => ({\n+        panic!($msg)\n+    });\n     ($fmt:expr, $($arg:tt)+) => ({\n         $crate::rt::begin_panic_fmt(&format_args!($fmt, $($arg)+),\n                                     &(file!(), line!(), __rust_unstable_column!()))\n@@ -312,7 +315,10 @@ pub mod builtin {\n     /// ```\n     #[stable(feature = \"compile_error_macro\", since = \"1.20.0\")]\n     #[macro_export]\n-    macro_rules! compile_error { ($msg:expr) => ({ /* compiler built-in */ }) }\n+    macro_rules! compile_error {\n+        ($msg:expr) => ({ /* compiler built-in */ });\n+        ($msg:expr,) => ({ /* compiler built-in */ });\n+    }\n \n     /// The core macro for formatted string creation & output.\n     ///\n@@ -400,7 +406,10 @@ pub mod builtin {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n-    macro_rules! option_env { ($name:expr) => ({ /* compiler built-in */ }) }\n+    macro_rules! option_env {\n+        ($name:expr) => ({ /* compiler built-in */ });\n+        ($name:expr,) => ({ /* compiler built-in */ });\n+    }\n \n     /// Concatenate identifiers into one identifier.\n     ///\n@@ -580,7 +589,10 @@ pub mod builtin {\n     /// Compiling 'main.rs' and running the resulting binary will print \"adi\u00f3s\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n-    macro_rules! include_str { ($file:expr) => ({ /* compiler built-in */ }) }\n+    macro_rules! include_str {\n+        ($file:expr) => ({ /* compiler built-in */ });\n+        ($file:expr,) => ({ /* compiler built-in */ });\n+    }\n \n     /// Includes a file as a reference to a byte array.\n     ///\n@@ -614,7 +626,10 @@ pub mod builtin {\n     /// Compiling 'main.rs' and running the resulting binary will print \"adi\u00f3s\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n-    macro_rules! include_bytes { ($file:expr) => ({ /* compiler built-in */ }) }\n+    macro_rules! include_bytes {\n+        ($file:expr) => ({ /* compiler built-in */ });\n+        ($file:expr,) => ({ /* compiler built-in */ });\n+    }\n \n     /// Expands to a string that represents the current module path.\n     ///\n@@ -700,7 +715,10 @@ pub mod builtin {\n     /// \"\ud83d\ude48\ud83d\ude4a\ud83d\ude49\ud83d\ude48\ud83d\ude4a\ud83d\ude49\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n-    macro_rules! include { ($file:expr) => ({ /* compiler built-in */ }) }\n+    macro_rules! include {\n+        ($file:expr) => ({ /* compiler built-in */ });\n+        ($file:expr,) => ({ /* compiler built-in */ });\n+    }\n }\n \n /// A macro for defining #[cfg] if-else statements."}, {"sha": "520ec942e42886f18df157c653874649b31f0fe2", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=ddab91a5debadfda47c057117c8b498a31abaae7", "patch": "@@ -890,8 +890,8 @@ pub fn check_zero_tts(cx: &ExtCtxt,\n     }\n }\n \n-/// Extract the string literal from the first token of `tts`. If this\n-/// is not a string literal, emit an error and return None.\n+/// Interpreting `tts` as a comma-separated sequence of expressions,\n+/// expect exactly one string literal, or emit an error and return None.\n pub fn get_single_str_from_tts(cx: &mut ExtCtxt,\n                                sp: Span,\n                                tts: &[tokenstream::TokenTree],\n@@ -903,6 +903,8 @@ pub fn get_single_str_from_tts(cx: &mut ExtCtxt,\n         return None\n     }\n     let ret = panictry!(p.parse_expr());\n+    let _ = p.eat(&token::Comma);\n+\n     if p.token != token::Eof {\n         cx.span_err(sp, &format!(\"{} takes 1 argument\", name));\n     }"}, {"sha": "1eeba9b30b8e24f5a481a2fd3011c47d10e22d77", "filename": "src/libsyntax_ext/cfg.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Flibsyntax_ext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Flibsyntax_ext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcfg.rs?ref=ddab91a5debadfda47c057117c8b498a31abaae7", "patch": "@@ -28,6 +28,8 @@ pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n     let mut p = cx.new_parser_from_tts(tts);\n     let cfg = panictry!(p.parse_meta_item());\n \n+    let _ = p.eat(&token::Comma);\n+\n     if !p.eat(&token::Eof) {\n         cx.span_err(sp, \"expected 1 cfg-pattern\");\n         return DummyResult::expr(sp);"}, {"sha": "620e57b463d1a5a1f6182ec4f33af3997bf8b481", "filename": "src/test/compile-fail/macro-comma-behavior.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Ftest%2Fcompile-fail%2Fmacro-comma-behavior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Ftest%2Fcompile-fail%2Fmacro-comma-behavior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-comma-behavior.rs?ref=ddab91a5debadfda47c057117c8b498a31abaae7", "patch": "@@ -0,0 +1,101 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Companion test to the similarly-named file in run-pass.\n+\n+// compile-flags: -C debug_assertions=yes\n+// revisions: std core\n+\n+#![cfg_attr(core, no_std)]\n+\n+#[cfg(std)] use std::fmt;\n+#[cfg(core)] use core::fmt;\n+\n+// (see documentation of the similarly-named test in run-pass)\n+fn to_format_or_not_to_format() {\n+    let falsum = || false;\n+\n+    // assert!(true, \"{}\",); // see run-pass\n+\n+    assert_eq!(1, 1, \"{}\",);\n+    //[core]~^ ERROR no arguments\n+    //[std]~^^ ERROR no arguments\n+    assert_ne!(1, 2, \"{}\",);\n+    //[core]~^ ERROR no arguments\n+    //[std]~^^ ERROR no arguments\n+\n+    // debug_assert!(true, \"{}\",); // see run-pass\n+\n+    debug_assert_eq!(1, 1, \"{}\",);\n+    //[core]~^ ERROR no arguments\n+    //[std]~^^ ERROR no arguments\n+    debug_assert_ne!(1, 2, \"{}\",);\n+    //[core]~^ ERROR no arguments\n+    //[std]~^^ ERROR no arguments\n+\n+    #[cfg(std)] {\n+        eprint!(\"{}\",);\n+        //[std]~^ ERROR no arguments\n+    }\n+\n+    #[cfg(std)] {\n+        // FIXME: compile-fail says \"expected error not found\" even though\n+        //        rustc does emit an error\n+        // eprintln!(\"{}\",);\n+        // <DISABLED> [std]~^ ERROR no arguments\n+    }\n+\n+    #[cfg(std)] {\n+        format!(\"{}\",);\n+        //[std]~^ ERROR no arguments\n+    }\n+\n+    format_args!(\"{}\",);\n+    //[core]~^ ERROR no arguments\n+    //[std]~^^ ERROR no arguments\n+\n+    // if falsum() { panic!(\"{}\",); } // see run-pass\n+\n+    #[cfg(std)] {\n+        print!(\"{}\",);\n+        //[std]~^ ERROR no arguments\n+    }\n+\n+    #[cfg(std)] {\n+        // FIXME: compile-fail says \"expected error not found\" even though\n+        //        rustc does emit an error\n+        // println!(\"{}\",);\n+        // <DISABLED> [std]~^ ERROR no arguments\n+    }\n+\n+    unimplemented!(\"{}\",);\n+    //[core]~^ ERROR no arguments\n+    //[std]~^^ ERROR no arguments\n+\n+    // if falsum() { unreachable!(\"{}\",); } // see run-pass\n+\n+    struct S;\n+    impl fmt::Display for S {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            write!(f, \"{}\",)?;\n+            //[core]~^ ERROR no arguments\n+            //[std]~^^ ERROR no arguments\n+\n+            // FIXME: compile-fail says \"expected error not found\" even though\n+            //        rustc does emit an error\n+            // writeln!(f, \"{}\",)?;\n+            // <DISABLED> [core]~^ ERROR no arguments\n+            // <DISABLED> [std]~^^ ERROR no arguments\n+            Ok(())\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "e5fe9b4dd7f10ac36379f6ab37e7688286e3e5fa", "filename": "src/test/compile-fail/macro-comma-support.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Ftest%2Fcompile-fail%2Fmacro-comma-support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Ftest%2Fcompile-fail%2Fmacro-comma-support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-comma-support.rs?ref=ddab91a5debadfda47c057117c8b498a31abaae7", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is a companion to the similarly-named test in run-pass.\n+//\n+// It tests macros that unavoidably produce compile errors.\n+\n+fn compile_error() {\n+    compile_error!(\"lel\"); //~ ERROR lel\n+    compile_error!(\"lel\",); //~ ERROR lel\n+}\n+\n+fn main() {}"}, {"sha": "6eafd520a726bca51b74c65fed490fecbe31b44e", "filename": "src/test/run-pass/auxiliary/macro-comma-support.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Ftest%2Frun-pass%2Fauxiliary%2Fmacro-comma-support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Ftest%2Frun-pass%2Fauxiliary%2Fmacro-comma-support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fmacro-comma-support.rs?ref=ddab91a5debadfda47c057117c8b498a31abaae7", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+()"}, {"sha": "2a434009e134faf612afaf554300062ba76ef935", "filename": "src/test/run-pass/macro-comma-behavior.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Ftest%2Frun-pass%2Fmacro-comma-behavior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Ftest%2Frun-pass%2Fmacro-comma-behavior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-comma-behavior.rs?ref=ddab91a5debadfda47c057117c8b498a31abaae7", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ideally, any macro call with a trailing comma should behave\n+// identically to a call without the comma.\n+//\n+// This checks the behavior of macros with trailing commas in key\n+// places where regressions in behavior seem highly possible (due\n+// to it being e.g. a place where the addition of an argument\n+// causes it to go down a code path with subtly different behavior).\n+//\n+// There is a companion test in compile-fail.\n+\n+// compile-flags: --test -C debug_assertions=yes\n+// revisions: std core\n+\n+#![cfg_attr(core, no_std)]\n+\n+#[cfg(std)] use std::fmt;\n+#[cfg(core)] use core::fmt;\n+\n+// an easy mistake in the implementation of 'assert!'\n+// would cause this to say \"explicit panic\"\n+#[test]\n+#[should_panic(expected = \"assertion failed\")]\n+fn assert_1arg() {\n+    assert!(false,);\n+}\n+\n+// same as 'assert_1arg'\n+#[test]\n+#[should_panic(expected = \"assertion failed\")]\n+fn debug_assert_1arg() {\n+    debug_assert!(false,);\n+}\n+\n+// make sure we don't accidentally forward to `write!(\"text\")`\n+#[cfg(std)]\n+#[test]\n+fn writeln_1arg() {\n+    use fmt::Write;\n+\n+    let mut s = String::new();\n+    writeln!(&mut s,).unwrap();\n+    assert_eq!(&s, \"\\n\");\n+}\n+\n+// A number of format_args-like macros have special-case treatment\n+// for a single message string, which is not formatted.\n+//\n+// This test ensures that the addition of a trailing comma does not\n+// suddenly cause these strings to get formatted when they otherwise\n+// would not be. This is an easy mistake to make by having such a macro\n+// accept \", $($tok:tt)*\" instead of \", $($tok:tt)+\" after its minimal\n+// set of arguments.\n+//\n+// (Example: Issue #48042)\n+#[test]\n+fn to_format_or_not_to_format() {\n+    // (\"{}\" is the easiest string to test because if this gets\n+    // sent to format_args!, it'll simply fail to compile.\n+    // \"{{}}\" is an example of an input that could compile and\n+    // produce an incorrect program, but testing the panics\n+    // would be burdensome.)\n+    let falsum = || false;\n+\n+    assert!(true, \"{}\",);\n+\n+    // assert_eq!(1, 1, \"{}\",); // see compile-fail\n+    // assert_ne!(1, 2, \"{}\",); // see compile-fail\n+\n+    debug_assert!(true, \"{}\",);\n+\n+    // debug_assert_eq!(1, 1, \"{}\",); // see compile-fail\n+    // debug_assert_ne!(1, 2, \"{}\",); // see compile-fail\n+    // eprint!(\"{}\",); // see compile-fail\n+    // eprintln!(\"{}\",); // see compile-fail\n+    // format!(\"{}\",); // see compile-fail\n+    // format_args!(\"{}\",); // see compile-fail\n+\n+    if falsum() { panic!(\"{}\",); }\n+\n+    // print!(\"{}\",); // see compile-fail\n+    // println!(\"{}\",); // see compile-fail\n+    // unimplemented!(\"{}\",); // see compile-fail\n+\n+    if falsum() { unreachable!(\"{}\",); }\n+\n+    // write!(&mut stdout, \"{}\",); // see compile-fail\n+    // writeln!(&mut stdout, \"{}\",); // see compile-fail\n+}"}, {"sha": "bfd911002a0ee5abaebc2a3cf7f007365691b733", "filename": "src/test/run-pass/macro-comma-support.rs", "status": "added", "additions": 359, "deletions": 0, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Ftest%2Frun-pass%2Fmacro-comma-support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Ftest%2Frun-pass%2Fmacro-comma-support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-comma-support.rs?ref=ddab91a5debadfda47c057117c8b498a31abaae7", "patch": "@@ -0,0 +1,359 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is meant to be a comprehensive test of invocations with/without\n+// trailing commas (or other, similar optionally-trailing separators).\n+// Every macro is accounted for, even those not tested in this file.\n+// (There will be a note indicating why).\n+\n+// std and core are both tested because they may contain separate\n+// implementations for some macro_rules! macros as an implementation\n+// detail.\n+\n+// ignore-pretty issue #37195\n+\n+// compile-flags: --test -C debug_assertions=yes\n+// revisions: std core\n+\n+#![cfg_attr(core, no_std)]\n+\n+#![feature(concat_idents)]\n+\n+#[cfg(std)] use std::fmt;\n+#[cfg(core)] use core::fmt;\n+\n+#[test]\n+fn assert() {\n+    assert!(true);\n+    assert!(true,);\n+    assert!(true, \"hello\");\n+    assert!(true, \"hello\",);\n+    assert!(true, \"hello {}\", \"world\");\n+    assert!(true, \"hello {}\", \"world\",);\n+}\n+\n+#[test]\n+fn assert_eq() {\n+    assert_eq!(1, 1);\n+    assert_eq!(1, 1,);\n+    assert_eq!(1, 1, \"hello\");\n+    assert_eq!(1, 1, \"hello\",);\n+    assert_eq!(1, 1, \"hello {}\", \"world\");\n+    assert_eq!(1, 1, \"hello {}\", \"world\",);\n+}\n+\n+#[test]\n+fn assert_ne() {\n+    assert_ne!(1, 2);\n+    assert_ne!(1, 2,);\n+    assert_ne!(1, 2, \"hello\");\n+    assert_ne!(1, 2, \"hello\",);\n+    assert_ne!(1, 2, \"hello {}\", \"world\");\n+    assert_ne!(1, 2, \"hello {}\", \"world\",);\n+}\n+\n+#[test]\n+fn cfg() {\n+    let _ = cfg!(pants);\n+    let _ = cfg!(pants,);\n+    let _ = cfg!(pants = \"pants\");\n+    let _ = cfg!(pants = \"pants\",);\n+    let _ = cfg!(all(pants));\n+    let _ = cfg!(all(pants),);\n+    let _ = cfg!(all(pants,));\n+    let _ = cfg!(all(pants,),);\n+}\n+\n+#[test]\n+fn column() {\n+    let _ = column!();\n+}\n+\n+// compile_error! is in a companion to this test in compile-fail\n+\n+#[test]\n+fn concat() {\n+    let _ = concat!();\n+    let _ = concat!(\"hello\");\n+    let _ = concat!(\"hello\",);\n+    let _ = concat!(\"hello\", \" world\");\n+    let _ = concat!(\"hello\", \" world\",);\n+}\n+\n+#[test]\n+fn concat_idents() {\n+    fn foo() {}\n+    fn foobar() {}\n+\n+    concat_idents!(foo)();\n+    concat_idents!(foo,)();\n+    concat_idents!(foo, bar)();\n+    concat_idents!(foo, bar,)();\n+}\n+\n+#[test]\n+fn debug_assert() {\n+    debug_assert!(true);\n+    debug_assert!(true, );\n+    debug_assert!(true, \"hello\");\n+    debug_assert!(true, \"hello\",);\n+    debug_assert!(true, \"hello {}\", \"world\");\n+    debug_assert!(true, \"hello {}\", \"world\",);\n+}\n+\n+#[test]\n+fn debug_assert_eq() {\n+    debug_assert_eq!(1, 1);\n+    debug_assert_eq!(1, 1,);\n+    debug_assert_eq!(1, 1, \"hello\");\n+    debug_assert_eq!(1, 1, \"hello\",);\n+    debug_assert_eq!(1, 1, \"hello {}\", \"world\");\n+    debug_assert_eq!(1, 1, \"hello {}\", \"world\",);\n+}\n+\n+#[test]\n+fn debug_assert_ne() {\n+    debug_assert_ne!(1, 2);\n+    debug_assert_ne!(1, 2,);\n+    debug_assert_ne!(1, 2, \"hello\");\n+    debug_assert_ne!(1, 2, \"hello\",);\n+    debug_assert_ne!(1, 2, \"hello {}\", \"world\");\n+    debug_assert_ne!(1, 2, \"hello {}\", \"world\",);\n+}\n+\n+#[test]\n+fn env() {\n+    let _ = env!(\"PATH\");\n+    let _ = env!(\"PATH\",);\n+    let _ = env!(\"PATH\", \"not found\");\n+    let _ = env!(\"PATH\", \"not found\",);\n+}\n+\n+#[cfg(std)]\n+#[test]\n+fn eprint() {\n+    eprint!(\"hello\");\n+    eprint!(\"hello\",);\n+    eprint!(\"hello {}\", \"world\");\n+    eprint!(\"hello {}\", \"world\",);\n+}\n+\n+#[cfg(std)]\n+#[test]\n+fn eprintln() {\n+    eprintln!();\n+    eprintln!(\"hello\");\n+    eprintln!(\"hello\",);\n+    eprintln!(\"hello {}\", \"world\");\n+    eprintln!(\"hello {}\", \"world\",);\n+}\n+\n+#[test]\n+fn file() {\n+    let _ = file!();\n+}\n+\n+#[cfg(std)]\n+#[test]\n+fn format() {\n+    let _ = format!(\"hello\");\n+    let _ = format!(\"hello\",);\n+    let _ = format!(\"hello {}\", \"world\");\n+    let _ = format!(\"hello {}\", \"world\",);\n+}\n+\n+#[test]\n+fn format_args() {\n+    let _ = format_args!(\"hello\");\n+    let _ = format_args!(\"hello\",);\n+    let _ = format_args!(\"hello {}\", \"world\");\n+    let _ = format_args!(\"hello {}\", \"world\",);\n+}\n+\n+#[test]\n+fn include() {\n+    let _ = include!(\"auxiliary/macro-comma-support.rs\");\n+    let _ = include!(\"auxiliary/macro-comma-support.rs\",);\n+}\n+\n+#[test]\n+fn include_bytes() {\n+    let _ = include_bytes!(\"auxiliary/macro-comma-support.rs\");\n+    let _ = include_bytes!(\"auxiliary/macro-comma-support.rs\",);\n+}\n+\n+#[test]\n+fn include_str() {\n+    let _ = include_str!(\"auxiliary/macro-comma-support.rs\");\n+    let _ = include_str!(\"auxiliary/macro-comma-support.rs\",);\n+}\n+\n+#[test]\n+fn line() {\n+    let _ = line!();\n+}\n+\n+#[test]\n+fn module_path() {\n+    let _ = module_path!();\n+}\n+\n+#[test]\n+fn option_env() {\n+    let _ = option_env!(\"PATH\");\n+    let _ = option_env!(\"PATH\",);\n+}\n+\n+#[test]\n+fn panic() {\n+    // prevent 'unreachable code' warnings\n+    let falsum = || false;\n+\n+    if falsum() { panic!(); }\n+    if falsum() { panic!(\"hello\"); }\n+    if falsum() { panic!(\"hello\",); }\n+    if falsum() { panic!(\"hello {}\", \"world\"); }\n+    if falsum() { panic!(\"hello {}\", \"world\",); }\n+}\n+\n+#[cfg(std)]\n+#[test]\n+fn print() {\n+    print!(\"hello\");\n+    print!(\"hello\",);\n+    print!(\"hello {}\", \"world\");\n+    print!(\"hello {}\", \"world\",);\n+}\n+\n+#[cfg(std)]\n+#[test]\n+fn println() {\n+    println!();\n+    println!(\"hello\");\n+    println!(\"hello\",);\n+    println!(\"hello {}\", \"world\");\n+    println!(\"hello {}\", \"world\",);\n+}\n+\n+// select! is too troublesome and unlikely to be stabilized\n+\n+// stringify! is N/A\n+\n+#[cfg(std)]\n+#[test]\n+fn thread_local() {\n+    // this has an optional trailing *semicolon*\n+    thread_local! {\n+        #[allow(unused)] pub static A: () = ()\n+    }\n+\n+    thread_local! {\n+        #[allow(unused)] pub static AA: () = ();\n+    }\n+\n+    thread_local! {\n+        #[allow(unused)] pub static AAA: () = ();\n+        #[allow(unused)] pub static AAAA: () = ()\n+    }\n+\n+    thread_local! {\n+        #[allow(unused)] pub static AAAAG: () = ();\n+        #[allow(unused)] pub static AAAAGH: () = ();\n+    }\n+}\n+\n+#[test]\n+fn try() {\n+    fn inner() -> Result<(), ()> {\n+        try!(Ok(()));\n+        try!(Ok(()),);\n+        Ok(())\n+    }\n+\n+    inner().unwrap();\n+}\n+\n+#[test]\n+fn unimplemented() {\n+    // prevent 'unreachable code' warnings\n+    let falsum = || false;\n+\n+    if falsum() { unimplemented!(); }\n+    if falsum() { unimplemented!(\"hello\"); }\n+    if falsum() { unimplemented!(\"hello\",); }\n+    if falsum() { unimplemented!(\"hello {}\", \"world\"); }\n+    if falsum() { unimplemented!(\"hello {}\", \"world\",); }\n+}\n+\n+#[test]\n+fn unreachable() {\n+    // prevent 'unreachable code' warnings\n+    let falsum = || false;\n+\n+    if falsum() { unreachable!(); }\n+    if falsum() { unreachable!(\"hello\"); }\n+    if falsum() { unreachable!(\"hello\",); }\n+    if falsum() { unreachable!(\"hello {}\", \"world\"); }\n+    if falsum() { unreachable!(\"hello {}\", \"world\",); }\n+}\n+\n+#[cfg(std)]\n+#[test]\n+fn vec() {\n+    let _: Vec<()> = vec![];\n+    let _ = vec![0];\n+    let _ = vec![0,];\n+    let _ = vec![0, 1];\n+    let _ = vec![0, 1,];\n+}\n+\n+// give a test body access to a fmt::Formatter, which seems\n+// to be the easiest way to use 'write!' on core.\n+macro_rules! test_with_formatter {\n+    (\n+        #[test]\n+        fn $fname:ident($f:ident: &mut fmt::Formatter) $block:block\n+    ) => {\n+        #[test]\n+        fn $fname() {\n+            struct Struct;\n+            impl fmt::Display for Struct {\n+                fn fmt(&self, $f: &mut fmt::Formatter) -> fmt::Result {\n+                    Ok($block)\n+                }\n+            }\n+\n+            // suppress \"unused\"\n+            assert!(true, \"{}\", Struct);\n+        }\n+    };\n+}\n+\n+test_with_formatter! {\n+    #[test]\n+    fn write(f: &mut fmt::Formatter) {\n+        let _ = write!(f, \"hello\");\n+        let _ = write!(f, \"hello\",);\n+        let _ = write!(f, \"hello {}\", \"world\");\n+        let _ = write!(f, \"hello {}\", \"world\",);\n+    }\n+}\n+\n+test_with_formatter! {\n+    #[test]\n+    fn writeln(f: &mut fmt::Formatter) {\n+        let _ = writeln!(f);\n+        let _ = writeln!(f,);\n+        let _ = writeln!(f, \"hello\");\n+        let _ = writeln!(f, \"hello\",);\n+        let _ = writeln!(f, \"hello {}\", \"world\");\n+        let _ = writeln!(f, \"hello {}\", \"world\",);\n+    }\n+}"}]}