{"sha": "a822d08bd1145f14838b5483582b574c8c12df52", "node_id": "C_kwDOAAsO6NoAKGE4MjJkMDhiZDExNDVmMTQ4MzhiNTQ4MzU4MmI1NzRjOGMxMmRmNTI", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-09-30T06:51:35Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-10-03T00:42:29Z"}, "message": "Remove `TokenStreamBuilder`.\n\nIt's now only used in one function. Also, the \"should we glue the\ntokens?\" check is only necessary when pushing a `TokenTree::Token`, not\nwhen pushing a `TokenTree::Delimited`.\n\nAs part of this, we now do the \"should we glue the tokens?\" check\nimmediately, which avoids having look back at the previous token. It\nalso puts all the logic dealing with token gluing in a single place.", "tree": {"sha": "f92987ae868873841e1b1bc00b6cb4effbf87497", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f92987ae868873841e1b1bc00b6cb4effbf87497"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a822d08bd1145f14838b5483582b574c8c12df52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a822d08bd1145f14838b5483582b574c8c12df52", "html_url": "https://github.com/rust-lang/rust/commit/a822d08bd1145f14838b5483582b574c8c12df52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a822d08bd1145f14838b5483582b574c8c12df52/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d0754d602d8d6fd2b357d98ee0bdaf2382b937a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d0754d602d8d6fd2b357d98ee0bdaf2382b937a", "html_url": "https://github.com/rust-lang/rust/commit/8d0754d602d8d6fd2b357d98ee0bdaf2382b937a"}], "stats": {"total": 57, "additions": 20, "deletions": 37}, "files": [{"sha": "0af52043d3759787539d1141c2c7629cad558450", "filename": "compiler/rustc_parse/src/lexer/tokentrees.rs", "status": "modified", "additions": 20, "deletions": 37, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/a822d08bd1145f14838b5483582b574c8c12df52/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a822d08bd1145f14838b5483582b574c8c12df52/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs?ref=a822d08bd1145f14838b5483582b574c8c12df52", "patch": "@@ -47,13 +47,13 @@ impl<'a> TokenTreesReader<'a> {\n     // Parse a stream of tokens into a list of `TokenTree`s.\n     fn parse_token_trees(&mut self, is_top_level: bool) -> PResult<'a, TokenStream> {\n         self.token = self.string_reader.next_token().0;\n-        let mut buf = TokenStreamBuilder::default();\n+        let mut buf = Vec::new();\n         loop {\n             match self.token.kind {\n                 token::OpenDelim(delim) => buf.push(self.parse_token_tree_open_delim(delim)),\n                 token::CloseDelim(delim) => {\n                     return if !is_top_level {\n-                        Ok(buf.into_token_stream())\n+                        Ok(TokenStream::new(buf))\n                     } else {\n                         Err(self.close_delim_err(delim))\n                     };\n@@ -62,21 +62,28 @@ impl<'a> TokenTreesReader<'a> {\n                     if !is_top_level {\n                         self.eof_err().emit();\n                     }\n-                    return Ok(buf.into_token_stream());\n+                    return Ok(TokenStream::new(buf));\n                 }\n                 _ => {\n-                    // `this_spacing` for the returned token refers to whether the token is\n-                    // immediately followed by another op token. It is determined by the\n-                    // next token: its kind and its `preceded_by_whitespace` status.\n-                    let (next_tok, is_next_tok_preceded_by_whitespace) =\n-                        self.string_reader.next_token();\n-                    let this_spacing = if is_next_tok_preceded_by_whitespace || !next_tok.is_op() {\n-                        Spacing::Alone\n-                    } else {\n-                        Spacing::Joint\n+                    // Get the next normal token. This might require getting multiple adjacent\n+                    // single-char tokens and joining them together.\n+                    let (this_spacing, next_tok) = loop {\n+                        let (next_tok, is_next_tok_preceded_by_whitespace) =\n+                            self.string_reader.next_token();\n+                        if !is_next_tok_preceded_by_whitespace {\n+                            if let Some(glued) = self.token.glue(&next_tok) {\n+                                self.token = glued;\n+                            } else {\n+                                let this_spacing =\n+                                    if next_tok.is_op() { Spacing::Joint } else { Spacing::Alone };\n+                                break (this_spacing, next_tok);\n+                            }\n+                        } else {\n+                            break (Spacing::Alone, next_tok);\n+                        }\n                     };\n                     let this_tok = std::mem::replace(&mut self.token, next_tok);\n-                    buf.push(TokenTree::Token(this_tok, this_spacing))\n+                    buf.push(TokenTree::Token(this_tok, this_spacing));\n                 }\n             }\n         }\n@@ -249,27 +256,3 @@ impl<'a> TokenTreesReader<'a> {\n         err\n     }\n }\n-\n-#[derive(Default)]\n-struct TokenStreamBuilder {\n-    buf: Vec<TokenTree>,\n-}\n-\n-impl TokenStreamBuilder {\n-    #[inline(always)]\n-    fn push(&mut self, tree: TokenTree) {\n-        if let Some(TokenTree::Token(prev_token, Spacing::Joint)) = self.buf.last()\n-            && let TokenTree::Token(token, joint) = &tree\n-            && let Some(glued) = prev_token.glue(token)\n-        {\n-            self.buf.pop();\n-            self.buf.push(TokenTree::Token(glued, *joint));\n-        } else {\n-            self.buf.push(tree)\n-        }\n-    }\n-\n-    fn into_token_stream(self) -> TokenStream {\n-        TokenStream::new(self.buf)\n-    }\n-}"}]}