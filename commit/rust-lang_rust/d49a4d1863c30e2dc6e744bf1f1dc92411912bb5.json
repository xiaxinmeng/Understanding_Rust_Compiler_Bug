{"sha": "d49a4d1863c30e2dc6e744bf1f1dc92411912bb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0OWE0ZDE4NjNjMzBlMmRjNmU3NDRiZjFmMWRjOTI0MTE5MTJiYjU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-03T17:36:39Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-03T17:40:27Z"}, "message": "Rename NameDefinition -> Definition", "tree": {"sha": "66a368988b4f3e698c6ec71309ffb4155a725331", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66a368988b4f3e698c6ec71309ffb4155a725331"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d49a4d1863c30e2dc6e744bf1f1dc92411912bb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d49a4d1863c30e2dc6e744bf1f1dc92411912bb5", "html_url": "https://github.com/rust-lang/rust/commit/d49a4d1863c30e2dc6e744bf1f1dc92411912bb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d49a4d1863c30e2dc6e744bf1f1dc92411912bb5/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13b25d73b56ede36d1680efc19f5c11b0669b96c", "url": "https://api.github.com/repos/rust-lang/rust/commits/13b25d73b56ede36d1680efc19f5c11b0669b96c", "html_url": "https://github.com/rust-lang/rust/commit/13b25d73b56ede36d1680efc19f5c11b0669b96c"}], "stats": {"total": 209, "additions": 103, "deletions": 106}, "files": [{"sha": "c9c14561a8c247df7ce24bb0d6186e21bd1d2882", "filename": "crates/ra_ide/src/display/navigation_target.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d49a4d1863c30e2dc6e744bf1f1dc92411912bb5/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d49a4d1863c30e2dc6e744bf1f1dc92411912bb5/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=d49a4d1863c30e2dc6e744bf1f1dc92411912bb5", "patch": "@@ -13,7 +13,7 @@ use ra_syntax::{\n \n use crate::{\n     // expand::original_range,\n-    references::NameDefinition,\n+    references::Definition,\n     FileSymbol,\n };\n \n@@ -189,15 +189,15 @@ impl ToNav for FileSymbol {\n     }\n }\n \n-impl TryToNav for NameDefinition {\n+impl TryToNav for Definition {\n     fn try_to_nav(&self, db: &RootDatabase) -> Option<NavigationTarget> {\n         match self {\n-            NameDefinition::Macro(it) => Some(it.to_nav(db)),\n-            NameDefinition::StructField(it) => Some(it.to_nav(db)),\n-            NameDefinition::ModuleDef(it) => it.try_to_nav(db),\n-            NameDefinition::SelfType(it) => Some(it.to_nav(db)),\n-            NameDefinition::Local(it) => Some(it.to_nav(db)),\n-            NameDefinition::TypeParam(it) => Some(it.to_nav(db)),\n+            Definition::Macro(it) => Some(it.to_nav(db)),\n+            Definition::StructField(it) => Some(it.to_nav(db)),\n+            Definition::ModuleDef(it) => it.try_to_nav(db),\n+            Definition::SelfType(it) => Some(it.to_nav(db)),\n+            Definition::Local(it) => Some(it.to_nav(db)),\n+            Definition::TypeParam(it) => Some(it.to_nav(db)),\n         }\n     }\n }"}, {"sha": "26c8996bc13ae2e657b8bb0e14396f1445a0698e", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d49a4d1863c30e2dc6e744bf1f1dc92411912bb5/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d49a4d1863c30e2dc6e744bf1f1dc92411912bb5/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=d49a4d1863c30e2dc6e744bf1f1dc92411912bb5", "patch": "@@ -2,7 +2,7 @@\n \n use hir::{Adt, HasSource, HirDisplay, Semantics};\n use ra_ide_db::{\n-    defs::{classify_name, NameDefinition},\n+    defs::{classify_name, Definition},\n     RootDatabase,\n };\n use ra_syntax::{\n@@ -92,20 +92,20 @@ fn hover_text(docs: Option<String>, desc: Option<String>) -> Option<String> {\n     }\n }\n \n-fn hover_text_from_name_kind(db: &RootDatabase, def: NameDefinition) -> Option<String> {\n+fn hover_text_from_name_kind(db: &RootDatabase, def: Definition) -> Option<String> {\n     return match def {\n-        NameDefinition::Macro(it) => {\n+        Definition::Macro(it) => {\n             let src = it.source(db);\n             hover_text(src.value.doc_comment_text(), Some(macro_label(&src.value)))\n         }\n-        NameDefinition::StructField(it) => {\n+        Definition::StructField(it) => {\n             let src = it.source(db);\n             match src.value {\n                 hir::FieldSource::Named(it) => hover_text(it.doc_comment_text(), it.short_label()),\n                 _ => None,\n             }\n         }\n-        NameDefinition::ModuleDef(it) => match it {\n+        Definition::ModuleDef(it) => match it {\n             hir::ModuleDef::Module(it) => match it.definition_source(db).value {\n                 hir::ModuleSource::Module(it) => {\n                     hover_text(it.doc_comment_text(), it.short_label())\n@@ -123,10 +123,10 @@ fn hover_text_from_name_kind(db: &RootDatabase, def: NameDefinition) -> Option<S\n             hir::ModuleDef::TypeAlias(it) => from_def_source(db, it),\n             hir::ModuleDef::BuiltinType(it) => Some(it.to_string()),\n         },\n-        NameDefinition::Local(it) => {\n+        Definition::Local(it) => {\n             Some(rust_code_markup(it.ty(db).display_truncated(db, None).to_string()))\n         }\n-        NameDefinition::TypeParam(_) | NameDefinition::SelfType(_) => {\n+        Definition::TypeParam(_) | Definition::SelfType(_) => {\n             // FIXME: Hover for generic param\n             None\n         }"}, {"sha": "95a5c1914dae0361e3a479f5aac6e8f6ea511f61", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d49a4d1863c30e2dc6e744bf1f1dc92411912bb5/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d49a4d1863c30e2dc6e744bf1f1dc92411912bb5/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=d49a4d1863c30e2dc6e744bf1f1dc92411912bb5", "patch": "@@ -31,7 +31,7 @@ pub(crate) use self::{\n     classify::{classify_name_ref, NameRefClass},\n     rename::rename,\n };\n-pub(crate) use ra_ide_db::defs::{classify_name, NameDefinition};\n+pub(crate) use ra_ide_db::defs::{classify_name, Definition};\n \n pub use self::search_scope::SearchScope;\n \n@@ -145,7 +145,7 @@ pub(crate) fn find_all_refs(\n \n pub(crate) fn find_refs_to_def(\n     db: &RootDatabase,\n-    def: &NameDefinition,\n+    def: &Definition,\n     search_scope: Option<SearchScope>,\n ) -> Vec<Reference> {\n     let search_scope = {\n@@ -169,7 +169,7 @@ fn find_name(\n     syntax: &SyntaxNode,\n     position: FilePosition,\n     opt_name: Option<ast::Name>,\n-) -> Option<RangeInfo<NameDefinition>> {\n+) -> Option<RangeInfo<Definition>> {\n     if let Some(name) = opt_name {\n         let def = classify_name(sema, &name)?.definition();\n         let range = name.syntax().text_range();\n@@ -183,7 +183,7 @@ fn find_name(\n \n fn process_definition(\n     db: &RootDatabase,\n-    def: &NameDefinition,\n+    def: &Definition,\n     name: String,\n     scope: SearchScope,\n ) -> Vec<Reference> {\n@@ -250,13 +250,9 @@ fn process_definition(\n     refs\n }\n \n-fn decl_access(\n-    def: &NameDefinition,\n-    syntax: &SyntaxNode,\n-    range: TextRange,\n-) -> Option<ReferenceAccess> {\n+fn decl_access(def: &Definition, syntax: &SyntaxNode, range: TextRange) -> Option<ReferenceAccess> {\n     match def {\n-        NameDefinition::Local(_) | NameDefinition::StructField(_) => {}\n+        Definition::Local(_) | Definition::StructField(_) => {}\n         _ => return None,\n     };\n \n@@ -273,10 +269,10 @@ fn decl_access(\n     None\n }\n \n-fn reference_access(def: &NameDefinition, name_ref: &ast::NameRef) -> Option<ReferenceAccess> {\n+fn reference_access(def: &Definition, name_ref: &ast::NameRef) -> Option<ReferenceAccess> {\n     // Only Locals and Fields have accesses for now.\n     match def {\n-        NameDefinition::Local(_) | NameDefinition::StructField(_) => {}\n+        Definition::Local(_) | Definition::StructField(_) => {}\n         _ => return None,\n     };\n "}, {"sha": "0bbf893f876650a07dc4ad72dc0d705a026cdc1c", "filename": "crates/ra_ide/src/references/classify.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d49a4d1863c30e2dc6e744bf1f1dc92411912bb5/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d49a4d1863c30e2dc6e744bf1f1dc92411912bb5/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs?ref=d49a4d1863c30e2dc6e744bf1f1dc92411912bb5", "patch": "@@ -1,22 +1,22 @@\n //! Functions that are used to classify an element from its definition or reference.\n \n use hir::{Local, PathResolution, Semantics};\n-use ra_ide_db::defs::NameDefinition;\n+use ra_ide_db::defs::Definition;\n use ra_ide_db::RootDatabase;\n use ra_prof::profile;\n use ra_syntax::{ast, AstNode};\n use test_utils::tested_by;\n \n pub enum NameRefClass {\n-    NameDefinition(NameDefinition),\n-    FieldShorthand { local: Local, field: NameDefinition },\n+    Definition(Definition),\n+    FieldShorthand { local: Local, field: Definition },\n }\n \n impl NameRefClass {\n-    pub fn definition(self) -> NameDefinition {\n+    pub fn definition(self) -> Definition {\n         match self {\n-            NameRefClass::NameDefinition(def) => def,\n-            NameRefClass::FieldShorthand { local, field: _ } => NameDefinition::Local(local),\n+            NameRefClass::Definition(def) => def,\n+            NameRefClass::FieldShorthand { local, field: _ } => Definition::Local(local),\n         }\n     }\n }\n@@ -32,24 +32,24 @@ pub(crate) fn classify_name_ref(\n     if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n         tested_by!(goto_def_for_methods);\n         if let Some(func) = sema.resolve_method_call(&method_call) {\n-            return Some(NameRefClass::NameDefinition(NameDefinition::ModuleDef(func.into())));\n+            return Some(NameRefClass::Definition(Definition::ModuleDef(func.into())));\n         }\n     }\n \n     if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {\n         tested_by!(goto_def_for_fields);\n         if let Some(field) = sema.resolve_field(&field_expr) {\n-            return Some(NameRefClass::NameDefinition(NameDefinition::StructField(field)));\n+            return Some(NameRefClass::Definition(Definition::StructField(field)));\n         }\n     }\n \n     if let Some(record_field) = ast::RecordField::cast(parent.clone()) {\n         tested_by!(goto_def_for_record_fields);\n         tested_by!(goto_def_for_field_init_shorthand);\n         if let Some((field, local)) = sema.resolve_record_field(&record_field) {\n-            let field = NameDefinition::StructField(field);\n+            let field = Definition::StructField(field);\n             let res = match local {\n-                None => NameRefClass::NameDefinition(field),\n+                None => NameRefClass::Definition(field),\n                 Some(local) => NameRefClass::FieldShorthand { field, local },\n             };\n             return Some(res);\n@@ -59,26 +59,26 @@ pub(crate) fn classify_name_ref(\n     if let Some(macro_call) = parent.ancestors().find_map(ast::MacroCall::cast) {\n         tested_by!(goto_def_for_macros);\n         if let Some(macro_def) = sema.resolve_macro_call(&macro_call) {\n-            return Some(NameRefClass::NameDefinition(NameDefinition::Macro(macro_def)));\n+            return Some(NameRefClass::Definition(Definition::Macro(macro_def)));\n         }\n     }\n \n     let path = name_ref.syntax().ancestors().find_map(ast::Path::cast)?;\n     let resolved = sema.resolve_path(&path)?;\n     let res = match resolved {\n-        PathResolution::Def(def) => NameDefinition::ModuleDef(def),\n+        PathResolution::Def(def) => Definition::ModuleDef(def),\n         PathResolution::AssocItem(item) => {\n             let def = match item {\n                 hir::AssocItem::Function(it) => it.into(),\n                 hir::AssocItem::Const(it) => it.into(),\n                 hir::AssocItem::TypeAlias(it) => it.into(),\n             };\n-            NameDefinition::ModuleDef(def)\n+            Definition::ModuleDef(def)\n         }\n-        PathResolution::Local(local) => NameDefinition::Local(local),\n-        PathResolution::TypeParam(par) => NameDefinition::TypeParam(par),\n-        PathResolution::Macro(def) => NameDefinition::Macro(def),\n-        PathResolution::SelfType(impl_def) => NameDefinition::SelfType(impl_def),\n+        PathResolution::Local(local) => Definition::Local(local),\n+        PathResolution::TypeParam(par) => Definition::TypeParam(par),\n+        PathResolution::Macro(def) => Definition::Macro(def),\n+        PathResolution::SelfType(impl_def) => Definition::SelfType(impl_def),\n     };\n-    Some(NameRefClass::NameDefinition(res))\n+    Some(NameRefClass::Definition(res))\n }"}, {"sha": "d98c84d91698553b06a3a43fbabe596687f9f165", "filename": "crates/ra_ide/src/references/search_scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d49a4d1863c30e2dc6e744bf1f1dc92411912bb5/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d49a4d1863c30e2dc6e744bf1f1dc92411912bb5/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs?ref=d49a4d1863c30e2dc6e744bf1f1dc92411912bb5", "patch": "@@ -12,7 +12,7 @@ use rustc_hash::FxHashMap;\n \n use ra_ide_db::RootDatabase;\n \n-use super::NameDefinition;\n+use super::Definition;\n \n pub struct SearchScope {\n     entries: FxHashMap<FileId, Option<TextRange>>,\n@@ -23,7 +23,7 @@ impl SearchScope {\n         SearchScope { entries: FxHashMap::default() }\n     }\n \n-    pub(crate) fn for_def(def: &NameDefinition, db: &RootDatabase) -> SearchScope {\n+    pub(crate) fn for_def(def: &Definition, db: &RootDatabase) -> SearchScope {\n         let _p = profile(\"search_scope\");\n         let module = match def.module(db) {\n             Some(it) => it,\n@@ -32,7 +32,7 @@ impl SearchScope {\n         let module_src = module.definition_source(db);\n         let file_id = module_src.file_id.original_file(db);\n \n-        if let NameDefinition::Local(var) = def {\n+        if let Definition::Local(var) = def {\n             let range = match var.parent(db) {\n                 DefWithBody::Function(f) => f.source(db).value.syntax().text_range(),\n                 DefWithBody::Const(c) => c.source(db).value.syntax().text_range(),"}, {"sha": "9e0ee215896452c92cd44af0bd94bbe2f95b3618", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d49a4d1863c30e2dc6e744bf1f1dc92411912bb5/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d49a4d1863c30e2dc6e744bf1f1dc92411912bb5/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=d49a4d1863c30e2dc6e744bf1f1dc92411912bb5", "patch": "@@ -7,7 +7,7 @@ mod tests;\n \n use hir::{Name, Semantics};\n use ra_ide_db::{\n-    defs::{classify_name, NameClass, NameDefinition},\n+    defs::{classify_name, Definition, NameClass},\n     RootDatabase,\n };\n use ra_prof::profile;\n@@ -172,7 +172,7 @@ fn highlight_element(\n             let name = element.into_node().and_then(ast::Name::cast).unwrap();\n             let name_kind = classify_name(sema, &name);\n \n-            if let Some(NameClass::NameDefinition(NameDefinition::Local(local))) = &name_kind {\n+            if let Some(NameClass::Definition(Definition::Local(local))) = &name_kind {\n                 if let Some(name) = local.name(db) {\n                     let shadow_count = bindings_shadow_count.entry(name.clone()).or_default();\n                     *shadow_count += 1;\n@@ -181,7 +181,7 @@ fn highlight_element(\n             };\n \n             match name_kind {\n-                Some(NameClass::NameDefinition(def)) => {\n+                Some(NameClass::Definition(def)) => {\n                     highlight_name(db, def) | HighlightModifier::Definition\n                 }\n                 Some(NameClass::ConstReference(def)) => highlight_name(db, def),\n@@ -196,8 +196,8 @@ fn highlight_element(\n             let name_kind = classify_name_ref(sema, &name_ref)?;\n \n             match name_kind {\n-                NameRefClass::NameDefinition(def) => {\n-                    if let NameDefinition::Local(local) = &def {\n+                NameRefClass::Definition(def) => {\n+                    if let Definition::Local(local) = &def {\n                         if let Some(name) = local.name(db) {\n                             let shadow_count =\n                                 bindings_shadow_count.entry(name.clone()).or_default();\n@@ -260,11 +260,11 @@ fn highlight_element(\n     }\n }\n \n-fn highlight_name(db: &RootDatabase, def: NameDefinition) -> Highlight {\n+fn highlight_name(db: &RootDatabase, def: Definition) -> Highlight {\n     match def {\n-        NameDefinition::Macro(_) => HighlightTag::Macro,\n-        NameDefinition::StructField(_) => HighlightTag::Field,\n-        NameDefinition::ModuleDef(def) => match def {\n+        Definition::Macro(_) => HighlightTag::Macro,\n+        Definition::StructField(_) => HighlightTag::Field,\n+        Definition::ModuleDef(def) => match def {\n             hir::ModuleDef::Module(_) => HighlightTag::Module,\n             hir::ModuleDef::Function(_) => HighlightTag::Function,\n             hir::ModuleDef::Adt(hir::Adt::Struct(_)) => HighlightTag::Struct,\n@@ -277,10 +277,10 @@ fn highlight_name(db: &RootDatabase, def: NameDefinition) -> Highlight {\n             hir::ModuleDef::TypeAlias(_) => HighlightTag::TypeAlias,\n             hir::ModuleDef::BuiltinType(_) => HighlightTag::BuiltinType,\n         },\n-        NameDefinition::SelfType(_) => HighlightTag::SelfType,\n-        NameDefinition::TypeParam(_) => HighlightTag::TypeParam,\n+        Definition::SelfType(_) => HighlightTag::SelfType,\n+        Definition::TypeParam(_) => HighlightTag::TypeParam,\n         // FIXME: distinguish between locals and parameters\n-        NameDefinition::Local(local) => {\n+        Definition::Local(local) => {\n             let mut h = Highlight::new(HighlightTag::Local);\n             if local.is_mut(db) || local.ty(db).is_mutable_reference() {\n                 h |= HighlightModifier::Mutable;"}, {"sha": "215daa441885e6d914ea5d1e9504eee20ac0c8ae", "filename": "crates/ra_ide_db/src/defs.rs", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/d49a4d1863c30e2dc6e744bf1f1dc92411912bb5/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d49a4d1863c30e2dc6e744bf1f1dc92411912bb5/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs?ref=d49a4d1863c30e2dc6e744bf1f1dc92411912bb5", "patch": "@@ -17,8 +17,9 @@ use ra_syntax::{\n \n use crate::RootDatabase;\n \n+// FIXME: a more precise name would probably be `Symbol`?\n #[derive(Debug, PartialEq, Eq)]\n-pub enum NameDefinition {\n+pub enum Definition {\n     Macro(MacroDef),\n     StructField(StructField),\n     ModuleDef(ModuleDef),\n@@ -27,26 +28,26 @@ pub enum NameDefinition {\n     TypeParam(TypeParam),\n }\n \n-impl NameDefinition {\n+impl Definition {\n     pub fn module(&self, db: &RootDatabase) -> Option<Module> {\n         match self {\n-            NameDefinition::Macro(it) => it.module(db),\n-            NameDefinition::StructField(it) => Some(it.parent_def(db).module(db)),\n-            NameDefinition::ModuleDef(it) => it.module(db),\n-            NameDefinition::SelfType(it) => Some(it.module(db)),\n-            NameDefinition::Local(it) => Some(it.module(db)),\n-            NameDefinition::TypeParam(it) => Some(it.module(db)),\n+            Definition::Macro(it) => it.module(db),\n+            Definition::StructField(it) => Some(it.parent_def(db).module(db)),\n+            Definition::ModuleDef(it) => it.module(db),\n+            Definition::SelfType(it) => Some(it.module(db)),\n+            Definition::Local(it) => Some(it.module(db)),\n+            Definition::TypeParam(it) => Some(it.module(db)),\n         }\n     }\n \n     pub fn visibility(&self, db: &RootDatabase) -> Option<ast::Visibility> {\n         match self {\n-            NameDefinition::Macro(_) => None,\n-            NameDefinition::StructField(sf) => match sf.source(db).value {\n+            Definition::Macro(_) => None,\n+            Definition::StructField(sf) => match sf.source(db).value {\n                 FieldSource::Named(it) => it.visibility(),\n                 FieldSource::Pos(it) => it.visibility(),\n             },\n-            NameDefinition::ModuleDef(def) => match def {\n+            Definition::ModuleDef(def) => match def {\n                 ModuleDef::Module(it) => it.declaration_source(db)?.value.visibility(),\n                 ModuleDef::Function(it) => it.source(db).value.visibility(),\n                 ModuleDef::Adt(adt) => match adt {\n@@ -61,17 +62,17 @@ impl NameDefinition {\n                 ModuleDef::EnumVariant(_) => None,\n                 ModuleDef::BuiltinType(_) => None,\n             },\n-            NameDefinition::SelfType(_) => None,\n-            NameDefinition::Local(_) => None,\n-            NameDefinition::TypeParam(_) => None,\n+            Definition::SelfType(_) => None,\n+            Definition::Local(_) => None,\n+            Definition::TypeParam(_) => None,\n         }\n     }\n \n     pub fn name(&self, db: &RootDatabase) -> Option<Name> {\n         let name = match self {\n-            NameDefinition::Macro(it) => it.name(db)?,\n-            NameDefinition::StructField(it) => it.name(db),\n-            NameDefinition::ModuleDef(def) => match def {\n+            Definition::Macro(it) => it.name(db)?,\n+            Definition::StructField(it) => it.name(db),\n+            Definition::ModuleDef(def) => match def {\n                 hir::ModuleDef::Module(it) => it.name(db)?,\n                 hir::ModuleDef::Function(it) => it.name(db),\n                 hir::ModuleDef::Adt(def) => match def {\n@@ -86,106 +87,106 @@ impl NameDefinition {\n                 hir::ModuleDef::TypeAlias(it) => it.name(db),\n                 hir::ModuleDef::BuiltinType(_) => return None,\n             },\n-            NameDefinition::SelfType(_) => return None,\n-            NameDefinition::Local(it) => it.name(db)?,\n-            NameDefinition::TypeParam(it) => it.name(db),\n+            Definition::SelfType(_) => return None,\n+            Definition::Local(it) => it.name(db)?,\n+            Definition::TypeParam(it) => it.name(db),\n         };\n         Some(name)\n     }\n }\n \n pub enum NameClass {\n-    NameDefinition(NameDefinition),\n+    Definition(Definition),\n     /// `None` in `if let None = Some(82) {}`\n-    ConstReference(NameDefinition),\n+    ConstReference(Definition),\n }\n \n impl NameClass {\n-    pub fn into_definition(self) -> Option<NameDefinition> {\n+    pub fn into_definition(self) -> Option<Definition> {\n         match self {\n-            NameClass::NameDefinition(it) => Some(it),\n+            NameClass::Definition(it) => Some(it),\n             NameClass::ConstReference(_) => None,\n         }\n     }\n \n-    pub fn definition(self) -> NameDefinition {\n+    pub fn definition(self) -> Definition {\n         match self {\n-            NameClass::NameDefinition(it) | NameClass::ConstReference(it) => it,\n+            NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n         }\n     }\n }\n \n pub fn classify_name(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Option<NameClass> {\n     if let Some(bind_pat) = name.syntax().parent().and_then(ast::BindPat::cast) {\n         if let Some(def) = sema.resolve_bind_pat_to_const(&bind_pat) {\n-            return Some(NameClass::ConstReference(NameDefinition::ModuleDef(def)));\n+            return Some(NameClass::ConstReference(Definition::ModuleDef(def)));\n         }\n     }\n \n-    classify_name_inner(sema, name).map(NameClass::NameDefinition)\n+    classify_name_inner(sema, name).map(NameClass::Definition)\n }\n \n-fn classify_name_inner(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Option<NameDefinition> {\n+fn classify_name_inner(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Option<Definition> {\n     let _p = profile(\"classify_name\");\n     let parent = name.syntax().parent()?;\n \n     match_ast! {\n         match parent {\n             ast::BindPat(it) => {\n                 let local = sema.to_def(&it)?;\n-                Some(NameDefinition::Local(local))\n+                Some(Definition::Local(local))\n             },\n             ast::RecordFieldDef(it) => {\n                 let field: hir::StructField = sema.to_def(&it)?;\n-                Some(NameDefinition::StructField(field))\n+                Some(Definition::StructField(field))\n             },\n             ast::Module(it) => {\n                 let def = sema.to_def(&it)?;\n-                Some(NameDefinition::ModuleDef(def.into()))\n+                Some(Definition::ModuleDef(def.into()))\n             },\n             ast::StructDef(it) => {\n                 let def: hir::Struct = sema.to_def(&it)?;\n-                Some(NameDefinition::ModuleDef(def.into()))\n+                Some(Definition::ModuleDef(def.into()))\n             },\n             ast::UnionDef(it) => {\n                 let def: hir::Union = sema.to_def(&it)?;\n-                Some(NameDefinition::ModuleDef(def.into()))\n+                Some(Definition::ModuleDef(def.into()))\n             },\n             ast::EnumDef(it) => {\n                 let def: hir::Enum = sema.to_def(&it)?;\n-                Some(NameDefinition::ModuleDef(def.into()))\n+                Some(Definition::ModuleDef(def.into()))\n             },\n             ast::TraitDef(it) => {\n                 let def: hir::Trait = sema.to_def(&it)?;\n-                Some(NameDefinition::ModuleDef(def.into()))\n+                Some(Definition::ModuleDef(def.into()))\n             },\n             ast::StaticDef(it) => {\n                 let def: hir::Static = sema.to_def(&it)?;\n-                Some(NameDefinition::ModuleDef(def.into()))\n+                Some(Definition::ModuleDef(def.into()))\n             },\n             ast::EnumVariant(it) => {\n                 let def: hir::EnumVariant = sema.to_def(&it)?;\n-                Some(NameDefinition::ModuleDef(def.into()))\n+                Some(Definition::ModuleDef(def.into()))\n             },\n             ast::FnDef(it) => {\n                 let def: hir::Function = sema.to_def(&it)?;\n-                Some(NameDefinition::ModuleDef(def.into()))\n+                Some(Definition::ModuleDef(def.into()))\n             },\n             ast::ConstDef(it) => {\n                 let def: hir::Const = sema.to_def(&it)?;\n-                Some(NameDefinition::ModuleDef(def.into()))\n+                Some(Definition::ModuleDef(def.into()))\n             },\n             ast::TypeAliasDef(it) => {\n                 let def: hir::TypeAlias = sema.to_def(&it)?;\n-                Some(NameDefinition::ModuleDef(def.into()))\n+                Some(Definition::ModuleDef(def.into()))\n             },\n             ast::MacroCall(it) => {\n                 let def = sema.to_def(&it)?;\n-                Some(NameDefinition::Macro(def))\n+                Some(Definition::Macro(def))\n             },\n             ast::TypeParam(it) => {\n                 let def = sema.to_def(&it)?;\n-                Some(NameDefinition::TypeParam(def))\n+                Some(Definition::TypeParam(def))\n             },\n             _ => None,\n         }"}, {"sha": "c9635198299652eec34d077094b218ce85dba092", "filename": "crates/ra_ide_db/src/imports_locator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d49a4d1863c30e2dc6e744bf1f1dc92411912bb5/crates%2Fra_ide_db%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d49a4d1863c30e2dc6e744bf1f1dc92411912bb5/crates%2Fra_ide_db%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fimports_locator.rs?ref=d49a4d1863c30e2dc6e744bf1f1dc92411912bb5", "patch": "@@ -6,7 +6,7 @@ use ra_prof::profile;\n use ra_syntax::{ast, AstNode, SyntaxKind::NAME};\n \n use crate::{\n-    defs::{classify_name, NameDefinition},\n+    defs::{classify_name, Definition},\n     symbol_index::{self, FileSymbol, Query},\n     RootDatabase,\n };\n@@ -43,13 +43,13 @@ impl<'a> ImportsLocator<'a> {\n             .chain(lib_results.into_iter())\n             .filter_map(|import_candidate| self.get_name_definition(&import_candidate))\n             .filter_map(|name_definition_to_import| match name_definition_to_import {\n-                NameDefinition::ModuleDef(module_def) => Some(module_def),\n+                Definition::ModuleDef(module_def) => Some(module_def),\n                 _ => None,\n             })\n             .collect()\n     }\n \n-    fn get_name_definition(&mut self, import_candidate: &FileSymbol) -> Option<NameDefinition> {\n+    fn get_name_definition(&mut self, import_candidate: &FileSymbol) -> Option<Definition> {\n         let _p = profile(\"get_name_definition\");\n         let file_id = import_candidate.file_id;\n "}]}