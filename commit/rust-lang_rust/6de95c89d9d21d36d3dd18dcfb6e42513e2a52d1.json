{"sha": "6de95c89d9d21d36d3dd18dcfb6e42513e2a52d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkZTk1Yzg5ZDlkMjFkMzZkM2RkMThkY2ZiNmU0MjUxM2UyYTUyZDE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-23T16:26:54Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-23T16:26:54Z"}, "message": "Implement enums", "tree": {"sha": "b8f7586257cb760342b9e3ebd73f56b67c6f8e6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8f7586257cb760342b9e3ebd73f56b67c6f8e6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6de95c89d9d21d36d3dd18dcfb6e42513e2a52d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6de95c89d9d21d36d3dd18dcfb6e42513e2a52d1", "html_url": "https://github.com/rust-lang/rust/commit/6de95c89d9d21d36d3dd18dcfb6e42513e2a52d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6de95c89d9d21d36d3dd18dcfb6e42513e2a52d1/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0463690408aedb7eeeb0ff0b62cd1e289473247", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0463690408aedb7eeeb0ff0b62cd1e289473247", "html_url": "https://github.com/rust-lang/rust/commit/b0463690408aedb7eeeb0ff0b62cd1e289473247"}], "stats": {"total": 260, "additions": 223, "deletions": 37}, "files": [{"sha": "dc78a6b10800ae7a317a1b182573ead89986d152", "filename": "example.rs", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6de95c89d9d21d36d3dd18dcfb6e42513e2a52d1/example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6de95c89d9d21d36d3dd18dcfb6e42513e2a52d1/example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example.rs?ref=6de95c89d9d21d36d3dd18dcfb6e42513e2a52d1", "patch": "@@ -18,10 +18,10 @@ trait Mul<RHS = Self> {\n     fn mul(self, rhs: RHS) -> Self::Output;\n }\n \n-impl Mul for u8 {\n-    type Output = u8;\n+impl Mul for u32 {\n+    type Output = u32;\n \n-    fn mul(self, rhs: u8) -> u8 {\n+    fn mul(self, rhs: u32) -> u32 {\n         self * rhs\n     }\n }\n@@ -31,23 +31,48 @@ fn panic(_expr_file_line_col: &(&'static str, &'static str, u32, u32)) -> ! {\n     loop {}\n }\n \n-fn abc(a: u8) -> u8 {\n+#[lang = \"drop_in_place\"]\n+#[allow(unconditional_recursion)]\n+unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+    // Code here does not matter - this is replaced by the\n+    // real drop glue by the compiler.\n+    drop_in_place(to_drop);\n+}\n+\n+fn abc(a: u32) -> u32 {\n     a * 2\n }\n \n-fn bcd(b: bool, a: u8) -> u8 {\n+fn bcd(b: bool, a: u32) -> u32 {\n     if b {\n         a * 2\n     } else {\n         a * 3\n     }\n }\n \n-fn call() {\n+// FIXME make calls work\n+/*fn call() {\n     abc(42);\n }\n \n fn indirect_call() {\n     let f: fn() = call;\n     f();\n+}*/\n+\n+enum BoolOption {\n+    Some(bool),\n+    None,\n+}\n+\n+fn option_unwrap_or(o: BoolOption, d: bool) -> bool {\n+    match o {\n+        BoolOption::Some(b) => b,\n+        BoolOption::None => d,\n+    }\n+}\n+\n+fn ret_42() -> u32 {\n+    42\n }"}, {"sha": "1786b732abe4f105f925c131106f06d83682b239", "filename": "src/base.rs", "status": "modified", "additions": 121, "deletions": 23, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/6de95c89d9d21d36d3dd18dcfb6e42513e2a52d1/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6de95c89d9d21d36d3dd18dcfb6e42513e2a52d1/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=6de95c89d9d21d36d3dd18dcfb6e42513e2a52d1", "patch": "@@ -44,15 +44,17 @@ pub fn trans_crate<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Box<Any> {\n                             })\n                         };\n \n-                        let mut f = Function::with_name_signature(ext_name_from_did(def_id), sig);\n-\n-                        trans_fn(cx, &mut f, def_id, substs);\n+                        let mut f = Function::with_name_signature(ExternalName::user(0, func_id.index() as u32), sig);\n \n                         let mut mir = ::std::io::Cursor::new(Vec::new());\n                         ::rustc_mir::util::write_mir_pretty(cx.tcx, Some(def_id), &mut mir).unwrap();\n+                        tcx.sess.warn(&format!(\"{:?}:\\n\\n{}\", def_id, String::from_utf8_lossy(&mir.into_inner())));\n+\n+                        trans_fn(cx, &mut f, def_id, substs);\n+\n                         let mut cton = String::new();\n                         ::cretonne::codegen::write_function(&mut cton, &f, None).unwrap();\n-                        tcx.sess.warn(&format!(\"{:?}:\\n\\n{}\\n\\n{}\", def_id, String::from_utf8_lossy(&mir.into_inner()), cton));\n+                        tcx.sess.warn(&cton);\n \n                         let flags = settings::Flags::new(settings::builder());\n                         match ::cretonne::codegen::verify_function(&f, &flags) {\n@@ -73,17 +75,26 @@ pub fn trans_crate<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Box<Any> {\n         }\n     }\n \n+    tcx.sess.warn(\"Compiled everything\");\n+\n     module.finalize_all();\n \n+    tcx.sess.warn(\"Finalized everything\");\n+\n     for (inst, func_id) in def_id_fn_id_map.iter() {\n-        if tcx.absolute_item_path_str(inst.def_id()) != \"example::ret_42\" {\n+        //if tcx.absolute_item_path_str(inst.def_id()) != \"example::ret_42\" {\n+        if tcx.absolute_item_path_str(inst.def_id()) != \"example::option_unwrap_or\" {\n             continue;\n         }\n         let finalized_function: *const u8 = module.finalize_function(*func_id);\n-        let f: extern \"C\" fn(&mut u32) = unsafe { ::std::mem::transmute(finalized_function) };\n+        /*let f: extern \"C\" fn(&mut u32) = unsafe { ::std::mem::transmute(finalized_function) };\n         let mut res = 0u32;\n         f(&mut res);\n-        tcx.sess.warn(&format!(\"ret_42 returned {}\", res));\n+        tcx.sess.warn(&format!(\"ret_42 returned {}\", res));*/\n+        let f: extern \"C\" fn(&mut bool, &u8, bool) = unsafe { ::std::mem::transmute(finalized_function) };\n+        let mut res = false;\n+        f(&mut res, &3, false);\n+        tcx.sess.warn(&format!(\"option_unwrap_or returned {}\", res));\n     }\n \n     module.finish();\n@@ -149,7 +160,10 @@ fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &mut\n     for (local, ebb_param, ty, stack_slot) in func_params {\n         let place = CPlace::from_stack_slot(fx, stack_slot);\n         if ty.is_some() {\n-            fx.bcx.ins().stack_store(ebb_param, stack_slot, 0);\n+            // FIXME(cretonne) support i16 and smaller\n+            let ebb_param = extend_val(fx, ebb_param, mir.local_decls[local].ty);\n+            CPlace::from_stack_slot(fx, stack_slot).write_cvalue(fx, CValue::ByVal(ebb_param), mir.local_decls[local].ty);\n+            //fx.bcx.ins().stack_store(ebb_param, stack_slot, 0);\n         } else {\n             place.write_cvalue(fx, CValue::ByRef(ebb_param), mir.local_decls[local].ty);\n         }\n@@ -275,15 +289,38 @@ fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &mut\n \n fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx>) {\n     match &stmt.kind {\n-        StatementKind::Assign(place, rval) => {\n-            let ty = place.ty(&fx.mir.local_decls, fx.tcx).to_ty(fx.tcx);\n-            let lval = trans_place(fx, place);\n+        StatementKind::Assign(to_place, rval) => {\n+            let dest_ty = to_place.ty(&fx.mir.local_decls, fx.tcx).to_ty(fx.tcx);\n+            let lval = trans_place(fx, to_place);\n             match rval {\n                 Rvalue::Use(operand) => {\n                     let val = trans_operand(fx, operand);\n-                    lval.write_cvalue(fx, val, ty);\n+                    lval.write_cvalue(fx, val, dest_ty);\n                 },\n+                Rvalue::BinaryOp(bin_op, lhs, rhs) => {\n+                    let ty = lhs.ty(&fx.mir.local_decls, fx.tcx);\n+                    let lhs_ty = lhs.ty(&fx.mir.local_decls, fx.tcx);\n+                    let lhs = trans_operand(fx, lhs).load_value(fx, lhs_ty);\n+                    let rhs_ty = rhs.ty(&fx.mir.local_decls, fx.tcx);\n+                    let rhs = trans_operand(fx, rhs).load_value(fx, rhs_ty);\n+\n+                    let res = match ty.sty {\n+                        TypeVariants::TyUint(_) => {\n+                            match bin_op {\n+                                BinOp::Add => fx.bcx.ins().iadd(lhs, rhs),\n+                                BinOp::Sub => fx.bcx.ins().isub(lhs, rhs),\n+                                BinOp::Mul => fx.bcx.ins().imul(lhs, rhs),\n+                                BinOp::Div => fx.bcx.ins().udiv(lhs, rhs),\n+                                bin_op => unimplemented!(\"checked uint bin op {:?} {:?} {:?}\", bin_op, lhs, rhs),\n+                            }\n+                        }\n+                        _ => unimplemented!(),\n+                    };\n+                    lval.write_cvalue(fx, CValue::ByVal(res), ty);\n+                }\n                 Rvalue::CheckedBinaryOp(bin_op, lhs, rhs) => {\n+                    // TODO correctly write output tuple\n+\n                     let ty = lhs.ty(&fx.mir.local_decls, fx.tcx);\n                     let lhs_ty = lhs.ty(&fx.mir.local_decls, fx.tcx);\n                     let lhs = trans_operand(fx, lhs).load_value(fx, lhs_ty);\n@@ -303,14 +340,79 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n                         _ => unimplemented!(),\n                     };\n                     lval.write_cvalue(fx, CValue::ByVal(res), ty);\n+                    unimplemented!(\"checked bin op {:?}\", bin_op);\n                 }\n                 Rvalue::Cast(CastKind::ReifyFnPointer, operand, ty) => {\n                     let operand = trans_operand(fx, operand);\n-                    lval.write_cvalue(fx, operand, ty);\n+                    lval.write_cvalue(fx, operand, dest_ty);\n                 }\n                 Rvalue::Cast(CastKind::UnsafeFnPointer, operand, ty) => {\n                     let operand = trans_operand(fx, operand);\n-                    lval.write_cvalue(fx, operand, ty);\n+                    lval.write_cvalue(fx, operand, dest_ty);\n+                }\n+                Rvalue::Discriminant(place) => {\n+                    let place_ty = place.ty(&fx.mir.local_decls, fx.tcx).to_ty(fx.tcx);\n+                    let cton_place_ty = cton_type_from_ty(place_ty);\n+                    let layout = fx.tcx.layout_of(ParamEnv::reveal_all().and(place_ty)).unwrap();\n+\n+                    if layout.abi == layout::Abi::Uninhabited {\n+                        fx.bcx.ins().trap(TrapCode::User(!0));\n+                    }\n+                    match layout.variants {\n+                        layout::Variants::Single { index } => {\n+                            let discr_val = layout.ty.ty_adt_def().map_or(\n+                                index as u128,\n+                                |def| def.discriminant_for_variant(fx.tcx, index).val);\n+                            let val = CValue::const_val(fx, dest_ty, discr_val as u64 as i64);\n+                            lval.write_cvalue(fx, val, dest_ty);\n+                        }\n+                        layout::Variants::Tagged { .. } |\n+                        layout::Variants::NicheFilling { .. } => {},\n+                    }\n+\n+                    let discr = lval.to_cvalue(fx).value_field(fx, mir::Field::new(0), place_ty);\n+                    let discr_ty = layout.field(layout::LayoutCx {\n+                        tcx: fx.tcx,\n+                        param_env: ParamEnv::reveal_all()\n+                    }, 0).unwrap().ty;\n+                    let lldiscr = discr.load_value(fx, discr_ty);\n+                    match layout.variants {\n+                        layout::Variants::Single { .. } => bug!(),\n+                        layout::Variants::Tagged { ref tag, .. } => {\n+                            let signed = match tag.value {\n+                                layout::Int(_, signed) => signed,\n+                                _ => false\n+                            };\n+                            let val = cton_intcast(fx, lldiscr, discr_ty, dest_ty, signed);\n+                            lval.write_cvalue(fx, CValue::ByVal(val), dest_ty);\n+                        }\n+                        layout::Variants::NicheFilling {\n+                            dataful_variant,\n+                            ref niche_variants,\n+                            niche_start,\n+                            ..\n+                        } => {\n+                            let niche_llty = cton_type_from_ty(discr_ty).unwrap();\n+                            if niche_variants.start() == niche_variants.end() {\n+                                let b = fx.bcx.ins().icmp_imm(IntCC::Equal, lldiscr, niche_start as u64 as i64);\n+                                let if_true = fx.bcx.ins().iconst(cton_type_from_ty(dest_ty).unwrap(), *niche_variants.start() as u64 as i64);\n+                                let if_false = fx.bcx.ins().iconst(cton_type_from_ty(dest_ty).unwrap(), dataful_variant as u64 as i64);\n+                                let val = fx.bcx.ins().select(b, if_true, if_false);\n+                                lval.write_cvalue(fx, CValue::ByVal(val), dest_ty);\n+                            } else {\n+                                // Rebase from niche values to discriminant values.\n+                                let delta = niche_start.wrapping_sub(*niche_variants.start() as u128);\n+                                let delta = fx.bcx.ins().iconst(niche_llty, delta as u64 as i64);\n+                                let lldiscr = fx.bcx.ins().isub(lldiscr, delta);\n+                                let lldiscr_max = fx.bcx.ins().iconst(niche_llty, *niche_variants.end() as u64 as i64);\n+                                let b = fx.bcx.ins().icmp_imm(IntCC::UnsignedLessThanOrEqual, lldiscr, *niche_variants.end() as u64 as i64);\n+                                let if_true = cton_intcast(fx, lldiscr, discr_ty, dest_ty, false);\n+                                let if_false = fx.bcx.ins().iconst(niche_llty, dataful_variant as u64 as i64);\n+                                let val = fx.bcx.ins().select(b, if_true, if_false);\n+                                lval.write_cvalue(fx, CValue::ByVal(val), dest_ty);\n+                            }\n+                        }\n+                    }\n                 }\n                 rval => unimplemented!(\"rval {:?}\", rval),\n             }\n@@ -324,17 +426,13 @@ fn trans_place<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, place: &Place<'tcx>)\n     match place {\n         Place::Local(local) => fx.get_local_place(*local),\n         Place::Projection(projection) => {\n-            let base = trans_place(fx, &projection.base).expect_addr();\n+            let base = trans_place(fx, &projection.base);\n             match projection.elem {\n                 ProjectionElem::Field(field, ty) => {\n-                    let layout = fx.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n-                    let field_offset = layout.fields.offset(field.index());\n-                    if field_offset.bytes() > 0 {\n-                        let field_offset = fx.bcx.ins().iconst(types::I64, field_offset.bytes() as i64);\n-                        CPlace::Addr(fx.bcx.ins().iadd(base, field_offset))\n-                    } else {\n-                        CPlace::Addr(base)\n-                    }\n+                    base.place_field(fx, field, ty).0\n+                }\n+                ProjectionElem::Downcast(_ty, _field) => {\n+                    base\n                 }\n                 _ => unimplemented!(\"projection {:?}\", projection),\n             }"}, {"sha": "44140c2897a125ec3ecabc84cddd7108a8fdb575", "filename": "src/common.rs", "status": "modified", "additions": 67, "deletions": 7, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/6de95c89d9d21d36d3dd18dcfb6e42513e2a52d1/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6de95c89d9d21d36d3dd18dcfb6e42513e2a52d1/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=6de95c89d9d21d36d3dd18dcfb6e42513e2a52d1", "patch": "@@ -29,7 +29,7 @@ pub fn cton_type_from_ty(ty: Ty) -> Option<types::Type> {\n                 UintTy::U32 => types::I32,\n                 UintTy::U64 => types::I64,\n                 UintTy::U128 => unimplemented!(),\n-                UintTy::Usize => unimplemented!(),\n+                UintTy::Usize => types::I64,\n             }\n         }\n         TypeVariants::TyInt(size) => {\n@@ -39,14 +39,30 @@ pub fn cton_type_from_ty(ty: Ty) -> Option<types::Type> {\n                 IntTy::I32 => types::I32,\n                 IntTy::I64 => types::I64,\n                 IntTy::I128 => unimplemented!(),\n-                IntTy::Isize => unimplemented!(),\n+                IntTy::Isize => types::I64,\n             }\n         }\n         TypeVariants::TyFnPtr(_) => types::I64,\n         _ => return None,\n     })\n }\n \n+pub fn extend_val<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, val: Value, ty: Ty) -> Value {\n+    let cton_ty = cton_type_from_ty(ty).unwrap();\n+    let to_ty = match cton_ty {\n+        types::I64 => return val,\n+        types::I32 => return val,\n+        _ => types::I32,\n+    };\n+    match ty.sty {\n+        TypeVariants::TyBool => fx.bcx.ins().uextend(to_ty, val),\n+        TypeVariants::TyUint(_) => fx.bcx.ins().uextend(to_ty, val),\n+        TypeVariants::TyInt(_) => fx.bcx.ins().sextend(to_ty, val),\n+        TypeVariants::TyFnPtr(_) => val,\n+        _ => unimplemented!(),\n+    }\n+}\n+\n // FIXME(cretonne) fix load.i8\n fn load_workaround(fx: &mut FunctionCx, ty: Type, addr: Value, offset: i32) -> Value {\n     use cretonne::codegen::ir::types::*;\n@@ -69,7 +85,7 @@ fn store_workaround(fx: &mut FunctionCx, ty: Type, addr: Value, val: Value, offs\n     };\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Debug, Copy, Clone)]\n pub enum CValue {\n     ByRef(Value),\n     ByVal(Value),\n@@ -117,9 +133,28 @@ impl CValue {\n             CValue::Func(_) => bug!(\"Expected CValue::ByRef, found CValue::Func\"),\n         }\n     }\n+\n+    pub fn value_field<'a, 'tcx: 'a>(self, fx: &mut FunctionCx<'a, 'tcx>, field: mir::Field, ty: Ty<'tcx>) -> CValue {\n+        let base = match self {\n+            CValue::ByRef(addr) => addr,\n+            _ => bug!(\"place_field for {:?}\", self),\n+        };\n+        let layout = fx.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n+        let field_offset = layout.fields.offset(field.index());\n+        if field_offset.bytes() > 0 {\n+            let field_offset = fx.bcx.ins().iconst(types::I64, field_offset.bytes() as i64);\n+            CValue::ByRef(fx.bcx.ins().iadd(base, field_offset))\n+        } else {\n+            CValue::ByRef(base)\n+        }\n+    }\n+\n+    pub fn const_val<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, ty: Ty<'tcx>, const_val: i64) -> CValue {\n+        CValue::ByVal(fx.bcx.ins().iconst(cton_type_from_ty(ty).unwrap(), const_val))\n+    }\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Debug, Copy, Clone)]\n pub enum CPlace {\n     Var(Variable),\n     Addr(Value),\n@@ -166,10 +201,18 @@ impl<'a, 'tcx: 'a> CPlace {\n             }\n         }\n     }\n-}\n \n-pub fn ext_name_from_did(def_id: DefId) -> ExternalName {\n-    ExternalName::user(def_id.krate.as_u32(), def_id.index.as_raw_u32())\n+    pub fn place_field(self, fx: &mut FunctionCx<'a, 'tcx>, field: mir::Field, ty: Ty<'tcx>) -> (CPlace, layout::TyLayout<'tcx>) {\n+        let base = self.expect_addr();\n+        let layout = fx.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n+        let field_offset = layout.fields.offset(field.index());\n+        if field_offset.bytes() > 0 {\n+            let field_offset = fx.bcx.ins().iconst(types::I64, field_offset.bytes() as i64);\n+            (CPlace::Addr(fx.bcx.ins().iadd(base, field_offset)), layout)\n+        } else {\n+            (CPlace::Addr(base), layout)\n+        }\n+    }\n }\n \n pub fn cton_sig_from_fn_sig<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sig: PolyFnSig<'tcx>, substs: &Substs<'tcx>) -> Signature {\n@@ -201,6 +244,23 @@ pub fn cton_sig_from_mono_fn_sig<'a ,'tcx: 'a>(sig: PolyFnSig<'tcx>) -> Signatur\n     }\n }\n \n+pub fn cton_intcast<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, val: Value, from: Ty<'tcx>, to: Ty<'tcx>, signed: bool) -> Value {\n+    let from = cton_type_from_ty(from).unwrap();\n+    let to = cton_type_from_ty(to).unwrap();\n+    if from == to {\n+        return val;\n+    }\n+    if from.wider_or_equal(to) {\n+        if signed {\n+            fx.bcx.ins().sextend(to, val)\n+        } else {\n+            fx.bcx.ins().uextend(to, val)\n+        }\n+    } else {\n+        fx.bcx.ins().ireduce(to, val)\n+    }\n+}\n+\n pub struct FunctionCx<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub module: &'a mut Module<CurrentBackend>,"}, {"sha": "100c7bbb1201de9a21809c19ae1ec13a8e74497d", "filename": "src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6de95c89d9d21d36d3dd18dcfb6e42513e2a52d1/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6de95c89d9d21d36d3dd18dcfb6e42513e2a52d1/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=6de95c89d9d21d36d3dd18dcfb6e42513e2a52d1", "patch": "@@ -23,7 +23,7 @@ use rustc::session::{\n };\n use rustc::middle::cstore::{MetadataLoader, EncodedMetadata};\n use rustc::dep_graph::DepGraph;\n-use rustc::ty::maps::Providers;\n+use rustc::ty::query::Providers;\n use rustc_codegen_utils::codegen_backend::{CodegenBackend, NoLlvmMetadataLoader};\n use rustc_codegen_utils::link::{out_filename, build_link_meta};\n \n@@ -41,6 +41,8 @@ mod prelude {\n     pub use rustc::session::Session;\n     pub use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n     pub use rustc::ty::{TyCtxt, Ty, TypeVariants, Instance, InstanceDef, ParamEnv, FnSig, PolyFnSig, subst::Substs};\n+    pub use rustc::ty::layout;\n+    pub use rustc::mir;\n     pub use rustc::mir::*;\n     pub use rustc_mir::monomorphize::collector;\n     pub use rustc_data_structures::{\n@@ -55,6 +57,7 @@ mod prelude {\n         FuncRef,\n         StackSlot,\n         function::Function,\n+        condcodes::IntCC,\n     };\n \n "}]}