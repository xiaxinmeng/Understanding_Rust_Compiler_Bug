{"sha": "d228cd3964b7cbac7665ff38bde46da67586b87d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyMjhjZDM5NjRiN2NiYWM3NjY1ZmYzOGJkZTQ2ZGE2NzU4NmI4N2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-11T10:19:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-11T10:19:44Z"}, "message": "Auto merge of #30490 - ipetkov:unix-spawn, r=alexcrichton\n\n* If the requested descriptors to inherit are stdio descriptors there\n  are situations where they will not be set correctly\n* Example: parent's stdout --> child's stderr\n           parent's stderr --> child's stdout\n* Solution: if the requested descriptors for the child are stdio\n  descriptors, `dup` them before overwriting the child's stdio\n\nExample of a program which exhibits the bug:\n```rust\n// stdio.rs\nuse std::io::Write;\nuse std::io::{stdout, stderr};\nuse std::process::{Command, Stdio};\nuse std::os::unix::io::FromRawFd;\n\nfn main() {\n    stdout().write_all(\"parent stdout\\n\".as_bytes()).unwrap();\n    stderr().write_all(\"parent stderr\\n\".as_bytes()).unwrap();\n\n    Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(\"echo 'child stdout'; echo 'child stderr' 1>&2\")\n        .stdin(Stdio::inherit())\n        .stdout(unsafe { FromRawFd::from_raw_fd(2) })\n        .stderr(unsafe { FromRawFd::from_raw_fd(1) })\n        .status()\n        .unwrap_or_else(|e| { panic!(\"failed to execute process: {}\", e) });\n}\n```\n\nBefore:\n```\n$ rustc --version\nrustc 1.7.0-nightly (8ad12c3e2 2015-12-19)\n$ rustc stdio.rs && ./stdio >out 2>err\n$ cat out\nparent stdout\n$ cat err\nparent stderr\nchild stdout\nchild stderr\n```\n\nAfter (expected):\n```\n$ rustc --version\nrustc 1.7.0-dev (712eccee2 2015-12-19)\n$ rustc stdio.rs && ./stdio >out 2>err\n$ cat out\nparent stdout\nchild stderr\n$ cat err\nparent stderr\nchild stdout\n```", "tree": {"sha": "7a7ce28ffa96dc074ff662496f983ad15375044c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a7ce28ffa96dc074ff662496f983ad15375044c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d228cd3964b7cbac7665ff38bde46da67586b87d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d228cd3964b7cbac7665ff38bde46da67586b87d", "html_url": "https://github.com/rust-lang/rust/commit/d228cd3964b7cbac7665ff38bde46da67586b87d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d228cd3964b7cbac7665ff38bde46da67586b87d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfaddb732ced1da9d310990df095ca36f43fbc3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfaddb732ced1da9d310990df095ca36f43fbc3d", "html_url": "https://github.com/rust-lang/rust/commit/dfaddb732ced1da9d310990df095ca36f43fbc3d"}, {"sha": "7f7a059c4719bbff6c2859802bc50ab2fcaf249f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f7a059c4719bbff6c2859802bc50ab2fcaf249f", "html_url": "https://github.com/rust-lang/rust/commit/7f7a059c4719bbff6c2859802bc50ab2fcaf249f"}], "stats": {"total": 139, "additions": 139, "deletions": 0}, "files": [{"sha": "bb9d37f93ab8b26b0217574a1cc40902703d4751", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d228cd3964b7cbac7665ff38bde46da67586b87d/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d228cd3964b7cbac7665ff38bde46da67586b87d/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=d228cd3964b7cbac7665ff38bde46da67586b87d", "patch": "@@ -288,6 +288,32 @@ impl Process {\n             unsafe { libc::_exit(1) }\n         }\n \n+        // Make sure that the source descriptors are not an stdio descriptor,\n+        // otherwise the order which we set the child's descriptors may blow\n+        // away a descriptor which we are hoping to save. For example,\n+        // suppose we want the child's stderr to be the parent's stdout, and\n+        // the child's stdout to be the parent's stderr. No matter which we\n+        // dup first, the second will get overwritten prematurely.\n+        let maybe_migrate = |src: Stdio, output: &mut AnonPipe| {\n+            match src {\n+                Stdio::Raw(fd @ libc::STDIN_FILENO) |\n+                Stdio::Raw(fd @ libc::STDOUT_FILENO) |\n+                Stdio::Raw(fd @ libc::STDERR_FILENO) => {\n+                    let fd = match cvt_r(|| libc::dup(fd)) {\n+                        Ok(fd) => fd,\n+                        Err(_) => fail(output),\n+                    };\n+                    let fd = FileDesc::new(fd);\n+                    fd.set_cloexec();\n+                    Stdio::Raw(fd.into_raw())\n+                },\n+\n+                s @ Stdio::None |\n+                s @ Stdio::Inherit |\n+                s @ Stdio::Raw(_) => s,\n+            }\n+        };\n+\n         let setup = |src: Stdio, dst: c_int| {\n             match src {\n                 Stdio::Inherit => true,\n@@ -313,6 +339,12 @@ impl Process {\n             }\n         };\n \n+        // Make sure we migrate all source descriptors before\n+        // we start overwriting them\n+        let in_fd = maybe_migrate(in_fd, &mut output);\n+        let out_fd = maybe_migrate(out_fd, &mut output);\n+        let err_fd = maybe_migrate(err_fd, &mut output);\n+\n         if !setup(in_fd, libc::STDIN_FILENO) { fail(&mut output) }\n         if !setup(out_fd, libc::STDOUT_FILENO) { fail(&mut output) }\n         if !setup(err_fd, libc::STDERR_FILENO) { fail(&mut output) }"}, {"sha": "ea603fc665ddab9722e9fe5c9bd9a10ff1ace481", "filename": "src/test/run-pass/issue-30490.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/d228cd3964b7cbac7665ff38bde46da67586b87d/src%2Ftest%2Frun-pass%2Fissue-30490.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d228cd3964b7cbac7665ff38bde46da67586b87d/src%2Ftest%2Frun-pass%2Fissue-30490.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-30490.rs?ref=d228cd3964b7cbac7665ff38bde46da67586b87d", "patch": "@@ -0,0 +1,107 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Previously libstd would set stdio descriptors of a child process\n+// by `dup`ing the requested descriptors to inherit directly into the\n+// stdio descriptors. This, however, would incorrectly handle cases\n+// where the descriptors to inherit were already stdio descriptors.\n+// This test checks to avoid that regression.\n+\n+#![cfg_attr(unix, feature(libc))]\n+#![cfg_attr(windows, allow(unused_imports))]\n+\n+#[cfg(unix)]\n+extern crate libc;\n+\n+use std::fs::File;\n+use std::io::{Read, Write};\n+use std::io::{stdout, stderr};\n+use std::process::{Command, Stdio};\n+\n+#[cfg(unix)]\n+use std::os::unix::io::FromRawFd;\n+\n+#[cfg(not(unix))]\n+fn main() {\n+    // Bug not present in Windows\n+}\n+\n+#[cfg(unix)]\n+fn main() {\n+    let mut args = std::env::args();\n+    let name = args.next().unwrap();\n+    let args: Vec<String> = args.collect();\n+    if let Some(\"--child\") = args.get(0).map(|s| &**s) {\n+        return child();\n+    } else if !args.is_empty() {\n+        panic!(\"unknown options\");\n+    }\n+\n+    let stdout_backup = unsafe { libc::dup(libc::STDOUT_FILENO) };\n+    let stderr_backup = unsafe { libc::dup(libc::STDERR_FILENO) };\n+    assert!(stdout_backup > -1);\n+    assert!(stderr_backup > -1);\n+\n+    let (stdout_reader, stdout_writer) = pipe();\n+    let (stderr_reader, stderr_writer) = pipe();\n+    assert!(unsafe { libc::dup2(stdout_writer, libc::STDOUT_FILENO) } > -1);\n+    assert!(unsafe { libc::dup2(stderr_writer, libc::STDERR_FILENO) } > -1);\n+\n+    // Make sure we close any duplicates of the writer end of the pipe,\n+    // otherwise we can get stuck reading from the pipe which has open\n+    // writers but no one supplying any input\n+    assert_eq!(unsafe { libc::close(stdout_writer) }, 0);\n+    assert_eq!(unsafe { libc::close(stderr_writer) }, 0);\n+\n+    stdout().write_all(\"parent stdout\\n\".as_bytes()).expect(\"failed to write to stdout\");\n+    stderr().write_all(\"parent stderr\\n\".as_bytes()).expect(\"failed to write to stderr\");\n+\n+    let child = {\n+        Command::new(name)\n+            .arg(\"--child\")\n+            .stdin(Stdio::inherit())\n+            .stdout(unsafe { FromRawFd::from_raw_fd(libc::STDERR_FILENO) })\n+            .stderr(unsafe { FromRawFd::from_raw_fd(libc::STDOUT_FILENO) })\n+            .spawn()\n+    };\n+\n+    // The Stdio passed into the Command took over (and closed) std{out, err}\n+    // so we should restore them as they were.\n+    assert!(unsafe { libc::dup2(stdout_backup, libc::STDOUT_FILENO) } > -1);\n+    assert!(unsafe { libc::dup2(stderr_backup, libc::STDERR_FILENO) } > -1);\n+\n+    // Using File as a shim around the descriptor\n+    let mut read = String::new();\n+    let mut f: File = unsafe { FromRawFd::from_raw_fd(stdout_reader) };\n+    f.read_to_string(&mut read).expect(\"failed to read from stdout file\");\n+    assert_eq!(read, \"parent stdout\\nchild stderr\\n\");\n+\n+    // Using File as a shim around the descriptor\n+    read.clear();\n+    let mut f: File = unsafe { FromRawFd::from_raw_fd(stderr_reader) };\n+    f.read_to_string(&mut read).expect(\"failed to read from stderr file\");\n+    assert_eq!(read, \"parent stderr\\nchild stdout\\n\");\n+\n+    assert!(child.expect(\"failed to execute child process\").wait().unwrap().success());\n+}\n+\n+#[cfg(unix)]\n+fn child() {\n+    stdout().write_all(\"child stdout\\n\".as_bytes()).expect(\"child failed to write to stdout\");\n+    stderr().write_all(\"child stderr\\n\".as_bytes()).expect(\"child failed to write to stderr\");\n+}\n+\n+#[cfg(unix)]\n+/// Returns a pipe (reader, writer combo)\n+fn pipe() -> (i32, i32) {\n+     let mut fds = [0; 2];\n+     assert_eq!(unsafe { libc::pipe(fds.as_mut_ptr()) }, 0);\n+     (fds[0], fds[1])\n+}"}]}