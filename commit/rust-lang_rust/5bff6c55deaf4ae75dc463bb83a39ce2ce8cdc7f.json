{"sha": "5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f", "node_id": "C_kwDOAAsO6NoAKDViZmY2YzU1ZGVhZjRhZTc1ZGM0NjNiYjgzYTM5Y2UyY2U4Y2RjN2Y", "commit": {"author": {"name": "feniljain", "email": "fkjainco@gmail.com", "date": "2022-10-07T19:24:57Z"}, "committer": {"name": "feniljain", "email": "fkjainco@gmail.com", "date": "2022-10-20T11:17:23Z"}, "message": "feat: add multiple getters mode in `generate_getter`\n\nThis commit adds two modes to generate_getter action.\nFirst, the plain old working on single fields.\nSecond, working on a selected range of fields.", "tree": {"sha": "f2e9aa51cd815af65cbc8ba5e88872e8e5a7baa3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2e9aa51cd815af65cbc8ba5e88872e8e5a7baa3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f", "html_url": "https://github.com/rust-lang/rust/commit/5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f/comments", "author": {"login": "feniljain", "id": 49019259, "node_id": "MDQ6VXNlcjQ5MDE5MjU5", "avatar_url": "https://avatars.githubusercontent.com/u/49019259?v=4", "gravatar_id": "", "url": "https://api.github.com/users/feniljain", "html_url": "https://github.com/feniljain", "followers_url": "https://api.github.com/users/feniljain/followers", "following_url": "https://api.github.com/users/feniljain/following{/other_user}", "gists_url": "https://api.github.com/users/feniljain/gists{/gist_id}", "starred_url": "https://api.github.com/users/feniljain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/feniljain/subscriptions", "organizations_url": "https://api.github.com/users/feniljain/orgs", "repos_url": "https://api.github.com/users/feniljain/repos", "events_url": "https://api.github.com/users/feniljain/events{/privacy}", "received_events_url": "https://api.github.com/users/feniljain/received_events", "type": "User", "site_admin": false}, "committer": {"login": "feniljain", "id": 49019259, "node_id": "MDQ6VXNlcjQ5MDE5MjU5", "avatar_url": "https://avatars.githubusercontent.com/u/49019259?v=4", "gravatar_id": "", "url": "https://api.github.com/users/feniljain", "html_url": "https://github.com/feniljain", "followers_url": "https://api.github.com/users/feniljain/followers", "following_url": "https://api.github.com/users/feniljain/following{/other_user}", "gists_url": "https://api.github.com/users/feniljain/gists{/gist_id}", "starred_url": "https://api.github.com/users/feniljain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/feniljain/subscriptions", "organizations_url": "https://api.github.com/users/feniljain/orgs", "repos_url": "https://api.github.com/users/feniljain/repos", "events_url": "https://api.github.com/users/feniljain/events{/privacy}", "received_events_url": "https://api.github.com/users/feniljain/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97b357e41b99ee3d5dd72a1640f6c74e4f4d6b64", "url": "https://api.github.com/repos/rust-lang/rust/commits/97b357e41b99ee3d5dd72a1640f6c74e4f4d6b64", "html_url": "https://github.com/rust-lang/rust/commit/97b357e41b99ee3d5dd72a1640f6c74e4f4d6b64"}], "stats": {"total": 361, "additions": 292, "deletions": 69}, "files": [{"sha": "ceae80755037c00b56f401edb70c5a6264cb176e", "filename": "crates/ide-assists/src/handlers/generate_delegate_methods.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs?ref=5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f", "patch": "@@ -51,14 +51,14 @@ pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext<'\n         Some(field) => {\n             let field_name = field.name()?;\n             let field_ty = field.ty()?;\n-            (format!(\"{field_name}\"), field_ty, field.syntax().text_range())\n+            (field_name.to_string(), field_ty, field.syntax().text_range())\n         }\n         None => {\n             let field = ctx.find_node_at_offset::<ast::TupleField>()?;\n             let field_list = ctx.find_node_at_offset::<ast::TupleFieldList>()?;\n             let field_list_index = field_list.fields().position(|it| it == field)?;\n             let field_ty = field.ty()?;\n-            (format!(\"{field_list_index}\"), field_ty, field.syntax().text_range())\n+            (field_list_index.to_string(), field_ty, field.syntax().text_range())\n         }\n     };\n \n@@ -77,13 +77,11 @@ pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext<'\n     for method in methods {\n         let adt = ast::Adt::Struct(strukt.clone());\n         let name = method.name(ctx.db()).to_string();\n-        let impl_def = find_struct_impl(ctx, &adt, &name).flatten();\n-        let method_name = method.name(ctx.db());\n-\n+        let impl_def = find_struct_impl(ctx, &adt, &[name]).flatten();\n         acc.add_group(\n             &GroupLabel(\"Generate delegate methods\u2026\".to_owned()),\n             AssistId(\"generate_delegate_methods\", AssistKind::Generate),\n-            format!(\"Generate delegate for `{field_name}.{method_name}()`\"),\n+            format!(\"Generate delegate for `{}.{}()`\", field_name, method.name(ctx.db())),\n             target,\n             |builder| {\n                 // Create the function\n@@ -158,7 +156,7 @@ pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext<'\n                             }\n                             None => {\n                                 let offset = strukt.syntax().text_range().end();\n-                                let snippet = format!(\"\\n\\n{impl_def}\");\n+                                let snippet = format!(\"\\n\\n{}\", impl_def.syntax());\n                                 builder.insert(offset, snippet);\n                             }\n                         }"}, {"sha": "63e91b835f1f857d651b2a7daf2eac7675980145", "filename": "crates/ide-assists/src/handlers/generate_enum_is_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_is_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_is_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_is_method.rs?ref=5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f", "patch": "@@ -52,7 +52,7 @@ pub(crate) fn generate_enum_is_method(acc: &mut Assists, ctx: &AssistContext<'_>\n     let fn_name = format!(\"is_{}\", &to_lower_snake_case(&variant_name.text()));\n \n     // Return early if we've found an existing new fn\n-    let impl_def = find_struct_impl(ctx, &parent_enum, &fn_name)?;\n+    let impl_def = find_struct_impl(ctx, &parent_enum, &[fn_name.clone()])?;\n \n     let target = variant.syntax().text_range();\n     acc.add_group("}, {"sha": "bdd3cf4f06c253692d3e3989075ec4cd56e4ba15", "filename": "crates/ide-assists/src/handlers/generate_enum_projection_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs?ref=5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f", "patch": "@@ -147,7 +147,7 @@ fn generate_enum_projection_method(\n     let fn_name = format!(\"{}_{}\", fn_name_prefix, &to_lower_snake_case(&variant_name.text()));\n \n     // Return early if we've found an existing new fn\n-    let impl_def = find_struct_impl(ctx, &parent_enum, &fn_name)?;\n+    let impl_def = find_struct_impl(ctx, &parent_enum, &[fn_name.clone()])?;\n \n     let target = variant.syntax().text_range();\n     acc.add_group("}, {"sha": "c229127e48ffca348a66a7d56a54b75e8cb34c0a", "filename": "crates/ide-assists/src/handlers/generate_function.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f", "patch": "@@ -198,7 +198,7 @@ fn get_adt_source(\n     let file = ctx.sema.parse(range.file_id);\n     let adt_source =\n         ctx.sema.find_node_at_offset_with_macros(file.syntax(), range.range.start())?;\n-    find_struct_impl(ctx, &adt_source, fn_name).map(|impl_| (impl_, range.file_id))\n+    find_struct_impl(ctx, &adt_source, &[fn_name.to_string()]).map(|impl_| (impl_, range.file_id))\n }\n \n struct FunctionTemplate {"}, {"sha": "5e71914283495e7a44afd3310bb015406285a38c", "filename": "crates/ide-assists/src/handlers/generate_getter.rs", "status": "modified", "additions": 272, "deletions": 49, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs?ref=5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f", "patch": "@@ -1,6 +1,9 @@\n use ide_db::famous_defs::FamousDefs;\n use stdx::{format_to, to_lower_snake_case};\n-use syntax::ast::{self, AstNode, HasName, HasVisibility};\n+use syntax::{\n+    ast::{self, AstNode, HasName, HasVisibility},\n+    TextRange,\n+};\n \n use crate::{\n     utils::{convert_reference_type, find_impl_block_end, find_struct_impl, generate_impl_text},\n@@ -72,88 +75,259 @@ pub(crate) fn generate_getter_mut(acc: &mut Assists, ctx: &AssistContext<'_>) ->\n     generate_getter_impl(acc, ctx, true)\n }\n \n+#[derive(Clone, Debug)]\n+struct RecordFieldInfo {\n+    field_name: syntax::ast::Name,\n+    field_ty: syntax::ast::Type,\n+    fn_name: String,\n+    target: TextRange,\n+}\n+\n+struct GetterInfo {\n+    impl_def: Option<ast::Impl>,\n+    strukt: ast::Struct,\n+    mutable: bool,\n+}\n+\n pub(crate) fn generate_getter_impl(\n     acc: &mut Assists,\n     ctx: &AssistContext<'_>,\n     mutable: bool,\n ) -> Option<()> {\n-    let strukt = ctx.find_node_at_offset::<ast::Struct>()?;\n-    let field = ctx.find_node_at_offset::<ast::RecordField>()?;\n+    // This if condition denotes two modes this assist can work in:\n+    // - First is acting upon selection of record fields\n+    // - Next is acting upon a single record field\n+    //\n+    // This is the only part where implementation diverges a bit,\n+    // subsequent code is generic for both of these modes\n \n-    let field_name = field.name()?;\n-    let field_ty = field.ty()?;\n+    let (strukt, info_of_record_fields, fn_names) = if !ctx.has_empty_selection() {\n+        // Selection Mode\n+        let node = ctx.covering_element();\n \n-    // Return early if we've found an existing fn\n-    let mut fn_name = to_lower_snake_case(&field_name.to_string());\n-    if mutable {\n-        format_to!(fn_name, \"_mut\");\n+        let node = match node {\n+            syntax::NodeOrToken::Node(n) => n,\n+            syntax::NodeOrToken::Token(t) => t.parent()?,\n+        };\n+\n+        let parent_struct = node.ancestors().find_map(ast::Struct::cast)?;\n+\n+        let (info_of_record_fields, field_names) =\n+            extract_and_parse_record_fields(&parent_struct, ctx.selection_trimmed(), mutable)?;\n+\n+        (parent_struct, info_of_record_fields, field_names)\n+    } else {\n+        // Single Record Field mode\n+        let strukt = ctx.find_node_at_offset::<ast::Struct>()?;\n+        let field = ctx.find_node_at_offset::<ast::RecordField>()?;\n+\n+        let record_field_info = parse_record_field(field, mutable)?;\n+\n+        let fn_name = record_field_info.fn_name.clone();\n+\n+        (strukt, vec![record_field_info], vec![fn_name])\n+    };\n+\n+    // No record fields to do work on :(\n+    if info_of_record_fields.len() == 0 {\n+        return None;\n     }\n-    let impl_def = find_struct_impl(ctx, &ast::Adt::Struct(strukt.clone()), fn_name.as_str())?;\n+\n+    let impl_def = find_struct_impl(ctx, &ast::Adt::Struct(strukt.clone()), &fn_names)?;\n \n     let (id, label) = if mutable {\n         (\"generate_getter_mut\", \"Generate a mut getter method\")\n     } else {\n         (\"generate_getter\", \"Generate a getter method\")\n     };\n-    let target = field.syntax().text_range();\n+\n+    // Computing collective text range of all record fields in selected region\n+    let target: TextRange = info_of_record_fields\n+        .iter()\n+        .map(|record_field_info| record_field_info.target)\n+        .reduce(|acc, target| acc.cover(target))?;\n+\n+    let getter_info = GetterInfo { impl_def, strukt, mutable };\n+\n     acc.add_group(\n         &GroupLabel(\"Generate getter/setter\".to_owned()),\n         AssistId(id, AssistKind::Generate),\n         label,\n         target,\n         |builder| {\n+            let record_fields_count = info_of_record_fields.len();\n+\n             let mut buf = String::with_capacity(512);\n \n-            if impl_def.is_some() {\n-                buf.push('\\n');\n+            // Check if an impl exists\n+            if let Some(impl_def) = &getter_info.impl_def {\n+                // Check if impl is empty\n+                if let Some(assoc_item_list) = impl_def.assoc_item_list() {\n+                    if assoc_item_list.assoc_items().next().is_some() {\n+                        // If not empty then only insert a new line\n+                        buf.push('\\n');\n+                    }\n+                }\n             }\n \n-            let vis = strukt.visibility().map_or(String::new(), |v| format!(\"{v} \"));\n-            let (ty, body) = if mutable {\n-                (format!(\"&mut {field_ty}\"), format!(\"&mut self.{field_name}\"))\n-            } else {\n-                (|| {\n-                    let krate = ctx.sema.scope(field_ty.syntax())?.krate();\n-                    let famous_defs = &FamousDefs(&ctx.sema, krate);\n-                    ctx.sema\n-                        .resolve_type(&field_ty)\n-                        .and_then(|ty| convert_reference_type(ty, ctx.db(), famous_defs))\n-                        .map(|conversion| {\n-                            cov_mark::hit!(convert_reference_type);\n-                            (\n-                                conversion.convert_type(ctx.db()),\n-                                conversion.getter(field_name.to_string()),\n-                            )\n-                        })\n-                })()\n-                .unwrap_or_else(|| (format!(\"&{field_ty}\"), format!(\"&self.{field_name}\")))\n-            };\n-\n-            let mut_ = mutable.then(|| \"mut \").unwrap_or_default();\n-            format_to!(\n-                buf,\n-                \"    {vis}fn {fn_name}(&{mut_}self) -> {ty} {{\n-        {body}\n-    }}\"\n-            );\n-\n-            let start_offset = impl_def\n-                .and_then(|impl_def| find_impl_block_end(impl_def, &mut buf))\n+            for (i, record_field_info) in info_of_record_fields.iter().enumerate() {\n+                // this buf inserts a newline at the end of a getter\n+                // automatically, if one wants to add one more newline\n+                // for separating it from other assoc items, that needs\n+                // to be handled spearately\n+                let mut getter_buf =\n+                    generate_getter_from_info(ctx, &getter_info, &record_field_info);\n+\n+                // Insert `$0` only for last getter we generate\n+                if i == record_fields_count - 1 {\n+                    getter_buf = getter_buf.replacen(\"fn \", \"fn $0\", 1);\n+                }\n+\n+                // For first element we do not merge with '\\n', as\n+                // that can be inserted by impl_def check defined\n+                // above, for other cases which are:\n+                //\n+                // - impl exists but it empty, here we would ideally\n+                // not want to keep newline between impl <struct> {\n+                // and fn <fn-name>() { line\n+                //\n+                // - next if impl itself does not exist, in this\n+                // case we ourselves generate a new impl and that\n+                // again ends up with the same reasoning as above\n+                // for not keeping newline\n+                if i == 0 {\n+                    buf = buf + &getter_buf;\n+                } else {\n+                    buf = buf + \"\\n\" + &getter_buf;\n+                }\n+\n+                // We don't insert a new line at the end of\n+                // last getter as it will end up in the end\n+                // of an impl where we would not like to keep\n+                // getter and end of impl ( i.e. `}` ) with an\n+                // extra line for no reason\n+                if i < record_fields_count - 1 {\n+                    buf = buf + \"\\n\";\n+                }\n+            }\n+\n+            let start_offset = getter_info\n+                .impl_def\n+                .as_ref()\n+                .and_then(|impl_def| find_impl_block_end(impl_def.to_owned(), &mut buf))\n                 .unwrap_or_else(|| {\n-                    buf = generate_impl_text(&ast::Adt::Struct(strukt.clone()), &buf);\n-                    strukt.syntax().text_range().end()\n+                    buf = generate_impl_text(&ast::Adt::Struct(getter_info.strukt.clone()), &buf);\n+                    getter_info.strukt.syntax().text_range().end()\n                 });\n \n             match ctx.config.snippet_cap {\n-                Some(cap) => {\n-                    builder.insert_snippet(cap, start_offset, buf.replacen(\"fn \", \"fn $0\", 1))\n-                }\n+                Some(cap) => builder.insert_snippet(cap, start_offset, buf),\n                 None => builder.insert(start_offset, buf),\n             }\n         },\n     )\n }\n \n+fn generate_getter_from_info(\n+    ctx: &AssistContext<'_>,\n+    info: &GetterInfo,\n+    record_field_info: &RecordFieldInfo,\n+) -> String {\n+    let mut buf = String::with_capacity(512);\n+\n+    let vis = info.strukt.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n+    let (ty, body) = if info.mutable {\n+        (\n+            format!(\"&mut {}\", record_field_info.field_ty),\n+            format!(\"&mut self.{}\", record_field_info.field_name),\n+        )\n+    } else {\n+        (|| {\n+            let krate = ctx.sema.scope(record_field_info.field_ty.syntax())?.krate();\n+            let famous_defs = &FamousDefs(&ctx.sema, krate);\n+            ctx.sema\n+                .resolve_type(&record_field_info.field_ty)\n+                .and_then(|ty| convert_reference_type(ty, ctx.db(), famous_defs))\n+                .map(|conversion| {\n+                    cov_mark::hit!(convert_reference_type);\n+                    (\n+                        conversion.convert_type(ctx.db()),\n+                        conversion.getter(record_field_info.field_name.to_string()),\n+                    )\n+                })\n+        })()\n+        .unwrap_or_else(|| {\n+            (\n+                format!(\"&{}\", record_field_info.field_ty),\n+                format!(\"&self.{}\", record_field_info.field_name),\n+            )\n+        })\n+    };\n+\n+    format_to!(\n+        buf,\n+        \"    {}fn {}(&{}self) -> {} {{\n+        {}\n+    }}\",\n+        vis,\n+        record_field_info.fn_name,\n+        info.mutable.then(|| \"mut \").unwrap_or_default(),\n+        ty,\n+        body,\n+    );\n+\n+    buf\n+}\n+\n+fn extract_and_parse_record_fields(\n+    node: &ast::Struct,\n+    selection_range: TextRange,\n+    mutable: bool,\n+) -> Option<(Vec<RecordFieldInfo>, Vec<String>)> {\n+    let mut field_names: Vec<String> = vec![];\n+    let field_list = node.field_list()?;\n+\n+    match field_list {\n+        ast::FieldList::RecordFieldList(ele) => {\n+            let info_of_record_fields_in_selection = ele\n+                .fields()\n+                .filter_map(|record_field| {\n+                    if selection_range.contains_range(record_field.syntax().text_range()) {\n+                        let record_field_info = parse_record_field(record_field, mutable)?;\n+                        field_names.push(record_field_info.fn_name.clone());\n+                        return Some(record_field_info);\n+                    }\n+\n+                    None\n+                })\n+                .collect::<Vec<RecordFieldInfo>>();\n+\n+            if info_of_record_fields_in_selection.len() == 0 {\n+                return None;\n+            }\n+\n+            Some((info_of_record_fields_in_selection, field_names))\n+        }\n+        ast::FieldList::TupleFieldList(_) => {\n+            return None;\n+        }\n+    }\n+}\n+\n+fn parse_record_field(record_field: ast::RecordField, mutable: bool) -> Option<RecordFieldInfo> {\n+    let field_name = record_field.name()?;\n+    let field_ty = record_field.ty()?;\n+\n+    let mut fn_name = to_lower_snake_case(&field_name.to_string());\n+    if mutable {\n+        format_to!(fn_name, \"_mut\");\n+    }\n+\n+    let target = record_field.syntax().text_range();\n+\n+    Some(RecordFieldInfo { field_name, field_ty, fn_name, target })\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -485,4 +659,53 @@ impl Context {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn test_generate_multiple_getters_from_selection() {\n+        check_assist(\n+            generate_getter,\n+            r#\"\n+struct Context {\n+    $0data: Data,\n+    count: usize,$0\n+}\n+    \"#,\n+            r#\"\n+struct Context {\n+    data: Data,\n+    count: usize,\n+}\n+\n+impl Context {\n+    fn data(&self) -> &Data {\n+        &self.data\n+    }\n+\n+    fn $0count(&self) -> &usize {\n+        &self.count\n+    }\n+}\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_multiple_getters_from_selection_one_already_exists() {\n+        // As impl for one of the fields already exist, skip it\n+        check_assist_not_applicable(\n+            generate_getter,\n+            r#\"\n+struct Context {\n+    $0data: Data,\n+    count: usize,$0\n+}\n+\n+impl Context {\n+    fn data(&self) -> &Data {\n+        &self.data\n+    }\n+}\n+    \"#,\n+        );\n+    }\n }"}, {"sha": "17fadea0eaf19d28737afadc72a6b43861ba4fce", "filename": "crates/ide-assists/src/handlers/generate_new.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs?ref=5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f", "patch": "@@ -39,7 +39,8 @@ pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option\n     };\n \n     // Return early if we've found an existing new fn\n-    let impl_def = find_struct_impl(ctx, &ast::Adt::Struct(strukt.clone()), \"new\")?;\n+    let impl_def =\n+        find_struct_impl(ctx, &ast::Adt::Struct(strukt.clone()), &[String::from(\"new\")])?;\n \n     let current_module = ctx.sema.scope(strukt.syntax())?.module();\n "}, {"sha": "62f72df1c9d619823fa08bbac6352453df429cff", "filename": "crates/ide-assists/src/handlers/generate_setter.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_setter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_setter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_setter.rs?ref=5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f", "patch": "@@ -36,11 +36,8 @@ pub(crate) fn generate_setter(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opt\n \n     // Return early if we've found an existing fn\n     let fn_name = to_lower_snake_case(&field_name.to_string());\n-    let impl_def = find_struct_impl(\n-        ctx,\n-        &ast::Adt::Struct(strukt.clone()),\n-        format!(\"set_{fn_name}\").as_str(),\n-    )?;\n+    let impl_def =\n+        find_struct_impl(ctx, &ast::Adt::Struct(strukt.clone()), &[format!(\"set_{fn_name}\")])?;\n \n     let target = field.syntax().text_range();\n     acc.add_group("}, {"sha": "db32e7182c44d76ab78db38123862d8fe9f84257", "filename": "crates/ide-assists/src/utils.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f/crates%2Fide-assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f/crates%2Fide-assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Futils.rs?ref=5bff6c55deaf4ae75dc463bb83a39ce2ce8cdc7f", "patch": "@@ -331,10 +331,14 @@ fn calc_depth(pat: &ast::Pat, depth: usize) -> usize {\n // FIXME: change the new fn checking to a more semantic approach when that's more\n // viable (e.g. we process proc macros, etc)\n // FIXME: this partially overlaps with `find_impl_block_*`\n+\n+/// `find_struct_impl` looks for impl of a struct, but this also has additional feature\n+/// where it takes a list of function names and check if they exist inside impl_, if\n+/// even one match is found, it returns None\n pub(crate) fn find_struct_impl(\n     ctx: &AssistContext<'_>,\n     adt: &ast::Adt,\n-    name: &str,\n+    names: &[String],\n ) -> Option<Option<ast::Impl>> {\n     let db = ctx.db();\n     let module = adt.syntax().parent()?;\n@@ -362,20 +366,20 @@ pub(crate) fn find_struct_impl(\n     });\n \n     if let Some(ref impl_blk) = block {\n-        if has_fn(impl_blk, name) {\n+        if has_any_fn(impl_blk, names) {\n             return None;\n         }\n     }\n \n     Some(block)\n }\n \n-fn has_fn(imp: &ast::Impl, rhs_name: &str) -> bool {\n+fn has_any_fn(imp: &ast::Impl, names: &[String]) -> bool {\n     if let Some(il) = imp.assoc_item_list() {\n         for item in il.assoc_items() {\n             if let ast::AssocItem::Fn(f) = item {\n                 if let Some(name) = f.name() {\n-                    if name.text().eq_ignore_ascii_case(rhs_name) {\n+                    if names.iter().any(|n| n.eq_ignore_ascii_case(&name.text())) {\n                         return true;\n                     }\n                 }"}]}