{"sha": "7b7a1ed062edd438caa824b6a71aaaa56b48e7d4", "node_id": "C_kwDOAAsO6NoAKDdiN2ExZWQwNjJlZGQ0MzhjYWE4MjRiNmE3MWFhYWE1NmI0OGU3ZDQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-12-23T14:39:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-23T14:39:21Z"}, "message": "Merge #10933\n\n10933: show values of constants in hover r=lnicola a=HKalbasi\n\nFix #8497\r\ncc #8655\r\n\n\nCo-authored-by: hkalbasi <hamidrezakalbasi@protonmail.com>", "tree": {"sha": "d365090edbb3c1183eb948f969e2783bc39168b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d365090edbb3c1183eb948f969e2783bc39168b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b7a1ed062edd438caa824b6a71aaaa56b48e7d4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhxIoZCRBK7hj4Ov3rIwAAkjgIABhVPYZlXAT7Vur7BgL05yPF\nGakFaL6LV49i+62WZf2YAkpcrVOWer4rjpcTwQXe5y1NIa63LAZshcV2KNwe9roD\nOB8yjvY1GxpbtNQkabs16lHuZC9Ac9JN8wmMn732Ti1vGuTFQ3eZOdoZhiRF8p7r\nAG12MK1lZmKWraRXloqtZVkVG5j5ymZ32w378FEXIZ7pU3NFpIUbuyq5HajE4qQu\nY5ThNXzyZZAepWpntMgXXFzq0tdQo9mF6+UvNnPpUzZrzJAY9W5zOTawzRY+WN8X\naMCw4dg+7PUD9zywo9wGRBqnPyaWKNGs2mkqFbHvp9+qtRTuvtjjA7nQ43ZkRwI=\n=dQV4\n-----END PGP SIGNATURE-----\n", "payload": "tree d365090edbb3c1183eb948f969e2783bc39168b4\nparent cb0e270c026987e8863894a96fd19d33d7db1ef1\nparent e6139cf47ba0df3080110b391fe18af931780099\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1640270361 +0000\ncommitter GitHub <noreply@github.com> 1640270361 +0000\n\nMerge #10933\n\n10933: show values of constants in hover r=lnicola a=HKalbasi\n\nFix #8497\r\ncc #8655\r\n\n\nCo-authored-by: hkalbasi <hamidrezakalbasi@protonmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b7a1ed062edd438caa824b6a71aaaa56b48e7d4", "html_url": "https://github.com/rust-lang/rust/commit/7b7a1ed062edd438caa824b6a71aaaa56b48e7d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b7a1ed062edd438caa824b6a71aaaa56b48e7d4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb0e270c026987e8863894a96fd19d33d7db1ef1", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb0e270c026987e8863894a96fd19d33d7db1ef1", "html_url": "https://github.com/rust-lang/rust/commit/cb0e270c026987e8863894a96fd19d33d7db1ef1"}, {"sha": "e6139cf47ba0df3080110b391fe18af931780099", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6139cf47ba0df3080110b391fe18af931780099", "html_url": "https://github.com/rust-lang/rust/commit/e6139cf47ba0df3080110b391fe18af931780099"}], "stats": {"total": 413, "additions": 406, "deletions": 7}, "files": [{"sha": "6306ae534da59b0bb1429087ddd292716a6eee01", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a1ed062edd438caa824b6a71aaaa56b48e7d4/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a1ed062edd438caa824b6a71aaaa56b48e7d4/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=7b7a1ed062edd438caa824b6a71aaaa56b48e7d4", "patch": "@@ -31,7 +31,7 @@ pub mod db;\n \n mod display;\n \n-use std::{iter, ops::ControlFlow, sync::Arc};\n+use std::{collections::HashMap, iter, ops::ControlFlow, sync::Arc};\n \n use arrayvec::ArrayVec;\n use base_db::{CrateDisplayName, CrateId, CrateOrigin, Edition, FileId};\n@@ -50,7 +50,7 @@ use hir_def::{\n use hir_expand::{name::name, MacroCallKind, MacroDefKind};\n use hir_ty::{\n     autoderef,\n-    consteval::ConstExt,\n+    consteval::{eval_const, ComputedExpr, ConstEvalCtx, ConstEvalError, ConstExt},\n     could_unify,\n     diagnostics::BodyValidationDiagnostic,\n     method_resolution::{self, TyFingerprint},\n@@ -1532,6 +1532,23 @@ impl Const {\n         let ty = ctx.lower_ty(&data.type_ref);\n         Type::new_with_resolver_inner(db, krate.id, &resolver, ty)\n     }\n+\n+    pub fn eval(self, db: &dyn HirDatabase) -> Result<ComputedExpr, ConstEvalError> {\n+        let body = db.body(self.id.into());\n+        let root = &body.exprs[body.body_expr];\n+        let infer = db.infer_query(self.id.into());\n+        let infer = infer.as_ref();\n+        let result = eval_const(\n+            root,\n+            ConstEvalCtx {\n+                exprs: &body.exprs,\n+                pats: &body.pats,\n+                local_data: HashMap::default(),\n+                infer,\n+            },\n+        );\n+        result\n+    }\n }\n \n impl HasVisibility for Const {"}, {"sha": "0005a86b7f65f3fef318ed15ae80ba0be8e0bd50", "filename": "crates/hir_ty/src/consteval.rs", "status": "modified", "additions": 245, "deletions": 3, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a1ed062edd438caa824b6a71aaaa56b48e7d4/crates%2Fhir_ty%2Fsrc%2Fconsteval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a1ed062edd438caa824b6a71aaaa56b48e7d4/crates%2Fhir_ty%2Fsrc%2Fconsteval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fconsteval.rs?ref=7b7a1ed062edd438caa824b6a71aaaa56b48e7d4", "patch": "@@ -1,14 +1,17 @@\n //! Constant evaluation details\n \n-use std::convert::TryInto;\n+use std::{collections::HashMap, convert::TryInto, fmt::Display};\n \n+use chalk_ir::{IntTy, Scalar};\n use hir_def::{\n     builtin_type::BuiltinUint,\n-    expr::{Expr, Literal},\n+    expr::{ArithOp, BinaryOp, Expr, Literal, Pat},\n     type_ref::ConstScalar,\n };\n+use hir_expand::name::Name;\n+use la_arena::Arena;\n \n-use crate::{Const, ConstData, ConstValue, Interner, TyKind};\n+use crate::{Const, ConstData, ConstValue, InferenceResult, Interner, TyKind};\n \n /// Extension trait for [`Const`]\n pub trait ConstExt {\n@@ -38,6 +41,245 @@ impl ConstExt for Const {\n     }\n }\n \n+#[derive(Clone)]\n+pub struct ConstEvalCtx<'a> {\n+    pub exprs: &'a Arena<Expr>,\n+    pub pats: &'a Arena<Pat>,\n+    pub local_data: HashMap<Name, ComputedExpr>,\n+    pub infer: &'a InferenceResult,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub enum ConstEvalError {\n+    NotSupported(&'static str),\n+    TypeError,\n+    IncompleteExpr,\n+    Panic(String),\n+}\n+\n+#[derive(Clone)]\n+pub enum ComputedExpr {\n+    Literal(Literal),\n+    Tuple(Box<[ComputedExpr]>),\n+}\n+\n+impl Display for ComputedExpr {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            ComputedExpr::Literal(l) => match l {\n+                Literal::Int(x, _) => {\n+                    if *x >= 16 {\n+                        write!(f, \"{} ({:#X})\", x, x)\n+                    } else {\n+                        write!(f, \"{}\", x)\n+                    }\n+                }\n+                Literal::Uint(x, _) => {\n+                    if *x >= 16 {\n+                        write!(f, \"{} ({:#X})\", x, x)\n+                    } else {\n+                        write!(f, \"{}\", x)\n+                    }\n+                }\n+                Literal::Float(x, _) => write!(f, \"{}\", x),\n+                Literal::Bool(x) => write!(f, \"{}\", x),\n+                Literal::Char(x) => write!(f, \"{:?}\", x),\n+                Literal::String(x) => write!(f, \"{:?}\", x),\n+                Literal::ByteString(x) => write!(f, \"{:?}\", x),\n+            },\n+            ComputedExpr::Tuple(t) => {\n+                write!(f, \"(\")?;\n+                for x in &**t {\n+                    write!(f, \"{}, \", x)?;\n+                }\n+                write!(f, \")\")\n+            }\n+        }\n+    }\n+}\n+\n+fn scalar_max(scalar: &Scalar) -> i128 {\n+    match scalar {\n+        Scalar::Bool => 1,\n+        Scalar::Char => u32::MAX as i128,\n+        Scalar::Int(x) => match x {\n+            IntTy::Isize => isize::MAX as i128,\n+            IntTy::I8 => i8::MAX as i128,\n+            IntTy::I16 => i16::MAX as i128,\n+            IntTy::I32 => i32::MAX as i128,\n+            IntTy::I64 => i64::MAX as i128,\n+            IntTy::I128 => i128::MAX as i128,\n+        },\n+        Scalar::Uint(x) => match x {\n+            chalk_ir::UintTy::Usize => usize::MAX as i128,\n+            chalk_ir::UintTy::U8 => u8::MAX as i128,\n+            chalk_ir::UintTy::U16 => u16::MAX as i128,\n+            chalk_ir::UintTy::U32 => u32::MAX as i128,\n+            chalk_ir::UintTy::U64 => u64::MAX as i128,\n+            chalk_ir::UintTy::U128 => i128::MAX as i128, // ignore too big u128 for now\n+        },\n+        Scalar::Float(_) => 0,\n+    }\n+}\n+\n+fn is_valid(scalar: &Scalar, value: i128) -> bool {\n+    if value < 0 {\n+        !matches!(scalar, Scalar::Uint(_)) && -scalar_max(scalar) - 1 <= value\n+    } else {\n+        value <= scalar_max(scalar)\n+    }\n+}\n+\n+pub fn eval_const(expr: &Expr, mut ctx: ConstEvalCtx<'_>) -> Result<ComputedExpr, ConstEvalError> {\n+    match expr {\n+        Expr::Literal(l) => Ok(ComputedExpr::Literal(l.clone())),\n+        &Expr::UnaryOp { expr, op } => {\n+            let ty = &ctx.infer[expr];\n+            let ev = eval_const(&ctx.exprs[expr], ctx)?;\n+            match op {\n+                hir_def::expr::UnaryOp::Deref => Err(ConstEvalError::NotSupported(\"deref\")),\n+                hir_def::expr::UnaryOp::Not => {\n+                    let v = match ev {\n+                        ComputedExpr::Literal(Literal::Bool(b)) => {\n+                            return Ok(ComputedExpr::Literal(Literal::Bool(!b)))\n+                        }\n+                        ComputedExpr::Literal(Literal::Int(v, _)) => v,\n+                        ComputedExpr::Literal(Literal::Uint(v, _)) => v\n+                            .try_into()\n+                            .map_err(|_| ConstEvalError::NotSupported(\"too big u128\"))?,\n+                        _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n+                    };\n+                    let r = match ty.kind(Interner) {\n+                        TyKind::Scalar(Scalar::Uint(x)) => match x {\n+                            chalk_ir::UintTy::U8 => !(v as u8) as i128,\n+                            chalk_ir::UintTy::U16 => !(v as u16) as i128,\n+                            chalk_ir::UintTy::U32 => !(v as u32) as i128,\n+                            chalk_ir::UintTy::U64 => !(v as u64) as i128,\n+                            chalk_ir::UintTy::U128 => {\n+                                return Err(ConstEvalError::NotSupported(\"negation of u128\"))\n+                            }\n+                            chalk_ir::UintTy::Usize => !(v as usize) as i128,\n+                        },\n+                        TyKind::Scalar(Scalar::Int(x)) => match x {\n+                            chalk_ir::IntTy::I8 => !(v as i8) as i128,\n+                            chalk_ir::IntTy::I16 => !(v as i16) as i128,\n+                            chalk_ir::IntTy::I32 => !(v as i32) as i128,\n+                            chalk_ir::IntTy::I64 => !(v as i64) as i128,\n+                            chalk_ir::IntTy::I128 => !v,\n+                            chalk_ir::IntTy::Isize => !(v as isize) as i128,\n+                        },\n+                        _ => return Err(ConstEvalError::NotSupported(\"unreachable?\")),\n+                    };\n+                    Ok(ComputedExpr::Literal(Literal::Int(r, None)))\n+                }\n+                hir_def::expr::UnaryOp::Neg => {\n+                    let v = match ev {\n+                        ComputedExpr::Literal(Literal::Int(v, _)) => v,\n+                        ComputedExpr::Literal(Literal::Uint(v, _)) => v\n+                            .try_into()\n+                            .map_err(|_| ConstEvalError::NotSupported(\"too big u128\"))?,\n+                        _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n+                    };\n+                    Ok(ComputedExpr::Literal(Literal::Int(\n+                        v.checked_neg().ok_or_else(|| {\n+                            ConstEvalError::Panic(\"overflow in negation\".to_string())\n+                        })?,\n+                        None,\n+                    )))\n+                }\n+            }\n+        }\n+        &Expr::BinaryOp { lhs, rhs, op } => {\n+            let ty = &ctx.infer[lhs];\n+            let lhs = eval_const(&ctx.exprs[lhs], ctx.clone())?;\n+            let rhs = eval_const(&ctx.exprs[rhs], ctx.clone())?;\n+            let op = op.ok_or(ConstEvalError::IncompleteExpr)?;\n+            let v1 = match lhs {\n+                ComputedExpr::Literal(Literal::Int(v, _)) => v,\n+                ComputedExpr::Literal(Literal::Uint(v, _)) => {\n+                    v.try_into().map_err(|_| ConstEvalError::NotSupported(\"too big u128\"))?\n+                }\n+                _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n+            };\n+            let v2 = match rhs {\n+                ComputedExpr::Literal(Literal::Int(v, _)) => v,\n+                ComputedExpr::Literal(Literal::Uint(v, _)) => {\n+                    v.try_into().map_err(|_| ConstEvalError::NotSupported(\"too big u128\"))?\n+                }\n+                _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n+            };\n+            match op {\n+                BinaryOp::ArithOp(b) => {\n+                    let panic_arith = ConstEvalError::Panic(\n+                        \"attempt to run invalid arithmetic operation\".to_string(),\n+                    );\n+                    let r = match b {\n+                        ArithOp::Add => v1.checked_add(v2).ok_or_else(|| panic_arith.clone())?,\n+                        ArithOp::Mul => v1.checked_mul(v2).ok_or_else(|| panic_arith.clone())?,\n+                        ArithOp::Sub => v1.checked_sub(v2).ok_or_else(|| panic_arith.clone())?,\n+                        ArithOp::Div => v1.checked_div(v2).ok_or_else(|| panic_arith.clone())?,\n+                        ArithOp::Rem => v1.checked_rem(v2).ok_or_else(|| panic_arith.clone())?,\n+                        ArithOp::Shl => v1\n+                            .checked_shl(v2.try_into().map_err(|_| panic_arith.clone())?)\n+                            .ok_or_else(|| panic_arith.clone())?,\n+                        ArithOp::Shr => v1\n+                            .checked_shr(v2.try_into().map_err(|_| panic_arith.clone())?)\n+                            .ok_or_else(|| panic_arith.clone())?,\n+                        ArithOp::BitXor => v1 ^ v2,\n+                        ArithOp::BitOr => v1 | v2,\n+                        ArithOp::BitAnd => v1 & v2,\n+                    };\n+                    if let TyKind::Scalar(s) = ty.kind(Interner) {\n+                        if !is_valid(s, r) {\n+                            return Err(panic_arith);\n+                        }\n+                    }\n+                    Ok(ComputedExpr::Literal(Literal::Int(r, None)))\n+                }\n+                BinaryOp::LogicOp(_) => Err(ConstEvalError::TypeError),\n+                _ => return Err(ConstEvalError::NotSupported(\"bin op on this operators\")),\n+            }\n+        }\n+        Expr::Block { statements, tail, .. } => {\n+            for statement in &**statements {\n+                match statement {\n+                    &hir_def::expr::Statement::Let { pat, initializer, .. } => {\n+                        let pat = &ctx.pats[pat];\n+                        let name = match pat {\n+                            Pat::Bind { name, subpat, .. } if subpat.is_none() => name.clone(),\n+                            _ => {\n+                                return Err(ConstEvalError::NotSupported(\"complex patterns in let\"))\n+                            }\n+                        };\n+                        let value = match initializer {\n+                            Some(x) => eval_const(&ctx.exprs[x], ctx.clone())?,\n+                            None => continue,\n+                        };\n+                        ctx.local_data.insert(name, value);\n+                    }\n+                    &hir_def::expr::Statement::Expr { .. } => {\n+                        return Err(ConstEvalError::NotSupported(\"this kind of statement\"))\n+                    }\n+                }\n+            }\n+            let tail_expr = match tail {\n+                &Some(x) => &ctx.exprs[x],\n+                None => return Ok(ComputedExpr::Tuple(Box::new([]))),\n+            };\n+            eval_const(tail_expr, ctx)\n+        }\n+        Expr::Path(p) => {\n+            let name = p.mod_path().as_ident().ok_or(ConstEvalError::NotSupported(\"big paths\"))?;\n+            let r = ctx\n+                .local_data\n+                .get(name)\n+                .ok_or(ConstEvalError::NotSupported(\"Non local name resolution\"))?;\n+            Ok(r.clone())\n+        }\n+        _ => Err(ConstEvalError::NotSupported(\"This kind of expression\")),\n+    }\n+}\n+\n // FIXME: support more than just evaluating literals\n pub fn eval_usize(expr: &Expr) -> Option<u64> {\n     match expr {"}, {"sha": "9ae122d8a416e817969ec53957c37e9b7955fb54", "filename": "crates/ide/src/hover/render.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a1ed062edd438caa824b6a71aaaa56b48e7d4/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a1ed062edd438caa824b6a71aaaa56b48e7d4/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=7b7a1ed062edd438caa824b6a71aaaa56b48e7d4", "patch": "@@ -360,7 +360,13 @@ pub(super) fn definition(\n         Definition::Function(it) => label_and_docs(db, it),\n         Definition::Adt(it) => label_and_docs(db, it),\n         Definition::Variant(it) => label_and_docs(db, it),\n-        Definition::Const(it) => label_value_and_docs(db, it, |it| it.value(db)),\n+        Definition::Const(it) => label_value_and_docs(db, it, |it| {\n+            let body = it.eval(db);\n+            match body {\n+                Ok(x) => Some(format!(\"{}\", x)),\n+                Err(_) => it.value(db).map(|x| format!(\"{}\", x)),\n+            }\n+        }),\n         Definition::Static(it) => label_value_and_docs(db, it, |it| it.value(db)),\n         Definition::Trait(it) => label_and_docs(db, it),\n         Definition::TypeAlias(it) => label_and_docs(db, it),"}, {"sha": "82fc385040edf10231565ea10eb96dd56fde5685", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 135, "deletions": 1, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a1ed062edd438caa824b6a71aaaa56b48e7d4/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a1ed062edd438caa824b6a71aaaa56b48e7d4/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=7b7a1ed062edd438caa824b6a71aaaa56b48e7d4", "patch": "@@ -552,7 +552,7 @@ fn hover_const_static() {\n             ```\n \n             ```rust\n-            const foo: u32 = 123\n+            const foo: u32 = 123 (0x7B)\n             ```\n         \"#]],\n     );\n@@ -3278,6 +3278,140 @@ impl<const LEN: usize> Foo<LEN$0> {}\n     );\n }\n \n+#[test]\n+fn hover_const_eval() {\n+    check(\n+        r#\"\n+/// This is a doc\n+const FOO$0: usize = !0 & !(!0 >> 1);\n+\"#,\n+        expect![[r#\"\n+            *FOO*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const FOO: usize = 9223372036854775808 (0x8000000000000000)\n+            ```\n+\n+            ---\n+\n+            This is a doc\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+/// This is a doc\n+const FOO$0: usize = {\n+    let a = 3 + 2;\n+    let b = a * a;\n+    b\n+};\n+\"#,\n+        expect![[r#\"\n+            *FOO*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const FOO: usize = 25 (0x19)\n+            ```\n+\n+            ---\n+\n+            This is a doc\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+/// This is a doc\n+const FOO$0: usize = 1 << 10;\n+\"#,\n+        expect![[r#\"\n+            *FOO*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const FOO: usize = 1024 (0x400)\n+            ```\n+\n+            ---\n+\n+            This is a doc\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+/// This is a doc\n+const FOO$0: usize = 2 - 3;\n+\"#,\n+        expect![[r#\"\n+            *FOO*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const FOO: usize = 2 - 3\n+            ```\n+\n+            ---\n+\n+            This is a doc\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+/// This is a doc\n+const FOO$0: i32 = 2 - 3;\n+\"#,\n+        expect![[r#\"\n+            *FOO*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const FOO: i32 = -1\n+            ```\n+\n+            ---\n+\n+            This is a doc\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+/// This is a doc\n+const FOO$0: usize = 1 << 100;\n+\"#,\n+        expect![[r#\"\n+            *FOO*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const FOO: usize = 1 << 100\n+            ```\n+\n+            ---\n+\n+            This is a doc\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn hover_const_pat() {\n     check("}]}