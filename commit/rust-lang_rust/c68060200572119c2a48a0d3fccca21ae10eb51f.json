{"sha": "c68060200572119c2a48a0d3fccca21ae10eb51f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2ODA2MDIwMDU3MjExOWMyYTQ4YTBkM2ZjY2NhMjFhZTEwZWI1MWY=", "commit": {"author": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-08-18T17:10:52Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-08-18T17:50:23Z"}, "message": "Merge remote-tracking branch 'upstream/master' into rustup", "tree": {"sha": "818a98e803f3a8a6adde5c9914d2e3972fea653e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/818a98e803f3a8a6adde5c9914d2e3972fea653e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c68060200572119c2a48a0d3fccca21ae10eb51f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEqv54U47RUUXZfOLnLO/Nsn7QvnkFAl88FN8ACgkQLO/Nsn7Q\nvnmSEw//QeWeCEQTLfq7I04SgU+mIlfSDShJlTHFMlvk0otAgZdUkHL974mazFfh\nNZYo3eipJYfxbFn0V5RyTlbdODBNHbi0mFywFwZVLIoT1cL24RYEQguYr5XlXvQv\nBAafKMUk3PlQ/N2RjwLVJ3FiXGEleRw+emlJdMGLZ/4RLkO/EVniIfjtbDynwOTK\nq/TXaVpeanFcFHI4gd7jceqtWOP13ajW7z96zkQ/YYHj2Pnt6CZ0AiabkuP0T+Lh\nC3lfmIa093PA4aeqTJFzIUJ+QqrG1Wvwz4DfbZaTIestpUqkdyeN/PC9xeKr2SWG\nTJsLGqz7eyHy3fwn25zlLauUotj+7ET3ZwyNeUaNQn+BTVUxuQigwluAPnt/gti1\nWqFPGX9pKApe6vt1NYBS4qax+jWC9ATEk7jxS/ufSS6kILb09Jg3R9pQLW3sbiiG\nPt/lEmg7PM1TleB9Zw4FnruecHXJrwB1fI4/TzXongs1kvWfCGWK1FdYRZ/8TWqQ\nG4ytzPqSMZbrYnWjd4loOtO79pXYyOtp7t57wXL3A/a6Wsy3CIRzsPQfJtmAAmH7\nqXjChzsvXZvVmy3rQqgI59E+PTNssC9i3oFetFbekUhjAt3PyohqxMf/gBQBazi4\nPP1Ul1qeRYEy+vmaeXNliLQ+qhYrLPYddDpQLZIX5/gmI71Qbr4=\n=xAp/\n-----END PGP SIGNATURE-----", "payload": "tree 818a98e803f3a8a6adde5c9914d2e3972fea653e\nparent 4b0e6d5b90b8044a3201e3ddb4eef19b6a63c47b\nparent 9360ca6dc29839372382017a0e11988c94df430a\nauthor flip1995 <hello@philkrones.com> 1597770652 +0200\ncommitter flip1995 <hello@philkrones.com> 1597773023 +0200\n\nMerge remote-tracking branch 'upstream/master' into rustup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c68060200572119c2a48a0d3fccca21ae10eb51f", "html_url": "https://github.com/rust-lang/rust/commit/c68060200572119c2a48a0d3fccca21ae10eb51f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c68060200572119c2a48a0d3fccca21ae10eb51f/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b0e6d5b90b8044a3201e3ddb4eef19b6a63c47b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b0e6d5b90b8044a3201e3ddb4eef19b6a63c47b", "html_url": "https://github.com/rust-lang/rust/commit/4b0e6d5b90b8044a3201e3ddb4eef19b6a63c47b"}, {"sha": "9360ca6dc29839372382017a0e11988c94df430a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9360ca6dc29839372382017a0e11988c94df430a", "html_url": "https://github.com/rust-lang/rust/commit/9360ca6dc29839372382017a0e11988c94df430a"}], "stats": {"total": 3697, "additions": 2851, "deletions": 846}, "files": [{"sha": "5ce63c0a1574351c9b6de943086eda36a9374eb9", "filename": "CHANGELOG.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1690,6 +1690,7 @@ Released 2018-09-13\n [`same_functions_in_if_condition`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_functions_in_if_condition\n [`same_item_push`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_item_push\n [`search_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#search_is_some\n+[`self_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#self_assignment\n [`serde_api_misuse`]: https://rust-lang.github.io/rust-clippy/master/index.html#serde_api_misuse\n [`shadow_reuse`]: https://rust-lang.github.io/rust-clippy/master/index.html#shadow_reuse\n [`shadow_same`]: https://rust-lang.github.io/rust-clippy/master/index.html#shadow_same\n@@ -1699,6 +1700,7 @@ Released 2018-09-13\n [`should_implement_trait`]: https://rust-lang.github.io/rust-clippy/master/index.html#should_implement_trait\n [`similar_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#similar_names\n [`single_char_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_char_pattern\n+[`single_char_push_str`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_char_push_str\n [`single_component_path_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_component_path_imports\n [`single_match`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_match\n [`single_match_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_match_else\n@@ -1723,6 +1725,7 @@ Released 2018-09-13\n [`temporary_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#temporary_assignment\n [`temporary_cstring_as_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#temporary_cstring_as_ptr\n [`to_digit_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_digit_is_some\n+[`to_string_in_display`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_string_in_display\n [`todo`]: https://rust-lang.github.io/rust-clippy/master/index.html#todo\n [`too_many_arguments`]: https://rust-lang.github.io/rust-clippy/master/index.html#too_many_arguments\n [`too_many_lines`]: https://rust-lang.github.io/rust-clippy/master/index.html#too_many_lines\n@@ -1752,6 +1755,7 @@ Released 2018-09-13\n [`unnecessary_cast`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n [`unnecessary_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_filter_map\n [`unnecessary_fold`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_fold\n+[`unnecessary_lazy_evaluations`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_lazy_evaluations\n [`unnecessary_mut_passed`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_mut_passed\n [`unnecessary_operation`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_operation\n [`unnecessary_sort_by`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_sort_by"}, {"sha": "c7a3099b8ab0a4f0857cce4b5d079b359a27e85e", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -31,13 +31,13 @@ path = \"src/driver.rs\"\n # begin automatic update\n clippy_lints = { version = \"0.0.212\", path = \"clippy_lints\" }\n # end automatic update\n-semver = \"0.9\"\n+semver = \"0.10\"\n rustc_tools_util = { version = \"0.2.0\", path = \"rustc_tools_util\"}\n tempfile = { version = \"3.1.0\", optional = true }\n lazy_static = \"1.0\"\n \n [dev-dependencies]\n-cargo_metadata = \"0.9.1\"\n+cargo_metadata = \"0.11.1\"\n compiletest_rs = { version = \"0.5.0\", features = [\"tmp\"] }\n tester = \"0.7\"\n lazy_static = \"1.0\""}, {"sha": "cc7d3a04f003ee0728feb89aa83ef147fe12e7ac", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -17,7 +17,7 @@ keywords = [\"clippy\", \"lint\", \"plugin\"]\n edition = \"2018\"\n \n [dependencies]\n-cargo_metadata = \"0.9.1\"\n+cargo_metadata = \"0.11.1\"\n if_chain = \"1.0.0\"\n itertools = \"0.9\"\n lazy_static = \"1.0.2\"\n@@ -28,7 +28,7 @@ serde = { version = \"1.0\", features = [\"derive\"] }\n smallvec = { version = \"1\", features = [\"union\"] }\n toml = \"0.5.3\"\n unicode-normalization = \"0.1\"\n-semver = \"0.9.0\"\n+semver = \"0.10.0\"\n # NOTE: cargo requires serde feat in its url dep\n # see <https://github.com/rust-lang/rust/pull/63587#issuecomment-522343864>\n url = { version =  \"2.1.0\", features = [\"serde\"] }"}, {"sha": "b3185b88840142253648eb1eb033dca657d20aa6", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,5 +1,5 @@\n use crate::utils::{\n-    get_trait_def_id, implements_trait, snippet_opt, span_lint_and_then, trait_ref_of_method, SpanlessEq,\n+    eq_expr_value, get_trait_def_id, implements_trait, snippet_opt, span_lint_and_then, trait_ref_of_method,\n };\n use crate::utils::{higher, sugg};\n use if_chain::if_chain;\n@@ -70,11 +70,11 @@ impl<'tcx> LateLintPass<'tcx> for AssignOps {\n                         return;\n                     }\n                     // lhs op= l op r\n-                    if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, l) {\n+                    if eq_expr_value(cx, lhs, l) {\n                         lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, r);\n                     }\n                     // lhs op= l commutative_op r\n-                    if is_commutative(op.node) && SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, r) {\n+                    if is_commutative(op.node) && eq_expr_value(cx, lhs, r) {\n                         lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, l);\n                     }\n                 }\n@@ -161,14 +161,12 @@ impl<'tcx> LateLintPass<'tcx> for AssignOps {\n \n                     if visitor.counter == 1 {\n                         // a = a op b\n-                        if SpanlessEq::new(cx).ignore_fn().eq_expr(assignee, l) {\n+                        if eq_expr_value(cx, assignee, l) {\n                             lint(assignee, r);\n                         }\n                         // a = b commutative_op a\n                         // Limited to primitive type as these ops are know to be commutative\n-                        if SpanlessEq::new(cx).ignore_fn().eq_expr(assignee, r)\n-                            && cx.typeck_results().expr_ty(assignee).is_primitive_ty()\n-                        {\n+                        if eq_expr_value(cx, assignee, r) && cx.typeck_results().expr_ty(assignee).is_primitive_ty() {\n                             match op.node {\n                                 hir::BinOpKind::Add\n                                 | hir::BinOpKind::Mul\n@@ -253,7 +251,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        if SpanlessEq::new(self.cx).ignore_fn().eq_expr(self.assignee, expr) {\n+        if eq_expr_value(self.cx, self.assignee, expr) {\n             self.counter += 1;\n         }\n "}, {"sha": "cfcc1b3c5f356948df9bb333ccc292dd7a12e06e", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -5,8 +5,8 @@ use crate::utils::{\n     span_lint_and_sugg, span_lint_and_then, without_block_comments,\n };\n use if_chain::if_chain;\n-use rustc_ast::{AttrKind, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n+use rustc_ast::{AttrKind, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n use rustc_errors::Applicability;\n use rustc_hir::{\n     Block, Expr, ExprKind, ImplItem, ImplItemKind, Item, ItemKind, StmtKind, TraitFn, TraitItem, TraitItemKind,"}, {"sha": "280a2c7fe6770c68987354a8c7bfc7f8c527ef02", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::{\n-    get_trait_def_id, implements_trait, in_macro, is_type_diagnostic_item, paths, snippet_opt, span_lint_and_sugg,\n-    span_lint_and_then, SpanlessEq,\n+    eq_expr_value, get_trait_def_id, implements_trait, in_macro, is_type_diagnostic_item, paths, snippet_opt,\n+    span_lint_and_sugg, span_lint_and_then,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n@@ -128,7 +128,7 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n             }\n         }\n         for (n, expr) in self.terminals.iter().enumerate() {\n-            if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e, expr) {\n+            if eq_expr_value(self.cx, e, expr) {\n                 #[allow(clippy::cast_possible_truncation)]\n                 return Ok(Bool::Term(n as u8));\n             }\n@@ -138,8 +138,8 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                 if implements_ord(self.cx, e_lhs);\n                 if let ExprKind::Binary(expr_binop, expr_lhs, expr_rhs) = &expr.kind;\n                 if negate(e_binop.node) == Some(expr_binop.node);\n-                if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e_lhs, expr_lhs);\n-                if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e_rhs, expr_rhs);\n+                if eq_expr_value(self.cx, e_lhs, expr_lhs);\n+                if eq_expr_value(self.cx, e_rhs, expr_rhs);\n                 then {\n                     #[allow(clippy::cast_possible_truncation)]\n                     return Ok(Bool::Not(Box::new(Bool::Term(n as u8))));"}, {"sha": "10a64769585e543bdbfd46ae8cd59287080bfd5f", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,5 +1,5 @@\n+use crate::utils::{eq_expr_value, SpanlessEq, SpanlessHash};\n use crate::utils::{get_parent_expr, higher, if_sequence, snippet, span_lint_and_note, span_lint_and_then};\n-use crate::utils::{SpanlessEq, SpanlessHash};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::{Arm, Block, Expr, ExprKind, MatchSource, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -197,8 +197,7 @@ fn lint_same_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n         h.finish()\n     };\n \n-    let eq: &dyn Fn(&&Expr<'_>, &&Expr<'_>) -> bool =\n-        &|&lhs, &rhs| -> bool { SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, rhs) };\n+    let eq: &dyn Fn(&&Expr<'_>, &&Expr<'_>) -> bool = &|&lhs, &rhs| -> bool { eq_expr_value(cx, lhs, rhs) };\n \n     for (i, j) in search_same(conds, hash, eq) {\n         span_lint_and_note(\n@@ -222,7 +221,7 @@ fn lint_same_fns_in_if_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n \n     let eq: &dyn Fn(&&Expr<'_>, &&Expr<'_>) -> bool = &|&lhs, &rhs| -> bool {\n         // Do not spawn warning if `IFS_SAME_COND` already produced it.\n-        if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, rhs) {\n+        if eq_expr_value(cx, lhs, rhs) {\n             return false;\n         }\n         SpanlessEq::new(cx).eq_expr(lhs, rhs)"}, {"sha": "9555459e240e9f874ba29132cb32eb47fe531161", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 69, "deletions": 6, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,16 +1,22 @@\n use crate::utils::{implements_trait, is_entrypoint_fn, is_type_diagnostic_item, return_ty, span_lint};\n use if_chain::if_chain;\n use itertools::Itertools;\n-use rustc_ast::ast::{AttrKind, Attribute};\n+use rustc_ast::ast::{Async, AttrKind, Attribute, FnRetTy, ItemKind};\n use rustc_ast::token::CommentKind;\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::sync::Lrc;\n+use rustc_errors::emitter::EmitterWriter;\n+use rustc_errors::Handler;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty;\n+use rustc_parse::maybe_new_parser_from_source_str;\n+use rustc_session::parse::ParseSess;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::{BytePos, MultiSpan, Span};\n-use rustc_span::Pos;\n+use rustc_span::source_map::{BytePos, FilePathMapping, MultiSpan, SourceMap, Span};\n+use rustc_span::{FileName, Pos};\n+use std::io;\n use std::ops::Range;\n use url::Url;\n \n@@ -431,10 +437,67 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n     headers\n }\n \n-static LEAVE_MAIN_PATTERNS: &[&str] = &[\"static\", \"fn main() {}\", \"extern crate\", \"async fn main() {\"];\n-\n fn check_code(cx: &LateContext<'_>, text: &str, span: Span) {\n-    if text.contains(\"fn main() {\") && !LEAVE_MAIN_PATTERNS.iter().any(|p| text.contains(p)) {\n+    fn has_needless_main(code: &str) -> bool {\n+        let filename = FileName::anon_source_code(code);\n+\n+        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+        let emitter = EmitterWriter::new(box io::sink(), None, false, false, false, None, false);\n+        let handler = Handler::with_emitter(false, None, box emitter);\n+        let sess = ParseSess::with_span_handler(handler, sm);\n+\n+        let mut parser = match maybe_new_parser_from_source_str(&sess, filename, code.into()) {\n+            Ok(p) => p,\n+            Err(errs) => {\n+                for mut err in errs {\n+                    err.cancel();\n+                }\n+                return false;\n+            },\n+        };\n+\n+        let mut relevant_main_found = false;\n+        loop {\n+            match parser.parse_item() {\n+                Ok(Some(item)) => match &item.kind {\n+                    // Tests with one of these items are ignored\n+                    ItemKind::Static(..)\n+                    | ItemKind::Const(..)\n+                    | ItemKind::ExternCrate(..)\n+                    | ItemKind::ForeignMod(..) => return false,\n+                    // We found a main function ...\n+                    ItemKind::Fn(_, sig, _, Some(block)) if item.ident.name == sym!(main) => {\n+                        let is_async = matches!(sig.header.asyncness, Async::Yes{..});\n+                        let returns_nothing = match &sig.decl.output {\n+                            FnRetTy::Default(..) => true,\n+                            FnRetTy::Ty(ty) if ty.kind.is_unit() => true,\n+                            _ => false,\n+                        };\n+\n+                        if returns_nothing && !is_async && !block.stmts.is_empty() {\n+                            // This main function should be linted, but only if there are no other functions\n+                            relevant_main_found = true;\n+                        } else {\n+                            // This main function should not be linted, we're done\n+                            return false;\n+                        }\n+                    },\n+                    // Another function was found; this case is ignored too\n+                    ItemKind::Fn(..) => return false,\n+                    _ => {},\n+                },\n+                Ok(None) => break,\n+                Err(mut e) => {\n+                    e.cancel();\n+                    return false;\n+                },\n+            }\n+        }\n+\n+        relevant_main_found\n+    }\n+\n+    if has_needless_main(text) {\n         span_lint(cx, NEEDLESS_DOCTEST_MAIN, span, \"needless `fn main` in doctest\");\n     }\n }"}, {"sha": "19f56195ec1b483d693c8e20d6464ca4864c0fa9", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -6,7 +6,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n \n-use crate::utils::{snippet_with_applicability, span_lint_and_sugg, SpanlessEq};\n+use crate::utils::{eq_expr_value, snippet_with_applicability, span_lint_and_sugg};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for double comparisons that could be simplified to a single expression.\n@@ -46,8 +46,7 @@ impl<'tcx> DoubleComparisons {\n             },\n             _ => return,\n         };\n-        let mut spanless_eq = SpanlessEq::new(cx).ignore_fn();\n-        if !(spanless_eq.eq_expr(&llhs, &rlhs) && spanless_eq.eq_expr(&lrhs, &rrhs)) {\n+        if !(eq_expr_value(cx, &llhs, &rlhs) && eq_expr_value(cx, &lrhs, &rrhs)) {\n             return;\n         }\n         macro_rules! lint_double_comparison {"}, {"sha": "8ece44878fe32c6c7bcd1777e717cd6e185137ec", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -56,7 +56,7 @@ impl<'tcx> LateLintPass<'tcx> for DurationSubsec {\n                     cx,\n                     DURATION_SUBSEC,\n                     expr.span,\n-                    &format!(\"Calling `{}()` is more concise than this calculation\", suggested_fn),\n+                    &format!(\"calling `{}()` is more concise than this calculation\", suggested_fn),\n                     \"try\",\n                     format!(\n                         \"{}.{}()\","}, {"sha": "48caf48dbdb2cab0e80f0e2f4ee70e631c225a62", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -72,7 +72,7 @@ impl<'tcx> LateLintPass<'tcx> for UnportableVariant {\n                             cx,\n                             ENUM_CLIKE_UNPORTABLE_VARIANT,\n                             var.span,\n-                            \"Clike enum variant discriminant is not portable to 32-bit targets\",\n+                            \"C-like enum variant discriminant is not portable to 32-bit targets\",\n                         );\n                     };\n                 }"}, {"sha": "a9294a87f15d060d23878f0ff1a15705713d8395", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -183,10 +183,10 @@ fn check_variant(\n             && name.chars().nth(item_name_chars).map_or(false, |c| !c.is_lowercase())\n             && name.chars().nth(item_name_chars + 1).map_or(false, |c| !c.is_numeric())\n         {\n-            span_lint(cx, lint, var.span, \"Variant name starts with the enum's name\");\n+            span_lint(cx, lint, var.span, \"variant name starts with the enum's name\");\n         }\n         if partial_rmatch(item_name, &name) == item_name_chars {\n-            span_lint(cx, lint, var.span, \"Variant name ends with the enum's name\");\n+            span_lint(cx, lint, var.span, \"variant name ends with the enum's name\");\n         }\n     }\n     let first = &def.variants[0].ident.name.as_str();\n@@ -227,7 +227,7 @@ fn check_variant(\n         cx,\n         lint,\n         span,\n-        &format!(\"All variants have the same {}fix: `{}`\", what, value),\n+        &format!(\"all variants have the same {}fix: `{}`\", what, value),\n         None,\n         &format!(\n             \"remove the {}fixes and use full paths to \\"}, {"sha": "e16ec783fab79c6c6744bcfaa958786ca7e912e5", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,5 +1,5 @@\n use crate::utils::{\n-    implements_trait, in_macro, is_copy, multispan_sugg, snippet, span_lint, span_lint_and_then, SpanlessEq,\n+    eq_expr_value, implements_trait, in_macro, is_copy, multispan_sugg, snippet, span_lint, span_lint_and_then,\n };\n use rustc_errors::Applicability;\n use rustc_hir::{BinOp, BinOpKind, BorrowKind, Expr, ExprKind};\n@@ -69,7 +69,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n             if macro_with_not_op(&left.kind) || macro_with_not_op(&right.kind) {\n                 return;\n             }\n-            if is_valid_operator(op) && SpanlessEq::new(cx).ignore_fn().eq_expr(left, right) {\n+            if is_valid_operator(op) && eq_expr_value(cx, left, right) {\n                 span_lint(\n                     cx,\n                     EQ_OP,"}, {"sha": "1b02cee126d03b71af78ed69cba56e3cddbd9905", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -2,7 +2,7 @@ use crate::consts::{\n     constant, constant_simple, Constant,\n     Constant::{Int, F32, F64},\n };\n-use crate::utils::{get_parent_expr, higher, numeric_literal, span_lint_and_sugg, sugg, SpanlessEq};\n+use crate::utils::{eq_expr_value, get_parent_expr, higher, numeric_literal, span_lint_and_sugg, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, PathSegment, UnOp};\n@@ -363,8 +363,8 @@ fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n         if_chain! {\n             if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref lmul_lhs, ref lmul_rhs) = add_lhs.kind;\n             if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref rmul_lhs, ref rmul_rhs) = add_rhs.kind;\n-            if are_exprs_equal(cx, lmul_lhs, lmul_rhs);\n-            if are_exprs_equal(cx, rmul_lhs, rmul_rhs);\n+            if eq_expr_value(cx, lmul_lhs, lmul_rhs);\n+            if eq_expr_value(cx, rmul_lhs, rmul_rhs);\n             then {\n                 return Some(format!(\"{}.hypot({})\", Sugg::hir(cx, &lmul_lhs, \"..\"), Sugg::hir(cx, &rmul_lhs, \"..\")));\n             }\n@@ -502,8 +502,8 @@ fn check_mul_add(cx: &LateContext<'_>, expr: &Expr<'_>) {\n fn is_testing_positive(cx: &LateContext<'_>, expr: &Expr<'_>, test: &Expr<'_>) -> bool {\n     if let ExprKind::Binary(Spanned { node: op, .. }, left, right) = expr.kind {\n         match op {\n-            BinOpKind::Gt | BinOpKind::Ge => is_zero(cx, right) && are_exprs_equal(cx, left, test),\n-            BinOpKind::Lt | BinOpKind::Le => is_zero(cx, left) && are_exprs_equal(cx, right, test),\n+            BinOpKind::Gt | BinOpKind::Ge => is_zero(cx, right) && eq_expr_value(cx, left, test),\n+            BinOpKind::Lt | BinOpKind::Le => is_zero(cx, left) && eq_expr_value(cx, right, test),\n             _ => false,\n         }\n     } else {\n@@ -515,19 +515,15 @@ fn is_testing_positive(cx: &LateContext<'_>, expr: &Expr<'_>, test: &Expr<'_>) -\n fn is_testing_negative(cx: &LateContext<'_>, expr: &Expr<'_>, test: &Expr<'_>) -> bool {\n     if let ExprKind::Binary(Spanned { node: op, .. }, left, right) = expr.kind {\n         match op {\n-            BinOpKind::Gt | BinOpKind::Ge => is_zero(cx, left) && are_exprs_equal(cx, right, test),\n-            BinOpKind::Lt | BinOpKind::Le => is_zero(cx, right) && are_exprs_equal(cx, left, test),\n+            BinOpKind::Gt | BinOpKind::Ge => is_zero(cx, left) && eq_expr_value(cx, right, test),\n+            BinOpKind::Lt | BinOpKind::Le => is_zero(cx, right) && eq_expr_value(cx, left, test),\n             _ => false,\n         }\n     } else {\n         false\n     }\n }\n \n-fn are_exprs_equal(cx: &LateContext<'_>, expr1: &Expr<'_>, expr2: &Expr<'_>) -> bool {\n-    SpanlessEq::new(cx).ignore_fn().eq_expr(expr1, expr2)\n-}\n-\n /// Returns true iff expr is some zero literal\n fn is_zero(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     match constant_simple(cx, cx.typeck_results(), expr) {\n@@ -546,12 +542,12 @@ fn is_zero(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n /// returns None.\n fn are_negated<'a>(cx: &LateContext<'_>, expr1: &'a Expr<'a>, expr2: &'a Expr<'a>) -> Option<(bool, &'a Expr<'a>)> {\n     if let ExprKind::Unary(UnOp::UnNeg, expr1_negated) = &expr1.kind {\n-        if are_exprs_equal(cx, expr1_negated, expr2) {\n+        if eq_expr_value(cx, expr1_negated, expr2) {\n             return Some((false, expr2));\n         }\n     }\n     if let ExprKind::Unary(UnOp::UnNeg, expr2_negated) = &expr2.kind {\n-        if are_exprs_equal(cx, expr1, expr2_negated) {\n+        if eq_expr_value(cx, expr1, expr2_negated) {\n             return Some((true, expr1));\n         }\n     }\n@@ -614,7 +610,7 @@ fn are_same_base_logs(cx: &LateContext<'_>, expr_a: &Expr<'_>, expr_b: &Expr<'_>\n                 args_a.len() == args_b.len() &&\n                 (\n                     [\"ln\", \"log2\", \"log10\"].contains(&&*method_name_a.as_str()) ||\n-                    method_name_a.as_str() == \"log\" && args_a.len() == 2 && are_exprs_equal(cx, &args_a[1], &args_b[1])\n+                    method_name_a.as_str() == \"log\" && args_a.len() == 2 && eq_expr_value(cx, &args_a[1], &args_b[1])\n                 );\n         }\n     }"}, {"sha": "28b20cdeac343ecdf30c3cf66be49aa909765b96", "filename": "clippy_lints/src/if_let_some_result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_some_result.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -61,8 +61,8 @@ impl<'tcx> LateLintPass<'tcx> for OkIfLet {\n                     cx,\n                     IF_LET_SOME_RESULT,\n                     expr.span.with_hi(op.span.hi()),\n-                    \"Matching on `Some` with `ok()` is redundant\",\n-                    &format!(\"Consider matching on `Ok({})` and removing the call to `ok` instead\", some_expr_string),\n+                    \"matching on `Some` with `ok()` is redundant\",\n+                    &format!(\"consider matching on `Ok({})` and removing the call to `ok` instead\", some_expr_string),\n                     sugg,\n                     applicability,\n                 );"}, {"sha": "b86d2e766566bd16391dde7b738d288d873050ac", "filename": "clippy_lints/src/if_not_else.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fif_not_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fif_not_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_not_else.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -60,7 +60,7 @@ impl EarlyLintPass for IfNotElse {\n                             cx,\n                             IF_NOT_ELSE,\n                             item.span,\n-                            \"Unnecessary boolean `not` operation\",\n+                            \"unnecessary boolean `not` operation\",\n                             None,\n                             \"remove the `!` and swap the blocks of the `if`/`else`\",\n                         );\n@@ -70,7 +70,7 @@ impl EarlyLintPass for IfNotElse {\n                             cx,\n                             IF_NOT_ELSE,\n                             item.span,\n-                            \"Unnecessary `!=` operation\",\n+                            \"unnecessary `!=` operation\",\n                             None,\n                             \"change to `==` and swap the blocks of the `if`/`else`\",\n                         );"}, {"sha": "b57fe8dc4269e341b7f6299cae07331aff409562", "filename": "clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -158,9 +158,9 @@ fn print_lint_and_sugg(cx: &LateContext<'_>, var_name: &str, expr: &Expr<'_>) {\n         cx,\n         IMPLICIT_SATURATING_SUB,\n         expr.span,\n-        \"Implicitly performing saturating subtraction\",\n+        \"implicitly performing saturating subtraction\",\n         \"try\",\n-        format!(\"{} = {}.saturating_sub({});\", var_name, var_name, 1.to_string()),\n+        format!(\"{} = {}.saturating_sub({});\", var_name, var_name, '1'),\n         Applicability::MachineApplicable,\n     );\n }"}, {"sha": "4e6bb604785417977320c72d6de98ad623abd59e", "filename": "clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_impl.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -81,9 +81,9 @@ impl<'tcx> LateLintPass<'tcx> for MultipleInherentImpl {\n                             cx,\n                             MULTIPLE_INHERENT_IMPL,\n                             *additional_span,\n-                            \"Multiple implementations of this structure\",\n+                            \"multiple implementations of this structure\",\n                             |diag| {\n-                                diag.span_note(*initial_span, \"First implementation here\");\n+                                diag.span_note(*initial_span, \"first implementation here\");\n                             },\n                         )\n                     })"}, {"sha": "c629ee05ab97c1e2740441170c3ad142c857fbb7", "filename": "clippy_lints/src/int_plus_one.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fint_plus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fint_plus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fint_plus_one.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -152,7 +152,7 @@ impl IntPlusOne {\n             cx,\n             INT_PLUS_ONE,\n             block.span,\n-            \"Unnecessary `>= y + 1` or `x - 1 >=`\",\n+            \"unnecessary `>= y + 1` or `x - 1 >=`\",\n             \"change it to\",\n             recommendation,\n             Applicability::MachineApplicable, // snippet\n@@ -163,8 +163,8 @@ impl IntPlusOne {\n impl EarlyLintPass for IntPlusOne {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, item: &Expr) {\n         if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = item.kind {\n-            if let Some(ref rec) = Self::check_binop(cx, kind.node, lhs, rhs) {\n-                Self::emit_warning(cx, item, rec.clone());\n+            if let Some(rec) = Self::check_binop(cx, kind.node, lhs, rhs) {\n+                Self::emit_warning(cx, item, rec);\n             }\n         }\n     }"}, {"sha": "fa560ffb980c82407d748018b6b12717c7572267", "filename": "clippy_lints/src/let_and_return.rs", "status": "removed", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/4b0e6d5b90b8044a3201e3ddb4eef19b6a63c47b/clippy_lints%2Fsrc%2Flet_and_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0e6d5b90b8044a3201e3ddb4eef19b6a63c47b/clippy_lints%2Fsrc%2Flet_and_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_and_return.rs?ref=4b0e6d5b90b8044a3201e3ddb4eef19b6a63c47b", "patch": "@@ -1,124 +0,0 @@\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Block, Expr, ExprKind, PatKind, StmtKind};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::hir::map::Map;\n-use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-use crate::utils::{fn_def_id, in_macro, match_qpath, snippet_opt, span_lint_and_then};\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for `let`-bindings, which are subsequently\n-    /// returned.\n-    ///\n-    /// **Why is this bad?** It is just extraneous code. Remove it to make your code\n-    /// more rusty.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// fn foo() -> String {\n-    ///     let x = String::new();\n-    ///     x\n-    /// }\n-    /// ```\n-    /// instead, use\n-    /// ```\n-    /// fn foo() -> String {\n-    ///     String::new()\n-    /// }\n-    /// ```\n-    pub LET_AND_RETURN,\n-    style,\n-    \"creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\"\n-}\n-\n-declare_lint_pass!(LetReturn => [LET_AND_RETURN]);\n-\n-impl<'tcx> LateLintPass<'tcx> for LetReturn {\n-    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n-        // we need both a let-binding stmt and an expr\n-        if_chain! {\n-            if let Some(retexpr) = block.expr;\n-            if let Some(stmt) = block.stmts.iter().last();\n-            if let StmtKind::Local(local) = &stmt.kind;\n-            if local.ty.is_none();\n-            if local.attrs.is_empty();\n-            if let Some(initexpr) = &local.init;\n-            if let PatKind::Binding(.., ident, _) = local.pat.kind;\n-            if let ExprKind::Path(qpath) = &retexpr.kind;\n-            if match_qpath(qpath, &[&*ident.name.as_str()]);\n-            if !last_statement_borrows(cx, initexpr);\n-            if !in_external_macro(cx.sess(), initexpr.span);\n-            if !in_external_macro(cx.sess(), retexpr.span);\n-            if !in_external_macro(cx.sess(), local.span);\n-            if !in_macro(local.span);\n-            then {\n-                span_lint_and_then(\n-                    cx,\n-                    LET_AND_RETURN,\n-                    retexpr.span,\n-                    \"returning the result of a `let` binding from a block\",\n-                    |err| {\n-                        err.span_label(local.span, \"unnecessary `let` binding\");\n-\n-                        if let Some(snippet) = snippet_opt(cx, initexpr.span) {\n-                            err.multipart_suggestion(\n-                                \"return the expression directly\",\n-                                vec![\n-                                    (local.span, String::new()),\n-                                    (retexpr.span, snippet),\n-                                ],\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else {\n-                            err.span_help(initexpr.span, \"this expression can be directly returned\");\n-                        }\n-                    },\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn last_statement_borrows<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    let mut visitor = BorrowVisitor { cx, borrows: false };\n-    walk_expr(&mut visitor, expr);\n-    visitor.borrows\n-}\n-\n-struct BorrowVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    borrows: bool,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for BorrowVisitor<'_, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.borrows {\n-            return;\n-        }\n-\n-        if let Some(def_id) = fn_def_id(self.cx, expr) {\n-            self.borrows = self\n-                .cx\n-                .tcx\n-                .fn_sig(def_id)\n-                .output()\n-                .skip_binder()\n-                .walk()\n-                .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)));\n-        }\n-\n-        walk_expr(self, expr);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}"}, {"sha": "d45394ab8d21858593226425f114fb5a9b515ef4", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -218,7 +218,6 @@ mod large_const_arrays;\n mod large_enum_variant;\n mod large_stack_arrays;\n mod len_zero;\n-mod let_and_return;\n mod let_if_seq;\n mod let_underscore;\n mod lifetimes;\n@@ -285,6 +284,7 @@ mod reference;\n mod regex;\n mod repeat_once;\n mod returns;\n+mod self_assignment;\n mod serde_api;\n mod shadow;\n mod single_component_path_imports;\n@@ -296,6 +296,7 @@ mod swap;\n mod tabs_in_doc_comments;\n mod temporary_assignment;\n mod to_digit_is_some;\n+mod to_string_in_display;\n mod trait_bounds;\n mod transmute;\n mod transmuting_null;\n@@ -310,6 +311,7 @@ mod unnested_or_patterns;\n mod unsafe_removed_from_name;\n mod unused_io_amount;\n mod unused_self;\n+mod unused_unit;\n mod unwrap;\n mod use_self;\n mod useless_conversion;\n@@ -586,7 +588,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &large_stack_arrays::LARGE_STACK_ARRAYS,\n         &len_zero::LEN_WITHOUT_IS_EMPTY,\n         &len_zero::LEN_ZERO,\n-        &let_and_return::LET_AND_RETURN,\n         &let_if_seq::USELESS_LET_IF_SEQ,\n         &let_underscore::LET_UNDERSCORE_LOCK,\n         &let_underscore::LET_UNDERSCORE_MUST_USE,\n@@ -677,13 +678,15 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &methods::SEARCH_IS_SOME,\n         &methods::SHOULD_IMPLEMENT_TRAIT,\n         &methods::SINGLE_CHAR_PATTERN,\n+        &methods::SINGLE_CHAR_PUSH_STR,\n         &methods::SKIP_WHILE_NEXT,\n         &methods::STRING_EXTEND_CHARS,\n         &methods::SUSPICIOUS_MAP,\n         &methods::TEMPORARY_CSTRING_AS_PTR,\n         &methods::UNINIT_ASSUMED_INIT,\n         &methods::UNNECESSARY_FILTER_MAP,\n         &methods::UNNECESSARY_FOLD,\n+        &methods::UNNECESSARY_LAZY_EVALUATIONS,\n         &methods::UNWRAP_USED,\n         &methods::USELESS_ASREF,\n         &methods::WRONG_PUB_SELF_CONVENTION,\n@@ -769,8 +772,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &regex::INVALID_REGEX,\n         &regex::TRIVIAL_REGEX,\n         &repeat_once::REPEAT_ONCE,\n+        &returns::LET_AND_RETURN,\n         &returns::NEEDLESS_RETURN,\n-        &returns::UNUSED_UNIT,\n+        &self_assignment::SELF_ASSIGNMENT,\n         &serde_api::SERDE_API_MISUSE,\n         &shadow::SHADOW_REUSE,\n         &shadow::SHADOW_SAME,\n@@ -788,6 +792,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &tabs_in_doc_comments::TABS_IN_DOC_COMMENTS,\n         &temporary_assignment::TEMPORARY_ASSIGNMENT,\n         &to_digit_is_some::TO_DIGIT_IS_SOME,\n+        &to_string_in_display::TO_STRING_IN_DISPLAY,\n         &trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS,\n         &trait_bounds::TYPE_REPETITION_IN_BOUNDS,\n         &transmute::CROSSPOINTER_TRANSMUTE,\n@@ -840,6 +845,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME,\n         &unused_io_amount::UNUSED_IO_AMOUNT,\n         &unused_self::UNUSED_SELF,\n+        &unused_unit::UNUSED_UNIT,\n         &unwrap::PANICKING_UNWRAP,\n         &unwrap::UNNECESSARY_UNWRAP,\n         &use_self::USE_SELF,\n@@ -930,11 +936,11 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || box cognitive_complexity::CognitiveComplexity::new(cognitive_complexity_threshold));\n     let too_large_for_stack = conf.too_large_for_stack;\n     store.register_late_pass(move || box escape::BoxedLocal{too_large_for_stack});\n+    store.register_late_pass(move || box vec::UselessVec{too_large_for_stack});\n     store.register_late_pass(|| box panic_unimplemented::PanicUnimplemented);\n     store.register_late_pass(|| box strings::StringLitAsBytes);\n     store.register_late_pass(|| box derive::Derive);\n     store.register_late_pass(|| box types::CharLitAsU8);\n-    store.register_late_pass(|| box vec::UselessVec);\n     store.register_late_pass(|| box drop_bounds::DropBounds);\n     store.register_late_pass(|| box get_last_with_len::GetLastWithLen);\n     store.register_late_pass(|| box drop_forget_ref::DropForgetRef);\n@@ -1017,6 +1023,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| box reference::DerefAddrOf);\n     store.register_early_pass(|| box reference::RefInDeref);\n     store.register_early_pass(|| box double_parens::DoubleParens);\n+    store.register_late_pass(|| box to_string_in_display::ToStringInDisplay::new());\n     store.register_early_pass(|| box unsafe_removed_from_name::UnsafeNameRemoval);\n     store.register_early_pass(|| box if_not_else::IfNotElse);\n     store.register_early_pass(|| box else_if_without_else::ElseIfWithoutElse);\n@@ -1025,8 +1032,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| box misc_early::MiscEarlyLints);\n     store.register_early_pass(|| box redundant_closure_call::RedundantClosureCall);\n     store.register_late_pass(|| box redundant_closure_call::RedundantClosureCall);\n-    store.register_early_pass(|| box returns::Return);\n-    store.register_late_pass(|| box let_and_return::LetReturn);\n+    store.register_early_pass(|| box unused_unit::UnusedUnit);\n+    store.register_late_pass(|| box returns::Return);\n     store.register_early_pass(|| box collapsible_if::CollapsibleIf);\n     store.register_early_pass(|| box items_after_statements::ItemsAfterStatements);\n     store.register_early_pass(|| box precedence::Precedence);\n@@ -1085,6 +1092,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box pattern_type_mismatch::PatternTypeMismatch);\n     store.register_late_pass(|| box stable_sort_primitive::StableSortPrimitive);\n     store.register_late_pass(|| box repeat_once::RepeatOnce);\n+    store.register_late_pass(|| box self_assignment::SelfAssignment);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1284,7 +1292,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&large_enum_variant::LARGE_ENUM_VARIANT),\n         LintId::of(&len_zero::LEN_WITHOUT_IS_EMPTY),\n         LintId::of(&len_zero::LEN_ZERO),\n-        LintId::of(&let_and_return::LET_AND_RETURN),\n         LintId::of(&let_underscore::LET_UNDERSCORE_LOCK),\n         LintId::of(&lifetimes::EXTRA_UNUSED_LIFETIMES),\n         LintId::of(&lifetimes::NEEDLESS_LIFETIMES),\n@@ -1349,13 +1356,15 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&methods::SEARCH_IS_SOME),\n         LintId::of(&methods::SHOULD_IMPLEMENT_TRAIT),\n         LintId::of(&methods::SINGLE_CHAR_PATTERN),\n+        LintId::of(&methods::SINGLE_CHAR_PUSH_STR),\n         LintId::of(&methods::SKIP_WHILE_NEXT),\n         LintId::of(&methods::STRING_EXTEND_CHARS),\n         LintId::of(&methods::SUSPICIOUS_MAP),\n         LintId::of(&methods::TEMPORARY_CSTRING_AS_PTR),\n         LintId::of(&methods::UNINIT_ASSUMED_INIT),\n         LintId::of(&methods::UNNECESSARY_FILTER_MAP),\n         LintId::of(&methods::UNNECESSARY_FOLD),\n+        LintId::of(&methods::UNNECESSARY_LAZY_EVALUATIONS),\n         LintId::of(&methods::USELESS_ASREF),\n         LintId::of(&methods::WRONG_SELF_CONVENTION),\n         LintId::of(&methods::ZST_OFFSET),\n@@ -1413,8 +1422,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&regex::INVALID_REGEX),\n         LintId::of(&regex::TRIVIAL_REGEX),\n         LintId::of(&repeat_once::REPEAT_ONCE),\n+        LintId::of(&returns::LET_AND_RETURN),\n         LintId::of(&returns::NEEDLESS_RETURN),\n-        LintId::of(&returns::UNUSED_UNIT),\n+        LintId::of(&self_assignment::SELF_ASSIGNMENT),\n         LintId::of(&serde_api::SERDE_API_MISUSE),\n         LintId::of(&single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n         LintId::of(&slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n@@ -1427,6 +1437,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&tabs_in_doc_comments::TABS_IN_DOC_COMMENTS),\n         LintId::of(&temporary_assignment::TEMPORARY_ASSIGNMENT),\n         LintId::of(&to_digit_is_some::TO_DIGIT_IS_SOME),\n+        LintId::of(&to_string_in_display::TO_STRING_IN_DISPLAY),\n         LintId::of(&transmute::CROSSPOINTER_TRANSMUTE),\n         LintId::of(&transmute::TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS),\n         LintId::of(&transmute::TRANSMUTE_BYTES_TO_STR),\n@@ -1460,6 +1471,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&unnecessary_sort_by::UNNECESSARY_SORT_BY),\n         LintId::of(&unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n         LintId::of(&unused_io_amount::UNUSED_IO_AMOUNT),\n+        LintId::of(&unused_unit::UNUSED_UNIT),\n         LintId::of(&unwrap::PANICKING_UNWRAP),\n         LintId::of(&unwrap::UNNECESSARY_UNWRAP),\n         LintId::of(&useless_conversion::USELESS_CONVERSION),\n@@ -1500,7 +1512,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&inherent_to_string::INHERENT_TO_STRING),\n         LintId::of(&len_zero::LEN_WITHOUT_IS_EMPTY),\n         LintId::of(&len_zero::LEN_ZERO),\n-        LintId::of(&let_and_return::LET_AND_RETURN),\n         LintId::of(&literal_representation::INCONSISTENT_DIGIT_GROUPING),\n         LintId::of(&loops::EMPTY_LOOP),\n         LintId::of(&loops::FOR_KV_MAP),\n@@ -1532,8 +1543,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&methods::OPTION_MAP_OR_NONE),\n         LintId::of(&methods::RESULT_MAP_OR_INTO_OPTION),\n         LintId::of(&methods::SHOULD_IMPLEMENT_TRAIT),\n+        LintId::of(&methods::SINGLE_CHAR_PUSH_STR),\n         LintId::of(&methods::STRING_EXTEND_CHARS),\n         LintId::of(&methods::UNNECESSARY_FOLD),\n+        LintId::of(&methods::UNNECESSARY_LAZY_EVALUATIONS),\n         LintId::of(&methods::WRONG_SELF_CONVENTION),\n         LintId::of(&misc::TOPLEVEL_REF_ARG),\n         LintId::of(&misc::ZERO_PTR),\n@@ -1554,8 +1567,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&redundant_field_names::REDUNDANT_FIELD_NAMES),\n         LintId::of(&redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES),\n         LintId::of(&regex::TRIVIAL_REGEX),\n+        LintId::of(&returns::LET_AND_RETURN),\n         LintId::of(&returns::NEEDLESS_RETURN),\n-        LintId::of(&returns::UNUSED_UNIT),\n         LintId::of(&single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n         LintId::of(&strings::STRING_LIT_AS_BYTES),\n         LintId::of(&tabs_in_doc_comments::TABS_IN_DOC_COMMENTS),\n@@ -1564,6 +1577,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::FN_TO_NUMERIC_CAST),\n         LintId::of(&types::FN_TO_NUMERIC_CAST_WITH_TRUNCATION),\n         LintId::of(&unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n+        LintId::of(&unused_unit::UNUSED_UNIT),\n         LintId::of(&write::PRINTLN_EMPTY_STRING),\n         LintId::of(&write::PRINT_LITERAL),\n         LintId::of(&write::PRINT_WITH_NEWLINE),\n@@ -1704,10 +1718,12 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&ptr::MUT_FROM_REF),\n         LintId::of(&ranges::REVERSED_EMPTY_RANGES),\n         LintId::of(&regex::INVALID_REGEX),\n+        LintId::of(&self_assignment::SELF_ASSIGNMENT),\n         LintId::of(&serde_api::SERDE_API_MISUSE),\n         LintId::of(&suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n         LintId::of(&suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n         LintId::of(&swap::ALMOST_SWAPPED),\n+        LintId::of(&to_string_in_display::TO_STRING_IN_DISPLAY),\n         LintId::of(&transmute::UNSOUND_COLLECTION_TRANSMUTE),\n         LintId::of(&transmute::WRONG_TRANSMUTE),\n         LintId::of(&transmuting_null::TRANSMUTING_NULL),"}, {"sha": "c95e43a9430446b2470aac5c782c10418b23ac57", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1141,11 +1141,31 @@ fn detect_same_item_push<'tcx>(\n     if same_item_push_visitor.should_lint {\n         if let Some((vec, pushed_item)) = same_item_push_visitor.vec_push {\n             // Make sure that the push does not involve possibly mutating values\n-            if mutated_variables(pushed_item, cx).map_or(false, |mutvars| mutvars.is_empty()) {\n-                if let PatKind::Wild = pat.kind {\n-                    let vec_str = snippet_with_macro_callsite(cx, vec.span, \"\");\n-                    let item_str = snippet_with_macro_callsite(cx, pushed_item.span, \"\");\n-\n+            if let PatKind::Wild = pat.kind {\n+                let vec_str = snippet_with_macro_callsite(cx, vec.span, \"\");\n+                let item_str = snippet_with_macro_callsite(cx, pushed_item.span, \"\");\n+                if let ExprKind::Path(ref qpath) = pushed_item.kind {\n+                    if_chain! {\n+                        if let Res::Local(hir_id) = qpath_res(cx, qpath, pushed_item.hir_id);\n+                        let node = cx.tcx.hir().get(hir_id);\n+                        if let Node::Binding(pat) = node;\n+                        if let PatKind::Binding(bind_ann, ..) = pat.kind;\n+                        if !matches!(bind_ann, BindingAnnotation::RefMut | BindingAnnotation::Mutable);\n+                        then {\n+                            span_lint_and_help(\n+                                cx,\n+                                SAME_ITEM_PUSH,\n+                                vec.span,\n+                                \"it looks like the same item is being pushed into this Vec\",\n+                                None,\n+                                &format!(\n+                                    \"try using vec![{};SIZE] or {}.resize(NEW_SIZE, {})\",\n+                                    item_str, vec_str, item_str\n+                                ),\n+                            )\n+                        }\n+                    }\n+                } else if mutated_variables(pushed_item, cx).map_or(false, |mutvars| mutvars.is_empty()) {\n                     span_lint_and_help(\n                         cx,\n                         SAME_ITEM_PUSH,"}, {"sha": "1cd5b2012922f72ac65772a64de3af1f3d38c2e8", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -111,8 +111,8 @@ fn lint_needless_cloning(cx: &LateContext<'_>, root: Span, receiver: Span) {\n         cx,\n         MAP_CLONE,\n         root.trim_start(receiver).unwrap(),\n-        \"You are needlessly cloning iterator elements\",\n-        \"Remove the `map` call\",\n+        \"you are needlessly cloning iterator elements\",\n+        \"remove the `map` call\",\n         String::new(),\n         Applicability::MachineApplicable,\n     )\n@@ -125,8 +125,8 @@ fn lint(cx: &LateContext<'_>, replace: Span, root: Span, copied: bool) {\n             cx,\n             MAP_CLONE,\n             replace,\n-            \"You are using an explicit closure for copying elements\",\n-            \"Consider calling the dedicated `copied` method\",\n+            \"you are using an explicit closure for copying elements\",\n+            \"consider calling the dedicated `copied` method\",\n             format!(\n                 \"{}.copied()\",\n                 snippet_with_applicability(cx, root, \"..\", &mut applicability)\n@@ -138,8 +138,8 @@ fn lint(cx: &LateContext<'_>, replace: Span, root: Span, copied: bool) {\n             cx,\n             MAP_CLONE,\n             replace,\n-            \"You are using an explicit closure for cloning elements\",\n-            \"Consider calling the dedicated `cloned` method\",\n+            \"you are using an explicit closure for cloning elements\",\n+            \"consider calling the dedicated `cloned` method\",\n             format!(\n                 \"{}.cloned()\",\n                 snippet_with_applicability(cx, root, \"..\", &mut applicability)"}, {"sha": "57966452253d52e75e55367ff540000448324377", "filename": "clippy_lints/src/match_on_vec_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,5 +1,5 @@\n-use crate::utils::{is_type_diagnostic_item, is_type_lang_item, snippet, span_lint_and_sugg};\n use crate::utils::walk_ptrs_ty;\n+use crate::utils::{is_type_diagnostic_item, is_type_lang_item, snippet, span_lint_and_sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, LangItem, MatchSource};"}, {"sha": "2498c48f067e36c689c635adc20ca41444321ed0", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 239, "deletions": 63, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -3,6 +3,7 @@ mod inefficient_to_string;\n mod manual_saturating_arithmetic;\n mod option_map_unwrap_or;\n mod unnecessary_filter_map;\n+mod unnecessary_lazy_eval;\n \n use std::borrow::Cow;\n use std::fmt;\n@@ -799,7 +800,7 @@ declare_clippy_lint! {\n     ///     call_some_ffi_func(c_str);\n     /// }\n     /// ```\n-    /// Here `c_str` point to a freed address. The correct use would be:\n+    /// Here `c_str` points to a freed address. The correct use would be:\n     /// ```rust\n     /// # use std::ffi::CString;\n     /// # fn call_some_ffi_func(_: *const i8) {}\n@@ -1306,6 +1307,65 @@ declare_clippy_lint! {\n     \"using `.iter().next()` on a sliced array, which can be shortened to just `.get()`\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Warns when using push_str with a single-character string literal,\n+    /// and push with a char would work fine.\n+    ///\n+    /// **Why is this bad?** It's less clear that we are pushing a single character\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```\n+    /// let mut string = String::new();\n+    /// string.push_str(\"R\");\n+    /// ```\n+    /// Could be written as\n+    /// ```\n+    /// let mut string = String::new();\n+    /// string.push('R');\n+    /// ```\n+    pub SINGLE_CHAR_PUSH_STR,\n+    style,\n+    \"`push_str()` used with a single-character string literal as parameter\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** As the counterpart to `or_fun_call`, this lint looks for unnecessary\n+    /// lazily evaluated closures on `Option` and `Result`.\n+    ///\n+    /// This lint suggests changing the following functions, when eager evaluation results in\n+    /// simpler code:\n+    ///  - `unwrap_or_else` to `unwrap_or`\n+    ///  - `and_then` to `and`\n+    ///  - `or_else` to `or`\n+    ///  - `get_or_insert_with` to `get_or_insert`\n+    ///  - `ok_or_else` to `ok_or`\n+    ///\n+    /// **Why is this bad?** Using eager evaluation is shorter and simpler in some cases.\n+    ///\n+    /// **Known problems:** It is possible, but not recommended for `Deref` and `Index` to have\n+    /// side effects. Eagerly evaluating them can change the semantics of the program.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // example code where clippy issues a warning\n+    /// let opt: Option<u32> = None;\n+    ///\n+    /// opt.unwrap_or_else(|| 42);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let opt: Option<u32> = None;\n+    ///\n+    /// opt.unwrap_or(42);\n+    /// ```\n+    pub UNNECESSARY_LAZY_EVALUATIONS,\n+    style,\n+    \"using unnecessary lazy evaluation, which can be replaced with simpler eager evaluation\"\n+}\n+\n declare_lint_pass!(Methods => [\n     UNWRAP_USED,\n     EXPECT_USED,\n@@ -1327,6 +1387,7 @@ declare_lint_pass!(Methods => [\n     INEFFICIENT_TO_STRING,\n     NEW_RET_NO_SELF,\n     SINGLE_CHAR_PATTERN,\n+    SINGLE_CHAR_PUSH_STR,\n     SEARCH_IS_SOME,\n     TEMPORARY_CSTRING_AS_PTR,\n     FILTER_NEXT,\n@@ -1354,6 +1415,7 @@ declare_lint_pass!(Methods => [\n     ZST_OFFSET,\n     FILETYPE_IS_FILE,\n     OPTION_AS_REF_DEREF,\n+    UNNECESSARY_LAZY_EVALUATIONS,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Methods {\n@@ -1374,13 +1436,19 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"expect\", \"ok\"] => lint_ok_expect(cx, expr, arg_lists[1]),\n             [\"expect\", ..] => lint_expect(cx, expr, arg_lists[0]),\n             [\"unwrap_or\", \"map\"] => option_map_unwrap_or::lint(cx, expr, arg_lists[1], arg_lists[0], method_spans[1]),\n-            [\"unwrap_or_else\", \"map\"] => lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0]),\n+            [\"unwrap_or_else\", \"map\"] => {\n+                if !lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0]) {\n+                    unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"unwrap_or\");\n+                }\n+            },\n             [\"map_or\", ..] => lint_map_or_none(cx, expr, arg_lists[0]),\n             [\"and_then\", ..] => {\n+                unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], false, \"and\");\n                 bind_instead_of_map::OptionAndThenSome::lint(cx, expr, arg_lists[0]);\n                 bind_instead_of_map::ResultAndThenOk::lint(cx, expr, arg_lists[0]);\n             },\n             [\"or_else\", ..] => {\n+                unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], false, \"or\");\n                 bind_instead_of_map::ResultOrElseErrInfo::lint(cx, expr, arg_lists[0]);\n             },\n             [\"next\", \"filter\"] => lint_filter_next(cx, expr, arg_lists[1]),\n@@ -1424,6 +1492,9 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"is_file\", ..] => lint_filetype_is_file(cx, expr, arg_lists[0]),\n             [\"map\", \"as_ref\"] => lint_option_as_ref_deref(cx, expr, arg_lists[1], arg_lists[0], false),\n             [\"map\", \"as_mut\"] => lint_option_as_ref_deref(cx, expr, arg_lists[1], arg_lists[0], true),\n+            [\"unwrap_or_else\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"unwrap_or\"),\n+            [\"get_or_insert_with\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"get_or_insert\"),\n+            [\"ok_or_else\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"ok_or\"),\n             _ => {},\n         }\n \n@@ -1441,6 +1512,12 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                     inefficient_to_string::lint(cx, expr, &args[0], self_ty);\n                 }\n \n+                if let Some(fn_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n+                    if match_def_path(cx, fn_def_id, &paths::PUSH_STR) {\n+                        lint_single_char_push_string(cx, expr, args);\n+                    }\n+                }\n+\n                 match self_ty.kind {\n                     ty::Ref(_, ty, _) if ty.kind == ty::Str => {\n                         for &(method, pos) in &PATTERN_METHODS {\n@@ -1470,6 +1547,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n         }\n     }\n \n+    #[allow(clippy::too_many_lines)]\n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx hir::ImplItem<'_>) {\n         if in_external_macro(cx.sess(), impl_item.span) {\n             return;\n@@ -1495,16 +1573,31 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n \n             then {\n                 if cx.access_levels.is_exported(impl_item.hir_id) {\n-                // check missing trait implementations\n-                    for &(method_name, n_args, fn_header, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n-                        if name == method_name &&\n-                            sig.decl.inputs.len() == n_args &&\n-                            out_type.matches(cx, &sig.decl.output) &&\n-                            self_kind.matches(cx, self_ty, first_arg_ty) &&\n-                            fn_header_equals(*fn_header, sig.header) {\n-                            span_lint(cx, SHOULD_IMPLEMENT_TRAIT, impl_item.span, &format!(\n-                                \"defining a method called `{}` on this type; consider implementing \\\n-                                the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n+                    // check missing trait implementations\n+                    for method_config in &TRAIT_METHODS {\n+                        if name == method_config.method_name &&\n+                            sig.decl.inputs.len() == method_config.param_count &&\n+                            method_config.output_type.matches(cx, &sig.decl.output) &&\n+                            method_config.self_kind.matches(cx, self_ty, first_arg_ty) &&\n+                            fn_header_equals(method_config.fn_header, sig.header) &&\n+                            method_config.lifetime_param_cond(&impl_item)\n+                        {\n+                            span_lint_and_help(\n+                                cx,\n+                                SHOULD_IMPLEMENT_TRAIT,\n+                                impl_item.span,\n+                                &format!(\n+                                    \"method `{}` can be confused for the standard trait method `{}::{}`\",\n+                                    method_config.method_name,\n+                                    method_config.trait_name,\n+                                    method_config.method_name\n+                                ),\n+                                None,\n+                                &format!(\n+                                    \"consider implementing the trait `{}` or choosing a less ambiguous method name\",\n+                                    method_config.trait_name\n+                                )\n+                            );\n                         }\n                     }\n                 }\n@@ -2280,7 +2373,7 @@ fn lint_iter_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, iter_\n                     cx,\n                     ITER_NEXT_SLICE,\n                     expr.span,\n-                    \"Using `.iter().next()` on a Slice without end index.\",\n+                    \"using `.iter().next()` on a Slice without end index\",\n                     \"try calling\",\n                     format!(\"{}.get({})\", snippet_with_applicability(cx, caller_var.span, \"..\", &mut applicability), start_idx),\n                     applicability,\n@@ -2299,7 +2392,7 @@ fn lint_iter_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, iter_\n             cx,\n             ITER_NEXT_SLICE,\n             expr.span,\n-            \"Using `.iter().next()` on an array\",\n+            \"using `.iter().next()` on an array\",\n             \"try calling\",\n             format!(\n                 \"{}.get(0)\",\n@@ -2618,12 +2711,13 @@ fn lint_map_flatten<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n }\n \n /// lint use of `map().unwrap_or_else()` for `Option`s and `Result`s\n+/// Return true if lint triggered\n fn lint_map_unwrap_or_else<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n     map_args: &'tcx [hir::Expr<'_>],\n     unwrap_args: &'tcx [hir::Expr<'_>],\n-) {\n+) -> bool {\n     // lint if the caller of `map()` is an `Option`\n     let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(option_type));\n     let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(result_type));\n@@ -2635,10 +2729,10 @@ fn lint_map_unwrap_or_else<'tcx>(\n         let unwrap_mutated_vars = mutated_variables(&unwrap_args[1], cx);\n         if let (Some(map_mutated_vars), Some(unwrap_mutated_vars)) = (map_mutated_vars, unwrap_mutated_vars) {\n             if map_mutated_vars.intersection(&unwrap_mutated_vars).next().is_some() {\n-                return;\n+                return false;\n             }\n         } else {\n-            return;\n+            return false;\n         }\n \n         // lint message\n@@ -2668,10 +2762,14 @@ fn lint_map_unwrap_or_else<'tcx>(\n                     map_snippet, unwrap_snippet,\n                 ),\n             );\n+            return true;\n         } else if same_span && multiline {\n             span_lint(cx, MAP_UNWRAP_OR, expr.span, msg);\n-        };\n+            return true;\n+        }\n     }\n+\n+    false\n }\n \n /// lint use of `_.map_or(None, _)` for `Option`s and `Result`s\n@@ -3124,15 +3222,18 @@ fn lint_chars_last_cmp_with_unwrap<'tcx>(cx: &LateContext<'tcx>, info: &BinaryEx\n     }\n }\n \n-/// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n-fn lint_single_char_pattern<'tcx>(cx: &LateContext<'tcx>, _expr: &'tcx hir::Expr<'_>, arg: &'tcx hir::Expr<'_>) {\n+fn get_hint_if_single_char_arg(\n+    cx: &LateContext<'_>,\n+    arg: &hir::Expr<'_>,\n+    applicability: &mut Applicability,\n+) -> Option<String> {\n     if_chain! {\n         if let hir::ExprKind::Lit(lit) = &arg.kind;\n         if let ast::LitKind::Str(r, style) = lit.node;\n-        if r.as_str().len() == 1;\n+        let string = r.as_str();\n+        if string.len() == 1;\n         then {\n-            let mut applicability = Applicability::MachineApplicable;\n-            let snip = snippet_with_applicability(cx, arg.span, \"..\", &mut applicability);\n+            let snip = snippet_with_applicability(cx, arg.span, &string, applicability);\n             let ch = if let ast::StrStyle::Raw(nhash) = style {\n                 let nhash = nhash as usize;\n                 // for raw string: r##\"a\"##\n@@ -3142,19 +3243,47 @@ fn lint_single_char_pattern<'tcx>(cx: &LateContext<'tcx>, _expr: &'tcx hir::Expr\n                 &snip[1..(snip.len() - 1)]\n             };\n             let hint = format!(\"'{}'\", if ch == \"'\" { \"\\\\'\" } else { ch });\n-            span_lint_and_sugg(\n-                cx,\n-                SINGLE_CHAR_PATTERN,\n-                arg.span,\n-                \"single-character string constant used as pattern\",\n-                \"try using a `char` instead\",\n-                hint,\n-                applicability,\n-            );\n+            Some(hint)\n+        } else {\n+            None\n         }\n     }\n }\n \n+/// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n+fn lint_single_char_pattern(cx: &LateContext<'_>, _expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    if let Some(hint) = get_hint_if_single_char_arg(cx, arg, &mut applicability) {\n+        span_lint_and_sugg(\n+            cx,\n+            SINGLE_CHAR_PATTERN,\n+            arg.span,\n+            \"single-character string constant used as pattern\",\n+            \"try using a `char` instead\",\n+            hint,\n+            applicability,\n+        );\n+    }\n+}\n+\n+/// lint for length-1 `str`s as argument for `push_str`\n+fn lint_single_char_push_string(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    if let Some(extension_string) = get_hint_if_single_char_arg(cx, &args[1], &mut applicability) {\n+        let base_string_snippet = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n+        let sugg = format!(\"{}.push({})\", base_string_snippet, extension_string);\n+        span_lint_and_sugg(\n+            cx,\n+            SINGLE_CHAR_PUSH_STR,\n+            expr.span,\n+            \"calling `push_str()` using a single-character string literal\",\n+            \"consider using `push` with a character literal\",\n+            sugg,\n+            applicability,\n+        );\n+    }\n+}\n+\n /// Checks for the `USELESS_ASREF` lint.\n fn lint_asref(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, as_ref_args: &[hir::Expr<'_>]) {\n     // when we get here, we've already checked that the call name is \"as_ref\" or \"as_mut\"\n@@ -3403,38 +3532,85 @@ const FN_HEADER: hir::FnHeader = hir::FnHeader {\n     abi: rustc_target::spec::abi::Abi::Rust,\n };\n \n+struct ShouldImplTraitCase {\n+    trait_name: &'static str,\n+    method_name: &'static str,\n+    param_count: usize,\n+    fn_header: hir::FnHeader,\n+    // implicit self kind expected (none, self, &self, ...)\n+    self_kind: SelfKind,\n+    // checks against the output type\n+    output_type: OutType,\n+    // certain methods with explicit lifetimes can't implement the equivalent trait method\n+    lint_explicit_lifetime: bool,\n+}\n+impl ShouldImplTraitCase {\n+    const fn new(\n+        trait_name: &'static str,\n+        method_name: &'static str,\n+        param_count: usize,\n+        fn_header: hir::FnHeader,\n+        self_kind: SelfKind,\n+        output_type: OutType,\n+        lint_explicit_lifetime: bool,\n+    ) -> ShouldImplTraitCase {\n+        ShouldImplTraitCase {\n+            trait_name,\n+            method_name,\n+            param_count,\n+            fn_header,\n+            self_kind,\n+            output_type,\n+            lint_explicit_lifetime,\n+        }\n+    }\n+\n+    fn lifetime_param_cond(&self, impl_item: &hir::ImplItem<'_>) -> bool {\n+        self.lint_explicit_lifetime\n+            || !impl_item.generics.params.iter().any(|p| {\n+                matches!(\n+                    p.kind,\n+                    hir::GenericParamKind::Lifetime {\n+                        kind: hir::LifetimeParamKind::Explicit\n+                    }\n+                )\n+            })\n+    }\n+}\n+\n #[rustfmt::skip]\n-const TRAIT_METHODS: [(&str, usize, &hir::FnHeader, SelfKind, OutType, &str); 30] = [\n-    (\"add\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Add\"),\n-    (\"as_mut\", 1, &FN_HEADER, SelfKind::RefMut, OutType::Ref, \"std::convert::AsMut\"),\n-    (\"as_ref\", 1, &FN_HEADER, SelfKind::Ref, OutType::Ref, \"std::convert::AsRef\"),\n-    (\"bitand\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::BitAnd\"),\n-    (\"bitor\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::BitOr\"),\n-    (\"bitxor\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::BitXor\"),\n-    (\"borrow\", 1, &FN_HEADER, SelfKind::Ref, OutType::Ref, \"std::borrow::Borrow\"),\n-    (\"borrow_mut\", 1, &FN_HEADER, SelfKind::RefMut, OutType::Ref, \"std::borrow::BorrowMut\"),\n-    (\"clone\", 1, &FN_HEADER, SelfKind::Ref, OutType::Any, \"std::clone::Clone\"),\n-    (\"cmp\", 2, &FN_HEADER, SelfKind::Ref, OutType::Any, \"std::cmp::Ord\"),\n-    (\"default\", 0, &FN_HEADER, SelfKind::No, OutType::Any, \"std::default::Default\"),\n-    (\"deref\", 1, &FN_HEADER, SelfKind::Ref, OutType::Ref, \"std::ops::Deref\"),\n-    (\"deref_mut\", 1, &FN_HEADER, SelfKind::RefMut, OutType::Ref, \"std::ops::DerefMut\"),\n-    (\"div\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Div\"),\n-    (\"drop\", 1, &FN_HEADER, SelfKind::RefMut, OutType::Unit, \"std::ops::Drop\"),\n-    (\"eq\", 2, &FN_HEADER, SelfKind::Ref, OutType::Bool, \"std::cmp::PartialEq\"),\n-    (\"from_iter\", 1, &FN_HEADER, SelfKind::No, OutType::Any, \"std::iter::FromIterator\"),\n-    (\"from_str\", 1, &FN_HEADER, SelfKind::No, OutType::Any, \"std::str::FromStr\"),\n-    (\"hash\", 2, &FN_HEADER, SelfKind::Ref, OutType::Unit, \"std::hash::Hash\"),\n-    (\"index\", 2, &FN_HEADER, SelfKind::Ref, OutType::Ref, \"std::ops::Index\"),\n-    (\"index_mut\", 2, &FN_HEADER, SelfKind::RefMut, OutType::Ref, \"std::ops::IndexMut\"),\n-    (\"into_iter\", 1, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::iter::IntoIterator\"),\n-    (\"mul\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Mul\"),\n-    (\"neg\", 1, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Neg\"),\n-    (\"next\", 1, &FN_HEADER, SelfKind::RefMut, OutType::Any, \"std::iter::Iterator\"),\n-    (\"not\", 1, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Not\"),\n-    (\"rem\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Rem\"),\n-    (\"shl\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Shl\"),\n-    (\"shr\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Shr\"),\n-    (\"sub\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Sub\"),\n+const TRAIT_METHODS: [ShouldImplTraitCase; 30] = [\n+    ShouldImplTraitCase::new(\"std::ops::Add\", \"add\",  2,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::convert::AsMut\", \"as_mut\",  1,  FN_HEADER,  SelfKind::RefMut,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::convert::AsRef\", \"as_ref\",  1,  FN_HEADER,  SelfKind::Ref,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::ops::BitAnd\", \"bitand\",  2,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::BitOr\", \"bitor\",  2,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::BitXor\", \"bitxor\",  2,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::borrow::Borrow\", \"borrow\",  1,  FN_HEADER,  SelfKind::Ref,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::borrow::BorrowMut\", \"borrow_mut\",  1,  FN_HEADER,  SelfKind::RefMut,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::clone::Clone\", \"clone\",  1,  FN_HEADER,  SelfKind::Ref,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::cmp::Ord\", \"cmp\",  2,  FN_HEADER,  SelfKind::Ref,  OutType::Any, true),\n+    // FIXME: default doesn't work\n+    ShouldImplTraitCase::new(\"std::default::Default\", \"default\",  0,  FN_HEADER,  SelfKind::No,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Deref\", \"deref\",  1,  FN_HEADER,  SelfKind::Ref,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::ops::DerefMut\", \"deref_mut\",  1,  FN_HEADER,  SelfKind::RefMut,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::ops::Div\", \"div\",  2,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Drop\", \"drop\",  1,  FN_HEADER,  SelfKind::RefMut,  OutType::Unit, true),\n+    ShouldImplTraitCase::new(\"std::cmp::PartialEq\", \"eq\",  2,  FN_HEADER,  SelfKind::Ref,  OutType::Bool, true),\n+    ShouldImplTraitCase::new(\"std::iter::FromIterator\", \"from_iter\",  1,  FN_HEADER,  SelfKind::No,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::str::FromStr\", \"from_str\",  1,  FN_HEADER,  SelfKind::No,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::hash::Hash\", \"hash\",  2,  FN_HEADER,  SelfKind::Ref,  OutType::Unit, true),\n+    ShouldImplTraitCase::new(\"std::ops::Index\", \"index\",  2,  FN_HEADER,  SelfKind::Ref,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::ops::IndexMut\", \"index_mut\",  2,  FN_HEADER,  SelfKind::RefMut,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::iter::IntoIterator\", \"into_iter\",  1,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Mul\", \"mul\",  2,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Neg\", \"neg\",  1,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::iter::Iterator\", \"next\",  1,  FN_HEADER,  SelfKind::RefMut,  OutType::Any, false),\n+    ShouldImplTraitCase::new(\"std::ops::Not\", \"not\",  1,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Rem\", \"rem\",  2,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Shl\", \"shl\",  2,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Shr\", \"shr\",  2,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Sub\", \"sub\",  2,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n ];\n \n #[rustfmt::skip]"}, {"sha": "31517659c34dcbc9efa957fa7ba3c6f06603d1af", "filename": "clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -0,0 +1,111 @@\n+use crate::utils::{is_type_diagnostic_item, match_qpath, snippet, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::UNNECESSARY_LAZY_EVALUATIONS;\n+\n+// Return true if the expression is an accessor of any of the arguments\n+fn expr_uses_argument(expr: &hir::Expr<'_>, params: &[hir::Param<'_>]) -> bool {\n+    params.iter().any(|arg| {\n+        if_chain! {\n+            if let hir::PatKind::Binding(_, _, ident, _) = arg.pat.kind;\n+            if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.kind;\n+            if let [p, ..] = path.segments;\n+            then {\n+                ident.name == p.ident.name\n+            } else {\n+                false\n+            }\n+        }\n+    })\n+}\n+\n+fn match_any_qpath(path: &hir::QPath<'_>, paths: &[&[&str]]) -> bool {\n+    paths.iter().any(|candidate| match_qpath(path, candidate))\n+}\n+\n+fn can_simplify(expr: &hir::Expr<'_>, params: &[hir::Param<'_>], variant_calls: bool) -> bool {\n+    match expr.kind {\n+        // Closures returning literals can be unconditionally simplified\n+        hir::ExprKind::Lit(_) => true,\n+\n+        hir::ExprKind::Index(ref object, ref index) => {\n+            // arguments are not being indexed into\n+            if expr_uses_argument(object, params) {\n+                false\n+            } else {\n+                // arguments are not used as index\n+                !expr_uses_argument(index, params)\n+            }\n+        },\n+\n+        // Reading fields can be simplified if the object is not an argument of the closure\n+        hir::ExprKind::Field(ref object, _) => !expr_uses_argument(object, params),\n+\n+        // Paths can be simplified if the root is not the argument, this also covers None\n+        hir::ExprKind::Path(_) => !expr_uses_argument(expr, params),\n+\n+        // Calls to Some, Ok, Err can be considered literals if they don't derive an argument\n+        hir::ExprKind::Call(ref func, ref args) => if_chain! {\n+            if variant_calls; // Disable lint when rules conflict with bind_instead_of_map\n+            if let hir::ExprKind::Path(ref path) = func.kind;\n+            if match_any_qpath(path, &[&[\"Some\"], &[\"Ok\"], &[\"Err\"]]);\n+            then {\n+                // Recursively check all arguments\n+                args.iter().all(|arg| can_simplify(arg, params, variant_calls))\n+            } else {\n+                false\n+            }\n+        },\n+\n+        // For anything more complex than the above, a closure is probably the right solution,\n+        // or the case is handled by an other lint\n+        _ => false,\n+    }\n+}\n+\n+/// lint use of `<fn>_else(simple closure)` for `Option`s and `Result`s that can be\n+/// replaced with `<fn>(return value of simple closure)`\n+pub(super) fn lint<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    args: &'tcx [hir::Expr<'_>],\n+    allow_variant_calls: bool,\n+    simplify_using: &str,\n+) {\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym!(option_type));\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym!(result_type));\n+\n+    if is_option || is_result {\n+        if let hir::ExprKind::Closure(_, _, eid, _, _) = args[1].kind {\n+            let body = cx.tcx.hir().body(eid);\n+            let ex = &body.value;\n+            let params = &body.params;\n+\n+            if can_simplify(ex, params, allow_variant_calls) {\n+                let msg = if is_option {\n+                    \"unnecessary closure used to substitute value for `Option::None`\"\n+                } else {\n+                    \"unnecessary closure used to substitute value for `Result::Err`\"\n+                };\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    UNNECESSARY_LAZY_EVALUATIONS,\n+                    expr.span,\n+                    msg,\n+                    &format!(\"Use `{}` instead\", simplify_using),\n+                    format!(\n+                        \"{0}.{1}({2})\",\n+                        snippet(cx, args[0].span, \"..\"),\n+                        simplify_using,\n+                        snippet(cx, ex.span, \"..\"),\n+                    ),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "06f367a8b775f99ee7ae9fc610cc315c1170c4e5", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -433,8 +433,7 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n             return;\n         }\n         let binding = match expr.kind {\n-            ExprKind::Path(hir::QPath::LangItem(..)) => None,\n-            ExprKind::Path(ref qpath) => {\n+            ExprKind::Path(ref qpath) if !matches!(qpath, hir::QPath::LangItem(..)) => {\n                 let binding = last_path_segment(qpath).ident.as_str();\n                 if binding.starts_with('_') &&\n                     !binding.starts_with(\"__\") &&"}, {"sha": "c506440ed7987e48c7733262abbc12ac78805826", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -9,8 +9,8 @@ declare_clippy_lint! {\n     /// **What it does:** Detects passing a mutable reference to a function that only\n     /// requires an immutable reference.\n     ///\n-    /// **Why is this bad?** The immutable reference rules out all other references\n-    /// to the value. Also the code misleads about the intent of the call site.\n+    /// **Why is this bad?** The mutable reference rules out all other references to\n+    /// the value. Also the code misleads about the intent of the call site.\n     ///\n     /// **Known problems:** None.\n     ///\n@@ -39,21 +39,28 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryMutPassed {\n                         arguments,\n                         cx.typeck_results().expr_ty(fn_expr),\n                         &rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false)),\n+                        \"function\",\n                     );\n                 }\n             },\n             ExprKind::MethodCall(ref path, _, ref arguments, _) => {\n                 let def_id = cx.typeck_results().type_dependent_def_id(e.hir_id).unwrap();\n                 let substs = cx.typeck_results().node_substs(e.hir_id);\n                 let method_type = cx.tcx.type_of(def_id).subst(cx.tcx, substs);\n-                check_arguments(cx, arguments, method_type, &path.ident.as_str())\n+                check_arguments(cx, arguments, method_type, &path.ident.as_str(), \"method\")\n             },\n             _ => (),\n         }\n     }\n }\n \n-fn check_arguments<'tcx>(cx: &LateContext<'tcx>, arguments: &[Expr<'_>], type_definition: Ty<'tcx>, name: &str) {\n+fn check_arguments<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    arguments: &[Expr<'_>],\n+    type_definition: Ty<'tcx>,\n+    name: &str,\n+    fn_kind: &str,\n+) {\n     match type_definition.kind {\n         ty::FnDef(..) | ty::FnPtr(_) => {\n             let parameters = type_definition.fn_sig(cx.tcx).skip_binder().inputs();\n@@ -68,7 +75,7 @@ fn check_arguments<'tcx>(cx: &LateContext<'tcx>, arguments: &[Expr<'_>], type_de\n                                 cx,\n                                 UNNECESSARY_MUT_PASSED,\n                                 argument.span,\n-                                &format!(\"The function/method `{}` doesn't need a mutable reference\", name),\n+                                &format!(\"the {} `{}` doesn't need a mutable reference\", fn_kind, name),\n                             );\n                         }\n                     },"}, {"sha": "21efee71269862484f60ca618249bb067dd363e5", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -72,8 +72,8 @@ impl<'tcx> LateLintPass<'tcx> for Mutex {\n                 let mutex_param = subst.type_at(0);\n                 if let Some(atomic_name) = get_atomic_name(mutex_param) {\n                     let msg = format!(\n-                        \"Consider using an `{}` instead of a `Mutex` here. If you just want the locking \\\n-                         behavior and not the internal type, consider using `Mutex<()>`.\",\n+                        \"consider using an `{}` instead of a `Mutex` here; if you just want the locking \\\n+                         behavior and not the internal type, consider using `Mutex<()>`\",\n                         atomic_name\n                     );\n                     match mutex_param.kind {"}, {"sha": "7dafb1555dc6e7e187f62e44c1977de7dd2fd81d", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -36,14 +36,27 @@ declare_clippy_lint! {\n     /// argument may also fail to compile if you change the argument. Applying\n     /// this lint on them will fix the problem, but they may be in other crates.\n     ///\n+    /// One notable example of a function that may cause issues, and which cannot\n+    /// easily be changed due to being in the standard library is `Vec::contains`.\n+    /// when called on a `Vec<Vec<T>>`. If a `&Vec` is passed to that method then\n+    /// it will compile, but if a `&[T]` is passed then it will not compile.\n+    ///\n+    /// ```ignore\n+    /// fn cannot_take_a_slice(v: &Vec<u8>) -> bool {\n+    ///     let vec_of_vecs: Vec<Vec<u8>> = some_other_fn();\n+    ///\n+    ///     vec_of_vecs.contains(v)\n+    /// }\n+    /// ```\n+    ///\n     /// Also there may be `fn(&Vec)`-typed references pointing to your function.\n     /// If you have them, you will get a compiler error after applying this lint's\n     /// suggestions. You then have the choice to undo your changes or change the\n     /// type of the reference.\n     ///\n     /// Note that if the function is part of your public interface, there may be\n-    /// other crates referencing it you may not be aware. Carefully deprecate the\n-    /// function before applying the lint suggestions in this case.\n+    /// other crates referencing it, of which you may not be aware. Carefully\n+    /// deprecate the function before applying the lint suggestions in this case.\n     ///\n     /// **Example:**\n     /// ```ignore"}, {"sha": "dbc676ae22408b139172a742361ca9ac7e511003", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -7,8 +7,8 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    higher, is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet_with_applicability,\n-    span_lint_and_sugg, SpanlessEq,\n+    eq_expr_value, higher, is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet_with_applicability,\n+    span_lint_and_sugg,\n };\n \n declare_clippy_lint! {\n@@ -65,7 +65,7 @@ impl QuestionMark {\n                         if let ExprKind::Block(block, None) = &else_.kind;\n                         if block.stmts.is_empty();\n                         if let Some(block_expr) = &block.expr;\n-                        if SpanlessEq::new(cx).ignore_fn().eq_expr(subject, block_expr);\n+                        if eq_expr_value(cx, subject, block_expr);\n                         then {\n                             replacement = Some(format!(\"Some({}?)\", receiver_str));\n                         }"}, {"sha": "3c5541e64b4d44f5d920b8f46b25c2f8252c76f2", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 210, "deletions": 207, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,60 +1,67 @@\n use if_chain::if_chain;\n-use rustc_ast::ast;\n-use rustc_ast::visit::FnKind;\n+use rustc_ast::ast::Attribute;\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_hir::intravisit::{walk_expr, FnKind, NestedVisitorMap, Visitor};\n+use rustc_hir::{Block, Body, Expr, ExprKind, FnDecl, HirId, MatchSource, PatKind, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::subst::GenericArgKind;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::BytePos;\n \n-use crate::utils::{snippet_opt, span_lint_and_sugg, span_lint_and_then};\n+use crate::utils::{fn_def_id, in_macro, match_qpath, snippet_opt, span_lint_and_sugg, span_lint_and_then};\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for return statements at the end of a block.\n+    /// **What it does:** Checks for `let`-bindings, which are subsequently\n+    /// returned.\n     ///\n-    /// **Why is this bad?** Removing the `return` and semicolon will make the code\n+    /// **Why is this bad?** It is just extraneous code. Remove it to make your code\n     /// more rusty.\n     ///\n-    /// **Known problems:** If the computation returning the value borrows a local\n-    /// variable, removing the `return` may run afoul of the borrow checker.\n+    /// **Known problems:** None.\n     ///\n     /// **Example:**\n     /// ```rust\n-    /// fn foo(x: usize) -> usize {\n-    ///     return x;\n+    /// fn foo() -> String {\n+    ///     let x = String::new();\n+    ///     x\n     /// }\n     /// ```\n-    /// simplify to\n-    /// ```rust\n-    /// fn foo(x: usize) -> usize {\n-    ///     x\n+    /// instead, use\n+    /// ```\n+    /// fn foo() -> String {\n+    ///     String::new()\n     /// }\n     /// ```\n-    pub NEEDLESS_RETURN,\n+    pub LET_AND_RETURN,\n     style,\n-    \"using a return statement like `return expr;` where an expression would suffice\"\n+    \"creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\"\n }\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for unit (`()`) expressions that can be removed.\n+    /// **What it does:** Checks for return statements at the end of a block.\n     ///\n-    /// **Why is this bad?** Such expressions add no value, but can make the code\n-    /// less readable. Depending on formatting they can make a `break` or `return`\n-    /// statement look like a function call.\n+    /// **Why is this bad?** Removing the `return` and semicolon will make the code\n+    /// more rusty.\n     ///\n-    /// **Known problems:** The lint currently misses unit return types in types,\n-    /// e.g., the `F` in `fn generic_unit<F: Fn() -> ()>(f: F) { .. }`.\n+    /// **Known problems:** None.\n     ///\n     /// **Example:**\n     /// ```rust\n-    /// fn return_unit() -> () {\n-    ///     ()\n+    /// fn foo(x: usize) -> usize {\n+    ///     return x;\n     /// }\n     /// ```\n-    pub UNUSED_UNIT,\n+    /// simplify to\n+    /// ```rust\n+    /// fn foo(x: usize) -> usize {\n+    ///     x\n+    /// }\n+    /// ```\n+    pub NEEDLESS_RETURN,\n     style,\n-    \"needless unit expression\"\n+    \"using a return statement like `return expr;` where an expression would suffice\"\n }\n \n #[derive(PartialEq, Eq, Copy, Clone)]\n@@ -63,221 +70,217 @@ enum RetReplacement {\n     Block,\n }\n \n-declare_lint_pass!(Return => [NEEDLESS_RETURN, UNUSED_UNIT]);\n+declare_lint_pass!(Return => [LET_AND_RETURN, NEEDLESS_RETURN]);\n \n-impl Return {\n-    // Check the final stmt or expr in a block for unnecessary return.\n-    fn check_block_return(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n-        if let Some(stmt) = block.stmts.last() {\n-            match stmt.kind {\n-                ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => {\n-                    self.check_final_expr(cx, expr, Some(stmt.span), RetReplacement::Empty);\n-                },\n-                _ => (),\n+impl<'tcx> LateLintPass<'tcx> for Return {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n+        // we need both a let-binding stmt and an expr\n+        if_chain! {\n+            if let Some(retexpr) = block.expr;\n+            if let Some(stmt) = block.stmts.iter().last();\n+            if let StmtKind::Local(local) = &stmt.kind;\n+            if local.ty.is_none();\n+            if local.attrs.is_empty();\n+            if let Some(initexpr) = &local.init;\n+            if let PatKind::Binding(.., ident, _) = local.pat.kind;\n+            if let ExprKind::Path(qpath) = &retexpr.kind;\n+            if match_qpath(qpath, &[&*ident.name.as_str()]);\n+            if !last_statement_borrows(cx, initexpr);\n+            if !in_external_macro(cx.sess(), initexpr.span);\n+            if !in_external_macro(cx.sess(), retexpr.span);\n+            if !in_external_macro(cx.sess(), local.span);\n+            if !in_macro(local.span);\n+            then {\n+                span_lint_and_then(\n+                    cx,\n+                    LET_AND_RETURN,\n+                    retexpr.span,\n+                    \"returning the result of a `let` binding from a block\",\n+                    |err| {\n+                        err.span_label(local.span, \"unnecessary `let` binding\");\n+\n+                        if let Some(snippet) = snippet_opt(cx, initexpr.span) {\n+                            err.multipart_suggestion(\n+                                \"return the expression directly\",\n+                                vec![\n+                                    (local.span, String::new()),\n+                                    (retexpr.span, snippet),\n+                                ],\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else {\n+                            err.span_help(initexpr.span, \"this expression can be directly returned\");\n+                        }\n+                    },\n+                );\n             }\n         }\n     }\n \n-    // Check the final expression in a block if it's a return.\n-    fn check_final_expr(\n+    fn check_fn(\n         &mut self,\n-        cx: &EarlyContext<'_>,\n-        expr: &ast::Expr,\n-        span: Option<Span>,\n-        replacement: RetReplacement,\n+        cx: &LateContext<'tcx>,\n+        kind: FnKind<'tcx>,\n+        _: &'tcx FnDecl<'tcx>,\n+        body: &'tcx Body<'tcx>,\n+        _: Span,\n+        _: HirId,\n     ) {\n-        match expr.kind {\n-            // simple return is always \"bad\"\n-            ast::ExprKind::Ret(ref inner) => {\n-                // allow `#[cfg(a)] return a; #[cfg(b)] return b;`\n-                if !expr.attrs.iter().any(attr_is_cfg) {\n-                    Self::emit_return_lint(\n-                        cx,\n-                        span.expect(\"`else return` is not possible\"),\n-                        inner.as_ref().map(|i| i.span),\n-                        replacement,\n-                    );\n-                }\n-            },\n-            // a whole block? check it!\n-            ast::ExprKind::Block(ref block, _) => {\n-                self.check_block_return(cx, block);\n-            },\n-            // an if/if let expr, check both exprs\n-            // note, if without else is going to be a type checking error anyways\n-            // (except for unit type functions) so we don't match it\n-            ast::ExprKind::If(_, ref ifblock, Some(ref elsexpr)) => {\n-                self.check_block_return(cx, ifblock);\n-                self.check_final_expr(cx, elsexpr, None, RetReplacement::Empty);\n-            },\n-            // a match expr, check all arms\n-            ast::ExprKind::Match(_, ref arms) => {\n-                for arm in arms {\n-                    self.check_final_expr(cx, &arm.body, Some(arm.body.span), RetReplacement::Block);\n+        match kind {\n+            FnKind::Closure(_) => check_final_expr(cx, &body.value, Some(body.value.span), RetReplacement::Empty),\n+            FnKind::ItemFn(..) | FnKind::Method(..) => {\n+                if let ExprKind::Block(ref block, _) = body.value.kind {\n+                    check_block_return(cx, block);\n                 }\n             },\n-            _ => (),\n         }\n     }\n+}\n \n-    fn emit_return_lint(cx: &EarlyContext<'_>, ret_span: Span, inner_span: Option<Span>, replacement: RetReplacement) {\n-        match inner_span {\n-            Some(inner_span) => {\n-                if in_external_macro(cx.sess(), inner_span) || inner_span.from_expansion() {\n-                    return;\n-                }\n+fn attr_is_cfg(attr: &Attribute) -> bool {\n+    attr.meta_item_list().is_some() && attr.has_name(sym!(cfg))\n+}\n \n-                span_lint_and_then(cx, NEEDLESS_RETURN, ret_span, \"unneeded `return` statement\", |diag| {\n-                    if let Some(snippet) = snippet_opt(cx, inner_span) {\n-                        diag.span_suggestion(ret_span, \"remove `return`\", snippet, Applicability::MachineApplicable);\n-                    }\n-                })\n+fn check_block_return<'tcx>(cx: &LateContext<'tcx>, block: &Block<'tcx>) {\n+    if let Some(expr) = block.expr {\n+        check_final_expr(cx, expr, Some(expr.span), RetReplacement::Empty);\n+    } else if let Some(stmt) = block.stmts.iter().last() {\n+        match stmt.kind {\n+            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => {\n+                check_final_expr(cx, expr, Some(stmt.span), RetReplacement::Empty);\n             },\n-            None => match replacement {\n-                RetReplacement::Empty => {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        NEEDLESS_RETURN,\n-                        ret_span,\n-                        \"unneeded `return` statement\",\n-                        \"remove `return`\",\n-                        String::new(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                },\n-                RetReplacement::Block => {\n-                    span_lint_and_sugg(\n+            _ => (),\n+        }\n+    }\n+}\n+\n+fn check_final_expr<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    span: Option<Span>,\n+    replacement: RetReplacement,\n+) {\n+    match expr.kind {\n+        // simple return is always \"bad\"\n+        ExprKind::Ret(ref inner) => {\n+            // allow `#[cfg(a)] return a; #[cfg(b)] return b;`\n+            if !expr.attrs.iter().any(attr_is_cfg) {\n+                let borrows = inner.map_or(false, |inner| last_statement_borrows(cx, inner));\n+                if !borrows {\n+                    emit_return_lint(\n                         cx,\n-                        NEEDLESS_RETURN,\n-                        ret_span,\n-                        \"unneeded `return` statement\",\n-                        \"replace `return` with an empty block\",\n-                        \"{}\".to_string(),\n-                        Applicability::MachineApplicable,\n+                        span.expect(\"`else return` is not possible\"),\n+                        inner.as_ref().map(|i| i.span),\n+                        replacement,\n                     );\n-                },\n+                }\n+            }\n+        },\n+        // a whole block? check it!\n+        ExprKind::Block(ref block, _) => {\n+            check_block_return(cx, block);\n+        },\n+        // a match expr, check all arms\n+        // an if/if let expr, check both exprs\n+        // note, if without else is going to be a type checking error anyways\n+        // (except for unit type functions) so we don't match it\n+        ExprKind::Match(_, ref arms, source) => match source {\n+            MatchSource::Normal => {\n+                for arm in arms.iter() {\n+                    check_final_expr(cx, &arm.body, Some(arm.body.span), RetReplacement::Block);\n+                }\n             },\n-        }\n+            MatchSource::IfDesugar {\n+                contains_else_clause: true,\n+            }\n+            | MatchSource::IfLetDesugar {\n+                contains_else_clause: true,\n+            } => {\n+                if let ExprKind::Block(ref ifblock, _) = arms[0].body.kind {\n+                    check_block_return(cx, ifblock);\n+                }\n+                check_final_expr(cx, arms[1].body, None, RetReplacement::Empty);\n+            },\n+            _ => (),\n+        },\n+        _ => (),\n     }\n }\n \n-impl EarlyLintPass for Return {\n-    fn check_fn(&mut self, cx: &EarlyContext<'_>, kind: FnKind<'_>, span: Span, _: ast::NodeId) {\n-        match kind {\n-            FnKind::Fn(.., Some(block)) => self.check_block_return(cx, block),\n-            FnKind::Closure(_, body) => self.check_final_expr(cx, body, Some(body.span), RetReplacement::Empty),\n-            FnKind::Fn(.., None) => {},\n-        }\n-        if_chain! {\n-            if let ast::FnRetTy::Ty(ref ty) = kind.decl().output;\n-            if let ast::TyKind::Tup(ref vals) = ty.kind;\n-            if vals.is_empty() && !ty.span.from_expansion() && get_def(span) == get_def(ty.span);\n-            then {\n-                lint_unneeded_unit_return(cx, ty, span);\n+fn emit_return_lint(cx: &LateContext<'_>, ret_span: Span, inner_span: Option<Span>, replacement: RetReplacement) {\n+    match inner_span {\n+        Some(inner_span) => {\n+            if in_external_macro(cx.tcx.sess, inner_span) || inner_span.from_expansion() {\n+                return;\n             }\n-        }\n-    }\n \n-    fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n-        if_chain! {\n-            if let Some(ref stmt) = block.stmts.last();\n-            if let ast::StmtKind::Expr(ref expr) = stmt.kind;\n-            if is_unit_expr(expr) && !stmt.span.from_expansion();\n-            then {\n-                let sp = expr.span;\n+            span_lint_and_then(cx, NEEDLESS_RETURN, ret_span, \"unneeded `return` statement\", |diag| {\n+                if let Some(snippet) = snippet_opt(cx, inner_span) {\n+                    diag.span_suggestion(ret_span, \"remove `return`\", snippet, Applicability::MachineApplicable);\n+                }\n+            })\n+        },\n+        None => match replacement {\n+            RetReplacement::Empty => {\n                 span_lint_and_sugg(\n                     cx,\n-                    UNUSED_UNIT,\n-                    sp,\n-                    \"unneeded unit expression\",\n-                    \"remove the final `()`\",\n+                    NEEDLESS_RETURN,\n+                    ret_span,\n+                    \"unneeded `return` statement\",\n+                    \"remove `return`\",\n                     String::new(),\n                     Applicability::MachineApplicable,\n                 );\n-            }\n-        }\n-    }\n-\n-    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n-        match e.kind {\n-            ast::ExprKind::Ret(Some(ref expr)) | ast::ExprKind::Break(_, Some(ref expr)) => {\n-                if is_unit_expr(expr) && !expr.span.from_expansion() {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        UNUSED_UNIT,\n-                        expr.span,\n-                        \"unneeded `()`\",\n-                        \"remove the `()`\",\n-                        String::new(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n             },\n-            _ => (),\n-        }\n-    }\n-\n-    fn check_poly_trait_ref(&mut self, cx: &EarlyContext<'_>, poly: &ast::PolyTraitRef, _: &ast::TraitBoundModifier) {\n-        let segments = &poly.trait_ref.path.segments;\n-\n-        if_chain! {\n-            if segments.len() == 1;\n-            if [\"Fn\", \"FnMut\", \"FnOnce\"].contains(&&*segments[0].ident.name.as_str());\n-            if let Some(args) = &segments[0].args;\n-            if let ast::GenericArgs::Parenthesized(generic_args) = &**args;\n-            if let ast::FnRetTy::Ty(ty) = &generic_args.output;\n-            if ty.kind.is_unit();\n-            then {\n-                lint_unneeded_unit_return(cx, ty, generic_args.span);\n-            }\n-        }\n+            RetReplacement::Block => {\n+                span_lint_and_sugg(\n+                    cx,\n+                    NEEDLESS_RETURN,\n+                    ret_span,\n+                    \"unneeded `return` statement\",\n+                    \"replace `return` with an empty block\",\n+                    \"{}\".to_string(),\n+                    Applicability::MachineApplicable,\n+                );\n+            },\n+        },\n     }\n }\n \n-fn attr_is_cfg(attr: &ast::Attribute) -> bool {\n-    attr.meta_item_list().is_some() && attr.has_name(sym!(cfg))\n+fn last_statement_borrows<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+    let mut visitor = BorrowVisitor { cx, borrows: false };\n+    walk_expr(&mut visitor, expr);\n+    visitor.borrows\n }\n \n-// get the def site\n-#[must_use]\n-fn get_def(span: Span) -> Option<Span> {\n-    if span.from_expansion() {\n-        Some(span.ctxt().outer_expn_data().def_site)\n-    } else {\n-        None\n-    }\n+struct BorrowVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    borrows: bool,\n }\n \n-// is this expr a `()` unit?\n-fn is_unit_expr(expr: &ast::Expr) -> bool {\n-    if let ast::ExprKind::Tup(ref vals) = expr.kind {\n-        vals.is_empty()\n-    } else {\n-        false\n+impl<'tcx> Visitor<'tcx> for BorrowVisitor<'_, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if self.borrows {\n+            return;\n+        }\n+\n+        if let Some(def_id) = fn_def_id(self.cx, expr) {\n+            self.borrows = self\n+                .cx\n+                .tcx\n+                .fn_sig(def_id)\n+                .output()\n+                .skip_binder()\n+                .walk()\n+                .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)));\n+        }\n+\n+        walk_expr(self, expr);\n     }\n-}\n \n-fn lint_unneeded_unit_return(cx: &EarlyContext<'_>, ty: &ast::Ty, span: Span) {\n-    let (ret_span, appl) = if let Ok(fn_source) = cx.sess().source_map().span_to_snippet(span.with_hi(ty.span.hi())) {\n-        fn_source\n-            .rfind(\"->\")\n-            .map_or((ty.span, Applicability::MaybeIncorrect), |rpos| {\n-                (\n-                    #[allow(clippy::cast_possible_truncation)]\n-                    ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),\n-                    Applicability::MachineApplicable,\n-                )\n-            })\n-    } else {\n-        (ty.span, Applicability::MaybeIncorrect)\n-    };\n-    span_lint_and_sugg(\n-        cx,\n-        UNUSED_UNIT,\n-        ret_span,\n-        \"unneeded unit return type\",\n-        \"remove the `-> ()`\",\n-        String::new(),\n-        appl,\n-    );\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n }"}, {"sha": "e096c9aebc122fe8b7a53ef15d446fce2512d442", "filename": "clippy_lints/src/self_assignment.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fself_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fself_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fself_assignment.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -0,0 +1,51 @@\n+use crate::utils::{eq_expr_value, snippet, span_lint};\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for explicit self-assignments.\n+    ///\n+    /// **Why is this bad?** Self-assignments are redundant and unlikely to be\n+    /// intentional.\n+    ///\n+    /// **Known problems:** If expression contains any deref coercions or\n+    /// indexing operations they are assumed not to have any side effects.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// struct Event {\n+    ///     id: usize,\n+    ///     x: i32,\n+    ///     y: i32,\n+    /// }\n+    ///\n+    /// fn copy_position(a: &mut Event, b: &Event) {\n+    ///     a.x = b.x;\n+    ///     a.y = a.y;\n+    /// }\n+    /// ```\n+    pub SELF_ASSIGNMENT,\n+    correctness,\n+    \"explicit self-assignment\"\n+}\n+\n+declare_lint_pass!(SelfAssignment => [SELF_ASSIGNMENT]);\n+\n+impl<'tcx> LateLintPass<'tcx> for SelfAssignment {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::Assign(lhs, rhs, _) = &expr.kind {\n+            if eq_expr_value(cx, lhs, rhs) {\n+                let lhs = snippet(cx, lhs.span, \"<lhs>\");\n+                let rhs = snippet(cx, rhs.span, \"<rhs>\");\n+                span_lint(\n+                    cx,\n+                    SELF_ASSIGNMENT,\n+                    expr.span,\n+                    &format!(\"self-assignment of `{}` to `{}`\", rhs, lhs),\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "22c49a20451f1f16c5ad11d7891d05a46b6d497d", "filename": "clippy_lints/src/stable_sort_primitive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fstable_sort_primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fstable_sort_primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstable_sort_primitive.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -111,9 +111,9 @@ impl LateLintPass<'_> for StableSortPrimitive {\n                 STABLE_SORT_PRIMITIVE,\n                 expr.span,\n                 format!(\n-                    \"Use {} instead of {}\",\n-                    detection.method.unstable_name(),\n-                    detection.method.stable_name()\n+                    \"used {} instead of {}\",\n+                    detection.method.stable_name(),\n+                    detection.method.unstable_name()\n                 )\n                 .as_str(),\n                 \"try\","}, {"sha": "3a688a7bbef324cd12a61086ec78fa9d059230ae", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -86,12 +86,20 @@ impl<'tcx> LateLintPass<'tcx> for SuspiciousImpl {\n                 cx,\n                 expr,\n                 binop.node,\n-                &[\"Add\", \"Sub\", \"Mul\", \"Div\"],\n+                &[\n+                    \"Add\", \"Sub\", \"Mul\", \"Div\", \"Rem\", \"BitAnd\", \"BitOr\", \"BitXor\", \"Shl\", \"Shr\",\n+                ],\n                 &[\n                     hir::BinOpKind::Add,\n                     hir::BinOpKind::Sub,\n                     hir::BinOpKind::Mul,\n                     hir::BinOpKind::Div,\n+                    hir::BinOpKind::Rem,\n+                    hir::BinOpKind::BitAnd,\n+                    hir::BinOpKind::BitOr,\n+                    hir::BinOpKind::BitXor,\n+                    hir::BinOpKind::Shl,\n+                    hir::BinOpKind::Shr,\n                 ],\n             ) {\n                 span_lint("}, {"sha": "cc39f060fc7f3929a69ed1860ca789a6dfbc6e54", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,7 +1,7 @@\n use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    differing_macro_contexts, is_type_diagnostic_item, snippet_with_applicability, span_lint_and_then, walk_ptrs_ty,\n-    SpanlessEq,\n+    differing_macro_contexts, eq_expr_value, is_type_diagnostic_item, snippet_with_applicability, span_lint_and_then,\n+    walk_ptrs_ty,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -92,8 +92,8 @@ fn check_manual_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n             if rhs2.segments.len() == 1;\n \n             if ident.as_str() == rhs2.segments[0].ident.as_str();\n-            if SpanlessEq::new(cx).ignore_fn().eq_expr(tmp_init, lhs1);\n-            if SpanlessEq::new(cx).ignore_fn().eq_expr(rhs1, lhs2);\n+            if eq_expr_value(cx, tmp_init, lhs1);\n+            if eq_expr_value(cx, rhs1, lhs2);\n             then {\n                 if let ExprKind::Field(ref lhs1, _) = lhs1.kind {\n                     if let ExprKind::Field(ref lhs2, _) = lhs2.kind {\n@@ -193,7 +193,7 @@ enum Slice<'a> {\n fn check_for_slice<'a>(cx: &LateContext<'_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<'_>) -> Slice<'a> {\n     if let ExprKind::Index(ref lhs1, ref idx1) = lhs1.kind {\n         if let ExprKind::Index(ref lhs2, ref idx2) = lhs2.kind {\n-            if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n+            if eq_expr_value(cx, lhs1, lhs2) {\n                 let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(lhs1));\n \n                 if matches!(ty.kind, ty::Slice(_))\n@@ -221,8 +221,8 @@ fn check_suspicious_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n             if !differing_macro_contexts(first.span, second.span);\n             if let ExprKind::Assign(ref lhs0, ref rhs0, _) = first.kind;\n             if let ExprKind::Assign(ref lhs1, ref rhs1, _) = second.kind;\n-            if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs0, rhs1);\n-            if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, rhs0);\n+            if eq_expr_value(cx, lhs0, rhs1);\n+            if eq_expr_value(cx, lhs1, rhs0);\n             then {\n                 let lhs0 = Sugg::hir_opt(cx, lhs0);\n                 let rhs0 = Sugg::hir_opt(cx, rhs0);"}, {"sha": "11bdd27d9b1b2c88b3a7d6070d0b530aa0355d8f", "filename": "clippy_lints/src/to_string_in_display.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fto_string_in_display.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -0,0 +1,100 @@\n+use crate::utils::{match_def_path, match_trait_method, paths, span_lint};\n+use if_chain::if_chain;\n+use rustc_hir::{Expr, ExprKind, Item, ItemKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for uses of `to_string()` in `Display` traits.\n+    ///\n+    /// **Why is this bad?** Usually `to_string` is implemented indirectly\n+    /// via `Display`. Hence using it while implementing `Display` would\n+    /// lead to infinite recursion.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// struct Structure(i32);\n+    /// impl fmt::Display for Structure {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    ///         write!(f, \"{}\", self.to_string())\n+    ///     }\n+    /// }\n+    ///\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// struct Structure(i32);\n+    /// impl fmt::Display for Structure {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    ///         write!(f, \"{}\", self.0)\n+    ///     }\n+    /// }\n+    /// ```\n+    pub TO_STRING_IN_DISPLAY,\n+    correctness,\n+    \"to_string method used while implementing Display trait\"\n+}\n+\n+#[derive(Default)]\n+pub struct ToStringInDisplay {\n+    in_display_impl: bool,\n+}\n+\n+impl ToStringInDisplay {\n+    pub fn new() -> Self {\n+        Self { in_display_impl: false }\n+    }\n+}\n+\n+impl_lint_pass!(ToStringInDisplay => [TO_STRING_IN_DISPLAY]);\n+\n+impl LateLintPass<'_> for ToStringInDisplay {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        if is_display_impl(cx, item) {\n+            self.in_display_impl = true;\n+        }\n+    }\n+\n+    fn check_item_post(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        if is_display_impl(cx, item) {\n+            self.in_display_impl = false;\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::MethodCall(ref path, _, _, _) = expr.kind;\n+            if path.ident.name == sym!(to_string);\n+            if match_trait_method(cx, expr, &paths::TO_STRING);\n+            if self.in_display_impl;\n+\n+            then {\n+                span_lint(\n+                    cx,\n+                    TO_STRING_IN_DISPLAY,\n+                    expr.span,\n+                    \"Using to_string in fmt::Display implementation might lead to infinite recursion\",\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn is_display_impl(cx: &LateContext<'_>, item: &Item<'_>) -> bool {\n+    if_chain! {\n+        if let ItemKind::Impl { of_trait: Some(trait_ref), .. } = &item.kind;\n+        if let Some(did) = trait_ref.trait_def_id();\n+        then {\n+            match_def_path(cx, did, &paths::DISPLAY_TRAIT)\n+        } else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "a4676e505b6f38e946d0e83b5fdf9a6dee9a7030", "filename": "clippy_lints/src/try_err.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftry_err.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,10 +1,10 @@\n use crate::utils::{\n-    is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet,\n-    snippet_with_macro_callsite, span_lint_and_sugg,\n+    is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet, snippet_with_macro_callsite,\n+    span_lint_and_sugg,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, QPath, LangItem, MatchSource};\n+use rustc_hir::{Expr, ExprKind, LangItem, MatchSource, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Ty};"}, {"sha": "7e9190bef5e78425ac5478cb78e6e2ec24879f12", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -353,14 +353,25 @@ impl Types {\n                             );\n                             return; // don't recurse into the type\n                         }\n-                        if let Some(span) = match_type_parameter(cx, qpath, &paths::BOX) {\n+                        if match_type_parameter(cx, qpath, &paths::BOX).is_some() {\n+                            let box_ty = match &last_path_segment(qpath).args.unwrap().args[0] {\n+                                GenericArg::Type(ty) => match &ty.kind {\n+                                    TyKind::Path(qpath) => qpath,\n+                                    _ => return,\n+                                },\n+                                _ => return,\n+                            };\n+                            let inner_span = match &last_path_segment(&box_ty).args.unwrap().args[0] {\n+                                GenericArg::Type(ty) => ty.span,\n+                                _ => return,\n+                            };\n                             span_lint_and_sugg(\n                                 cx,\n                                 REDUNDANT_ALLOCATION,\n                                 hir_ty.span,\n                                 \"usage of `Rc<Box<T>>`\",\n                                 \"try\",\n-                                snippet(cx, span, \"..\").to_string(),\n+                                format!(\"Rc<{}>\", snippet(cx, inner_span, \"..\")),\n                                 Applicability::MachineApplicable,\n                             );\n                             return; // don't recurse into the type"}, {"sha": "d73662f49362ebd7c547d5e5c6485e50fec94a06", "filename": "clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -2,9 +2,9 @@\n \n use crate::utils::ast_utils::{eq_field_pat, eq_id, eq_pat, eq_path};\n use crate::utils::{over, span_lint_and_then};\n-use rustc_ast::{self as ast, Pat, PatKind, PatKind::*, DUMMY_NODE_ID};\n use rustc_ast::mut_visit::*;\n use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, Pat, PatKind, PatKind::*, DUMMY_NODE_ID};\n use rustc_ast_pretty::pprust;\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};"}, {"sha": "7548c6afa973afec4838369bb06ed8b6bd5efd3c", "filename": "clippy_lints/src/unused_unit.rs", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Funused_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Funused_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_unit.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -0,0 +1,144 @@\n+use if_chain::if_chain;\n+use rustc_ast::ast;\n+use rustc_ast::visit::FnKind;\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+use rustc_span::BytePos;\n+\n+use crate::utils::span_lint_and_sugg;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for unit (`()`) expressions that can be removed.\n+    ///\n+    /// **Why is this bad?** Such expressions add no value, but can make the code\n+    /// less readable. Depending on formatting they can make a `break` or `return`\n+    /// statement look like a function call.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn return_unit() -> () {\n+    ///     ()\n+    /// }\n+    /// ```\n+    pub UNUSED_UNIT,\n+    style,\n+    \"needless unit expression\"\n+}\n+\n+declare_lint_pass!(UnusedUnit => [UNUSED_UNIT]);\n+\n+impl EarlyLintPass for UnusedUnit {\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, kind: FnKind<'_>, span: Span, _: ast::NodeId) {\n+        if_chain! {\n+            if let ast::FnRetTy::Ty(ref ty) = kind.decl().output;\n+            if let ast::TyKind::Tup(ref vals) = ty.kind;\n+            if vals.is_empty() && !ty.span.from_expansion() && get_def(span) == get_def(ty.span);\n+            then {\n+                lint_unneeded_unit_return(cx, ty, span);\n+            }\n+        }\n+    }\n+\n+    fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n+        if_chain! {\n+            if let Some(ref stmt) = block.stmts.last();\n+            if let ast::StmtKind::Expr(ref expr) = stmt.kind;\n+            if is_unit_expr(expr) && !stmt.span.from_expansion();\n+            then {\n+                let sp = expr.span;\n+                span_lint_and_sugg(\n+                    cx,\n+                    UNUSED_UNIT,\n+                    sp,\n+                    \"unneeded unit expression\",\n+                    \"remove the final `()`\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n+        match e.kind {\n+            ast::ExprKind::Ret(Some(ref expr)) | ast::ExprKind::Break(_, Some(ref expr)) => {\n+                if is_unit_expr(expr) && !expr.span.from_expansion() {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        UNUSED_UNIT,\n+                        expr.span,\n+                        \"unneeded `()`\",\n+                        \"remove the `()`\",\n+                        String::new(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+\n+    fn check_poly_trait_ref(&mut self, cx: &EarlyContext<'_>, poly: &ast::PolyTraitRef, _: &ast::TraitBoundModifier) {\n+        let segments = &poly.trait_ref.path.segments;\n+\n+        if_chain! {\n+            if segments.len() == 1;\n+            if [\"Fn\", \"FnMut\", \"FnOnce\"].contains(&&*segments[0].ident.name.as_str());\n+            if let Some(args) = &segments[0].args;\n+            if let ast::GenericArgs::Parenthesized(generic_args) = &**args;\n+            if let ast::FnRetTy::Ty(ty) = &generic_args.output;\n+            if ty.kind.is_unit();\n+            then {\n+                lint_unneeded_unit_return(cx, ty, generic_args.span);\n+            }\n+        }\n+    }\n+}\n+\n+// get the def site\n+#[must_use]\n+fn get_def(span: Span) -> Option<Span> {\n+    if span.from_expansion() {\n+        Some(span.ctxt().outer_expn_data().def_site)\n+    } else {\n+        None\n+    }\n+}\n+\n+// is this expr a `()` unit?\n+fn is_unit_expr(expr: &ast::Expr) -> bool {\n+    if let ast::ExprKind::Tup(ref vals) = expr.kind {\n+        vals.is_empty()\n+    } else {\n+        false\n+    }\n+}\n+\n+fn lint_unneeded_unit_return(cx: &EarlyContext<'_>, ty: &ast::Ty, span: Span) {\n+    let (ret_span, appl) = if let Ok(fn_source) = cx.sess().source_map().span_to_snippet(span.with_hi(ty.span.hi())) {\n+        fn_source\n+            .rfind(\"->\")\n+            .map_or((ty.span, Applicability::MaybeIncorrect), |rpos| {\n+                (\n+                    #[allow(clippy::cast_possible_truncation)]\n+                    ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),\n+                    Applicability::MachineApplicable,\n+                )\n+            })\n+    } else {\n+        (ty.span, Applicability::MaybeIncorrect)\n+    };\n+    span_lint_and_sugg(\n+        cx,\n+        UNUSED_UNIT,\n+        ret_span,\n+        \"unneeded unit return type\",\n+        \"remove the `-> ()`\",\n+        String::new(),\n+        appl,\n+    );\n+}"}, {"sha": "427a1b6577315c271611a0cd9c5c5d8e721a4346", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -50,7 +50,7 @@ declare_clippy_lint! {\n     /// ```\n     pub USE_SELF,\n     nursery,\n-    \"Unnecessary structure name repetition whereas `Self` is applicable\"\n+    \"unnecessary structure name repetition whereas `Self` is applicable\"\n }\n \n declare_lint_pass!(UseSelf => [USE_SELF]);"}, {"sha": "4ab2b5e796deb75f7361fc466c9d69306e7c7db4", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,3 +1,4 @@\n+use crate::utils::sugg::Sugg;\n use crate::utils::{\n     get_parent_expr, is_type_diagnostic_item, match_def_path, match_trait_method, paths, snippet,\n     snippet_with_macro_callsite, span_lint_and_help, span_lint_and_sugg,\n@@ -158,7 +159,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                             if TyS::same_type(a, b);\n \n                             then {\n-                                let sugg = snippet(cx, args[0].span.source_callsite(), \"<expr>\").into_owned();\n+                                let sugg = Sugg::hir_with_macro_callsite(cx, &args[0], \"<expr>\").maybe_par();\n                                 let sugg_msg =\n                                     format!(\"consider removing `{}()`\", snippet(cx, path.span, \"From::from\"));\n                                 span_lint_and_sugg(\n@@ -167,7 +168,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                                     e.span,\n                                     \"useless conversion to the same type\",\n                                     &sugg_msg,\n-                                    sugg,\n+                                    sugg.to_string(),\n                                     Applicability::MachineApplicable, // snippet\n                                 );\n                             }"}, {"sha": "7b419431c0f51dafe566ad6a29dd46394213ac74", "filename": "clippy_lints/src/utils/ast_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -5,8 +5,8 @@\n #![allow(clippy::similar_names, clippy::wildcard_imports, clippy::enum_glob_use)]\n \n use crate::utils::{both, over};\n-use rustc_ast::{self as ast, *};\n use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, *};\n use rustc_span::symbol::Ident;\n use std::mem;\n "}, {"sha": "6eda6d1fa834074abca08450b2ece236c44ba175", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -175,18 +175,15 @@ impl PrintVisitor {\n     }\n \n     fn print_qpath(&mut self, path: &QPath<'_>) {\n-        match  *path {\n-            QPath::LangItem(lang_item, _) => {\n-                println!(\n-                    \"    if matches!({}, QPath::LangItem(LangItem::{:?}, _));\",\n-                   self.current, lang_item,\n-                );\n-            },\n-            _ => {\n-                print!(\"    if match_qpath({}, &[\", self.current);\n-                print_path(path, &mut true);\n-                println!(\"]);\");\n-            },\n+        if let QPath::LangItem(lang_item, _) = *path {\n+            println!(\n+                \"    if matches!({}, QPath::LangItem(LangItem::{:?}, _));\",\n+                self.current, lang_item,\n+            );\n+        } else {\n+            print!(\"    if match_qpath({}, &[\", self.current);\n+            print_path(path, &mut true);\n+            println!(\"]);\");\n         }\n     }\n }"}, {"sha": "292dbd7ad6b480babd426aae3dadc51060b419ac", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -138,7 +138,7 @@ define_Conf! {\n     (type_complexity_threshold, \"type_complexity_threshold\": u64, 250),\n     /// Lint: MANY_SINGLE_CHAR_NAMES. The maximum number of single char bindings a scope may have\n     (single_char_binding_names_threshold, \"single_char_binding_names_threshold\": u64, 4),\n-    /// Lint: BOXED_LOCAL. The maximum size of objects (in bytes) that will be linted. Larger objects are ok on the heap\n+    /// Lint: BOXED_LOCAL, USELESS_VEC. The maximum size of objects (in bytes) that will be linted. Larger objects are ok on the heap\n     (too_large_for_stack, \"too_large_for_stack\": u64, 200),\n     /// Lint: ENUM_VARIANT_NAMES. The minimum number of enum variants for the lints about variant names to trigger\n     (enum_variant_name_threshold, \"enum_variant_name_threshold\": u64, 3),"}, {"sha": "8563b469a30dd73772ee71722bdf04520f67575d", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -56,43 +56,45 @@ pub fn range<'a>(expr: &'a hir::Expr<'_>) -> Option<Range<'a>> {\n     }\n \n     match expr.kind {\n-        hir::ExprKind::Call(ref path, ref args) if matches!(\n-            path.kind,\n-            hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, _))\n-        ) => Some(Range {\n-            start: Some(&args[0]),\n-            end: Some(&args[1]),\n-            limits: ast::RangeLimits::Closed,\n-        }),\n-        hir::ExprKind::Struct(ref path, ref fields, None) => {\n-            match path {\n-                hir::QPath::LangItem(hir::LangItem::RangeFull, _) => Some(Range {\n-                    start: None,\n-                    end: None,\n-                    limits: ast::RangeLimits::HalfOpen,\n-                }),\n-                hir::QPath::LangItem(hir::LangItem::RangeFrom, _) => Some(Range {\n-                    start: Some(get_field(\"start\", fields)?),\n-                    end: None,\n-                    limits: ast::RangeLimits::HalfOpen,\n-                }),\n-                hir::QPath::LangItem(hir::LangItem::Range, _) => Some(Range {\n-                    start: Some(get_field(\"start\", fields)?),\n-                    end: Some(get_field(\"end\", fields)?),\n-                    limits: ast::RangeLimits::HalfOpen,\n-                }),\n-                hir::QPath::LangItem(hir::LangItem::RangeToInclusive, _) => Some(Range {\n-                    start: None,\n-                    end: Some(get_field(\"end\", fields)?),\n-                    limits: ast::RangeLimits::Closed,\n-                }),\n-                hir::QPath::LangItem(hir::LangItem::RangeTo, _) => Some(Range {\n-                    start: None,\n-                    end: Some(get_field(\"end\", fields)?),\n-                    limits: ast::RangeLimits::HalfOpen,\n-                }),\n-                _ => None,\n-            }\n+        hir::ExprKind::Call(ref path, ref args)\n+            if matches!(\n+                path.kind,\n+                hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, _))\n+            ) =>\n+        {\n+            Some(Range {\n+                start: Some(&args[0]),\n+                end: Some(&args[1]),\n+                limits: ast::RangeLimits::Closed,\n+            })\n+        },\n+        hir::ExprKind::Struct(ref path, ref fields, None) => match path {\n+            hir::QPath::LangItem(hir::LangItem::RangeFull, _) => Some(Range {\n+                start: None,\n+                end: None,\n+                limits: ast::RangeLimits::HalfOpen,\n+            }),\n+            hir::QPath::LangItem(hir::LangItem::RangeFrom, _) => Some(Range {\n+                start: Some(get_field(\"start\", fields)?),\n+                end: None,\n+                limits: ast::RangeLimits::HalfOpen,\n+            }),\n+            hir::QPath::LangItem(hir::LangItem::Range, _) => Some(Range {\n+                start: Some(get_field(\"start\", fields)?),\n+                end: Some(get_field(\"end\", fields)?),\n+                limits: ast::RangeLimits::HalfOpen,\n+            }),\n+            hir::QPath::LangItem(hir::LangItem::RangeToInclusive, _) => Some(Range {\n+                start: None,\n+                end: Some(get_field(\"end\", fields)?),\n+                limits: ast::RangeLimits::Closed,\n+            }),\n+            hir::QPath::LangItem(hir::LangItem::RangeTo, _) => Some(Range {\n+                start: None,\n+                end: Some(get_field(\"end\", fields)?),\n+                limits: ast::RangeLimits::HalfOpen,\n+            }),\n+            _ => None,\n         },\n         _ => None,\n     }"}, {"sha": "c7263f48965a5a505e0e1f879fda4eaf2d0c5522", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -3,9 +3,9 @@ use crate::utils::differing_macro_contexts;\n use rustc_ast::ast::InlineAsmTemplatePiece;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::{\n-    BinOpKind, Block, BlockCheckMode, BodyId, BorrowKind, CaptureBy, Expr, ExprKind, Field, FieldPat,\n-    FnRetTy, GenericArg, GenericArgs, Guard, InlineAsmOperand, Lifetime, LifetimeName, ParamName,\n-    Pat, PatKind, Path, PathSegment, QPath, Stmt, StmtKind, Ty, TyKind, TypeBinding,\n+    BinOpKind, Block, BlockCheckMode, BodyId, BorrowKind, CaptureBy, Expr, ExprKind, Field, FieldPat, FnRetTy,\n+    GenericArg, GenericArgs, Guard, InlineAsmOperand, Lifetime, LifetimeName, ParamName, Pat, PatKind, Path,\n+    PathSegment, QPath, Stmt, StmtKind, Ty, TyKind, TypeBinding,\n };\n use rustc_lint::LateContext;\n use rustc_middle::ich::StableHashingContextProvider;\n@@ -23,23 +23,22 @@ pub struct SpanlessEq<'a, 'tcx> {\n     /// Context used to evaluate constant expressions.\n     cx: &'a LateContext<'tcx>,\n     maybe_typeck_results: Option<&'tcx TypeckResults<'tcx>>,\n-    /// If is true, never consider as equal expressions containing function\n-    /// calls.\n-    ignore_fn: bool,\n+    allow_side_effects: bool,\n }\n \n impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     pub fn new(cx: &'a LateContext<'tcx>) -> Self {\n         Self {\n             cx,\n             maybe_typeck_results: cx.maybe_typeck_results(),\n-            ignore_fn: false,\n+            allow_side_effects: true,\n         }\n     }\n \n-    pub fn ignore_fn(self) -> Self {\n+    /// Consider expressions containing potential side effects as not equal.\n+    pub fn deny_side_effects(self) -> Self {\n         Self {\n-            ignore_fn: true,\n+            allow_side_effects: false,\n             ..self\n         }\n     }\n@@ -67,7 +66,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n \n     #[allow(clippy::similar_names)]\n     pub fn eq_expr(&mut self, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n-        if self.ignore_fn && differing_macro_contexts(left.span, right.span) {\n+        if !self.allow_side_effects && differing_macro_contexts(left.span, right.span) {\n             return false;\n         }\n \n@@ -90,10 +89,10 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                 both(&li.label, &ri.label, |l, r| l.ident.as_str() == r.ident.as_str())\n             },\n             (&ExprKind::Assign(ref ll, ref lr, _), &ExprKind::Assign(ref rl, ref rr, _)) => {\n-                self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+                self.allow_side_effects && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             },\n             (&ExprKind::AssignOp(ref lo, ref ll, ref lr), &ExprKind::AssignOp(ref ro, ref rl, ref rr)) => {\n-                lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+                self.allow_side_effects && lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             },\n             (&ExprKind::Block(ref l, _), &ExprKind::Block(ref r, _)) => self.eq_block(l, r),\n             (&ExprKind::Binary(l_op, ref ll, ref lr), &ExprKind::Binary(r_op, ref rl, ref rr)) => {\n@@ -108,7 +107,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             },\n             (&ExprKind::Box(ref l), &ExprKind::Box(ref r)) => self.eq_expr(l, r),\n             (&ExprKind::Call(l_fun, l_args), &ExprKind::Call(r_fun, r_args)) => {\n-                !self.ignore_fn && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n+                self.allow_side_effects && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprKind::Cast(ref lx, ref lt), &ExprKind::Cast(ref rx, ref rt))\n             | (&ExprKind::Type(ref lx, ref lt), &ExprKind::Type(ref rx, ref rt)) => {\n@@ -134,7 +133,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                     })\n             },\n             (&ExprKind::MethodCall(l_path, _, l_args, _), &ExprKind::MethodCall(r_path, _, r_args, _)) => {\n-                !self.ignore_fn && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n+                self.allow_side_effects && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprKind::Repeat(ref le, ref ll_id), &ExprKind::Repeat(ref re, ref rl_id)) => {\n                 let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(ll_id.body));\n@@ -186,10 +185,8 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     }\n \n     pub fn eq_fieldpat(&mut self, left: &FieldPat<'_>, right: &FieldPat<'_>) -> bool {\n-        match (&left, &right) {\n-            (FieldPat { ident: li, pat: lp, .. }, FieldPat { ident: ri, pat: rp, .. }) =>\n-                li.name.as_str() == ri.name.as_str() && self.eq_pat(lp, rp),\n-        }\n+        let (FieldPat { ident: li, pat: lp, .. }, FieldPat { ident: ri, pat: rp, .. }) = (&left, &right);\n+        li.name.as_str() == ri.name.as_str() && self.eq_pat(lp, rp)\n     }\n \n     /// Checks whether two patterns are the same.\n@@ -233,8 +230,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             (&QPath::TypeRelative(ref lty, ref lseg), &QPath::TypeRelative(ref rty, ref rseg)) => {\n                 self.eq_ty(lty, rty) && self.eq_path_segment(lseg, rseg)\n             },\n-            (&QPath::LangItem(llang_item, _), &QPath::LangItem(rlang_item, _)) =>\n-                llang_item == rlang_item,\n+            (&QPath::LangItem(llang_item, _), &QPath::LangItem(rlang_item, _)) => llang_item == rlang_item,\n             _ => false,\n         }\n     }\n@@ -352,6 +348,11 @@ pub fn over<X>(left: &[X], right: &[X], mut eq_fn: impl FnMut(&X, &X) -> bool) -\n     left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y))\n }\n \n+/// Checks if two expressions evaluate to the same value, and don't contain any side effects.\n+pub fn eq_expr_value(cx: &LateContext<'_>, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n+    SpanlessEq::new(cx).deny_side_effects().eq_expr(left, right)\n+}\n+\n /// Type used to hash an ast element. This is different from the `Hash` trait\n /// on ast types as this\n /// trait would consider IDs and spans.\n@@ -615,7 +616,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             },\n             QPath::LangItem(lang_item, ..) => {\n                 lang_item.hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n-            }\n+            },\n         }\n         // self.maybe_typeck_results.unwrap().qpath_res(p, id).hash(&mut self.s);\n     }\n@@ -727,7 +728,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 },\n                 QPath::LangItem(lang_item, ..) => {\n                     lang_item.hash(&mut self.s);\n-                }\n+                },\n             },\n             TyKind::OpaqueDef(_, arg_list) => {\n                 self.hash_generic_args(arg_list);"}, {"sha": "8fa5d22210a3691f585b16256dc54e5464827d85", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,7 +1,6 @@\n-use crate::utils::SpanlessEq;\n use crate::utils::{\n     is_expn_of, match_def_path, match_qpath, match_type, method_calls, paths, run_lints, snippet, span_lint,\n-    span_lint_and_help, span_lint_and_sugg, walk_ptrs_ty,\n+    span_lint_and_help, span_lint_and_sugg, walk_ptrs_ty, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::{Crate as AstCrate, ItemKind, LitKind, NodeId};\n@@ -493,7 +492,7 @@ impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n             if let StmtKind::Semi(only_expr) = &stmts[0].kind;\n             if let ExprKind::MethodCall(ref ps, _, ref span_call_args, _) = &only_expr.kind;\n             let and_then_snippets = get_and_then_snippets(cx, and_then_args);\n-            let mut sle = SpanlessEq::new(cx).ignore_fn();\n+            let mut sle = SpanlessEq::new(cx).deny_side_effects();\n             then {\n                 match &*ps.ident.as_str() {\n                     \"span_suggestion\" if sle.eq_expr(&and_then_args[2], &span_call_args[1]) => {"}, {"sha": "2aef995cec44b9245d9092327d49cedc324a4345", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -21,7 +21,7 @@ pub mod sugg;\n pub mod usage;\n pub use self::attrs::*;\n pub use self::diagnostics::*;\n-pub use self::hir_utils::{both, over, SpanlessEq, SpanlessHash};\n+pub use self::hir_utils::{both, eq_expr_value, over, SpanlessEq, SpanlessHash};\n \n use std::borrow::Cow;\n use std::mem;"}, {"sha": "b6a1e0a6aa992fbb718dc55d4b4046bafd2df9c9", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -84,6 +84,7 @@ pub const POLL: [&str; 4] = [\"core\", \"task\", \"poll\", \"Poll\"];\n pub const PTR_EQ: [&str; 3] = [\"core\", \"ptr\", \"eq\"];\n pub const PTR_NULL: [&str; 2] = [\"ptr\", \"null\"];\n pub const PTR_NULL_MUT: [&str; 2] = [\"ptr\", \"null_mut\"];\n+pub const PUSH_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"push_str\"];\n pub const RANGE_ARGUMENT_TRAIT: [&str; 3] = [\"core\", \"ops\", \"RangeBounds\"];\n pub const RC: [&str; 3] = [\"alloc\", \"rc\", \"Rc\"];\n pub const RC_PTR_EQ: [&str; 4] = [\"alloc\", \"rc\", \"Rc\", \"ptr_eq\"];"}, {"sha": "84e907d7125de8951f291dc201a4c453d417c74d", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 60, "deletions": 37, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,13 +1,20 @@\n-use crate::consts::constant;\n+use crate::consts::{constant, Constant};\n+use crate::rustc_target::abi::LayoutOf;\n use crate::utils::{higher, is_copy, snippet_with_applicability, span_lint_and_sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BorrowKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, Ty};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n \n+#[allow(clippy::module_name_repetitions)]\n+#[derive(Copy, Clone)]\n+pub struct UselessVec {\n+    pub too_large_for_stack: u64,\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of `&vec![..]` when using `&[..]` would\n     /// be possible.\n@@ -31,7 +38,7 @@ declare_clippy_lint! {\n     \"useless `vec!`\"\n }\n \n-declare_lint_pass!(UselessVec => [USELESS_VEC]);\n+impl_lint_pass!(UselessVec => [USELESS_VEC]);\n \n impl<'tcx> LateLintPass<'tcx> for UselessVec {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n@@ -42,7 +49,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessVec {\n             if let ExprKind::AddrOf(BorrowKind::Ref, _, ref addressee) = expr.kind;\n             if let Some(vec_args) = higher::vec_macro(cx, addressee);\n             then {\n-                check_vec_macro(cx, &vec_args, expr.span);\n+                self.check_vec_macro(cx, &vec_args, expr.span);\n             }\n         }\n \n@@ -60,46 +67,62 @@ impl<'tcx> LateLintPass<'tcx> for UselessVec {\n                     .ctxt()\n                     .outer_expn_data()\n                     .call_site;\n-                check_vec_macro(cx, &vec_args, span);\n+                self.check_vec_macro(cx, &vec_args, span);\n             }\n         }\n     }\n }\n \n-fn check_vec_macro<'tcx>(cx: &LateContext<'tcx>, vec_args: &higher::VecArgs<'tcx>, span: Span) {\n-    let mut applicability = Applicability::MachineApplicable;\n-    let snippet = match *vec_args {\n-        higher::VecArgs::Repeat(elem, len) => {\n-            if constant(cx, cx.typeck_results(), len).is_some() {\n-                format!(\n-                    \"&[{}; {}]\",\n-                    snippet_with_applicability(cx, elem.span, \"elem\", &mut applicability),\n-                    snippet_with_applicability(cx, len.span, \"len\", &mut applicability)\n-                )\n-            } else {\n-                return;\n-            }\n-        },\n-        higher::VecArgs::Vec(args) => {\n-            if let Some(last) = args.iter().last() {\n-                let span = args[0].span.to(last.span);\n+impl UselessVec {\n+    fn check_vec_macro<'tcx>(self, cx: &LateContext<'tcx>, vec_args: &higher::VecArgs<'tcx>, span: Span) {\n+        let mut applicability = Applicability::MachineApplicable;\n+        let snippet = match *vec_args {\n+            higher::VecArgs::Repeat(elem, len) => {\n+                if let Some((Constant::Int(len_constant), _)) = constant(cx, cx.typeck_results(), len) {\n+                    #[allow(clippy::cast_possible_truncation)]\n+                    if len_constant as u64 * size_of(cx, elem) > self.too_large_for_stack {\n+                        return;\n+                    }\n \n-                format!(\"&[{}]\", snippet_with_applicability(cx, span, \"..\", &mut applicability))\n-            } else {\n-                \"&[]\".into()\n-            }\n-        },\n-    };\n+                    format!(\n+                        \"&[{}; {}]\",\n+                        snippet_with_applicability(cx, elem.span, \"elem\", &mut applicability),\n+                        snippet_with_applicability(cx, len.span, \"len\", &mut applicability)\n+                    )\n+                } else {\n+                    return;\n+                }\n+            },\n+            higher::VecArgs::Vec(args) => {\n+                if let Some(last) = args.iter().last() {\n+                    #[allow(clippy::cast_possible_truncation)]\n+                    if args.len() as u64 * size_of(cx, last) > self.too_large_for_stack {\n+                        return;\n+                    }\n+                    let span = args[0].span.to(last.span);\n+\n+                    format!(\"&[{}]\", snippet_with_applicability(cx, span, \"..\", &mut applicability))\n+                } else {\n+                    \"&[]\".into()\n+                }\n+            },\n+        };\n+\n+        span_lint_and_sugg(\n+            cx,\n+            USELESS_VEC,\n+            span,\n+            \"useless use of `vec!`\",\n+            \"you can use a slice directly\",\n+            snippet,\n+            applicability,\n+        );\n+    }\n+}\n \n-    span_lint_and_sugg(\n-        cx,\n-        USELESS_VEC,\n-        span,\n-        \"useless use of `vec!`\",\n-        \"you can use a slice directly\",\n-        snippet,\n-        applicability,\n-    );\n+fn size_of(cx: &LateContext<'_>, expr: &Expr<'_>) -> u64 {\n+    let ty = cx.typeck_results().expr_ty_adjusted(expr);\n+    cx.layout_of(ty).map_or(0, |l| l.size.bytes())\n }\n \n /// Returns the item type of the vector (i.e., the `T` in `Vec<T>`)."}, {"sha": "5f88dcb188a0bf75044a41eeac61df664357d4c9", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -237,7 +237,7 @@ impl EarlyLintPass for Write {\n     fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &MacCall) {\n         if mac.path == sym!(println) {\n             span_lint(cx, PRINT_STDOUT, mac.span(), \"use of `println!`\");\n-            if let (Some(fmt_str), _) = self.check_tts(cx, &mac.args.inner_tokens(), false) {\n+            if let (Some(fmt_str), _) = self.check_tts(cx, mac.args.inner_tokens(), false) {\n                 if fmt_str.symbol == Symbol::intern(\"\") {\n                     span_lint_and_sugg(\n                         cx,\n@@ -252,7 +252,7 @@ impl EarlyLintPass for Write {\n             }\n         } else if mac.path == sym!(print) {\n             span_lint(cx, PRINT_STDOUT, mac.span(), \"use of `print!`\");\n-            if let (Some(fmt_str), _) = self.check_tts(cx, &mac.args.inner_tokens(), false) {\n+            if let (Some(fmt_str), _) = self.check_tts(cx, mac.args.inner_tokens(), false) {\n                 if check_newlines(&fmt_str) {\n                     span_lint_and_then(\n                         cx,\n@@ -273,7 +273,7 @@ impl EarlyLintPass for Write {\n                 }\n             }\n         } else if mac.path == sym!(write) {\n-            if let (Some(fmt_str), _) = self.check_tts(cx, &mac.args.inner_tokens(), true) {\n+            if let (Some(fmt_str), _) = self.check_tts(cx, mac.args.inner_tokens(), true) {\n                 if check_newlines(&fmt_str) {\n                     span_lint_and_then(\n                         cx,\n@@ -294,7 +294,7 @@ impl EarlyLintPass for Write {\n                 }\n             }\n         } else if mac.path == sym!(writeln) {\n-            if let (Some(fmt_str), expr) = self.check_tts(cx, &mac.args.inner_tokens(), true) {\n+            if let (Some(fmt_str), expr) = self.check_tts(cx, mac.args.inner_tokens(), true) {\n                 if fmt_str.symbol == Symbol::intern(\"\") {\n                     let mut applicability = Applicability::MachineApplicable;\n                     let suggestion = expr.map_or_else(\n@@ -364,17 +364,11 @@ impl Write {\n     /// (Some(\"string to write: {}\"), Some(buf))\n     /// ```\n     #[allow(clippy::too_many_lines)]\n-    fn check_tts<'a>(\n-        &self,\n-        cx: &EarlyContext<'a>,\n-        tts: &TokenStream,\n-        is_write: bool,\n-    ) -> (Option<StrLit>, Option<Expr>) {\n+    fn check_tts<'a>(&self, cx: &EarlyContext<'a>, tts: TokenStream, is_write: bool) -> (Option<StrLit>, Option<Expr>) {\n         use rustc_parse_format::{\n             AlignUnknown, ArgumentImplicitlyIs, ArgumentIs, ArgumentNamed, CountImplied, FormatSpec, ParseMode, Parser,\n             Piece,\n         };\n-        let tts = tts.clone();\n \n         let mut parser = parser::Parser::new(&cx.sess.parse_sess, tts, false, None);\n         let mut expr: Option<Expr> = None;"}, {"sha": "3c782e9b17ff15c0db0947b54b766aa52f8326ef", "filename": "doc/adding_lints.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -295,8 +295,14 @@ impl EarlyLintPass for FooFunctions {\n \n Running our UI test should now produce output that contains the lint message.\n \n+According to [the rustc-dev-guide], the text should be matter of fact and avoid\n+capitalization and periods, unless multiple sentences are needed.\n+When code or an identifier must appear in a message or label, it should be\n+surrounded with single acute accents \\`.\n+\n [check_fn]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html#method.check_fn\n [diagnostics]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/utils/diagnostics.rs\n+[the rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/diagnostics.html\n \n ## Adding the lint logic\n "}, {"sha": "bf58c117aaaa95c24a5a9154f1673fdbf577fc5e", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1037,7 +1037,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         group: \"style\",\n         desc: \"creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\",\n         deprecation: None,\n-        module: \"let_and_return\",\n+        module: \"returns\",\n     },\n     Lint {\n         name: \"let_underscore_lock\",\n@@ -1956,6 +1956,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"methods\",\n     },\n+    Lint {\n+        name: \"self_assignment\",\n+        group: \"correctness\",\n+        desc: \"explicit self-assignment\",\n+        deprecation: None,\n+        module: \"self_assignment\",\n+    },\n     Lint {\n         name: \"serde_api_misuse\",\n         group: \"correctness\",\n@@ -2012,6 +2019,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"methods\",\n     },\n+    Lint {\n+        name: \"single_char_push_str\",\n+        group: \"style\",\n+        desc: \"`push_str()` used with a single-character string literal as parameter\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n     Lint {\n         name: \"single_component_path_imports\",\n         group: \"style\",\n@@ -2166,6 +2180,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"to_digit_is_some\",\n     },\n+    Lint {\n+        name: \"to_string_in_display\",\n+        group: \"correctness\",\n+        desc: \"to_string method used while implementing Display trait\",\n+        deprecation: None,\n+        module: \"to_string_in_display\",\n+    },\n     Lint {\n         name: \"todo\",\n         group: \"restriction\",\n@@ -2369,6 +2390,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"methods\",\n     },\n+    Lint {\n+        name: \"unnecessary_lazy_evaluations\",\n+        group: \"style\",\n+        desc: \"using unnecessary lazy evaluation, which can be replaced with simpler eager evaluation\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n     Lint {\n         name: \"unnecessary_mut_passed\",\n         group: \"style\",\n@@ -2479,7 +2507,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         group: \"style\",\n         desc: \"needless unit expression\",\n         deprecation: None,\n-        module: \"returns\",\n+        module: \"unused_unit\",\n     },\n     Lint {\n         name: \"unwrap_used\",\n@@ -2498,7 +2526,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n     Lint {\n         name: \"use_self\",\n         group: \"nursery\",\n-        desc: \"Unnecessary structure name repetition whereas `Self` is applicable\",\n+        desc: \"unnecessary structure name repetition whereas `Self` is applicable\",\n         deprecation: None,\n         module: \"use_self\",\n     },"}, {"sha": "cdbeff6a037834f818e717ddc8ae24842dc8b412", "filename": "tests/ui/duration_subsec.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fduration_subsec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fduration_subsec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fduration_subsec.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,30 +1,30 @@\n-error: Calling `subsec_millis()` is more concise than this calculation\n+error: calling `subsec_millis()` is more concise than this calculation\n   --> $DIR/duration_subsec.rs:10:24\n    |\n LL |     let bad_millis_1 = dur.subsec_micros() / 1_000;\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `dur.subsec_millis()`\n    |\n    = note: `-D clippy::duration-subsec` implied by `-D warnings`\n \n-error: Calling `subsec_millis()` is more concise than this calculation\n+error: calling `subsec_millis()` is more concise than this calculation\n   --> $DIR/duration_subsec.rs:11:24\n    |\n LL |     let bad_millis_2 = dur.subsec_nanos() / 1_000_000;\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `dur.subsec_millis()`\n \n-error: Calling `subsec_micros()` is more concise than this calculation\n+error: calling `subsec_micros()` is more concise than this calculation\n   --> $DIR/duration_subsec.rs:16:22\n    |\n LL |     let bad_micros = dur.subsec_nanos() / 1_000;\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `dur.subsec_micros()`\n \n-error: Calling `subsec_micros()` is more concise than this calculation\n+error: calling `subsec_micros()` is more concise than this calculation\n   --> $DIR/duration_subsec.rs:21:13\n    |\n LL |     let _ = (&dur).subsec_nanos() / 1_000;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `(&dur).subsec_micros()`\n \n-error: Calling `subsec_micros()` is more concise than this calculation\n+error: calling `subsec_micros()` is more concise than this calculation\n   --> $DIR/duration_subsec.rs:25:13\n    |\n LL |     let _ = dur.subsec_nanos() / NANOS_IN_MICRO;"}, {"sha": "5935eea5e036e74845b71e7020526cd1d4426195", "filename": "tests/ui/enum_clike_unportable_variant.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fenum_clike_unportable_variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fenum_clike_unportable_variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fenum_clike_unportable_variant.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,54 +1,54 @@\n-error: Clike enum variant discriminant is not portable to 32-bit targets\n+error: C-like enum variant discriminant is not portable to 32-bit targets\n   --> $DIR/enum_clike_unportable_variant.rs:8:5\n    |\n LL |     X = 0x1_0000_0000,\n    |     ^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::enum-clike-unportable-variant` implied by `-D warnings`\n \n-error: Clike enum variant discriminant is not portable to 32-bit targets\n+error: C-like enum variant discriminant is not portable to 32-bit targets\n   --> $DIR/enum_clike_unportable_variant.rs:15:5\n    |\n LL |     X = 0x1_0000_0000,\n    |     ^^^^^^^^^^^^^^^^^\n \n-error: Clike enum variant discriminant is not portable to 32-bit targets\n+error: C-like enum variant discriminant is not portable to 32-bit targets\n   --> $DIR/enum_clike_unportable_variant.rs:18:5\n    |\n LL |     A = 0xFFFF_FFFF,\n    |     ^^^^^^^^^^^^^^^\n \n-error: Clike enum variant discriminant is not portable to 32-bit targets\n+error: C-like enum variant discriminant is not portable to 32-bit targets\n   --> $DIR/enum_clike_unportable_variant.rs:25:5\n    |\n LL |     Z = 0xFFFF_FFFF,\n    |     ^^^^^^^^^^^^^^^\n \n-error: Clike enum variant discriminant is not portable to 32-bit targets\n+error: C-like enum variant discriminant is not portable to 32-bit targets\n   --> $DIR/enum_clike_unportable_variant.rs:26:5\n    |\n LL |     A = 0x1_0000_0000,\n    |     ^^^^^^^^^^^^^^^^^\n \n-error: Clike enum variant discriminant is not portable to 32-bit targets\n+error: C-like enum variant discriminant is not portable to 32-bit targets\n   --> $DIR/enum_clike_unportable_variant.rs:28:5\n    |\n LL |     C = (i32::MIN as isize) - 1,\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: Clike enum variant discriminant is not portable to 32-bit targets\n+error: C-like enum variant discriminant is not portable to 32-bit targets\n   --> $DIR/enum_clike_unportable_variant.rs:34:5\n    |\n LL |     Z = 0xFFFF_FFFF,\n    |     ^^^^^^^^^^^^^^^\n \n-error: Clike enum variant discriminant is not portable to 32-bit targets\n+error: C-like enum variant discriminant is not portable to 32-bit targets\n   --> $DIR/enum_clike_unportable_variant.rs:35:5\n    |\n LL |     A = 0x1_0000_0000,\n    |     ^^^^^^^^^^^^^^^^^\n \n-error: Clike enum variant discriminant is not portable to 32-bit targets\n+error: C-like enum variant discriminant is not portable to 32-bit targets\n   --> $DIR/enum_clike_unportable_variant.rs:40:5\n    |\n LL |     X = <usize as Trait>::Number,"}, {"sha": "b1d481190ff53bdfa68e41934fa668c49edb05f6", "filename": "tests/ui/enum_variants.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fenum_variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fenum_variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fenum_variants.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,30 +1,30 @@\n-error: Variant name ends with the enum's name\n+error: variant name ends with the enum's name\n   --> $DIR/enum_variants.rs:16:5\n    |\n LL |     cFoo,\n    |     ^^^^\n    |\n    = note: `-D clippy::enum-variant-names` implied by `-D warnings`\n \n-error: Variant name starts with the enum's name\n+error: variant name starts with the enum's name\n   --> $DIR/enum_variants.rs:27:5\n    |\n LL |     FoodGood,\n    |     ^^^^^^^^\n \n-error: Variant name starts with the enum's name\n+error: variant name starts with the enum's name\n   --> $DIR/enum_variants.rs:28:5\n    |\n LL |     FoodMiddle,\n    |     ^^^^^^^^^^\n \n-error: Variant name starts with the enum's name\n+error: variant name starts with the enum's name\n   --> $DIR/enum_variants.rs:29:5\n    |\n LL |     FoodBad,\n    |     ^^^^^^^\n \n-error: All variants have the same prefix: `Food`\n+error: all variants have the same prefix: `Food`\n   --> $DIR/enum_variants.rs:26:1\n    |\n LL | / enum Food {\n@@ -36,7 +36,7 @@ LL | | }\n    |\n    = help: remove the prefixes and use full paths to the variants instead of glob imports\n \n-error: All variants have the same prefix: `CallType`\n+error: all variants have the same prefix: `CallType`\n   --> $DIR/enum_variants.rs:36:1\n    |\n LL | / enum BadCallType {\n@@ -48,7 +48,7 @@ LL | | }\n    |\n    = help: remove the prefixes and use full paths to the variants instead of glob imports\n \n-error: All variants have the same prefix: `Constant`\n+error: all variants have the same prefix: `Constant`\n   --> $DIR/enum_variants.rs:48:1\n    |\n LL | / enum Consts {\n@@ -60,7 +60,7 @@ LL | | }\n    |\n    = help: remove the prefixes and use full paths to the variants instead of glob imports\n \n-error: All variants have the same prefix: `With`\n+error: all variants have the same prefix: `With`\n   --> $DIR/enum_variants.rs:82:1\n    |\n LL | / enum Seallll {\n@@ -72,7 +72,7 @@ LL | | }\n    |\n    = help: remove the prefixes and use full paths to the variants instead of glob imports\n \n-error: All variants have the same prefix: `Prefix`\n+error: all variants have the same prefix: `Prefix`\n   --> $DIR/enum_variants.rs:88:1\n    |\n LL | / enum NonCaps {\n@@ -84,7 +84,7 @@ LL | | }\n    |\n    = help: remove the prefixes and use full paths to the variants instead of glob imports\n \n-error: All variants have the same prefix: `With`\n+error: all variants have the same prefix: `With`\n   --> $DIR/enum_variants.rs:94:1\n    |\n LL | / pub enum PubSeall {"}, {"sha": "6afee0f36b9da21b592e78b947cdc07140b14015", "filename": "tests/ui/if_let_some_result.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fif_let_some_result.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fif_let_some_result.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_let_some_result.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,22 +1,22 @@\n-error: Matching on `Some` with `ok()` is redundant\n+error: matching on `Some` with `ok()` is redundant\n   --> $DIR/if_let_some_result.rs:6:5\n    |\n LL |     if let Some(y) = x.parse().ok() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::if-let-some-result` implied by `-D warnings`\n-help: Consider matching on `Ok(y)` and removing the call to `ok` instead\n+help: consider matching on `Ok(y)` and removing the call to `ok` instead\n    |\n LL |     if let Ok(y) = x.parse() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: Matching on `Some` with `ok()` is redundant\n+error: matching on `Some` with `ok()` is redundant\n   --> $DIR/if_let_some_result.rs:24:9\n    |\n LL |         if let Some(y) = x   .   parse()   .   ok   ()    {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: Consider matching on `Ok(y)` and removing the call to `ok` instead\n+help: consider matching on `Ok(y)` and removing the call to `ok` instead\n    |\n LL |         if let Ok(y) = x   .   parse()       {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "53d1b86d02a962a639631ea29c6415573cb8ee51", "filename": "tests/ui/if_not_else.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fif_not_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fif_not_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_not_else.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,4 +1,4 @@\n-error: Unnecessary boolean `not` operation\n+error: unnecessary boolean `not` operation\n   --> $DIR/if_not_else.rs:9:5\n    |\n LL | /     if !bla() {\n@@ -11,7 +11,7 @@ LL | |     }\n    = note: `-D clippy::if-not-else` implied by `-D warnings`\n    = help: remove the `!` and swap the blocks of the `if`/`else`\n \n-error: Unnecessary `!=` operation\n+error: unnecessary `!=` operation\n   --> $DIR/if_not_else.rs:14:5\n    |\n LL | /     if 4 != 5 {"}, {"sha": "aab688cc2d8b2b87d77ca9eb864a699a191edc3c", "filename": "tests/ui/impl.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fimpl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fimpl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,4 +1,4 @@\n-error: Multiple implementations of this structure\n+error: multiple implementations of this structure\n   --> $DIR/impl.rs:10:1\n    |\n LL | / impl MyStruct {\n@@ -7,23 +7,23 @@ LL | | }\n    | |_^\n    |\n    = note: `-D clippy::multiple-inherent-impl` implied by `-D warnings`\n-note: First implementation here\n+note: first implementation here\n   --> $DIR/impl.rs:6:1\n    |\n LL | / impl MyStruct {\n LL | |     fn first() {}\n LL | | }\n    | |_^\n \n-error: Multiple implementations of this structure\n+error: multiple implementations of this structure\n   --> $DIR/impl.rs:24:5\n    |\n LL | /     impl super::MyStruct {\n LL | |         fn third() {}\n LL | |     }\n    | |_____^\n    |\n-note: First implementation here\n+note: first implementation here\n   --> $DIR/impl.rs:6:1\n    |\n LL | / impl MyStruct {"}, {"sha": "5bb9a606422a13fdb740663f33850c3d3181f34b", "filename": "tests/ui/implicit_saturating_sub.stderr", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fimplicit_saturating_sub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fimplicit_saturating_sub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_saturating_sub.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,4 +1,4 @@\n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:13:5\n    |\n LL | /     if u_8 > 0 {\n@@ -8,175 +8,175 @@ LL | |     }\n    |\n    = note: `-D clippy::implicit-saturating-sub` implied by `-D warnings`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:20:13\n    |\n LL | /             if u_8 > 0 {\n LL | |                 u_8 -= 1;\n LL | |             }\n    | |_____________^ help: try: `u_8 = u_8.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:34:5\n    |\n LL | /     if u_16 > 0 {\n LL | |         u_16 -= 1;\n LL | |     }\n    | |_____^ help: try: `u_16 = u_16.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:44:5\n    |\n LL | /     if u_32 != 0 {\n LL | |         u_32 -= 1;\n LL | |     }\n    | |_____^ help: try: `u_32 = u_32.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:65:5\n    |\n LL | /     if u_64 > 0 {\n LL | |         u_64 -= 1;\n LL | |     }\n    | |_____^ help: try: `u_64 = u_64.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:70:5\n    |\n LL | /     if 0 < u_64 {\n LL | |         u_64 -= 1;\n LL | |     }\n    | |_____^ help: try: `u_64 = u_64.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:75:5\n    |\n LL | /     if 0 != u_64 {\n LL | |         u_64 -= 1;\n LL | |     }\n    | |_____^ help: try: `u_64 = u_64.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:96:5\n    |\n LL | /     if u_usize > 0 {\n LL | |         u_usize -= 1;\n LL | |     }\n    | |_____^ help: try: `u_usize = u_usize.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:108:5\n    |\n LL | /     if i_8 > i8::MIN {\n LL | |         i_8 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_8 = i_8.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:113:5\n    |\n LL | /     if i_8 > i8::MIN {\n LL | |         i_8 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_8 = i_8.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:118:5\n    |\n LL | /     if i_8 != i8::MIN {\n LL | |         i_8 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_8 = i_8.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:123:5\n    |\n LL | /     if i_8 != i8::MIN {\n LL | |         i_8 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_8 = i_8.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:133:5\n    |\n LL | /     if i_16 > i16::MIN {\n LL | |         i_16 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_16 = i_16.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:138:5\n    |\n LL | /     if i_16 > i16::MIN {\n LL | |         i_16 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_16 = i_16.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:143:5\n    |\n LL | /     if i_16 != i16::MIN {\n LL | |         i_16 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_16 = i_16.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:148:5\n    |\n LL | /     if i_16 != i16::MIN {\n LL | |         i_16 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_16 = i_16.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:158:5\n    |\n LL | /     if i_32 > i32::MIN {\n LL | |         i_32 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_32 = i_32.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:163:5\n    |\n LL | /     if i_32 > i32::MIN {\n LL | |         i_32 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_32 = i_32.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:168:5\n    |\n LL | /     if i_32 != i32::MIN {\n LL | |         i_32 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_32 = i_32.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:173:5\n    |\n LL | /     if i_32 != i32::MIN {\n LL | |         i_32 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_32 = i_32.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:183:5\n    |\n LL | /     if i64::MIN < i_64 {\n LL | |         i_64 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_64 = i_64.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:188:5\n    |\n LL | /     if i64::MIN != i_64 {\n LL | |         i_64 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_64 = i_64.saturating_sub(1);`\n \n-error: Implicitly performing saturating subtraction\n+error: implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:193:5\n    |\n LL | /     if i64::MIN < i_64 {"}, {"sha": "c5b020ba8ced51bce578f1337fe5ac52c7801662", "filename": "tests/ui/int_plus_one.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fint_plus_one.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fint_plus_one.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fint_plus_one.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,24 +1,24 @@\n-error: Unnecessary `>= y + 1` or `x - 1 >=`\n+error: unnecessary `>= y + 1` or `x - 1 >=`\n   --> $DIR/int_plus_one.rs:9:13\n    |\n LL |     let _ = x >= y + 1;\n    |             ^^^^^^^^^^ help: change it to: `x > y`\n    |\n    = note: `-D clippy::int-plus-one` implied by `-D warnings`\n \n-error: Unnecessary `>= y + 1` or `x - 1 >=`\n+error: unnecessary `>= y + 1` or `x - 1 >=`\n   --> $DIR/int_plus_one.rs:10:13\n    |\n LL |     let _ = y + 1 <= x;\n    |             ^^^^^^^^^^ help: change it to: `y < x`\n \n-error: Unnecessary `>= y + 1` or `x - 1 >=`\n+error: unnecessary `>= y + 1` or `x - 1 >=`\n   --> $DIR/int_plus_one.rs:12:13\n    |\n LL |     let _ = x - 1 >= y;\n    |             ^^^^^^^^^^ help: change it to: `x > y`\n \n-error: Unnecessary `>= y + 1` or `x - 1 >=`\n+error: unnecessary `>= y + 1` or `x - 1 >=`\n   --> $DIR/int_plus_one.rs:13:13\n    |\n LL |     let _ = y <= x - 1;"}, {"sha": "8c10a252ee01b427ead6cc1b2c2432a505003e49", "filename": "tests/ui/iter_next_slice.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fiter_next_slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fiter_next_slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_next_slice.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,24 +1,24 @@\n-error: Using `.iter().next()` on an array\n+error: using `.iter().next()` on an array\n   --> $DIR/iter_next_slice.rs:9:5\n    |\n LL |     s.iter().next();\n    |     ^^^^^^^^^^^^^^^ help: try calling: `s.get(0)`\n    |\n    = note: `-D clippy::iter-next-slice` implied by `-D warnings`\n \n-error: Using `.iter().next()` on a Slice without end index.\n+error: using `.iter().next()` on a Slice without end index\n   --> $DIR/iter_next_slice.rs:12:5\n    |\n LL |     s[2..].iter().next();\n    |     ^^^^^^^^^^^^^^^^^^^^ help: try calling: `s.get(2)`\n \n-error: Using `.iter().next()` on a Slice without end index.\n+error: using `.iter().next()` on a Slice without end index\n   --> $DIR/iter_next_slice.rs:15:5\n    |\n LL |     v[5..].iter().next();\n    |     ^^^^^^^^^^^^^^^^^^^^ help: try calling: `v.get(5)`\n \n-error: Using `.iter().next()` on an array\n+error: using `.iter().next()` on an array\n   --> $DIR/iter_next_slice.rs:18:5\n    |\n LL |     v.iter().next();"}, {"sha": "4f43cff50244449b93b23b76db601285132eab85", "filename": "tests/ui/map_clone.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fmap_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fmap_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_clone.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,40 +1,40 @@\n-error: You are using an explicit closure for copying elements\n+error: you are using an explicit closure for copying elements\n   --> $DIR/map_clone.rs:10:22\n    |\n LL |     let _: Vec<i8> = vec![5_i8; 6].iter().map(|x| *x).collect();\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider calling the dedicated `copied` method: `vec![5_i8; 6].iter().copied()`\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling the dedicated `copied` method: `vec![5_i8; 6].iter().copied()`\n    |\n    = note: `-D clippy::map-clone` implied by `-D warnings`\n \n-error: You are using an explicit closure for cloning elements\n+error: you are using an explicit closure for cloning elements\n   --> $DIR/map_clone.rs:11:26\n    |\n LL |     let _: Vec<String> = vec![String::new()].iter().map(|x| x.clone()).collect();\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider calling the dedicated `cloned` method: `vec![String::new()].iter().cloned()`\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling the dedicated `cloned` method: `vec![String::new()].iter().cloned()`\n \n-error: You are using an explicit closure for copying elements\n+error: you are using an explicit closure for copying elements\n   --> $DIR/map_clone.rs:12:23\n    |\n LL |     let _: Vec<u32> = vec![42, 43].iter().map(|&x| x).collect();\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider calling the dedicated `copied` method: `vec![42, 43].iter().copied()`\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling the dedicated `copied` method: `vec![42, 43].iter().copied()`\n \n-error: You are using an explicit closure for copying elements\n+error: you are using an explicit closure for copying elements\n   --> $DIR/map_clone.rs:14:26\n    |\n LL |     let _: Option<u64> = Some(&16).map(|b| *b);\n-   |                          ^^^^^^^^^^^^^^^^^^^^^ help: Consider calling the dedicated `copied` method: `Some(&16).copied()`\n+   |                          ^^^^^^^^^^^^^^^^^^^^^ help: consider calling the dedicated `copied` method: `Some(&16).copied()`\n \n-error: You are using an explicit closure for copying elements\n+error: you are using an explicit closure for copying elements\n   --> $DIR/map_clone.rs:15:25\n    |\n LL |     let _: Option<u8> = Some(&1).map(|x| x.clone());\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider calling the dedicated `copied` method: `Some(&1).copied()`\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling the dedicated `copied` method: `Some(&1).copied()`\n \n-error: You are needlessly cloning iterator elements\n+error: you are needlessly cloning iterator elements\n   --> $DIR/map_clone.rs:26:29\n    |\n LL |     let _ = std::env::args().map(|v| v.clone());\n-   |                             ^^^^^^^^^^^^^^^^^^^ help: Remove the `map` call\n+   |                             ^^^^^^^^^^^^^^^^^^^ help: remove the `map` call\n \n error: aborting due to 6 previous errors\n "}, {"sha": "80dd2f744b3a1137c06f513a4329afee18f9de9f", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 3, "deletions": 65, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -10,6 +10,7 @@\n     clippy::non_ascii_literal,\n     clippy::new_without_default,\n     clippy::needless_pass_by_value,\n+    clippy::needless_lifetimes,\n     clippy::print_stdout,\n     clippy::must_use_candidate,\n     clippy::use_self,\n@@ -33,71 +34,6 @@ use std::sync::{self, Arc};\n \n use option_helpers::IteratorFalsePositives;\n \n-pub struct T;\n-\n-impl T {\n-    pub fn add(self, other: T) -> T {\n-        self\n-    }\n-\n-    // no error, not public interface\n-    pub(crate) fn drop(&mut self) {}\n-\n-    // no error, private function\n-    fn neg(self) -> Self {\n-        self\n-    }\n-\n-    // no error, private function\n-    fn eq(&self, other: T) -> bool {\n-        true\n-    }\n-\n-    // No error; self is a ref.\n-    fn sub(&self, other: T) -> &T {\n-        self\n-    }\n-\n-    // No error; different number of arguments.\n-    fn div(self) -> T {\n-        self\n-    }\n-\n-    // No error; wrong return type.\n-    fn rem(self, other: T) {}\n-\n-    // Fine\n-    fn into_u32(self) -> u32 {\n-        0\n-    }\n-\n-    fn into_u16(&self) -> u16 {\n-        0\n-    }\n-\n-    fn to_something(self) -> u32 {\n-        0\n-    }\n-\n-    fn new(self) -> Self {\n-        unimplemented!();\n-    }\n-}\n-\n-pub struct T1;\n-\n-impl T1 {\n-    // Shouldn't trigger lint as it is unsafe.\n-    pub unsafe fn add(self, rhs: T1) -> T1 {\n-        self\n-    }\n-\n-    // Should not trigger lint since this is an async function.\n-    pub async fn next(&mut self) -> Option<T1> {\n-        None\n-    }\n-}\n-\n struct Lt<'a> {\n     foo: &'a u32,\n }\n@@ -171,6 +107,8 @@ impl BadNew {\n     }\n }\n \n+struct T;\n+\n impl Mul<T> for T {\n     type Output = T;\n     // No error, obviously."}, {"sha": "2a0a43e83a653089158ed99ac5e80d4d729ad8f7", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,15 +1,5 @@\n-error: defining a method called `add` on this type; consider implementing the `std::ops::Add` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:39:5\n-   |\n-LL | /     pub fn add(self, other: T) -> T {\n-LL | |         self\n-LL | |     }\n-   | |_____^\n-   |\n-   = note: `-D clippy::should-implement-trait` implied by `-D warnings`\n-\n error: methods called `new` usually return `Self`\n-  --> $DIR/methods.rs:169:5\n+  --> $DIR/methods.rs:105:5\n    |\n LL | /     fn new() -> i32 {\n LL | |         0\n@@ -19,7 +9,7 @@ LL | |     }\n    = note: `-D clippy::new-ret-no-self` implied by `-D warnings`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:188:13\n+  --> $DIR/methods.rs:126:13\n    |\n LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -28,7 +18,7 @@ LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    = note: replace `filter(|&x| *x < 0).next()` with `find(|&x| *x < 0)`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:191:13\n+  --> $DIR/methods.rs:129:13\n    |\n LL |       let _ = v.iter().filter(|&x| {\n    |  _____________^\n@@ -38,33 +28,33 @@ LL | |                    ).next();\n    | |___________________________^\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:208:22\n+  --> $DIR/methods.rs:146:22\n    |\n LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| *x < 0)`\n    |\n    = note: `-D clippy::search-is-some` implied by `-D warnings`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:209:20\n+  --> $DIR/methods.rs:147:20\n    |\n LL |     let _ = (0..1).find(|x| **y == *x).is_some(); // one dereference less\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| **y == x)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:210:20\n+  --> $DIR/methods.rs:148:20\n    |\n LL |     let _ = (0..1).find(|x| *x == 0).is_some();\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| x == 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:211:22\n+  --> $DIR/methods.rs:149:22\n    |\n LL |     let _ = v.iter().find(|x| **x == 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| *x == 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:214:13\n+  --> $DIR/methods.rs:152:13\n    |\n LL |       let _ = v.iter().find(|&x| {\n    |  _____________^\n@@ -74,13 +64,13 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:220:22\n+  --> $DIR/methods.rs:158:22\n    |\n LL |     let _ = v.iter().position(|&x| x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:223:13\n+  --> $DIR/methods.rs:161:13\n    |\n LL |       let _ = v.iter().position(|&x| {\n    |  _____________^\n@@ -90,13 +80,13 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:229:22\n+  --> $DIR/methods.rs:167:22\n    |\n LL |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:232:13\n+  --> $DIR/methods.rs:170:13\n    |\n LL |       let _ = v.iter().rposition(|&x| {\n    |  _____________^\n@@ -105,5 +95,5 @@ LL | |                                }\n LL | |                    ).is_some();\n    | |______________________________^\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 12 previous errors\n "}, {"sha": "062d30b262c1be2dc62988f12e535e70972afa7b", "filename": "tests/ui/mut_reference.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fmut_reference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fmut_reference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_reference.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,18 +1,18 @@\n-error: The function/method `takes_an_immutable_reference` doesn't need a mutable reference\n+error: the function `takes_an_immutable_reference` doesn't need a mutable reference\n   --> $DIR/mut_reference.rs:17:34\n    |\n LL |     takes_an_immutable_reference(&mut 42);\n    |                                  ^^^^^^^\n    |\n    = note: `-D clippy::unnecessary-mut-passed` implied by `-D warnings`\n \n-error: The function/method `as_ptr` doesn't need a mutable reference\n+error: the function `as_ptr` doesn't need a mutable reference\n   --> $DIR/mut_reference.rs:19:12\n    |\n LL |     as_ptr(&mut 42);\n    |            ^^^^^^^\n \n-error: The function/method `takes_an_immutable_reference` doesn't need a mutable reference\n+error: the method `takes_an_immutable_reference` doesn't need a mutable reference\n   --> $DIR/mut_reference.rs:23:44\n    |\n LL |     my_struct.takes_an_immutable_reference(&mut 42);"}, {"sha": "a3511ba708a885f808e6f4afd7d257149951c891", "filename": "tests/ui/mutex_atomic.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fmutex_atomic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fmutex_atomic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmutex_atomic.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,44 +1,44 @@\n-error: Consider using an `AtomicBool` instead of a `Mutex` here. If you just want the locking behavior and not the internal type, consider using `Mutex<()>`.\n+error: consider using an `AtomicBool` instead of a `Mutex` here; if you just want the locking behavior and not the internal type, consider using `Mutex<()>`\n   --> $DIR/mutex_atomic.rs:6:5\n    |\n LL |     Mutex::new(true);\n    |     ^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::mutex-atomic` implied by `-D warnings`\n \n-error: Consider using an `AtomicUsize` instead of a `Mutex` here. If you just want the locking behavior and not the internal type, consider using `Mutex<()>`.\n+error: consider using an `AtomicUsize` instead of a `Mutex` here; if you just want the locking behavior and not the internal type, consider using `Mutex<()>`\n   --> $DIR/mutex_atomic.rs:7:5\n    |\n LL |     Mutex::new(5usize);\n    |     ^^^^^^^^^^^^^^^^^^\n \n-error: Consider using an `AtomicIsize` instead of a `Mutex` here. If you just want the locking behavior and not the internal type, consider using `Mutex<()>`.\n+error: consider using an `AtomicIsize` instead of a `Mutex` here; if you just want the locking behavior and not the internal type, consider using `Mutex<()>`\n   --> $DIR/mutex_atomic.rs:8:5\n    |\n LL |     Mutex::new(9isize);\n    |     ^^^^^^^^^^^^^^^^^^\n \n-error: Consider using an `AtomicPtr` instead of a `Mutex` here. If you just want the locking behavior and not the internal type, consider using `Mutex<()>`.\n+error: consider using an `AtomicPtr` instead of a `Mutex` here; if you just want the locking behavior and not the internal type, consider using `Mutex<()>`\n   --> $DIR/mutex_atomic.rs:10:5\n    |\n LL |     Mutex::new(&x as *const u32);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: Consider using an `AtomicPtr` instead of a `Mutex` here. If you just want the locking behavior and not the internal type, consider using `Mutex<()>`.\n+error: consider using an `AtomicPtr` instead of a `Mutex` here; if you just want the locking behavior and not the internal type, consider using `Mutex<()>`\n   --> $DIR/mutex_atomic.rs:11:5\n    |\n LL |     Mutex::new(&mut x as *mut u32);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: Consider using an `AtomicUsize` instead of a `Mutex` here. If you just want the locking behavior and not the internal type, consider using `Mutex<()>`.\n+error: consider using an `AtomicUsize` instead of a `Mutex` here; if you just want the locking behavior and not the internal type, consider using `Mutex<()>`\n   --> $DIR/mutex_atomic.rs:12:5\n    |\n LL |     Mutex::new(0u32);\n    |     ^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::mutex-integer` implied by `-D warnings`\n \n-error: Consider using an `AtomicIsize` instead of a `Mutex` here. If you just want the locking behavior and not the internal type, consider using `Mutex<()>`.\n+error: consider using an `AtomicIsize` instead of a `Mutex` here; if you just want the locking behavior and not the internal type, consider using `Mutex<()>`\n   --> $DIR/mutex_atomic.rs:13:5\n    |\n LL |     Mutex::new(0i32);"}, {"sha": "883683e08a2aa83b4356d0a31bef4a7983cdf570", "filename": "tests/ui/needless_doc_main.rs", "status": "modified", "additions": 64, "deletions": 4, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fneedless_doc_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fneedless_doc_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_doc_main.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -9,16 +9,21 @@\n /// }\n /// ```\n ///\n-/// This should, too.\n+/// With an explicit return type it should lint too\n+/// ```\n+/// fn main() -> () {\n+///     unimplemented!();\n+/// }\n+/// ```\n ///\n+/// This should, too.\n /// ```rust\n /// fn main() {\n ///     unimplemented!();\n /// }\n /// ```\n ///\n /// This one too.\n-///\n /// ```no_run\n /// fn main() {\n ///     unimplemented!();\n@@ -33,6 +38,20 @@ fn bad_doctests() {}\n /// fn main(){}\n /// ```\n ///\n+/// This shouldn't lint either, because main is async:\n+/// ```\n+/// async fn main() {\n+///     assert_eq!(42, ANSWER);\n+/// }\n+/// ```\n+///\n+/// Same here, because the return type is not the unit type:\n+/// ```\n+/// fn main() -> Result<()> {\n+///     Ok(())\n+/// }\n+/// ```\n+///\n /// This shouldn't lint either, because there's a `static`:\n /// ```\n /// static ANSWER: i32 = 42;\n@@ -42,6 +61,15 @@ fn bad_doctests() {}\n /// }\n /// ```\n ///\n+/// This shouldn't lint either, because there's a `const`:\n+/// ```\n+/// fn main() {\n+///     assert_eq!(42, ANSWER);\n+/// }\n+///\n+/// const ANSWER: i32 = 42;\n+/// ```\n+///\n /// Neither should this lint because of `extern crate`:\n /// ```\n /// #![feature(test)]\n@@ -51,16 +79,48 @@ fn bad_doctests() {}\n /// }\n /// ```\n ///\n-/// We should not lint ignored examples:\n+/// Neither should this lint because it has an extern block:\n+/// ```\n+/// extern {}\n+/// fn main() {\n+///     unimplemented!();\n+/// }\n+/// ```\n+///\n+/// This should not lint because there is another function defined:\n+/// ```\n+/// fn fun() {}\n+///\n+/// fn main() {\n+///     unimplemented!();\n+/// }\n+/// ```\n ///\n+/// We should not lint inside raw strings ...\n+/// ```\n+/// let string = r#\"\n+/// fn main() {\n+///     unimplemented!();\n+/// }\n+/// \"#;\n+/// ```\n+///\n+/// ... or comments\n+/// ```\n+/// // fn main() {\n+/// //     let _inception = 42;\n+/// // }\n+/// let _inception = 42;\n+/// ```\n+///\n+/// We should not lint ignored examples:\n /// ```rust,ignore\n /// fn main() {\n ///     unimplemented!();\n /// }\n /// ```\n ///\n /// Or even non-rust examples:\n-///\n /// ```text\n /// fn main() {\n ///     is what starts the program"}, {"sha": "05c7f9d33a7924f3d1ea642b0ad665f7edbf06d7", "filename": "tests/ui/needless_doc_main.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fneedless_doc_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fneedless_doc_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_doc_main.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -7,16 +7,22 @@ LL | /// fn main() {\n    = note: `-D clippy::needless-doctest-main` implied by `-D warnings`\n \n error: needless `fn main` in doctest\n-  --> $DIR/needless_doc_main.rs:15:4\n+  --> $DIR/needless_doc_main.rs:14:4\n+   |\n+LL | /// fn main() -> () {\n+   |    ^^^^^^^^^^^^^^^^^^\n+\n+error: needless `fn main` in doctest\n+  --> $DIR/needless_doc_main.rs:21:4\n    |\n LL | /// fn main() {\n    |    ^^^^^^^^^^^^\n \n error: needless `fn main` in doctest\n-  --> $DIR/needless_doc_main.rs:23:4\n+  --> $DIR/needless_doc_main.rs:28:4\n    |\n LL | /// fn main() {\n    |    ^^^^^^^^^^^^\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n "}, {"sha": "d849e093da7bb821a765122d0d966ba78adf4a39", "filename": "tests/ui/needless_return.fixed", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fneedless_return.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fneedless_return.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.fixed?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -69,6 +69,23 @@ fn test_void_match(x: u32) {\n     }\n }\n \n+fn read_line() -> String {\n+    use std::io::BufRead;\n+    let stdin = ::std::io::stdin();\n+    return stdin.lock().lines().next().unwrap().unwrap();\n+}\n+\n+fn borrows_but_not_last(value: bool) -> String {\n+    if value {\n+        use std::io::BufRead;\n+        let stdin = ::std::io::stdin();\n+        let _a = stdin.lock().lines().next().unwrap().unwrap();\n+        String::from(\"test\")\n+    } else {\n+        String::new()\n+    }\n+}\n+\n fn main() {\n     let _ = test_end_of_fn();\n     let _ = test_no_semicolon();"}, {"sha": "29f2bd1852af00e9f1df68916f1f7624046e4c93", "filename": "tests/ui/needless_return.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fneedless_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fneedless_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -69,6 +69,23 @@ fn test_void_match(x: u32) {\n     }\n }\n \n+fn read_line() -> String {\n+    use std::io::BufRead;\n+    let stdin = ::std::io::stdin();\n+    return stdin.lock().lines().next().unwrap().unwrap();\n+}\n+\n+fn borrows_but_not_last(value: bool) -> String {\n+    if value {\n+        use std::io::BufRead;\n+        let stdin = ::std::io::stdin();\n+        let _a = stdin.lock().lines().next().unwrap().unwrap();\n+        return String::from(\"test\");\n+    } else {\n+        return String::new();\n+    }\n+}\n+\n fn main() {\n     let _ = test_end_of_fn();\n     let _ = test_no_semicolon();"}, {"sha": "f73c833a801f3dc143bb92545a5e7ad41b566916", "filename": "tests/ui/needless_return.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fneedless_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fneedless_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -72,5 +72,17 @@ error: unneeded `return` statement\n LL |         _ => return,\n    |              ^^^^^^ help: replace `return` with an empty block: `{}`\n \n-error: aborting due to 12 previous errors\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:83:9\n+   |\n+LL |         return String::from(\"test\");\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `String::from(\"test\")`\n+\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:85:9\n+   |\n+LL |         return String::new();\n+   |         ^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `String::new()`\n+\n+error: aborting due to 14 previous errors\n "}, {"sha": "6514fd6d1ac76bbe7ebbbd37453af5002e3c3308", "filename": "tests/ui/redundant_allocation.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fredundant_allocation.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fredundant_allocation.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_allocation.fixed?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -33,7 +33,7 @@ pub fn test5(a: Rc<bool>) {}\n \n // Rc<Box<T>>\n \n-pub fn test6(a: Box<bool>) {}\n+pub fn test6(a: Rc<bool>) {}\n \n // Box<&T>\n "}, {"sha": "92e4f67f5db6e40e6f2f0f9bd8ed422b3ec32c0c", "filename": "tests/ui/redundant_allocation.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fredundant_allocation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fredundant_allocation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_allocation.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -28,7 +28,7 @@ error: usage of `Rc<Box<T>>`\n   --> $DIR/redundant_allocation.rs:36:17\n    |\n LL | pub fn test6(a: Rc<Box<bool>>) {}\n-   |                 ^^^^^^^^^^^^^ help: try: `Box<bool>`\n+   |                 ^^^^^^^^^^^^^ help: try: `Rc<bool>`\n \n error: usage of `Box<&T>`\n   --> $DIR/redundant_allocation.rs:40:22"}, {"sha": "bfe27e020445c77b83c4ddfb14f773eb4ee36b85", "filename": "tests/ui/same_item_push.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsame_item_push.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -86,4 +86,12 @@ fn main() {\n     for a in vec_a {\n         vec12.push(2u8.pow(a.kind));\n     }\n+\n+    // Fix #5902\n+    let mut vec13: Vec<u8> = Vec::new();\n+    let mut item = 0;\n+    for _ in 0..10 {\n+        vec13.push(item);\n+        item += 10;\n+    }\n }"}, {"sha": "a7cbb9cd78b151cb82b9f415c59a170be1541e2e", "filename": "tests/ui/self_assignment.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fself_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fself_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fself_assignment.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -0,0 +1,67 @@\n+#![warn(clippy::self_assignment)]\n+\n+pub struct S<'a> {\n+    a: i32,\n+    b: [i32; 10],\n+    c: Vec<Vec<i32>>,\n+    e: &'a mut i32,\n+    f: &'a mut i32,\n+}\n+\n+pub fn positives(mut a: usize, b: &mut u32, mut s: S) {\n+    a = a;\n+    *b = *b;\n+    s = s;\n+    s.a = s.a;\n+    s.b[10] = s.b[5 + 5];\n+    s.c[0][1] = s.c[0][1];\n+    s.b[a] = s.b[a];\n+    *s.e = *s.e;\n+    s.b[a + 10] = s.b[10 + a];\n+\n+    let mut t = (0, 1);\n+    t.1 = t.1;\n+    t.0 = (t.0);\n+}\n+\n+pub fn negatives_not_equal(mut a: usize, b: &mut usize, mut s: S) {\n+    dbg!(&a);\n+    a = *b;\n+    dbg!(&a);\n+    s.b[1] += s.b[1];\n+    s.b[1] = s.b[2];\n+    s.c[1][0] = s.c[0][1];\n+    s.b[a] = s.b[*b];\n+    s.b[a + 10] = s.b[a + 11];\n+    *s.e = *s.f;\n+\n+    let mut t = (0, 1);\n+    t.0 = t.1;\n+}\n+\n+#[allow(clippy::eval_order_dependence)]\n+pub fn negatives_side_effects() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let mut i = 0;\n+    v[{\n+        i += 1;\n+        i\n+    }] = v[{\n+        i += 1;\n+        i\n+    }];\n+\n+    fn next(n: &mut usize) -> usize {\n+        let v = *n;\n+        *n += 1;\n+        v\n+    }\n+\n+    let mut w = vec![1, 2, 3, 4, 5];\n+    let mut i = 0;\n+    let i = &mut i;\n+    w[next(i)] = w[next(i)];\n+    w[next(i)] = w[next(i)];\n+}\n+\n+fn main() {}"}, {"sha": "826e0d0ba888dacda4a21b006fed23157c67f22f", "filename": "tests/ui/self_assignment.stderr", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fself_assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fself_assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fself_assignment.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -0,0 +1,70 @@\n+error: self-assignment of `a` to `a`\n+  --> $DIR/self_assignment.rs:12:5\n+   |\n+LL |     a = a;\n+   |     ^^^^^\n+   |\n+   = note: `-D clippy::self-assignment` implied by `-D warnings`\n+\n+error: self-assignment of `*b` to `*b`\n+  --> $DIR/self_assignment.rs:13:5\n+   |\n+LL |     *b = *b;\n+   |     ^^^^^^^\n+\n+error: self-assignment of `s` to `s`\n+  --> $DIR/self_assignment.rs:14:5\n+   |\n+LL |     s = s;\n+   |     ^^^^^\n+\n+error: self-assignment of `s.a` to `s.a`\n+  --> $DIR/self_assignment.rs:15:5\n+   |\n+LL |     s.a = s.a;\n+   |     ^^^^^^^^^\n+\n+error: self-assignment of `s.b[5 + 5]` to `s.b[10]`\n+  --> $DIR/self_assignment.rs:16:5\n+   |\n+LL |     s.b[10] = s.b[5 + 5];\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: self-assignment of `s.c[0][1]` to `s.c[0][1]`\n+  --> $DIR/self_assignment.rs:17:5\n+   |\n+LL |     s.c[0][1] = s.c[0][1];\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: self-assignment of `s.b[a]` to `s.b[a]`\n+  --> $DIR/self_assignment.rs:18:5\n+   |\n+LL |     s.b[a] = s.b[a];\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: self-assignment of `*s.e` to `*s.e`\n+  --> $DIR/self_assignment.rs:19:5\n+   |\n+LL |     *s.e = *s.e;\n+   |     ^^^^^^^^^^^\n+\n+error: self-assignment of `s.b[10 + a]` to `s.b[a + 10]`\n+  --> $DIR/self_assignment.rs:20:5\n+   |\n+LL |     s.b[a + 10] = s.b[10 + a];\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: self-assignment of `t.1` to `t.1`\n+  --> $DIR/self_assignment.rs:23:5\n+   |\n+LL |     t.1 = t.1;\n+   |     ^^^^^^^^^\n+\n+error: self-assignment of `(t.0)` to `t.0`\n+  --> $DIR/self_assignment.rs:24:5\n+   |\n+LL |     t.0 = (t.0);\n+   |     ^^^^^^^^^^^\n+\n+error: aborting due to 11 previous errors\n+"}, {"sha": "6c5ffe6aba8b7b7c1e4923c957617f6df31ffc64", "filename": "tests/ui/should_impl_trait/corner_cases.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fshould_impl_trait%2Fcorner_cases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fshould_impl_trait%2Fcorner_cases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshould_impl_trait%2Fcorner_cases.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -0,0 +1,83 @@\n+// edition:2018\n+\n+#![warn(clippy::all, clippy::pedantic)]\n+#![allow(\n+    clippy::missing_errors_doc,\n+    clippy::needless_pass_by_value,\n+    clippy::must_use_candidate,\n+    clippy::unused_self,\n+    clippy::needless_lifetimes,\n+    clippy::missing_safety_doc,\n+    clippy::wrong_self_convention\n+)]\n+\n+use std::ops::Mul;\n+use std::rc::{self, Rc};\n+use std::sync::{self, Arc};\n+\n+fn main() {}\n+\n+pub struct T1;\n+impl T1 {\n+    // corner cases: should not lint\n+\n+    // no error, not public interface\n+    pub(crate) fn drop(&mut self) {}\n+\n+    // no error, private function\n+    fn neg(self) -> Self {\n+        self\n+    }\n+\n+    // no error, private function\n+    fn eq(&self, other: Self) -> bool {\n+        true\n+    }\n+\n+    // No error; self is a ref.\n+    fn sub(&self, other: Self) -> &Self {\n+        self\n+    }\n+\n+    // No error; different number of arguments.\n+    fn div(self) -> Self {\n+        self\n+    }\n+\n+    // No error; wrong return type.\n+    fn rem(self, other: Self) {}\n+\n+    // Fine\n+    fn into_u32(self) -> u32 {\n+        0\n+    }\n+\n+    fn into_u16(&self) -> u16 {\n+        0\n+    }\n+\n+    fn to_something(self) -> u32 {\n+        0\n+    }\n+\n+    fn new(self) -> Self {\n+        unimplemented!();\n+    }\n+\n+    pub fn next<'b>(&'b mut self) -> Option<&'b mut T1> {\n+        unimplemented!();\n+    }\n+}\n+\n+pub struct T2;\n+impl T2 {\n+    // Shouldn't trigger lint as it is unsafe.\n+    pub unsafe fn add(self, rhs: Self) -> Self {\n+        self\n+    }\n+\n+    // Should not trigger lint since this is an async function.\n+    pub async fn next(&mut self) -> Option<Self> {\n+        None\n+    }\n+}"}, {"sha": "f8d248fc98d82a2db4ac7ae5d106bfe10d7fe782", "filename": "tests/ui/should_impl_trait/method_list_1.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -0,0 +1,87 @@\n+// edition:2018\n+\n+#![warn(clippy::all, clippy::pedantic)]\n+#![allow(\n+    clippy::missing_errors_doc,\n+    clippy::needless_pass_by_value,\n+    clippy::must_use_candidate,\n+    clippy::unused_self,\n+    clippy::needless_lifetimes,\n+    clippy::missing_safety_doc,\n+    clippy::wrong_self_convention\n+)]\n+\n+use std::ops::Mul;\n+use std::rc::{self, Rc};\n+use std::sync::{self, Arc};\n+\n+fn main() {}\n+pub struct T;\n+\n+impl T {\n+    // *****************************************\n+    // trait method list part 1, should lint all\n+    // *****************************************\n+    pub fn add(self, other: T) -> T {\n+        unimplemented!()\n+    }\n+\n+    pub fn as_mut(&mut self) -> &mut T {\n+        unimplemented!()\n+    }\n+\n+    pub fn as_ref(&self) -> &T {\n+        unimplemented!()\n+    }\n+\n+    pub fn bitand(self, rhs: T) -> T {\n+        unimplemented!()\n+    }\n+\n+    pub fn bitor(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn bitxor(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn borrow(&self) -> &str {\n+        unimplemented!()\n+    }\n+\n+    pub fn borrow_mut(&mut self) -> &mut str {\n+        unimplemented!()\n+    }\n+\n+    pub fn clone(&self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn cmp(&self, other: &Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn default() -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn deref(&self) -> &Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn deref_mut(&mut self) -> &mut Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn div(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn drop(&mut self) {\n+        unimplemented!()\n+    }\n+    // **********\n+    // part 1 end\n+    // **********\n+}"}, {"sha": "2b7d4628c3fa02b703e9a58cb98b73d4a1dd6489", "filename": "tests/ui/should_impl_trait/method_list_1.stderr", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -0,0 +1,143 @@\n+error: method `add` can be confused for the standard trait method `std::ops::Add::add`\n+  --> $DIR/method_list_1.rs:25:5\n+   |\n+LL | /     pub fn add(self, other: T) -> T {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::should-implement-trait` implied by `-D warnings`\n+   = help: consider implementing the trait `std::ops::Add` or choosing a less ambiguous method name\n+\n+error: method `as_mut` can be confused for the standard trait method `std::convert::AsMut::as_mut`\n+  --> $DIR/method_list_1.rs:29:5\n+   |\n+LL | /     pub fn as_mut(&mut self) -> &mut T {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::convert::AsMut` or choosing a less ambiguous method name\n+\n+error: method `as_ref` can be confused for the standard trait method `std::convert::AsRef::as_ref`\n+  --> $DIR/method_list_1.rs:33:5\n+   |\n+LL | /     pub fn as_ref(&self) -> &T {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::convert::AsRef` or choosing a less ambiguous method name\n+\n+error: method `bitand` can be confused for the standard trait method `std::ops::BitAnd::bitand`\n+  --> $DIR/method_list_1.rs:37:5\n+   |\n+LL | /     pub fn bitand(self, rhs: T) -> T {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::BitAnd` or choosing a less ambiguous method name\n+\n+error: method `bitor` can be confused for the standard trait method `std::ops::BitOr::bitor`\n+  --> $DIR/method_list_1.rs:41:5\n+   |\n+LL | /     pub fn bitor(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::BitOr` or choosing a less ambiguous method name\n+\n+error: method `bitxor` can be confused for the standard trait method `std::ops::BitXor::bitxor`\n+  --> $DIR/method_list_1.rs:45:5\n+   |\n+LL | /     pub fn bitxor(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::BitXor` or choosing a less ambiguous method name\n+\n+error: method `borrow` can be confused for the standard trait method `std::borrow::Borrow::borrow`\n+  --> $DIR/method_list_1.rs:49:5\n+   |\n+LL | /     pub fn borrow(&self) -> &str {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::borrow::Borrow` or choosing a less ambiguous method name\n+\n+error: method `borrow_mut` can be confused for the standard trait method `std::borrow::BorrowMut::borrow_mut`\n+  --> $DIR/method_list_1.rs:53:5\n+   |\n+LL | /     pub fn borrow_mut(&mut self) -> &mut str {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::borrow::BorrowMut` or choosing a less ambiguous method name\n+\n+error: method `clone` can be confused for the standard trait method `std::clone::Clone::clone`\n+  --> $DIR/method_list_1.rs:57:5\n+   |\n+LL | /     pub fn clone(&self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::clone::Clone` or choosing a less ambiguous method name\n+\n+error: method `cmp` can be confused for the standard trait method `std::cmp::Ord::cmp`\n+  --> $DIR/method_list_1.rs:61:5\n+   |\n+LL | /     pub fn cmp(&self, other: &Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::cmp::Ord` or choosing a less ambiguous method name\n+\n+error: method `deref` can be confused for the standard trait method `std::ops::Deref::deref`\n+  --> $DIR/method_list_1.rs:69:5\n+   |\n+LL | /     pub fn deref(&self) -> &Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Deref` or choosing a less ambiguous method name\n+\n+error: method `deref_mut` can be confused for the standard trait method `std::ops::DerefMut::deref_mut`\n+  --> $DIR/method_list_1.rs:73:5\n+   |\n+LL | /     pub fn deref_mut(&mut self) -> &mut Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::DerefMut` or choosing a less ambiguous method name\n+\n+error: method `div` can be confused for the standard trait method `std::ops::Div::div`\n+  --> $DIR/method_list_1.rs:77:5\n+   |\n+LL | /     pub fn div(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Div` or choosing a less ambiguous method name\n+\n+error: method `drop` can be confused for the standard trait method `std::ops::Drop::drop`\n+  --> $DIR/method_list_1.rs:81:5\n+   |\n+LL | /     pub fn drop(&mut self) {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Drop` or choosing a less ambiguous method name\n+\n+error: aborting due to 14 previous errors\n+"}, {"sha": "ed5e0d384bf5040c0d90135bc6cd65ab5832306d", "filename": "tests/ui/should_impl_trait/method_list_2.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -0,0 +1,88 @@\n+// edition:2018\n+\n+#![warn(clippy::all, clippy::pedantic)]\n+#![allow(\n+    clippy::missing_errors_doc,\n+    clippy::needless_pass_by_value,\n+    clippy::must_use_candidate,\n+    clippy::unused_self,\n+    clippy::needless_lifetimes,\n+    clippy::missing_safety_doc,\n+    clippy::wrong_self_convention\n+)]\n+\n+use std::ops::Mul;\n+use std::rc::{self, Rc};\n+use std::sync::{self, Arc};\n+\n+fn main() {}\n+pub struct T;\n+\n+impl T {\n+    // *****************************************\n+    // trait method list part 2, should lint all\n+    // *****************************************\n+\n+    pub fn eq(&self, other: &Self) -> bool {\n+        unimplemented!()\n+    }\n+\n+    pub fn from_iter<T>(iter: T) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn from_str(s: &str) -> Result<Self, Self> {\n+        unimplemented!()\n+    }\n+\n+    pub fn hash(&self, state: &mut T) {\n+        unimplemented!()\n+    }\n+\n+    pub fn index(&self, index: usize) -> &Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn index_mut(&mut self, index: usize) -> &mut Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn into_iter(self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn mul(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn neg(self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn next(&mut self) -> Option<Self> {\n+        unimplemented!()\n+    }\n+\n+    pub fn not(self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn rem(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn shl(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn shr(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn sub(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+    // **********\n+    // part 2 end\n+    // **********\n+}"}, {"sha": "b6fd435695698e6ca47adee8a423824472e6b14d", "filename": "tests/ui/should_impl_trait/method_list_2.stderr", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -0,0 +1,153 @@\n+error: method `eq` can be confused for the standard trait method `std::cmp::PartialEq::eq`\n+  --> $DIR/method_list_2.rs:26:5\n+   |\n+LL | /     pub fn eq(&self, other: &Self) -> bool {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::should-implement-trait` implied by `-D warnings`\n+   = help: consider implementing the trait `std::cmp::PartialEq` or choosing a less ambiguous method name\n+\n+error: method `from_iter` can be confused for the standard trait method `std::iter::FromIterator::from_iter`\n+  --> $DIR/method_list_2.rs:30:5\n+   |\n+LL | /     pub fn from_iter<T>(iter: T) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::iter::FromIterator` or choosing a less ambiguous method name\n+\n+error: method `from_str` can be confused for the standard trait method `std::str::FromStr::from_str`\n+  --> $DIR/method_list_2.rs:34:5\n+   |\n+LL | /     pub fn from_str(s: &str) -> Result<Self, Self> {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::str::FromStr` or choosing a less ambiguous method name\n+\n+error: method `hash` can be confused for the standard trait method `std::hash::Hash::hash`\n+  --> $DIR/method_list_2.rs:38:5\n+   |\n+LL | /     pub fn hash(&self, state: &mut T) {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::hash::Hash` or choosing a less ambiguous method name\n+\n+error: method `index` can be confused for the standard trait method `std::ops::Index::index`\n+  --> $DIR/method_list_2.rs:42:5\n+   |\n+LL | /     pub fn index(&self, index: usize) -> &Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Index` or choosing a less ambiguous method name\n+\n+error: method `index_mut` can be confused for the standard trait method `std::ops::IndexMut::index_mut`\n+  --> $DIR/method_list_2.rs:46:5\n+   |\n+LL | /     pub fn index_mut(&mut self, index: usize) -> &mut Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::IndexMut` or choosing a less ambiguous method name\n+\n+error: method `into_iter` can be confused for the standard trait method `std::iter::IntoIterator::into_iter`\n+  --> $DIR/method_list_2.rs:50:5\n+   |\n+LL | /     pub fn into_iter(self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::iter::IntoIterator` or choosing a less ambiguous method name\n+\n+error: method `mul` can be confused for the standard trait method `std::ops::Mul::mul`\n+  --> $DIR/method_list_2.rs:54:5\n+   |\n+LL | /     pub fn mul(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Mul` or choosing a less ambiguous method name\n+\n+error: method `neg` can be confused for the standard trait method `std::ops::Neg::neg`\n+  --> $DIR/method_list_2.rs:58:5\n+   |\n+LL | /     pub fn neg(self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Neg` or choosing a less ambiguous method name\n+\n+error: method `next` can be confused for the standard trait method `std::iter::Iterator::next`\n+  --> $DIR/method_list_2.rs:62:5\n+   |\n+LL | /     pub fn next(&mut self) -> Option<Self> {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::iter::Iterator` or choosing a less ambiguous method name\n+\n+error: method `not` can be confused for the standard trait method `std::ops::Not::not`\n+  --> $DIR/method_list_2.rs:66:5\n+   |\n+LL | /     pub fn not(self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Not` or choosing a less ambiguous method name\n+\n+error: method `rem` can be confused for the standard trait method `std::ops::Rem::rem`\n+  --> $DIR/method_list_2.rs:70:5\n+   |\n+LL | /     pub fn rem(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Rem` or choosing a less ambiguous method name\n+\n+error: method `shl` can be confused for the standard trait method `std::ops::Shl::shl`\n+  --> $DIR/method_list_2.rs:74:5\n+   |\n+LL | /     pub fn shl(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Shl` or choosing a less ambiguous method name\n+\n+error: method `shr` can be confused for the standard trait method `std::ops::Shr::shr`\n+  --> $DIR/method_list_2.rs:78:5\n+   |\n+LL | /     pub fn shr(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Shr` or choosing a less ambiguous method name\n+\n+error: method `sub` can be confused for the standard trait method `std::ops::Sub::sub`\n+  --> $DIR/method_list_2.rs:82:5\n+   |\n+LL | /     pub fn sub(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Sub` or choosing a less ambiguous method name\n+\n+error: aborting due to 15 previous errors\n+"}, {"sha": "0812c026a644fbdd84f05569edc5cf954a8a109f", "filename": "tests/ui/single_char_push_str.fixed", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fsingle_char_push_str.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fsingle_char_push_str.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_char_push_str.fixed?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+#![warn(clippy::single_char_push_str)]\n+\n+fn main() {\n+    let mut string = String::new();\n+    string.push('R');\n+    string.push('\\'');\n+\n+    string.push('u');\n+    string.push_str(\"st\");\n+    string.push_str(\"\");\n+    string.push('\\x52');\n+    string.push('\\u{0052}');\n+    string.push('a');\n+}"}, {"sha": "ab293bbe4eeb5ce8171ec28f610410a45f2d5cb8", "filename": "tests/ui/single_char_push_str.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fsingle_char_push_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fsingle_char_push_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_char_push_str.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+#![warn(clippy::single_char_push_str)]\n+\n+fn main() {\n+    let mut string = String::new();\n+    string.push_str(\"R\");\n+    string.push_str(\"'\");\n+\n+    string.push('u');\n+    string.push_str(\"st\");\n+    string.push_str(\"\");\n+    string.push_str(\"\\x52\");\n+    string.push_str(\"\\u{0052}\");\n+    string.push_str(r##\"a\"##);\n+}"}, {"sha": "0e9bdaa23e7e8474accd8321884cc0861db8405c", "filename": "tests/ui/single_char_push_str.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fsingle_char_push_str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fsingle_char_push_str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_char_push_str.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -0,0 +1,34 @@\n+error: calling `push_str()` using a single-character string literal\n+  --> $DIR/single_char_push_str.rs:6:5\n+   |\n+LL |     string.push_str(\"R\");\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using `push` with a character literal: `string.push('R')`\n+   |\n+   = note: `-D clippy::single-char-push-str` implied by `-D warnings`\n+\n+error: calling `push_str()` using a single-character string literal\n+  --> $DIR/single_char_push_str.rs:7:5\n+   |\n+LL |     string.push_str(\"'\");\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using `push` with a character literal: `string.push('/'')`\n+\n+error: calling `push_str()` using a single-character string literal\n+  --> $DIR/single_char_push_str.rs:12:5\n+   |\n+LL |     string.push_str(\"/x52\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `push` with a character literal: `string.push('/x52')`\n+\n+error: calling `push_str()` using a single-character string literal\n+  --> $DIR/single_char_push_str.rs:13:5\n+   |\n+LL |     string.push_str(\"/u{0052}\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `push` with a character literal: `string.push('/u{0052}')`\n+\n+error: calling `push_str()` using a single-character string literal\n+  --> $DIR/single_char_push_str.rs:14:5\n+   |\n+LL |     string.push_str(r##\"a\"##);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `push` with a character literal: `string.push('a')`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "b73012a4691b65ffc31a183fd70bf89a3defda81", "filename": "tests/ui/stable_sort_primitive.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fstable_sort_primitive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fstable_sort_primitive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstable_sort_primitive.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,42 +1,42 @@\n-error: Use sort_unstable instead of sort\n+error: used sort instead of sort_unstable\n   --> $DIR/stable_sort_primitive.rs:7:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n    |\n    = note: `-D clippy::stable-sort-primitive` implied by `-D warnings`\n \n-error: Use sort_unstable instead of sort\n+error: used sort instead of sort_unstable\n   --> $DIR/stable_sort_primitive.rs:9:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n \n-error: Use sort_unstable instead of sort\n+error: used sort instead of sort_unstable\n   --> $DIR/stable_sort_primitive.rs:11:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n \n-error: Use sort_unstable instead of sort\n+error: used sort instead of sort_unstable\n   --> $DIR/stable_sort_primitive.rs:13:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n \n-error: Use sort_unstable instead of sort\n+error: used sort instead of sort_unstable\n   --> $DIR/stable_sort_primitive.rs:15:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n \n-error: Use sort_unstable instead of sort\n+error: used sort instead of sort_unstable\n   --> $DIR/stable_sort_primitive.rs:17:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n \n-error: Use sort_unstable instead of sort\n+error: used sort instead of sort_unstable\n   --> $DIR/stable_sort_primitive.rs:19:5\n    |\n LL |     arr.sort();"}, {"sha": "5c280efac1a876dbb849b7c81940b6d3db1b48ad", "filename": "tests/ui/suspicious_arithmetic_impl.rs", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fsuspicious_arithmetic_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fsuspicious_arithmetic_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_arithmetic_impl.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,5 +1,7 @@\n #![warn(clippy::suspicious_arithmetic_impl)]\n-use std::ops::{Add, AddAssign, BitOrAssign, Div, DivAssign, Mul, MulAssign, Sub};\n+use std::ops::{\n+    Add, AddAssign, BitAnd, BitOr, BitOrAssign, BitXor, Div, DivAssign, Mul, MulAssign, Rem, Shl, Shr, Sub,\n+};\n \n #[derive(Copy, Clone)]\n struct Foo(u32);\n@@ -61,6 +63,54 @@ impl Div for Foo {\n     }\n }\n \n+impl Rem for Foo {\n+    type Output = Foo;\n+\n+    fn rem(self, other: Self) -> Self {\n+        Foo(self.0 / other.0)\n+    }\n+}\n+\n+impl BitAnd for Foo {\n+    type Output = Foo;\n+\n+    fn bitand(self, other: Self) -> Self {\n+        Foo(self.0 | other.0)\n+    }\n+}\n+\n+impl BitOr for Foo {\n+    type Output = Foo;\n+\n+    fn bitor(self, other: Self) -> Self {\n+        Foo(self.0 ^ other.0)\n+    }\n+}\n+\n+impl BitXor for Foo {\n+    type Output = Foo;\n+\n+    fn bitxor(self, other: Self) -> Self {\n+        Foo(self.0 & other.0)\n+    }\n+}\n+\n+impl Shl for Foo {\n+    type Output = Foo;\n+\n+    fn shl(self, other: Self) -> Self {\n+        Foo(self.0 >> other.0)\n+    }\n+}\n+\n+impl Shr for Foo {\n+    type Output = Foo;\n+\n+    fn shr(self, other: Self) -> Self {\n+        Foo(self.0 << other.0)\n+    }\n+}\n+\n struct Bar(i32);\n \n impl Add for Bar {"}, {"sha": "388fc7400820947ab912c088099d94e20391995d", "filename": "tests/ui/suspicious_arithmetic_impl.stderr", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fsuspicious_arithmetic_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fsuspicious_arithmetic_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_arithmetic_impl.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -1,24 +1,60 @@\n error: suspicious use of binary operator in `Add` impl\n-  --> $DIR/suspicious_arithmetic_impl.rs:11:20\n+  --> $DIR/suspicious_arithmetic_impl.rs:13:20\n    |\n LL |         Foo(self.0 - other.0)\n    |                    ^\n    |\n    = note: `-D clippy::suspicious-arithmetic-impl` implied by `-D warnings`\n \n error: suspicious use of binary operator in `AddAssign` impl\n-  --> $DIR/suspicious_arithmetic_impl.rs:17:23\n+  --> $DIR/suspicious_arithmetic_impl.rs:19:23\n    |\n LL |         *self = *self - other;\n    |                       ^\n    |\n    = note: `#[deny(clippy::suspicious_op_assign_impl)]` on by default\n \n error: suspicious use of binary operator in `MulAssign` impl\n-  --> $DIR/suspicious_arithmetic_impl.rs:30:16\n+  --> $DIR/suspicious_arithmetic_impl.rs:32:16\n    |\n LL |         self.0 /= other.0;\n    |                ^^\n \n-error: aborting due to 3 previous errors\n+error: suspicious use of binary operator in `Rem` impl\n+  --> $DIR/suspicious_arithmetic_impl.rs:70:20\n+   |\n+LL |         Foo(self.0 / other.0)\n+   |                    ^\n+\n+error: suspicious use of binary operator in `BitAnd` impl\n+  --> $DIR/suspicious_arithmetic_impl.rs:78:20\n+   |\n+LL |         Foo(self.0 | other.0)\n+   |                    ^\n+\n+error: suspicious use of binary operator in `BitOr` impl\n+  --> $DIR/suspicious_arithmetic_impl.rs:86:20\n+   |\n+LL |         Foo(self.0 ^ other.0)\n+   |                    ^\n+\n+error: suspicious use of binary operator in `BitXor` impl\n+  --> $DIR/suspicious_arithmetic_impl.rs:94:20\n+   |\n+LL |         Foo(self.0 & other.0)\n+   |                    ^\n+\n+error: suspicious use of binary operator in `Shl` impl\n+  --> $DIR/suspicious_arithmetic_impl.rs:102:20\n+   |\n+LL |         Foo(self.0 >> other.0)\n+   |                    ^^\n+\n+error: suspicious use of binary operator in `Shr` impl\n+  --> $DIR/suspicious_arithmetic_impl.rs:110:20\n+   |\n+LL |         Foo(self.0 << other.0)\n+   |                    ^^\n+\n+error: aborting due to 9 previous errors\n "}, {"sha": "3b46324704e1c1dd23b1c201632d349e090884d2", "filename": "tests/ui/to_string_in_display.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fto_string_in_display.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -0,0 +1,55 @@\n+#![warn(clippy::to_string_in_display)]\n+#![allow(clippy::inherent_to_string_shadow_display)]\n+\n+use std::fmt;\n+\n+struct A;\n+impl A {\n+    fn fmt(&self) {\n+        self.to_string();\n+    }\n+}\n+\n+trait B {\n+    fn fmt(&self) {}\n+}\n+\n+impl B for A {\n+    fn fmt(&self) {\n+        self.to_string();\n+    }\n+}\n+\n+impl fmt::Display for A {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.to_string())\n+    }\n+}\n+\n+fn fmt(a: A) {\n+    a.to_string();\n+}\n+\n+struct C;\n+\n+impl C {\n+    fn to_string(&self) -> String {\n+        String::from(\"I am C\")\n+    }\n+}\n+\n+impl fmt::Display for C {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.to_string())\n+    }\n+}\n+\n+fn main() {\n+    let a = A;\n+    a.to_string();\n+    a.fmt();\n+    fmt(a);\n+\n+    let c = C;\n+    c.to_string();\n+}"}, {"sha": "cbc0a41036be3b7975da2ed321c80595b627243c", "filename": "tests/ui/to_string_in_display.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fto_string_in_display.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fto_string_in_display.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fto_string_in_display.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -0,0 +1,10 @@\n+error: Using to_string in fmt::Display implementation might lead to infinite recursion\n+  --> $DIR/to_string_in_display.rs:25:25\n+   |\n+LL |         write!(f, \"{}\", self.to_string())\n+   |                         ^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::to-string-in-display` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "fa66e68794e4be0d6b1ac082c2c9b2044b0e36bb", "filename": "tests/ui/unnecessary_lazy_eval.fixed", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Funnecessary_lazy_eval.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Funnecessary_lazy_eval.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_lazy_eval.fixed?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -0,0 +1,117 @@\n+// run-rustfix\n+#![warn(clippy::unnecessary_lazy_evaluations)]\n+#![allow(clippy::redundant_closure)]\n+#![allow(clippy::bind_instead_of_map)]\n+\n+struct Deep(Option<usize>);\n+\n+#[derive(Copy, Clone)]\n+struct SomeStruct {\n+    some_field: usize,\n+}\n+\n+impl SomeStruct {\n+    fn return_some_field(&self) -> usize {\n+        self.some_field\n+    }\n+}\n+\n+fn some_call<T: Default>() -> T {\n+    T::default()\n+}\n+\n+fn main() {\n+    let astronomers_pi = 10;\n+    let ext_arr: [usize; 1] = [2];\n+    let ext_str = SomeStruct { some_field: 10 };\n+\n+    let mut opt = Some(42);\n+    let ext_opt = Some(42);\n+    let nested_opt = Some(Some(42));\n+    let nested_tuple_opt = Some(Some((42, 43)));\n+\n+    // Should lint - Option\n+    let _ = opt.unwrap_or(2);\n+    let _ = opt.unwrap_or(astronomers_pi);\n+    let _ = opt.unwrap_or(ext_str.some_field);\n+    let _ = opt.unwrap_or(ext_arr[0]);\n+    let _ = opt.and(ext_opt);\n+    let _ = opt.or(ext_opt);\n+    let _ = opt.or(None);\n+    let _ = opt.get_or_insert(2);\n+    let _ = opt.ok_or(2);\n+    let _ = opt.ok_or(ext_arr[0]);\n+\n+    // Cases when unwrap is not called on a simple variable\n+    let _ = Some(10).unwrap_or(2);\n+    let _ = Some(10).and(ext_opt);\n+    let _: Option<usize> = None.or(ext_opt);\n+    let _ = None.get_or_insert(2);\n+    let _: Result<usize, usize> = None.ok_or(2);\n+    let _: Option<usize> = None.or(None);\n+\n+    let mut deep = Deep(Some(42));\n+    let _ = deep.0.unwrap_or(2);\n+    let _ = deep.0.and(ext_opt);\n+    let _ = deep.0.or(None);\n+    let _ = deep.0.get_or_insert(2);\n+    let _ = deep.0.ok_or(2);\n+\n+    // Should not lint - Option\n+    let _ = opt.unwrap_or_else(|| ext_str.return_some_field());\n+    let _ = nested_opt.unwrap_or_else(|| Some(some_call()));\n+    let _ = nested_tuple_opt.unwrap_or_else(|| Some((1, 2)));\n+    let _ = nested_tuple_opt.unwrap_or_else(|| Some((some_call(), some_call())));\n+    let _ = opt.or_else(some_call);\n+    let _ = opt.or_else(|| some_call());\n+    let _: Result<usize, usize> = opt.ok_or_else(|| some_call());\n+    let _: Result<usize, usize> = opt.ok_or_else(some_call);\n+    let _ = deep.0.get_or_insert_with(|| some_call());\n+    let _ = deep.0.or_else(some_call);\n+    let _ = deep.0.or_else(|| some_call());\n+\n+    // These are handled by bind_instead_of_map\n+    let _ = Some(10).and_then(|idx| Some(ext_arr[idx]));\n+    let _ = Some(10).and_then(|idx| Some(idx));\n+    let _: Option<usize> = None.or_else(|| Some(3));\n+    let _ = deep.0.or_else(|| Some(3));\n+    let _ = opt.or_else(|| Some(3));\n+\n+    // Should lint - Result\n+    let res: Result<usize, usize> = Err(5);\n+    let res2: Result<usize, SomeStruct> = Err(SomeStruct { some_field: 5 });\n+\n+    let _ = res2.unwrap_or(2);\n+    let _ = res2.unwrap_or(astronomers_pi);\n+    let _ = res2.unwrap_or(ext_str.some_field);\n+\n+    // Should not lint - Result\n+    let _ = res.unwrap_or_else(|err| err);\n+    let _ = res.unwrap_or_else(|err| ext_arr[err]);\n+    let _ = res2.unwrap_or_else(|err| err.some_field);\n+    let _ = res2.unwrap_or_else(|err| err.return_some_field());\n+    let _ = res2.unwrap_or_else(|_| ext_str.return_some_field());\n+\n+    let _: Result<usize, usize> = res.and_then(|x| Ok(x));\n+    let _: Result<usize, usize> = res.and_then(|x| Err(x));\n+\n+    let _: Result<usize, usize> = res.or_else(|err| Ok(err));\n+    let _: Result<usize, usize> = res.or_else(|err| Err(err));\n+\n+    // These are handled by bind_instead_of_map\n+    let _: Result<usize, usize> = res.and_then(|_| Ok(2));\n+    let _: Result<usize, usize> = res.and_then(|_| Ok(astronomers_pi));\n+    let _: Result<usize, usize> = res.and_then(|_| Ok(ext_str.some_field));\n+\n+    let _: Result<usize, usize> = res.and_then(|_| Err(2));\n+    let _: Result<usize, usize> = res.and_then(|_| Err(astronomers_pi));\n+    let _: Result<usize, usize> = res.and_then(|_| Err(ext_str.some_field));\n+\n+    let _: Result<usize, usize> = res.or_else(|_| Ok(2));\n+    let _: Result<usize, usize> = res.or_else(|_| Ok(astronomers_pi));\n+    let _: Result<usize, usize> = res.or_else(|_| Ok(ext_str.some_field));\n+\n+    let _: Result<usize, usize> = res.or_else(|_| Err(2));\n+    let _: Result<usize, usize> = res.or_else(|_| Err(astronomers_pi));\n+    let _: Result<usize, usize> = res.or_else(|_| Err(ext_str.some_field));\n+}"}, {"sha": "04f47d1aa2978f8afb54126b6d2cd97532f20521", "filename": "tests/ui/unnecessary_lazy_eval.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_lazy_eval.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -0,0 +1,117 @@\n+// run-rustfix\n+#![warn(clippy::unnecessary_lazy_evaluations)]\n+#![allow(clippy::redundant_closure)]\n+#![allow(clippy::bind_instead_of_map)]\n+\n+struct Deep(Option<usize>);\n+\n+#[derive(Copy, Clone)]\n+struct SomeStruct {\n+    some_field: usize,\n+}\n+\n+impl SomeStruct {\n+    fn return_some_field(&self) -> usize {\n+        self.some_field\n+    }\n+}\n+\n+fn some_call<T: Default>() -> T {\n+    T::default()\n+}\n+\n+fn main() {\n+    let astronomers_pi = 10;\n+    let ext_arr: [usize; 1] = [2];\n+    let ext_str = SomeStruct { some_field: 10 };\n+\n+    let mut opt = Some(42);\n+    let ext_opt = Some(42);\n+    let nested_opt = Some(Some(42));\n+    let nested_tuple_opt = Some(Some((42, 43)));\n+\n+    // Should lint - Option\n+    let _ = opt.unwrap_or_else(|| 2);\n+    let _ = opt.unwrap_or_else(|| astronomers_pi);\n+    let _ = opt.unwrap_or_else(|| ext_str.some_field);\n+    let _ = opt.unwrap_or_else(|| ext_arr[0]);\n+    let _ = opt.and_then(|_| ext_opt);\n+    let _ = opt.or_else(|| ext_opt);\n+    let _ = opt.or_else(|| None);\n+    let _ = opt.get_or_insert_with(|| 2);\n+    let _ = opt.ok_or_else(|| 2);\n+    let _ = opt.ok_or_else(|| ext_arr[0]);\n+\n+    // Cases when unwrap is not called on a simple variable\n+    let _ = Some(10).unwrap_or_else(|| 2);\n+    let _ = Some(10).and_then(|_| ext_opt);\n+    let _: Option<usize> = None.or_else(|| ext_opt);\n+    let _ = None.get_or_insert_with(|| 2);\n+    let _: Result<usize, usize> = None.ok_or_else(|| 2);\n+    let _: Option<usize> = None.or_else(|| None);\n+\n+    let mut deep = Deep(Some(42));\n+    let _ = deep.0.unwrap_or_else(|| 2);\n+    let _ = deep.0.and_then(|_| ext_opt);\n+    let _ = deep.0.or_else(|| None);\n+    let _ = deep.0.get_or_insert_with(|| 2);\n+    let _ = deep.0.ok_or_else(|| 2);\n+\n+    // Should not lint - Option\n+    let _ = opt.unwrap_or_else(|| ext_str.return_some_field());\n+    let _ = nested_opt.unwrap_or_else(|| Some(some_call()));\n+    let _ = nested_tuple_opt.unwrap_or_else(|| Some((1, 2)));\n+    let _ = nested_tuple_opt.unwrap_or_else(|| Some((some_call(), some_call())));\n+    let _ = opt.or_else(some_call);\n+    let _ = opt.or_else(|| some_call());\n+    let _: Result<usize, usize> = opt.ok_or_else(|| some_call());\n+    let _: Result<usize, usize> = opt.ok_or_else(some_call);\n+    let _ = deep.0.get_or_insert_with(|| some_call());\n+    let _ = deep.0.or_else(some_call);\n+    let _ = deep.0.or_else(|| some_call());\n+\n+    // These are handled by bind_instead_of_map\n+    let _ = Some(10).and_then(|idx| Some(ext_arr[idx]));\n+    let _ = Some(10).and_then(|idx| Some(idx));\n+    let _: Option<usize> = None.or_else(|| Some(3));\n+    let _ = deep.0.or_else(|| Some(3));\n+    let _ = opt.or_else(|| Some(3));\n+\n+    // Should lint - Result\n+    let res: Result<usize, usize> = Err(5);\n+    let res2: Result<usize, SomeStruct> = Err(SomeStruct { some_field: 5 });\n+\n+    let _ = res2.unwrap_or_else(|_| 2);\n+    let _ = res2.unwrap_or_else(|_| astronomers_pi);\n+    let _ = res2.unwrap_or_else(|_| ext_str.some_field);\n+\n+    // Should not lint - Result\n+    let _ = res.unwrap_or_else(|err| err);\n+    let _ = res.unwrap_or_else(|err| ext_arr[err]);\n+    let _ = res2.unwrap_or_else(|err| err.some_field);\n+    let _ = res2.unwrap_or_else(|err| err.return_some_field());\n+    let _ = res2.unwrap_or_else(|_| ext_str.return_some_field());\n+\n+    let _: Result<usize, usize> = res.and_then(|x| Ok(x));\n+    let _: Result<usize, usize> = res.and_then(|x| Err(x));\n+\n+    let _: Result<usize, usize> = res.or_else(|err| Ok(err));\n+    let _: Result<usize, usize> = res.or_else(|err| Err(err));\n+\n+    // These are handled by bind_instead_of_map\n+    let _: Result<usize, usize> = res.and_then(|_| Ok(2));\n+    let _: Result<usize, usize> = res.and_then(|_| Ok(astronomers_pi));\n+    let _: Result<usize, usize> = res.and_then(|_| Ok(ext_str.some_field));\n+\n+    let _: Result<usize, usize> = res.and_then(|_| Err(2));\n+    let _: Result<usize, usize> = res.and_then(|_| Err(astronomers_pi));\n+    let _: Result<usize, usize> = res.and_then(|_| Err(ext_str.some_field));\n+\n+    let _: Result<usize, usize> = res.or_else(|_| Ok(2));\n+    let _: Result<usize, usize> = res.or_else(|_| Ok(astronomers_pi));\n+    let _: Result<usize, usize> = res.or_else(|_| Ok(ext_str.some_field));\n+\n+    let _: Result<usize, usize> = res.or_else(|_| Err(2));\n+    let _: Result<usize, usize> = res.or_else(|_| Err(astronomers_pi));\n+    let _: Result<usize, usize> = res.or_else(|_| Err(ext_str.some_field));\n+}"}, {"sha": "5c1b2eb1f14e833bd7aecb01e58c78a7699641da", "filename": "tests/ui/unnecessary_lazy_eval.stderr", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Funnecessary_lazy_eval.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Funnecessary_lazy_eval.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_lazy_eval.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -0,0 +1,148 @@\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:34:13\n+   |\n+LL |     let _ = opt.unwrap_or_else(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(2)`\n+   |\n+   = note: `-D clippy::unnecessary-lazy-evaluations` implied by `-D warnings`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:35:13\n+   |\n+LL |     let _ = opt.unwrap_or_else(|| astronomers_pi);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(astronomers_pi)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:36:13\n+   |\n+LL |     let _ = opt.unwrap_or_else(|| ext_str.some_field);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(ext_str.some_field)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:37:13\n+   |\n+LL |     let _ = opt.unwrap_or_else(|| ext_arr[0]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(ext_arr[0])`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:38:13\n+   |\n+LL |     let _ = opt.and_then(|_| ext_opt);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `opt.and(ext_opt)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:39:13\n+   |\n+LL |     let _ = opt.or_else(|| ext_opt);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `opt.or(ext_opt)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:40:13\n+   |\n+LL |     let _ = opt.or_else(|| None);\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `opt.or(None)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:41:13\n+   |\n+LL |     let _ = opt.get_or_insert_with(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `get_or_insert` instead: `opt.get_or_insert(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:42:13\n+   |\n+LL |     let _ = opt.ok_or_else(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `opt.ok_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:43:13\n+   |\n+LL |     let _ = opt.ok_or_else(|| ext_arr[0]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `opt.ok_or(ext_arr[0])`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:46:13\n+   |\n+LL |     let _ = Some(10).unwrap_or_else(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `Some(10).unwrap_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:47:13\n+   |\n+LL |     let _ = Some(10).and_then(|_| ext_opt);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `Some(10).and(ext_opt)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:48:28\n+   |\n+LL |     let _: Option<usize> = None.or_else(|| ext_opt);\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `None.or(ext_opt)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:49:13\n+   |\n+LL |     let _ = None.get_or_insert_with(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `get_or_insert` instead: `None.get_or_insert(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:50:35\n+   |\n+LL |     let _: Result<usize, usize> = None.ok_or_else(|| 2);\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `None.ok_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:51:28\n+   |\n+LL |     let _: Option<usize> = None.or_else(|| None);\n+   |                            ^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `None.or(None)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:54:13\n+   |\n+LL |     let _ = deep.0.unwrap_or_else(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `deep.0.unwrap_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:55:13\n+   |\n+LL |     let _ = deep.0.and_then(|_| ext_opt);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `deep.0.and(ext_opt)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:56:13\n+   |\n+LL |     let _ = deep.0.or_else(|| None);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `deep.0.or(None)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:57:13\n+   |\n+LL |     let _ = deep.0.get_or_insert_with(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `get_or_insert` instead: `deep.0.get_or_insert(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:58:13\n+   |\n+LL |     let _ = deep.0.ok_or_else(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `deep.0.ok_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:84:13\n+   |\n+LL |     let _ = res2.unwrap_or_else(|_| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `res2.unwrap_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:85:13\n+   |\n+LL |     let _ = res2.unwrap_or_else(|_| astronomers_pi);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `res2.unwrap_or(astronomers_pi)`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:86:13\n+   |\n+LL |     let _ = res2.unwrap_or_else(|_| ext_str.some_field);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `res2.unwrap_or(ext_str.some_field)`\n+\n+error: aborting due to 24 previous errors\n+"}, {"sha": "8a9b0cd3cf019466d3786f7be3eb08ceda2f0509", "filename": "tests/ui/useless_conversion.fixed", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fuseless_conversion.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fuseless_conversion.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_conversion.fixed?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -64,4 +64,9 @@ fn main() {\n     let _ = \"\".lines();\n     let _ = vec![1, 2, 3].into_iter();\n     let _: String = format!(\"Hello {}\", \"world\");\n+\n+    // keep parenthesis around `a + b` for suggestion (see #4750)\n+    let a: i32 = 1;\n+    let b: i32 = 1;\n+    let _ = (a + b) * 3;\n }"}, {"sha": "4faa1572973bc0ff5df24d3c2fe392e49d219c0d", "filename": "tests/ui/useless_conversion.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_conversion.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -64,4 +64,9 @@ fn main() {\n     let _ = \"\".lines().into_iter();\n     let _ = vec![1, 2, 3].into_iter().into_iter();\n     let _: String = format!(\"Hello {}\", \"world\").into();\n+\n+    // keep parenthesis around `a + b` for suggestion (see #4750)\n+    let a: i32 = 1;\n+    let b: i32 = 1;\n+    let _ = i32::from(a + b) * 3;\n }"}, {"sha": "f1e880d2696c40c430e23e11f2a60aec52e5dc7f", "filename": "tests/ui/useless_conversion.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fuseless_conversion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fuseless_conversion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_conversion.stderr?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -64,5 +64,11 @@ error: useless conversion to the same type\n LL |     let _: String = format!(\"Hello {}\", \"world\").into();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `.into()`: `format!(\"Hello {}\", \"world\")`\n \n-error: aborting due to 10 previous errors\n+error: useless conversion to the same type\n+  --> $DIR/useless_conversion.rs:71:13\n+   |\n+LL |     let _ = i32::from(a + b) * 3;\n+   |             ^^^^^^^^^^^^^^^^ help: consider removing `i32::from()`: `(a + b)`\n+\n+error: aborting due to 11 previous errors\n "}, {"sha": "856771596202efb47f1c755759ccf60040133d00", "filename": "tests/ui/vec.fixed", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fvec.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fvec.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvec.fixed?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -52,4 +52,11 @@ fn main() {\n     for a in vec![NonCopy, NonCopy] {\n         println!(\"{:?}\", a);\n     }\n+\n+    on_vec(&vec![1; 201]); // Ok, size of `vec` higher than `too_large_for_stack`\n+\n+    // Ok\n+    for a in vec![1; 201] {\n+        println!(\"{:?}\", a);\n+    }\n }"}, {"sha": "03b8ee816658ccefbebb278a89e278cc36945691", "filename": "tests/ui/vec.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68060200572119c2a48a0d3fccca21ae10eb51f/tests%2Fui%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvec.rs?ref=c68060200572119c2a48a0d3fccca21ae10eb51f", "patch": "@@ -52,4 +52,11 @@ fn main() {\n     for a in vec![NonCopy, NonCopy] {\n         println!(\"{:?}\", a);\n     }\n+\n+    on_vec(&vec![1; 201]); // Ok, size of `vec` higher than `too_large_for_stack`\n+\n+    // Ok\n+    for a in vec![1; 201] {\n+        println!(\"{:?}\", a);\n+    }\n }"}, {"sha": "319de217e0d90170c1bcf7545aef25e1caff11d5", "filename": "util/dev", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4b0e6d5b90b8044a3201e3ddb4eef19b6a63c47b/util%2Fdev", "raw_url": "https://github.com/rust-lang/rust/raw/4b0e6d5b90b8044a3201e3ddb4eef19b6a63c47b/util%2Fdev", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fdev?ref=4b0e6d5b90b8044a3201e3ddb4eef19b6a63c47b", "patch": "@@ -1,7 +0,0 @@\n-#!/bin/sh\n-CARGO_TARGET_DIR=$(pwd)/target/\n-export CARGO_TARGET_DIR\n-\n-echo 'Deprecated! `util/dev` usage is deprecated, please use `cargo dev` instead.'\n-\n-cd clippy_dev && cargo run -- \"$@\""}]}