{"sha": "0b0666e2b6e0a19ea11734619a978d9c3dc71bed", "node_id": "C_kwDOAAsO6NoAKDBiMDY2NmUyYjZlMGExOWVhMTE3MzQ2MTlhOTc4ZDljM2RjNzFiZWQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-12-28T12:59:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-28T12:59:24Z"}, "message": "Rollup merge of #92238 - dtolnay:stringifytest, r=Mark-Simulacrum\n\nAdd a test suite for stringify macro\n\nThis attempts to cover the behavior of `stringify!` on various interpolated syntax tree nodes.\n\nThe pretty printer has a history of unsightly whitespace (double spaces, missing spaces, spaces where there shouldn't be spaces) &mdash; #91437, #91562, #91568. There are several such issues left; the test cases that I consider to be currently behaving incorrectly are marked with `// FIXME` in the PR.", "tree": {"sha": "53aa3096ce651ed634cde2cb7e2fccb2df4fea48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53aa3096ce651ed634cde2cb7e2fccb2df4fea48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b0666e2b6e0a19ea11734619a978d9c3dc71bed", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhywosCRBK7hj4Ov3rIwAAcMIIAEqONkoh1AHepAgbXKoRQI+R\nCTb7oh9bRysP19L3kNDyyNHUq1qKhTK1yfeprFdILTIROKkd1uc8B9WjapFTQGEF\n2WtzSMxXqppUDlgWp2cE+woAlBf9iFO0VQnJJEs2cpjKmjLdLA9WEBUkh1WAlQ/e\nXUU7hJJnBJtJaduNp0T4p7ti7v54zA5i3SffOfiGpxpDeyYS6cPHN+053rESgqFl\nqzCozzOVRGxjpbwDCjOEe1iaguTHIyCwBefmYwMXGyWas8v60OybB6XzAvGG429v\nQPRVFtccDGeu5QgAXQE5GHsKqA+8e/xnRHEsHHnmWQ1BQfn/7k7XWp7vGhsF/1A=\n=ArqK\n-----END PGP SIGNATURE-----\n", "payload": "tree 53aa3096ce651ed634cde2cb7e2fccb2df4fea48\nparent f1598edc3f8f249b5b2e84135f91a3dbda4d7565\nparent 55fc986be72c0db77b65b0198ed5b26ac918ddad\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1640696364 +0100\ncommitter GitHub <noreply@github.com> 1640696364 +0100\n\nRollup merge of #92238 - dtolnay:stringifytest, r=Mark-Simulacrum\n\nAdd a test suite for stringify macro\n\nThis attempts to cover the behavior of `stringify!` on various interpolated syntax tree nodes.\n\nThe pretty printer has a history of unsightly whitespace (double spaces, missing spaces, spaces where there shouldn't be spaces) &mdash; #91437, #91562, #91568. There are several such issues left; the test cases that I consider to be currently behaving incorrectly are marked with `// FIXME` in the PR.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b0666e2b6e0a19ea11734619a978d9c3dc71bed", "html_url": "https://github.com/rust-lang/rust/commit/0b0666e2b6e0a19ea11734619a978d9c3dc71bed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b0666e2b6e0a19ea11734619a978d9c3dc71bed/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1598edc3f8f249b5b2e84135f91a3dbda4d7565", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1598edc3f8f249b5b2e84135f91a3dbda4d7565", "html_url": "https://github.com/rust-lang/rust/commit/f1598edc3f8f249b5b2e84135f91a3dbda4d7565"}, {"sha": "55fc986be72c0db77b65b0198ed5b26ac918ddad", "url": "https://api.github.com/repos/rust-lang/rust/commits/55fc986be72c0db77b65b0198ed5b26ac918ddad", "html_url": "https://github.com/rust-lang/rust/commit/55fc986be72c0db77b65b0198ed5b26ac918ddad"}], "stats": {"total": 879, "additions": 879, "deletions": 0}, "files": [{"sha": "fcf6a9278d8fe35e785937cc89bc737b8ba88565", "filename": "src/test/ui/macros/stringify.rs", "status": "added", "additions": 879, "deletions": 0, "changes": 879, "blob_url": "https://github.com/rust-lang/rust/blob/0b0666e2b6e0a19ea11734619a978d9c3dc71bed/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0666e2b6e0a19ea11734619a978d9c3dc71bed/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs?ref=0b0666e2b6e0a19ea11734619a978d9c3dc71bed", "patch": "@@ -0,0 +1,879 @@\n+// run-pass\n+// edition:2021\n+// compile-flags: --test\n+\n+#![feature(async_closure)]\n+#![feature(const_trait_impl)]\n+#![feature(generators)]\n+#![feature(half_open_range_patterns)]\n+#![feature(more_qualified_paths)]\n+#![feature(raw_ref_op)]\n+#![deny(unused_macros)]\n+\n+macro_rules! stringify_block {\n+    ($block:block) => {\n+        stringify!($block)\n+    };\n+}\n+\n+macro_rules! stringify_expr {\n+    ($expr:expr) => {\n+        stringify!($expr)\n+    };\n+}\n+\n+macro_rules! stringify_item {\n+    ($item:item) => {\n+        stringify!($item)\n+    };\n+}\n+\n+macro_rules! stringify_meta {\n+    ($meta:meta) => {\n+        stringify!($meta)\n+    };\n+}\n+\n+macro_rules! stringify_pat {\n+    ($pat:pat) => {\n+        stringify!($pat)\n+    };\n+}\n+\n+macro_rules! stringify_path {\n+    ($path:path) => {\n+        stringify!($path)\n+    };\n+}\n+\n+macro_rules! stringify_stmt {\n+    ($stmt:stmt) => {\n+        stringify!($stmt)\n+    };\n+}\n+\n+macro_rules! stringify_ty {\n+    ($ty:ty) => {\n+        stringify!($ty)\n+    };\n+}\n+\n+macro_rules! stringify_vis {\n+    ($vis:vis) => {\n+        stringify!($vis)\n+    };\n+}\n+\n+#[test]\n+fn test_block() {\n+    assert_eq!(stringify_block!({}), \"{}\");\n+    assert_eq!(stringify_block!({ true }), \"{ true }\");\n+    assert_eq!(stringify_block!({ return }), \"{ return }\");\n+    assert_eq!(\n+        stringify_block!({\n+            return;\n+        }),\n+        \"{ return; }\",\n+    );\n+    assert_eq!(\n+        stringify_block!({\n+            let _;\n+            true\n+        }),\n+        \"{ let _; true }\",\n+    );\n+}\n+\n+#[test]\n+fn test_expr() {\n+    // ExprKind::Box\n+    assert_eq!(stringify_expr!(box expr), \"box expr\");\n+\n+    // ExprKind::Array\n+    assert_eq!(stringify_expr!([]), \"[]\");\n+    assert_eq!(stringify_expr!([true]), \"[true]\");\n+    assert_eq!(stringify_expr!([true,]), \"[true]\");\n+    assert_eq!(stringify_expr!([true, true]), \"[true, true]\");\n+\n+    // ExprKind::Call\n+    assert_eq!(stringify_expr!(f()), \"f()\");\n+    assert_eq!(stringify_expr!(f::<u8>()), \"f::<u8>()\");\n+    assert_eq!(stringify_expr!(f::<1>()), \"f::<1>()\");\n+    assert_eq!(stringify_expr!(f::<'a, u8, 1>()), \"f::<'a, u8, 1>()\");\n+    assert_eq!(stringify_expr!(f(true)), \"f(true)\");\n+    assert_eq!(stringify_expr!(f(true,)), \"f(true)\");\n+    assert_eq!(stringify_expr!(()()), \"()()\");\n+\n+    // ExprKind::MethodCall\n+    assert_eq!(stringify_expr!(x.f()), \"x.f()\");\n+    assert_eq!(stringify_expr!(x.f::<u8>()), \"x.f::<u8>()\");\n+\n+    // ExprKind::Tup\n+    assert_eq!(stringify_expr!(()), \"()\");\n+    assert_eq!(stringify_expr!((true,)), \"(true,)\");\n+    assert_eq!(stringify_expr!((true, false)), \"(true, false)\");\n+    assert_eq!(stringify_expr!((true, false,)), \"(true, false)\");\n+\n+    // ExprKind::Binary\n+    assert_eq!(stringify_expr!(true || false), \"true || false\");\n+    assert_eq!(stringify_expr!(true || false && false), \"true || false && false\");\n+\n+    // ExprKind::Unary\n+    assert_eq!(stringify_expr!(*expr), \"*expr\");\n+    assert_eq!(stringify_expr!(!expr), \"!expr\");\n+    assert_eq!(stringify_expr!(-expr), \"-expr\");\n+\n+    // ExprKind::Lit\n+    assert_eq!(stringify_expr!('x'), \"'x'\");\n+    assert_eq!(stringify_expr!(1_000_i8), \"1_000_i8\");\n+    assert_eq!(stringify_expr!(1.00000000000000001), \"1.00000000000000001\");\n+\n+    // ExprKind::Cast\n+    assert_eq!(stringify_expr!(expr as T), \"expr as T\");\n+    assert_eq!(stringify_expr!(expr as T<u8>), \"expr as T<u8>\");\n+\n+    // ExprKind::Type\n+    assert_eq!(stringify_expr!(expr: T), \"expr: T\");\n+    assert_eq!(stringify_expr!(expr: T<u8>), \"expr: T<u8>\");\n+\n+    // ExprKind::If\n+    assert_eq!(stringify_expr!(if true {}), \"if true {}\");\n+    assert_eq!(\n+        stringify_expr!(if true {\n+        } else {\n+        }),\n+        \"if true {} else {}\",\n+    );\n+    assert_eq!(\n+        stringify_expr!(if let true = true {\n+        } else {\n+        }),\n+        \"if let true = true {} else {}\",\n+    );\n+    assert_eq!(\n+        stringify_expr!(if true {\n+        } else if false {\n+        }),\n+        \"if true {} else if false {}\",\n+    );\n+    assert_eq!(\n+        stringify_expr!(if true {\n+        } else if false {\n+        } else {\n+        }),\n+        \"if true {} else if false {} else {}\",\n+    );\n+    assert_eq!(\n+        stringify_expr!(if true {\n+            return;\n+        } else if false {\n+            0\n+        } else {\n+            0\n+        }),\n+        \"if true { return; } else if false { 0 } else { 0 }\",\n+    );\n+\n+    // ExprKind::While\n+    assert_eq!(stringify_expr!(while true {}), \"while true {}\");\n+    assert_eq!(stringify_expr!('a: while true {}), \"'a: while true {}\");\n+    assert_eq!(stringify_expr!(while let true = true {}), \"while let true = true {}\");\n+\n+    // ExprKind::ForLoop\n+    assert_eq!(stringify_expr!(for _ in x {}), \"for _ in x {}\");\n+    assert_eq!(stringify_expr!('a: for _ in x {}), \"'a: for _ in x {}\");\n+\n+    // ExprKind::Loop\n+    assert_eq!(stringify_expr!(loop {}), \"loop {}\");\n+    assert_eq!(stringify_expr!('a: loop {}), \"'a: loop {}\");\n+\n+    // ExprKind::Match\n+    assert_eq!(stringify_expr!(match self {}), \"match self {}\");\n+    assert_eq!(\n+        stringify_expr!(match self {\n+            Ok => 1,\n+        }),\n+        \"match self { Ok => 1, }\",\n+    );\n+    assert_eq!(\n+        stringify_expr!(match self {\n+            Ok => 1,\n+            Err => 0,\n+        }),\n+        \"match self { Ok => 1, Err => 0, }\",\n+    );\n+\n+    // ExprKind::Closure\n+    assert_eq!(stringify_expr!(|| {}), \"|| {}\");\n+    assert_eq!(stringify_expr!(|x| {}), \"|x| {}\");\n+    assert_eq!(stringify_expr!(|x: u8| {}), \"|x: u8| {}\");\n+    assert_eq!(stringify_expr!(|| ()), \"|| ()\");\n+    assert_eq!(stringify_expr!(move || self), \"move || self\");\n+    assert_eq!(stringify_expr!(async || self), \"async || self\");\n+    assert_eq!(stringify_expr!(async move || self), \"async move || self\");\n+    assert_eq!(stringify_expr!(static || self), \"static || self\");\n+    assert_eq!(stringify_expr!(static move || self), \"static move || self\");\n+    #[rustfmt::skip] // https://github.com/rust-lang/rustfmt/issues/5149\n+    assert_eq!(\n+        stringify_expr!(static async || self),\n+        \"static async || self\",\n+    );\n+    #[rustfmt::skip] // https://github.com/rust-lang/rustfmt/issues/5149\n+    assert_eq!(\n+        stringify_expr!(static async move || self),\n+        \"static async move || self\",\n+    );\n+    assert_eq!(stringify_expr!(|| -> u8 { self }), \"|| -> u8 { self }\");\n+    assert_eq!(stringify_expr!(1 + || {}), \"1 + (|| {})\"); // ??\n+\n+    // ExprKind::Block\n+    assert_eq!(stringify_expr!({}), \"{}\");\n+    assert_eq!(stringify_expr!(unsafe {}), \"unsafe {}\");\n+    assert_eq!(stringify_expr!('a: {}), \"'a: {}\");\n+    assert_eq!(\n+        stringify_expr!(\n+            #[attr]\n+            {}\n+        ),\n+        \"#[attr] { }\", // FIXME\n+    );\n+    assert_eq!(\n+        stringify_expr!(\n+            {\n+                #![attr]\n+            }\n+        ),\n+        \"{\\n\\\n+        \\x20   #![attr]\\n\\\n+        }\",\n+    );\n+\n+    // ExprKind::Async\n+    assert_eq!(stringify_expr!(async {}), \"async {}\");\n+    assert_eq!(stringify_expr!(async move {}), \"async move {}\");\n+\n+    // ExprKind::Await\n+    assert_eq!(stringify_expr!(expr.await), \"expr.await\");\n+\n+    // ExprKind::TryBlock\n+    assert_eq!(stringify_expr!(try {}), \"try  {}\"); // FIXME\n+\n+    // ExprKind::Assign\n+    assert_eq!(stringify_expr!(expr = true), \"expr = true\");\n+\n+    // ExprKind::AssignOp\n+    assert_eq!(stringify_expr!(expr += true), \"expr += true\");\n+\n+    // ExprKind::Field\n+    assert_eq!(stringify_expr!(expr.field), \"expr.field\");\n+    assert_eq!(stringify_expr!(expr.0), \"expr.0\");\n+\n+    // ExprKind::Index\n+    assert_eq!(stringify_expr!(expr[true]), \"expr[true]\");\n+\n+    // ExprKind::Range\n+    assert_eq!(stringify_expr!(..), \"..\");\n+    assert_eq!(stringify_expr!(..hi), \"..hi\");\n+    assert_eq!(stringify_expr!(lo..), \"lo..\");\n+    assert_eq!(stringify_expr!(lo..hi), \"lo..hi\");\n+    assert_eq!(stringify_expr!(..=hi), \"..=hi\");\n+    assert_eq!(stringify_expr!(lo..=hi), \"lo..=hi\");\n+    assert_eq!(stringify_expr!(-2..=-1), \"-2..=-1\");\n+\n+    // ExprKind::Path\n+    assert_eq!(stringify_expr!(thing), \"thing\");\n+    assert_eq!(stringify_expr!(m::thing), \"m::thing\");\n+    assert_eq!(stringify_expr!(self::thing), \"self::thing\");\n+    assert_eq!(stringify_expr!(crate::thing), \"crate::thing\");\n+    assert_eq!(stringify_expr!(Self::thing), \"Self::thing\");\n+    assert_eq!(stringify_expr!(<Self as T>::thing), \"<Self as T>::thing\");\n+    assert_eq!(stringify_expr!(Self::<'static>), \"Self::<'static>\");\n+\n+    // ExprKind::AddrOf\n+    assert_eq!(stringify_expr!(&expr), \"&expr\");\n+    assert_eq!(stringify_expr!(&mut expr), \"&mut expr\");\n+    assert_eq!(stringify_expr!(&raw const expr), \"&raw const expr\");\n+    assert_eq!(stringify_expr!(&raw mut expr), \"&raw mut expr\");\n+\n+    // ExprKind::Break\n+    assert_eq!(stringify_expr!(break), \"break\");\n+    assert_eq!(stringify_expr!(break 'a), \"break 'a\");\n+    assert_eq!(stringify_expr!(break true), \"break true\");\n+    assert_eq!(stringify_expr!(break 'a true), \"break 'a true\");\n+\n+    // ExprKind::Continue\n+    assert_eq!(stringify_expr!(continue), \"continue\");\n+    assert_eq!(stringify_expr!(continue 'a), \"continue 'a\");\n+\n+    // ExprKind::Ret\n+    assert_eq!(stringify_expr!(return), \"return\");\n+    assert_eq!(stringify_expr!(return true), \"return true\");\n+\n+    // ExprKind::MacCall\n+    assert_eq!(stringify_expr!(mac!(...)), \"mac!(...)\");\n+    assert_eq!(stringify_expr!(mac![...]), \"mac![...]\");\n+    assert_eq!(stringify_expr!(mac! { ... }), \"mac! { ... }\");\n+\n+    // ExprKind::Struct\n+    assert_eq!(stringify_expr!(Struct {}), \"Struct{}\"); // FIXME\n+    #[rustfmt::skip] // https://github.com/rust-lang/rustfmt/issues/5151\n+    assert_eq!(stringify_expr!(<Struct as Trait>::Type {}), \"<Struct as Trait>::Type{}\");\n+    assert_eq!(stringify_expr!(Struct { .. }), \"Struct{..}\"); // FIXME\n+    assert_eq!(stringify_expr!(Struct { ..base }), \"Struct{..base}\"); // FIXME\n+    assert_eq!(stringify_expr!(Struct { x }), \"Struct{x,}\");\n+    assert_eq!(stringify_expr!(Struct { x, .. }), \"Struct{x, ..}\");\n+    assert_eq!(stringify_expr!(Struct { x, ..base }), \"Struct{x, ..base}\");\n+    assert_eq!(stringify_expr!(Struct { x: true }), \"Struct{x: true,}\");\n+    assert_eq!(stringify_expr!(Struct { x: true, .. }), \"Struct{x: true, ..}\");\n+    assert_eq!(stringify_expr!(Struct { x: true, ..base }), \"Struct{x: true, ..base}\");\n+\n+    // ExprKind::Repeat\n+    assert_eq!(stringify_expr!([(); 0]), \"[(); 0]\");\n+\n+    // ExprKind::Paren\n+    assert_eq!(stringify_expr!((expr)), \"(expr)\");\n+\n+    // ExprKind::Try\n+    assert_eq!(stringify_expr!(expr?), \"expr?\");\n+\n+    // ExprKind::Yield\n+    assert_eq!(stringify_expr!(yield), \"yield\");\n+    assert_eq!(stringify_expr!(yield true), \"yield true\");\n+}\n+\n+#[test]\n+fn test_item() {\n+    // ItemKind::ExternCrate\n+    assert_eq!(\n+        stringify_item!(\n+            extern crate std;\n+        ),\n+        \"extern crate std;\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            pub extern crate self as std;\n+        ),\n+        \"pub extern crate self as std;\",\n+    );\n+\n+    // ItemKind::Use\n+    assert_eq!(\n+        stringify_item!(\n+            pub use crate::{a, b::c};\n+        ),\n+        \"pub use crate::{a, b::c};\",\n+    );\n+\n+    // ItemKind::Static\n+    assert_eq!(\n+        stringify_item!(\n+            pub static S: () = {};\n+        ),\n+        \"pub static S: () = {};\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            static mut S: () = {};\n+        ),\n+        \"static mut S: () = {};\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            static S: ();\n+        ),\n+        \"static S: () ;\", // FIXME\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            static mut S: ();\n+        ),\n+        \"static mut S: () ;\",\n+    );\n+\n+    // ItemKind::Const\n+    assert_eq!(\n+        stringify_item!(\n+            pub const S: () = {};\n+        ),\n+        \"pub const S: () = {};\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            const S: ();\n+        ),\n+        \"const S: () ;\", // FIXME\n+    );\n+\n+    // ItemKind::Fn\n+    assert_eq!(\n+        stringify_item!(\n+            pub default const async unsafe extern \"C\" fn f() {}\n+        ),\n+        \"pub default const async unsafe extern \\\"C\\\" fn f() {}\",\n+    );\n+\n+    // ItemKind::Mod\n+    assert_eq!(\n+        stringify_item!(\n+            pub mod m;\n+        ),\n+        \"pub mod m;\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            mod m {}\n+        ),\n+        \"mod m {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            unsafe mod m;\n+        ),\n+        \"unsafe mod m;\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            unsafe mod m {}\n+        ),\n+        \"unsafe mod m {}\",\n+    );\n+\n+    // ItemKind::ForeignMod\n+    assert_eq!(\n+        stringify_item!(\n+            extern \"C\" {}\n+        ),\n+        \"extern \\\"C\\\" {}\",\n+    );\n+    #[rustfmt::skip]\n+    assert_eq!(\n+        stringify_item!(\n+            pub extern \"C\" {}\n+        ),\n+        \"extern \\\"C\\\" {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            unsafe extern \"C++\" {}\n+        ),\n+        \"unsafe extern \\\"C++\\\" {}\",\n+    );\n+\n+    // ItemKind::TyAlias\n+    #[rustfmt::skip]\n+    assert_eq!(\n+        stringify_item!(\n+            pub default type Type<'a>: Bound\n+            where\n+                Self: 'a,\n+            = T;\n+        ),\n+        \"pub default type Type<'a>: Bound where Self: 'a = T;\",\n+    );\n+\n+    // ItemKind::Enum\n+    assert_eq!(\n+        stringify_item!(\n+            pub enum Void {}\n+        ),\n+        \"pub enum Void {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            enum Empty {\n+                Unit,\n+                Tuple(),\n+                Struct {},\n+            }\n+        ),\n+        \"enum Empty { Unit, Tuple(), Struct {}, }\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            enum Enum<T>\n+            where\n+                T: 'a,\n+            {\n+                Unit,\n+                Tuple(T),\n+                Struct { t: T },\n+            }\n+        ),\n+        \"enum Enum<T> where T: 'a {\\n\\\n+        \\x20   Unit,\\n\\\n+        \\x20   Tuple(T),\\n\\\n+        \\x20   Struct {\\n\\\n+        \\x20       t: T,\\n\\\n+        \\x20   },\\n\\\n+        }\",\n+    );\n+\n+    // ItemKind::Struct\n+    assert_eq!(\n+        stringify_item!(\n+            pub struct Unit;\n+        ),\n+        \"pub struct Unit;\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            struct Tuple();\n+        ),\n+        \"struct Tuple();\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            struct Tuple(T);\n+        ),\n+        \"struct Tuple(T);\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            struct Struct {}\n+        ),\n+        \"struct Struct {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            struct Struct<T>\n+            where\n+                T: 'a,\n+            {\n+                t: T,\n+            }\n+        ),\n+        \"struct Struct<T> where T: 'a {\\n\\\n+        \\x20   t: T,\\n\\\n+        }\",\n+    );\n+\n+    // ItemKind::Union\n+    assert_eq!(\n+        stringify_item!(\n+            pub union Union {}\n+        ),\n+        \"pub union Union {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            union Union<T> where T: 'a {\n+                t: T,\n+            }\n+        ),\n+        \"union Union<T> where T: 'a {\\n\\\n+        \\x20   t: T,\\n\\\n+        }\",\n+    );\n+\n+    // ItemKind::Trait\n+    assert_eq!(\n+        stringify_item!(\n+            pub unsafe auto trait Send {}\n+        ),\n+        \"pub unsafe auto trait Send {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            trait Trait<'a>: Sized\n+            where\n+                Self: 'a,\n+            {\n+            }\n+        ),\n+        \"trait Trait<'a>: Sized where Self: 'a {}\",\n+    );\n+\n+    // ItemKind::TraitAlias\n+    assert_eq!(\n+        stringify_item!(\n+            pub trait Trait<T> = Sized where T: 'a;\n+        ),\n+        \"\", // FIXME\n+    );\n+\n+    // ItemKind::Impl\n+    assert_eq!(\n+        stringify_item!(\n+            pub impl Struct {}\n+        ),\n+        \"pub impl Struct {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            impl<T> Struct<T> {}\n+        ),\n+        \"impl <T> Struct<T> {}\", // FIXME\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            pub impl Trait for Struct {}\n+        ),\n+        \"pub impl Trait for Struct {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            impl ~const Struct {}\n+        ),\n+        \"impl Struct {}\", // FIXME\n+    );\n+\n+    // ItemKind::MacCall\n+    assert_eq!(stringify_item!(mac!(...);), \"mac!(...);\");\n+    assert_eq!(stringify_item!(mac![...];), \"mac![...];\");\n+    assert_eq!(stringify_item!(mac! { ... }), \"mac! { ... }\");\n+\n+    // ItemKind::MacroDef\n+    assert_eq!(\n+        stringify_item!(\n+            macro_rules! stringify {\n+                () => {};\n+            }\n+        ),\n+        \"macro_rules! stringify { () => {} ; }\", // FIXME\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            pub macro stringify() {}\n+        ),\n+        \"pub macro stringify { () => {} }\",\n+    );\n+}\n+\n+#[test]\n+fn test_meta() {\n+    assert_eq!(stringify_meta!(k), \"k\");\n+    assert_eq!(stringify_meta!(k = \"v\"), \"k = \\\"v\\\"\");\n+    assert_eq!(stringify_meta!(list(k1, k2 = \"v\")), \"list(k1, k2 = \\\"v\\\")\");\n+    assert_eq!(stringify_meta!(serde::k), \"serde::k\");\n+}\n+\n+#[test]\n+fn test_pat() {\n+    // PatKind::Wild\n+    assert_eq!(stringify_pat!(_), \"_\");\n+\n+    // PatKind::Ident\n+    assert_eq!(stringify_pat!(_x), \"_x\");\n+    assert_eq!(stringify_pat!(ref _x), \"ref _x\");\n+    assert_eq!(stringify_pat!(mut _x), \"mut _x\");\n+    assert_eq!(stringify_pat!(ref mut _x), \"ref mut _x\");\n+    assert_eq!(stringify_pat!(ref mut _x @ _), \"ref mut _x @ _\");\n+\n+    // PatKind::Struct\n+    assert_eq!(stringify_pat!(Struct {}), \"Struct {  }\"); // FIXME\n+    assert_eq!(stringify_pat!(Struct::<u8> {}), \"Struct::<u8> {  }\");\n+    assert_eq!(stringify_pat!(Struct::<'static> {}), \"Struct::<'static> {  }\");\n+    assert_eq!(stringify_pat!(Struct { x }), \"Struct { x }\");\n+    assert_eq!(stringify_pat!(Struct { x: _x }), \"Struct { x: _x }\");\n+    assert_eq!(stringify_pat!(Struct { .. }), \"Struct { .. }\");\n+    assert_eq!(stringify_pat!(Struct { x, .. }), \"Struct { x, .. }\");\n+    assert_eq!(stringify_pat!(Struct { x: _x, .. }), \"Struct { x: _x, .. }\");\n+    #[rustfmt::skip] // https://github.com/rust-lang/rustfmt/issues/5151\n+    assert_eq!(\n+        stringify_pat!(<Struct as Trait>::Type {}),\n+        \"<Struct as Trait>::Type {  }\",\n+    );\n+\n+    // PatKind::TupleStruct\n+    assert_eq!(stringify_pat!(Tuple()), \"Tuple()\");\n+    assert_eq!(stringify_pat!(Tuple::<u8>()), \"Tuple::<u8>()\");\n+    assert_eq!(stringify_pat!(Tuple::<'static>()), \"Tuple::<'static>()\");\n+    assert_eq!(stringify_pat!(Tuple(x)), \"Tuple(x)\");\n+    assert_eq!(stringify_pat!(Tuple(..)), \"Tuple(..)\");\n+    assert_eq!(stringify_pat!(Tuple(x, ..)), \"Tuple(x, ..)\");\n+    assert_eq!(stringify_pat!(<Struct as Trait>::Type()), \"<Struct as Trait>::Type()\");\n+\n+    // PatKind::Or\n+    assert_eq!(stringify_pat!(true | false), \"true | false\");\n+    assert_eq!(stringify_pat!(| true), \"true\");\n+    assert_eq!(stringify_pat!(|true| false), \"true | false\");\n+\n+    // PatKind::Path\n+    assert_eq!(stringify_pat!(crate::Path), \"crate::Path\");\n+    assert_eq!(stringify_pat!(Path::<u8>), \"Path::<u8>\");\n+    assert_eq!(stringify_pat!(Path::<'static>), \"Path::<'static>\");\n+    assert_eq!(stringify_pat!(<Struct as Trait>::Type), \"<Struct as Trait>::Type\");\n+\n+    // PatKind::Tuple\n+    assert_eq!(stringify_pat!(()), \"()\");\n+    assert_eq!(stringify_pat!((true,)), \"(true,)\");\n+    assert_eq!(stringify_pat!((true, false)), \"(true, false)\");\n+\n+    // PatKind::Box\n+    assert_eq!(stringify_pat!(box pat), \"box pat\");\n+\n+    // PatKind::Ref\n+    assert_eq!(stringify_pat!(&pat), \"&pat\");\n+    assert_eq!(stringify_pat!(&mut pat), \"&mut pat\");\n+\n+    // PatKind::Lit\n+    assert_eq!(stringify_pat!(1_000_i8), \"1_000_i8\");\n+\n+    // PatKind::Range\n+    assert_eq!(stringify_pat!(..1), \"..1\");\n+    assert_eq!(stringify_pat!(0..), \"0 ..\"); // FIXME\n+    assert_eq!(stringify_pat!(0..1), \"0 ..1\");\n+    assert_eq!(stringify_pat!(0..=1), \"0 ..=1\");\n+    assert_eq!(stringify_pat!(-2..=-1), \"-2 ..=-1\");\n+\n+    // PatKind::Slice\n+    assert_eq!(stringify_pat!([]), \"[]\");\n+    assert_eq!(stringify_pat!([true]), \"[true]\");\n+    assert_eq!(stringify_pat!([true,]), \"[true]\");\n+    assert_eq!(stringify_pat!([true, false]), \"[true, false]\");\n+\n+    // PatKind::Rest\n+    assert_eq!(stringify_pat!(..), \"..\");\n+\n+    // PatKind::Paren\n+    assert_eq!(stringify_pat!((pat)), \"(pat)\");\n+\n+    // PatKind::MacCall\n+    assert_eq!(stringify_pat!(mac!(...)), \"mac!(...)\");\n+    assert_eq!(stringify_pat!(mac![...]), \"mac![...]\");\n+    assert_eq!(stringify_pat!(mac! { ... }), \"mac! { ... }\");\n+}\n+\n+#[test]\n+fn test_path() {\n+    assert_eq!(stringify_path!(thing), \"thing\");\n+    assert_eq!(stringify_path!(m::thing), \"m::thing\");\n+    assert_eq!(stringify_path!(self::thing), \"self::thing\");\n+    assert_eq!(stringify_path!(crate::thing), \"crate::thing\");\n+    assert_eq!(stringify_path!(Self::thing), \"Self::thing\");\n+    assert_eq!(stringify_path!(Self<'static>), \"Self<'static>\");\n+    assert_eq!(stringify_path!(Self::<'static>), \"Self<'static>\");\n+    assert_eq!(stringify_path!(Self()), \"Self()\");\n+    assert_eq!(stringify_path!(Self() -> ()), \"Self() -> ()\");\n+}\n+\n+#[test]\n+fn test_stmt() {\n+    // StmtKind::Local\n+    assert_eq!(stringify_stmt!(let _), \"let _;\");\n+    assert_eq!(stringify_stmt!(let x = true), \"let x = true;\");\n+    assert_eq!(stringify_stmt!(let x: bool = true), \"let x: bool = true;\");\n+\n+    // StmtKind::Item\n+    assert_eq!(\n+        stringify_stmt!(\n+            struct S;\n+        ),\n+        \"struct S;\",\n+    );\n+\n+    // StmtKind::Expr\n+    assert_eq!(stringify_stmt!(loop {}), \"loop {}\");\n+\n+    // StmtKind::Semi\n+    assert_eq!(stringify_stmt!(1 + 1), \"1 + 1;\");\n+\n+    // StmtKind::Empty\n+    assert_eq!(stringify_stmt!(;), \";\");\n+\n+    // StmtKind::MacCall\n+    assert_eq!(stringify_stmt!(mac!(...)), \"mac!(...)\");\n+    assert_eq!(stringify_stmt!(mac![...]), \"mac![...]\");\n+    assert_eq!(stringify_stmt!(mac! { ... }), \"mac! { ... }\");\n+}\n+\n+#[test]\n+fn test_ty() {\n+    // TyKind::Slice\n+    assert_eq!(stringify_ty!([T]), \"[T]\");\n+\n+    // TyKind::Array\n+    assert_eq!(stringify_ty!([T; 0]), \"[T; 0]\");\n+\n+    // TyKind::Ptr\n+    assert_eq!(stringify_ty!(*const T), \"*const T\");\n+    assert_eq!(stringify_ty!(*mut T), \"*mut T\");\n+\n+    // TyKind::Rptr\n+    assert_eq!(stringify_ty!(&T), \"&T\");\n+    assert_eq!(stringify_ty!(&mut T), \"&mut T\");\n+    assert_eq!(stringify_ty!(&'a T), \"&'a T\");\n+    assert_eq!(stringify_ty!(&'a mut T), \"&'a mut T\");\n+\n+    // TyKind::BareFn\n+    assert_eq!(stringify_ty!(fn()), \"fn()\");\n+    assert_eq!(stringify_ty!(fn() -> ()), \"fn() -> ()\");\n+    assert_eq!(stringify_ty!(fn(u8)), \"fn(u8)\");\n+    assert_eq!(stringify_ty!(fn(x: u8)), \"fn(x: u8)\");\n+    #[rustfmt::skip]\n+    assert_eq!(stringify_ty!(for<> fn()), \"fn()\");\n+    assert_eq!(stringify_ty!(for<'a> fn()), \"for<'a>fn()\"); // FIXME\n+\n+    // TyKind::Never\n+    assert_eq!(stringify_ty!(!), \"!\");\n+\n+    // TyKind::Tup\n+    assert_eq!(stringify_ty!(()), \"()\");\n+    assert_eq!(stringify_ty!((T,)), \"(T,)\");\n+    assert_eq!(stringify_ty!((T, U)), \"(T, U)\");\n+\n+    // TyKind::Path\n+    assert_eq!(stringify_ty!(T), \"T\");\n+    assert_eq!(stringify_ty!(Ref<'a>), \"Ref<'a>\");\n+    assert_eq!(stringify_ty!(PhantomData<T>), \"PhantomData<T>\");\n+    assert_eq!(stringify_ty!(PhantomData::<T>), \"PhantomData<T>\");\n+    assert_eq!(stringify_ty!(Fn() -> !), \"Fn() -> !\");\n+    assert_eq!(stringify_ty!(Fn(u8) -> !), \"Fn(u8) -> !\");\n+    assert_eq!(stringify_ty!(<Struct as Trait>::Type), \"<Struct as Trait>::Type\");\n+\n+    // TyKind::TraitObject\n+    assert_eq!(stringify_ty!(dyn Send), \"dyn Send\");\n+    assert_eq!(stringify_ty!(dyn Send + 'a), \"dyn Send + 'a\");\n+    assert_eq!(stringify_ty!(dyn 'a + Send), \"dyn 'a + Send\");\n+    assert_eq!(stringify_ty!(dyn ?Sized), \"dyn ?Sized\");\n+    assert_eq!(stringify_ty!(dyn ~const Clone), \"dyn Clone\"); // FIXME\n+    assert_eq!(stringify_ty!(dyn for<'a> Send), \"dyn for<'a> Send\");\n+\n+    // TyKind::ImplTrait\n+    assert_eq!(stringify_ty!(impl Send), \"impl Send\");\n+    assert_eq!(stringify_ty!(impl Send + 'a), \"impl Send + 'a\");\n+    assert_eq!(stringify_ty!(impl 'a + Send), \"impl 'a + Send\");\n+    assert_eq!(stringify_ty!(impl ?Sized), \"impl ?Sized\");\n+    assert_eq!(stringify_ty!(impl ~const Clone), \"impl Clone\"); // FIXME\n+    assert_eq!(stringify_ty!(impl for<'a> Send), \"impl for<'a> Send\");\n+\n+    // TyKind::Paren\n+    assert_eq!(stringify_ty!((T)), \"(T)\");\n+\n+    // TyKind::Infer\n+    assert_eq!(stringify_ty!(_), \"_\");\n+\n+    // TyKind::MacCall\n+    assert_eq!(stringify_ty!(mac!(...)), \"mac!(...)\");\n+    assert_eq!(stringify_ty!(mac![...]), \"mac![...]\");\n+    assert_eq!(stringify_ty!(mac! { ... }), \"mac! { ... }\");\n+}\n+\n+#[test]\n+fn test_vis() {\n+    // VisibilityKind::Public\n+    assert_eq!(stringify_vis!(pub), \"pub \");\n+\n+    // VisibilityKind::Crate\n+    assert_eq!(stringify_vis!(crate), \"crate \");\n+\n+    // VisibilityKind::Restricted\n+    assert_eq!(stringify_vis!(pub(self)), \"pub(self) \");\n+    assert_eq!(stringify_vis!(pub(super)), \"pub(super) \");\n+    assert_eq!(stringify_vis!(pub(in self)), \"pub(self) \");\n+    assert_eq!(stringify_vis!(pub(in super)), \"pub(super) \");\n+    assert_eq!(stringify_vis!(pub(in path::to)), \"pub(in path::to) \");\n+    assert_eq!(stringify_vis!(pub(in ::path::to)), \"pub(in ::path::to) \");\n+    assert_eq!(stringify_vis!(pub(in self::path::to)), \"pub(in self::path::to) \");\n+    assert_eq!(stringify_vis!(pub(in super::path::to)), \"pub(in super::path::to) \");\n+\n+    // VisibilityKind::Inherited\n+    // Directly calling `stringify_vis!()` does not work.\n+    macro_rules! stringify_inherited_vis {\n+        ($vis:vis struct) => {\n+            stringify_vis!($vis)\n+        };\n+    }\n+    assert_eq!(stringify_inherited_vis!(struct), \"\");\n+}"}]}