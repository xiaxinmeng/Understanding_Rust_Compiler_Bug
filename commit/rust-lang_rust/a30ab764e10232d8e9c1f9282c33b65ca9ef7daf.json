{"sha": "a30ab764e10232d8e9c1f9282c33b65ca9ef7daf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzMGFiNzY0ZTEwMjMyZDhlOWMxZjkyODJjMzNiNjVjYTllZjdkYWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-26T12:20:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-26T12:20:06Z"}, "message": "auto merge of #7255 : michaelwoerister/rust/debuginfo, r=jdm\n\nThis PR contains no real code changes. Just some documentation additions in the form of comments and some internal reordering of functions within debuginfo.rs.", "tree": {"sha": "c403e0c1216d5307945ea831c245c243b8fb0126", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c403e0c1216d5307945ea831c245c243b8fb0126"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a30ab764e10232d8e9c1f9282c33b65ca9ef7daf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a30ab764e10232d8e9c1f9282c33b65ca9ef7daf", "html_url": "https://github.com/rust-lang/rust/commit/a30ab764e10232d8e9c1f9282c33b65ca9ef7daf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a30ab764e10232d8e9c1f9282c33b65ca9ef7daf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ec05e02fa5f64aaef922948ce00d25f42e0478d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ec05e02fa5f64aaef922948ce00d25f42e0478d", "html_url": "https://github.com/rust-lang/rust/commit/4ec05e02fa5f64aaef922948ce00d25f42e0478d"}, {"sha": "6eb3c0f30daa0db6fc219694a3028917bb1596af", "url": "https://api.github.com/repos/rust-lang/rust/commits/6eb3c0f30daa0db6fc219694a3028917bb1596af", "html_url": "https://github.com/rust-lang/rust/commit/6eb3c0f30daa0db6fc219694a3028917bb1596af"}], "stats": {"total": 474, "additions": 268, "deletions": 206}, "files": [{"sha": "dae3d58d2be545d379b50a42136a75930a16d40d", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 268, "deletions": 206, "changes": 474, "blob_url": "https://github.com/rust-lang/rust/blob/a30ab764e10232d8e9c1f9282c33b65ca9ef7daf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a30ab764e10232d8e9c1f9282c33b65ca9ef7daf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=a30ab764e10232d8e9c1f9282c33b65ca9ef7daf", "patch": "@@ -8,6 +8,39 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/*!\n+# Debug Info Module\n+\n+This module serves the purpose of generating debug symbols. We use LLVM's\n+[source level debugging](http://llvm.org/docs/SourceLevelDebugging.html) features for generating\n+the debug information. The general principle is this:\n+\n+Given the right metadata in the LLVM IR, the LLVM code generator is able to create DWARF debug\n+symbols for the given code. The [metadata](http://llvm.org/docs/LangRef.html#metadata-type) is\n+structured much like DWARF *debugging information entries* (DIE), representing type information\n+such as datatype layout, function signatures, block layout, variable location and scope information,\n+etc. It is the purpose of this module to generate correct metadata and insert it into the LLVM IR.\n+\n+As the exact format of metadata trees may change between different LLVM versions, we now use LLVM\n+[DIBuilder](http://llvm.org/docs/doxygen/html/classllvm_1_1DIBuilder.html) to create metadata\n+where possible. This will hopefully ease the adaption of this module to future LLVM versions.\n+\n+The public API of the module is a set of functions that will insert the correct metadata into the\n+LLVM IR when called with the right parameters. The module is thus driven from an outside client with\n+functions like `debuginfo::create_local_var(bcx: block, local: @ast::local)`.\n+\n+Internally the module will try to reuse already created metadata by utilizing a cache. All private\n+state used by the module is stored within a DebugContext struct, which in turn is contained in the\n+CrateContext.\n+\n+\n+This file consists of three conceptual sections:\n+1. The public interface of the module\n+2. Module-internal metadata creation functions\n+3. Minor utility functions\n+\n+*/\n+\n use core::prelude::*;\n \n use driver::session;\n@@ -34,20 +67,8 @@ use syntax::{ast, codemap, ast_util, ast_map};\n \n static DW_LANG_RUST: int = 0x9000;\n \n-static CompileUnitTag: int = 17;\n-static FileDescriptorTag: int = 41;\n-static SubprogramTag: int = 46;\n-static SubroutineTag: int = 21;\n-static BasicTypeDescriptorTag: int = 36;\n static AutoVariableTag: int = 256;\n static ArgVariableTag: int = 257;\n-static ReturnVariableTag: int = 258;\n-static LexicalBlockTag: int = 11;\n-static PointerTypeTag: int = 15;\n-static StructureTypeTag: int = 19;\n-static MemberTag: int = 13;\n-static ArrayTypeTag: int = 1;\n-static SubrangeTag: int = 33;\n \n static DW_ATE_boolean: int = 0x02;\n static DW_ATE_float: int = 0x04;\n@@ -56,8 +77,14 @@ static DW_ATE_signed_char: int = 0x06;\n static DW_ATE_unsigned: int = 0x07;\n static DW_ATE_unsigned_char: int = 0x08;\n \n-////////////////\n \n+\n+\n+//=-------------------------------------------------------------------------------------------------\n+//  Public Interface of debuginfo module\n+//=-------------------------------------------------------------------------------------------------\n+\n+/// A context object for maintaining all state needed by the debuginfo module.\n pub struct DebugContext {\n     names: namegen,\n     crate_file: ~str,\n@@ -90,16 +117,6 @@ impl DebugContext {\n     }\n }\n \n-#[inline]\n-fn dbg_cx<'a>(cx: &'a mut CrateContext) -> &'a mut DebugContext {\n-    cx.dbg_cx.get_mut_ref()\n-}\n-\n-#[inline]\n-fn DIB(cx: &CrateContext) -> DIBuilderRef {\n-    cx.dbg_cx.get_ref().builder\n-}\n-\n /// Create any deferred debug metadata nodes\n pub fn finalize(cx: @mut CrateContext) {\n     debug!(\"finalize\");\n@@ -110,6 +127,207 @@ pub fn finalize(cx: @mut CrateContext) {\n     };\n }\n \n+/// Creates debug information for the given local variable.\n+///\n+/// Adds the created metadata nodes directly to the crate's IR.\n+/// The return value should be ignored if called from outside of the debuginfo module.\n+pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n+    let cx = bcx.ccx();\n+\n+    let ident = match local.node.pat.node {\n+      ast::pat_ident(_, pth, _) => ast_util::path_to_ident(pth),\n+      // FIXME this should be handled (#2533)\n+      _ => {\n+        bcx.sess().span_note(local.span, \"debuginfo for pattern bindings NYI\");\n+        return ptr::null();\n+      }\n+    };\n+    let name: &str = cx.sess.str_of(ident);\n+    debug!(\"create_local_var: %s\", name);\n+\n+    let loc = span_start(cx, local.span);\n+    let ty = node_id_type(bcx, local.node.id);\n+    let tymd = create_ty(cx, ty, local.node.ty.span);\n+    let filemd = create_file(cx, loc.file.name);\n+    let context = match bcx.parent {\n+        None => create_function(bcx.fcx),\n+        Some(_) => create_block(bcx)\n+    };\n+\n+    let var_md = do as_c_str(name) |name| { unsafe {\n+        llvm::LLVMDIBuilderCreateLocalVariable(\n+            DIB(cx), AutoVariableTag as u32,\n+            context, name, filemd,\n+            loc.line as c_uint, tymd, false, 0, 0)\n+        }};\n+\n+    // FIXME(#6814) Should use `pat_util::pat_bindings` for pats like (a, b) etc\n+    let llptr = match bcx.fcx.lllocals.find_copy(&local.node.pat.id) {\n+        Some(v) => v,\n+        None => {\n+            bcx.tcx().sess.span_bug(\n+                local.span,\n+                fmt!(\"No entry in lllocals table for %?\", local.node.id));\n+        }\n+    };\n+\n+    set_debug_location(cx, create_block(bcx), loc.line, loc.col.to_uint());\n+    unsafe {\n+        let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(DIB(cx), llptr, var_md, bcx.llbb);\n+        llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n+    }\n+\n+    return var_md;\n+}\n+\n+/// Creates debug information for the given function argument.\n+///\n+/// Adds the created metadata nodes directly to the crate's IR.\n+/// The return value should be ignored if called from outside of the debuginfo module.\n+pub fn create_arg(bcx: block, arg: ast::arg, span: span) -> Option<DIVariable> {\n+    debug!(\"create_arg\");\n+    if true {\n+        // XXX create_arg disabled for now because \"node_id_type(bcx, arg.id)\" below blows\n+        // up: \"error: internal compiler error: node_id_to_type: no type for node `arg (id=10)`\"\n+        return None;\n+    }\n+\n+    let fcx = bcx.fcx;\n+    let cx = fcx.ccx;\n+\n+    let loc = span_start(cx, span);\n+    if \"<intrinsic>\" == loc.file.name {\n+        return None;\n+    }\n+\n+    let ty = node_id_type(bcx, arg.id);\n+    let tymd = create_ty(cx, ty, arg.ty.span);\n+    let filemd = create_file(cx, loc.file.name);\n+    let context = create_function(fcx);\n+\n+    match arg.pat.node {\n+        ast::pat_ident(_, path, _) => {\n+            // XXX: This is wrong; it should work for multiple bindings.\n+            let ident = path.idents.last();\n+            let name: &str = cx.sess.str_of(*ident);\n+            let mdnode = do as_c_str(name) |name| { unsafe {\n+                llvm::LLVMDIBuilderCreateLocalVariable(DIB(cx),\n+                    ArgVariableTag as u32, context, name,\n+                    filemd, loc.line as c_uint, tymd, false, 0, 0)\n+                    // XXX need to pass in a real argument number\n+            }};\n+\n+            let llptr = fcx.llargs.get_copy(&arg.id);\n+            set_debug_location(cx, create_block(bcx), loc.line, loc.col.to_uint());\n+            unsafe {\n+                let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n+                        DIB(cx), llptr, mdnode, bcx.llbb);\n+                llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n+            }\n+            return Some(mdnode);\n+        }\n+        _ => {\n+            return None;\n+        }\n+    }\n+}\n+\n+/// Sets the current debug location at the beginning of the span\n+///\n+/// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...)\n+pub fn update_source_pos(bcx: block, span: span) {\n+    if !bcx.sess().opts.debuginfo || (*span.lo == 0 && *span.hi == 0) {\n+        return;\n+    }\n+    debug!(\"update_source_pos: %s\", bcx.sess().codemap.span_to_str(span));\n+    let loc = span_start(bcx.ccx(), span);\n+    set_debug_location(bcx.ccx(), create_block(bcx), loc.line, loc.col.to_uint())\n+}\n+\n+/// Creates debug information for the given function.\n+///\n+/// Adds the created metadata nodes directly to the crate's IR.\n+/// The return value should be ignored if called from outside of the debuginfo module.\n+pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n+    let cx = fcx.ccx;\n+    let fcx = &mut *fcx;\n+    let span = fcx.span.get();\n+\n+    let (ident, ret_ty, id) = match cx.tcx.items.get_copy(&fcx.id) {\n+      ast_map::node_item(item, _) => {\n+        match item.node {\n+          ast::item_fn(ref decl, _, _, _, _) => {\n+            (item.ident, decl.output, item.id)\n+          }\n+          _ => fcx.ccx.sess.span_bug(item.span, \"create_function: item bound to non-function\")\n+        }\n+      }\n+      ast_map::node_method(method, _, _) => {\n+          (method.ident, method.decl.output, method.id)\n+      }\n+      ast_map::node_expr(expr) => {\n+        match expr.node {\n+          ast::expr_fn_block(ref decl, _) => {\n+            ((dbg_cx(cx).names)(\"fn\"), decl.output, expr.id)\n+          }\n+          _ => fcx.ccx.sess.span_bug(expr.span,\n+                  \"create_function: expected an expr_fn_block here\")\n+        }\n+      }\n+      _ => fcx.ccx.sess.bug(\"create_function: unexpected sort of node\")\n+    };\n+\n+    match dbg_cx(cx).created_functions.find(&id) {\n+        Some(fn_md) => return *fn_md,\n+        None => ()\n+    }\n+\n+    debug!(\"create_function: %s, %s\", cx.sess.str_of(ident), cx.sess.codemap.span_to_str(span));\n+\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n+\n+    let ret_ty_md = if cx.sess.opts.extra_debuginfo {\n+        match ret_ty.node {\n+          ast::ty_nil => ptr::null(),\n+          _ => create_ty(cx, ty::node_id_to_type(cx.tcx, id),\n+                         ret_ty.span)\n+        }\n+    } else {\n+        ptr::null()\n+    };\n+\n+    let fn_ty = unsafe {\n+        llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx),\n+            file_md, create_DIArray(DIB(cx), [ret_ty_md]))\n+    };\n+\n+    let fn_md =\n+        do as_c_str(cx.sess.str_of(ident)) |name| {\n+        do as_c_str(cx.sess.str_of(ident)) |linkage| { unsafe {\n+            llvm::LLVMDIBuilderCreateFunction(\n+                DIB(cx),\n+                file_md,\n+                name, linkage,\n+                file_md, loc.line as c_uint,\n+                fn_ty, false, true,\n+                loc.line as c_uint,\n+                FlagPrototyped as c_uint,\n+                cx.sess.opts.optimize != session::No,\n+                fcx.llfn, ptr::null(), ptr::null())\n+            }}};\n+\n+    dbg_cx(cx).created_functions.insert(id, fn_md);\n+    return fn_md;\n+}\n+\n+\n+\n+\n+//=-------------------------------------------------------------------------------------------------\n+// Module-Internal debug info creation functions\n+//=-------------------------------------------------------------------------------------------------\n+\n fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n     return unsafe {\n         llvm::LLVMDIBuilderGetOrCreateArray(builder, vec::raw::to_ptr(arr), arr.len() as u32)\n@@ -160,10 +378,7 @@ fn create_file(cx: @mut CrateContext, full_path: &str) -> DIFile {\n     return file_md;\n }\n \n-/// Return codemap::Loc corresponding to the beginning of the span\n-fn span_start(cx: &CrateContext, span: span) -> codemap::Loc {\n-    return cx.sess.codemap.lookup_char_pos(span.lo);\n-}\n+\n \n fn create_block(bcx: block) -> DILexicalBlock {\n     let mut bcx = bcx;\n@@ -205,10 +420,7 @@ fn create_block(bcx: block) -> DILexicalBlock {\n     return block_md;\n }\n \n-fn size_and_align_of(cx: @mut CrateContext, t: ty::t) -> (uint, uint) {\n-    let llty = type_of::type_of(cx, t);\n-    (machine::llsize_of_real(cx, llty), machine::llalign_of_min(cx, llty))\n-}\n+\n \n fn create_basic_type(cx: @mut CrateContext, t: ty::t, _span: span) -> DIType {\n     let ty_id = ty::type_id(t);\n@@ -252,6 +464,9 @@ fn create_basic_type(cx: @mut CrateContext, t: ty::t, _span: span) -> DIType {\n                 size * 8 as u64, align * 8 as u64, encoding as c_uint)\n         }};\n \n+    // One could think that this call is not necessary, as the create_ty() function will insert the\n+    // type descriptor into the cache anyway. Mind, however, that create_basic_type() is also called\n+    // directly from other functions (e.g. create_boxed_type()).\n     dbg_cx(cx).created_types.insert(ty_id, ty_md);\n     return ty_md;\n }\n@@ -324,11 +539,6 @@ impl StructContext {\n     }\n }\n \n-#[inline]\n-fn roundup(x: uint, a: uint) -> uint {\n-    ((x + (a - 1)) / a) * a\n-}\n-\n fn create_struct(cx: @mut CrateContext, t: ty::t, fields: ~[ty::field], span: span)\n                 -> DICompositeType {\n     let loc = span_start(cx, span);\n@@ -579,103 +789,6 @@ fn create_ty(cx: @mut CrateContext, t: ty::t, span: span) -> DIType {\n     return ty_md;\n }\n \n-pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n-    let cx = bcx.ccx();\n-\n-    let ident = match local.node.pat.node {\n-      ast::pat_ident(_, pth, _) => ast_util::path_to_ident(pth),\n-      // FIXME this should be handled (#2533)\n-      _ => {\n-        bcx.sess().span_note(local.span, \"debuginfo for pattern bindings NYI\");\n-        return ptr::null();\n-      }\n-    };\n-    let name: &str = cx.sess.str_of(ident);\n-    debug!(\"create_local_var: %s\", name);\n-\n-    let loc = span_start(cx, local.span);\n-    let ty = node_id_type(bcx, local.node.id);\n-    let tymd = create_ty(cx, ty, local.node.ty.span);\n-    let filemd = create_file(cx, loc.file.name);\n-    let context = match bcx.parent {\n-        None => create_function(bcx.fcx),\n-        Some(_) => create_block(bcx)\n-    };\n-\n-    let var_md = do as_c_str(name) |name| { unsafe {\n-        llvm::LLVMDIBuilderCreateLocalVariable(\n-            DIB(cx), AutoVariableTag as u32,\n-            context, name, filemd,\n-            loc.line as c_uint, tymd, false, 0, 0)\n-        }};\n-\n-    // FIXME(#6814) Should use `pat_util::pat_bindings` for pats like (a, b) etc\n-    let llptr = match bcx.fcx.lllocals.find_copy(&local.node.pat.id) {\n-        Some(v) => v,\n-        None => {\n-            bcx.tcx().sess.span_bug(\n-                local.span,\n-                fmt!(\"No entry in lllocals table for %?\", local.node.id));\n-        }\n-    };\n-\n-    set_debug_location(cx, create_block(bcx), loc.line, loc.col.to_uint());\n-    unsafe {\n-        let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(DIB(cx), llptr, var_md, bcx.llbb);\n-        llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n-    }\n-\n-    return var_md;\n-}\n-\n-pub fn create_arg(bcx: block, arg: ast::arg, span: span) -> Option<DIVariable> {\n-    debug!(\"create_arg\");\n-    if true {\n-        // XXX create_arg disabled for now because \"node_id_type(bcx, arg.id)\" below blows\n-        // up: \"error: internal compiler error: node_id_to_type: no type for node `arg (id=10)`\"\n-        return None;\n-    }\n-\n-    let fcx = bcx.fcx;\n-    let cx = fcx.ccx;\n-\n-    let loc = span_start(cx, span);\n-    if \"<intrinsic>\" == loc.file.name {\n-        return None;\n-    }\n-\n-    let ty = node_id_type(bcx, arg.id);\n-    let tymd = create_ty(cx, ty, arg.ty.span);\n-    let filemd = create_file(cx, loc.file.name);\n-    let context = create_function(fcx);\n-\n-    match arg.pat.node {\n-        ast::pat_ident(_, path, _) => {\n-            // XXX: This is wrong; it should work for multiple bindings.\n-            let ident = path.idents.last();\n-            let name: &str = cx.sess.str_of(*ident);\n-            let mdnode = do as_c_str(name) |name| { unsafe {\n-                llvm::LLVMDIBuilderCreateLocalVariable(DIB(cx),\n-                    ArgVariableTag as u32, context, name,\n-                    filemd, loc.line as c_uint, tymd, false, 0, 0)\n-                    // XXX need to pass in a real argument number\n-            }};\n-\n-            let llptr = fcx.llargs.get_copy(&arg.id);\n-            set_debug_location(cx, create_block(bcx), loc.line, loc.col.to_uint());\n-            unsafe {\n-                let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n-                        DIB(cx), llptr, mdnode, bcx.llbb);\n-                llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n-            }\n-            return Some(mdnode);\n-        }\n-        _ => {\n-            return None;\n-        }\n-    }\n-}\n-\n fn set_debug_location(cx: @mut CrateContext, scope: DIScope, line: uint, col: uint) {\n     if dbg_cx(cx).curr_loc == (line, col) {\n         return;\n@@ -692,85 +805,34 @@ fn set_debug_location(cx: @mut CrateContext, scope: DIScope, line: uint, col: ui\n     }\n }\n \n-/// Set current debug location at the beginning of the span\n-pub fn update_source_pos(bcx: block, span: span) {\n-    if !bcx.sess().opts.debuginfo || (*span.lo == 0 && *span.hi == 0) {\n-        return;\n-    }\n-    debug!(\"update_source_pos: %s\", bcx.sess().codemap.span_to_str(span));\n-    let loc = span_start(bcx.ccx(), span);\n-    set_debug_location(bcx.ccx(), create_block(bcx), loc.line, loc.col.to_uint())\n-}\n \n-pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n-    let cx = fcx.ccx;\n-    let fcx = &mut *fcx;\n-    let span = fcx.span.get();\n \n-    let (ident, ret_ty, id) = match cx.tcx.items.get_copy(&fcx.id) {\n-      ast_map::node_item(item, _) => {\n-        match item.node {\n-          ast::item_fn(ref decl, _, _, _, _) => {\n-            (item.ident, decl.output, item.id)\n-          }\n-          _ => fcx.ccx.sess.span_bug(item.span, \"create_function: item bound to non-function\")\n-        }\n-      }\n-      ast_map::node_method(method, _, _) => {\n-          (method.ident, method.decl.output, method.id)\n-      }\n-      ast_map::node_expr(expr) => {\n-        match expr.node {\n-          ast::expr_fn_block(ref decl, _) => {\n-            ((dbg_cx(cx).names)(\"fn\"), decl.output, expr.id)\n-          }\n-          _ => fcx.ccx.sess.span_bug(expr.span,\n-                  \"create_function: expected an expr_fn_block here\")\n-        }\n-      }\n-      _ => fcx.ccx.sess.bug(\"create_function: unexpected sort of node\")\n-    };\n-\n-    match dbg_cx(cx).created_functions.find(&id) {\n-        Some(fn_md) => return *fn_md,\n-        None => ()\n-    }\n \n-    debug!(\"create_function: %s, %s\", cx.sess.str_of(ident), cx.sess.codemap.span_to_str(span));\n+//=-------------------------------------------------------------------------------------------------\n+//  Utility Functions\n+//=-------------------------------------------------------------------------------------------------\n \n-    let loc = span_start(cx, span);\n-    let file_md = create_file(cx, loc.file.name);\n+#[inline]\n+fn roundup(x: uint, a: uint) -> uint {\n+    ((x + (a - 1)) / a) * a\n+}\n \n-    let ret_ty_md = if cx.sess.opts.extra_debuginfo {\n-        match ret_ty.node {\n-          ast::ty_nil => ptr::null(),\n-          _ => create_ty(cx, ty::node_id_to_type(cx.tcx, id),\n-                         ret_ty.span)\n-        }\n-    } else {\n-        ptr::null()\n-    };\n+/// Return codemap::Loc corresponding to the beginning of the span\n+fn span_start(cx: &CrateContext, span: span) -> codemap::Loc {\n+    return cx.sess.codemap.lookup_char_pos(span.lo);\n+}\n \n-    let fn_ty = unsafe {\n-        llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx),\n-            file_md, create_DIArray(DIB(cx), [ret_ty_md]))\n-    };\n+fn size_and_align_of(cx: @mut CrateContext, t: ty::t) -> (uint, uint) {\n+    let llty = type_of::type_of(cx, t);\n+    (machine::llsize_of_real(cx, llty), machine::llalign_of_min(cx, llty))\n+}\n \n-    let fn_md =\n-        do as_c_str(cx.sess.str_of(ident)) |name| {\n-        do as_c_str(cx.sess.str_of(ident)) |linkage| { unsafe {\n-            llvm::LLVMDIBuilderCreateFunction(\n-                DIB(cx),\n-                file_md,\n-                name, linkage,\n-                file_md, loc.line as c_uint,\n-                fn_ty, false, true,\n-                loc.line as c_uint,\n-                FlagPrototyped as c_uint,\n-                cx.sess.opts.optimize != session::No,\n-                fcx.llfn, ptr::null(), ptr::null())\n-            }}};\n+#[inline]\n+fn dbg_cx<'a>(cx: &'a mut CrateContext) -> &'a mut DebugContext {\n+    cx.dbg_cx.get_mut_ref()\n+}\n \n-    dbg_cx(cx).created_functions.insert(id, fn_md);\n-    return fn_md;\n+#[inline]\n+fn DIB(cx: &CrateContext) -> DIBuilderRef {\n+    cx.dbg_cx.get_ref().builder\n }"}]}