{"sha": "58df4664bb144514880917cbfdab40af290b7350", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4ZGY0NjY0YmIxNDQ1MTQ4ODA5MTdjYmZkYWI0MGFmMjkwYjczNTA=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-06-23T00:30:27Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-06-23T00:30:27Z"}, "message": "Merge pull request #107 from cassiersg/rewrite\n\nAdd a Rewrite trait", "tree": {"sha": "6214bd5b717653ebacb0a3d62d2a645a7e8f1df4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6214bd5b717653ebacb0a3d62d2a645a7e8f1df4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58df4664bb144514880917cbfdab40af290b7350", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58df4664bb144514880917cbfdab40af290b7350", "html_url": "https://github.com/rust-lang/rust/commit/58df4664bb144514880917cbfdab40af290b7350", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58df4664bb144514880917cbfdab40af290b7350/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c10bfecdc2869df8b42675c395b6c1e33ef674e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c10bfecdc2869df8b42675c395b6c1e33ef674e7", "html_url": "https://github.com/rust-lang/rust/commit/c10bfecdc2869df8b42675c395b6c1e33ef674e7"}, {"sha": "b7ead806f4309485ec1cf27eb04fc9c3d524895d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7ead806f4309485ec1cf27eb04fc9c3d524895d", "html_url": "https://github.com/rust-lang/rust/commit/b7ead806f4309485ec1cf27eb04fc9c3d524895d"}], "stats": {"total": 436, "additions": 245, "deletions": 191}, "files": [{"sha": "85ea41fb060c8b7919c496c6778d25186111e99f", "filename": "src/expr.rs", "status": "modified", "additions": 197, "deletions": 188, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/58df4664bb144514880917cbfdab40af290b7350/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58df4664bb144514880917cbfdab40af290b7350/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=58df4664bb144514880917cbfdab40af290b7350", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use visitor::FmtVisitor;\n use utils::*;\n use lists::{write_list, ListFormatting, SeparatorTactic, ListTactic};\n+use rewrite::{Rewrite, RewriteContext};\n \n use syntax::{ast, ptr};\n use syntax::codemap::{Pos, Span};\n@@ -19,194 +19,239 @@ use syntax::print::pprust;\n \n use MIN_STRING;\n \n-impl<'a> FmtVisitor<'a> {\n-    fn rewrite_string_lit(&mut self, s: &str, span: Span, width: usize, offset: usize) -> String {\n-        // FIXME I bet this stomps unicode escapes in the source string\n-\n-        // Check if there is anything to fix: we always try to fixup multi-line\n-        // strings, or if the string is too long for the line.\n-        let l_loc = self.codemap.lookup_char_pos(span.lo);\n-        let r_loc = self.codemap.lookup_char_pos(span.hi);\n-        if l_loc.line == r_loc.line && r_loc.col.to_usize() <= config!(max_width) {\n-            return self.snippet(span);\n+impl Rewrite for ast::Expr {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+        match self.node {\n+            ast::Expr_::ExprLit(ref l) => {\n+                match l.node {\n+                    ast::Lit_::LitStr(ref is, _) => {\n+                        let result = rewrite_string_lit(context, &is, l.span, width, offset);\n+                        debug!(\"string lit: `{:?}`\", result);\n+                        return result;\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            ast::Expr_::ExprCall(ref callee, ref args) => {\n+                return rewrite_call(context, callee, args, width, offset);\n+            }\n+            ast::Expr_::ExprParen(ref subexpr) => {\n+                return rewrite_paren(context, subexpr, width, offset);\n+            }\n+            ast::Expr_::ExprStruct(ref path, ref fields, ref base) => {\n+                return rewrite_struct_lit(context, path,\n+                                               fields,\n+                                               base.as_ref().map(|e| &**e),\n+                                               width,\n+                                               offset);\n+            }\n+            ast::Expr_::ExprTup(ref items) => {\n+                return rewrite_tuple_lit(context, items, width, offset);\n+            }\n+            _ => {}\n         }\n \n-        // TODO if lo.col > IDEAL - 10, start a new line (need cur indent for that)\n-\n-        let s = s.escape_default();\n+        context.codemap.span_to_snippet(self.span).ok()\n+    }\n+}\n \n-        let offset = offset + 1;\n-        let indent = make_indent(offset);\n-        let indent = &indent;\n+fn rewrite_string_lit(context: &RewriteContext, s: &str, span: Span, width: usize, offset: usize) -> Option<String> {\n+    // FIXME I bet this stomps unicode escapes in the source string\n \n-        let mut cur_start = 0;\n-        let mut result = String::with_capacity(round_up_to_power_of_two(s.len()));\n-        result.push('\"');\n-        loop {\n-            let max_chars = if cur_start == 0 {\n-                // First line.\n-                width - 2 // 2 = \" + \\\n-            } else {\n-                config!(max_width) - offset - 1 // 1 = either \\ or ;\n-            };\n+    // Check if there is anything to fix: we always try to fixup multi-line\n+    // strings, or if the string is too long for the line.\n+    let l_loc = context.codemap.lookup_char_pos(span.lo);\n+    let r_loc = context.codemap.lookup_char_pos(span.hi);\n+    if l_loc.line == r_loc.line && r_loc.col.to_usize() <= config!(max_width) {\n+        return context.codemap.span_to_snippet(span).ok();\n+    }\n \n-            let mut cur_end = cur_start + max_chars;\n+    // TODO if lo.col > IDEAL - 10, start a new line (need cur indent for that)\n \n-            if cur_end >= s.len() {\n-                result.push_str(&s[cur_start..]);\n-                break;\n-            }\n+    let s = s.escape_default();\n \n-            // Make sure we're on a char boundary.\n-            cur_end = next_char(&s, cur_end);\n+    let offset = offset + 1;\n+    let indent = make_indent(offset);\n+    let indent = &indent;\n \n-            // Push cur_end left until we reach whitespace\n-            while !s.char_at(cur_end-1).is_whitespace() {\n-                cur_end = prev_char(&s, cur_end);\n+    let mut cur_start = 0;\n+    let mut result = String::with_capacity(round_up_to_power_of_two(s.len()));\n+    result.push('\"');\n+    loop {\n+        let max_chars = if cur_start == 0 {\n+            // First line.\n+            width - 2 // 2 = \" + \\\n+        } else {\n+            config!(max_width) - offset - 1 // 1 = either \\ or ;\n+        };\n \n-                if cur_end - cur_start < MIN_STRING {\n-                    // We can't break at whitespace, fall back to splitting\n-                    // anywhere that doesn't break an escape sequence\n-                    cur_end = next_char(&s, cur_start + max_chars);\n-                    while s.char_at(prev_char(&s, cur_end)) == '\\\\' {\n-                        cur_end = prev_char(&s, cur_end);\n-                    }\n-                    break;\n-                }\n-            }\n-            // Make sure there is no whitespace to the right of the break.\n-            while cur_end < s.len() && s.char_at(cur_end).is_whitespace() {\n-                cur_end = next_char(&s, cur_end+1);\n-            }\n-            result.push_str(&s[cur_start..cur_end]);\n-            result.push_str(\"\\\\\\n\");\n-            result.push_str(indent);\n+        let mut cur_end = cur_start + max_chars;\n \n-            cur_start = cur_end;\n+        if cur_end >= s.len() {\n+            result.push_str(&s[cur_start..]);\n+            break;\n         }\n-        result.push('\"');\n-\n-        result\n-    }\n \n-    fn rewrite_call(&mut self,\n-                    callee: &ast::Expr,\n-                    args: &[ptr::P<ast::Expr>],\n-                    width: usize,\n-                    offset: usize)\n-        -> String\n-    {\n-        debug!(\"rewrite_call, width: {}, offset: {}\", width, offset);\n+        // Make sure we're on a char boundary.\n+        cur_end = next_char(&s, cur_end);\n \n-        // TODO using byte lens instead of char lens (and probably all over the place too)\n-        let callee_str = self.rewrite_expr(callee, width, offset);\n-        debug!(\"rewrite_call, callee_str: `{}`\", callee_str);\n-        // 2 is for parens.\n-        let remaining_width = width - callee_str.len() - 2;\n-        let offset = callee_str.len() + 1 + offset;\n-        let arg_count = args.len();\n-\n-        let args_str = if arg_count > 0 {\n-            let args: Vec<_> = args.iter().map(|e| (self.rewrite_expr(e,\n-                                                                      remaining_width,\n-                                                                      offset), String::new())).collect();\n-            let fmt = ListFormatting {\n-                tactic: ListTactic::HorizontalVertical,\n-                separator: \",\",\n-                trailing_separator: SeparatorTactic::Never,\n-                indent: offset,\n-                h_width: remaining_width,\n-                v_width: remaining_width,\n-            };\n-            write_list(&args, &fmt)\n-        } else {\n-            String::new()\n-        };\n+        // Push cur_end left until we reach whitespace\n+        while !s.char_at(cur_end-1).is_whitespace() {\n+            cur_end = prev_char(&s, cur_end);\n \n-        format!(\"{}({})\", callee_str, args_str)\n-    }\n+            if cur_end - cur_start < MIN_STRING {\n+                // We can't break at whitespace, fall back to splitting\n+                // anywhere that doesn't break an escape sequence\n+                cur_end = next_char(&s, cur_start + max_chars);\n+                while s.char_at(prev_char(&s, cur_end)) == '\\\\' {\n+                    cur_end = prev_char(&s, cur_end);\n+                }\n+                break;\n+            }\n+        }\n+        // Make sure there is no whitespace to the right of the break.\n+        while cur_end < s.len() && s.char_at(cur_end).is_whitespace() {\n+            cur_end = next_char(&s, cur_end+1);\n+        }\n+        result.push_str(&s[cur_start..cur_end]);\n+        result.push_str(\"\\\\\\n\");\n+        result.push_str(indent);\n \n-    fn rewrite_paren(&mut self, subexpr: &ast::Expr, width: usize, offset: usize) -> String {\n-        debug!(\"rewrite_paren, width: {}, offset: {}\", width, offset);\n-        // 1 is for opening paren, 2 is for opening+closing, we want to keep the closing\n-        // paren on the same line as the subexpr\n-        let subexpr_str = self.rewrite_expr(subexpr, width-2, offset+1);\n-        debug!(\"rewrite_paren, subexpr_str: `{}`\", subexpr_str);\n-        format!(\"({})\", subexpr_str)\n+        cur_start = cur_end;\n     }\n+    result.push('\"');\n \n-    fn rewrite_struct_lit(&mut self,\n-                          path: &ast::Path,\n-                          fields: &[ast::Field],\n-                          base: Option<&ast::Expr>,\n-                          width: usize,\n-                          offset: usize)\n-        -> String\n-    {\n-        debug!(\"rewrite_struct_lit: width {}, offset {}\", width, offset);\n-        assert!(fields.len() > 0 || base.is_some());\n+    Some(result)\n+}\n \n-        let path_str = pprust::path_to_string(path);\n-        // Foo { a: Foo } - indent is +3, width is -5.\n-        let indent = offset + path_str.len() + 3;\n-        let budget = width - (path_str.len() + 5);\n+fn rewrite_call(context: &RewriteContext,\n+                callee: &ast::Expr,\n+                args: &[ptr::P<ast::Expr>],\n+                width: usize,\n+                offset: usize)\n+        -> Option<String>\n+{\n+    debug!(\"rewrite_call, width: {}, offset: {}\", width, offset);\n \n-        let mut field_strs: Vec<_> =\n-            fields.iter().map(|f| self.rewrite_field(f, budget, indent)).collect();\n-        if let Some(expr) = base {\n-            // Another 2 on the width/indent for the ..\n-            field_strs.push(format!(\"..{}\", self.rewrite_expr(expr, budget - 2, indent + 2)))\n-        }\n+    // TODO using byte lens instead of char lens (and probably all over the place too)\n+    let callee_str = try_opt!(callee.rewrite(context, width, offset));\n+    debug!(\"rewrite_call, callee_str: `{:?}`\", callee_str);\n+    // 2 is for parens.\n+    let remaining_width = width - callee_str.len() - 2;\n+    let offset = callee_str.len() + 1 + offset;\n+    let arg_count = args.len();\n \n-        // FIXME comments\n-        let field_strs: Vec<_> = field_strs.into_iter().map(|s| (s, String::new())).collect();\n+    let args_str = if arg_count > 0 {\n+        let args_rewritten: Vec<_> =\n+            try_opt!(args.iter()\n+                         .map(|arg| arg.rewrite(context, remaining_width, offset)\n+                                       .map(|arg_str| (arg_str, String::new())))\n+                         .collect());\n         let fmt = ListFormatting {\n             tactic: ListTactic::HorizontalVertical,\n             separator: \",\",\n-            trailing_separator: if base.is_some() {\n-                    SeparatorTactic::Never\n-                } else {\n-                    config!(struct_lit_trailing_comma)\n-                },\n-            indent: indent,\n-            h_width: budget,\n-            v_width: budget,\n+            trailing_separator: SeparatorTactic::Never,\n+            indent: offset,\n+            h_width: remaining_width,\n+            v_width: remaining_width,\n         };\n-        let fields_str = write_list(&field_strs, &fmt);\n-        format!(\"{} {{ {} }}\", path_str, fields_str)\n+        write_list(&args_rewritten, &fmt)\n+    } else {\n+        String::new()\n+    };\n+\n+    Some(format!(\"{}({})\", callee_str, args_str))\n+}\n+\n+fn rewrite_paren(context: &RewriteContext, subexpr: &ast::Expr, width: usize, offset: usize) -> Option<String> {\n+    debug!(\"rewrite_paren, width: {}, offset: {}\", width, offset);\n+    // 1 is for opening paren, 2 is for opening+closing, we want to keep the closing\n+    // paren on the same line as the subexpr\n+    let subexpr_str = subexpr.rewrite(context, width-2, offset+1);\n+    debug!(\"rewrite_paren, subexpr_str: `{:?}`\", subexpr_str);\n+    subexpr_str.map(|s| format!(\"({})\", s))\n+}\n+\n+fn rewrite_struct_lit(context: &RewriteContext,\n+                      path: &ast::Path,\n+                      fields: &[ast::Field],\n+                      base: Option<&ast::Expr>,\n+                      width: usize,\n+                      offset: usize)\n+        -> Option<String>\n+{\n+    debug!(\"rewrite_struct_lit: width {}, offset {}\", width, offset);\n+    assert!(fields.len() > 0 || base.is_some());\n+\n+    let path_str = pprust::path_to_string(path);\n+    // Foo { a: Foo } - indent is +3, width is -5.\n+    let indent = offset + path_str.len() + 3;\n+    let budget = width - (path_str.len() + 5);\n+\n+    let field_strs: Vec<_> =\n+        try_opt!(fields.iter()\n+                       .map(|field| rewrite_field(context, field, budget, indent))\n+                       .chain(base.iter()\n+                                  .map(|expr| expr.rewrite(context,\n+                                                           // 2 = \"..\"\n+                                                           budget - 2,\n+                                                           indent + 2)\n+                                                  .map(|s| format!(\"..{}\", s))))\n+                       .collect());\n+    // FIXME comments\n+    let field_strs: Vec<_> = field_strs.into_iter().map(|s| (s, String::new())).collect();\n+    let fmt = ListFormatting {\n+        tactic: ListTactic::HorizontalVertical,\n+        separator: \",\",\n+        trailing_separator: if base.is_some() {\n+            SeparatorTactic::Never\n+        } else {\n+            config!(struct_lit_trailing_comma)\n+        },\n+        indent: indent,\n+        h_width: budget,\n+        v_width: budget,\n+    };\n+    let fields_str = write_list(&field_strs, &fmt);\n+    Some(format!(\"{} {{ {} }}\", path_str, fields_str))\n \n         // FIXME if the usual multi-line layout is too wide, we should fall back to\n         // Foo {\n         //     a: ...,\n         // }\n-    }\n+}\n \n-    fn rewrite_field(&mut self, field: &ast::Field, width: usize, offset: usize) -> String {\n-        let name = &token::get_ident(field.ident.node);\n-        let overhead = name.len() + 2;\n-        let expr = self.rewrite_expr(&field.expr, width - overhead, offset + overhead);\n-        format!(\"{}: {}\", name, expr)\n-    }\n+fn rewrite_field(context: &RewriteContext, field: &ast::Field, width: usize, offset: usize) -> Option<String> {\n+    let name = &token::get_ident(field.ident.node);\n+    let overhead = name.len() + 2;\n+    let expr = field.expr.rewrite(context, width - overhead, offset + overhead);\n+    expr.map(|s| format!(\"{}: {}\", name, s))\n+}\n \n-    fn rewrite_tuple_lit(&mut self, items: &[ptr::P<ast::Expr>], width: usize, offset: usize)\n-        -> String {\n+fn rewrite_tuple_lit(context: &RewriteContext,\n+                     items: &[ptr::P<ast::Expr>],\n+                     width: usize,\n+                     offset: usize)\n+    -> Option<String> {\n         // opening paren\n         let indent = offset + 1;\n         // In case of length 1, need a trailing comma\n         if items.len() == 1 {\n-            return format!(\"({},)\", self.rewrite_expr(&*items[0], width - 3, indent));\n+            return items[0].rewrite(context, width - 3, indent).map(|s| format!(\"({},)\", s));\n         }\n         // Only last line has width-1 as budget, other may take max_width\n         let item_strs: Vec<_> =\n-            items.iter()\n-                 .enumerate()\n-                 .map(|(i, item)| self.rewrite_expr(\n-                    item,\n-                    // last line : given width (minus \"(\"+\")\"), other lines : max_width\n-                    // (minus \"(\"+\",\"))\n-                    if i == items.len() - 1 { width - 2 } else { config!(max_width) - indent - 2 },\n-                    indent))\n-                 .collect();\n+            try_opt!(items.iter()\n+                          .enumerate()\n+                          .map(|(i, item)| {\n+                              let rem_width = if i == items.len() - 1 {\n+                                  width - 2\n+                              } else {\n+                                  config!(max_width) - indent - 2\n+                              };\n+                              item.rewrite(context, rem_width, indent)\n+                          })\n+                          .collect());\n         let tactics = if item_strs.iter().any(|s| s.contains('\\n')) {\n             ListTactic::Vertical\n         } else {\n@@ -223,41 +268,5 @@ impl<'a> FmtVisitor<'a> {\n             v_width: width - 2,\n         };\n         let item_str = write_list(&item_strs, &fmt);\n-        format!(\"({})\", item_str)\n-    }\n-\n-\n-    pub fn rewrite_expr(&mut self, expr: &ast::Expr, width: usize, offset: usize) -> String {\n-        match expr.node {\n-            ast::Expr_::ExprLit(ref l) => {\n-                match l.node {\n-                    ast::Lit_::LitStr(ref is, _) => {\n-                        let result = self.rewrite_string_lit(&is, l.span, width, offset);\n-                        debug!(\"string lit: `{}`\", result);\n-                        return result;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            ast::Expr_::ExprCall(ref callee, ref args) => {\n-                return self.rewrite_call(callee, args, width, offset);\n-            }\n-            ast::Expr_::ExprParen(ref subexpr) => {\n-                return self.rewrite_paren(subexpr, width, offset);\n-            }\n-            ast::Expr_::ExprStruct(ref path, ref fields, ref base) => {\n-                return self.rewrite_struct_lit(path,\n-                                               fields,\n-                                               base.as_ref().map(|e| &**e),\n-                                               width,\n-                                               offset);\n-            }\n-            ast::Expr_::ExprTup(ref items) => {\n-                return self.rewrite_tuple_lit(items, width, offset);\n-            }\n-            _ => {}\n-        }\n-\n-        self.snippet(expr.span)\n+        Some(format!(\"({})\", item_str))\n     }\n-}"}, {"sha": "1b360433e94b2a8a4826b2ea45321ffd0101b485", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58df4664bb144514880917cbfdab40af290b7350/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58df4664bb144514880917cbfdab40af290b7350/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=58df4664bb144514880917cbfdab40af290b7350", "patch": "@@ -59,6 +59,7 @@ mod types;\n mod expr;\n mod imports;\n mod issues;\n+mod rewrite;\n \n const MIN_STRING: usize = 10;\n // When we get scoped annotations, we should have rustfmt::skip."}, {"sha": "354e9b17061de3bf52ba122ab9dd772410db5cf5", "filename": "src/rewrite.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/58df4664bb144514880917cbfdab40af290b7350/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58df4664bb144514880917cbfdab40af290b7350/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=58df4664bb144514880917cbfdab40af290b7350", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A generic trait to abstract the rewriting of an element (of the AST).\n+\n+use syntax::codemap::CodeMap;\n+\n+pub trait Rewrite {\n+    /// Rewrite self into offset and width.\n+    /// `offset` is the indentation of the first line. The next lines\n+    /// should begin with a least `offset` spaces (except backwards\n+    /// indentation). The first line should not begin with indentation.\n+    /// `width` is the maximum number of characters on the last line\n+    /// (excluding offset). The width of other lines is not limited by\n+    /// `width`.\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String>;\n+}\n+\n+pub struct RewriteContext<'a> {\n+    pub codemap: &'a CodeMap,\n+}"}, {"sha": "795c0d983093a85a83d841ed013ca319c5114a09", "filename": "src/utils.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/58df4664bb144514880917cbfdab40af290b7350/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58df4664bb144514880917cbfdab40af290b7350/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=58df4664bb144514880917cbfdab40af290b7350", "patch": "@@ -159,6 +159,15 @@ macro_rules! impl_enum_decodable {\n     };\n }\n \n+// Same as try!, but for Option\n+#[macro_export]\n+macro_rules! try_opt {\n+    ($expr:expr) => (match $expr {\n+        Some(val) => val,\n+        None => { return None; }\n+    })\n+}\n+\n #[test]\n fn power_rounding() {\n     assert_eq!(0, round_up_to_power_of_two(0));"}, {"sha": "0b9a9cfa46badb4419d5992e9b9255def82f65b6", "filename": "src/visitor.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/58df4664bb144514880917cbfdab40af290b7350/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58df4664bb144514880917cbfdab40af290b7350/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=58df4664bb144514880917cbfdab40af290b7350", "patch": "@@ -16,6 +16,7 @@ use utils;\n \n use SKIP_ANNOTATION;\n use changes::ChangeSet;\n+use rewrite::{Rewrite, RewriteContext};\n \n pub struct FmtVisitor<'a> {\n     pub codemap: &'a CodeMap,\n@@ -32,9 +33,15 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                self.codemap.lookup_char_pos(ex.span.hi));\n         self.format_missing(ex.span.lo);\n         let offset = self.changes.cur_offset_span(ex.span);\n-        let new_str = self.rewrite_expr(ex, config!(max_width) - offset, offset);\n-        self.changes.push_str_span(ex.span, &new_str);\n-        self.last_pos = ex.span.hi;\n+        match ex.rewrite(&RewriteContext { codemap: self.codemap },\n+                         config!(max_width) - offset,\n+                         offset) {\n+            Some(new_str) => {\n+                self.changes.push_str_span(ex.span, &new_str);\n+                self.last_pos = ex.span.hi;\n+            }\n+            None => { self.last_pos = ex.span.lo; }\n+        }\n     }\n \n     fn visit_stmt(&mut self, stmt: &'v ast::Stmt) {"}]}