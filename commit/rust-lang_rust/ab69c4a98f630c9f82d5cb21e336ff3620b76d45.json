{"sha": "ab69c4a98f630c9f82d5cb21e336ff3620b76d45", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiNjljNGE5OGY2MzBjOWY4MmQ1Y2IyMWUzMzZmZjM2MjBiNzZkNDU=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-06-07T20:50:30Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-06-07T21:12:34Z"}, "message": "Removing dead code and redundant fails; changing fails to sess.bug\ncalls (issue #444).", "tree": {"sha": "40c41487421f9c39a18cb1e2aa411c77aac6257f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40c41487421f9c39a18cb1e2aa411c77aac6257f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab69c4a98f630c9f82d5cb21e336ff3620b76d45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab69c4a98f630c9f82d5cb21e336ff3620b76d45", "html_url": "https://github.com/rust-lang/rust/commit/ab69c4a98f630c9f82d5cb21e336ff3620b76d45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab69c4a98f630c9f82d5cb21e336ff3620b76d45/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1d6f12a050ea0c99f13a1eb58c06577559cc76a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1d6f12a050ea0c99f13a1eb58c06577559cc76a", "html_url": "https://github.com/rust-lang/rust/commit/b1d6f12a050ea0c99f13a1eb58c06577559cc76a"}], "stats": {"total": 251, "additions": 93, "deletions": 158}, "files": [{"sha": "7333375b902c651325a5bbfe40e7e0dcbd36f95b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ab69c4a98f630c9f82d5cb21e336ff3620b76d45/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab69c4a98f630c9f82d5cb21e336ff3620b76d45/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=ab69c4a98f630c9f82d5cb21e336ff3620b76d45", "patch": "@@ -3687,13 +3687,11 @@ fn autoderef(&@block_ctxt cx, ValueRef v, &ty::t t) -> result {\n \n                 v1 = load_if_immediate(cx, v1, t1);\n             }\n-            case (_) {\n-                ret res(cx, v1);\n-            }\n+            case (_) { break; }\n         }\n     }\n \n-    fail; // fools the return-checker\n+    ret res(cx, v1);\n }\n \n fn autoderefed_ty(&@crate_ctxt ccx, &ty::t t) -> ty::t {\n@@ -3704,13 +3702,11 @@ fn autoderefed_ty(&@crate_ctxt ccx, &ty::t t) -> ty::t {\n             case (ty::ty_box(?mt)) {\n                 t1 = mt.ty;\n             }\n-            case (_) {\n-                ret t1;\n-            }\n+            case (_) { break; }\n         }\n     }\n \n-    fail; // fools the return-checker\n+    ret t1;\n }\n \n fn trans_binary(&@block_ctxt cx, ast::binop op,\n@@ -3876,7 +3872,7 @@ fn trans_if(&@block_ctxt cx, &@ast::expr cond,\n             }\n \n             // FIXME: This isn't quite right, particularly re: dynamic types\n-            auto expr_ty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx.node_types,\n+            auto expr_ty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx,\n                                            ann);\n             if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, expr_ty)) {\n                 expr_llty = T_typaram_ptr(cx.fcx.lcx.ccx.tn);\n@@ -4260,7 +4256,7 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n \n         case (ast::pat_lit(?lt, ?ann)) {\n             auto lllit = trans_lit(cx.fcx.lcx.ccx, *lt, ann);\n-            auto lltype = ty::ann_to_type(cx.fcx.lcx.ccx.tcx.node_types, ann);\n+            auto lltype = ty::ann_to_type(cx.fcx.lcx.ccx.tcx, ann);\n             auto lleq = trans_compare(cx, ast::eq, lltype, llval, lllit);\n \n             auto matched_cx = new_sub_block_ctxt(lleq.bcx, \"matched_cx\");\n@@ -4298,7 +4294,7 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n             cx.build.CondBr(lleq, matched_cx.llbb, next_cx.llbb);\n \n             auto ty_params =\n-                ty::ann_to_type_params(cx.fcx.lcx.ccx.tcx.node_types, ann);\n+                ty::ann_to_type_params(cx.fcx.lcx.ccx.tcx, ann);\n \n             if (vec::len[@ast::pat](subpats) > 0u) {\n                 auto llblobptr = matched_cx.build.GEP(lltagptr,\n@@ -4359,7 +4355,7 @@ fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat,\n             auto llblobptr = cx.build.GEP(lltagptr, [C_int(0), C_int(1)]);\n \n             auto ty_param_substs =\n-                ty::ann_to_type_params(cx.fcx.lcx.ccx.tcx.node_types, ann);\n+                ty::ann_to_type_params(cx.fcx.lcx.ccx.tcx, ann);\n \n             auto this_cx = cx;\n             auto i = 0;\n@@ -4408,7 +4404,7 @@ fn trans_alt(&@block_ctxt cx, &@ast::expr expr,\n                                   \"non-exhaustive match failure\");\n \n     // FIXME: This isn't quite right, particularly re: dynamic types\n-    auto expr_ty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx.node_types, ann);\n+    auto expr_ty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx, ann);\n     auto expr_llty;\n     if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, expr_ty)) {\n         expr_llty = T_typaram_ptr(cx.fcx.lcx.ccx.tn);\n@@ -4473,8 +4469,8 @@ fn lval_generic_fn(&@block_ctxt cx,\n         lv = trans_external_path(cx, fn_id, tpt);\n     }\n \n-    auto tys = ty::ann_to_type_params(cx.fcx.lcx.ccx.tcx.node_types, ann);\n-    auto monoty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx.node_types, ann);\n+    auto tys = ty::ann_to_type_params(cx.fcx.lcx.ccx.tcx, ann);\n+    auto monoty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx, ann);\n \n     if (vec::len[ty::t](tys) != 0u) {\n         auto bcx = lv.res.bcx;\n@@ -5361,7 +5357,7 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f,\n \n     }\n \n-    auto ret_ty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx.node_types, ann);\n+    auto ret_ty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx, ann);\n     auto args_res = trans_args(f_res.res.bcx,\n                                llenv, f_res.llobj,\n                                f_res.generic,\n@@ -6910,7 +6906,7 @@ fn is_terminated(&@block_ctxt cx) -> bool {\n }\n \n fn arg_tys_of_fn(&@crate_ctxt ccx, ast::ann ann) -> vec[ty::arg] {\n-    alt (ty::struct(ccx.tcx, ty::ann_to_type(ccx.tcx.node_types, ann))) {\n+    alt (ty::struct(ccx.tcx, ty::ann_to_type(ccx.tcx, ann))) {\n         case (ty::ty_fn(_, ?arg_tys, _, _)) {\n             ret arg_tys;\n         }\n@@ -6927,7 +6923,7 @@ fn ret_ty_of_fn_ty(&@crate_ctxt ccx, ty::t t) -> ty::t {\n \n \n fn ret_ty_of_fn(&@crate_ctxt ccx, ast::ann ann) -> ty::t {\n-    ret ret_ty_of_fn_ty(ccx, ty::ann_to_type(ccx.tcx.node_types, ann));\n+    ret ret_ty_of_fn_ty(ccx, ty::ann_to_type(ccx.tcx, ann));\n }\n \n fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, val_self_pair llself) {"}, {"sha": "b801954b933e33dcb6891b6bca92ae5dc846ec78", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab69c4a98f630c9f82d5cb21e336ff3620b76d45/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab69c4a98f630c9f82d5cb21e336ff3620b76d45/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=ab69c4a98f630c9f82d5cb21e336ff3620b76d45", "patch": "@@ -482,7 +482,7 @@ fn controlflow_def_id(&crate_ctxt ccx, &def_id d) -> controlflow {\n  If it has a function type with a ! annotation,\n the answer is noreturn. */\n fn controlflow_expr(&crate_ctxt ccx, @expr e) -> controlflow {\n-    alt (ty::struct(ccx.tcx, ty::ann_to_type(ccx.tcx.node_types,\n+    alt (ty::struct(ccx.tcx, ty::ann_to_type(ccx.tcx,\n                                              expr_ann(e)))) {\n         case (ty::ty_fn(_,_,_,?cf)) {\n             ret cf;"}, {"sha": "206eb24501c43346497d0921bb6ac2d5ba7a3ada", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 42, "deletions": 104, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/ab69c4a98f630c9f82d5cb21e336ff3620b76d45/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab69c4a98f630c9f82d5cb21e336ff3620b76d45/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=ab69c4a98f630c9f82d5cb21e336ff3620b76d45", "patch": "@@ -921,9 +921,7 @@ fn sequence_element_type(&ctxt cx, &t ty) -> t {\n         // NB: This is not exhaustive.\n     }\n \n-    // FIXME: add sess.err or sess.span_err explaining failure (issue\n-    // #444)\n-    fail;\n+    cx.sess.bug(\"sequence_element_type called on non-sequence value\");\n }\n \n fn type_is_tup_like(&ctxt cx, &t ty) -> bool {\n@@ -949,8 +947,8 @@ fn get_element_type(&ctxt cx, &t ty, uint i) -> t {\n         // tag.\n     }\n \n-    // FIXME: add sess.err or sess.span_err explaining failure (issue #444)\n-    fail;\n+    cx.sess.bug(\"get_element_type called on a value other than a \"\n+                + \"tuple or record\");\n }\n \n fn type_is_box(&ctxt cx, &t ty) -> bool {\n@@ -1544,24 +1542,25 @@ fn eq_ty(&t a, &t b) -> bool { ret a == b; }\n \n // Type lookups\n \n-fn ann_to_ty_param_substs_opt_and_ty(&node_type_table ntt, &ast::ann ann)\n-        -> ty_param_substs_opt_and_ty {\n-    alt ({ntt.(ann.id)}) {\n+fn ann_to_ty_param_substs_opt_and_ty(&ty_ctxt tcx, &ast::ann ann)\n+    -> ty_param_substs_opt_and_ty {\n+\n+    // Pull out the node type table.\n+    alt ({tcx.node_types.(ann.id)}) {\n         case (none) {\n-            log_err \"ann_to_ty_param_substs_opt_and_ty() called on an \" +\n-                \"untyped node\";\n-            fail;\n+            tcx.sess.bug(\"ann_to_ty_param_substs_opt_and_ty() called on an \" +\n+                         \"untyped node\");\n         }\n         case (some(?tpot)) { ret tpot; }\n     }\n }\n \n-fn ann_to_type(&node_type_table ntt, &ast::ann ann) -> t {\n-    ret ann_to_ty_param_substs_opt_and_ty(ntt, ann)._1;\n+fn ann_to_type(&ty_ctxt tcx, &ast::ann ann) -> t {\n+    ret ann_to_ty_param_substs_opt_and_ty(tcx, ann)._1;\n }\n \n-fn ann_to_type_params(&node_type_table ntt, &ast::ann ann) -> vec[t] {\n-    alt (ann_to_ty_param_substs_opt_and_ty(ntt, ann)._0) {\n+fn ann_to_type_params(&ty_ctxt tcx, &ast::ann ann) -> vec[t] {\n+    alt (ann_to_ty_param_substs_opt_and_ty(tcx, ann)._0) {\n         case (none) {\n             let vec[t] result = [];\n             ret result;\n@@ -1570,16 +1569,16 @@ fn ann_to_type_params(&node_type_table ntt, &ast::ann ann) -> vec[t] {\n     }\n }\n \n-fn ann_has_type_params(&node_type_table ntt, &ast::ann ann) -> bool {\n-    auto tpt = ann_to_ty_param_substs_opt_and_ty(ntt, ann);\n+fn ann_has_type_params(&ty_ctxt tcx, &ast::ann ann) -> bool {\n+    auto tpt = ann_to_ty_param_substs_opt_and_ty(tcx, ann);\n     ret !option::is_none[vec[t]](tpt._0);\n }\n \n \n // Returns the type of an annotation, with type parameter substitutions\n // performed if applicable.\n fn ann_to_monotype(&ctxt cx, ast::ann a) -> t {\n-    auto tpot = ann_to_ty_param_substs_opt_and_ty(cx.node_types, a);\n+    auto tpot = ann_to_ty_param_substs_opt_and_ty(cx, a);\n     alt (tpot._0) {\n         case (none) { ret tpot._1; }\n         case (some(?tps)) {\n@@ -1638,29 +1637,29 @@ fn ty_fn_args(&ctxt cx, &t fty) -> vec[arg] {\n         case (ty::ty_fn(_, ?a, _, _)) { ret a; }\n         case (ty::ty_native_fn(_, ?a, _)) { ret a; }\n     }\n-    fail;\n+    cx.sess.bug(\"ty_fn_args() called on non-fn type\");\n }\n \n fn ty_fn_proto(&ctxt cx, &t fty) -> ast::proto {\n     alt (struct(cx, fty)) {\n         case (ty::ty_fn(?p, _, _, _)) { ret p; }\n     }\n-    fail;\n+    cx.sess.bug(\"ty_fn_proto() called on non-fn type\");\n }\n \n fn ty_fn_abi(&ctxt cx, &t fty) -> ast::native_abi {\n     alt (struct(cx, fty)) {\n         case (ty::ty_native_fn(?a, _, _)) { ret a; }\n     }\n-    fail;\n+    cx.sess.bug(\"ty_fn_abi() called on non-native-fn type\");\n }\n \n fn ty_fn_ret(&ctxt cx, &t fty) -> t {\n     alt (struct(cx, fty)) {\n         case (ty::ty_fn(_, _, ?r, _)) { ret r; }\n         case (ty::ty_native_fn(_, _, ?r)) { ret r; }\n     }\n-    fail;\n+    cx.sess.bug(\"ty_fn_ret() called on non-fn type\");\n }\n \n fn is_fn_ty(&ctxt cx, &t fty) -> bool {\n@@ -1674,66 +1673,8 @@ fn is_fn_ty(&ctxt cx, &t fty) -> bool {\n \n // Type accessors for AST nodes\n \n-// Given an item, returns the associated type as well as the number of type\n-// parameters it has.\n-fn native_item_ty(&node_type_table ntt, &@ast::native_item it)\n-        -> ty_param_count_and_ty {\n-    auto ty_param_count;\n-    auto result_ty;\n-    alt (it.node) {\n-        case (ast::native_item_fn(_, _, _, ?tps, _, ?ann)) {\n-            ty_param_count = vec::len[ast::ty_param](tps);\n-            result_ty = ann_to_type(ntt, ann);\n-        }\n-    }\n-    ret tup(ty_param_count, result_ty);\n-}\n-\n-fn item_ty(&node_type_table ntt, &@ast::item it) -> ty_param_count_and_ty {\n-    auto ty_param_count;\n-    auto result_ty;\n-    alt (it.node) {\n-        case (ast::item_const(_, _, _, _, ?ann)) {\n-            ty_param_count = 0u;\n-            result_ty = ann_to_type(ntt, ann);\n-        }\n-        case (ast::item_fn(_, _, ?tps, _, ?ann)) {\n-            ty_param_count = vec::len[ast::ty_param](tps);\n-            result_ty = ann_to_type(ntt, ann);\n-        }\n-        case (ast::item_mod(_, _, _)) {\n-            fail;   // modules are typeless\n-        }\n-        case (ast::item_ty(_, _, ?tps, _, ?ann)) {\n-            ty_param_count = vec::len[ast::ty_param](tps);\n-            result_ty = ann_to_type(ntt, ann);\n-        }\n-        case (ast::item_tag(_, _, ?tps, ?did, ?ann)) {\n-            ty_param_count = vec::len[ast::ty_param](tps);\n-            result_ty = ann_to_type(ntt, ann);\n-        }\n-        case (ast::item_obj(_, _, ?tps, _, ?ann)) {\n-            ty_param_count = vec::len[ast::ty_param](tps);\n-            result_ty = ann_to_type(ntt, ann);\n-        }\n-    }\n-\n-    ret tup(ty_param_count, result_ty);\n-}\n-\n-fn stmt_ty(&ctxt cx, &@ast::stmt s) -> t {\n-    alt (s.node) {\n-        case (ast::stmt_expr(?e,_)) {\n-            ret expr_ty(cx, e);\n-        }\n-        case (_) {\n-            ret mk_nil(cx);\n-        }\n-    }\n-}\n-\n fn block_ty(&ctxt cx, &ast::block b) -> t {\n-    ret ann_to_type(cx.node_types, b.node.a);\n+    ret ann_to_type(cx, b.node.a);\n }\n \n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n@@ -1820,18 +1761,18 @@ fn expr_ty_params_and_ty(&ctxt cx, &@ast::expr expr)\n         -> tup(vec[t], t) {\n     auto a = expr_ann(expr);\n \n-    ret tup(ann_to_type_params(cx.node_types, a),\n-            ann_to_type(cx.node_types, a));\n+    ret tup(ann_to_type_params(cx, a),\n+            ann_to_type(cx, a));\n }\n \n-fn expr_has_ty_params(&node_type_table ntt, &@ast::expr expr) -> bool {\n-    ret ann_has_type_params(ntt, expr_ann(expr));\n+fn expr_has_ty_params(&ty_ctxt tcx, &@ast::expr expr) -> bool {\n+    ret ann_has_type_params(tcx, expr_ann(expr));\n }\n \n fn decl_local_ty(&ctxt cx, &@ast::decl d) -> t {\n     alt (d.node) {\n         case (ast::decl_local(?l)) {\n-            ret ann_to_type(cx.node_types, l.ann);\n+            ret ann_to_type(cx, l.ann);\n         }\n         case (_) {\n             cx.sess.bug(\"decl_local_ty called on an item decl\");\n@@ -2281,8 +2222,9 @@ mod unify {\n             case (ty::ty_bound_param(?actual_id)) {\n                 alt (struct(cx.tcx, expected)) {\n                     case (ty::ty_local(_)) {\n-                        log_err \"TODO: bound param unifying with local\";\n-                        fail;\n+                        // TODO: bound param unifying with local\n+                        cx.tcx.sess.unimpl(\"TODO: bound param unifying with \"\n+                                           + \"local\");\n                     }\n \n                     case (_) {\n@@ -2686,18 +2628,15 @@ mod unify {\n     }\n \n     fn unify_sets[T](&ty_ctxt tcx, &@bindings[T] bindings) -> set_result {\n-        obj handler() {\n+        obj handler(ty_ctxt tcx) {\n             fn resolve_local(ast::def_id id) -> option::t[t] {\n-                log_err \"resolve_local in unify_sets\";\n-                fail;\n+                tcx.sess.bug(\"resolve_local in unify_sets\");\n             }\n             fn record_local(ast::def_id id, t ty) {\n-                log_err \"record_local in unify_sets\";\n-                fail;\n+                tcx.sess.bug(\"record_local in unify_sets\");\n             }\n             fn record_param(uint index, t binding) -> unify::result {\n-                log_err \"record_param in unify_sets\";\n-                fail;\n+                tcx.sess.bug(\"record_param in unify_sets\");\n             }\n         }\n \n@@ -2718,8 +2657,8 @@ mod unify {\n                             // FIXME: Is this right?\n                             auto bindings = mk_bindings[int](int::hash,\n                                                              int::eq_alias);\n-                            alt (unify(expected, actual, handler(), bindings,\n-                                    tcx)) {\n+                            alt (unify(expected, actual, handler(tcx), \n+                                       bindings, tcx)) {\n                                 case (ures_ok(?result_ty)) {\n                                     results.(i) = some[t](result_ty);\n                                 }\n@@ -2840,9 +2779,8 @@ fn bind_params_in_type(&ctxt cx, &t typ) -> t {\n     fn binder(&ctxt cx, t typ) -> t {\n         alt (struct(cx, typ)) {\n             case (ty_bound_param(?index)) {\n-                log_err \"bind_params_in_type() called on type that already \" +\n-                    \"has bound params in it\";\n-                fail;\n+                cx.sess.bug(\"bind_params_in_type() called on type that \"\n+                            + \"already has bound params in it\");\n             }\n             case (ty_param(?index)) { ret mk_bound_param(cx, index); }\n             case (_) { ret typ; }\n@@ -2924,9 +2862,9 @@ fn tag_variant_with_id(&ctxt cx,\n         }\n         i += 1u;\n     }\n+            \n+    cx.sess.bug(\"tag_variant_with_id(): no variant exists with that ID\");\n \n-    log_err \"tag_variant_with_id(): no variant exists with that ID\";\n-    fail;\n }\n \n // If the given item is in an external crate, looks up its type and adds it to\n@@ -2954,13 +2892,13 @@ fn ret_ty_of_fn_ty(ty_ctxt tcx, t a_ty) -> t {\n             ret ret_ty;\n         }\n         case (_) {\n-            fail;\n+            tcx.sess.bug(\"ret_ty_of_fn_ty() called on non-function type\");\n         }\n     }\n }\n \n fn ret_ty_of_fn(ty_ctxt tcx, ast::ann ann) -> t {\n-    ret ret_ty_of_fn_ty(tcx, ann_to_type(tcx.node_types, ann));\n+    ret ret_ty_of_fn_ty(tcx, ann_to_type(tcx, ann));\n }\n \n // Local Variables:"}, {"sha": "c07e76f8332e2c466c7bce72369047268e899b25", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ab69c4a98f630c9f82d5cb21e336ff3620b76d45/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab69c4a98f630c9f82d5cb21e336ff3620b76d45/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=ab69c4a98f630c9f82d5cb21e336ff3620b76d45", "patch": "@@ -1116,7 +1116,7 @@ mod pushdown {\n                 // TODO: enforce mutability\n \n                 auto t = demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx, ann));\n                 alt (struct(scx.fcx.ccx.tcx, t)) {\n                     case (ty::ty_vec(?mt)) {\n                         for (@ast::expr e_0 in es_0) {\n@@ -1132,7 +1132,7 @@ mod pushdown {\n             }\n             case (ast::expr_tup(?es_0, ?ann)) {\n                 auto t = demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx, ann));\n                 alt (struct(scx.fcx.ccx.tcx, t)) {\n                     case (ty::ty_tup(?mts)) {\n                         auto i = 0u;\n@@ -1151,7 +1151,7 @@ mod pushdown {\n             case (ast::expr_rec(?fields_0, ?base_0, ?ann)) {\n \n                 auto t = demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx, ann));\n                 alt (struct(scx.fcx.ccx.tcx, t)) {\n                     case (ty::ty_rec(?field_mts)) {\n                         alt (base_0) {\n@@ -1192,7 +1192,7 @@ mod pushdown {\n             }\n             case (ast::expr_bind(?sube, ?es, ?ann)) {\n                 auto t = demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx, ann));\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_call(?sube, ?es, ?ann)) {\n@@ -1201,24 +1201,24 @@ mod pushdown {\n                 // produce a box; things like expr_binary or expr_bind can't,\n                 // so there's no need.\n                 auto t = demand::autoderef(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n+                    ann_to_type(scx.fcx.ccx.tcx, ann), adk);\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_self_method(?id, ?ann)) {\n                 auto t = demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx, ann));\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_binary(?bop, ?lhs, ?rhs, ?ann)) {\n                 auto t = demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx, ann));\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_unary(?uop, ?sube, ?ann)) {\n                 // See note in expr_unary for why we're calling\n                 // demand::autoderef.\n                 auto t = demand::autoderef(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n+                    ann_to_type(scx.fcx.ccx.tcx, ann), adk);\n                 write::ty_only_fixup(scx, ann.id, t);\n \n                 /* The following is a bit special-cased, but takes care of\n@@ -1248,17 +1248,17 @@ mod pushdown {\n             }\n             case (ast::expr_lit(?lit, ?ann)) {\n                 auto t = demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx, ann));\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_cast(?sube, ?ast_ty, ?ann)) {\n                 auto t = demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx, ann));\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_if(?cond, ?then_0, ?else_0, ?ann)) {\n                 auto t = demand::autoderef(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n+                    ann_to_type(scx.fcx.ccx.tcx, ann), adk);\n \n                 auto then_t = ty::block_ty(scx.fcx.ccx.tcx, then_0);\n                 pushdown_block(scx, expected, then_0);\n@@ -1274,65 +1274,65 @@ mod pushdown {\n             }\n             case (ast::expr_for(?decl, ?seq, ?bloc, ?ann)) {\n                 auto t = demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx, ann));\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_for_each(?decl, ?seq, ?bloc, ?ann)) {\n                 auto t = demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx, ann));\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_while(?cond, ?bloc, ?ann)) {\n                 auto t = demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx, ann));\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_do_while(?bloc, ?cond, ?ann)) {\n                 auto t = demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx, ann));\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_block(?bloc, ?ann)) {\n                 auto t = demand::autoderef(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n+                    ann_to_type(scx.fcx.ccx.tcx, ann), adk);\n                 write::ty_only_fixup(scx, ann.id, t);\n                 pushdown_block(scx, t, bloc);\n             }\n             case (ast::expr_move(?lhs_0, ?rhs_0, ?ann)) {\n                 auto t = demand::autoderef(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n+                    ann_to_type(scx.fcx.ccx.tcx, ann), adk);\n                 pushdown_expr(scx, expected, lhs_0);\n                 pushdown_expr(scx, expected, rhs_0);\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_assign(?lhs_0, ?rhs_0, ?ann)) {\n                 auto t = demand::autoderef(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n+                    ann_to_type(scx.fcx.ccx.tcx, ann), adk);\n                 pushdown_expr(scx, expected, lhs_0);\n                 pushdown_expr(scx, expected, rhs_0);\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_assign_op(?op, ?lhs_0, ?rhs_0, ?ann)) {\n                 auto t = demand::autoderef(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n+                    ann_to_type(scx.fcx.ccx.tcx, ann), adk);\n                 pushdown_expr(scx, expected, lhs_0);\n                 pushdown_expr(scx, expected, rhs_0);\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_field(?lhs, ?rhs, ?ann)) {\n                 auto t = demand::autoderef(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n+                    ann_to_type(scx.fcx.ccx.tcx, ann), adk);\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_index(?base, ?index, ?ann)) {\n                 auto t = demand::autoderef(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n+                    ann_to_type(scx.fcx.ccx.tcx, ann), adk);\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_path(?pth, ?ann)) {\n                 auto tp_substs_0 =\n-                    ty::ann_to_type_params(scx.fcx.ccx.tcx.node_types, ann);\n-                auto t_0 = ann_to_type(scx.fcx.ccx.tcx.node_types, ann);\n+                    ty::ann_to_type_params(scx.fcx.ccx.tcx, ann);\n+                auto t_0 = ann_to_type(scx.fcx.ccx.tcx, ann);\n \n                 auto result_0 = demand::full(scx, e.span, expected, t_0,\n                                              tp_substs_0, adk);\n@@ -1341,8 +1341,9 @@ mod pushdown {\n                 // Fill in the type parameter substitutions if they weren't\n                 // provided by the programmer.\n                 auto ty_params_opt;\n+\n                 alt (ty::ann_to_ty_param_substs_opt_and_ty\n-                        (scx.fcx.ccx.tcx.node_types, ann)._0) {\n+                        (scx.fcx.ccx.tcx, ann)._0) {\n                     case (none) {\n                         ty_params_opt = none[vec[ty::t]];\n                     }\n@@ -1355,7 +1356,7 @@ mod pushdown {\n             }\n             case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?ann)) {\n                 auto t = demand::autoderef(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n+                    ann_to_type(scx.fcx.ccx.tcx, ann), adk);\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             /* FIXME: should this check the type annotations? */\n@@ -1371,13 +1372,13 @@ mod pushdown {\n \n             case (ast::expr_port(?ann)) {\n                 auto t = demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx, ann));\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n \n             case (ast::expr_chan(?es, ?ann)) {\n                 auto t = demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx, ann));\n                 alt (struct(scx.fcx.ccx.tcx, t)) {\n                     case (ty::ty_chan(?subty)) {\n                         auto pt = ty::mk_port(scx.fcx.ccx.tcx, subty);\n@@ -1419,15 +1420,15 @@ mod pushdown {\n                 // produce a box; things like expr_binary or expr_bind can't,\n                 // so there's no need.\n                 auto t = demand::autoderef(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n+                    ann_to_type(scx.fcx.ccx.tcx, ann), adk);\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n \n             case (ast::expr_anon_obj(?anon_obj, ?tps, ?odid, ?ann)) {\n                 // NB: Not sure if this is correct, but not worrying too much\n                 // about it since pushdown is going away anyway.\n                 auto t = demand::autoderef(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n+                    ann_to_type(scx.fcx.ccx.tcx, ann), adk);\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n \n@@ -1450,7 +1451,7 @@ mod pushdown {\n             }\n         }\n         demand::simple(scx, bloc.span, expected,\n-          ann_to_type(scx.fcx.ccx.tcx.node_types, bloc.node.a));\n+          ann_to_type(scx.fcx.ccx.tcx, bloc.node.a));\n     }\n }\n \n@@ -1488,7 +1489,7 @@ mod writeback {\n         }\n \n         auto tpot =\n-            ty::ann_to_ty_param_substs_opt_and_ty(fcx.ccx.tcx.node_types,\n+            ty::ann_to_ty_param_substs_opt_and_ty(fcx.ccx.tcx,\n                                                   ann);\n         auto tt = tpot._1;\n         if (!ty::type_contains_locals(fcx.ccx.tcx, tt)) { ret; }\n@@ -1553,7 +1554,7 @@ fn replace_expr_type(&@stmt_ctxt scx,\n                      &@ast::expr expr,\n                      &tup(vec[ty::t], ty::t) new_tyt) {\n     auto new_tps;\n-    if (ty::expr_has_ty_params(scx.fcx.ccx.tcx.node_types, expr)) {\n+    if (ty::expr_has_ty_params(scx.fcx.ccx.tcx, expr)) {\n         new_tps = some[vec[ty::t]](new_tyt._0);\n     } else {\n         new_tps = none[vec[ty::t]];\n@@ -2722,7 +2723,7 @@ fn check_block(&@stmt_ctxt scx, &ast::block block) {\n fn check_const(&@crate_ctxt ccx, &span sp, &@ast::expr e, &ast::ann ann) {\n     // FIXME: this is kinda a kludge; we manufacture a fake function context\n     // and statement context for checking the initializer expression.\n-    auto rty = ann_to_type(ccx.tcx.node_types, ann);\n+    auto rty = ann_to_type(ccx.tcx, ann);\n     let @fn_ctxt fcx = @rec(ret_ty = rty,\n                             purity = ast::pure_fn,\n                             locals = @common::new_def_hash[ty::t](),\n@@ -2742,7 +2743,7 @@ fn check_fn(&@crate_ctxt ccx, &ast::fn_decl decl, ast::proto proto,\n     alt (get_obj_info(ccx)) {\n         case (option::some(?oinfo)) {\n             for (ast::obj_field f in oinfo.obj_fields) {\n-                auto field_ty = ty::ann_to_type(ccx.tcx.node_types, f.ann);\n+                auto field_ty = ty::ann_to_type(ccx.tcx, f.ann);\n                 local_ty_table.insert(f.id, field_ty);\n             }\n         }"}, {"sha": "2c7e65dcb22002bdb92117c8de4222badb1f87b2", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab69c4a98f630c9f82d5cb21e336ff3620b76d45/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab69c4a98f630c9f82d5cb21e336ff3620b76d45/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=ab69c4a98f630c9f82d5cb21e336ff3620b76d45", "patch": "@@ -945,7 +945,7 @@ fn print_decl(&ps s, &@ast::decl decl) {\n                         case (mo_untyped) { /* no-op */ }\n                         case (mo_typed(?tcx)) {\n                             auto lty =\n-                                ty::ann_to_type(tcx.node_types, loc.ann);\n+                                ty::ann_to_type(tcx, loc.ann);\n                             word_space(s, ty::ty_to_str(tcx, lty));\n                         }\n                         case (mo_identified) { /* no-op */ }"}]}