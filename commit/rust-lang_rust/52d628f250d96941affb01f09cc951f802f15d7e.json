{"sha": "52d628f250d96941affb01f09cc951f802f15d7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyZDYyOGYyNTBkOTY5NDFhZmZiMDFmMDljYzk1MWY4MDJmMTVkN2U=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-05-19T20:25:07Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-05-22T17:03:08Z"}, "message": "Remove unused error reporting code", "tree": {"sha": "42d25cea74797acf23e0b2aada40dcec781a37ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42d25cea74797acf23e0b2aada40dcec781a37ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52d628f250d96941affb01f09cc951f802f15d7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52d628f250d96941affb01f09cc951f802f15d7e", "html_url": "https://github.com/rust-lang/rust/commit/52d628f250d96941affb01f09cc951f802f15d7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52d628f250d96941affb01f09cc951f802f15d7e/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "html_url": "https://github.com/rust-lang/rust/commit/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea"}], "stats": {"total": 536, "additions": 0, "deletions": 536}, "files": [{"sha": "efe52689550c47c82da93bbd55945e1ac1b881b1", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52d628f250d96941affb01f09cc951f802f15d7e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52d628f250d96941affb01f09cc951f802f15d7e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=52d628f250d96941affb01f09cc951f802f15d7e", "patch": "@@ -8,7 +8,6 @@ use rustc_span::source_map::Span;\n mod different_lifetimes;\n mod find_anon_type;\n mod named_anon_conflict;\n-mod outlives_closure;\n mod placeholder_error;\n mod static_impl_trait;\n mod trait_impl_difference;\n@@ -57,7 +56,6 @@ impl<'cx, 'tcx> NiceRegionError<'cx, 'tcx> {\n                 ErrorReported\n             })\n             .or_else(|| self.try_report_anon_anon_conflict())\n-            .or_else(|| self.try_report_outlives_closure())\n             .or_else(|| self.try_report_static_impl_trait())\n             .or_else(|| self.try_report_impl_not_conforming_to_trait())\n     }"}, {"sha": "fc858a497597e5bad0f2e02bd935c33089a201d5", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "patch": "@@ -1,117 +0,0 @@\n-//! Error Reporting for Anonymous Region Lifetime Errors\n-//! where both the regions are anonymous.\n-\n-use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use crate::infer::lexical_region_resolve::RegionResolutionError::SubSupConflict;\n-use crate::infer::SubregionOrigin;\n-use rustc_errors::ErrorReported;\n-use rustc_hir::{Expr, ExprKind::Closure, Node};\n-use rustc_middle::ty::RegionKind;\n-\n-impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n-    /// Print the error message for lifetime errors when binding escapes a closure.\n-    ///\n-    /// Consider a case where we have\n-    ///\n-    /// ```no_run\n-    /// fn with_int<F>(f: F) where F: FnOnce(&isize) {\n-    ///     let x = 3;\n-    ///     f(&x);\n-    /// }\n-    /// fn main() {\n-    ///     let mut x = None;\n-    ///     with_int(|y| x = Some(y));\n-    /// }\n-    /// ```\n-    ///\n-    /// the output will be\n-    ///\n-    /// ```text\n-    ///     let mut x = None;\n-    ///         ----- borrowed data cannot be stored into here...\n-    ///     with_int(|y| x = Some(y));\n-    ///              ---          ^ cannot be stored outside of its closure\n-    ///              |\n-    ///              ...because it cannot outlive this closure\n-    /// ```\n-    pub(super) fn try_report_outlives_closure(&self) -> Option<ErrorReported> {\n-        if let Some(SubSupConflict(_, origin, ref sub_origin, _, ref sup_origin, sup_region)) =\n-            self.error\n-        {\n-            // #45983: when trying to assign the contents of an argument to a binding outside of a\n-            // closure, provide a specific message pointing this out.\n-            if let (\n-                &SubregionOrigin::BindingTypeIsNotValidAtDecl(ref external_span),\n-                &RegionKind::ReFree(ref free_region),\n-            ) = (&sub_origin, sup_region)\n-            {\n-                let hir = &self.tcx().hir();\n-                if let Some(def_id) = free_region.scope.as_local() {\n-                    let hir_id = hir.as_local_hir_id(def_id);\n-                    if let Node::Expr(Expr { kind: Closure(_, _, _, closure_span, None), .. }) =\n-                        hir.get(hir_id)\n-                    {\n-                        let sup_sp = sup_origin.span();\n-                        let origin_sp = origin.span();\n-                        let mut err = self.tcx().sess.struct_span_err(\n-                            sup_sp,\n-                            \"borrowed data cannot be stored outside of its closure\",\n-                        );\n-                        err.span_label(sup_sp, \"cannot be stored outside of its closure\");\n-                        if origin_sp == sup_sp || origin_sp.contains(sup_sp) {\n-                            // // sup_sp == origin.span():\n-                            //\n-                            // let mut x = None;\n-                            //     ----- borrowed data cannot be stored into here...\n-                            // with_int(|y| x = Some(y));\n-                            //          ---          ^ cannot be stored outside of its closure\n-                            //          |\n-                            //          ...because it cannot outlive this closure\n-                            //\n-                            // // origin.contains(&sup_sp):\n-                            //\n-                            // let mut f: Option<&u32> = None;\n-                            //     ----- borrowed data cannot be stored into here...\n-                            // closure_expecting_bound(|x: &'x u32| {\n-                            //                         ------------ ... because it cannot outlive this closure\n-                            //     f = Some(x);\n-                            //              ^ cannot be stored outside of its closure\n-                            err.span_label(\n-                                *external_span,\n-                                \"borrowed data cannot be stored into here...\",\n-                            );\n-                            err.span_label(\n-                                *closure_span,\n-                                \"...because it cannot outlive this closure\",\n-                            );\n-                        } else {\n-                            // FIXME: the wording for this case could be much improved\n-                            //\n-                            // let mut lines_to_use: Vec<&CrateId> = Vec::new();\n-                            //                           - cannot infer an appropriate lifetime...\n-                            // let push_id = |installed_id: &CrateId| {\n-                            //     -------   ------------------------ borrowed data cannot outlive this closure\n-                            //     |\n-                            //     ...so that variable is valid at time of its declaration\n-                            //     lines_to_use.push(installed_id);\n-                            //                       ^^^^^^^^^^^^ cannot be stored outside of its closure\n-                            err.span_label(origin_sp, \"cannot infer an appropriate lifetime...\");\n-                            err.span_label(\n-                                *external_span,\n-                                \"...so that variable is valid at time of its \\\n-                                            declaration\",\n-                            );\n-                            err.span_label(\n-                                *closure_span,\n-                                \"borrowed data cannot outlive this closure\",\n-                            );\n-                        }\n-                        err.emit();\n-                        return Some(ErrorReported);\n-                    }\n-                }\n-            }\n-        }\n-        None\n-    }\n-}"}, {"sha": "a4e51fe0b1c00b9cc38ca5f0953a3c37494a9402", "filename": "src/librustc_infer/infer/error_reporting/note.rs", "status": "modified", "additions": 0, "deletions": 355, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/52d628f250d96941affb01f09cc951f802f15d7e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52d628f250d96941affb01f09cc951f802f15d7e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs?ref=52d628f250d96941affb01f09cc951f802f15d7e", "patch": "@@ -38,65 +38,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n                 err.span_note(span, &format!(\"...so that closure can access `{}`\", var_name));\n             }\n-            infer::InfStackClosure(span) => {\n-                err.span_note(span, \"...so that closure does not outlive its stack frame\");\n-            }\n-            infer::InvokeClosure(span) => {\n-                err.span_note(span, \"...so that closure is not invoked outside its lifetime\");\n-            }\n-            infer::DerefPointer(span) => {\n-                err.span_note(span, \"...so that pointer is not dereferenced outside its lifetime\");\n-            }\n-            infer::ClosureCapture(span, id) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\n-                        \"...so that captured variable `{}` does not outlive the \\\n-                                        enclosing closure\",\n-                        self.tcx.hir().name(id)\n-                    ),\n-                );\n-            }\n-            infer::IndexSlice(span) => {\n-                err.span_note(span, \"...so that slice is not indexed outside the lifetime\");\n-            }\n             infer::RelateObjectBound(span) => {\n                 err.span_note(span, \"...so that it can be closed over into an object\");\n             }\n-            infer::CallRcvr(span) => {\n-                err.span_note(span, \"...so that method receiver is valid for the method call\");\n-            }\n-            infer::CallArg(span) => {\n-                err.span_note(span, \"...so that argument is valid for the call\");\n-            }\n             infer::CallReturn(span) => {\n                 err.span_note(span, \"...so that return value is valid for the call\");\n             }\n-            infer::Operand(span) => {\n-                err.span_note(span, \"...so that operand is valid for operation\");\n-            }\n-            infer::AddrOf(span) => {\n-                err.span_note(span, \"...so that reference is valid at the time of borrow\");\n-            }\n-            infer::AutoBorrow(span) => {\n-                err.span_note(span, \"...so that auto-reference is valid at the time of borrow\");\n-            }\n-            infer::ExprTypeIsNotInScope(t, span) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\n-                        \"...so type `{}` of expression is valid during the \\\n-                                        expression\",\n-                        self.ty_to_string(t)\n-                    ),\n-                );\n-            }\n-            infer::BindingTypeIsNotValidAtDecl(span) => {\n-                err.span_note(span, \"...so that variable is valid at time of its declaration\");\n-            }\n-            infer::ParameterInScope(_, span) => {\n-                err.span_note(span, \"...so that a type/lifetime parameter is in scope here\");\n-            }\n             infer::DataBorrowed(ty, span) => {\n                 err.span_note(\n                     span,\n@@ -126,25 +73,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     ),\n                 );\n             }\n-            infer::RelateDefaultParamBound(span, t) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\n-                        \"...so that type parameter instantiated with `{}`, will \\\n-                                        meet its declared lifetime bounds\",\n-                        self.ty_to_string(t)\n-                    ),\n-                );\n-            }\n             infer::RelateRegionParamBound(span) => {\n                 err.span_note(\n                     span,\n                     \"...so that the declared lifetime parameter bounds are satisfied\",\n                 );\n             }\n-            infer::SafeDestructor(span) => {\n-                err.span_note(span, \"...so that references are valid when the destructor runs\");\n-            }\n             infer::CompareImplMethodObligation { span, .. } => {\n                 err.span_note(\n                     span,\n@@ -231,106 +165,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 );\n                 err\n             }\n-            infer::InfStackClosure(span) => {\n-                let mut err =\n-                    struct_span_err!(self.tcx.sess, span, E0314, \"closure outlives stack frame\");\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"...the closure must be valid for \",\n-                    sub,\n-                    \"...\",\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"...but the closure's stack frame is only valid \\\n-                                                  for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::InvokeClosure(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0315,\n-                    \"cannot invoke closure outside of its lifetime\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the closure is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::DerefPointer(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0473,\n-                    \"dereference of reference outside its lifetime\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the reference is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::ClosureCapture(span, id) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0474,\n-                    \"captured variable `{}` does not outlive the \\\n-                                                enclosing closure\",\n-                    self.tcx.hir().name(id)\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"captured variable is valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"closure is valid for \",\n-                    sub,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::IndexSlice(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0475,\n-                    \"index of slice outside its lifetime\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the slice is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n             infer::RelateObjectBound(span) => {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n@@ -407,61 +241,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 );\n                 err\n             }\n-            infer::RelateDefaultParamBound(span, ty) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0479,\n-                    \"the type `{}` (provided as the value of a type \\\n-                                                parameter) is not valid at this point\",\n-                    self.ty_to_string(ty)\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"type must outlive \",\n-                    sub,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::CallRcvr(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0480,\n-                    \"lifetime of method receiver does not outlive the \\\n-                                                method call\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the receiver is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::CallArg(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0481,\n-                    \"lifetime of function argument does not outlive \\\n-                                                the function call\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the function argument is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n             infer::CallReturn(span) => {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n@@ -480,140 +259,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 );\n                 err\n             }\n-            infer::Operand(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0483,\n-                    \"lifetime of operand does not outlive the \\\n-                                                operation\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the operand is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::AddrOf(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0484,\n-                    \"reference is not valid at the time of borrow\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the borrow is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::AutoBorrow(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0485,\n-                    \"automatically reference is not valid at the time \\\n-                                                of borrow\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the automatic borrow is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::ExprTypeIsNotInScope(t, span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0486,\n-                    \"type of expression contains references that are \\\n-                                                not valid during the expression: `{}`\",\n-                    self.ty_to_string(t)\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"type is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::SafeDestructor(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0487,\n-                    \"unsafe use of destructor: destructor might be \\\n-                                                called while references are dead\"\n-                );\n-                // FIXME (22171): terms \"super/subregion\" are suboptimal\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"superregion: \",\n-                    sup,\n-                    \"\",\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"subregion: \",\n-                    sub,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::BindingTypeIsNotValidAtDecl(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0488,\n-                    \"lifetime of variable does not enclose its \\\n-                                                declaration\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the variable is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::ParameterInScope(_, span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0489,\n-                    \"type/lifetime parameter not in scope here\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the parameter is only valid for \",\n-                    sub,\n-                    \"\",\n-                );\n-                err\n-            }\n             infer::DataBorrowed(ty, span) => {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,"}, {"sha": "fdd0c5b2ff368825cee5f9eaedc8c26844e31db5", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/52d628f250d96941affb01f09cc951f802f15d7e/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52d628f250d96941affb01f09cc951f802f15d7e/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=52d628f250d96941affb01f09cc951f802f15d7e", "patch": "@@ -378,22 +378,6 @@ pub enum SubregionOrigin<'tcx> {\n     /// Arose from a subtyping relation\n     Subtype(Box<TypeTrace<'tcx>>),\n \n-    /// Stack-allocated closures cannot outlive innermost loop\n-    /// or function so as to ensure we only require finite stack\n-    InfStackClosure(Span),\n-\n-    /// Invocation of closure must be within its lifetime\n-    InvokeClosure(Span),\n-\n-    /// Dereference of reference must be within its lifetime\n-    DerefPointer(Span),\n-\n-    /// Closure bound must not outlive captured variables\n-    ClosureCapture(Span, hir::HirId),\n-\n-    /// Index into slice must be within its lifetime\n-    IndexSlice(Span),\n-\n     /// When casting `&'a T` to an `&'b Trait` object,\n     /// relating `'a` to `'b`\n     RelateObjectBound(Span),\n@@ -406,10 +390,6 @@ pub enum SubregionOrigin<'tcx> {\n     /// that must outlive some other region.\n     RelateRegionParamBound(Span),\n \n-    /// A bound placed on type parameters that states that must outlive\n-    /// the moment of their instantiation.\n-    RelateDefaultParamBound(Span, Ty<'tcx>),\n-\n     /// Creating a pointer `b` to contents of another reference\n     Reborrow(Span),\n \n@@ -422,36 +402,9 @@ pub enum SubregionOrigin<'tcx> {\n     /// (&'a &'b T) where a >= b\n     ReferenceOutlivesReferent(Ty<'tcx>, Span),\n \n-    /// Type or region parameters must be in scope.\n-    ParameterInScope(ParameterOrigin, Span),\n-\n-    /// The type T of an expression E must outlive the lifetime for E.\n-    ExprTypeIsNotInScope(Ty<'tcx>, Span),\n-\n-    /// A `ref b` whose region does not enclose the decl site\n-    BindingTypeIsNotValidAtDecl(Span),\n-\n-    /// Regions appearing in a method receiver must outlive method call\n-    CallRcvr(Span),\n-\n-    /// Regions appearing in a function argument must outlive func call\n-    CallArg(Span),\n-\n     /// Region in return type of invoked fn must enclose call\n     CallReturn(Span),\n \n-    /// Operands must be in scope\n-    Operand(Span),\n-\n-    /// Region resulting from a `&` expr must enclose the `&` expr\n-    AddrOf(Span),\n-\n-    /// An auto-borrow that does not enclose the expr where it occurs\n-    AutoBorrow(Span),\n-\n-    /// Region constraint arriving from destructor safety\n-    SafeDestructor(Span),\n-\n     /// Comparing the signature and requirements of an impl method against\n     /// the containing trait.\n     CompareImplMethodObligation {\n@@ -1809,29 +1762,14 @@ impl<'tcx> SubregionOrigin<'tcx> {\n     pub fn span(&self) -> Span {\n         match *self {\n             Subtype(ref a) => a.span(),\n-            InfStackClosure(a) => a,\n-            InvokeClosure(a) => a,\n-            DerefPointer(a) => a,\n-            ClosureCapture(a, _) => a,\n-            IndexSlice(a) => a,\n             RelateObjectBound(a) => a,\n             RelateParamBound(a, _) => a,\n             RelateRegionParamBound(a) => a,\n-            RelateDefaultParamBound(a, _) => a,\n             Reborrow(a) => a,\n             ReborrowUpvar(a, _) => a,\n             DataBorrowed(_, a) => a,\n             ReferenceOutlivesReferent(_, a) => a,\n-            ParameterInScope(_, a) => a,\n-            ExprTypeIsNotInScope(_, a) => a,\n-            BindingTypeIsNotValidAtDecl(a) => a,\n-            CallRcvr(a) => a,\n-            CallArg(a) => a,\n             CallReturn(a) => a,\n-            Operand(a) => a,\n-            AddrOf(a) => a,\n-            AutoBorrow(a) => a,\n-            SafeDestructor(a) => a,\n             CompareImplMethodObligation { span, .. } => span,\n         }\n     }"}]}