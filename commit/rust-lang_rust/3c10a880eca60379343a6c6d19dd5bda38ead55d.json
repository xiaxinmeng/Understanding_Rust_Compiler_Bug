{"sha": "3c10a880eca60379343a6c6d19dd5bda38ead55d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjMTBhODgwZWNhNjAzNzkzNDNhNmM2ZDE5ZGQ1YmRhMzhlYWQ1NWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-13T17:29:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-13T17:29:22Z"}, "message": "Auto merge of #81494 - cuviper:btree-node-init, r=Mark-Simulacrum\n\nInitialize BTree nodes directly in the heap\n\nWe can avoid any stack-local nodes entirely by using `Box::new_uninit`, and since the nodes are mostly `MaybeUninit` fields, we only need a couple of actual writes before `assume_init`. This should help with the stack overflows in #81444, and may also improve performance in general.\n\nr? `@Mark-Simulacrum`\ncc `@ssomers`", "tree": {"sha": "8018d176ef77379f7d3f776833257fa5f7d92064", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8018d176ef77379f7d3f776833257fa5f7d92064"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c10a880eca60379343a6c6d19dd5bda38ead55d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c10a880eca60379343a6c6d19dd5bda38ead55d", "html_url": "https://github.com/rust-lang/rust/commit/3c10a880eca60379343a6c6d19dd5bda38ead55d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c10a880eca60379343a6c6d19dd5bda38ead55d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e0241c63755ea28045d512b742f50b307874419", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e0241c63755ea28045d512b742f50b307874419", "html_url": "https://github.com/rust-lang/rust/commit/7e0241c63755ea28045d512b742f50b307874419"}, {"sha": "5a58cf4943da9ea50c0cc534756bee31b4ac1899", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a58cf4943da9ea50c0cc534756bee31b4ac1899", "html_url": "https://github.com/rust-lang/rust/commit/5a58cf4943da9ea50c0cc534756bee31b4ac1899"}], "stats": {"total": 48, "additions": 30, "deletions": 18}, "files": [{"sha": "50d6fb11b11ce8af500da8fc9f75629080f66b66", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3c10a880eca60379343a6c6d19dd5bda38ead55d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c10a880eca60379343a6c6d19dd5bda38ead55d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=3c10a880eca60379343a6c6d19dd5bda38ead55d", "patch": "@@ -67,17 +67,24 @@ struct LeafNode<K, V> {\n }\n \n impl<K, V> LeafNode<K, V> {\n-    /// Creates a new `LeafNode`. Unsafe because all nodes should really be hidden behind\n+    /// Initializes a new `LeafNode` in-place.\n+    unsafe fn init(this: *mut Self) {\n+        // As a general policy, we leave fields uninitialized if they can be, as this should\n+        // be both slightly faster and easier to track in Valgrind.\n+        unsafe {\n+            // parent_idx, keys, and vals are all MaybeUninit\n+            ptr::addr_of_mut!((*this).parent).write(None);\n+            ptr::addr_of_mut!((*this).len).write(0);\n+        }\n+    }\n+\n+    /// Creates a new boxed `LeafNode`. Unsafe because all nodes should really be hidden behind\n     /// `BoxedNode`, preventing accidental dropping of uninitialized keys and values.\n-    unsafe fn new() -> Self {\n-        LeafNode {\n-            // As a general policy, we leave fields uninitialized if they can be, as this should\n-            // be both slightly faster and easier to track in Valgrind.\n-            keys: MaybeUninit::uninit_array(),\n-            vals: MaybeUninit::uninit_array(),\n-            parent: None,\n-            parent_idx: MaybeUninit::uninit(),\n-            len: 0,\n+    unsafe fn new() -> Box<Self> {\n+        unsafe {\n+            let mut leaf = Box::new_uninit();\n+            LeafNode::init(leaf.as_mut_ptr());\n+            leaf.assume_init()\n         }\n     }\n }\n@@ -99,15 +106,20 @@ struct InternalNode<K, V> {\n }\n \n impl<K, V> InternalNode<K, V> {\n-    /// Creates a new `InternalNode`.\n+    /// Creates a new boxed `InternalNode`.\n     ///\n-    /// This is unsafe for two reasons. First, it returns an `InternalNode` by value, risking\n+    /// This is unsafe for two reasons. First, it returns an owned `InternalNode` in a box, risking\n     /// dropping of uninitialized fields. Second, an invariant of internal nodes is that `len + 1`\n     /// edges are initialized and valid, meaning that even when the node is empty (having a\n     /// `len` of 0), there must be one initialized and valid edge. This function does not set up\n     /// such an edge.\n-    unsafe fn new() -> Self {\n-        InternalNode { data: unsafe { LeafNode::new() }, edges: MaybeUninit::uninit_array() }\n+    unsafe fn new() -> Box<Self> {\n+        unsafe {\n+            let mut node = Box::<Self>::new_uninit();\n+            // We only need to initialize the data; the edges are MaybeUninit.\n+            LeafNode::init(ptr::addr_of_mut!((*node.as_mut_ptr()).data));\n+            node.assume_init()\n+        }\n     }\n }\n \n@@ -133,7 +145,7 @@ impl<K, V> Root<K, V> {\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n     fn new_leaf() -> Self {\n-        Self::from_new_leaf(Box::new(unsafe { LeafNode::new() }))\n+        Self::from_new_leaf(unsafe { LeafNode::new() })\n     }\n \n     fn from_new_leaf(leaf: Box<LeafNode<K, V>>) -> Self {\n@@ -143,7 +155,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n     fn new_internal(child: Root<K, V>) -> Self {\n-        let mut new_node = Box::new(unsafe { InternalNode::new() });\n+        let mut new_node = unsafe { InternalNode::new() };\n         new_node.edges[0].write(child.node);\n         NodeRef::from_new_internal(new_node, child.height + 1)\n     }\n@@ -1075,7 +1087,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     ///   allocated node.\n     pub fn split(mut self) -> SplitResult<'a, K, V, marker::Leaf> {\n         unsafe {\n-            let mut new_node = Box::new(LeafNode::new());\n+            let mut new_node = LeafNode::new();\n \n             let kv = self.split_leaf_data(&mut new_node);\n \n@@ -1110,7 +1122,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     pub fn split(mut self) -> SplitResult<'a, K, V, marker::Internal> {\n         let old_len = self.node.len();\n         unsafe {\n-            let mut new_node = Box::new(InternalNode::new());\n+            let mut new_node = InternalNode::new();\n             let kv = self.split_leaf_data(&mut new_node.data);\n             let new_len = usize::from(new_node.data.len);\n             move_to_slice("}]}