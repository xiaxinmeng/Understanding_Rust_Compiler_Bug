{"sha": "b6edc59413f79016a1063c2ec6bc05516bc99cb6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2ZWRjNTk0MTNmNzkwMTZhMTA2M2MyZWM2YmMwNTUxNmJjOTljYjY=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2014-09-16T14:49:26Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2014-09-27T14:25:46Z"}, "message": "complete btree rewrite\n\nReplaces BTree with BTreeMap and BTreeSet, which are completely new implementations.\nBTreeMap's internal Node representation is particularly inefficient at the moment to\nmake this first implementation easy to reason about and fairly safe. Both collections\nare also currently missing some of the tooling specific to sorted collections, which\nis planned as future work pending reform of these APIs. General implementation issues\nare discussed with TODOs internally\n\nPerf results on x86_64 Linux:\n\ntest treemap::bench::find_rand_100                         ... bench:        76 ns/iter (+/- 4)\ntest treemap::bench::find_rand_10_000                      ... bench:       163 ns/iter (+/- 6)\ntest treemap::bench::find_seq_100                          ... bench:        77 ns/iter (+/- 3)\ntest treemap::bench::find_seq_10_000                       ... bench:       115 ns/iter (+/- 1)\ntest treemap::bench::insert_rand_100                       ... bench:       111 ns/iter (+/- 1)\ntest treemap::bench::insert_rand_10_000                    ... bench:       996 ns/iter (+/- 18)\ntest treemap::bench::insert_seq_100                        ... bench:       486 ns/iter (+/- 20)\ntest treemap::bench::insert_seq_10_000                     ... bench:       800 ns/iter (+/- 15)\n\ntest btree::map::bench::find_rand_100                      ... bench:        74 ns/iter (+/- 4)\ntest btree::map::bench::find_rand_10_000                   ... bench:       153 ns/iter (+/- 5)\ntest btree::map::bench::find_seq_100                       ... bench:        82 ns/iter (+/- 1)\ntest btree::map::bench::find_seq_10_000                    ... bench:       108 ns/iter (+/- 0)\ntest btree::map::bench::insert_rand_100                    ... bench:       220 ns/iter (+/- 1)\ntest btree::map::bench::insert_rand_10_000                 ... bench:       620 ns/iter (+/- 16)\ntest btree::map::bench::insert_seq_100                     ... bench:       411 ns/iter (+/- 12)\ntest btree::map::bench::insert_seq_10_000                  ... bench:       534 ns/iter (+/- 14)\n\nBTreeMap still has a lot of room for optimization, but it's already beating out TreeMap on most access patterns.\n\n[breaking-change]", "tree": {"sha": "daadc61d56ca134036e1cf5b23ae4a34667267ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/daadc61d56ca134036e1cf5b23ae4a34667267ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6edc59413f79016a1063c2ec6bc05516bc99cb6", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6edc59413f79016a1063c2ec6bc05516bc99cb6", "html_url": "https://github.com/rust-lang/rust/commit/b6edc59413f79016a1063c2ec6bc05516bc99cb6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6edc59413f79016a1063c2ec6bc05516bc99cb6/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d299bafb31a7c0528e690e48ec6d5591f1eb0bac", "url": "https://api.github.com/repos/rust-lang/rust/commits/d299bafb31a7c0528e690e48ec6d5591f1eb0bac", "html_url": "https://github.com/rust-lang/rust/commit/d299bafb31a7c0528e690e48ec6d5591f1eb0bac"}], "stats": {"total": 3143, "additions": 2222, "deletions": 921}, "files": [{"sha": "f6011976b65d01897b79dd6aee71002463785565", "filename": "src/libcollections/btree.rs", "status": "removed", "additions": 0, "deletions": 919, "changes": 919, "blob_url": "https://github.com/rust-lang/rust/blob/d299bafb31a7c0528e690e48ec6d5591f1eb0bac/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d299bafb31a7c0528e690e48ec6d5591f1eb0bac/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=d299bafb31a7c0528e690e48ec6d5591f1eb0bac", "patch": "@@ -1,919 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-\n-// NB. this is not deprecated for removal, just deprecating the\n-// current implementation. If the major pain-points are addressed\n-// (overuse of by-value self and .clone), this can be removed.\n-#![deprecated = \"the current implementation is extremely inefficient, \\\n-                 prefer a HashMap, TreeMap or TrieMap\"]\n-#![allow(deprecated)]\n-\n-//! Starting implementation of a B-tree for Rust.\n-//! Structure inspired by Github user davidhalperin's gist.\n-\n-// A B-tree contains a root node (which contains a vector of elements),\n-// a length (the height of the tree), and lower and upper bounds on the\n-// number of elements that a given node can contain.\n-\n-use core::prelude::*;\n-\n-use alloc::boxed::Box;\n-use core::fmt;\n-use core::fmt::Show;\n-\n-use MutableSeq;\n-use vec::Vec;\n-\n-#[allow(missing_doc)]\n-pub struct BTree<K, V> {\n-    root: Node<K, V>,\n-    len: uint,\n-    lower_bound: uint,\n-    upper_bound: uint\n-}\n-\n-impl<K: Ord, V> BTree<K, V> {\n-    /// Returns new `BTree` with root node (leaf) and user-supplied lower bound\n-    /// The lower bound applies to every node except the root node.\n-    pub fn new(k: K, v: V, lb: uint) -> BTree<K, V> {\n-        BTree {\n-            root: Node::new_leaf(vec!(LeafElt::new(k, v))),\n-            len: 1,\n-            lower_bound: lb,\n-            upper_bound: 2 * lb\n-        }\n-    }\n-\n-    /// Helper function for `clone`: returns new BTree with supplied root node,\n-    /// length, and lower bound. For use when the length is known already.\n-    fn new_with_node_len(n: Node<K, V>,\n-                         length: uint,\n-                         lb: uint) -> BTree<K, V> {\n-        BTree {\n-            root: n,\n-            len: length,\n-            lower_bound: lb,\n-            upper_bound: 2 * lb\n-        }\n-    }\n-}\n-\n-// We would probably want to remove the dependence on the Clone trait in the future.\n-// It is here as a crutch to ensure values can be passed around through the tree's nodes\n-// especially during insertions and deletions.\n-impl<K: Clone + Ord, V: Clone> BTree<K, V> {\n-    /// Returns the value of a given key, which may not exist in the tree.\n-    /// Calls the root node's get method.\n-    pub fn get(self, k: K) -> Option<V> {\n-        return self.root.get(k);\n-    }\n-\n-    /// An insert method that uses the `clone` method for support.\n-    pub fn insert(mut self, k: K, v: V) -> BTree<K, V> {\n-        let (a, b) = self.root.clone().insert(k, v, self.upper_bound.clone());\n-        if b {\n-            match a.clone() {\n-                LeafNode(leaf) => {\n-                    self.root = Node::new_leaf(leaf.clone().elts);\n-                }\n-                BranchNode(branch) => {\n-                    self.root = Node::new_branch(branch.clone().elts,\n-                                                 branch.clone().rightmost_child);\n-                }\n-            }\n-        }\n-        self\n-    }\n-}\n-\n-impl<K: Clone + Ord, V: Clone> Clone for BTree<K, V> {\n-    fn clone(&self) -> BTree<K, V> {\n-        BTree::new_with_node_len(self.root.clone(), self.len, self.lower_bound)\n-    }\n-}\n-\n-impl<K: Ord, V: Eq> PartialEq for BTree<K, V> {\n-    fn eq(&self, other: &BTree<K, V>) -> bool {\n-        self.root.cmp(&other.root) == Equal\n-    }\n-}\n-\n-impl<K: Ord, V: Eq> Eq for BTree<K, V> {}\n-\n-impl<K: Ord, V: Eq> PartialOrd for BTree<K, V> {\n-    fn partial_cmp(&self, other: &BTree<K, V>) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl<K: Ord, V: Eq> Ord for BTree<K, V> {\n-    /// Returns an ordering based on the root nodes of each `BTree`.\n-    fn cmp(&self, other: &BTree<K, V>) -> Ordering {\n-        self.root.cmp(&other.root)\n-    }\n-}\n-\n-impl<K: fmt::Show + Ord, V: fmt::Show> fmt::Show for BTree<K, V> {\n-    /// Returns a string representation of the `BTree`.\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.root.fmt(f)\n-    }\n-}\n-\n-\n-// Node types\n-//\n-// A node is either a LeafNode or a BranchNode, which contain either a Leaf or a Branch.\n-// Branches contain BranchElts, which contain a left child (another node) and a key-value\n-// pair. Branches also contain the rightmost child of the elements in the array.\n-// Leaves contain LeafElts, which do not have children.\n-enum Node<K, V> {\n-    LeafNode(Leaf<K, V>),\n-    BranchNode(Branch<K, V>)\n-}\n-\n-\n-impl<K: Ord, V> Node<K, V> {\n-    /// Creates a new leaf node given a vector of elements.\n-    fn new_leaf(vec: Vec<LeafElt<K, V>>) -> Node<K,V> {\n-        LeafNode(Leaf::new(vec))\n-    }\n-\n-    /// Creates a new branch node given a vector of an elements and a pointer to a rightmost child.\n-    fn new_branch(vec: Vec<BranchElt<K, V>>, right: Box<Node<K, V>>)\n-                  -> Node<K, V> {\n-        BranchNode(Branch::new(vec, right))\n-    }\n-\n-    /// Determines whether the given Node contains a Branch or a Leaf.\n-    /// Used in testing.\n-    fn is_leaf(&self) -> bool {\n-        match self {\n-            &LeafNode(..) => true,\n-            &BranchNode(..) => false\n-        }\n-    }\n-\n-    /// A binary search function for Nodes.\n-    /// Calls either the Branch's or the Leaf's bsearch function.\n-    fn bsearch_node(&self, k: K) -> Option<uint> {\n-         match self {\n-             &LeafNode(ref leaf) => leaf.bsearch_leaf(k),\n-             &BranchNode(ref branch) => branch.bsearch_branch(k)\n-         }\n-     }\n-}\n-\n-impl<K: Clone + Ord, V: Clone> Node<K, V> {\n-    /// Returns the corresponding value to the provided key.\n-    /// `get()` is called in different ways on a branch or a leaf.\n-    fn get(&self, k: K) -> Option<V> {\n-        match *self {\n-            LeafNode(ref leaf) => return leaf.get(k),\n-            BranchNode(ref branch) => return branch.get(k)\n-        }\n-    }\n-\n-    /// Matches on the `Node`, then performs and returns the appropriate insert method.\n-    fn insert(self, k: K, v: V, ub: uint) -> (Node<K, V>, bool) {\n-        match self {\n-            LeafNode(leaf) => leaf.insert(k, v, ub),\n-            BranchNode(branch) => branch.insert(k, v, ub)\n-        }\n-    }\n-}\n-\n-impl<K: Clone + Ord, V: Clone> Clone for Node<K, V> {\n-    /// Returns a new `Node` based on whether or not it is a branch or a leaf.\n-    fn clone(&self) -> Node<K, V> {\n-        match *self {\n-            LeafNode(ref leaf) => {\n-                Node::new_leaf(leaf.elts.clone())\n-            }\n-            BranchNode(ref branch) => {\n-                Node::new_branch(branch.elts.clone(),\n-                                 branch.rightmost_child.clone())\n-            }\n-        }\n-    }\n-}\n-\n-impl<K: Ord, V: Eq> PartialEq for Node<K, V> {\n-    fn eq(&self, other: &Node<K, V>) -> bool {\n-        match *self{\n-            BranchNode(ref branch) => {\n-                if other.is_leaf() {\n-                    return false;\n-                }\n-                match *other {\n-                    BranchNode(ref branch2) => branch.cmp(branch2) == Equal,\n-                    LeafNode(..) => false\n-                }\n-            }\n-            LeafNode(ref leaf) => {\n-                match *other {\n-                    LeafNode(ref leaf2) => leaf.cmp(leaf2) == Equal,\n-                    BranchNode(..) => false\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<K: Ord, V: Eq> Eq for Node<K, V> {}\n-\n-impl<K: Ord, V: Eq> PartialOrd for Node<K, V> {\n-    fn partial_cmp(&self, other: &Node<K, V>) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl<K: Ord, V: Eq> Ord for Node<K, V> {\n-    /// Implementation of `Ord` for `Node`s.\n-    fn cmp(&self, other: &Node<K, V>) -> Ordering {\n-        match *self {\n-            LeafNode(ref leaf) => {\n-                match *other {\n-                    LeafNode(ref leaf2) => leaf.cmp(leaf2),\n-                    BranchNode(_) => Less\n-                }\n-            }\n-            BranchNode(ref branch) => {\n-                match *other {\n-                    BranchNode(ref branch2) => branch.cmp(branch2),\n-                    LeafNode(_) => Greater\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<K: fmt::Show + Ord, V: fmt::Show> fmt::Show for Node<K, V> {\n-    /// Returns a string representation of a `Node`.\n-    /// Will iterate over the Node and show `Key: x, value: y, child: ()`\n-    /// for all elements in the `Node`. `child` only exists if the `Node` contains\n-    /// a branch.\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            LeafNode(ref leaf) => leaf.fmt(f),\n-            BranchNode(ref branch) => branch.fmt(f),\n-        }\n-    }\n-}\n-\n-\n-// A leaf is a vector with elements that contain no children. A leaf also\n-// does not contain a rightmost child.\n-struct Leaf<K, V> {\n-    elts: Vec<LeafElt<K, V>>\n-}\n-\n-// Vector of values with children, plus a rightmost child (greater than all)\n-struct Branch<K, V> {\n-    elts: Vec<BranchElt<K,V>>,\n-    rightmost_child: Box<Node<K, V>>,\n-}\n-\n-\n-impl<K: Ord, V> Leaf<K, V> {\n-    /// Creates a new `Leaf` from a vector of `LeafElts`.\n-    fn new(vec: Vec<LeafElt<K, V>>) -> Leaf<K, V> {\n-        Leaf {\n-            elts: vec\n-        }\n-    }\n-\n-    /// Searches a leaf for a spot for a new element using a binary search.\n-    /// Returns `None` if the element is already in the vector.\n-    fn bsearch_leaf(&self, k: K) -> Option<uint> {\n-        let mut high: uint = self.elts.len();\n-        let mut low: uint = 0;\n-        let mut midpoint: uint = (high - low) / 2 ;\n-        if midpoint == high {\n-            midpoint = 0;\n-        }\n-        loop {\n-            let order = self.elts[midpoint].key.cmp(&k);\n-            match order {\n-                Equal => {\n-                    return None;\n-                }\n-                Greater => {\n-                    if midpoint > 0 {\n-                        if self.elts[midpoint - 1].key.cmp(&k) == Less {\n-                            return Some(midpoint);\n-                        }\n-                        else {\n-                            let tmp = midpoint;\n-                            midpoint = midpoint / 2;\n-                            high = tmp;\n-                            continue;\n-                        }\n-                    }\n-                    else {\n-                        return Some(0);\n-                    }\n-                }\n-                Less => {\n-                    if midpoint + 1 < self.elts.len() {\n-                        if self.elts[midpoint + 1].key.cmp(&k) == Greater {\n-                            return Some(midpoint);\n-                        }\n-                        else {\n-                            let tmp = midpoint;\n-                            midpoint = (high + low) / 2;\n-                            low = tmp;\n-                        }\n-                    }\n-                    else {\n-                        return Some(self.elts.len());\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-\n-impl<K: Clone + Ord, V: Clone> Leaf<K, V> {\n-    /// Returns the corresponding value to the supplied key.\n-    fn get(&self, k: K) -> Option<V> {\n-        for s in self.elts.iter() {\n-            let order = s.key.cmp(&k);\n-            match order {\n-                Equal => return Some(s.value.clone()),\n-                _ => {}\n-            }\n-        }\n-        return None;\n-    }\n-\n-    /// Uses `clone()` to facilitate inserting new elements into a tree.\n-    fn insert(mut self, k: K, v: V, ub: uint) -> (Node<K, V>, bool) {\n-        let to_insert = LeafElt::new(k, v);\n-        let index: Option<uint> = self.bsearch_leaf(to_insert.clone().key);\n-        //Check index to see whether we actually inserted the element into the vector.\n-        match index {\n-            //If the index is None, the new element already exists in the vector.\n-            None => {\n-                return (Node::new_leaf(self.clone().elts), false);\n-            }\n-            //If there is an index, insert at that index.\n-            Some(i) => {\n-                if i >= self.elts.len() {\n-                    self.elts.push(to_insert.clone());\n-                }\n-                else {\n-                    self.elts.insert(i, to_insert.clone());\n-                }\n-            }\n-        }\n-        //If we have overfilled the vector (by making its size greater than the\n-        //upper bound), we return a new Branch with one element and two children.\n-        if self.elts.len() > ub {\n-            let midpoint_opt = self.elts.remove(ub / 2);\n-            let midpoint = midpoint_opt.unwrap();\n-            let (left_leaf, right_leaf) = self.elts.partition(|le|\n-                                                              le.key.cmp(&midpoint.key.clone())\n-                                                              == Less);\n-            let branch_return = Node::new_branch(vec!(BranchElt::new(midpoint.key.clone(),\n-                                                                  midpoint.value.clone(),\n-                                                             box Node::new_leaf(left_leaf))),\n-                                            box Node::new_leaf(right_leaf));\n-            return (branch_return, true);\n-        }\n-        (Node::new_leaf(self.elts.clone()), true)\n-    }\n-}\n-\n-impl<K: Clone + Ord, V: Clone> Clone for Leaf<K, V> {\n-    /// Returns a new `Leaf` with the same elts.\n-    fn clone(&self) -> Leaf<K, V> {\n-        Leaf::new(self.elts.clone())\n-    }\n-}\n-\n-impl<K: Ord, V: Eq> PartialEq for Leaf<K, V> {\n-    fn eq(&self, other: &Leaf<K, V>) -> bool {\n-        self.elts == other.elts\n-    }\n-}\n-\n-impl<K: Ord, V: Eq> Eq for Leaf<K, V> {}\n-\n-impl<K: Ord, V: Eq> PartialOrd for Leaf<K, V> {\n-    fn partial_cmp(&self, other: &Leaf<K, V>) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl<K: Ord, V: Eq> Ord for Leaf<K, V> {\n-    /// Returns an ordering based on the first element of each `Leaf`.\n-    fn cmp(&self, other: &Leaf<K, V>) -> Ordering {\n-        if self.elts.len() > other.elts.len() {\n-            return Greater;\n-        }\n-        if self.elts.len() < other.elts.len() {\n-            return Less;\n-        }\n-        self.elts[0].cmp(&other.elts[0])\n-    }\n-}\n-\n-\n-impl<K: fmt::Show + Ord, V: fmt::Show> fmt::Show for Leaf<K, V> {\n-    /// Returns a string representation of a `Leaf`.\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        for (i, s) in self.elts.iter().enumerate() {\n-            if i != 0 { try!(write!(f, \" // \")) }\n-            try!(write!(f, \"{}\", *s))\n-        }\n-        Ok(())\n-    }\n-}\n-\n-\n-impl<K: Ord, V> Branch<K, V> {\n-    /// Creates a new `Branch` from a vector of `BranchElts` and a rightmost child (a node).\n-    fn new(vec: Vec<BranchElt<K, V>>, right: Box<Node<K, V>>)\n-           -> Branch<K, V> {\n-        Branch {\n-            elts: vec,\n-            rightmost_child: right\n-        }\n-    }\n-\n-    fn bsearch_branch(&self, k: K) -> Option<uint> {\n-        let mut midpoint: uint = self.elts.len() / 2;\n-        let mut high: uint = self.elts.len();\n-        let mut low: uint = 0u;\n-        if midpoint == high {\n-            midpoint = 0u;\n-        }\n-        loop {\n-            let order = self.elts[midpoint].key.cmp(&k);\n-            match order {\n-                Equal => {\n-                    return None;\n-                }\n-                Greater => {\n-                    if midpoint > 0 {\n-                        if self.elts[midpoint - 1].key.cmp(&k) == Less {\n-                            return Some(midpoint);\n-                        }\n-                        else {\n-                            let tmp = midpoint;\n-                            midpoint = (midpoint - low) / 2;\n-                            high = tmp;\n-                            continue;\n-                        }\n-                    }\n-                    else {\n-                        return Some(0);\n-                    }\n-                }\n-                Less => {\n-                    if midpoint + 1 < self.elts.len() {\n-                        if self.elts[midpoint + 1].key.cmp(&k) == Greater {\n-                            return Some(midpoint);\n-                        }\n-                        else {\n-                            let tmp = midpoint;\n-                            midpoint = (high - midpoint) / 2;\n-                            low = tmp;\n-                        }\n-                    }\n-                    else {\n-                        return Some(self.elts.len());\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<K: Clone + Ord, V: Clone> Branch<K, V> {\n-    /// Returns the corresponding value to the supplied key.\n-    /// If the key is not there, find the child that might hold it.\n-    fn get(&self, k: K) -> Option<V> {\n-        for s in self.elts.iter() {\n-            let order = s.key.cmp(&k);\n-            match order {\n-                Less => return s.left.get(k),\n-                Equal => return Some(s.value.clone()),\n-                _ => {}\n-            }\n-        }\n-        self.rightmost_child.get(k)\n-    }\n-\n-    /// An insert method that uses `.clone()` for support.\n-    fn insert(mut self, k: K, v: V, ub: uint) -> (Node<K, V>, bool) {\n-        let mut new_branch = Node::new_branch(self.clone().elts, self.clone().rightmost_child);\n-        let mut outcome = false;\n-        let index: Option<uint> = new_branch.bsearch_node(k.clone());\n-        //First, find which path down the tree will lead to the appropriate leaf\n-        //for the key-value pair.\n-        match index.clone() {\n-            None => {\n-                return (Node::new_branch(self.clone().elts,\n-                                         self.clone().rightmost_child),\n-                        outcome);\n-            }\n-            Some(i) => {\n-                if i == self.elts.len() {\n-                    let new_outcome = self.clone().rightmost_child.insert(k.clone(),\n-                                                                          v.clone(),\n-                                                                          ub.clone());\n-                    new_branch = new_outcome.clone().val0();\n-                    outcome = new_outcome.val1();\n-                }\n-                else {\n-                    let new_outcome = self.elts[i].left.clone().insert(k.clone(),\n-                                                                       v.clone(),\n-                                                                       ub.clone());\n-                    new_branch = new_outcome.clone().val0();\n-                    outcome = new_outcome.val1();\n-                }\n-                //Check to see whether a branch or a leaf was returned from the\n-                //tree traversal.\n-                match new_branch.clone() {\n-                    //If we have a leaf, we do not need to resize the tree,\n-                    //so we can return false.\n-                    LeafNode(..) => {\n-                        if i == self.elts.len() {\n-                            self.rightmost_child = box new_branch.clone();\n-                        }\n-                        else {\n-                            self.elts.get_mut(i).left = box new_branch.clone();\n-                        }\n-                        return (Node::new_branch(self.clone().elts,\n-                                                 self.clone().rightmost_child),\n-                                true);\n-                    }\n-                    //If we have a branch, we might need to refactor the tree.\n-                    BranchNode(..) => {}\n-                }\n-            }\n-        }\n-        //If we inserted something into the tree, do the following:\n-        if outcome {\n-            match new_branch.clone() {\n-                //If we have a new leaf node, integrate it into the current branch\n-                //and return it, saying we have inserted a new element.\n-                LeafNode(..) => {\n-                    if index.unwrap() == self.elts.len() {\n-                        self.rightmost_child = box new_branch;\n-                    }\n-                    else {\n-                        self.elts.get_mut(index.unwrap()).left = box new_branch;\n-                    }\n-                    return (Node::new_branch(self.clone().elts,\n-                                             self.clone().rightmost_child),\n-                            true);\n-                }\n-                //If we have a new branch node, attempt to insert it into the tree\n-                //as with the key-value pair, then check to see if the node is overfull.\n-                BranchNode(branch) => {\n-                    let new_elt = branch.elts[0].clone();\n-                    let new_elt_index = self.bsearch_branch(new_elt.clone().key);\n-                    match new_elt_index {\n-                        None => {\n-                            return (Node::new_branch(self.clone().elts,\n-                                                     self.clone().rightmost_child),\n-                                    false);\n-                            }\n-                        Some(i) => {\n-                            self.elts.insert(i, new_elt);\n-                            if i + 1 >= self.elts.len() {\n-                                self.rightmost_child = branch.clone().rightmost_child;\n-                            }\n-                            else {\n-                                self.elts.get_mut(i + 1).left =\n-                                    branch.clone().rightmost_child;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            //If the current node is overfilled, create a new branch with one element\n-            //and two children.\n-            if self.elts.len() > ub {\n-                let midpoint = self.elts.remove(ub / 2).unwrap();\n-                let (new_left, new_right) = self.clone().elts.partition(|le|\n-                                                                midpoint.key.cmp(&le.key)\n-                                                                        == Greater);\n-                new_branch = Node::new_branch(\n-                    vec!(BranchElt::new(midpoint.clone().key,\n-                                     midpoint.clone().value,\n-                                     box Node::new_branch(new_left,\n-                                                       midpoint.clone().left))),\n-                    box Node::new_branch(new_right, self.clone().rightmost_child));\n-                return (new_branch, true);\n-            }\n-        }\n-        (Node::new_branch(self.elts.clone(), self.rightmost_child.clone()), outcome)\n-    }\n-}\n-\n-impl<K: Clone + Ord, V: Clone> Clone for Branch<K, V> {\n-    /// Returns a new branch using the clone methods of the `Branch`'s internal variables.\n-    fn clone(&self) -> Branch<K, V> {\n-        Branch::new(self.elts.clone(), self.rightmost_child.clone())\n-    }\n-}\n-\n-impl<K: Ord, V: Eq> PartialEq for Branch<K, V> {\n-    fn eq(&self, other: &Branch<K, V>) -> bool {\n-        self.elts == other.elts\n-    }\n-}\n-\n-impl<K: Ord, V: Eq> Eq for Branch<K, V> {}\n-\n-impl<K: Ord, V: Eq> PartialOrd for Branch<K, V> {\n-    fn partial_cmp(&self, other: &Branch<K, V>) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl<K: Ord, V: Eq> Ord for Branch<K, V> {\n-    /// Compares the first elements of two `Branch`es to determine an\n-    /// `Ordering`.\n-    fn cmp(&self, other: &Branch<K, V>) -> Ordering {\n-        if self.elts.len() > other.elts.len() {\n-            return Greater;\n-        }\n-        if self.elts.len() < other.elts.len() {\n-            return Less;\n-        }\n-        self.elts[0].cmp(&other.elts[0])\n-    }\n-}\n-\n-impl<K: fmt::Show + Ord, V: fmt::Show> fmt::Show for Branch<K, V> {\n-    /// Returns a string representation of a `Branch`.\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        for (i, s) in self.elts.iter().enumerate() {\n-            if i != 0 { try!(write!(f, \" // \")) }\n-            try!(write!(f, \"{}\", *s))\n-        }\n-        write!(f, \" // rightmost child: ({}) \", *self.rightmost_child)\n-    }\n-}\n-\n-//A LeafElt contains no left child, but a key-value pair.\n-struct LeafElt<K, V> {\n-    key: K,\n-    value: V\n-}\n-\n-//A BranchElt has a left child in insertion to a key-value pair.\n-struct BranchElt<K, V> {\n-    left: Box<Node<K, V>>,\n-    key: K,\n-    value: V\n-}\n-\n-impl<K: Ord, V> LeafElt<K, V> {\n-    /// Creates a new `LeafElt` from a supplied key-value pair.\n-    fn new(k: K, v: V) -> LeafElt<K, V> {\n-        LeafElt {\n-            key: k,\n-            value: v\n-        }\n-    }\n-}\n-\n-impl<K: Clone + Ord, V: Clone> Clone for LeafElt<K, V> {\n-    /// Returns a new `LeafElt` by cloning the key and value.\n-    fn clone(&self) -> LeafElt<K, V> {\n-        LeafElt::new(self.key.clone(), self.value.clone())\n-    }\n-}\n-\n-impl<K: Ord, V: Eq> PartialEq for LeafElt<K, V> {\n-    fn eq(&self, other: &LeafElt<K, V>) -> bool {\n-        self.key == other.key && self.value == other.value\n-    }\n-}\n-\n-impl<K: Ord, V: Eq> Eq for LeafElt<K, V> {}\n-\n-impl<K: Ord, V: Eq> PartialOrd for LeafElt<K, V> {\n-    fn partial_cmp(&self, other: &LeafElt<K, V>) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl<K: Ord, V: Eq> Ord for LeafElt<K, V> {\n-    /// Returns an ordering based on the keys of the `LeafElt`s.\n-    fn cmp(&self, other: &LeafElt<K, V>) -> Ordering {\n-        self.key.cmp(&other.key)\n-    }\n-}\n-\n-impl<K: fmt::Show + Ord, V: fmt::Show> fmt::Show for LeafElt<K, V> {\n-    /// Returns a string representation of a `LeafElt`.\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Key: {}, value: {};\", self.key, self.value)\n-    }\n-}\n-\n-impl<K: Ord, V> BranchElt<K, V> {\n-    /// Creates a new `BranchElt` from a supplied key, value, and left child.\n-    fn new(k: K, v: V, n: Box<Node<K, V>>) -> BranchElt<K, V> {\n-        BranchElt {\n-            left: n,\n-            key: k,\n-            value: v\n-        }\n-    }\n-}\n-\n-\n-impl<K: Clone + Ord, V: Clone> Clone for BranchElt<K, V> {\n-    /// Returns a new `BranchElt` by cloning the key, value, and left child.\n-    fn clone(&self) -> BranchElt<K, V> {\n-        BranchElt::new(self.key.clone(),\n-                       self.value.clone(),\n-                       self.left.clone())\n-    }\n-}\n-\n-impl<K: Ord, V: Eq> PartialEq for BranchElt<K, V>{\n-    fn eq(&self, other: &BranchElt<K, V>) -> bool {\n-        self.key == other.key && self.value == other.value\n-    }\n-}\n-\n-impl<K: Ord, V: Eq> Eq for BranchElt<K, V>{}\n-\n-impl<K: Ord, V: Eq> PartialOrd for BranchElt<K, V> {\n-    fn partial_cmp(&self, other: &BranchElt<K, V>) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl<K: Ord, V: Eq> Ord for BranchElt<K, V> {\n-    /// Fulfills `Ord` for `BranchElts`.\n-    fn cmp(&self, other: &BranchElt<K, V>) -> Ordering {\n-        self.key.cmp(&other.key)\n-    }\n-}\n-\n-impl<K: fmt::Show + Ord, V: fmt::Show> fmt::Show for BranchElt<K, V> {\n-    /// Formats as a string containing the key, value, and child (which should recur to a\n-    /// leaf). Consider changing in future to be more readable.\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Key: {}, value: {}, (child: {})\",\n-               self.key, self.value, *self.left)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test_btree {\n-    use std::prelude::*;\n-\n-    use super::{BTree, Node, LeafElt};\n-\n-    use MutableSeq;\n-\n-    //Tests the functionality of the insert methods (which are unfinished).\n-    #[test]\n-    fn insert_test_one() {\n-        let b = BTree::new(1i, \"abc\".to_string(), 2);\n-        let is_insert = b.insert(2i, \"xyz\".to_string());\n-        assert!(is_insert.root.is_leaf());\n-    }\n-\n-    #[test]\n-    fn insert_test_two() {\n-        let leaf_elt_1 = LeafElt::new(1i, \"aaa\".to_string());\n-        let leaf_elt_2 = LeafElt::new(2i, \"bbb\".to_string());\n-        let leaf_elt_3 = LeafElt::new(3i, \"ccc\".to_string());\n-        let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3));\n-        let b = BTree::new_with_node_len(n, 3, 2);\n-        //println!(\"{}\", b.clone().insert(4, \"ddd\".to_string()).to_string());\n-        assert!(b.insert(4, \"ddd\".to_string()).root.is_leaf());\n-    }\n-\n-    #[test]\n-    fn insert_test_three() {\n-        let leaf_elt_1 = LeafElt::new(1i, \"aaa\".to_string());\n-        let leaf_elt_2 = LeafElt::new(2i, \"bbb\".to_string());\n-        let leaf_elt_3 = LeafElt::new(3i, \"ccc\".to_string());\n-        let leaf_elt_4 = LeafElt::new(4i, \"ddd\".to_string());\n-        let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4));\n-        let b = BTree::new_with_node_len(n, 3, 2);\n-        //println!(\"{}\", b.clone().insert(5, \"eee\".to_string()).to_string());\n-        assert!(!b.insert(5, \"eee\".to_string()).root.is_leaf());\n-    }\n-\n-    #[test]\n-    fn insert_test_four() {\n-        let leaf_elt_1 = LeafElt::new(1i, \"aaa\".to_string());\n-        let leaf_elt_2 = LeafElt::new(2i, \"bbb\".to_string());\n-        let leaf_elt_3 = LeafElt::new(3i, \"ccc\".to_string());\n-        let leaf_elt_4 = LeafElt::new(4i, \"ddd\".to_string());\n-        let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4));\n-        let mut b = BTree::new_with_node_len(n, 3, 2);\n-        b = b.clone().insert(5, \"eee\".to_string());\n-        b = b.clone().insert(6, \"fff\".to_string());\n-        b = b.clone().insert(7, \"ggg\".to_string());\n-        b = b.clone().insert(8, \"hhh\".to_string());\n-        b = b.clone().insert(0, \"omg\".to_string());\n-        //println!(\"{}\", b.clone().to_string());\n-        assert!(!b.root.is_leaf());\n-    }\n-\n-    #[test]\n-    fn bsearch_test_one() {\n-        let b = BTree::new(1i, \"abc\".to_string(), 2u);\n-        assert_eq!(Some(1), b.root.bsearch_node(2));\n-    }\n-\n-    #[test]\n-    fn bsearch_test_two() {\n-        let b = BTree::new(1i, \"abc\".to_string(), 2u);\n-        assert_eq!(Some(0), b.root.bsearch_node(0));\n-    }\n-\n-    #[test]\n-    fn bsearch_test_three() {\n-        let leaf_elt_1 = LeafElt::new(1i, \"aaa\".to_string());\n-        let leaf_elt_2 = LeafElt::new(2i, \"bbb\".to_string());\n-        let leaf_elt_3 = LeafElt::new(4i, \"ccc\".to_string());\n-        let leaf_elt_4 = LeafElt::new(5i, \"ddd\".to_string());\n-        let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4));\n-        let b = BTree::new_with_node_len(n, 3, 2);\n-        assert_eq!(Some(2), b.root.bsearch_node(3));\n-    }\n-\n-    #[test]\n-    fn bsearch_test_four() {\n-        let leaf_elt_1 = LeafElt::new(1i, \"aaa\".to_string());\n-        let leaf_elt_2 = LeafElt::new(2i, \"bbb\".to_string());\n-        let leaf_elt_3 = LeafElt::new(4i, \"ccc\".to_string());\n-        let leaf_elt_4 = LeafElt::new(5i, \"ddd\".to_string());\n-        let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4));\n-        let b = BTree::new_with_node_len(n, 3, 2);\n-        assert_eq!(Some(4), b.root.bsearch_node(800));\n-    }\n-\n-    //Tests the functionality of the get method.\n-    #[test]\n-    fn get_test() {\n-        let b = BTree::new(1i, \"abc\".to_string(), 2);\n-        let val = b.get(1);\n-        assert_eq!(val, Some(\"abc\".to_string()));\n-    }\n-\n-    //Tests the BTree's clone() method.\n-    #[test]\n-    fn btree_clone_test() {\n-        let b = BTree::new(1i, \"abc\".to_string(), 2);\n-        let b2 = b.clone();\n-        assert!(b.root == b2.root)\n-    }\n-\n-    //Tests the BTree's cmp() method when one node is \"less than\" another.\n-    #[test]\n-    fn btree_cmp_test_less() {\n-        let b = BTree::new(1i, \"abc\".to_string(), 2);\n-        let b2 = BTree::new(2i, \"bcd\".to_string(), 2);\n-        assert!(&b.cmp(&b2) == &Less)\n-    }\n-\n-    //Tests the BTree's cmp() method when two nodes are equal.\n-    #[test]\n-    fn btree_cmp_test_eq() {\n-        let b = BTree::new(1i, \"abc\".to_string(), 2);\n-        let b2 = BTree::new(1i, \"bcd\".to_string(), 2);\n-        assert!(&b.cmp(&b2) == &Equal)\n-    }\n-\n-    //Tests the BTree's cmp() method when one node is \"greater than\" another.\n-    #[test]\n-    fn btree_cmp_test_greater() {\n-        let b = BTree::new(1i, \"abc\".to_string(), 2);\n-        let b2 = BTree::new(2i, \"bcd\".to_string(), 2);\n-        assert!(&b2.cmp(&b) == &Greater)\n-    }\n-\n-    //Tests the BTree's to_string() method.\n-    #[test]\n-    fn btree_tostr_test() {\n-        let b = BTree::new(1i, \"abc\".to_string(), 2);\n-        assert_eq!(b.to_string(), \"Key: 1, value: abc;\".to_string())\n-    }\n-\n-}"}, {"sha": "b0ba2254621504f5ac6f28fe19de7fcf78db5e3c", "filename": "src/libcollections/btree/map.rs", "status": "added", "additions": 1203, "deletions": 0, "changes": 1203, "blob_url": "https://github.com/rust-lang/rust/blob/b6edc59413f79016a1063c2ec6bc05516bc99cb6/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6edc59413f79016a1063c2ec6bc05516bc99cb6/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=b6edc59413f79016a1063c2ec6bc05516bc99cb6", "patch": "@@ -0,0 +1,1203 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This implementation is largely based on the high-level description and analysis of B-Trees\n+// found in *Open Data Structures* (ODS). Although our implementation does not use any of\n+// the source found in ODS, if one wishes to review the high-level design of this structure, it\n+// can be freely downloaded at http://opendatastructures.org/. Its contents are as of this\n+// writing (August 2014) freely licensed under the following Creative Commons Attribution\n+// License: [CC BY 2.5 CA](http://creativecommons.org/licenses/by/2.5/ca/).\n+\n+use core::prelude::*;\n+\n+use super::node::*;\n+use std::hash::{Writer, Hash};\n+use core::default::Default;\n+use core::{iter, fmt, mem};\n+use core::fmt::Show;\n+\n+use {Deque, Map, MutableMap, Mutable, MutableSeq};\n+use ringbuf::RingBuf;\n+\n+\n+\n+/// A map based on a B-Tree.\n+#[deriving(Clone)]\n+pub struct BTreeMap<K, V> {\n+    root: Node<K, V>,\n+    length: uint,\n+    depth: uint,\n+    b: uint,\n+}\n+\n+/// An abstract base over-which all other BTree iterators are built.\n+struct AbsEntries<T> {\n+    lca: T,\n+    left: RingBuf<T>,\n+    right: RingBuf<T>,\n+    size: uint,\n+}\n+\n+/// An iterator over a BTreeMap's entries.\n+pub struct Entries<'a, K, V> {\n+    inner: AbsEntries<Traversal<'a, K, V>>\n+}\n+\n+/// A mutable iterator over a BTreeMap's entries.\n+pub struct MutEntries<'a, K, V> {\n+    inner: AbsEntries<MutTraversal<'a, K, V>>\n+}\n+\n+/// An owning iterator over a BTreeMap's entries.\n+pub struct MoveEntries<K, V> {\n+    inner: AbsEntries<MoveTraversal<K, V>>\n+}\n+\n+/// An iterator over a BTreeMap's keys.\n+pub type Keys<'a, K, V> = iter::Map<'static, (&'a K, &'a V), &'a K, Entries<'a, K, V>>;\n+\n+/// An iterator over a BTreeMap's values.\n+pub type Values<'a, K, V> = iter::Map<'static, (&'a K, &'a V), &'a V, Entries<'a, K, V>>;\n+\n+/// A view into a single entry in a map, which may either be vacant or occupied.\n+pub enum Entry<'a, K:'a, V:'a> {\n+    /// A vacant Entry\n+    Vacant(VacantEntry<'a, K, V>),\n+    /// An occupied Entry\n+    Occupied(OccupiedEntry<'a, K, V>),\n+}\n+\n+/// A vacant Entry.\n+pub struct VacantEntry<'a, K:'a, V:'a> {\n+    key: K,\n+    stack: stack::SearchStack<'a, K, V>,\n+}\n+\n+/// An occupied Entry.\n+pub struct OccupiedEntry<'a, K:'a, V:'a> {\n+    stack: stack::SearchStack<'a, K, V>,\n+}\n+\n+impl<K: Ord, V> BTreeMap<K, V> {\n+    /// Makes a new empty BTreeMap with a reasonable choice for B.\n+    pub fn new() -> BTreeMap<K, V> {\n+        //FIXME(Gankro): Tune this as a function of size_of<K/V>?\n+        BTreeMap::with_b(6)\n+    }\n+\n+    /// Makes a new empty BTreeMap with the given B.\n+    pub fn with_b(b: uint) -> BTreeMap<K, V> {\n+        assert!(b > 1, \"B must be greater than 1\");\n+        BTreeMap {\n+            length: 0,\n+            depth: 1,\n+            root: Node::make_leaf_root(b),\n+            b: b,\n+        }\n+    }\n+}\n+\n+impl<K: Ord, V> Map<K, V> for BTreeMap<K, V> {\n+    // Searching in a B-Tree is pretty straightforward.\n+    //\n+    // Start at the root. Try to find the key in the current node. If we find it, return it.\n+    // If it's not in there, follow the edge *before* the smallest key larger than\n+    // the search key. If no such key exists (they're *all* smaller), then just take the last\n+    // edge in the node. If we're in a leaf and we don't find our key, then it's not\n+    // in the tree.\n+    fn find(&self, key: &K) -> Option<&V> {\n+        let mut cur_node = &self.root;\n+        loop {\n+            match cur_node.search(key) {\n+                Found(i) => return cur_node.val(i),\n+                GoDown(i) => match cur_node.edge(i) {\n+                    None => return None,\n+                    Some(next_node) => {\n+                        cur_node = next_node;\n+                        continue;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<K: Ord, V> MutableMap<K, V> for BTreeMap<K, V> {\n+    // See `find` for implementation notes, this is basically a copy-paste with mut's added\n+    fn find_mut(&mut self, key: &K) -> Option<&mut V> {\n+        // temp_node is a Borrowck hack for having a mutable value outlive a loop iteration\n+        let mut temp_node = &mut self.root;\n+        loop {\n+            let cur_node = temp_node;\n+            match cur_node.search(key) {\n+                Found(i) => return cur_node.val_mut(i),\n+                GoDown(i) => match cur_node.edge_mut(i) {\n+                    None => return None,\n+                    Some(next_node) => {\n+                        temp_node = next_node;\n+                        continue;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // Insertion in a B-Tree is a bit complicated.\n+    //\n+    // First we do the same kind of search described in `find`. But we need to maintain a stack of\n+    // all the nodes/edges in our search path. If we find a match for the key we're trying to\n+    // insert, just swap the vals and return the old ones. However, when we bottom out in a leaf,\n+    // we attempt to insert our key-value pair at the same location we would want to follow another\n+    // edge.\n+    //\n+    // If the node has room, then this is done in the obvious way by shifting elements. However,\n+    // if the node itself is full, we split node into two, and give its median key-value\n+    // pair to its parent to insert the new node with. Of course, the parent may also be\n+    // full, and insertion can propagate until we reach the root. If we reach the root, and\n+    // it is *also* full, then we split the root and place the two nodes under a newly made root.\n+    //\n+    // Note that we subtly deviate from Open Data Structures in our implementation of split.\n+    // ODS describes inserting into the node *regardless* of its capacity, and then\n+    // splitting *afterwards* if it happens to be overfull. However, this is inefficient.\n+    // Instead, we split beforehand, and then insert the key-value pair into the appropriate\n+    // result node. This has two consequences:\n+    //\n+    // 1) While ODS produces a left node of size B-1, and a right node of size B,\n+    // we may potentially reverse this. However, this shouldn't effect the analysis.\n+    //\n+    // 2) While ODS may potentially return the pair we *just* inserted after\n+    // the split, we will never do this. Again, this shouldn't effect the analysis.\n+\n+    fn swap(&mut self, key: K, mut value: V) -> Option<V> {\n+        // This is a stack of rawptrs to nodes paired with indices, respectively\n+        // representing the nodes and edges of our search path. We have to store rawptrs\n+        // because as far as Rust is concerned, we can mutate aliased data with such a\n+        // stack. It is of course correct, but what it doesn't know is that we will only\n+        // be popping and using these ptrs one at a time in child-to-parent order. The alternative\n+        // to doing this is to take the Nodes from their parents. This actually makes\n+        // borrowck *really* happy and everything is pretty smooth. However, this creates\n+        // *tons* of pointless writes, and requires us to always walk all the way back to\n+        // the root after an insertion, even if we only needed to change a leaf. Therefore,\n+        // we accept this potential unsafety and complexity in the name of performance.\n+        //\n+        // Regardless, the actual dangerous logic is completely abstracted away from BTreeMap\n+        // by the stack module. All it can do is immutably read nodes, and ask the search stack\n+        // to proceed down some edge by index. This makes the search logic we'll be reusing in a\n+        // few different methods much neater, and of course drastically improves safety.\n+        let mut stack = stack::PartialSearchStack::new(self);\n+\n+        loop {\n+            // Same basic logic as found in `find`, but with PartialSearchStack mediating the\n+            // actual nodes for us\n+            match stack.next().search(&key) {\n+                Found(i) => unsafe {\n+                    // Perfect match, swap the values and return the old one\n+                    let next = stack.into_next();\n+                    mem::swap(next.unsafe_val_mut(i), &mut value);\n+                    return Some(value);\n+                },\n+                GoDown(i) => {\n+                    // We need to keep searching, try to get the search stack\n+                    // to go down further\n+                    stack = match stack.push(i) {\n+                        stack::Done(new_stack) => {\n+                            // We've reached a leaf, perform the insertion here\n+                            new_stack.insert(key, value);\n+                            return None;\n+                        }\n+                        stack::Grew(new_stack) => {\n+                            // We've found the subtree to insert this key/value pair in,\n+                            // keep searching\n+                            new_stack\n+                        }\n+                    };\n+                }\n+            }\n+        }\n+    }\n+\n+    // Deletion is the most complicated operation for a B-Tree.\n+    //\n+    // First we do the same kind of search described in\n+    // `find`. But we need to maintain a stack of all the nodes/edges in our search path.\n+    // If we don't find the key, then we just return `None` and do nothing. If we do find the\n+    // key, we perform two operations: remove the item, and then possibly handle underflow.\n+    //\n+    // # removing the item\n+    //      If the node is a leaf, we just remove the item, and shift\n+    //      any items after it back to fill the hole.\n+    //\n+    //      If the node is an internal node, we *swap* the item with the smallest item in\n+    //      in its right subtree (which must reside in a leaf), and then revert to the leaf\n+    //      case\n+    //\n+    // # handling underflow\n+    //      After removing an item, there may be too few items in the node. We want nodes\n+    //      to be mostly full for efficiency, although we make an exception for the root, which\n+    //      may have as few as one item. If this is the case, we may first try to steal\n+    //      an item from our left or right neighbour.\n+    //\n+    //      To steal from the left (right) neighbour,\n+    //      we take the largest (smallest) item and child from it. We then swap the taken item\n+    //      with the item in their mutual parent that separates them, and then insert the\n+    //      parent's item and the taken child into the first (last) index of the underflowed node.\n+    //\n+    //      However, stealing has the possibility of underflowing our neighbour. If this is the\n+    //      case, we instead *merge* with our neighbour. This of course reduces the number of\n+    //      children in the parent. Therefore, we also steal the item that separates the now\n+    //      merged nodes, and insert it into the merged node.\n+    //\n+    //      Merging may cause the parent to underflow. If this is the case, then we must repeat\n+    //      the underflow handling process on the parent. If merging merges the last two children\n+    //      of the root, then we replace the root with the merged node.\n+\n+    fn pop(&mut self, key: &K) -> Option<V> {\n+        // See `swap` for a more thorough description of the stuff going on in here\n+        let mut stack = stack::PartialSearchStack::new(self);\n+        loop {\n+            match stack.next().search(key) {\n+                Found(i) => {\n+                    // Perfect match. Terminate the stack here, and remove the entry\n+                    return Some(stack.seal(i).remove());\n+                },\n+                GoDown(i) => {\n+                    // We need to keep searching, try to go down the next edge\n+                    stack = match stack.push(i) {\n+                        stack::Done(_) => return None, // We're at a leaf; the key isn't in here\n+                        stack::Grew(new_stack) => {\n+                            new_stack\n+                        }\n+                    };\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// The stack module provides a safe interface for constructing and manipulating a stack of ptrs\n+/// to nodes. By using this module much better safety guarantees can be made, and more search\n+/// boilerplate gets cut out.\n+mod stack {\n+    use core::prelude::*;\n+    use super::BTreeMap;\n+    use super::super::node::*;\n+    use {MutableMap, MutableSeq};\n+    use vec::Vec;\n+\n+    type StackItem<K, V> = (*mut Node<K, V>, uint);\n+    type Stack<K, V> = Vec<StackItem<K, V>>;\n+\n+    /// A PartialSearchStack handles the construction of a search stack.\n+    pub struct PartialSearchStack<'a, K:'a, V:'a> {\n+        map: &'a mut BTreeMap<K, V>,\n+        stack: Stack<K, V>,\n+        next: *mut Node<K, V>,\n+    }\n+\n+    /// A SearchStack represents a full path to an element of interest. It provides methods\n+    /// for manipulating the element at the top of its stack.\n+    pub struct SearchStack<'a, K:'a, V:'a> {\n+        map: &'a mut BTreeMap<K, V>,\n+        stack: Stack<K, V>,\n+        top: StackItem<K, V>,\n+    }\n+\n+    /// The result of asking a PartialSearchStack to push another node onto itself. Either it\n+    /// Grew, in which case it's still Partial, or it found its last node was actually a leaf, in\n+    /// which case it seals itself and yields a complete SearchStack.\n+    pub enum PushResult<'a, K:'a, V:'a> {\n+        Grew(PartialSearchStack<'a, K, V>),\n+        Done(SearchStack<'a, K, V>),\n+    }\n+\n+    impl<'a, K, V> PartialSearchStack<'a, K, V> {\n+        /// Creates a new PartialSearchStack from a BTreeMap by initializing the stack with the\n+        /// root of the tree.\n+        pub fn new<'a>(map: &'a mut BTreeMap<K, V>) -> PartialSearchStack<'a, K, V> {\n+            let depth = map.depth;\n+\n+            PartialSearchStack {\n+                next: &mut map.root as *mut _,\n+                map: map,\n+                stack: Vec::with_capacity(depth),\n+            }\n+        }\n+\n+        /// Pushes the requested child of the stack's current top on top of the stack. If the child\n+        /// exists, then a new PartialSearchStack is yielded. Otherwise, a full SearchStack is\n+        /// yielded.\n+        pub fn push(self, edge: uint) -> PushResult<'a, K, V> {\n+            let map = self.map;\n+            let mut stack = self.stack;\n+            let next_ptr = self.next;\n+            let next_node = unsafe {\n+                &mut *next_ptr\n+            };\n+            let to_insert = (next_ptr, edge);\n+            match next_node.edge_mut(edge) {\n+                None => Done(SearchStack {\n+                    map: map,\n+                    stack: stack,\n+                    top: to_insert,\n+                }),\n+                Some(node) => {\n+                    stack.push(to_insert);\n+                    Grew(PartialSearchStack {\n+                        map: map,\n+                        stack: stack,\n+                        next: node as *mut _,\n+                    })\n+                },\n+            }\n+        }\n+\n+        /// Converts the stack into a mutable reference to its top.\n+        pub fn into_next(self) -> &'a mut Node<K, V> {\n+            unsafe {\n+                &mut *self.next\n+            }\n+        }\n+\n+        /// Gets the top of the stack.\n+        pub fn next(&self) -> &Node<K, V> {\n+            unsafe {\n+                &*self.next\n+            }\n+        }\n+\n+        /// Converts the PartialSearchStack into a SearchStack.\n+        pub fn seal(self, index: uint) -> SearchStack<'a, K, V> {\n+            SearchStack {\n+                map: self.map,\n+                stack: self.stack,\n+                top: (self.next as *mut _, index),\n+            }\n+        }\n+    }\n+\n+    impl<'a, K, V> SearchStack<'a, K, V> {\n+        /// Gets a reference to the value the stack points to.\n+        pub fn peek(&self) -> &V {\n+            let (node_ptr, index) = self.top;\n+            unsafe {\n+                (*node_ptr).val(index).unwrap()\n+            }\n+        }\n+\n+        /// Gets a mutable reference to the value the stack points to.\n+        pub fn peek_mut(&mut self) -> &mut V {\n+            let (node_ptr, index) = self.top;\n+            unsafe {\n+                (*node_ptr).val_mut(index).unwrap()\n+            }\n+        }\n+\n+        /// Converts the stack into a mutable reference to the value it points to, with a lifetime\n+        /// tied to the original tree.\n+        pub fn into_top(self) -> &'a mut V {\n+            let (node_ptr, index) = self.top;\n+            unsafe {\n+                (*node_ptr).val_mut(index).unwrap()\n+            }\n+        }\n+\n+        /// Inserts the key and value into the top element in the stack, and if that node has to\n+        /// split recursively inserts the split contents into the next element stack until\n+        /// splits stop.\n+        ///\n+        /// Assumes that the stack represents a search path from the root to a leaf.\n+        ///\n+        /// An &mut V is returned to the inserted value, for callers that want a reference to this.\n+        pub fn insert(self, key: K, val: V) -> &'a mut V {\n+            unsafe {\n+                let map = self.map;\n+                map.length += 1;\n+\n+                let mut stack = self.stack;\n+                // Insert the key and value into the leaf at the top of the stack\n+                let (node, index) = self.top;\n+                let (mut insertion, inserted_ptr) = {\n+                    (*node).insert_as_leaf(index, key, val)\n+                };\n+\n+                loop {\n+                    match insertion {\n+                        Fit => {\n+                            // The last insertion went off without a hitch, no splits! We can stop\n+                            // inserting now.\n+                            return &mut *inserted_ptr;\n+                        }\n+                        Split(key, val, right) => match stack.pop() {\n+                            // The last insertion triggered a split, so get the next element on the\n+                            // stack to recursively insert the split node into.\n+                            None => {\n+                                // The stack was empty; we've split the root, and need to make a\n+                                // a new one. This is done in-place because we can't move the\n+                                // root out of a reference to the tree.\n+                                Node::make_internal_root(&mut map.root, map.b, key, val, right);\n+\n+                                map.depth += 1;\n+                                return &mut *inserted_ptr;\n+                            }\n+                            Some((node, index)) => {\n+                                // The stack wasn't empty, do the insertion and recurse\n+                                insertion = (*node).insert_as_internal(index, key, val, right);\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        /// Removes the key and value in the top element of the stack, then handles underflows as\n+        /// described in BTree's pop function.\n+        pub fn remove(mut self) -> V {\n+            // Ensure that the search stack goes to a leaf. This is necessary to perform deletion\n+            // in a BTree. Note that this may put the tree in an inconsistent state (further\n+            // described in leafify's comments), but this is immediately fixed by the\n+            // removing the value we want to remove\n+            self.leafify();\n+\n+            let map = self.map;\n+            map.length -= 1;\n+\n+            let mut stack = self.stack;\n+\n+            // Remove the key-value pair from the leaf that this search stack points to.\n+            // Then, note if the leaf is underfull, and promptly forget the leaf and its ptr\n+            // to avoid ownership issues.\n+            let (value, mut underflow) = unsafe {\n+                let (leaf_ptr, index) = self.top;\n+                let leaf = &mut *leaf_ptr;\n+                let (_key, value) = leaf.remove_as_leaf(index);\n+                let underflow = leaf.is_underfull();\n+                (value, underflow)\n+            };\n+\n+            loop {\n+                match stack.pop() {\n+                    None => {\n+                        // We've reached the root, so no matter what, we're done. We manually\n+                        // access the root via the tree itself to avoid creating any dangling\n+                        // pointers.\n+                        if map.root.len() == 0 && !map.root.is_leaf() {\n+                            // We've emptied out the root, so make its only child the new root.\n+                            // If it's a leaf, we just let it become empty.\n+                            map.depth -= 1;\n+                            map.root = map.root.pop_edge().unwrap();\n+                        }\n+                        return value;\n+                    }\n+                    Some((parent_ptr, index)) => {\n+                        if underflow {\n+                            // Underflow! Handle it!\n+                            unsafe {\n+                                let parent = &mut *parent_ptr;\n+                                parent.handle_underflow(index);\n+                                underflow = parent.is_underfull();\n+                            }\n+                        } else {\n+                            // All done!\n+                            return value;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        /// Subroutine for removal. Takes a search stack for a key that might terminate at an\n+        /// internal node, and mutates the tree and search stack to *make* it a search stack\n+        /// for that same key that *does* terminates at a leaf. If the mutation occurs, then this\n+        /// leaves the tree in an inconsistent state that must be repaired by the caller by\n+        /// removing the entry in question. Specifically the key-value pair and its successor will\n+        /// become swapped.\n+        fn leafify(&mut self) {\n+            unsafe {\n+                let (node_ptr, index) = self.top;\n+                // First, get ptrs to the found key-value pair\n+                let node = &mut *node_ptr;\n+                let (key_ptr, val_ptr) = {\n+                    (node.unsafe_key_mut(index) as *mut _,\n+                     node.unsafe_val_mut(index) as *mut _)\n+                };\n+\n+                // Try to go into the right subtree of the found key to find its successor\n+                match node.edge_mut(index + 1) {\n+                    None => {\n+                        // We're a proper leaf stack, nothing to do\n+                    }\n+                    Some(mut temp_node) => {\n+                        //We're not a proper leaf stack, let's get to work.\n+                        self.stack.push((node_ptr, index + 1));\n+                        loop {\n+                            // Walk into the smallest subtree of this node\n+                            let node = temp_node;\n+                            let node_ptr = node as *mut _;\n+\n+                            if node.is_leaf() {\n+                                // This node is a leaf, do the swap and return\n+                                self.top = (node_ptr, 0);\n+                                node.unsafe_swap(0, &mut *key_ptr, &mut *val_ptr);\n+                                break;\n+                            } else {\n+                                // This node is internal, go deeper\n+                                self.stack.push((node_ptr, 0));\n+                                temp_node = node.unsafe_edge_mut(0);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<K, V> Collection for BTreeMap<K, V> {\n+    fn len(&self) -> uint {\n+        self.length\n+    }\n+}\n+\n+impl<K: Ord, V> Mutable for BTreeMap<K, V> {\n+    fn clear(&mut self) {\n+        let b = self.b;\n+        // avoid recursive destructors by manually traversing the tree\n+        for _ in mem::replace(self, BTreeMap::with_b(b)).into_iter() {};\n+    }\n+}\n+\n+impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n+    fn from_iter<T: Iterator<(K, V)>>(iter: T) -> BTreeMap<K, V> {\n+        let mut map = BTreeMap::new();\n+        map.extend(iter);\n+        map\n+    }\n+}\n+\n+impl<K: Ord, V> Extendable<(K, V)> for BTreeMap<K, V> {\n+    #[inline]\n+    fn extend<T: Iterator<(K, V)>>(&mut self, mut iter: T) {\n+        for (k, v) in iter {\n+            self.insert(k, v);\n+        }\n+    }\n+}\n+\n+impl<S: Writer, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n+    fn hash(&self, state: &mut S) {\n+        for elt in self.iter() {\n+            elt.hash(state);\n+        }\n+    }\n+}\n+\n+impl<K: Ord, V> Default for BTreeMap<K, V> {\n+    fn default() -> BTreeMap<K, V> {\n+        BTreeMap::new()\n+    }\n+}\n+\n+impl<K: PartialEq, V: PartialEq> PartialEq for BTreeMap<K, V> {\n+    fn eq(&self, other: &BTreeMap<K, V>) -> bool {\n+        self.len() == other.len() &&\n+            self.iter().zip(other.iter()).all(|(a, b)| a == b)\n+    }\n+}\n+\n+impl<K: Eq, V: Eq> Eq for BTreeMap<K, V> {}\n+\n+impl<K: PartialOrd, V: PartialOrd> PartialOrd for BTreeMap<K, V> {\n+    #[inline]\n+    fn partial_cmp(&self, other: &BTreeMap<K, V>) -> Option<Ordering> {\n+        iter::order::partial_cmp(self.iter(), other.iter())\n+    }\n+}\n+\n+impl<K: Ord, V: Ord> Ord for BTreeMap<K, V> {\n+    #[inline]\n+    fn cmp(&self, other: &BTreeMap<K, V>) -> Ordering {\n+        iter::order::cmp(self.iter(), other.iter())\n+    }\n+}\n+\n+impl<K: Show, V: Show> Show for BTreeMap<K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{{\"));\n+\n+        for (i, (k, v)) in self.iter().enumerate() {\n+            if i != 0 { try!(write!(f, \", \")); }\n+            try!(write!(f, \"{}: {}\", *k, *v));\n+        }\n+\n+        write!(f, \"}}\")\n+    }\n+}\n+\n+impl<K: Ord, V> Index<K, V> for BTreeMap<K, V> {\n+    fn index(&self, key: &K) -> &V {\n+        self.find(key).expect(\"no entry found for key\")\n+    }\n+}\n+\n+/// Genericises over how to get the correct type of iterator from the correct type\n+/// of Node ownership.\n+trait Traverse<N> {\n+    fn traverse(node: N) -> Self;\n+}\n+\n+impl<'a, K, V> Traverse<&'a Node<K, V>> for Traversal<'a, K, V> {\n+    fn traverse(node: &'a Node<K, V>) -> Traversal<'a, K, V> {\n+        node.iter()\n+    }\n+}\n+\n+impl<'a, K, V> Traverse<&'a mut Node<K, V>> for MutTraversal<'a, K, V> {\n+    fn traverse(node: &'a mut Node<K, V>) -> MutTraversal<'a, K, V> {\n+        node.iter_mut()\n+    }\n+}\n+\n+impl<K, V> Traverse<Node<K, V>> for MoveTraversal<K, V> {\n+    fn traverse(node: Node<K, V>) -> MoveTraversal<K, V> {\n+        node.into_iter()\n+    }\n+}\n+\n+/// Represents an operation to perform inside the following iterator methods.\n+/// This is necessary to use in `next` because we want to modify self.left inside\n+/// a match that borrows it. Similarly, in `next_back` for self.right. Instead, we use this\n+/// enum to note what we want to do, and do it after the match.\n+enum StackOp<T> {\n+    Push(T),\n+    Pop,\n+}\n+\n+impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n+        Iterator<(K, V)> for AbsEntries<T> {\n+    // This function is pretty long, but only because there's a lot of cases to consider.\n+    // Our iterator represents two search paths, left and right, to the smallest and largest\n+    // elements we have yet to yield. lca represents the least common ancestor of these two paths,\n+    // above-which we never walk, since everything outside it has already been consumed (or was\n+    // never in the range to iterate).\n+    //\n+    // Note that the design of these iterators permits an *arbitrary* initial pair of min and max,\n+    // making these arbitrary sub-range iterators. However the logic to construct these paths\n+    // efficiently is fairly involved, so this is a FIXME. The sub-range iterators also wouldn't be\n+    // able to accurately predict size, so those iterators can't implement ExactSize.\n+    fn next(&mut self) -> Option<(K, V)> {\n+        loop {\n+            // We want the smallest element, so try to get the top of the left stack\n+            let op = match self.left.back_mut() {\n+                // The left stack is empty, so try to get the next element of the two paths\n+                // LCAs (the left search path is currently a subpath of the right one)\n+                None => match self.lca.next() {\n+                    // The lca has been exhausted, walk further down the right path\n+                    None => match self.right.pop_front() {\n+                        // The right path is exhausted, so we're done\n+                        None => return None,\n+                        // The right path had something, make that the new LCA\n+                        // and restart the whole process\n+                        Some(right) => {\n+                            self.lca = right;\n+                            continue;\n+                        }\n+                    },\n+                    // The lca yielded an edge, make that the new head of the left path\n+                    Some(Edge(next)) => Push(Traverse::traverse(next)),\n+                    // The lca yielded an entry, so yield that\n+                    Some(Elem(k, v)) => {\n+                        self.size -= 1;\n+                        return Some((k, v))\n+                    }\n+                },\n+                // The left stack wasn't empty, so continue along the node in its head\n+                Some(iter) => match iter.next() {\n+                    // The head of the left path is empty, so Pop it off and restart the process\n+                    None => Pop,\n+                    // The head of the left path yielded an edge, so make that the new head\n+                    // of the left path\n+                    Some(Edge(next)) => Push(Traverse::traverse(next)),\n+                    // The head of the left path yielded entry, so yield that\n+                    Some(Elem(k, v)) => {\n+                        self.size -= 1;\n+                        return Some((k, v))\n+                    }\n+                }\n+            };\n+\n+            // Handle any operation on the left stack as necessary\n+            match op {\n+                Push(item) => { self.left.push(item); },\n+                Pop => { self.left.pop(); },\n+            }\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (self.size, Some(self.size))\n+    }\n+}\n+\n+impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n+        DoubleEndedIterator<(K, V)> for AbsEntries<T> {\n+    // next_back is totally symmetric to next\n+    fn next_back(&mut self) -> Option<(K, V)> {\n+        loop {\n+            let op = match self.right.back_mut() {\n+                None => match self.lca.next_back() {\n+                    None => match self.left.pop_front() {\n+                        None => return None,\n+                        Some(left) => {\n+                            self.lca = left;\n+                            continue;\n+                        }\n+                    },\n+                    Some(Edge(next)) => Push(Traverse::traverse(next)),\n+                    Some(Elem(k, v)) => {\n+                        self.size -= 1;\n+                        return Some((k, v))\n+                    }\n+                },\n+                Some(iter) => match iter.next_back() {\n+                    None => Pop,\n+                    Some(Edge(next)) => Push(Traverse::traverse(next)),\n+                    Some(Elem(k, v)) => {\n+                        self.size -= 1;\n+                        return Some((k, v))\n+                    }\n+                }\n+            };\n+\n+            match op {\n+                Push(item) => { self.right.push(item); },\n+                Pop => { self.right.pop(); }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n+    fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+}\n+impl<'a, K, V> DoubleEndedIterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n+    fn next_back(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next_back() }\n+}\n+impl<'a, K, V> ExactSize<(&'a K, &'a V)> for Entries<'a, K, V> {}\n+\n+\n+impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n+    fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+}\n+impl<'a, K, V> DoubleEndedIterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n+    fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next_back() }\n+}\n+impl<'a, K, V> ExactSize<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {}\n+\n+\n+impl<K, V> Iterator<(K, V)> for MoveEntries<K, V> {\n+    fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+}\n+impl<K, V> DoubleEndedIterator<(K, V)> for MoveEntries<K, V> {\n+    fn next_back(&mut self) -> Option<(K, V)> { self.inner.next_back() }\n+}\n+impl<K, V> ExactSize<(K, V)> for MoveEntries<K, V> {}\n+\n+\n+\n+impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n+    /// Sets the value of the entry with the VacantEntry's key,\n+    /// and returns a mutable reference to it.\n+    pub fn set(self, value: V) -> &'a mut V {\n+        self.stack.insert(self.key, value)\n+    }\n+}\n+\n+impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n+    /// Gets a reference to the value in the entry.\n+    pub fn get(&self) -> &V {\n+        self.stack.peek()\n+    }\n+\n+    /// Gets a mutable reference to the value in the entry.\n+    pub fn get_mut(&mut self) -> &mut V {\n+        self.stack.peek_mut()\n+    }\n+\n+    /// Converts the entry into a mutable reference to its value.\n+    pub fn into_mut(self) -> &'a mut V {\n+        self.stack.into_top()\n+    }\n+\n+    /// Sets the value of the entry with the OccupiedEntry's key,\n+    /// and returns the entry's old value.\n+    pub fn set(&mut self, mut value: V) -> V {\n+        mem::swap(self.stack.peek_mut(), &mut value);\n+        value\n+    }\n+\n+    /// Takes the value of the entry out of the map, and returns it.\n+    pub fn take(self) -> V {\n+        self.stack.remove()\n+    }\n+}\n+\n+impl<K, V> BTreeMap<K, V> {\n+    /// Gets an iterator over the entries of the map.\n+    pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n+        let len = self.len();\n+        Entries {\n+            inner: AbsEntries {\n+                lca: Traverse::traverse(&self.root),\n+                left: RingBuf::new(),\n+                right: RingBuf::new(),\n+                size: len,\n+            }\n+        }\n+    }\n+\n+    /// Gets a mutable iterator over the entries of the map.\n+    pub fn iter_mut<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n+        let len = self.len();\n+        MutEntries {\n+            inner: AbsEntries {\n+                lca: Traverse::traverse(&mut self.root),\n+                left: RingBuf::new(),\n+                right: RingBuf::new(),\n+                size: len,\n+            }\n+        }\n+    }\n+\n+    /// Gets an owning iterator over the entries of the map.\n+    pub fn into_iter(self) -> MoveEntries<K, V> {\n+        let len = self.len();\n+        MoveEntries {\n+            inner: AbsEntries {\n+                lca: Traverse::traverse(self.root),\n+                left: RingBuf::new(),\n+                right: RingBuf::new(),\n+                size: len,\n+            }\n+        }\n+    }\n+\n+    /// Gets an iterator over the keys of the map.\n+    pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n+        self.iter().map(|(k, _)| k)\n+    }\n+\n+    /// Gets an iterator over the values of the map.\n+    pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n+        self.iter().map(|(_, v)| v)\n+    }\n+}\n+\n+impl<K: Ord, V> BTreeMap<K, V> {\n+    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n+    pub fn entry<'a>(&'a mut self, key: K) -> Entry<'a, K, V> {\n+        // same basic logic of `swap` and `pop`, blended together\n+        let mut stack = stack::PartialSearchStack::new(self);\n+        loop {\n+            match stack.next().search(&key) {\n+                Found(i) => {\n+                    // Perfect match\n+                    return Occupied(OccupiedEntry {\n+                        stack: stack.seal(i)\n+                    });\n+                },\n+                GoDown(i) => {\n+                    stack = match stack.push(i) {\n+                        stack::Done(new_stack) => {\n+                            // Not in the tree, but we've found where it goes\n+                            return Vacant(VacantEntry {\n+                                stack: new_stack,\n+                                key: key,\n+                            });\n+                        }\n+                        stack::Grew(new_stack) => {\n+                            // We've found the subtree this key must go in\n+                            new_stack\n+                        }\n+                    };\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\n+\n+\n+\n+#[cfg(test)]\n+mod test {\n+    use std::prelude::*;\n+\n+    use {Map, MutableMap};\n+    use super::{BTreeMap, Occupied, Vacant};\n+\n+    #[test]\n+    fn test_basic_large() {\n+        let mut map = BTreeMap::new();\n+        let size = 10000u;\n+        assert_eq!(map.len(), 0);\n+\n+        for i in range(0, size) {\n+            assert_eq!(map.swap(i, 10*i), None);\n+            assert_eq!(map.len(), i + 1);\n+        }\n+\n+        for i in range(0, size) {\n+            assert_eq!(map.find(&i).unwrap(), &(i*10));\n+        }\n+\n+        for i in range(size, size*2) {\n+            assert_eq!(map.find(&i), None);\n+        }\n+\n+        for i in range(0, size) {\n+            assert_eq!(map.swap(i, 100*i), Some(10*i));\n+            assert_eq!(map.len(), size);\n+        }\n+\n+        for i in range(0, size) {\n+            assert_eq!(map.find(&i).unwrap(), &(i*100));\n+        }\n+\n+        for i in range(0, size/2) {\n+            assert_eq!(map.pop(&(i*2)), Some(i*200));\n+            assert_eq!(map.len(), size - i - 1);\n+        }\n+\n+        for i in range(0, size/2) {\n+            assert_eq!(map.find(&(2*i)), None);\n+            assert_eq!(map.find(&(2*i+1)).unwrap(), &(i*200 + 100));\n+        }\n+\n+        for i in range(0, size/2) {\n+            assert_eq!(map.pop(&(2*i)), None);\n+            assert_eq!(map.pop(&(2*i+1)), Some(i*200 + 100));\n+            assert_eq!(map.len(), size/2 - i - 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_basic_small() {\n+        let mut map = BTreeMap::new();\n+        assert_eq!(map.pop(&1), None);\n+        assert_eq!(map.find(&1), None);\n+        assert_eq!(map.swap(1u, 1u), None);\n+        assert_eq!(map.find(&1), Some(&1));\n+        assert_eq!(map.swap(1, 2), Some(1));\n+        assert_eq!(map.find(&1), Some(&2));\n+        assert_eq!(map.swap(2, 4), None);\n+        assert_eq!(map.find(&2), Some(&4));\n+        assert_eq!(map.pop(&1), Some(2));\n+        assert_eq!(map.pop(&2), Some(4));\n+        assert_eq!(map.pop(&1), None);\n+    }\n+\n+    #[test]\n+    fn test_iter() {\n+        let size = 10000u;\n+\n+        // Forwards\n+        let mut map: BTreeMap<uint, uint> = Vec::from_fn(size, |i| (i, i)).into_iter().collect();\n+\n+        {\n+            let mut iter = map.iter();\n+            for i in range(0, size) {\n+                assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n+                assert_eq!(iter.next().unwrap(), (&i, &i));\n+            }\n+            assert_eq!(iter.size_hint(), (0, Some(0)));\n+            assert_eq!(iter.next(), None);\n+        }\n+\n+        {\n+            let mut iter = map.iter_mut();\n+            for i in range(0, size) {\n+                assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n+                assert_eq!(iter.next().unwrap(), (&i, &mut (i + 0)));\n+            }\n+            assert_eq!(iter.size_hint(), (0, Some(0)));\n+            assert_eq!(iter.next(), None);\n+        }\n+\n+        {\n+            let mut iter = map.into_iter();\n+            for i in range(0, size) {\n+                assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n+                assert_eq!(iter.next().unwrap(), (i, i));\n+            }\n+            assert_eq!(iter.size_hint(), (0, Some(0)));\n+            assert_eq!(iter.next(), None);\n+        }\n+\n+    }\n+\n+    #[test]\n+    fn test_iter_rev() {\n+        let size = 10000u;\n+\n+        // Forwards\n+        let mut map: BTreeMap<uint, uint> = Vec::from_fn(size, |i| (i, i)).into_iter().collect();\n+\n+        {\n+            let mut iter = map.iter().rev();\n+            for i in range(0, size) {\n+                assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n+                assert_eq!(iter.next().unwrap(), (&(size - i - 1), &(size - i - 1)));\n+            }\n+            assert_eq!(iter.size_hint(), (0, Some(0)));\n+            assert_eq!(iter.next(), None);\n+        }\n+\n+        {\n+            let mut iter = map.iter_mut().rev();\n+            for i in range(0, size) {\n+                assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n+                assert_eq!(iter.next().unwrap(), (&(size - i - 1), &mut(size - i - 1)));\n+            }\n+            assert_eq!(iter.size_hint(), (0, Some(0)));\n+            assert_eq!(iter.next(), None);\n+        }\n+\n+        {\n+            let mut iter = map.into_iter().rev();\n+            for i in range(0, size) {\n+                assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n+                assert_eq!(iter.next().unwrap(), (size - i - 1, size - i - 1));\n+            }\n+            assert_eq!(iter.size_hint(), (0, Some(0)));\n+            assert_eq!(iter.next(), None);\n+        }\n+\n+    }\n+\n+    #[test]\n+    fn test_entry(){\n+        let xs = [(1i, 10i), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n+\n+        let mut map: BTreeMap<int, int> = xs.iter().map(|&x| x).collect();\n+\n+        // Existing key (insert)\n+        match map.entry(1) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(mut view) => {\n+                assert_eq!(view.get(), &10);\n+                assert_eq!(view.set(100), 10);\n+            }\n+        }\n+        assert_eq!(map.find(&1).unwrap(), &100);\n+        assert_eq!(map.len(), 6);\n+\n+\n+        // Existing key (update)\n+        match map.entry(2) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(mut view) => {\n+                let v = view.get_mut();\n+                *v *= 10;\n+            }\n+        }\n+        assert_eq!(map.find(&2).unwrap(), &200);\n+        assert_eq!(map.len(), 6);\n+\n+        // Existing key (take)\n+        match map.entry(3) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(view) => {\n+                assert_eq!(view.take(), 30);\n+            }\n+        }\n+        assert_eq!(map.find(&3), None);\n+        assert_eq!(map.len(), 5);\n+\n+\n+        // Inexistent key (insert)\n+        match map.entry(10) {\n+            Occupied(_) => unreachable!(),\n+            Vacant(view) => {\n+                assert_eq!(*view.set(1000), 1000);\n+            }\n+        }\n+        assert_eq!(map.find(&10).unwrap(), &1000);\n+        assert_eq!(map.len(), 6);\n+    }\n+}\n+\n+\n+\n+\n+\n+\n+#[cfg(test)]\n+mod bench {\n+    use test::Bencher;\n+\n+    use super::BTreeMap;\n+    use deque::bench::{insert_rand_n, insert_seq_n, find_rand_n, find_seq_n};\n+\n+    #[bench]\n+    pub fn insert_rand_100(b: &mut Bencher) {\n+        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        insert_rand_n(100, &mut m, b);\n+    }\n+\n+    #[bench]\n+    pub fn insert_rand_10_000(b: &mut Bencher) {\n+        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        insert_rand_n(10_000, &mut m, b);\n+    }\n+\n+    // Insert seq\n+    #[bench]\n+    pub fn insert_seq_100(b: &mut Bencher) {\n+        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        insert_seq_n(100, &mut m, b);\n+    }\n+\n+    #[bench]\n+    pub fn insert_seq_10_000(b: &mut Bencher) {\n+        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        insert_seq_n(10_000, &mut m, b);\n+    }\n+\n+    // Find rand\n+    #[bench]\n+    pub fn find_rand_100(b: &mut Bencher) {\n+        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        find_rand_n(100, &mut m, b);\n+    }\n+\n+    #[bench]\n+    pub fn find_rand_10_000(b: &mut Bencher) {\n+        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        find_rand_n(10_000, &mut m, b);\n+    }\n+\n+    // Find seq\n+    #[bench]\n+    pub fn find_seq_100(b: &mut Bencher) {\n+        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        find_seq_n(100, &mut m, b);\n+    }\n+\n+    #[bench]\n+    pub fn find_seq_10_000(b: &mut Bencher) {\n+        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        find_seq_n(10_000, &mut m, b);\n+    }\n+}"}, {"sha": "435a91f217eae5959783217709c59fa02a697b0d", "filename": "src/libcollections/btree/mod.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b6edc59413f79016a1063c2ec6bc05516bc99cb6/src%2Flibcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6edc59413f79016a1063c2ec6bc05516bc99cb6/src%2Flibcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmod.rs?ref=b6edc59413f79016a1063c2ec6bc05516bc99cb6", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use self::map::BTreeMap;\n+pub use self::map::Entries;\n+pub use self::map::MutEntries;\n+pub use self::map::MoveEntries;\n+pub use self::map::Keys;\n+pub use self::map::Values;\n+pub use self::map::Entry;\n+pub use self::map::OccupiedEntry;\n+pub use self::map::VacantEntry;\n+\n+pub use self::set::BTreeSet;\n+pub use self::set::Items;\n+pub use self::set::MoveItems;\n+pub use self::set::DifferenceItems;\n+pub use self::set::UnionItems;\n+pub use self::set::SymDifferenceItems;\n+pub use self::set::IntersectionItems;\n+\n+\n+mod node;\n+mod map;\n+mod set;"}, {"sha": "e30b29f8767d3aa26d7857de2f8a187ab83875c3", "filename": "src/libcollections/btree/node.rs", "status": "added", "additions": 552, "deletions": 0, "changes": 552, "blob_url": "https://github.com/rust-lang/rust/blob/b6edc59413f79016a1063c2ec6bc05516bc99cb6/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6edc59413f79016a1063c2ec6bc05516bc99cb6/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=b6edc59413f79016a1063c2ec6bc05516bc99cb6", "patch": "@@ -0,0 +1,552 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This module represents all the internal representation and logic for a B-Tree's node\n+// with a safe interface, so that BTreeMap itself does not depend on any of these details.\n+\n+use core::prelude::*;\n+\n+use core::{slice, mem, ptr};\n+use core::iter::Zip;\n+use MutableSeq;\n+\n+use vec;\n+use vec::Vec;\n+\n+/// Represents the result of an Insertion: either the item fit, or the node had to split\n+pub enum InsertionResult<K, V> {\n+    /// The inserted element fit\n+    Fit,\n+    /// The inserted element did not fit, so the node was split\n+    Split(K, V, Node<K, V>),\n+}\n+\n+/// Represents the result of a search for a key in a single node\n+pub enum SearchResult {\n+    /// The element was found at the given index\n+    Found(uint),\n+    /// The element wasn't found, but if it's anywhere, it must be beyond this edge\n+    GoDown(uint),\n+}\n+\n+/// A B-Tree Node. We keep keys/edges/values separate to optimize searching for keys.\n+#[deriving(Clone)]\n+pub struct Node<K, V> {\n+    // FIXME(Gankro): This representation is super safe and easy to reason about, but painfully\n+    // inefficient. As three Vecs, each node consists of *9* words: (ptr, cap, size) * 3. In\n+    // theory, if we take full control of allocation like HashMap's RawTable does,\n+    // and restrict leaves to max size 256 (not unreasonable for a btree node) we can cut\n+    // this down to just (ptr, cap: u8, size: u8, is_leaf: bool). With generic\n+    // integer arguments, cap can even move into the the type, reducing this just to\n+    // (ptr, size, is_leaf). This could also have cache benefits for very small nodes, as keys\n+    // could bleed into edges and vals.\n+    //\n+    // However doing this would require a fair amount of code to reimplement all\n+    // the Vec logic and iterators. It would also use *way* more unsafe code, which sucks and is\n+    // hard. For now, we accept this cost in the name of correctness and simplicity.\n+    //\n+    // As a compromise, keys and vals could be merged into one Vec<(K, V)>, which would shave\n+    // off 3 words, but possibly hurt our cache effeciency during search, which only cares about\n+    // keys. This would also avoid the Zip we use in our iterator implementations. This is\n+    // probably worth investigating.\n+    //\n+    // Note that this space waste is especially tragic since we store the Nodes by value in their\n+    // parent's edges Vec, so unoccupied spaces in the edges Vec are quite large, and we have\n+    // to shift around a lot more bits during insertion/removal.\n+\n+    keys: Vec<K>,\n+    edges: Vec<Node<K, V>>,\n+    vals: Vec<V>,\n+}\n+\n+impl<K: Ord, V> Node<K, V> {\n+    /// Searches for the given key in the node. If it finds an exact match,\n+    /// `Found` will be yielded with the matching index. If it fails to find an exact match,\n+    /// `GoDown` will be yielded with the index of the subtree the key must lie in.\n+    pub fn search(&self, key: &K) -> SearchResult {\n+        // FIXME(Gankro): Tune when to search linear or binary based on B (and maybe K/V).\n+        // For the B configured as of this writing (B = 6), binary search was *singnificantly*\n+        // worse for uints.\n+        self.search_linear(key)\n+    }\n+\n+    fn search_linear(&self, key: &K) -> SearchResult {\n+        for (i, k) in self.keys.iter().enumerate() {\n+            match k.cmp(key) {\n+                Less => {},\n+                Equal => return Found(i),\n+                Greater => return GoDown(i),\n+            }\n+        }\n+        GoDown(self.len())\n+    }\n+}\n+\n+// Public interface\n+impl <K, V> Node<K, V> {\n+    /// Make a new internal node\n+    pub fn new_internal(capacity: uint) -> Node<K, V> {\n+        Node {\n+            keys: Vec::with_capacity(capacity),\n+            vals: Vec::with_capacity(capacity),\n+            edges: Vec::with_capacity(capacity + 1),\n+        }\n+    }\n+\n+    /// Make a new leaf node\n+    pub fn new_leaf(capacity: uint) -> Node<K, V> {\n+        Node {\n+            keys: Vec::with_capacity(capacity),\n+            vals: Vec::with_capacity(capacity),\n+            edges: Vec::new(),\n+        }\n+    }\n+\n+    /// Make a leaf root from scratch\n+    pub fn make_leaf_root(b: uint) -> Node<K, V> {\n+        Node::new_leaf(capacity_from_b(b))\n+    }\n+\n+    /// Make an internal root and swap it with an old root\n+    pub fn make_internal_root(left_and_out: &mut Node<K,V>, b: uint, key: K, value: V,\n+            right: Node<K,V>) {\n+        let mut node = Node::new_internal(capacity_from_b(b));\n+        mem::swap(left_and_out, &mut node);\n+        left_and_out.keys.push(key);\n+        left_and_out.vals.push(value);\n+        left_and_out.edges.push(node);\n+        left_and_out.edges.push(right);\n+    }\n+\n+\n+    /// How many key-value pairs the node contains\n+    pub fn len(&self) -> uint {\n+        self.keys.len()\n+    }\n+\n+    /// How many key-value pairs the node can fit\n+    pub fn capacity(&self) -> uint {\n+        self.keys.capacity()\n+    }\n+\n+    /// If the node has any children\n+    pub fn is_leaf(&self) -> bool {\n+        self.edges.is_empty()\n+    }\n+\n+    /// if the node has too few elements\n+    pub fn is_underfull(&self) -> bool {\n+        self.len() < min_load_from_capacity(self.capacity())\n+    }\n+\n+    /// if the node cannot fit any more elements\n+    pub fn is_full(&self) -> bool {\n+        self.len() == self.capacity()\n+    }\n+\n+    /// Swap the given key-value pair with the key-value pair stored in the node's index,\n+    /// without checking bounds.\n+    pub unsafe fn unsafe_swap(&mut self, index: uint, key: &mut K, val: &mut V) {\n+        mem::swap(self.keys.as_mut_slice().unsafe_mut(index), key);\n+        mem::swap(self.vals.as_mut_slice().unsafe_mut(index), val);\n+    }\n+\n+    /// Get the node's key mutably without any bounds checks.\n+    pub unsafe fn unsafe_key_mut(&mut self, index: uint) -> &mut K {\n+        self.keys.as_mut_slice().unsafe_mut(index)\n+    }\n+\n+    /// Get the node's value at the given index\n+    pub fn val(&self, index: uint) -> Option<&V> {\n+        self.vals.as_slice().get(index)\n+    }\n+\n+    /// Get the node's value at the given index\n+    pub fn val_mut(&mut self, index: uint) -> Option<&mut V> {\n+        self.vals.as_mut_slice().get_mut(index)\n+    }\n+\n+    /// Get the node's value mutably without any bounds checks.\n+    pub unsafe fn unsafe_val_mut(&mut self, index: uint) -> &mut V {\n+        self.vals.as_mut_slice().unsafe_mut(index)\n+    }\n+\n+    /// Get the node's edge at the given index\n+    pub fn edge(&self, index: uint) -> Option<&Node<K,V>> {\n+        self.edges.as_slice().get(index)\n+    }\n+\n+    /// Get the node's edge mutably at the given index\n+    pub fn edge_mut(&mut self, index: uint) -> Option<&mut Node<K,V>> {\n+        self.edges.as_mut_slice().get_mut(index)\n+    }\n+\n+    /// Get the node's edge mutably without any bounds checks.\n+    pub unsafe fn unsafe_edge_mut(&mut self, index: uint) -> &mut Node<K,V> {\n+        self.edges.as_mut_slice().unsafe_mut(index)\n+    }\n+\n+    /// Pop an edge off the end of the node\n+    pub fn pop_edge(&mut self) -> Option<Node<K,V>> {\n+        self.edges.pop()\n+    }\n+\n+    /// Try to insert this key-value pair at the given index in this internal node\n+    /// If the node is full, we have to split it.\n+    ///\n+    /// Returns a *mut V to the inserted value, because the caller may want this when\n+    /// they're done mutating the tree, but we don't want to borrow anything for now.\n+    pub fn insert_as_leaf(&mut self, index: uint, key: K, value: V) ->\n+            (InsertionResult<K, V>, *mut V) {\n+        if !self.is_full() {\n+            // The element can fit, just insert it\n+            self.insert_fit_as_leaf(index, key, value);\n+            (Fit, unsafe { self.unsafe_val_mut(index) as *mut _ })\n+        } else {\n+            // The element can't fit, this node is full. Split it into two nodes.\n+            let (new_key, new_val, mut new_right) = self.split();\n+            let left_len = self.len();\n+\n+            let ptr = if index <= left_len {\n+                self.insert_fit_as_leaf(index, key, value);\n+                unsafe { self.unsafe_val_mut(index) as *mut _ }\n+            } else {\n+                new_right.insert_fit_as_leaf(index - left_len - 1, key, value);\n+                unsafe { new_right.unsafe_val_mut(index - left_len - 1) as *mut _ }\n+            };\n+\n+            (Split(new_key, new_val, new_right), ptr)\n+        }\n+    }\n+\n+    /// Try to insert this key-value pair at the given index in this internal node\n+    /// If the node is full, we have to split it.\n+    pub fn insert_as_internal(&mut self, index: uint, key: K, value: V, right: Node<K, V>)\n+            -> InsertionResult<K, V> {\n+        if !self.is_full() {\n+            // The element can fit, just insert it\n+            self.insert_fit_as_internal(index, key, value, right);\n+            Fit\n+        } else {\n+            // The element can't fit, this node is full. Split it into two nodes.\n+            let (new_key, new_val, mut new_right) = self.split();\n+            let left_len = self.len();\n+\n+            if index <= left_len {\n+                self.insert_fit_as_internal(index, key, value, right);\n+            } else {\n+                new_right.insert_fit_as_internal(index - left_len - 1, key, value, right);\n+            }\n+\n+            Split(new_key, new_val, new_right)\n+        }\n+    }\n+\n+    /// Remove the key-value pair at the given index\n+    pub fn remove_as_leaf(&mut self, index: uint) -> (K, V) {\n+        match (self.keys.remove(index), self.vals.remove(index)) {\n+            (Some(k), Some(v)) => (k, v),\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    /// Handle an underflow in this node's child. We favour handling \"to the left\" because we know\n+    /// we're empty, but our neighbour can be full. Handling to the left means when we choose to\n+    /// steal, we pop off the end of our neighbour (always fast) and \"unshift\" ourselves\n+    /// (always slow, but at least faster since we know we're half-empty).\n+    /// Handling \"to the right\" reverses these roles. Of course, we merge whenever possible\n+    /// because we want dense nodes, and merging is about equal work regardless of direction.\n+    pub fn handle_underflow(&mut self, underflowed_child_index: uint) {\n+        assert!(underflowed_child_index <= self.len());\n+        unsafe {\n+            if underflowed_child_index > 0 {\n+                self.handle_underflow_to_left(underflowed_child_index);\n+            } else {\n+                self.handle_underflow_to_right(underflowed_child_index);\n+            }\n+        }\n+    }\n+\n+    pub fn iter<'a>(&'a self) -> Traversal<'a, K, V> {\n+        let is_leaf = self.is_leaf();\n+        Traversal {\n+            elems: self.keys.as_slice().iter().zip(self.vals.as_slice().iter()),\n+            edges: self.edges.as_slice().iter(),\n+            head_is_edge: true,\n+            tail_is_edge: true,\n+            has_edges: !is_leaf,\n+        }\n+    }\n+\n+    pub fn iter_mut<'a>(&'a mut self) -> MutTraversal<'a, K, V> {\n+        let is_leaf = self.is_leaf();\n+        MutTraversal {\n+            elems: self.keys.as_slice().iter().zip(self.vals.as_mut_slice().iter_mut()),\n+            edges: self.edges.as_mut_slice().iter_mut(),\n+            head_is_edge: true,\n+            tail_is_edge: true,\n+            has_edges: !is_leaf,\n+        }\n+    }\n+\n+    pub fn into_iter(self) -> MoveTraversal<K, V> {\n+        let is_leaf = self.is_leaf();\n+        MoveTraversal {\n+            elems: self.keys.into_iter().zip(self.vals.into_iter()),\n+            edges: self.edges.into_iter(),\n+            head_is_edge: true,\n+            tail_is_edge: true,\n+            has_edges: !is_leaf,\n+        }\n+    }\n+}\n+\n+// Private implementation details\n+impl<K, V> Node<K, V> {\n+    /// Make a node from its raw components\n+    fn from_vecs(keys: Vec<K>, vals: Vec<V>, edges: Vec<Node<K, V>>) -> Node<K, V> {\n+        Node {\n+            keys: keys,\n+            vals: vals,\n+            edges: edges,\n+        }\n+    }\n+\n+    /// We have somehow verified that this key-value pair will fit in this internal node,\n+    /// so insert under that assumption.\n+    fn insert_fit_as_leaf(&mut self, index: uint, key: K, val: V) {\n+        self.keys.insert(index, key);\n+        self.vals.insert(index, val);\n+    }\n+\n+    /// We have somehow verified that this key-value pair will fit in this internal node,\n+    /// so insert under that assumption\n+    fn insert_fit_as_internal(&mut self, index: uint, key: K, val: V, right: Node<K, V>) {\n+        self.keys.insert(index, key);\n+        self.vals.insert(index, val);\n+        self.edges.insert(index + 1, right);\n+    }\n+\n+    /// Node is full, so split it into two nodes, and yield the middle-most key-value pair\n+    /// because we have one too many, and our parent now has one too few\n+    fn split(&mut self) -> (K, V, Node<K, V>) {\n+        let r_keys = split(&mut self.keys);\n+        let r_vals = split(&mut self.vals);\n+        let r_edges = if self.edges.is_empty() {\n+            Vec::new()\n+        } else {\n+            split(&mut self.edges)\n+        };\n+\n+        let right = Node::from_vecs(r_keys, r_vals, r_edges);\n+        // Pop it\n+        let key = self.keys.pop().unwrap();\n+        let val = self.vals.pop().unwrap();\n+\n+        (key, val, right)\n+    }\n+\n+    /// Right is underflowed. Try to steal from left,\n+    /// but merge left and right if left is low too.\n+    unsafe fn handle_underflow_to_left(&mut self, underflowed_child_index: uint) {\n+        let left_len = self.edges[underflowed_child_index - 1].len();\n+        if left_len > min_load_from_capacity(self.capacity()) {\n+            self.steal_to_left(underflowed_child_index);\n+        } else {\n+            self.merge_children(underflowed_child_index - 1);\n+        }\n+    }\n+\n+    /// Left is underflowed. Try to steal from the right,\n+    /// but merge left and right if right is low too.\n+    unsafe fn handle_underflow_to_right(&mut self, underflowed_child_index: uint) {\n+        let right_len = self.edges[underflowed_child_index + 1].len();\n+        if right_len > min_load_from_capacity(self.capacity()) {\n+            self.steal_to_right(underflowed_child_index);\n+        } else {\n+            self.merge_children(underflowed_child_index);\n+        }\n+    }\n+\n+    /// Steal! Stealing is roughly analagous to a binary tree rotation.\n+    /// In this case, we're \"rotating\" right.\n+    unsafe fn steal_to_left(&mut self, underflowed_child_index: uint) {\n+        // Take the biggest stuff off left\n+        let (mut key, mut val, edge) = {\n+            let left = self.unsafe_edge_mut(underflowed_child_index - 1);\n+            match (left.keys.pop(), left.vals.pop(), left.edges.pop()) {\n+                (Some(k), Some(v), e) => (k, v, e),\n+                _ => unreachable!(),\n+            }\n+        };\n+\n+        // Swap the parent's seperating key-value pair with left's\n+        self.unsafe_swap(underflowed_child_index - 1, &mut key, &mut val);\n+\n+        // Put them at the start of right\n+        {\n+            let right = self.unsafe_edge_mut(underflowed_child_index);\n+            right.keys.insert(0, key);\n+            right.vals.insert(0, val);\n+            match edge {\n+                None => {}\n+                Some(e) => right.edges.insert(0, e)\n+            }\n+        }\n+    }\n+\n+    /// Steal! Stealing is roughly analagous to a binary tree rotation.\n+    /// In this case, we're \"rotating\" left.\n+    unsafe fn steal_to_right(&mut self, underflowed_child_index: uint) {\n+        // Take the smallest stuff off right\n+        let (mut key, mut val, edge) = {\n+            let right = self.unsafe_edge_mut(underflowed_child_index + 1);\n+            match (right.keys.remove(0), right.vals.remove(0), right.edges.remove(0)) {\n+                (Some(k), Some(v), e) => (k, v, e),\n+                _ => unreachable!(),\n+            }\n+        };\n+\n+        // Swap the parent's seperating key-value pair with right's\n+        self.unsafe_swap(underflowed_child_index, &mut key, &mut val);\n+\n+        // Put them at the end of left\n+        {\n+            let left = self.unsafe_edge_mut(underflowed_child_index);\n+            left.keys.push(key);\n+            left.vals.push(val);\n+            match edge {\n+                None => {}\n+                Some(e) => left.edges.push(e)\n+            }\n+        }\n+    }\n+\n+    /// Merge! Left and right will be smooshed into one node, along with the key-value\n+    /// pair that seperated them in their parent.\n+    unsafe fn merge_children(&mut self, left_index: uint) {\n+        // Permanently remove right's index, and the key-value pair that seperates\n+        // left and right\n+        let (key, val, right) = {\n+            match (self.keys.remove(left_index),\n+                self.vals.remove(left_index),\n+                self.edges.remove(left_index + 1)) {\n+                (Some(k), Some(v), Some(e)) => (k, v, e),\n+                _ => unreachable!(),\n+            }\n+        };\n+\n+        // Give left right's stuff.\n+        let left = self.unsafe_edge_mut(left_index);\n+        left.absorb(key, val, right);\n+    }\n+\n+    /// Take all the values from right, seperated by the given key and value\n+    fn absorb(&mut self, key: K, val: V, right: Node<K, V>) {\n+        // Just as a sanity check, make sure we can fit this guy in\n+        debug_assert!(self.len() + right.len() <= self.capacity())\n+\n+        self.keys.push(key);\n+        self.vals.push(val);\n+        self.keys.extend(right.keys.into_iter());\n+        self.vals.extend(right.vals.into_iter());\n+        self.edges.extend(right.edges.into_iter());\n+    }\n+}\n+\n+/// Takes a Vec, and splits half the elements into a new one.\n+fn split<T>(left: &mut Vec<T>) -> Vec<T> {\n+    // This function is intended to be called on a full Vec of size 2B - 1 (keys, values),\n+    // or 2B (edges). In the former case, left should get B elements, and right should get\n+    // B - 1. In the latter case, both should get B. Therefore, we can just always take the last\n+    // size / 2 elements from left, and put them on right. This also ensures this method is\n+    // safe, even if the Vec isn't full. Just uninteresting for our purposes.\n+    let len = left.len();\n+    let right_len = len / 2;\n+    let left_len = len - right_len;\n+    let mut right = Vec::with_capacity(left.capacity());\n+    unsafe {\n+        let left_ptr = left.as_slice().unsafe_get(left_len) as *const _;\n+        let right_ptr = right.as_mut_slice().as_mut_ptr();\n+        ptr::copy_nonoverlapping_memory(right_ptr, left_ptr, right_len);\n+        left.set_len(left_len);\n+        right.set_len(right_len);\n+    }\n+    right\n+}\n+\n+/// Get the capacity of a node from the order of the parent B-Tree\n+fn capacity_from_b(b: uint) -> uint {\n+    2 * b - 1\n+}\n+\n+/// Get the minimum load of a node from its capacity\n+fn min_load_from_capacity(cap: uint) -> uint {\n+    // B - 1\n+    cap / 2\n+}\n+\n+/// An abstraction over all the different kinds of traversals a node supports\n+struct AbsTraversal<Elems, Edges> {\n+    elems: Elems,\n+    edges: Edges,\n+    head_is_edge: bool,\n+    tail_is_edge: bool,\n+    has_edges: bool,\n+}\n+\n+/// A single atomic step in a traversal. Either an element is visited, or an edge is followed\n+pub enum TraversalItem<K, V, E> {\n+    Elem(K, V),\n+    Edge(E),\n+}\n+\n+/// A traversal over a node's entries and edges\n+pub type Traversal<'a, K, V> = AbsTraversal<Zip<slice::Items<'a, K>, slice::Items<'a, V>>,\n+                                            slice::Items<'a, Node<K, V>>>;\n+\n+/// A mutable traversal over a node's entries and edges\n+pub type MutTraversal<'a, K, V> = AbsTraversal<Zip<slice::Items<'a, K>, slice::MutItems<'a, V>>,\n+                                               slice::MutItems<'a, Node<K, V>>>;\n+\n+/// An owning traversal over a node's entries and edges\n+pub type MoveTraversal<K, V> = AbsTraversal<Zip<vec::MoveItems<K>, vec::MoveItems<V>>,\n+                                                vec::MoveItems<Node<K, V>>>;\n+\n+\n+impl<K, V, E, Elems: Iterator<(K, V)>, Edges: Iterator<E>>\n+        Iterator<TraversalItem<K, V, E>> for AbsTraversal<Elems, Edges> {\n+\n+    fn next(&mut self) -> Option<TraversalItem<K, V, E>> {\n+        let head_is_edge = self.head_is_edge;\n+        self.head_is_edge = !head_is_edge;\n+\n+        if head_is_edge && self.has_edges {\n+            self.edges.next().map(|node| Edge(node))\n+        } else {\n+            self.elems.next().map(|(k, v)| Elem(k, v))\n+        }\n+    }\n+}\n+\n+impl<K, V, E, Elems: DoubleEndedIterator<(K, V)>, Edges: DoubleEndedIterator<E>>\n+        DoubleEndedIterator<TraversalItem<K, V, E>> for AbsTraversal<Elems, Edges> {\n+\n+    fn next_back(&mut self) -> Option<TraversalItem<K, V, E>> {\n+        let tail_is_edge = self.tail_is_edge;\n+        self.tail_is_edge = !tail_is_edge;\n+\n+        if tail_is_edge && self.has_edges {\n+            self.edges.next_back().map(|node| Edge(node))\n+        } else {\n+            self.elems.next_back().map(|(k, v)| Elem(k, v))\n+        }\n+    }\n+}"}, {"sha": "b21af89742c947080bf13bb013fdec33a1593470", "filename": "src/libcollections/btree/set.rs", "status": "added", "additions": 433, "deletions": 0, "changes": 433, "blob_url": "https://github.com/rust-lang/rust/blob/b6edc59413f79016a1063c2ec6bc05516bc99cb6/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6edc59413f79016a1063c2ec6bc05516bc99cb6/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=b6edc59413f79016a1063c2ec6bc05516bc99cb6", "patch": "@@ -0,0 +1,433 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is pretty much entirely stolen from TreeSet, since BTreeMap has an identical interface\n+// to TreeMap\n+\n+use core::prelude::*;\n+\n+use super::{BTreeMap, Keys, MoveEntries};\n+use std::hash::Hash;\n+use core::default::Default;\n+use core::{iter, fmt};\n+use core::iter::Peekable;\n+use core::fmt::Show;\n+\n+use {Mutable, Set, MutableSet, MutableMap, Map};\n+\n+/// A set based on a B-Tree.\n+#[deriving(Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]\n+pub struct BTreeSet<T>{\n+    map: BTreeMap<T, ()>,\n+}\n+\n+/// An iterator over a BTreeSet's items.\n+pub type Items<'a, T> = Keys<'a, T, ()>;\n+\n+/// An owning iterator over a BTreeSet's items.\n+pub type MoveItems<T> = iter::Map<'static, (T, ()), T, MoveEntries<T, ()>>;\n+\n+/// A lazy iterator producing elements in the set difference (in-order).\n+pub struct DifferenceItems<'a, T:'a> {\n+    a: Peekable<&'a T, Items<'a, T>>,\n+    b: Peekable<&'a T, Items<'a, T>>,\n+}\n+\n+/// A lazy iterator producing elements in the set symmetric difference (in-order).\n+pub struct SymDifferenceItems<'a, T:'a> {\n+    a: Peekable<&'a T, Items<'a, T>>,\n+    b: Peekable<&'a T, Items<'a, T>>,\n+}\n+\n+/// A lazy iterator producing elements in the set intersection (in-order).\n+pub struct IntersectionItems<'a, T:'a> {\n+    a: Peekable<&'a T, Items<'a, T>>,\n+    b: Peekable<&'a T, Items<'a, T>>,\n+}\n+\n+/// A lazy iterator producing elements in the set union (in-order).\n+pub struct UnionItems<'a, T:'a> {\n+    a: Peekable<&'a T, Items<'a, T>>,\n+    b: Peekable<&'a T, Items<'a, T>>,\n+}\n+\n+impl<T: Ord> BTreeSet<T> {\n+    /// Makes a new BTreeSet with a reasonable choice of B.\n+    pub fn new() -> BTreeSet<T> {\n+        BTreeSet { map: BTreeMap::new() }\n+    }\n+\n+    /// Makes a new BTreeSet with the given B.\n+    pub fn with_b(b: uint) -> BTreeSet<T> {\n+        BTreeSet { map: BTreeMap::with_b(b) }\n+    }\n+}\n+\n+impl<T> BTreeSet<T> {\n+    /// Gets an iterator over the BTreeSet's contents.\n+    pub fn iter<'a>(&'a self) -> Items<'a, T> {\n+        self.map.keys()\n+    }\n+\n+    /// Gets an iterator for moving out the BtreeSet's contents.\n+    pub fn into_iter(self) -> MoveItems<T> {\n+        self.map.into_iter().map(|(k, _)| k)\n+    }\n+}\n+\n+impl<T: Ord> BTreeSet<T> {\n+    /// Visits the values representing the difference, in ascending order.\n+    pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> DifferenceItems<'a, T> {\n+        DifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    }\n+\n+    /// Visits the values representing the symmetric difference, in ascending order.\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>)\n+        -> SymDifferenceItems<'a, T> {\n+        SymDifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    }\n+\n+    /// Visits the values representing the intersection, in ascending order.\n+    pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>)\n+        -> IntersectionItems<'a, T> {\n+        IntersectionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    }\n+\n+    /// Visits the values representing the union, in ascending order.\n+    pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> UnionItems<'a, T> {\n+        UnionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    }\n+}\n+\n+impl<T> Collection for BTreeSet<T> {\n+    fn len(&self) -> uint {\n+        self.map.len()\n+    }\n+}\n+\n+impl<T: Ord> Mutable for BTreeSet<T> {\n+    fn clear(&mut self) {\n+        self.map.clear()\n+    }\n+}\n+\n+impl<T: Ord> Set<T> for BTreeSet<T> {\n+    fn contains(&self, value: &T) -> bool {\n+        self.map.find(value).is_some()\n+    }\n+\n+    fn is_disjoint(&self, other: &BTreeSet<T>) -> bool {\n+        self.intersection(other).next().is_none()\n+    }\n+\n+    fn is_subset(&self, other: &BTreeSet<T>) -> bool {\n+        // Stolen from TreeMap\n+        let mut x = self.iter();\n+        let mut y = other.iter();\n+        let mut a = x.next();\n+        let mut b = y.next();\n+        while a.is_some() {\n+            if b.is_none() {\n+                return false;\n+            }\n+\n+            let a1 = a.unwrap();\n+            let b1 = b.unwrap();\n+\n+            match b1.cmp(a1) {\n+                Less => (),\n+                Greater => return false,\n+                Equal => a = x.next(),\n+            }\n+\n+            b = y.next();\n+        }\n+        true\n+    }\n+}\n+\n+impl<T: Ord> MutableSet<T> for BTreeSet<T>{\n+    fn insert(&mut self, value: T) -> bool {\n+        self.map.insert(value, ())\n+    }\n+\n+    fn remove(&mut self, value: &T) -> bool {\n+        self.map.remove(value)\n+    }\n+}\n+\n+impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n+    fn from_iter<Iter: Iterator<T>>(iter: Iter) -> BTreeSet<T> {\n+        let mut set = BTreeSet::new();\n+        set.extend(iter);\n+        set\n+    }\n+}\n+\n+impl<T: Ord> Extendable<T> for BTreeSet<T> {\n+    #[inline]\n+    fn extend<Iter: Iterator<T>>(&mut self, mut iter: Iter) {\n+        for elem in iter {\n+            self.insert(elem);\n+        }\n+    }\n+}\n+\n+impl<T: Ord> Default for BTreeSet<T> {\n+    fn default() -> BTreeSet<T> {\n+        BTreeSet::new()\n+    }\n+}\n+\n+impl<T: Show> Show for BTreeSet<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{{\"));\n+\n+        for (i, x) in self.iter().enumerate() {\n+            if i != 0 { try!(write!(f, \", \")); }\n+            try!(write!(f, \"{}\", *x));\n+        }\n+\n+        write!(f, \"}}\")\n+    }\n+}\n+\n+/// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n+fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n+                        short: Ordering, long: Ordering) -> Ordering {\n+    match (x, y) {\n+        (None    , _       ) => short,\n+        (_       , None    ) => long,\n+        (Some(x1), Some(y1)) => x1.cmp(y1),\n+    }\n+}\n+\n+impl<'a, T: Ord> Iterator<&'a T> for DifferenceItems<'a, T> {\n+    fn next(&mut self) -> Option<&'a T> {\n+        loop {\n+            match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n+                Less    => return self.a.next(),\n+                Equal   => { self.a.next(); self.b.next(); }\n+                Greater => { self.b.next(); }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, T: Ord> Iterator<&'a T> for SymDifferenceItems<'a, T> {\n+    fn next(&mut self) -> Option<&'a T> {\n+        loop {\n+            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n+                Less    => return self.a.next(),\n+                Equal   => { self.a.next(); self.b.next(); }\n+                Greater => return self.b.next(),\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, T: Ord> Iterator<&'a T> for IntersectionItems<'a, T> {\n+    fn next(&mut self) -> Option<&'a T> {\n+        loop {\n+            let o_cmp = match (self.a.peek(), self.b.peek()) {\n+                (None    , _       ) => None,\n+                (_       , None    ) => None,\n+                (Some(a1), Some(b1)) => Some(a1.cmp(b1)),\n+            };\n+            match o_cmp {\n+                None          => return None,\n+                Some(Less)    => { self.a.next(); }\n+                Some(Equal)   => { self.b.next(); return self.a.next() }\n+                Some(Greater) => { self.b.next(); }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, T: Ord> Iterator<&'a T> for UnionItems<'a, T> {\n+    fn next(&mut self) -> Option<&'a T> {\n+        loop {\n+            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n+                Less    => return self.a.next(),\n+                Equal   => { self.b.next(); return self.a.next() }\n+                Greater => return self.b.next(),\n+            }\n+        }\n+    }\n+}\n+\n+\n+#[cfg(test)]\n+mod test {\n+    use std::prelude::*;\n+\n+    use {Set, MutableSet};\n+    use super::BTreeSet;\n+    use std::hash;\n+\n+    #[test]\n+    fn test_clone_eq() {\n+      let mut m = BTreeSet::new();\n+\n+      m.insert(1i);\n+      m.insert(2);\n+\n+      assert!(m.clone() == m);\n+    }\n+\n+    #[test]\n+    fn test_hash() {\n+      let mut x = BTreeSet::new();\n+      let mut y = BTreeSet::new();\n+\n+      x.insert(1i);\n+      x.insert(2);\n+      x.insert(3);\n+\n+      y.insert(3i);\n+      y.insert(2);\n+      y.insert(1);\n+\n+      assert!(hash::hash(&x) == hash::hash(&y));\n+    }\n+\n+    fn check(a: &[int],\n+             b: &[int],\n+             expected: &[int],\n+             f: |&BTreeSet<int>, &BTreeSet<int>, f: |&int| -> bool| -> bool) {\n+        let mut set_a = BTreeSet::new();\n+        let mut set_b = BTreeSet::new();\n+\n+        for x in a.iter() { assert!(set_a.insert(*x)) }\n+        for y in b.iter() { assert!(set_b.insert(*y)) }\n+\n+        let mut i = 0;\n+        f(&set_a, &set_b, |x| {\n+            assert_eq!(*x, expected[i]);\n+            i += 1;\n+            true\n+        });\n+        assert_eq!(i, expected.len());\n+    }\n+\n+    #[test]\n+    fn test_intersection() {\n+        fn check_intersection(a: &[int], b: &[int], expected: &[int]) {\n+            check(a, b, expected, |x, y, f| x.intersection(y).all(f))\n+        }\n+\n+        check_intersection([], [], []);\n+        check_intersection([1, 2, 3], [], []);\n+        check_intersection([], [1, 2, 3], []);\n+        check_intersection([2], [1, 2, 3], [2]);\n+        check_intersection([1, 2, 3], [2], [2]);\n+        check_intersection([11, 1, 3, 77, 103, 5, -5],\n+                           [2, 11, 77, -9, -42, 5, 3],\n+                           [3, 5, 11, 77]);\n+    }\n+\n+    #[test]\n+    fn test_difference() {\n+        fn check_difference(a: &[int], b: &[int], expected: &[int]) {\n+            check(a, b, expected, |x, y, f| x.difference(y).all(f))\n+        }\n+\n+        check_difference([], [], []);\n+        check_difference([1, 12], [], [1, 12]);\n+        check_difference([], [1, 2, 3, 9], []);\n+        check_difference([1, 3, 5, 9, 11],\n+                         [3, 9],\n+                         [1, 5, 11]);\n+        check_difference([-5, 11, 22, 33, 40, 42],\n+                         [-12, -5, 14, 23, 34, 38, 39, 50],\n+                         [11, 22, 33, 40, 42]);\n+    }\n+\n+    #[test]\n+    fn test_symmetric_difference() {\n+        fn check_symmetric_difference(a: &[int], b: &[int],\n+                                      expected: &[int]) {\n+            check(a, b, expected, |x, y, f| x.symmetric_difference(y).all(f))\n+        }\n+\n+        check_symmetric_difference([], [], []);\n+        check_symmetric_difference([1, 2, 3], [2], [1, 3]);\n+        check_symmetric_difference([2], [1, 2, 3], [1, 3]);\n+        check_symmetric_difference([1, 3, 5, 9, 11],\n+                                   [-2, 3, 9, 14, 22],\n+                                   [-2, 1, 5, 11, 14, 22]);\n+    }\n+\n+    #[test]\n+    fn test_union() {\n+        fn check_union(a: &[int], b: &[int],\n+                                      expected: &[int]) {\n+            check(a, b, expected, |x, y, f| x.union(y).all(f))\n+        }\n+\n+        check_union([], [], []);\n+        check_union([1, 2, 3], [2], [1, 2, 3]);\n+        check_union([2], [1, 2, 3], [1, 2, 3]);\n+        check_union([1, 3, 5, 9, 11, 16, 19, 24],\n+                    [-2, 1, 5, 9, 13, 19],\n+                    [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n+    }\n+\n+    #[test]\n+    fn test_zip() {\n+        let mut x = BTreeSet::new();\n+        x.insert(5u);\n+        x.insert(12u);\n+        x.insert(11u);\n+\n+        let mut y = BTreeSet::new();\n+        y.insert(\"foo\");\n+        y.insert(\"bar\");\n+\n+        let x = x;\n+        let y = y;\n+        let mut z = x.iter().zip(y.iter());\n+\n+        // FIXME: #5801: this needs a type hint to compile...\n+        let result: Option<(&uint, & &'static str)> = z.next();\n+        assert_eq!(result.unwrap(), (&5u, &(\"bar\")));\n+\n+        let result: Option<(&uint, & &'static str)> = z.next();\n+        assert_eq!(result.unwrap(), (&11u, &(\"foo\")));\n+\n+        let result: Option<(&uint, & &'static str)> = z.next();\n+        assert!(result.is_none());\n+    }\n+\n+    #[test]\n+    fn test_from_iter() {\n+        let xs = [1i, 2, 3, 4, 5, 6, 7, 8, 9];\n+\n+        let set: BTreeSet<int> = xs.iter().map(|&x| x).collect();\n+\n+        for x in xs.iter() {\n+            assert!(set.contains(x));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_show() {\n+        let mut set: BTreeSet<int> = BTreeSet::new();\n+        let empty: BTreeSet<int> = BTreeSet::new();\n+\n+        set.insert(1);\n+        set.insert(2);\n+\n+        let set_str = format!(\"{}\", set);\n+\n+        assert!(set_str == \"{1, 2}\".to_string());\n+        assert_eq!(format!(\"{}\", empty), \"{}\".to_string());\n+    }\n+}"}, {"sha": "8b9a0ec796e27eba11ba9bd161a72cfdc7a35cdd", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6edc59413f79016a1063c2ec6bc05516bc99cb6/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6edc59413f79016a1063c2ec6bc05516bc99cb6/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=b6edc59413f79016a1063c2ec6bc05516bc99cb6", "patch": "@@ -37,7 +37,7 @@ extern crate alloc;\n use core::prelude::Option;\n \n pub use bitv::{Bitv, BitvSet};\n-pub use btree::BTree;\n+pub use btree::{BTreeMap, BTreeSet};\n pub use core::prelude::Collection;\n pub use dlist::DList;\n pub use enum_set::EnumSet;"}, {"sha": "324c0295971e1ceb5e9aa0b81fb5a59a0a40ab21", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6edc59413f79016a1063c2ec6bc05516bc99cb6/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6edc59413f79016a1063c2ec6bc05516bc99cb6/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=b6edc59413f79016a1063c2ec6bc05516bc99cb6", "patch": "@@ -16,7 +16,7 @@\n \n pub use core_collections::{Collection, Mutable, Map, MutableMap};\n pub use core_collections::{Set, MutableSet, Deque, MutableSeq};\n-pub use core_collections::{Bitv, BitvSet, BTree, DList, EnumSet};\n+pub use core_collections::{Bitv, BitvSet, BTreeMap, BTreeSet, DList, EnumSet};\n pub use core_collections::{PriorityQueue, RingBuf, SmallIntMap};\n pub use core_collections::{TreeMap, TreeSet, TrieMap, TrieSet};\n pub use core_collections::{bitv, btree, dlist, enum_set};"}]}