{"sha": "ad6ca084e7ac47b59714356c08eeb274a6e239ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkNmNhMDg0ZTdhYzQ3YjU5NzE0MzU2YzA4ZWViMjc0YTZlMjM5Y2E=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-17T09:22:26Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-18T20:38:29Z"}, "message": "don't create region vars in LUB coercions\n\ninstead, extract the target region out of the autoderef loop", "tree": {"sha": "25a33f690a55623e9bedde52ad7189f0efdff6f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25a33f690a55623e9bedde52ad7189f0efdff6f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad6ca084e7ac47b59714356c08eeb274a6e239ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad6ca084e7ac47b59714356c08eeb274a6e239ca", "html_url": "https://github.com/rust-lang/rust/commit/ad6ca084e7ac47b59714356c08eeb274a6e239ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad6ca084e7ac47b59714356c08eeb274a6e239ca/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00c942016033abb6dea1015c017bea5517af25a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/00c942016033abb6dea1015c017bea5517af25a0", "html_url": "https://github.com/rust-lang/rust/commit/00c942016033abb6dea1015c017bea5517af25a0"}], "stats": {"total": 125, "additions": 84, "deletions": 41}, "files": [{"sha": "d0e3f72e0e12bcc93f7288463556c093c32ca4fd", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 84, "deletions": 41, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/ad6ca084e7ac47b59714356c08eeb274a6e239ca/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad6ca084e7ac47b59714356c08eeb274a6e239ca/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=ad6ca084e7ac47b59714356c08eeb274a6e239ca", "patch": "@@ -71,7 +71,7 @@ use middle::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n use middle::ty::{self, LvaluePreference, TypeAndMut, Ty, TyCtxt};\n use middle::ty::fold::TypeFoldable;\n use middle::ty::error::TypeError;\n-use middle::ty::relate::{relate_substs, RelateResult, TypeRelation};\n+use middle::ty::relate::{relate_substs, Relate, RelateResult, TypeRelation};\n use util::common::indent;\n \n use std::cell::RefCell;\n@@ -112,8 +112,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         self.fcx.tcx()\n     }\n \n-    /// Unify two types (using sub or lub) and produce a noop coercion.\n-    fn unify_and_identity(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n+    fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         let infcx = self.fcx.infcx();\n         infcx.commit_if_ok(|_| {\n             let trace = TypeTrace::types(self.origin, false, a, b);\n@@ -122,7 +121,12 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             } else {\n                 infcx.sub(false, trace).relate(&a, &b)\n             }\n-        }).and_then(|ty| self.identity(ty))\n+        })\n+    }\n+\n+    /// Unify two types (using sub or lub) and produce a noop coercion.\n+    fn unify_and_identity(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n+        self.unify(&a, &b).and_then(|ty| self.identity(ty))\n     }\n \n     /// Synthesize an identity adjustment.\n@@ -167,7 +171,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n \n             ty::TyRef(r_b, mt_b) => {\n-                return self.coerce_borrowed_pointer(exprs, a, b, r_b, mt_b.mutbl);\n+                return self.coerce_borrowed_pointer(exprs, a, b, r_b, mt_b);\n             }\n \n             _ => {}\n@@ -200,7 +204,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                          a: Ty<'tcx>,\n                                          b: Ty<'tcx>,\n                                          r_b: &'tcx ty::Region,\n-                                         mutbl_b: hir::Mutability)\n+                                         mt_b: TypeAndMut<'tcx>)\n                                          -> CoerceResult<'tcx>\n         // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n         where E: Fn() -> I,\n@@ -214,68 +218,107 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // to type check, we will construct the type that `&M*expr` would\n         // yield.\n \n-        let (_r_a, _mutbl_a) = match a.sty {\n+        let r_a = match a.sty {\n             ty::TyRef(r_a, mt_a) => {\n-                try!(coerce_mutbls(mt_a.mutbl, mutbl_b));\n-                (r_a, mt_a.mutbl)\n+                try!(coerce_mutbls(mt_a.mutbl, mt_b.mutbl));\n+                r_a\n             }\n             _ => return self.unify_and_identity(a, b)\n         };\n \n         let span = self.origin.span();\n-        let coercion = Coercion(span);\n-        let r_borrow = {\n-            // If are coercing from `&'a T` to `&'b U`, then we want to\n-            // reborrow the contents of `'a` for the lifetime `'b`\n-            // (which ought to be a sublifetime of `'a`).\n-            if !self.use_lub {\n-                r_b\n-            } else {\n-                // With LUB, we need more flexibility.\n-                let r_borrow = self.fcx.infcx().next_region_var(coercion);\n-                self.tcx().mk_region(r_borrow)\n-            }\n-        };\n-        let autoref = Some(AutoPtr(r_borrow, mutbl_b));\n \n-        let lvalue_pref = LvaluePreference::from_mutbl(mutbl_b);\n+        let lvalue_pref = LvaluePreference::from_mutbl(mt_b.mutbl);\n         let mut first_error = None;\n         let (_, autoderefs, success) = autoderef(self.fcx, span, a, exprs,\n                                                  UnresolvedTypeAction::Ignore,\n                                                  lvalue_pref,\n-                                                 |inner_ty, autoderef| {\n+                                                 |referent_ty, autoderef|\n+        {\n             if autoderef == 0 {\n                 // Don't let this pass, otherwise it would cause\n                 // &T to autoref to &&T.\n                 return None;\n             }\n-            let ty = self.tcx().mk_ref(r_borrow,\n-                                        TypeAndMut {ty: inner_ty, mutbl: mutbl_b});\n-            match self.unify_and_identity(ty, b) {\n+\n+            // At this point, we have deref'd `a` to `referent_ty`.  So\n+            // imagine we are coercing from `&'a mut Vec<T>` to `&'b mut [T]`.\n+            // In the autoderef loop for `&'a mut Vec<T>`, we would get\n+            // three callbacks:\n+            //\n+            // - `&'a mut Vec<T>` -- 0 derefs, just ignore it\n+            // - `Vec<T>` -- 1 deref\n+            // - `[T]` -- 2 deref\n+            //\n+            // At each point after the first callback, we want to\n+            // check to see whether this would match out target type\n+            // (`&'b mut [T]`) if we autoref'd it. We can't just\n+            // compare the referent types, though, because we still\n+            // have to consider the mutability. E.g., in the case\n+            // we've been considering, we have an `&mut` reference, so\n+            // the `T` in `[T]` needs to be unified with equality.\n+            //\n+            // Therefore, we construct reference types reflecting what\n+            // the types will be after we do the final auto-ref and\n+            // compare those. Note that this means we use the target\n+            // mutability [1], since it may be that we are coercing\n+            // from `&mut T` to `&U`.\n+            //\n+            // One fine point concerns the region that we use [2]. We\n+            // choose the region such that the region of the final\n+            // type that results from `unify` will be the region we\n+            // want for the autoref:\n+            //\n+            // - if in lub mode, that means we want to unify `&'a mut [T]`\n+            //   (from source) and `&'b mut [T]` (target).\n+            // - if in sub mode, that means we want to use `'b` for\n+            //   both pointers. This is because sub mode (somewhat\n+            //   arbitrarily) returns the subtype region.  In the case\n+            //   where we are coercing to a target type, we know we\n+            //   want to use that target type region (`'b`) because --\n+            //   for the program to type-check -- it must be the\n+            //   smaller of the two.\n+            let r = if self.use_lub {r_a} else {r_b}; // [2] above\n+            let derefd_ty_a = self.tcx().mk_ref(r, TypeAndMut {\n+                ty: referent_ty,\n+                mutbl: mt_b.mutbl // [1] above\n+            });\n+            match self.unify(derefd_ty_a, b) {\n+                Ok(ty) => Some(ty),\n                 Err(err) => {\n                     if first_error.is_none() {\n                         first_error = Some(err);\n                     }\n                     None\n                 }\n-                Ok((ty, _)) => Some(ty)\n             }\n         });\n \n-        match success {\n-            Some(ty) => {\n-                Ok((ty, AdjustDerefRef(AutoDerefRef {\n-                    autoderefs: autoderefs,\n-                    autoref: autoref,\n-                    unsize: None\n-                })))\n-            }\n+        // Extract type or return an error. We return the first error\n+        // we got, which should be from relating the \"base\" type\n+        // (e.g., in example above, the failure from relating `Vec<T>`\n+        // to the target type), since that should be the least\n+        // confusing.\n+        let ty = match success {\n+            Some(ty) => ty,\n             None => {\n-                // Return original error as if overloaded deref was never\n-                // attempted, to avoid irrelevant/confusing error messages.\n-                Err(first_error.expect(\"coerce_borrowed_pointer failed with no error?\"))\n+                return Err(first_error.expect(\"coerce_borrowed_pointer had no error\"));\n             }\n-        }\n+        };\n+\n+        // Now apply the autoref. We have to extract the region out of\n+        // the final ref type we got.\n+        let r_borrow = match ty.sty {\n+            ty::TyRef(r, _) => r,\n+            _ => self.tcx().sess.span_bug(span,\n+                                          &format!(\"expected a ref type, got {:?}\", ty))\n+        };\n+        let autoref = Some(AutoPtr(r_borrow, mt_b.mutbl));\n+        Ok((ty, AdjustDerefRef(AutoDerefRef {\n+            autoderefs: autoderefs,\n+            autoref: autoref,\n+            unsize: None\n+        })))\n     }\n \n "}]}