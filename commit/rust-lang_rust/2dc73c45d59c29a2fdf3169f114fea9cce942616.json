{"sha": "2dc73c45d59c29a2fdf3169f114fea9cce942616", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkYzczYzQ1ZDU5YzI5YTJmZGYzMTY5ZjExNGZlYTljY2U5NDI2MTY=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-01-24T08:04:37Z"}, "committer": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-01-24T08:04:37Z"}, "message": "Clean up `methods/mod.rs`", "tree": {"sha": "ce38b1362f83c32cfe81b31732cbe778613b482a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce38b1362f83c32cfe81b31732cbe778613b482a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2dc73c45d59c29a2fdf3169f114fea9cce942616", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2dc73c45d59c29a2fdf3169f114fea9cce942616", "html_url": "https://github.com/rust-lang/rust/commit/2dc73c45d59c29a2fdf3169f114fea9cce942616", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2dc73c45d59c29a2fdf3169f114fea9cce942616/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c7cfa83211c03a24f0c075c71ac3e77525f3232", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c7cfa83211c03a24f0c075c71ac3e77525f3232", "html_url": "https://github.com/rust-lang/rust/commit/2c7cfa83211c03a24f0c075c71ac3e77525f3232"}], "stats": {"total": 104, "additions": 52, "deletions": 52}, "files": [{"sha": "add1bcef8737cb8df7b48e2c7bc3defc4d3e3634", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/2dc73c45d59c29a2fdf3169f114fea9cce942616/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc73c45d59c29a2fdf3169f114fea9cce942616/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=2dc73c45d59c29a2fdf3169f114fea9cce942616", "patch": "@@ -2133,14 +2133,12 @@ fn lint_iter_nth<'a, 'tcx>(\n         return; // caller is not a type that we want to lint\n     };\n \n-    span_lint(\n+    span_help_and_lint(\n         cx,\n         ITER_NTH,\n         expr.span,\n-        &format!(\n-            \"called `.iter{0}().nth()` on a {1}. Calling `.get{0}()` is both faster and more readable\",\n-            mut_str, caller_type\n-        ),\n+        &format!(\"called `.iter{0}().nth()` on a {1}\", mut_str, caller_type),\n+        &format!(\"Calling `.get{}()` is both faster and more readable\", mut_str),\n     );\n }\n \n@@ -2244,11 +2242,12 @@ fn lint_get_unwrap<'a, 'tcx>(\n fn lint_iter_skip_next(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) {\n     // lint if caller of skip is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        span_lint(\n+        span_help_and_lint(\n             cx,\n             ITER_SKIP_NEXT,\n             expr.span,\n-            \"called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\",\n+            \"called `skip(x).next()` on an iterator\",\n+            \"This is more succinctly expressed by calling `nth(x)`.\",\n         );\n     }\n }\n@@ -2304,15 +2303,15 @@ fn lint_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, unwrap_args: &[hi\n     };\n \n     if let Some((lint, kind, none_value)) = mess {\n-        span_lint(\n+        span_help_and_lint(\n             cx,\n             lint,\n             expr.span,\n+            &format!(\"used `unwrap()` on `{}` value\", kind,),\n             &format!(\n-                \"used `unwrap()` on `{}` value. If you don't want to handle the `{}` case gracefully, consider \\\n-                 using `expect()` to provide a better panic \\\n-                 message\",\n-                kind, none_value\n+                \"If you don't want to handle the `{}` case gracefully, consider \\\n+                using `expect()` to provide a better panic message.\",\n+                none_value,\n             ),\n         );\n     }\n@@ -2331,14 +2330,12 @@ fn lint_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, expect_args: &[hi\n     };\n \n     if let Some((lint, kind, none_value)) = mess {\n-        span_lint(\n+        span_help_and_lint(\n             cx,\n             lint,\n             expr.span,\n-            &format!(\n-                \"used `expect()` on `{}` value. If this value is an `{}` it will panic\",\n-                kind, none_value\n-            ),\n+            &format!(\"used `expect()` on `{}` value\", kind,),\n+            &format!(\"If this value is an `{}`, it will panic.\", none_value,),\n         );\n     }\n }\n@@ -2353,11 +2350,12 @@ fn lint_ok_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, ok_args: &[hir\n         if has_debug_impl(error_type, cx);\n \n         then {\n-            span_lint(\n+            span_help_and_lint(\n                 cx,\n                 OK_EXPECT,\n                 expr.span,\n-                \"called `ok().expect()` on a `Result` value. You can call `expect()` directly on the `Result`\",\n+                \"called `ok().expect()` on a `Result` value\",\n+                \"You can call `expect()` directly on the `Result`\",\n             );\n         }\n     }\n@@ -2372,14 +2370,15 @@ fn lint_map_flatten<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<\n         let self_snippet = snippet(cx, map_args[0].span, \"..\");\n         let func_snippet = snippet(cx, map_args[1].span, \"..\");\n         let hint = format!(\"{0}.flat_map({1})\", self_snippet, func_snippet);\n-        span_lint_and_then(cx, MAP_FLATTEN, expr.span, msg, |db| {\n-            db.span_suggestion(\n-                expr.span,\n-                \"try using `flat_map` instead\",\n-                hint,\n-                Applicability::MachineApplicable,\n-            );\n-        });\n+        span_lint_and_sugg(\n+            cx,\n+            MAP_FLATTEN,\n+            expr.span,\n+            msg,\n+            \"try using `flat_map` instead\",\n+            hint,\n+            Applicability::MachineApplicable,\n+        );\n     }\n }\n \n@@ -2474,14 +2473,15 @@ fn lint_map_or_none<'a, 'tcx>(\n             let map_or_self_snippet = snippet(cx, map_or_args[0].span, \"..\");\n             let map_or_func_snippet = snippet(cx, map_or_args[2].span, \"..\");\n             let hint = format!(\"{0}.and_then({1})\", map_or_self_snippet, map_or_func_snippet);\n-            span_lint_and_then(cx, OPTION_MAP_OR_NONE, expr.span, msg, |db| {\n-                db.span_suggestion(\n-                    expr.span,\n-                    \"try using `and_then` instead\",\n-                    hint,\n-                    Applicability::MachineApplicable, // snippet\n-                );\n-            });\n+            span_lint_and_sugg(\n+                cx,\n+                OPTION_MAP_OR_NONE,\n+                expr.span,\n+                msg,\n+                \"try using `and_then` instead\",\n+                hint,\n+                Applicability::MachineApplicable,\n+            );\n         }\n     }\n }\n@@ -2607,9 +2607,9 @@ fn lint_filter_map<'a, 'tcx>(\n ) {\n     // lint if caller of `.filter().map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let msg = \"called `filter(p).map(q)` on an `Iterator`. \\\n-                   This is more succinctly expressed by calling `.filter_map(..)` instead.\";\n-        span_lint(cx, FILTER_MAP, expr.span, msg);\n+        let msg = \"called `filter(p).map(q)` on an `Iterator`\";\n+        let hint = \"This is more succinctly expressed by calling `.filter_map(..)` instead.\";\n+        span_help_and_lint(cx, FILTER_MAP, expr.span, msg, hint);\n     }\n }\n \n@@ -2647,9 +2647,9 @@ fn lint_find_map<'a, 'tcx>(\n ) {\n     // lint if caller of `.filter().map()` is an Iterator\n     if match_trait_method(cx, &map_args[0], &paths::ITERATOR) {\n-        let msg = \"called `find(p).map(q)` on an `Iterator`. \\\n-                   This is more succinctly expressed by calling `.find_map(..)` instead.\";\n-        span_lint(cx, FIND_MAP, expr.span, msg);\n+        let msg = \"called `find(p).map(q)` on an `Iterator`\";\n+        let hint = \"This is more succinctly expressed by calling `.find_map(..)` instead.\";\n+        span_help_and_lint(cx, FIND_MAP, expr.span, msg, hint);\n     }\n }\n \n@@ -2662,9 +2662,9 @@ fn lint_filter_map_map<'a, 'tcx>(\n ) {\n     // lint if caller of `.filter().map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let msg = \"called `filter_map(p).map(q)` on an `Iterator`. \\\n-                   This is more succinctly expressed by only calling `.filter_map(..)` instead.\";\n-        span_lint(cx, FILTER_MAP, expr.span, msg);\n+        let msg = \"called `filter_map(p).map(q)` on an `Iterator`\";\n+        let hint = \"This is more succinctly expressed by only calling `.filter_map(..)` instead.\";\n+        span_help_and_lint(cx, FILTER_MAP, expr.span, msg, hint);\n     }\n }\n \n@@ -2677,10 +2677,10 @@ fn lint_filter_flat_map<'a, 'tcx>(\n ) {\n     // lint if caller of `.filter().flat_map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let msg = \"called `filter(p).flat_map(q)` on an `Iterator`. \\\n-                   This is more succinctly expressed by calling `.flat_map(..)` \\\n-                   and filtering by returning an empty Iterator.\";\n-        span_lint(cx, FILTER_MAP, expr.span, msg);\n+        let msg = \"called `filter(p).flat_map(q)` on an `Iterator`\";\n+        let hint = \"This is more succinctly expressed by calling `.flat_map(..)` \\\n+            and filtering by returning an empty Iterator.\";\n+        span_help_and_lint(cx, FILTER_MAP, expr.span, msg, hint);\n     }\n }\n \n@@ -2693,10 +2693,10 @@ fn lint_filter_map_flat_map<'a, 'tcx>(\n ) {\n     // lint if caller of `.filter_map().flat_map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let msg = \"called `filter_map(p).flat_map(q)` on an `Iterator`. \\\n-                   This is more succinctly expressed by calling `.flat_map(..)` \\\n-                   and filtering by returning an empty Iterator.\";\n-        span_lint(cx, FILTER_MAP, expr.span, msg);\n+        let msg = \"called `filter_map(p).flat_map(q)` on an `Iterator`\";\n+        let hint = \"This is more succinctly expressed by calling `.flat_map(..)` \\\n+            and filtering by returning an empty Iterator.\";\n+        span_help_and_lint(cx, FILTER_MAP, expr.span, msg, hint);\n     }\n }\n "}]}