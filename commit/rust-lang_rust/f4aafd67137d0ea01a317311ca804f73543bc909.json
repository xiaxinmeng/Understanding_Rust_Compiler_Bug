{"sha": "f4aafd67137d0ea01a317311ca804f73543bc909", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0YWFmZDY3MTM3ZDBlYTAxYTMxNzMxMWNhODA0ZjczNTQzYmM5MDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-02T19:16:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-02T19:16:07Z"}, "message": "auto merge of #16916 : alexcrichton/rust/tcp-accept-stress-again-oh-my, r=brson\n\nThe tcp-accept-stress, despite the previous modifications, is still deadlocking\r\non the osx buildbots. When building/testing/running repeatedly locally, it was\r\ndiscovered that the test would often fail with TcpStream::connect returning the\r\nerror `address not available`.\r\n\r\nThis test opens up quite a large number of sockets, and it looks like by default\r\nosx isn't the speediest at recycling those sockets for further use.\r\n\r\nThe test has been modified (and verified) to not deadlock in this error case,\r\nand the test is not just officially ignored on OSX (with no FIXME). I believe\r\nthat we'll get good coverage of the relevant code on the linux builders, so this\r\nisn't so much of a loss.\r\n\r\nAt the same time I turned down the stress parameters to hopefully lighten the\r\nsocket load on other platforms.", "tree": {"sha": "0b30fd05520efcdf9b5991e3d7a0e05991ec3ae3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b30fd05520efcdf9b5991e3d7a0e05991ec3ae3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4aafd67137d0ea01a317311ca804f73543bc909", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4aafd67137d0ea01a317311ca804f73543bc909", "html_url": "https://github.com/rust-lang/rust/commit/f4aafd67137d0ea01a317311ca804f73543bc909", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4aafd67137d0ea01a317311ca804f73543bc909/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfbd4669cd0ce6298b5cee7d4b5e1585d8228daa", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfbd4669cd0ce6298b5cee7d4b5e1585d8228daa", "html_url": "https://github.com/rust-lang/rust/commit/dfbd4669cd0ce6298b5cee7d4b5e1585d8228daa"}, {"sha": "79f51c1d31a4010c91234768765a4ebb44d8e6ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/79f51c1d31a4010c91234768765a4ebb44d8e6ed", "html_url": "https://github.com/rust-lang/rust/commit/79f51c1d31a4010c91234768765a4ebb44d8e6ed"}], "stats": {"total": 29, "additions": 19, "deletions": 10}, "files": [{"sha": "1d69568e2b891a9b97b17400a664342f25e503fe", "filename": "src/test/run-pass/tcp-accept-stress.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f4aafd67137d0ea01a317311ca804f73543bc909/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4aafd67137d0ea01a317311ca804f73543bc909/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs?ref=f4aafd67137d0ea01a317311ca804f73543bc909", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-macos osx really doesn't like cycling through large numbers of\n+//              sockets as calls to connect() will start returning EADDRNOTAVAIL\n+//              quite quickly and it takes a few seconds for the sockets to get\n+//              recycled.\n+\n #![feature(phase)]\n \n #[phase(plugin)]\n@@ -20,7 +25,7 @@ use std::task::TaskBuilder;\n use native::NativeTaskBuilder;\n \n static N: uint = 8;\n-static M: uint = 100;\n+static M: uint = 20;\n \n green_start!(main)\n \n@@ -40,11 +45,12 @@ fn test() {\n     let mut a = l.listen().unwrap();\n     let cnt = Arc::new(atomic::AtomicUint::new(0));\n \n-    let (tx, rx) = channel();\n+    let (srv_tx, srv_rx) = channel();\n+    let (cli_tx, cli_rx) = channel();\n     for _ in range(0, N) {\n         let a = a.clone();\n         let cnt = cnt.clone();\n-        let tx = tx.clone();\n+        let srv_tx = srv_tx.clone();\n         spawn(proc() {\n             let mut a = a;\n             loop {\n@@ -58,33 +64,36 @@ fn test() {\n                     Err(e) => fail!(\"{}\", e),\n                 }\n             }\n-            tx.send(());\n+            srv_tx.send(());\n         });\n     }\n \n     for _ in range(0, N) {\n-        let tx = tx.clone();\n+        let cli_tx = cli_tx.clone();\n         spawn(proc() {\n             for _ in range(0, M) {\n                 let _s = TcpStream::connect(addr.ip.to_string().as_slice(),\n                                             addr.port).unwrap();\n             }\n-            tx.send(());\n+            cli_tx.send(());\n         });\n     }\n-    drop(tx);\n+    drop((cli_tx, srv_tx));\n \n     // wait for senders\n-    assert_eq!(rx.iter().take(N).count(), N);\n+    if cli_rx.iter().take(N).count() != N {\n+        a.close_accept().unwrap();\n+        fail!(\"clients failed\");\n+    }\n \n     // wait for one acceptor to die\n-    let _ = rx.recv();\n+    let _ = srv_rx.recv();\n \n     // Notify other receivers should die\n     a.close_accept().unwrap();\n \n     // wait for receivers\n-    assert_eq!(rx.iter().take(N - 1).count(), N - 1);\n+    assert_eq!(srv_rx.iter().take(N - 1).count(), N - 1);\n \n     // Everything should have been accepted.\n     assert_eq!(cnt.load(atomic::SeqCst), N * M);"}]}