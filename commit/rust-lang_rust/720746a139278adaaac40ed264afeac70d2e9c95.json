{"sha": "720746a139278adaaac40ed264afeac70d2e9c95", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyMDc0NmExMzkyNzhhZGFhYWM0MGVkMjY0YWZlYWM3MGQyZTljOTU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-08-06T18:25:14Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-08-06T18:25:14Z"}, "message": "Merge commit '881bfb1a180a1b545daa9da1539ec4c8ebda7ed1' into rollup", "tree": {"sha": "a23d7f639a1c8297592fc6530df2187a9d0a32f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a23d7f639a1c8297592fc6530df2187a9d0a32f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/720746a139278adaaac40ed264afeac70d2e9c95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/720746a139278adaaac40ed264afeac70d2e9c95", "html_url": "https://github.com/rust-lang/rust/commit/720746a139278adaaac40ed264afeac70d2e9c95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/720746a139278adaaac40ed264afeac70d2e9c95/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5df5f56069de2778857597118a6e5f95d659736", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5df5f56069de2778857597118a6e5f95d659736", "html_url": "https://github.com/rust-lang/rust/commit/e5df5f56069de2778857597118a6e5f95d659736"}, {"sha": "881bfb1a180a1b545daa9da1539ec4c8ebda7ed1", "url": "https://api.github.com/repos/rust-lang/rust/commits/881bfb1a180a1b545daa9da1539ec4c8ebda7ed1", "html_url": "https://github.com/rust-lang/rust/commit/881bfb1a180a1b545daa9da1539ec4c8ebda7ed1"}], "stats": {"total": 372, "additions": 271, "deletions": 101}, "files": [{"sha": "b1128bc40cc5c05c6d9839bf5683bbe521c9dea8", "filename": "mk/platform.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/720746a139278adaaac40ed264afeac70d2e9c95/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/720746a139278adaaac40ed264afeac70d2e9c95/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=720746a139278adaaac40ed264afeac70d2e9c95", "patch": "@@ -377,7 +377,7 @@ RUSTC_CROSS_FLAGS_arm-unknown-linux-gnueabi :=\n # mipsel-linux configuration\n CC_mipsel-linux=mipsel-linux-gcc\n CXX_mipsel-linux=mipsel-linux-g++\n-CPP_mipsel-linux=mipsel-linux-gcc \n+CPP_mipsel-linux=mipsel-linux-gcc\n AR_mipsel-linux=mipsel-linux-ar\n CFG_LIB_NAME_mipsel-linux=lib$(1).so\n CFG_STATIC_LIB_NAME_mipsel-linux=lib$(1).a\n@@ -641,7 +641,7 @@ define CFG_MAKE_TOOLCHAIN\n \tCXX_$(1)=$(CROSS_PREFIX_$(1))$(CXX_$(1))\n \tCPP_$(1)=$(CROSS_PREFIX_$(1))$(CPP_$(1))\n \tAR_$(1)=$(CROSS_PREFIX_$(1))$(AR_$(1))\n-\tRUSTC_CROSS_FLAGS_$(1)=-C linker=$$(call FIND_COMPILER,$$(CXX_$(1))) \\\n+\tRUSTC_CROSS_FLAGS_$(1)=-C linker=$$(call FIND_COMPILER,$$(CC_$(1))) \\\n \t    -C ar=$$(call FIND_COMPILER,$$(AR_$(1))) $(RUSTC_CROSS_FLAGS_$(1))\n \n \tRUSTC_FLAGS_$(1)=$$(RUSTC_CROSS_FLAGS_$(1)) $(RUSTC_FLAGS_$(1))"}, {"sha": "c5acb69df8d732653d4aadd505bb50cc2f6d7f7a", "filename": "src/etc/get-snapshot.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/720746a139278adaaac40ed264afeac70d2e9c95/src%2Fetc%2Fget-snapshot.py", "raw_url": "https://github.com/rust-lang/rust/raw/720746a139278adaaac40ed264afeac70d2e9c95/src%2Fetc%2Fget-snapshot.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fget-snapshot.py?ref=720746a139278adaaac40ed264afeac70d2e9c95", "patch": "@@ -53,7 +53,7 @@ def unpack_snapshot(triple, dl_path):\n   dl_path = sys.argv[2]\n else:\n   # There are no 64-bit Windows snapshots yet, so we'll use 32-bit ones instead, for now\n-  snap_triple = triple if triple != \"x86_64-w64-mingw32\" else \"i686-pc-mingw32\"\n+  snap_triple = triple if triple != \"x86_64-w64-mingw32\" else \"i686-w64-mingw32\"\n   snap = determine_curr_snapshot(snap_triple)\n   dl = os.path.join(download_dir_base, snap)\n   url = download_url_base + \"/\" + snap"}, {"sha": "b63758cdcc5e7c8b2c86959a23e62f9d5db2354c", "filename": "src/libgreen/context.rs", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/720746a139278adaaac40ed264afeac70d2e9c95/src%2Flibgreen%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/720746a139278adaaac40ed264afeac70d2e9c95/src%2Flibgreen%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcontext.rs?ref=720746a139278adaaac40ed264afeac70d2e9c95", "patch": "@@ -13,6 +13,8 @@ use std::uint;\n use std::mem::transmute;\n use std::rt::stack;\n use std::raw;\n+#[cfg(target_arch = \"x86_64\")]\n+use std::simd;\n \n // FIXME #7761: Registers is boxed so that it is 16-byte aligned, for storing\n // SSE regs.  It would be marginally better not to do this. In C++ we\n@@ -103,11 +105,11 @@ impl Context {\n             // invalid for the current task. Lucky for us `rust_swap_registers`\n             // is a C function so we don't have to worry about that!\n             match in_context.stack_bounds {\n-                Some((lo, hi)) => stack::record_stack_bounds(lo, hi),\n+                Some((lo, hi)) => stack::record_rust_managed_stack_bounds(lo, hi),\n                 // If we're going back to one of the original contexts or\n                 // something that's possibly not a \"normal task\", then reset\n                 // the stack limit to 0 to make morestack never fail\n-                None => stack::record_stack_bounds(0, uint::MAX),\n+                None => stack::record_rust_managed_stack_bounds(0, uint::MAX),\n             }\n             rust_swap_registers(out_regs, in_regs)\n         }\n@@ -186,14 +188,30 @@ fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n // windows requires saving more registers (both general and XMM), so the windows\n // register context must be larger.\n #[cfg(windows, target_arch = \"x86_64\")]\n-type Registers = [uint, ..34];\n+struct Registers {\n+    gpr:[uint, ..14],\n+    _xmm:[simd::u32x4, ..10]\n+}\n #[cfg(not(windows), target_arch = \"x86_64\")]\n-type Registers = [uint, ..22];\n+struct Registers {\n+    gpr:[uint, ..10],\n+    _xmm:[simd::u32x4, ..6]\n+}\n \n #[cfg(windows, target_arch = \"x86_64\")]\n-fn new_regs() -> Box<Registers> { box() ([0, .. 34]) }\n+fn new_regs() -> Box<Registers> {\n+    box() Registers {\n+        gpr:[0,..14],\n+        _xmm:[simd::u32x4(0,0,0,0),..10]\n+    }\n+}\n #[cfg(not(windows), target_arch = \"x86_64\")]\n-fn new_regs() -> Box<Registers> { box() ([0, .. 22]) }\n+fn new_regs() -> Box<Registers> {\n+    box() Registers {\n+        gpr:[0,..10],\n+        _xmm:[simd::u32x4(0,0,0,0),..6]\n+    }\n+}\n \n #[cfg(target_arch = \"x86_64\")]\n fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n@@ -222,20 +240,20 @@ fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n \n     // These registers are frobbed by rust_bootstrap_green_task into the right\n     // location so we can invoke the \"real init function\", `fptr`.\n-    regs[RUSTRT_R12] = arg as uint;\n-    regs[RUSTRT_R13] = procedure.code as uint;\n-    regs[RUSTRT_R14] = procedure.env as uint;\n-    regs[RUSTRT_R15] = fptr as uint;\n+    regs.gpr[RUSTRT_R12] = arg as uint;\n+    regs.gpr[RUSTRT_R13] = procedure.code as uint;\n+    regs.gpr[RUSTRT_R14] = procedure.env as uint;\n+    regs.gpr[RUSTRT_R15] = fptr as uint;\n \n     // These registers are picked up by the regular context switch paths. These\n     // will put us in \"mostly the right context\" except for frobbing all the\n     // arguments to the right place. We have the small trampoline code inside of\n     // rust_bootstrap_green_task to do that.\n-    regs[RUSTRT_RSP] = sp as uint;\n-    regs[RUSTRT_IP] = rust_bootstrap_green_task as uint;\n+    regs.gpr[RUSTRT_RSP] = sp as uint;\n+    regs.gpr[RUSTRT_IP] = rust_bootstrap_green_task as uint;\n \n     // Last base pointer on the stack should be 0\n-    regs[RUSTRT_RBP] = 0;\n+    regs.gpr[RUSTRT_RBP] = 0;\n }\n \n #[cfg(target_arch = \"arm\")]"}, {"sha": "c7b89b6cb915375d9825842560e773e7e7c2bd59", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/720746a139278adaaac40ed264afeac70d2e9c95/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/720746a139278adaaac40ed264afeac70d2e9c95/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=720746a139278adaaac40ed264afeac70d2e9c95", "patch": "@@ -137,7 +137,7 @@ pub fn start(argc: int, argv: *const *const u8, main: proc()) -> int {\n     task.name = Some(str::Slice(\"<main>\"));\n     drop(task.run(|| {\n         unsafe {\n-            rt::stack::record_stack_bounds(my_stack_bottom, my_stack_top);\n+            rt::stack::record_os_managed_stack_bounds(my_stack_bottom, my_stack_top);\n         }\n         exit_code = Some(run(main.take_unwrap()));\n     }).destroy());"}, {"sha": "55806caaf1352781ef43c2e989f0d99a77b9ee61", "filename": "src/libnative/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/720746a139278adaaac40ed264afeac70d2e9c95/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/720746a139278adaaac40ed264afeac70d2e9c95/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=720746a139278adaaac40ed264afeac70d2e9c95", "patch": "@@ -84,7 +84,7 @@ pub fn spawn_opts(opts: TaskOpts, f: proc():Send) {\n         let addr = &something_around_the_top_of_the_stack as *const int;\n         let my_stack = addr as uint;\n         unsafe {\n-            stack::record_stack_bounds(my_stack - stack + 1024, my_stack);\n+            stack::record_os_managed_stack_bounds(my_stack - stack + 1024, my_stack);\n         }\n         let mut ops = ops;\n         ops.stack_bounds = (my_stack - stack + 1024, my_stack);"}, {"sha": "db6308c10dcf2b547cd76472d259047a27531ce6", "filename": "src/librustrt/libunwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/720746a139278adaaac40ed264afeac70d2e9c95/src%2Flibrustrt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/720746a139278adaaac40ed264afeac70d2e9c95/src%2Flibrustrt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flibunwind.rs?ref=720746a139278adaaac40ed264afeac70d2e9c95", "patch": "@@ -60,7 +60,7 @@ pub type _Unwind_Word = libc::uintptr_t;\n pub static unwinder_private_data_size: uint = 5;\n \n #[cfg(target_arch = \"x86_64\")]\n-pub static unwinder_private_data_size: uint = 2;\n+pub static unwinder_private_data_size: uint = 6;\n \n #[cfg(target_arch = \"arm\", not(target_os = \"ios\"))]\n pub static unwinder_private_data_size: uint = 20;"}, {"sha": "c941107d7e81ae66cf23689078d9b5f37ba6bc81", "filename": "src/librustrt/stack.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/720746a139278adaaac40ed264afeac70d2e9c95/src%2Flibrustrt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/720746a139278adaaac40ed264afeac70d2e9c95/src%2Flibrustrt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fstack.rs?ref=720746a139278adaaac40ed264afeac70d2e9c95", "patch": "@@ -124,8 +124,23 @@ extern fn stack_exhausted() {\n     }\n }\n \n+// Windows maintains a record of upper and lower stack bounds in the Thread Information\n+// Block (TIB), and some syscalls do check that addresses which are supposed to be in\n+// the stack, indeed lie between these two values.\n+// (See https://github.com/rust-lang/rust/issues/3445#issuecomment-26114839)\n+//\n+// When using Rust-managed stacks (libgreen), we must maintain these values accordingly.\n+// For OS-managed stacks (libnative), we let the OS manage them for us.\n+//\n+// On all other platforms both variants behave identically.\n+\n #[inline(always)]\n-pub unsafe fn record_stack_bounds(stack_lo: uint, stack_hi: uint) {\n+pub unsafe fn record_os_managed_stack_bounds(stack_lo: uint, _stack_hi: uint) {\n+    record_sp_limit(stack_lo + RED_ZONE);\n+}\n+\n+#[inline(always)]\n+pub unsafe fn record_rust_managed_stack_bounds(stack_lo: uint, stack_hi: uint) {\n     // When the old runtime had segmented stacks, it used a calculation that was\n     // \"limit + RED_ZONE + FUDGE\". The red zone was for things like dynamic\n     // symbol resolution, llvm function calls, etc. In theory this red zone\n@@ -138,16 +153,17 @@ pub unsafe fn record_stack_bounds(stack_lo: uint, stack_hi: uint) {\n \n     return target_record_stack_bounds(stack_lo, stack_hi);\n \n-    #[cfg(not(windows))] #[cfg(not(target_arch = \"x86_64\"))] #[inline(always)]\n+    #[cfg(not(windows))] #[inline(always)]\n     unsafe fn target_record_stack_bounds(_stack_lo: uint, _stack_hi: uint) {}\n+\n+    #[cfg(windows, target_arch = \"x86\")] #[inline(always)]\n+    unsafe fn target_record_stack_bounds(stack_lo: uint, stack_hi: uint) {\n+        // stack range is at TIB: %fs:0x04 (top) and %fs:0x08 (bottom)\n+        asm!(\"mov $0, %fs:0x04\" :: \"r\"(stack_hi) :: \"volatile\");\n+        asm!(\"mov $0, %fs:0x08\" :: \"r\"(stack_lo) :: \"volatile\");\n+    }\n     #[cfg(windows, target_arch = \"x86_64\")] #[inline(always)]\n     unsafe fn target_record_stack_bounds(stack_lo: uint, stack_hi: uint) {\n-        // Windows compiles C functions which may check the stack bounds. This\n-        // means that if we want to perform valid FFI on windows, then we need\n-        // to ensure that the stack bounds are what they truly are for this\n-        // task. More info can be found at:\n-        //   https://github.com/rust-lang/rust/issues/3445#issuecomment-26114839\n-        //\n         // stack range is at TIB: %gs:0x08 (top) and %gs:0x10 (bottom)\n         asm!(\"mov $0, %gs:0x08\" :: \"r\"(stack_hi) :: \"volatile\");\n         asm!(\"mov $0, %gs:0x10\" :: \"r\"(stack_lo) :: \"volatile\");"}, {"sha": "43364466dbe3937913a839b6f5c38ee6c5040f97", "filename": "src/librustrt/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/720746a139278adaaac40ed264afeac70d2e9c95/src%2Flibrustrt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/720746a139278adaaac40ed264afeac70d2e9c95/src%2Flibrustrt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread.rs?ref=720746a139278adaaac40ed264afeac70d2e9c95", "patch": "@@ -44,7 +44,7 @@ static DEFAULT_STACK_SIZE: uint = 1024 * 1024;\n #[no_split_stack]\n extern fn thread_start(main: *mut libc::c_void) -> imp::rust_thread_return {\n     unsafe {\n-        stack::record_stack_bounds(0, uint::MAX);\n+        stack::record_os_managed_stack_bounds(0, uint::MAX);\n         let f: Box<proc()> = mem::transmute(main);\n         (*f)();\n         mem::transmute(0 as imp::rust_thread_return)"}, {"sha": "117f680011e5bac64ace4dbeb5391e89eb4d9d5f", "filename": "src/librustrt/unwind.rs", "status": "modified", "additions": 130, "deletions": 28, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/720746a139278adaaac40ed264afeac70d2e9c95/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/720746a139278adaaac40ed264afeac70d2e9c95/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=720746a139278adaaac40ed264afeac70d2e9c95", "patch": "@@ -220,14 +220,21 @@ fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n //\n // This is pretty close to Rust's exception handling approach, except that Rust\n // does have a single \"catch-all\" handler at the bottom of each task's stack.\n-// So we have two versions:\n+// So we have two versions of the personality routine:\n // - rust_eh_personality, used by all cleanup landing pads, which never catches,\n //   so the behavior of __gcc_personality_v0 is perfectly adequate there, and\n // - rust_eh_personality_catch, used only by rust_try(), which always catches.\n-//   This is achieved by overriding the return value in search phase to always\n-//   say \"catch!\".\n+//\n+// Note, however, that for implementation simplicity, rust_eh_personality_catch\n+// lacks code to install a landing pad, so in order to obtain exception object\n+// pointer (which it needs to return upstream), rust_try() employs another trick:\n+// it calls into the nested rust_try_inner(), whose landing pad does not resume\n+// unwinds.  Instead, it extracts the exception pointer and performs a \"normal\"\n+// return.\n+//\n+// See also: rt/rust_try.ll\n \n-#[cfg(not(target_arch = \"arm\"), not(test))]\n+#[cfg(not(target_arch = \"arm\"), not(windows, target_arch = \"x86_64\"), not(test))]\n #[doc(hidden)]\n #[allow(visible_private_types)]\n pub mod eabi {\n@@ -244,7 +251,8 @@ pub mod eabi {\n     }\n \n     #[lang=\"eh_personality\"]\n-    extern fn eh_personality(\n+    #[no_mangle] // referenced from rust_try.ll\n+    extern fn rust_eh_personality(\n         version: c_int,\n         actions: uw::_Unwind_Action,\n         exception_class: uw::_Unwind_Exception_Class,\n@@ -260,21 +268,19 @@ pub mod eabi {\n \n     #[no_mangle] // referenced from rust_try.ll\n     pub extern \"C\" fn rust_eh_personality_catch(\n-        version: c_int,\n+        _version: c_int,\n         actions: uw::_Unwind_Action,\n-        exception_class: uw::_Unwind_Exception_Class,\n-        ue_header: *mut uw::_Unwind_Exception,\n-        context: *mut uw::_Unwind_Context\n+        _exception_class: uw::_Unwind_Exception_Class,\n+        _ue_header: *mut uw::_Unwind_Exception,\n+        _context: *mut uw::_Unwind_Context\n     ) -> uw::_Unwind_Reason_Code\n     {\n+\n         if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n             uw::_URC_HANDLER_FOUND // catch!\n         }\n         else { // cleanup phase\n-            unsafe {\n-                __gcc_personality_v0(version, actions, exception_class, ue_header,\n-                                     context)\n-            }\n+            uw::_URC_INSTALL_CONTEXT\n         }\n     }\n }\n@@ -299,7 +305,7 @@ pub mod eabi {\n     }\n \n     #[lang=\"eh_personality\"]\n-    #[no_mangle] // so we can reference it by name from middle/trans/base.rs\n+    #[no_mangle] // referenced from rust_try.ll\n     pub extern \"C\" fn rust_eh_personality(\n         version: c_int,\n         actions: uw::_Unwind_Action,\n@@ -316,29 +322,27 @@ pub mod eabi {\n \n     #[no_mangle] // referenced from rust_try.ll\n     pub extern \"C\" fn rust_eh_personality_catch(\n-        version: c_int,\n+        _version: c_int,\n         actions: uw::_Unwind_Action,\n-        exception_class: uw::_Unwind_Exception_Class,\n-        ue_header: *mut uw::_Unwind_Exception,\n-        context: *mut uw::_Unwind_Context\n+        _exception_class: uw::_Unwind_Exception_Class,\n+        _ue_header: *mut uw::_Unwind_Exception,\n+        _context: *mut uw::_Unwind_Context\n     ) -> uw::_Unwind_Reason_Code\n     {\n         if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n             uw::_URC_HANDLER_FOUND // catch!\n         }\n         else { // cleanup phase\n-            unsafe {\n-                __gcc_personality_sj0(version, actions, exception_class, ue_header,\n-                                      context)\n-            }\n+            uw::_URC_INSTALL_CONTEXT\n         }\n     }\n }\n \n \n // ARM EHABI uses a slightly different personality routine signature,\n // but otherwise works the same.\n-#[cfg(target_arch = \"arm\", not(test), not(target_os = \"ios\"))]\n+#[cfg(target_arch = \"arm\", not(target_os = \"ios\"), not(test))]\n+#[doc(hidden)]\n #[allow(visible_private_types)]\n pub mod eabi {\n     use uw = libunwind;\n@@ -352,7 +356,8 @@ pub mod eabi {\n     }\n \n     #[lang=\"eh_personality\"]\n-    extern \"C\" fn eh_personality(\n+    #[no_mangle] // referenced from rust_try.ll\n+    extern \"C\" fn rust_eh_personality(\n         state: uw::_Unwind_State,\n         ue_header: *mut uw::_Unwind_Exception,\n         context: *mut uw::_Unwind_Context\n@@ -366,19 +371,116 @@ pub mod eabi {\n     #[no_mangle] // referenced from rust_try.ll\n     pub extern \"C\" fn rust_eh_personality_catch(\n         state: uw::_Unwind_State,\n-        ue_header: *mut uw::_Unwind_Exception,\n-        context: *mut uw::_Unwind_Context\n+        _ue_header: *mut uw::_Unwind_Exception,\n+        _context: *mut uw::_Unwind_Context\n     ) -> uw::_Unwind_Reason_Code\n     {\n         if (state as c_int & uw::_US_ACTION_MASK as c_int)\n                            == uw::_US_VIRTUAL_UNWIND_FRAME as c_int { // search phase\n             uw::_URC_HANDLER_FOUND // catch!\n         }\n         else { // cleanup phase\n-            unsafe {\n-                __gcc_personality_v0(state, ue_header, context)\n+            uw::_URC_INSTALL_CONTEXT\n+        }\n+    }\n+}\n+\n+// Win64 SEH (see http://msdn.microsoft.com/en-us/library/1eyas8tf.aspx)\n+//\n+// This looks a bit convoluted because rather than implementing a native SEH handler,\n+// GCC reuses the same personality routine as for the other architectures by wrapping it\n+// with an \"API translator\" layer (_GCC_specific_handler).\n+\n+#[cfg(windows, target_arch = \"x86_64\", not(test))]\n+#[doc(hidden)]\n+#[allow(visible_private_types)]\n+#[allow(non_camel_case_types)]\n+pub mod eabi {\n+    use uw = libunwind;\n+    use libc::{c_void, c_int};\n+\n+    struct EXCEPTION_RECORD;\n+    struct CONTEXT;\n+    struct DISPATCHER_CONTEXT;\n+\n+    #[repr(C)]\n+    enum EXCEPTION_DISPOSITION {\n+        ExceptionContinueExecution,\n+        ExceptionContinueSearch,\n+        ExceptionNestedException,\n+        ExceptionCollidedUnwind\n+    }\n+\n+    type _Unwind_Personality_Fn =\n+        extern \"C\" fn(\n+            version: c_int,\n+            actions: uw::_Unwind_Action,\n+            exception_class: uw::_Unwind_Exception_Class,\n+            ue_header: *mut uw::_Unwind_Exception,\n+            context: *mut uw::_Unwind_Context\n+        ) -> uw::_Unwind_Reason_Code;\n+\n+    extern \"C\" {\n+        fn __gcc_personality_seh0(\n+            exceptionRecord: *mut EXCEPTION_RECORD,\n+            establisherFrame: *mut c_void,\n+            contextRecord: *mut CONTEXT,\n+            dispatcherContext: *mut DISPATCHER_CONTEXT\n+        ) -> EXCEPTION_DISPOSITION;\n+\n+        fn _GCC_specific_handler(\n+            exceptionRecord: *mut EXCEPTION_RECORD,\n+            establisherFrame: *mut c_void,\n+            contextRecord: *mut CONTEXT,\n+            dispatcherContext: *mut DISPATCHER_CONTEXT,\n+            personality: _Unwind_Personality_Fn\n+        ) -> EXCEPTION_DISPOSITION;\n+    }\n+\n+    #[lang=\"eh_personality\"]\n+    #[no_mangle] // referenced from rust_try.ll\n+    extern \"C\" fn rust_eh_personality(\n+        exceptionRecord: *mut EXCEPTION_RECORD,\n+        establisherFrame: *mut c_void,\n+        contextRecord: *mut CONTEXT,\n+        dispatcherContext: *mut DISPATCHER_CONTEXT\n+    ) -> EXCEPTION_DISPOSITION\n+    {\n+        unsafe {\n+            __gcc_personality_seh0(exceptionRecord, establisherFrame,\n+                                   contextRecord, dispatcherContext)\n+        }\n+    }\n+\n+    #[no_mangle] // referenced from rust_try.ll\n+    pub extern \"C\" fn rust_eh_personality_catch(\n+        exceptionRecord: *mut EXCEPTION_RECORD,\n+        establisherFrame: *mut c_void,\n+        contextRecord: *mut CONTEXT,\n+        dispatcherContext: *mut DISPATCHER_CONTEXT\n+    ) -> EXCEPTION_DISPOSITION\n+    {\n+        extern \"C\" fn inner(\n+                _version: c_int,\n+                actions: uw::_Unwind_Action,\n+                _exception_class: uw::_Unwind_Exception_Class,\n+                _ue_header: *mut uw::_Unwind_Exception,\n+                _context: *mut uw::_Unwind_Context\n+            ) -> uw::_Unwind_Reason_Code\n+        {\n+            if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n+                uw::_URC_HANDLER_FOUND // catch!\n+            }\n+            else { // cleanup phase\n+                uw::_URC_INSTALL_CONTEXT\n             }\n         }\n+\n+        unsafe {\n+            _GCC_specific_handler(exceptionRecord, establisherFrame,\n+                                  contextRecord, dispatcherContext,\n+                                  inner)\n+        }\n     }\n }\n "}, {"sha": "ffe8e539ffba13b9b07516eb393fce74d3354a0a", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/720746a139278adaaac40ed264afeac70d2e9c95/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/720746a139278adaaac40ed264afeac70d2e9c95/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=720746a139278adaaac40ed264afeac70d2e9c95", "patch": "@@ -136,10 +136,11 @@ mod imp {\n     use rand::Rng;\n     use result::{Ok, Err};\n     use rt::stack;\n-    use self::libc::{c_ulong, DWORD, BYTE, LPCSTR, BOOL};\n+    use self::libc::{DWORD, BYTE, LPCSTR, BOOL};\n+    use self::libc::types::os::arch::extra::{LONG_PTR};\n     use slice::MutableVector;\n \n-    type HCRYPTPROV = c_ulong;\n+    type HCRYPTPROV = LONG_PTR;\n \n     /// A random number generator that retrieves randomness straight from\n     /// the operating system. Platform sources:"}, {"sha": "90a314162053a0c51a50a1c603c9203bef241e0d", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=720746a139278adaaac40ed264afeac70d2e9c95", "patch": "@@ -1 +1 @@\n-Subproject commit 0d999e5b315b6ff78fcea772466d985ce53fd8dc\n+Subproject commit 90a314162053a0c51a50a1c603c9203bef241e0d"}, {"sha": "33d2d31a2e0c1775865b33ae9f90c8ddfa93153e", "filename": "src/rt/rust_try.ll", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/720746a139278adaaac40ed264afeac70d2e9c95/src%2Frt%2Frust_try.ll", "raw_url": "https://github.com/rust-lang/rust/raw/720746a139278adaaac40ed264afeac70d2e9c95/src%2Frt%2Frust_try.ll", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_try.ll?ref=720746a139278adaaac40ed264afeac70d2e9c95", "patch": "@@ -11,24 +11,41 @@\n ; Rust's try-catch\n ; When f(...) returns normally, the return value is null.\n ; When f(...) throws, the return value is a pointer to the caught exception object.\n-; See also: libstd/rt/unwind.rs\n+\n+; See also: librustrt/unwind.rs\n \n define i8* @rust_try(void (i8*,i8*)* %f, i8* %fptr, i8* %env) {\n \n-\tinvoke void %f(i8* %fptr, i8* %env)\n-\t\tto label %normal\n-\t\tunwind label %catch\n+    %1 = invoke i8* @rust_try_inner(void (i8*,i8*)* %f, i8* %fptr, i8* %env)\n+        to label %normal\n+        unwind label %catch\n \n normal:\n-\tret i8* null\n+    ret i8* %1\n \n catch:\n-\t%1 = landingpad { i8*, i32 } personality i8* bitcast (i32 (...)* @rust_eh_personality_catch to i8*)\n-\t\t\tcatch i8* null ; catch everything\n+    landingpad { i8*, i32 } personality i8* bitcast (i32 (...)* @rust_eh_personality_catch to i8*)\n+        catch i8* null\n+    ; rust_try_inner's landing pad does not resume unwinds, so execution will never reach here\n+    ret i8* null\n+}\n+\n+define internal i8* @rust_try_inner(void (i8*,i8*)* %f, i8* %fptr, i8* %env) {\n+\n+    invoke void %f(i8* %fptr, i8* %env)\n+        to label %normal\n+        unwind label %catch\n \n-\t; extract and return pointer to the exception object\n+normal:\n+    ret i8* null\n+\n+catch:\n+    %1 = landingpad { i8*, i32 } personality i8* bitcast (i32 (...)* @rust_eh_personality to i8*)\n+        catch i8* null\n+    ; extract and return pointer to the exception object\n     %2 = extractvalue { i8*, i32 } %1, 0\n-\tret i8* %2\n+    ret i8* %2\n }\n \n+declare i32 @rust_eh_personality(...)\n declare i32 @rust_eh_personality_catch(...)"}, {"sha": "af01dfd71a71c71907b7391a7a55975e6daaa91a", "filename": "src/rt/valgrind/valgrind.h", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/720746a139278adaaac40ed264afeac70d2e9c95/src%2Frt%2Fvalgrind%2Fvalgrind.h", "raw_url": "https://github.com/rust-lang/rust/raw/720746a139278adaaac40ed264afeac70d2e9c95/src%2Frt%2Fvalgrind%2Fvalgrind.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fvalgrind%2Fvalgrind.h?ref=720746a139278adaaac40ed264afeac70d2e9c95", "patch": "@@ -21,16 +21,16 @@\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n \n-   2. The origin of this software must not be misrepresented; you must \n-      not claim that you wrote the original software.  If you use this \n-      software in a product, an acknowledgment in the product \n+   2. The origin of this software must not be misrepresented; you must\n+      not claim that you wrote the original software.  If you use this\n+      software in a product, an acknowledgment in the product\n       documentation would be appreciated but is not required.\n \n    3. Altered source versions must be plainly marked as such, and must\n       not be misrepresented as being the original software.\n \n-   4. The name of the author may not be used to endorse or promote \n-      products derived from this software without specific prior written \n+   4. The name of the author may not be used to endorse or promote\n+      products derived from this software without specific prior written\n       permission.\n \n    THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS\n@@ -52,13 +52,13 @@\n    the terms of the GNU General Public License, version 2.  See the\n    COPYING file in the source distribution for details.\n \n-   ---------------------------------------------------------------- \n+   ----------------------------------------------------------------\n */\n \n \n /* This file is for inclusion into client (your!) code.\n \n-   You can use these macros to manipulate and query Valgrind's \n+   You can use these macros to manipulate and query Valgrind's\n    execution inside your own programs.\n \n    The resulting executables will still run without Valgrind, just a\n@@ -126,11 +126,11 @@\n #  define PLAT_x86_darwin 1\n #elif defined(__APPLE__) && defined(__x86_64__)\n #  define PLAT_amd64_darwin 1\n+#elif defined(__MINGW64__) || (defined(_WIN64) && defined(_M_X64))\n+#  define PLAT_amd64_win64 1\n #elif defined(__MINGW32__) || defined(__CYGWIN32__) \\\n       || (defined(_WIN32) && defined(_M_IX86))\n #  define PLAT_x86_win32 1\n-#elif defined(__MINGW64__) || (defined(_WIN64) && defined(_M_X64))\n-#  define PLAT_amd64_win64 1\n #elif defined(__linux__) && defined(__i386__)\n #  define PLAT_x86_linux 1\n #elif defined(__linux__) && defined(__x86_64__)\n@@ -214,8 +214,8 @@\n    this is executed not under Valgrind.  Args are passed in a memory\n    block, and so there's no intrinsic limit to the number that could\n    be passed, but it's currently five.\n-   \n-   The macro args are: \n+\n+   The macro args are:\n       _zzq_rlval    result lvalue\n       _zzq_default  default value (result returned when running on real CPU)\n       _zzq_request  request code\n@@ -242,7 +242,7 @@\n     ||  (defined(PLAT_x86_win32) && defined(__GNUC__))\n \n typedef\n-   struct { \n+   struct {\n       unsigned int nraddr; /* where's the code? */\n    }\n    OrigFn;\n@@ -306,7 +306,7 @@ typedef\n #if defined(PLAT_x86_win32) && !defined(__GNUC__)\n \n typedef\n-   struct { \n+   struct {\n       unsigned int nraddr; /* where's the code? */\n    }\n    OrigFn;\n@@ -374,12 +374,13 @@ valgrind_do_client_request_expr(uintptr_t _zzq_default, uintptr_t _zzq_request,\n \n #endif /* PLAT_x86_win32 */\n \n-/* ------------------------ amd64-{linux,darwin} --------------- */\n+/* -------------------- amd64-{linux,darwin,win64} ------------- */\n \n-#if defined(PLAT_amd64_linux)  ||  defined(PLAT_amd64_darwin)\n+#if defined(PLAT_amd64_linux)  ||  defined(PLAT_amd64_darwin) \\\n+    || defined(PLAT_amd64_win64)\n \n typedef\n-   struct { \n+   struct {\n       unsigned long long int nraddr; /* where's the code? */\n    }\n    OrigFn;\n@@ -443,7 +444,7 @@ typedef\n #if defined(PLAT_ppc32_linux)\n \n typedef\n-   struct { \n+   struct {\n       unsigned int nraddr; /* where's the code? */\n    }\n    OrigFn;\n@@ -512,7 +513,7 @@ typedef\n #if defined(PLAT_ppc64_linux)\n \n typedef\n-   struct { \n+   struct {\n       unsigned long long int nraddr; /* where's the code? */\n       unsigned long long int r2;  /* what tocptr do we need? */\n    }\n@@ -591,7 +592,7 @@ typedef\n #if defined(PLAT_arm_linux)\n \n typedef\n-   struct { \n+   struct {\n       unsigned int nraddr; /* where's the code? */\n    }\n    OrigFn;\n@@ -736,7 +737,7 @@ typedef\n #if defined(PLAT_mips32_linux)\n \n typedef\n-   struct { \n+   struct {\n       unsigned int nraddr; /* where's the code? */\n    }\n    OrigFn;\n@@ -750,7 +751,7 @@ typedef\n                      \"srl $0, $0, 29\\n\\t\"       \\\n                      \"srl $0, $0, 3\\n\\t\"        \\\n                      \"srl $0, $0, 19\\n\\t\"\n-                    \n+\n #define VALGRIND_DO_CLIENT_REQUEST_EXPR(                          \\\n        _zzq_default, _zzq_request,                                \\\n        _zzq_arg1, _zzq_arg2, _zzq_arg3, _zzq_arg4, _zzq_arg5)     \\\n@@ -1999,7 +2000,7 @@ typedef\n #define VALGRIND_RESTORE_STACK             \\\n       \"mr 1,28\\n\\t\"\n \n-/* These CALL_FN_ macros assume that on ppc32-linux, \n+/* These CALL_FN_ macros assume that on ppc32-linux,\n    sizeof(unsigned long) == 4. */\n \n #define CALL_FN_W_v(lval, orig)                                   \\\n@@ -3509,7 +3510,7 @@ typedef\n #define __CALLER_SAVED_REGS \"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"14\", \\\n                            \"f0\",\"f1\",\"f2\",\"f3\",\"f4\",\"f5\",\"f6\",\"f7\"\n \n-/* Nb: Although r11 is modified in the asm snippets below (inside \n+/* Nb: Although r11 is modified in the asm snippets below (inside\n    VALGRIND_CFI_PROLOGUE) it is not listed in the clobber section, for\n    two reasons:\n    (1) r11 is restored in VALGRIND_CFI_EPILOGUE, so effectively it is not\n@@ -3959,7 +3960,7 @@ typedef\n #endif /* PLAT_s390x_linux */\n \n /* ------------------------- mips32-linux ----------------------- */\n- \n+\n #if defined(PLAT_mips32_linux)\n \n /* These regs are trashed by the hidden call. */\n@@ -4935,7 +4936,7 @@ typedef\n #define VG_IS_TOOL_USERREQ(a, b, v) \\\n    (VG_USERREQ_TOOL_BASE(a,b) == ((v) & 0xffff0000))\n \n-/* !! ABIWARNING !! ABIWARNING !! ABIWARNING !! ABIWARNING !! \n+/* !! ABIWARNING !! ABIWARNING !! ABIWARNING !! ABIWARNING !!\n    This enum comprises an ABI exported by Valgrind to programs\n    which use client requests.  DO NOT CHANGE THE ORDER OF THESE\n    ENTRIES, NOR DELETE ANY -- add new ones at the end. */\n@@ -5073,7 +5074,7 @@ VALGRIND_PRINTF(const char *format, ...)\n    _qzz_res = VALGRIND_DO_CLIENT_REQUEST_EXPR(0,\n                               VG_USERREQ__PRINTF_VALIST_BY_REF,\n                               (unsigned long)format,\n-                              (unsigned long)&vargs, \n+                              (unsigned long)&vargs,\n                               0, 0, 0);\n #endif\n    va_end(vargs);\n@@ -5111,7 +5112,7 @@ VALGRIND_PRINTF_BACKTRACE(const char *format, ...)\n    _qzz_res = VALGRIND_DO_CLIENT_REQUEST_EXPR(0,\n                               VG_USERREQ__PRINTF_BACKTRACE_VALIST_BY_REF,\n                               (unsigned long)format,\n-                              (unsigned long)&vargs, \n+                              (unsigned long)&vargs,\n                               0, 0, 0);\n #endif\n    va_end(vargs);\n@@ -5122,7 +5123,7 @@ VALGRIND_PRINTF_BACKTRACE(const char *format, ...)\n \n /* These requests allow control to move from the simulated CPU to the\n    real CPU, calling an arbitary function.\n-   \n+\n    Note that the current ThreadId is inserted as the first argument.\n    So this call:\n \n@@ -5208,15 +5209,15 @@ VALGRIND_PRINTF_BACKTRACE(const char *format, ...)\n    - It marks the block as being addressable and undefined (if 'is_zeroed' is\n      not set), or addressable and defined (if 'is_zeroed' is set).  This\n      controls how accesses to the block by the program are handled.\n-   \n+\n    'addr' is the start of the usable block (ie. after any\n    redzone), 'sizeB' is its size.  'rzB' is the redzone size if the allocator\n    can apply redzones -- these are blocks of padding at the start and end of\n    each block.  Adding redzones is recommended as it makes it much more likely\n    Valgrind will spot block overruns.  `is_zeroed' indicates if the memory is\n    zeroed (or filled with another predictable value), as is the case for\n    calloc().\n-   \n+\n    VALGRIND_MALLOCLIKE_BLOCK should be put immediately after the point where a\n    heap block -- that will be used by the client program -- is allocated.\n    It's best to put it at the outermost level of the allocator if possible;"}, {"sha": "8051235da20aa8000b02a499db4efac949505662", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/720746a139278adaaac40ed264afeac70d2e9c95/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/720746a139278adaaac40ed264afeac70d2e9c95/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=720746a139278adaaac40ed264afeac70d2e9c95", "patch": "@@ -282,7 +282,7 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateSubroutineType(\n     LLVMValueRef ParameterTypes) {\n     return wrap(Builder->createSubroutineType(\n         unwrapDI<DIFile>(File),\n-        unwrapDI<DIArray>(ParameterTypes)));\n+        unwrapDI<DITypeArray>(ParameterTypes)));\n }\n \n extern \"C\" LLVMValueRef LLVMDIBuilderCreateFunction(\n@@ -634,7 +634,7 @@ extern \"C\" void LLVMDICompositeTypeSetTypeArray(\n     LLVMValueRef CompositeType,\n     LLVMValueRef TypeArray)\n {\n-    unwrapDI<DICompositeType>(CompositeType).setTypeArray(unwrapDI<DIArray>(TypeArray));\n+    unwrapDI<DICompositeType>(CompositeType).setArrays(unwrapDI<DIArray>(TypeArray));\n }\n \n extern \"C\" char *LLVMTypeToString(LLVMTypeRef Type) {"}, {"sha": "dd1c444119bde49b720f558ebfa90d5d889f377d", "filename": "src/rustllvm/llvm-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/720746a139278adaaac40ed264afeac70d2e9c95/src%2Frustllvm%2Fllvm-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/720746a139278adaaac40ed264afeac70d2e9c95/src%2Frustllvm%2Fllvm-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-auto-clean-trigger?ref=720746a139278adaaac40ed264afeac70d2e9c95", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be forcibly cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2014-07-29\n+2014-08-05"}, {"sha": "edf5068184aea3d62b280c447397bc6fa11615f2", "filename": "src/test/run-pass/intrinsic-alignment.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/720746a139278adaaac40ed264afeac70d2e9c95/src%2Ftest%2Frun-pass%2Fintrinsic-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/720746a139278adaaac40ed264afeac70d2e9c95/src%2Ftest%2Frun-pass%2Fintrinsic-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-alignment.rs?ref=720746a139278adaaac40ed264afeac70d2e9c95", "patch": "@@ -52,6 +52,15 @@ mod m {\n             assert_eq!(::rusti::min_align_of::<u64>(), 8u);\n         }\n     }\n+\n+    #[main]\n+    #[cfg(target_arch = \"x86_64\")]\n+    pub fn main() {\n+        unsafe {\n+            assert_eq!(::rusti::pref_align_of::<u64>(), 8u);\n+            assert_eq!(::rusti::min_align_of::<u64>(), 8u);\n+        }\n+    }\n }\n \n #[cfg(target_os = \"android\")]"}, {"sha": "5c484dec445b1dd30b99973ed60168ccbfaee7c5", "filename": "src/test/run-pass/rec-align-u64.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/720746a139278adaaac40ed264afeac70d2e9c95/src%2Ftest%2Frun-pass%2Frec-align-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/720746a139278adaaac40ed264afeac70d2e9c95/src%2Ftest%2Frun-pass%2Frec-align-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-align-u64.rs?ref=720746a139278adaaac40ed264afeac70d2e9c95", "patch": "@@ -62,6 +62,12 @@ mod m {\n         pub fn align() -> uint { 8u }\n         pub fn size() -> uint { 16u }\n     }\n+\n+    #[cfg(target_arch = \"x86_64\")]\n+    pub mod m {\n+        pub fn align() -> uint { 8u }\n+        pub fn size() -> uint { 16u }\n+    }\n }\n \n #[cfg(target_os = \"android\")]"}]}