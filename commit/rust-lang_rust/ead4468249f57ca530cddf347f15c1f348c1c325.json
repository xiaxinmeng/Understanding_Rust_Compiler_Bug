{"sha": "ead4468249f57ca530cddf347f15c1f348c1c325", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhZDQ0NjgyNDlmNTdjYTUzMGNkZGYzNDdmMTVjMWYzNDhjMWMzMjU=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-10T13:01:45Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-10T13:02:55Z"}, "message": "std: fix tests", "tree": {"sha": "956157b8ac50a2c607c6d0a09489c1e584dfe334", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/956157b8ac50a2c607c6d0a09489c1e584dfe334"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ead4468249f57ca530cddf347f15c1f348c1c325", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ead4468249f57ca530cddf347f15c1f348c1c325", "html_url": "https://github.com/rust-lang/rust/commit/ead4468249f57ca530cddf347f15c1f348c1c325", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ead4468249f57ca530cddf347f15c1f348c1c325/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec5a028adac360537c8f37a669eda522bd8c9b6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec5a028adac360537c8f37a669eda522bd8c9b6b", "html_url": "https://github.com/rust-lang/rust/commit/ec5a028adac360537c8f37a669eda522bd8c9b6b"}], "stats": {"total": 26, "additions": 13, "deletions": 13}, "files": [{"sha": "98ac71bc018ddc549f6c6ae0b2741ae14baeae8f", "filename": "src/libstd/str.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ead4468249f57ca530cddf347f15c1f348c1c325/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ead4468249f57ca530cddf347f15c1f348c1c325/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=ead4468249f57ca530cddf347f15c1f348c1c325", "patch": "@@ -1194,8 +1194,8 @@ pub fn with_capacity(capacity: uint) -> ~str {\n  * The number of Unicode characters in `s` between the given indices.\n  */\n pub fn count_chars(s: &str, start: uint, end: uint) -> uint {\n-    assert!(is_char_boundary(s, start));\n-    assert!(is_char_boundary(s, end));\n+    assert!(s.is_char_boundary(start));\n+    assert!(s.is_char_boundary(end));\n     let mut (i, len) = (start, 0u);\n     while i < end {\n         let next = s.char_range_at(i).next;\n@@ -1208,7 +1208,7 @@ pub fn count_chars(s: &str, start: uint, end: uint) -> uint {\n /// Counts the number of bytes taken by the first `n` chars in `s`\n /// starting from `start`.\n pub fn count_bytes<'b>(s: &'b str, start: uint, n: uint) -> uint {\n-    assert!(is_char_boundary(s, start));\n+    assert!(s.is_char_boundary(start));\n     let mut (end, cnt) = (start, n);\n     let l = s.len();\n     while cnt > 0u {\n@@ -1658,7 +1658,7 @@ pub trait StrSlice<'self> {\n     fn trim_right_chars(&self, chars_to_trim: &[char]) -> &'self str;\n     fn to_owned(&self) -> ~str;\n     fn to_managed(&self) -> @str;\n-    fn is_char_boundary(s: &str, index: uint) -> bool;\n+    fn is_char_boundary(&self, index: uint) -> bool;\n     fn char_range_at(&self, start: uint) -> CharRange;\n     fn char_at(&self, i: uint) -> char;\n     fn char_range_at_reverse(&self, start: uint) -> CharRange;\n@@ -1800,8 +1800,8 @@ impl<'self> StrSlice<'self> for &'self str {\n      */\n     #[inline]\n     fn slice(&self, begin: uint, end: uint) -> &'self str {\n-        assert!(is_char_boundary(*self, begin));\n-        assert!(is_char_boundary(*self, end));\n+        assert!(self.is_char_boundary(begin));\n+        assert!(self.is_char_boundary(end));\n         unsafe { raw::slice_bytes(*self, begin, end) }\n     }\n     #[inline]\n@@ -2284,7 +2284,7 @@ impl<'self> Iterator<char> for StrCharIterator<'self> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n         if self.index < self.string.len() {\n-            let CharRange {ch, next} = char_range_at(self.string, self.index);\n+            let CharRange {ch, next} = self.string.char_range_at(self.index);\n             self.index = next;\n             Some(ch)\n         } else {\n@@ -2303,7 +2303,7 @@ impl<'self> Iterator<char> for StrCharRevIterator<'self> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n         if self.index > 0 {\n-            let CharRange {ch, next} = char_range_at_reverse(self.string, self.index);\n+            let CharRange {ch, next} = self.string.char_range_at_reverse(self.index);\n             self.index = next;\n             Some(ch)\n         } else {\n@@ -2461,7 +2461,7 @@ mod tests {\n \n         let data = \"abcabc\";\n         assert_eq!(data.slice(0u, 6u).find_str(\"ab\"), Some(0u));\n-        assert_eq!(data.slice(2u, 6u).find_str(\"ab\"), Some(3u));\n+        assert_eq!(data.slice(2u, 6u).find_str(\"ab\"), Some(3u - 2u));\n         assert!(data.slice(2u, 4u).find_str(\"ab\").is_none());\n \n         let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n@@ -3042,10 +3042,10 @@ mod tests {\n \n     #[test]\n     fn test_contains_char() {\n-        assert!(contains_char(\"abc\", 'b'));\n-        assert!(contains_char(\"a\", 'a'));\n-        assert!(!contains_char(\"abc\", 'd'));\n-        assert!(!contains_char(\"\", 'a'));\n+        assert!(\"abc\".contains_char('b'));\n+        assert!(\"a\".contains_char('a'));\n+        assert!(!\"abc\".contains_char('d'));\n+        assert!(!\"\".contains_char('a'));\n     }\n \n     #[test]"}]}