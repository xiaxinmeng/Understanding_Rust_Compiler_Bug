{"sha": "e0a9bd0f3cfd20694ff62ac8b74747adcdbbfa99", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwYTliZDBmM2NmZDIwNjk0ZmY2MmFjOGI3NDc0N2FkY2RiYmZhOTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-07T05:33:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-07T05:33:11Z"}, "message": "Auto merge of #49419 - leodasvacas:small-typeck-refactorings, r=nikomatsakis\n\nSmall typeck refactorings\n\nSome code improvements I noticed while reading the code.", "tree": {"sha": "9d2399a2ef39e73a2e395325f40e082cad7eef9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d2399a2ef39e73a2e395325f40e082cad7eef9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0a9bd0f3cfd20694ff62ac8b74747adcdbbfa99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0a9bd0f3cfd20694ff62ac8b74747adcdbbfa99", "html_url": "https://github.com/rust-lang/rust/commit/e0a9bd0f3cfd20694ff62ac8b74747adcdbbfa99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0a9bd0f3cfd20694ff62ac8b74747adcdbbfa99/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee1014e50570e4572980e2496634cbb0eac768dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee1014e50570e4572980e2496634cbb0eac768dd", "html_url": "https://github.com/rust-lang/rust/commit/ee1014e50570e4572980e2496634cbb0eac768dd"}, {"sha": "0a3eb5c508bce50873401ca942e3cb1d4a0ce21f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a3eb5c508bce50873401ca942e3cb1d4a0ce21f", "html_url": "https://github.com/rust-lang/rust/commit/0a3eb5c508bce50873401ca942e3cb1d4a0ce21f"}], "stats": {"total": 149, "additions": 66, "deletions": 83}, "files": [{"sha": "6c18f8d285d0297d8be2c8c73ea6c4c8ab49dc8b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 63, "deletions": 80, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/e0a9bd0f3cfd20694ff62ac8b74747adcdbbfa99/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0a9bd0f3cfd20694ff62ac8b74747adcdbbfa99/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e0a9bd0f3cfd20694ff62ac8b74747adcdbbfa99", "patch": "@@ -2507,7 +2507,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             sp: Span,\n                             expr_sp: Span,\n                             fn_inputs: &[Ty<'tcx>],\n-                            expected_arg_tys: &[Ty<'tcx>],\n+                            mut expected_arg_tys: &[Ty<'tcx>],\n                             args: &'gcx [hir::Expr],\n                             variadic: bool,\n                             tuple_arguments: TupleArgumentsFlag,\n@@ -2528,19 +2528,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.register_wf_obligation(fn_input_ty, sp, traits::MiscObligation);\n         }\n \n-        let mut expected_arg_tys = expected_arg_tys;\n         let expected_arg_count = fn_inputs.len();\n \n-        fn parameter_count_error<'tcx>(sess: &Session,\n-                                       sp: Span,\n-                                       expr_sp: Span,\n-                                       expected_count: usize,\n-                                       arg_count: usize,\n-                                       error_code: &str,\n-                                       variadic: bool,\n-                                       def_span: Option<Span>,\n-                                       sugg_unit: bool) {\n-            let mut err = sess.struct_span_err_with_code(sp,\n+        let param_count_error = |expected_count: usize,\n+                                arg_count: usize,\n+                                error_code: &str,\n+                                variadic: bool,\n+                                sugg_unit: bool| {\n+            let mut err = tcx.sess.struct_span_err_with_code(sp,\n                 &format!(\"this function takes {}{} parameter{} but {} parameter{} supplied\",\n                     if variadic {\"at least \"} else {\"\"},\n                     expected_count,\n@@ -2549,11 +2544,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if arg_count == 1 {\" was\"} else {\"s were\"}),\n                 DiagnosticId::Error(error_code.to_owned()));\n \n-            if let Some(def_s) = def_span.map(|sp| sess.codemap().def_span(sp)) {\n+            if let Some(def_s) = def_span.map(|sp| tcx.sess.codemap().def_span(sp)) {\n                 err.span_label(def_s, \"defined here\");\n             }\n             if sugg_unit {\n-                let sugg_span = sess.codemap().end_point(expr_sp);\n+                let sugg_span = tcx.sess.codemap().end_point(expr_sp);\n                 // remove closing `)` from the span\n                 let sugg_span = sugg_span.shrink_to_lo();\n                 err.span_suggestion(\n@@ -2567,14 +2562,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                             if expected_count == 1 {\"\"} else {\"s\"}));\n             }\n             err.emit();\n-        }\n+        };\n \n         let formal_tys = if tuple_arguments == TupleArguments {\n             let tuple_type = self.structurally_resolved_type(sp, fn_inputs[0]);\n             match tuple_type.sty {\n                 ty::TyTuple(arg_types) if arg_types.len() != args.len() => {\n-                    parameter_count_error(tcx.sess, sp, expr_sp, arg_types.len(), args.len(),\n-                                          \"E0057\", false, def_span, false);\n+                    param_count_error(arg_types.len(), args.len(), \"E0057\", false, false);\n                     expected_arg_tys = &[];\n                     self.err_args(args.len())\n                 }\n@@ -2602,8 +2596,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if supplied_arg_count >= expected_arg_count {\n                 fn_inputs.to_vec()\n             } else {\n-                parameter_count_error(tcx.sess, sp, expr_sp, expected_arg_count,\n-                                      supplied_arg_count, \"E0060\", true, def_span, false);\n+                param_count_error(expected_arg_count, supplied_arg_count, \"E0060\", true, false);\n                 expected_arg_tys = &[];\n                 self.err_args(supplied_arg_count)\n             }\n@@ -2616,11 +2609,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             } else {\n                 false\n             };\n-            parameter_count_error(tcx.sess, sp, expr_sp, expected_arg_count,\n-                                  supplied_arg_count, \"E0061\", false, def_span, sugg_unit);\n+            param_count_error(expected_arg_count, supplied_arg_count, \"E0061\", false, sugg_unit);\n+\n             expected_arg_tys = &[];\n             self.err_args(supplied_arg_count)\n         };\n+        // If there is no expectation, expect formal_tys.\n+        let expected_arg_tys = if !expected_arg_tys.is_empty() {\n+            expected_arg_tys\n+        } else {\n+            &formal_tys\n+        };\n \n         debug!(\"check_argument_types: formal_tys={:?}\",\n                formal_tys.iter().map(|t| self.ty_to_string(*t)).collect::<Vec<String>>());\n@@ -2672,28 +2671,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // The special-cased logic below has three functions:\n                 // 1. Provide as good of an expected type as possible.\n-                let expected = expected_arg_tys.get(i).map(|&ty| {\n-                    Expectation::rvalue_hint(self, ty)\n-                });\n+                let expected = Expectation::rvalue_hint(self, expected_arg_tys[i]);\n \n-                let checked_ty = self.check_expr_with_expectation(\n-                    &arg,\n-                    expected.unwrap_or(ExpectHasType(formal_ty)));\n+                let checked_ty = self.check_expr_with_expectation(&arg, expected);\n \n                 // 2. Coerce to the most detailed type that could be coerced\n                 //    to, which is `expected_ty` if `rvalue_hint` returns an\n                 //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n-                let coerce_ty = expected.and_then(|e| e.only_has_type(self));\n+                let coerce_ty = expected.only_has_type(self).unwrap_or(formal_ty);\n                 // We're processing function arguments so we definitely want to use\n                 // two-phase borrows.\n-                self.demand_coerce(&arg,\n-                                   checked_ty,\n-                                   coerce_ty.unwrap_or(formal_ty),\n-                                   AllowTwoPhase::Yes);\n+                self.demand_coerce(&arg, checked_ty, coerce_ty,  AllowTwoPhase::Yes);\n \n                 // 3. Relate the expected type and the formal one,\n                 //    if the expected type was used for the coercion.\n-                coerce_ty.map(|ty| self.demand_suptype(arg.span, formal_ty, ty));\n+                self.demand_suptype(arg.span, formal_ty, coerce_ty);\n             }\n         }\n \n@@ -2839,18 +2831,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_expr_coercable_to_type(&self,\n                                     expr: &'gcx hir::Expr,\n                                     expected: Ty<'tcx>) -> Ty<'tcx> {\n-        self.check_expr_coercable_to_type_with_needs(expr, expected, Needs::None)\n-    }\n-\n-    fn check_expr_coercable_to_type_with_needs(&self,\n-                                               expr: &'gcx hir::Expr,\n-                                               expected: Ty<'tcx>,\n-                                               needs: Needs)\n-                                               -> Ty<'tcx> {\n-        let ty = self.check_expr_with_expectation_and_needs(\n-            expr,\n-            ExpectHasType(expected),\n-            needs);\n+        let ty = self.check_expr_with_hint(expr, expected);\n         // checks don't need two phase\n         self.demand_coerce(expr, ty, expected, AllowTwoPhase::No)\n     }\n@@ -2900,45 +2881,47 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                            formal_args: &[Ty<'tcx>])\n                                            -> Vec<Ty<'tcx>> {\n         let formal_ret = self.resolve_type_vars_with_obligations(formal_ret);\n-        let expected_args = expected_ret.only_has_type(self).and_then(|ret_ty| {\n-            self.fudge_regions_if_ok(&RegionVariableOrigin::Coercion(call_span), || {\n-                // Attempt to apply a subtyping relationship between the formal\n-                // return type (likely containing type variables if the function\n-                // is polymorphic) and the expected return type.\n-                // No argument expectations are produced if unification fails.\n-                let origin = self.misc(call_span);\n-                let ures = self.at(&origin, self.param_env).sup(ret_ty, &formal_ret);\n-\n-                // FIXME(#27336) can't use ? here, Try::from_error doesn't default\n-                // to identity so the resulting type is not constrained.\n-                match ures {\n-                    Ok(ok) => {\n-                        // Process any obligations locally as much as\n-                        // we can.  We don't care if some things turn\n-                        // out unconstrained or ambiguous, as we're\n-                        // just trying to get hints here.\n-                        self.save_and_restore_in_snapshot_flag(|_| {\n-                            let mut fulfill = TraitEngine::new(self.tcx);\n-                            for obligation in ok.obligations {\n-                                fulfill.register_predicate_obligation(self, obligation);\n-                            }\n-                            fulfill.select_where_possible(self)\n-                        }).map_err(|_| ())?;\n-                    }\n-                    Err(_) => return Err(()),\n+        let ret_ty = match expected_ret.only_has_type(self) {\n+            Some(ret) => ret,\n+            None => return Vec::new()\n+        };\n+        let expect_args = self.fudge_regions_if_ok(&RegionVariableOrigin::Coercion(call_span), || {\n+            // Attempt to apply a subtyping relationship between the formal\n+            // return type (likely containing type variables if the function\n+            // is polymorphic) and the expected return type.\n+            // No argument expectations are produced if unification fails.\n+            let origin = self.misc(call_span);\n+            let ures = self.at(&origin, self.param_env).sup(ret_ty, &formal_ret);\n+\n+            // FIXME(#27336) can't use ? here, Try::from_error doesn't default\n+            // to identity so the resulting type is not constrained.\n+            match ures {\n+                Ok(ok) => {\n+                    // Process any obligations locally as much as\n+                    // we can.  We don't care if some things turn\n+                    // out unconstrained or ambiguous, as we're\n+                    // just trying to get hints here.\n+                    self.save_and_restore_in_snapshot_flag(|_| {\n+                        let mut fulfill = TraitEngine::new(self.tcx);\n+                        for obligation in ok.obligations {\n+                            fulfill.register_predicate_obligation(self, obligation);\n+                        }\n+                        fulfill.select_where_possible(self)\n+                    }).map_err(|_| ())?;\n                 }\n+                Err(_) => return Err(()),\n+            }\n \n-                // Record all the argument types, with the substitutions\n-                // produced from the above subtyping unification.\n-                Ok(formal_args.iter().map(|ty| {\n-                    self.resolve_type_vars_if_possible(ty)\n-                }).collect())\n-            }).ok()\n-        }).unwrap_or(vec![]);\n+            // Record all the argument types, with the substitutions\n+            // produced from the above subtyping unification.\n+            Ok(formal_args.iter().map(|ty| {\n+                self.resolve_type_vars_if_possible(ty)\n+            }).collect())\n+        }).unwrap_or(Vec::new());\n         debug!(\"expected_inputs_for_expected_output(formal={:?} -> {:?}, expected={:?} -> {:?})\",\n                formal_args, formal_ret,\n-               expected_args, expected_ret);\n-        expected_args\n+               expect_args, expected_ret);\n+        expect_args\n     }\n \n     // Checks a method call."}, {"sha": "4a175248d74a317533d17bbf39cc0cfbac62659c", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0a9bd0f3cfd20694ff62ac8b74747adcdbbfa99/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0a9bd0f3cfd20694ff62ac8b74747adcdbbfa99/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=e0a9bd0f3cfd20694ff62ac8b74747adcdbbfa99", "patch": "@@ -174,9 +174,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // trait matching creating lifetime constraints that are too strict.\n         // E.g. adding `&'a T` and `&'b T`, given `&'x T: Add<&'x T>`, will result\n         // in `&'a T <: &'x T` and `&'b T <: &'x T`, instead of `'a = 'b = 'x`.\n-        let lhs_ty = self.check_expr_coercable_to_type_with_needs(lhs_expr,\n-            self.next_ty_var(TypeVariableOrigin::MiscVariable(lhs_expr.span)),\n-            lhs_needs);\n+        let lhs_ty = self.check_expr_with_needs(lhs_expr, lhs_needs);\n+        let fresh_var = self.next_ty_var(TypeVariableOrigin::MiscVariable(lhs_expr.span));\n+        let lhs_ty = self.demand_coerce(lhs_expr, lhs_ty, fresh_var,  AllowTwoPhase::No);\n         let lhs_ty = self.resolve_type_vars_with_obligations(lhs_ty);\n \n         // NB: As we have not yet type-checked the RHS, we don't have the"}]}