{"sha": "f770fecfe1cf3415675ac6165a200dff564bd00f", "node_id": "C_kwDOAAsO6NoAKGY3NzBmZWNmZTFjZjM0MTU2NzVhYzYxNjVhMjAwZGZmNTY0YmQwMGY", "commit": {"author": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-10-20T18:15:37Z"}, "committer": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-11-19T15:36:08Z"}, "message": "unify inherent impls of `CompileTimeEvalContext`", "tree": {"sha": "753b8bd074ef0f3790bb3787787e32f4e7909ca7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/753b8bd074ef0f3790bb3787787e32f4e7909ca7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f770fecfe1cf3415675ac6165a200dff564bd00f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f770fecfe1cf3415675ac6165a200dff564bd00f", "html_url": "https://github.com/rust-lang/rust/commit/f770fecfe1cf3415675ac6165a200dff564bd00f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f770fecfe1cf3415675ac6165a200dff564bd00f/comments", "author": null, "committer": null, "parents": [{"sha": "f13c4f4d6a4f0bb042839613bc92e9d3cfd9c308", "url": "https://api.github.com/repos/rust-lang/rust/commits/f13c4f4d6a4f0bb042839613bc92e9d3cfd9c308", "html_url": "https://github.com/rust-lang/rust/commit/f13c4f4d6a4f0bb042839613bc92e9d3cfd9c308"}], "stats": {"total": 90, "additions": 44, "deletions": 46}, "files": [{"sha": "66d6014946ceca75c1ab15c64e89e2fa31c9b4d1", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 44, "deletions": 46, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/f770fecfe1cf3415675ac6165a200dff564bd00f/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f770fecfe1cf3415675ac6165a200dff564bd00f/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=f770fecfe1cf3415675ac6165a200dff564bd00f", "patch": "@@ -23,52 +23,6 @@ use crate::interpret::{\n \n use super::error::*;\n \n-impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n-    /// \"Intercept\" a function call to a panic-related function\n-    /// because we have something special to do for it.\n-    /// If this returns successfully (`Ok`), the function should just be evaluated normally.\n-    fn hook_special_const_fn(\n-        &mut self,\n-        instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx>],\n-    ) -> InterpResult<'tcx, Option<ty::Instance<'tcx>>> {\n-        // All `#[rustc_do_not_const_check]` functions should be hooked here.\n-        let def_id = instance.def_id();\n-\n-        if Some(def_id) == self.tcx.lang_items().panic_display()\n-            || Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n-        {\n-            // &str or &&str\n-            assert!(args.len() == 1);\n-\n-            let mut msg_place = self.deref_operand(&args[0])?;\n-            while msg_place.layout.ty.is_ref() {\n-                msg_place = self.deref_operand(&msg_place.into())?;\n-            }\n-\n-            let msg = Symbol::intern(self.read_str(&msg_place)?);\n-            let span = self.find_closest_untracked_caller_location();\n-            let (file, line, col) = self.location_triple_for_span(span);\n-            return Err(ConstEvalErrKind::Panic { msg, file, line, col }.into());\n-        } else if Some(def_id) == self.tcx.lang_items().panic_fmt() {\n-            // For panic_fmt, call const_panic_fmt instead.\n-            if let Some(const_panic_fmt) = self.tcx.lang_items().const_panic_fmt() {\n-                return Ok(Some(\n-                    ty::Instance::resolve(\n-                        *self.tcx,\n-                        ty::ParamEnv::reveal_all(),\n-                        const_panic_fmt,\n-                        self.tcx.intern_substs(&[]),\n-                    )\n-                    .unwrap()\n-                    .unwrap(),\n-                ));\n-            }\n-        }\n-        Ok(None)\n-    }\n-}\n-\n /// Extra machine state for CTFE, and the Machine instance\n pub struct CompileTimeInterpreter<'mir, 'tcx> {\n     /// For now, the number of terminators that can be evaluated before we throw a resource\n@@ -191,6 +145,50 @@ impl interpret::MayLeak for ! {\n }\n \n impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n+    /// \"Intercept\" a function call to a panic-related function\n+    /// because we have something special to do for it.\n+    /// If this returns successfully (`Ok`), the function should just be evaluated normally.\n+    fn hook_special_const_fn(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        args: &[OpTy<'tcx>],\n+    ) -> InterpResult<'tcx, Option<ty::Instance<'tcx>>> {\n+        // All `#[rustc_do_not_const_check]` functions should be hooked here.\n+        let def_id = instance.def_id();\n+\n+        if Some(def_id) == self.tcx.lang_items().panic_display()\n+            || Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n+        {\n+            // &str or &&str\n+            assert!(args.len() == 1);\n+\n+            let mut msg_place = self.deref_operand(&args[0])?;\n+            while msg_place.layout.ty.is_ref() {\n+                msg_place = self.deref_operand(&msg_place.into())?;\n+            }\n+\n+            let msg = Symbol::intern(self.read_str(&msg_place)?);\n+            let span = self.find_closest_untracked_caller_location();\n+            let (file, line, col) = self.location_triple_for_span(span);\n+            return Err(ConstEvalErrKind::Panic { msg, file, line, col }.into());\n+        } else if Some(def_id) == self.tcx.lang_items().panic_fmt() {\n+            // For panic_fmt, call const_panic_fmt instead.\n+            if let Some(const_panic_fmt) = self.tcx.lang_items().const_panic_fmt() {\n+                return Ok(Some(\n+                    ty::Instance::resolve(\n+                        *self.tcx,\n+                        ty::ParamEnv::reveal_all(),\n+                        const_panic_fmt,\n+                        self.tcx.intern_substs(&[]),\n+                    )\n+                    .unwrap()\n+                    .unwrap(),\n+                ));\n+            }\n+        }\n+        Ok(None)\n+    }\n+\n     /// See documentation on the `ptr_guaranteed_cmp` intrinsic.\n     fn guaranteed_cmp(&mut self, a: Scalar, b: Scalar) -> InterpResult<'tcx, u8> {\n         Ok(match (a, b) {"}]}