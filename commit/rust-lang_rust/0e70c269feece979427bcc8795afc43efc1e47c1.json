{"sha": "0e70c269feece979427bcc8795afc43efc1e47c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlNzBjMjY5ZmVlY2U5Nzk0MjdiY2M4Nzk1YWZjNDNlZmMxZTQ3YzE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-12-07T15:52:10Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-12-09T16:44:52Z"}, "message": "fix BTree creating shared references that are not entirely in-bounds", "tree": {"sha": "203c53e0ffefbfa4675f606df4b89fb2b45f9317", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/203c53e0ffefbfa4675f606df4b89fb2b45f9317"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e70c269feece979427bcc8795afc43efc1e47c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e70c269feece979427bcc8795afc43efc1e47c1", "html_url": "https://github.com/rust-lang/rust/commit/0e70c269feece979427bcc8795afc43efc1e47c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e70c269feece979427bcc8795afc43efc1e47c1/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ccb5b219d50b1bc96dbb85e82a8473f16422582", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ccb5b219d50b1bc96dbb85e82a8473f16422582", "html_url": "https://github.com/rust-lang/rust/commit/1ccb5b219d50b1bc96dbb85e82a8473f16422582"}], "stats": {"total": 115, "additions": 86, "deletions": 29}, "files": [{"sha": "13cbcee2f8e08c638619906c2f6bb587913b0757", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 86, "deletions": 29, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/0e70c269feece979427bcc8795afc43efc1e47c1/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e70c269feece979427bcc8795afc43efc1e47c1/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=0e70c269feece979427bcc8795afc43efc1e47c1", "patch": "@@ -58,9 +58,34 @@ pub const CAPACITY: usize = 2 * B - 1;\n /// these should always be put behind pointers, and specifically behind `BoxedNode` in the owned\n /// case.\n ///\n-/// We put the metadata first so that its position is the same for every `K` and `V`, in order\n-/// to statically allocate a single dummy node to avoid allocations. This struct is `repr(C)` to\n-/// prevent them from being reordered.\n+/// We have a separate type for the header and rely on it matching the prefix of `LeafNode`, in\n+/// order to statically allocate a single dummy node to avoid allocations. This struct is\n+/// `repr(C)` to prevent them from being reordered.  `LeafNode` does not just contain a\n+/// `NodeHeader` because we do not want unnecessary padding between `len` and the keys.\n+/// Crucially, `NodeHeader` can be safely transmuted to different K and V.  (This is exploited\n+/// by `as_header`.)\n+/// See `into_key_slice` for an explanation of K2.  K2 cannot be safely transmuted around\n+/// because the size of `NodeHeader` depends on its alignment!\n+#[repr(C)]\n+struct NodeHeader<K, V, K2 = ()> {\n+    /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n+    /// This either points to an actual node or is null.\n+    parent: *const InternalNode<K, V>,\n+\n+    /// This node's index into the parent node's `edges` array.\n+    /// `*node.parent.edges[node.parent_idx]` should be the same thing as `node`.\n+    /// This is only guaranteed to be initialized when `parent` is non-null.\n+    parent_idx: MaybeUninit<u16>,\n+\n+    /// The number of keys and values this node stores.\n+    ///\n+    /// This next to `parent_idx` to encourage the compiler to join `len` and\n+    /// `parent_idx` into the same 32-bit word, reducing space overhead.\n+    len: u16,\n+\n+    /// See `into_key_slice`.\n+    keys_start: [K2; 0],\n+}\n #[repr(C)]\n struct LeafNode<K, V> {\n     /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n@@ -98,24 +123,25 @@ impl<K, V> LeafNode<K, V> {\n             len: 0\n         }\n     }\n+}\n \n+impl<K, V> NodeHeader<K, V> {\n     fn is_shared_root(&self) -> bool {\n         ptr::eq(self, &EMPTY_ROOT_NODE as *const _ as *const _)\n     }\n }\n \n // We need to implement Sync here in order to make a static instance.\n-unsafe impl Sync for LeafNode<(), ()> {}\n+unsafe impl Sync for NodeHeader<(), ()> {}\n \n // An empty node used as a placeholder for the root node, to avoid allocations.\n-// We use () in order to save space, since no operation on an empty tree will\n+// We use just a header in order to save space, since no operation on an empty tree will\n // ever take a pointer past the first key.\n-static EMPTY_ROOT_NODE: LeafNode<(), ()> = LeafNode {\n+static EMPTY_ROOT_NODE: NodeHeader<(), ()> = NodeHeader {\n     parent: ptr::null(),\n     parent_idx: MaybeUninit::uninitialized(),\n     len: 0,\n-    keys: MaybeUninit::uninitialized(),\n-    vals: MaybeUninit::uninitialized(),\n+    keys_start: [],\n };\n \n /// The underlying representation of internal nodes. As with `LeafNode`s, these should be hidden\n@@ -306,6 +332,11 @@ impl<K, V> Root<K, V> {\n ///   `Leaf`, the `NodeRef` points to a leaf node, when this is `Internal` the\n ///   `NodeRef` points to an internal node, and when this is `LeafOrInternal` the\n ///   `NodeRef` could be pointing to either type of node.\n+///   Note that in case of a leaf node, this might still be the shared root!  Only turn\n+///   this into a `LeafNode` reference if you know it is not a root!  Shared references\n+///   must be dereferencable *for the entire size of their pointee*, so `&InternalNode`\n+///   pointing to the shared root is UB.\n+///   Turning this into a `NodeHeader` is always safe.\n pub struct NodeRef<BorrowType, K, V, Type> {\n     height: usize,\n     node: NonNull<LeafNode<K, V>>,\n@@ -352,7 +383,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// Finds the length of the node. This is the number of keys or values. In an\n     /// internal node, the number of edges is `len() + 1`.\n     pub fn len(&self) -> usize {\n-        self.as_leaf().len as usize\n+        self.as_header().len as usize\n     }\n \n     /// Returns the height of this node in the whole tree. Zero height denotes the\n@@ -382,14 +413,19 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         }\n     }\n \n-    fn as_leaf(&self) -> &LeafNode<K, V> {\n+    /// Assert that this is indeed a proper leaf node, and not the shared root.\n+    unsafe fn as_leaf(&self) -> &LeafNode<K, V> {\n+        self.node.as_ref()\n+    }\n+\n+    fn as_header(&self) -> &NodeHeader<K, V> {\n         unsafe {\n-            self.node.as_ref()\n+            &*(self.node.as_ptr() as *const NodeHeader<K, V>)\n         }\n     }\n \n     pub fn is_shared_root(&self) -> bool {\n-        self.as_leaf().is_shared_root()\n+        self.as_header().is_shared_root()\n     }\n \n     pub fn keys(&self) -> &[K] {\n@@ -418,7 +454,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         >,\n         Self\n     > {\n-        let parent_as_leaf = self.as_leaf().parent as *const LeafNode<K, V>;\n+        let parent_as_leaf = self.as_header().parent as *const LeafNode<K, V>;\n         if let Some(non_zero) = NonNull::new(parent_as_leaf as *mut _) {\n             Ok(Handle {\n                 node: NodeRef {\n@@ -427,7 +463,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n                     root: self.root,\n                     _marker: PhantomData\n                 },\n-                idx: unsafe { usize::from(*self.as_leaf().parent_idx.get_ref()) },\n+                idx: unsafe { usize::from(*self.as_header().parent_idx.get_ref()) },\n                 _marker: PhantomData\n             })\n         } else {\n@@ -535,9 +571,8 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     }\n \n     fn as_leaf_mut(&mut self) -> &mut LeafNode<K, V> {\n-        unsafe {\n-            self.node.as_mut()\n-        }\n+        // We are mutable, so we cannot be the root, so this is okay.\n+        unsafe { self.node.as_mut() }\n     }\n \n     fn keys_mut(&mut self) -> &mut [K] {\n@@ -551,28 +586,50 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n     fn into_key_slice(self) -> &'a [K] {\n-        // When taking a pointer to the keys, if our key has a stricter\n-        // alignment requirement than the shared root does, then the pointer\n-        // would be out of bounds, which LLVM assumes will not happen. If the\n-        // alignment is more strict, we need to make an empty slice that doesn't\n-        // use an out of bounds pointer.\n+        // We have to be careful here because we might be pointing to the shared root.\n+        // In that case, we must not create an `&LeafNode`.  We could just return\n+        // an empty slice whenever the lenght is 0 (this includes the shared root),\n+        // but we want to avoid that run-time check.\n+        // Instead, we create a slice pointing into the node whenever possible.\n+        // We can sometimes do this even for the shared root, as the slice will be\n+        // empty.  We cannot *always* do this because if the type is too highly\n+        // aligned, the offset of `keys` in a \"full node\" might be outside the bounds\n+        // of the header!  So we do an alignment check first, that will be\n+        // evaluated at compile-time, and only do any run-time check in the rare case\n+        // that the alignment is very big.\n         if mem::align_of::<K>() > mem::align_of::<LeafNode<(), ()>>() && self.is_shared_root() {\n             &[]\n         } else {\n-            // Here either it's not the root, or the alignment is less strict,\n-            // in which case the keys pointer will point \"one-past-the-end\" of\n-            // the node, which is allowed by LLVM.\n+            // Thanks to the alignment check above, we know that `keys` will be\n+            // in-bounds of some allocation even if this is the shared root!\n+            // (We might be one-past-the-end, but that is allowed by LLVM.)\n+            // Getting the pointer is tricky though.  `NodeHeader` does not have a `keys`\n+            // field because we want its size to not depend on the alignment of `K`\n+            // (needed becuase `as_header` should be safe).  We cannot call `as_leaf`\n+            // because we might be the shared root.\n+            // For this reason, `NodeHeader` has this `K2` parameter (that's usually `()`\n+            // and hence just adds a size-0-align-1 field, not affecting layout).\n+            // We know that we can transmute `NodeHeader<K, V, ()>` to `NodeHeader<K, V, K>`\n+            // because we did the alignment check above, and hence `NodeHeader<K, V, K>`\n+            // is not bigger than `NodeHeader<K, V, ()>`!  Then we can use `NodeHeader<K, V, K>`\n+            // to compute the pointer where the keys start.\n+            // This entire hack will become unnecessary once\n+            // <https://github.com/rust-lang/rfcs/pull/2582> lands, then we can just take a raw\n+            // pointer to the `keys` field of `*const InternalNode<K, V>`.\n+\n+            // This is a non-debug-assert because it can be completely compile-time evaluated.\n+            assert!(mem::size_of::<NodeHeader<K, V>>() == mem::size_of::<NodeHeader<K, V, K>>());\n+            let header = self.as_header() as *const _ as *const NodeHeader<K, V, K>;\n+            let keys = unsafe { &(*header).keys_start as *const _ as *const K };\n             unsafe {\n-                slice::from_raw_parts(\n-                    self.as_leaf().keys.as_ptr() as *const K,\n-                    self.len()\n-                )\n+                slice::from_raw_parts(keys, self.len())\n             }\n         }\n     }\n \n     fn into_val_slice(self) -> &'a [V] {\n         debug_assert!(!self.is_shared_root());\n+        // We cannot be the root, so `as_leaf` is okay\n         unsafe {\n             slice::from_raw_parts(\n                 self.as_leaf().vals.as_ptr() as *const V,"}]}