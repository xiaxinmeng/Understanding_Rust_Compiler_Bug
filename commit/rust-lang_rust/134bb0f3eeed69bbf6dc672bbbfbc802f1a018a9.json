{"sha": "134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzNGJiMGYzZWVlZDY5YmJmNmRjNjcyYmJiZmJjODAyZjFhMDE4YTk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-30T00:52:00Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-30T00:52:00Z"}, "message": "core::rt: Change the signature of context switching methods to avoid infinite recursion", "tree": {"sha": "74f7efa3539745c6144b6d9775a3726677198220", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74f7efa3539745c6144b6d9775a3726677198220"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9", "html_url": "https://github.com/rust-lang/rust/commit/134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f343e6172b7132545c72e3e09e6afccc06fdcee7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f343e6172b7132545c72e3e09e6afccc06fdcee7", "html_url": "https://github.com/rust-lang/rust/commit/f343e6172b7132545c72e3e09e6afccc06fdcee7"}], "stats": {"total": 166, "additions": 66, "deletions": 100}, "files": [{"sha": "8ff3887f779c09eaab568072dbbb0114f4e97c60", "filename": "src/libcore/rt/comm.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9/src%2Flibcore%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9/src%2Flibcore%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fcomm.rs?ref=134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9", "patch": "@@ -159,7 +159,7 @@ impl<T> PortOne<T> {\n \n         // Switch to the scheduler to put the ~Task into the Packet state.\n         let sched = Local::take::<Scheduler>();\n-        do sched.deschedule_running_task_and_then |task| {\n+        do sched.deschedule_running_task_and_then |sched, task| {\n             unsafe {\n                 // Atomically swap the task pointer into the Packet state, issuing\n                 // an acquire barrier to prevent reordering of the subsequent read\n@@ -178,12 +178,10 @@ impl<T> PortOne<T> {\n                         // triggering infinite recursion on the scheduler's stack.\n                         let task: ~Coroutine = cast::transmute(task_as_state);\n                         let task = Cell(task);\n-                        let mut sched = Local::take::<Scheduler>();\n                         do sched.event_loop.callback {\n                             let sched = Local::take::<Scheduler>();\n                             sched.resume_task_immediately(task.take());\n                         }\n-                        Local::put(sched);\n                     }\n                     _ => util::unreachable()\n                 }"}, {"sha": "1113d7abe7dcb3c8d2091fcf9287ea5ee840c40d", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9", "patch": "@@ -238,12 +238,9 @@ fn test_context() {\n         let task = ~do Coroutine::new(&mut sched.stack_pool) {\n             assert_eq!(context(), TaskContext);\n             let sched = Local::take::<Scheduler>();\n-            do sched.deschedule_running_task_and_then() |task| {\n+            do sched.deschedule_running_task_and_then() |sched, task| {\n                 assert_eq!(context(), SchedulerContext);\n-                let task = Cell(task);\n-                do Local::borrow::<Scheduler> |sched| {\n-                    sched.enqueue_task(task.take());\n-                }\n+                sched.enqueue_task(task);\n             }\n         };\n         sched.enqueue_task(task);"}, {"sha": "089c95cd7cd532c8a81140b8c0024ae6a68e40c2", "filename": "src/libcore/rt/sched.rs", "status": "modified", "additions": 30, "deletions": 33, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9", "patch": "@@ -280,11 +280,9 @@ pub impl Scheduler {\n \n         rtdebug!(\"ending running task\");\n \n-        do self.deschedule_running_task_and_then |dead_task| {\n+        do self.deschedule_running_task_and_then |sched, dead_task| {\n             let dead_task = Cell(dead_task);\n-            do Local::borrow::<Scheduler> |sched| {\n-                dead_task.take().recycle(&mut sched.stack_pool);\n-            }\n+            dead_task.take().recycle(&mut sched.stack_pool);\n         }\n \n         abort!(\"control reached end of task\");\n@@ -293,22 +291,18 @@ pub impl Scheduler {\n     fn schedule_new_task(~self, task: ~Coroutine) {\n         assert!(self.in_task_context());\n \n-        do self.switch_running_tasks_and_then(task) |last_task| {\n+        do self.switch_running_tasks_and_then(task) |sched, last_task| {\n             let last_task = Cell(last_task);\n-            do Local::borrow::<Scheduler> |sched| {\n-                sched.enqueue_task(last_task.take());\n-            }\n+            sched.enqueue_task(last_task.take());\n         }\n     }\n \n     fn schedule_task(~self, task: ~Coroutine) {\n         assert!(self.in_task_context());\n \n-        do self.switch_running_tasks_and_then(task) |last_task| {\n+        do self.switch_running_tasks_and_then(task) |sched, last_task| {\n             let last_task = Cell(last_task);\n-            do Local::borrow::<Scheduler> |sched| {\n-                sched.enqueue_task(last_task.take());\n-            }\n+            sched.enqueue_task(last_task.take());\n         }\n     }\n \n@@ -352,15 +346,20 @@ pub impl Scheduler {\n     /// The closure here is a *stack* closure that lives in the\n     /// running task.  It gets transmuted to the scheduler's lifetime\n     /// and called while the task is blocked.\n-    fn deschedule_running_task_and_then(~self, f: &fn(~Coroutine)) {\n+    ///\n+    /// This passes a Scheduler pointer to the fn after the context switch\n+    /// in order to prevent that fn from performing further scheduling operations.\n+    /// Doing further scheduling could easily result in infinite recursion.\n+    fn deschedule_running_task_and_then(~self, f: &fn(&mut Scheduler, ~Coroutine)) {\n         let mut this = self;\n         assert!(this.in_task_context());\n \n         rtdebug!(\"blocking task\");\n \n         unsafe {\n             let blocked_task = this.current_task.swap_unwrap();\n-            let f_fake_region = transmute::<&fn(~Coroutine), &fn(~Coroutine)>(f);\n+            let f_fake_region = transmute::<&fn(&mut Scheduler, ~Coroutine),\n+                                            &fn(&mut Scheduler, ~Coroutine)>(f);\n             let f_opaque = ClosureConverter::from_fn(f_fake_region);\n             this.enqueue_cleanup_job(GiveTask(blocked_task, f_opaque));\n         }\n@@ -382,14 +381,18 @@ pub impl Scheduler {\n     /// Switch directly to another task, without going through the scheduler.\n     /// You would want to think hard about doing this, e.g. if there are\n     /// pending I/O events it would be a bad idea.\n-    fn switch_running_tasks_and_then(~self, next_task: ~Coroutine, f: &fn(~Coroutine)) {\n+    fn switch_running_tasks_and_then(~self, next_task: ~Coroutine,\n+                                     f: &fn(&mut Scheduler, ~Coroutine)) {\n         let mut this = self;\n         assert!(this.in_task_context());\n \n         rtdebug!(\"switching tasks\");\n \n         let old_running_task = this.current_task.swap_unwrap();\n-        let f_fake_region = unsafe { transmute::<&fn(~Coroutine), &fn(~Coroutine)>(f) };\n+        let f_fake_region = unsafe {\n+            transmute::<&fn(&mut Scheduler, ~Coroutine),\n+                        &fn(&mut Scheduler, ~Coroutine)>(f)\n+        };\n         let f_opaque = ClosureConverter::from_fn(f_fake_region);\n         this.enqueue_cleanup_job(GiveTask(old_running_task, f_opaque));\n         this.current_task = Some(next_task);\n@@ -426,7 +429,7 @@ pub impl Scheduler {\n         let cleanup_job = self.cleanup_job.swap_unwrap();\n         match cleanup_job {\n             DoNothing => { }\n-            GiveTask(task, f) => (f.to_fn())(task)\n+            GiveTask(task, f) => (f.to_fn())(self, task)\n         }\n     }\n \n@@ -535,12 +538,12 @@ pub impl Coroutine {\n // complaining\n type UnsafeTaskReceiver = sys::Closure;\n trait ClosureConverter {\n-    fn from_fn(&fn(~Coroutine)) -> Self;\n-    fn to_fn(self) -> &fn(~Coroutine);\n+    fn from_fn(&fn(&mut Scheduler, ~Coroutine)) -> Self;\n+    fn to_fn(self) -> &fn(&mut Scheduler, ~Coroutine);\n }\n impl ClosureConverter for UnsafeTaskReceiver {\n-    fn from_fn(f: &fn(~Coroutine)) -> UnsafeTaskReceiver { unsafe { transmute(f) } }\n-    fn to_fn(self) -> &fn(~Coroutine) { unsafe { transmute(self) } }\n+    fn from_fn(f: &fn(&mut Scheduler, ~Coroutine)) -> UnsafeTaskReceiver { unsafe { transmute(f) } }\n+    fn to_fn(self) -> &fn(&mut Scheduler, ~Coroutine) { unsafe { transmute(self) } }\n }\n \n #[cfg(test)]\n@@ -604,11 +607,9 @@ mod test {\n                     unsafe { *count_ptr = *count_ptr + 1; }\n                 };\n                 // Context switch directly to the new task\n-                do sched.switch_running_tasks_and_then(task2) |task1| {\n+                do sched.switch_running_tasks_and_then(task2) |sched, task1| {\n                     let task1 = Cell(task1);\n-                    do Local::borrow::<Scheduler> |sched| {\n-                        sched.enqueue_task(task1.take());\n-                    }\n+                    sched.enqueue_task(task1.take());\n                 }\n                 unsafe { *count_ptr = *count_ptr + 1; }\n             };\n@@ -658,12 +659,10 @@ mod test {\n             let task = ~do Coroutine::new(&mut sched.stack_pool) {\n                 let sched = Local::take::<Scheduler>();\n                 assert!(sched.in_task_context());\n-                do sched.deschedule_running_task_and_then() |task| {\n+                do sched.deschedule_running_task_and_then() |sched, task| {\n                     let task = Cell(task);\n-                    do Local::borrow::<Scheduler> |sched| {\n-                        assert!(!sched.in_task_context());\n-                        sched.enqueue_task(task.take());\n-                    }\n+                    assert!(!sched.in_task_context());\n+                    sched.enqueue_task(task.take());\n                 }\n             };\n             sched.enqueue_task(task);\n@@ -680,16 +679,14 @@ mod test {\n         do run_in_newsched_task {\n             do spawn {\n                 let sched = Local::take::<Scheduler>();\n-                do sched.deschedule_running_task_and_then |task| {\n-                    let mut sched = Local::take::<Scheduler>();\n+                do sched.deschedule_running_task_and_then |sched, task| {\n                     let task = Cell(task);\n                     do sched.event_loop.callback_ms(10) {\n                         rtdebug!(\"in callback\");\n                         let mut sched = Local::take::<Scheduler>();\n                         sched.enqueue_task(task.take());\n                         Local::put(sched);\n                     }\n-                    Local::put(sched);\n                 }\n             }\n         }"}, {"sha": "16b0aef5e266bfffc53061d23a2b572c69b4a281", "filename": "src/libcore/rt/test.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9/src%2Flibcore%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9/src%2Flibcore%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftest.rs?ref=134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9", "patch": "@@ -122,11 +122,7 @@ pub fn spawntask(f: ~fn()) {\n     let task = ~Coroutine::with_task(&mut sched.stack_pool,\n                                      ~Task::without_unwinding(),\n                                      f);\n-    do sched.switch_running_tasks_and_then(task) |task| {\n-        let task = Cell(task);\n-        let sched = Local::take::<Scheduler>();\n-        sched.schedule_new_task(task.take());\n-    }\n+    sched.schedule_new_task(task);\n }\n \n /// Create a new task and run it right now. Aborts on failure\n@@ -137,11 +133,8 @@ pub fn spawntask_immediately(f: ~fn()) {\n     let task = ~Coroutine::with_task(&mut sched.stack_pool,\n                                      ~Task::without_unwinding(),\n                                      f);\n-    do sched.switch_running_tasks_and_then(task) |task| {\n-        let task = Cell(task);\n-        do Local::borrow::<Scheduler> |sched| {\n-            sched.enqueue_task(task.take());\n-        }\n+    do sched.switch_running_tasks_and_then(task) |sched, task| {\n+        sched.enqueue_task(task);\n     }\n }\n \n@@ -172,11 +165,8 @@ pub fn spawntask_random(f: ~fn()) {\n                                      f);\n \n     if run_now {\n-        do sched.switch_running_tasks_and_then(task) |task| {\n-            let task = Cell(task);\n-            do Local::borrow::<Scheduler> |sched| {\n-                sched.enqueue_task(task.take());\n-            }\n+        do sched.switch_running_tasks_and_then(task) |sched, task| {\n+            sched.enqueue_task(task);\n         }\n     } else {\n         sched.enqueue_task(task);\n@@ -199,27 +189,23 @@ pub fn spawntask_try(f: ~fn()) -> Result<(), ()> {\n     // Switch to the scheduler\n     let f = Cell(Cell(f));\n     let sched = Local::take::<Scheduler>();\n-    do sched.deschedule_running_task_and_then() |old_task| {\n+    do sched.deschedule_running_task_and_then() |sched, old_task| {\n         let old_task = Cell(old_task);\n         let f = f.take();\n-        let mut sched = Local::take::<Scheduler>();\n         let new_task = ~do Coroutine::new(&mut sched.stack_pool) {\n             do (|| {\n                 (f.take())()\n             }).finally {\n                 // Check for failure then resume the parent task\n                 unsafe { *failed_ptr = task::failing(); }\n                 let sched = Local::take::<Scheduler>();\n-                do sched.switch_running_tasks_and_then(old_task.take()) |new_task| {\n-                    let new_task = Cell(new_task);\n-                    do Local::borrow::<Scheduler> |sched| {\n-                        sched.enqueue_task(new_task.take());\n-                    }\n+                do sched.switch_running_tasks_and_then(old_task.take()) |sched, new_task| {\n+                    sched.enqueue_task(new_task);\n                 }\n             }\n         };\n \n-        sched.resume_task_immediately(new_task);\n+        sched.enqueue_task(new_task);\n     }\n \n     if !failed { Ok(()) } else { Err(()) }"}, {"sha": "4482a92d916aaf683c7d9a97b5fe7d25b776b6bf", "filename": "src/libcore/rt/tube.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9/src%2Flibcore%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9/src%2Flibcore%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftube.rs?ref=134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9", "patch": "@@ -72,7 +72,7 @@ impl<T> Tube<T> {\n                 assert!(self.p.refcount() > 1); // There better be somebody to wake us up\n                 assert!((*state).blocked_task.is_none());\n                 let sched = Local::take::<Scheduler>();\n-                do sched.deschedule_running_task_and_then |task| {\n+                do sched.deschedule_running_task_and_then |_, task| {\n                     (*state).blocked_task = Some(task);\n                 }\n                 rtdebug!(\"waking after tube recv\");\n@@ -107,11 +107,10 @@ mod test {\n             let tube_clone = tube.clone();\n             let tube_clone_cell = Cell(tube_clone);\n             let sched = Local::take::<Scheduler>();\n-            do sched.deschedule_running_task_and_then |task| {\n+            do sched.deschedule_running_task_and_then |sched, task| {\n                 let mut tube_clone = tube_clone_cell.take();\n                 tube_clone.send(1);\n-                let sched = Local::take::<Scheduler>();\n-                sched.resume_task_immediately(task);\n+                sched.enqueue_task(task);\n             }\n \n             assert!(tube.recv() == 1);\n@@ -123,21 +122,17 @@ mod test {\n         do run_in_newsched_task {\n             let mut tube: Tube<int> = Tube::new();\n             let tube_clone = tube.clone();\n-            let tube_clone = Cell(Cell(Cell(tube_clone)));\n+            let tube_clone = Cell(tube_clone);\n             let sched = Local::take::<Scheduler>();\n-            do sched.deschedule_running_task_and_then |task| {\n-                let tube_clone = tube_clone.take();\n-                do Local::borrow::<Scheduler> |sched| {\n-                    let tube_clone = tube_clone.take();\n-                    do sched.event_loop.callback {\n-                        let mut tube_clone = tube_clone.take();\n-                        // The task should be blocked on this now and\n-                        // sending will wake it up.\n-                        tube_clone.send(1);\n-                    }\n+            do sched.deschedule_running_task_and_then |sched, task| {\n+                let tube_clone = Cell(tube_clone.take());\n+                do sched.event_loop.callback {\n+                    let mut tube_clone = tube_clone.take();\n+                    // The task should be blocked on this now and\n+                    // sending will wake it up.\n+                    tube_clone.send(1);\n                 }\n-                let sched = Local::take::<Scheduler>();\n-                sched.resume_task_immediately(task);\n+                sched.enqueue_task(task);\n             }\n \n             assert!(tube.recv() == 1);\n@@ -153,7 +148,7 @@ mod test {\n             let tube_clone = tube.clone();\n             let tube_clone = Cell(tube_clone);\n             let sched = Local::take::<Scheduler>();\n-            do sched.deschedule_running_task_and_then |task| {\n+            do sched.deschedule_running_task_and_then |sched, task| {\n                 callback_send(tube_clone.take(), 0);\n \n                 fn callback_send(tube: Tube<int>, i: int) {\n@@ -172,8 +167,7 @@ mod test {\n                     }\n                 }\n \n-                let sched = Local::take::<Scheduler>();\n-                sched.resume_task_immediately(task);\n+                sched.enqueue_task(task);\n             }\n \n             for int::range(0, MAX) |i| {"}, {"sha": "1ee6504d11fc5354e63a42d0d0a4b9d2307c9e07", "filename": "src/libcore/rt/uv/uvio.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs?ref=134bb0f3eeed69bbf6dc672bbbfbc802f1a018a9", "patch": "@@ -205,12 +205,10 @@ impl IoFactory for UvIoFactory {\n         assert!(scheduler.in_task_context());\n \n         // Block this task and take ownership, switch to scheduler context\n-        do scheduler.deschedule_running_task_and_then |task| {\n+        do scheduler.deschedule_running_task_and_then |sched, task| {\n \n             rtdebug!(\"connect: entered scheduler context\");\n-            do Local::borrow::<Scheduler> |scheduler| {\n-                assert!(!scheduler.in_task_context());\n-            }\n+            assert!(!sched.in_task_context());\n             let mut tcp_watcher = TcpWatcher::new(self.uv_loop());\n             let task_cell = Cell(task);\n \n@@ -250,7 +248,7 @@ impl IoFactory for UvIoFactory {\n             Ok(_) => Ok(~UvTcpListener::new(watcher)),\n             Err(uverr) => {\n                 let scheduler = Local::take::<Scheduler>();\n-                do scheduler.deschedule_running_task_and_then |task| {\n+                do scheduler.deschedule_running_task_and_then |_, task| {\n                     let task_cell = Cell(task);\n                     do watcher.as_stream().close {\n                         let scheduler = Local::take::<Scheduler>();\n@@ -286,7 +284,7 @@ impl Drop for UvTcpListener {\n     fn finalize(&self) {\n         let watcher = self.watcher();\n         let scheduler = Local::take::<Scheduler>();\n-        do scheduler.deschedule_running_task_and_then |task| {\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n             let task_cell = Cell(task);\n             do watcher.as_stream().close {\n                 let scheduler = Local::take::<Scheduler>();\n@@ -348,7 +346,7 @@ impl Drop for UvTcpStream {\n         rtdebug!(\"closing tcp stream\");\n         let watcher = self.watcher();\n         let scheduler = Local::take::<Scheduler>();\n-        do scheduler.deschedule_running_task_and_then |task| {\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n             let task_cell = Cell(task);\n             do watcher.close {\n                 let scheduler = Local::take::<Scheduler>();\n@@ -367,11 +365,9 @@ impl RtioTcpStream for UvTcpStream {\n         assert!(scheduler.in_task_context());\n         let watcher = self.watcher();\n         let buf_ptr: *&mut [u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |task| {\n+        do scheduler.deschedule_running_task_and_then |sched, task| {\n             rtdebug!(\"read: entered scheduler context\");\n-            do Local::borrow::<Scheduler> |scheduler| {\n-                assert!(!scheduler.in_task_context());\n-            }\n+            assert!(!sched.in_task_context());\n             let mut watcher = watcher;\n             let task_cell = Cell(task);\n             // XXX: We shouldn't reallocate these callbacks every\n@@ -413,7 +409,7 @@ impl RtioTcpStream for UvTcpStream {\n         assert!(scheduler.in_task_context());\n         let watcher = self.watcher();\n         let buf_ptr: *&[u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |task| {\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n             let mut watcher = watcher;\n             let task_cell = Cell(task);\n             let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n@@ -507,11 +503,9 @@ fn test_read_and_block() {\n                 // Yield to the other task in hopes that it\n                 // will trigger a read callback while we are\n                 // not ready for it\n-                do scheduler.deschedule_running_task_and_then |task| {\n+                do scheduler.deschedule_running_task_and_then |sched, task| {\n                     let task = Cell(task);\n-                    do Local::borrow::<Scheduler> |scheduler| {\n-                        scheduler.enqueue_task(task.take());\n-                    }\n+                    sched.enqueue_task(task.take());\n                 }\n             }\n "}]}