{"sha": "425732311af6d7a4f972dff04e1abb7db6a22f3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyNTczMjMxMWFmNmQ3YTRmOTcyZGZmMDRlMWFiYjdkYjZhMjJmM2I=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-07-06T22:22:23Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-07-12T01:52:50Z"}, "message": "Move macro expansion to a separate phase, change macro syntax, and add parse_sess to session.", "tree": {"sha": "5b3d5493c7fc3a32a28b166f5ea393d640537c23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b3d5493c7fc3a32a28b166f5ea393d640537c23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/425732311af6d7a4f972dff04e1abb7db6a22f3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/425732311af6d7a4f972dff04e1abb7db6a22f3b", "html_url": "https://github.com/rust-lang/rust/commit/425732311af6d7a4f972dff04e1abb7db6a22f3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/425732311af6d7a4f972dff04e1abb7db6a22f3b/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80cf4ecd3bfe602004145e57cf7fdfb067b76ce1", "url": "https://api.github.com/repos/rust-lang/rust/commits/80cf4ecd3bfe602004145e57cf7fdfb067b76ce1", "html_url": "https://github.com/rust-lang/rust/commit/80cf4ecd3bfe602004145e57cf7fdfb067b76ce1"}], "stats": {"total": 510, "additions": 336, "deletions": 174}, "files": [{"sha": "a8c9738eb4a14e5f699d14269d608ce9f1f29840", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=425732311af6d7a4f972dff04e1abb7db6a22f3b", "patch": "@@ -80,10 +80,10 @@ fn parse_input(session::session sess, &ast::crate_cfg cfg, str input)\n     -> @ast::crate {\n     ret if (str::ends_with(input, \".rc\")) {\n             parser::parse_crate_from_crate_file\n-                (input, cfg, sess.get_codemap())\n+                (input, cfg, sess.get_parse_sess())\n         } else if (str::ends_with(input, \".rs\")) {\n             parser::parse_crate_from_source_file\n-                (input, cfg, sess.get_codemap())\n+                (input, cfg, sess.get_parse_sess())\n         } else { sess.fatal(\"unknown input file type: \" + input); fail };\n }\n \n@@ -110,6 +110,9 @@ fn compile_input(session::session sess, ast::crate_cfg cfg, str input,\n         crate = time(time_passes, \"building test harness\",\n                      bind front::test::modify_for_testing(crate));\n     }\n+    crate = time(time_passes, \"expansion\",\n+                 bind syntax::ext::expand::expand_crate(sess, crate));\n+\n     auto ast_map = time(time_passes, \"ast indexing\",\n                         bind middle::ast_map::map_crate(*crate));\n     time(time_passes, \"external crate/lib resolution\",\n@@ -357,7 +360,8 @@ fn build_session(@session::options sopts) -> session::session {\n     auto target_cfg = build_target_config();\n     auto cstore = cstore::mk_cstore();\n     ret session::session(target_cfg, sopts, cstore,\n-                         codemap::new_codemap(), 0u);\n+                         @rec(cm=codemap::new_codemap(), mutable next_id=0),\n+                         0u);\n }\n \n fn parse_pretty(session::session sess, &str name) -> pp_mode {"}, {"sha": "8da3e40baa6c09def83b4fa3d1b7aae79ff2d533", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=425732311af6d7a4f972dff04e1abb7db6a22f3b", "patch": "@@ -11,6 +11,7 @@ import std::option::some;\n import std::option::none;\n import std::str;\n import std::vec;\n+import syntax::parse::parser::parse_sess;\n \n tag os { os_win32; os_macos; os_linux; }\n \n@@ -47,26 +48,26 @@ type crate_metadata = rec(str name, vec[u8] data);\n obj session(@config targ_cfg,\n             @options opts,\n             metadata::cstore::cstore cstore,\n-            codemap::codemap cm,\n+            parse_sess parse_sess,\n             mutable uint err_count) {\n     fn get_targ_cfg() -> @config { ret targ_cfg; }\n     fn get_opts() -> @options { ret opts; }\n     fn get_cstore() -> metadata::cstore::cstore { cstore }\n     fn span_fatal(span sp, str msg) -> ! {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n-        codemap::emit_error(some(sp), msg, cm);\n+        codemap::emit_error(some(sp), msg, parse_sess.cm);\n         fail;\n     }\n     fn fatal(str msg) -> ! {\n-        codemap::emit_error(none, msg, cm);\n+        codemap::emit_error(none, msg, parse_sess.cm);\n         fail;\n     }\n     fn span_err(span sp, str msg) {\n-        codemap::emit_error(some(sp), msg, cm);\n+        codemap::emit_error(some(sp), msg, parse_sess.cm);\n         err_count += 1u;\n     }\n     fn err(str msg) {\n-        codemap::emit_error(none, msg, cm);\n+        codemap::emit_error(none, msg, parse_sess.cm);\n         err_count += 1u;\n     }\n     fn abort_if_errors() {\n@@ -76,17 +77,17 @@ obj session(@config targ_cfg,\n     }\n     fn span_warn(span sp, str msg) {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n-        codemap::emit_warning(some(sp), msg, cm);\n+        codemap::emit_warning(some(sp), msg, parse_sess.cm);\n     }\n     fn warn(str msg) {\n-        codemap::emit_warning(none, msg, cm);\n+        codemap::emit_warning(none, msg, parse_sess.cm);\n     }\n     fn span_note(span sp, str msg) {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n-        codemap::emit_note(some(sp), msg, cm);\n+        codemap::emit_note(some(sp), msg, parse_sess.cm);\n     }\n     fn note(str msg) {\n-        codemap::emit_note(none, msg, cm);\n+        codemap::emit_note(none, msg, parse_sess.cm);\n     }\n     fn span_bug(span sp, str msg) -> ! {\n         self.span_fatal(sp, #fmt(\"internal compiler error %s\", msg));\n@@ -98,9 +99,13 @@ obj session(@config targ_cfg,\n         self.span_bug(sp, \"unimplemented \" + msg);\n     }\n     fn unimpl(str msg) -> ! { self.bug(\"unimplemented \" + msg); }\n-    fn get_codemap() -> codemap::codemap { ret cm; }\n+    fn get_codemap() -> codemap::codemap { ret parse_sess.cm; }\n     fn lookup_pos(uint pos) -> codemap::loc {\n-        ret codemap::lookup_pos(cm, pos);\n+        ret codemap::lookup_pos(parse_sess.cm, pos);\n+    }\n+    fn get_parse_sess() -> parse_sess { ret parse_sess; }\n+    fn next_node_id() -> ast::node_id {\n+        ret syntax::parse::parser::next_node_id(parse_sess);\n     }\n     fn span_str(span sp) -> str {\n         ret codemap::span_to_str(sp, self.get_codemap());"}, {"sha": "5c39b5d2f744c2308ef48e910f357b12382948bf", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=425732311af6d7a4f972dff04e1abb7db6a22f3b", "patch": "@@ -6378,8 +6378,8 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n         case (ast::expr_rec(?args, ?base)) {\n             ret trans_rec(cx, args, base, e.id);\n         }\n-        case (ast::expr_ext(_, _, _, ?expanded)) {\n-            ret trans_expr(cx, expanded);\n+        case (ast::expr_ext(_, _, _)) {\n+            ret cx.fcx.lcx.ccx.sess.bug(\"unexpanded macro\");\n         }\n         case (ast::expr_fail(?expr)) {\n             ret trans_fail_expr(cx, some(e.span), expr);"}, {"sha": "dae56fdf1cb343cc11032b9fc10c4899fc65d9fc", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=425732311af6d7a4f972dff04e1abb7db6a22f3b", "patch": "@@ -570,9 +570,8 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n         case (expr_break) { clear_pp(expr_pp(fcx.ccx, e)); }\n         case (expr_cont) { clear_pp(expr_pp(fcx.ccx, e)); }\n         case (expr_port(_)) { clear_pp(expr_pp(fcx.ccx, e)); }\n-        case (expr_ext(_, _, _, ?expanded)) {\n-            find_pre_post_expr(fcx, expanded);\n-            copy_pre_post(fcx.ccx, e.id, expanded);\n+        case (expr_ext(_, _, _)) {\n+            fcx.ccx.tcx.sess.bug(\"unexpanded macro\");\n         }\n         case (expr_anon_obj(?anon_obj, _)) {\n             alt (anon_obj.with_obj) {"}, {"sha": "f3f78924442a4e2921604e51594d4dcce2caefa6", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=425732311af6d7a4f972dff04e1abb7db6a22f3b", "patch": "@@ -367,8 +367,8 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         case (expr_chan(?ex)) {\n             ret find_pre_post_state_sub(fcx, pres, ex, e.id, none);\n         }\n-        case (expr_ext(_, _, _, ?expanded)) {\n-            ret find_pre_post_state_sub(fcx, pres, expanded, e.id, none);\n+        case (expr_ext(_, _, _)) {\n+            fcx.ccx.tcx.sess.bug(\"unexpanded macro\");\n         }\n         case (expr_put(?maybe_e)) {\n             alt (maybe_e) {"}, {"sha": "3a9b1f6c39637c6f66a90508f3f9223ac03f5cff", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=425732311af6d7a4f972dff04e1abb7db6a22f3b", "patch": "@@ -1780,10 +1780,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             }\n             write::ty_only_fixup(fcx, id, tpt._1);\n         }\n-        case (ast::expr_ext(?p, ?args, ?body, ?expanded)) {\n-            check_expr(fcx, expanded);\n-            auto t = expr_ty(fcx.ccx.tcx, expanded);\n-            write::ty_only_fixup(fcx, id, t);\n+        case (ast::expr_ext(_,_,_)) {\n+            fcx.ccx.tcx.sess.bug(\"unexpanded macro\");\n         }\n         case (ast::expr_fail(?expr_opt)) {\n             alt (expr_opt) {"}, {"sha": "79cec1a725c4e2e9ba6375358e7b32ab8fb59924", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=425732311af6d7a4f972dff04e1abb7db6a22f3b", "patch": "@@ -53,6 +53,7 @@ mod syntax {\n         mod fmt;\n         mod env;\n         mod simplext;\n+        mod expand;\n     }\n     mod print {\n         mod pprust;"}, {"sha": "a75aa4d8c23c2f20b28a554e44c6f8d10c30353a", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=425732311af6d7a4f972dff04e1abb7db6a22f3b", "patch": "@@ -305,7 +305,7 @@ tag expr_ {\n     expr_field(@expr, ident);\n     expr_index(@expr, @expr);\n     expr_path(path);\n-    expr_ext(path, (@expr)[], option::t[str], @expr);\n+    expr_ext(path, (@expr)[], option::t[str]);\n     expr_fail(option::t[@expr]);\n     expr_break;\n     expr_cont;"}, {"sha": "84319cf5f38f46e8dfdf42a347f66a93cee170a6", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=425732311af6d7a4f972dff04e1abb7db6a22f3b", "patch": "@@ -2,7 +2,7 @@ import std::ivec;\n import std::vec;\n import std::option;\n import std::map::hashmap;\n-import parse::parser::parse_sess;\n+import driver::session::session;\n import codemap::span;\n import std::map::new_str_hash;\n import codemap;\n@@ -41,14 +41,14 @@ type ext_ctxt =\n         span_msg_fn span_unimpl,\n         next_id_fn next_id);\n \n-fn mk_ctxt(&parse_sess sess) -> ext_ctxt {\n-    fn ext_span_fatal_(&codemap::codemap cm, span sp, str msg) -> ! {\n-        codemap::emit_error(option::some(sp), msg, cm);\n+fn mk_ctxt(&session sess) -> ext_ctxt {\n+    fn ext_span_fatal_(&session sess, span sp, str msg) -> ! {\n+        sess.span_err(sp, msg);\n         fail;\n     }\n-    auto ext_span_fatal = bind ext_span_fatal_(sess.cm, _, _);\n-    fn ext_span_unimpl_(&codemap::codemap cm, span sp, str msg) -> ! {\n-        codemap::emit_error(option::some(sp), \"unimplemented \" + msg, cm);\n+    auto ext_span_fatal = bind ext_span_fatal_(sess, _, _);\n+    fn ext_span_unimpl_(&session sess, span sp, str msg) -> ! {\n+        sess.span_err(sp, \"unimplemented \" + msg);\n         fail;\n     }\n \n@@ -59,9 +59,12 @@ fn mk_ctxt(&parse_sess sess) -> ext_ctxt {\n     // the extensions the file name of the crate being compiled so they can\n     // use it to guess whether paths should be prepended with \"std::\". This is\n     // super-ugly and needs a better solution.\n-    auto crate_file_name_hack = sess.cm.files.(0).name;\n-    auto ext_span_unimpl = bind ext_span_unimpl_(sess.cm, _, _);\n-    auto ext_next_id = bind parse::parser::next_node_id(sess);\n+    auto crate_file_name_hack = sess.get_codemap().files.(0).name;\n+    auto ext_span_unimpl = bind ext_span_unimpl_(sess, _, _);\n+    fn ext_next_id_(&session sess) -> ast::node_id {\n+        ret sess.next_node_id(); // temporary, until bind works better\n+    }\n+    auto ext_next_id = bind ext_next_id_(sess);\n     ret rec(crate_file_name_hack=crate_file_name_hack,\n             span_fatal=ext_span_fatal,\n             span_unimpl=ext_span_unimpl,"}, {"sha": "3af9fdc5070268bb5008bfc93a8a3ac6e312c643", "filename": "src/comp/syntax/ext/expand.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs?ref=425732311af6d7a4f972dff04e1abb7db6a22f3b", "patch": "@@ -0,0 +1,65 @@\n+\n+import codemap::emit_error;\n+import driver::session;\n+import syntax::ast::crate;\n+import syntax::ast::expr_;\n+import syntax::ast::expr_ext;\n+import syntax::fold::*;\n+\n+import std::option::none;\n+import std::option::some;\n+\n+import std::map::hashmap;\n+import std::ivec;\n+\n+fn expand_expr(&hashmap[str, base::syntax_extension] exts, \n+               &session::session sess, &expr_ e, ast_fold fld, \n+               &fn(&ast::expr_, ast_fold) -> expr_ orig) -> expr_ {\n+    ret alt(e) {\n+        case (expr_ext(?pth, ?args, ?body)) {\n+            assert(ivec::len(pth.node.idents) > 0u);\n+            auto extname = pth.node.idents.(0);\n+            auto ext_cx = base::mk_ctxt(sess);\n+            alt (exts.find(extname)) {\n+                case (none) {\n+                    emit_error(some(pth.span), \"unknown syntax expander: '\"\n+                               + extname + \"'\", sess.get_codemap());\n+                    fail\n+                }\n+                case (some(base::normal(?ext))) {\n+                    //keep going, outside-in\n+                    fld.fold_expr(ext(ext_cx, pth.span, args, body)).node\n+                }\n+                case (some(base::macro_defining(?ext))) {\n+                    auto named_extension = ext(ext_cx, pth.span, args, body);\n+                    exts.insert(named_extension._0, named_extension._1);\n+                    ast::expr_tup([])\n+                }\n+            }\n+\n+        }\n+        case (_) { orig(e, fld) }\n+    };\n+}\n+\n+fn expand_crate(&session::session sess, &@crate c) -> @crate {\n+    auto exts = ext::base::syntax_expander_table();\n+    auto afp = default_ast_fold();\n+    auto f_pre =\n+        rec(fold_expr = bind expand_expr(exts, sess, _, _, afp.fold_expr)\n+            with *afp);\n+    auto f = make_fold(f_pre);\n+    auto res = @f.fold_crate(*c);\n+    dummy_out(f); //temporary: kill circular reference\n+    ret res;\n+    \n+}\n+\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "59505a5a89a5e379adee4399f1335063233b43a2", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 198, "deletions": 74, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=425732311af6d7a4f972dff04e1abb7db6a22f3b", "patch": "@@ -16,121 +16,245 @@ import base::expr_to_str;\n import base::expr_to_ident;\n \n import fold::*;\n+import ast::respan;\n import ast::ident;\n+import ast::path;\n import ast::path_;\n import ast::expr_path;\n+import ast::expr_vec;\n+import ast::expr_ext;\n \n export add_new_extension;\n \n-\n-//temporary, until 'position' shows up in the snapshot\n-fn position[T](&T x, &vec[T] v) -> option::t[uint] {\n-    let uint i = 0u;\n-    while (i < len(v)) {\n-        if (x == v.(i)) { ret some[uint](i); }\n-        i += 1u;\n+fn lookup(&vec[invk_binding] ibs, ident i) -> option::t[invk_binding] {\n+    for (invk_binding ib in ibs) {\n+        alt (ib) {\n+            case (ident_binding(?p_id, _)) { if (i == p_id) { ret some(ib); }}\n+            case (path_binding(?p_id, _)) { if (i == p_id) { ret some(ib); }}\n+            case (expr_binding(?p_id, _)) { if (i == p_id) { ret some(ib); }}\n+        }\n     }\n-    ret none[uint];\n+    ret none;\n }\n \n // substitute, in a position that's required to be an ident\n-fn subst_ident(&ext_ctxt cx, &(@ast::expr)[] args, \n-               @vec[ident] param_names, &ident i, ast_fold fld) -> ident {\n-    alt (position(i, *param_names)) {\n-        case (some[uint](?idx)) {\n-            ret expr_to_ident(cx, args.(idx), \n-                              \"This argument is expanded as an \"\n-                              + \"identifier; it must be one.\");\n+fn subst_ident(&ext_ctxt cx, &(invk_binding)[] ibs, &ident i, ast_fold fld)\n+    -> ident {\n+    ret alt (lookup(ibs, i)) {\n+        case (some(ident_binding(_, ?a_id))) { a_id.node }\n+        case (some(path_binding(_, ?pth))) {\n+            cx.span_fatal(pth.span, \"This argument is expanded as an \"\n+                          + \"identifier; it must be one.\")\n         }\n-        case (none[uint]) {\n-            ret i;\n+        case (some(expr_binding(_, ?expr))) {\n+            cx.span_fatal(expr.span, \"This argument is expanded as an \"\n+                          + \"identifier; it must be one.\")\n         }\n+        case (none) { i }\n     }\n }\n \n-fn subst_path(&ext_ctxt cx, &(@ast::expr)[] args, \n-              @vec[ident] param_names, &path_ p, ast_fold fld) -> path_ {\n+\n+fn subst_path(&ext_ctxt cx, &(invk_binding)[] ibs, &path_ p, ast_fold fld)\n+    -> path_ {\n     // Don't substitute into qualified names.\n     if (ivec::len(p.types) > 0u || ivec::len(p.idents) != 1u) { ret p; }\n-    alt (position(p.idents.(0), *param_names)) {\n-        case (some[uint](?idx)) {\n-            alt (args.(idx).node) {\n-                case (expr_path(?new_path)) {\n-                    ret new_path.node;\n-                }\n-                case (_) {\n-                    cx.span_fatal(args.(idx).span,\n-                                \"This argument is expanded as a path; \"\n-                                + \"it must be one.\");\n-                }\n-            }\n+    ret alt (lookup(ibs, p.idents.(0))) {\n+        case (some(ident_binding(_, ?id))) { \n+            rec(global=false, idents=~[id.node], types=~[]) \n         }\n-        case (none[uint]) { ret p; }\n+        case (some(path_binding(_, ?a_pth))) { a_pth.node }\n+        case (some(expr_binding(_, ?expr))) {\n+            cx.span_fatal(expr.span, \"This argument is expanded as an \"\n+                          + \"path; it must be one.\")\n+        }\n+        case (none) { p }\n     }\n }\n \n \n-fn subst_expr(&ext_ctxt cx, &(@ast::expr)[] args, @vec[ident] param_names, \n-              &ast::expr_ e, ast_fold fld, \n-              fn(&ast::expr_, ast_fold) -> ast::expr_ orig) -> ast::expr_ {\n+fn subst_expr(&ext_ctxt cx, &(invk_binding)[] ibs, &ast::expr_ e, \n+              ast_fold fld, fn(&ast::expr_, ast_fold) -> ast::expr_ orig) \n+    -> ast::expr_ {\n     ret alt(e) {\n         case (expr_path(?p)){\n             // Don't substitute into qualified names.\n-            if (ivec::len(p.node.types) > 0u ||\n-                    ivec::len(p.node.idents) != 1u) { e }\n-            alt (position(p.node.idents.(0), *param_names)) {\n-                case (some[uint](?idx)) {\n-                    args.(idx).node\n+            if (ivec::len(p.node.types) > 0u || \n+                ivec::len(p.node.idents) != 1u) { e }\n+            alt (lookup(ibs, p.node.idents.(0))) {\n+                case (some(ident_binding(_, ?id))) { \n+                    expr_path(respan(id.span, \n+                                     rec(global=false, \n+                                         idents=~[id.node],types=~[])))\n                 }\n-                case (none[uint]) { e }\n+                case (some(path_binding(_, ?a_pth))) { expr_path(*a_pth) }\n+                case (some(expr_binding(_, ?a_exp))) { a_exp.node }\n+                case (none) { orig(e,fld) }\n             }\n         }\n         case (_) { orig(e,fld) }\n     }\n }\n \n+type pat_ext = rec(vec[@ast::expr] invk, @ast::expr body);\n+\n+// maybe box?\n+tag invk_binding {\n+    expr_binding(ident, @ast::expr);\n+    path_binding(ident, @ast::path);\n+    ident_binding(ident, ast::spanned[ident]);\n+}\n+\n+fn path_to_ident(&path pth) -> option::t[ident] {\n+    if (ivec::len(pth.node.idents) == 1u \n+        && ivec::len(pth.node.types) == 0u) {\n+        ret some(pth.node.idents.(0u));\n+    }\n+    ret none;\n+}\n \n fn add_new_extension(&ext_ctxt cx, span sp, &(@ast::expr)[] args,\n                      option::t[str] body) -> tup(str, syntax_extension) {\n-    if (ivec::len(args) < 2u) {\n-        cx.span_fatal(sp, \"malformed extension description\");\n+    let option::t[str] macro_name = none;\n+    let vec[pat_ext] pat_exts = [];\n+    for (@ast::expr arg in args) {\n+        alt(arg.node) {\n+            case(expr_vec(?elts, ?mut, ?seq_kind)) {\n+                \n+                if (len(elts) != 2u) {\n+                    cx.span_fatal((*arg).span, \n+                                  \"extension clause must consist of [\" + \n+                                  \"macro invocation, expansion body]\");\n+                }\n+                alt(elts.(0u).node) {\n+                    case(expr_ext(?pth, ?invk_args, ?body)) {\n+                        let str clause_name = alt(path_to_ident(pth)) {\n+                            case (some(?id)) { id }\n+                            case (none) {\n+                                cx.span_fatal\n+                                (elts.(0u).span,\n+                                 \"macro name must not be a path\")\n+                            }\n+                        };\n+                        if (macro_name == none) {\n+                            macro_name = some(clause_name);\n+                        } else if (macro_name != some(clause_name)) {\n+                            cx.span_fatal(elts.(0u).span, \"macros must have\"\n+                                          + \" only one name\");\n+                        }\n+                        pat_exts += [rec(invk=invk_args, body=elts.(1u))];\n+                    }\n+                    case(_) {\n+                        cx.span_fatal(elts.(0u).span, \"extension clause must\"\n+                                      + \" start with a macro invocation.\");\n+                    }\n+                }\n+            }\n+            case(_) {\n+                    cx.span_fatal((*arg).span, \"extension must be [clause, \"\n+                                  + \" ...]\");\n+            }\n+        }\n     }\n \n-    fn generic_extension(&ext_ctxt cx, span sp, &(@ast::expr)[] args,\n-                         option::t[str] body, @vec[ident] param_names,\n-                         @ast::expr dest_form) -> @ast::expr {\n-        if (ivec::len(args) != len(*param_names)) {\n-            cx.span_fatal(sp, #fmt(\"extension expects %u arguments, got %u\",\n-                                 len(*param_names), ivec::len(args)));\n+    auto ext = bind generic_extension(_,_,_,_,@pat_exts);\n+    \n+    ret tup(alt (macro_name) {\n+                case (some(?id)) { id }\n+                case (none) { \n+                    cx.span_fatal(sp, \"macro definition must have \"\n+                                  + \"at least one clause\")\n+                }\n+            },\n+            normal(ext));\n+\n+\n+    fn generic_extension(&ext_ctxt cx, span sp, &vec[@ast::expr] args,\n+                         option::t[str] body, @vec[pat_ext] clauses)\n+        -> @ast::expr {\n+\n+        /* returns a list of bindings, or none if the match fails. */\n+        fn match_invk(@ast::expr pattern, @ast::expr argument)\n+            -> option::t[vec[invk_binding]] {\n+            auto pat = pattern.node;\n+            auto arg = argument.node;\n+            ret alt (pat) {\n+                case (expr_vec(?p_elts, _, _)) {\n+                    alt (arg) {\n+                        case (expr_vec(?a_elts, _, _)) {\n+                            if (vec::len(p_elts) != vec::len(a_elts)) { \n+                                none[vec[invk_binding]]\n+                            }\n+                            let uint i = 0u;\n+                            let vec[invk_binding] res = [];\n+                            while (i < vec::len(p_elts)) {\n+                                alt (match_invk(p_elts.(i), a_elts.(i))) {\n+                                    case (some(?v)) { res += v; }\n+                                    case (none) { ret none; }\n+                                }\n+                                i += 1u;\n+                            }\n+                            some(res)\n+                        }\n+                        case (_) { none }\n+                    }\n+                }\n+                case (expr_path(?p_pth)) {\n+                    alt (path_to_ident(p_pth)) {\n+                        case (some(?p_id)) {\n+                            /* let's bind! */\n+                            alt (arg) {\n+                                case (expr_path(?a_pth)) {\n+                                    alt (path_to_ident(a_pth)) {\n+                                        case (some(?a_id)) {\n+                                            some([ident_binding\n+                                                  (p_id, respan(argument.span,\n+                                                                 a_id))])\n+                                        }\n+                                        case (none) {\n+                                            some([path_binding(p_id, @a_pth)])\n+                                        }\n+                                    }\n+                                }\n+                                case (_) {\n+                                    some([expr_binding(p_id, argument)])\n+                                }\n+                            }\n+                        }\n+                        // FIXME this still compares on internal spans\n+                        case (_) { if(pat == arg) { some([]) } else { none } }\n+                    }\n+                }\n+                // FIXME this still compares on internal spans\n+                case (_) { if (pat == arg) { some([]) } else { none } }\n+            }\n         }\n \n-        // FIXME: This binds to alias arguments.\n-        auto afp = default_ast_fold();\n-        auto f_pre = \n-            rec(fold_ident = bind subst_ident(cx, args, param_names, _, _),\n-                fold_path = bind subst_path(cx, args, param_names, _, _),\n-                fold_expr = bind subst_expr(cx, args, param_names, _, _,\n-                                            afp.fold_expr)\n+        for (pat_ext pe in *clauses) {\n+            if (vec::len(args) != vec::len(pe.invk)) { cont; }\n+            let uint i = 0u;\n+            let vec[invk_binding] bindings = [];\n+            while (i < vec::len(args)) {\n+                alt (match_invk(pe.invk.(i), args.(i))) {\n+                    case (some(?v)) { bindings += v; }\n+                    case (none) { cont }\n+                }\n+                i += 1u;\n+            }\n+            auto afp = default_ast_fold();\n+            auto f_pre =\n+                rec(fold_ident = bind subst_ident(cx, bindings, _, _),\n+                    fold_path = bind subst_path(cx, bindings, _, _),\n+                    fold_expr = bind subst_expr(cx, bindings, _, _,\n+                                                afp.fold_expr)\n                 with *afp);\n-        auto f = make_fold(f_pre);\n-        auto result = f.fold_expr(dest_form);\n-        dummy_out(f); //temporary: kill circular reference\n-        ret result;\n-        \n-    }\n-\n-    let vec[ident] param_names = vec::empty[ident]();\n-    let uint idx = 1u;\n-    while(1u+idx < ivec::len(args)) {\n-        param_names +=\n-            [expr_to_ident(cx, args.(idx),\n-                           \"this parameter name must be an identifier.\")];\n-        idx += 1u;\n+            auto f = make_fold(f_pre);\n+            auto result = f.fold_expr(pe.body);\n+            dummy_out(f); //temporary: kill circular reference\n+            ret result;\n+        }\n+        cx.span_fatal(sp, \"no clauses match macro invocation\");\n     }\n-\n-    ret tup(expr_to_str(cx, args.(0), \"first arg must be a literal string.\"),\n-            normal(bind generic_extension(_,_,_,_,@param_names,\n-                                          args.(ivec::len(args)-1u))));\n }\n \n "}, {"sha": "1487ff3e2e04626b84751439fc62ac34bfe9edf0", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=425732311af6d7a4f972dff04e1abb7db6a22f3b", "patch": "@@ -414,11 +414,11 @@ fn noop_fold_expr(&expr_ e, ast_fold fld) -> expr_ {\n         case (expr_path(?pth)) {\n             expr_path(fld.fold_path(pth))\n                 }\n-        case (expr_ext(?pth, ?args, ?body, ?expanded)) {\n+        case (expr_ext(?pth, ?args, ?body)) {\n             expr_ext(fld.fold_path(pth), ivec::map(fld.fold_expr, args),\n                      body, fld.fold_expr(expanded))\n                 }\n-        case (expr_fail(_)) { e }\n+        case (expr_fail(?e)) { expr_fail(option::map(fld.fold_expr, e)) }\n         case (expr_break()) { e }\n         case (expr_cont()) { e }\n         case (expr_ret(?e)) { "}, {"sha": "7a711b1dbfa8b188d75739946e1720d3ac02175e", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 49, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=425732311af6d7a4f972dff04e1abb7db6a22f3b", "patch": "@@ -50,7 +50,6 @@ type parser =\n         fn get_reader() -> lexer::reader ;\n         fn get_filemap() -> codemap::filemap ;\n         fn get_bad_expr_words() -> hashmap[str, ()] ;\n-        fn get_syntax_expanders() -> hashmap[str, ex::syntax_extension] ;\n         fn get_chpos() -> uint ;\n         fn get_id() -> ast::node_id ;\n         fn get_sess() -> parse_sess;\n@@ -82,8 +81,7 @@ fn new_parser(parse_sess sess, ast::crate_cfg cfg, lexer::reader rdr,\n                      mutable restriction restr,\n                      lexer::reader rdr,\n                      vec[op_spec] precs,\n-                     hashmap[str, ()] bad_words,\n-                     hashmap[str, ex::syntax_extension] syntax_expanders) {\n+                     hashmap[str, ()] bad_words) {\n         fn peek() -> token::token { ret tok; }\n         fn bump() {\n             // log rdr.get_filename()\n@@ -116,9 +114,6 @@ fn new_parser(parse_sess sess, ast::crate_cfg cfg, lexer::reader rdr,\n         fn get_reader() -> lexer::reader { ret rdr; }\n         fn get_filemap() -> codemap::filemap { ret rdr.get_filemap(); }\n         fn get_bad_expr_words() -> hashmap[str, ()] { ret bad_words; }\n-        fn get_syntax_expanders() -> hashmap[str, ex::syntax_extension] {\n-            ret syntax_expanders;\n-        }\n         fn get_chpos() -> uint { ret rdr.get_chpos(); }\n         fn get_id() -> ast::node_id { ret next_node_id(sess); }\n         fn get_sess() -> parse_sess { ret sess; }\n@@ -129,8 +124,7 @@ fn new_parser(parse_sess sess, ast::crate_cfg cfg, lexer::reader rdr,\n     auto npos = rdr.get_chpos();\n     ret stdio_parser(sess, cfg, ftype, lexer::next_token(rdr),\n                      npos, npos, npos, UNRESTRICTED, rdr,\n-                     prec_table(), bad_expr_word_table(),\n-                     ex::syntax_expander_table());\n+                     prec_table(), bad_expr_word_table());\n }\n \n // These are the words that shouldn't be allowed as value identifiers,\n@@ -1028,38 +1022,7 @@ fn parse_syntax_ext_naked(&parser p, uint lo) -> @ast::expr {\n     auto es = parse_seq_ivec(token::LPAREN, token::RPAREN,\n                              some(token::COMMA), parse_expr, p);\n     auto hi = es.span.hi;\n-    auto ext_span = rec(lo=lo, hi=hi);\n-    auto ex = expand_syntax_ext(p, ext_span, pth, es.node, none);\n-    ret mk_expr(p, lo, hi, ex);\n-}\n-\n-/*\n- * FIXME: This is a crude approximation of the syntax-extension system,\n- * for purposes of prototyping and/or hard-wiring any extensions we\n- * wish to use while bootstrapping. The eventual aim is to permit\n- * loading rust crates to process extensions.\n- */\n-fn expand_syntax_ext(&parser p, span sp, &ast::path path,\n-                     &(@ast::expr)[] args, option::t[str] body) ->\n-   ast::expr_ {\n-    assert (ivec::len(path.node.idents) > 0u);\n-    auto extname = path.node.idents.(0);\n-    alt (p.get_syntax_expanders().find(extname)) {\n-        case (none) { p.fatal(\"unknown syntax expander: '\" + extname + \"'\"); }\n-        case (some(ex::normal(?ext))) {\n-            auto ext_cx = ex::mk_ctxt(p.get_sess());\n-            ret ast::expr_ext(path, args, body, ext(ext_cx, sp, args, body));\n-        }\n-        // because we have expansion inside parsing, new macros are only\n-        // visible further down the file\n-        case (some(ex::macro_defining(?ext))) {\n-            auto ext_cx = ex::mk_ctxt(p.get_sess());\n-            auto name_and_extension = ext(ext_cx, sp, args, body);\n-            p.get_syntax_expanders().insert(name_and_extension._0,\n-                                            name_and_extension._1);\n-            ret ast::expr_tup(~[]);\n-        }\n-    }\n+    ret mk_expr(p, lo, hi, ast::expr_ext(pth, es.node, none));\n }\n \n fn parse_self_method(&parser p) -> @ast::expr {\n@@ -1698,7 +1661,7 @@ fn stmt_ends_with_semi(&ast::stmt stmt) -> bool {\n                 case (ast::expr_field(_, _)) { true }\n                 case (ast::expr_index(_, _)) { true }\n                 case (ast::expr_path(_)) { true }\n-                case (ast::expr_ext(_, _, _, _)) { true }\n+                case (ast::expr_ext(_, _, _)) { true }\n                 case (ast::expr_fail(_)) { true }\n                 case (ast::expr_break) { true }\n                 case (ast::expr_cont) { true }\n@@ -2443,10 +2406,9 @@ fn parse_native_view(&parser p) -> (@ast::view_item)[] {\n }\n \n fn parse_crate_from_source_file(&str input, &ast::crate_cfg cfg,\n-                                &codemap::codemap cm) -> @ast::crate {\n-    auto sess = @rec(cm=cm, mutable next_id=0);\n+                                &parse_sess sess) -> @ast::crate {\n     auto p = new_parser_from_file(sess, cfg, input, 0u);\n-    ret parse_crate_mod(p, cfg);\n+    ret parse_crate_mod(p, cfg, sess);\n }\n \n fn parse_crate_from_source_str(&str name, &str source, &ast::crate_cfg cfg,\n@@ -2458,12 +2420,12 @@ fn parse_crate_from_source_str(&str name, &str source, &ast::crate_cfg cfg,\n     auto itr = @interner::mk(str::hash, str::eq);\n     auto rdr = lexer::new_reader(sess.cm, source, filemap, itr);\n     auto p = new_parser(sess, cfg, rdr, ftype);\n-    ret parse_crate_mod(p, cfg);\n+    ret parse_crate_mod(p, cfg, sess);\n }\n \n // Parses a source module as a crate\n-fn parse_crate_mod(&parser p, &ast::crate_cfg cfg) -> @ast::crate {\n-\n+fn parse_crate_mod(&parser p, &ast::crate_cfg cfg, parse_sess sess) \n+    -> @ast::crate {\n     auto lo = p.get_lo_pos();\n     auto crate_attrs = parse_inner_attrs_and_next(p);\n     auto first_item_outer_attrs = crate_attrs._1;\n@@ -2570,8 +2532,7 @@ fn parse_crate_directives(&parser p, token::token term,\n }\n \n fn parse_crate_from_crate_file(&str input, &ast::crate_cfg cfg,\n-                               &codemap::codemap cm) -> @ast::crate {\n-    auto sess = @rec(cm=cm, mutable next_id=0);\n+                               &parse_sess sess) -> @ast::crate {\n     auto p = new_parser_from_file(sess, cfg, input, 0u);\n     auto lo = p.get_lo_pos();\n     auto prefix = std::fs::dirname(p.get_filemap().name);"}, {"sha": "9566fef32e6cd9f148ef95eb3aae642ab3e21e7a", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=425732311af6d7a4f972dff04e1abb7db6a22f3b", "patch": "@@ -961,7 +961,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             print_expr(s, expr);\n             pclose(s);\n         }\n-        case (ast::expr_ext(?path, ?args, ?body, _)) {\n+        case (ast::expr_ext(?path, ?args, ?body)) {\n             word(s.s, \"#\");\n             print_path(s, path);\n             if (ivec::len(args) > 0u) {"}, {"sha": "b1d928939efaa69f8e0bd8c11eb190f1fafaa3f1", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=425732311af6d7a4f972dff04e1abb7db6a22f3b", "patch": "@@ -362,8 +362,10 @@ fn visit_expr[E](&@expr ex, &E e, &vt[E] v) {\n         case (expr_path(?p)) {\n             for (@ty tp in p.node.types) { v.visit_ty(tp, e, v); }\n         }\n-        case (expr_ext(_, _, _, ?expansion)) {\n-            v.visit_expr(expansion, e, v);\n+        case (expr_ext(_, ?args, _)) {\n+            for(@ast::expr arg in args) {\n+                vt(v).visit_expr(arg, e, v);\n+            }\n         }\n         case (expr_fail(?eo)) {\n             visit_expr_opt(eo, e, v);"}, {"sha": "1902c5e69a99ac75dd6f165853a499dac2f6693c", "filename": "src/comp/syntax/walk.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fsyntax%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Fcomp%2Fsyntax%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fwalk.rs?ref=425732311af6d7a4f972dff04e1abb7db6a22f3b", "patch": "@@ -367,10 +367,10 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n         case (ast::expr_path(?p)) {\n             for (@ast::ty tp in p.node.types) { walk_ty(v, tp); }\n         }\n-        case (ast::expr_ext(_, ?args, ?body, ?expansion)) {\n-            // Only walk expansion, not args/body.\n-\n-            walk_expr(v, expansion);\n+        case (ast::expr_ext(_, ?args, _)) {\n+            for (@ast::expr e in args) {\n+                walk_expr(v, e);\n+            }\n         }\n         case (ast::expr_fail(?eo)) { walk_expr_opt(v, eo); }\n         case (ast::expr_break) { }"}, {"sha": "a48413af656970616b585c50e1d3ab0944ea2c70", "filename": "src/test/compile-fail/macro-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs?ref=425732311af6d7a4f972dff04e1abb7db6a22f3b", "patch": "@@ -1,6 +1,6 @@\n //error-pattern:expanded as an identifier\n fn main() {\n-  #macro(\"mylambda\", x, body, {fn f(int x) -> int {ret body}; f});\n+  #macro([#mylambda(x, body), {fn f(int x) -> int {ret body}; f}]);\n   \n   assert(#mylambda(y*1, y*2)(8) == 16);\n }\n\\ No newline at end of file"}, {"sha": "4ce021a9d746aa3b90133f30716a004f42dbca94", "filename": "src/test/compile-fail/macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Ftest%2Fcompile-fail%2Fmacro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Ftest%2Fcompile-fail%2Fmacro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro.rs?ref=425732311af6d7a4f972dff04e1abb7db6a22f3b", "patch": "@@ -1,7 +1,7 @@\n-//error-pattern:expects 0 arguments, got 16\n+//error-pattern:no clauses match\n \n fn main() {\n-  #macro(\"trivial\", 1*2*4*2*1);\n+  #macro([#trivial(), 1*2*4*2*1]);\n   \n   assert(#trivial(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16) == 16);\n }"}, {"sha": "7d07b19a08519f02883b003f935f8c65fec085d5", "filename": "src/test/run-pass/macro-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Ftest%2Frun-pass%2Fmacro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Ftest%2Frun-pass%2Fmacro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-2.rs?ref=425732311af6d7a4f972dff04e1abb7db6a22f3b", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-  #macro(\"mylambda\", x, body, {fn f(int x) -> int {ret body}; f});\n+  #macro([#mylambda(x,body), {fn f(int x) -> int { ret body }; f}]);\n   \n   assert(#mylambda(y,y*2)(8) == 16);\n }\n\\ No newline at end of file"}, {"sha": "6b48a9a1bcb9852dc8bff2146e7ec1783a824e8a", "filename": "src/test/run-pass/macro-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Ftest%2Frun-pass%2Fmacro-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Ftest%2Frun-pass%2Fmacro-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-3.rs?ref=425732311af6d7a4f972dff04e1abb7db6a22f3b", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-  #macro(\"trivial\", 1*2*4*2*1);\n+  #macro([#trivial(), 1*2*4*2*1]);\n   \n   assert(#trivial() == 16);\n }"}, {"sha": "3618228b1914f5199820785557c2166a8234e866", "filename": "src/test/run-pass/macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Ftest%2Frun-pass%2Fmacro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/425732311af6d7a4f972dff04e1abb7db6a22f3b/src%2Ftest%2Frun-pass%2Fmacro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro.rs?ref=425732311af6d7a4f972dff04e1abb7db6a22f3b", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n-  #macro(\"m1\", a, a*4);\n+  #macro([#m1(a), a*4]);\n   assert (#m1(2) == 8);  \n }\n\\ No newline at end of file"}]}