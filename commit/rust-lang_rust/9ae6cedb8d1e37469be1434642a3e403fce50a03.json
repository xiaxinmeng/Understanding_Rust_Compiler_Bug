{"sha": "9ae6cedb8d1e37469be1434642a3e403fce50a03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhZTZjZWRiOGQxZTM3NDY5YmUxNDM0NjQyYTNlNDAzZmNlNTBhMDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-23T18:28:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-23T18:28:33Z"}, "message": "Auto merge of #67560 - Centril:rollup-fzdpu9c, r=Centril\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #67233 (Add PartialEq and Eq to Cursor)\n - #67466 (Require const stability attributes on intrinsics to be able to use them in constant contexts)\n - #67507 (Remove mem::uninitalized from tests)\n - #67527 (Results show too much)\n - #67536 (Move `{hir::lowering -> hir}::is_range_literal`)\n - #67538 (Improve diagnostics for invalid assignment)\n - #67546 (Fix ICE in mir interpretation)\n - #67559 (Document that calling Drop, even after it panics, is UB)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "94ea2d34cd99239633126bd50f0f0a5663e233b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94ea2d34cd99239633126bd50f0f0a5663e233b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ae6cedb8d1e37469be1434642a3e403fce50a03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ae6cedb8d1e37469be1434642a3e403fce50a03", "html_url": "https://github.com/rust-lang/rust/commit/9ae6cedb8d1e37469be1434642a3e403fce50a03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ae6cedb8d1e37469be1434642a3e403fce50a03/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a916ac22b9f7f1f0f7aba0a41a789b3ecd765018", "url": "https://api.github.com/repos/rust-lang/rust/commits/a916ac22b9f7f1f0f7aba0a41a789b3ecd765018", "html_url": "https://github.com/rust-lang/rust/commit/a916ac22b9f7f1f0f7aba0a41a789b3ecd765018"}, {"sha": "68a9a2d64888be73fda2d00ea1f5c121bc08164b", "url": "https://api.github.com/repos/rust-lang/rust/commits/68a9a2d64888be73fda2d00ea1f5c121bc08164b", "html_url": "https://github.com/rust-lang/rust/commit/68a9a2d64888be73fda2d00ea1f5c121bc08164b"}], "stats": {"total": 988, "additions": 619, "deletions": 369}, "files": [{"sha": "502090731f4a159f04c25151a60f17721c63ced6", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1,6 +1,22 @@\n //! Compiler intrinsics.\n //!\n //! The corresponding definitions are in `librustc_codegen_llvm/intrinsic.rs`.\n+//! The corresponding const implementations are in `librustc_mir/interpret/intrinsics.rs`\n+//!\n+//! # Const intrinsics\n+//!\n+//! Note: any changes to the constness of intrinsics should be discussed with the language team.\n+//! This includes changes in the stability of the constness.\n+//!\n+//! In order to make an intrinsic usable at compile-time, one needs to copy the implementation\n+//! from https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs to\n+//! `librustc_mir/interpret/intrinsics.rs` and add a\n+//! `#[rustc_const_unstable(feature = \"foo\", issue = \"01234\")]` to the intrinsic.\n+//!\n+//! If an intrinsic is supposed to be used from a `const fn` with a `rustc_const_stable` attribute,\n+//! the intrinsic's attribute must be `rustc_const_stable`, too. Such a change should not be done\n+//! without T-lang consulation, because it bakes a feature into the language that cannot be\n+//! replicated in user code without compiler support.\n //!\n //! # Volatiles\n //!\n@@ -671,14 +687,17 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`std::mem::size_of`](../../std/mem/fn.size_of.html).\n+    #[rustc_const_stable(feature = \"const_size_of\", since = \"1.40.0\")]\n     pub fn size_of<T>() -> usize;\n \n     /// Moves a value to an uninitialized memory location.\n     ///\n     /// Drop glue is not run on the destination.\n     pub fn move_val_init<T>(dst: *mut T, src: T);\n \n+    #[rustc_const_stable(feature = \"const_min_align_of\", since = \"1.40.0\")]\n     pub fn min_align_of<T>() -> usize;\n+    #[rustc_const_unstable(feature = \"const_pref_align_of\", issue = \"0\")]\n     pub fn pref_align_of<T>() -> usize;\n \n     /// The size of the referenced value in bytes.\n@@ -689,18 +708,21 @@ extern \"rust-intrinsic\" {\n     pub fn min_align_of_val<T: ?Sized>(_: &T) -> usize;\n \n     /// Gets a static string slice containing the name of a type.\n+    #[rustc_const_unstable(feature = \"const_type_name\", issue = \"0\")]\n     pub fn type_name<T: ?Sized>() -> &'static str;\n \n     /// Gets an identifier which is globally unique to the specified type. This\n     /// function will return the same value for a type regardless of whichever\n     /// crate it is invoked in.\n+    #[rustc_const_unstable(feature = \"const_type_id\", issue = \"0\")]\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n \n     /// A guard for unsafe functions that cannot ever be executed if `T` is uninhabited:\n     /// This will statically either panic, or do nothing.\n     pub fn panic_if_uninhabited<T>();\n \n     /// Gets a reference to a static `Location` indicating where it was called.\n+    #[rustc_const_unstable(feature = \"const_caller_location\", issue = \"47809\")]\n     pub fn caller_location() -> &'static crate::panic::Location<'static>;\n \n     /// Creates a value initialized to zero.\n@@ -957,6 +979,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`std::mem::needs_drop`](../../std/mem/fn.needs_drop.html).\n+    #[rustc_const_stable(feature = \"const_needs_drop\", since = \"1.40.0\")]\n     pub fn needs_drop<T>() -> bool;\n \n     /// Calculates the offset from a pointer.\n@@ -1154,6 +1177,7 @@ extern \"rust-intrinsic\" {\n     pub fn float_to_int_approx_unchecked<Float, Int>(value: Float) -> Int;\n \n     /// Returns the number of bits set in an integer type `T`\n+    #[rustc_const_stable(feature = \"const_ctpop\", since = \"1.40.0\")]\n     pub fn ctpop<T>(x: T) -> T;\n \n     /// Returns the number of leading unset bits (zeroes) in an integer type `T`.\n@@ -1181,6 +1205,7 @@ extern \"rust-intrinsic\" {\n     /// let num_leading = ctlz(x);\n     /// assert_eq!(num_leading, 16);\n     /// ```\n+    #[rustc_const_stable(feature = \"const_ctlz\", since = \"1.40.0\")]\n     pub fn ctlz<T>(x: T) -> T;\n \n     /// Like `ctlz`, but extra-unsafe as it returns `undef` when\n@@ -1197,6 +1222,7 @@ extern \"rust-intrinsic\" {\n     /// let num_leading = unsafe { ctlz_nonzero(x) };\n     /// assert_eq!(num_leading, 3);\n     /// ```\n+    #[rustc_const_unstable(feature = \"constctlz\", issue = \"0\")]\n     pub fn ctlz_nonzero<T>(x: T) -> T;\n \n     /// Returns the number of trailing unset bits (zeroes) in an integer type `T`.\n@@ -1224,6 +1250,7 @@ extern \"rust-intrinsic\" {\n     /// let num_trailing = cttz(x);\n     /// assert_eq!(num_trailing, 16);\n     /// ```\n+    #[rustc_const_stable(feature = \"const_cttz\", since = \"1.40.0\")]\n     pub fn cttz<T>(x: T) -> T;\n \n     /// Like `cttz`, but extra-unsafe as it returns `undef` when\n@@ -1240,30 +1267,36 @@ extern \"rust-intrinsic\" {\n     /// let num_trailing = unsafe { cttz_nonzero(x) };\n     /// assert_eq!(num_trailing, 3);\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_cttz\", issue = \"0\")]\n     pub fn cttz_nonzero<T>(x: T) -> T;\n \n     /// Reverses the bytes in an integer type `T`.\n+    #[rustc_const_stable(feature = \"const_bswap\", since = \"1.40.0\")]\n     pub fn bswap<T>(x: T) -> T;\n \n     /// Reverses the bits in an integer type `T`.\n+    #[rustc_const_stable(feature = \"const_bitreverse\", since = \"1.40.0\")]\n     pub fn bitreverse<T>(x: T) -> T;\n \n     /// Performs checked integer addition.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_add` method. For example,\n     /// [`std::u32::overflowing_add`](../../std/primitive.u32.html#method.overflowing_add)\n+    #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     pub fn add_with_overflow<T>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer subtraction\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_sub` method. For example,\n     /// [`std::u32::overflowing_sub`](../../std/primitive.u32.html#method.overflowing_sub)\n+    #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     pub fn sub_with_overflow<T>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer multiplication\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_mul` method. For example,\n     /// [`std::u32::overflowing_mul`](../../std/primitive.u32.html#method.overflowing_mul)\n+    #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     pub fn mul_with_overflow<T>(x: T, y: T) -> (T, bool);\n \n     /// Performs an exact division, resulting in undefined behavior where\n@@ -1279,9 +1312,11 @@ extern \"rust-intrinsic\" {\n \n     /// Performs an unchecked left shift, resulting in undefined behavior when\n     /// y < 0 or y >= N, where N is the width of T in bits.\n+    #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n     pub fn unchecked_shl<T>(x: T, y: T) -> T;\n     /// Performs an unchecked right shift, resulting in undefined behavior when\n     /// y < 0 or y >= N, where N is the width of T in bits.\n+    #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n     pub fn unchecked_shr<T>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked addition, resulting in\n@@ -1300,39 +1335,46 @@ extern \"rust-intrinsic\" {\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `rotate_left` method. For example,\n     /// [`std::u32::rotate_left`](../../std/primitive.u32.html#method.rotate_left)\n+    #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n     pub fn rotate_left<T>(x: T, y: T) -> T;\n \n     /// Performs rotate right.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `rotate_right` method. For example,\n     /// [`std::u32::rotate_right`](../../std/primitive.u32.html#method.rotate_right)\n+    #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n     pub fn rotate_right<T>(x: T, y: T) -> T;\n \n     /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_add` method. For example,\n     /// [`std::u32::wrapping_add`](../../std/primitive.u32.html#method.wrapping_add)\n+    #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     pub fn wrapping_add<T>(a: T, b: T) -> T;\n     /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_sub` method. For example,\n     /// [`std::u32::wrapping_sub`](../../std/primitive.u32.html#method.wrapping_sub)\n+    #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     pub fn wrapping_sub<T>(a: T, b: T) -> T;\n     /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_mul` method. For example,\n     /// [`std::u32::wrapping_mul`](../../std/primitive.u32.html#method.wrapping_mul)\n+    #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     pub fn wrapping_mul<T>(a: T, b: T) -> T;\n \n     /// Computes `a + b`, while saturating at numeric bounds.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `saturating_add` method. For example,\n     /// [`std::u32::saturating_add`](../../std/primitive.u32.html#method.saturating_add)\n+    #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n     pub fn saturating_add<T>(a: T, b: T) -> T;\n     /// Computes `a - b`, while saturating at numeric bounds.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `saturating_sub` method. For example,\n     /// [`std::u32::saturating_sub`](../../std/primitive.u32.html#method.saturating_sub)\n+    #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n     pub fn saturating_sub<T>(a: T, b: T) -> T;\n \n     /// Returns the value of the discriminant for the variant in 'v',\n@@ -1354,6 +1396,7 @@ extern \"rust-intrinsic\" {\n     pub fn nontemporal_store<T>(ptr: *mut T, val: T);\n \n     /// See documentation of `<*const T>::offset_from` for details.\n+    #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"0\")]\n     pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize;\n \n     /// Internal hook used by Miri to implement unwinding."}, {"sha": "d12aebb87b975a5a58e135881e47198feace7ce8", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -127,6 +127,8 @@\n #![feature(maybe_uninit_slice)]\n #![feature(external_doc)]\n #![feature(associated_type_bounds)]\n+#![feature(const_type_id)]\n+#![feature(const_caller_location)]\n \n #[prelude_import]\n #[allow(unused)]"}, {"sha": "1a3d338fb98767401bff787f1cf484d38ef4baf6", "filename": "src/libcore/macros/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibcore%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibcore%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros%2Fmod.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -5,6 +5,7 @@\n     // the `caller_location` intrinsic, but once  `#[track_caller]` is implemented,\n     // `panicking::{panic, panic_fmt}` can use that instead of a `Location` argument.\n     core_intrinsics,\n+    const_caller_location,\n )]\n #[stable(feature = \"core\", since = \"1.6.0\")]\n macro_rules! panic {"}, {"sha": "5233b475c4646fa5767d88ad75f6f72931154aa8", "filename": "src/libcore/ops/drop.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibcore%2Fops%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibcore%2Fops%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fdrop.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -99,9 +99,15 @@ pub trait Drop {\n     /// Given that a [`panic!`] will call `drop` as it unwinds, any [`panic!`]\n     /// in a `drop` implementation will likely abort.\n     ///\n+    /// Note that even if this panics, the value is considered to be dropped;\n+    /// you must not cause `drop` to be called again. This is normally automatically\n+    /// handled by the compiler, but when using unsafe code, can sometimes occur\n+    /// unintentionally, particularly when using [`std::ptr::drop_in_place`].\n+    ///\n     /// [E0040]: ../../error-index.html#E0040\n     /// [`panic!`]: ../macro.panic.html\n     /// [`std::mem::drop`]: ../../std/mem/fn.drop.html\n+    /// [`std::ptr::drop_in_place`]: ../../std/ptr/fn.drop_in_place.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn drop(&mut self);\n }"}, {"sha": "a7a8673d49eb1d020796907592ea9ce0be2299c8", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1043,9 +1043,9 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n         }\n-        ExprKind::Assign(ref left_hand_expression, ref right_hand_expression) => {\n-            visitor.visit_expr(right_hand_expression);\n-            visitor.visit_expr(left_hand_expression)\n+        ExprKind::Assign(ref lhs, ref rhs, _) => {\n+            visitor.visit_expr(rhs);\n+            visitor.visit_expr(lhs)\n         }\n         ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n             visitor.visit_expr(right_expression);"}, {"sha": "a702eb839845e4aa55fa4853cd22211d1a81b557", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -3437,65 +3437,3 @@ fn body_ids(bodies: &BTreeMap<hir::BodyId, hir::Body<'hir>>) -> Vec<hir::BodyId>\n     body_ids.sort_by_key(|b| bodies[b].value.span);\n     body_ids\n }\n-\n-/// Checks if the specified expression is a built-in range literal.\n-/// (See: `LoweringContext::lower_expr()`).\n-pub fn is_range_literal(sess: &Session, expr: &hir::Expr) -> bool {\n-    use hir::{Path, QPath, ExprKind, TyKind};\n-\n-    // Returns whether the given path represents a (desugared) range,\n-    // either in std or core, i.e. has either a `::std::ops::Range` or\n-    // `::core::ops::Range` prefix.\n-    fn is_range_path(path: &Path) -> bool {\n-        let segs: Vec<_> = path.segments.iter().map(|seg| seg.ident.to_string()).collect();\n-        let segs: Vec<_> = segs.iter().map(|seg| &**seg).collect();\n-\n-        // \"{{root}}\" is the equivalent of `::` prefix in `Path`.\n-        if let [\"{{root}}\", std_core, \"ops\", range] = segs.as_slice() {\n-            (*std_core == \"std\" || *std_core == \"core\") && range.starts_with(\"Range\")\n-        } else {\n-            false\n-        }\n-    };\n-\n-    // Check whether a span corresponding to a range expression is a\n-    // range literal, rather than an explicit struct or `new()` call.\n-    fn is_lit(sess: &Session, span: &Span) -> bool {\n-        let source_map = sess.source_map();\n-        let end_point = source_map.end_point(*span);\n-\n-        if let Ok(end_string) = source_map.span_to_snippet(end_point) {\n-            !(end_string.ends_with(\"}\") || end_string.ends_with(\")\"))\n-        } else {\n-            false\n-        }\n-    };\n-\n-    match expr.kind {\n-        // All built-in range literals but `..=` and `..` desugar to `Struct`s.\n-        ExprKind::Struct(ref qpath, _, _) => {\n-            if let QPath::Resolved(None, ref path) = **qpath {\n-                return is_range_path(&path) && is_lit(sess, &expr.span);\n-            }\n-        }\n-\n-        // `..` desugars to its struct path.\n-        ExprKind::Path(QPath::Resolved(None, ref path)) => {\n-            return is_range_path(&path) && is_lit(sess, &expr.span);\n-        }\n-\n-        // `..=` desugars into `::std::ops::RangeInclusive::new(...)`.\n-        ExprKind::Call(ref func, _) => {\n-            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref segment)) = func.kind {\n-                if let TyKind::Path(QPath::Resolved(None, ref path)) = ty.kind {\n-                    let new_call = segment.ident.name == sym::new;\n-                    return is_range_path(&path) && is_lit(sess, &expr.span) && new_call;\n-                }\n-            }\n-        }\n-\n-        _ => {}\n-    }\n-\n-    false\n-}"}, {"sha": "8311b9168e4553b0c6ac84381c7903ac1599b469", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -122,8 +122,8 @@ impl LoweringContext<'_, '_> {\n                 self.lower_block(blk, opt_label.is_some()),\n                 self.lower_label(opt_label),\n             ),\n-            ExprKind::Assign(ref el, ref er) => {\n-                hir::ExprKind::Assign(P(self.lower_expr(el)), P(self.lower_expr(er)))\n+            ExprKind::Assign(ref el, ref er, span) => {\n+                hir::ExprKind::Assign(P(self.lower_expr(el)), P(self.lower_expr(er)), span)\n             }\n             ExprKind::AssignOp(op, ref el, ref er) => hir::ExprKind::AssignOp(\n                 self.lower_binop(op),\n@@ -994,8 +994,11 @@ impl LoweringContext<'_, '_> {\n             let (val_pat, val_pat_hid) = self.pat_ident(pat.span, val_ident);\n             let val_expr = P(self.expr_ident(pat.span, val_ident, val_pat_hid));\n             let next_expr = P(self.expr_ident(pat.span, next_ident, next_pat_hid));\n-            let assign =\n-                P(self.expr(pat.span, hir::ExprKind::Assign(next_expr, val_expr), ThinVec::new()));\n+            let assign = P(self.expr(\n+                pat.span,\n+                hir::ExprKind::Assign(next_expr, val_expr, pat.span),\n+                ThinVec::new(),\n+            ));\n             let some_pat = self.pat_some(pat.span, val_pat);\n             self.arm(some_pat, assign)\n         };"}, {"sha": "bf95324d776dc12fe0d87b1368781237f3b0eeb6", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 66, "deletions": 3, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -29,10 +29,10 @@ use syntax::ast::{AttrVec, Attribute, FloatTy, IntTy, Label, LitKind, StrStyle,\n pub use syntax::ast::{BorrowKind, ImplPolarity, IsAuto};\n pub use syntax::ast::{CaptureBy, Constness, Movability, Mutability, Unsafety};\n use syntax::attr::{InlineAttr, OptimizeAttr};\n-use syntax::source_map::Spanned;\n-use syntax::symbol::{kw, Symbol};\n use syntax::tokenstream::TokenStream;\n use syntax::util::parser::ExprPrecedence;\n+use syntax_pos::source_map::{SourceMap, Spanned};\n+use syntax_pos::symbol::{kw, sym, Symbol};\n use syntax_pos::{MultiSpan, Span, DUMMY_SP};\n \n /// HIR doesn't commit to a concrete storage type and has its own alias for a vector.\n@@ -1564,6 +1564,68 @@ impl fmt::Debug for Expr {\n     }\n }\n \n+/// Checks if the specified expression is a built-in range literal.\n+/// (See: `LoweringContext::lower_expr()`).\n+///\n+/// FIXME(#60607): This function is a hack. If and when we have `QPath::Lang(...)`,\n+/// we can use that instead as simpler, more reliable mechanism, as opposed to using `SourceMap`.\n+pub fn is_range_literal(sm: &SourceMap, expr: &Expr) -> bool {\n+    // Returns whether the given path represents a (desugared) range,\n+    // either in std or core, i.e. has either a `::std::ops::Range` or\n+    // `::core::ops::Range` prefix.\n+    fn is_range_path(path: &Path) -> bool {\n+        let segs: Vec<_> = path.segments.iter().map(|seg| seg.ident.to_string()).collect();\n+        let segs: Vec<_> = segs.iter().map(|seg| &**seg).collect();\n+\n+        // \"{{root}}\" is the equivalent of `::` prefix in `Path`.\n+        if let [\"{{root}}\", std_core, \"ops\", range] = segs.as_slice() {\n+            (*std_core == \"std\" || *std_core == \"core\") && range.starts_with(\"Range\")\n+        } else {\n+            false\n+        }\n+    };\n+\n+    // Check whether a span corresponding to a range expression is a\n+    // range literal, rather than an explicit struct or `new()` call.\n+    fn is_lit(sm: &SourceMap, span: &Span) -> bool {\n+        let end_point = sm.end_point(*span);\n+\n+        if let Ok(end_string) = sm.span_to_snippet(end_point) {\n+            !(end_string.ends_with(\"}\") || end_string.ends_with(\")\"))\n+        } else {\n+            false\n+        }\n+    };\n+\n+    match expr.kind {\n+        // All built-in range literals but `..=` and `..` desugar to `Struct`s.\n+        ExprKind::Struct(ref qpath, _, _) => {\n+            if let QPath::Resolved(None, ref path) = **qpath {\n+                return is_range_path(&path) && is_lit(sm, &expr.span);\n+            }\n+        }\n+\n+        // `..` desugars to its struct path.\n+        ExprKind::Path(QPath::Resolved(None, ref path)) => {\n+            return is_range_path(&path) && is_lit(sm, &expr.span);\n+        }\n+\n+        // `..=` desugars into `::std::ops::RangeInclusive::new(...)`.\n+        ExprKind::Call(ref func, _) => {\n+            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref segment)) = func.kind {\n+                if let TyKind::Path(QPath::Resolved(None, ref path)) = ty.kind {\n+                    let new_call = segment.ident.name == sym::new;\n+                    return is_range_path(&path) && is_lit(sm, &expr.span) && new_call;\n+                }\n+            }\n+        }\n+\n+        _ => {}\n+    }\n+\n+    false\n+}\n+\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ExprKind {\n     /// A `box x` expression.\n@@ -1628,7 +1690,8 @@ pub enum ExprKind {\n     Block(P<Block>, Option<Label>),\n \n     /// An assignment (e.g., `a = foo()`).\n-    Assign(P<Expr>, P<Expr>),\n+    /// The `Span` argument is the span of the `=` token.\n+    Assign(P<Expr>, P<Expr>, Span),\n     /// An assignment with an operator.\n     ///\n     /// E.g., `a += 1`."}, {"sha": "2f3b6f82ee5ee206e22cf3b2a3453c26fefd7668", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1289,7 +1289,7 @@ impl<'a> State<'a> {\n                 self.ibox(0);\n                 self.print_block(&blk);\n             }\n-            hir::ExprKind::Assign(ref lhs, ref rhs) => {\n+            hir::ExprKind::Assign(ref lhs, ref rhs, _) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(&lhs, prec + 1);\n                 self.s.space();\n@@ -2265,7 +2265,7 @@ fn contains_exterior_struct_lit(value: &hir::Expr) -> bool {\n     match value.kind {\n         hir::ExprKind::Struct(..) => true,\n \n-        hir::ExprKind::Assign(ref lhs, ref rhs)\n+        hir::ExprKind::Assign(ref lhs, ref rhs, _)\n         | hir::ExprKind::AssignOp(_, ref lhs, ref rhs)\n         | hir::ExprKind::Binary(_, ref lhs, ref rhs) => {\n             // `X { y: 1 } + X { y: 2 }`"}, {"sha": "7fe950ef7b7f6050268fcf4bd69a92e836f26070", "filename": "src/librustc/ty/constness.rs", "status": "modified", "additions": 2, "deletions": 96, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc%2Fty%2Fconstness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc%2Fty%2Fconstness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fconstness.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -2,7 +2,7 @@ use crate::ty::query::Providers;\n use crate::hir::def_id::DefId;\n use crate::hir;\n use crate::ty::TyCtxt;\n-use syntax_pos::symbol::{sym, Symbol};\n+use syntax_pos::symbol::Symbol;\n use rustc_target::spec::abi::Abi;\n use crate::hir::map::blocks::FnLikeNode;\n use syntax::attr;\n@@ -41,51 +41,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    /// Returns `true` if the `def_id` refers to an intrisic which we've whitelisted\n-    /// for being called from stable `const fn`s (`min_const_fn`).\n-    ///\n-    /// Adding more intrinsics requires sign-off from @rust-lang/lang.\n-    ///\n-    /// This list differs from the list in `is_const_intrinsic` in the sense that any item on this\n-    /// list must be on the `is_const_intrinsic` list, too, because if an intrinsic is callable from\n-    /// stable, it must be callable at all.\n-    fn is_intrinsic_min_const_fn(self, def_id: DefId) -> bool {\n-        match self.item_name(def_id) {\n-            | sym::size_of\n-            | sym::min_align_of\n-            | sym::needs_drop\n-            // Arithmetic:\n-            | sym::add_with_overflow // ~> .overflowing_add\n-            | sym::sub_with_overflow // ~> .overflowing_sub\n-            | sym::mul_with_overflow // ~> .overflowing_mul\n-            | sym::wrapping_add // ~> .wrapping_add\n-            | sym::wrapping_sub // ~> .wrapping_sub\n-            | sym::wrapping_mul // ~> .wrapping_mul\n-            | sym::saturating_add // ~> .saturating_add\n-            | sym::saturating_sub // ~> .saturating_sub\n-            | sym::unchecked_shl // ~> .wrapping_shl\n-            | sym::unchecked_shr // ~> .wrapping_shr\n-            | sym::rotate_left // ~> .rotate_left\n-            | sym::rotate_right // ~> .rotate_right\n-            | sym::ctpop // ~> .count_ones\n-            | sym::ctlz // ~> .leading_zeros\n-            | sym::cttz // ~> .trailing_zeros\n-            | sym::bswap // ~> .swap_bytes\n-            | sym::bitreverse // ~> .reverse_bits\n-            => true,\n-            _ => false,\n-        }\n-    }\n-\n     /// Returns `true` if this function must conform to `min_const_fn`\n     pub fn is_min_const_fn(self, def_id: DefId) -> bool {\n         // Bail out if the signature doesn't contain `const`\n         if !self.is_const_fn_raw(def_id) {\n             return false;\n         }\n-        if let Abi::RustIntrinsic = self.fn_sig(def_id).abi() {\n-            return self.is_intrinsic_min_const_fn(def_id);\n-        }\n \n         if self.features().staged_api {\n             // In order for a libstd function to be considered min_const_fn\n@@ -134,62 +95,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     fn is_const_intrinsic(tcx: TyCtxt<'_>, def_id: DefId) -> Option<bool> {\n         match tcx.fn_sig(def_id).abi() {\n             Abi::RustIntrinsic |\n-            Abi::PlatformIntrinsic => {\n-                // FIXME: deduplicate these two lists as much as possible\n-                match tcx.item_name(def_id) {\n-                    // Keep this list in the same order as the match patterns in\n-                    // `librustc_mir/interpret/intrinsics.rs`\n-\n-                    // This whitelist is a list of intrinsics that have a miri-engine implementation\n-                    // and can thus be called when enabling enough feature gates. The similar\n-                    // whitelist in `is_intrinsic_min_const_fn` (in this file), exists for allowing\n-                    // the intrinsics to be called by stable const fns.\n-                    | sym::caller_location\n-\n-                    | sym::min_align_of\n-                    | sym::pref_align_of\n-                    | sym::needs_drop\n-                    | sym::size_of\n-                    | sym::type_id\n-                    | sym::type_name\n-\n-                    | sym::ctpop\n-                    | sym::cttz\n-                    | sym::cttz_nonzero\n-                    | sym::ctlz\n-                    | sym::ctlz_nonzero\n-                    | sym::bswap\n-                    | sym::bitreverse\n-\n-                    | sym::wrapping_add\n-                    | sym::wrapping_sub\n-                    | sym::wrapping_mul\n-                    | sym::add_with_overflow\n-                    | sym::sub_with_overflow\n-                    | sym::mul_with_overflow\n-\n-                    | sym::saturating_add\n-                    | sym::saturating_sub\n-\n-                    | sym::unchecked_shl\n-                    | sym::unchecked_shr\n-\n-                    | sym::rotate_left\n-                    | sym::rotate_right\n-\n-                    | sym::ptr_offset_from\n-\n-                    | sym::transmute\n-\n-                    | sym::simd_insert\n-\n-                    | sym::simd_extract\n-\n-                    => Some(true),\n-\n-                    _ => Some(false)\n-                }\n-            }\n+            Abi::PlatformIntrinsic => Some(tcx.lookup_const_stability(def_id).is_some()),\n             _ => None\n         }\n     }"}, {"sha": "45b8666c42b45d111aa081b3b1c8c4f00601991a", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -3,8 +3,7 @@\n use crate::hir::def_id::DefId;\n use lint::{LateContext, LintArray, LintContext};\n use lint::{LateLintPass, LintPass};\n-use rustc::hir::lowering::is_range_literal;\n-use rustc::hir::{ExprKind, Node};\n+use rustc::hir::{is_range_literal, ExprKind, Node};\n use rustc::ty::layout::{self, IntegerExt, LayoutOf, SizeSkeleton, VariantIdx};\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n@@ -266,7 +265,7 @@ fn lint_int_literal<'a, 'tcx>(\n         let par_id = cx.tcx.hir().get_parent_node(e.hir_id);\n         if let Node::Expr(par_e) = cx.tcx.hir().get(par_id) {\n             if let hir::ExprKind::Struct(..) = par_e.kind {\n-                if is_range_literal(cx.sess(), par_e)\n+                if is_range_literal(cx.sess().source_map(), par_e)\n                     && lint_overflowing_range_endpoint(cx, lit, v, max, e, par_e, t.name_str())\n                 {\n                     // The overflowing literal lint was overridden.\n@@ -318,7 +317,7 @@ fn lint_uint_literal<'a, 'tcx>(\n                         return;\n                     }\n                 }\n-                hir::ExprKind::Struct(..) if is_range_literal(cx.sess(), par_e) => {\n+                hir::ExprKind::Struct(..) if is_range_literal(cx.sess().source_map(), par_e) => {\n                     let t = t.name_str();\n                     if lint_overflowing_range_endpoint(cx, lit, lit_val, max, e, par_e, t) {\n                         // The overflowing literal lint was overridden."}, {"sha": "5f57aabe8d426bc53e9ea28d88d44c2235d3a85a", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -490,7 +490,7 @@ impl EarlyLintPass for UnusedParens {\n                 (value, \"`return` value\", false, Some(left), None)\n             }\n \n-            Assign(_, ref value) => (value, \"assigned value\", false, None, None),\n+            Assign(_, ref value, _) => (value, \"assigned value\", false, None, None),\n             AssignOp(.., ref value) => (value, \"assigned value\", false, None, None),\n             // either function/method call, or something this lint doesn't care about\n             ref call_or_other => {"}, {"sha": "b5cd24bebc33ab2921f369fe710a0aa4deb122e5", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -227,7 +227,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr\n \n         hir::ExprKind::Block(ref blk, _) => ExprKind::Block { body: &blk },\n \n-        hir::ExprKind::Assign(ref lhs, ref rhs) => {\n+        hir::ExprKind::Assign(ref lhs, ref rhs, _) => {\n             ExprKind::Assign { lhs: lhs.to_ref(), rhs: rhs.to_ref() }\n         }\n "}, {"sha": "1141239e49a53c6dd0b2b176a416d0d560fc4aa8", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -530,11 +530,12 @@ where\n                     // This can only be reached in ConstProp and non-rustc-MIR.\n                     throw_ub!(BoundsCheckFailed { len: min_length as u64, index: n as u64 });\n                 }\n-                assert!(offset < min_length);\n \n                 let index = if from_end {\n+                    assert!(0 < offset && offset - 1 < min_length);\n                     n - u64::from(offset)\n                 } else {\n+                    assert!(offset < min_length);\n                     u64::from(offset)\n                 };\n "}, {"sha": "e0eb841f2c0cfd17e99417446125d2fc05b956e0", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -281,7 +281,9 @@ impl<'a> Parser<'a> {\n                     let binary = self.mk_binary(source_map::respan(cur_op_span, ast_op), lhs, rhs);\n                     self.mk_expr(span, binary, AttrVec::new())\n                 }\n-                AssocOp::Assign => self.mk_expr(span, ExprKind::Assign(lhs, rhs), AttrVec::new()),\n+                AssocOp::Assign => {\n+                    self.mk_expr(span, ExprKind::Assign(lhs, rhs, cur_op_span), AttrVec::new())\n+                }\n                 AssocOp::AssignOp(k) => {\n                     let aop = match k {\n                         token::Plus => BinOpKind::Add,"}, {"sha": "1d5e65c6d27cd39f35cbc918339bdf0248b90105", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -737,8 +737,14 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         for predicate in &generics.where_clause.predicates {\n             if let WherePredicate::EqPredicate(ref predicate) = *predicate {\n                 self.err_handler()\n-                    .span_err(predicate.span, \"equality constraints are not yet \\\n-                                               supported in where clauses (see #20041)\");\n+                    .struct_span_err(\n+                        predicate.span,\n+                        \"equality constraints are not yet supported in `where` clauses\",\n+                    )\n+                    .note(\n+                        \"for more information, see https://github.com/rust-lang/rust/issues/20041\",\n+                    )\n+                    .emit();\n             }\n         }\n "}, {"sha": "1a8abeb7abcdc34a310ea7fee43380b423b45942", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1079,7 +1079,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     .unwrap_or_else(|| span_bug!(expr.span, \"continue to unknown label\"))\n             }\n \n-            hir::ExprKind::Assign(ref l, ref r) => {\n+            hir::ExprKind::Assign(ref l, ref r, _) => {\n                 // see comment on places in\n                 // propagate_through_place_components()\n                 let succ = self.write_place(&l, succ, ACC_WRITE);\n@@ -1373,7 +1373,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n \n fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr) {\n     match expr.kind {\n-        hir::ExprKind::Assign(ref l, _) => {\n+        hir::ExprKind::Assign(ref l, ..) => {\n             this.check_place(&l);\n         }\n "}, {"sha": "cdfcb8090e65ee2318832935492e5031e7c84f56", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1251,7 +1251,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             return;\n         }\n         match expr.kind {\n-            hir::ExprKind::Assign(.., ref rhs) | hir::ExprKind::Match(ref rhs, ..) => {\n+            hir::ExprKind::Assign(_, ref rhs, _) | hir::ExprKind::Match(ref rhs, ..) => {\n                 // Do not report duplicate errors for `x = y` and `match x { ... }`.\n                 if self.check_expr_pat_type(rhs.hir_id, rhs.span) {\n                     return;"}, {"sha": "9a14b75ca2f4dc4ec66be06434e117e04ba1efe4", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -3,9 +3,7 @@ use rustc::infer::InferOk;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n \n use errors::{Applicability, DiagnosticBuilder};\n-use rustc::hir;\n-use rustc::hir::Node;\n-use rustc::hir::{lowering::is_range_literal, print};\n+use rustc::hir::{self, is_range_literal, print, Node};\n use rustc::ty::adjustment::AllowTwoPhase;\n use rustc::ty::{self, AssocItem, Ty};\n use syntax::symbol::sym;\n@@ -478,7 +476,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // parenthesize if needed (Issue #46756)\n                             hir::ExprKind::Cast(_, _) | hir::ExprKind::Binary(_, _, _) => true,\n                             // parenthesize borrows of range literals (Issue #54505)\n-                            _ if is_range_literal(self.tcx.sess, expr) => true,\n+                            _ if is_range_literal(self.tcx.sess.source_map(), expr) => true,\n                             _ => false,\n                         };\n                         let sugg_expr = if needs_parens { format!(\"({})\", src) } else { src };\n@@ -492,7 +490,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             String::new()\n                         };\n                         if let Some(hir::Node::Expr(hir::Expr {\n-                            kind: hir::ExprKind::Assign(left_expr, _),\n+                            kind: hir::ExprKind::Assign(left_expr, ..),\n                             ..\n                         })) = self.tcx.hir().find(self.tcx.hir().get_parent_node(expr.hir_id))\n                         {"}, {"sha": "5c602ad76cd32d05090fdd36e54d31f0f5bf6239", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -17,7 +17,7 @@ use crate::check::TupleArgumentsFlag::DontTupleArguments;\n use crate::util::common::ErrorReported;\n use crate::util::nodemap::FxHashMap;\n \n-use errors::{pluralize, Applicability, DiagnosticBuilder};\n+use errors::{pluralize, Applicability, DiagnosticBuilder, DiagnosticId};\n use rustc::hir;\n use rustc::hir::def::{CtorKind, DefKind, Res};\n use rustc::hir::def_id::DefId;\n@@ -219,6 +219,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Box(ref subexpr) => self.check_expr_box(subexpr, expected),\n             ExprKind::Lit(ref lit) => self.check_lit(&lit, expected),\n             ExprKind::Binary(op, ref lhs, ref rhs) => self.check_binop(expr, op, lhs, rhs),\n+            ExprKind::Assign(ref lhs, ref rhs, ref span) => {\n+                self.check_expr_assign(expr, expected, lhs, rhs, span)\n+            }\n             ExprKind::AssignOp(op, ref lhs, ref rhs) => self.check_binop_assign(expr, op, lhs, rhs),\n             ExprKind::Unary(unop, ref oprnd) => {\n                 self.check_expr_unary(unop, oprnd, expected, needs, expr)\n@@ -245,7 +248,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n             ExprKind::Ret(ref expr_opt) => self.check_expr_return(expr_opt.as_deref(), expr),\n-            ExprKind::Assign(ref lhs, ref rhs) => self.check_expr_assign(expr, expected, lhs, rhs),\n             ExprKind::Loop(ref body, _, source) => {\n                 self.check_expr_loop(body, source, expected, expr)\n             }\n@@ -723,6 +725,40 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n     }\n \n+    fn is_destructuring_place_expr(&self, expr: &'tcx hir::Expr) -> bool {\n+        match &expr.kind {\n+            ExprKind::Array(comps) | ExprKind::Tup(comps) => {\n+                comps.iter().all(|e| self.is_destructuring_place_expr(e))\n+            }\n+            ExprKind::Struct(_path, fields, rest) => {\n+                rest.as_ref().map(|e| self.is_destructuring_place_expr(e)).unwrap_or(true)\n+                    && fields.iter().all(|f| self.is_destructuring_place_expr(&f.expr))\n+            }\n+            _ => expr.is_syntactic_place_expr(),\n+        }\n+    }\n+\n+    pub(crate) fn check_lhs_assignable(\n+        &self,\n+        lhs: &'tcx hir::Expr,\n+        err_code: &'static str,\n+        expr_span: &Span,\n+    ) {\n+        if !lhs.is_syntactic_place_expr() {\n+            let mut err = self.tcx.sess.struct_span_err_with_code(\n+                *expr_span,\n+                \"invalid left-hand side of assignment\",\n+                DiagnosticId::Error(err_code.into()),\n+            );\n+            err.span_label(lhs.span, \"cannot assign to this expression\");\n+            if self.is_destructuring_place_expr(lhs) {\n+                err.note(\"destructuring assignments are not currently supported\");\n+                err.note(\"for more information, see https://github.com/rust-lang/rfcs/issues/372\");\n+            }\n+            err.emit();\n+        }\n+    }\n+\n     /// Type check assignment expression `expr` of form `lhs = rhs`.\n     /// The expected type is `()` and is passsed to the function for the purposes of diagnostics.\n     fn check_expr_assign(\n@@ -731,6 +767,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Expectation<'tcx>,\n         lhs: &'tcx hir::Expr,\n         rhs: &'tcx hir::Expr,\n+        span: &Span,\n     ) -> Ty<'tcx> {\n         let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n         let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n@@ -752,10 +789,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 err.help(msg);\n             }\n             err.emit();\n-        } else if !lhs.is_syntactic_place_expr() {\n-            struct_span_err!(self.tcx.sess, expr.span, E0070, \"invalid left-hand side expression\")\n-                .span_label(expr.span, \"left-hand of expression not valid\")\n-                .emit();\n+        } else {\n+            self.check_lhs_assignable(lhs, \"E0070\", span);\n         }\n \n         self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);"}, {"sha": "c5d3aac136bcbd64ca94c84956b8ffd7fd139eec", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -19,30 +19,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &'tcx hir::Expr,\n         op: hir::BinOp,\n-        lhs_expr: &'tcx hir::Expr,\n-        rhs_expr: &'tcx hir::Expr,\n+        lhs: &'tcx hir::Expr,\n+        rhs: &'tcx hir::Expr,\n     ) -> Ty<'tcx> {\n         let (lhs_ty, rhs_ty, return_ty) =\n-            self.check_overloaded_binop(expr, lhs_expr, rhs_expr, op, IsAssign::Yes);\n+            self.check_overloaded_binop(expr, lhs, rhs, op, IsAssign::Yes);\n \n         let ty =\n             if !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() && is_builtin_binop(lhs_ty, rhs_ty, op) {\n-                self.enforce_builtin_binop_types(lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n+                self.enforce_builtin_binop_types(lhs, lhs_ty, rhs, rhs_ty, op);\n                 self.tcx.mk_unit()\n             } else {\n                 return_ty\n             };\n \n-        if !lhs_expr.is_syntactic_place_expr() {\n-            struct_span_err!(\n-                self.tcx.sess,\n-                lhs_expr.span,\n-                E0067,\n-                \"invalid left-hand side expression\"\n-            )\n-            .span_label(lhs_expr.span, \"invalid expression for left-hand side\")\n-            .emit();\n-        }\n+        self.check_lhs_assignable(lhs, \"E0067\", &op.span);\n+\n         ty\n     }\n "}, {"sha": "6c7e3658365a060e5989b8e0971826b5f3c3f017", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -286,7 +286,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 }\n             }\n \n-            hir::ExprKind::Assign(ref lhs, ref rhs) => {\n+            hir::ExprKind::Assign(ref lhs, ref rhs, _) => {\n                 self.mutate_expr(lhs);\n                 self.consume_expr(rhs);\n             }"}, {"sha": "8ccb74d6f15d3b7c025e8d0c8c8b3cf57f380d17", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -138,6 +138,22 @@ function getSearchElement() {\n         }\n     }\n \n+    function showSearchResults(search) {\n+        if (search === null || typeof search === 'undefined') {\n+            search = getSearchElement();\n+        }\n+        addClass(main, \"hidden\");\n+        removeClass(search, \"hidden\");\n+    }\n+\n+    function hideSearchResults(search) {\n+        if (search === null || typeof search === 'undefined') {\n+            search = getSearchElement();\n+        }\n+        addClass(search, \"hidden\");\n+        removeClass(main, \"hidden\");\n+    }\n+\n     // used for special search precedence\n     var TY_PRIMITIVE = itemTypes.indexOf(\"primitive\");\n     var TY_KEYWORD = itemTypes.indexOf(\"keyword\");\n@@ -169,8 +185,7 @@ function getSearchElement() {\n         if (ev !== null && search && !hasClass(search, \"hidden\") && ev.newURL) {\n             // This block occurs when clicking on an element in the navbar while\n             // in a search.\n-            addClass(search, \"hidden\");\n-            removeClass(main, \"hidden\");\n+            hideSearchResults(search);\n             var hash = ev.newURL.slice(ev.newURL.indexOf(\"#\") + 1);\n             if (browserSupportsHistoryApi()) {\n                 history.replaceState(hash, \"\", \"?search=#\" + hash);\n@@ -331,8 +346,7 @@ function getSearchElement() {\n             displayHelp(false, ev, help);\n         } else if (hasClass(search, \"hidden\") === false) {\n             ev.preventDefault();\n-            addClass(search, \"hidden\");\n-            removeClass(main, \"hidden\");\n+            hideSearchResults(search);\n             document.title = titleBeforeSearch;\n         }\n         defocusSearchBar();\n@@ -390,8 +404,8 @@ function getSearchElement() {\n         return null;\n     }\n \n-    document.onkeypress = handleShortcut;\n-    document.onkeydown = handleShortcut;\n+    document.addEventListener(\"keypress\", handleShortcut);\n+    document.addEventListener(\"keydown\", handleShortcut);\n \n     var handleSourceHighlight = (function() {\n         var prev_line_id = 0;\n@@ -430,7 +444,7 @@ function getSearchElement() {\n         }\n     })();\n \n-    document.onclick = function(ev) {\n+    document.addEventListener(\"click\", function(ev) {\n         if (hasClass(ev.target, \"collapse-toggle\")) {\n             collapseDocs(ev.target, \"toggle\");\n         } else if (hasClass(ev.target.parentNode, \"collapse-toggle\")) {\n@@ -452,7 +466,7 @@ function getSearchElement() {\n                 expandSection(a.hash.replace(/^#/, \"\"));\n             }\n         }\n-    };\n+    });\n \n     var x = document.getElementsByClassName(\"version-selector\");\n     if (x.length > 0) {\n@@ -1264,8 +1278,7 @@ function getSearchElement() {\n                 }\n                 dst = dst[0];\n                 if (window.location.pathname === dst.pathname) {\n-                    addClass(getSearchElement(), \"hidden\");\n-                    removeClass(main, \"hidden\");\n+                    hideSearchResults();\n                     document.location.href = dst.href;\n                 }\n             };\n@@ -1340,8 +1353,6 @@ function getSearchElement() {\n                     e.preventDefault();\n                 } else if (e.which === 16) { // shift\n                     // Does nothing, it's just to avoid losing \"focus\" on the highlighted element.\n-                } else if (e.which === 27) { // escape\n-                    handleEscape(e);\n                 } else if (actives[currentTab].length > 0) {\n                     removeClass(actives[currentTab][0], \"highlighted\");\n                 }\n@@ -1491,10 +1502,9 @@ function getSearchElement() {\n                 \"</div><div id=\\\"results\\\">\" +\n                 ret_others[0] + ret_in_args[0] + ret_returned[0] + \"</div>\";\n \n-            addClass(main, \"hidden\");\n             var search = getSearchElement();\n-            removeClass(search, \"hidden\");\n             search.innerHTML = output;\n+            showSearchResults(search);\n             var tds = search.getElementsByTagName(\"td\");\n             var td_width = 0;\n             if (tds.length > 0) {\n@@ -1699,13 +1709,7 @@ function getSearchElement() {\n                     if (browserSupportsHistoryApi()) {\n                         history.replaceState(\"\", window.currentCrate + \" - Rust\", \"?search=\");\n                     }\n-                    if (hasClass(main, \"content\")) {\n-                        removeClass(main, \"hidden\");\n-                    }\n-                    var search_c = getSearchElement();\n-                    if (hasClass(search_c, \"content\")) {\n-                        addClass(search_c, \"hidden\");\n-                    }\n+                    hideSearchResults();\n                 } else {\n                     searchTimeout = setTimeout(search, 500);\n                 }\n@@ -1718,6 +1722,10 @@ function getSearchElement() {\n                 search();\n             };\n             search_input.onchange = function(e) {\n+                if (e.target !== document.activeElement) {\n+                    // To prevent doing anything when it's from a blur event.\n+                    return;\n+                }\n                 // Do NOT e.preventDefault() here. It will prevent pasting.\n                 clearTimeout(searchTimeout);\n                 // zero-timeout necessary here because at the time of event handler execution the\n@@ -1741,19 +1749,8 @@ function getSearchElement() {\n                 // Store the previous <title> so we can revert back to it later.\n                 var previousTitle = document.title;\n \n-                window.onpopstate = function(e) {\n+                window.addEventListener(\"popstate\", function(e) {\n                     var params = getQueryStringParams();\n-                    // When browsing back from search results the main page\n-                    // visibility must be reset.\n-                    if (!params.search) {\n-                        if (hasClass(main, \"content\")) {\n-                            removeClass(main, \"hidden\");\n-                        }\n-                        var search_c = getSearchElement();\n-                        if (hasClass(search_c, \"content\")) {\n-                            addClass(search_c, \"hidden\");\n-                        }\n-                    }\n                     // Revert to the previous title manually since the History\n                     // API ignores the title parameter.\n                     document.title = previousTitle;\n@@ -1765,18 +1762,21 @@ function getSearchElement() {\n                     // perform the search. This will empty the bar if there's\n                     // nothing there, which lets you really go back to a\n                     // previous state with nothing in the bar.\n-                    if (params.search) {\n+                    if (params.search && params.search.length > 0) {\n                         search_input.value = params.search;\n+                        // Some browsers fire \"onpopstate\" for every page load\n+                        // (Chrome), while others fire the event only when actually\n+                        // popping a state (Firefox), which is why search() is\n+                        // called both here and at the end of the startSearch()\n+                        // function.\n+                        search(e);\n                     } else {\n                         search_input.value = \"\";\n+                        // When browsing back from search results the main page\n+                        // visibility must be reset.\n+                        hideSearchResults();\n                     }\n-                    // Some browsers fire \"onpopstate\" for every page load\n-                    // (Chrome), while others fire the event only when actually\n-                    // popping a state (Firefox), which is why search() is\n-                    // called both here and at the end of the startSearch()\n-                    // function.\n-                    search();\n-                };\n+                });\n             }\n             search();\n         }\n@@ -2522,9 +2522,9 @@ function getSearchElement() {\n     }\n \n     function putBackSearch(search_input) {\n-        if (search_input.value !== \"\") {\n-            addClass(main, \"hidden\");\n-            removeClass(getSearchElement(), \"hidden\");\n+        var search = getSearchElement();\n+        if (search_input.value !== \"\" && hasClass(search, \"hidden\")) {\n+            showSearchResults(search);\n             if (browserSupportsHistoryApi()) {\n                 history.replaceState(search_input.value,\n                                      \"\",\n@@ -2541,10 +2541,9 @@ function getSearchElement() {\n \n     var params = getQueryStringParams();\n     if (params && params.search) {\n-        addClass(main, \"hidden\");\n         var search = getSearchElement();\n-        removeClass(search, \"hidden\");\n         search.innerHTML = \"<h3 style=\\\"text-align: center;\\\">Loading search results...</h3>\";\n+        showSearchResults(search);\n     }\n \n     var sidebar_menu = document.getElementsByClassName(\"sidebar-menu\")[0];"}, {"sha": "9787cbb556bd237ba7c76bfaee5142c981cc303e", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -72,7 +72,7 @@ use core::convert::TryInto;\n /// }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone, Debug, Default)]\n+#[derive(Clone, Debug, Default, Eq, PartialEq)]\n pub struct Cursor<T> {\n     inner: T,\n     pos: u64,\n@@ -942,4 +942,16 @@ mod tests {\n         c.set_position(<usize>::max_value() as u64 + 1);\n         assert!(c.write_all(&[1, 2, 3]).is_err());\n     }\n+\n+    #[test]\n+    fn test_partial_eq() {\n+        assert_eq!(Cursor::new(Vec::<u8>::new()), Cursor::new(Vec::<u8>::new()));\n+    }\n+\n+    #[test]\n+    fn test_eq() {\n+        struct AssertEq<T: Eq>(pub T);\n+\n+        let _: AssertEq<Cursor<Vec<u8>>> = AssertEq(Cursor::new(Vec::new()));\n+    }\n }"}, {"sha": "c98942abaf3c2ae26ec390c1add4ca09d856acc9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1216,7 +1216,8 @@ pub enum ExprKind {\n     TryBlock(P<Block>),\n \n     /// An assignment (`a = foo()`).\n-    Assign(P<Expr>, P<Expr>),\n+    /// The `Span` argument is the span of the `=` token.\n+    Assign(P<Expr>, P<Expr>, Span),\n     /// An assignment with an operator.\n     ///\n     /// E.g., `a += 1`."}, {"sha": "f6817c713a4a66f20bf4690a8db3d217436f3cb8", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1168,7 +1168,7 @@ pub fn noop_visit_expr<T: MutVisitor>(Expr { kind, id, span, attrs }: &mut Expr,\n             vis.visit_block(body);\n         }\n         ExprKind::Await(expr) => vis.visit_expr(expr),\n-        ExprKind::Assign(el, er) => {\n+        ExprKind::Assign(el, er, _) => {\n             vis.visit_expr(el);\n             vis.visit_expr(er);\n         }"}, {"sha": "b1b667f03bee2be489ebc4628e5cd0481161edc0", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -2041,7 +2041,7 @@ impl<'a> State<'a> {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n                 self.s.word(\".await\");\n             }\n-            ast::ExprKind::Assign(ref lhs, ref rhs) => {\n+            ast::ExprKind::Assign(ref lhs, ref rhs, _) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(lhs, prec + 1);\n                 self.s.space();"}, {"sha": "98af382efb0838672460775b8cc2a5b4c0ffb913", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -378,7 +378,7 @@ pub fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n     match value.kind {\n         ast::ExprKind::Struct(..) => true,\n \n-        ast::ExprKind::Assign(ref lhs, ref rhs)\n+        ast::ExprKind::Assign(ref lhs, ref rhs, _)\n         | ast::ExprKind::AssignOp(_, ref lhs, ref rhs)\n         | ast::ExprKind::Binary(_, ref lhs, ref rhs) => {\n             // X { y: 1 } + X { y: 2 }"}, {"sha": "fbc5d1332490fc8e70399201fe04bdb17341c84c", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -766,9 +766,9 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_block(body);\n         }\n         ExprKind::Await(ref expr) => visitor.visit_expr(expr),\n-        ExprKind::Assign(ref left_hand_expression, ref right_hand_expression) => {\n-            visitor.visit_expr(left_hand_expression);\n-            visitor.visit_expr(right_hand_expression);\n+        ExprKind::Assign(ref lhs, ref rhs, _) => {\n+            visitor.visit_expr(lhs);\n+            visitor.visit_expr(rhs);\n         }\n         ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n             visitor.visit_expr(left_expression);"}, {"sha": "f5787903a2b594e3e6f440e3c6f25f086423da7d", "filename": "src/test/run-make-fulldeps/sanitizer-memory/Makefile", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2FMakefile?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -7,3 +7,5 @@\n all:\n \t$(RUSTC) -g -Z sanitizer=memory -Z print-link-args uninit.rs | $(CGREP) librustc_msan\n \t$(TMPDIR)/uninit 2>&1 | $(CGREP) use-of-uninitialized-value\n+\t$(RUSTC) -g -Z sanitizer=memory -Z print-link-args maybeuninit.rs | $(CGREP) librustc_msan\n+\t$(TMPDIR)/maybeuninit 2>&1 | $(CGREP) use-of-uninitialized-value"}, {"sha": "a9ae85f57639e8d8e78f38d19cc83fc2ef829c04", "filename": "src/test/run-make-fulldeps/sanitizer-memory/maybeuninit.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2Fmaybeuninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2Fmaybeuninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2Fmaybeuninit.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -0,0 +1,8 @@\n+use std::mem::MaybeUninit;\n+\n+fn main() {\n+    // This is technically not sound -- but we're literally trying to test\n+    // that the sanitizer catches this, so I guess \"intentionally unsound\"?\n+    let xs: [u8; 4] = unsafe { MaybeUninit::uninit().assume_init() };\n+    let y = xs[0] + xs[1];\n+}"}, {"sha": "eae52508f658543ee92825830af6aebe13176880", "filename": "src/test/run-make-fulldeps/sanitizer-memory/uninit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2Funinit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2Funinit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2Funinit.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1,7 +1,7 @@\n-use std::mem;\n-\n fn main() {\n+    // This is technically not sound -- but we're literally trying to test\n+    // that the sanitizer catches this, so I guess \"intentionally unsound\"?\n     #[allow(deprecated)]\n-    let xs: [u8; 4] = unsafe { mem::uninitialized() };\n+    let xs: [u8; 4] = unsafe { std::mem::uninitialized() };\n     let y = xs[0] + xs[1];\n }"}, {"sha": "8000ce73bd42fcc2db36b8ef1809c2a96726260d", "filename": "src/test/rustdoc/issue-52873.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Frustdoc%2Fissue-52873.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Frustdoc%2Fissue-52873.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-52873.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -105,8 +105,7 @@ impl<U: Unsigned, B: Bit> Add<B0> for UInt<U, B> {\n impl<U: Unsigned> Add<U> for UTerm {\n     type Output = U;\n     fn add(self, _: U) -> Self::Output {\n-        #[allow(deprecated)]\n-        unsafe { ::std::mem::uninitialized() }\n+        unimplemented!()\n     }\n }\n \n@@ -137,7 +136,7 @@ where\n {\n     type Output = UInt<Prod<Ul, UInt<Ur, B>>, B0>;\n     fn mul(self, _: UInt<Ur, B>) -> Self::Output {\n-        unsafe { ::std::mem::uninitialized() }\n+        unimplemented!()\n     }\n }\n "}, {"sha": "36d47cea13b07cd4d2ff1d3cad2d0d32a853f0eb", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -126,8 +126,8 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n                                           DUMMY_SP)));\n             },\n             12 => {\n-                iter_exprs(depth - 1, &mut |e| g(ExprKind::Assign(e, make_x())));\n-                iter_exprs(depth - 1, &mut |e| g(ExprKind::Assign(make_x(), e)));\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Assign(e, make_x(), DUMMY_SP)));\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Assign(make_x(), e, DUMMY_SP)));\n             },\n             13 => {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Field(e, Ident::from_str(\"f\"))));"}, {"sha": "1d5b362e29dfe9e276b36e96b0243b0bb32c1f3e", "filename": "src/test/ui/abi/stack-probes.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fabi%2Fstack-probes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fabi%2Fstack-probes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fabi%2Fstack-probes.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -13,7 +13,7 @@\n // ignore-sgx no processes\n // ignore-musl FIXME #31506\n \n-use std::mem;\n+use std::mem::MaybeUninit;\n use std::process::Command;\n use std::thread;\n use std::env;\n@@ -28,8 +28,8 @@ fn main() {\n     let args = env::args().skip(1).collect::<Vec<_>>();\n     if args.len() > 0 {\n         match &args[0][..] {\n-            \"main-thread\" => recurse(&[]),\n-            \"child-thread\" => thread::spawn(|| recurse(&[])).join().unwrap(),\n+            \"main-thread\" => recurse(&MaybeUninit::uninit()),\n+            \"child-thread\" => thread::spawn(|| recurse(&MaybeUninit::uninit())).join().unwrap(),\n             _ => panic!(),\n         }\n         return\n@@ -48,10 +48,11 @@ fn main() {\n }\n \n #[allow(unconditional_recursion)]\n-fn recurse(array: &[u64]) {\n-    unsafe { black_box(array.as_ptr() as u64); }\n-    #[allow(deprecated)]\n-    let local: [_; 1024] = unsafe { mem::uninitialized() };\n+fn recurse(array: &MaybeUninit<[u64; 1024]>) {\n+    unsafe {\n+        black_box(array.as_ptr() as u64);\n+    }\n+    let local: MaybeUninit<[u64; 1024]> = MaybeUninit::uninit();\n     recurse(&local);\n }\n "}, {"sha": "d7cf1b77005145bd74e9ae31b847ebdcb1b5934a", "filename": "src/test/ui/bad/bad-expr-lhs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fbad%2Fbad-expr-lhs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fbad%2Fbad-expr-lhs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbad%2Fbad-expr-lhs.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1,10 +1,10 @@\n fn main() {\n-    1 = 2; //~ ERROR invalid left-hand side expression\n-    1 += 2; //~ ERROR invalid left-hand side expression\n-    (1, 2) = (3, 4); //~ ERROR invalid left-hand side expression\n+    1 = 2; //~ ERROR invalid left-hand side of assignment\n+    1 += 2; //~ ERROR invalid left-hand side of assignment\n+    (1, 2) = (3, 4); //~ ERROR invalid left-hand side of assignment\n \n     let (a, b) = (1, 2);\n-    (a, b) = (3, 4); //~ ERROR invalid left-hand side expression\n+    (a, b) = (3, 4); //~ ERROR invalid left-hand side of assignment\n \n-    None = Some(3); //~ ERROR invalid left-hand side expression\n+    None = Some(3); //~ ERROR invalid left-hand side of assignment\n }"}, {"sha": "a195e1054d099e7b4211df6e3be396951cdbbfbd", "filename": "src/test/ui/bad/bad-expr-lhs.stderr", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fbad%2Fbad-expr-lhs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fbad%2Fbad-expr-lhs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbad%2Fbad-expr-lhs.stderr?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1,32 +1,45 @@\n-error[E0070]: invalid left-hand side expression\n-  --> $DIR/bad-expr-lhs.rs:2:5\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/bad-expr-lhs.rs:2:7\n    |\n LL |     1 = 2;\n-   |     ^^^^^ left-hand of expression not valid\n+   |     - ^\n+   |     |\n+   |     cannot assign to this expression\n \n-error[E0067]: invalid left-hand side expression\n-  --> $DIR/bad-expr-lhs.rs:3:5\n+error[E0067]: invalid left-hand side of assignment\n+  --> $DIR/bad-expr-lhs.rs:3:7\n    |\n LL |     1 += 2;\n-   |     ^ invalid expression for left-hand side\n+   |     - ^^\n+   |     |\n+   |     cannot assign to this expression\n \n-error[E0070]: invalid left-hand side expression\n-  --> $DIR/bad-expr-lhs.rs:4:5\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/bad-expr-lhs.rs:4:12\n    |\n LL |     (1, 2) = (3, 4);\n-   |     ^^^^^^^^^^^^^^^ left-hand of expression not valid\n+   |     ------ ^\n+   |     |\n+   |     cannot assign to this expression\n \n-error[E0070]: invalid left-hand side expression\n-  --> $DIR/bad-expr-lhs.rs:7:5\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/bad-expr-lhs.rs:7:12\n    |\n LL |     (a, b) = (3, 4);\n-   |     ^^^^^^^^^^^^^^^ left-hand of expression not valid\n+   |     ------ ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: destructuring assignments are not currently supported\n+   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n \n-error[E0070]: invalid left-hand side expression\n-  --> $DIR/bad-expr-lhs.rs:9:5\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/bad-expr-lhs.rs:9:10\n    |\n LL |     None = Some(3);\n-   |     ^^^^^^^^^^^^^^ left-hand of expression not valid\n+   |     ---- ^\n+   |     |\n+   |     cannot assign to this expression\n \n error: aborting due to 5 previous errors\n "}, {"sha": "4fa150ffef09ecd2384e4e58d6d23823269c3d78", "filename": "src/test/ui/const-generics/issues/issue-61422.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61422.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61422.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61422.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -5,6 +5,10 @@\n \n use std::mem;\n \n+// Neither of the uninits below are currently accepted as not UB, however,\n+// this code does not run and is merely checking that we do not ICE on this pattern,\n+// so this is fine.\n+\n fn foo<const SIZE: usize>() {\n     let arr: [u8; SIZE] = unsafe {\n         #[allow(deprecated)]\n@@ -13,4 +17,12 @@ fn foo<const SIZE: usize>() {\n     };\n }\n \n+fn bar<const SIZE: usize>() {\n+    let arr: [u8; SIZE] = unsafe {\n+        let array: [u8; SIZE] = mem::MaybeUninit::uninit().assume_init();\n+        array\n+    };\n+}\n+\n+\n fn main() {}"}, {"sha": "92231d4ced321ea9f87d0ff529ed9deedbca36b2", "filename": "src/test/ui/consts/const-eval/simd/insert_extract.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fsimd%2Finsert_extract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fsimd%2Finsert_extract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fsimd%2Finsert_extract.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -2,14 +2,18 @@\n #![feature(const_fn)]\n #![feature(repr_simd)]\n #![feature(platform_intrinsics)]\n+#![feature(staged_api)]\n+#![stable(feature = \"foo\", since = \"1.33.7\")]\n #![allow(non_camel_case_types)]\n \n #[repr(simd)] struct i8x1(i8);\n #[repr(simd)] struct u16x2(u16, u16);\n #[repr(simd)] struct f32x3(f32, f32, f32);\n \n extern \"platform-intrinsic\" {\n+    #[rustc_const_stable(feature = \"foo\", since = \"1.3.37\")]\n     fn simd_insert<T, U>(x: T, idx: u32, val: U) -> T;\n+    #[rustc_const_stable(feature = \"foo\", since = \"1.3.37\")]\n     fn simd_extract<T, U>(x: T, idx: u32) -> U;\n }\n "}, {"sha": "72fac19c191739171f29d3e6fcd5c4380d8086d6", "filename": "src/test/ui/consts/const-fn-type-name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-type-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-type-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-type-name.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -2,6 +2,7 @@\n \n #![feature(core_intrinsics)]\n #![feature(const_fn)]\n+#![feature(const_type_name)]\n #![allow(dead_code)]\n \n const fn type_name_wrapper<T>(_: &T) -> &'static str {"}, {"sha": "5fec36e44bd8c874e49fc510810ce36f692b3f96", "filename": "src/test/ui/consts/const_prop_slice_pat_ice.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fconsts%2Fconst_prop_slice_pat_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fconsts%2Fconst_prop_slice_pat_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_prop_slice_pat_ice.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -0,0 +1,9 @@\n+// check-pass\n+#![feature(slice_patterns)]\n+\n+fn main() {\n+    match &[0, 1] as &[i32] {\n+        [a @ .., x] => {}\n+        &[] => {}\n+    }\n+}"}, {"sha": "876c9efea264782686750e125f0faece79496e1f", "filename": "src/test/ui/destructuring-assignment/note-unsupported.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -0,0 +1,25 @@\n+struct S { x: u8, y: u8 }\n+\n+fn main() {\n+    let (a, b) = (1, 2);\n+\n+    (a, b) = (3, 4); //~ ERROR invalid left-hand side of assignment\n+    (a, b) += (3, 4); //~ ERROR invalid left-hand side of assignment\n+    //~^ ERROR binary assignment operation `+=` cannot be applied\n+\n+    [a, b] = [3, 4]; //~ ERROR invalid left-hand side of assignment\n+    [a, b] += [3, 4]; //~ ERROR invalid left-hand side of assignment\n+    //~^ ERROR binary assignment operation `+=` cannot be applied\n+\n+    let s = S { x: 3, y: 4 };\n+\n+    S { x: a, y: b } = s; //~ ERROR invalid left-hand side of assignment\n+    S { x: a, y: b } += s; //~ ERROR invalid left-hand side of assignment\n+    //~^ ERROR binary assignment operation `+=` cannot be applied\n+\n+    S { x: a, ..s } = S { x: 3, y: 4 }; //~ ERROR invalid left-hand side of assignment\n+\n+    let c = 3;\n+\n+    ((a, b), c) = ((3, 4), 5); //~ ERROR invalid left-hand side of assignment\n+}"}, {"sha": "a6805c32a6e5275143676bfe02052c595578b714", "filename": "src/test/ui/destructuring-assignment/note-unsupported.stderr", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -0,0 +1,122 @@\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/note-unsupported.rs:6:12\n+   |\n+LL |     (a, b) = (3, 4);\n+   |     ------ ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: destructuring assignments are not currently supported\n+   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n+\n+error[E0368]: binary assignment operation `+=` cannot be applied to type `({integer}, {integer})`\n+  --> $DIR/note-unsupported.rs:7:5\n+   |\n+LL |     (a, b) += (3, 4);\n+   |     ------^^^^^^^^^^\n+   |     |\n+   |     cannot use `+=` on type `({integer}, {integer})`\n+   |\n+   = note: an implementation of `std::ops::AddAssign` might be missing for `({integer}, {integer})`\n+\n+error[E0067]: invalid left-hand side of assignment\n+  --> $DIR/note-unsupported.rs:7:12\n+   |\n+LL |     (a, b) += (3, 4);\n+   |     ------ ^^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: destructuring assignments are not currently supported\n+   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n+\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/note-unsupported.rs:10:12\n+   |\n+LL |     [a, b] = [3, 4];\n+   |     ------ ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: destructuring assignments are not currently supported\n+   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n+\n+error[E0368]: binary assignment operation `+=` cannot be applied to type `[{integer}; 2]`\n+  --> $DIR/note-unsupported.rs:11:5\n+   |\n+LL |     [a, b] += [3, 4];\n+   |     ------^^^^^^^^^^\n+   |     |\n+   |     cannot use `+=` on type `[{integer}; 2]`\n+   |\n+   = note: an implementation of `std::ops::AddAssign` might be missing for `[{integer}; 2]`\n+\n+error[E0067]: invalid left-hand side of assignment\n+  --> $DIR/note-unsupported.rs:11:12\n+   |\n+LL |     [a, b] += [3, 4];\n+   |     ------ ^^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: destructuring assignments are not currently supported\n+   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n+\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/note-unsupported.rs:16:22\n+   |\n+LL |     S { x: a, y: b } = s;\n+   |     ---------------- ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: destructuring assignments are not currently supported\n+   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n+\n+error[E0368]: binary assignment operation `+=` cannot be applied to type `S`\n+  --> $DIR/note-unsupported.rs:17:5\n+   |\n+LL |     S { x: a, y: b } += s;\n+   |     ----------------^^^^^\n+   |     |\n+   |     cannot use `+=` on type `S`\n+   |\n+   = note: an implementation of `std::ops::AddAssign` might be missing for `S`\n+\n+error[E0067]: invalid left-hand side of assignment\n+  --> $DIR/note-unsupported.rs:17:22\n+   |\n+LL |     S { x: a, y: b } += s;\n+   |     ---------------- ^^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: destructuring assignments are not currently supported\n+   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n+\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/note-unsupported.rs:20:21\n+   |\n+LL |     S { x: a, ..s } = S { x: 3, y: 4 };\n+   |     --------------- ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: destructuring assignments are not currently supported\n+   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n+\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/note-unsupported.rs:24:17\n+   |\n+LL |     ((a, b), c) = ((3, 4), 5);\n+   |     ----------- ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: destructuring assignments are not currently supported\n+   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n+\n+error: aborting due to 11 previous errors\n+\n+Some errors have detailed explanations: E0067, E0070, E0368.\n+For more information about an error, try `rustc --explain E0067`."}, {"sha": "526503798b3d47d203fffa9b768b5b9301bf9bff", "filename": "src/test/ui/error-codes/E0067.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Ferror-codes%2FE0067.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Ferror-codes%2FE0067.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0067.stderr?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -8,11 +8,13 @@ LL |     LinkedList::new() += 1;\n    |\n    = note: an implementation of `std::ops::AddAssign` might be missing for `std::collections::LinkedList<_>`\n \n-error[E0067]: invalid left-hand side expression\n-  --> $DIR/E0067.rs:4:5\n+error[E0067]: invalid left-hand side of assignment\n+  --> $DIR/E0067.rs:4:23\n    |\n LL |     LinkedList::new() += 1;\n-   |     ^^^^^^^^^^^^^^^^^ invalid expression for left-hand side\n+   |     ----------------- ^^\n+   |     |\n+   |     cannot assign to this expression\n \n error: aborting due to 2 previous errors\n "}, {"sha": "d809bb18dee16a0fc75d5fa86247711f6921eddb", "filename": "src/test/ui/error-codes/E0070.stderr", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Ferror-codes%2FE0070.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Ferror-codes%2FE0070.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0070.stderr?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1,26 +1,32 @@\n-error[E0070]: invalid left-hand side expression\n-  --> $DIR/E0070.rs:6:5\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/E0070.rs:6:16\n    |\n LL |     SOME_CONST = 14;\n-   |     ^^^^^^^^^^^^^^^ left-hand of expression not valid\n+   |     ---------- ^\n+   |     |\n+   |     cannot assign to this expression\n \n-error[E0070]: invalid left-hand side expression\n-  --> $DIR/E0070.rs:7:5\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/E0070.rs:7:7\n    |\n LL |     1 = 3;\n-   |     ^^^^^ left-hand of expression not valid\n+   |     - ^\n+   |     |\n+   |     cannot assign to this expression\n \n error[E0308]: mismatched types\n   --> $DIR/E0070.rs:8:25\n    |\n LL |     some_other_func() = 4;\n    |                         ^ expected `()`, found integer\n \n-error[E0070]: invalid left-hand side expression\n-  --> $DIR/E0070.rs:8:5\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/E0070.rs:8:23\n    |\n LL |     some_other_func() = 4;\n-   |     ^^^^^^^^^^^^^^^^^^^^^ left-hand of expression not valid\n+   |     ----------------- ^\n+   |     |\n+   |     cannot assign to this expression\n \n error: aborting due to 4 previous errors\n "}, {"sha": "eba385461b951e192ed400d39745c969a3f90d1c", "filename": "src/test/ui/for-loop-while/for-loop-has-unit-body.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Ffor-loop-while%2Ffor-loop-has-unit-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Ffor-loop-while%2Ffor-loop-has-unit-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor-loop-while%2Ffor-loop-has-unit-body.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -2,8 +2,8 @@\n fn main() {\n     // Check that the tail statement in the body unifies with something\n     for _ in 0..3 {\n-        #[allow(deprecated)]\n-        unsafe { std::mem::uninitialized() }\n+        // `()` is fine to zero-initialize as it is zero sized and inhabited.\n+        unsafe { std::mem::zeroed() }\n     }\n \n     // Check that the tail statement in the body can be unit"}, {"sha": "fa53d55f5b3d7240b7dc9a97224ee00976c38c2c", "filename": "src/test/ui/issues/issue-13407.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fissues%2Fissue-13407.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fissues%2Fissue-13407.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13407.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -4,7 +4,7 @@ mod A {\n \n fn main() {\n     A::C = 1;\n-    //~^ ERROR: invalid left-hand side expression\n+    //~^ ERROR: invalid left-hand side of assignment\n     //~| ERROR: mismatched types\n     //~| ERROR: struct `C` is private\n }"}, {"sha": "b280de3158fede7567b64391c728f6464b685e13", "filename": "src/test/ui/issues/issue-13407.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fissues%2Fissue-13407.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fissues%2Fissue-13407.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13407.stderr?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -10,11 +10,13 @@ error[E0308]: mismatched types\n LL |     A::C = 1;\n    |            ^ expected struct `A::C`, found integer\n \n-error[E0070]: invalid left-hand side expression\n-  --> $DIR/issue-13407.rs:6:5\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/issue-13407.rs:6:10\n    |\n LL |     A::C = 1;\n-   |     ^^^^^^^^ left-hand of expression not valid\n+   |     ---- ^\n+   |     |\n+   |     cannot assign to this expression\n \n error: aborting due to 3 previous errors\n "}, {"sha": "c838515caf997e6f6a8ba6ad2a06ea124256354a", "filename": "src/test/ui/issues/issue-26093.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fissues%2Fissue-26093.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fissues%2Fissue-26093.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-26093.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1,7 +1,9 @@\n macro_rules! not_a_place {\n     ($thing:expr) => {\n         $thing = 42;\n-        //~^ ERROR invalid left-hand side expression\n+        //~^ ERROR invalid left-hand side of assignment\n+        $thing += 42;\n+        //~^ ERROR invalid left-hand side of assignment\n     }\n }\n "}, {"sha": "c96228b518a853bf59eeebdeda607a447622ca04", "filename": "src/test/ui/issues/issue-26093.stderr", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fissues%2Fissue-26093.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fissues%2Fissue-26093.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-26093.stderr?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1,12 +1,28 @@\n-error[E0070]: invalid left-hand side expression\n-  --> $DIR/issue-26093.rs:3:9\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/issue-26093.rs:3:16\n    |\n LL |         $thing = 42;\n-   |         ^^^^^^^^^^^ left-hand of expression not valid\n+   |                ^\n ...\n LL |     not_a_place!(99);\n-   |     ----------------- in this macro invocation\n+   |     -----------------\n+   |     |            |\n+   |     |            cannot assign to this expression\n+   |     in this macro invocation\n \n-error: aborting due to previous error\n+error[E0067]: invalid left-hand side of assignment\n+  --> $DIR/issue-26093.rs:5:16\n+   |\n+LL |         $thing += 42;\n+   |                ^^\n+...\n+LL |     not_a_place!(99);\n+   |     -----------------\n+   |     |            |\n+   |     |            cannot assign to this expression\n+   |     in this macro invocation\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0070`.\n+Some errors have detailed explanations: E0067, E0070.\n+For more information about an error, try `rustc --explain E0067`."}, {"sha": "e34b5c9a0f47e3a7b84a3902ce756769ce4808d1", "filename": "src/test/ui/issues/issue-34334.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fissues%2Fissue-34334.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fissues%2Fissue-34334.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34334.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -3,7 +3,7 @@ fn main () {\n     //~^ ERROR expected one of `,` or `>`, found `=`\n     //~| ERROR expected value, found struct `Vec`\n     //~| ERROR mismatched types\n-    //~| ERROR invalid left-hand side expression\n+    //~| ERROR invalid left-hand side of assignment\n     //~| ERROR expected expression, found reserved identifier `_`\n     //~| ERROR expected expression, found reserved identifier `_`\n     let sr2: Vec<(u32, _, _)> = sr.iter().map(|(faction, th_sender, th_receiver)| {}).collect();"}, {"sha": "3055e316a082a381197317e563b7dc2601956aca", "filename": "src/test/ui/issues/issue-34334.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -35,11 +35,13 @@ LL |     let sr: Vec<(u32, _, _) = vec![];\n             found struct `std::vec::Vec<_>`\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n-error[E0070]: invalid left-hand side expression\n-  --> $DIR/issue-34334.rs:2:13\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/issue-34334.rs:2:29\n    |\n LL |     let sr: Vec<(u32, _, _) = vec![];\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^ left-hand of expression not valid\n+   |             --------------- ^\n+   |             |\n+   |             cannot assign to this expression\n \n error[E0599]: no method named `iter` found for type `()` in the current scope\n   --> $DIR/issue-34334.rs:9:36"}, {"sha": "85664e62eaded5ee6c62ce5f4b37b20a134e28fe", "filename": "src/test/ui/issues/issue-48131.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fissues%2Fissue-48131.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fissues%2Fissue-48131.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-48131.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1,7 +1,7 @@\n // This note is annotated because the purpose of the test\n // is to ensure that certain other notes are not generated.\n #![deny(unused_unsafe)] //~ NOTE\n-#![allow(deprecated)]\n+\n \n // (test that no note is generated on this unsafe fn)\n pub unsafe fn a() {\n@@ -20,8 +20,8 @@ pub fn b() {\n             unsafe { /* unnecessary */ } //~ ERROR unnecessary `unsafe`\n                                          //~^ NOTE\n         }\n-\n-        let () = ::std::mem::uninitialized();\n+        // `()` is fine to zero-initialize as it is zero sized and inhabited.\n+        let () = ::std::mem::zeroed();\n \n         inner()\n     }"}, {"sha": "4695497c3a184881567d1b6515a66bce68e90168", "filename": "src/test/ui/issues/issue-58212.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fissues%2Fissue-58212.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fissues%2Fissue-58212.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58212.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1,13 +1,12 @@\n-// run-pass\n+// check-pass\n \n trait FromUnchecked {\n-    unsafe fn from_unchecked();\n+    fn from_unchecked();\n }\n \n impl FromUnchecked for [u8; 1] {\n-    unsafe fn from_unchecked() {\n-        #[allow(deprecated)]\n-        let mut array: Self = std::mem::uninitialized();\n+    fn from_unchecked() {\n+        let mut array: Self = [0; 1];\n         let _ptr = &mut array as *mut [u8] as *mut u8;\n     }\n }"}, {"sha": "7d15d607dd60619837139a78a7c173ff8e9151c6", "filename": "src/test/ui/structs-enums/enum-non-c-like-repr-c-and-int.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fstructs-enums%2Fenum-non-c-like-repr-c-and-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fstructs-enums%2Fenum-non-c-like-repr-c-and-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fenum-non-c-like-repr-c-and-int.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -69,8 +69,10 @@ fn main() {\n     unsafe {\n         // This should be safe, because we don't match on it unless it's fully formed,\n         // and it doesn't have a destructor.\n-        #[allow(deprecated)]\n-        let mut dest: MyEnum = mem::uninitialized();\n+        //\n+        // MyEnum is repr(C, u8) so it is guaranteed to have a separate discriminant and each\n+        // variant can be zero initialized.\n+        let mut dest: MyEnum = mem::zeroed();\n         while buf.len() > 0 {\n             match parse_my_enum(&mut dest, &mut buf) {\n                 Ok(()) => output.push(Ok(dest)),"}, {"sha": "fc9efdeca7d19bc3d42341ec7b430f22b6e926f3", "filename": "src/test/ui/structs-enums/enum-non-c-like-repr-c.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fstructs-enums%2Fenum-non-c-like-repr-c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fstructs-enums%2Fenum-non-c-like-repr-c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fenum-non-c-like-repr-c.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -69,8 +69,11 @@ fn main() {\n     unsafe {\n         // This should be safe, because we don't match on it unless it's fully formed,\n         // and it doesn't have a destructor.\n-        #[allow(deprecated)]\n-        let mut dest: MyEnum = mem::uninitialized();\n+        //\n+        // Furthermore, there are no types within MyEnum which cannot be initialized with zero,\n+        // specifically, though padding and such are present, there are no references or similar\n+        // types.\n+        let mut dest: MyEnum = mem::zeroed();\n         while buf.len() > 0 {\n             match parse_my_enum(&mut dest, &mut buf) {\n                 Ok(()) => output.push(Ok(dest)),"}, {"sha": "f9e96c1a0f4aeb71717c6e260325e1af7c114be5", "filename": "src/test/ui/structs-enums/enum-non-c-like-repr-int.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fstructs-enums%2Fenum-non-c-like-repr-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fstructs-enums%2Fenum-non-c-like-repr-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fenum-non-c-like-repr-int.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -65,8 +65,10 @@ fn main() {\n     unsafe {\n         // This should be safe, because we don't match on it unless it's fully formed,\n         // and it doesn't have a destructor.\n-        #[allow(deprecated)]\n-        let mut dest: MyEnum = mem::uninitialized();\n+        //\n+        // MyEnum is repr(u8) so it is guaranteed to have a separate discriminant and each variant\n+        // can be zero initialized.\n+        let mut dest: MyEnum = mem::zeroed();\n         while buf.len() > 0 {\n             match parse_my_enum(&mut dest, &mut buf) {\n                 Ok(()) => output.push(Ok(dest)),"}, {"sha": "191939bdb705b4d09d02df1d8ca3ea056db351cf", "filename": "src/test/ui/type/type-check/assignment-expected-bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-expected-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-expected-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-expected-bool.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -30,5 +30,5 @@ fn main() {\n     // A test to check that not expecting `bool` behaves well:\n     let _: usize = 0 = 0;\n     //~^ ERROR mismatched types [E0308]\n-    //~| ERROR invalid left-hand side expression [E0070]\n+    //~| ERROR invalid left-hand side of assignment [E0070]\n }"}, {"sha": "3f1caddf728cbead005a00cd44e78c3b8d66ac54", "filename": "src/test/ui/type/type-check/assignment-expected-bool.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-expected-bool.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-expected-bool.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-expected-bool.stderr?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -97,11 +97,13 @@ LL |         || (0 = 0);\n    |            expected `bool`, found `()`\n    |            help: try comparing for equality: `0 == 0`\n \n-error[E0070]: invalid left-hand side expression\n-  --> $DIR/assignment-expected-bool.rs:31:20\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/assignment-expected-bool.rs:31:22\n    |\n LL |     let _: usize = 0 = 0;\n-   |                    ^^^^^ left-hand of expression not valid\n+   |                    - ^\n+   |                    |\n+   |                    cannot assign to this expression\n \n error[E0308]: mismatched types\n   --> $DIR/assignment-expected-bool.rs:31:20"}, {"sha": "8da7b32b47b14ca21f015c09dc69251041aea895", "filename": "src/test/ui/type/type-check/assignment-in-if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -26,7 +26,7 @@ fn main() {\n         //~^ ERROR mismatched types\n         println!(\"{}\", x);\n     }\n-    // \"invalid left-hand side expression\" error is suppresed\n+    // \"invalid left-hand side of assignment\" error is suppresed\n     if 3 = x {\n         //~^ ERROR mismatched types\n         println!(\"{}\", x);"}, {"sha": "e804afcf9ed99bf214a9ea4d51f1f48c2eacfcd3", "filename": "src/test/ui/uninhabited/uninhabited-matches-feature-gated.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1,5 +1,4 @@\n-#![allow(deprecated)]\n-\n+use std::mem::zeroed;\n enum Void {}\n \n fn main() {\n@@ -8,21 +7,25 @@ fn main() {\n         Ok(n) => n,\n     };\n \n-    let x: &Void = unsafe { std::mem::uninitialized() };\n+    // This is pretty much instant UB. However, we have no choice -- we need to\n+    // test matching on a reference to `&Void`; we cannot do anything other than\n+    // just accept the fact that this is UB if `main` did run, but it doesn't;\n+    // this test only checks that these are feature-gated.\n+    let x: &Void = unsafe { zeroed() };\n     let _ = match x {}; //~ ERROR non-exhaustive\n \n-    let x: (Void,) = unsafe { std::mem::uninitialized() };\n+    let x: (Void,) = unsafe { zeroed() };\n     let _ = match x {}; //~ ERROR non-exhaustive\n \n-    let x: [Void; 1] = unsafe { std::mem::uninitialized() };\n+    let x: [Void; 1] = unsafe { zeroed() };\n     let _ = match x {}; //~ ERROR non-exhaustive\n \n-    let x: &[Void] = unsafe { std::mem::uninitialized() };\n+    let x: &[Void] = unsafe { zeroed() };\n     let _ = match x {   //~ ERROR non-exhaustive\n         &[] => (),\n     };\n \n-    let x: Void = unsafe { std::mem::uninitialized() };\n+    let x: Void = unsafe { zeroed() };\n     let _ = match x {}; // okay\n \n     let x: Result<u32, Void> = Ok(23);"}, {"sha": "a667e1fe2da3a99eb6624b44fafca854874c15ac", "filename": "src/test/ui/uninhabited/uninhabited-matches-feature-gated.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1,13 +1,13 @@\n error[E0004]: non-exhaustive patterns: `Err(_)` not covered\n-  --> $DIR/uninhabited-matches-feature-gated.rs:7:19\n+  --> $DIR/uninhabited-matches-feature-gated.rs:6:19\n    |\n LL |     let _ = match x {\n    |                   ^ pattern `Err(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: type `&Void` is non-empty\n-  --> $DIR/uninhabited-matches-feature-gated.rs:12:19\n+  --> $DIR/uninhabited-matches-feature-gated.rs:15:19\n    |\n LL | enum Void {}\n    | ------------ `Void` defined here\n@@ -18,39 +18,39 @@ LL |     let _ = match x {};\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: type `(Void,)` is non-empty\n-  --> $DIR/uninhabited-matches-feature-gated.rs:15:19\n+  --> $DIR/uninhabited-matches-feature-gated.rs:18:19\n    |\n LL |     let _ = match x {};\n    |                   ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: type `[Void; 1]` is non-empty\n-  --> $DIR/uninhabited-matches-feature-gated.rs:18:19\n+  --> $DIR/uninhabited-matches-feature-gated.rs:21:19\n    |\n LL |     let _ = match x {};\n    |                   ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `&[_, ..]` not covered\n-  --> $DIR/uninhabited-matches-feature-gated.rs:21:19\n+  --> $DIR/uninhabited-matches-feature-gated.rs:24:19\n    |\n LL |     let _ = match x {\n    |                   ^ pattern `&[_, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `Err(_)` not covered\n-  --> $DIR/uninhabited-matches-feature-gated.rs:29:19\n+  --> $DIR/uninhabited-matches-feature-gated.rs:32:19\n    |\n LL |     let _ = match x {\n    |                   ^ pattern `Err(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n-  --> $DIR/uninhabited-matches-feature-gated.rs:34:9\n+  --> $DIR/uninhabited-matches-feature-gated.rs:37:9\n    |\n LL |     let Ok(x) = x;\n    |         ^^^^^ pattern `Err(_)` not covered"}, {"sha": "b21de882b2ceb95bf684c52824106c438dab6b58", "filename": "src/test/ui/uninit-empty-types.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Funinit-empty-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Funinit-empty-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinit-empty-types.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1,17 +1,19 @@\n-// run-pass\n+// build-pass\n // Test the uninit() construct returning various empty types.\n \n // pretty-expanded FIXME #23616\n \n-use std::mem;\n+use std::mem::MaybeUninit;\n \n-#[derive(Clone)]\n struct Foo;\n \n #[allow(deprecated)]\n pub fn main() {\n     unsafe {\n-        let _x: Foo = mem::uninitialized();\n-        let _x: [Foo; 2] = mem::uninitialized();\n+        // `Foo` and `[Foo; 2]` are both zero sized and inhabited, so this is safe.\n+        let _x: Foo = MaybeUninit::uninit().assume_init();\n+        let _x: [Foo; 2] = MaybeUninit::uninit().assume_init();\n+        let _x: Foo = std::mem::uninitialized();\n+        let _x: [Foo; 2] = std::mem::uninitialized();\n     }\n }"}, {"sha": "8828f09d92d333d548a320d148ca66140dce8f51", "filename": "src/test/ui/where-clauses/where-equality-constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-equality-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-equality-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-equality-constraints.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1,6 +1,6 @@\n fn f() where u8 = u16 {}\n-//~^ ERROR equality constraints are not yet supported in where clauses\n+//~^ ERROR equality constraints are not yet supported in `where` clauses\n fn g() where for<'a> &'static (u8,) == u16, {}\n-//~^ ERROR equality constraints are not yet supported in where clauses\n+//~^ ERROR equality constraints are not yet supported in `where` clauses\n \n fn main() {}"}, {"sha": "c0241fe708f6451e0aaaec7e76b5153c53fe3171", "filename": "src/test/ui/where-clauses/where-equality-constraints.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-equality-constraints.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-equality-constraints.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-equality-constraints.stderr?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1,14 +1,18 @@\n-error: equality constraints are not yet supported in where clauses (see #20041)\n+error: equality constraints are not yet supported in `where` clauses\n   --> $DIR/where-equality-constraints.rs:1:14\n    |\n LL | fn f() where u8 = u16 {}\n    |              ^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/20041\n \n-error: equality constraints are not yet supported in where clauses (see #20041)\n+error: equality constraints are not yet supported in `where` clauses\n   --> $DIR/where-equality-constraints.rs:3:14\n    |\n LL | fn g() where for<'a> &'static (u8,) == u16, {}\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/20041\n \n error: aborting due to 2 previous errors\n "}]}