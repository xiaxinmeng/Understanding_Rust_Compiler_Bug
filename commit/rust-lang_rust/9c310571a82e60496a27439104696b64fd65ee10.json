{"sha": "9c310571a82e60496a27439104696b64fd65ee10", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljMzEwNTcxYTgyZTYwNDk2YTI3NDM5MTA0Njk2YjY0ZmQ2NWVlMTA=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-03-08T12:13:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-08T12:13:23Z"}, "message": "Rollup merge of #82682 - petrochenkov:cfgeval, r=Aaron1011\n\nImplement built-in attribute macro `#[cfg_eval]` + some refactoring\n\nThis PR implements a built-in attribute macro `#[cfg_eval]` as it was suggested in https://github.com/rust-lang/rust/pull/79078 to avoid `#[derive()]` without arguments being abused as a way to configure input for other attributes.\n\nThe macro is used for eagerly expanding all `#[cfg]` and `#[cfg_attr]` attributes in its input (\"fully configuring\" the input).\nThe effect is identical to effect of `#[derive(Foo, Bar)]` which also fully configures its input before passing it to macros `Foo` and `Bar`, but unlike `#[derive]` `#[cfg_eval]` can be applied to any syntax nodes supporting macro attributes, not only certain items.\n\n`cfg_eval` was the first name suggested in https://github.com/rust-lang/rust/pull/79078, but other alternatives are also possible, e.g. `cfg_expand`.\n\n```rust\n#[cfg_eval]\n#[my_attr] // Receives `struct S {}` as input, the field is configured away by `#[cfg_eval]`\nstruct S {\n    #[cfg(FALSE)]\n    field: u8,\n}\n```\n\nTracking issue: https://github.com/rust-lang/rust/issues/82679", "tree": {"sha": "62727a3819a4d92ff23c16e857bf23f80f6ec2d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62727a3819a4d92ff23c16e857bf23f80f6ec2d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c310571a82e60496a27439104696b64fd65ee10", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgRhTkCRBK7hj4Ov3rIwAAdHIIABXUsfgVRI3t9B44b/P0YZWl\nB7hxbFB/vsZoI6WQV0LhzrywqJNFKsdh3p4pskhPUYzSLoTfMlyNj2wrdxdQ2zqR\nIkWrYGDPLeAwhLWsKxVS7TXOGIYo0F+ObndyFnqXrjfsltAvyTfSrycPz6erahUU\niu5cBfbBKQ14ef+bHT/7ljBRmp9jiF2ZoZH9h9fatz1WE50jL+yXOE1tbLhrgUCp\nxwEzE0jKhwYpmz7orIEa1/mDmoVNkL579F59Aam5t/ywHas/ad9GIifidL8SwKh5\nxlpPkkkTrtYVBZB4ra8cZ3X64yKoaLkzYhWaYOv1kCW/n5Wb1bcwYBhwtUc3n9M=\n=eSna\n-----END PGP SIGNATURE-----\n", "payload": "tree 62727a3819a4d92ff23c16e857bf23f80f6ec2d8\nparent 7b78d86d6a084e714243f41c65b70517e93b1076\nparent 5d27728141beed69bf64212de1eb504b6b2ac0f0\nauthor Dylan DPC <dylan.dpc@gmail.com> 1615205603 +0100\ncommitter GitHub <noreply@github.com> 1615205603 +0100\n\nRollup merge of #82682 - petrochenkov:cfgeval, r=Aaron1011\n\nImplement built-in attribute macro `#[cfg_eval]` + some refactoring\n\nThis PR implements a built-in attribute macro `#[cfg_eval]` as it was suggested in https://github.com/rust-lang/rust/pull/79078 to avoid `#[derive()]` without arguments being abused as a way to configure input for other attributes.\n\nThe macro is used for eagerly expanding all `#[cfg]` and `#[cfg_attr]` attributes in its input (\"fully configuring\" the input).\nThe effect is identical to effect of `#[derive(Foo, Bar)]` which also fully configures its input before passing it to macros `Foo` and `Bar`, but unlike `#[derive]` `#[cfg_eval]` can be applied to any syntax nodes supporting macro attributes, not only certain items.\n\n`cfg_eval` was the first name suggested in https://github.com/rust-lang/rust/pull/79078, but other alternatives are also possible, e.g. `cfg_expand`.\n\n```rust\n#[cfg_eval]\n#[my_attr] // Receives `struct S {}` as input, the field is configured away by `#[cfg_eval]`\nstruct S {\n    #[cfg(FALSE)]\n    field: u8,\n}\n```\n\nTracking issue: https://github.com/rust-lang/rust/issues/82679\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c310571a82e60496a27439104696b64fd65ee10", "html_url": "https://github.com/rust-lang/rust/commit/9c310571a82e60496a27439104696b64fd65ee10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c310571a82e60496a27439104696b64fd65ee10/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b78d86d6a084e714243f41c65b70517e93b1076", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b78d86d6a084e714243f41c65b70517e93b1076", "html_url": "https://github.com/rust-lang/rust/commit/7b78d86d6a084e714243f41c65b70517e93b1076"}, {"sha": "5d27728141beed69bf64212de1eb504b6b2ac0f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d27728141beed69bf64212de1eb504b6b2ac0f0", "html_url": "https://github.com/rust-lang/rust/commit/5d27728141beed69bf64212de1eb504b6b2ac0f0"}], "stats": {"total": 712, "additions": 453, "deletions": 259}, "files": [{"sha": "99196210e004b1ff2cbf71808d9991b0dce70fc8", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c310571a82e60496a27439104696b64fd65ee10/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c310571a82e60496a27439104696b64fd65ee10/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=9c310571a82e60496a27439104696b64fd65ee10", "patch": "@@ -915,16 +915,6 @@ impl Stmt {\n         }\n     }\n \n-    pub fn tokens_mut(&mut self) -> Option<&mut LazyTokenStream> {\n-        match self.kind {\n-            StmtKind::Local(ref mut local) => local.tokens.as_mut(),\n-            StmtKind::Item(ref mut item) => item.tokens.as_mut(),\n-            StmtKind::Expr(ref mut expr) | StmtKind::Semi(ref mut expr) => expr.tokens.as_mut(),\n-            StmtKind::Empty => None,\n-            StmtKind::MacCall(ref mut mac) => mac.tokens.as_mut(),\n-        }\n-    }\n-\n     pub fn has_trailing_semicolon(&self) -> bool {\n         match &self.kind {\n             StmtKind::Semi(_) => true,"}, {"sha": "a71f2ac9815012389303ed77e4284dd6db61ebc0", "filename": "compiler/rustc_ast/src/ast_like.rs", "status": "modified", "additions": 34, "deletions": 54, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/9c310571a82e60496a27439104696b64fd65ee10/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c310571a82e60496a27439104696b64fd65ee10/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs?ref=9c310571a82e60496a27439104696b64fd65ee10", "patch": "@@ -11,13 +11,7 @@ use super::{AttrVec, Attribute, Stmt, StmtKind};\n pub trait AstLike: Sized {\n     fn attrs(&self) -> &[Attribute];\n     fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>));\n-    /// Called by `Parser::collect_tokens` to store the collected\n-    /// tokens inside an AST node\n-    fn finalize_tokens(&mut self, _tokens: LazyTokenStream) {\n-        // This default impl makes this trait easier to implement\n-        // in tools like `rust-analyzer`\n-        panic!(\"`finalize_tokens` is not supported!\")\n-    }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>>;\n }\n \n impl<T: AstLike + 'static> AstLike for P<T> {\n@@ -27,8 +21,8 @@ impl<T: AstLike + 'static> AstLike for P<T> {\n     fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n         (**self).visit_attrs(f);\n     }\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        (**self).finalize_tokens(tokens)\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        (**self).tokens_mut()\n     }\n }\n \n@@ -42,12 +36,12 @@ fn visit_attrvec(attrs: &mut AttrVec, f: impl FnOnce(&mut Vec<Attribute>)) {\n \n impl AstLike for StmtKind {\n     fn attrs(&self) -> &[Attribute] {\n-        match *self {\n-            StmtKind::Local(ref local) => local.attrs(),\n-            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => expr.attrs(),\n-            StmtKind::Item(ref item) => item.attrs(),\n+        match self {\n+            StmtKind::Local(local) => local.attrs(),\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr.attrs(),\n+            StmtKind::Item(item) => item.attrs(),\n             StmtKind::Empty => &[],\n-            StmtKind::MacCall(ref mac) => &*mac.attrs,\n+            StmtKind::MacCall(mac) => &mac.attrs,\n         }\n     }\n \n@@ -60,17 +54,14 @@ impl AstLike for StmtKind {\n             StmtKind::MacCall(mac) => visit_attrvec(&mut mac.attrs, f),\n         }\n     }\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        let stmt_tokens = match self {\n-            StmtKind::Local(ref mut local) => &mut local.tokens,\n-            StmtKind::Item(ref mut item) => &mut item.tokens,\n-            StmtKind::Expr(ref mut expr) | StmtKind::Semi(ref mut expr) => &mut expr.tokens,\n-            StmtKind::Empty => return,\n-            StmtKind::MacCall(ref mut mac) => &mut mac.tokens,\n-        };\n-        if stmt_tokens.is_none() {\n-            *stmt_tokens = Some(tokens);\n-        }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        Some(match self {\n+            StmtKind::Local(local) => &mut local.tokens,\n+            StmtKind::Item(item) => &mut item.tokens,\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => &mut expr.tokens,\n+            StmtKind::Empty => return None,\n+            StmtKind::MacCall(mac) => &mut mac.tokens,\n+        })\n     }\n }\n \n@@ -82,8 +73,8 @@ impl AstLike for Stmt {\n     fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n         self.kind.visit_attrs(f);\n     }\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        self.kind.finalize_tokens(tokens)\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        self.kind.tokens_mut()\n     }\n }\n \n@@ -92,17 +83,13 @@ impl AstLike for Attribute {\n         &[]\n     }\n     fn visit_attrs(&mut self, _f: impl FnOnce(&mut Vec<Attribute>)) {}\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        match &mut self.kind {\n-            AttrKind::Normal(_, attr_tokens) => {\n-                if attr_tokens.is_none() {\n-                    *attr_tokens = Some(tokens);\n-                }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        Some(match &mut self.kind {\n+            AttrKind::Normal(_, tokens) => tokens,\n+            kind @ AttrKind::DocComment(..) => {\n+                panic!(\"Called tokens_mut on doc comment attr {:?}\", kind)\n             }\n-            AttrKind::DocComment(..) => {\n-                panic!(\"Called finalize_tokens on doc comment attr {:?}\", self)\n-            }\n-        }\n+        })\n     }\n }\n \n@@ -115,10 +102,8 @@ impl<T: AstLike> AstLike for Option<T> {\n             inner.visit_attrs(f);\n         }\n     }\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        if let Some(inner) = self {\n-            inner.finalize_tokens(tokens);\n-        }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        self.as_mut().and_then(|inner| inner.tokens_mut())\n     }\n }\n \n@@ -152,11 +137,8 @@ macro_rules! derive_has_tokens_and_attrs {\n                 VecOrAttrVec::visit(&mut self.attrs, f)\n             }\n \n-            fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-                if self.tokens.is_none() {\n-                    self.tokens = Some(tokens);\n-                }\n-\n+            fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+                Some(&mut self.tokens)\n             }\n         }\n     )* }\n@@ -173,7 +155,9 @@ macro_rules! derive_has_attrs_no_tokens {\n                 VecOrAttrVec::visit(&mut self.attrs, f)\n             }\n \n-            fn finalize_tokens(&mut self, _tokens: LazyTokenStream) {}\n+            fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+                None\n+            }\n         }\n     )* }\n }\n@@ -185,14 +169,10 @@ macro_rules! derive_has_tokens_no_attrs {\n                 &[]\n             }\n \n-            fn visit_attrs(&mut self, _f: impl FnOnce(&mut Vec<Attribute>)) {\n-            }\n-\n-            fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-                if self.tokens.is_none() {\n-                    self.tokens = Some(tokens);\n-                }\n+            fn visit_attrs(&mut self, _f: impl FnOnce(&mut Vec<Attribute>)) {}\n \n+            fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+                Some(&mut self.tokens)\n             }\n         }\n     )* }"}, {"sha": "eea4d785dee069943941709d79c5b34f468b073d", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/9c310571a82e60496a27439104696b64fd65ee10/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c310571a82e60496a27439104696b64fd65ee10/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=9c310571a82e60496a27439104696b64fd65ee10", "patch": "@@ -0,0 +1,157 @@\n+use crate::util::check_builtin_macro_attribute;\n+\n+use rustc_ast::mut_visit::{self, MutVisitor};\n+use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, AstLike};\n+use rustc_expand::base::{Annotatable, ExtCtxt};\n+use rustc_expand::config::StripUnconfigured;\n+use rustc_expand::configure;\n+use rustc_span::symbol::sym;\n+use rustc_span::Span;\n+use smallvec::SmallVec;\n+\n+crate fn expand(\n+    ecx: &mut ExtCtxt<'_>,\n+    _span: Span,\n+    meta_item: &ast::MetaItem,\n+    annotatable: Annotatable,\n+) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(ecx, meta_item, sym::cfg_eval);\n+    cfg_eval(ecx, annotatable)\n+}\n+\n+crate fn cfg_eval(ecx: &ExtCtxt<'_>, annotatable: Annotatable) -> Vec<Annotatable> {\n+    let mut visitor = CfgEval {\n+        cfg: StripUnconfigured { sess: ecx.sess, features: ecx.ecfg.features, modified: false },\n+    };\n+    let mut annotatable = visitor.configure_annotatable(annotatable);\n+    if visitor.cfg.modified {\n+        // Erase the tokens if cfg-stripping modified the item\n+        // This will cause us to synthesize fake tokens\n+        // when `nt_to_tokenstream` is called on this item.\n+        if let Some(tokens) = annotatable.tokens_mut() {\n+            *tokens = None;\n+        }\n+    }\n+    vec![annotatable]\n+}\n+\n+struct CfgEval<'a> {\n+    cfg: StripUnconfigured<'a>,\n+}\n+\n+impl CfgEval<'_> {\n+    fn configure<T: AstLike>(&mut self, node: T) -> Option<T> {\n+        self.cfg.configure(node)\n+    }\n+\n+    fn configure_annotatable(&mut self, annotatable: Annotatable) -> Annotatable {\n+        // Since the item itself has already been configured by the InvocationCollector,\n+        // we know that fold result vector will contain exactly one element\n+        match annotatable {\n+            Annotatable::Item(item) => Annotatable::Item(self.flat_map_item(item).pop().unwrap()),\n+            Annotatable::TraitItem(item) => {\n+                Annotatable::TraitItem(self.flat_map_trait_item(item).pop().unwrap())\n+            }\n+            Annotatable::ImplItem(item) => {\n+                Annotatable::ImplItem(self.flat_map_impl_item(item).pop().unwrap())\n+            }\n+            Annotatable::ForeignItem(item) => {\n+                Annotatable::ForeignItem(self.flat_map_foreign_item(item).pop().unwrap())\n+            }\n+            Annotatable::Stmt(stmt) => {\n+                Annotatable::Stmt(stmt.map(|stmt| self.flat_map_stmt(stmt).pop().unwrap()))\n+            }\n+            Annotatable::Expr(mut expr) => Annotatable::Expr({\n+                self.visit_expr(&mut expr);\n+                expr\n+            }),\n+            Annotatable::Arm(arm) => Annotatable::Arm(self.flat_map_arm(arm).pop().unwrap()),\n+            Annotatable::Field(field) => {\n+                Annotatable::Field(self.flat_map_field(field).pop().unwrap())\n+            }\n+            Annotatable::FieldPat(fp) => {\n+                Annotatable::FieldPat(self.flat_map_field_pattern(fp).pop().unwrap())\n+            }\n+            Annotatable::GenericParam(param) => {\n+                Annotatable::GenericParam(self.flat_map_generic_param(param).pop().unwrap())\n+            }\n+            Annotatable::Param(param) => {\n+                Annotatable::Param(self.flat_map_param(param).pop().unwrap())\n+            }\n+            Annotatable::StructField(sf) => {\n+                Annotatable::StructField(self.flat_map_struct_field(sf).pop().unwrap())\n+            }\n+            Annotatable::Variant(v) => {\n+                Annotatable::Variant(self.flat_map_variant(v).pop().unwrap())\n+            }\n+        }\n+    }\n+}\n+\n+impl MutVisitor for CfgEval<'_> {\n+    fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n+        self.cfg.configure_expr(expr);\n+        mut_visit::noop_visit_expr(expr, self);\n+    }\n+\n+    fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n+        let mut expr = configure!(self, expr);\n+        mut_visit::noop_visit_expr(&mut expr, self);\n+        Some(expr)\n+    }\n+\n+    fn flat_map_generic_param(\n+        &mut self,\n+        param: ast::GenericParam,\n+    ) -> SmallVec<[ast::GenericParam; 1]> {\n+        mut_visit::noop_flat_map_generic_param(configure!(self, param), self)\n+    }\n+\n+    fn flat_map_stmt(&mut self, stmt: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n+        mut_visit::noop_flat_map_stmt(configure!(self, stmt), self)\n+    }\n+\n+    fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n+        mut_visit::noop_flat_map_item(configure!(self, item), self)\n+    }\n+\n+    fn flat_map_impl_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n+        mut_visit::noop_flat_map_assoc_item(configure!(self, item), self)\n+    }\n+\n+    fn flat_map_trait_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n+        mut_visit::noop_flat_map_assoc_item(configure!(self, item), self)\n+    }\n+\n+    fn flat_map_foreign_item(\n+        &mut self,\n+        foreign_item: P<ast::ForeignItem>,\n+    ) -> SmallVec<[P<ast::ForeignItem>; 1]> {\n+        mut_visit::noop_flat_map_foreign_item(configure!(self, foreign_item), self)\n+    }\n+\n+    fn flat_map_arm(&mut self, arm: ast::Arm) -> SmallVec<[ast::Arm; 1]> {\n+        mut_visit::noop_flat_map_arm(configure!(self, arm), self)\n+    }\n+\n+    fn flat_map_field(&mut self, field: ast::Field) -> SmallVec<[ast::Field; 1]> {\n+        mut_visit::noop_flat_map_field(configure!(self, field), self)\n+    }\n+\n+    fn flat_map_field_pattern(&mut self, fp: ast::FieldPat) -> SmallVec<[ast::FieldPat; 1]> {\n+        mut_visit::noop_flat_map_field_pattern(configure!(self, fp), self)\n+    }\n+\n+    fn flat_map_param(&mut self, p: ast::Param) -> SmallVec<[ast::Param; 1]> {\n+        mut_visit::noop_flat_map_param(configure!(self, p), self)\n+    }\n+\n+    fn flat_map_struct_field(&mut self, sf: ast::StructField) -> SmallVec<[ast::StructField; 1]> {\n+        mut_visit::noop_flat_map_struct_field(configure!(self, sf), self)\n+    }\n+\n+    fn flat_map_variant(&mut self, variant: ast::Variant) -> SmallVec<[ast::Variant; 1]> {\n+        mut_visit::noop_flat_map_variant(configure!(self, variant), self)\n+    }\n+}"}, {"sha": "0da2c1c1021f33224b1f79a2987a7e849830d531", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9c310571a82e60496a27439104696b64fd65ee10/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c310571a82e60496a27439104696b64fd65ee10/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=9c310571a82e60496a27439104696b64fd65ee10", "patch": "@@ -1,7 +1,8 @@\n+use crate::cfg_eval::cfg_eval;\n+\n use rustc_ast::{self as ast, token, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, Indeterminate, MultiItemModifier};\n-use rustc_expand::config::StripUnconfigured;\n use rustc_feature::AttributeTemplate;\n use rustc_parse::validate_attr;\n use rustc_session::Session;\n@@ -51,26 +52,7 @@ impl MultiItemModifier for Expander {\n \n         // FIXME: Try to cache intermediate results to avoid collecting same paths multiple times.\n         match ecx.resolver.resolve_derives(ecx.current_expansion.id, derives, ecx.force_mode) {\n-            Ok(()) => {\n-                let mut visitor =\n-                    StripUnconfigured { sess, features: ecx.ecfg.features, modified: false };\n-                let mut item = visitor.fully_configure(item);\n-                if visitor.modified {\n-                    // Erase the tokens if cfg-stripping modified the item\n-                    // This will cause us to synthesize fake tokens\n-                    // when `nt_to_tokenstream` is called on this item.\n-                    match &mut item {\n-                        Annotatable::Item(item) => item,\n-                        Annotatable::Stmt(stmt) => match &mut stmt.kind {\n-                            StmtKind::Item(item) => item,\n-                            _ => unreachable!(),\n-                        },\n-                        _ => unreachable!(),\n-                    }\n-                    .tokens = None;\n-                }\n-                ExpandResult::Ready(vec![item])\n-            }\n+            Ok(()) => ExpandResult::Ready(cfg_eval(ecx, item)),\n             Err(Indeterminate) => ExpandResult::Retry(item),\n         }\n     }"}, {"sha": "1017b23e5675a2d6513f2b167b24da12b6754117", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c310571a82e60496a27439104696b64fd65ee10/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c310571a82e60496a27439104696b64fd65ee10/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=9c310571a82e60496a27439104696b64fd65ee10", "patch": "@@ -24,6 +24,7 @@ mod asm;\n mod assert;\n mod cfg;\n mod cfg_accessible;\n+mod cfg_eval;\n mod compile_error;\n mod concat;\n mod concat_idents;\n@@ -89,6 +90,7 @@ pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n     register_attr! {\n         bench: test::expand_bench,\n         cfg_accessible: cfg_accessible::Expander,\n+        cfg_eval: cfg_eval::expand,\n         derive: derive::Expander,\n         global_allocator: global_allocator::expand,\n         test: test::expand_test,"}, {"sha": "666065efdfb43e331c663b13444028a184912555", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9c310571a82e60496a27439104696b64fd65ee10/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c310571a82e60496a27439104696b64fd65ee10/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=9c310571a82e60496a27439104696b64fd65ee10", "patch": "@@ -81,8 +81,22 @@ impl AstLike for Annotatable {\n         }\n     }\n \n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        panic!(\"Called finalize_tokens on an Annotatable: {:?}\", tokens);\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        match self {\n+            Annotatable::Item(item) => item.tokens_mut(),\n+            Annotatable::TraitItem(trait_item) => trait_item.tokens_mut(),\n+            Annotatable::ImplItem(impl_item) => impl_item.tokens_mut(),\n+            Annotatable::ForeignItem(foreign_item) => foreign_item.tokens_mut(),\n+            Annotatable::Stmt(stmt) => stmt.tokens_mut(),\n+            Annotatable::Expr(expr) => expr.tokens_mut(),\n+            Annotatable::Arm(arm) => arm.tokens_mut(),\n+            Annotatable::Field(field) => field.tokens_mut(),\n+            Annotatable::FieldPat(fp) => fp.tokens_mut(),\n+            Annotatable::GenericParam(gp) => gp.tokens_mut(),\n+            Annotatable::Param(p) => p.tokens_mut(),\n+            Annotatable::StructField(sf) => sf.tokens_mut(),\n+            Annotatable::Variant(v) => v.tokens_mut(),\n+        }\n     }\n }\n "}, {"sha": "a23731cf309a41a7749ad778779e5c31a6013d56", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 6, "deletions": 169, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/9c310571a82e60496a27439104696b64fd65ee10/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c310571a82e60496a27439104696b64fd65ee10/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=9c310571a82e60496a27439104696b64fd65ee10", "patch": "@@ -1,8 +1,5 @@\n //! Conditional compilation stripping.\n \n-use crate::base::Annotatable;\n-\n-use rustc_ast::mut_visit::*;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{DelimToken, Token, TokenKind};\n use rustc_ast::tokenstream::{DelimSpan, LazyTokenStream, Spacing, TokenStream, TokenTree};\n@@ -22,8 +19,6 @@ use rustc_span::edition::{Edition, ALL_EDITIONS};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n-use smallvec::SmallVec;\n-\n /// A folder that strips out items that do not belong in the current configuration.\n pub struct StripUnconfigured<'a> {\n     pub sess: &'a Session,\n@@ -272,7 +267,7 @@ impl<'a> StripUnconfigured<'a> {\n     /// Gives compiler warnings if any `cfg_attr` does not contain any\n     /// attributes and is in the original source code. Gives compiler errors if\n     /// the syntax of any `cfg_attr` is incorrect.\n-    pub fn process_cfg_attrs<T: AstLike>(&mut self, node: &mut T) {\n+    fn process_cfg_attrs<T: AstLike>(&mut self, node: &mut T) {\n         node.visit_attrs(|attrs| {\n             attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n         });\n@@ -387,7 +382,7 @@ impl<'a> StripUnconfigured<'a> {\n     }\n \n     /// Determines if a node with the given attributes should be included in this configuration.\n-    pub fn in_cfg(&self, attrs: &[Attribute]) -> bool {\n+    fn in_cfg(&self, attrs: &[Attribute]) -> bool {\n         attrs.iter().all(|attr| {\n             if !is_cfg(self.sess, attr) {\n                 return true;\n@@ -427,16 +422,8 @@ impl<'a> StripUnconfigured<'a> {\n         })\n     }\n \n-    /// Visit attributes on expression and statements (but not attributes on items in blocks).\n-    fn visit_expr_attrs(&mut self, attrs: &[Attribute]) {\n-        // flag the offending attributes\n-        for attr in attrs.iter() {\n-            self.maybe_emit_expr_attr_err(attr);\n-        }\n-    }\n-\n     /// If attributes are not allowed on expressions, emit an error for `attr`\n-    pub fn maybe_emit_expr_attr_err(&self, attr: &Attribute) {\n+    crate fn maybe_emit_expr_attr_err(&self, attr: &Attribute) {\n         if !self.features.map_or(true, |features| features.stmt_expr_attributes) {\n             let mut err = feature_err(\n                 &self.sess.parse_sess,\n@@ -453,49 +440,10 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n-    pub fn configure_foreign_mod(&mut self, foreign_mod: &mut ast::ForeignMod) {\n-        let ast::ForeignMod { unsafety: _, abi: _, items } = foreign_mod;\n-        items.flat_map_in_place(|item| self.configure(item));\n-    }\n-\n-    fn configure_variant_data(&mut self, vdata: &mut ast::VariantData) {\n-        match vdata {\n-            ast::VariantData::Struct(fields, ..) | ast::VariantData::Tuple(fields, _) => {\n-                fields.flat_map_in_place(|field| self.configure(field))\n-            }\n-            ast::VariantData::Unit(_) => {}\n-        }\n-    }\n-\n-    pub fn configure_item_kind(&mut self, item: &mut ast::ItemKind) {\n-        match item {\n-            ast::ItemKind::Struct(def, _generics) | ast::ItemKind::Union(def, _generics) => {\n-                self.configure_variant_data(def)\n-            }\n-            ast::ItemKind::Enum(ast::EnumDef { variants }, _generics) => {\n-                variants.flat_map_in_place(|variant| self.configure(variant));\n-                for variant in variants {\n-                    self.configure_variant_data(&mut variant.data);\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    pub fn configure_expr_kind(&mut self, expr_kind: &mut ast::ExprKind) {\n-        match expr_kind {\n-            ast::ExprKind::Match(_m, arms) => {\n-                arms.flat_map_in_place(|arm| self.configure(arm));\n-            }\n-            ast::ExprKind::Struct(_path, fields, _base) => {\n-                fields.flat_map_in_place(|field| self.configure(field));\n-            }\n-            _ => {}\n-        }\n-    }\n-\n     pub fn configure_expr(&mut self, expr: &mut P<ast::Expr>) {\n-        self.visit_expr_attrs(expr.attrs());\n+        for attr in expr.attrs.iter() {\n+            self.maybe_emit_expr_attr_err(attr);\n+        }\n \n         // If an expr is valid to cfg away it will have been removed by the\n         // outer stmt or expression folder before descending in here.\n@@ -511,117 +459,6 @@ impl<'a> StripUnconfigured<'a> {\n \n         self.process_cfg_attrs(expr)\n     }\n-\n-    pub fn configure_pat(&mut self, pat: &mut P<ast::Pat>) {\n-        if let ast::PatKind::Struct(_path, fields, _etc) = &mut pat.kind {\n-            fields.flat_map_in_place(|field| self.configure(field));\n-        }\n-    }\n-\n-    pub fn configure_fn_decl(&mut self, fn_decl: &mut ast::FnDecl) {\n-        fn_decl.inputs.flat_map_in_place(|arg| self.configure(arg));\n-    }\n-\n-    pub fn fully_configure(&mut self, item: Annotatable) -> Annotatable {\n-        // Since the item itself has already been configured by the InvocationCollector,\n-        // we know that fold result vector will contain exactly one element\n-        match item {\n-            Annotatable::Item(item) => Annotatable::Item(self.flat_map_item(item).pop().unwrap()),\n-            Annotatable::TraitItem(item) => {\n-                Annotatable::TraitItem(self.flat_map_trait_item(item).pop().unwrap())\n-            }\n-            Annotatable::ImplItem(item) => {\n-                Annotatable::ImplItem(self.flat_map_impl_item(item).pop().unwrap())\n-            }\n-            Annotatable::ForeignItem(item) => {\n-                Annotatable::ForeignItem(self.flat_map_foreign_item(item).pop().unwrap())\n-            }\n-            Annotatable::Stmt(stmt) => {\n-                Annotatable::Stmt(stmt.map(|stmt| self.flat_map_stmt(stmt).pop().unwrap()))\n-            }\n-            Annotatable::Expr(mut expr) => Annotatable::Expr({\n-                self.visit_expr(&mut expr);\n-                expr\n-            }),\n-            Annotatable::Arm(arm) => Annotatable::Arm(self.flat_map_arm(arm).pop().unwrap()),\n-            Annotatable::Field(field) => {\n-                Annotatable::Field(self.flat_map_field(field).pop().unwrap())\n-            }\n-            Annotatable::FieldPat(fp) => {\n-                Annotatable::FieldPat(self.flat_map_field_pattern(fp).pop().unwrap())\n-            }\n-            Annotatable::GenericParam(param) => {\n-                Annotatable::GenericParam(self.flat_map_generic_param(param).pop().unwrap())\n-            }\n-            Annotatable::Param(param) => {\n-                Annotatable::Param(self.flat_map_param(param).pop().unwrap())\n-            }\n-            Annotatable::StructField(sf) => {\n-                Annotatable::StructField(self.flat_map_struct_field(sf).pop().unwrap())\n-            }\n-            Annotatable::Variant(v) => {\n-                Annotatable::Variant(self.flat_map_variant(v).pop().unwrap())\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a> MutVisitor for StripUnconfigured<'a> {\n-    fn visit_foreign_mod(&mut self, foreign_mod: &mut ast::ForeignMod) {\n-        self.configure_foreign_mod(foreign_mod);\n-        noop_visit_foreign_mod(foreign_mod, self);\n-    }\n-\n-    fn visit_item_kind(&mut self, item: &mut ast::ItemKind) {\n-        self.configure_item_kind(item);\n-        noop_visit_item_kind(item, self);\n-    }\n-\n-    fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n-        self.configure_expr(expr);\n-        self.configure_expr_kind(&mut expr.kind);\n-        noop_visit_expr(expr, self);\n-    }\n-\n-    fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        let mut expr = configure!(self, expr);\n-        self.configure_expr_kind(&mut expr.kind);\n-        noop_visit_expr(&mut expr, self);\n-        Some(expr)\n-    }\n-\n-    fn flat_map_generic_param(\n-        &mut self,\n-        param: ast::GenericParam,\n-    ) -> SmallVec<[ast::GenericParam; 1]> {\n-        noop_flat_map_generic_param(configure!(self, param), self)\n-    }\n-\n-    fn flat_map_stmt(&mut self, stmt: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n-        noop_flat_map_stmt(configure!(self, stmt), self)\n-    }\n-\n-    fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n-        noop_flat_map_item(configure!(self, item), self)\n-    }\n-\n-    fn flat_map_impl_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n-        noop_flat_map_assoc_item(configure!(self, item), self)\n-    }\n-\n-    fn flat_map_trait_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n-        noop_flat_map_assoc_item(configure!(self, item), self)\n-    }\n-\n-    fn visit_pat(&mut self, pat: &mut P<ast::Pat>) {\n-        self.configure_pat(pat);\n-        noop_visit_pat(pat, self)\n-    }\n-\n-    fn visit_fn_decl(&mut self, mut fn_decl: &mut P<ast::FnDecl>) {\n-        self.configure_fn_decl(&mut fn_decl);\n-        noop_visit_fn_decl(fn_decl, self);\n-    }\n }\n \n fn is_cfg(sess: &Session, attr: &Attribute) -> bool {"}, {"sha": "7512f46988c918cd27389694a279b41e03663502", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c310571a82e60496a27439104696b64fd65ee10/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c310571a82e60496a27439104696b64fd65ee10/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=9c310571a82e60496a27439104696b64fd65ee10", "patch": "@@ -72,6 +72,10 @@ impl<'a> Parser<'a> {\n         let cursor_snapshot = self.token_cursor.clone();\n \n         let (mut ret, trailing_token) = f(self, attrs.attrs)?;\n+        let tokens = match ret.tokens_mut() {\n+            Some(tokens) if tokens.is_none() => tokens,\n+            _ => return Ok(ret),\n+        };\n \n         // Produces a `TokenStream` on-demand. Using `cursor_snapshot`\n         // and `num_calls`, we can reconstruct the `TokenStream` seen\n@@ -128,14 +132,14 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let lazy_impl = LazyTokenStreamImpl {\n+        *tokens = Some(LazyTokenStream::new(LazyTokenStreamImpl {\n             start_token,\n             num_calls,\n             cursor_snapshot,\n             desugar_doc_comments: self.desugar_doc_comments,\n             append_unglued_token: self.token_cursor.append_unglued_token.clone(),\n-        };\n-        ret.finalize_tokens(LazyTokenStream::new(lazy_impl));\n+        }));\n+\n         Ok(ret)\n     }\n }"}, {"sha": "507eb1e1cbe8912129129d5b9717c4212ef00f17", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c310571a82e60496a27439104696b64fd65ee10/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c310571a82e60496a27439104696b64fd65ee10/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=9c310571a82e60496a27439104696b64fd65ee10", "patch": "@@ -344,6 +344,7 @@ symbols! {\n         cfg_attr,\n         cfg_attr_multi,\n         cfg_doctest,\n+        cfg_eval,\n         cfg_panic,\n         cfg_sanitize,\n         cfg_target_feature,"}, {"sha": "28fed9b8a14cd3886b1bfc75ac0ec2f5fcd2bed8", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c310571a82e60496a27439104696b64fd65ee10/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c310571a82e60496a27439104696b64fd65ee10/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=9c310571a82e60496a27439104696b64fd65ee10", "patch": "@@ -1452,6 +1452,18 @@ pub(crate) mod builtin {\n         /* compiler built-in */\n     }\n \n+    /// Expands all `#[cfg]` and `#[cfg_attr]` attributes in the code fragment it's applied to.\n+    #[cfg(not(bootstrap))]\n+    #[unstable(\n+        feature = \"cfg_eval\",\n+        issue = \"82679\",\n+        reason = \"`cfg_eval` is a recently implemented feature\"\n+    )]\n+    #[rustc_builtin_macro]\n+    pub macro cfg_eval($($tt:tt)*) {\n+        /* compiler built-in */\n+    }\n+\n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "5e8a8d252a23883c32ae7f72a0af520922c26e90", "filename": "library/core/src/prelude/v1.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c310571a82e60496a27439104696b64fd65ee10/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c310571a82e60496a27439104696b64fd65ee10/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs?ref=9c310571a82e60496a27439104696b64fd65ee10", "patch": "@@ -81,3 +81,12 @@ pub use crate::macros::builtin::derive;\n )]\n #[doc(no_inline)]\n pub use crate::macros::builtin::cfg_accessible;\n+\n+#[cfg(not(bootstrap))]\n+#[unstable(\n+    feature = \"cfg_eval\",\n+    issue = \"82679\",\n+    reason = \"`cfg_eval` is a recently implemented feature\"\n+)]\n+#[doc(no_inline)]\n+pub use crate::macros::builtin::cfg_eval;"}, {"sha": "acdf7550fe71d358adbc7c0b961cb8bcb1ee0c7a", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c310571a82e60496a27439104696b64fd65ee10/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c310571a82e60496a27439104696b64fd65ee10/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=9c310571a82e60496a27439104696b64fd65ee10", "patch": "@@ -234,6 +234,7 @@\n #![feature(box_syntax)]\n #![feature(c_variadic)]\n #![feature(cfg_accessible)]\n+#![cfg_attr(not(bootstrap), feature(cfg_eval))]\n #![feature(cfg_target_has_atomic)]\n #![feature(cfg_target_thread_local)]\n #![feature(char_error_internals)]"}, {"sha": "7181dc6e710e4e33d74fde17bb2e76d0bc172743", "filename": "library/std/src/prelude/v1.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c310571a82e60496a27439104696b64fd65ee10/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c310571a82e60496a27439104696b64fd65ee10/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs?ref=9c310571a82e60496a27439104696b64fd65ee10", "patch": "@@ -67,6 +67,15 @@ pub use core::prelude::v1::derive;\n #[doc(hidden)]\n pub use core::prelude::v1::cfg_accessible;\n \n+#[cfg(not(bootstrap))]\n+#[unstable(\n+    feature = \"cfg_eval\",\n+    issue = \"82679\",\n+    reason = \"`cfg_eval` is a recently implemented feature\"\n+)]\n+#[doc(hidden)]\n+pub use core::prelude::v1::cfg_eval;\n+\n // The file so far is equivalent to src/libcore/prelude/v1.rs,\n // and below to src/liballoc/prelude.rs.\n // Those files are duplicated rather than using glob imports"}, {"sha": "379491f3126b06e0e978a035e74a87f492284454", "filename": "src/test/ui/proc-macro/cfg-eval-fail.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c310571a82e60496a27439104696b64fd65ee10/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c310571a82e60496a27439104696b64fd65ee10/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval-fail.rs?ref=9c310571a82e60496a27439104696b64fd65ee10", "patch": "@@ -0,0 +1,9 @@\n+#![feature(cfg_eval)]\n+#![feature(stmt_expr_attributes)]\n+\n+fn main() {\n+    let _ = #[cfg_eval] #[cfg(FALSE)] 0;\n+    //~^ ERROR removing an expression is not supported in this position\n+    //~| ERROR removing an expression is not supported in this position\n+    //~| ERROR removing an expression is not supported in this position\n+}"}, {"sha": "010ac006b0bee3b8e69eb8135c234d9d9d98190e", "filename": "src/test/ui/proc-macro/cfg-eval-fail.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9c310571a82e60496a27439104696b64fd65ee10/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c310571a82e60496a27439104696b64fd65ee10/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval-fail.stderr?ref=9c310571a82e60496a27439104696b64fd65ee10", "patch": "@@ -0,0 +1,20 @@\n+error: removing an expression is not supported in this position\n+  --> $DIR/cfg-eval-fail.rs:5:25\n+   |\n+LL |     let _ = #[cfg_eval] #[cfg(FALSE)] 0;\n+   |                         ^^^^^^^^^^^^^\n+\n+error: removing an expression is not supported in this position\n+  --> $DIR/cfg-eval-fail.rs:5:25\n+   |\n+LL |     let _ = #[cfg_eval] #[cfg(FALSE)] 0;\n+   |                         ^^^^^^^^^^^^^\n+\n+error: removing an expression is not supported in this position\n+  --> $DIR/cfg-eval-fail.rs:5:25\n+   |\n+LL |     let _ = #[cfg_eval] #[cfg(FALSE)] 0;\n+   |                         ^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "ea397df545265510905871f8812d0cb80fdd88b6", "filename": "src/test/ui/proc-macro/cfg-eval.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9c310571a82e60496a27439104696b64fd65ee10/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c310571a82e60496a27439104696b64fd65ee10/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval.rs?ref=9c310571a82e60496a27439104696b64fd65ee10", "patch": "@@ -0,0 +1,32 @@\n+// check-pass\n+// compile-flags: -Z span-debug\n+// aux-build:test-macros.rs\n+\n+#![feature(cfg_eval)]\n+#![feature(proc_macro_hygiene)]\n+#![feature(stmt_expr_attributes)]\n+\n+#![no_std] // Don't load unnecessary hygiene information from std\n+extern crate std;\n+\n+#[macro_use]\n+extern crate test_macros;\n+\n+#[cfg_eval]\n+#[print_attr]\n+struct S1 {\n+    #[cfg(FALSE)]\n+    field_false: u8,\n+    #[cfg(all(/*true*/))]\n+    #[cfg_attr(FALSE, unknown_attr)]\n+    #[cfg_attr(all(/*true*/), allow())]\n+    field_true: u8,\n+}\n+\n+#[cfg_eval]\n+#[cfg(FALSE)]\n+struct S2 {}\n+\n+fn main() {\n+    let _ = #[cfg_eval] #[print_attr](#[cfg(FALSE)] 0, #[cfg(all(/*true*/))] 1);\n+}"}, {"sha": "b98e8961bfea712063544b3bc5a9690b41e75a91", "filename": "src/test/ui/proc-macro/cfg-eval.stdout", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/9c310571a82e60496a27439104696b64fd65ee10/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9c310571a82e60496a27439104696b64fd65ee10/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval.stdout?ref=9c310571a82e60496a27439104696b64fd65ee10", "patch": "@@ -0,0 +1,135 @@\n+PRINT-ATTR INPUT (DISPLAY): struct S1 { #[cfg(all())] #[allow()] field_true : u8, }\n+PRINT-ATTR INPUT (DEBUG): TokenStream [\n+    Ident {\n+        ident: \"struct\",\n+        span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+    },\n+    Ident {\n+        ident: \"S1\",\n+        span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+    },\n+    Group {\n+        delimiter: Brace,\n+        stream: TokenStream [\n+            Punct {\n+                ch: '#',\n+                spacing: Alone,\n+                span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+            },\n+            Group {\n+                delimiter: Bracket,\n+                stream: TokenStream [\n+                    Ident {\n+                        ident: \"cfg\",\n+                        span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+                    },\n+                    Group {\n+                        delimiter: Parenthesis,\n+                        stream: TokenStream [\n+                            Ident {\n+                                ident: \"all\",\n+                                span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+                            },\n+                            Group {\n+                                delimiter: Parenthesis,\n+                                stream: TokenStream [],\n+                                span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+                            },\n+                        ],\n+                        span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+                    },\n+                ],\n+                span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+            },\n+            Punct {\n+                ch: '#',\n+                spacing: Alone,\n+                span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+            },\n+            Group {\n+                delimiter: Bracket,\n+                stream: TokenStream [\n+                    Ident {\n+                        ident: \"allow\",\n+                        span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+                    },\n+                    Group {\n+                        delimiter: Parenthesis,\n+                        stream: TokenStream [],\n+                        span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+                    },\n+                ],\n+                span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+            },\n+            Ident {\n+                ident: \"field_true\",\n+                span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+            },\n+            Punct {\n+                ch: ':',\n+                spacing: Alone,\n+                span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+            },\n+            Ident {\n+                ident: \"u8\",\n+                span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+            },\n+            Punct {\n+                ch: ',',\n+                spacing: Alone,\n+                span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+            },\n+        ],\n+        span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+    },\n+]\n+PRINT-ATTR INPUT (DISPLAY): (#[cfg(all())] 1,)\n+PRINT-ATTR INPUT (DEBUG): TokenStream [\n+    Group {\n+        delimiter: Parenthesis,\n+        stream: TokenStream [\n+            Punct {\n+                ch: '#',\n+                spacing: Alone,\n+                span: $DIR/cfg-eval.rs:31:38: 31:80 (#0),\n+            },\n+            Group {\n+                delimiter: Bracket,\n+                stream: TokenStream [\n+                    Ident {\n+                        ident: \"cfg\",\n+                        span: $DIR/cfg-eval.rs:31:38: 31:80 (#0),\n+                    },\n+                    Group {\n+                        delimiter: Parenthesis,\n+                        stream: TokenStream [\n+                            Ident {\n+                                ident: \"all\",\n+                                span: $DIR/cfg-eval.rs:31:38: 31:80 (#0),\n+                            },\n+                            Group {\n+                                delimiter: Parenthesis,\n+                                stream: TokenStream [],\n+                                span: $DIR/cfg-eval.rs:31:38: 31:80 (#0),\n+                            },\n+                        ],\n+                        span: $DIR/cfg-eval.rs:31:38: 31:80 (#0),\n+                    },\n+                ],\n+                span: $DIR/cfg-eval.rs:31:38: 31:80 (#0),\n+            },\n+            Literal {\n+                kind: Integer,\n+                symbol: \"1\",\n+                suffix: None,\n+                span: $DIR/cfg-eval.rs:31:38: 31:80 (#0),\n+            },\n+            Punct {\n+                ch: ',',\n+                spacing: Alone,\n+                span: $DIR/cfg-eval.rs:31:38: 31:80 (#0),\n+            },\n+        ],\n+        span: $DIR/cfg-eval.rs:31:38: 31:80 (#0),\n+    },\n+]"}]}