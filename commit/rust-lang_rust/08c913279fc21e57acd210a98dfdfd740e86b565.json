{"sha": "08c913279fc21e57acd210a98dfdfd740e86b565", "node_id": "C_kwDOAAsO6NoAKDA4YzkxMzI3OWZjMjFlNTdhY2QyMTBhOThkZmRmZDc0MGU4NmI1NjU", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-17T03:14:27Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-17T15:39:05Z"}, "message": "Pass the right HIR back from get_fn_decl", "tree": {"sha": "403cfcbda395f2fc4bfe2f4709ee4684012bf299", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/403cfcbda395f2fc4bfe2f4709ee4684012bf299"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08c913279fc21e57acd210a98dfdfd740e86b565", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08c913279fc21e57acd210a98dfdfd740e86b565", "html_url": "https://github.com/rust-lang/rust/commit/08c913279fc21e57acd210a98dfdfd740e86b565", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08c913279fc21e57acd210a98dfdfd740e86b565/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c50c62d225e004f5b488006d3d205a34363a128c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c50c62d225e004f5b488006d3d205a34363a128c", "html_url": "https://github.com/rust-lang/rust/commit/c50c62d225e004f5b488006d3d205a34363a128c"}], "stats": {"total": 111, "additions": 75, "deletions": 36}, "files": [{"sha": "035ccf30b2462acf81ee418989b1c638c9cfa3aa", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08c913279fc21e57acd210a98dfdfd740e86b565/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08c913279fc21e57acd210a98dfdfd740e86b565/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=08c913279fc21e57acd210a98dfdfd740e86b565", "patch": "@@ -299,7 +299,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             {\n                 // check that the `if` expr without `else` is the fn body's expr\n                 if expr.span == sp {\n-                    return self.get_fn_decl(hir_id).and_then(|(fn_decl, _)| {\n+                    return self.get_fn_decl(hir_id).and_then(|(_, fn_decl, _)| {\n                         let span = fn_decl.output.span();\n                         let snippet = self.tcx.sess.source_map().span_to_snippet(span).ok()?;\n                         Some((span, format!(\"expected `{snippet}` because of this return type\")))"}, {"sha": "a27905ea46c9453880193876b3c3aab59acf3dfb", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/08c913279fc21e57acd210a98dfdfd740e86b565/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08c913279fc21e57acd210a98dfdfd740e86b565/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=08c913279fc21e57acd210a98dfdfd740e86b565", "patch": "@@ -1722,20 +1722,21 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                     fcx.suggest_semicolon_at_end(cond_expr.span, &mut err);\n                 }\n             }\n-            fcx.get_node_fn_decl(parent).map(|(fn_decl, _, is_main)| (fn_decl, is_main))\n+            fcx.get_node_fn_decl(parent)\n+                .map(|(fn_id, fn_decl, _, is_main)| (fn_id, fn_decl, is_main))\n         } else {\n             fcx.get_fn_decl(parent_id)\n         };\n \n-        if let Some((fn_decl, can_suggest)) = fn_decl {\n+        if let Some((fn_id, fn_decl, can_suggest)) = fn_decl {\n             if blk_id.is_none() {\n                 pointing_at_return_type |= fcx.suggest_missing_return_type(\n                     &mut err,\n                     &fn_decl,\n                     expected,\n                     found,\n                     can_suggest,\n-                    fcx.tcx.hir().get_parent_item(id).into(),\n+                    fn_id,\n                 );\n             }\n             if !pointing_at_return_type {\n@@ -1746,17 +1747,11 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         let parent_id = fcx.tcx.hir().get_parent_item(id);\n         let parent_item = fcx.tcx.hir().get_by_def_id(parent_id.def_id);\n \n-        if let (Some(expr), Some(_), Some((fn_decl, _, _))) =\n+        if let (Some(expr), Some(_), Some((fn_id, fn_decl, _, _))) =\n             (expression, blk_id, fcx.get_node_fn_decl(parent_item))\n         {\n             fcx.suggest_missing_break_or_return_expr(\n-                &mut err,\n-                expr,\n-                fn_decl,\n-                expected,\n-                found,\n-                id,\n-                parent_id.into(),\n+                &mut err, expr, fn_decl, expected, found, id, fn_id,\n             );\n         }\n \n@@ -1882,7 +1877,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n     }\n \n     fn is_return_ty_unsized<'a>(&self, fcx: &FnCtxt<'a, 'tcx>, blk_id: hir::HirId) -> bool {\n-        if let Some((fn_decl, _)) = fcx.get_fn_decl(blk_id)\n+        if let Some((_, fn_decl, _)) = fcx.get_fn_decl(blk_id)\n             && let hir::FnRetTy::Return(ty) = fn_decl.output\n             && let ty = fcx.astconv().ast_ty_to_ty( ty)\n             && let ty::Dynamic(..) = ty.kind()"}, {"sha": "d64b5728f3251088a0439ddd799c54403c836b0f", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08c913279fc21e57acd210a98dfdfd740e86b565/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08c913279fc21e57acd210a98dfdfd740e86b565/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=08c913279fc21e57acd210a98dfdfd740e86b565", "patch": "@@ -799,7 +799,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.ret_coercion_span.set(Some(expr.span));\n             }\n             let cause = self.cause(expr.span, ObligationCauseCode::ReturnNoExpression);\n-            if let Some((fn_decl, _)) = self.get_fn_decl(expr.hir_id) {\n+            if let Some((_, fn_decl, _)) = self.get_fn_decl(expr.hir_id) {\n                 coercion.coerce_forced_unit(\n                     self,\n                     &cause,"}, {"sha": "8455076de56348bb28d958e1d69c6a394ab548dd", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 42, "deletions": 19, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/08c913279fc21e57acd210a98dfdfd740e86b565/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08c913279fc21e57acd210a98dfdfd740e86b565/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=08c913279fc21e57acd210a98dfdfd740e86b565", "patch": "@@ -898,51 +898,74 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )\n     }\n \n-    /// Given a function `Node`, return its `FnDecl` if it exists, or `None` otherwise.\n+    /// Given a function `Node`, return its  `HirId` and `FnDecl` if it exists. Given a closure\n+    /// that is the child of a function, return that function's `HirId` and `FnDecl` instead.\n+    /// This may seem confusing at first, but this is used in diagnostics for `async fn`,\n+    /// for example, where most of the type checking actually happens within a nested closure,\n+    /// but we often want access to the parent function's signature.\n+    ///\n+    /// Otherwise, return false.\n     pub(in super::super) fn get_node_fn_decl(\n         &self,\n         node: Node<'tcx>,\n-    ) -> Option<(&'tcx hir::FnDecl<'tcx>, Ident, bool)> {\n+    ) -> Option<(hir::HirId, &'tcx hir::FnDecl<'tcx>, Ident, bool)> {\n         match node {\n-            Node::Item(&hir::Item { ident, kind: hir::ItemKind::Fn(ref sig, ..), .. }) => {\n+            Node::Item(&hir::Item {\n+                ident,\n+                kind: hir::ItemKind::Fn(ref sig, ..),\n+                owner_id,\n+                ..\n+            }) => {\n                 // This is less than ideal, it will not suggest a return type span on any\n                 // method called `main`, regardless of whether it is actually the entry point,\n                 // but it will still present it as the reason for the expected type.\n-                Some((&sig.decl, ident, ident.name != sym::main))\n+                Some((\n+                    hir::HirId::make_owner(owner_id.def_id),\n+                    &sig.decl,\n+                    ident,\n+                    ident.name != sym::main,\n+                ))\n             }\n             Node::TraitItem(&hir::TraitItem {\n                 ident,\n                 kind: hir::TraitItemKind::Fn(ref sig, ..),\n+                owner_id,\n                 ..\n-            }) => Some((&sig.decl, ident, true)),\n+            }) => Some((hir::HirId::make_owner(owner_id.def_id), &sig.decl, ident, true)),\n             Node::ImplItem(&hir::ImplItem {\n                 ident,\n                 kind: hir::ImplItemKind::Fn(ref sig, ..),\n+                owner_id,\n                 ..\n-            }) => Some((&sig.decl, ident, false)),\n-            Node::Expr(&hir::Expr {\n-                hir_id,\n-                kind: hir::ExprKind::Closure(..),\n-                ..\n-            }) if let Some(Node::Item(&hir::Item {\n+            }) => Some((hir::HirId::make_owner(owner_id.def_id), &sig.decl, ident, false)),\n+            Node::Expr(&hir::Expr { hir_id, kind: hir::ExprKind::Closure(..), .. })\n+                if let Some(Node::Item(&hir::Item {\n+                    ident,\n+                    kind: hir::ItemKind::Fn(ref sig, ..),\n+                    owner_id,\n+                    ..\n+                })) = self.tcx.hir().find_parent(hir_id) => Some((\n+                hir::HirId::make_owner(owner_id.def_id),\n+                &sig.decl,\n                 ident,\n-                kind: hir::ItemKind::Fn(ref sig, ..),\n-                ..\n-            })) = self.tcx.hir().find_parent(hir_id) => {\n-                Some((&sig.decl, ident, ident.name != sym::main))\n-            },\n+                ident.name != sym::main,\n+            )),\n             _ => None,\n         }\n     }\n \n-    /// Given a `HirId`, return the `FnDecl` of the method it is enclosed by and whether a\n+    /// Given a `HirId`, return the `HirId` of the enclosing function, its `FnDecl`, and whether a\n     /// suggestion can be made, `None` otherwise.\n-    pub fn get_fn_decl(&self, blk_id: hir::HirId) -> Option<(&'tcx hir::FnDecl<'tcx>, bool)> {\n+    pub fn get_fn_decl(\n+        &self,\n+        blk_id: hir::HirId,\n+    ) -> Option<(hir::HirId, &'tcx hir::FnDecl<'tcx>, bool)> {\n         // Get enclosing Fn, if it is a function or a trait method, unless there's a `loop` or\n         // `while` before reaching it, as block tail returns are not available in them.\n         self.tcx.hir().get_return_block(blk_id).and_then(|blk_id| {\n             let parent = self.tcx.hir().get(blk_id);\n-            self.get_node_fn_decl(parent).map(|(fn_decl, _, is_main)| (fn_decl, is_main))\n+            self.get_node_fn_decl(parent)\n+                .map(|(fn_id, fn_decl, _, is_main)| (fn_id, fn_decl, is_main))\n         })\n     }\n "}, {"sha": "61338ac613aea50cc8d2e9175c6184d8f215e741", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08c913279fc21e57acd210a98dfdfd740e86b565/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08c913279fc21e57acd210a98dfdfd740e86b565/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=08c913279fc21e57acd210a98dfdfd740e86b565", "patch": "@@ -1669,7 +1669,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Given a function block's `HirId`, returns its `FnDecl` if it exists, or `None` otherwise.\n     fn get_parent_fn_decl(&self, blk_id: hir::HirId) -> Option<(&'tcx hir::FnDecl<'tcx>, Ident)> {\n         let parent = self.tcx.hir().get_by_def_id(self.tcx.hir().get_parent_item(blk_id).def_id);\n-        self.get_node_fn_decl(parent).map(|(fn_decl, ident, _)| (fn_decl, ident))\n+        self.get_node_fn_decl(parent).map(|(_, fn_decl, ident, _)| (fn_decl, ident))\n     }\n \n     /// If `expr` is a `match` expression that has only one non-`!` arm, use that arm's tail"}, {"sha": "7a09ea40d7974b3b3af8b45e0039e79ff3728fb4", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08c913279fc21e57acd210a98dfdfd740e86b565/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08c913279fc21e57acd210a98dfdfd740e86b565/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=08c913279fc21e57acd210a98dfdfd740e86b565", "patch": "@@ -64,8 +64,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let expr = expr.peel_drop_temps();\n         self.suggest_missing_semicolon(err, expr, expected, false);\n         let mut pointing_at_return_type = false;\n-        if let Some((fn_decl, can_suggest)) = self.get_fn_decl(blk_id) {\n-            let fn_id = self.tcx.hir().get_return_block(blk_id).unwrap();\n+        if let Some((fn_id, fn_decl, can_suggest)) = self.get_fn_decl(blk_id) {\n             pointing_at_return_type = self.suggest_missing_return_type(\n                 err,\n                 &fn_decl,"}, {"sha": "459b94f943b502a22cddea3c6c265acce8de5370", "filename": "tests/ui/suggestions/suggest-ret-on-async-w-late.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/08c913279fc21e57acd210a98dfdfd740e86b565/tests%2Fui%2Fsuggestions%2Fsuggest-ret-on-async-w-late.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08c913279fc21e57acd210a98dfdfd740e86b565/tests%2Fui%2Fsuggestions%2Fsuggest-ret-on-async-w-late.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-ret-on-async-w-late.rs?ref=08c913279fc21e57acd210a98dfdfd740e86b565", "patch": "@@ -0,0 +1,11 @@\n+// edition: 2021\n+\n+// Make sure we don't ICE when suggesting a return type\n+// for an async fn that has late-bound vars...\n+\n+async fn ice(_: &i32) {\n+    true\n+    //~^ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "bff864b222bff9394fae69ed5bf277cc8ab890b9", "filename": "tests/ui/suggestions/suggest-ret-on-async-w-late.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/08c913279fc21e57acd210a98dfdfd740e86b565/tests%2Fui%2Fsuggestions%2Fsuggest-ret-on-async-w-late.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08c913279fc21e57acd210a98dfdfd740e86b565/tests%2Fui%2Fsuggestions%2Fsuggest-ret-on-async-w-late.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-ret-on-async-w-late.stderr?ref=08c913279fc21e57acd210a98dfdfd740e86b565", "patch": "@@ -0,0 +1,11 @@\n+error[E0308]: mismatched types\n+  --> $DIR/suggest-ret-on-async-w-late.rs:7:5\n+   |\n+LL | async fn ice(_: &i32) {\n+   |                       - help: try adding a return type: `-> bool`\n+LL |     true\n+   |     ^^^^ expected `()`, found `bool`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}