{"sha": "b6d774136b62b2df51555a325439126a29038da3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2ZDc3NDEzNmI2MmIyZGY1MTU1NWEzMjU0MzkxMjZhMjkwMzhkYTM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-11T18:50:02Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-11T21:25:34Z"}, "message": "stdlib: Add interior vector-ified versions of ebml and term", "tree": {"sha": "1aa7485778178c303cfa1ae8bf9c17d3bf1a0e1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1aa7485778178c303cfa1ae8bf9c17d3bf1a0e1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6d774136b62b2df51555a325439126a29038da3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6d774136b62b2df51555a325439126a29038da3", "html_url": "https://github.com/rust-lang/rust/commit/b6d774136b62b2df51555a325439126a29038da3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6d774136b62b2df51555a325439126a29038da3/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a84310aa481c667744ab006976ed98420d23798d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a84310aa481c667744ab006976ed98420d23798d", "html_url": "https://github.com/rust-lang/rust/commit/a84310aa481c667744ab006976ed98420d23798d"}], "stats": {"total": 255, "additions": 255, "deletions": 0}, "files": [{"sha": "64b9db5b2d094e43f488e585a675efea511eb7f3", "filename": "src/lib/ebmlivec.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/b6d774136b62b2df51555a325439126a29038da3/src%2Flib%2Febmlivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6d774136b62b2df51555a325439126a29038da3/src%2Flib%2Febmlivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febmlivec.rs?ref=b6d774136b62b2df51555a325439126a29038da3", "patch": "@@ -0,0 +1,172 @@\n+\n+\n+// Simple Extensible Binary Markup Language (ebml) reader and writer on a\n+// cursor model. See the specification here:\n+//     http://www.matroska.org/technical/specs/rfc/index.html\n+import option::none;\n+import option::some;\n+\n+type ebml_tag = rec(uint id, uint size);\n+\n+type ebml_state = rec(ebml_tag ebml_tag, uint tag_pos, uint data_pos);\n+\n+\n+// TODO: When we have module renaming, make \"reader\" and \"writer\" separate\n+// modules within this file.\n+\n+// ebml reading\n+type doc = rec(u8[] data, uint start, uint end);\n+\n+fn vint_at(&u8[] data, uint start) -> tup(uint, uint) {\n+    auto a = data.(start);\n+    if (a & 0x80u8 != 0u8) { ret tup(a & 0x7fu8 as uint, start + 1u); }\n+    if (a & 0x40u8 != 0u8) {\n+        ret tup((a & 0x3fu8 as uint) << 8u | (data.(start + 1u) as uint),\n+                start + 2u);\n+    } else if (a & 0x20u8 != 0u8) {\n+        ret tup((a & 0x1fu8 as uint) << 16u |\n+                    (data.(start + 1u) as uint) << 8u |\n+                    (data.(start + 2u) as uint), start + 3u);\n+    } else if (a & 0x10u8 != 0u8) {\n+        ret tup((a & 0x0fu8 as uint) << 24u |\n+                    (data.(start + 1u) as uint) << 16u |\n+                    (data.(start + 2u) as uint) << 8u |\n+                    (data.(start + 3u) as uint), start + 4u);\n+    } else { log_err \"vint too big\"; fail; }\n+}\n+\n+fn new_doc(&u8[] data) -> doc {\n+    ret rec(data=data, start=0u, end=ivec::len[u8](data));\n+}\n+\n+fn doc_at(&u8[] data, uint start) -> doc {\n+    auto elt_tag = vint_at(data, start);\n+    auto elt_size = vint_at(data, elt_tag._1);\n+    auto end = elt_size._1 + elt_size._0;\n+    ret rec(data=data, start=elt_size._1, end=end);\n+}\n+\n+fn maybe_get_doc(doc d, uint tg) -> option::t[doc] {\n+    auto pos = d.start;\n+    while (pos < d.end) {\n+        auto elt_tag = vint_at(d.data, pos);\n+        auto elt_size = vint_at(d.data, elt_tag._1);\n+        pos = elt_size._1 + elt_size._0;\n+        if (elt_tag._0 == tg) {\n+            ret some[doc](rec(data=d.data, start=elt_size._1, end=pos));\n+        }\n+    }\n+    ret none[doc];\n+}\n+\n+fn get_doc(doc d, uint tg) -> doc {\n+    alt (maybe_get_doc(d, tg)) {\n+        case (some(?d)) { ret d; }\n+        case (none) {\n+            log_err \"failed to find block with tag \" + uint::to_str(tg, 10u);\n+            fail;\n+        }\n+    }\n+}\n+\n+iter docs(doc d) -> tup(uint, doc) {\n+    auto pos = d.start;\n+    while (pos < d.end) {\n+        auto elt_tag = vint_at(d.data, pos);\n+        auto elt_size = vint_at(d.data, elt_tag._1);\n+        pos = elt_size._1 + elt_size._0;\n+        put tup(elt_tag._0, rec(data=d.data, start=elt_size._1, end=pos));\n+    }\n+}\n+\n+iter tagged_docs(doc d, uint tg) -> doc {\n+    auto pos = d.start;\n+    while (pos < d.end) {\n+        auto elt_tag = vint_at(d.data, pos);\n+        auto elt_size = vint_at(d.data, elt_tag._1);\n+        pos = elt_size._1 + elt_size._0;\n+        if (elt_tag._0 == tg) {\n+            put rec(data=d.data, start=elt_size._1, end=pos);\n+        }\n+    }\n+}\n+\n+fn doc_data(doc d) -> u8[] { ret ivec::slice[u8](d.data, d.start, d.end); }\n+\n+fn be_uint_from_bytes(&u8[] data, uint start, uint size) -> uint {\n+    auto sz = size;\n+    assert (sz <= 4u);\n+    auto val = 0u;\n+    auto pos = start;\n+    while (sz > 0u) {\n+        sz -= 1u;\n+        val += (data.(pos) as uint) << sz * 8u;\n+        pos += 1u;\n+    }\n+    ret val;\n+}\n+\n+fn doc_as_uint(doc d) -> uint {\n+    ret be_uint_from_bytes(d.data, d.start, d.end - d.start);\n+}\n+\n+\n+// ebml writing\n+type writer = rec(ioivec::buf_writer writer, mutable uint[] size_positions);\n+\n+fn write_sized_vint(&ioivec::buf_writer w, uint n, uint size) {\n+    let u8[] buf;\n+    alt (size) {\n+        case (1u) { buf = ~[0x80u8 | (n as u8)]; }\n+        case (2u) { buf = ~[0x40u8 | (n >> 8u as u8), n & 0xffu as u8]; }\n+        case (3u) {\n+            buf =\n+                ~[0x20u8 | (n >> 16u as u8), n >> 8u & 0xffu as u8,\n+                  n & 0xffu as u8];\n+        }\n+        case (4u) {\n+            buf =\n+                ~[0x10u8 | (n >> 24u as u8), n >> 16u & 0xffu as u8,\n+                  n >> 8u & 0xffu as u8, n & 0xffu as u8];\n+        }\n+        case (_) { log_err \"vint to write too big\"; fail; }\n+    }\n+    w.write(buf);\n+}\n+\n+fn write_vint(&ioivec::buf_writer w, uint n) {\n+    if (n < 0x7fu) { write_sized_vint(w, n, 1u); ret; }\n+    if (n < 0x4000u) { write_sized_vint(w, n, 2u); ret; }\n+    if (n < 0x200000u) { write_sized_vint(w, n, 3u); ret; }\n+    if (n < 0x10000000u) { write_sized_vint(w, n, 4u); ret; }\n+    log_err \"vint to write too big\";\n+    fail;\n+}\n+\n+fn create_writer(&ioivec::buf_writer w) -> writer {\n+    let uint[] size_positions = ~[];\n+    ret rec(writer=w, mutable size_positions=size_positions);\n+}\n+\n+\n+// TODO: Provide a function to write the standard ebml header.\n+fn start_tag(&writer w, uint tag_id) {\n+    // Write the tag ID:\n+\n+    write_vint(w.writer, tag_id);\n+    // Write a placeholder four-byte size.\n+\n+    w.size_positions += ~[w.writer.tell()];\n+    let u8[] zeroes = ~[0u8, 0u8, 0u8, 0u8];\n+    w.writer.write(zeroes);\n+}\n+\n+fn end_tag(&writer w) {\n+    auto last_size_pos = ivec::pop[uint](w.size_positions);\n+    auto cur_pos = w.writer.tell();\n+    w.writer.seek(last_size_pos as int, ioivec::seek_set);\n+    write_sized_vint(w.writer, cur_pos - last_size_pos - 4u, 4u);\n+    w.writer.seek(cur_pos as int, ioivec::seek_set);\n+}\n+// TODO: optionally perform \"relaxations\" on end_tag to more efficiently\n+// encode sizes; this is a fixed point iteration"}, {"sha": "622a9563c8749222b24aa7aaf242e3c08687ee6c", "filename": "src/lib/std.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6d774136b62b2df51555a325439126a29038da3/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/b6d774136b62b2df51555a325439126a29038da3/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=b6d774136b62b2df51555a325439126a29038da3", "patch": "@@ -90,6 +90,8 @@ mod smallintmap;\n mod ptr;\n mod test;\n mod unsafe;\n+mod ebmlivec;\n+mod termivec;\n \n // Local Variables:\n // mode: rust;"}, {"sha": "d80c17fcf626772a9815cb4552d6e5a2eab1407b", "filename": "src/lib/termivec.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/b6d774136b62b2df51555a325439126a29038da3/src%2Flib%2Ftermivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6d774136b62b2df51555a325439126a29038da3/src%2Flib%2Ftermivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftermivec.rs?ref=b6d774136b62b2df51555a325439126a29038da3", "patch": "@@ -0,0 +1,81 @@\n+\n+\n+\n+// Simple ANSI color library.\n+//\n+// TODO: Windows support.\n+const u8 color_black = 0u8;\n+\n+const u8 color_red = 1u8;\n+\n+const u8 color_green = 2u8;\n+\n+const u8 color_yellow = 3u8;\n+\n+const u8 color_blue = 4u8;\n+\n+const u8 color_magenta = 5u8;\n+\n+const u8 color_cyan = 6u8;\n+\n+const u8 color_light_gray = 7u8;\n+\n+const u8 color_light_grey = 7u8;\n+\n+const u8 color_dark_gray = 8u8;\n+\n+const u8 color_dark_grey = 8u8;\n+\n+const u8 color_bright_red = 9u8;\n+\n+const u8 color_bright_green = 10u8;\n+\n+const u8 color_bright_yellow = 11u8;\n+\n+const u8 color_bright_blue = 12u8;\n+\n+const u8 color_bright_magenta = 13u8;\n+\n+const u8 color_bright_cyan = 14u8;\n+\n+const u8 color_bright_white = 15u8;\n+\n+fn esc(ioivec::buf_writer writer) { writer.write(~[0x1bu8, '[' as u8]); }\n+\n+fn reset(ioivec::buf_writer writer) {\n+    esc(writer);\n+    writer.write(~['0' as u8, 'm' as u8]);\n+}\n+\n+fn color_supported() -> bool {\n+    auto supported_terms = [\"xterm-color\", \"xterm\", \"screen-bce\"];\n+    ret alt (generic_os::getenv(\"TERM\")) {\n+            case (option::some(?env)) { vec::member(env, supported_terms) }\n+            case (option::none) { false }\n+        };\n+}\n+\n+fn set_color(ioivec::buf_writer writer, u8 first_char, u8 color) {\n+    assert (color < 16u8);\n+    esc(writer);\n+    if (color >= 8u8) { writer.write(~['1' as u8, ';' as u8]); color -= 8u8; }\n+    writer.write(~[first_char, ('0' as u8) + color, 'm' as u8]);\n+}\n+\n+fn fg(ioivec::buf_writer writer, u8 color) {\n+    ret set_color(writer, '3' as u8, color);\n+}\n+\n+fn bg(ioivec::buf_writer writer, u8 color) {\n+    ret set_color(writer, '4' as u8, color);\n+}\n+// export fg;\n+// export bg;\n+\n+// Local Variables:\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}]}