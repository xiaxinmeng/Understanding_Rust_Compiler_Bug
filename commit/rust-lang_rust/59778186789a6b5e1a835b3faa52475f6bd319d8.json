{"sha": "59778186789a6b5e1a835b3faa52475f6bd319d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5Nzc4MTg2Nzg5YTZiNWUxYTgzNWIzZmFhNTI0NzVmNmJkMzE5ZDg=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-04-14T01:04:38Z"}, "committer": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-04-17T15:54:10Z"}, "message": "run rustfmt on rustc_driver/driver.rs", "tree": {"sha": "a51364065c028196bc1aafcc5199388b9eb3246d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a51364065c028196bc1aafcc5199388b9eb3246d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59778186789a6b5e1a835b3faa52475f6bd319d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59778186789a6b5e1a835b3faa52475f6bd319d8", "html_url": "https://github.com/rust-lang/rust/commit/59778186789a6b5e1a835b3faa52475f6bd319d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59778186789a6b5e1a835b3faa52475f6bd319d8/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d6d9f98d1ac09013edf63344f9f21e1a704993d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d6d9f98d1ac09013edf63344f9f21e1a704993d", "html_url": "https://github.com/rust-lang/rust/commit/3d6d9f98d1ac09013edf63344f9f21e1a704993d"}], "stats": {"total": 1136, "additions": 610, "deletions": 526}, "files": [{"sha": "f8c0289cc98c870269fa62bc9a34073a635f028b", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 610, "deletions": 526, "changes": 1136, "blob_url": "https://github.com/rust-lang/rust/blob/59778186789a6b5e1a835b3faa52475f6bd319d8/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59778186789a6b5e1a835b3faa52475f6bd319d8/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=59778186789a6b5e1a835b3faa52475f6bd319d8", "patch": "@@ -14,17 +14,17 @@ use rustc::hir::lowering::lower_crate;\n use rustc::ich::Fingerprint;\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_mir as mir;\n-use rustc::session::{Session, CompileResult, CrateDisambiguator};\n+use rustc::session::{CompileResult, CrateDisambiguator, Session};\n use rustc::session::CompileIncomplete;\n use rustc::session::config::{self, Input, OutputFilenames, OutputType};\n use rustc::session::search_paths::PathKind;\n use rustc::lint;\n-use rustc::middle::{self, stability, reachable, resolve_lifetime};\n+use rustc::middle::{self, reachable, resolve_lifetime, stability};\n use rustc::middle::cstore::CrateStore;\n use rustc::middle::privacy::AccessLevels;\n-use rustc::ty::{self, TyCtxt, Resolutions, AllArenas};\n+use rustc::ty::{self, AllArenas, Resolutions, TyCtxt};\n use rustc::traits;\n-use rustc::util::common::{ErrorReported, time, install_panic_hook};\n+use rustc::util::common::{install_panic_hook, time, ErrorReported};\n use rustc_allocator as allocator;\n use rustc_borrowck as borrowck;\n use rustc_incremental;\n@@ -37,14 +37,14 @@ use rustc_typeck as typeck;\n use rustc_privacy;\n use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n-use rustc_passes::{self, ast_validation, loops, rvalue_promotion, hir_stats};\n+use rustc_passes::{self, ast_validation, hir_stats, loops, rvalue_promotion};\n use super::Compilation;\n \n use serialize::json;\n \n use std::any::Any;\n use std::env;\n-use std::ffi::{OsString, OsStr};\n+use std::ffi::{OsStr, OsString};\n use std::fs;\n use std::io::{self, Write};\n use std::iter;\n@@ -64,15 +64,17 @@ use pretty::ReplaceBodyWithLoop;\n \n use profile;\n \n-pub fn compile_input(trans: Box<TransCrate>,\n-                     sess: &Session,\n-                     cstore: &CStore,\n-                     input_path: &Option<PathBuf>,\n-                     input: &Input,\n-                     outdir: &Option<PathBuf>,\n-                     output: &Option<PathBuf>,\n-                     addl_plugins: Option<Vec<String>>,\n-                     control: &CompileController) -> CompileResult {\n+pub fn compile_input(\n+    trans: Box<TransCrate>,\n+    sess: &Session,\n+    cstore: &CStore,\n+    input_path: &Option<PathBuf>,\n+    input: &Input,\n+    outdir: &Option<PathBuf>,\n+    output: &Option<PathBuf>,\n+    addl_plugins: Option<Vec<String>>,\n+    control: &CompileController,\n+) -> CompileResult {\n     macro_rules! controller_entry_point {\n         ($point: ident, $tsess: expr, $make_state: expr, $phase_result: expr) => {{\n             let state = &mut $make_state;\n@@ -106,16 +108,9 @@ pub fn compile_input(trans: Box<TransCrate>,\n         };\n \n         let (krate, registry) = {\n-            let mut compile_state = CompileState::state_after_parse(input,\n-                                                                    sess,\n-                                                                    outdir,\n-                                                                    output,\n-                                                                    krate,\n-                                                                    &cstore);\n-            controller_entry_point!(after_parse,\n-                                    sess,\n-                                    compile_state,\n-                                    Ok(()));\n+            let mut compile_state =\n+                CompileState::state_after_parse(input, sess, outdir, output, krate, &cstore);\n+            controller_entry_point!(after_parse, sess, compile_state, Ok(()));\n \n             (compile_state.krate.unwrap(), compile_state.registry)\n         };\n@@ -125,7 +120,13 @@ pub fn compile_input(trans: Box<TransCrate>,\n             ::rustc_trans_utils::link::find_crate_name(Some(sess), &krate.attrs, input);\n         install_panic_hook();\n \n-        let ExpansionResult { expanded_crate, defs, analysis, resolutions, mut hir_forest } = {\n+        let ExpansionResult {\n+            expanded_crate,\n+            defs,\n+            analysis,\n+            resolutions,\n+            mut hir_forest,\n+        } = {\n             phase_2_configure_and_expand(\n                 sess,\n                 &cstore,\n@@ -136,11 +137,17 @@ pub fn compile_input(trans: Box<TransCrate>,\n                 control.make_glob_map,\n                 |expanded_crate| {\n                     let mut state = CompileState::state_after_expand(\n-                        input, sess, outdir, output, &cstore, expanded_crate, &crate_name,\n+                        input,\n+                        sess,\n+                        outdir,\n+                        output,\n+                        &cstore,\n+                        expanded_crate,\n+                        &crate_name,\n                     );\n                     controller_entry_point!(after_expand, sess, state, Ok(()));\n                     Ok(())\n-                }\n+                },\n             )?\n         };\n \n@@ -152,24 +159,28 @@ pub fn compile_input(trans: Box<TransCrate>,\n                 if output_contains_path(&output_paths, input_path) {\n                     sess.err(&format!(\n                         \"the input file \\\"{}\\\" would be overwritten by the generated \\\n-                        executable\",\n-                        input_path.display()));\n+                         executable\",\n+                        input_path.display()\n+                    ));\n                     return Err(CompileIncomplete::Stopped);\n                 }\n                 if let Some(dir_path) = output_conflicts_with_dir(&output_paths) {\n                     sess.err(&format!(\n                         \"the generated executable for the input file \\\"{}\\\" conflicts with the \\\n-                        existing directory \\\"{}\\\"\",\n-                        input_path.display(), dir_path.display()));\n+                         existing directory \\\"{}\\\"\",\n+                        input_path.display(),\n+                        dir_path.display()\n+                    ));\n                     return Err(CompileIncomplete::Stopped);\n                 }\n             }\n         }\n \n         write_out_deps(sess, &outputs, &output_paths);\n-        if sess.opts.output_types.contains_key(&OutputType::DepInfo) &&\n-            sess.opts.output_types.len() == 1 {\n-            return Ok(())\n+        if sess.opts.output_types.contains_key(&OutputType::DepInfo)\n+            && sess.opts.output_types.len() == 1\n+        {\n+            return Ok(());\n         }\n \n         if let &Some(ref dir) = outdir {\n@@ -182,28 +193,32 @@ pub fn compile_input(trans: Box<TransCrate>,\n         let arenas = AllArenas::new();\n \n         // Construct the HIR map\n-        let hir_map = time(sess,\n-                           \"indexing hir\",\n-                           || hir_map::map_crate(sess, cstore, &mut hir_forest, &defs));\n+        let hir_map = time(sess, \"indexing hir\", || {\n+            hir_map::map_crate(sess, cstore, &mut hir_forest, &defs)\n+        });\n \n         {\n             hir_map.dep_graph.assert_ignored();\n-            controller_entry_point!(after_hir_lowering,\n-                                    sess,\n-                                    CompileState::state_after_hir_lowering(input,\n-                                                                  sess,\n-                                                                  outdir,\n-                                                                  output,\n-                                                                  &arenas,\n-                                                                  &cstore,\n-                                                                  &hir_map,\n-                                                                  &analysis,\n-                                                                  &resolutions,\n-                                                                  &expanded_crate,\n-                                                                  &hir_map.krate(),\n-                                                                  &outputs,\n-                                                                  &crate_name),\n-                                    Ok(()));\n+            controller_entry_point!(\n+                after_hir_lowering,\n+                sess,\n+                CompileState::state_after_hir_lowering(\n+                    input,\n+                    sess,\n+                    outdir,\n+                    output,\n+                    &arenas,\n+                    &cstore,\n+                    &hir_map,\n+                    &analysis,\n+                    &resolutions,\n+                    &expanded_crate,\n+                    &hir_map.krate(),\n+                    &outputs,\n+                    &crate_name\n+                ),\n+                Ok(())\n+            );\n         }\n \n         let opt_crate = if control.keep_ast {\n@@ -213,60 +228,64 @@ pub fn compile_input(trans: Box<TransCrate>,\n             None\n         };\n \n-        phase_3_run_analysis_passes(&*trans,\n-                                    control,\n-                                    sess,\n-                                    cstore,\n-                                    hir_map,\n-                                    analysis,\n-                                    resolutions,\n-                                    &arenas,\n-                                    &crate_name,\n-                                    &outputs,\n-                                    |tcx, analysis, rx, result| {\n-            {\n-                // Eventually, we will want to track plugins.\n-                tcx.dep_graph.with_ignore(|| {\n-                    let mut state = CompileState::state_after_analysis(input,\n-                                                                       sess,\n-                                                                       outdir,\n-                                                                       output,\n-                                                                       opt_crate,\n-                                                                       tcx.hir.krate(),\n-                                                                       &analysis,\n-                                                                       tcx,\n-                                                                       &crate_name);\n-                    (control.after_analysis.callback)(&mut state);\n-                });\n-\n-                if control.after_analysis.stop == Compilation::Stop {\n-                    return result.and_then(|_| Err(CompileIncomplete::Stopped));\n+        phase_3_run_analysis_passes(\n+            &*trans,\n+            control,\n+            sess,\n+            cstore,\n+            hir_map,\n+            analysis,\n+            resolutions,\n+            &arenas,\n+            &crate_name,\n+            &outputs,\n+            |tcx, analysis, rx, result| {\n+                {\n+                    // Eventually, we will want to track plugins.\n+                    tcx.dep_graph.with_ignore(|| {\n+                        let mut state = CompileState::state_after_analysis(\n+                            input,\n+                            sess,\n+                            outdir,\n+                            output,\n+                            opt_crate,\n+                            tcx.hir.krate(),\n+                            &analysis,\n+                            tcx,\n+                            &crate_name,\n+                        );\n+                        (control.after_analysis.callback)(&mut state);\n+                    });\n+\n+                    if control.after_analysis.stop == Compilation::Stop {\n+                        return result.and_then(|_| Err(CompileIncomplete::Stopped));\n+                    }\n                 }\n-            }\n \n-            result?;\n+                result?;\n \n-            if log_enabled!(::log::Level::Info) {\n-                println!(\"Pre-trans\");\n-                tcx.print_debug_stats();\n-            }\n+                if log_enabled!(::log::Level::Info) {\n+                    println!(\"Pre-trans\");\n+                    tcx.print_debug_stats();\n+                }\n \n-            let ongoing_trans = phase_4_translate_to_llvm(&*trans, tcx, rx);\n+                let ongoing_trans = phase_4_translate_to_llvm(&*trans, tcx, rx);\n \n-            if log_enabled!(::log::Level::Info) {\n-                println!(\"Post-trans\");\n-                tcx.print_debug_stats();\n-            }\n+                if log_enabled!(::log::Level::Info) {\n+                    println!(\"Post-trans\");\n+                    tcx.print_debug_stats();\n+                }\n \n-            if tcx.sess.opts.output_types.contains_key(&OutputType::Mir) {\n-                if let Err(e) = mir::transform::dump_mir::emit_mir(tcx, &outputs) {\n-                    sess.err(&format!(\"could not emit MIR: {}\", e));\n-                    sess.abort_if_errors();\n+                if tcx.sess.opts.output_types.contains_key(&OutputType::Mir) {\n+                    if let Err(e) = mir::transform::dump_mir::emit_mir(tcx, &outputs) {\n+                        sess.err(&format!(\"could not emit MIR: {}\", e));\n+                        sess.abort_if_errors();\n+                    }\n                 }\n-            }\n \n-            Ok((outputs.clone(), ongoing_trans, tcx.dep_graph.clone()))\n-        })??\n+                Ok((outputs.clone(), ongoing_trans, tcx.dep_graph.clone()))\n+            },\n+        )??\n     };\n \n     if sess.opts.debugging_opts.print_type_sizes {\n@@ -391,10 +410,7 @@ pub struct CompileState<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> CompileState<'a, 'tcx> {\n-    fn empty(input: &'a Input,\n-             session: &'tcx Session,\n-             out_dir: &'a Option<PathBuf>)\n-             -> Self {\n+    fn empty(input: &'a Input, session: &'tcx Session, out_dir: &'a Option<PathBuf>) -> Self {\n         CompileState {\n             input,\n             session,\n@@ -415,13 +431,14 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n         }\n     }\n \n-    fn state_after_parse(input: &'a Input,\n-                         session: &'tcx Session,\n-                         out_dir: &'a Option<PathBuf>,\n-                         out_file: &'a Option<PathBuf>,\n-                         krate: ast::Crate,\n-                         cstore: &'tcx CStore)\n-                         -> Self {\n+    fn state_after_parse(\n+        input: &'a Input,\n+        session: &'tcx Session,\n+        out_dir: &'a Option<PathBuf>,\n+        out_file: &'a Option<PathBuf>,\n+        krate: ast::Crate,\n+        cstore: &'tcx CStore,\n+    ) -> Self {\n         CompileState {\n             // Initialize the registry before moving `krate`\n             registry: Some(Registry::new(&session, krate.span)),\n@@ -432,14 +449,15 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n         }\n     }\n \n-    fn state_after_expand(input: &'a Input,\n-                          session: &'tcx Session,\n-                          out_dir: &'a Option<PathBuf>,\n-                          out_file: &'a Option<PathBuf>,\n-                          cstore: &'tcx CStore,\n-                          expanded_crate: &'a ast::Crate,\n-                          crate_name: &'a str)\n-                          -> Self {\n+    fn state_after_expand(\n+        input: &'a Input,\n+        session: &'tcx Session,\n+        out_dir: &'a Option<PathBuf>,\n+        out_file: &'a Option<PathBuf>,\n+        cstore: &'tcx CStore,\n+        expanded_crate: &'a ast::Crate,\n+        crate_name: &'a str,\n+    ) -> Self {\n         CompileState {\n             crate_name: Some(crate_name),\n             cstore: Some(cstore),\n@@ -449,20 +467,21 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n         }\n     }\n \n-    fn state_after_hir_lowering(input: &'a Input,\n-                                session: &'tcx Session,\n-                                out_dir: &'a Option<PathBuf>,\n-                                out_file: &'a Option<PathBuf>,\n-                                arenas: &'tcx AllArenas<'tcx>,\n-                                cstore: &'tcx CStore,\n-                                hir_map: &'a hir_map::Map<'tcx>,\n-                                analysis: &'a ty::CrateAnalysis,\n-                                resolutions: &'a Resolutions,\n-                                krate: &'a ast::Crate,\n-                                hir_crate: &'a hir::Crate,\n-                                output_filenames: &'a OutputFilenames,\n-                                crate_name: &'a str)\n-                                -> Self {\n+    fn state_after_hir_lowering(\n+        input: &'a Input,\n+        session: &'tcx Session,\n+        out_dir: &'a Option<PathBuf>,\n+        out_file: &'a Option<PathBuf>,\n+        arenas: &'tcx AllArenas<'tcx>,\n+        cstore: &'tcx CStore,\n+        hir_map: &'a hir_map::Map<'tcx>,\n+        analysis: &'a ty::CrateAnalysis,\n+        resolutions: &'a Resolutions,\n+        krate: &'a ast::Crate,\n+        hir_crate: &'a hir::Crate,\n+        output_filenames: &'a OutputFilenames,\n+        crate_name: &'a str,\n+    ) -> Self {\n         CompileState {\n             crate_name: Some(crate_name),\n             arenas: Some(arenas),\n@@ -478,16 +497,17 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n         }\n     }\n \n-    fn state_after_analysis(input: &'a Input,\n-                            session: &'tcx Session,\n-                            out_dir: &'a Option<PathBuf>,\n-                            out_file: &'a Option<PathBuf>,\n-                            krate: Option<&'a ast::Crate>,\n-                            hir_crate: &'a hir::Crate,\n-                            analysis: &'a ty::CrateAnalysis,\n-                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            crate_name: &'a str)\n-                            -> Self {\n+    fn state_after_analysis(\n+        input: &'a Input,\n+        session: &'tcx Session,\n+        out_dir: &'a Option<PathBuf>,\n+        out_file: &'a Option<PathBuf>,\n+        krate: Option<&'a ast::Crate>,\n+        hir_crate: &'a hir::Crate,\n+        analysis: &'a ty::CrateAnalysis,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        crate_name: &'a str,\n+    ) -> Self {\n         CompileState {\n             analysis: Some(analysis),\n             tcx: Some(tcx),\n@@ -499,39 +519,37 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n         }\n     }\n \n-    fn state_when_compilation_done(input: &'a Input,\n-                                   session: &'tcx Session,\n-                                   out_dir: &'a Option<PathBuf>,\n-                                   out_file: &'a Option<PathBuf>)\n-                                   -> Self {\n+    fn state_when_compilation_done(\n+        input: &'a Input,\n+        session: &'tcx Session,\n+        out_dir: &'a Option<PathBuf>,\n+        out_file: &'a Option<PathBuf>,\n+    ) -> Self {\n         CompileState {\n             out_file: out_file.as_ref().map(|s| &**s),\n             ..CompileState::empty(input, session, out_dir)\n         }\n     }\n }\n \n-pub fn phase_1_parse_input<'a>(control: &CompileController,\n-                               sess: &'a Session,\n-                               input: &Input)\n-                               -> PResult<'a, ast::Crate> {\n-    sess.diagnostic().set_continue_after_error(control.continue_parse_after_error);\n+pub fn phase_1_parse_input<'a>(\n+    control: &CompileController,\n+    sess: &'a Session,\n+    input: &Input,\n+) -> PResult<'a, ast::Crate> {\n+    sess.diagnostic()\n+        .set_continue_after_error(control.continue_parse_after_error);\n \n     if sess.profile_queries() {\n         profile::begin(sess);\n     }\n \n-    let krate = time(sess, \"parsing\", || {\n-        match *input {\n-            Input::File(ref file) => {\n-                parse::parse_crate_from_file(file, &sess.parse_sess)\n-            }\n-            Input::Str { ref input, ref name } => {\n-                parse::parse_crate_from_source_str(name.clone(),\n-                                                   input.clone(),\n-                                                   &sess.parse_sess)\n-            }\n-        }\n+    let krate = time(sess, \"parsing\", || match *input {\n+        Input::File(ref file) => parse::parse_crate_from_file(file, &sess.parse_sess),\n+        Input::Str {\n+            ref input,\n+            ref name,\n+        } => parse::parse_crate_from_source_str(name.clone(), input.clone(), &sess.parse_sess),\n     })?;\n \n     sess.diagnostic().set_continue_after_error(true);\n@@ -541,7 +559,10 @@ pub fn phase_1_parse_input<'a>(control: &CompileController,\n     }\n \n     if sess.opts.debugging_opts.input_stats {\n-        println!(\"Lines of code:             {}\", sess.codemap().count_lines());\n+        println!(\n+            \"Lines of code:             {}\",\n+            sess.codemap().count_lines()\n+        );\n         println!(\"Pre-expansion node count:  {}\", count_nodes(&krate));\n     }\n \n@@ -586,69 +607,92 @@ pub struct InnerExpansionResult<'a> {\n /// standard library and prelude, and name resolution.\n ///\n /// Returns `None` if we're aborting after handling -W help.\n-pub fn phase_2_configure_and_expand<F>(sess: &Session,\n-                                       cstore: &CStore,\n-                                       krate: ast::Crate,\n-                                       registry: Option<Registry>,\n-                                       crate_name: &str,\n-                                       addl_plugins: Option<Vec<String>>,\n-                                       make_glob_map: MakeGlobMap,\n-                                       after_expand: F)\n-                                       -> Result<ExpansionResult, CompileIncomplete>\n-    where F: FnOnce(&ast::Crate) -> CompileResult {\n+pub fn phase_2_configure_and_expand<F>(\n+    sess: &Session,\n+    cstore: &CStore,\n+    krate: ast::Crate,\n+    registry: Option<Registry>,\n+    crate_name: &str,\n+    addl_plugins: Option<Vec<String>>,\n+    make_glob_map: MakeGlobMap,\n+    after_expand: F,\n+) -> Result<ExpansionResult, CompileIncomplete>\n+where\n+    F: FnOnce(&ast::Crate) -> CompileResult,\n+{\n     // Currently, we ignore the name resolution data structures for the purposes of dependency\n     // tracking. Instead we will run name resolution and include its output in the hash of each\n     // item, much like we do for macro expansion. In other words, the hash reflects not just\n     // its contents but the results of name resolution on those contents. Hopefully we'll push\n     // this back at some point.\n     let mut crate_loader = CrateLoader::new(sess, &cstore, &crate_name);\n     let resolver_arenas = Resolver::arenas();\n-    let result = phase_2_configure_and_expand_inner(sess, cstore, krate, registry, crate_name,\n-                                                    addl_plugins, make_glob_map, &resolver_arenas,\n-                                                    &mut crate_loader, after_expand);\n+    let result = phase_2_configure_and_expand_inner(\n+        sess,\n+        cstore,\n+        krate,\n+        registry,\n+        crate_name,\n+        addl_plugins,\n+        make_glob_map,\n+        &resolver_arenas,\n+        &mut crate_loader,\n+        after_expand,\n+    );\n     match result {\n-        Ok(InnerExpansionResult {expanded_crate, resolver, hir_forest}) => {\n-            Ok(ExpansionResult {\n-                expanded_crate,\n-                defs: resolver.definitions,\n-                hir_forest,\n-                resolutions: Resolutions {\n-                    freevars: resolver.freevars,\n-                    export_map: resolver.export_map,\n-                    trait_map: resolver.trait_map,\n-                    maybe_unused_trait_imports: resolver.maybe_unused_trait_imports,\n-                    maybe_unused_extern_crates: resolver.maybe_unused_extern_crates,\n-                },\n-\n-                analysis: ty::CrateAnalysis {\n-                    access_levels: Lrc::new(AccessLevels::default()),\n-                    name: crate_name.to_string(),\n-                    glob_map: if resolver.make_glob_map { Some(resolver.glob_map) } else { None },\n+        Ok(InnerExpansionResult {\n+            expanded_crate,\n+            resolver,\n+            hir_forest,\n+        }) => Ok(ExpansionResult {\n+            expanded_crate,\n+            defs: resolver.definitions,\n+            hir_forest,\n+            resolutions: Resolutions {\n+                freevars: resolver.freevars,\n+                export_map: resolver.export_map,\n+                trait_map: resolver.trait_map,\n+                maybe_unused_trait_imports: resolver.maybe_unused_trait_imports,\n+                maybe_unused_extern_crates: resolver.maybe_unused_extern_crates,\n+            },\n+\n+            analysis: ty::CrateAnalysis {\n+                access_levels: Lrc::new(AccessLevels::default()),\n+                name: crate_name.to_string(),\n+                glob_map: if resolver.make_glob_map {\n+                    Some(resolver.glob_map)\n+                } else {\n+                    None\n                 },\n-            })\n-        }\n-        Err(x) => Err(x)\n+            },\n+        }),\n+        Err(x) => Err(x),\n     }\n }\n \n /// Same as phase_2_configure_and_expand, but doesn't let you keep the resolver\n /// around\n-pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n-                                       cstore: &'a CStore,\n-                                       krate: ast::Crate,\n-                                       registry: Option<Registry>,\n-                                       crate_name: &str,\n-                                       addl_plugins: Option<Vec<String>>,\n-                                       make_glob_map: MakeGlobMap,\n-                                       resolver_arenas: &'a ResolverArenas<'a>,\n-                                       crate_loader: &'a mut CrateLoader,\n-                                       after_expand: F)\n-                                       -> Result<InnerExpansionResult<'a>, CompileIncomplete>\n-    where F: FnOnce(&ast::Crate) -> CompileResult,\n+pub fn phase_2_configure_and_expand_inner<'a, F>(\n+    sess: &'a Session,\n+    cstore: &'a CStore,\n+    krate: ast::Crate,\n+    registry: Option<Registry>,\n+    crate_name: &str,\n+    addl_plugins: Option<Vec<String>>,\n+    make_glob_map: MakeGlobMap,\n+    resolver_arenas: &'a ResolverArenas<'a>,\n+    crate_loader: &'a mut CrateLoader,\n+    after_expand: F,\n+) -> Result<InnerExpansionResult<'a>, CompileIncomplete>\n+where\n+    F: FnOnce(&ast::Crate) -> CompileResult,\n {\n-    let (mut krate, features) = syntax::config::features(krate, &sess.parse_sess,\n-                                                         sess.opts.test,\n-                                                         sess.opts.debugging_opts.edition);\n+    let (mut krate, features) = syntax::config::features(\n+        krate,\n+        &sess.parse_sess,\n+        sess.opts.test,\n+        sess.opts.debugging_opts.edition,\n+    );\n     // these need to be set \"early\" so that expansion sees `quote` if enabled.\n     sess.init_features(features);\n \n@@ -657,17 +701,16 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n \n     let disambiguator = compute_crate_disambiguator(sess);\n     sess.crate_disambiguator.set(disambiguator);\n-    rustc_incremental::prepare_session_directory(\n-        sess,\n-        &crate_name,\n-        disambiguator,\n-    );\n+    rustc_incremental::prepare_session_directory(sess, &crate_name, disambiguator);\n \n     if sess.opts.incremental.is_some() {\n         time(sess, \"garbage collect incremental cache directory\", || {\n             if let Err(e) = rustc_incremental::garbage_collect_session_directories(sess) {\n-                warn!(\"Error while trying to garbage collect incremental \\\n-                       compilation cache directory: {}\", e);\n+                warn!(\n+                    \"Error while trying to garbage collect incremental \\\n+                     compilation cache directory: {}\",\n+                    e\n+                );\n             }\n         });\n     }\n@@ -690,23 +733,31 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n \n     let mut addl_plugins = Some(addl_plugins);\n     let registrars = time(sess, \"plugin loading\", || {\n-        plugin::load::load_plugins(sess,\n-                                   &cstore,\n-                                   &krate,\n-                                   crate_name,\n-                                   addl_plugins.take().unwrap())\n+        plugin::load::load_plugins(\n+            sess,\n+            &cstore,\n+            &krate,\n+            crate_name,\n+            addl_plugins.take().unwrap(),\n+        )\n     });\n \n     let mut registry = registry.unwrap_or(Registry::new(sess, krate.span));\n \n     time(sess, \"plugin registration\", || {\n         if sess.features_untracked().rustc_diagnostic_macros {\n-            registry.register_macro(\"__diagnostic_used\",\n-                                    diagnostics::plugin::expand_diagnostic_used);\n-            registry.register_macro(\"__register_diagnostic\",\n-                                    diagnostics::plugin::expand_register_diagnostic);\n-            registry.register_macro(\"__build_diagnostic_array\",\n-                                    diagnostics::plugin::expand_build_diagnostic_array);\n+            registry.register_macro(\n+                \"__diagnostic_used\",\n+                diagnostics::plugin::expand_diagnostic_used,\n+            );\n+            registry.register_macro(\n+                \"__register_diagnostic\",\n+                diagnostics::plugin::expand_register_diagnostic,\n+            );\n+            registry.register_macro(\n+                \"__build_diagnostic_array\",\n+                diagnostics::plugin::expand_build_diagnostic_array,\n+            );\n         }\n \n         for registrar in registrars {\n@@ -716,8 +767,15 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n     });\n \n     let whitelisted_legacy_custom_derives = registry.take_whitelisted_custom_derives();\n-    let Registry { syntax_exts, early_lint_passes, late_lint_passes, lint_groups,\n-                   llvm_passes, attributes, .. } = registry;\n+    let Registry {\n+        syntax_exts,\n+        early_lint_passes,\n+        late_lint_passes,\n+        lint_groups,\n+        llvm_passes,\n+        attributes,\n+        ..\n+    } = registry;\n \n     sess.track_errors(|| {\n         let mut ls = sess.lint_store.borrow_mut();\n@@ -742,16 +800,19 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n         return Err(CompileIncomplete::Stopped);\n     }\n \n-    let mut resolver = Resolver::new(sess,\n-                                     cstore,\n-                                     &krate,\n-                                     crate_name,\n-                                     make_glob_map,\n-                                     crate_loader,\n-                                     &resolver_arenas);\n+    let mut resolver = Resolver::new(\n+        sess,\n+        cstore,\n+        &krate,\n+        crate_name,\n+        make_glob_map,\n+        crate_loader,\n+        &resolver_arenas,\n+    );\n     resolver.whitelisted_legacy_custom_derives = whitelisted_legacy_custom_derives;\n     syntax_ext::register_builtins(&mut resolver, syntax_exts, sess.features_untracked().quote);\n \n+    // Expand all macros\n     krate = time(sess, \"expansion\", || {\n         // Windows dlls do not have rpaths, so they don't know how to find their\n         // dependencies. It's up to us to tell the system where to find all the\n@@ -769,18 +830,23 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n         let mut old_path = OsString::new();\n         if cfg!(windows) {\n             old_path = env::var_os(\"PATH\").unwrap_or(old_path);\n-            let mut new_path = sess.host_filesearch(PathKind::All)\n-                                   .get_dylib_search_paths();\n+            let mut new_path = sess.host_filesearch(PathKind::All).get_dylib_search_paths();\n             for path in env::split_paths(&old_path) {\n                 if !new_path.contains(&path) {\n                     new_path.push(path);\n                 }\n             }\n-            env::set_var(\"PATH\",\n-                &env::join_paths(new_path.iter()\n-                                         .filter(|p| env::join_paths(iter::once(p)).is_ok()))\n-                     .unwrap());\n+            env::set_var(\n+                \"PATH\",\n+                &env::join_paths(\n+                    new_path\n+                        .iter()\n+                        .filter(|p| env::join_paths(iter::once(p)).is_ok()),\n+                ).unwrap(),\n+            );\n         }\n+\n+        // Create the config for macro expansion\n         let features = sess.features_untracked();\n         let cfg = syntax::ext::expand::ExpansionConfig {\n             features: Some(&features),\n@@ -793,16 +859,23 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n         let mut ecx = ExtCtxt::new(&sess.parse_sess, cfg, &mut resolver);\n         let err_count = ecx.parse_sess.span_diagnostic.err_count();\n \n+        // Expand macros now!\n         let krate = time(sess, \"expand crate\", || {\n             ecx.monotonic_expander().expand_crate(krate)\n         });\n \n+        // The rest is error reporting\n+\n         time(sess, \"check unused macros\", || {\n             ecx.check_unused_macros();\n         });\n \n-        let mut missing_fragment_specifiers: Vec<_> =\n-            ecx.parse_sess.missing_fragment_specifiers.borrow().iter().cloned().collect();\n+        let mut missing_fragment_specifiers: Vec<_> = ecx.parse_sess\n+            .missing_fragment_specifiers\n+            .borrow()\n+            .iter()\n+            .cloned()\n+            .collect();\n         missing_fragment_specifiers.sort();\n         for span in missing_fragment_specifiers {\n             let lint = lint::builtin::MISSING_FRAGMENT_SPECIFIER;\n@@ -819,12 +892,14 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n     });\n \n     krate = time(sess, \"maybe building test harness\", || {\n-        syntax::test::modify_for_testing(&sess.parse_sess,\n-                                         &mut resolver,\n-                                         sess.opts.test,\n-                                         krate,\n-                                         sess.diagnostic(),\n-                                         &sess.features_untracked())\n+        syntax::test::modify_for_testing(\n+            &sess.parse_sess,\n+            &mut resolver,\n+            sess.opts.test,\n+            krate,\n+            sess.diagnostic(),\n+            &sess.features_untracked(),\n+        )\n     });\n \n     // If we're actually rustdoc then there's no need to actually compile\n@@ -842,21 +917,20 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n             let num_crate_types = crate_types.len();\n             let is_proc_macro_crate = crate_types.contains(&config::CrateTypeProcMacro);\n             let is_test_crate = sess.opts.test;\n-            syntax_ext::proc_macro_registrar::modify(&sess.parse_sess,\n-                                                     &mut resolver,\n-                                                     krate,\n-                                                     is_proc_macro_crate,\n-                                                     is_test_crate,\n-                                                     num_crate_types,\n-                                                     sess.diagnostic())\n+            syntax_ext::proc_macro_registrar::modify(\n+                &sess.parse_sess,\n+                &mut resolver,\n+                krate,\n+                is_proc_macro_crate,\n+                is_test_crate,\n+                num_crate_types,\n+                sess.diagnostic(),\n+            )\n         });\n     }\n \n     krate = time(sess, \"creating allocators\", || {\n-        allocator::expand::modify(&sess.parse_sess,\n-                                  &mut resolver,\n-                                  krate,\n-                                  sess.diagnostic())\n+        allocator::expand::modify(&sess.parse_sess, &mut resolver, krate, sess.diagnostic())\n     });\n \n     after_expand(&krate)?;\n@@ -873,9 +947,9 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n         println!(\"{}\", json::as_json(&krate));\n     }\n \n-    time(sess,\n-         \"AST validation\",\n-         || ast_validation::check_crate(sess, &krate));\n+    time(sess, \"AST validation\", || {\n+        ast_validation::check_crate(sess, &krate)\n+    });\n \n     time(sess, \"name resolution\", || -> CompileResult {\n         resolver.resolve_crate(&krate);\n@@ -885,11 +959,13 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n     // Needs to go *after* expansion to be able to check the results of macro expansion.\n     time(sess, \"complete gated feature checking\", || {\n         sess.track_errors(|| {\n-            syntax::feature_gate::check_crate(&krate,\n-                                              &sess.parse_sess,\n-                                              &sess.features_untracked(),\n-                                              &attributes,\n-                                              sess.opts.unstable_features);\n+            syntax::feature_gate::check_crate(\n+                &krate,\n+                &sess.parse_sess,\n+                &sess.features_untracked(),\n+                &attributes,\n+                sess.opts.unstable_features,\n+            );\n         })\n     })?;\n \n@@ -905,11 +981,12 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n         None => DepGraph::new_disabled(),\n         Some(future) => {\n             let prev_graph = time(sess, \"blocked while dep-graph loading finishes\", || {\n-                future.open()\n-                      .unwrap_or_else(|e| rustc_incremental::LoadResult::Error {\n-                          message: format!(\"could not decode incremental cache: {:?}\", e)\n-                      })\n-                      .open(sess)\n+                future\n+                    .open()\n+                    .unwrap_or_else(|e| rustc_incremental::LoadResult::Error {\n+                        message: format!(\"could not decode incremental cache: {:?}\", e),\n+                    })\n+                    .open(sess)\n             });\n             DepGraph::new(prev_graph)\n         }\n@@ -924,9 +1001,9 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n         hir_map::Forest::new(hir_crate, &dep_graph)\n     });\n \n-    time(sess,\n-         \"early lint checks\",\n-         || lint::check_ast_crate(sess, &krate));\n+    time(sess, \"early lint checks\", || {\n+        lint::check_ast_crate(sess, &krate)\n+    });\n \n     // Discard hygiene data, which isn't required after lowering to HIR.\n     if !sess.opts.debugging_opts.keep_hygiene_data {\n@@ -965,39 +1042,43 @@ pub fn default_provide_extern(providers: &mut ty::maps::Providers) {\n /// Run the resolution, typechecking, region checking and other\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n-pub fn phase_3_run_analysis_passes<'tcx, F, R>(trans: &TransCrate,\n-                                               control: &CompileController,\n-                                               sess: &'tcx Session,\n-                                               cstore: &'tcx CrateStore,\n-                                               hir_map: hir_map::Map<'tcx>,\n-                                               mut analysis: ty::CrateAnalysis,\n-                                               resolutions: Resolutions,\n-                                               arenas: &'tcx AllArenas<'tcx>,\n-                                               name: &str,\n-                                               output_filenames: &OutputFilenames,\n-                                               f: F)\n-                                               -> Result<R, CompileIncomplete>\n-    where F: for<'a> FnOnce(TyCtxt<'a, 'tcx, 'tcx>,\n-                            ty::CrateAnalysis,\n-                            mpsc::Receiver<Box<Any + Send>>,\n-                            CompileResult) -> R\n+pub fn phase_3_run_analysis_passes<'tcx, F, R>(\n+    trans: &TransCrate,\n+    control: &CompileController,\n+    sess: &'tcx Session,\n+    cstore: &'tcx CrateStore,\n+    hir_map: hir_map::Map<'tcx>,\n+    mut analysis: ty::CrateAnalysis,\n+    resolutions: Resolutions,\n+    arenas: &'tcx AllArenas<'tcx>,\n+    name: &str,\n+    output_filenames: &OutputFilenames,\n+    f: F,\n+) -> Result<R, CompileIncomplete>\n+where\n+    F: for<'a> FnOnce(\n+        TyCtxt<'a, 'tcx, 'tcx>,\n+        ty::CrateAnalysis,\n+        mpsc::Receiver<Box<Any + Send>>,\n+        CompileResult,\n+    ) -> R,\n {\n-    let query_result_on_disk_cache = time(sess,\n-        \"load query result cache\",\n-        || rustc_incremental::load_query_result_cache(sess));\n+    let query_result_on_disk_cache = time(sess, \"load query result cache\", || {\n+        rustc_incremental::load_query_result_cache(sess)\n+    });\n \n-    time(sess,\n-         \"looking for entry point\",\n-         || middle::entry::find_entry_point(sess, &hir_map, name));\n+    time(sess, \"looking for entry point\", || {\n+        middle::entry::find_entry_point(sess, &hir_map, name)\n+    });\n \n-    sess.plugin_registrar_fn.set(time(sess, \"looking for plugin registrar\", || {\n-        plugin::build::find_plugin_registrar(sess.diagnostic(), &hir_map)\n-    }));\n-    sess.derive_registrar_fn.set(derive_registrar::find(&hir_map));\n+    sess.plugin_registrar_fn\n+        .set(time(sess, \"looking for plugin registrar\", || {\n+            plugin::build::find_plugin_registrar(sess.diagnostic(), &hir_map)\n+        }));\n+    sess.derive_registrar_fn\n+        .set(derive_registrar::find(&hir_map));\n \n-    time(sess,\n-         \"loop checking\",\n-         || loops::check_crate(sess, &hir_map));\n+    time(sess, \"loop checking\", || loops::check_crate(sess, &hir_map));\n \n     let mut local_providers = ty::maps::Providers::default();\n     default_provide(&mut local_providers);\n@@ -1011,115 +1092,113 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(trans: &TransCrate,\n \n     let (tx, rx) = mpsc::channel();\n \n-    TyCtxt::create_and_enter(sess,\n-                             cstore,\n-                             local_providers,\n-                             extern_providers,\n-                             arenas,\n-                             resolutions,\n-                             hir_map,\n-                             query_result_on_disk_cache,\n-                             name,\n-                             tx,\n-                             output_filenames,\n-                             |tcx| {\n-        // Do some initialization of the DepGraph that can only be done with the\n-        // tcx available.\n-        rustc_incremental::dep_graph_tcx_init(tcx);\n-\n-        time(sess, \"attribute checking\", || {\n-            hir::check_attr::check_crate(tcx)\n-        });\n+    TyCtxt::create_and_enter(\n+        sess,\n+        cstore,\n+        local_providers,\n+        extern_providers,\n+        arenas,\n+        resolutions,\n+        hir_map,\n+        query_result_on_disk_cache,\n+        name,\n+        tx,\n+        output_filenames,\n+        |tcx| {\n+            // Do some initialization of the DepGraph that can only be done with the\n+            // tcx available.\n+            rustc_incremental::dep_graph_tcx_init(tcx);\n+\n+            time(sess, \"attribute checking\", || {\n+                hir::check_attr::check_crate(tcx)\n+            });\n \n-        time(sess,\n-             \"stability checking\",\n-             || stability::check_unstable_api_usage(tcx));\n+            time(sess, \"stability checking\", || {\n+                stability::check_unstable_api_usage(tcx)\n+            });\n \n-        // passes are timed inside typeck\n-        match typeck::check_crate(tcx) {\n-            Ok(x) => x,\n-            Err(x) => {\n-                f(tcx, analysis, rx, Err(x));\n-                return Err(x);\n+            // passes are timed inside typeck\n+            match typeck::check_crate(tcx) {\n+                Ok(x) => x,\n+                Err(x) => {\n+                    f(tcx, analysis, rx, Err(x));\n+                    return Err(x);\n+                }\n             }\n-        }\n \n-        time(sess,\n-             \"rvalue promotion\",\n-             || rvalue_promotion::check_crate(tcx));\n+            time(sess, \"rvalue promotion\", || {\n+                rvalue_promotion::check_crate(tcx)\n+            });\n \n-        analysis.access_levels =\n-            time(sess, \"privacy checking\", || rustc_privacy::check_crate(tcx));\n+            analysis.access_levels =\n+                time(sess, \"privacy checking\", || rustc_privacy::check_crate(tcx));\n \n-        time(sess,\n-             \"intrinsic checking\",\n-             || middle::intrinsicck::check_crate(tcx));\n+            time(sess, \"intrinsic checking\", || {\n+                middle::intrinsicck::check_crate(tcx)\n+            });\n \n-        time(sess,\n-             \"match checking\",\n-             || mir::matchck_crate(tcx));\n+            time(sess, \"match checking\", || mir::matchck_crate(tcx));\n \n-        // this must run before MIR dump, because\n-        // \"not all control paths return a value\" is reported here.\n-        //\n-        // maybe move the check to a MIR pass?\n-        time(sess,\n-             \"liveness checking\",\n-             || middle::liveness::check_crate(tcx));\n-\n-        time(sess,\n-             \"borrow checking\",\n-             || borrowck::check_crate(tcx));\n-\n-        time(sess,\n-             \"MIR borrow checking\",\n-             || for def_id in tcx.body_owners() { tcx.mir_borrowck(def_id); });\n-\n-        time(sess,\n-             \"MIR effect checking\",\n-             || for def_id in tcx.body_owners() {\n-                 mir::transform::check_unsafety::check_unsafety(tcx, def_id)\n-             });\n-        // Avoid overwhelming user with errors if type checking failed.\n-        // I'm not sure how helpful this is, to be honest, but it avoids\n-        // a\n-        // lot of annoying errors in the compile-fail tests (basically,\n-        // lint warnings and so on -- kindck used to do this abort, but\n-        // kindck is gone now). -nmatsakis\n-        if sess.err_count() > 0 {\n-            return Ok(f(tcx, analysis, rx, sess.compile_status()));\n-        }\n+            // this must run before MIR dump, because\n+            // \"not all control paths return a value\" is reported here.\n+            //\n+            // maybe move the check to a MIR pass?\n+            time(sess, \"liveness checking\", || {\n+                middle::liveness::check_crate(tcx)\n+            });\n \n-        time(sess, \"death checking\", || middle::dead::check_crate(tcx));\n+            time(sess, \"borrow checking\", || borrowck::check_crate(tcx));\n \n-        time(sess, \"unused lib feature checking\", || {\n-            stability::check_unused_or_stable_features(tcx)\n-        });\n+            time(sess, \"MIR borrow checking\", || {\n+                for def_id in tcx.body_owners() {\n+                    tcx.mir_borrowck(def_id);\n+                }\n+            });\n \n-        time(sess, \"lint checking\", || lint::check_crate(tcx));\n+            time(sess, \"MIR effect checking\", || {\n+                for def_id in tcx.body_owners() {\n+                    mir::transform::check_unsafety::check_unsafety(tcx, def_id)\n+                }\n+            });\n+            // Avoid overwhelming user with errors if type checking failed.\n+            // I'm not sure how helpful this is, to be honest, but it avoids\n+            // a\n+            // lot of annoying errors in the compile-fail tests (basically,\n+            // lint warnings and so on -- kindck used to do this abort, but\n+            // kindck is gone now). -nmatsakis\n+            if sess.err_count() > 0 {\n+                return Ok(f(tcx, analysis, rx, sess.compile_status()));\n+            }\n \n-        time(sess,\n-             \"dumping chalk-like clauses\",\n-             || rustc_traits::lowering::dump_program_clauses(tcx));\n+            time(sess, \"death checking\", || middle::dead::check_crate(tcx));\n \n-        return Ok(f(tcx, analysis, rx, tcx.sess.compile_status()));\n-    })\n+            time(sess, \"unused lib feature checking\", || {\n+                stability::check_unused_or_stable_features(tcx)\n+            });\n+\n+            time(sess, \"lint checking\", || lint::check_crate(tcx));\n+\n+            time(sess, \"dumping chalk-like clauses\", || {\n+                rustc_traits::lowering::dump_program_clauses(tcx)\n+            });\n+\n+            return Ok(f(tcx, analysis, rx, tcx.sess.compile_status()));\n+        },\n+    )\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n-pub fn phase_4_translate_to_llvm<'a, 'tcx>(trans: &TransCrate,\n-                                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                           rx: mpsc::Receiver<Box<Any + Send>>)\n-                                           -> Box<Any> {\n-    time(tcx.sess,\n-         \"resolving dependency formats\",\n-         || ::rustc::middle::dependency_format::calculate(tcx));\n-\n-    let translation =\n-        time(tcx.sess, \"translation\", move || {\n-            trans.trans_crate(tcx, rx)\n-        });\n+pub fn phase_4_translate_to_llvm<'a, 'tcx>(\n+    trans: &TransCrate,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    rx: mpsc::Receiver<Box<Any + Send>>,\n+) -> Box<Any> {\n+    time(tcx.sess, \"resolving dependency formats\", || {\n+        ::rustc::middle::dependency_format::calculate(tcx)\n+    });\n+\n+    let translation = time(tcx.sess, \"translation\", move || trans.trans_crate(tcx, rx));\n     if tcx.sess.profile_queries() {\n         profile::dump(&tcx.sess, \"profile_queries\".to_string())\n     }\n@@ -1134,27 +1213,27 @@ fn escape_dep_filename(filename: &FileName) -> String {\n }\n \n // Returns all the paths that correspond to generated files.\n-fn generated_output_paths(sess: &Session,\n-                          outputs: &OutputFilenames,\n-                          exact_name: bool,\n-                          crate_name: &str) -> Vec<PathBuf> {\n+fn generated_output_paths(\n+    sess: &Session,\n+    outputs: &OutputFilenames,\n+    exact_name: bool,\n+    crate_name: &str,\n+) -> Vec<PathBuf> {\n     let mut out_filenames = Vec::new();\n     for output_type in sess.opts.output_types.keys() {\n         let file = outputs.path(*output_type);\n         match *output_type {\n             // If the filename has been overridden using `-o`, it will not be modified\n             // by appending `.rlib`, `.exe`, etc., so we can skip this transformation.\n-            OutputType::Exe if !exact_name => {\n-                for crate_type in sess.crate_types.borrow().iter() {\n-                    let p = ::rustc_trans_utils::link::filename_for_input(\n-                        sess,\n-                        *crate_type,\n-                        crate_name,\n-                        outputs\n-                    );\n-                    out_filenames.push(p);\n-                }\n-            }\n+            OutputType::Exe if !exact_name => for crate_type in sess.crate_types.borrow().iter() {\n+                let p = ::rustc_trans_utils::link::filename_for_input(\n+                    sess,\n+                    *crate_type,\n+                    crate_name,\n+                    outputs,\n+                );\n+                out_filenames.push(p);\n+            },\n             OutputType::DepInfo if sess.opts.debugging_opts.dep_info_omit_d_target => {\n                 // Don't add the dep-info output when omitting it from dep-info targets\n             }\n@@ -1169,24 +1248,28 @@ fn generated_output_paths(sess: &Session,\n // Runs `f` on every output file path and returns the first non-None result, or None if `f`\n // returns None for every file path.\n fn check_output<F, T>(output_paths: &Vec<PathBuf>, f: F) -> Option<T>\n-        where F: Fn(&PathBuf) -> Option<T> {\n-            for output_path in output_paths {\n-                if let Some(result) = f(output_path) {\n-                    return Some(result);\n-                }\n-            }\n-            None\n+where\n+    F: Fn(&PathBuf) -> Option<T>,\n+{\n+    for output_path in output_paths {\n+        if let Some(result) = f(output_path) {\n+            return Some(result);\n+        }\n+    }\n+    None\n }\n \n pub fn output_contains_path(output_paths: &Vec<PathBuf>, input_path: &PathBuf) -> bool {\n     let input_path = input_path.canonicalize().ok();\n     if input_path.is_none() {\n-        return false\n+        return false;\n     }\n     let check = |output_path: &PathBuf| {\n         if output_path.canonicalize().ok() == input_path {\n             Some(())\n-        } else { None }\n+        } else {\n+            None\n+        }\n     };\n     check_output(output_paths, check).is_some()\n }\n@@ -1195,100 +1278,92 @@ pub fn output_conflicts_with_dir(output_paths: &Vec<PathBuf>) -> Option<PathBuf>\n     let check = |output_path: &PathBuf| {\n         if output_path.is_dir() {\n             Some(output_path.clone())\n-        } else { None }\n+        } else {\n+            None\n+        }\n     };\n     check_output(output_paths, check)\n }\n \n-fn write_out_deps(sess: &Session,\n-                  outputs: &OutputFilenames,\n-                  out_filenames: &Vec<PathBuf>) {\n+fn write_out_deps(sess: &Session, outputs: &OutputFilenames, out_filenames: &Vec<PathBuf>) {\n     // Write out dependency rules to the dep-info file if requested\n     if !sess.opts.output_types.contains_key(&OutputType::DepInfo) {\n         return;\n     }\n     let deps_filename = outputs.path(OutputType::DepInfo);\n \n-    let result =\n-        (|| -> io::Result<()> {\n-            // Build a list of files used to compile the output and\n-            // write Makefile-compatible dependency rules\n-            let files: Vec<String> = sess.codemap()\n-                                         .files()\n-                                         .iter()\n-                                         .filter(|fmap| fmap.is_real_file())\n-                                         .filter(|fmap| !fmap.is_imported())\n-                                         .map(|fmap| escape_dep_filename(&fmap.name))\n-                                         .collect();\n-            let mut file = fs::File::create(&deps_filename)?;\n-            for path in out_filenames {\n-                write!(file, \"{}: {}\\n\\n\", path.display(), files.join(\" \"))?;\n-            }\n+    let result = (|| -> io::Result<()> {\n+        // Build a list of files used to compile the output and\n+        // write Makefile-compatible dependency rules\n+        let files: Vec<String> = sess.codemap()\n+            .files()\n+            .iter()\n+            .filter(|fmap| fmap.is_real_file())\n+            .filter(|fmap| !fmap.is_imported())\n+            .map(|fmap| escape_dep_filename(&fmap.name))\n+            .collect();\n+        let mut file = fs::File::create(&deps_filename)?;\n+        for path in out_filenames {\n+            write!(file, \"{}: {}\\n\\n\", path.display(), files.join(\" \"))?;\n+        }\n \n-            // Emit a fake target for each input file to the compilation. This\n-            // prevents `make` from spitting out an error if a file is later\n-            // deleted. For more info see #28735\n-            for path in files {\n-                writeln!(file, \"{}:\", path)?;\n-            }\n-            Ok(())\n-        })();\n+        // Emit a fake target for each input file to the compilation. This\n+        // prevents `make` from spitting out an error if a file is later\n+        // deleted. For more info see #28735\n+        for path in files {\n+            writeln!(file, \"{}:\", path)?;\n+        }\n+        Ok(())\n+    })();\n \n     match result {\n         Ok(()) => {}\n         Err(e) => {\n-            sess.fatal(&format!(\"error writing dependencies to `{}`: {}\",\n-                                deps_filename.display(),\n-                                e));\n+            sess.fatal(&format!(\n+                \"error writing dependencies to `{}`: {}\",\n+                deps_filename.display(),\n+                e\n+            ));\n         }\n     }\n }\n \n pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<config::CrateType> {\n     // Unconditionally collect crate types from attributes to make them used\n-    let attr_types: Vec<config::CrateType> =\n-        attrs.iter()\n-             .filter_map(|a| {\n-                 if a.check_name(\"crate_type\") {\n-                     match a.value_str() {\n-                         Some(ref n) if *n == \"rlib\" => {\n-                             Some(config::CrateTypeRlib)\n-                         }\n-                         Some(ref n) if *n == \"dylib\" => {\n-                             Some(config::CrateTypeDylib)\n-                         }\n-                         Some(ref n) if *n == \"cdylib\" => {\n-                             Some(config::CrateTypeCdylib)\n-                         }\n-                         Some(ref n) if *n == \"lib\" => {\n-                             Some(config::default_lib_output())\n-                         }\n-                         Some(ref n) if *n == \"staticlib\" => {\n-                             Some(config::CrateTypeStaticlib)\n-                         }\n-                         Some(ref n) if *n == \"proc-macro\" => {\n-                             Some(config::CrateTypeProcMacro)\n-                         }\n-                         Some(ref n) if *n == \"bin\" => Some(config::CrateTypeExecutable),\n-                         Some(_) => {\n-                             session.buffer_lint(lint::builtin::UNKNOWN_CRATE_TYPES,\n-                                                 ast::CRATE_NODE_ID,\n-                                                 a.span,\n-                                                 \"invalid `crate_type` value\");\n-                             None\n-                         }\n-                         _ => {\n-                             session.struct_span_err(a.span, \"`crate_type` requires a value\")\n-                                 .note(\"for example: `#![crate_type=\\\"lib\\\"]`\")\n-                                 .emit();\n-                             None\n-                         }\n-                     }\n-                 } else {\n-                     None\n-                 }\n-             })\n-             .collect();\n+    let attr_types: Vec<config::CrateType> = attrs\n+        .iter()\n+        .filter_map(|a| {\n+            if a.check_name(\"crate_type\") {\n+                match a.value_str() {\n+                    Some(ref n) if *n == \"rlib\" => Some(config::CrateTypeRlib),\n+                    Some(ref n) if *n == \"dylib\" => Some(config::CrateTypeDylib),\n+                    Some(ref n) if *n == \"cdylib\" => Some(config::CrateTypeCdylib),\n+                    Some(ref n) if *n == \"lib\" => Some(config::default_lib_output()),\n+                    Some(ref n) if *n == \"staticlib\" => Some(config::CrateTypeStaticlib),\n+                    Some(ref n) if *n == \"proc-macro\" => Some(config::CrateTypeProcMacro),\n+                    Some(ref n) if *n == \"bin\" => Some(config::CrateTypeExecutable),\n+                    Some(_) => {\n+                        session.buffer_lint(\n+                            lint::builtin::UNKNOWN_CRATE_TYPES,\n+                            ast::CRATE_NODE_ID,\n+                            a.span,\n+                            \"invalid `crate_type` value\",\n+                        );\n+                        None\n+                    }\n+                    _ => {\n+                        session\n+                            .struct_span_err(a.span, \"`crate_type` requires a value\")\n+                            .note(\"for example: `#![crate_type=\\\"lib\\\"]`\")\n+                            .emit();\n+                        None\n+                    }\n+                }\n+            } else {\n+                None\n+            }\n+        })\n+        .collect();\n \n     // If we're generating a test executable, then ignore all other output\n     // styles at all other locations\n@@ -1303,7 +1378,9 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n     if base.is_empty() {\n         base.extend(attr_types);\n         if base.is_empty() {\n-            base.push(::rustc_trans_utils::link::default_output_for_target(session));\n+            base.push(::rustc_trans_utils::link::default_output_for_target(\n+                session,\n+            ));\n         }\n         base.sort();\n         base.dedup();\n@@ -1314,9 +1391,10 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n             let res = !::rustc_trans_utils::link::invalid_output_for_target(session, *crate_type);\n \n             if !res {\n-                session.warn(&format!(\"dropping unsupported crate type `{}` for target `{}`\",\n-                                      *crate_type,\n-                                      session.opts.target_triple));\n+                session.warn(&format!(\n+                    \"dropping unsupported crate type `{}` for target `{}`\",\n+                    *crate_type, session.opts.target_triple\n+                ));\n             }\n \n             res\n@@ -1351,19 +1429,22 @@ pub fn compute_crate_disambiguator(session: &Session) -> CrateDisambiguator {\n \n     // Also incorporate crate type, so that we don't get symbol conflicts when\n     // linking against a library of the same name, if this is an executable.\n-    let is_exe = session.crate_types.borrow().contains(&config::CrateTypeExecutable);\n+    let is_exe = session\n+        .crate_types\n+        .borrow()\n+        .contains(&config::CrateTypeExecutable);\n     hasher.write(if is_exe { b\"exe\" } else { b\"lib\" });\n \n     CrateDisambiguator::from(hasher.finish())\n-\n }\n \n-pub fn build_output_filenames(input: &Input,\n-                              odir: &Option<PathBuf>,\n-                              ofile: &Option<PathBuf>,\n-                              attrs: &[ast::Attribute],\n-                              sess: &Session)\n-                              -> OutputFilenames {\n+pub fn build_output_filenames(\n+    input: &Input,\n+    odir: &Option<PathBuf>,\n+    ofile: &Option<PathBuf>,\n+    attrs: &[ast::Attribute],\n+    sess: &Session,\n+) -> OutputFilenames {\n     match *ofile {\n         None => {\n             // \"-\" as input file will cause the parser to read from stdin so we\n@@ -1376,10 +1457,10 @@ pub fn build_output_filenames(input: &Input,\n \n             // If a crate name is present, we use it as the link name\n             let stem = sess.opts\n-                           .crate_name\n-                           .clone()\n-                           .or_else(|| attr::find_crate_name(attrs).map(|n| n.to_string()))\n-                           .unwrap_or(input.filestem());\n+                .crate_name\n+                .clone()\n+                .or_else(|| attr::find_crate_name(attrs).map(|n| n.to_string()))\n+                .unwrap_or(input.filestem());\n \n             OutputFilenames {\n                 out_directory: dirpath,\n@@ -1392,13 +1473,15 @@ pub fn build_output_filenames(input: &Input,\n \n         Some(ref out_file) => {\n             let unnamed_output_types = sess.opts\n-                                           .output_types\n-                                           .values()\n-                                           .filter(|a| a.is_none())\n-                                           .count();\n+                .output_types\n+                .values()\n+                .filter(|a| a.is_none())\n+                .count();\n             let ofile = if unnamed_output_types > 1 {\n-                sess.warn(\"due to multiple output types requested, the explicitly specified \\\n-                           output file name will be adapted for each output type\");\n+                sess.warn(\n+                    \"due to multiple output types requested, the explicitly specified \\\n+                     output file name will be adapted for each output type\",\n+                );\n                 None\n             } else {\n                 Some(out_file.clone())\n@@ -1414,11 +1497,12 @@ pub fn build_output_filenames(input: &Input,\n \n             OutputFilenames {\n                 out_directory: out_file.parent().unwrap_or(cur_dir).to_path_buf(),\n-                out_filestem: out_file.file_stem()\n-                                      .unwrap_or(OsStr::new(\"\"))\n-                                      .to_str()\n-                                      .unwrap()\n-                                      .to_string(),\n+                out_filestem: out_file\n+                    .file_stem()\n+                    .unwrap_or(OsStr::new(\"\"))\n+                    .to_str()\n+                    .unwrap()\n+                    .to_string(),\n                 single_output_file: ofile,\n                 extra: sess.opts.cg.extra_filename.clone(),\n                 outputs: sess.opts.output_types.clone(),"}]}