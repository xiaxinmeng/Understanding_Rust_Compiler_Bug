{"sha": "23967c39c9dad1a75e581d90b0cb0313c830b3ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzOTY3YzM5YzlkYWQxYTc1ZTU4MWQ5MGIwY2IwMzEzYzgzMGIzYWI=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-03-24T17:26:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-24T17:26:38Z"}, "message": "Rollup merge of #49235 - topecongiro:run-rustfmt/libtest, r=nrc\n\nCargo fmt libtest\n\nr? @nrc\n\nUsing `rustfmt 0.4.1- (87180d9 2018-03-16)` (`rustfmt --version` is a bit broken).", "tree": {"sha": "43ff99382dfb160f24652b47cb6b3be10ac45097", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43ff99382dfb160f24652b47cb6b3be10ac45097"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23967c39c9dad1a75e581d90b0cb0313c830b3ab", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJatopOCRBK7hj4Ov3rIwAAdHIIAJrkIMmjliSn1EkGMc0iDIFj\nB6dTFt3DIuDznRLCYcrXOQCvukAuz8x9Yq4eOGSPZiNRRuw7oaC6lzfbAq4DEeUT\ndOR6OXurRm8k0QxO+ceJb4JYBOdpi/N0TWLQ8JwV/1NTUNkxZBB4jLFxAD3hzQmW\n+0dWPqukFkgl4ULw15TjkXy6Cs7fnGP3QFRnnyyWmF534zVVW2ntqssR0dCskISy\nlCgDhmpd6mIydEb3HxXSoVnFPpIUfc/5JMizVij8uyG+jtSxqBKbq2W+d8SXI1CI\nMx0SzC08a9Rwg4HtHO7gjFZxzBr+Ws/7it9m8TSJ5EhS8/3Slqh4Z72p9ALgNRc=\n=S+ON\n-----END PGP SIGNATURE-----\n", "payload": "tree 43ff99382dfb160f24652b47cb6b3be10ac45097\nparent 8c1535f1156cb05eb3976497ac732c01ba4b5048\nparent 75dcc61d3c1cce7b4428dd85bb588e99d9faf7a9\nauthor kennytm <kennytm@gmail.com> 1521912398 +0800\ncommitter GitHub <noreply@github.com> 1521912398 +0800\n\nRollup merge of #49235 - topecongiro:run-rustfmt/libtest, r=nrc\n\nCargo fmt libtest\n\nr? @nrc\n\nUsing `rustfmt 0.4.1- (87180d9 2018-03-16)` (`rustfmt --version` is a bit broken).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23967c39c9dad1a75e581d90b0cb0313c830b3ab", "html_url": "https://github.com/rust-lang/rust/commit/23967c39c9dad1a75e581d90b0cb0313c830b3ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23967c39c9dad1a75e581d90b0cb0313c830b3ab/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c1535f1156cb05eb3976497ac732c01ba4b5048", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c1535f1156cb05eb3976497ac732c01ba4b5048", "html_url": "https://github.com/rust-lang/rust/commit/8c1535f1156cb05eb3976497ac732c01ba4b5048"}, {"sha": "75dcc61d3c1cce7b4428dd85bb588e99d9faf7a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/75dcc61d3c1cce7b4428dd85bb588e99d9faf7a9", "html_url": "https://github.com/rust-lang/rust/commit/75dcc61d3c1cce7b4428dd85bb588e99d9faf7a9"}], "stats": {"total": 415, "additions": 182, "deletions": 233}, "files": [{"sha": "89235d897bde6bc218e2e95766506cd598d38fd7", "filename": "src/libtest/formatters/json.rs", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/23967c39c9dad1a75e581d90b0cb0313c830b3ab/src%2Flibtest%2Fformatters%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23967c39c9dad1a75e581d90b0cb0313c830b3ab/src%2Flibtest%2Fformatters%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fjson.rs?ref=23967c39c9dad1a75e581d90b0cb0313c830b3ab", "patch": "@@ -36,17 +36,12 @@ impl<T: Write> JsonFormatter<T> {\n         if let Some(extras) = extra {\n             self.write_message(&*format!(\n                 r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\", {} }}\"#,\n-                ty,\n-                name,\n-                evt,\n-                extras\n+                ty, name, evt, extras\n             ))\n         } else {\n             self.write_message(&*format!(\n                 r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\" }}\"#,\n-                ty,\n-                name,\n-                evt\n+                ty, name, evt\n             ))\n         }\n     }\n@@ -89,14 +84,12 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n                 self.write_event(\"test\", desc.name.as_slice(), \"failed\", extra_data)\n             }\n \n-            TrFailedMsg(ref m) => {\n-                self.write_event(\n-                    \"test\",\n-                    desc.name.as_slice(),\n-                    \"failed\",\n-                    Some(format!(r#\"\"message\": \"{}\"\"#, EscapedString(m))),\n-                )\n-            }\n+            TrFailedMsg(ref m) => self.write_event(\n+                \"test\",\n+                desc.name.as_slice(),\n+                \"failed\",\n+                Some(format!(r#\"\"message\": \"{}\"\"#, EscapedString(m))),\n+            ),\n \n             TrIgnored => self.write_event(\"test\", desc.name.as_slice(), \"ignored\", None),\n \n@@ -116,13 +109,10 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n \n                 let line = format!(\n                     \"{{ \\\"type\\\": \\\"bench\\\", \\\n-                                \\\"name\\\": \\\"{}\\\", \\\n-                                \\\"median\\\": {}, \\\n-                                \\\"deviation\\\": {}{} }}\",\n-                    desc.name,\n-                    median,\n-                    deviation,\n-                    mbps\n+                     \\\"name\\\": \\\"{}\\\", \\\n+                     \\\"median\\\": {}, \\\n+                     \\\"deviation\\\": {}{} }}\",\n+                    desc.name, median, deviation, mbps\n                 );\n \n                 self.write_message(&*line)\n@@ -138,16 +128,15 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n     }\n \n     fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n-\n         self.write_message(&*format!(\n             \"{{ \\\"type\\\": \\\"suite\\\", \\\n-            \\\"event\\\": \\\"{}\\\", \\\n-            \\\"passed\\\": {}, \\\n-            \\\"failed\\\": {}, \\\n-            \\\"allowed_fail\\\": {}, \\\n-            \\\"ignored\\\": {}, \\\n-            \\\"measured\\\": {}, \\\n-            \\\"filtered_out\\\": \\\"{}\\\" }}\",\n+             \\\"event\\\": \\\"{}\\\", \\\n+             \\\"passed\\\": {}, \\\n+             \\\"failed\\\": {}, \\\n+             \\\"allowed_fail\\\": {}, \\\n+             \\\"ignored\\\": {}, \\\n+             \\\"measured\\\": {}, \\\n+             \\\"filtered_out\\\": \\\"{}\\\" }}\",\n             if state.failed == 0 { \"ok\" } else { \"failed\" },\n             state.passed,\n             state.failed + state.allowed_fail,"}, {"sha": "8e5fa00b5f27d6ebdded792cc7d072fe7ec8ea68", "filename": "src/libtest/formatters/pretty.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/23967c39c9dad1a75e581d90b0cb0313c830b3ab/src%2Flibtest%2Fformatters%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23967c39c9dad1a75e581d90b0cb0313c830b3ab/src%2Flibtest%2Fformatters%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fpretty.rs?ref=23967c39c9dad1a75e581d90b0cb0313c830b3ab", "patch": "@@ -196,8 +196,7 @@ impl<T: Write> OutputFormatter for PrettyFormatter<T> {\n \n         self.write_plain(&format!(\n             \"test {} has been running for over {} seconds\\n\",\n-            desc.name,\n-            TEST_WARN_TIMEOUT_S\n+            desc.name, TEST_WARN_TIMEOUT_S\n         ))\n     }\n \n@@ -232,11 +231,7 @@ impl<T: Write> OutputFormatter for PrettyFormatter<T> {\n         } else {\n             format!(\n                 \". {} passed; {} failed; {} ignored; {} measured; {} filtered out\\n\\n\",\n-                state.passed,\n-                state.failed,\n-                state.ignored,\n-                state.measured,\n-                state.filtered_out\n+                state.passed, state.failed, state.ignored, state.measured, state.filtered_out\n             )\n         };\n "}, {"sha": "85286027d69210d49c4c399508d7a0bddb2d6392", "filename": "src/libtest/formatters/terse.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/23967c39c9dad1a75e581d90b0cb0313c830b3ab/src%2Flibtest%2Fformatters%2Fterse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23967c39c9dad1a75e581d90b0cb0313c830b3ab/src%2Flibtest%2Fformatters%2Fterse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fterse.rs?ref=23967c39c9dad1a75e581d90b0cb0313c830b3ab", "patch": "@@ -195,8 +195,7 @@ impl<T: Write> OutputFormatter for TerseFormatter<T> {\n     fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n         self.write_plain(&format!(\n             \"test {} has been running for over {} seconds\\n\",\n-            desc.name,\n-            TEST_WARN_TIMEOUT_S\n+            desc.name, TEST_WARN_TIMEOUT_S\n         ))\n     }\n \n@@ -231,11 +230,7 @@ impl<T: Write> OutputFormatter for TerseFormatter<T> {\n         } else {\n             format!(\n                 \". {} passed; {} failed; {} ignored; {} measured; {} filtered out\\n\\n\",\n-                state.passed,\n-                state.failed,\n-                state.ignored,\n-                state.measured,\n-                state.filtered_out\n+                state.passed, state.failed, state.ignored, state.measured, state.filtered_out\n             )\n         };\n "}, {"sha": "b8be1aeff174278244bca9fcfebc509c1fecb3f7", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 145, "deletions": 180, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/23967c39c9dad1a75e581d90b0cb0313c830b3ab/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23967c39c9dad1a75e581d90b0cb0313c830b3ab/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=23967c39c9dad1a75e581d90b0cb0313c830b3ab", "patch": "@@ -30,10 +30,8 @@\n #![unstable(feature = \"test\", issue = \"27812\")]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n-       test(attr(deny(warnings))))]\n+       html_root_url = \"https://doc.rust-lang.org/nightly/\", test(attr(deny(warnings))))]\n #![deny(warnings)]\n-\n #![feature(asm)]\n #![feature(fnbox)]\n #![cfg_attr(any(unix, target_os = \"cloudabi\"), feature(libc))]\n@@ -43,10 +41,10 @@\n #![feature(termination_trait_lib)]\n \n extern crate getopts;\n-extern crate term;\n #[cfg(any(unix, target_os = \"cloudabi\"))]\n extern crate libc;\n extern crate panic_unwind;\n+extern crate term;\n \n pub use self::TestFn::*;\n pub use self::ColorConfig::*;\n@@ -72,7 +70,7 @@ use std::process::Termination;\n use std::sync::mpsc::{channel, Sender};\n use std::sync::{Arc, Mutex};\n use std::thread;\n-use std::time::{Instant, Duration};\n+use std::time::{Duration, Instant};\n use std::borrow::Cow;\n use std::process;\n \n@@ -81,16 +79,16 @@ const QUIET_MODE_MAX_COLUMN: usize = 100; // insert a '\\n' after 100 tests in qu\n \n // to be used by rustc to compile tests in libtest\n pub mod test {\n-    pub use {Bencher, TestName, TestResult, TestDesc, TestDescAndFn, TestOpts, TrFailed,\n-             TrFailedMsg, TrIgnored, TrOk, Metric, MetricMap, StaticTestFn, StaticTestName,\n-             DynTestName, DynTestFn, assert_test_result, run_test, test_main, test_main_static,\n-             filter_tests, parse_opts, StaticBenchFn, ShouldPanic, Options};\n+    pub use {assert_test_result, filter_tests, parse_opts, run_test, test_main, test_main_static,\n+             Bencher, DynTestFn, DynTestName, Metric, MetricMap, Options, ShouldPanic,\n+             StaticBenchFn, StaticTestFn, StaticTestName, TestDesc, TestDescAndFn, TestName,\n+             TestOpts, TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk};\n }\n \n pub mod stats;\n mod formatters;\n \n-use formatters::{OutputFormatter, PrettyFormatter, TerseFormatter, JsonFormatter};\n+use formatters::{JsonFormatter, OutputFormatter, PrettyFormatter, TerseFormatter};\n \n // The name of a test. By convention this follows the rules for rust\n // paths; i.e. it should be a series of identifiers separated by double\n@@ -255,7 +253,9 @@ pub struct Options {\n \n impl Options {\n     pub fn new() -> Options {\n-        Options { display_output: false }\n+        Options {\n+            display_output: false,\n+        }\n     }\n \n     pub fn display_output(mut self, display_output: bool) -> Options {\n@@ -272,7 +272,7 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Options) {\n         Some(Err(msg)) => {\n             eprintln!(\"error: {}\", msg);\n             process::exit(101);\n-        },\n+        }\n         None => return,\n     };\n \n@@ -289,7 +289,7 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Options) {\n             Err(e) => {\n                 eprintln!(\"error: io error when listing tests: {:?}\", e);\n                 process::exit(101);\n-            },\n+            }\n         }\n     }\n }\n@@ -306,18 +306,14 @@ pub fn test_main_static(tests: &[TestDescAndFn]) {\n     let owned_tests = tests\n         .iter()\n         .map(|t| match t.testfn {\n-            StaticTestFn(f) => {\n-                TestDescAndFn {\n-                    testfn: StaticTestFn(f),\n-                    desc: t.desc.clone(),\n-                }\n-            }\n-            StaticBenchFn(f) => {\n-                TestDescAndFn {\n-                    testfn: StaticBenchFn(f),\n-                    desc: t.desc.clone(),\n-                }\n-            }\n+            StaticTestFn(f) => TestDescAndFn {\n+                testfn: StaticTestFn(f),\n+                desc: t.desc.clone(),\n+            },\n+            StaticBenchFn(f) => TestDescAndFn {\n+                testfn: StaticBenchFn(f),\n+                desc: t.desc.clone(),\n+            },\n             _ => panic!(\"non-static tests passed to test::test_main_static\"),\n         })\n         .collect();\n@@ -397,34 +393,34 @@ fn optgroups() -> getopts::Options {\n             \"\",\n             \"logfile\",\n             \"Write logs to the specified file instead \\\n-                                of stdout\",\n+             of stdout\",\n             \"PATH\",\n         )\n         .optflag(\n             \"\",\n             \"nocapture\",\n             \"don't capture stdout/stderr of each \\\n-                                   task, allow printing directly\",\n+             task, allow printing directly\",\n         )\n         .optopt(\n             \"\",\n             \"test-threads\",\n             \"Number of threads used for running tests \\\n-                                     in parallel\",\n+             in parallel\",\n             \"n_threads\",\n         )\n         .optmulti(\n             \"\",\n             \"skip\",\n             \"Skip tests whose names contain FILTER (this flag can \\\n-                               be used multiple times)\",\n+             be used multiple times)\",\n             \"FILTER\",\n         )\n         .optflag(\n             \"q\",\n             \"quiet\",\n             \"Display one character per test instead of one line. \\\n-                                Alias to --format=terse\",\n+             Alias to --format=terse\",\n         )\n         .optflag(\n             \"\",\n@@ -516,8 +512,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n     if let Some(opt) = matches.opt_str(\"Z\") {\n         if !is_nightly() {\n             return Some(Err(\n-                \"the option `Z` is only accepted on the nightly compiler\"\n-                    .into(),\n+                \"the option `Z` is only accepted on the nightly compiler\".into(),\n             ));\n         }\n \n@@ -562,19 +557,17 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n     }\n \n     let test_threads = match matches.opt_str(\"test-threads\") {\n-        Some(n_str) => {\n-            match n_str.parse::<usize>() {\n-                Ok(0) => return Some(Err(format!(\"argument for --test-threads must not be 0\"))),\n-                Ok(n) => Some(n),\n-                Err(e) => {\n-                    return Some(Err(format!(\n-                        \"argument for --test-threads must be a number > 0 \\\n-                                             (error: {})\",\n-                        e\n-                    )))\n-                }\n+        Some(n_str) => match n_str.parse::<usize>() {\n+            Ok(0) => return Some(Err(format!(\"argument for --test-threads must not be 0\"))),\n+            Ok(n) => Some(n),\n+            Err(e) => {\n+                return Some(Err(format!(\n+                    \"argument for --test-threads must be a number > 0 \\\n+                     (error: {})\",\n+                    e\n+                )))\n             }\n-        }\n+        },\n         None => None,\n     };\n \n@@ -586,7 +579,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         Some(v) => {\n             return Some(Err(format!(\n                 \"argument for --color must be auto, always, or never (was \\\n-                                     {})\",\n+                 {})\",\n                 v\n             )))\n         }\n@@ -599,8 +592,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         Some(\"json\") => {\n             if !allow_unstable {\n                 return Some(Err(\n-                    \"The \\\"json\\\" format is only accepted on the nightly compiler\"\n-                        .into(),\n+                    \"The \\\"json\\\" format is only accepted on the nightly compiler\".into(),\n                 ));\n             }\n             OutputFormat::Json\n@@ -609,7 +601,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         Some(v) => {\n             return Some(Err(format!(\n                 \"argument for --format must be pretty, terse, or json (was \\\n-                                     {})\",\n+                 {})\",\n                 v\n             )))\n         }\n@@ -811,8 +803,7 @@ pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Res\n                 ntest += 1;\n                 \"test\"\n             }\n-            StaticBenchFn(..) |\n-            DynBenchFn(..) => {\n+            StaticBenchFn(..) | DynBenchFn(..) => {\n                 nbench += 1;\n                 \"benchmark\"\n             }\n@@ -834,7 +825,8 @@ pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Res\n             writeln!(output, \"\")?;\n         }\n \n-        writeln!(output,\n+        writeln!(\n+            output,\n             \"{}, {}\",\n             plural(ntest, \"test\"),\n             plural(nbench, \"benchmark\")\n@@ -851,7 +843,6 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n         st: &mut ConsoleTestState,\n         out: &mut OutputFormatter,\n     ) -> io::Result<()> {\n-\n         match (*event).clone() {\n             TeFiltered(ref filtered_tests) => {\n                 st.total = filtered_tests.len();\n@@ -989,8 +980,7 @@ fn use_color(opts: &TestOpts) -> bool {\n     }\n }\n \n-#[cfg(any(target_os = \"cloudabi\",\n-          target_os = \"redox\",\n+#[cfg(any(target_os = \"cloudabi\", target_os = \"redox\",\n           all(target_arch = \"wasm32\", not(target_os = \"emscripten\"))))]\n fn stdout_isatty() -> bool {\n     // FIXME: Implement isatty on Redox\n@@ -1089,10 +1079,12 @@ where\n         let now = Instant::now();\n         let timed_out = running_tests\n             .iter()\n-            .filter_map(|(desc, timeout)| if &now >= timeout {\n-                Some(desc.clone())\n-            } else {\n-                None\n+            .filter_map(|(desc, timeout)| {\n+                if &now >= timeout {\n+                    Some(desc.clone())\n+                } else {\n+                    None\n+                }\n             })\n             .collect();\n         for test in &timed_out {\n@@ -1174,12 +1166,10 @@ fn get_concurrency() -> usize {\n             let opt_n: Option<usize> = s.parse().ok();\n             match opt_n {\n                 Some(n) if n > 0 => n,\n-                _ => {\n-                    panic!(\n-                        \"RUST_TEST_THREADS is `{}`, should be a positive integer.\",\n-                        s\n-                    )\n-                }\n+                _ => panic!(\n+                    \"RUST_TEST_THREADS is `{}`, should be a positive integer.\",\n+                    s\n+                ),\n             }\n         }\n         Err(..) => num_cpus(),\n@@ -1223,20 +1213,15 @@ fn get_concurrency() -> usize {\n         1\n     }\n \n-    #[cfg(any(target_os = \"android\",\n-              target_os = \"cloudabi\",\n-              target_os = \"emscripten\",\n-              target_os = \"fuchsia\",\n-              target_os = \"ios\",\n-              target_os = \"linux\",\n-              target_os = \"macos\",\n-              target_os = \"solaris\"))]\n+    #[cfg(any(target_os = \"android\", target_os = \"cloudabi\", target_os = \"emscripten\",\n+              target_os = \"fuchsia\", target_os = \"ios\", target_os = \"linux\",\n+              target_os = \"macos\", target_os = \"solaris\"))]\n     fn num_cpus() -> usize {\n         unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as usize }\n     }\n \n     #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"bitrig\",\n-                target_os = \"netbsd\"))]\n+              target_os = \"netbsd\"))]\n     fn num_cpus() -> usize {\n         use std::ptr;\n \n@@ -1308,26 +1293,28 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n     // Remove tests that don't match the test filter\n     filtered = match opts.filter {\n         None => filtered,\n-        Some(ref filter) => {\n-            filtered\n-                .into_iter()\n-                .filter(|test| if opts.filter_exact {\n+        Some(ref filter) => filtered\n+            .into_iter()\n+            .filter(|test| {\n+                if opts.filter_exact {\n                     test.desc.name.as_slice() == &filter[..]\n                 } else {\n                     test.desc.name.as_slice().contains(&filter[..])\n-                })\n-                .collect()\n-        }\n+                }\n+            })\n+            .collect(),\n     };\n \n     // Skip tests that match any of the skip filters\n     filtered = filtered\n         .into_iter()\n         .filter(|t| {\n-            !opts.skip.iter().any(|sf| if opts.filter_exact {\n-                t.desc.name.as_slice() == &sf[..]\n-            } else {\n-                t.desc.name.as_slice().contains(&sf[..])\n+            !opts.skip.iter().any(|sf| {\n+                if opts.filter_exact {\n+                    t.desc.name.as_slice() == &sf[..]\n+                } else {\n+                    t.desc.name.as_slice().contains(&sf[..])\n+                }\n             })\n         })\n         .collect();\n@@ -1354,31 +1341,23 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n     };\n \n     // Sort the tests alphabetically\n-    filtered.sort_by(|t1, t2| {\n-        t1.desc.name.as_slice().cmp(t2.desc.name.as_slice())\n-    });\n+    filtered.sort_by(|t1, t2| t1.desc.name.as_slice().cmp(t2.desc.name.as_slice()));\n \n     filtered\n }\n \n pub fn convert_benchmarks_to_tests(tests: Vec<TestDescAndFn>) -> Vec<TestDescAndFn> {\n     // convert benchmarks to tests, if we're not benchmarking them\n-    tests.into_iter().map(|x| {\n-        let testfn = match x.testfn {\n-            DynBenchFn(bench) => {\n-                DynTestFn(Box::new(move || {\n-                    bench::run_once(|b| {\n-                        __rust_begin_short_backtrace(|| bench.run(b))\n-                    })\n-                }))\n-            }\n-            StaticBenchFn(benchfn) => {\n-                DynTestFn(Box::new(move || {\n-                    bench::run_once(|b| {\n-                        __rust_begin_short_backtrace(|| benchfn(b))\n-                    })\n-                }))\n-            }\n+    tests\n+        .into_iter()\n+        .map(|x| {\n+            let testfn = match x.testfn {\n+                DynBenchFn(bench) => DynTestFn(Box::new(move || {\n+                    bench::run_once(|b| __rust_begin_short_backtrace(|| bench.run(b)))\n+                })),\n+                StaticBenchFn(benchfn) => DynTestFn(Box::new(move || {\n+                    bench::run_once(|b| __rust_begin_short_backtrace(|| benchfn(b)))\n+                })),\n                 f => f,\n             };\n             TestDescAndFn {\n@@ -1395,22 +1374,22 @@ pub fn run_test(\n     test: TestDescAndFn,\n     monitor_ch: Sender<MonitorMsg>,\n ) {\n-\n     let TestDescAndFn { desc, testfn } = test;\n \n-    let ignore_because_panic_abort = cfg!(target_arch = \"wasm32\") &&\n-        !cfg!(target_os = \"emscripten\") &&\n-        desc.should_panic != ShouldPanic::No;\n+    let ignore_because_panic_abort = cfg!(target_arch = \"wasm32\") && !cfg!(target_os = \"emscripten\")\n+        && desc.should_panic != ShouldPanic::No;\n \n     if force_ignore || desc.ignore || ignore_because_panic_abort {\n         monitor_ch.send((desc, TrIgnored, Vec::new())).unwrap();\n         return;\n     }\n \n-    fn run_test_inner(desc: TestDesc,\n-                      monitor_ch: Sender<MonitorMsg>,\n-                      nocapture: bool,\n-                      testfn: Box<FnBox() + Send>) {\n+    fn run_test_inner(\n+        desc: TestDesc,\n+        monitor_ch: Sender<MonitorMsg>,\n+        nocapture: bool,\n+        testfn: Box<FnBox() + Send>,\n+    ) {\n         // Buffer for capturing standard I/O\n         let data = Arc::new(Mutex::new(Vec::new()));\n         let data2 = data.clone();\n@@ -1440,7 +1419,6 @@ pub fn run_test(\n                 .unwrap();\n         };\n \n-\n         // If the platform is single-threaded we're just going to run\n         // the test synchronously, regardless of the concurrency\n         // level.\n@@ -1455,27 +1433,25 @@ pub fn run_test(\n \n     match testfn {\n         DynBenchFn(bencher) => {\n-            ::bench::benchmark(desc,\n-                                monitor_ch,\n-                                opts.nocapture,\n-                                |harness| bencher.run(harness));\n+            ::bench::benchmark(desc, monitor_ch, opts.nocapture, |harness| {\n+                bencher.run(harness)\n+            });\n         }\n         StaticBenchFn(benchfn) => {\n-            ::bench::benchmark(desc,\n-                                monitor_ch,\n-                                opts.nocapture,\n-                                |harness| (benchfn.clone())(harness));\n+            ::bench::benchmark(desc, monitor_ch, opts.nocapture, |harness| {\n+                (benchfn.clone())(harness)\n+            });\n         }\n         DynTestFn(f) => {\n-            let cb = move || {\n-                __rust_begin_short_backtrace(f)\n-            };\n+            let cb = move || __rust_begin_short_backtrace(f);\n             run_test_inner(desc, monitor_ch, opts.nocapture, Box::new(cb))\n         }\n-        StaticTestFn(f) => {\n-            run_test_inner(desc, monitor_ch, opts.nocapture,\n-                           Box::new(move || __rust_begin_short_backtrace(f)))\n-        }\n+        StaticTestFn(f) => run_test_inner(\n+            desc,\n+            monitor_ch,\n+            opts.nocapture,\n+            Box::new(move || __rust_begin_short_backtrace(f)),\n+        ),\n     }\n }\n \n@@ -1487,8 +1463,7 @@ fn __rust_begin_short_backtrace<F: FnOnce()>(f: F) {\n \n fn calc_result(desc: &TestDesc, task_result: Result<(), Box<Any + Send>>) -> TestResult {\n     match (&desc.should_panic, task_result) {\n-        (&ShouldPanic::No, Ok(())) |\n-        (&ShouldPanic::Yes, Err(_)) => TrOk,\n+        (&ShouldPanic::No, Ok(())) | (&ShouldPanic::Yes, Err(_)) => TrOk,\n         (&ShouldPanic::YesWithMessage(msg), Err(ref err)) => {\n             if err.downcast_ref::<String>()\n                 .map(|e| &**e)\n@@ -1545,7 +1520,6 @@ impl MetricMap {\n     }\n }\n \n-\n // Benchmarking\n \n /// A function that is opaque to the optimizer, to allow benchmarks to\n@@ -1566,7 +1540,6 @@ pub fn black_box<T>(dummy: T) -> T {\n     dummy\n }\n \n-\n impl Bencher {\n     /// Callback for benchmark functions to run in their body.\n     pub fn iter<T, F>(&mut self, mut inner: F)\n@@ -1605,7 +1578,6 @@ where\n     return ns_from_dur(start.elapsed());\n }\n \n-\n pub fn iter<T, F>(inner: &mut F) -> stats::Summary\n where\n     F: FnMut() -> T,\n@@ -1649,8 +1621,8 @@ where\n \n         // If we've run for 100ms and seem to have converged to a\n         // stable median.\n-        if loop_run > Duration::from_millis(100) && summ.median_abs_dev_pct < 1.0 &&\n-            summ.median - summ5.median < summ5.median_abs_dev\n+        if loop_run > Duration::from_millis(100) && summ.median_abs_dev_pct < 1.0\n+            && summ.median - summ5.median < summ5.median_abs_dev\n         {\n             return summ5;\n         }\n@@ -1680,7 +1652,7 @@ pub mod bench {\n     use std::io;\n     use std::sync::{Arc, Mutex};\n     use stats;\n-    use super::{Bencher, BenchSamples, BenchMode, Sink, MonitorMsg, TestDesc, Sender, TestResult};\n+    use super::{BenchMode, BenchSamples, Bencher, MonitorMsg, Sender, Sink, TestDesc, TestResult};\n \n     pub fn benchmark<F>(desc: TestDesc, monitor_ch: Sender<MonitorMsg>, nocapture: bool, f: F)\n     where\n@@ -1711,7 +1683,8 @@ pub mod bench {\n             io::set_panic(panicio);\n         };\n \n-        let test_result = match result { //bs.bench(f) {\n+        let test_result = match result {\n+            //bs.bench(f) {\n             Ok(Some(ns_iter_summ)) => {\n                 let ns_iter = cmp::max(ns_iter_summ.median as u64, 1);\n                 let mb_s = bs.bytes * 1000 / ns_iter;\n@@ -1732,9 +1705,7 @@ pub mod bench {\n                 };\n                 TestResult::TrBench(bs)\n             }\n-            Err(_) => {\n-                TestResult::TrFailed\n-            }\n+            Err(_) => TestResult::TrFailed,\n         };\n \n         let stdout = data.lock().unwrap().to_vec();\n@@ -1756,9 +1727,9 @@ pub mod bench {\n \n #[cfg(test)]\n mod tests {\n-    use test::{TrFailed, TrFailedMsg, TrIgnored, TrOk, filter_tests, parse_opts, TestDesc,\n-               TestDescAndFn, TestOpts, run_test, MetricMap, StaticTestName, DynTestName,\n-               DynTestFn, ShouldPanic};\n+    use test::{filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, ShouldPanic,\n+               StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailed, TrFailedMsg,\n+               TrIgnored, TrOk};\n     use std::sync::mpsc::channel;\n     use bench;\n     use Bencher;\n@@ -1904,25 +1875,26 @@ mod tests {\n         opts.run_tests = true;\n         opts.run_ignored = true;\n \n-        let tests =\n-            vec![TestDescAndFn {\n-                             desc: TestDesc {\n-                                 name: StaticTestName(\"1\"),\n-                                 ignore: true,\n-                                 should_panic: ShouldPanic::No,\n-                                 allow_fail: false,\n-                             },\n-                             testfn: DynTestFn(Box::new(move || {})),\n-                         },\n-                         TestDescAndFn {\n-                             desc: TestDesc {\n-                                 name: StaticTestName(\"2\"),\n-                                 ignore: false,\n-                                 should_panic: ShouldPanic::No,\n-                                 allow_fail: false,\n-                             },\n-                             testfn: DynTestFn(Box::new(move || {})),\n-                         }];\n+        let tests = vec![\n+            TestDescAndFn {\n+                desc: TestDesc {\n+                    name: StaticTestName(\"1\"),\n+                    ignore: true,\n+                    should_panic: ShouldPanic::No,\n+                    allow_fail: false,\n+                },\n+                testfn: DynTestFn(Box::new(move || {})),\n+            },\n+            TestDescAndFn {\n+                desc: TestDesc {\n+                    name: StaticTestName(\"2\"),\n+                    ignore: false,\n+                    should_panic: ShouldPanic::No,\n+                    allow_fail: false,\n+                },\n+                testfn: DynTestFn(Box::new(move || {})),\n+            },\n+        ];\n         let filtered = filter_tests(&opts, tests);\n \n         assert_eq!(filtered.len(), 1);\n@@ -1935,17 +1907,16 @@ mod tests {\n         fn tests() -> Vec<TestDescAndFn> {\n             vec![\"base\", \"base::test\", \"base::test1\", \"base::test2\"]\n                 .into_iter()\n-                .map(|name| {\n-                    TestDescAndFn {\n-                        desc: TestDesc {\n-                            name: StaticTestName(name),\n-                            ignore: false,\n-                            should_panic: ShouldPanic::No,\n-                            allow_fail: false,\n-                        },\n-                        testfn: DynTestFn(Box::new(move || {}))\n-                    }\n-                }).collect()\n+                .map(|name| TestDescAndFn {\n+                    desc: TestDesc {\n+                        name: StaticTestName(name),\n+                        ignore: false,\n+                        should_panic: ShouldPanic::No,\n+                        allow_fail: false,\n+                    },\n+                    testfn: DynTestFn(Box::new(move || {})),\n+                })\n+                .collect()\n         }\n \n         let substr = filter_tests(\n@@ -2127,10 +2098,7 @@ mod tests {\n             allow_fail: false,\n         };\n \n-        ::bench::benchmark(desc,\n-                            tx,\n-                            true,\n-                            f);\n+        ::bench::benchmark(desc, tx, true, f);\n         rx.recv().unwrap();\n     }\n \n@@ -2149,10 +2117,7 @@ mod tests {\n             allow_fail: false,\n         };\n \n-        ::bench::benchmark(desc,\n-                            tx,\n-                            true,\n-                            f);\n+        ::bench::benchmark(desc, tx, true, f);\n         rx.recv().unwrap();\n     }\n }"}, {"sha": "ddb5dcf2a1cd3a2d8ee7acf416542f3d10cf1919", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/23967c39c9dad1a75e581d90b0cb0313c830b3ab/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23967c39c9dad1a75e581d90b0cb0313c830b3ab/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=23967c39c9dad1a75e581d90b0cb0313c830b3ab", "patch": "@@ -279,7 +279,6 @@ impl Stats for [f64] {\n     }\n }\n \n-\n // Helper function: extract a value representing the `pct` percentile of a sorted sample-set, using\n // linear interpolation. If samples are not sorted, return nonsensical value.\n fn percentile_of_sorted(sorted_samples: &[f64], pct: f64) -> f64 {\n@@ -304,7 +303,6 @@ fn percentile_of_sorted(sorted_samples: &[f64], pct: f64) -> f64 {\n     lo + (hi - lo) * d\n }\n \n-\n /// Winsorize a set of samples, replacing values above the `100-pct` percentile\n /// and below the `pct` percentile with those percentiles themselves. This is a\n /// way of minimizing the effect of outliers, at the cost of biasing the sample.\n@@ -338,15 +336,18 @@ mod tests {\n     use std::io;\n \n     macro_rules! assert_approx_eq {\n-        ($a:expr, $b:expr) => ({\n+        ($a: expr, $b: expr) => {{\n             let (a, b) = (&$a, &$b);\n-            assert!((*a - *b).abs() < 1.0e-6,\n-                    \"{} is not approximately equal to {}\", *a, *b);\n-        })\n+            assert!(\n+                (*a - *b).abs() < 1.0e-6,\n+                \"{} is not approximately equal to {}\",\n+                *a,\n+                *b\n+            );\n+        }};\n     }\n \n     fn check(samples: &[f64], summ: &Summary) {\n-\n         let summ2 = Summary::new(samples);\n \n         let mut w = io::sink();\n@@ -911,14 +912,18 @@ mod bench {\n \n     #[bench]\n     pub fn sum_three_items(b: &mut Bencher) {\n-        b.iter(|| { [1e20f64, 1.5f64, -1e20f64].sum(); })\n+        b.iter(|| {\n+            [1e20f64, 1.5f64, -1e20f64].sum();\n+        })\n     }\n     #[bench]\n     pub fn sum_many_f64(b: &mut Bencher) {\n         let nums = [-1e30f64, 1e60, 1e30, 1.0, -1e60];\n         let v = (0..500).map(|i| nums[i % 5]).collect::<Vec<_>>();\n \n-        b.iter(|| { v.sum(); })\n+        b.iter(|| {\n+            v.sum();\n+        })\n     }\n \n     #[bench]"}]}