{"sha": "c4944fb60d102a4a4e0cb5f3f86379bea2338ed0", "node_id": "C_kwDOAAsO6NoAKGM0OTQ0ZmI2MGQxMDJhNGE0ZTBjYjVmM2Y4NjM3OWJlYTIzMzhlZDA", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2022-02-12T09:32:44Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2022-02-17T17:02:31Z"}, "message": "Actually lint parking_lot in await_holding_lock\n\nThis adapts the paths for the parking_lot mutex guards, so that\nparking_lot mutexes and RwLocks actually get linted. This is now also\ntested.", "tree": {"sha": "5d6aaa69f1c22049ecc53711b0e8cf068606e598", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d6aaa69f1c22049ecc53711b0e8cf068606e598"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4944fb60d102a4a4e0cb5f3f86379bea2338ed0", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmIOf60ACgkQHKDfKvWd\naKVigBAAtjciMYSBlTGHcOg13Oqey7FFAh9oyw1XAlbOpTob+HWqwxVEcK9lwVc8\nty6MbfyFZV14ru52JPUOHlGygPexSikPajXkKrGCb3MMPq8EHv0L+VVdnFbhsFE2\n1zs+Bbd74LeJAsiJzwq2XByaP6mGyCaskVpeJb5vHQY/4/D/7mcYcKk2ICINmy5q\nulS+nmh7Ymlox/lnAD3hRQ/hQuxOHc9EJPnnDSiZbXQ+f9GUMxRdNZOqJeNyZFz2\nhU0G5DHX5t1PM3sDMtPlgidpljqmYr8IPvrsyjVVilki5Kfirdzs0I9UvMuXkG3W\nlUpuE2RieN0pQaVNgcpGN/h+AKrLCfcT6dZi26WwP2y5XCnQa7MXhaKsaA7Jk3wT\nOF0b4VPhw00H3FhaisalDOk+3Qn7W7XSbIy6pBG5gJeDOoZUuH+Abl3nm+sHsNC6\nWx66du0HnAuSzfEyYCeHZaYgyxgetygypc5JenJfSoUHn+LEaB7lnFw7dcztlVc0\nDe4q4yHWuSoKpTYatfUM85EQ/rUf0pOl37Vs0R8U2aCXxwYhSZ975nKs0FRg3mj4\nVO8mZjl2RMgrvUwQjYEh5A7HcR6ntscN9ZLxg7KzL6JuBVNNym25YZqVHhI7sRy3\nuZ4CZRgNgiyS8BpGC4XsRdHMfOHeJdXKKoW8XCnKyIx8eK2eiOI=\n=SMa3\n-----END PGP SIGNATURE-----", "payload": "tree 5d6aaa69f1c22049ecc53711b0e8cf068606e598\nparent cdf9a28006b1216653eac1bdc45a83e436fac9ba\nauthor flip1995 <philipp.krones@embecosm.com> 1644658364 +0100\ncommitter flip1995 <philipp.krones@embecosm.com> 1645117351 +0100\n\nActually lint parking_lot in await_holding_lock\n\nThis adapts the paths for the parking_lot mutex guards, so that\nparking_lot mutexes and RwLocks actually get linted. This is now also\ntested.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4944fb60d102a4a4e0cb5f3f86379bea2338ed0", "html_url": "https://github.com/rust-lang/rust/commit/c4944fb60d102a4a4e0cb5f3f86379bea2338ed0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4944fb60d102a4a4e0cb5f3f86379bea2338ed0/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdf9a28006b1216653eac1bdc45a83e436fac9ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdf9a28006b1216653eac1bdc45a83e436fac9ba", "html_url": "https://github.com/rust-lang/rust/commit/cdf9a28006b1216653eac1bdc45a83e436fac9ba"}], "stats": {"total": 390, "additions": 287, "deletions": 103}, "files": [{"sha": "b54bd3a4fef0b0186b34433a4e910484d6def13b", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4944fb60d102a4a4e0cb5f3f86379bea2338ed0/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4944fb60d102a4a4e0cb5f3f86379bea2338ed0/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=c4944fb60d102a4a4e0cb5f3f86379bea2338ed0", "patch": "@@ -105,9 +105,9 @@ pub const OS_STRING_AS_OS_STR: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsString\",\n pub const OS_STR_TO_OS_STRING: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsStr\", \"to_os_string\"];\n pub const PARKING_LOT_RAWMUTEX: [&str; 3] = [\"parking_lot\", \"raw_mutex\", \"RawMutex\"];\n pub const PARKING_LOT_RAWRWLOCK: [&str; 3] = [\"parking_lot\", \"raw_rwlock\", \"RawRwLock\"];\n-pub const PARKING_LOT_MUTEX_GUARD: [&str; 2] = [\"parking_lot\", \"MutexGuard\"];\n-pub const PARKING_LOT_RWLOCK_READ_GUARD: [&str; 2] = [\"parking_lot\", \"RwLockReadGuard\"];\n-pub const PARKING_LOT_RWLOCK_WRITE_GUARD: [&str; 2] = [\"parking_lot\", \"RwLockWriteGuard\"];\n+pub const PARKING_LOT_MUTEX_GUARD: [&str; 3] = [\"lock_api\", \"mutex\", \"MutexGuard\"];\n+pub const PARKING_LOT_RWLOCK_READ_GUARD: [&str; 3] = [\"lock_api\", \"rwlock\", \"RwLockReadGuard\"];\n+pub const PARKING_LOT_RWLOCK_WRITE_GUARD: [&str; 3] = [\"lock_api\", \"rwlock\", \"RwLockWriteGuard\"];\n pub const PATH_BUF_AS_PATH: [&str; 4] = [\"std\", \"path\", \"PathBuf\", \"as_path\"];\n pub const PATH_TO_PATH_BUF: [&str; 4] = [\"std\", \"path\", \"Path\", \"to_path_buf\"];\n pub const PERMISSIONS: [&str; 3] = [\"std\", \"fs\", \"Permissions\"];"}, {"sha": "1a57db91ab59e959b7f2220d7e74ef2938daf504", "filename": "tests/ui/await_holding_lock.rs", "status": "modified", "additions": 147, "deletions": 57, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/c4944fb60d102a4a4e0cb5f3f86379bea2338ed0/tests%2Fui%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4944fb60d102a4a4e0cb5f3f86379bea2338ed0/tests%2Fui%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_lock.rs?ref=c4944fb60d102a4a4e0cb5f3f86379bea2338ed0", "patch": "@@ -1,88 +1,178 @@\n #![warn(clippy::await_holding_lock)]\n \n-use std::sync::{Mutex, RwLock};\n+// When adding or modifying a test, please do the same for parking_lot::Mutex.\n+mod std_mutex {\n+    use std::sync::{Mutex, RwLock};\n \n-async fn bad(x: &Mutex<u32>) -> u32 {\n-    let guard = x.lock().unwrap();\n-    baz().await\n-}\n+    pub async fn bad(x: &Mutex<u32>) -> u32 {\n+        let guard = x.lock().unwrap();\n+        baz().await\n+    }\n \n-async fn good(x: &Mutex<u32>) -> u32 {\n-    {\n+    pub async fn good(x: &Mutex<u32>) -> u32 {\n+        {\n+            let guard = x.lock().unwrap();\n+            let y = *guard + 1;\n+        }\n+        baz().await;\n         let guard = x.lock().unwrap();\n-        let y = *guard + 1;\n+        47\n     }\n-    baz().await;\n-    let guard = x.lock().unwrap();\n-    47\n-}\n \n-pub async fn bad_rw(x: &RwLock<u32>) -> u32 {\n-    let guard = x.read().unwrap();\n-    baz().await\n-}\n+    pub async fn bad_rw(x: &RwLock<u32>) -> u32 {\n+        let guard = x.read().unwrap();\n+        baz().await\n+    }\n \n-pub async fn bad_rw_write(x: &RwLock<u32>) -> u32 {\n-    let mut guard = x.write().unwrap();\n-    baz().await\n-}\n+    pub async fn bad_rw_write(x: &RwLock<u32>) -> u32 {\n+        let mut guard = x.write().unwrap();\n+        baz().await\n+    }\n \n-pub async fn good_rw(x: &RwLock<u32>) -> u32 {\n-    {\n+    pub async fn good_rw(x: &RwLock<u32>) -> u32 {\n+        {\n+            let guard = x.read().unwrap();\n+            let y = *guard + 1;\n+        }\n+        {\n+            let mut guard = x.write().unwrap();\n+            *guard += 1;\n+        }\n+        baz().await;\n         let guard = x.read().unwrap();\n-        let y = *guard + 1;\n+        47\n     }\n-    {\n-        let mut guard = x.write().unwrap();\n-        *guard += 1;\n+\n+    pub async fn baz() -> u32 {\n+        42\n     }\n-    baz().await;\n-    let guard = x.read().unwrap();\n-    47\n-}\n \n-async fn baz() -> u32 {\n-    42\n-}\n+    pub async fn also_bad(x: &Mutex<u32>) -> u32 {\n+        let first = baz().await;\n+\n+        let guard = x.lock().unwrap();\n \n-async fn also_bad(x: &Mutex<u32>) -> u32 {\n-    let first = baz().await;\n+        let second = baz().await;\n \n-    let guard = x.lock().unwrap();\n+        let third = baz().await;\n \n-    let second = baz().await;\n+        first + second + third\n+    }\n+\n+    pub async fn not_good(x: &Mutex<u32>) -> u32 {\n+        let first = baz().await;\n+\n+        let second = {\n+            let guard = x.lock().unwrap();\n+            baz().await\n+        };\n \n-    let third = baz().await;\n+        let third = baz().await;\n \n-    first + second + third\n+        first + second + third\n+    }\n+\n+    #[allow(clippy::manual_async_fn)]\n+    pub fn block_bad(x: &Mutex<u32>) -> impl std::future::Future<Output = u32> + '_ {\n+        async move {\n+            let guard = x.lock().unwrap();\n+            baz().await\n+        }\n+    }\n }\n \n-async fn not_good(x: &Mutex<u32>) -> u32 {\n-    let first = baz().await;\n+// When adding or modifying a test, please do the same for std::Mutex.\n+mod parking_lot_mutex {\n+    use parking_lot::{Mutex, RwLock};\n \n-    let second = {\n-        let guard = x.lock().unwrap();\n+    pub async fn bad(x: &Mutex<u32>) -> u32 {\n+        let guard = x.lock();\n         baz().await\n-    };\n+    }\n \n-    let third = baz().await;\n+    pub async fn good(x: &Mutex<u32>) -> u32 {\n+        {\n+            let guard = x.lock();\n+            let y = *guard + 1;\n+        }\n+        baz().await;\n+        let guard = x.lock();\n+        47\n+    }\n \n-    first + second + third\n-}\n+    pub async fn bad_rw(x: &RwLock<u32>) -> u32 {\n+        let guard = x.read();\n+        baz().await\n+    }\n \n-#[allow(clippy::manual_async_fn)]\n-fn block_bad(x: &Mutex<u32>) -> impl std::future::Future<Output = u32> + '_ {\n-    async move {\n-        let guard = x.lock().unwrap();\n+    pub async fn bad_rw_write(x: &RwLock<u32>) -> u32 {\n+        let mut guard = x.write();\n         baz().await\n     }\n+\n+    pub async fn good_rw(x: &RwLock<u32>) -> u32 {\n+        {\n+            let guard = x.read();\n+            let y = *guard + 1;\n+        }\n+        {\n+            let mut guard = x.write();\n+            *guard += 1;\n+        }\n+        baz().await;\n+        let guard = x.read();\n+        47\n+    }\n+\n+    pub async fn baz() -> u32 {\n+        42\n+    }\n+\n+    pub async fn also_bad(x: &Mutex<u32>) -> u32 {\n+        let first = baz().await;\n+\n+        let guard = x.lock();\n+\n+        let second = baz().await;\n+\n+        let third = baz().await;\n+\n+        first + second + third\n+    }\n+\n+    pub async fn not_good(x: &Mutex<u32>) -> u32 {\n+        let first = baz().await;\n+\n+        let second = {\n+            let guard = x.lock();\n+            baz().await\n+        };\n+\n+        let third = baz().await;\n+\n+        first + second + third\n+    }\n+\n+    #[allow(clippy::manual_async_fn)]\n+    pub fn block_bad(x: &Mutex<u32>) -> impl std::future::Future<Output = u32> + '_ {\n+        async move {\n+            let guard = x.lock();\n+            baz().await\n+        }\n+    }\n }\n \n fn main() {\n-    let m = Mutex::new(100);\n-    good(&m);\n-    bad(&m);\n-    also_bad(&m);\n-    not_good(&m);\n-    block_bad(&m);\n+    let m = std::sync::Mutex::new(100);\n+    std_mutex::good(&m);\n+    std_mutex::bad(&m);\n+    std_mutex::also_bad(&m);\n+    std_mutex::not_good(&m);\n+    std_mutex::block_bad(&m);\n+\n+    let m = parking_lot::Mutex::new(100);\n+    parking_lot_mutex::good(&m);\n+    parking_lot_mutex::bad(&m);\n+    parking_lot_mutex::also_bad(&m);\n+    parking_lot_mutex::not_good(&m);\n }"}, {"sha": "a6c1dd228e46f2baa83149d73766aadcb8abc478", "filename": "tests/ui/await_holding_lock.stderr", "status": "modified", "additions": 137, "deletions": 43, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/c4944fb60d102a4a4e0cb5f3f86379bea2338ed0/tests%2Fui%2Fawait_holding_lock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4944fb60d102a4a4e0cb5f3f86379bea2338ed0/tests%2Fui%2Fawait_holding_lock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_lock.stderr?ref=c4944fb60d102a4a4e0cb5f3f86379bea2338ed0", "patch": "@@ -1,97 +1,191 @@\n error: this `MutexGuard` is held across an `await` point\n-  --> $DIR/await_holding_lock.rs:6:9\n+  --> $DIR/await_holding_lock.rs:8:13\n    |\n-LL |     let guard = x.lock().unwrap();\n-   |         ^^^^^\n+LL |         let guard = x.lock().unwrap();\n+   |             ^^^^^\n    |\n    = note: `-D clippy::await-holding-lock` implied by `-D warnings`\n    = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n note: these are all the `await` points this lock is held through\n-  --> $DIR/await_holding_lock.rs:6:5\n+  --> $DIR/await_holding_lock.rs:8:9\n    |\n-LL | /     let guard = x.lock().unwrap();\n-LL | |     baz().await\n-LL | | }\n-   | |_^\n+LL | /         let guard = x.lock().unwrap();\n+LL | |         baz().await\n+LL | |     }\n+   | |_____^\n \n error: this `MutexGuard` is held across an `await` point\n-  --> $DIR/await_holding_lock.rs:21:9\n+  --> $DIR/await_holding_lock.rs:23:13\n    |\n-LL |     let guard = x.read().unwrap();\n-   |         ^^^^^\n+LL |         let guard = x.read().unwrap();\n+   |             ^^^^^\n    |\n    = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n note: these are all the `await` points this lock is held through\n-  --> $DIR/await_holding_lock.rs:21:5\n+  --> $DIR/await_holding_lock.rs:23:9\n    |\n-LL | /     let guard = x.read().unwrap();\n-LL | |     baz().await\n-LL | | }\n-   | |_^\n+LL | /         let guard = x.read().unwrap();\n+LL | |         baz().await\n+LL | |     }\n+   | |_____^\n \n error: this `MutexGuard` is held across an `await` point\n-  --> $DIR/await_holding_lock.rs:26:9\n+  --> $DIR/await_holding_lock.rs:28:13\n    |\n-LL |     let mut guard = x.write().unwrap();\n-   |         ^^^^^^^^^\n+LL |         let mut guard = x.write().unwrap();\n+   |             ^^^^^^^^^\n    |\n    = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n note: these are all the `await` points this lock is held through\n-  --> $DIR/await_holding_lock.rs:26:5\n+  --> $DIR/await_holding_lock.rs:28:9\n    |\n-LL | /     let mut guard = x.write().unwrap();\n-LL | |     baz().await\n-LL | | }\n-   | |_^\n+LL | /         let mut guard = x.write().unwrap();\n+LL | |         baz().await\n+LL | |     }\n+   | |_____^\n \n error: this `MutexGuard` is held across an `await` point\n-  --> $DIR/await_holding_lock.rs:51:9\n+  --> $DIR/await_holding_lock.rs:53:13\n    |\n-LL |     let guard = x.lock().unwrap();\n-   |         ^^^^^\n+LL |         let guard = x.lock().unwrap();\n+   |             ^^^^^\n    |\n    = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n note: these are all the `await` points this lock is held through\n-  --> $DIR/await_holding_lock.rs:51:5\n+  --> $DIR/await_holding_lock.rs:53:9\n    |\n-LL | /     let guard = x.lock().unwrap();\n+LL | /         let guard = x.lock().unwrap();\n LL | |\n-LL | |     let second = baz().await;\n+LL | |         let second = baz().await;\n LL | |\n ...  |\n-LL | |     first + second + third\n-LL | | }\n-   | |_^\n+LL | |         first + second + third\n+LL | |     }\n+   | |_____^\n \n error: this `MutexGuard` is held across an `await` point\n-  --> $DIR/await_holding_lock.rs:64:13\n+  --> $DIR/await_holding_lock.rs:66:17\n    |\n-LL |         let guard = x.lock().unwrap();\n+LL |             let guard = x.lock().unwrap();\n+   |                 ^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:66:13\n+   |\n+LL | /             let guard = x.lock().unwrap();\n+LL | |             baz().await\n+LL | |         };\n+   | |_________^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:78:17\n+   |\n+LL |             let guard = x.lock().unwrap();\n+   |                 ^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:78:13\n+   |\n+LL | /             let guard = x.lock().unwrap();\n+LL | |             baz().await\n+LL | |         }\n+   | |_________^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:89:13\n+   |\n+LL |         let guard = x.lock();\n    |             ^^^^^\n    |\n    = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n note: these are all the `await` points this lock is held through\n-  --> $DIR/await_holding_lock.rs:64:9\n+  --> $DIR/await_holding_lock.rs:89:9\n    |\n-LL | /         let guard = x.lock().unwrap();\n+LL | /         let guard = x.lock();\n LL | |         baz().await\n-LL | |     };\n+LL | |     }\n    | |_____^\n \n error: this `MutexGuard` is held across an `await` point\n-  --> $DIR/await_holding_lock.rs:76:13\n+  --> $DIR/await_holding_lock.rs:104:13\n    |\n-LL |         let guard = x.lock().unwrap();\n+LL |         let guard = x.read();\n    |             ^^^^^\n    |\n    = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n note: these are all the `await` points this lock is held through\n-  --> $DIR/await_holding_lock.rs:76:9\n+  --> $DIR/await_holding_lock.rs:104:9\n    |\n-LL | /         let guard = x.lock().unwrap();\n+LL | /         let guard = x.read();\n LL | |         baz().await\n LL | |     }\n    | |_____^\n \n-error: aborting due to 6 previous errors\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:109:13\n+   |\n+LL |         let mut guard = x.write();\n+   |             ^^^^^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:109:9\n+   |\n+LL | /         let mut guard = x.write();\n+LL | |         baz().await\n+LL | |     }\n+   | |_____^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:134:13\n+   |\n+LL |         let guard = x.lock();\n+   |             ^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:134:9\n+   |\n+LL | /         let guard = x.lock();\n+LL | |\n+LL | |         let second = baz().await;\n+LL | |\n+...  |\n+LL | |         first + second + third\n+LL | |     }\n+   | |_____^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:147:17\n+   |\n+LL |             let guard = x.lock();\n+   |                 ^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:147:13\n+   |\n+LL | /             let guard = x.lock();\n+LL | |             baz().await\n+LL | |         };\n+   | |_________^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:159:17\n+   |\n+LL |             let guard = x.lock();\n+   |                 ^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:159:13\n+   |\n+LL | /             let guard = x.lock();\n+LL | |             baz().await\n+LL | |         }\n+   | |_________^\n+\n+error: aborting due to 12 previous errors\n "}]}