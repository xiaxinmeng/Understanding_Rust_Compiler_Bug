{"sha": "07c51f605a021f1416a23e0cd76afa2156d5526c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3YzUxZjYwNWEwMjFmMTQxNmEyM2UwY2Q3NmFmYTIxNTZkNTUyNmM=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-11-11T19:48:17Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-01-14T22:37:16Z"}, "message": "Implement new dataflow framework and cursor", "tree": {"sha": "a8e2206c61914db58a7437601206b6c67b5c7347", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8e2206c61914db58a7437601206b6c67b5c7347"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07c51f605a021f1416a23e0cd76afa2156d5526c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07c51f605a021f1416a23e0cd76afa2156d5526c", "html_url": "https://github.com/rust-lang/rust/commit/07c51f605a021f1416a23e0cd76afa2156d5526c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07c51f605a021f1416a23e0cd76afa2156d5526c/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fb4c4472e4563a52e2dc544e47a01f564b9219e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fb4c4472e4563a52e2dc544e47a01f564b9219e", "html_url": "https://github.com/rust-lang/rust/commit/2fb4c4472e4563a52e2dc544e47a01f564b9219e"}], "stats": {"total": 995, "additions": 995, "deletions": 0}, "files": [{"sha": "f819b0fb5d69a974ef851023a8abb817f3dda070", "filename": "src/librustc_mir/dataflow/generic/cursor.rs", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/07c51f605a021f1416a23e0cd76afa2156d5526c/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c51f605a021f1416a23e0cd76afa2156d5526c/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fcursor.rs?ref=07c51f605a021f1416a23e0cd76afa2156d5526c", "patch": "@@ -0,0 +1,265 @@\n+//! Random access inspection of the results of a dataflow analysis.\n+\n+use std::borrow::Borrow;\n+\n+use rustc::mir::{self, BasicBlock, Location};\n+use rustc_index::bit_set::BitSet;\n+\n+use super::{Analysis, Results};\n+\n+/// A `ResultsCursor` that borrows the underlying `Results`.\n+pub type ResultsRefCursor<'a, 'mir, 'tcx, A> = ResultsCursor<'mir, 'tcx, A, &'a Results<'tcx, A>>;\n+\n+/// Allows random access inspection of the results of a dataflow analysis.\n+///\n+/// This cursor only has linear performance within a basic block when its statements are visited in\n+/// order. In the worst case\u2014when statements are visited in *reverse* order\u2014performance will be\n+/// quadratic in the number of statements in the block. The order in which basic blocks are\n+/// inspected has no impact on performance.\n+///\n+/// A `ResultsCursor` can either own (the default) or borrow the dataflow results it inspects. The\n+/// type of ownership is determined by `R` (see `ResultsRefCursor` above).\n+pub struct ResultsCursor<'mir, 'tcx, A, R = Results<'tcx, A>>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    body: &'mir mir::Body<'tcx>,\n+    results: R,\n+    state: BitSet<A::Idx>,\n+\n+    pos: CursorPosition,\n+\n+    /// When this flag is set, the cursor is pointing at a `Call` terminator whose call return\n+    /// effect has been applied to `state`.\n+    ///\n+    /// This flag helps to ensure that multiple calls to `seek_after_assume_call_returns` with the\n+    /// same target will result in exactly one invocation of `apply_call_return_effect`. It is\n+    /// sufficient to clear this only in `seek_to_block_start`, since seeking away from a\n+    /// terminator will always require a cursor reset.\n+    call_return_effect_applied: bool,\n+}\n+\n+impl<'mir, 'tcx, A, R> ResultsCursor<'mir, 'tcx, A, R>\n+where\n+    A: Analysis<'tcx>,\n+    R: Borrow<Results<'tcx, A>>,\n+{\n+    /// Returns a new cursor for `results` that points to the start of the `START_BLOCK`.\n+    pub fn new(body: &'mir mir::Body<'tcx>, results: R) -> Self {\n+        ResultsCursor {\n+            body,\n+            pos: CursorPosition::BlockStart(mir::START_BLOCK),\n+            state: results.borrow().entry_sets[mir::START_BLOCK].clone(),\n+            call_return_effect_applied: false,\n+            results,\n+        }\n+    }\n+\n+    /// Returns the `Analysis` used to generate the underlying results.\n+    pub fn analysis(&self) -> &A {\n+        &self.results.borrow().analysis\n+    }\n+\n+    /// Returns the dataflow state at the current location.\n+    pub fn get(&self) -> &BitSet<A::Idx> {\n+        &self.state\n+    }\n+\n+    /// Resets the cursor to the start of the given basic block.\n+    pub fn seek_to_block_start(&mut self, block: BasicBlock) {\n+        self.state.overwrite(&self.results.borrow().entry_sets[block]);\n+        self.pos = CursorPosition::BlockStart(block);\n+        self.call_return_effect_applied = false;\n+    }\n+\n+    /// Advances the cursor to hold all effects up to and including to the \"before\" effect of the\n+    /// statement (or terminator) at the given location.\n+    ///\n+    /// If you wish to observe the full effect of a statement or terminator, not just the \"before\"\n+    /// effect, use `seek_after` or `seek_after_assume_call_returns`.\n+    pub fn seek_before(&mut self, target: Location) {\n+        assert!(target <= self.body.terminator_loc(target.block));\n+        self._seek(target, false);\n+    }\n+\n+    /// Advances the cursor to hold the full effect of all statements (and possibly closing\n+    /// terminators) up to and including the `target`.\n+    ///\n+    /// If the `target` is a `Call` terminator, any call return effect for that terminator will\n+    /// **not** be observed. Use `seek_after_assume_call_returns` if you wish to observe the call\n+    /// return effect.\n+    pub fn seek_after(&mut self, target: Location) {\n+        assert!(target <= self.body.terminator_loc(target.block));\n+\n+        // If we have already applied the call return effect, we are currently pointing at a `Call`\n+        // terminator. Unconditionally reset the dataflow cursor, since there is no way to \"undo\"\n+        // the call return effect.\n+        if self.call_return_effect_applied {\n+            self.seek_to_block_start(target.block);\n+        }\n+\n+        self._seek(target, true);\n+    }\n+\n+    /// Advances the cursor to hold all effects up to and including of the statement (or\n+    /// terminator) at the given location.\n+    ///\n+    /// If the `target` is a `Call` terminator, any call return effect for that terminator will\n+    /// be observed. Use `seek_after` if you do **not** wish to observe the call return effect.\n+    pub fn seek_after_assume_call_returns(&mut self, target: Location) {\n+        let terminator_loc = self.body.terminator_loc(target.block);\n+        assert!(target.statement_index <= terminator_loc.statement_index);\n+\n+        self._seek(target, true);\n+\n+        if target != terminator_loc {\n+            return;\n+        }\n+\n+        let terminator = self.body.basic_blocks()[target.block].terminator();\n+        if let mir::TerminatorKind::Call {\n+            destination: Some((return_place, _)), func, args, ..\n+        } = &terminator.kind\n+        {\n+            if !self.call_return_effect_applied {\n+                self.call_return_effect_applied = true;\n+                self.results.borrow().analysis.apply_call_return_effect(\n+                    &mut self.state,\n+                    target.block,\n+                    func,\n+                    args,\n+                    return_place,\n+                );\n+            }\n+        }\n+    }\n+\n+    fn _seek(&mut self, target: Location, apply_after_effect_at_target: bool) {\n+        use CursorPosition::*;\n+\n+        match self.pos {\n+            // Return early if we are already at the target location.\n+            Before(curr) if curr == target && !apply_after_effect_at_target => return,\n+            After(curr) if curr == target && apply_after_effect_at_target => return,\n+\n+            // Otherwise, we must reset to the start of the target block if...\n+\n+            // we are in a different block entirely.\n+            BlockStart(block) | Before(Location { block, .. }) | After(Location { block, .. })\n+                if block != target.block =>\n+            {\n+                self.seek_to_block_start(target.block)\n+            }\n+\n+            // we are in the same block but have advanced past the target statement.\n+            Before(curr) | After(curr) if curr.statement_index > target.statement_index => {\n+                self.seek_to_block_start(target.block)\n+            }\n+\n+            // we have already applied the entire effect of a statement but only wish to observe\n+            // its \"before\" effect.\n+            After(curr)\n+                if curr.statement_index == target.statement_index\n+                    && !apply_after_effect_at_target =>\n+            {\n+                self.seek_to_block_start(target.block)\n+            }\n+\n+            // N.B., `call_return_effect_applied` is checked in `seek_after`, not here.\n+            _ => (),\n+        }\n+\n+        let analysis = &self.results.borrow().analysis;\n+        let block_data = &self.body.basic_blocks()[target.block];\n+\n+        // At this point, the cursor is in the same block as the target location at an earlier\n+        // statement.\n+        debug_assert_eq!(target.block, self.pos.block());\n+\n+        // Find the first statement whose transfer function has not yet been applied.\n+        let first_unapplied_statement = match self.pos {\n+            BlockStart(_) => 0,\n+            After(Location { statement_index, .. }) => statement_index + 1,\n+\n+            // If we have only applied the \"before\" effect for the current statement, apply the\n+            // remainder before continuing.\n+            Before(curr) => {\n+                if curr.statement_index == block_data.statements.len() {\n+                    let terminator = block_data.terminator();\n+                    analysis.apply_terminator_effect(&mut self.state, terminator, curr);\n+                } else {\n+                    let statement = &block_data.statements[curr.statement_index];\n+                    analysis.apply_statement_effect(&mut self.state, statement, curr);\n+                }\n+\n+                // If all we needed to do was go from `Before` to `After` in the same statement,\n+                // we are now done.\n+                if curr.statement_index == target.statement_index {\n+                    debug_assert!(apply_after_effect_at_target);\n+                    self.pos = After(target);\n+                    return;\n+                }\n+\n+                curr.statement_index + 1\n+            }\n+        };\n+\n+        // We have now applied all effects prior to `first_unapplied_statement`.\n+\n+        // Apply the effects of all statements before `target`.\n+        let mut location = Location { block: target.block, statement_index: 0 };\n+        for statement_index in first_unapplied_statement..target.statement_index {\n+            location.statement_index = statement_index;\n+            let statement = &block_data.statements[statement_index];\n+            analysis.apply_before_statement_effect(&mut self.state, statement, location);\n+            analysis.apply_statement_effect(&mut self.state, statement, location);\n+        }\n+\n+        // Apply the effect of the statement (or terminator) at `target`.\n+        location.statement_index = target.statement_index;\n+        if target.statement_index == block_data.statements.len() {\n+            let terminator = &block_data.terminator();\n+            analysis.apply_before_terminator_effect(&mut self.state, terminator, location);\n+\n+            if apply_after_effect_at_target {\n+                analysis.apply_terminator_effect(&mut self.state, terminator, location);\n+                self.pos = After(target);\n+            } else {\n+                self.pos = Before(target);\n+            }\n+        } else {\n+            let statement = &block_data.statements[target.statement_index];\n+            analysis.apply_before_statement_effect(&mut self.state, statement, location);\n+\n+            if apply_after_effect_at_target {\n+                analysis.apply_statement_effect(&mut self.state, statement, location);\n+                self.pos = After(target)\n+            } else {\n+                self.pos = Before(target);\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+enum CursorPosition {\n+    /// No effects within this block have been applied.\n+    BlockStart(BasicBlock),\n+\n+    /// Only the \"before\" effect of the statement (or terminator) at this location has been\n+    /// applied (along with the effects of all previous statements).\n+    Before(Location),\n+\n+    /// The effects of all statements up to and including the one at this location have been\n+    /// applied.\n+    After(Location),\n+}\n+\n+impl CursorPosition {\n+    fn block(&self) -> BasicBlock {\n+        match *self {\n+            Self::BlockStart(block) => block,\n+            Self::Before(loc) | Self::After(loc) => loc.block,\n+        }\n+    }\n+}"}, {"sha": "332217700666621cef281379549db7c0ed6fb68f", "filename": "src/librustc_mir/dataflow/generic/engine.rs", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/07c51f605a021f1416a23e0cd76afa2156d5526c/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c51f605a021f1416a23e0cd76afa2156d5526c/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs?ref=07c51f605a021f1416a23e0cd76afa2156d5526c", "patch": "@@ -0,0 +1,421 @@\n+//! A solver for dataflow problems.\n+\n+use std::ffi::OsString;\n+use std::fs;\n+use std::path::PathBuf;\n+\n+use rustc::mir::{self, traversal, BasicBlock, Location};\n+use rustc::ty::TyCtxt;\n+use rustc_data_structures::work_queue::WorkQueue;\n+use rustc_hir::def_id::DefId;\n+use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::IndexVec;\n+use rustc_span::symbol::{sym, Symbol};\n+use syntax::ast;\n+\n+use super::graphviz;\n+use super::{Analysis, GenKillAnalysis, GenKillSet, Results};\n+\n+/// A solver for dataflow problems.\n+pub struct Engine<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    bits_per_block: usize,\n+    tcx: TyCtxt<'tcx>,\n+    body: &'a mir::Body<'tcx>,\n+    def_id: DefId,\n+    dead_unwinds: Option<&'a BitSet<BasicBlock>>,\n+    entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n+    analysis: A,\n+\n+    /// Cached, cumulative transfer functions for each block.\n+    trans_for_block: Option<IndexVec<BasicBlock, GenKillSet<A::Idx>>>,\n+}\n+\n+impl<A> Engine<'a, 'tcx, A>\n+where\n+    A: GenKillAnalysis<'tcx>,\n+{\n+    /// Creates a new `Engine` to solve a gen-kill dataflow problem.\n+    pub fn new_gen_kill(\n+        tcx: TyCtxt<'tcx>,\n+        body: &'a mir::Body<'tcx>,\n+        def_id: DefId,\n+        analysis: A,\n+    ) -> Self {\n+        let bits_per_block = analysis.bits_per_block(body);\n+        let mut trans_for_block =\n+            IndexVec::from_elem(GenKillSet::identity(bits_per_block), body.basic_blocks());\n+\n+        // Compute cumulative block transfer functions.\n+        //\n+        // FIXME: we may want to skip this if the MIR is acyclic, since we will never access a\n+        // block transfer function more than once.\n+\n+        for (block, block_data) in body.basic_blocks().iter_enumerated() {\n+            let trans = &mut trans_for_block[block];\n+\n+            for (i, statement) in block_data.statements.iter().enumerate() {\n+                let loc = Location { block, statement_index: i };\n+                analysis.before_statement_effect(trans, statement, loc);\n+                analysis.statement_effect(trans, statement, loc);\n+            }\n+\n+            if let Some(terminator) = &block_data.terminator {\n+                let loc = Location { block, statement_index: block_data.statements.len() };\n+                analysis.before_terminator_effect(trans, terminator, loc);\n+                analysis.terminator_effect(trans, terminator, loc);\n+            }\n+        }\n+\n+        Self::new(tcx, body, def_id, analysis, Some(trans_for_block))\n+    }\n+}\n+\n+impl<A> Engine<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    /// Creates a new `Engine` to solve a dataflow problem with an arbitrary transfer\n+    /// function.\n+    ///\n+    /// Gen-kill problems should use `new_gen_kill`, which will coalesce transfer functions for\n+    /// better performance.\n+    pub fn new_generic(\n+        tcx: TyCtxt<'tcx>,\n+        body: &'a mir::Body<'tcx>,\n+        def_id: DefId,\n+        analysis: A,\n+    ) -> Self {\n+        Self::new(tcx, body, def_id, analysis, None)\n+    }\n+\n+    fn new(\n+        tcx: TyCtxt<'tcx>,\n+        body: &'a mir::Body<'tcx>,\n+        def_id: DefId,\n+        analysis: A,\n+        trans_for_block: Option<IndexVec<BasicBlock, GenKillSet<A::Idx>>>,\n+    ) -> Self {\n+        let bits_per_block = analysis.bits_per_block(body);\n+\n+        let bottom_value_set = if A::BOTTOM_VALUE == true {\n+            BitSet::new_filled(bits_per_block)\n+        } else {\n+            BitSet::new_empty(bits_per_block)\n+        };\n+\n+        let mut entry_sets = IndexVec::from_elem(bottom_value_set, body.basic_blocks());\n+        analysis.initialize_start_block(body, &mut entry_sets[mir::START_BLOCK]);\n+\n+        Engine {\n+            analysis,\n+            bits_per_block,\n+            tcx,\n+            body,\n+            def_id,\n+            dead_unwinds: None,\n+            entry_sets,\n+            trans_for_block,\n+        }\n+    }\n+\n+    pub fn dead_unwinds(mut self, dead_unwinds: &'a BitSet<BasicBlock>) -> Self {\n+        self.dead_unwinds = Some(dead_unwinds);\n+        self\n+    }\n+\n+    pub fn iterate_to_fixpoint(mut self) -> Results<'tcx, A> {\n+        let mut temp_state = BitSet::new_empty(self.bits_per_block);\n+\n+        let mut dirty_queue: WorkQueue<BasicBlock> =\n+            WorkQueue::with_none(self.body.basic_blocks().len());\n+\n+        for (bb, _) in traversal::reverse_postorder(self.body) {\n+            dirty_queue.insert(bb);\n+        }\n+\n+        // Add blocks that are not reachable from START_BLOCK to the work queue. These blocks will\n+        // be processed after the ones added above.\n+        for bb in self.body.basic_blocks().indices() {\n+            dirty_queue.insert(bb);\n+        }\n+\n+        while let Some(bb) = dirty_queue.pop() {\n+            let bb_data = &self.body[bb];\n+            let on_entry = &self.entry_sets[bb];\n+\n+            temp_state.overwrite(on_entry);\n+            self.apply_whole_block_effect(&mut temp_state, bb, bb_data);\n+\n+            self.propagate_bits_into_graph_successors_of(\n+                &mut temp_state,\n+                (bb, bb_data),\n+                &mut dirty_queue,\n+            );\n+        }\n+\n+        let Engine { tcx, body, def_id, trans_for_block, entry_sets, analysis, .. } = self;\n+        let results = Results { analysis, entry_sets };\n+\n+        let res = write_graphviz_results(tcx, def_id, body, &results, trans_for_block);\n+        if let Err(e) = res {\n+            warn!(\"Failed to write graphviz dataflow results: {}\", e);\n+        }\n+\n+        results\n+    }\n+\n+    /// Applies the cumulative effect of an entire block, excluding the call return effect if one\n+    /// exists.\n+    fn apply_whole_block_effect(\n+        &self,\n+        state: &mut BitSet<A::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+    ) {\n+        // Use the cached block transfer function if available.\n+        if let Some(trans_for_block) = &self.trans_for_block {\n+            trans_for_block[block].apply(state);\n+            return;\n+        }\n+\n+        // Otherwise apply effects one-by-one.\n+\n+        for (statement_index, statement) in block_data.statements.iter().enumerate() {\n+            let location = Location { block, statement_index };\n+            self.analysis.apply_before_statement_effect(state, statement, location);\n+            self.analysis.apply_statement_effect(state, statement, location);\n+        }\n+\n+        let terminator = block_data.terminator();\n+        let location = Location { block, statement_index: block_data.statements.len() };\n+        self.analysis.apply_before_terminator_effect(state, terminator, location);\n+        self.analysis.apply_terminator_effect(state, terminator, location);\n+    }\n+\n+    fn propagate_bits_into_graph_successors_of(\n+        &mut self,\n+        in_out: &mut BitSet<A::Idx>,\n+        (bb, bb_data): (BasicBlock, &'a mir::BasicBlockData<'tcx>),\n+        dirty_list: &mut WorkQueue<BasicBlock>,\n+    ) {\n+        use mir::TerminatorKind::*;\n+\n+        match bb_data.terminator().kind {\n+            Return | Resume | Abort | GeneratorDrop | Unreachable => {}\n+\n+            Goto { target }\n+            | Assert { target, cleanup: None, .. }\n+            | Yield { resume: target, drop: None, .. }\n+            | Drop { target, location: _, unwind: None }\n+            | DropAndReplace { target, value: _, location: _, unwind: None } => {\n+                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list)\n+            }\n+\n+            Yield { resume: target, drop: Some(drop), .. } => {\n+                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n+                self.propagate_bits_into_entry_set_for(in_out, drop, dirty_list);\n+            }\n+\n+            Assert { target, cleanup: Some(unwind), .. }\n+            | Drop { target, location: _, unwind: Some(unwind) }\n+            | DropAndReplace { target, value: _, location: _, unwind: Some(unwind) } => {\n+                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n+                if self.dead_unwinds.map_or(true, |bbs| !bbs.contains(bb)) {\n+                    self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n+                }\n+            }\n+\n+            SwitchInt { ref targets, .. } => {\n+                for target in targets {\n+                    self.propagate_bits_into_entry_set_for(in_out, *target, dirty_list);\n+                }\n+            }\n+\n+            Call { cleanup, ref destination, ref func, ref args, .. } => {\n+                if let Some(unwind) = cleanup {\n+                    if self.dead_unwinds.map_or(true, |bbs| !bbs.contains(bb)) {\n+                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n+                    }\n+                }\n+\n+                if let Some((ref dest_place, dest_bb)) = *destination {\n+                    // N.B.: This must be done *last*, otherwise the unwind path will see the call\n+                    // return effect.\n+                    self.analysis.apply_call_return_effect(in_out, bb, func, args, dest_place);\n+                    self.propagate_bits_into_entry_set_for(in_out, dest_bb, dirty_list);\n+                }\n+            }\n+\n+            FalseEdges { real_target, imaginary_target } => {\n+                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n+                self.propagate_bits_into_entry_set_for(in_out, imaginary_target, dirty_list);\n+            }\n+\n+            FalseUnwind { real_target, unwind } => {\n+                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n+                if let Some(unwind) = unwind {\n+                    if self.dead_unwinds.map_or(true, |bbs| !bbs.contains(bb)) {\n+                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn propagate_bits_into_entry_set_for(\n+        &mut self,\n+        in_out: &BitSet<A::Idx>,\n+        bb: BasicBlock,\n+        dirty_queue: &mut WorkQueue<BasicBlock>,\n+    ) {\n+        let entry_set = &mut self.entry_sets[bb];\n+        let set_changed = self.analysis.join(entry_set, &in_out);\n+        if set_changed {\n+            dirty_queue.insert(bb);\n+        }\n+    }\n+}\n+\n+// Graphviz\n+\n+/// Writes a DOT file containing the results of a dataflow analysis if the user requested it via\n+/// `rustc_mir` attributes.\n+fn write_graphviz_results<A>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    body: &mir::Body<'tcx>,\n+    results: &Results<'tcx, A>,\n+    block_transfer_functions: Option<IndexVec<BasicBlock, GenKillSet<A::Idx>>>,\n+) -> std::io::Result<()>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    let attrs = match RustcMirAttrs::parse(tcx, def_id) {\n+        Ok(attrs) => attrs,\n+\n+        // Invalid `rustc_mir` attrs will be reported using `span_err`.\n+        Err(()) => return Ok(()),\n+    };\n+\n+    let path = match attrs.output_path(A::NAME) {\n+        Some(path) => path,\n+        None => return Ok(()),\n+    };\n+\n+    let bits_per_block = results.analysis.bits_per_block(body);\n+\n+    let mut formatter: Box<dyn graphviz::StateFormatter<'tcx, _>> = match attrs.formatter {\n+        Some(sym::two_phase) => Box::new(graphviz::TwoPhaseDiff::new(bits_per_block)),\n+        Some(sym::gen_kill) => {\n+            if let Some(trans_for_block) = block_transfer_functions {\n+                Box::new(graphviz::BlockTransferFunc::new(body, trans_for_block))\n+            } else {\n+                Box::new(graphviz::SimpleDiff::new(bits_per_block))\n+            }\n+        }\n+\n+        // Default to the `SimpleDiff` output style.\n+        _ => Box::new(graphviz::SimpleDiff::new(bits_per_block)),\n+    };\n+\n+    debug!(\"printing dataflow results for {:?} to {}\", def_id, path.display());\n+    let mut buf = Vec::new();\n+\n+    let graphviz = graphviz::Formatter::new(body, def_id, results, &mut *formatter);\n+    dot::render(&graphviz, &mut buf)?;\n+    fs::write(&path, buf)?;\n+    Ok(())\n+}\n+\n+#[derive(Default)]\n+struct RustcMirAttrs {\n+    basename_and_suffix: Option<PathBuf>,\n+    formatter: Option<Symbol>,\n+}\n+\n+impl RustcMirAttrs {\n+    fn parse(tcx: TyCtxt<'tcx>, def_id: DefId) -> Result<Self, ()> {\n+        let attrs = tcx.get_attrs(def_id);\n+\n+        let mut result = Ok(());\n+        let mut ret = RustcMirAttrs::default();\n+\n+        let rustc_mir_attrs = attrs\n+            .into_iter()\n+            .filter(|attr| attr.check_name(sym::rustc_mir))\n+            .flat_map(|attr| attr.meta_item_list().into_iter().flat_map(|v| v.into_iter()));\n+\n+        for attr in rustc_mir_attrs {\n+            let attr_result = if attr.check_name(sym::borrowck_graphviz_postflow) {\n+                Self::set_field(&mut ret.basename_and_suffix, tcx, &attr, |s| {\n+                    let path = PathBuf::from(s.to_string());\n+                    match path.file_name() {\n+                        Some(_) => Ok(path),\n+                        None => {\n+                            tcx.sess.span_err(attr.span(), \"path must end in a filename\");\n+                            Err(())\n+                        }\n+                    }\n+                })\n+            } else if attr.check_name(sym::borrowck_graphviz_format) {\n+                Self::set_field(&mut ret.formatter, tcx, &attr, |s| match s {\n+                    sym::gen_kill | sym::two_phase => Ok(s),\n+                    _ => {\n+                        tcx.sess.span_err(attr.span(), \"unknown formatter\");\n+                        Err(())\n+                    }\n+                })\n+            } else {\n+                Ok(())\n+            };\n+\n+            result = result.and(attr_result);\n+        }\n+\n+        result.map(|()| ret)\n+    }\n+\n+    fn set_field<T>(\n+        field: &mut Option<T>,\n+        tcx: TyCtxt<'tcx>,\n+        attr: &ast::NestedMetaItem,\n+        mapper: impl FnOnce(Symbol) -> Result<T, ()>,\n+    ) -> Result<(), ()> {\n+        if field.is_some() {\n+            tcx.sess\n+                .span_err(attr.span(), &format!(\"duplicate values for `{}`\", attr.name_or_empty()));\n+\n+            return Err(());\n+        }\n+\n+        if let Some(s) = attr.value_str() {\n+            *field = Some(mapper(s)?);\n+            Ok(())\n+        } else {\n+            tcx.sess\n+                .span_err(attr.span(), &format!(\"`{}` requires an argument\", attr.name_or_empty()));\n+            Err(())\n+        }\n+    }\n+\n+    /// Returns the path where dataflow results should be written, or `None`\n+    /// `borrowck_graphviz_postflow` was not specified.\n+    ///\n+    /// This performs the following transformation to the argument of `borrowck_graphviz_postflow`:\n+    ///\n+    /// \"path/suffix.dot\" -> \"path/analysis_name_suffix.dot\"\n+    fn output_path(&self, analysis_name: &str) -> Option<PathBuf> {\n+        let mut ret = self.basename_and_suffix.as_ref().cloned()?;\n+        let suffix = ret.file_name().unwrap(); // Checked when parsing attrs\n+\n+        let mut file_name: OsString = analysis_name.into();\n+        file_name.push(\"_\");\n+        file_name.push(suffix);\n+        ret.set_file_name(file_name);\n+\n+        Some(ret)\n+    }\n+}"}, {"sha": "1b628f2c7eb8edbb8f397c609e4d0da17d9270ff", "filename": "src/librustc_mir/dataflow/generic/mod.rs", "status": "added", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/07c51f605a021f1416a23e0cd76afa2156d5526c/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c51f605a021f1416a23e0cd76afa2156d5526c/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs?ref=07c51f605a021f1416a23e0cd76afa2156d5526c", "patch": "@@ -0,0 +1,309 @@\n+//! A framework for expressing dataflow problems.\n+\n+use std::io;\n+\n+use rustc::mir::{self, BasicBlock, Location};\n+use rustc_index::bit_set::{BitSet, HybridBitSet};\n+use rustc_index::vec::{Idx, IndexVec};\n+\n+use crate::dataflow::BottomValue;\n+\n+mod cursor;\n+mod engine;\n+mod graphviz;\n+\n+pub use self::cursor::{ResultsCursor, ResultsRefCursor};\n+pub use self::engine::Engine;\n+\n+/// A dataflow analysis that has converged to fixpoint.\n+pub struct Results<'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    pub analysis: A,\n+    entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n+}\n+\n+impl<A> Results<'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    pub fn into_cursor(self, body: &'mir mir::Body<'tcx>) -> ResultsCursor<'mir, 'tcx, A> {\n+        ResultsCursor::new(body, self)\n+    }\n+\n+    pub fn on_block_entry(&self, block: BasicBlock) -> &BitSet<A::Idx> {\n+        &self.entry_sets[block]\n+    }\n+}\n+\n+/// Define the domain of a dataflow problem.\n+///\n+/// This trait specifies the lattice on which this analysis operates. For now, this must be a\n+/// powerset of values of type `Idx`. The elements of this lattice are represented with a `BitSet`\n+/// and referred to as the state vector.\n+///\n+/// This trait also defines the initial value for the dataflow state upon entry to the\n+/// `START_BLOCK`, as well as some names used to refer to this analysis when debugging.\n+pub trait AnalysisDomain<'tcx>: BottomValue {\n+    /// The type of the elements in the state vector.\n+    type Idx: Idx;\n+\n+    /// A descriptive name for this analysis. Used only for debugging.\n+    ///\n+    /// This name should be brief and contain no spaces, periods or other characters that are not\n+    /// suitable as part of a filename.\n+    const NAME: &'static str;\n+\n+    /// The size of the state vector.\n+    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize;\n+\n+    /// Mutates the entry set of the `START_BLOCK` to contain the initial state for dataflow\n+    /// analysis.\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>);\n+\n+    /// Prints an element in the state vector for debugging.\n+    fn pretty_print_idx(&self, w: &mut impl io::Write, idx: Self::Idx) -> io::Result<()> {\n+        write!(w, \"{:?}\", idx)\n+    }\n+}\n+\n+/// Define a dataflow problem with an arbitrarily complex transfer function.\n+pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n+    /// Updates the current dataflow state with the effect of evaluating a statement.\n+    fn apply_statement_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    );\n+\n+    /// Updates the current dataflow state with an effect that occurs immediately *before* the\n+    /// given statement.\n+    ///\n+    /// This method is useful if the consumer of the results of this analysis needs only to observe\n+    /// *part* of the effect of a statement (e.g. for two-phase borrows). As a general rule,\n+    /// analyses should not implement this without implementing `apply_statement_effect`.\n+    fn apply_before_statement_effect(\n+        &self,\n+        _state: &mut BitSet<Self::Idx>,\n+        _statement: &mir::Statement<'tcx>,\n+        _location: Location,\n+    ) {\n+    }\n+\n+    /// Updates the current dataflow state with the effect of evaluating a terminator.\n+    ///\n+    /// The effect of a successful return from a `Call` terminator should **not** be accounted for\n+    /// in this function. That should go in `apply_call_return_effect`. For example, in the\n+    /// `InitializedPlaces` analyses, the return place for a function call is not marked as\n+    /// initialized here.\n+    fn apply_terminator_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    );\n+\n+    /// Updates the current dataflow state with an effect that occurs immediately *before* the\n+    /// given terminator.\n+    ///\n+    /// This method is useful if the consumer of the results of this analysis needs only to observe\n+    /// *part* of the effect of a terminator (e.g. for two-phase borrows). As a general rule,\n+    /// analyses should not implement this without implementing `apply_terminator_effect`.\n+    fn apply_before_terminator_effect(\n+        &self,\n+        _state: &mut BitSet<Self::Idx>,\n+        _terminator: &mir::Terminator<'tcx>,\n+        _location: Location,\n+    ) {\n+    }\n+\n+    /// Updates the current dataflow state with the effect of a successful return from a `Call`\n+    /// terminator.\n+    ///\n+    /// This is separate from `apply_terminator_effect` to properly track state across unwind\n+    /// edges.\n+    fn apply_call_return_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        block: BasicBlock,\n+        func: &mir::Operand<'tcx>,\n+        args: &[mir::Operand<'tcx>],\n+        return_place: &mir::Place<'tcx>,\n+    );\n+}\n+\n+/// Define a gen/kill dataflow problem.\n+///\n+/// Each method in this trait has a corresponding one in `Analysis`. However, these methods only\n+/// allow modification of the dataflow state via \"gen\" and \"kill\" operations. By defining transfer\n+/// functions for each statement in this way, the transfer function for an entire basic block can\n+/// be computed efficiently.\n+///\n+/// `Analysis` is automatically implemented for all implementers of `GenKillAnalysis`.\n+pub trait GenKillAnalysis<'tcx>: Analysis<'tcx> {\n+    /// See `Analysis::apply_statement_effect`.\n+    fn statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    );\n+\n+    /// See `Analysis::apply_before_statement_effect`.\n+    fn before_statement_effect(\n+        &self,\n+        _trans: &mut impl GenKill<Self::Idx>,\n+        _statement: &mir::Statement<'tcx>,\n+        _location: Location,\n+    ) {\n+    }\n+\n+    /// See `Analysis::apply_terminator_effect`.\n+    fn terminator_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    );\n+\n+    /// See `Analysis::apply_before_terminator_effect`.\n+    fn before_terminator_effect(\n+        &self,\n+        _trans: &mut impl GenKill<Self::Idx>,\n+        _terminator: &mir::Terminator<'tcx>,\n+        _location: Location,\n+    ) {\n+    }\n+\n+    /// See `Analysis::apply_call_return_effect`.\n+    fn call_return_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        block: BasicBlock,\n+        func: &mir::Operand<'tcx>,\n+        args: &[mir::Operand<'tcx>],\n+        return_place: &mir::Place<'tcx>,\n+    );\n+}\n+\n+impl<A> Analysis<'tcx> for A\n+where\n+    A: GenKillAnalysis<'tcx>,\n+{\n+    fn apply_statement_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        self.statement_effect(state, statement, location);\n+    }\n+\n+    fn apply_before_statement_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        self.before_statement_effect(state, statement, location);\n+    }\n+\n+    fn apply_terminator_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n+        self.terminator_effect(state, terminator, location);\n+    }\n+\n+    fn apply_before_terminator_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n+        self.before_terminator_effect(state, terminator, location);\n+    }\n+\n+    fn apply_call_return_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        block: BasicBlock,\n+        func: &mir::Operand<'tcx>,\n+        args: &[mir::Operand<'tcx>],\n+        return_place: &mir::Place<'tcx>,\n+    ) {\n+        self.call_return_effect(state, block, func, args, return_place);\n+    }\n+}\n+\n+/// The legal operations for a transfer function in a gen/kill problem.\n+pub trait GenKill<T>: Sized {\n+    /// Inserts `elem` into the `gen` set, removing it the `kill` set if present.\n+    fn gen(&mut self, elem: T);\n+\n+    /// Inserts `elem` into the `kill` set, removing it the `gen` set if present.\n+    fn kill(&mut self, elem: T);\n+\n+    /// Inserts the given elements into the `gen` set, removing them from the `kill` set if present.\n+    fn gen_all(&mut self, elems: impl IntoIterator<Item = T>) {\n+        for elem in elems {\n+            self.gen(elem);\n+        }\n+    }\n+\n+    /// Inserts the given elements into the `kill` set, removing them from the `gen` set if present.\n+    fn kill_all(&mut self, elems: impl IntoIterator<Item = T>) {\n+        for elem in elems {\n+            self.kill(elem);\n+        }\n+    }\n+}\n+\n+/// Stores a transfer function for a gen/kill problem.\n+#[derive(Clone)]\n+pub struct GenKillSet<T: Idx> {\n+    gen: HybridBitSet<T>,\n+    kill: HybridBitSet<T>,\n+}\n+\n+impl<T: Idx> GenKillSet<T> {\n+    /// Creates a new transfer function that will leave the dataflow state unchanged.\n+    pub fn identity(universe: usize) -> Self {\n+        GenKillSet {\n+            gen: HybridBitSet::new_empty(universe),\n+            kill: HybridBitSet::new_empty(universe),\n+        }\n+    }\n+\n+    /// Applies this transfer function to the given bitset.\n+    pub fn apply(&self, state: &mut BitSet<T>) {\n+        state.union(&self.gen);\n+        state.subtract(&self.kill);\n+    }\n+}\n+\n+impl<T: Idx> GenKill<T> for GenKillSet<T> {\n+    fn gen(&mut self, elem: T) {\n+        self.gen.insert(elem);\n+        self.kill.remove(elem);\n+    }\n+\n+    fn kill(&mut self, elem: T) {\n+        self.kill.insert(elem);\n+        self.gen.remove(elem);\n+    }\n+}\n+\n+impl<T: Idx> GenKill<T> for BitSet<T> {\n+    fn gen(&mut self, elem: T) {\n+        self.insert(elem);\n+    }\n+\n+    fn kill(&mut self, elem: T) {\n+        self.remove(elem);\n+    }\n+}"}]}