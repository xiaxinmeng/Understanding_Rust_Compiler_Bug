{"sha": "d338879ba5fef07890930abce6c8dd3549fe6fd4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzMzg4NzliYTVmZWYwNzg5MDkzMGFiY2U2YzhkZDM1NDlmZTZmZDQ=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-12T23:52:32Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-14T00:13:53Z"}, "message": "Reintroduce linked failure (killing runtime)\n\nThis reverts commit 5724c6454950617c292daba89cdb9a3b4c862430.", "tree": {"sha": "a09a21d14eeaca77a0ef9f8701f9860679f5b554", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a09a21d14eeaca77a0ef9f8701f9860679f5b554"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d338879ba5fef07890930abce6c8dd3549fe6fd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d338879ba5fef07890930abce6c8dd3549fe6fd4", "html_url": "https://github.com/rust-lang/rust/commit/d338879ba5fef07890930abce6c8dd3549fe6fd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d338879ba5fef07890930abce6c8dd3549fe6fd4/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62575d9c4a26eb2fa0bd1a1dbf1580633a886dce", "url": "https://api.github.com/repos/rust-lang/rust/commits/62575d9c4a26eb2fa0bd1a1dbf1580633a886dce", "html_url": "https://github.com/rust-lang/rust/commit/62575d9c4a26eb2fa0bd1a1dbf1580633a886dce"}], "stats": {"total": 82, "additions": 59, "deletions": 23}, "files": [{"sha": "66ea094818de460da04aa0c498669b1f9929aff7", "filename": "src/libcore/task.rs", "status": "modified", "additions": 36, "deletions": 20, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d338879ba5fef07890930abce6c8dd3549fe6fd4/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d338879ba5fef07890930abce6c8dd3549fe6fd4/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=d338879ba5fef07890930abce6c8dd3549fe6fd4", "patch": "@@ -591,16 +591,21 @@ class taskgroup {\n     let my_pos:     uint;\n     // let parent_group: taskgroup_arc; // TODO(bblum)\n     // TODO XXX bblum: add a list of empty slots to get runtime back\n-    let mut failed: bool;\n-    new(-tasks: taskgroup_arc, me: *rust_task, my_pos: uint) {\n-        self.tasks = tasks; self.me = me; self.my_pos = my_pos;\n-        self.failed = true; // This will get un-set on successful exit.\n+    // Indicates whether this is the main (root) taskgroup. If so, failure\n+    // here should take down the entire runtime.\n+    let is_main:    bool;\n+    new(-tasks: taskgroup_arc, me: *rust_task, my_pos: uint, is_main: bool) {\n+        self.tasks   = tasks;\n+        self.me      = me;\n+        self.my_pos  = my_pos;\n+        self.is_main = is_main;\n     }\n     // Runs on task exit.\n     drop {\n-        if self.failed {\n+        // If we are failing, the whole taskgroup needs to die.\n+        if rustrt::rust_task_is_unwinding(self.me) {\n             // Take everybody down with us.\n-            kill_taskgroup(self.tasks, self.me, self.my_pos);\n+            kill_taskgroup(self.tasks, self.me, self.my_pos, self.is_main);\n         } else {\n             // Remove ourselves from the group.\n             leave_taskgroup(self.tasks, self.me, self.my_pos);\n@@ -642,7 +647,8 @@ fn leave_taskgroup(group_arc: taskgroup_arc, me: *rust_task, index: uint) {\n }\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n-fn kill_taskgroup(group_arc: taskgroup_arc, me: *rust_task, index: uint) {\n+fn kill_taskgroup(group_arc: taskgroup_arc, me: *rust_task, index: uint,\n+                  is_main: bool) {\n     // NB: We could do the killing iteration outside of the group arc, by\n     // having \"let mut newstate\" here, swapping inside, and iterating after.\n     // But that would let other exiting tasks fall-through and exit while we\n@@ -667,32 +673,40 @@ fn kill_taskgroup(group_arc: taskgroup_arc, me: *rust_task, index: uint) {\n                     rustrt::rust_task_kill_other(task);\n                 };\n             }\n+            // Only one task should ever do this.\n+            if is_main {\n+                rustrt::rust_task_kill_all(me);\n+            }\n         };\n+        // (note: multiple tasks may reach this point)\n     };\n }\n \n-fn share_parent_taskgroup() -> taskgroup_arc {\n+fn share_parent_taskgroup() -> (taskgroup_arc, bool) {\n     let me = rustrt::rust_get_task();\n     alt unsafe { local_get(me, taskgroup_key) } {\n         some(group) {\n-            group.tasks.clone()\n+            // Clone the shared state for the child; propagate main-ness.\n+            (group.tasks.clone(), group.is_main)\n         }\n         none {\n-            /* Main task, doing first spawn ever. */\n+            // Main task, doing first spawn ever.\n             let tasks = arc::exclusive(some(dvec::from_elem(some(me))));\n-            let group = @taskgroup(tasks.clone(), me, 0);\n+            let group = @taskgroup(tasks.clone(), me, 0, true);\n             unsafe { local_set(me, taskgroup_key, group); }\n-            tasks\n+            // Tell child task it's also in the main group.\n+            (tasks, true)\n         }\n     }\n }\n \n fn spawn_raw(opts: task_opts, +f: fn~()) {\n     // Decide whether the child needs to be in a new linked failure group.\n-    let child_tg: taskgroup_arc = if opts.supervise {\n+    let (child_tg, is_main) = if opts.supervise {\n         share_parent_taskgroup()\n     } else {\n-        arc::exclusive(some(dvec::from_elem(none)))\n+        // Detached from the parent group; create a new (non-main) one.\n+        (arc::exclusive(some(dvec::from_elem(none))), false)\n     };\n \n     unsafe {\n@@ -712,7 +726,8 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n             // Getting killed after here would leak the task.\n \n             let child_wrapper =\n-                make_child_wrapper(new_task, child_tg, opts.supervise, f);\n+                make_child_wrapper(new_task, child_tg,\n+                                   opts.supervise, is_main, f);\n             let fptr = ptr::addr_of(child_wrapper);\n             let closure: *rust_closure = unsafe::reinterpret_cast(fptr);\n \n@@ -730,7 +745,8 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n     }\n \n     fn make_child_wrapper(child_task: *rust_task, -child_tg: taskgroup_arc,\n-                          supervise: bool, -f: fn~()) -> fn~() {\n+                          supervise: bool, is_main: bool,\n+                          -f: fn~()) -> fn~() {\n         let child_tg_ptr = ~mut some(child_tg);\n         fn~() {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n@@ -746,13 +762,12 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n             // parent was already failing, so don't bother doing anything.\n             alt enlist_in_taskgroup(child_tg, child_task) {\n                 some(my_index) {\n-                    let group = @taskgroup(child_tg, child_task, my_index);\n+                    let group =\n+                        @taskgroup(child_tg, child_task, my_index, is_main);\n                     unsafe { local_set(child_task, taskgroup_key, group); }\n                     // Run the child's body.\n                     f();\n-                    // Report successful exit. (TLS cleanup code will tear\n-                    // down the group.)\n-                    group.failed = false;\n+                    // TLS cleanup code will exit the taskgroup.\n                 }\n                 none { }\n             }\n@@ -1006,6 +1021,7 @@ extern mod rustrt {\n     fn rust_task_inhibit_kill();\n     fn rust_task_allow_kill();\n     fn rust_task_kill_other(task: *rust_task);\n+    fn rust_task_kill_all(task: *rust_task);\n \n     #[rust_stack]\n     fn rust_get_task_local_data(task: *rust_task) -> *libc::c_void;"}, {"sha": "66337d6c8eac95adf2d8cf18d93e83f511a3f62a", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d338879ba5fef07890930abce6c8dd3549fe6fd4/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d338879ba5fef07890930abce6c8dd3549fe6fd4/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=d338879ba5fef07890930abce6c8dd3549fe6fd4", "patch": "@@ -863,6 +863,11 @@ rust_task_kill_other(rust_task *task) { /* Used for linked failure */\n     task->kill();\n }\n \n+extern \"C\" void\n+rust_task_kill_all(rust_task *task) {\n+    task->fail_sched_loop();\n+}\n+\n extern \"C\" rust_cond_lock*\n rust_create_cond_lock() {\n     return new rust_cond_lock();"}, {"sha": "1a63596f15c0df5d140852dcc99d52c70634130d", "filename": "src/rt/rust_sched_loop.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d338879ba5fef07890930abce6c8dd3549fe6fd4/src%2Frt%2Frust_sched_loop.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d338879ba5fef07890930abce6c8dd3549fe6fd4/src%2Frt%2Frust_sched_loop.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.cpp?ref=d338879ba5fef07890930abce6c8dd3549fe6fd4", "patch": "@@ -260,8 +260,8 @@ rust_task *\n rust_sched_loop::create_task(rust_task *spawner, const char *name) {\n     rust_task *task =\n         new (this->kernel, \"rust_task\")\n-        rust_task (this, task_state_newborn,\n-                   spawner, name, kernel->env->min_stack_size);\n+        rust_task(this, task_state_newborn,\n+                  spawner, name, kernel->env->min_stack_size);\n     DLOG(this, task, \"created task: \" PTR \", spawner: %s, name: %s\",\n                         task, spawner ? spawner->name : \"null\", name);\n "}, {"sha": "a6c9b791fda984bf0dd4080c90869b84ee686407", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d338879ba5fef07890930abce6c8dd3549fe6fd4/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d338879ba5fef07890930abce6c8dd3549fe6fd4/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=d338879ba5fef07890930abce6c8dd3549fe6fd4", "patch": "@@ -129,6 +129,11 @@ cleanup_task(cleanup_args *args) {\n         // assert(task->task_local_data != NULL);\n         task->task_local_data_cleanup(task->task_local_data);\n         task->task_local_data = NULL;\n+    } else if (threw_exception) {\n+        // Edge case: If main never spawns any tasks, but fails anyway, TLS\n+        // won't be around to take down the kernel (task.rs:kill_taskgroup,\n+        // rust_task_kill_all). Do it here instead.\n+        task->fail_sched_loop();\n     }\n \n     // FIXME (#2676): For performance we should do the annihilator\n@@ -282,6 +287,7 @@ rust_task::kill() {\n     LOG(this, task, \"preparing to unwind task: 0x%\" PRIxPTR, this);\n }\n \n+// TODO(bblum): Move this to rust_builtin.cpp (cleanup)\n extern \"C\" CDECL\n bool rust_task_is_unwinding(rust_task *rt) {\n     return rt->unwinding;\n@@ -315,10 +321,14 @@ rust_task::begin_failure(char const *expr, char const *file, size_t line) {\n #else\n     die();\n     // FIXME (#908): Need unwinding on windows. This will end up aborting\n-    sched_loop->fail();\n+    fail_sched_loop();\n #endif\n }\n \n+void rust_task::fail_sched_loop() {\n+    sched_loop->fail();\n+}\n+\n void\n rust_task::unsupervise()\n {"}, {"sha": "d562d151894bb4eec8d604e8bf02ee41c2ed557a", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d338879ba5fef07890930abce6c8dd3549fe6fd4/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/d338879ba5fef07890930abce6c8dd3549fe6fd4/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=d338879ba5fef07890930abce6c8dd3549fe6fd4", "patch": "@@ -275,6 +275,10 @@ rust_task : public kernel_owned<rust_task>\n     void fail();\n     void fail(char const *expr, char const *file, size_t line);\n \n+    // Propagate failure to the entire rust runtime.\n+    // TODO(bblum): maybe this can be done at rust-level?\n+    void fail_sched_loop();\n+\n     // Disconnect from our supervisor.\n     void unsupervise();\n "}, {"sha": "a8256bba300d427ddcecb8938a3f7af7a7be68f4", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d338879ba5fef07890930abce6c8dd3549fe6fd4/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/d338879ba5fef07890930abce6c8dd3549fe6fd4/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=d338879ba5fef07890930abce6c8dd3549fe6fd4", "patch": "@@ -178,6 +178,7 @@ rust_port_task\n rust_task_inhibit_kill\n rust_task_allow_kill\n rust_task_kill_other\n+rust_task_kill_all\n rust_create_cond_lock\n rust_destroy_cond_lock\n rust_lock_cond_lock"}]}