{"sha": "52f21791fbec58e14a54b8c6f9146807a8ae8d84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyZjIxNzkxZmJlYzU4ZTE0YTU0YjhjNmY5MTQ2ODA3YThhZThkODQ=", "commit": {"author": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2020-12-07T01:30:55Z"}, "committer": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2021-01-11T20:13:22Z"}, "message": "Serialize incr comp structures to file via fixed-size buffer\n\nReduce a large memory spike that happens during serialization by writing\nthe incr comp structures to file by way of a fixed-size buffer, rather\nthan an unbounded vector.\n\nEffort was made to keep the instruction count close to that of the\nprevious implementation. However, buffered writing to a file inherently\nhas more overhead than writing to a vector, because each write may\nresult in a handleable error. To reduce this overhead, arrangements are\nmade so that each LEB128-encoded integer can be written to the buffer\nwith only one capacity and error check. Higher-level optimizations in\nwhich entire composite structures can be written with one capacity and\nerror check are possible, but would require much more work.\n\nThe performance is mostly on par with the previous implementation, with\nsmall to moderate instruction count regressions. The memory reduction is\nsignificant, however, so it seems like a worth-while trade-off.", "tree": {"sha": "909011c456b942de9598dc80d10965d13924ef13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/909011c456b942de9598dc80d10965d13924ef13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52f21791fbec58e14a54b8c6f9146807a8ae8d84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52f21791fbec58e14a54b8c6f9146807a8ae8d84", "html_url": "https://github.com/rust-lang/rust/commit/52f21791fbec58e14a54b8c6f9146807a8ae8d84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52f21791fbec58e14a54b8c6f9146807a8ae8d84/comments", "author": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6526e5c772f2da07db745c94ca6bb0a591a39ba4", "url": "https://api.github.com/repos/rust-lang/rust/commits/6526e5c772f2da07db745c94ca6bb0a591a39ba4", "html_url": "https://github.com/rust-lang/rust/commit/6526e5c772f2da07db745c94ca6bb0a591a39ba4"}], "stats": {"total": 785, "additions": 610, "deletions": 175}, "files": [{"sha": "08c3419a8421df0ef6783d9ee3d555543d0b059d", "filename": "compiler/rustc_data_structures/src/fingerprint.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/52f21791fbec58e14a54b8c6f9146807a8ae8d84/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f21791fbec58e14a54b8c6f9146807a8ae8d84/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs?ref=52f21791fbec58e14a54b8c6f9146807a8ae8d84", "patch": "@@ -1,6 +1,6 @@\n use crate::stable_hasher;\n use rustc_serialize::{\n-    opaque::{self, EncodeResult},\n+    opaque::{self, EncodeResult, FileEncodeResult},\n     Decodable, Encodable,\n };\n use std::hash::{Hash, Hasher};\n@@ -53,13 +53,6 @@ impl Fingerprint {\n         format!(\"{:x}{:x}\", self.0, self.1)\n     }\n \n-    pub fn encode_opaque(&self, encoder: &mut opaque::Encoder) -> EncodeResult {\n-        let bytes: [u8; 16] = unsafe { mem::transmute([self.0.to_le(), self.1.to_le()]) };\n-\n-        encoder.emit_raw_bytes(&bytes);\n-        Ok(())\n-    }\n-\n     pub fn decode_opaque(decoder: &mut opaque::Decoder<'_>) -> Result<Fingerprint, String> {\n         let mut bytes: [MaybeUninit<u8>; 16] = MaybeUninit::uninit_array();\n \n@@ -142,7 +135,16 @@ impl<E: rustc_serialize::Encoder> FingerprintEncoder for E {\n \n impl FingerprintEncoder for opaque::Encoder {\n     fn encode_fingerprint(&mut self, f: &Fingerprint) -> EncodeResult {\n-        f.encode_opaque(self)\n+        let bytes: [u8; 16] = unsafe { mem::transmute([f.0.to_le(), f.1.to_le()]) };\n+        self.emit_raw_bytes(&bytes);\n+        Ok(())\n+    }\n+}\n+\n+impl FingerprintEncoder for opaque::FileEncoder {\n+    fn encode_fingerprint(&mut self, f: &Fingerprint) -> FileEncodeResult {\n+        let bytes: [u8; 16] = unsafe { mem::transmute([f.0.to_le(), f.1.to_le()]) };\n+        self.emit_raw_bytes(&bytes)\n     }\n }\n \n@@ -198,7 +200,7 @@ impl<E: rustc_serialize::Encoder> Encodable<E> for PackedFingerprint {\n impl<D: rustc_serialize::Decoder> Decodable<D> for PackedFingerprint {\n     #[inline]\n     fn decode(d: &mut D) -> Result<Self, D::Error> {\n-        Fingerprint::decode(d).map(|f| PackedFingerprint(f))\n+        Fingerprint::decode(d).map(PackedFingerprint)\n     }\n }\n "}, {"sha": "087f83c24754a1e18258cf746ab5f9eca293789b", "filename": "compiler/rustc_incremental/src/persist/file_format.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/52f21791fbec58e14a54b8c6f9146807a8ae8d84/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f21791fbec58e14a54b8c6f9146807a8ae8d84/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs?ref=52f21791fbec58e14a54b8c6f9146807a8ae8d84", "patch": "@@ -14,7 +14,7 @@ use std::fs;\n use std::io::{self, Read};\n use std::path::Path;\n \n-use rustc_serialize::opaque::Encoder;\n+use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n \n /// The first few bytes of files generated by incremental compilation.\n const FILE_MAGIC: &[u8] = b\"RSIC\";\n@@ -27,15 +27,17 @@ const HEADER_FORMAT_VERSION: u16 = 0;\n /// the Git commit hash.\n const RUSTC_VERSION: Option<&str> = option_env!(\"CFG_VERSION\");\n \n-pub fn write_file_header(stream: &mut Encoder, nightly_build: bool) {\n-    stream.emit_raw_bytes(FILE_MAGIC);\n-    stream\n-        .emit_raw_bytes(&[(HEADER_FORMAT_VERSION >> 0) as u8, (HEADER_FORMAT_VERSION >> 8) as u8]);\n+pub fn write_file_header(stream: &mut FileEncoder, nightly_build: bool) -> FileEncodeResult {\n+    stream.emit_raw_bytes(FILE_MAGIC)?;\n+    stream.emit_raw_bytes(&[\n+        (HEADER_FORMAT_VERSION >> 0) as u8,\n+        (HEADER_FORMAT_VERSION >> 8) as u8,\n+    ])?;\n \n     let rustc_version = rustc_version(nightly_build);\n     assert_eq!(rustc_version.len(), (rustc_version.len() as u8) as usize);\n-    stream.emit_raw_bytes(&[rustc_version.len() as u8]);\n-    stream.emit_raw_bytes(rustc_version.as_bytes());\n+    stream.emit_raw_bytes(&[rustc_version.len() as u8])?;\n+    stream.emit_raw_bytes(rustc_version.as_bytes())\n }\n \n /// Reads the contents of a file with a file header as defined in this module."}, {"sha": "f63cdfc56945e6256c2a86daf51dbac70bff2981", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/52f21791fbec58e14a54b8c6f9146807a8ae8d84/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f21791fbec58e14a54b8c6f9146807a8ae8d84/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=52f21791fbec58e14a54b8c6f9146807a8ae8d84", "patch": "@@ -2,7 +2,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::join;\n use rustc_middle::dep_graph::{DepGraph, DepKind, WorkProduct, WorkProductId};\n use rustc_middle::ty::TyCtxt;\n-use rustc_serialize::opaque::Encoder;\n+use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_serialize::Encodable as RustcEncodable;\n use rustc_session::Session;\n use std::fs;\n@@ -33,12 +33,12 @@ pub fn save_dep_graph(tcx: TyCtxt<'_>) {\n         join(\n             move || {\n                 sess.time(\"incr_comp_persist_result_cache\", || {\n-                    save_in(sess, query_cache_path, |e| encode_query_cache(tcx, e));\n+                    save_in(sess, query_cache_path, \"query cache\", |e| encode_query_cache(tcx, e));\n                 });\n             },\n             || {\n                 sess.time(\"incr_comp_persist_dep_graph\", || {\n-                    save_in(sess, dep_graph_path, |e| {\n+                    save_in(sess, dep_graph_path, \"dependency graph\", |e| {\n                         sess.time(\"incr_comp_encode_dep_graph\", || encode_dep_graph(tcx, e))\n                     });\n                 });\n@@ -65,7 +65,7 @@ pub fn save_work_product_index(\n     debug!(\"save_work_product_index()\");\n     dep_graph.assert_ignored();\n     let path = work_products_path(sess);\n-    save_in(sess, path, |e| encode_work_product_index(&new_work_products, e));\n+    save_in(sess, path, \"work product index\", |e| encode_work_product_index(&new_work_products, e));\n \n     // We also need to clean out old work-products, as not all of them are\n     // deleted during invalidation. Some object files don't change their\n@@ -92,13 +92,13 @@ pub fn save_work_product_index(\n     });\n }\n \n-fn save_in<F>(sess: &Session, path_buf: PathBuf, encode: F)\n+fn save_in<F>(sess: &Session, path_buf: PathBuf, name: &str, encode: F)\n where\n-    F: FnOnce(&mut Encoder),\n+    F: FnOnce(&mut FileEncoder) -> FileEncodeResult,\n {\n     debug!(\"save: storing data in {}\", path_buf.display());\n \n-    // delete the old dep-graph, if any\n+    // Delete the old file, if any.\n     // Note: It's important that we actually delete the old file and not just\n     // truncate and overwrite it, since it might be a shared hard-link, the\n     // underlying data of which we don't want to modify\n@@ -109,34 +109,44 @@ where\n         Err(err) if err.kind() == io::ErrorKind::NotFound => (),\n         Err(err) => {\n             sess.err(&format!(\n-                \"unable to delete old dep-graph at `{}`: {}\",\n+                \"unable to delete old {} at `{}`: {}\",\n+                name,\n                 path_buf.display(),\n                 err\n             ));\n             return;\n         }\n     }\n \n-    // generate the data in a memory buffer\n-    let mut encoder = Encoder::new(Vec::new());\n-    file_format::write_file_header(&mut encoder, sess.is_nightly_build());\n-    encode(&mut encoder);\n-\n-    // write the data out\n-    let data = encoder.into_inner();\n-    match fs::write(&path_buf, data) {\n-        Ok(_) => {\n-            debug!(\"save: data written to disk successfully\");\n-        }\n+    let mut encoder = match FileEncoder::new(&path_buf) {\n+        Ok(encoder) => encoder,\n         Err(err) => {\n-            sess.err(&format!(\"failed to write dep-graph to `{}`: {}\", path_buf.display(), err));\n+            sess.err(&format!(\"failed to create {} at `{}`: {}\", name, path_buf.display(), err));\n+            return;\n         }\n+    };\n+\n+    if let Err(err) = file_format::write_file_header(&mut encoder, sess.is_nightly_build()) {\n+        sess.err(&format!(\"failed to write {} header to `{}`: {}\", name, path_buf.display(), err));\n+        return;\n+    }\n+\n+    if let Err(err) = encode(&mut encoder) {\n+        sess.err(&format!(\"failed to write {} to `{}`: {}\", name, path_buf.display(), err));\n+        return;\n     }\n+\n+    if let Err(err) = encoder.flush() {\n+        sess.err(&format!(\"failed to flush {} to `{}`: {}\", name, path_buf.display(), err));\n+        return;\n+    }\n+\n+    debug!(\"save: data written to disk successfully\");\n }\n \n-fn encode_dep_graph(tcx: TyCtxt<'_>, encoder: &mut Encoder) {\n+fn encode_dep_graph(tcx: TyCtxt<'_>, encoder: &mut FileEncoder) -> FileEncodeResult {\n     // First encode the commandline arguments hash\n-    tcx.sess.opts.dep_tracking_hash().encode(encoder).unwrap();\n+    tcx.sess.opts.dep_tracking_hash().encode(encoder)?;\n \n     // Encode the graph data.\n     let serialized_graph =\n@@ -214,15 +224,13 @@ fn encode_dep_graph(tcx: TyCtxt<'_>, encoder: &mut Encoder) {\n         println!(\"[incremental]\");\n     }\n \n-    tcx.sess.time(\"incr_comp_encode_serialized_dep_graph\", || {\n-        serialized_graph.encode(encoder).unwrap();\n-    });\n+    tcx.sess.time(\"incr_comp_encode_serialized_dep_graph\", || serialized_graph.encode(encoder))\n }\n \n fn encode_work_product_index(\n     work_products: &FxHashMap<WorkProductId, WorkProduct>,\n-    encoder: &mut Encoder,\n-) {\n+    encoder: &mut FileEncoder,\n+) -> FileEncodeResult {\n     let serialized_products: Vec<_> = work_products\n         .iter()\n         .map(|(id, work_product)| SerializedWorkProduct {\n@@ -231,11 +239,9 @@ fn encode_work_product_index(\n         })\n         .collect();\n \n-    serialized_products.encode(encoder).unwrap();\n+    serialized_products.encode(encoder)\n }\n \n-fn encode_query_cache(tcx: TyCtxt<'_>, encoder: &mut Encoder) {\n-    tcx.sess.time(\"incr_comp_serialize_result_cache\", || {\n-        tcx.serialize_query_result_cache(encoder).unwrap();\n-    })\n+fn encode_query_cache(tcx: TyCtxt<'_>, encoder: &mut FileEncoder) -> FileEncodeResult {\n+    tcx.sess.time(\"incr_comp_serialize_result_cache\", || tcx.serialize_query_result_cache(encoder))\n }"}, {"sha": "8abae6924b5245a81e42170288ae7629f9ce6b42", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f21791fbec58e14a54b8c6f9146807a8ae8d84/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f21791fbec58e14a54b8c6f9146807a8ae8d84/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=52f21791fbec58e14a54b8c6f9146807a8ae8d84", "patch": "@@ -308,7 +308,7 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n \n impl<'a, 'tcx> FingerprintEncoder for EncodeContext<'a, 'tcx> {\n     fn encode_fingerprint(&mut self, f: &Fingerprint) -> Result<(), Self::Error> {\n-        f.encode_opaque(&mut self.opaque)\n+        self.opaque.encode_fingerprint(f)\n     }\n }\n "}, {"sha": "9d371503e0a4c748ef29b53263fb02dbd3278df0", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/52f21791fbec58e14a54b8c6f9146807a8ae8d84/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f21791fbec58e14a54b8c6f9146807a8ae8d84/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=52f21791fbec58e14a54b8c6f9146807a8ae8d84", "patch": "@@ -50,22 +50,6 @@ impl<'tcx, E: TyEncoder<'tcx>> EncodableWithShorthand<'tcx, E> for ty::Predicate\n     }\n }\n \n-pub trait OpaqueEncoder: Encoder {\n-    fn opaque(&mut self) -> &mut rustc_serialize::opaque::Encoder;\n-    fn encoder_position(&self) -> usize;\n-}\n-\n-impl OpaqueEncoder for rustc_serialize::opaque::Encoder {\n-    #[inline]\n-    fn opaque(&mut self) -> &mut rustc_serialize::opaque::Encoder {\n-        self\n-    }\n-    #[inline]\n-    fn encoder_position(&self) -> usize {\n-        self.position()\n-    }\n-}\n-\n pub trait TyEncoder<'tcx>: Encoder {\n     const CLEAR_CROSS_CRATE: bool;\n "}, {"sha": "3540f0f06b6e6ebc279d18bd1142db4e81c3091e", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52f21791fbec58e14a54b8c6f9146807a8ae8d84/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f21791fbec58e14a54b8c6f9146807a8ae8d84/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=52f21791fbec58e14a54b8c6f9146807a8ae8d84", "patch": "@@ -47,6 +47,7 @@ use rustc_hir::{\n };\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n+use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_session::config::{BorrowckMode, CrateType, OutputFilenames};\n use rustc_session::lint::{Level, Lint};\n use rustc_session::Session;\n@@ -1336,10 +1337,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn serialize_query_result_cache<E>(self, encoder: &mut E) -> Result<(), E::Error>\n-    where\n-        E: ty::codec::OpaqueEncoder,\n-    {\n+    pub fn serialize_query_result_cache(self, encoder: &mut FileEncoder) -> FileEncodeResult {\n         self.queries.on_disk_cache.as_ref().map(|c| c.serialize(self, encoder)).unwrap_or(Ok(()))\n     }\n "}, {"sha": "abe58aacbb1698ed7ec05411b28e855635f30a81", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 52, "deletions": 36, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/52f21791fbec58e14a54b8c6f9146807a8ae8d84/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f21791fbec58e14a54b8c6f9146807a8ae8d84/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=52f21791fbec58e14a54b8c6f9146807a8ae8d84", "patch": "@@ -1,7 +1,7 @@\n use crate::dep_graph::{DepNode, DepNodeIndex, SerializedDepNodeIndex};\n use crate::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use crate::mir::{self, interpret};\n-use crate::ty::codec::{OpaqueEncoder, RefDecodable, TyDecoder, TyEncoder};\n+use crate::ty::codec::{RefDecodable, TyDecoder, TyEncoder};\n use crate::ty::context::TyCtxt;\n use crate::ty::{self, Ty};\n use rustc_data_structures::fingerprint::{Fingerprint, FingerprintDecoder, FingerprintEncoder};\n@@ -14,7 +14,10 @@ use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathHash;\n use rustc_hir::definitions::Definitions;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n+use rustc_serialize::{\n+    opaque::{self, FileEncodeResult, FileEncoder},\n+    Decodable, Decoder, Encodable, Encoder,\n+};\n use rustc_session::{CrateDisambiguator, Session};\n use rustc_span::hygiene::{\n     ExpnDataDecodeMode, ExpnDataEncodeMode, ExpnId, HygieneDecodeContext, HygieneEncodeContext,\n@@ -241,10 +244,11 @@ impl<'sess> OnDiskCache<'sess> {\n         }\n     }\n \n-    pub fn serialize<'tcx, E>(&self, tcx: TyCtxt<'tcx>, encoder: &mut E) -> Result<(), E::Error>\n-    where\n-        E: OpaqueEncoder,\n-    {\n+    pub fn serialize<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        encoder: &mut FileEncoder,\n+    ) -> FileEncodeResult {\n         // Serializing the `DepGraph` should not modify it.\n         tcx.dep_graph.with_ignore(|| {\n             // Allocate `SourceFileIndex`es.\n@@ -298,14 +302,14 @@ impl<'sess> OnDiskCache<'sess> {\n             // Encode query results.\n             let mut query_result_index = EncodedQueryResultIndex::new();\n \n-            tcx.sess.time(\"encode_query_results\", || {\n+            tcx.sess.time(\"encode_query_results\", || -> FileEncodeResult {\n                 let enc = &mut encoder;\n                 let qri = &mut query_result_index;\n \n                 macro_rules! encode_queries {\n                     ($($query:ident,)*) => {\n                         $(\n-                            encode_query_results::<ty::query::queries::$query<'_>, _>(\n+                            encode_query_results::<ty::query::queries::$query<'_>>(\n                                 tcx,\n                                 enc,\n                                 qri\n@@ -324,15 +328,17 @@ impl<'sess> OnDiskCache<'sess> {\n                 .current_diagnostics\n                 .borrow()\n                 .iter()\n-                .map(|(dep_node_index, diagnostics)| {\n-                    let pos = AbsoluteBytePos::new(encoder.position());\n-                    // Let's make sure we get the expected type here.\n-                    let diagnostics: &EncodedDiagnostics = diagnostics;\n-                    let dep_node_index = SerializedDepNodeIndex::new(dep_node_index.index());\n-                    encoder.encode_tagged(dep_node_index, diagnostics)?;\n-\n-                    Ok((dep_node_index, pos))\n-                })\n+                .map(\n+                    |(dep_node_index, diagnostics)| -> Result<_, <FileEncoder as Encoder>::Error> {\n+                        let pos = AbsoluteBytePos::new(encoder.position());\n+                        // Let's make sure we get the expected type here.\n+                        let diagnostics: &EncodedDiagnostics = diagnostics;\n+                        let dep_node_index = SerializedDepNodeIndex::new(dep_node_index.index());\n+                        encoder.encode_tagged(dep_node_index, diagnostics)?;\n+\n+                        Ok((dep_node_index, pos))\n+                    },\n+                )\n                 .collect::<Result<_, _>>()?;\n \n             let interpret_alloc_index = {\n@@ -375,13 +381,13 @@ impl<'sess> OnDiskCache<'sess> {\n \n             hygiene_encode_context.encode(\n                 &mut encoder,\n-                |encoder, index, ctxt_data| {\n+                |encoder, index, ctxt_data| -> FileEncodeResult {\n                     let pos = AbsoluteBytePos::new(encoder.position());\n                     encoder.encode_tagged(TAG_SYNTAX_CONTEXT, ctxt_data)?;\n                     syntax_contexts.insert(index, pos);\n                     Ok(())\n                 },\n-                |encoder, index, expn_data| {\n+                |encoder, index, expn_data| -> FileEncodeResult {\n                     let pos = AbsoluteBytePos::new(encoder.position());\n                     encoder.encode_tagged(TAG_EXPN_DATA, expn_data)?;\n                     expn_ids.insert(index, pos);\n@@ -410,7 +416,7 @@ impl<'sess> OnDiskCache<'sess> {\n \n             // Encode the position of the footer as the last 8 bytes of the\n             // file so we know where to look for it.\n-            IntEncodedWithFixedSize(footer_pos).encode(encoder.encoder.opaque())?;\n+            IntEncodedWithFixedSize(footer_pos).encode(encoder.encoder)?;\n \n             // DO NOT WRITE ANYTHING TO THE ENCODER AFTER THIS POINT! The address\n             // of the footer must be the last thing in the data stream.\n@@ -964,6 +970,17 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [Span] {\n \n //- ENCODING -------------------------------------------------------------------\n \n+trait OpaqueEncoder: Encoder {\n+    fn position(&self) -> usize;\n+}\n+\n+impl OpaqueEncoder for FileEncoder {\n+    #[inline]\n+    fn position(&self) -> usize {\n+        FileEncoder::position(self)\n+    }\n+}\n+\n /// An encoder that can write to the incremental compilation cache.\n struct CacheEncoder<'a, 'tcx, E: OpaqueEncoder> {\n     tcx: TyCtxt<'tcx>,\n@@ -1005,9 +1022,9 @@ where\n     }\n }\n \n-impl<'a, 'tcx> FingerprintEncoder for CacheEncoder<'a, 'tcx, rustc_serialize::opaque::Encoder> {\n-    fn encode_fingerprint(&mut self, f: &Fingerprint) -> opaque::EncodeResult {\n-        f.encode_opaque(self.encoder)\n+impl<'a, 'tcx, E: OpaqueEncoder> FingerprintEncoder for CacheEncoder<'a, 'tcx, E> {\n+    fn encode_fingerprint(&mut self, f: &Fingerprint) -> Result<(), E::Error> {\n+        self.encoder.encode_fingerprint(f)\n     }\n }\n \n@@ -1073,7 +1090,7 @@ where\n     const CLEAR_CROSS_CRATE: bool = false;\n \n     fn position(&self) -> usize {\n-        self.encoder.encoder_position()\n+        self.encoder.position()\n     }\n     fn type_shorthands(&mut self) -> &mut FxHashMap<Ty<'tcx>, usize> {\n         &mut self.type_shorthands\n@@ -1159,12 +1176,12 @@ where\n     }\n }\n \n-// This ensures that the `Encodable<opaque::Encoder>::encode` specialization for byte slices\n-// is used when a `CacheEncoder` having an `opaque::Encoder` is passed to `Encodable::encode`.\n+// This ensures that the `Encodable<opaque::FileEncoder>::encode` specialization for byte slices\n+// is used when a `CacheEncoder` having an `opaque::FileEncoder` is passed to `Encodable::encode`.\n // Unfortunately, we have to manually opt into specializations this way, given how `CacheEncoder`\n // and the encoding traits currently work.\n-impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx, opaque::Encoder>> for [u8] {\n-    fn encode(&self, e: &mut CacheEncoder<'a, 'tcx, opaque::Encoder>) -> opaque::EncodeResult {\n+impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx, FileEncoder>> for [u8] {\n+    fn encode(&self, e: &mut CacheEncoder<'a, 'tcx, FileEncoder>) -> FileEncodeResult {\n         self.encode(e.encoder)\n     }\n }\n@@ -1176,8 +1193,8 @@ impl IntEncodedWithFixedSize {\n     pub const ENCODED_SIZE: usize = 8;\n }\n \n-impl Encodable<opaque::Encoder> for IntEncodedWithFixedSize {\n-    fn encode(&self, e: &mut opaque::Encoder) -> Result<(), !> {\n+impl<E: OpaqueEncoder> Encodable<E> for IntEncodedWithFixedSize {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         let start_pos = e.position();\n         for i in 0..IntEncodedWithFixedSize::ENCODED_SIZE {\n             ((self.0 >> (i * 8)) as u8).encode(e)?;\n@@ -1205,15 +1222,14 @@ impl<'a> Decodable<opaque::Decoder<'a>> for IntEncodedWithFixedSize {\n     }\n }\n \n-fn encode_query_results<'a, 'tcx, Q, E>(\n+fn encode_query_results<'a, 'tcx, Q>(\n     tcx: TyCtxt<'tcx>,\n-    encoder: &mut CacheEncoder<'a, 'tcx, E>,\n+    encoder: &mut CacheEncoder<'a, 'tcx, FileEncoder>,\n     query_result_index: &mut EncodedQueryResultIndex,\n-) -> Result<(), E::Error>\n+) -> FileEncodeResult\n where\n     Q: super::QueryDescription<TyCtxt<'tcx>> + super::QueryAccessors<TyCtxt<'tcx>>,\n-    Q::Value: Encodable<CacheEncoder<'a, 'tcx, E>>,\n-    E: 'a + OpaqueEncoder,\n+    Q::Value: Encodable<CacheEncoder<'a, 'tcx, FileEncoder>>,\n {\n     let _timer = tcx\n         .sess\n@@ -1230,7 +1246,7 @@ where\n \n                 // Record position of the cache entry.\n                 query_result_index\n-                    .push((dep_node, AbsoluteBytePos::new(encoder.encoder.opaque().position())));\n+                    .push((dep_node, AbsoluteBytePos::new(encoder.encoder.position())));\n \n                 // Encode the type check tables with the `SerializedDepNodeIndex`\n                 // as tag."}, {"sha": "0b13a35bb5cd9813b19faa1c73b18869bf0e5044", "filename": "compiler/rustc_serialize/src/leb128.rs", "status": "modified", "additions": 68, "deletions": 32, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/52f21791fbec58e14a54b8c6f9146807a8ae8d84/compiler%2Frustc_serialize%2Fsrc%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f21791fbec58e14a54b8c6f9146807a8ae8d84/compiler%2Frustc_serialize%2Fsrc%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fleb128.rs?ref=52f21791fbec58e14a54b8c6f9146807a8ae8d84", "patch": "@@ -1,16 +1,45 @@\n+#![macro_use]\n+\n+macro_rules! max_leb128_len {\n+    ($int_ty:ty) => {\n+        // The longest LEB128 encoding for an integer uses 7 bits per byte.\n+        (std::mem::size_of::<$int_ty>() * 8 + 6) / 7\n+    };\n+}\n+\n+// Returns the longest LEB128 encoding of all supported integer types.\n+pub const fn max_leb128_len() -> usize {\n+    max_leb128_len!(u128)\n+}\n+\n macro_rules! impl_write_unsigned_leb128 {\n-    ($fn_name:ident, $int_ty:ident) => {\n+    ($fn_name:ident, $int_ty:ty) => {\n         #[inline]\n-        pub fn $fn_name(out: &mut Vec<u8>, mut value: $int_ty) {\n+        pub fn $fn_name(\n+            out: &mut [::std::mem::MaybeUninit<u8>; max_leb128_len!($int_ty)],\n+            mut value: $int_ty,\n+        ) -> &[u8] {\n+            let mut i = 0;\n+\n             loop {\n                 if value < 0x80 {\n-                    out.push(value as u8);\n+                    unsafe {\n+                        *out.get_unchecked_mut(i).as_mut_ptr() = value as u8;\n+                    }\n+\n+                    i += 1;\n                     break;\n                 } else {\n-                    out.push(((value & 0x7f) | 0x80) as u8);\n+                    unsafe {\n+                        *out.get_unchecked_mut(i).as_mut_ptr() = ((value & 0x7f) | 0x80) as u8;\n+                    }\n+\n                     value >>= 7;\n+                    i += 1;\n                 }\n             }\n+\n+            unsafe { ::std::mem::MaybeUninit::slice_assume_init_ref(&out.get_unchecked(..i)) }\n         }\n     };\n }\n@@ -22,7 +51,7 @@ impl_write_unsigned_leb128!(write_u128_leb128, u128);\n impl_write_unsigned_leb128!(write_usize_leb128, usize);\n \n macro_rules! impl_read_unsigned_leb128 {\n-    ($fn_name:ident, $int_ty:ident) => {\n+    ($fn_name:ident, $int_ty:ty) => {\n         #[inline]\n         pub fn $fn_name(slice: &[u8]) -> ($int_ty, usize) {\n             let mut result = 0;\n@@ -49,39 +78,46 @@ impl_read_unsigned_leb128!(read_u64_leb128, u64);\n impl_read_unsigned_leb128!(read_u128_leb128, u128);\n impl_read_unsigned_leb128!(read_usize_leb128, usize);\n \n-#[inline]\n-/// encodes an integer using signed leb128 encoding and stores\n-/// the result using a callback function.\n-///\n-/// The callback `write` is called once for each position\n-/// that is to be written to with the byte to be encoded\n-/// at that position.\n-pub fn write_signed_leb128_to<W>(mut value: i128, mut write: W)\n-where\n-    W: FnMut(u8),\n-{\n-    loop {\n-        let mut byte = (value as u8) & 0x7f;\n-        value >>= 7;\n-        let more =\n-            !(((value == 0) && ((byte & 0x40) == 0)) || ((value == -1) && ((byte & 0x40) != 0)));\n+macro_rules! impl_write_signed_leb128 {\n+    ($fn_name:ident, $int_ty:ty) => {\n+        #[inline]\n+        pub fn $fn_name(\n+            out: &mut [::std::mem::MaybeUninit<u8>; max_leb128_len!($int_ty)],\n+            mut value: $int_ty,\n+        ) -> &[u8] {\n+            let mut i = 0;\n \n-        if more {\n-            byte |= 0x80; // Mark this byte to show that more bytes will follow.\n-        }\n+            loop {\n+                let mut byte = (value as u8) & 0x7f;\n+                value >>= 7;\n+                let more = !(((value == 0) && ((byte & 0x40) == 0))\n+                    || ((value == -1) && ((byte & 0x40) != 0)));\n \n-        write(byte);\n+                if more {\n+                    byte |= 0x80; // Mark this byte to show that more bytes will follow.\n+                }\n \n-        if !more {\n-            break;\n+                unsafe {\n+                    *out.get_unchecked_mut(i).as_mut_ptr() = byte;\n+                }\n+\n+                i += 1;\n+\n+                if !more {\n+                    break;\n+                }\n+            }\n+\n+            unsafe { ::std::mem::MaybeUninit::slice_assume_init_ref(&out.get_unchecked(..i)) }\n         }\n-    }\n+    };\n }\n \n-#[inline]\n-pub fn write_signed_leb128(out: &mut Vec<u8>, value: i128) {\n-    write_signed_leb128_to(value, |v| out.push(v))\n-}\n+impl_write_signed_leb128!(write_i16_leb128, i16);\n+impl_write_signed_leb128!(write_i32_leb128, i32);\n+impl_write_signed_leb128!(write_i64_leb128, i64);\n+impl_write_signed_leb128!(write_i128_leb128, i128);\n+impl_write_signed_leb128!(write_isize_leb128, isize);\n \n #[inline]\n pub fn read_signed_leb128(data: &[u8], start_position: usize) -> (i128, usize) {"}, {"sha": "ea04e7bb44b3bd6de21c8e83113eeef783f24864", "filename": "compiler/rustc_serialize/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/52f21791fbec58e14a54b8c6f9146807a8ae8d84/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f21791fbec58e14a54b8c6f9146807a8ae8d84/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Flib.rs?ref=52f21791fbec58e14a54b8c6f9146807a8ae8d84", "patch": "@@ -16,6 +16,9 @@ Core encoding and decoding interfaces.\n #![cfg_attr(bootstrap, feature(min_const_generics))]\n #![feature(min_specialization)]\n #![feature(vec_spare_capacity)]\n+#![feature(core_intrinsics)]\n+#![feature(maybe_uninit_slice)]\n+#![feature(new_uninit)]\n #![cfg_attr(test, feature(test))]\n #![allow(rustc::internal)]\n "}, {"sha": "a31b73b4ee93a37e5b0a822cfbed4895658ca57a", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 389, "deletions": 22, "changes": 411, "blob_url": "https://github.com/rust-lang/rust/blob/52f21791fbec58e14a54b8c6f9146807a8ae8d84/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f21791fbec58e14a54b8c6f9146807a8ae8d84/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=52f21791fbec58e14a54b8c6f9146807a8ae8d84", "patch": "@@ -1,7 +1,10 @@\n-use crate::leb128::{self, read_signed_leb128, write_signed_leb128};\n+use crate::leb128::{self, max_leb128_len, read_signed_leb128};\n use crate::serialize;\n use std::borrow::Cow;\n+use std::fs::File;\n+use std::io::{self, Write};\n use std::mem::MaybeUninit;\n+use std::path::Path;\n use std::ptr;\n \n // -----------------------------------------------------------------------------\n@@ -23,22 +26,35 @@ impl Encoder {\n         self.data\n     }\n \n+    #[inline]\n+    pub fn position(&self) -> usize {\n+        self.data.len()\n+    }\n+\n     #[inline]\n     pub fn emit_raw_bytes(&mut self, s: &[u8]) {\n         self.data.extend_from_slice(s);\n     }\n }\n \n-macro_rules! write_uleb128 {\n-    ($enc:expr, $value:expr, $fun:ident) => {{\n-        leb128::$fun(&mut $enc.data, $value);\n-        Ok(())\n-    }};\n-}\n+macro_rules! write_leb128 {\n+    ($enc:expr, $value:expr, $int_ty:ty, $fun:ident) => {{\n+        const MAX_ENCODED_LEN: usize = max_leb128_len!($int_ty);\n+        let old_len = $enc.data.len();\n+\n+        if MAX_ENCODED_LEN > $enc.data.capacity() - old_len {\n+            $enc.data.reserve(MAX_ENCODED_LEN);\n+        }\n+\n+        // SAFETY: The above check and `reserve` ensures that there is enough\n+        // room to write the encoded value to the vector's internal buffer.\n+        unsafe {\n+            let buf = &mut *($enc.data.as_mut_ptr().add(old_len)\n+                as *mut [MaybeUninit<u8>; MAX_ENCODED_LEN]);\n+            let encoded = leb128::$fun(buf, $value);\n+            $enc.data.set_len(old_len + encoded.len());\n+        }\n \n-macro_rules! write_sleb128 {\n-    ($enc:expr, $value:expr) => {{\n-        write_signed_leb128(&mut $enc.data, $value as i128);\n         Ok(())\n     }};\n }\n@@ -53,27 +69,27 @@ impl serialize::Encoder for Encoder {\n \n     #[inline]\n     fn emit_usize(&mut self, v: usize) -> EncodeResult {\n-        write_uleb128!(self, v, write_usize_leb128)\n+        write_leb128!(self, v, usize, write_usize_leb128)\n     }\n \n     #[inline]\n     fn emit_u128(&mut self, v: u128) -> EncodeResult {\n-        write_uleb128!(self, v, write_u128_leb128)\n+        write_leb128!(self, v, u128, write_u128_leb128)\n     }\n \n     #[inline]\n     fn emit_u64(&mut self, v: u64) -> EncodeResult {\n-        write_uleb128!(self, v, write_u64_leb128)\n+        write_leb128!(self, v, u64, write_u64_leb128)\n     }\n \n     #[inline]\n     fn emit_u32(&mut self, v: u32) -> EncodeResult {\n-        write_uleb128!(self, v, write_u32_leb128)\n+        write_leb128!(self, v, u32, write_u32_leb128)\n     }\n \n     #[inline]\n     fn emit_u16(&mut self, v: u16) -> EncodeResult {\n-        write_uleb128!(self, v, write_u16_leb128)\n+        write_leb128!(self, v, u16, write_u16_leb128)\n     }\n \n     #[inline]\n@@ -84,27 +100,27 @@ impl serialize::Encoder for Encoder {\n \n     #[inline]\n     fn emit_isize(&mut self, v: isize) -> EncodeResult {\n-        write_sleb128!(self, v)\n+        write_leb128!(self, v, isize, write_isize_leb128)\n     }\n \n     #[inline]\n     fn emit_i128(&mut self, v: i128) -> EncodeResult {\n-        write_sleb128!(self, v)\n+        write_leb128!(self, v, i128, write_i128_leb128)\n     }\n \n     #[inline]\n     fn emit_i64(&mut self, v: i64) -> EncodeResult {\n-        write_sleb128!(self, v)\n+        write_leb128!(self, v, i64, write_i64_leb128)\n     }\n \n     #[inline]\n     fn emit_i32(&mut self, v: i32) -> EncodeResult {\n-        write_sleb128!(self, v)\n+        write_leb128!(self, v, i32, write_i32_leb128)\n     }\n \n     #[inline]\n     fn emit_i16(&mut self, v: i16) -> EncodeResult {\n-        write_sleb128!(self, v)\n+        write_leb128!(self, v, i16, write_i16_leb128)\n     }\n \n     #[inline]\n@@ -143,10 +159,354 @@ impl serialize::Encoder for Encoder {\n     }\n }\n \n-impl Encoder {\n+pub type FileEncodeResult = Result<(), io::Error>;\n+\n+// `FileEncoder` encodes data to file via fixed-size buffer.\n+//\n+// When encoding large amounts of data to a file, using `FileEncoder` may be\n+// preferred over using `Encoder` to encode to a `Vec`, and then writing the\n+// `Vec` to file, as the latter uses as much memory as there is encoded data,\n+// while the former uses the fixed amount of memory allocated to the buffer.\n+// `FileEncoder` also has the advantage of not needing to reallocate as data\n+// is appended to it, but the disadvantage of requiring more error handling,\n+// which has some runtime overhead.\n+pub struct FileEncoder {\n+    // The input buffer. For adequate performance, we need more control over\n+    // buffering than `BufWriter` offers. If `BufWriter` ever offers a raw\n+    // buffer access API, we can use it, and remove `buf` and `buffered`.\n+    buf: Box<[MaybeUninit<u8>]>,\n+    buffered: usize,\n+    flushed: usize,\n+    file: File,\n+}\n+\n+impl FileEncoder {\n+    pub fn new<P: AsRef<Path>>(path: P) -> io::Result<Self> {\n+        const DEFAULT_BUF_SIZE: usize = 8192;\n+        FileEncoder::with_capacity(path, DEFAULT_BUF_SIZE)\n+    }\n+\n+    pub fn with_capacity<P: AsRef<Path>>(path: P, capacity: usize) -> io::Result<Self> {\n+        // Require capacity at least as large as the largest LEB128 encoding\n+        // here, so that we don't have to check or handle this on every write.\n+        assert!(capacity >= max_leb128_len());\n+\n+        // Require capacity small enough such that some capacity checks can be\n+        // done using guaranteed non-overflowing add rather than sub, which\n+        // shaves an instruction off those code paths (on x86 at least).\n+        assert!(capacity <= usize::MAX - max_leb128_len());\n+\n+        let file = File::create(path)?;\n+\n+        Ok(FileEncoder { buf: Box::new_uninit_slice(capacity), buffered: 0, flushed: 0, file })\n+    }\n+\n     #[inline]\n     pub fn position(&self) -> usize {\n-        self.data.len()\n+        // Tracking position this way instead of having a `self.position` field\n+        // means that we don't have to update the position on every write call.\n+        self.flushed + self.buffered\n+    }\n+\n+    #[inline]\n+    pub fn emit_raw_bytes(&mut self, s: &[u8]) -> FileEncodeResult {\n+        self.write_all(s)\n+    }\n+\n+    pub fn flush(&mut self) -> FileEncodeResult {\n+        // This is basically a copy of `BufWriter::flush`. If `BufWriter` ever\n+        // offers a raw buffer access API, we can use it, and remove this.\n+\n+        /// Helper struct to ensure the buffer is updated after all the writes\n+        /// are complete. It tracks the number of written bytes and drains them\n+        /// all from the front of the buffer when dropped.\n+        struct BufGuard<'a> {\n+            buffer: &'a mut [u8],\n+            encoder_buffered: &'a mut usize,\n+            encoder_flushed: &'a mut usize,\n+            flushed: usize,\n+        }\n+\n+        impl<'a> BufGuard<'a> {\n+            fn new(\n+                buffer: &'a mut [u8],\n+                encoder_buffered: &'a mut usize,\n+                encoder_flushed: &'a mut usize,\n+            ) -> Self {\n+                assert_eq!(buffer.len(), *encoder_buffered);\n+                Self { buffer, encoder_buffered, encoder_flushed, flushed: 0 }\n+            }\n+\n+            /// The unwritten part of the buffer\n+            fn remaining(&self) -> &[u8] {\n+                &self.buffer[self.flushed..]\n+            }\n+\n+            /// Flag some bytes as removed from the front of the buffer\n+            fn consume(&mut self, amt: usize) {\n+                self.flushed += amt;\n+            }\n+\n+            /// true if all of the bytes have been written\n+            fn done(&self) -> bool {\n+                self.flushed >= *self.encoder_buffered\n+            }\n+        }\n+\n+        impl Drop for BufGuard<'_> {\n+            fn drop(&mut self) {\n+                if self.flushed > 0 {\n+                    if self.done() {\n+                        *self.encoder_flushed += *self.encoder_buffered;\n+                        *self.encoder_buffered = 0;\n+                    } else {\n+                        self.buffer.copy_within(self.flushed.., 0);\n+                        *self.encoder_flushed += self.flushed;\n+                        *self.encoder_buffered -= self.flushed;\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut guard = BufGuard::new(\n+            unsafe { MaybeUninit::slice_assume_init_mut(&mut self.buf[..self.buffered]) },\n+            &mut self.buffered,\n+            &mut self.flushed,\n+        );\n+\n+        while !guard.done() {\n+            match self.file.write(guard.remaining()) {\n+                Ok(0) => {\n+                    return Err(io::Error::new(\n+                        io::ErrorKind::WriteZero,\n+                        \"failed to write the buffered data\",\n+                    ));\n+                }\n+                Ok(n) => guard.consume(n),\n+                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n+                Err(e) => return Err(e),\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    #[inline]\n+    fn capacity(&self) -> usize {\n+        self.buf.len()\n+    }\n+\n+    #[inline]\n+    fn write_one(&mut self, value: u8) -> FileEncodeResult {\n+        // We ensure this during `FileEncoder` construction.\n+        debug_assert!(self.capacity() >= 1);\n+\n+        let mut buffered = self.buffered;\n+\n+        if std::intrinsics::unlikely(buffered >= self.capacity()) {\n+            self.flush()?;\n+            buffered = 0;\n+        }\n+\n+        // SAFETY: The above check and `flush` ensures that there is enough\n+        // room to write the input to the buffer.\n+        unsafe {\n+            *MaybeUninit::slice_as_mut_ptr(&mut self.buf).add(buffered) = value;\n+        }\n+\n+        self.buffered = buffered + 1;\n+\n+        Ok(())\n+    }\n+\n+    #[inline]\n+    fn write_all(&mut self, buf: &[u8]) -> FileEncodeResult {\n+        let capacity = self.capacity();\n+        let buf_len = buf.len();\n+\n+        if std::intrinsics::likely(buf_len <= capacity) {\n+            let mut buffered = self.buffered;\n+\n+            if std::intrinsics::unlikely(buf_len > capacity - buffered) {\n+                self.flush()?;\n+                buffered = 0;\n+            }\n+\n+            // SAFETY: The above check and `flush` ensures that there is enough\n+            // room to write the input to the buffer.\n+            unsafe {\n+                let src = buf.as_ptr();\n+                let dst = MaybeUninit::slice_as_mut_ptr(&mut self.buf).add(buffered);\n+                ptr::copy_nonoverlapping(src, dst, buf_len);\n+            }\n+\n+            self.buffered = buffered + buf_len;\n+\n+            Ok(())\n+        } else {\n+            self.write_all_unbuffered(buf)\n+        }\n+    }\n+\n+    fn write_all_unbuffered(&mut self, mut buf: &[u8]) -> FileEncodeResult {\n+        if self.buffered > 0 {\n+            self.flush()?;\n+        }\n+\n+        // This is basically a copy of `Write::write_all` but also updates our\n+        // `self.flushed`. It's necessary because `Write::write_all` does not\n+        // return the number of bytes written when an error is encountered, and\n+        // without that, we cannot accurately update `self.flushed` on error.\n+        while !buf.is_empty() {\n+            match self.file.write(buf) {\n+                Ok(0) => {\n+                    return Err(io::Error::new(\n+                        io::ErrorKind::WriteZero,\n+                        \"failed to write whole buffer\",\n+                    ));\n+                }\n+                Ok(n) => {\n+                    buf = &buf[n..];\n+                    self.flushed += n;\n+                }\n+                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n+                Err(e) => return Err(e),\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+impl Drop for FileEncoder {\n+    fn drop(&mut self) {\n+        let _result = self.flush();\n+    }\n+}\n+\n+macro_rules! file_encoder_write_leb128 {\n+    ($enc:expr, $value:expr, $int_ty:ty, $fun:ident) => {{\n+        const MAX_ENCODED_LEN: usize = max_leb128_len!($int_ty);\n+\n+        // We ensure this during `FileEncoder` construction.\n+        debug_assert!($enc.capacity() >= MAX_ENCODED_LEN);\n+\n+        let mut buffered = $enc.buffered;\n+\n+        // This can't overflow. See assertion in `FileEncoder::with_capacity`.\n+        if std::intrinsics::unlikely(buffered + MAX_ENCODED_LEN > $enc.capacity()) {\n+            $enc.flush()?;\n+            buffered = 0;\n+        }\n+\n+        // SAFETY: The above check and flush ensures that there is enough\n+        // room to write the encoded value to the buffer.\n+        let buf = unsafe {\n+            &mut *($enc.buf.as_mut_ptr().add(buffered) as *mut [MaybeUninit<u8>; MAX_ENCODED_LEN])\n+        };\n+\n+        let encoded = leb128::$fun(buf, $value);\n+        $enc.buffered = buffered + encoded.len();\n+\n+        Ok(())\n+    }};\n+}\n+\n+impl serialize::Encoder for FileEncoder {\n+    type Error = io::Error;\n+\n+    #[inline]\n+    fn emit_unit(&mut self) -> FileEncodeResult {\n+        Ok(())\n+    }\n+\n+    #[inline]\n+    fn emit_usize(&mut self, v: usize) -> FileEncodeResult {\n+        file_encoder_write_leb128!(self, v, usize, write_usize_leb128)\n+    }\n+\n+    #[inline]\n+    fn emit_u128(&mut self, v: u128) -> FileEncodeResult {\n+        file_encoder_write_leb128!(self, v, u128, write_u128_leb128)\n+    }\n+\n+    #[inline]\n+    fn emit_u64(&mut self, v: u64) -> FileEncodeResult {\n+        file_encoder_write_leb128!(self, v, u64, write_u64_leb128)\n+    }\n+\n+    #[inline]\n+    fn emit_u32(&mut self, v: u32) -> FileEncodeResult {\n+        file_encoder_write_leb128!(self, v, u32, write_u32_leb128)\n+    }\n+\n+    #[inline]\n+    fn emit_u16(&mut self, v: u16) -> FileEncodeResult {\n+        file_encoder_write_leb128!(self, v, u16, write_u16_leb128)\n+    }\n+\n+    #[inline]\n+    fn emit_u8(&mut self, v: u8) -> FileEncodeResult {\n+        self.write_one(v)\n+    }\n+\n+    #[inline]\n+    fn emit_isize(&mut self, v: isize) -> FileEncodeResult {\n+        file_encoder_write_leb128!(self, v, isize, write_isize_leb128)\n+    }\n+\n+    #[inline]\n+    fn emit_i128(&mut self, v: i128) -> FileEncodeResult {\n+        file_encoder_write_leb128!(self, v, i128, write_i128_leb128)\n+    }\n+\n+    #[inline]\n+    fn emit_i64(&mut self, v: i64) -> FileEncodeResult {\n+        file_encoder_write_leb128!(self, v, i64, write_i64_leb128)\n+    }\n+\n+    #[inline]\n+    fn emit_i32(&mut self, v: i32) -> FileEncodeResult {\n+        file_encoder_write_leb128!(self, v, i32, write_i32_leb128)\n+    }\n+\n+    #[inline]\n+    fn emit_i16(&mut self, v: i16) -> FileEncodeResult {\n+        file_encoder_write_leb128!(self, v, i16, write_i16_leb128)\n+    }\n+\n+    #[inline]\n+    fn emit_i8(&mut self, v: i8) -> FileEncodeResult {\n+        let as_u8: u8 = unsafe { std::mem::transmute(v) };\n+        self.emit_u8(as_u8)\n+    }\n+\n+    #[inline]\n+    fn emit_bool(&mut self, v: bool) -> FileEncodeResult {\n+        self.emit_u8(if v { 1 } else { 0 })\n+    }\n+\n+    #[inline]\n+    fn emit_f64(&mut self, v: f64) -> FileEncodeResult {\n+        let as_u64: u64 = v.to_bits();\n+        self.emit_u64(as_u64)\n+    }\n+\n+    #[inline]\n+    fn emit_f32(&mut self, v: f32) -> FileEncodeResult {\n+        let as_u32: u32 = v.to_bits();\n+        self.emit_u32(as_u32)\n+    }\n+\n+    #[inline]\n+    fn emit_char(&mut self, v: char) -> FileEncodeResult {\n+        self.emit_u32(v as u32)\n+    }\n+\n+    #[inline]\n+    fn emit_str(&mut self, v: &str) -> FileEncodeResult {\n+        self.emit_usize(v.len())?;\n+        self.emit_raw_bytes(v.as_bytes())\n     }\n }\n \n@@ -342,6 +702,13 @@ impl serialize::Encodable<Encoder> for [u8] {\n     }\n }\n \n+impl serialize::Encodable<FileEncoder> for [u8] {\n+    fn encode(&self, e: &mut FileEncoder) -> FileEncodeResult {\n+        serialize::Encoder::emit_usize(e, self.len())?;\n+        e.emit_raw_bytes(self)\n+    }\n+}\n+\n // Specialize decoding `Vec<u8>`. This specialization also applies to decoding `Box<[u8]>`s, etc.,\n // since the default implementations call `decode` to produce a `Vec<u8>` internally.\n impl<'a> serialize::Decodable<Decoder<'a>> for Vec<u8> {"}, {"sha": "45afcc256ed8f1b67c71b50a260b1ba59516567d", "filename": "compiler/rustc_serialize/tests/leb128.rs", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/52f21791fbec58e14a54b8c6f9146807a8ae8d84/compiler%2Frustc_serialize%2Ftests%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f21791fbec58e14a54b8c6f9146807a8ae8d84/compiler%2Frustc_serialize%2Ftests%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Ftests%2Fleb128.rs?ref=52f21791fbec58e14a54b8c6f9146807a8ae8d84", "patch": "@@ -1,4 +1,8 @@\n+#![feature(maybe_uninit_slice)]\n+#![feature(maybe_uninit_uninit_array)]\n+\n use rustc_serialize::leb128::*;\n+use std::mem::MaybeUninit;\n \n macro_rules! impl_test_unsigned_leb128 {\n     ($test_name:ident, $write_fn_name:ident, $read_fn_name:ident, $int_ty:ident) => {\n@@ -7,7 +11,8 @@ macro_rules! impl_test_unsigned_leb128 {\n             let mut stream = Vec::new();\n \n             for x in 0..62 {\n-                $write_fn_name(&mut stream, (3u64 << x) as $int_ty);\n+                let mut buf = MaybeUninit::uninit_array();\n+                stream.extend($write_fn_name(&mut buf, (3u64 << x) as $int_ty));\n             }\n \n             let mut position = 0;\n@@ -28,18 +33,34 @@ impl_test_unsigned_leb128!(test_u64_leb128, write_u64_leb128, read_u64_leb128, u\n impl_test_unsigned_leb128!(test_u128_leb128, write_u128_leb128, read_u128_leb128, u128);\n impl_test_unsigned_leb128!(test_usize_leb128, write_usize_leb128, read_usize_leb128, usize);\n \n-#[test]\n-fn test_signed_leb128() {\n-    let values: Vec<_> = (-500..500).map(|i| i * 0x12345789ABCDEF).collect();\n-    let mut stream = Vec::new();\n-    for &x in &values {\n-        write_signed_leb128(&mut stream, x);\n-    }\n-    let mut pos = 0;\n-    for &x in &values {\n-        let (value, bytes_read) = read_signed_leb128(&mut stream, pos);\n-        pos += bytes_read;\n-        assert_eq!(x, value);\n-    }\n-    assert_eq!(pos, stream.len());\n+macro_rules! impl_test_signed_leb128 {\n+    ($test_name:ident, $write_fn_name:ident, $int_ty:ident) => {\n+        #[test]\n+        fn $test_name() {\n+            let values: Vec<_> = (-500..500)\n+                .map(|i| ((i as $int_ty).wrapping_mul(0x12345789ABCDEF_i64 as $int_ty)))\n+                .collect();\n+            let mut stream = Vec::new();\n+\n+            for &x in &values {\n+                let mut buf = MaybeUninit::uninit_array();\n+                stream.extend($write_fn_name(&mut buf, x));\n+            }\n+\n+            let mut position = 0;\n+            for &x in &values {\n+                let expected = x as i128;\n+                let (actual, bytes_read) = read_signed_leb128(&mut stream, position);\n+                assert_eq!(expected, actual);\n+                position += bytes_read;\n+            }\n+            assert_eq!(stream.len(), position);\n+        }\n+    };\n }\n+\n+impl_test_signed_leb128!(test_i16_leb128, write_i16_leb128, i16);\n+impl_test_signed_leb128!(test_i32_leb128, write_i32_leb128, i32);\n+impl_test_signed_leb128!(test_i64_leb128, write_i64_leb128, i64);\n+impl_test_signed_leb128!(test_i128_leb128, write_i128_leb128, i128);\n+impl_test_signed_leb128!(test_isize_leb128, write_isize_leb128, isize);"}]}