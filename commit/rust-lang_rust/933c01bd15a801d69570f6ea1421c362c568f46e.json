{"sha": "933c01bd15a801d69570f6ea1421c362c568f46e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzM2MwMWJkMTVhODAxZDY5NTcwZjZlYTE0MjFjMzYyYzU2OGY0NmU=", "commit": {"author": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-03-21T21:47:38Z"}, "committer": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-03-21T21:53:11Z"}, "message": "Every upcall needs a task pointer to find the C stack. It is just that when\nhandling cdecl call they should skip it when calling the final function.\n\nThere is some cleanup to be done on the generated IL, but this gets us\nrunning Hello World for real.", "tree": {"sha": "ed3060d1fe2fef2a94040c024886e69999e90439", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed3060d1fe2fef2a94040c024886e69999e90439"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/933c01bd15a801d69570f6ea1421c362c568f46e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/933c01bd15a801d69570f6ea1421c362c568f46e", "html_url": "https://github.com/rust-lang/rust/commit/933c01bd15a801d69570f6ea1421c362c568f46e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/933c01bd15a801d69570f6ea1421c362c568f46e/comments", "author": null, "committer": null, "parents": [{"sha": "0eb6be13fb141689e132bf1cd28fe4853498b9e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0eb6be13fb141689e132bf1cd28fe4853498b9e7", "html_url": "https://github.com/rust-lang/rust/commit/0eb6be13fb141689e132bf1cd28fe4853498b9e7"}], "stats": {"total": 112, "additions": 66, "deletions": 46}, "files": [{"sha": "cae1dc90e8b8a17b9e04e36cef0e37ad5e794bd0", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/933c01bd15a801d69570f6ea1421c362c568f46e/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933c01bd15a801d69570f6ea1421c362c568f46e/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=933c01bd15a801d69570f6ea1421c362c568f46e", "patch": "@@ -75,8 +75,11 @@ fn vec_append_glue_name() -> str {\n     ret \"rust_vec_append_glue\";\n }\n \n-fn upcall_glue_name(int n) -> str {\n-    ret \"rust_upcall_\" + util.common.istr(n);\n+fn upcall_glue_name(int n, bool pass_task) -> str {\n+    if (pass_task) {\n+        ret \"rust_upcall_rust_\" + util.common.istr(n);\n+    }\n+    ret \"rust_upcall_cdecl_\" + util.common.istr(n);\n }\n \n fn activate_glue_name() -> str {"}, {"sha": "1ac03d1f4ee1bd3af69b0d13f896462dbaf5d629", "filename": "src/comp/back/x86.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/933c01bd15a801d69570f6ea1421c362c568f46e/src%2Fcomp%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933c01bd15a801d69570f6ea1421c362c568f46e/src%2Fcomp%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86.rs?ref=933c01bd15a801d69570f6ea1421c362c568f46e", "patch": "@@ -179,7 +179,7 @@ fn rust_yield_glue() -> vec[str] {\n         + vec(\"ret\");\n }\n \n-fn upcall_glue(int n_args) -> vec[str] {\n+fn upcall_glue(int n_args, bool pass_task) -> vec[str] {\n \n     /*\n      * 0, 4, 8, 12 are callee-saves\n@@ -191,18 +191,23 @@ fn upcall_glue(int n_args) -> vec[str] {\n      *\n      */\n \n-    fn copy_arg(uint i) -> str {\n-        if (i == 0u) {\n+    fn copy_arg(bool pass_task, uint i) -> str {\n+        if (i == 0u && pass_task) {\n             ret \"movl  %edx, (%esp)\";\n         }\n-        auto src_off = wstr(4 + (i as int));\n         auto dst_off = wstr(0 + (i as int));\n+        auto src_off;\n+        if (pass_task) {\n+            src_off = wstr(4 + (i as int));\n+        } else {\n+            src_off = wstr(5 + (i as int));\n+        }\n         auto m = vec(\"movl  \" + src_off + \"(%ebp),%eax\",\n                      \"movl  %eax,\" + dst_off + \"(%esp)\");\n         ret _str.connect(m, \"\\n\\t\");\n     }\n \n-    auto carg = copy_arg;\n+    auto carg = bind copy_arg(pass_task, _);\n \n     ret\n         save_callee_saves()\n@@ -237,11 +242,11 @@ fn decl_glue(int align, str prefix, str name, vec[str] insns) -> str {\n }\n \n \n-fn decl_upcall_glue(int align, str prefix, uint n) -> str {\n+fn decl_upcall_glue(int align, str prefix, bool pass_task, uint n) -> str {\n     let int i = n as int;\n     ret decl_glue(align, prefix,\n-                  abi.upcall_glue_name(i),\n-                  upcall_glue(i));\n+                  abi.upcall_glue_name(i, pass_task),\n+                  upcall_glue(i, pass_task));\n }\n \n fn get_symbol_prefix() -> str {\n@@ -267,9 +272,12 @@ fn get_module_asm() -> str {\n                       abi.yield_glue_name(),\n                       rust_yield_glue()))\n \n-        + _vec.init_fn[str](bind decl_upcall_glue(align, prefix, _),\n+        + _vec.init_fn[str](bind decl_upcall_glue(align, prefix, true, _),\n+                            (abi.n_upcall_glues + 1) as uint)\n+        + _vec.init_fn[str](bind decl_upcall_glue(align, prefix, false, _),\n                             (abi.n_upcall_glues + 1) as uint);\n \n+\n     ret _str.connect(glues, \"\\n\\n\");\n }\n "}, {"sha": "e71024137887c2410a19a3d1bd120fa9d5ace854", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 44, "deletions": 35, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/933c01bd15a801d69570f6ea1421c362c568f46e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933c01bd15a801d69570f6ea1421c362c568f46e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=933c01bd15a801d69570f6ea1421c362c568f46e", "patch": "@@ -53,7 +53,8 @@ state obj namegen(mutable int i) {\n type glue_fns = rec(ValueRef activate_glue,\n                     ValueRef yield_glue,\n                     ValueRef exit_task_glue,\n-                    vec[ValueRef] upcall_glues,\n+                    vec[ValueRef] upcall_glues_rust,\n+                    vec[ValueRef] upcall_glues_cdecl,\n                     ValueRef no_op_type_glue,\n                     ValueRef memcpy_glue,\n                     ValueRef bzero_glue,\n@@ -71,7 +72,6 @@ state type crate_ctxt = rec(session.session sess,\n                             hashmap[str, ValueRef] upcalls,\n                             hashmap[str, ValueRef] intrinsics,\n                             hashmap[str, ValueRef] item_names,\n-                            hashmap[str, ValueRef] native_fns,\n                             hashmap[ast.def_id, ValueRef] item_ids,\n                             hashmap[ast.def_id, @ast.item] items,\n                             hashmap[ast.def_id,\n@@ -826,16 +826,19 @@ fn decl_glue(ModuleRef llmod, type_names tn, str s) -> ValueRef {\n     ret decl_cdecl_fn(llmod, s, T_fn(vec(T_taskptr(tn)), T_void()));\n }\n \n-fn decl_upcall_glue(ModuleRef llmod, type_names tn, uint _n) -> ValueRef {\n+fn decl_upcall_glue(ModuleRef llmod, type_names tn,\n+                    bool pass_task, uint _n) -> ValueRef {\n     // It doesn't actually matter what type we come up with here, at the\n     // moment, as we cast the upcall function pointers to int before passing\n     // them to the indirect upcall-invocation glue.  But eventually we'd like\n     // to call them directly, once we have a calling convention worked out.\n     let int n = _n as int;\n-    let str s = abi.upcall_glue_name(n);\n-    let vec[TypeRef] args =\n-        vec(T_int())     // callee\n-        + _vec.init_elt[TypeRef](T_int(), n as uint);\n+    let str s = abi.upcall_glue_name(n, pass_task);\n+    let vec[TypeRef] args = vec(T_int()); // callee\n+    if (!pass_task) {\n+        args += vec(T_int()); // taskptr, will not be passed\n+    }\n+    args += _vec.init_elt[TypeRef](T_int(), n as uint);\n \n     ret decl_fastcall_fn(llmod, s, T_fn(args, T_int()));\n }\n@@ -856,21 +859,29 @@ fn trans_upcall(@block_ctxt cx, str name, vec[ValueRef] args) -> result {\n     auto cxx = cx.fcx.ccx;\n     auto lltaskptr = cx.build.PtrToInt(cx.fcx.lltaskptr, T_int());\n     auto args2 = vec(lltaskptr) + args;\n-    auto t = trans_upcall2(cx.build, cxx.glues,\n-                           cxx.upcalls, cxx.tn, cxx.llmod, name, args2);\n+    auto t = trans_upcall2(cx.build, cxx.glues, lltaskptr,\n+                           cxx.upcalls, cxx.tn, cxx.llmod, name, true, args2);\n     ret res(cx, t);\n }\n \n-fn trans_upcall2(builder b, @glue_fns glues,\n+fn trans_upcall2(builder b, @glue_fns glues, ValueRef lltaskptr,\n                  &hashmap[str, ValueRef] upcalls,\n                  type_names tn, ModuleRef llmod, str name,\n-                 vec[ValueRef] args) -> ValueRef {\n+                 bool pass_task, vec[ValueRef] args) -> ValueRef {\n     let int n = (_vec.len[ValueRef](args) as int);\n     let ValueRef llupcall = get_upcall(upcalls, llmod, name, n);\n     llupcall = llvm.LLVMConstPointerCast(llupcall, T_int());\n \n-    let ValueRef llglue = glues.upcall_glues.(n);\n+    let ValueRef llglue;\n+    if (pass_task) {\n+        llglue = glues.upcall_glues_rust.(n);\n+    } else {\n+        llglue = glues.upcall_glues_cdecl.(n);\n+    }\n     let vec[ValueRef] call_args = vec(llupcall);\n+    if (!pass_task) {\n+        call_args += vec(lltaskptr);\n+    }\n \n     for (ValueRef a in args) {\n         call_args += vec(b.ZExtOrBitCast(a, T_int()));\n@@ -5457,44 +5468,38 @@ fn decl_native_fn_and_pair(@crate_ctxt cx,\n     auto llfnty = type_of_native_fn(cx, abi, ty.ty_fn_args(fn_type),\n                                     ty.ty_fn_ret(fn_type), num_ty_param);\n \n-    // We can only declare a native function with a given name once; LLVM\n-    // unhelpfully mangles the names if we try to multiply declare one.\n-    auto function;\n-    if (!cx.native_fns.contains_key(name)) {\n-        function = decl_cdecl_fn(cx.llmod, name, llfnty);\n-        cx.native_fns.insert(name, function);\n-    } else {\n-        // We support type-punning a native function by giving it different\n-        // Rust types.\n-        auto llorigfn = cx.native_fns.get(name);\n-        function = bcx.build.PointerCast(llorigfn, T_ptr(llfnty));\n-    }\n-\n     let vec[ValueRef] call_args = vec();\n     auto arg_n = 3u;\n+    auto pass_task;\n+\n+    auto lltaskptr = bcx.build.PtrToInt(fcx.lltaskptr, T_int());\n     alt (abi) {\n         case (ast.native_abi_rust) {\n-            call_args += vec(fcx.lltaskptr);\n+            pass_task = true;\n+            call_args += vec(lltaskptr);\n             for each (uint i in _uint.range(0u, num_ty_param)) {\n                 auto llarg = llvm.LLVMGetParam(fcx.llfn, arg_n);\n                 check (llarg as int != 0);\n-                call_args += vec(llarg);\n+                call_args += vec(bcx.build.PointerCast(llarg, T_i32()));\n                 arg_n += 1u;\n             }\n         }\n         case (ast.native_abi_cdecl) {\n+            pass_task = false;\n         }\n     }\n     auto args = ty.ty_fn_args(fn_type);\n     for (ty.arg arg in args) {\n         auto llarg = llvm.LLVMGetParam(fcx.llfn, arg_n);\n         check (llarg as int != 0);\n-        call_args += vec(llarg);\n+        call_args += vec(bcx.build.PointerCast(llarg, T_i32()));\n         arg_n += 1u;\n     }\n \n-    auto r = bcx.build.Call(function, call_args);\n-    bcx.build.Store(r, fcx.llretptr);\n+    auto r = trans_upcall2(bcx.build, cx.glues, lltaskptr, cx.upcalls, cx.tn,\n+                           cx.llmod, name, pass_task, call_args);\n+    auto rptr = bcx.build.BitCast(fcx.llretptr, T_ptr(T_i32()));\n+    bcx.build.Store(r, rptr);\n     bcx.build.RetVoid();\n }\n \n@@ -5695,8 +5700,8 @@ fn trans_exit_task_glue(@glue_fns glues,\n     auto build = new_builder(entrybb);\n     auto tptr = build.PtrToInt(lltaskptr, T_int());\n     auto V_args2 = vec(tptr) + V_args;\n-    trans_upcall2(build, glues,\n-                  upcalls, tn, llmod, \"upcall_exit\", V_args2);\n+    trans_upcall2(build, glues, lltaskptr,\n+                  upcalls, tn, llmod, \"upcall_exit\", true, V_args2);\n     build.RetVoid();\n }\n \n@@ -6146,8 +6151,13 @@ fn make_glues(ModuleRef llmod, type_names tn) -> @glue_fns {\n                                                      T_taskptr(tn)),\n                                                  T_void())),\n \n-             upcall_glues =\n-             _vec.init_fn[ValueRef](bind decl_upcall_glue(llmod, tn, _),\n+             upcall_glues_rust =\n+             _vec.init_fn[ValueRef](bind decl_upcall_glue(llmod, tn, true,\n+                                                          _),\n+                                    abi.n_upcall_glues + 1 as uint),\n+             upcall_glues_cdecl =\n+             _vec.init_fn[ValueRef](bind decl_upcall_glue(llmod, tn, false,\n+                                                          _),\n                                     abi.n_upcall_glues + 1 as uint),\n              no_op_type_glue = decl_no_op_type_glue(llmod, tn),\n              memcpy_glue = decl_memcpy_glue(llmod),\n@@ -6217,7 +6227,6 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n                    upcalls = new_str_hash[ValueRef](),\n                    intrinsics = intrinsics,\n                    item_names = new_str_hash[ValueRef](),\n-                   native_fns = new_str_hash[ValueRef](),\n                    item_ids = new_def_hash[ValueRef](),\n                    items = new_def_hash[@ast.item](),\n                    native_items = new_def_hash[@ast.native_item](),"}]}