{"sha": "90f11310224e9e2d5a27e3e4b8c5b1aaa1c0b980", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwZjExMzEwMjI0ZTllMmQ1YTI3ZTNlNGI4YzViMWFhYTFjMGI5ODA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-04-23T17:40:41Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-04-23T17:43:13Z"}, "message": "Miri Frame: use mir::Location to represent position in function", "tree": {"sha": "4cb95d1389dca17ddf97a80f4c2300fdc2a5bf63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cb95d1389dca17ddf97a80f4c2300fdc2a5bf63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90f11310224e9e2d5a27e3e4b8c5b1aaa1c0b980", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90f11310224e9e2d5a27e3e4b8c5b1aaa1c0b980", "html_url": "https://github.com/rust-lang/rust/commit/90f11310224e9e2d5a27e3e4b8c5b1aaa1c0b980", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90f11310224e9e2d5a27e3e4b8c5b1aaa1c0b980/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66f7a5d92f5adb9053bf66e0bf8f6d31d404870d", "url": "https://api.github.com/repos/rust-lang/rust/commits/66f7a5d92f5adb9053bf66e0bf8f6d31d404870d", "html_url": "https://github.com/rust-lang/rust/commit/66f7a5d92f5adb9053bf66e0bf8f6d31d404870d"}], "stats": {"total": 70, "additions": 29, "deletions": 41}, "files": [{"sha": "02fce7dfb43c208efe94b4675cff6c3639ad8908", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 20, "deletions": 30, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/90f11310224e9e2d5a27e3e4b8c5b1aaa1c0b980/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f11310224e9e2d5a27e3e4b8c5b1aaa1c0b980/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=90f11310224e9e2d5a27e3e4b8c5b1aaa1c0b980", "patch": "@@ -81,14 +81,9 @@ pub struct Frame<'mir, 'tcx, Tag = (), Extra = ()> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n     ////////////////////////////////////////////////////////////////////////////////\n-    /// The block that is currently executed (or will be executed after the above call stacks\n-    /// return).\n     /// If this is `None`, we are unwinding and this function doesn't need any clean-up.\n     /// Just continue the same as with `Resume`.\n-    pub block: Option<mir::BasicBlock>,\n-\n-    /// The index of the currently evaluated statement.\n-    pub stmt: usize,\n+    pub loc: Option<mir::Location>,\n }\n \n #[derive(Clone, Eq, PartialEq, Debug, HashStable)] // Miri debug-prints these\n@@ -168,8 +163,7 @@ impl<'mir, 'tcx, Tag> Frame<'mir, 'tcx, Tag> {\n             return_to_block: self.return_to_block,\n             return_place: self.return_place,\n             locals: self.locals,\n-            block: self.block,\n-            stmt: self.stmt,\n+            loc: self.loc,\n             extra,\n         }\n     }\n@@ -178,10 +172,10 @@ impl<'mir, 'tcx, Tag> Frame<'mir, 'tcx, Tag> {\n impl<'mir, 'tcx, Tag, Extra> Frame<'mir, 'tcx, Tag, Extra> {\n     /// Return the `SourceInfo` of the current instruction.\n     pub fn current_source_info(&self) -> Option<mir::SourceInfo> {\n-        self.block.map(|block| {\n-            let block = &self.body.basic_blocks()[block];\n-            if self.stmt < block.statements.len() {\n-                block.statements[self.stmt].source_info\n+        self.loc.map(|loc| {\n+            let block = &self.body.basic_blocks()[loc.block];\n+            if loc.statement_index < block.statements.len() {\n+                block.statements[loc.statement_index].source_info\n             } else {\n                 block.terminator().source_info\n             }\n@@ -615,14 +609,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // first push a stack frame so we have access to the local substs\n         let pre_frame = Frame {\n             body,\n-            block: Some(mir::START_BLOCK),\n+            loc: Some(mir::Location::START),\n             return_to_block,\n             return_place,\n             // empty local array, we fill it in below, after we are inside the stack frame and\n             // all methods actually know about the frame\n             locals: IndexVec::new(),\n             instance,\n-            stmt: 0,\n             extra: (),\n         };\n         let frame = M::init_frame_extra(self, pre_frame)?;\n@@ -671,9 +664,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Jump to the given block.\n     #[inline]\n     pub fn go_to_block(&mut self, target: mir::BasicBlock) {\n-        let frame = self.frame_mut();\n-        frame.block = Some(target);\n-        frame.stmt = 0;\n+        self.frame_mut().loc = Some(mir::Location { block: target, statement_index: 0 });\n     }\n \n     /// *Return* to the given `target` basic block.\n@@ -695,9 +686,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// If `target` is `None`, that indicates the function does not need cleanup during\n     /// unwinding, and we will just keep propagating that upwards.\n     pub fn unwind_to_block(&mut self, target: Option<mir::BasicBlock>) {\n-        let frame = self.frame_mut();\n-        frame.block = target;\n-        frame.stmt = 0;\n+        self.frame_mut().loc = target.map(|block| mir::Location { block, statement_index: 0 });\n     }\n \n     /// Pops the current frame from the stack, deallocating the\n@@ -724,9 +713,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Sanity check `unwinding`.\n         assert_eq!(\n             unwinding,\n-            match self.frame().block {\n+            match self.frame().loc {\n                 None => true,\n-                Some(block) => self.body().basic_blocks()[block].is_cleanup,\n+                Some(loc) => self.body().basic_blocks()[loc.block].is_cleanup,\n             }\n         );\n \n@@ -987,13 +976,14 @@ where\n     Tag: HashStable<StableHashingContext<'ctx>>,\n {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'ctx>, hasher: &mut StableHasher) {\n-        self.body.hash_stable(hcx, hasher);\n-        self.instance.hash_stable(hcx, hasher);\n-        self.return_to_block.hash_stable(hcx, hasher);\n-        self.return_place.as_ref().map(|r| &**r).hash_stable(hcx, hasher);\n-        self.locals.hash_stable(hcx, hasher);\n-        self.block.hash_stable(hcx, hasher);\n-        self.stmt.hash_stable(hcx, hasher);\n-        self.extra.hash_stable(hcx, hasher);\n+        // Exhaustive match on fields to make sure we forget no field.\n+        let Frame { body, instance, return_to_block, return_place, locals, loc, extra } = self;\n+        body.hash_stable(hcx, hasher);\n+        instance.hash_stable(hcx, hasher);\n+        return_to_block.hash_stable(hcx, hasher);\n+        return_place.as_ref().map(|r| &**r).hash_stable(hcx, hasher);\n+        locals.hash_stable(hcx, hasher);\n+        loc.hash_stable(hcx, hasher);\n+        extra.hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "bb4c0156c88cf8d3e4308a66487a94c90fc03ead", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/90f11310224e9e2d5a27e3e4b8c5b1aaa1c0b980/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f11310224e9e2d5a27e3e4b8c5b1aaa1c0b980/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=90f11310224e9e2d5a27e3e4b8c5b1aaa1c0b980", "patch": "@@ -46,8 +46,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(false);\n         }\n \n-        let block = match self.frame().block {\n-            Some(block) => block,\n+        let loc = match self.frame().loc {\n+            Some(loc) => loc,\n             None => {\n                 // We are unwinding and this fn has no cleanup code.\n                 // Just go on unwinding.\n@@ -56,13 +56,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 return Ok(true);\n             }\n         };\n-        let stmt_id = self.frame().stmt;\n-        let body = self.body();\n-        let basic_block = &body.basic_blocks()[block];\n+        let basic_block = &self.body().basic_blocks()[loc.block];\n \n         let old_frames = self.frame_idx();\n \n-        if let Some(stmt) = basic_block.statements.get(stmt_id) {\n+        if let Some(stmt) = basic_block.statements.get(loc.statement_index) {\n             assert_eq!(old_frames, self.frame_idx());\n             self.statement(stmt)?;\n             return Ok(true);\n@@ -126,7 +124,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             LlvmInlineAsm { .. } => throw_unsup_format!(\"inline assembly is not supported\"),\n         }\n \n-        self.stack_mut()[frame_idx].stmt += 1;\n+        self.stack_mut()[frame_idx].loc.as_mut().unwrap().statement_index += 1;\n         Ok(())\n     }\n \n@@ -279,8 +277,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         self.eval_terminator(terminator)?;\n         if !self.stack().is_empty() {\n-            if let Some(block) = self.frame().block {\n-                info!(\"// executing {:?}\", block);\n+            if let Some(loc) = self.frame().loc {\n+                info!(\"// executing {:?}\", loc.block);\n             }\n         }\n         Ok(())"}, {"sha": "6ead962dcd869abaa674b7057136b999d20f3e12", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90f11310224e9e2d5a27e3e4b8c5b1aaa1c0b980/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f11310224e9e2d5a27e3e4b8c5b1aaa1c0b980/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=90f11310224e9e2d5a27e3e4b8c5b1aaa1c0b980", "patch": "@@ -53,7 +53,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Call { ref func, ref args, destination, ref cleanup, .. } => {\n                 let old_stack = self.frame_idx();\n-                let old_bb = self.frame().block;\n+                let old_loc = self.frame().loc;\n                 let func = self.eval_operand(func, None)?;\n                 let (fn_val, abi) = match func.layout.ty.kind {\n                     ty::FnPtr(sig) => {\n@@ -80,7 +80,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.eval_fn_call(fn_val, abi, &args[..], ret, *cleanup)?;\n                 // Sanity-check that `eval_fn_call` either pushed a new frame or\n                 // did a jump to another block.\n-                if self.frame_idx() == old_stack && self.frame().block == old_bb {\n+                if self.frame_idx() == old_stack && self.frame().loc == old_loc {\n                     span_bug!(terminator.source_info.span, \"evaluating this call made no progress\");\n                 }\n             }"}]}