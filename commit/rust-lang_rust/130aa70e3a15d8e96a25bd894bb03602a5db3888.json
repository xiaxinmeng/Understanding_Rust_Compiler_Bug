{"sha": "130aa70e3a15d8e96a25bd894bb03602a5db3888", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzMGFhNzBlM2ExNWQ4ZTk2YTI1YmQ4OTRiYjAzNjAyYTVkYjM4ODg=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-06-06T02:52:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-06T02:52:48Z"}, "message": "Merge pull request #1621 from topecongiro/combining\n\nCombine more expressions", "tree": {"sha": "588e4f15df73e74783d9696faeed6521c7ba5c40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/588e4f15df73e74783d9696faeed6521c7ba5c40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/130aa70e3a15d8e96a25bd894bb03602a5db3888", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/130aa70e3a15d8e96a25bd894bb03602a5db3888", "html_url": "https://github.com/rust-lang/rust/commit/130aa70e3a15d8e96a25bd894bb03602a5db3888", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/130aa70e3a15d8e96a25bd894bb03602a5db3888/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d04ab9e5ba46b21a49027ce38dc913b4617125ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/d04ab9e5ba46b21a49027ce38dc913b4617125ba", "html_url": "https://github.com/rust-lang/rust/commit/d04ab9e5ba46b21a49027ce38dc913b4617125ba"}, {"sha": "7250a468f978991e87e9f8dfd19ed74af903c21f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7250a468f978991e87e9f8dfd19ed74af903c21f", "html_url": "https://github.com/rust-lang/rust/commit/7250a468f978991e87e9f8dfd19ed74af903c21f"}], "stats": {"total": 850, "additions": 611, "deletions": 239}, "files": [{"sha": "605f5d63291b41323e0c35df6e8d80d22d9e4543", "filename": "Configurations.md", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/130aa70e3a15d8e96a25bd894bb03602a5db3888/Configurations.md", "raw_url": "https://github.com/rust-lang/rust/raw/130aa70e3a15d8e96a25bd894bb03602a5db3888/Configurations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Configurations.md?ref=130aa70e3a15d8e96a25bd894bb03602a5db3888", "patch": "@@ -166,6 +166,62 @@ lorem_ipsum(|| {\n });\n ```\n \n+## `combine_control_expr`\n+\n+Combine control expressions with function calls.\n+\n+- **Default value**: `true`\n+- **Possible values**: `true`, `false`\n+\n+#### `true`\n+\n+```rust\n+fn example() {\n+    // If\n+    foo!(if x {\n+        foo();\n+    } else {\n+        bar();\n+    });\n+\n+    // IfLet\n+    foo!(if let Some(..) = x {\n+        foo();\n+    } else {\n+        bar();\n+    });\n+\n+    // While\n+    foo!(while x {\n+        foo();\n+        bar();\n+    });\n+\n+    // WhileLet\n+    foo!(while let Some(..) = x {\n+        foo();\n+        bar();\n+    });\n+\n+    // ForLoop\n+    foo!(for x in y {\n+        foo();\n+        bar();\n+    });\n+\n+    // Loop\n+    foo!(loop {\n+        foo();\n+        bar();\n+    });\n+}\n+```\n+\n+#### `false`\n+\n+```rust\n+```\n+\n ## `comment_width`\n \n Maximum length of comments. No effect unless`wrap_comments = true`."}, {"sha": "e286dcb4b7fbc3a1b05b49de60a555f30541282b", "filename": "rfc-rustfmt.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/130aa70e3a15d8e96a25bd894bb03602a5db3888/rfc-rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/130aa70e3a15d8e96a25bd894bb03602a5db3888/rfc-rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rfc-rustfmt.toml?ref=130aa70e3a15d8e96a25bd894bb03602a5db3888", "patch": "@@ -4,3 +4,4 @@ control_style = \"Rfc\"\n where_style = \"Rfc\"\n generics_indent = \"Block\"\n fn_call_style = \"Block\"\n+combine_control_expr = true"}, {"sha": "204f0b804232c3ec436b62e578ff55f886b601a1", "filename": "src/chains.rs", "status": "modified", "additions": 81, "deletions": 32, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/130aa70e3a15d8e96a25bd894bb03602a5db3888/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130aa70e3a15d8e96a25bd894bb03602a5db3888/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=130aa70e3a15d8e96a25bd894bb03602a5db3888", "patch": "@@ -117,22 +117,18 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     };\n     let parent_rewrite = try_opt!(parent.rewrite(context, parent_shape));\n     let parent_rewrite_contains_newline = parent_rewrite.contains('\\n');\n+    let is_small_parent = parent_rewrite.len() <= context.config.tab_spaces();\n \n     // Decide how to layout the rest of the chain. `extend` is true if we can\n     // put the first non-parent item on the same line as the parent.\n-    let first_subexpr_is_try = match subexpr_list.last().unwrap().node {\n-        ast::ExprKind::Try(..) => true,\n-        _ => false,\n-    };\n+    let first_subexpr_is_try = subexpr_list.last().map_or(false, is_try);\n     let (nested_shape, extend) = if !parent_rewrite_contains_newline && is_continuable(&parent) {\n         let nested_shape = if first_subexpr_is_try {\n             parent_shape.block_indent(context.config.tab_spaces())\n         } else {\n             chain_indent(context, shape.add_offset(parent_rewrite.len()))\n         };\n-        (nested_shape,\n-         context.config.chain_indent() == IndentStyle::Visual ||\n-         parent_rewrite.len() <= context.config.tab_spaces())\n+        (nested_shape, context.config.chain_indent() == IndentStyle::Visual || is_small_parent)\n     } else if is_block_expr(context, &parent, &parent_rewrite) {\n         match context.config.chain_indent() {\n             // Try to put the first child on the same line with parent's last line\n@@ -168,9 +164,9 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n             .into_iter()\n             .chain(::std::iter::repeat(other_child_shape).take(subexpr_list.len() - 1));\n     let iter = subexpr_list.iter().rev().zip(child_shape_iter);\n-    let mut rewrites =\n-        try_opt!(iter.map(|(e, shape)| rewrite_chain_subexpr(e, total_span, context, shape))\n-                     .collect::<Option<Vec<_>>>());\n+    let mut rewrites = try_opt!(iter.map(|(e, shape)| {\n+                                             rewrite_chain_subexpr(e, total_span, context, shape)\n+                                         }).collect::<Option<Vec<_>>>());\n \n     // Total of all items excluding the last.\n     let last_non_try_index = rewrites.len() - (1 + trailing_try_num);\n@@ -229,7 +225,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     }\n \n     // Try overflowing the last element if we are using block indent.\n-    if !fits_single_line && context.config.fn_call_style() == IndentStyle::Block {\n+    if !fits_single_line && context.use_block_indent() {\n         let (init, last) = rewrites.split_at_mut(last_non_try_index);\n         let almost_single_line = init.iter().all(|s| !s.contains('\\n'));\n         if almost_single_line {\n@@ -252,29 +248,53 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         String::new()\n     } else {\n         // Use new lines.\n+        if context.force_one_line_chain {\n+            return None;\n+        }\n         format!(\"\\n{}\", nested_shape.indent.to_string(context.config))\n     };\n \n-    let first_connector = if subexpr_list.is_empty() {\n-        \"\"\n-    } else if extend || first_subexpr_is_try {\n-        // 1 = \";\", being conservative here.\n-        if last_line_width(&parent_rewrite) + first_line_width(&rewrites[0]) + 1 <=\n-           context.config.max_width() {\n-            \"\"\n-        } else {\n-            &*connector\n-        }\n+    let first_connector = choose_first_connector(context,\n+                                                 &parent_rewrite,\n+                                                 &rewrites[0],\n+                                                 &connector,\n+                                                 &subexpr_list,\n+                                                 extend);\n+\n+    if is_small_parent && rewrites.len() > 1 {\n+        let second_connector = choose_first_connector(context,\n+                                                      &rewrites[0],\n+                                                      &rewrites[1],\n+                                                      &connector,\n+                                                      &subexpr_list[0..subexpr_list.len() - 1],\n+                                                      false);\n+        wrap_str(format!(\"{}{}{}{}{}\",\n+                         parent_rewrite,\n+                         first_connector,\n+                         rewrites[0],\n+                         second_connector,\n+                         join_rewrites(&rewrites[1..],\n+                                       &subexpr_list[0..subexpr_list.len() - 1],\n+                                       &connector)),\n+                 context.config.max_width(),\n+                 shape)\n     } else {\n-        &*connector\n-    };\n+        wrap_str(format!(\"{}{}{}\",\n+                         parent_rewrite,\n+                         first_connector,\n+                         join_rewrites(&rewrites, &subexpr_list, &connector)),\n+                 context.config.max_width(),\n+                 shape)\n+    }\n+}\n \n-    wrap_str(format!(\"{}{}{}\",\n-                     parent_rewrite,\n-                     first_connector,\n-                     join_rewrites(&rewrites, &subexpr_list, &connector)),\n-             context.config.max_width(),\n-             shape)\n+fn is_extendable_parent(context: &RewriteContext, parent_str: &str) -> bool {\n+    context.config.chain_indent() == IndentStyle::Block &&\n+    parent_str.lines().last().map_or(false, |s| {\n+        s.trim()\n+            .chars()\n+            .all(|c| c == ')' || c == ']' || c == '}' || c == '?')\n+    })\n }\n \n // True if the chain is only `?`s.\n@@ -339,9 +359,8 @@ fn join_rewrites(rewrites: &[String], subexps: &[ast::Expr], connector: &str) ->\n // parens, braces, and brackets in its idiomatic formatting.\n fn is_block_expr(context: &RewriteContext, expr: &ast::Expr, repr: &str) -> bool {\n     match expr.node {\n-        ast::ExprKind::Call(..) => {\n-            context.config.fn_call_style() == IndentStyle::Block && repr.contains('\\n')\n-        }\n+        ast::ExprKind::Mac(..) |\n+        ast::ExprKind::Call(..) => context.use_block_indent() && repr.contains('\\n'),\n         ast::ExprKind::Struct(..) |\n         ast::ExprKind::While(..) |\n         ast::ExprKind::WhileLet(..) |\n@@ -474,6 +493,36 @@ fn is_continuable(expr: &ast::Expr) -> bool {\n     }\n }\n \n+fn is_try(expr: &ast::Expr) -> bool {\n+    match expr.node {\n+        ast::ExprKind::Try(..) => true,\n+        _ => false,\n+    }\n+}\n+\n+fn choose_first_connector<'a>(context: &RewriteContext,\n+                              parent_str: &str,\n+                              first_child_str: &str,\n+                              connector: &'a str,\n+                              subexpr_list: &[ast::Expr],\n+                              extend: bool)\n+                              -> &'a str {\n+    if subexpr_list.is_empty() {\n+        \"\"\n+    } else if extend || subexpr_list.last().map_or(false, is_try) ||\n+              is_extendable_parent(context, parent_str) {\n+        // 1 = \";\", being conservative here.\n+        if last_line_width(parent_str) + first_line_width(first_child_str) + 1 <=\n+           context.config.max_width() {\n+            \"\"\n+        } else {\n+            connector\n+        }\n+    } else {\n+        connector\n+    }\n+}\n+\n fn rewrite_method_call(method_name: ast::Ident,\n                        types: &[ptr::P<ast::Ty>],\n                        args: &[ptr::P<ast::Expr>],"}, {"sha": "c61b03b88d7911afca92db136456c555a5bb11a4", "filename": "src/config.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/130aa70e3a15d8e96a25bd894bb03602a5db3888/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130aa70e3a15d8e96a25bd894bb03602a5db3888/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=130aa70e3a15d8e96a25bd894bb03602a5db3888", "patch": "@@ -575,7 +575,8 @@ create_config! {\n     write_mode: WriteMode, WriteMode::Replace,\n         \"What Write Mode to use when none is supplied: Replace, Overwrite, Display, Diff, Coverage\";\n     condense_wildcard_suffixes: bool, false, \"Replace strings of _ wildcards by a single .. in \\\n-                                              tuple patterns\"\n+                                              tuple patterns\";\n+    combine_control_expr: bool, false, \"Combine control expressions with funciton calls.\"\n }\n \n #[cfg(test)]"}, {"sha": "46e030bd094bb3fc2b1a85596cec963e71b4e93e", "filename": "src/expr.rs", "status": "modified", "additions": 121, "deletions": 123, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/130aa70e3a15d8e96a25bd894bb03602a5db3888/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130aa70e3a15d8e96a25bd894bb03602a5db3888/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=130aa70e3a15d8e96a25bd894bb03602a5db3888", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use std::cmp::{Ordering, min};\n-use std::mem::swap;\n use std::ops::Deref;\n use std::iter::ExactSizeIterator;\n use std::fmt::Write;\n@@ -928,6 +927,7 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                                           cond,\n                                           self.matcher,\n                                           self.connector,\n+                                          self.keyword,\n                                           cond_shape))\n             }\n             None => String::new(),\n@@ -980,12 +980,14 @@ impl<'a> Rewrite for ControlFlow<'a> {\n         // for event in event\n         let between_kwd_cond = mk_sp(\n             context.codemap.span_after(self.span, self.keyword.trim()),\n-            self.pat\n-                .map_or(cond_span.lo, |p| if self.matcher.is_empty() {\n+            self.pat.map_or(\n+                cond_span.lo,\n+                |p| if self.matcher.is_empty() {\n                     p.span.lo\n                 } else {\n                     context.codemap.span_before(self.span, self.matcher.trim())\n-                }),\n+                },\n+            ),\n         );\n \n         let between_kwd_cond_comment = extract_comment(between_kwd_cond, context, shape);\n@@ -1375,7 +1377,7 @@ impl Rewrite for ast::Arm {\n             ast::ExprKind::Tup(..) => (true, &**body),\n             _ => (false, &**body),\n         };\n-        extend &= context.config.fn_call_style() == IndentStyle::Block;\n+        extend &= context.use_block_indent();\n \n         let comma = arm_comma(&context.config, body);\n         let alt_block_sep = String::from(\"\\n\") +\n@@ -1529,6 +1531,7 @@ fn rewrite_pat_expr(context: &RewriteContext,\n                     // Connecting piece between pattern and expression,\n                     // *without* trailing space.\n                     connector: &str,\n+                    keyword: &str,\n                     shape: Shape)\n                     -> Option<String> {\n     debug!(\"rewrite_pat_expr {:?} {:?} {:?}\", shape, pat, expr);\n@@ -1567,6 +1570,10 @@ fn rewrite_pat_expr(context: &RewriteContext,\n         }\n     }\n \n+    if pat.is_none() && keyword == \"if\" {\n+        return None;\n+    }\n+\n     let nested_indent = shape.indent.block_only().block_indent(context.config);\n \n     // The expression won't fit on the current line, jump to next.\n@@ -1691,17 +1698,17 @@ fn rewrite_call_inner(context: &RewriteContext,\n         .ok_or(Ordering::Greater)?;\n \n     let span_lo = context.codemap.span_after(span, \"(\");\n-    let new_span = mk_sp(span_lo, span.hi);\n+    let args_span = mk_sp(span_lo, span.hi);\n \n     let (extendable, list_str) = rewrite_call_args(context,\n                                                    args,\n-                                                   new_span,\n+                                                   args_span,\n                                                    nested_shape,\n                                                    one_line_width,\n                                                    force_trailing_comma)\n         .ok_or(Ordering::Less)?;\n \n-    if !use_block_indent(context) && need_block_indent(&list_str, nested_shape) && !extendable {\n+    if !context.use_block_indent() && need_block_indent(&list_str, nested_shape) && !extendable {\n         let mut new_context = context.clone();\n         new_context.use_block = true;\n         return rewrite_call_inner(&new_context,\n@@ -1746,41 +1753,54 @@ fn rewrite_call_args(context: &RewriteContext,\n     // Try letting the last argument overflow to the next line with block\n     // indentation. If its first line fits on one line with the other arguments,\n     // we format the function arguments horizontally.\n-    let overflow_last = can_be_overflowed(&item_context, args);\n-\n-    let mut orig_last = None;\n-    let mut placeholder = None;\n+    let tactic = try_overflow_last_arg(&item_context, &mut item_vec, args, shape, one_line_width);\n \n-    // Replace the last item with its first line to see if it fits with\n-    // first arguments.\n-    if overflow_last {\n-        let arg_shape = if use_block_indent(context) && is_extendable(args) {\n-            Shape {\n-                width: context.config.fn_call_width(),\n-                indent: shape.block().indent.block_unindent(context.config),\n-                offset: 0,\n-            }\n+    let fmt = ListFormatting {\n+        tactic: tactic,\n+        separator: \",\",\n+        trailing_separator: if force_trailing_comma {\n+            SeparatorTactic::Always\n+        } else if context.inside_macro || !context.use_block_indent() {\n+            SeparatorTactic::Never\n         } else {\n-            shape.block()\n-        };\n-        let rewrite = args.last().unwrap().rewrite(&item_context, arg_shape);\n-        swap(&mut item_vec[args.len() - 1].item, &mut orig_last);\n+            context.config.trailing_comma()\n+        },\n+        shape: shape,\n+        ends_with_newline: false,\n+        config: context.config,\n+    };\n \n-        if let Some(rewrite) = rewrite {\n-            let rewrite_first_line = Some(rewrite[..first_line_width(&rewrite)].to_owned());\n-            placeholder = Some(rewrite);\n+    write_list(&item_vec, &fmt).map(|args_str| (tactic != DefinitiveListTactic::Vertical, args_str))\n+}\n \n-            item_vec[args.len() - 1].item = rewrite_first_line;\n-        }\n-    }\n+fn try_overflow_last_arg(context: &RewriteContext,\n+                         item_vec: &mut Vec<ListItem>,\n+                         args: &[ptr::P<ast::Expr>],\n+                         shape: Shape,\n+                         one_line_width: usize)\n+                         -> DefinitiveListTactic {\n+    let overflow_last = can_be_overflowed(&context, args);\n \n-    let one_line_shape = Shape {\n-        width: one_line_width,\n-        ..shape\n+    // Replace the last item with its first line to see if it fits with\n+    // first arguments.\n+    let (orig_last, placeholder) = if overflow_last {\n+        let mut context = context.clone();\n+        match args[args.len() - 1].node {\n+            ast::ExprKind::MethodCall(..) => context.force_one_line_chain = true,\n+            _ => (),\n+        }\n+        last_arg_shape(&context, &item_vec, shape).map_or((None, None), |arg_shape| {\n+            rewrite_last_arg_with_overflow(&context,\n+                                           &args[args.len() - 1],\n+                                           &mut item_vec[args.len() - 1],\n+                                           arg_shape)\n+        })\n+    } else {\n+        (None, None)\n     };\n \n     let tactic =\n-        definitive_tactic(&item_vec,\n+        definitive_tactic(&*item_vec,\n                           ListTactic::LimitedHorizontalVertical(context.config.fn_call_width()),\n                           one_line_width);\n \n@@ -1796,100 +1816,78 @@ fn rewrite_call_args(context: &RewriteContext,\n         (false, _, _) => {}\n     }\n \n-    let mut fmt = ListFormatting {\n-        tactic: tactic,\n-        separator: \",\",\n-        trailing_separator: if force_trailing_comma {\n-            SeparatorTactic::Always\n-        } else if context.inside_macro || context.config.fn_call_style() == IndentStyle::Visual ||\n-                  args.len() <= 1 {\n-            SeparatorTactic::Never\n-        } else {\n-            context.config.trailing_comma()\n-        },\n-        shape: one_line_shape,\n-        ends_with_newline: false,\n-        config: context.config,\n-    };\n+    tactic\n+}\n \n-    let one_line_budget = min(one_line_width, context.config.fn_call_width());\n-    let almost_no_newline =\n-        item_vec\n-            .iter()\n-            .rev()\n-            .skip(1)\n-            .all(|item| item.item.as_ref().map_or(false, |s| !s.contains('\\n')));\n-    let extendable = almost_no_newline &&\n-                     item_vec.iter().fold(0, |acc, item| {\n-        acc + item.item.as_ref().map_or(0, |s| 2 + first_line_width(s))\n-    }) <= one_line_budget + 2;\n-\n-    let result = write_list(&item_vec, &fmt);\n-    let last_char_is_not_comma = result\n-        .as_ref()\n-        .map_or(false, |r| r.chars().last().unwrap_or(' ') != ',');\n-    match result {\n-        // If arguments do not fit in a single line and do not contain newline,\n-        // try to put it on the next line. Try this only when we are in block mode\n-        // and not rewriting macro.\n-        Some(ref s) if use_block_indent(context) && !context.inside_macro &&\n-                       ((!can_be_overflowed(context, args) && last_char_is_not_comma &&\n-                         s.contains('\\n')) ||\n-                        first_line_width(s) > one_line_budget) => {\n-            fmt.trailing_separator = SeparatorTactic::Vertical;\n-            fmt.tactic = DefinitiveListTactic::Vertical;\n-            write_list(&item_vec, &fmt).map(|rw| (false, rw))\n-        }\n-        rewrite @ _ => {\n-            rewrite.map(|rw| (extendable && (last_char_is_not_comma || force_trailing_comma), rw))\n-        }\n-    }\n+fn last_arg_shape(context: &RewriteContext, items: &Vec<ListItem>, shape: Shape) -> Option<Shape> {\n+    let overhead = items.iter().rev().skip(1).fold(0, |acc, i| {\n+        acc + i.item.as_ref().map_or(0, |s| first_line_width(&s))\n+    });\n+    let max_width = min(context.config.fn_call_width(), shape.width);\n+    let arg_indent = if context.use_block_indent() {\n+        shape.block().indent.block_unindent(context.config)\n+    } else {\n+        shape.block().indent\n+    };\n+    Some(Shape {\n+             width: try_opt!(max_width.checked_sub(overhead)),\n+             indent: arg_indent,\n+             offset: 0,\n+         })\n }\n \n-fn use_block_indent(context: &RewriteContext) -> bool {\n-    context.config.fn_call_style() == IndentStyle::Block || context.use_block\n+fn rewrite_last_arg_with_overflow(context: &RewriteContext,\n+                                  last_arg: &ptr::P<ast::Expr>,\n+                                  last_item: &mut ListItem,\n+                                  shape: Shape)\n+                                  -> (Option<String>, Option<String>) {\n+    let rewrite = last_arg.rewrite(context, shape);\n+    let orig_last = last_item.item.clone();\n+\n+    if let Some(rewrite) = rewrite {\n+        let rewrite_first_line = Some(rewrite[..first_line_width(&rewrite)].to_owned());\n+        last_item.item = rewrite_first_line;\n+        (orig_last, Some(rewrite))\n+    } else {\n+        (orig_last, None)\n+    }\n }\n \n fn can_be_overflowed(context: &RewriteContext, args: &[ptr::P<ast::Expr>]) -> bool {\n-    match args.last().map(|x| &x.node) {\n-        Some(&ast::ExprKind::Match(..)) => {\n-            (use_block_indent(context) && args.len() == 1) ||\n-            (context.config.fn_call_style() == IndentStyle::Visual && args.len() > 1)\n-        }\n-        Some(&ast::ExprKind::Block(..)) |\n-        Some(&ast::ExprKind::Closure(..)) => {\n-            use_block_indent(context) ||\n-            context.config.fn_call_style() == IndentStyle::Visual && args.len() > 1\n-        }\n-        Some(&ast::ExprKind::Call(..)) |\n-        Some(&ast::ExprKind::Mac(..)) |\n-        Some(&ast::ExprKind::Struct(..)) => use_block_indent(context) && args.len() == 1,\n-        Some(&ast::ExprKind::Tup(..)) => use_block_indent(context),\n-        _ => false,\n-    }\n+    args.last()\n+        .map_or(false, |x| can_be_overflowed_expr(context, &x, args.len()))\n }\n \n-fn is_extendable(args: &[ptr::P<ast::Expr>]) -> bool {\n-    if args.len() == 1 {\n-        match args[0].node {\n-            ast::ExprKind::Block(..) |\n-            ast::ExprKind::Call(..) |\n-            ast::ExprKind::Closure(..) |\n-            ast::ExprKind::Match(..) |\n-            ast::ExprKind::Mac(..) |\n-            ast::ExprKind::Struct(..) |\n-            ast::ExprKind::Tup(..) => true,\n-            _ => false,\n-        }\n-    } else if args.len() > 1 {\n-        match args[args.len() - 1].node {\n-            ast::ExprKind::Block(..) |\n-            ast::ExprKind::Closure(..) |\n-            ast::ExprKind::Tup(..) => true,\n-            _ => false,\n-        }\n-    } else {\n-        false\n+fn can_be_overflowed_expr(context: &RewriteContext, expr: &ast::Expr, args_len: usize) -> bool {\n+    match expr.node {\n+        ast::ExprKind::Match(..) => {\n+            (context.use_block_indent() && args_len == 1) ||\n+            (context.config.fn_call_style() == IndentStyle::Visual && args_len > 1)\n+        }\n+        ast::ExprKind::If(..) |\n+        ast::ExprKind::IfLet(..) |\n+        ast::ExprKind::ForLoop(..) |\n+        ast::ExprKind::Loop(..) |\n+        ast::ExprKind::While(..) |\n+        ast::ExprKind::WhileLet(..) => {\n+            context.config.combine_control_expr() && context.use_block_indent() && args_len == 1\n+        }\n+        ast::ExprKind::Block(..) |\n+        ast::ExprKind::Closure(..) => {\n+            context.use_block_indent() ||\n+            context.config.fn_call_style() == IndentStyle::Visual && args_len > 1\n+        }\n+        ast::ExprKind::Call(..) |\n+        ast::ExprKind::MethodCall(..) |\n+        ast::ExprKind::Mac(..) |\n+        ast::ExprKind::Struct(..) => context.use_block_indent() && args_len == 1,\n+        ast::ExprKind::Tup(..) => context.use_block_indent(),\n+        ast::ExprKind::AddrOf(_, ref expr) |\n+        ast::ExprKind::Box(ref expr) |\n+        ast::ExprKind::Try(ref expr) |\n+        ast::ExprKind::Unary(_, ref expr) |\n+        ast::ExprKind::Cast(ref expr, _) => can_be_overflowed_expr(context, expr, args_len),\n+        _ => false,\n     }\n }\n \n@@ -1899,7 +1897,7 @@ fn wrap_args_with_parens(context: &RewriteContext,\n                          shape: Shape,\n                          nested_shape: Shape)\n                          -> String {\n-    if !use_block_indent(context) || (context.inside_macro && !args_str.contains('\\n')) ||\n+    if !context.use_block_indent() || (context.inside_macro && !args_str.contains('\\n')) ||\n        is_extendable {\n         if context.config.spaces_within_parens() && args_str.len() > 0 {\n             format!(\"( {} )\", args_str)\n@@ -2096,7 +2094,7 @@ fn shape_from_fn_call_style(context: &RewriteContext,\n                             overhead: usize,\n                             offset: usize)\n                             -> Option<Shape> {\n-    if use_block_indent(context) {\n+    if context.use_block_indent() {\n         Some(shape.block().block_indent(context.config.tab_spaces()))\n     } else {\n         shape.visual_indent(offset).sub_width(overhead)"}, {"sha": "aa3ae8537af76e5b0e6c17c43bcb7ae6d68335f0", "filename": "src/filemap.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/130aa70e3a15d8e96a25bd894bb03602a5db3888/src%2Ffilemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130aa70e3a15d8e96a25bd894bb03602a5db3888/src%2Ffilemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffilemap.rs?ref=130aa70e3a15d8e96a25bd894bb03602a5db3888", "patch": "@@ -143,8 +143,9 @@ pub fn write_file<T>(text: &StringBuffer,\n             if let Ok((ori, fmt)) = source_and_formatted_text(text, filename, config) {\n                 let mismatch = make_diff(&ori, &fmt, 3);\n                 let has_diff = !mismatch.is_empty();\n-                print_diff(mismatch,\n-                           |line_num| format!(\"Diff in {} at line {}:\", filename, line_num));\n+                print_diff(mismatch, |line_num| {\n+                    format!(\"Diff in {} at line {}:\", filename, line_num)\n+                });\n                 return Ok(has_diff);\n             }\n         }"}, {"sha": "e5cc83aa3f9720d623c285279285b9603e38f66e", "filename": "src/items.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/130aa70e3a15d8e96a25bd894bb03602a5db3888/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130aa70e3a15d8e96a25bd894bb03602a5db3888/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=130aa70e3a15d8e96a25bd894bb03602a5db3888", "patch": "@@ -1176,21 +1176,23 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n         .unwrap_or(0);\n     let type_indent = indent + line_width;\n     // Try to fit the type on the same line\n-    let ty_str = try_opt!(ty.rewrite(context, Shape::legacy(budget, type_indent))\n-                              .or_else(|| {\n-        // The line was too short, try to put the type on the next line\n-\n-        // Remove the space after '='\n-        result.pop();\n-        let type_indent = indent.block_indent(context.config);\n-        result.push('\\n');\n-        result.push_str(&type_indent.to_string(context.config));\n-        let budget = try_opt!(context\n-                                  .config\n-                                  .max_width()\n-                                  .checked_sub(type_indent.width() + \";\".len()));\n+    let ty_str = try_opt!(\n         ty.rewrite(context, Shape::legacy(budget, type_indent))\n-    }));\n+            .or_else(|| {\n+                // The line was too short, try to put the type on the next line\n+\n+                // Remove the space after '='\n+                result.pop();\n+                let type_indent = indent.block_indent(context.config);\n+                result.push('\\n');\n+                result.push_str(&type_indent.to_string(context.config));\n+                let budget = try_opt!(context\n+                                          .config\n+                                          .max_width()\n+                                          .checked_sub(type_indent.width() + \";\".len()));\n+                ty.rewrite(context, Shape::legacy(budget, type_indent))\n+            })\n+    );\n     result.push_str(&ty_str);\n     result.push_str(\";\");\n     Some(result)"}, {"sha": "1635553eccd9ad590d3eb956e26e9dca607a94b1", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/130aa70e3a15d8e96a25bd894bb03602a5db3888/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130aa70e3a15d8e96a25bd894bb03602a5db3888/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=130aa70e3a15d8e96a25bd894bb03602a5db3888", "patch": "@@ -626,7 +626,7 @@ pub fn format_input<T: Write>(input: Input,\n                 return filemap::write_file(file, file_name, out, config);\n             }\n             Ok(false)\n-        }\n+        },\n     ) {\n         Ok((file_map, has_diff)) => {\n             if report.has_warnings() {"}, {"sha": "f99e236ac88e4c1a70e867310032ffbcb3f01956", "filename": "src/macros.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/130aa70e3a15d8e96a25bd894bb03602a5db3888/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130aa70e3a15d8e96a25bd894bb03602a5db3888/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=130aa70e3a15d8e96a25bd894bb03602a5db3888", "patch": "@@ -172,12 +172,12 @@ pub fn rewrite_macro(mac: &ast::Mac,\n         MacroStyle::Parens => {\n             // Format macro invocation as function call, forcing no trailing\n             // comma because not all macros support them.\n-            rewrite_call(context, &macro_name, &expr_vec, mac.span, shape).map(|rw| {\n-                match position {\n+            rewrite_call(context, &macro_name, &expr_vec, mac.span, shape).map(\n+                |rw| match position {\n                     MacroPosition::Item => format!(\"{};\", rw),\n                     _ => rw,\n-                }\n-            })\n+                },\n+            )\n         }\n         MacroStyle::Brackets => {\n             let mac_shape = try_opt!(shape.shrink_left(macro_name.len()));\n@@ -199,17 +199,13 @@ pub fn rewrite_macro(mac: &ast::Mac,\n             } else {\n                 // Format macro invocation as array literal.\n                 let rewrite =\n-                    try_opt!(rewrite_array(\n-                    expr_vec.iter().map(|x| &**x),\n-                    mk_sp(\n-                        context\n-                            .codemap\n-                            .span_after(mac.span, original_style.opener()),\n-                        mac.span.hi - BytePos(1),\n-                    ),\n-                    context,\n-                    mac_shape,\n-                ));\n+                    try_opt!(rewrite_array(expr_vec.iter().map(|x| &**x),\n+                                           mk_sp(context\n+                                                     .codemap\n+                                                     .span_after(mac.span, original_style.opener()),\n+                                               mac.span.hi - BytePos(1)),\n+                                           context,\n+                                           mac_shape));\n \n                 Some(format!(\"{}{}\", macro_name, rewrite))\n             }"}, {"sha": "57ebc332ac485a4ece626cd08502d37dc5828a67", "filename": "src/missed_spans.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/130aa70e3a15d8e96a25bd894bb03602a5db3888/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130aa70e3a15d8e96a25bd894bb03602a5db3888/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=130aa70e3a15d8e96a25bd894bb03602a5db3888", "patch": "@@ -22,8 +22,9 @@ impl<'a> FmtVisitor<'a> {\n     // TODO these format_missing methods are ugly. Refactor and add unit tests\n     // for the central whitespace stripping loop.\n     pub fn format_missing(&mut self, end: BytePos) {\n-        self.format_missing_inner(end,\n-                                  |this, last_snippet, _| this.buffer.push_str(last_snippet))\n+        self.format_missing_inner(end, |this, last_snippet, _| {\n+            this.buffer.push_str(last_snippet)\n+        })\n     }\n \n     pub fn format_missing_with_indent(&mut self, end: BytePos) {"}, {"sha": "5c1236104b520a70cf5380908e96fbdf89b51d64", "filename": "src/rewrite.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/130aa70e3a15d8e96a25bd894bb03602a5db3888/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130aa70e3a15d8e96a25bd894bb03602a5db3888/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=130aa70e3a15d8e96a25bd894bb03602a5db3888", "patch": "@@ -14,7 +14,7 @@ use syntax::codemap::{CodeMap, Span};\n use syntax::parse::ParseSess;\n \n use Shape;\n-use config::Config;\n+use config::{Config, IndentStyle};\n \n pub trait Rewrite {\n     /// Rewrite self into shape.\n@@ -32,10 +32,17 @@ pub struct RewriteContext<'a> {\n     // When `format_if_else_cond_comment` is true, unindent the comment on top\n     // of the `else` or `else if`.\n     pub is_if_else_block: bool,\n+    // When rewriting chain, veto going multi line except the last element\n+    pub force_one_line_chain: bool,\n }\n \n impl<'a> RewriteContext<'a> {\n     pub fn snippet(&self, span: Span) -> String {\n         self.codemap.span_to_snippet(span).unwrap()\n     }\n+\n+    /// Return true if we should use block indent style for rewriting function call.\n+    pub fn use_block_indent(&self) -> bool {\n+        self.config.fn_call_style() == IndentStyle::Block || self.use_block\n+    }\n }"}, {"sha": "17e9a467d1bb0355f960c07eb7475a203f17d4b7", "filename": "src/types.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/130aa70e3a15d8e96a25bd894bb03602a5db3888/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130aa70e3a15d8e96a25bd894bb03602a5db3888/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=130aa70e3a15d8e96a25bd894bb03602a5db3888", "patch": "@@ -376,13 +376,15 @@ impl Rewrite for ast::WherePredicate {\n                     // 6 = \"for<> \".len()\n                     let used_width = lifetime_str.len() + type_str.len() + colon.len() + 6;\n                     let budget = try_opt!(shape.width.checked_sub(used_width));\n-                    let bounds_str: String = try_opt!(bounds\n-                                                          .iter()\n-                                                          .map(|ty_bound| {\n-                        ty_bound.rewrite(context, Shape::legacy(budget, shape.indent + used_width))\n-                    })\n-                                                          .collect::<Option<Vec<_>>>())\n-                        .join(joiner);\n+                    let bounds_str: String = try_opt!(\n+                        bounds\n+                            .iter()\n+                            .map(|ty_bound| {\n+                                ty_bound.rewrite(context,\n+                                                 Shape::legacy(budget, shape.indent + used_width))\n+                            })\n+                            .collect::<Option<Vec<_>>>()\n+                    ).join(joiner);\n \n                     if context.config.spaces_within_angle_brackets() && lifetime_str.len() > 0 {\n                         format!(\"for< {} > {}{}{}\",\n@@ -400,13 +402,15 @@ impl Rewrite for ast::WherePredicate {\n                     };\n                     let used_width = type_str.len() + colon.len();\n                     let budget = try_opt!(shape.width.checked_sub(used_width));\n-                    let bounds_str: String = try_opt!(bounds\n-                                                          .iter()\n-                                                          .map(|ty_bound| {\n-                        ty_bound.rewrite(context, Shape::legacy(budget, shape.indent + used_width))\n-                    })\n-                                                          .collect::<Option<Vec<_>>>())\n-                        .join(joiner);\n+                    let bounds_str: String = try_opt!(\n+                        bounds\n+                            .iter()\n+                            .map(|ty_bound| {\n+                                ty_bound.rewrite(context,\n+                                                 Shape::legacy(budget, shape.indent + used_width))\n+                            })\n+                            .collect::<Option<Vec<_>>>()\n+                    ).join(joiner);\n \n                     format!(\"{}{}{}\", type_str, colon, bounds_str)\n                 }\n@@ -699,15 +703,16 @@ fn rewrite_bare_fn(bare_fn: &ast::BareFnTy,\n         // 6 = \"for<> \".len(), 4 = \"for<\".\n         // This doesn't work out so nicely for mutliline situation with lots of\n         // rightward drift. If that is a problem, we could use the list stuff.\n-        result.push_str(&try_opt!(bare_fn\n-                                      .lifetimes\n-                                      .iter()\n-                                      .map(|l| {\n-            l.rewrite(context,\n-                      Shape::legacy(try_opt!(shape.width.checked_sub(6)), shape.indent + 4))\n-        })\n-                                      .collect::<Option<Vec<_>>>())\n-                            .join(\", \"));\n+        result.push_str(&try_opt!(\n+            bare_fn\n+                .lifetimes\n+                .iter()\n+                .map(|l| {\n+                    l.rewrite(context,\n+                              Shape::legacy(try_opt!(shape.width.checked_sub(6)), shape.indent + 4))\n+                })\n+                .collect::<Option<Vec<_>>>()\n+        ).join(\", \"));\n         result.push_str(\"> \");\n     }\n "}, {"sha": "51ae96158360e2b916b179545a85f336e4ce4fbd", "filename": "src/visitor.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/130aa70e3a15d8e96a25bd894bb03602a5db3888/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130aa70e3a15d8e96a25bd894bb03602a5db3888/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=130aa70e3a15d8e96a25bd894bb03602a5db3888", "patch": "@@ -633,6 +633,7 @@ impl<'a> FmtVisitor<'a> {\n             inside_macro: false,\n             use_block: false,\n             is_if_else_block: false,\n+            force_one_line_chain: false,\n         }\n     }\n }"}, {"sha": "b36676e4c371c03db7f59b3954a71f9d9a051689", "filename": "tests/system.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/130aa70e3a15d8e96a25bd894bb03602a5db3888/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130aa70e3a15d8e96a25bd894bb03602a5db3888/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=130aa70e3a15d8e96a25bd894bb03602a5db3888", "patch": "@@ -201,8 +201,9 @@ fn print_mismatches(result: HashMap<String, Vec<Mismatch>>) {\n     let mut t = term::stdout().unwrap();\n \n     for (file_name, diff) in result {\n-        print_diff(diff,\n-                   |line_num| format!(\"\\nMismatch at {}:{}:\", file_name, line_num));\n+        print_diff(diff, |line_num| {\n+            format!(\"\\nMismatch at {}:{}:\", file_name, line_num)\n+        });\n     }\n \n     t.reset().unwrap();"}, {"sha": "298c79ae91a8a2be6ba1ab48795636efaf2662df", "filename": "tests/target/chains.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/130aa70e3a15d8e96a25bd894bb03602a5db3888/tests%2Ftarget%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130aa70e3a15d8e96a25bd894bb03602a5db3888/tests%2Ftarget%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains.rs?ref=130aa70e3a15d8e96a25bd894bb03602a5db3888", "patch": "@@ -147,12 +147,9 @@ fn try_shorthand() {\n         .0\n         .x;\n \n-    parameterized(f,\n-                  substs,\n-                  def_id,\n-                  Ns::Value,\n-                  &[],\n-                  |tcx| tcx.lookup_item_type(def_id).generics)?;\n+    parameterized(f, substs, def_id, Ns::Value, &[], |tcx| {\n+        tcx.lookup_item_type(def_id).generics\n+    })?;\n     fooooooooooooooooooooooooooo()?\n         .bar()?\n         .baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaz()?;"}, {"sha": "0d9ab24a6edc18baf92eb5d25351905e44c20397", "filename": "tests/target/configs-combine_control_expr-false.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/130aa70e3a15d8e96a25bd894bb03602a5db3888/tests%2Ftarget%2Fconfigs-combine_control_expr-false.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130aa70e3a15d8e96a25bd894bb03602a5db3888/tests%2Ftarget%2Fconfigs-combine_control_expr-false.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-combine_control_expr-false.rs?ref=130aa70e3a15d8e96a25bd894bb03602a5db3888", "patch": "@@ -0,0 +1,133 @@\n+// rustfmt-fn_call_style: Block\n+// rustfmt-combine_control_expr: false\n+// Combining openings and closings. See https://github.com/rust-lang-nursery/fmt-rfcs/issues/61.\n+\n+fn main() {\n+    // Call\n+    foo(bar(\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,\n+    ));\n+\n+    // Mac\n+    foo(foo!(\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,\n+    ));\n+\n+    // MethodCall\n+    foo(x.foo::<Bar, Baz>(\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,\n+    ));\n+\n+    // Block\n+    foo!({\n+        foo();\n+        bar();\n+    });\n+\n+    // Closure\n+    foo(|x| {\n+        let y = x + 1;\n+        y\n+    });\n+\n+    // Match\n+    foo(match opt {\n+        Some(x) => x,\n+        None => y,\n+    });\n+\n+    // Struct\n+    foo(Bar {\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,\n+    });\n+\n+    // If\n+    foo!(\n+        if x {\n+            foo();\n+        } else {\n+            bar();\n+        }\n+    );\n+\n+    // IfLet\n+    foo!(\n+        if let Some(..) = x {\n+            foo();\n+        } else {\n+            bar();\n+        }\n+    );\n+\n+    // While\n+    foo!(\n+        while x {\n+            foo();\n+            bar();\n+        }\n+    );\n+\n+    // WhileLet\n+    foo!(\n+        while let Some(..) = x {\n+            foo();\n+            bar();\n+        }\n+    );\n+\n+    // ForLoop\n+    foo!(\n+        for x in y {\n+            foo();\n+            bar();\n+        }\n+    );\n+\n+    // Loop\n+    foo!(\n+        loop {\n+            foo();\n+            bar();\n+        }\n+    );\n+\n+    // Tuple\n+    foo((\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,\n+    ));\n+\n+    // AddrOf\n+    foo(&bar(\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,\n+    ));\n+\n+    // Box\n+    foo(box Bar {\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,\n+    });\n+\n+    // Unary\n+    foo(!bar(\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,\n+    ));\n+\n+    // Try\n+    foo(bar(\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,\n+    )?);\n+\n+    // Cast\n+    foo(Bar {\n+        xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,\n+        xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,\n+    } as i64);\n+}"}, {"sha": "925d223353903ed26a4dd90cd8e7e1b4b52d2df7", "filename": "tests/target/configs-combine_control_expr-true.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/130aa70e3a15d8e96a25bd894bb03602a5db3888/tests%2Ftarget%2Fconfigs-combine_control_expr-true.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130aa70e3a15d8e96a25bd894bb03602a5db3888/tests%2Ftarget%2Fconfigs-combine_control_expr-true.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-combine_control_expr-true.rs?ref=130aa70e3a15d8e96a25bd894bb03602a5db3888", "patch": "@@ -0,0 +1,121 @@\n+// rustfmt-fn_call_style: Block\n+// rustfmt-combine_control_expr: true\n+// Combining openings and closings. See https://github.com/rust-lang-nursery/fmt-rfcs/issues/61.\n+\n+fn main() {\n+    // Call\n+    foo(bar(\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,\n+    ));\n+\n+    // Mac\n+    foo(foo!(\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,\n+    ));\n+\n+    // MethodCall\n+    foo(x.foo::<Bar, Baz>(\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,\n+    ));\n+\n+    // Block\n+    foo!({\n+        foo();\n+        bar();\n+    });\n+\n+    // Closure\n+    foo(|x| {\n+        let y = x + 1;\n+        y\n+    });\n+\n+    // Match\n+    foo(match opt {\n+        Some(x) => x,\n+        None => y,\n+    });\n+\n+    // Struct\n+    foo(Bar {\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,\n+    });\n+\n+    // If\n+    foo!(if x {\n+        foo();\n+    } else {\n+        bar();\n+    });\n+\n+    // IfLet\n+    foo!(if let Some(..) = x {\n+        foo();\n+    } else {\n+        bar();\n+    });\n+\n+    // While\n+    foo!(while x {\n+        foo();\n+        bar();\n+    });\n+\n+    // WhileLet\n+    foo!(while let Some(..) = x {\n+        foo();\n+        bar();\n+    });\n+\n+    // ForLoop\n+    foo!(for x in y {\n+        foo();\n+        bar();\n+    });\n+\n+    // Loop\n+    foo!(loop {\n+        foo();\n+        bar();\n+    });\n+\n+    // Tuple\n+    foo((\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,\n+    ));\n+\n+    // AddrOf\n+    foo(&bar(\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,\n+    ));\n+\n+    // Box\n+    foo(box Bar {\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,\n+    });\n+\n+    // Unary\n+    foo(!bar(\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,\n+    ));\n+\n+    // Try\n+    foo(bar(\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,\n+    )?);\n+\n+    // Cast\n+    foo(Bar {\n+        xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,\n+        xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,\n+    } as i64);\n+}"}, {"sha": "ddead8ce5a857043e2c2ddeb1ae58899a25e57fb", "filename": "tests/target/configs-fn_call_style-block.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/130aa70e3a15d8e96a25bd894bb03602a5db3888/tests%2Ftarget%2Fconfigs-fn_call_style-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130aa70e3a15d8e96a25bd894bb03602a5db3888/tests%2Ftarget%2Fconfigs-fn_call_style-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-fn_call_style-block.rs?ref=130aa70e3a15d8e96a25bd894bb03602a5db3888", "patch": "@@ -134,15 +134,14 @@ impl Cursor {\n }\n \n fn issue1581() {\n-    bootstrap.checks.register(\n-        \"PERSISTED_LOCATIONS\",\n-        move || if locations2.0.inner_mut.lock().poisoned {\n+    bootstrap.checks.register(\"PERSISTED_LOCATIONS\", move || {\n+        if locations2.0.inner_mut.lock().poisoned {\n             Check::new(\n                 State::Error,\n                 \"Persisted location storage is poisoned due to a write failure\",\n             )\n         } else {\n             Check::new(State::Healthy, \"Persisted location storage is healthy\")\n-        },\n-    );\n+        }\n+    });\n }"}, {"sha": "bdd07ffbd7401e0ec9d7bcd49e87b91f42de2fc4", "filename": "tests/target/hard-tabs.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/130aa70e3a15d8e96a25bd894bb03602a5db3888/tests%2Ftarget%2Fhard-tabs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130aa70e3a15d8e96a25bd894bb03602a5db3888/tests%2Ftarget%2Fhard-tabs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fhard-tabs.rs?ref=130aa70e3a15d8e96a25bd894bb03602a5db3888", "patch": "@@ -67,18 +67,18 @@ fn main() {\n \t}\n \n \tloong_func().quux(move || if true {\n-\t\t                  1\n-\t\t                 } else {\n-\t\t                  2\n-\t\t                 });\n+\t\t1\n+\t} else {\n+\t\t2\n+\t});\n \n \tfffffffffffffffffffffffffffffffffff(a, {\n \t\tSCRIPT_TASK_ROOT.with(|root| { *root.borrow_mut() = Some(&script_task); });\n \t});\n \ta.b.c.d();\n \n \tx().y(|| match cond() {\n-\t          true => (),\n-\t          false => (),\n-\t      });\n+\t\ttrue => (),\n+\t\tfalse => (),\n+\t});\n }"}, {"sha": "a2e3c30f3ac4ef048ecc3dc1aae73767b90d0583", "filename": "tests/target/nested-visual-block.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/130aa70e3a15d8e96a25bd894bb03602a5db3888/tests%2Ftarget%2Fnested-visual-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130aa70e3a15d8e96a25bd894bb03602a5db3888/tests%2Ftarget%2Fnested-visual-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fnested-visual-block.rs?ref=130aa70e3a15d8e96a25bd894bb03602a5db3888", "patch": "@@ -45,13 +45,16 @@ fn main() {\n     });\n \n     // #1581\n-    bootstrap.checks.register(\n-        \"PERSISTED_LOCATIONS\",\n-        move || if locations2.0.inner_mut.lock().poisoned {\n+    bootstrap\n+        .checks\n+        .register(\"PERSISTED_LOCATIONS\", move || if locations2\n+               .0\n+               .inner_mut\n+               .lock()\n+               .poisoned {\n             Check::new(State::Error,\n                        \"Persisted location storage is poisoned due to a write failure\")\n         } else {\n             Check::new(State::Healthy, \"Persisted location storage is healthy\")\n-        }\n-    );\n+        });\n }"}]}