{"sha": "426d098bd6a032cb03e61d4b3d091caeaecbd4d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyNmQwOThiZDZhMDMyY2IwM2U2MWQ0YjNkMDkxY2FlYWVjYmQ0ZDA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-04-12T14:58:01Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-04-12T14:58:01Z"}, "message": "internal: prepare for lazy diagnostics", "tree": {"sha": "eb54a5d4e72a875b072af5f266673c6265057f3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb54a5d4e72a875b072af5f266673c6265057f3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/426d098bd6a032cb03e61d4b3d091caeaecbd4d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/426d098bd6a032cb03e61d4b3d091caeaecbd4d0", "html_url": "https://github.com/rust-lang/rust/commit/426d098bd6a032cb03e61d4b3d091caeaecbd4d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/426d098bd6a032cb03e61d4b3d091caeaecbd4d0/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cae920a1bb827726aa142e5c81da9e6b0ca38d97", "url": "https://api.github.com/repos/rust-lang/rust/commits/cae920a1bb827726aa142e5c81da9e6b0ca38d97", "html_url": "https://github.com/rust-lang/rust/commit/cae920a1bb827726aa142e5c81da9e6b0ca38d97"}], "stats": {"total": 173, "additions": 96, "deletions": 77}, "files": [{"sha": "4f0b4a62e15365b23b5a3451649e1d22a42dcbeb", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 44, "deletions": 39, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/426d098bd6a032cb03e61d4b3d091caeaecbd4d0/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426d098bd6a032cb03e61d4b3d091caeaecbd4d0/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=426d098bd6a032cb03e61d4b3d091caeaecbd4d0", "patch": "@@ -25,7 +25,7 @@ use syntax::{\n use text_edit::TextEdit;\n use unlinked_file::UnlinkedFile;\n \n-use crate::{FileId, Label, SourceChange};\n+use crate::{Assist, AssistId, AssistKind, FileId, Label, SourceChange};\n \n use self::fixes::DiagnosticWithFix;\n \n@@ -35,7 +35,7 @@ pub struct Diagnostic {\n     pub message: String,\n     pub range: TextRange,\n     pub severity: Severity,\n-    pub fix: Option<Fix>,\n+    pub fix: Option<Assist>,\n     pub unused: bool,\n     pub code: Option<DiagnosticCode>,\n }\n@@ -56,7 +56,7 @@ impl Diagnostic {\n         }\n     }\n \n-    fn with_fix(self, fix: Option<Fix>) -> Self {\n+    fn with_fix(self, fix: Option<Assist>) -> Self {\n         Self { fix, ..self }\n     }\n \n@@ -69,21 +69,6 @@ impl Diagnostic {\n     }\n }\n \n-#[derive(Debug)]\n-pub struct Fix {\n-    pub label: Label,\n-    pub source_change: SourceChange,\n-    /// Allows to trigger the fix only when the caret is in the range given\n-    pub fix_trigger_range: TextRange,\n-}\n-\n-impl Fix {\n-    fn new(label: &str, source_change: SourceChange, fix_trigger_range: TextRange) -> Self {\n-        let label = Label::new(label);\n-        Self { label, source_change, fix_trigger_range }\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone)]\n pub enum Severity {\n     Error,\n@@ -261,7 +246,8 @@ fn check_unnecessary_braces_in_use_statement(\n \n         acc.push(\n             Diagnostic::hint(use_range, \"Unnecessary braces in use statement\".to_string())\n-                .with_fix(Some(Fix::new(\n+                .with_fix(Some(fix(\n+                    \"remove_braces\",\n                     \"Remove unnecessary braces\",\n                     SourceChange::from_text_edit(file_id, edit),\n                     use_range,\n@@ -284,6 +270,17 @@ fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n     None\n }\n \n+fn fix(id: &'static str, label: &str, source_change: SourceChange, target: TextRange) -> Assist {\n+    assert!(!id.contains(' '));\n+    Assist {\n+        id: AssistId(id, AssistKind::QuickFix),\n+        label: Label::new(label),\n+        group: None,\n+        target,\n+        source_change: Some(source_change),\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};\n@@ -308,20 +305,21 @@ mod tests {\n             .unwrap();\n         let fix = diagnostic.fix.unwrap();\n         let actual = {\n-            let file_id = *fix.source_change.source_file_edits.keys().next().unwrap();\n+            let source_change = fix.source_change.unwrap();\n+            let file_id = *source_change.source_file_edits.keys().next().unwrap();\n             let mut actual = analysis.file_text(file_id).unwrap().to_string();\n \n-            for edit in fix.source_change.source_file_edits.values() {\n+            for edit in source_change.source_file_edits.values() {\n                 edit.apply(&mut actual);\n             }\n             actual\n         };\n \n         assert_eq_text!(&after, &actual);\n         assert!(\n-            fix.fix_trigger_range.contains_inclusive(file_position.offset),\n+            fix.target.contains_inclusive(file_position.offset),\n             \"diagnostic fix range {:?} does not touch cursor position {:?}\",\n-            fix.fix_trigger_range,\n+            fix.target,\n             file_position.offset\n         );\n     }\n@@ -665,24 +663,31 @@ fn test_fn() {\n                         range: 0..8,\n                         severity: Error,\n                         fix: Some(\n-                            Fix {\n+                            Assist {\n+                                id: AssistId(\n+                                    \"create_module\",\n+                                    QuickFix,\n+                                ),\n                                 label: \"Create module\",\n-                                source_change: SourceChange {\n-                                    source_file_edits: {},\n-                                    file_system_edits: [\n-                                        CreateFile {\n-                                            dst: AnchoredPathBuf {\n-                                                anchor: FileId(\n-                                                    0,\n-                                                ),\n-                                                path: \"foo.rs\",\n+                                group: None,\n+                                target: 0..8,\n+                                source_change: Some(\n+                                    SourceChange {\n+                                        source_file_edits: {},\n+                                        file_system_edits: [\n+                                            CreateFile {\n+                                                dst: AnchoredPathBuf {\n+                                                    anchor: FileId(\n+                                                        0,\n+                                                    ),\n+                                                    path: \"foo.rs\",\n+                                                },\n+                                                initial_contents: \"\",\n                                             },\n-                                            initial_contents: \"\",\n-                                        },\n-                                    ],\n-                                    is_snippet: false,\n-                                },\n-                                fix_trigger_range: 0..8,\n+                                        ],\n+                                        is_snippet: false,\n+                                    },\n+                                ),\n                             },\n                         ),\n                         unused: false,"}, {"sha": "2b1787f9b15a59ede185fed51c43273a003309c6", "filename": "crates/ide/src/diagnostics/field_shorthand.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/426d098bd6a032cb03e61d4b3d091caeaecbd4d0/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffield_shorthand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426d098bd6a032cb03e61d4b3d091caeaecbd4d0/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffield_shorthand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffield_shorthand.rs?ref=426d098bd6a032cb03e61d4b3d091caeaecbd4d0", "patch": "@@ -5,7 +5,7 @@ use ide_db::{base_db::FileId, source_change::SourceChange};\n use syntax::{ast, match_ast, AstNode, SyntaxNode};\n use text_edit::TextEdit;\n \n-use crate::{Diagnostic, Fix};\n+use crate::{diagnostics::fix, Diagnostic};\n \n pub(super) fn check(acc: &mut Vec<Diagnostic>, file_id: FileId, node: &SyntaxNode) {\n     match_ast! {\n@@ -47,7 +47,8 @@ fn check_expr_field_shorthand(\n         let field_range = record_field.syntax().text_range();\n         acc.push(\n             Diagnostic::hint(field_range, \"Shorthand struct initialization\".to_string()).with_fix(\n-                Some(Fix::new(\n+                Some(fix(\n+                    \"use_expr_field_shorthand\",\n                     \"Use struct shorthand initialization\",\n                     SourceChange::from_text_edit(file_id, edit),\n                     field_range,\n@@ -86,7 +87,8 @@ fn check_pat_field_shorthand(\n \n         let field_range = record_pat_field.syntax().text_range();\n         acc.push(Diagnostic::hint(field_range, \"Shorthand struct pattern\".to_string()).with_fix(\n-            Some(Fix::new(\n+            Some(fix(\n+                \"use_pat_field_shorthand\",\n                 \"Use struct field shorthand\",\n                 SourceChange::from_text_edit(file_id, edit),\n                 field_range,"}, {"sha": "69cf5288c3022da299e9eb3927c4177750e732cc", "filename": "crates/ide/src/diagnostics/fixes.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/426d098bd6a032cb03e61d4b3d091caeaecbd4d0/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426d098bd6a032cb03e61d4b3d091caeaecbd4d0/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs?ref=426d098bd6a032cb03e61d4b3d091caeaecbd4d0", "patch": "@@ -20,20 +20,21 @@ use syntax::{\n };\n use text_edit::TextEdit;\n \n-use crate::{diagnostics::Fix, references::rename::rename_with_semantics, FilePosition};\n+use crate::{diagnostics::fix, references::rename::rename_with_semantics, Assist, FilePosition};\n \n /// A [Diagnostic] that potentially has a fix available.\n ///\n /// [Diagnostic]: hir::diagnostics::Diagnostic\n pub(crate) trait DiagnosticWithFix: Diagnostic {\n-    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Fix>;\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Assist>;\n }\n \n impl DiagnosticWithFix for UnresolvedModule {\n-    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Fix> {\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Assist> {\n         let root = sema.db.parse_or_expand(self.file)?;\n         let unresolved_module = self.decl.to_node(&root);\n-        Some(Fix::new(\n+        Some(fix(\n+            \"create_module\",\n             \"Create module\",\n             FileSystemEdit::CreateFile {\n                 dst: AnchoredPathBuf {\n@@ -49,7 +50,7 @@ impl DiagnosticWithFix for UnresolvedModule {\n }\n \n impl DiagnosticWithFix for NoSuchField {\n-    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Fix> {\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Assist> {\n         let root = sema.db.parse_or_expand(self.file)?;\n         missing_record_expr_field_fix(\n             &sema,\n@@ -60,7 +61,7 @@ impl DiagnosticWithFix for NoSuchField {\n }\n \n impl DiagnosticWithFix for MissingFields {\n-    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Fix> {\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Assist> {\n         // Note that although we could add a diagnostics to\n         // fill the missing tuple field, e.g :\n         // `struct A(usize);`\n@@ -86,7 +87,8 @@ impl DiagnosticWithFix for MissingFields {\n                 .into_text_edit(&mut builder);\n             builder.finish()\n         };\n-        Some(Fix::new(\n+        Some(fix(\n+            \"fill_missing_fields\",\n             \"Fill struct fields\",\n             SourceChange::from_text_edit(self.file.original_file(sema.db), edit),\n             sema.original_range(&field_list_parent.syntax()).range,\n@@ -95,20 +97,20 @@ impl DiagnosticWithFix for MissingFields {\n }\n \n impl DiagnosticWithFix for MissingOkOrSomeInTailExpr {\n-    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Fix> {\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Assist> {\n         let root = sema.db.parse_or_expand(self.file)?;\n         let tail_expr = self.expr.to_node(&root);\n         let tail_expr_range = tail_expr.syntax().text_range();\n         let replacement = format!(\"{}({})\", self.required, tail_expr.syntax());\n         let edit = TextEdit::replace(tail_expr_range, replacement);\n         let source_change = SourceChange::from_text_edit(self.file.original_file(sema.db), edit);\n         let name = if self.required == \"Ok\" { \"Wrap with Ok\" } else { \"Wrap with Some\" };\n-        Some(Fix::new(name, source_change, tail_expr_range))\n+        Some(fix(\"wrap_tail_expr\", name, source_change, tail_expr_range))\n     }\n }\n \n impl DiagnosticWithFix for RemoveThisSemicolon {\n-    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Fix> {\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Assist> {\n         let root = sema.db.parse_or_expand(self.file)?;\n \n         let semicolon = self\n@@ -123,12 +125,12 @@ impl DiagnosticWithFix for RemoveThisSemicolon {\n         let edit = TextEdit::delete(semicolon);\n         let source_change = SourceChange::from_text_edit(self.file.original_file(sema.db), edit);\n \n-        Some(Fix::new(\"Remove this semicolon\", source_change, semicolon))\n+        Some(fix(\"remove_semicolon\", \"Remove this semicolon\", source_change, semicolon))\n     }\n }\n \n impl DiagnosticWithFix for IncorrectCase {\n-    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Fix> {\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Assist> {\n         let root = sema.db.parse_or_expand(self.file)?;\n         let name_node = self.ident.to_node(&root);\n \n@@ -140,12 +142,12 @@ impl DiagnosticWithFix for IncorrectCase {\n             rename_with_semantics(sema, file_position, &self.suggested_text).ok()?;\n \n         let label = format!(\"Rename to {}\", self.suggested_text);\n-        Some(Fix::new(&label, rename_changes, frange.range))\n+        Some(fix(\"change_case\", &label, rename_changes, frange.range))\n     }\n }\n \n impl DiagnosticWithFix for ReplaceFilterMapNextWithFindMap {\n-    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Fix> {\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Assist> {\n         let root = sema.db.parse_or_expand(self.file)?;\n         let next_expr = self.next_expr.to_node(&root);\n         let next_call = ast::MethodCallExpr::cast(next_expr.syntax().clone())?;\n@@ -163,7 +165,8 @@ impl DiagnosticWithFix for ReplaceFilterMapNextWithFindMap {\n \n         let source_change = SourceChange::from_text_edit(self.file.original_file(sema.db), edit);\n \n-        Some(Fix::new(\n+        Some(fix(\n+            \"replace_with_find_map\",\n             \"Replace filter_map(..).next() with find_map()\",\n             source_change,\n             trigger_range,\n@@ -175,7 +178,7 @@ fn missing_record_expr_field_fix(\n     sema: &Semantics<RootDatabase>,\n     usage_file_id: FileId,\n     record_expr_field: &ast::RecordExprField,\n-) -> Option<Fix> {\n+) -> Option<Assist> {\n     let record_lit = ast::RecordExpr::cast(record_expr_field.syntax().parent()?.parent()?)?;\n     let def_id = sema.resolve_variant(record_lit)?;\n     let module;\n@@ -233,7 +236,12 @@ fn missing_record_expr_field_fix(\n         def_file_id,\n         TextEdit::insert(last_field_syntax.text_range().end(), new_field),\n     );\n-    return Some(Fix::new(\"Create field\", source_change, record_expr_field.syntax().text_range()));\n+    return Some(fix(\n+        \"create_field\",\n+        \"Create field\",\n+        source_change,\n+        record_expr_field.syntax().text_range(),\n+    ));\n \n     fn record_field_list(field_def_list: ast::FieldList) -> Option<ast::RecordFieldList> {\n         match field_def_list {"}, {"sha": "5482b7287d5a9dee82a1432cb7776eb3f00d3d30", "filename": "crates/ide/src/diagnostics/unlinked_file.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/426d098bd6a032cb03e61d4b3d091caeaecbd4d0/crates%2Fide%2Fsrc%2Fdiagnostics%2Funlinked_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426d098bd6a032cb03e61d4b3d091caeaecbd4d0/crates%2Fide%2Fsrc%2Fdiagnostics%2Funlinked_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Funlinked_file.rs?ref=426d098bd6a032cb03e61d4b3d091caeaecbd4d0", "patch": "@@ -16,9 +16,10 @@ use syntax::{\n };\n use text_edit::TextEdit;\n \n-use crate::Fix;\n-\n-use super::fixes::DiagnosticWithFix;\n+use crate::{\n+    diagnostics::{fix, fixes::DiagnosticWithFix},\n+    Assist,\n+};\n \n // Diagnostic: unlinked-file\n //\n@@ -49,7 +50,7 @@ impl Diagnostic for UnlinkedFile {\n }\n \n impl DiagnosticWithFix for UnlinkedFile {\n-    fn fix(&self, sema: &hir::Semantics<RootDatabase>) -> Option<Fix> {\n+    fn fix(&self, sema: &hir::Semantics<RootDatabase>) -> Option<Assist> {\n         // If there's an existing module that could add a `mod` item to include the unlinked file,\n         // suggest that as a fix.\n \n@@ -100,7 +101,7 @@ fn make_fix(\n     parent_file_id: FileId,\n     new_mod_name: &str,\n     added_file_id: FileId,\n-) -> Option<Fix> {\n+) -> Option<Assist> {\n     fn is_outline_mod(item: &ast::Item) -> bool {\n         matches!(item, ast::Item::Module(m) if m.item_list().is_none())\n     }\n@@ -152,7 +153,8 @@ fn make_fix(\n \n     let edit = builder.finish();\n     let trigger_range = db.parse(added_file_id).tree().syntax().text_range();\n-    Some(Fix::new(\n+    Some(fix(\n+        \"add_mod_declaration\",\n         &format!(\"Insert `{}`\", mod_decl),\n         SourceChange::from_text_edit(parent_file_id, edit),\n         trigger_range,"}, {"sha": "0615b26d316641000dd3c8b97c3374195cb6bcc3", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/426d098bd6a032cb03e61d4b3d091caeaecbd4d0/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426d098bd6a032cb03e61d4b3d091caeaecbd4d0/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=426d098bd6a032cb03e61d4b3d091caeaecbd4d0", "patch": "@@ -69,7 +69,7 @@ use crate::display::ToNav;\n pub use crate::{\n     annotations::{Annotation, AnnotationConfig, AnnotationKind},\n     call_hierarchy::CallItem,\n-    diagnostics::{Diagnostic, DiagnosticsConfig, Fix, Severity},\n+    diagnostics::{Diagnostic, DiagnosticsConfig, Severity},\n     display::navigation_target::NavigationTarget,\n     expand_macro::ExpandedMacro,\n     file_structure::{StructureNode, StructureNodeKind},"}, {"sha": "107685c631ed03ea372fe55550b06444b73773cb", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/426d098bd6a032cb03e61d4b3d091caeaecbd4d0/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426d098bd6a032cb03e61d4b3d091caeaecbd4d0/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=426d098bd6a032cb03e61d4b3d091caeaecbd4d0", "patch": "@@ -1039,18 +1039,20 @@ fn add_quick_fixes(\n     for fix in diagnostics\n         .into_iter()\n         .filter_map(|d| d.fix)\n-        .filter(|fix| fix.fix_trigger_range.intersect(frange.range).is_some())\n+        .filter(|fix| fix.target.intersect(frange.range).is_some())\n     {\n-        let edit = to_proto::snippet_workspace_edit(&snap, fix.source_change)?;\n-        let action = lsp_ext::CodeAction {\n-            title: fix.label.to_string(),\n-            group: None,\n-            kind: Some(CodeActionKind::QUICKFIX),\n-            edit: Some(edit),\n-            is_preferred: Some(false),\n-            data: None,\n-        };\n-        acc.push(action);\n+        if let Some(source_change) = fix.source_change {\n+            let edit = to_proto::snippet_workspace_edit(&snap, source_change)?;\n+            let action = lsp_ext::CodeAction {\n+                title: fix.label.to_string(),\n+                group: None,\n+                kind: Some(CodeActionKind::QUICKFIX),\n+                edit: Some(edit),\n+                is_preferred: Some(false),\n+                data: None,\n+            };\n+            acc.push(action);\n+        }\n     }\n \n     for fix in snap.check_fixes.get(&frange.file_id).into_iter().flatten() {"}]}