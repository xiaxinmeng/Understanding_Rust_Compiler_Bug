{"sha": "6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlODA2YmRlZmRlOTFhZjEwMjU2N2VmNGI1ZGJkM2NjZjBjNWMyZWM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-08T01:26:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-08T01:26:58Z"}, "message": "rollup merge of #20721: japaric/snap\n\nConflicts:\n\tsrc/libcollections/vec.rs\n\tsrc/libcore/fmt/mod.rs\n\tsrc/librustc/lint/builtin.rs\n\tsrc/librustc/session/config.rs\n\tsrc/librustc_trans/trans/base.rs\n\tsrc/librustc_trans/trans/context.rs\n\tsrc/librustc_trans/trans/type_.rs\n\tsrc/librustc_typeck/check/_match.rs\n\tsrc/librustdoc/html/format.rs\n\tsrc/libsyntax/std_inject.rs\n\tsrc/libsyntax/util/interner.rs\n\tsrc/test/compile-fail/mut-pattern-mismatched.rs", "tree": {"sha": "b8627ad2c80976f618b661ec14695f6a322ad1b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8627ad2c80976f618b661ec14695f6a322ad1b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "html_url": "https://github.com/rust-lang/rust/commit/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6a7dc5528a9a9ac36867bbca2a6044b7be5bce2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6a7dc5528a9a9ac36867bbca2a6044b7be5bce2", "html_url": "https://github.com/rust-lang/rust/commit/f6a7dc5528a9a9ac36867bbca2a6044b7be5bce2"}, {"sha": "7d72719efc25c6cdb8963c187e93df646ba65245", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d72719efc25c6cdb8963c187e93df646ba65245", "html_url": "https://github.com/rust-lang/rust/commit/7d72719efc25c6cdb8963c187e93df646ba65245"}], "stats": {"total": 4916, "additions": 2421, "deletions": 2495}, "files": [{"sha": "5de93c52029226503abbeee5d715f139e36057ca", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -908,8 +908,7 @@ fn check_error_patterns(props: &TestProps,\n     }\n     if done { return; }\n \n-    let missing_patterns =\n-        props.error_patterns.index(&(next_err_idx..));\n+    let missing_patterns = &props.error_patterns[next_err_idx..];\n     if missing_patterns.len() == 1u {\n         fatal_proc_rec(format!(\"error pattern '{}' not found!\",\n                               missing_patterns[0]).as_slice(),"}, {"sha": "e922feff02bd271cef4be0de0707526ea26aecb0", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -330,7 +330,7 @@ impl Bitv {\n \n         if extra_bytes > 0 {\n             let mut last_word = 0u32;\n-            for (i, &byte) in bytes.index(&((complete_words*4)..)).iter().enumerate() {\n+            for (i, &byte) in bytes[(complete_words*4)..].iter().enumerate() {\n                 last_word |= (reverse_bits(byte) as u32) << (i * 8);\n             }\n             bitv.storage.push(last_word);"}, {"sha": "c3d226758683767deaba45e4811692744076fbae", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -556,7 +556,7 @@ impl<T> RingBuf<T> {\n             let buf = self.buffer_as_slice();\n             if contiguous {\n                 let (empty, buf) = buf.split_at(0);\n-                (buf.index(&(self.tail..self.head)), empty)\n+                (&buf[self.tail..self.head], empty)\n             } else {\n                 let (mid, right) = buf.split_at(self.tail);\n                 let (left, _) = mid.split_at(self.head);"}, {"sha": "fdc551f5b1938d1d83d9a0fe2ff7123d2f03c867", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -55,7 +55,7 @@\n //! #![feature(slicing_syntax)]\n //! fn main() {\n //!     let numbers = [0i, 1i, 2i];\n-//!     let last_numbers = numbers.index(&(1..3));\n+//!     let last_numbers = &numbers[1..3];\n //!     // last_numbers is now &[1i, 2i]\n //! }\n //! ```\n@@ -98,7 +98,7 @@ use core::iter::{range, range_step, MultiplicativeIterator};\n use core::marker::Sized;\n use core::mem::size_of;\n use core::mem;\n-use core::ops::{FnMut, FullRange, Index, IndexMut};\n+use core::ops::{FnMut, FullRange};\n use core::option::Option::{self, Some, None};\n use core::ptr::PtrExt;\n use core::ptr;\n@@ -1065,12 +1065,12 @@ impl ElementSwaps {\n \n #[unstable = \"trait is unstable\"]\n impl<T> BorrowFrom<Vec<T>> for [T] {\n-    fn borrow_from(owned: &Vec<T>) -> &[T] { owned.index(&FullRange) }\n+    fn borrow_from(owned: &Vec<T>) -> &[T] { &owned[] }\n }\n \n #[unstable = \"trait is unstable\"]\n impl<T> BorrowFromMut<Vec<T>> for [T] {\n-    fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { owned.index_mut(&FullRange) }\n+    fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { &mut owned[] }\n }\n \n #[unstable = \"trait is unstable\"]\n@@ -1400,7 +1400,6 @@ mod tests {\n     use core::prelude::{Ord, FullRange};\n     use core::default::Default;\n     use core::mem;\n-    use core::ops::Index;\n     use std::iter::RandomAccessIterator;\n     use std::rand::{Rng, thread_rng};\n     use std::rc::Rc;\n@@ -1611,15 +1610,15 @@ mod tests {\n \n         // Test on stack.\n         let vec_stack: &[_] = &[1i, 2, 3];\n-        let v_b = vec_stack.index(&(1u..3u)).to_vec();\n+        let v_b = vec_stack[1u..3u].to_vec();\n         assert_eq!(v_b.len(), 2u);\n         let v_b = v_b.as_slice();\n         assert_eq!(v_b[0], 2);\n         assert_eq!(v_b[1], 3);\n \n         // Test `Box<[T]>`\n         let vec_unique = vec![1i, 2, 3, 4, 5, 6];\n-        let v_d = vec_unique.index(&(1u..6u)).to_vec();\n+        let v_d = vec_unique[1u..6u].to_vec();\n         assert_eq!(v_d.len(), 5u);\n         let v_d = v_d.as_slice();\n         assert_eq!(v_d[0], 2);\n@@ -1632,21 +1631,21 @@ mod tests {\n     #[test]\n     fn test_slice_from() {\n         let vec: &[int] = &[1, 2, 3, 4];\n-        assert_eq!(vec.index(&(0..)), vec);\n+        assert_eq!(&vec[0..], vec);\n         let b: &[int] = &[3, 4];\n-        assert_eq!(vec.index(&(2..)), b);\n+        assert_eq!(&vec[2..], b);\n         let b: &[int] = &[];\n-        assert_eq!(vec.index(&(4..)), b);\n+        assert_eq!(&vec[4..], b);\n     }\n \n     #[test]\n     fn test_slice_to() {\n         let vec: &[int] = &[1, 2, 3, 4];\n-        assert_eq!(vec.index(&(0..4)), vec);\n+        assert_eq!(&vec[0..4], vec);\n         let b: &[int] = &[1, 2];\n-        assert_eq!(vec.index(&(0..2)), b);\n+        assert_eq!(&vec[0..2], b);\n         let b: &[int] = &[];\n-        assert_eq!(vec.index(&(0..0)), b);\n+        assert_eq!(&vec[0..0], b);\n     }\n \n \n@@ -2572,7 +2571,7 @@ mod tests {\n         }\n         assert_eq!(cnt, 3);\n \n-        for f in v.index(&(1..3)).iter() {\n+        for f in v[1..3].iter() {\n             assert!(*f == Foo);\n             cnt += 1;\n         }"}, {"sha": "ccf654ac0a048a93860f585977c52e2830a15cf5", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -386,7 +386,7 @@ macro_rules! utf8_acc_cont_byte {\n \n #[unstable = \"trait is unstable\"]\n impl BorrowFrom<String> for str {\n-    fn borrow_from(owned: &String) -> &str { owned.index(&FullRange) }\n+    fn borrow_from(owned: &String) -> &str { &owned[] }\n }\n \n #[unstable = \"trait is unstable\"]\n@@ -464,7 +464,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     #[unstable = \"this functionality may be moved to libunicode\"]\n     fn nfd_chars<'a>(&'a self) -> Decompositions<'a> {\n         Decompositions {\n-            iter: self.index(&FullRange).chars(),\n+            iter: self[].chars(),\n             buffer: Vec::new(),\n             sorted: false,\n             kind: Canonical\n@@ -477,7 +477,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     #[unstable = \"this functionality may be moved to libunicode\"]\n     fn nfkd_chars<'a>(&'a self) -> Decompositions<'a> {\n         Decompositions {\n-            iter: self.index(&FullRange).chars(),\n+            iter: self[].chars(),\n             buffer: Vec::new(),\n             sorted: false,\n             kind: Compatible\n@@ -525,7 +525,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn contains(&self, pat: &str) -> bool {\n-        core_str::StrExt::contains(self.index(&FullRange), pat)\n+        core_str::StrExt::contains(&self[], pat)\n     }\n \n     /// Returns true if a string contains a char pattern.\n@@ -541,7 +541,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"might get removed in favour of a more generic contains()\"]\n     fn contains_char<P: CharEq>(&self, pat: P) -> bool {\n-        core_str::StrExt::contains_char(self.index(&FullRange), pat)\n+        core_str::StrExt::contains_char(&self[], pat)\n     }\n \n     /// An iterator over the characters of `self`. Note, this iterates\n@@ -555,7 +555,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn chars(&self) -> Chars {\n-        core_str::StrExt::chars(self.index(&FullRange))\n+        core_str::StrExt::chars(&self[])\n     }\n \n     /// An iterator over the bytes of `self`\n@@ -568,13 +568,13 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn bytes(&self) -> Bytes {\n-        core_str::StrExt::bytes(self.index(&FullRange))\n+        core_str::StrExt::bytes(&self[])\n     }\n \n     /// An iterator over the characters of `self` and their byte offsets.\n     #[stable]\n     fn char_indices(&self) -> CharIndices {\n-        core_str::StrExt::char_indices(self.index(&FullRange))\n+        core_str::StrExt::char_indices(&self[])\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -597,7 +597,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn split<P: CharEq>(&self, pat: P) -> Split<P> {\n-        core_str::StrExt::split(self.index(&FullRange), pat)\n+        core_str::StrExt::split(&self[], pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -624,7 +624,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn splitn<P: CharEq>(&self, count: uint, pat: P) -> SplitN<P> {\n-        core_str::StrExt::splitn(self.index(&FullRange), count, pat)\n+        core_str::StrExt::splitn(&self[], count, pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -653,7 +653,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"might get removed\"]\n     fn split_terminator<P: CharEq>(&self, pat: P) -> SplitTerminator<P> {\n-        core_str::StrExt::split_terminator(self.index(&FullRange), pat)\n+        core_str::StrExt::split_terminator(&self[], pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -674,7 +674,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn rsplitn<P: CharEq>(&self, count: uint, pat: P) -> RSplitN<P> {\n-        core_str::StrExt::rsplitn(self.index(&FullRange), count, pat)\n+        core_str::StrExt::rsplitn(&self[], count, pat)\n     }\n \n     /// An iterator over the start and end indices of the disjoint\n@@ -699,7 +699,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"might have its iterator type changed\"]\n     fn match_indices<'a>(&'a self, pat: &'a str) -> MatchIndices<'a> {\n-        core_str::StrExt::match_indices(self.index(&FullRange), pat)\n+        core_str::StrExt::match_indices(&self[], pat)\n     }\n \n     /// An iterator over the substrings of `self` separated by the pattern `sep`.\n@@ -715,7 +715,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"might get removed in the future in favor of a more generic split()\"]\n     fn split_str<'a>(&'a self, pat: &'a str) -> SplitStr<'a> {\n-        core_str::StrExt::split_str(self.index(&FullRange), pat)\n+        core_str::StrExt::split_str(&self[], pat)\n     }\n \n     /// An iterator over the lines of a string (subsequences separated\n@@ -731,7 +731,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn lines(&self) -> Lines {\n-        core_str::StrExt::lines(self.index(&FullRange))\n+        core_str::StrExt::lines(&self[])\n     }\n \n     /// An iterator over the lines of a string, separated by either\n@@ -747,7 +747,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn lines_any(&self) -> LinesAny {\n-        core_str::StrExt::lines_any(self.index(&FullRange))\n+        core_str::StrExt::lines_any(&self[])\n     }\n \n     /// Returns a slice of the given string from the byte range\n@@ -782,7 +782,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"use slice notation [a..b] instead\"]\n     fn slice(&self, begin: uint, end: uint) -> &str {\n-        core_str::StrExt::slice(self.index(&FullRange), begin, end)\n+        core_str::StrExt::slice(&self[], begin, end)\n     }\n \n     /// Returns a slice of the string from `begin` to its end.\n@@ -795,7 +795,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// See also `slice`, `slice_to` and `slice_chars`.\n     #[unstable = \"use slice notation [a..] instead\"]\n     fn slice_from(&self, begin: uint) -> &str {\n-        core_str::StrExt::slice_from(self.index(&FullRange), begin)\n+        core_str::StrExt::slice_from(&self[], begin)\n     }\n \n     /// Returns a slice of the string from the beginning to byte\n@@ -809,7 +809,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// See also `slice`, `slice_from` and `slice_chars`.\n     #[unstable = \"use slice notation [0..a] instead\"]\n     fn slice_to(&self, end: uint) -> &str {\n-        core_str::StrExt::slice_to(self.index(&FullRange), end)\n+        core_str::StrExt::slice_to(&self[], end)\n     }\n \n     /// Returns a slice of the string from the character range\n@@ -837,7 +837,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"may have yet to prove its worth\"]\n     fn slice_chars(&self, begin: uint, end: uint) -> &str {\n-        core_str::StrExt::slice_chars(self.index(&FullRange), begin, end)\n+        core_str::StrExt::slice_chars(&self[], begin, end)\n     }\n \n     /// Takes a bytewise (not UTF-8) slice from a string.\n@@ -848,7 +848,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// the entire slice as well.\n     #[stable]\n     unsafe fn slice_unchecked(&self, begin: uint, end: uint) -> &str {\n-        core_str::StrExt::slice_unchecked(self.index(&FullRange), begin, end)\n+        core_str::StrExt::slice_unchecked(&self[], begin, end)\n     }\n \n     /// Returns true if the pattern `pat` is a prefix of the string.\n@@ -860,7 +860,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn starts_with(&self, pat: &str) -> bool {\n-        core_str::StrExt::starts_with(self.index(&FullRange), pat)\n+        core_str::StrExt::starts_with(&self[], pat)\n     }\n \n     /// Returns true if the pattern `pat` is a suffix of the string.\n@@ -872,7 +872,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn ends_with(&self, pat: &str) -> bool {\n-        core_str::StrExt::ends_with(self.index(&FullRange), pat)\n+        core_str::StrExt::ends_with(&self[], pat)\n     }\n \n     /// Returns a string with all pre- and suffixes that match\n@@ -892,7 +892,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn trim_matches<P: CharEq>(&self, pat: P) -> &str {\n-        core_str::StrExt::trim_matches(self.index(&FullRange), pat)\n+        core_str::StrExt::trim_matches(&self[], pat)\n     }\n \n     /// Returns a string with all prefixes that match\n@@ -912,7 +912,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn trim_left_matches<P: CharEq>(&self, pat: P) -> &str {\n-        core_str::StrExt::trim_left_matches(self.index(&FullRange), pat)\n+        core_str::StrExt::trim_left_matches(&self[], pat)\n     }\n \n     /// Returns a string with all suffixes that match\n@@ -932,7 +932,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn trim_right_matches<P: CharEq>(&self, pat: P) -> &str {\n-        core_str::StrExt::trim_right_matches(self.index(&FullRange), pat)\n+        core_str::StrExt::trim_right_matches(&self[], pat)\n     }\n \n     /// Check that `index`-th byte lies at the start and/or end of a\n@@ -960,7 +960,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"naming is uncertain with container conventions\"]\n     fn is_char_boundary(&self, index: uint) -> bool {\n-        core_str::StrExt::is_char_boundary(self.index(&FullRange), index)\n+        core_str::StrExt::is_char_boundary(&self[], index)\n     }\n \n     /// Pluck a character out of a string and return the index of the next\n@@ -1018,7 +1018,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     #[unstable = \"naming is uncertain with container conventions\"]\n     fn char_range_at(&self, start: uint) -> CharRange {\n-        core_str::StrExt::char_range_at(self.index(&FullRange), start)\n+        core_str::StrExt::char_range_at(&self[], start)\n     }\n \n     /// Given a byte position and a str, return the previous char and its position.\n@@ -1033,7 +1033,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// If `i` is not an index following a valid UTF-8 character.\n     #[unstable = \"naming is uncertain with container conventions\"]\n     fn char_range_at_reverse(&self, start: uint) -> CharRange {\n-        core_str::StrExt::char_range_at_reverse(self.index(&FullRange), start)\n+        core_str::StrExt::char_range_at_reverse(&self[], start)\n     }\n \n     /// Plucks the character starting at the `i`th byte of a string.\n@@ -1053,7 +1053,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     #[unstable = \"naming is uncertain with container conventions\"]\n     fn char_at(&self, i: uint) -> char {\n-        core_str::StrExt::char_at(self.index(&FullRange), i)\n+        core_str::StrExt::char_at(&self[], i)\n     }\n \n     /// Plucks the character ending at the `i`th byte of a string.\n@@ -1064,7 +1064,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// If `i` is not an index following a valid UTF-8 character.\n     #[unstable = \"naming is uncertain with container conventions\"]\n     fn char_at_reverse(&self, i: uint) -> char {\n-        core_str::StrExt::char_at_reverse(self.index(&FullRange), i)\n+        core_str::StrExt::char_at_reverse(&self[], i)\n     }\n \n     /// Work with the byte buffer of a string as a byte slice.\n@@ -1076,7 +1076,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn as_bytes(&self) -> &[u8] {\n-        core_str::StrExt::as_bytes(self.index(&FullRange))\n+        core_str::StrExt::as_bytes(&self[])\n     }\n \n     /// Returns the byte index of the first character of `self` that\n@@ -1104,7 +1104,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn find<P: CharEq>(&self, pat: P) -> Option<uint> {\n-        core_str::StrExt::find(self.index(&FullRange), pat)\n+        core_str::StrExt::find(&self[], pat)\n     }\n \n     /// Returns the byte index of the last character of `self` that\n@@ -1132,7 +1132,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn rfind<P: CharEq>(&self, pat: P) -> Option<uint> {\n-        core_str::StrExt::rfind(self.index(&FullRange), pat)\n+        core_str::StrExt::rfind(&self[], pat)\n     }\n \n     /// Returns the byte index of the first matching substring\n@@ -1156,7 +1156,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"might get removed in favor of a more generic find in the future\"]\n     fn find_str(&self, needle: &str) -> Option<uint> {\n-        core_str::StrExt::find_str(self.index(&FullRange), needle)\n+        core_str::StrExt::find_str(&self[], needle)\n     }\n \n     /// Retrieves the first character from a string slice and returns\n@@ -1179,7 +1179,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"awaiting conventions about shifting and slices\"]\n     fn slice_shift_char(&self) -> Option<(char, &str)> {\n-        core_str::StrExt::slice_shift_char(self.index(&FullRange))\n+        core_str::StrExt::slice_shift_char(&self[])\n     }\n \n     /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n@@ -1198,7 +1198,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"awaiting convention about comparability of arbitrary slices\"]\n     fn subslice_offset(&self, inner: &str) -> uint {\n-        core_str::StrExt::subslice_offset(self.index(&FullRange), inner)\n+        core_str::StrExt::subslice_offset(&self[], inner)\n     }\n \n     /// Return an unsafe pointer to the strings buffer.\n@@ -1209,13 +1209,13 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     #[stable]\n     #[inline]\n     fn as_ptr(&self) -> *const u8 {\n-        core_str::StrExt::as_ptr(self.index(&FullRange))\n+        core_str::StrExt::as_ptr(&self[])\n     }\n \n     /// Return an iterator of `u16` over the string encoded as UTF-16.\n     #[unstable = \"this functionality may only be provided by libunicode\"]\n     fn utf16_units(&self) -> Utf16Units {\n-        Utf16Units { encoder: Utf16Encoder::new(self.index(&FullRange).chars()) }\n+        Utf16Units { encoder: Utf16Encoder::new(self[].chars()) }\n     }\n \n     /// Return the number of bytes in this string\n@@ -1229,7 +1229,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     #[stable]\n     #[inline]\n     fn len(&self) -> uint {\n-        core_str::StrExt::len(self.index(&FullRange))\n+        core_str::StrExt::len(&self[])\n     }\n \n     /// Returns true if this slice contains no bytes\n@@ -1242,7 +1242,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     #[inline]\n     #[stable]\n     fn is_empty(&self) -> bool {\n-        core_str::StrExt::is_empty(self.index(&FullRange))\n+        core_str::StrExt::is_empty(&self[])\n     }\n \n     /// Parse this string into the specified type.\n@@ -1256,7 +1256,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     #[inline]\n     #[unstable = \"this method was just created\"]\n     fn parse<F: FromStr>(&self) -> Option<F> {\n-        core_str::StrExt::parse(self.index(&FullRange))\n+        core_str::StrExt::parse(&self[])\n     }\n \n     /// Returns an iterator over the\n@@ -1280,7 +1280,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"this functionality may only be provided by libunicode\"]\n     fn graphemes(&self, is_extended: bool) -> Graphemes {\n-        UnicodeStr::graphemes(self.index(&FullRange), is_extended)\n+        UnicodeStr::graphemes(&self[], is_extended)\n     }\n \n     /// Returns an iterator over the grapheme clusters of self and their byte offsets.\n@@ -1295,7 +1295,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"this functionality may only be provided by libunicode\"]\n     fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n-        UnicodeStr::grapheme_indices(self.index(&FullRange), is_extended)\n+        UnicodeStr::grapheme_indices(&self[], is_extended)\n     }\n \n     /// An iterator over the words of a string (subsequences separated\n@@ -1311,7 +1311,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn words(&self) -> Words {\n-        UnicodeStr::words(self.index(&FullRange))\n+        UnicodeStr::words(&self[])\n     }\n \n     /// Returns a string's displayed width in columns, treating control\n@@ -1325,25 +1325,25 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// `is_cjk` = `false`) if the locale is unknown.\n     #[unstable = \"this functionality may only be provided by libunicode\"]\n     fn width(&self, is_cjk: bool) -> uint {\n-        UnicodeStr::width(self.index(&FullRange), is_cjk)\n+        UnicodeStr::width(&self[], is_cjk)\n     }\n \n     /// Returns a string with leading and trailing whitespace removed.\n     #[stable]\n     fn trim(&self) -> &str {\n-        UnicodeStr::trim(self.index(&FullRange))\n+        UnicodeStr::trim(&self[])\n     }\n \n     /// Returns a string with leading whitespace removed.\n     #[stable]\n     fn trim_left(&self) -> &str {\n-        UnicodeStr::trim_left(self.index(&FullRange))\n+        UnicodeStr::trim_left(&self[])\n     }\n \n     /// Returns a string with trailing whitespace removed.\n     #[stable]\n     fn trim_right(&self) -> &str {\n-        UnicodeStr::trim_right(self.index(&FullRange))\n+        UnicodeStr::trim_right(&self[])\n     }\n }\n "}, {"sha": "1bb0be05b1e82e51b956aa6542e9ec19db0f880d", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -168,7 +168,7 @@ impl String {\n \n         if i > 0 {\n             unsafe {\n-                res.as_mut_vec().push_all(v.index(&(0..i)))\n+                res.as_mut_vec().push_all(&v[0..i])\n             };\n         }\n \n@@ -185,7 +185,7 @@ impl String {\n             macro_rules! error { () => ({\n                 unsafe {\n                     if subseqidx != i_ {\n-                        res.as_mut_vec().push_all(v.index(&(subseqidx..i_)));\n+                        res.as_mut_vec().push_all(&v[subseqidx..i_]);\n                     }\n                     subseqidx = i;\n                     res.as_mut_vec().push_all(REPLACEMENT);\n@@ -254,7 +254,7 @@ impl String {\n         }\n         if subseqidx < total {\n             unsafe {\n-                res.as_mut_vec().push_all(v.index(&(subseqidx..total)))\n+                res.as_mut_vec().push_all(&v[subseqidx..total])\n             };\n         }\n         Cow::Owned(res)\n@@ -852,21 +852,21 @@ impl ops::Index<ops::Range<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &str {\n-        &self.index(&FullRange)[*index]\n+        &self[][*index]\n     }\n }\n impl ops::Index<ops::RangeTo<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n-        &self.index(&FullRange)[*index]\n+        &self[][*index]\n     }\n }\n impl ops::Index<ops::RangeFrom<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n-        &self.index(&FullRange)[*index]\n+        &self[][*index]\n     }\n }\n impl ops::Index<ops::FullRange> for String {\n@@ -882,7 +882,7 @@ impl ops::Deref for String {\n     type Target = str;\n \n     fn deref<'a>(&'a self) -> &'a str {\n-        unsafe { mem::transmute(self.vec.index(&FullRange)) }\n+        unsafe { mem::transmute(&self.vec[]) }\n     }\n }\n "}, {"sha": "d9344d130b23ce097b98f830c6b285c4577cd0da", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -1178,7 +1178,7 @@ impl<T:Clone> Clone for Vec<T> {\n \n         // self.len <= other.len due to the truncate above, so the\n         // slice here is always in-bounds.\n-        let slice = other.index(&(self.len()..));\n+        let slice = &other[self.len()..];\n         self.push_all(slice);\n     }\n }\n@@ -2031,7 +2031,7 @@ mod tests {\n         v.push(());\n         assert_eq!(v.iter_mut().count(), 4);\n \n-        for &() in v.iter_mut() {}\n+        for &mut () in v.iter_mut() {}\n         unsafe { v.set_len(0); }\n         assert_eq!(v.iter_mut().count(), 0);\n     }"}, {"sha": "0cea0b3d88e143a69a05b17d7beec5ec44fff99f", "filename": "src/libcore/array.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -18,7 +18,7 @@ use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n use fmt;\n use marker::Copy;\n-use ops::{Deref, FullRange, Index};\n+use ops::{Deref, FullRange};\n use option::Option;\n \n // macro for implementing n-ary tuple functions and operations\n@@ -35,19 +35,19 @@ macro_rules! array_impls {\n             #[unstable = \"waiting for Show to stabilize\"]\n             impl<T:fmt::Show> fmt::Show for [T; $N] {\n                 fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                    fmt::Show::fmt(&self.index(&FullRange), f)\n+                    fmt::Show::fmt(&&self[], f)\n                 }\n             }\n \n             #[stable]\n             impl<A, B> PartialEq<[B; $N]> for [A; $N] where A: PartialEq<B> {\n                 #[inline]\n                 fn eq(&self, other: &[B; $N]) -> bool {\n-                    self.index(&FullRange) == other.index(&FullRange)\n+                    &self[] == &other[]\n                 }\n                 #[inline]\n                 fn ne(&self, other: &[B; $N]) -> bool {\n-                    self.index(&FullRange) != other.index(&FullRange)\n+                    &self[] != &other[]\n                 }\n             }\n \n@@ -58,11 +58,11 @@ macro_rules! array_impls {\n             {\n                 #[inline(always)]\n                 fn eq(&self, other: &Rhs) -> bool {\n-                    PartialEq::eq(self.index(&FullRange), &**other)\n+                    PartialEq::eq(&self[], &**other)\n                 }\n                 #[inline(always)]\n                 fn ne(&self, other: &Rhs) -> bool {\n-                    PartialEq::ne(self.index(&FullRange), &**other)\n+                    PartialEq::ne(&self[], &**other)\n                 }\n             }\n \n@@ -73,11 +73,11 @@ macro_rules! array_impls {\n             {\n                 #[inline(always)]\n                 fn eq(&self, other: &[B; $N]) -> bool {\n-                    PartialEq::eq(&**self, other.index(&FullRange))\n+                    PartialEq::eq(&**self, &other[])\n                 }\n                 #[inline(always)]\n                 fn ne(&self, other: &[B; $N]) -> bool {\n-                    PartialEq::ne(&**self, other.index(&FullRange))\n+                    PartialEq::ne(&**self, &other[])\n                 }\n             }\n \n@@ -88,31 +88,31 @@ macro_rules! array_impls {\n             impl<T:PartialOrd> PartialOrd for [T; $N] {\n                 #[inline]\n                 fn partial_cmp(&self, other: &[T; $N]) -> Option<Ordering> {\n-                    PartialOrd::partial_cmp(&self.index(&FullRange), &other.index(&FullRange))\n+                    PartialOrd::partial_cmp(&&self[], &&other[])\n                 }\n                 #[inline]\n                 fn lt(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::lt(&self.index(&FullRange), &other.index(&FullRange))\n+                    PartialOrd::lt(&&self[], &&other[])\n                 }\n                 #[inline]\n                 fn le(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::le(&self.index(&FullRange), &other.index(&FullRange))\n+                    PartialOrd::le(&&self[], &&other[])\n                 }\n                 #[inline]\n                 fn ge(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::ge(&self.index(&FullRange), &other.index(&FullRange))\n+                    PartialOrd::ge(&&self[], &&other[])\n                 }\n                 #[inline]\n                 fn gt(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::gt(&self.index(&FullRange), &other.index(&FullRange))\n+                    PartialOrd::gt(&&self[], &&other[])\n                 }\n             }\n \n             #[stable]\n             impl<T:Ord> Ord for [T; $N] {\n                 #[inline]\n                 fn cmp(&self, other: &[T; $N]) -> Ordering {\n-                    Ord::cmp(&self.index(&FullRange), &other.index(&FullRange))\n+                    Ord::cmp(&&self[], &&other[])\n                 }\n             }\n         )+"}, {"sha": "0ffcb014c2877f558f6b9e4dc6f41e6b894fa416", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -20,7 +20,7 @@ use fmt;\n use iter::{IteratorExt, range};\n use num::{cast, Float, ToPrimitive};\n use num::FpCategory as Fp;\n-use ops::{FnOnce, Index};\n+use ops::FnOnce;\n use result::Result::Ok;\n use slice::{self, SliceExt};\n use str::{self, StrExt};\n@@ -332,5 +332,5 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n         }\n     }\n \n-    f(unsafe { str::from_utf8_unchecked(buf.index(&(0..end))) })\n+    f(unsafe { str::from_utf8_unchecked(&buf[0..end]) })\n }"}, {"sha": "69df413a88c0dec8922df209e89f4e46565c2d7a", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -21,7 +21,7 @@ use mem;\n use option::Option;\n use option::Option::{Some, None};\n use result::Result::Ok;\n-use ops::{Deref, FnOnce, Index};\n+use ops::{Deref, FnOnce};\n use result;\n use slice::SliceExt;\n use slice;\n@@ -425,7 +425,7 @@ impl<'a> Formatter<'a> {\n             for c in sign.into_iter() {\n                 let mut b = [0; 4];\n                 let n = c.encode_utf8(&mut b).unwrap_or(0);\n-                let b = unsafe { str::from_utf8_unchecked(b.index(&(0..n))) };\n+                let b = unsafe { str::from_utf8_unchecked(&b[0..n]) };\n                 try!(f.buf.write_str(b));\n             }\n             if prefixed { f.buf.write_str(prefix) }\n@@ -533,7 +533,7 @@ impl<'a> Formatter<'a> {\n \n         let mut fill = [0u8; 4];\n         let len = self.fill.encode_utf8(&mut fill).unwrap_or(0);\n-        let fill = unsafe { str::from_utf8_unchecked(fill.index(&(..len))) };\n+        let fill = unsafe { str::from_utf8_unchecked(&fill[..len]) };\n \n         for _ in range(0, pre_pad) {\n             try!(self.buf.write_str(fill));\n@@ -668,7 +668,7 @@ impl String for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         let mut utf8 = [0u8; 4];\n         let amt = self.encode_utf8(&mut utf8).unwrap_or(0);\n-        let s: &str = unsafe { mem::transmute(utf8.index(&(0..amt))) };\n+        let s: &str = unsafe { mem::transmute(&utf8[0..amt]) };\n         String::fmt(s, f)\n     }\n }"}, {"sha": "1df6f8452258bb23c5e3e56de6cbe224f1d6a745", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -16,7 +16,6 @@\n \n use fmt;\n use iter::IteratorExt;\n-use ops::Index;\n use num::{Int, cast};\n use slice::SliceExt;\n use str;\n@@ -62,7 +61,7 @@ trait GenericRadix {\n                 if x == zero { break };                   // No more digits left to accumulate.\n             }\n         }\n-        let buf = unsafe { str::from_utf8_unchecked(buf.index(&(curr..))) };\n+        let buf = unsafe { str::from_utf8_unchecked(&buf[curr..]) };\n         f.pad_integral(is_positive, self.prefix(), buf)\n     }\n }"}, {"sha": "eae466266d69e29d18e235ef5a661546ce42db8f", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -2344,7 +2344,7 @@ impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n ///\n /// // This iterator will yield up to the last Fibonacci number before the max value of `u32`.\n /// // You can simply change `u32` to `u64` in this line if you want higher values than that.\n-/// let mut fibonacci = Unfold::new((Some(0u32), Some(1u32)), |&(ref mut x2, ref mut x1)| {\n+/// let mut fibonacci = Unfold::new((Some(0u32), Some(1u32)), |&mut (ref mut x2, ref mut x1)| {\n ///     // Attempt to get the next Fibonacci number\n ///     // `x1` will be `None` if previously overflowed.\n ///     let next = match (*x2, *x1) {"}, {"sha": "91fed8a31bd40b086faa86aed422446318c20c37", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -24,7 +24,7 @@ use iter::IteratorExt;\n use marker::Copy;\n use mem::size_of;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n-use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr, Index};\n+use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::Option;\n use option::Option::{Some, None};\n use str::{FromStr, StrExt};\n@@ -1577,7 +1577,7 @@ macro_rules! from_str_radix_float_impl {\n                         };\n \n                         // Parse the exponent as decimal integer\n-                        let src = src.index(&(offset..));\n+                        let src = &src[offset..];\n                         let (is_positive, exp) = match src.slice_shift_char() {\n                             Some(('-', src)) => (false, src.parse::<uint>()),\n                             Some(('+', src)) => (true,  src.parse::<uint>()),"}, {"sha": "24a20fbc0661ef657fc860fdb47d246ff5f396be", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -534,7 +534,7 @@ impl<T> Option<T> {\n     /// ```\n     /// let mut x = Some(4u);\n     /// match x.iter_mut().next() {\n-    ///     Some(&ref mut v) => *v = 42u,\n+    ///     Some(&mut ref mut v) => *v = 42u,\n     ///     None => {},\n     /// }\n     /// assert_eq!(x, Some(42));"}, {"sha": "7868ec67c8a3adfa915b3d90cd7a17c17f86f29b", "filename": "src/libcore/result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -383,8 +383,8 @@ impl<T, E> Result<T, E> {\n     /// ```\n     /// fn mutate(r: &mut Result<int, int>) {\n     ///     match r.as_mut() {\n-    ///         Ok(&ref mut v) => *v = 42,\n-    ///         Err(&ref mut e) => *e = 0,\n+    ///         Ok(&mut ref mut v) => *v = 42,\n+    ///         Err(&mut ref mut e) => *e = 0,\n     ///     }\n     /// }\n     ///\n@@ -529,7 +529,7 @@ impl<T, E> Result<T, E> {\n     /// ```\n     /// let mut x: Result<uint, &str> = Ok(7);\n     /// match x.iter_mut().next() {\n-    ///     Some(&ref mut x) => *x = 40,\n+    ///     Some(&mut ref mut x) => *x = 40,\n     ///     None => {},\n     /// }\n     /// assert_eq!(x, Ok(40));"}, {"sha": "6c62bfda1fecc98d0d9c3c97ab00d5bbd2930c5e", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -159,7 +159,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn split_at(&self, mid: uint) -> (&[T], &[T]) {\n-        (self.index(&(0..mid)), self.index(&(mid..)))\n+        (&self[0..mid], &self[mid..])\n     }\n \n     #[inline]\n@@ -236,11 +236,11 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn tail(&self) -> &[T] { self.index(&(1..)) }\n+    fn tail(&self) -> &[T] { &self[1..] }\n \n     #[inline]\n     fn init(&self) -> &[T] {\n-        self.index(&(0..(self.len() - 1)))\n+        &self[0..(self.len() - 1)]\n     }\n \n     #[inline]\n@@ -443,13 +443,13 @@ impl<T> SliceExt for [T] {\n     #[inline]\n     fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq {\n         let n = needle.len();\n-        self.len() >= n && needle == self.index(&(0..n))\n+        self.len() >= n && needle == &self[0..n]\n     }\n \n     #[inline]\n     fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq {\n         let (m, n) = (self.len(), needle.len());\n-        m >= n && needle == self.index(&((m-n)..))\n+        m >= n && needle == &self[(m-n)..]\n     }\n \n     #[unstable]\n@@ -972,8 +972,8 @@ impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n         match self.v.iter().position(|x| (self.pred)(x)) {\n             None => self.finish(),\n             Some(idx) => {\n-                let ret = Some(self.v.index(&(0..idx)));\n-                self.v = self.v.index(&((idx + 1)..));\n+                let ret = Some(&self.v[0..idx]);\n+                self.v = &self.v[(idx + 1)..];\n                 ret\n             }\n         }\n@@ -998,8 +998,8 @@ impl<'a, T, P> DoubleEndedIterator for Split<'a, T, P> where P: FnMut(&T) -> boo\n         match self.v.iter().rposition(|x| (self.pred)(x)) {\n             None => self.finish(),\n             Some(idx) => {\n-                let ret = Some(self.v.index(&((idx + 1)..)));\n-                self.v = self.v.index(&(0..idx));\n+                let ret = Some(&self.v[(idx + 1)..]);\n+                self.v = &self.v[0..idx];\n                 ret\n             }\n         }\n@@ -1195,8 +1195,8 @@ impl<'a, T> Iterator for Windows<'a, T> {\n         if self.size > self.v.len() {\n             None\n         } else {\n-            let ret = Some(self.v.index(&(0..self.size)));\n-            self.v = self.v.index(&(1..));\n+            let ret = Some(&self.v[0..self.size]);\n+            self.v = &self.v[1..];\n             ret\n         }\n     }\n@@ -1283,7 +1283,7 @@ impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n             let mut hi = lo + self.size;\n             if hi < lo || hi > self.v.len() { hi = self.v.len(); }\n \n-            Some(self.v.index(&(lo..hi)))\n+            Some(&self.v[lo..hi])\n         } else {\n             None\n         }"}, {"sha": "6051c68b116ba1d808912582fa3c21f90a48c21f", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -26,7 +26,7 @@ use iter::{Map, Iterator, IteratorExt, DoubleEndedIterator};\n use marker::Sized;\n use mem;\n use num::Int;\n-use ops::{Fn, FnMut, Index};\n+use ops::{Fn, FnMut};\n use option::Option::{self, None, Some};\n use ptr::PtrExt;\n use raw::{Repr, Slice};\n@@ -580,7 +580,7 @@ impl NaiveSearcher {\n \n     fn next(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(uint, uint)> {\n         while self.position + needle.len() <= haystack.len() {\n-            if haystack.index(&(self.position .. self.position + needle.len())) == needle {\n+            if &haystack[self.position .. self.position + needle.len()] == needle {\n                 let match_pos = self.position;\n                 self.position += needle.len(); // add 1 for all matches\n                 return Some((match_pos, match_pos + needle.len()));\n@@ -701,10 +701,10 @@ impl TwoWaySearcher {\n         //\n         // What's going on is we have some critical factorization (u, v) of the\n         // needle, and we want to determine whether u is a suffix of\n-        // v.index(&(0..period)). If it is, we use \"Algorithm CP1\". Otherwise we use\n+        // &v[0..period]. If it is, we use \"Algorithm CP1\". Otherwise we use\n         // \"Algorithm CP2\", which is optimized for when the period of the needle\n         // is large.\n-        if needle.index(&(0..crit_pos)) == needle.index(&(period.. period + crit_pos)) {\n+        if &needle[0..crit_pos] == &needle[period.. period + crit_pos] {\n             TwoWaySearcher {\n                 crit_pos: crit_pos,\n                 period: period,\n@@ -1412,13 +1412,13 @@ impl StrExt for str {\n     #[inline]\n     fn starts_with(&self, needle: &str) -> bool {\n         let n = needle.len();\n-        self.len() >= n && needle.as_bytes() == self.as_bytes().index(&(0..n))\n+        self.len() >= n && needle.as_bytes() == &self.as_bytes()[0..n]\n     }\n \n     #[inline]\n     fn ends_with(&self, needle: &str) -> bool {\n         let (m, n) = (self.len(), needle.len());\n-        m >= n && needle.as_bytes() == self.as_bytes().index(&((m-n)..))\n+        m >= n && needle.as_bytes() == &self.as_bytes()[(m-n)..]\n     }\n \n     #[inline]"}, {"sha": "e6a7170aceafb40ad57d559305f45f3c7b28fed4", "filename": "src/libcoretest/any.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcoretest%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcoretest%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fany.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -101,12 +101,12 @@ fn any_downcast_mut() {\n     }\n \n     match a_r.downcast_mut::<uint>() {\n-        Some(&612) => {}\n+        Some(&mut 612) => {}\n         x => panic!(\"Unexpected value {:?}\", x)\n     }\n \n     match b_r.downcast_mut::<uint>() {\n-        Some(&413) => {}\n+        Some(&mut 413) => {}\n         x => panic!(\"Unexpected value {:?}\", x)\n     }\n }"}, {"sha": "7b6b4f848085e75a49d2c578e83b9662a3c50aa0", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -167,7 +167,7 @@ fn test_encode_utf8() {\n     fn check(input: char, expect: &[u8]) {\n         let mut buf = [0u8; 4];\n         let n = input.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n-        assert_eq!(buf.index(&(0..n)), expect);\n+        assert_eq!(&buf[0..n], expect);\n     }\n \n     check('x', &[0x78]);\n@@ -181,7 +181,7 @@ fn test_encode_utf16() {\n     fn check(input: char, expect: &[u16]) {\n         let mut buf = [0u16; 2];\n         let n = input.encode_utf16(buf.as_mut_slice()).unwrap_or(0);\n-        assert_eq!(buf.index(&(0..n)), expect);\n+        assert_eq!(&buf[0..n], expect);\n     }\n \n     check('x', &[0x0078]);"}, {"sha": "6fae384763f843a3010ea7c6b68624f3593f3014", "filename": "src/libcoretest/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -57,17 +57,17 @@ fn iterator_to_slice() {\n             }\n             {\n                 let mut iter = data.iter_mut();\n-                assert_eq!(iter.index(&FullRange), other_data.index(&FullRange));\n+                assert_eq!(&iter[], &other_data[]);\n                 // mutability:\n                 assert!(&mut iter[] == other_data);\n \n                 iter.next();\n-                assert_eq!(iter.index(&FullRange), other_data.index(&(1..)));\n+                assert_eq!(&iter[], &other_data[1..]);\n                 assert!(&mut iter[] == &mut other_data[1..]);\n \n                 iter.next_back();\n \n-                assert_eq!(iter.index(&FullRange), other_data.index(&(1..2)));\n+                assert_eq!(&iter[], &other_data[1..2]);\n                 assert!(&mut iter[] == &mut other_data[1..2]);\n \n                 let s = iter.into_slice();"}, {"sha": "02eea5d024c7a990ac40800dc9aa1642343a1d1f", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -212,12 +212,12 @@ impl<'a> Parser<'a> {\n                 self.cur.next();\n             }\n             Some((_, other)) => {\n-                self.err(format!(\"expected `{:?}`, found `{:?}`\", c,\n-                                 other).index(&FullRange));\n+                self.err(&format!(\"expected `{:?}`, found `{:?}`\", c,\n+                                  other)[]);\n             }\n             None => {\n-                self.err(format!(\"expected `{:?}` but string was terminated\",\n-                                 c).index(&FullRange));\n+                self.err(&format!(\"expected `{:?}` but string was terminated\",\n+                                  c)[]);\n             }\n         }\n     }\n@@ -240,12 +240,12 @@ impl<'a> Parser<'a> {\n             // we may not consume the character, so clone the iterator\n             match self.cur.clone().next() {\n                 Some((pos, '}')) | Some((pos, '{')) => {\n-                    return self.input.index(&(start..pos));\n+                    return &self.input[start..pos];\n                 }\n                 Some(..) => { self.cur.next(); }\n                 None => {\n                     self.cur.next();\n-                    return self.input.index(&(start..self.input.len()));\n+                    return &self.input[start..self.input.len()];\n                 }\n             }\n         }\n@@ -285,7 +285,7 @@ impl<'a> Parser<'a> {\n             flags: 0,\n             precision: CountImplied,\n             width: CountImplied,\n-            ty: self.input.index(&(0..0)),\n+            ty: &self.input[0..0],\n         };\n         if !self.consume(':') { return spec }\n \n@@ -394,7 +394,7 @@ impl<'a> Parser<'a> {\n                 self.cur.next();\n                 pos\n             }\n-            Some(..) | None => { return self.input.index(&(0..0)); }\n+            Some(..) | None => { return &self.input[0..0]; }\n         };\n         let mut end;\n         loop {\n@@ -406,7 +406,7 @@ impl<'a> Parser<'a> {\n                 None => { end = self.input.len(); break }\n             }\n         }\n-        self.input.index(&(start..end))\n+        &self.input[start..end]\n     }\n \n     /// Optionally parses an integer at the current position. This doesn't deal"}, {"sha": "1d6c99542b58ec014c2aa4ede0d752056176f767", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -281,7 +281,7 @@ impl OptGroup {\n \n impl Matches {\n     fn opt_vals(&self, nm: &str) -> Vec<Optval> {\n-        match find_opt(self.opts.index(&FullRange), Name::from_str(nm)) {\n+        match find_opt(&self.opts[], Name::from_str(nm)) {\n             Some(id) => self.vals[id].clone(),\n             None => panic!(\"No option '{}' defined\", nm)\n         }\n@@ -309,7 +309,7 @@ impl Matches {\n     /// Returns true if any of several options were matched.\n     pub fn opts_present(&self, names: &[String]) -> bool {\n         for nm in names.iter() {\n-            match find_opt(self.opts.as_slice(), Name::from_str(nm.index(&FullRange))) {\n+            match find_opt(self.opts.as_slice(), Name::from_str(&nm[])) {\n                 Some(id) if !self.vals[id].is_empty() => return true,\n                 _ => (),\n             };\n@@ -320,7 +320,7 @@ impl Matches {\n     /// Returns the string argument supplied to one of several matching options or `None`.\n     pub fn opts_str(&self, names: &[String]) -> Option<String> {\n         for nm in names.iter() {\n-            match self.opt_val(nm.index(&FullRange)) {\n+            match self.opt_val(&nm[]) {\n                 Some(Val(ref s)) => return Some(s.clone()),\n                 _ => ()\n             }\n@@ -585,7 +585,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n     while i < l {\n         let cur = args[i].clone();\n         let curlen = cur.len();\n-        if !is_arg(cur.index(&FullRange)) {\n+        if !is_arg(&cur[]) {\n             free.push(cur);\n         } else if cur == \"--\" {\n             let mut j = i + 1;\n@@ -595,7 +595,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n             let mut names;\n             let mut i_arg = None;\n             if cur.as_bytes()[1] == b'-' {\n-                let tail = cur.index(&(2..curlen));\n+                let tail = &cur[2..curlen];\n                 let tail_eq: Vec<&str> = tail.split('=').collect();\n                 if tail_eq.len() <= 1 {\n                     names = vec!(Long(tail.to_string()));\n@@ -631,7 +631,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                     };\n \n                     if arg_follows && range.next < curlen {\n-                        i_arg = Some(cur.index(&(range.next..curlen)).to_string());\n+                        i_arg = Some((&cur[range.next..curlen]).to_string());\n                         break;\n                     }\n \n@@ -659,7 +659,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                         v.push(Val((i_arg.clone())\n                             .unwrap()));\n                     } else if name_pos < names.len() || i + 1 == l ||\n-                            is_arg(args[i + 1].index(&FullRange)) {\n+                            is_arg(&args[i + 1][]) {\n                         let v = &mut vals[optid];\n                         v.push(Given);\n                     } else {\n@@ -722,7 +722,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n             0 => {}\n             1 => {\n                 row.push('-');\n-                row.push_str(short_name.index(&FullRange));\n+                row.push_str(&short_name[]);\n                 row.push(' ');\n             }\n             _ => panic!(\"the short name should only be 1 ascii char long\"),\n@@ -733,18 +733,18 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n             0 => {}\n             _ => {\n                 row.push_str(\"--\");\n-                row.push_str(long_name.index(&FullRange));\n+                row.push_str(&long_name[]);\n                 row.push(' ');\n             }\n         }\n \n         // arg\n         match hasarg {\n             No => {}\n-            Yes => row.push_str(hint.index(&FullRange)),\n+            Yes => row.push_str(&hint[]),\n             Maybe => {\n                 row.push('[');\n-                row.push_str(hint.index(&FullRange));\n+                row.push_str(&hint[]);\n                 row.push(']');\n             }\n         }\n@@ -757,7 +757,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n                 row.push(' ');\n             }\n         } else {\n-            row.push_str(desc_sep.index(&FullRange));\n+            row.push_str(&desc_sep[]);\n         }\n \n         // Normalize desc to contain words separated by one space character\n@@ -769,14 +769,14 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n \n         // FIXME: #5516 should be graphemes not codepoints\n         let mut desc_rows = Vec::new();\n-        each_split_within(desc_normalized_whitespace.index(&FullRange), 54, |substr| {\n+        each_split_within(&desc_normalized_whitespace[], 54, |substr| {\n             desc_rows.push(substr.to_string());\n             true\n         });\n \n         // FIXME: #5516 should be graphemes not codepoints\n         // wrapped description\n-        row.push_str(desc_rows.connect(desc_sep.index(&FullRange)).index(&FullRange));\n+        row.push_str(&desc_rows.connect(&desc_sep[])[]);\n \n         row\n     });\n@@ -795,18 +795,18 @@ fn format_option(opt: &OptGroup) -> String {\n     // Use short_name is possible, but fallback to long_name.\n     if opt.short_name.len() > 0 {\n         line.push('-');\n-        line.push_str(opt.short_name.index(&FullRange));\n+        line.push_str(&opt.short_name[]);\n     } else {\n         line.push_str(\"--\");\n-        line.push_str(opt.long_name.index(&FullRange));\n+        line.push_str(&opt.long_name[]);\n     }\n \n     if opt.hasarg != No {\n         line.push(' ');\n         if opt.hasarg == Maybe {\n             line.push('[');\n         }\n-        line.push_str(opt.hint.index(&FullRange));\n+        line.push_str(&opt.hint[]);\n         if opt.hasarg == Maybe {\n             line.push(']');\n         }\n@@ -825,10 +825,10 @@ fn format_option(opt: &OptGroup) -> String {\n /// Derive a short one-line usage summary from a set of long options.\n pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> String {\n     let mut line = format!(\"Usage: {} \", program_name);\n-    line.push_str(opts.iter()\n-                      .map(format_option)\n-                      .collect::<Vec<String>>()\n-                      .connect(\" \").index(&FullRange));\n+    line.push_str(&opts.iter()\n+                       .map(format_option)\n+                       .collect::<Vec<String>>()\n+                       .connect(\" \")[]);\n     line\n }\n \n@@ -891,9 +891,9 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n             (B, Cr, UnderLim) => { B }\n             (B, Cr, OverLim)  if (i - last_start + 1) > lim\n                             => panic!(\"word starting with {} longer than limit!\",\n-                                    ss.index(&(last_start..(i + 1)))),\n+                                      &ss[last_start..(i + 1)]),\n             (B, Cr, OverLim)  => {\n-                *cont = it(ss.index(&(slice_start..last_end)));\n+                *cont = it(&ss[slice_start..last_end]);\n                 slice_start = last_start;\n                 B\n             }\n@@ -903,7 +903,7 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n             }\n             (B, Ws, OverLim)  => {\n                 last_end = i;\n-                *cont = it(ss.index(&(slice_start..last_end)));\n+                *cont = it(&ss[slice_start..last_end]);\n                 A\n             }\n \n@@ -912,14 +912,14 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n                 B\n             }\n             (C, Cr, OverLim)  => {\n-                *cont = it(ss.index(&(slice_start..last_end)));\n+                *cont = it(&ss[slice_start..last_end]);\n                 slice_start = i;\n                 last_start = i;\n                 last_end = i;\n                 B\n             }\n             (C, Ws, OverLim)  => {\n-                *cont = it(ss.index(&(slice_start..last_end)));\n+                *cont = it(&ss[slice_start..last_end]);\n                 A\n             }\n             (C, Ws, UnderLim) => {"}, {"sha": "9d2318e253e72672d35faaba9a36a2bebaab3a29", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -453,7 +453,7 @@ impl<'a> LabelText<'a> {\n     pub fn escape(&self) -> String {\n         match self {\n             &LabelStr(ref s) => s.escape_default(),\n-            &EscStr(ref s) => LabelText::escape_str(s.index(&FullRange)),\n+            &EscStr(ref s) => LabelText::escape_str(&s[]),\n         }\n     }\n \n@@ -482,7 +482,7 @@ impl<'a> LabelText<'a> {\n         let mut prefix = self.pre_escaped_content().into_owned();\n         let suffix = suffix.pre_escaped_content();\n         prefix.push_str(r\"\\n\\n\");\n-        prefix.push_str(suffix.index(&FullRange));\n+        prefix.push_str(&suffix[]);\n         EscStr(prefix.into_cow())\n     }\n }\n@@ -676,7 +676,7 @@ mod tests {\n \n     impl<'a> Labeller<'a, Node, &'a Edge> for LabelledGraph {\n         fn graph_id(&'a self) -> Id<'a> {\n-            Id::new(self.name.index(&FullRange)).unwrap()\n+            Id::new(&self.name[]).unwrap()\n         }\n         fn node_id(&'a self, n: &Node) -> Id<'a> {\n             id_name(n)"}, {"sha": "036663ad8f565940355f268038e7eae126cd6d08", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -288,7 +288,7 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     // Test the literal string from args against the current filter, if there\n     // is one.\n     match unsafe { FILTER.as_ref() } {\n-        Some(filter) if !filter.is_match(args.to_string().index(&FullRange)) => return,\n+        Some(filter) if !filter.is_match(&args.to_string()[]) => return,\n         _ => {}\n     }\n \n@@ -383,7 +383,7 @@ fn enabled(level: u32,\n     // Search for the longest match, the vector is assumed to be pre-sorted.\n     for directive in iter.rev() {\n         match directive.name {\n-            Some(ref name) if !module.starts_with(name.index(&FullRange)) => {},\n+            Some(ref name) if !module.starts_with(&name[]) => {},\n             Some(..) | None => {\n                 return level <= directive.level\n             }\n@@ -398,7 +398,7 @@ fn enabled(level: u32,\n /// `Once` primitive (and this function is called from that primitive).\n fn init() {\n     let (mut directives, filter) = match os::getenv(\"RUST_LOG\") {\n-        Some(spec) => directive::parse_logging_spec(spec.index(&FullRange)),\n+        Some(spec) => directive::parse_logging_spec(&spec[]),\n         None => (Vec::new(), None),\n     };\n "}, {"sha": "a6a8beba7934e343af7efdf640b2792e8db015d9", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -271,7 +271,7 @@ pub trait Rng : Sized {\n     /// let mut rng = thread_rng();\n     /// println!(\"{:?}\", rng.choose(&choices));\n     /// # // uncomment when slicing syntax is stable\n-    /// //assert_eq!(rng.choose(choices.index(&(0..0))), None);\n+    /// //assert_eq!(rng.choose(&choices[0..0]), None);\n     /// ```\n     fn choose<'a, T>(&mut self, values: &'a [T]) -> Option<&'a T> {\n         if values.is_empty() {"}, {"sha": "bdc00d7db97fe8e22da8b66d50826f459683b3ea", "filename": "src/librbml/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -95,7 +95,7 @@ impl Writer for SeekableMemWriter {\n             // there (left), and what will be appended on the end (right)\n             let cap = self.buf.len() - self.pos;\n             let (left, right) = if cap <= buf.len() {\n-                (buf.index(&(0..cap)), buf.index(&(cap..)))\n+                (&buf[0..cap], &buf[cap..])\n             } else {\n                 let result: (_, &[_]) = (buf, &[]);\n                 result"}, {"sha": "da803aa50119cfbf33d19b93d6ca94ac03589236", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -57,7 +57,7 @@ impl<'doc> Doc<'doc> {\n     }\n \n     pub fn as_str_slice<'a>(&'a self) -> &'a str {\n-        str::from_utf8(self.data.index(&(self.start..self.end))).unwrap()\n+        str::from_utf8(&self.data[self.start..self.end]).unwrap()\n     }\n \n     pub fn as_str(&self) -> String {\n@@ -292,7 +292,7 @@ pub mod reader {\n     pub fn with_doc_data<T, F>(d: Doc, f: F) -> T where\n         F: FnOnce(&[u8]) -> T,\n     {\n-        f(d.data.index(&(d.start..d.end)))\n+        f(&d.data[d.start..d.end])\n     }\n \n "}, {"sha": "d29a7a425c1164d1825549f49a99305377d89a95", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -105,7 +105,7 @@ impl Program {\n         // This is a bit hacky since we have to skip over the initial\n         // 'Save' instruction.\n         let mut pre = String::with_capacity(5);\n-        for inst in c.insts.index(&(1..)).iter() {\n+        for inst in c.insts[1..].iter() {\n             match *inst {\n                 OneChar(c, FLAG_EMPTY) => pre.push(c),\n                 _ => break"}, {"sha": "1cc2b271e9ccda688ff3cdbdaffb75ee2c10a29f", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 51, "deletions": 52, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -18,7 +18,6 @@ use std::cmp;\n use std::fmt;\n use std::iter;\n use std::num;\n-use std::ops::Index;\n \n /// Static data containing Unicode ranges for general categories and scripts.\n use unicode::regex::{UNICODE_CLASSES, PERLD, PERLS, PERLW};\n@@ -285,20 +284,20 @@ impl<'a> Parser<'a> {\n         match self.next_char() {\n             true => Ok(()),\n             false => {\n-                self.err(format!(\"Expected {:?} but got EOF.\",\n-                                 expected).index(&FullRange))\n+                self.err(&format!(\"Expected {:?} but got EOF.\",\n+                                  expected)[])\n             }\n         }\n     }\n \n     fn expect(&mut self, expected: char) -> Result<(), Error> {\n         match self.next_char() {\n             true if self.cur() == expected => Ok(()),\n-            true => self.err(format!(\"Expected '{:?}' but got '{:?}'.\",\n-                                     expected, self.cur()).index(&FullRange)),\n+            true => self.err(&format!(\"Expected '{:?}' but got '{:?}'.\",\n+                                      expected, self.cur())[]),\n             false => {\n-                self.err(format!(\"Expected '{:?}' but got EOF.\",\n-                                 expected).index(&FullRange))\n+                self.err(&format!(\"Expected '{:?}' but got EOF.\",\n+                                  expected)[])\n             }\n         }\n     }\n@@ -443,15 +442,15 @@ impl<'a> Parser<'a> {\n                     match try!(self.parse_escape()) {\n                         Literal(c3, _) => c2 = c3, // allow literal escapes below\n                         ast =>\n-                            return self.err(format!(\"Expected a literal, but got {:?}.\",\n-                                                    ast).index(&FullRange)),\n+                            return self.err(&format!(\"Expected a literal, but got {:?}.\",\n+                                                     ast)[]),\n                     }\n                 }\n                 if c2 < c {\n-                    return self.err(format!(\"Invalid character class \\\n-                                             range '{}-{}'\",\n-                                            c,\n-                                            c2).index(&FullRange))\n+                    return self.err(&format!(\"Invalid character class \\\n+                                              range '{}-{}'\",\n+                                             c,\n+                                             c2)[])\n                 }\n                 ranges.push((c, self.cur()))\n             } else {\n@@ -489,7 +488,7 @@ impl<'a> Parser<'a> {\n                 FLAG_EMPTY\n             };\n         let name = self.slice(name_start, closer - 1);\n-        match find_class(ASCII_CLASSES, name.index(&FullRange)) {\n+        match find_class(ASCII_CLASSES, &name[]) {\n             None => None,\n             Some(ranges) => {\n                 self.chari = closer;\n@@ -511,21 +510,21 @@ impl<'a> Parser<'a> {\n             match self.pos('}') {\n                 Some(i) => i,\n                 None => {\n-                    return self.err(format!(\"No closing brace for counted \\\n-                                             repetition starting at position \\\n-                                             {:?}.\",\n-                                            start).index(&FullRange))\n+                    return self.err(&format!(\"No closing brace for counted \\\n+                                              repetition starting at position \\\n+                                              {:?}.\",\n+                                             start)[])\n                 }\n             };\n         self.chari = closer;\n         let greed = try!(self.get_next_greedy());\n-        let inner = self.chars.index(&((start+1)..closer)).iter().cloned()\n+        let inner = self.chars[(start+1)..closer].iter().cloned()\n                                                .collect::<String>();\n \n         // Parse the min and max values from the regex.\n         let (mut min, mut max): (uint, Option<uint>);\n         if !inner.contains(\",\") {\n-            min = try!(self.parse_uint(inner.index(&FullRange)));\n+            min = try!(self.parse_uint(&inner[]));\n             max = Some(min);\n         } else {\n             let pieces: Vec<&str> = inner.splitn(1, ',').collect();\n@@ -545,21 +544,21 @@ impl<'a> Parser<'a> {\n \n         // Do some bounds checking and make sure max >= min.\n         if min > MAX_REPEAT {\n-            return self.err(format!(\n+            return self.err(&format!(\n                 \"{} exceeds maximum allowed repetitions ({})\",\n-                min, MAX_REPEAT).index(&FullRange));\n+                min, MAX_REPEAT)[]);\n         }\n         if max.is_some() {\n             let m = max.unwrap();\n             if m > MAX_REPEAT {\n-                return self.err(format!(\n+                return self.err(&format!(\n                     \"{} exceeds maximum allowed repetitions ({})\",\n-                    m, MAX_REPEAT).index(&FullRange));\n+                    m, MAX_REPEAT)[]);\n             }\n             if m < min {\n-                return self.err(format!(\n+                return self.err(&format!(\n                     \"Max repetitions ({}) cannot be smaller than min \\\n-                     repetitions ({}).\", m, min).index(&FullRange));\n+                     repetitions ({}).\", m, min)[]);\n             }\n         }\n \n@@ -623,7 +622,7 @@ impl<'a> Parser<'a> {\n                 Ok(AstClass(ranges, flags))\n             }\n             _ => {\n-                self.err(format!(\"Invalid escape sequence '\\\\\\\\{}'\", c).index(&FullRange))\n+                self.err(&format!(\"Invalid escape sequence '\\\\\\\\{}'\", c)[])\n             }\n         }\n     }\n@@ -641,9 +640,9 @@ impl<'a> Parser<'a> {\n             let closer =\n                 match self.pos('}') {\n                     Some(i) => i,\n-                    None => return self.err(format!(\n+                    None => return self.err(&format!(\n                         \"Missing '}}' for unclosed '{{' at position {}\",\n-                        self.chari).index(&FullRange)),\n+                        self.chari)[]),\n                 };\n             if closer - self.chari + 1 == 0 {\n                 return self.err(\"No Unicode class name found.\")\n@@ -657,10 +656,10 @@ impl<'a> Parser<'a> {\n             name = self.slice(self.chari + 1, self.chari + 2);\n             self.chari += 1;\n         }\n-        match find_class(UNICODE_CLASSES, name.index(&FullRange)) {\n+        match find_class(UNICODE_CLASSES, &name[]) {\n             None => {\n-                return self.err(format!(\"Could not find Unicode class '{}'\",\n-                                        name).index(&FullRange))\n+                return self.err(&format!(\"Could not find Unicode class '{}'\",\n+                                        name)[])\n             }\n             Some(ranges) => {\n                 Ok(AstClass(ranges, negated | (self.flags & FLAG_NOCASE)))\n@@ -683,11 +682,11 @@ impl<'a> Parser<'a> {\n             }\n         }\n         let s = self.slice(start, end);\n-        match num::from_str_radix::<u32>(s.index(&FullRange), 8) {\n+        match num::from_str_radix::<u32>(&s[], 8) {\n             Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n             None => {\n-                self.err(format!(\"Could not parse '{:?}' as octal number.\",\n-                                 s).index(&FullRange))\n+                self.err(&format!(\"Could not parse '{:?}' as octal number.\",\n+                                 s)[])\n             }\n         }\n     }\n@@ -703,14 +702,14 @@ impl<'a> Parser<'a> {\n         let closer =\n             match self.pos('}') {\n                 None => {\n-                    return self.err(format!(\"Missing '}}' for unclosed \\\n+                    return self.err(&format!(\"Missing '}}' for unclosed \\\n                                              '{{' at position {}\",\n-                                            start).index(&FullRange))\n+                                            start)[])\n                 }\n                 Some(i) => i,\n             };\n         self.chari = closer;\n-        self.parse_hex_digits(self.slice(start, closer).index(&FullRange))\n+        self.parse_hex_digits(&self.slice(start, closer)[])\n     }\n \n     // Parses a two-digit hex number.\n@@ -730,7 +729,7 @@ impl<'a> Parser<'a> {\n         match num::from_str_radix::<u32>(s, 16) {\n             Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n             None => {\n-                self.err(format!(\"Could not parse '{}' as hex number.\", s).index(&FullRange))\n+                self.err(&format!(\"Could not parse '{}' as hex number.\", s)[])\n             }\n         }\n     }\n@@ -755,8 +754,8 @@ impl<'a> Parser<'a> {\n                 \"Capture names can only have underscores, letters and digits.\")\n         }\n         if self.names.contains(&name) {\n-            return self.err(format!(\"Duplicate capture group name '{}'.\",\n-                                    name).index(&FullRange))\n+            return self.err(&format!(\"Duplicate capture group name '{}'.\",\n+                                    name)[])\n         }\n         self.names.push(name.clone());\n         self.chari = closer;\n@@ -788,9 +787,9 @@ impl<'a> Parser<'a> {\n                 'U' => { flags = flags | FLAG_SWAP_GREED; saw_flag = true},\n                 '-' => {\n                     if sign < 0 {\n-                        return self.err(format!(\n+                        return self.err(&format!(\n                             \"Cannot negate flags twice in '{}'.\",\n-                            self.slice(start, self.chari + 1)).index(&FullRange))\n+                            self.slice(start, self.chari + 1))[])\n                     }\n                     sign = -1;\n                     saw_flag = false;\n@@ -799,9 +798,9 @@ impl<'a> Parser<'a> {\n                 ':' | ')' => {\n                     if sign < 0 {\n                         if !saw_flag {\n-                            return self.err(format!(\n+                            return self.err(&format!(\n                                 \"A valid flag does not follow negation in '{}'\",\n-                                self.slice(start, self.chari + 1)).index(&FullRange))\n+                                self.slice(start, self.chari + 1))[])\n                         }\n                         flags = flags ^ flags;\n                     }\n@@ -812,8 +811,8 @@ impl<'a> Parser<'a> {\n                     self.flags = flags;\n                     return Ok(())\n                 }\n-                _ => return self.err(format!(\n-                    \"Unrecognized flag '{}'.\", self.cur()).index(&FullRange)),\n+                _ => return self.err(&format!(\n+                    \"Unrecognized flag '{}'.\", self.cur())[]),\n             }\n         }\n     }\n@@ -910,8 +909,8 @@ impl<'a> Parser<'a> {\n         match s.parse::<uint>() {\n             Some(i) => Ok(i),\n             None => {\n-                self.err(format!(\"Expected an unsigned integer but got '{}'.\",\n-                                 s).index(&FullRange))\n+                self.err(&format!(\"Expected an unsigned integer but got '{}'.\",\n+                                 s)[])\n             }\n         }\n     }\n@@ -920,8 +919,8 @@ impl<'a> Parser<'a> {\n         match char::from_u32(n) {\n             Some(c) => Ok(c),\n             None => {\n-                self.err(format!(\"Could not decode '{}' to unicode \\\n-                                  character.\", n).index(&FullRange))\n+                self.err(&format!(\"Could not decode '{}' to unicode \\\n+                                  character.\", n)[])\n             }\n         }\n     }\n@@ -954,7 +953,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn slice(&self, start: uint, end: uint) -> String {\n-        self.chars.index(&(start..end)).iter().cloned().collect()\n+        self.chars[start..end].iter().cloned().collect()\n     }\n }\n "}, {"sha": "16dd32b6be220692e295a96db5cda2804fc790f8", "filename": "src/libregex/re.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -238,19 +238,19 @@ impl Regex {\n             }\n \n             let (s, e) = cap.pos(0).unwrap(); // captures only reports matches\n-            new.push_str(text.index(&(last_match..s)));\n-            new.push_str(rep.reg_replace(&cap).index(&FullRange));\n+            new.push_str(&text[last_match..s]);\n+            new.push_str(&rep.reg_replace(&cap)[]);\n             last_match = e;\n         }\n-        new.push_str(text.index(&(last_match..text.len())));\n+        new.push_str(&text[last_match..text.len()]);\n         return new;\n     }\n \n     /// Returns the original string of this regex.\n     pub fn as_str<'a>(&'a self) -> &'a str {\n         match *self {\n-            Dynamic(ExDynamic { ref original, .. }) => original.index(&FullRange),\n-            Native(ExNative { ref original, .. }) => original.index(&FullRange),\n+            Dynamic(ExDynamic { ref original, .. }) => &original[],\n+            Native(ExNative { ref original, .. }) => &original[],\n         }\n     }\n \n@@ -347,13 +347,13 @@ impl<'r, 't> Iterator for RegexSplits<'r, 't> {\n                 if self.last >= text.len() {\n                     None\n                 } else {\n-                    let s = text.index(&(self.last..text.len()));\n+                    let s = &text[self.last..text.len()];\n                     self.last = text.len();\n                     Some(s)\n                 }\n             }\n             Some((s, e)) => {\n-                let matched = text.index(&(self.last..s));\n+                let matched = &text[self.last..s];\n                 self.last = e;\n                 Some(matched)\n             }\n@@ -384,7 +384,7 @@ impl<'r, 't> Iterator for RegexSplitsN<'r, 't> {\n         } else {\n             self.cur += 1;\n             if self.cur >= self.limit {\n-                Some(text.index(&(self.splits.last..text.len())))\n+                Some(&text[self.splits.last..text.len()])\n             } else {\n                 self.splits.next()\n             }\n@@ -517,7 +517,7 @@ impl<'t> Captures<'t> {\n             })\n         });\n         let re = Regex::new(r\"\\$\\$\").unwrap();\n-        re.replace_all(text.index(&FullRange), NoExpand(\"$\"))\n+        re.replace_all(&text[], NoExpand(\"$\"))\n     }\n \n     /// Returns the number of captured groups."}, {"sha": "9605536a052c04d3135888e754e0c18269b128d5", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -152,7 +152,7 @@ impl<'r, 't> Nfa<'r, 't> {\n                 // out early.\n                 if self.prog.prefix.len() > 0 && clist.size == 0 {\n                     let needle = self.prog.prefix.as_bytes();\n-                    let haystack = self.input.as_bytes().index(&(self.ic..));\n+                    let haystack = &self.input.as_bytes()[self.ic..];\n                     match find_prefix(needle, haystack) {\n                         None => break,\n                         Some(i) => {"}, {"sha": "7c210351f3121af01fda490438a9abd8d7e52f68", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -506,7 +506,7 @@ impl BoxPointers {\n         if n_uniq > 0 {\n             let s = ty_to_string(cx.tcx, ty);\n             let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n-            cx.span_lint(BOX_POINTERS, span, m.index(&FullRange));\n+            cx.span_lint(BOX_POINTERS, span, &m[]);\n         }\n     }\n }\n@@ -586,7 +586,7 @@ impl LintPass for RawPointerDerive {\n     }\n \n     fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n-        if !attr::contains_name(item.attrs.index(&FullRange), \"automatically_derived\") {\n+        if !attr::contains_name(&item.attrs[], \"automatically_derived\") {\n             return\n         }\n         let did = match item.node {\n@@ -770,11 +770,11 @@ impl LintPass for UnusedResults {\n             ty::ty_enum(did, _) => {\n                 if ast_util::is_local(did) {\n                     if let ast_map::NodeItem(it) = cx.tcx.map.get(did.node) {\n-                        warned |= check_must_use(cx, it.attrs.index(&FullRange), s.span);\n+                        warned |= check_must_use(cx, &it.attrs[], s.span);\n                     }\n                 } else {\n                     csearch::get_item_attrs(&cx.sess().cstore, did, |attrs| {\n-                        warned |= check_must_use(cx, attrs.index(&FullRange), s.span);\n+                        warned |= check_must_use(cx, &attrs[], s.span);\n                     });\n                 }\n             }\n@@ -796,7 +796,7 @@ impl LintPass for UnusedResults {\n                             msg.push_str(s.get());\n                         }\n                     }\n-                    cx.span_lint(UNUSED_MUST_USE, sp, msg.index(&FullRange));\n+                    cx.span_lint(UNUSED_MUST_USE, sp, &msg[]);\n                     return true;\n                 }\n             }\n@@ -842,7 +842,7 @@ impl NonCamelCaseTypes {\n             } else {\n                 format!(\"{} `{}` should have a camel case name such as `{}`\", sort, s, c)\n             };\n-            cx.span_lint(NON_CAMEL_CASE_TYPES, span, m.index(&FullRange));\n+            cx.span_lint(NON_CAMEL_CASE_TYPES, span, &m[]);\n         }\n     }\n }\n@@ -981,8 +981,8 @@ impl NonSnakeCase {\n \n         if !is_snake_case(ident) {\n             cx.span_lint(NON_SNAKE_CASE, span,\n-                format!(\"{} `{}` should have a snake case name such as `{}`\",\n-                        sort, s, to_snake_case(s.get())).index(&FullRange));\n+                &format!(\"{} `{}` should have a snake case name such as `{}`\",\n+                        sort, s, to_snake_case(s.get()))[]);\n         }\n     }\n }\n@@ -1066,10 +1066,10 @@ impl LintPass for NonUpperCaseGlobals {\n                 // upper/lowercase)\n                 if s.get().chars().any(|c| c.is_lowercase()) {\n                     cx.span_lint(NON_UPPER_CASE_GLOBALS, it.span,\n-                        format!(\"static constant `{}` should have an uppercase name \\\n+                        &format!(\"static constant `{}` should have an uppercase name \\\n                                  such as `{}`\",\n-                                s.get(), s.get().chars().map(|c| c.to_uppercase())\n-                                .collect::<String>().index(&FullRange)).index(&FullRange));\n+                                s.get(), &s.get().chars().map(|c| c.to_uppercase())\n+                                .collect::<String>()[])[]);\n                 }\n             }\n             _ => {}\n@@ -1083,10 +1083,10 @@ impl LintPass for NonUpperCaseGlobals {\n                 let s = token::get_ident(path1.node);\n                 if s.get().chars().any(|c| c.is_lowercase()) {\n                     cx.span_lint(NON_UPPER_CASE_GLOBALS, path1.span,\n-                        format!(\"static constant in pattern `{}` should have an uppercase \\\n+                        &format!(\"static constant in pattern `{}` should have an uppercase \\\n                                  name such as `{}`\",\n-                                s.get(), s.get().chars().map(|c| c.to_uppercase())\n-                                    .collect::<String>().index(&FullRange)).index(&FullRange));\n+                                s.get(), &s.get().chars().map(|c| c.to_uppercase())\n+                                    .collect::<String>()[])[]);\n                 }\n             }\n             _ => {}\n@@ -1110,8 +1110,8 @@ impl UnusedParens {\n             let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&**inner);\n             if !necessary {\n                 cx.span_lint(UNUSED_PARENS, value.span,\n-                             format!(\"unnecessary parentheses around {}\",\n-                                     msg).index(&FullRange))\n+                             &format!(\"unnecessary parentheses around {}\",\n+                                     msg)[])\n             }\n         }\n \n@@ -1213,7 +1213,7 @@ impl LintPass for UnusedImportBraces {\n                                     let m = format!(\"braces around {} is unnecessary\",\n                                                     token::get_ident(*name).get());\n                                     cx.span_lint(UNUSED_IMPORT_BRACES, view_item.span,\n-                                                 m.index(&FullRange));\n+                                                 &m[]);\n                                 },\n                                 _ => ()\n                             }\n@@ -1251,8 +1251,8 @@ impl LintPass for NonShorthandFieldPatterns {\n                 if let ast::PatIdent(_, ident, None) = fieldpat.node.pat.node {\n                     if ident.node.as_str() == fieldpat.node.ident.as_str() {\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n-                                     format!(\"the `{}:` in this pattern is redundant and can \\\n-                                              be removed\", ident.node.as_str()).index(&FullRange))\n+                                     &format!(\"the `{}:` in this pattern is redundant and can \\\n+                                              be removed\", ident.node.as_str())[])\n                     }\n                 }\n             }\n@@ -1356,7 +1356,7 @@ impl LintPass for UnusedMut {\n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         if let ast::ExprMatch(_, ref arms, _) = e.node {\n             for a in arms.iter() {\n-                self.check_unused_mut_pat(cx, a.pats.index(&FullRange))\n+                self.check_unused_mut_pat(cx, &a.pats[])\n             }\n         }\n     }\n@@ -1477,7 +1477,7 @@ impl MissingDoc {\n         });\n         if !has_doc {\n             cx.span_lint(MISSING_DOCS, sp,\n-                format!(\"missing documentation for {}\", desc).index(&FullRange));\n+                &format!(\"missing documentation for {}\", desc)[]);\n         }\n     }\n }\n@@ -1491,7 +1491,7 @@ impl LintPass for MissingDoc {\n         let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n             attr.check_name(\"doc\") && match attr.meta_item_list() {\n                 None => false,\n-                Some(l) => attr::contains_name(l.index(&FullRange), \"hidden\"),\n+                Some(l) => attr::contains_name(&l[], \"hidden\"),\n             }\n         });\n         self.doc_hidden_stack.push(doc_hidden);\n@@ -1513,7 +1513,7 @@ impl LintPass for MissingDoc {\n     }\n \n     fn check_crate(&mut self, cx: &Context, krate: &ast::Crate) {\n-        self.check_missing_docs_attrs(cx, None, krate.attrs.index(&FullRange),\n+        self.check_missing_docs_attrs(cx, None, &krate.attrs[],\n                                      krate.span, \"crate\");\n     }\n \n@@ -1527,7 +1527,7 @@ impl LintPass for MissingDoc {\n             ast::ItemTy(..) => \"a type alias\",\n             _ => return\n         };\n-        self.check_missing_docs_attrs(cx, Some(it.id), it.attrs.index(&FullRange),\n+        self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs[],\n                                      it.span, desc);\n     }\n \n@@ -1540,13 +1540,13 @@ impl LintPass for MissingDoc {\n \n             // Otherwise, doc according to privacy. This will also check\n             // doc for default methods defined on traits.\n-            self.check_missing_docs_attrs(cx, Some(m.id), m.attrs.index(&FullRange),\n+            self.check_missing_docs_attrs(cx, Some(m.id), &m.attrs[],\n                                           m.span, \"a method\");\n         }\n     }\n \n     fn check_ty_method(&mut self, cx: &Context, tm: &ast::TypeMethod) {\n-        self.check_missing_docs_attrs(cx, Some(tm.id), tm.attrs.index(&FullRange),\n+        self.check_missing_docs_attrs(cx, Some(tm.id), &tm.attrs[],\n                                      tm.span, \"a type method\");\n     }\n \n@@ -1556,14 +1556,14 @@ impl LintPass for MissingDoc {\n                 let cur_struct_def = *self.struct_def_stack.last()\n                     .expect(\"empty struct_def_stack\");\n                 self.check_missing_docs_attrs(cx, Some(cur_struct_def),\n-                                              sf.node.attrs.index(&FullRange), sf.span,\n+                                              &sf.node.attrs[], sf.span,\n                                               \"a struct field\")\n             }\n         }\n     }\n \n     fn check_variant(&mut self, cx: &Context, v: &ast::Variant, _: &ast::Generics) {\n-        self.check_missing_docs_attrs(cx, Some(v.node.id), v.node.attrs.index(&FullRange),\n+        self.check_missing_docs_attrs(cx, Some(v.node.id), &v.node.attrs[],\n                                      v.span, \"a variant\");\n         assert!(!self.in_variant);\n         self.in_variant = true;\n@@ -1693,7 +1693,7 @@ impl Stability {\n                 _ => format!(\"use of {} item\", label)\n             };\n \n-            cx.span_lint(lint, span, msg.index(&FullRange));\n+            cx.span_lint(lint, span, &msg[]);\n         }\n     }\n "}, {"sha": "0d6ee729a93f25e185d400f408b0c498739543a8", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -105,7 +105,7 @@ impl LintStore {\n     }\n \n     pub fn get_lints<'t>(&'t self) -> &'t [(&'static Lint, bool)] {\n-        self.lints.index(&FullRange)\n+        &self.lints[]\n     }\n \n     pub fn get_lint_groups<'t>(&'t self) -> Vec<(&'static str, Vec<LintId>, bool)> {\n@@ -125,11 +125,11 @@ impl LintStore {\n                 match (sess, from_plugin) {\n                     // We load builtin lints first, so a duplicate is a compiler bug.\n                     // Use early_error when handling -W help with no crate.\n-                    (None, _) => early_error(msg.index(&FullRange)),\n-                    (Some(sess), false) => sess.bug(msg.index(&FullRange)),\n+                    (None, _) => early_error(&msg[]),\n+                    (Some(sess), false) => sess.bug(&msg[]),\n \n                     // A duplicate name from a plugin is a user error.\n-                    (Some(sess), true)  => sess.err(msg.index(&FullRange)),\n+                    (Some(sess), true)  => sess.err(&msg[]),\n                 }\n             }\n \n@@ -150,11 +150,11 @@ impl LintStore {\n             match (sess, from_plugin) {\n                 // We load builtin lints first, so a duplicate is a compiler bug.\n                 // Use early_error when handling -W help with no crate.\n-                (None, _) => early_error(msg.index(&FullRange)),\n-                (Some(sess), false) => sess.bug(msg.index(&FullRange)),\n+                (None, _) => early_error(&msg[]),\n+                (Some(sess), false) => sess.bug(&msg[]),\n \n                 // A duplicate name from a plugin is a user error.\n-                (Some(sess), true)  => sess.err(msg.index(&FullRange)),\n+                (Some(sess), true)  => sess.err(&msg[]),\n             }\n         }\n     }\n@@ -269,8 +269,8 @@ impl LintStore {\n                 let warning = format!(\"lint {} has been renamed to {}\",\n                                       lint_name, new_name);\n                 match span {\n-                    Some(span) => sess.span_warn(span, warning.index(&FullRange)),\n-                    None => sess.warn(warning.index(&FullRange)),\n+                    Some(span) => sess.span_warn(span, &warning[]),\n+                    None => sess.warn(&warning[]),\n                 };\n                 Some(lint_id)\n             }\n@@ -280,21 +280,21 @@ impl LintStore {\n \n     pub fn process_command_line(&mut self, sess: &Session) {\n         for &(ref lint_name, level) in sess.opts.lint_opts.iter() {\n-            match self.find_lint(lint_name.index(&FullRange), sess, None) {\n+            match self.find_lint(&lint_name[], sess, None) {\n                 Some(lint_id) => self.set_level(lint_id, (level, CommandLine)),\n                 None => {\n                     match self.lint_groups.iter().map(|(&x, pair)| (x, pair.0.clone()))\n                                                  .collect::<FnvHashMap<&'static str,\n                                                                        Vec<LintId>>>()\n-                                                 .get(lint_name.index(&FullRange)) {\n+                                                 .get(&lint_name[]) {\n                         Some(v) => {\n                             v.iter()\n                              .map(|lint_id: &LintId|\n                                      self.set_level(*lint_id, (level, CommandLine)))\n                              .collect::<Vec<()>>();\n                         }\n-                        None => sess.err(format!(\"unknown {} flag: {}\",\n-                                                 level.as_str(), lint_name).index(&FullRange)),\n+                        None => sess.err(&format!(\"unknown {} flag: {}\",\n+                                                 level.as_str(), lint_name)[]),\n                     }\n                 }\n             }\n@@ -435,10 +435,10 @@ pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n     if level == Forbid { level = Deny; }\n \n     match (level, span) {\n-        (Warn, Some(sp)) => sess.span_warn(sp, msg.index(&FullRange)),\n-        (Warn, None)     => sess.warn(msg.index(&FullRange)),\n-        (Deny, Some(sp)) => sess.span_err(sp, msg.index(&FullRange)),\n-        (Deny, None)     => sess.err(msg.index(&FullRange)),\n+        (Warn, Some(sp)) => sess.span_warn(sp, &msg[]),\n+        (Warn, None)     => sess.warn(&msg[]),\n+        (Deny, Some(sp)) => sess.span_err(sp, &msg[]),\n+        (Deny, None)     => sess.err(&msg[]),\n         _ => sess.bug(\"impossible level in raw_emit_lint\"),\n     }\n \n@@ -549,9 +549,9 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                 if now == Forbid && level != Forbid {\n                     let lint_name = lint_id.as_str();\n                     self.tcx.sess.span_err(span,\n-                                           format!(\"{}({}) overruled by outer forbid({})\",\n+                                           &format!(\"{}({}) overruled by outer forbid({})\",\n                                                    level.as_str(), lint_name,\n-                                                   lint_name).index(&FullRange));\n+                                                   lint_name)[]);\n                 } else if now != level {\n                     let src = self.lints.get_level_source(lint_id).1;\n                     self.level_stack.push((lint_id, (now, src)));\n@@ -586,22 +586,22 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     fn visit_item(&mut self, it: &ast::Item) {\n-        self.with_lint_attrs(it.attrs.index(&FullRange), |cx| {\n+        self.with_lint_attrs(&it.attrs[], |cx| {\n             run_lints!(cx, check_item, it);\n             cx.visit_ids(|v| v.visit_item(it));\n             visit::walk_item(cx, it);\n         })\n     }\n \n     fn visit_foreign_item(&mut self, it: &ast::ForeignItem) {\n-        self.with_lint_attrs(it.attrs.index(&FullRange), |cx| {\n+        self.with_lint_attrs(&it.attrs[], |cx| {\n             run_lints!(cx, check_foreign_item, it);\n             visit::walk_foreign_item(cx, it);\n         })\n     }\n \n     fn visit_view_item(&mut self, i: &ast::ViewItem) {\n-        self.with_lint_attrs(i.attrs.index(&FullRange), |cx| {\n+        self.with_lint_attrs(&i.attrs[], |cx| {\n             run_lints!(cx, check_view_item, i);\n             cx.visit_ids(|v| v.visit_view_item(i));\n             visit::walk_view_item(cx, i);\n@@ -627,7 +627,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n                 body: &'v ast::Block, span: Span, id: ast::NodeId) {\n         match fk {\n             visit::FkMethod(_, _, m) => {\n-                self.with_lint_attrs(m.attrs.index(&FullRange), |cx| {\n+                self.with_lint_attrs(&m.attrs[], |cx| {\n                     run_lints!(cx, check_fn, fk, decl, body, span, id);\n                     cx.visit_ids(|v| {\n                         v.visit_fn(fk, decl, body, span, id);\n@@ -643,7 +643,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n \n     fn visit_ty_method(&mut self, t: &ast::TypeMethod) {\n-        self.with_lint_attrs(t.attrs.index(&FullRange), |cx| {\n+        self.with_lint_attrs(&t.attrs[], |cx| {\n             run_lints!(cx, check_ty_method, t);\n             visit::walk_ty_method(cx, t);\n         })\n@@ -660,14 +660,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n \n     fn visit_struct_field(&mut self, s: &ast::StructField) {\n-        self.with_lint_attrs(s.node.attrs.index(&FullRange), |cx| {\n+        self.with_lint_attrs(&s.node.attrs[], |cx| {\n             run_lints!(cx, check_struct_field, s);\n             visit::walk_struct_field(cx, s);\n         })\n     }\n \n     fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics) {\n-        self.with_lint_attrs(v.node.attrs.index(&FullRange), |cx| {\n+        self.with_lint_attrs(&v.node.attrs[], |cx| {\n             run_lints!(cx, check_variant, v, g);\n             visit::walk_variant(cx, v, g);\n             run_lints!(cx, check_variant_post, v, g);\n@@ -761,7 +761,7 @@ impl<'a, 'tcx> IdVisitingOperation for Context<'a, 'tcx> {\n             None => {}\n             Some(lints) => {\n                 for (lint_id, span, msg) in lints.into_iter() {\n-                    self.span_lint(lint_id.lint, span, msg.index(&FullRange))\n+                    self.span_lint(lint_id.lint, span, &msg[])\n                 }\n             }\n         }\n@@ -811,7 +811,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n     let mut cx = Context::new(tcx, krate, exported_items);\n \n     // Visit the whole crate.\n-    cx.with_lint_attrs(krate.attrs.index(&FullRange), |cx| {\n+    cx.with_lint_attrs(&krate.attrs[], |cx| {\n         cx.visit_id(ast::CRATE_NODE_ID);\n         cx.visit_ids(|v| {\n             v.visited_outermost = true;"}, {"sha": "310874c311b121f0c848de8afb445773b19c4bc7", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -65,7 +65,7 @@ fn dump_crates(cstore: &CStore) {\n }\n \n fn should_link(i: &ast::ViewItem) -> bool {\n-    !attr::contains_name(i.attrs.index(&FullRange), \"no_link\")\n+    !attr::contains_name(&i.attrs[], \"no_link\")\n \n }\n \n@@ -90,7 +90,7 @@ pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n     for c in s.chars() {\n         if c.is_alphanumeric() { continue }\n         if c == '_' || c == '-' { continue }\n-        err(format!(\"invalid character `{}` in crate name: `{}`\", c, s).index(&FullRange));\n+        err(&format!(\"invalid character `{}` in crate name: `{}`\", c, s)[]);\n     }\n     match sess {\n         Some(sess) => sess.abort_if_errors(),\n@@ -189,8 +189,8 @@ impl<'a> CrateReader<'a> {\n         match self.extract_crate_info(i) {\n             Some(info) => {\n                 let (cnum, _, _) = self.resolve_crate(&None,\n-                                                      info.ident.index(&FullRange),\n-                                                      info.name.index(&FullRange),\n+                                                      &info.ident[],\n+                                                      &info.name[],\n                                                       None,\n                                                       i.span,\n                                                       PathKind::Crate);\n@@ -209,7 +209,7 @@ impl<'a> CrateReader<'a> {\n                 let name = match *path_opt {\n                     Some((ref path_str, _)) => {\n                         let name = path_str.get().to_string();\n-                        validate_crate_name(Some(self.sess), name.index(&FullRange),\n+                        validate_crate_name(Some(self.sess), &name[],\n                                             Some(i.span));\n                         name\n                     }\n@@ -275,8 +275,8 @@ impl<'a> CrateReader<'a> {\n                                         cstore::NativeUnknown\n                                     } else {\n                                         self.sess.span_err(m.span,\n-                                            format!(\"unknown kind: `{}`\",\n-                                                    k).index(&FullRange));\n+                                            &format!(\"unknown kind: `{}`\",\n+                                                    k)[]);\n                                         cstore::NativeUnknown\n                                     }\n                                 }\n@@ -330,7 +330,7 @@ impl<'a> CrateReader<'a> {\n             match self.sess.opts.externs.get(name) {\n                 Some(locs) => {\n                     let found = locs.iter().any(|l| {\n-                        let l = fs::realpath(&Path::new(l.index(&FullRange))).ok();\n+                        let l = fs::realpath(&Path::new(&l[])).ok();\n                         l == source.dylib || l == source.rlib\n                     });\n                     if found {\n@@ -409,7 +409,7 @@ impl<'a> CrateReader<'a> {\n                     crate_name: name,\n                     hash: hash.map(|a| &*a),\n                     filesearch: self.sess.target_filesearch(kind),\n-                    triple: self.sess.opts.target_triple.index(&FullRange),\n+                    triple: &self.sess.opts.target_triple[],\n                     root: root,\n                     rejected_via_hash: vec!(),\n                     rejected_via_triple: vec!(),\n@@ -435,8 +435,8 @@ impl<'a> CrateReader<'a> {\n         decoder::get_crate_deps(cdata).iter().map(|dep| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n             let (local_cnum, _, _) = self.resolve_crate(root,\n-                                                   dep.name.index(&FullRange),\n-                                                   dep.name.index(&FullRange),\n+                                                   &dep.name[],\n+                                                   &dep.name[],\n                                                    Some(&dep.hash),\n                                                    span,\n                                                    PathKind::Dependency);\n@@ -447,7 +447,7 @@ impl<'a> CrateReader<'a> {\n     pub fn read_plugin_metadata<'b>(&'b mut self,\n                                     vi: &'b ast::ViewItem) -> PluginMetadata<'b> {\n         let info = self.extract_crate_info(vi).unwrap();\n-        let target_triple = self.sess.opts.target_triple.index(&FullRange);\n+        let target_triple = &self.sess.opts.target_triple[];\n         let is_cross = target_triple != config::host_triple();\n         let mut should_link = info.should_link && !is_cross;\n         let mut target_only = false;\n@@ -456,8 +456,8 @@ impl<'a> CrateReader<'a> {\n         let mut load_ctxt = loader::Context {\n             sess: self.sess,\n             span: vi.span,\n-            ident: ident.index(&FullRange),\n-            crate_name: name.index(&FullRange),\n+            ident: &ident[],\n+            crate_name: &name[],\n             hash: None,\n             filesearch: self.sess.host_filesearch(PathKind::Crate),\n             triple: config::host_triple(),\n@@ -485,8 +485,8 @@ impl<'a> CrateReader<'a> {\n         let register = should_link && self.existing_match(info.name.as_slice(), None).is_none();\n         let metadata = if register {\n             // Register crate now to avoid double-reading metadata\n-            let (_, cmd, _) = self.register_crate(&None, info.ident.index(&FullRange),\n-                                info.name.index(&FullRange), vi.span, library);\n+            let (_, cmd, _) = self.register_crate(&None, &info.ident[],\n+                                &info.name[], vi.span, library);\n             PMDSource::Registered(cmd)\n         } else {\n             // Not registering the crate; just hold on to the metadata\n@@ -507,8 +507,8 @@ impl<'a> CrateReader<'a> {\n impl<'a> PluginMetadata<'a> {\n     /// Read exported macros\n     pub fn exported_macros(&self) -> Vec<ast::MacroDef> {\n-        let imported_from = Some(token::intern(self.info.ident.index(&FullRange)).ident());\n-        let source_name = format!(\"<{} macros>\", self.info.ident.index(&FullRange));\n+        let imported_from = Some(token::intern(&self.info.ident[]).ident());\n+        let source_name = format!(\"<{} macros>\", &self.info.ident[]);\n         let mut macros = vec![];\n         decoder::each_exported_macro(self.metadata.as_slice(),\n                                      &*self.sess.cstore.intr,\n@@ -550,7 +550,7 @@ impl<'a> PluginMetadata<'a> {\n                                   self.info.ident,\n                                   config::host_triple(),\n                                   self.sess.opts.target_triple);\n-            self.sess.span_err(self.vi_span, message.index(&FullRange));\n+            self.sess.span_err(self.vi_span, &message[]);\n             self.sess.abort_if_errors();\n         }\n \n@@ -563,7 +563,7 @@ impl<'a> PluginMetadata<'a> {\n                 let message = format!(\"plugin crate `{}` only found in rlib format, \\\n                                        but must be available in dylib format\",\n                                        self.info.ident);\n-                self.sess.span_err(self.vi_span, message.index(&FullRange));\n+                self.sess.span_err(self.vi_span, &message[]);\n                 // No need to abort because the loading code will just ignore this\n                 // empty dylib.\n                 None"}, {"sha": "cfff7c9935bc8ddefd18986be22f2710964d550c", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -96,7 +96,7 @@ pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem>\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n-    let mut r = vec![ast_map::PathMod(token::intern(cdata.name.index(&FullRange)))];\n+    let mut r = vec![ast_map::PathMod(token::intern(&cdata.name[]))];\n     r.push_all(path.as_slice());\n     r\n }"}, {"sha": "5ac8f908bf1642360d3e4f2ab461786eb573fefe", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -74,7 +74,7 @@ fn lookup_hash<'a, F>(d: rbml::Doc<'a>, mut eq_fn: F, hash: u64) -> Option<rbml:\n     let mut ret = None;\n     reader::tagged_docs(tagged_doc.doc, belt, |elt| {\n         let pos = u64_from_be_bytes(elt.data, elt.start, 4) as uint;\n-        if eq_fn(elt.data.index(&((elt.start + 4) .. elt.end))) {\n+        if eq_fn(&elt.data[(elt.start + 4) .. elt.end]) {\n             ret = Some(reader::doc_at(d.data, pos).unwrap().doc);\n             false\n         } else {\n@@ -88,7 +88,7 @@ pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n                            items: rbml::Doc<'a>) -> Option<rbml::Doc<'a>> {\n     fn eq_item(bytes: &[u8], item_id: ast::NodeId) -> bool {\n         return u64_from_be_bytes(\n-            bytes.index(&(0u..4u)), 0u, 4u) as ast::NodeId\n+            &bytes[0u..4u], 0u, 4u) as ast::NodeId\n             == item_id;\n     }\n     lookup_hash(items,\n@@ -1190,7 +1190,7 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n     }\n     reader::tagged_docs(depsdoc, tag_crate_dep, |depdoc| {\n         let name = docstr(depdoc, tag_crate_dep_crate_name);\n-        let hash = Svh::new(docstr(depdoc, tag_crate_dep_hash).index(&FullRange));\n+        let hash = Svh::new(&docstr(depdoc, tag_crate_dep_hash)[]);\n         deps.push(CrateDep {\n             cnum: crate_num,\n             name: name,"}, {"sha": "c8921f1b2fb934787752c4b0423da8da8da0aa08", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -94,7 +94,7 @@ fn encode_impl_type_basename(rbml_w: &mut Encoder, name: ast::Ident) {\n }\n \n pub fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n-    rbml_w.wr_tagged_str(tag_def_id, def_to_string(id).index(&FullRange));\n+    rbml_w.wr_tagged_str(tag_def_id, &def_to_string(id)[]);\n }\n \n #[derive(Clone)]\n@@ -153,7 +153,7 @@ fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n     rbml_w.end_tag();\n \n     rbml_w.start_tag(tag_mod_child);\n-    rbml_w.wr_str(s.index(&FullRange));\n+    rbml_w.wr_str(&s[]);\n     rbml_w.end_tag();\n }\n \n@@ -263,7 +263,7 @@ fn encode_symbol(ecx: &EncodeContext,\n         }\n         None => {\n             ecx.diag.handler().bug(\n-                format!(\"encode_symbol: id not found {}\", id).index(&FullRange));\n+                &format!(\"encode_symbol: id not found {}\", id)[]);\n         }\n     }\n     rbml_w.end_tag();\n@@ -331,8 +331,8 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         encode_name(rbml_w, variant.node.name.name);\n         encode_parent_item(rbml_w, local_def(id));\n         encode_visibility(rbml_w, variant.node.vis);\n-        encode_attributes(rbml_w, variant.node.attrs.index(&FullRange));\n-        encode_repr_attrs(rbml_w, ecx, variant.node.attrs.index(&FullRange));\n+        encode_attributes(rbml_w, &variant.node.attrs[]);\n+        encode_repr_attrs(rbml_w, ecx, &variant.node.attrs[]);\n \n         let stab = stability::lookup(ecx.tcx, ast_util::local_def(variant.node.id));\n         encode_stability(rbml_w, stab);\n@@ -343,9 +343,9 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                 let fields = ty::lookup_struct_fields(ecx.tcx, def_id);\n                 let idx = encode_info_for_struct(ecx,\n                                                  rbml_w,\n-                                                 fields.index(&FullRange),\n+                                                 &fields[],\n                                                  index);\n-                encode_struct_fields(rbml_w, fields.index(&FullRange), def_id);\n+                encode_struct_fields(rbml_w, &fields[], def_id);\n                 encode_index(rbml_w, idx, write_i64);\n             }\n         }\n@@ -385,12 +385,12 @@ fn encode_reexported_static_method(rbml_w: &mut Encoder,\n             exp.name, token::get_name(method_name));\n     rbml_w.start_tag(tag_items_data_item_reexport);\n     rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n-    rbml_w.wr_str(def_to_string(method_def_id).index(&FullRange));\n+    rbml_w.wr_str(&def_to_string(method_def_id)[]);\n     rbml_w.end_tag();\n     rbml_w.start_tag(tag_items_data_item_reexport_name);\n-    rbml_w.wr_str(format!(\"{}::{}\",\n+    rbml_w.wr_str(&format!(\"{}::{}\",\n                           exp.name,\n-                          token::get_name(method_name)).index(&FullRange));\n+                          token::get_name(method_name))[]);\n     rbml_w.end_tag();\n     rbml_w.end_tag();\n }\n@@ -528,7 +528,7 @@ fn encode_reexports(ecx: &EncodeContext,\n                        id);\n                 rbml_w.start_tag(tag_items_data_item_reexport);\n                 rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n-                rbml_w.wr_str(def_to_string(exp.def_id).index(&FullRange));\n+                rbml_w.wr_str(&def_to_string(exp.def_id)[]);\n                 rbml_w.end_tag();\n                 rbml_w.start_tag(tag_items_data_item_reexport_name);\n                 rbml_w.wr_str(exp.name.as_str());\n@@ -561,13 +561,13 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     // Encode info about all the module children.\n     for item in md.items.iter() {\n         rbml_w.start_tag(tag_mod_child);\n-        rbml_w.wr_str(def_to_string(local_def(item.id)).index(&FullRange));\n+        rbml_w.wr_str(&def_to_string(local_def(item.id))[]);\n         rbml_w.end_tag();\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(def_to_string(local_def(\n-                        auxiliary_node_id)).index(&FullRange));\n+            rbml_w.wr_str(&def_to_string(local_def(\n+                        auxiliary_node_id))[]);\n             rbml_w.end_tag();\n             true\n         });\n@@ -579,7 +579,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                    did, ecx.tcx.map.node_to_string(did));\n \n             rbml_w.start_tag(tag_mod_impl);\n-            rbml_w.wr_str(def_to_string(local_def(did)).index(&FullRange));\n+            rbml_w.wr_str(&def_to_string(local_def(did))[]);\n             rbml_w.end_tag();\n         }\n     }\n@@ -614,7 +614,7 @@ fn encode_visibility(rbml_w: &mut Encoder, visibility: ast::Visibility) {\n         ast::Public => 'y',\n         ast::Inherited => 'i',\n     };\n-    rbml_w.wr_str(ch.to_string().index(&FullRange));\n+    rbml_w.wr_str(&ch.to_string()[]);\n     rbml_w.end_tag();\n }\n \n@@ -626,7 +626,7 @@ fn encode_unboxed_closure_kind(rbml_w: &mut Encoder,\n         ty::FnMutUnboxedClosureKind => 'm',\n         ty::FnOnceUnboxedClosureKind => 'o',\n     };\n-    rbml_w.wr_str(ch.to_string().index(&FullRange));\n+    rbml_w.wr_str(&ch.to_string()[]);\n     rbml_w.end_tag();\n }\n \n@@ -787,7 +787,7 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         rbml_w.end_tag();\n \n         rbml_w.wr_tagged_str(tag_region_param_def_def_id,\n-                             def_to_string(param.def_id).index(&FullRange));\n+                             &def_to_string(param.def_id)[]);\n \n         rbml_w.wr_tagged_u64(tag_region_param_def_space,\n                              param.space.to_uint() as u64);\n@@ -863,9 +863,9 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n     match ast_item_opt {\n         Some(&ast::MethodImplItem(ref ast_method)) => {\n-            encode_attributes(rbml_w, ast_method.attrs.index(&FullRange));\n+            encode_attributes(rbml_w, &ast_method.attrs[]);\n             let any_types = !pty.generics.types.is_empty();\n-            if any_types || is_default_impl || should_inline(ast_method.attrs.index(&FullRange)) {\n+            if any_types || is_default_impl || should_inline(&ast_method.attrs[]) {\n                 encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id),\n                                                                ast_item_opt.unwrap()));\n             }\n@@ -911,7 +911,7 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n     match typedef_opt {\n         None => {}\n         Some(typedef) => {\n-            encode_attributes(rbml_w, typedef.attrs.index(&FullRange));\n+            encode_attributes(rbml_w, &typedef.attrs[]);\n             encode_type(ecx, rbml_w, ty::node_id_to_type(ecx.tcx,\n                                                          typedef.id));\n         }\n@@ -1045,7 +1045,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_path(rbml_w, path);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n-        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n+        encode_attributes(rbml_w, &item.attrs[]);\n         rbml_w.end_tag();\n       }\n       ast::ItemConst(_, _) => {\n@@ -1071,8 +1071,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(rbml_w, item.ident.name);\n         encode_path(rbml_w, path);\n-        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n-        if tps_len > 0u || should_inline(item.attrs.index(&FullRange)) {\n+        encode_attributes(rbml_w, &item.attrs[]);\n+        if tps_len > 0u || should_inline(&item.attrs[]) {\n             encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n         }\n         if tps_len == 0 {\n@@ -1088,7 +1088,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_info_for_mod(ecx,\n                             rbml_w,\n                             m,\n-                            item.attrs.index(&FullRange),\n+                            &item.attrs[],\n                             item.id,\n                             path,\n                             item.ident,\n@@ -1105,7 +1105,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode all the items in this module.\n         for foreign_item in fm.items.iter() {\n             rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(def_to_string(local_def(foreign_item.id)).index(&FullRange));\n+            rbml_w.wr_str(&def_to_string(local_def(foreign_item.id))[]);\n             rbml_w.end_tag();\n         }\n         encode_visibility(rbml_w, vis);\n@@ -1133,8 +1133,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n-        encode_repr_attrs(rbml_w, ecx, item.attrs.index(&FullRange));\n+        encode_attributes(rbml_w, &item.attrs[]);\n+        encode_repr_attrs(rbml_w, ecx, &item.attrs[]);\n         for v in (*enum_definition).variants.iter() {\n             encode_variant_id(rbml_w, local_def(v.node.id));\n         }\n@@ -1151,7 +1151,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_enum_variant_info(ecx,\n                                  rbml_w,\n                                  item.id,\n-                                 (*enum_definition).variants.index(&FullRange),\n+                                 &(*enum_definition).variants[],\n                                  index);\n       }\n       ast::ItemStruct(ref struct_def, _) => {\n@@ -1163,7 +1163,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n            class itself */\n         let idx = encode_info_for_struct(ecx,\n                                          rbml_w,\n-                                         fields.index(&FullRange),\n+                                         &fields[],\n                                          index);\n \n         /* Index the class*/\n@@ -1177,16 +1177,16 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n+        encode_attributes(rbml_w, &item.attrs[]);\n         encode_path(rbml_w, path.clone());\n         encode_stability(rbml_w, stab);\n         encode_visibility(rbml_w, vis);\n-        encode_repr_attrs(rbml_w, ecx, item.attrs.index(&FullRange));\n+        encode_repr_attrs(rbml_w, ecx, &item.attrs[]);\n \n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        encode_struct_fields(rbml_w, fields.index(&FullRange), def_id);\n+        encode_struct_fields(rbml_w, &fields[], def_id);\n \n         encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n \n@@ -1218,7 +1218,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(rbml_w, 'i');\n         encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n+        encode_attributes(rbml_w, &item.attrs[]);\n         encode_unsafety(rbml_w, unsafety);\n         encode_polarity(rbml_w, polarity);\n         match ty.node {\n@@ -1322,7 +1322,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_generics(rbml_w, ecx, &trait_def.generics, tag_item_generics);\n         encode_trait_ref(rbml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n+        encode_attributes(rbml_w, &item.attrs[]);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n         for &method_def_id in ty::trait_item_def_ids(tcx, def_id).iter() {\n@@ -1340,7 +1340,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             rbml_w.end_tag();\n \n             rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(def_to_string(method_def_id.def_id()).index(&FullRange));\n+            rbml_w.wr_str(&def_to_string(method_def_id.def_id())[]);\n             rbml_w.end_tag();\n         }\n         encode_path(rbml_w, path.clone());\n@@ -1432,14 +1432,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             };\n             match trait_item {\n                 &ast::RequiredMethod(ref m) => {\n-                    encode_attributes(rbml_w, m.attrs.index(&FullRange));\n+                    encode_attributes(rbml_w, &m.attrs[]);\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'r');\n                     encode_method_argument_names(rbml_w, &*m.decl);\n                 }\n \n                 &ast::ProvidedMethod(ref m) => {\n-                    encode_attributes(rbml_w, m.attrs.index(&FullRange));\n+                    encode_attributes(rbml_w, &m.attrs[]);\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'p');\n                     encode_inlined_item(ecx, rbml_w, IITraitItemRef(def_id, trait_item));\n@@ -1448,7 +1448,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n                 &ast::TypeTraitItem(ref associated_type) => {\n                     encode_attributes(rbml_w,\n-                                      associated_type.attrs.index(&FullRange));\n+                                      &associated_type.attrs[]);\n                     encode_item_sort(rbml_w, 't');\n                 }\n             }\n@@ -1827,10 +1827,10 @@ fn encode_macro_defs(rbml_w: &mut Encoder,\n         rbml_w.start_tag(tag_macro_def);\n \n         encode_name(rbml_w, def.ident.name);\n-        encode_attributes(rbml_w, def.attrs.index(&FullRange));\n+        encode_attributes(rbml_w, &def.attrs[]);\n \n         rbml_w.start_tag(tag_macro_def_body);\n-        rbml_w.wr_str(pprust::tts_to_string(def.body.index(&FullRange)).index(&FullRange));\n+        rbml_w.wr_str(&pprust::tts_to_string(&def.body[])[]);\n         rbml_w.end_tag();\n \n         rbml_w.end_tag();\n@@ -1870,7 +1870,7 @@ fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &ast::Crate) {\n         fn visit_struct_field(&mut self, field: &ast::StructField) {\n             self.rbml_w.start_tag(tag_struct_field);\n             self.rbml_w.wr_tagged_u32(tag_struct_field_id, field.node.id);\n-            encode_attributes(self.rbml_w, field.node.attrs.index(&FullRange));\n+            encode_attributes(self.rbml_w, &field.node.attrs[]);\n             self.rbml_w.end_tag();\n         }\n     }\n@@ -1942,13 +1942,13 @@ fn encode_misc_info(ecx: &EncodeContext,\n     rbml_w.start_tag(tag_misc_info_crate_items);\n     for item in krate.module.items.iter() {\n         rbml_w.start_tag(tag_mod_child);\n-        rbml_w.wr_str(def_to_string(local_def(item.id)).index(&FullRange));\n+        rbml_w.wr_str(&def_to_string(local_def(item.id))[]);\n         rbml_w.end_tag();\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(def_to_string(local_def(\n-                        auxiliary_node_id)).index(&FullRange));\n+            rbml_w.wr_str(&def_to_string(local_def(\n+                        auxiliary_node_id))[]);\n             rbml_w.end_tag();\n             true\n         });\n@@ -2117,17 +2117,17 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n \n     let mut rbml_w = writer::Encoder::new(wr);\n \n-    encode_crate_name(&mut rbml_w, ecx.link_meta.crate_name.index(&FullRange));\n+    encode_crate_name(&mut rbml_w, &ecx.link_meta.crate_name[]);\n     encode_crate_triple(&mut rbml_w,\n-                        tcx.sess\n+                        &tcx.sess\n                            .opts\n                            .target_triple\n-                           .index(&FullRange));\n+                           []);\n     encode_hash(&mut rbml_w, &ecx.link_meta.crate_hash);\n     encode_dylib_dependency_formats(&mut rbml_w, &ecx);\n \n     let mut i = rbml_w.writer.tell().unwrap();\n-    encode_attributes(&mut rbml_w, krate.attrs.index(&FullRange));\n+    encode_attributes(&mut rbml_w, &krate.attrs[]);\n     stats.attr_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     i = rbml_w.writer.tell().unwrap();"}, {"sha": "3a925aba0b7c3d6caa0f6fe8ae6b7604e4b1496c", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -315,14 +315,14 @@ impl<'a> Context<'a> {\n             &Some(ref r) => format!(\"{} which `{}` depends on\",\n                                     message, r.ident)\n         };\n-        self.sess.span_err(self.span, message.index(&FullRange));\n+        self.sess.span_err(self.span, &message[]);\n \n         if self.rejected_via_triple.len() > 0 {\n             let mismatches = self.rejected_via_triple.iter();\n             for (i, &CrateMismatch{ ref path, ref got }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n-                    format!(\"crate `{}`, path #{}, triple {}: {}\",\n-                            self.ident, i+1, got, path.display()).index(&FullRange));\n+                    &format!(\"crate `{}`, path #{}, triple {}: {}\",\n+                            self.ident, i+1, got, path.display())[]);\n             }\n         }\n         if self.rejected_via_hash.len() > 0 {\n@@ -331,16 +331,16 @@ impl<'a> Context<'a> {\n             let mismatches = self.rejected_via_hash.iter();\n             for (i, &CrateMismatch{ ref path, .. }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n-                    format!(\"crate `{}` path {}{}: {}\",\n-                            self.ident, \"#\", i+1, path.display()).index(&FullRange));\n+                    &format!(\"crate `{}` path {}{}: {}\",\n+                            self.ident, \"#\", i+1, path.display())[]);\n             }\n             match self.root {\n                 &None => {}\n                 &Some(ref r) => {\n                     for (i, path) in r.paths().iter().enumerate() {\n                         self.sess.fileline_note(self.span,\n-                            format!(\"crate `{}` path #{}: {}\",\n-                                    r.ident, i+1, path.display()).index(&FullRange));\n+                            &format!(\"crate `{}` path #{}: {}\",\n+                                    r.ident, i+1, path.display())[]);\n                     }\n                 }\n             }\n@@ -386,7 +386,7 @@ impl<'a> Context<'a> {\n                 None => return FileDoesntMatch,\n                 Some(file) => file,\n             };\n-            let (hash, rlib) = if file.starts_with(rlib_prefix.index(&FullRange)) &&\n+            let (hash, rlib) = if file.starts_with(&rlib_prefix[]) &&\n                     file.ends_with(\".rlib\") {\n                 (file.slice(rlib_prefix.len(), file.len() - \".rlib\".len()),\n                  true)\n@@ -445,27 +445,27 @@ impl<'a> Context<'a> {\n             1 => Some(libraries.into_iter().next().unwrap()),\n             _ => {\n                 self.sess.span_err(self.span,\n-                    format!(\"multiple matching crates for `{}`\",\n-                            self.crate_name).index(&FullRange));\n+                    &format!(\"multiple matching crates for `{}`\",\n+                            self.crate_name)[]);\n                 self.sess.note(\"candidates:\");\n                 for lib in libraries.iter() {\n                     match lib.dylib {\n                         Some(ref p) => {\n-                            self.sess.note(format!(\"path: {}\",\n-                                                   p.display()).index(&FullRange));\n+                            self.sess.note(&format!(\"path: {}\",\n+                                                   p.display())[]);\n                         }\n                         None => {}\n                     }\n                     match lib.rlib {\n                         Some(ref p) => {\n-                            self.sess.note(format!(\"path: {}\",\n-                                                   p.display()).index(&FullRange));\n+                            self.sess.note(&format!(\"path: {}\",\n+                                                   p.display())[]);\n                         }\n                         None => {}\n                     }\n                     let data = lib.metadata.as_slice();\n                     let name = decoder::get_crate_name(data);\n-                    note_crate_name(self.sess.diagnostic(), name.index(&FullRange));\n+                    note_crate_name(self.sess.diagnostic(), &name[]);\n                 }\n                 None\n             }\n@@ -516,22 +516,22 @@ impl<'a> Context<'a> {\n             };\n             if ret.is_some() {\n                 self.sess.span_err(self.span,\n-                                   format!(\"multiple {} candidates for `{}` \\\n+                                   &format!(\"multiple {} candidates for `{}` \\\n                                             found\",\n                                            flavor,\n-                                           self.crate_name).index(&FullRange));\n+                                           self.crate_name)[]);\n                 self.sess.span_note(self.span,\n-                                    format!(r\"candidate #1: {}\",\n+                                    &format!(r\"candidate #1: {}\",\n                                             ret.as_ref().unwrap()\n-                                               .display()).index(&FullRange));\n+                                               .display())[]);\n                 error = 1;\n                 ret = None;\n             }\n             if error > 0 {\n                 error += 1;\n                 self.sess.span_note(self.span,\n-                                    format!(r\"candidate #{}: {}\", error,\n-                                            lib.display()).index(&FullRange));\n+                                    &format!(r\"candidate #{}: {}\", error,\n+                                            lib.display())[]);\n                 continue\n             }\n             *slot = Some(metadata);\n@@ -606,31 +606,31 @@ impl<'a> Context<'a> {\n         let mut rlibs = HashSet::new();\n         let mut dylibs = HashSet::new();\n         {\n-            let mut locs = locs.iter().map(|l| Path::new(l.index(&FullRange))).filter(|loc| {\n+            let mut locs = locs.iter().map(|l| Path::new(&l[])).filter(|loc| {\n                 if !loc.exists() {\n-                    sess.err(format!(\"extern location for {} does not exist: {}\",\n-                                     self.crate_name, loc.display()).index(&FullRange));\n+                    sess.err(&format!(\"extern location for {} does not exist: {}\",\n+                                     self.crate_name, loc.display())[]);\n                     return false;\n                 }\n                 let file = match loc.filename_str() {\n                     Some(file) => file,\n                     None => {\n-                        sess.err(format!(\"extern location for {} is not a file: {}\",\n-                                         self.crate_name, loc.display()).index(&FullRange));\n+                        sess.err(&format!(\"extern location for {} is not a file: {}\",\n+                                         self.crate_name, loc.display())[]);\n                         return false;\n                     }\n                 };\n                 if file.starts_with(\"lib\") && file.ends_with(\".rlib\") {\n                     return true\n                 } else {\n                     let (ref prefix, ref suffix) = dylibname;\n-                    if file.starts_with(prefix.index(&FullRange)) &&\n-                       file.ends_with(suffix.index(&FullRange)) {\n+                    if file.starts_with(&prefix[]) &&\n+                       file.ends_with(&suffix[]) {\n                         return true\n                     }\n                 }\n-                sess.err(format!(\"extern location for {} is of an unknown type: {}\",\n-                                 self.crate_name, loc.display()).index(&FullRange));\n+                sess.err(&format!(\"extern location for {} is of an unknown type: {}\",\n+                                 self.crate_name, loc.display())[]);\n                 false\n             });\n \n@@ -663,7 +663,7 @@ impl<'a> Context<'a> {\n }\n \n pub fn note_crate_name(diag: &SpanHandler, name: &str) {\n-    diag.handler().note(format!(\"crate name: {}\", name).index(&FullRange));\n+    diag.handler().note(&format!(\"crate name: {}\", name)[]);\n }\n \n impl ArchiveMetadata {"}, {"sha": "5aacaa04e46d049ec8e42c3882481db22f5b82ba", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -98,7 +98,7 @@ fn scan<R, F, G>(st: &mut PState, mut is_last: F, op: G) -> R where\n     }\n     let end_pos = st.pos;\n     st.pos += 1;\n-    return op(st.data.index(&(start_pos..end_pos)));\n+    return op(&st.data[start_pos..end_pos]);\n }\n \n pub fn parse_ident(st: &mut PState, last: char) -> ast::Ident {\n@@ -250,8 +250,8 @@ fn parse_trait_store_<F>(st: &mut PState, conv: &mut F) -> ty::TraitStore where\n         '~' => ty::UniqTraitStore,\n         '&' => ty::RegionTraitStore(parse_region_(st, conv), parse_mutability(st)),\n         c => {\n-            st.tcx.sess.bug(format!(\"parse_trait_store(): bad input '{}'\",\n-                                    c).index(&FullRange))\n+            st.tcx.sess.bug(&format!(\"parse_trait_store(): bad input '{}'\",\n+                                    c)[])\n         }\n     }\n }\n@@ -318,7 +318,7 @@ fn parse_bound_region_<F>(st: &mut PState, conv: &mut F) -> ty::BoundRegion wher\n         }\n         '[' => {\n             let def = parse_def_(st, RegionParameter, conv);\n-            let ident = token::str_to_ident(parse_str(st, ']').index(&FullRange));\n+            let ident = token::str_to_ident(&parse_str(st, ']')[]);\n             ty::BrNamed(def, ident.name)\n         }\n         'f' => {\n@@ -357,7 +357,7 @@ fn parse_region_<F>(st: &mut PState, conv: &mut F) -> ty::Region where\n         assert_eq!(next(st), '|');\n         let index = parse_u32(st);\n         assert_eq!(next(st), '|');\n-        let nm = token::str_to_ident(parse_str(st, ']').index(&FullRange));\n+        let nm = token::str_to_ident(&parse_str(st, ']')[]);\n         ty::ReEarlyBound(node_id, space, index, nm.name)\n       }\n       'f' => {\n@@ -481,7 +481,7 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n         assert_eq!(next(st), '|');\n         let space = parse_param_space(st);\n         assert_eq!(next(st), '|');\n-        let name = token::intern(parse_str(st, ']').index(&FullRange));\n+        let name = token::intern(&parse_str(st, ']')[]);\n         return ty::mk_param(tcx, space, index, name);\n       }\n       '~' => return ty::mk_uniq(tcx, parse_ty_(st, conv)),\n@@ -637,7 +637,7 @@ fn parse_abi_set(st: &mut PState) -> abi::Abi {\n     assert_eq!(next(st), '[');\n     scan(st, |c| c == ']', |bytes| {\n         let abi_str = str::from_utf8(bytes).unwrap();\n-        abi::lookup(abi_str.index(&FullRange)).expect(abi_str)\n+        abi::lookup(&abi_str[]).expect(abi_str)\n     })\n }\n \n@@ -733,8 +733,8 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n         panic!();\n     }\n \n-    let crate_part = buf.index(&(0u..colon_idx));\n-    let def_part = buf.index(&((colon_idx + 1u)..len));\n+    let crate_part = &buf[0u..colon_idx];\n+    let def_part = &buf[(colon_idx + 1u)..len];\n \n     let crate_num = match str::from_utf8(crate_part).ok().and_then(|s| s.parse::<uint>()) {\n        Some(cn) => cn as ast::CrateNum,"}, {"sha": "8cd3795580e8bccf24d76d40ae2ffc59fb23efaf", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -47,8 +47,8 @@ pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n             let a_def = match tcx.def_map.borrow().get(&id) {\n                 None => {\n                     tcx.sess.span_bug(ast_ty.span,\n-                                      format!(\"unbound path {}\",\n-                                              path.repr(tcx)).index(&FullRange))\n+                                      &format!(\"unbound path {}\",\n+                                              path.repr(tcx))[])\n                 }\n                 Some(&d) => d\n             };"}, {"sha": "550c0f34cafec6d53782098d387d566a15b9fd40", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -132,7 +132,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n             // Do an Option dance to use the path after it is moved below.\n             let s = ast_map::path_to_string(ast_map::Values(path.iter()));\n             path_as_str = Some(s);\n-            path_as_str.as_ref().map(|x| x.index(&FullRange))\n+            path_as_str.as_ref().map(|x| &x[])\n         });\n         let mut ast_dsr = reader::Decoder::new(ast_doc);\n         let from_id_range = Decodable::decode(&mut ast_dsr).unwrap();\n@@ -1876,8 +1876,8 @@ fn decode_side_tables(dcx: &DecodeContext,\n         match c::astencode_tag::from_uint(tag) {\n             None => {\n                 dcx.tcx.sess.bug(\n-                    format!(\"unknown tag found in side tables: {:x}\",\n-                            tag).index(&FullRange));\n+                    &format!(\"unknown tag found in side tables: {:x}\",\n+                            tag)[]);\n             }\n             Some(value) => {\n                 let val_doc = entry_doc.get(c::tag_table_val as uint);\n@@ -1961,8 +1961,8 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     }\n                     _ => {\n                         dcx.tcx.sess.bug(\n-                            format!(\"unknown tag found in side tables: {:x}\",\n-                                    tag).index(&FullRange));\n+                            &format!(\"unknown tag found in side tables: {:x}\",\n+                                    tag)[]);\n                     }\n                 }\n             }"}, {"sha": "b601ea59486ce6ee32e67218530700b0c20e75f4", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -362,7 +362,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let mut cond_exit = discr_exit;\n                 for arm in arms.iter() {\n                     cond_exit = self.add_dummy_node(&[cond_exit]);        // 2\n-                    let pats_exit = self.pats_any(arm.pats.index(&FullRange),\n+                    let pats_exit = self.pats_any(&arm.pats[],\n                                                   cond_exit);            // 3\n                     let guard_exit = self.opt_expr(&arm.guard,\n                                                    pats_exit);           // 4\n@@ -615,15 +615,15 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         }\n                         self.tcx.sess.span_bug(\n                             expr.span,\n-                            format!(\"no loop scope for id {}\",\n-                                    loop_id).index(&FullRange));\n+                            &format!(\"no loop scope for id {}\",\n+                                    loop_id)[]);\n                     }\n \n                     r => {\n                         self.tcx.sess.span_bug(\n                             expr.span,\n-                            format!(\"bad entry `{:?}` in def_map for label\",\n-                                    r).index(&FullRange));\n+                            &format!(\"bad entry `{:?}` in def_map for label\",\n+                                    r)[]);\n                     }\n                 }\n             }"}, {"sha": "f4db2b6e61db2d7ba6bcf8e98a18a447f3c15f2e", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -52,7 +52,7 @@ fn replace_newline_with_backslash_l(s: String) -> String {\n }\n \n impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n-    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(self.name.index(&FullRange)).unwrap() }\n+    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(&self.name[]).unwrap() }\n \n     fn node_id(&'a self, &(i,_): &Node<'a>) -> dot::Id<'a> {\n         dot::Id::new(format!(\"N{}\", i.node_id())).unwrap()\n@@ -85,9 +85,9 @@ impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n             let s = self.ast_map.node_to_string(node_id);\n             // left-aligns the lines\n             let s = replace_newline_with_backslash_l(s);\n-            label.push_str(format!(\"exiting scope_{} {}\",\n+            label.push_str(&format!(\"exiting scope_{} {}\",\n                                    i,\n-                                   s.index(&FullRange)).index(&FullRange));\n+                                   &s[])[]);\n         }\n         dot::LabelText::EscStr(label.into_cow())\n     }"}, {"sha": "1f779acac2503b10285a8f9762fa2becad809772", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -74,11 +74,11 @@ impl<'a> CheckLoopVisitor<'a> {\n             Loop => {}\n             Closure => {\n                 self.sess.span_err(span,\n-                                   format!(\"`{}` inside of a closure\", name).index(&FullRange));\n+                                   &format!(\"`{}` inside of a closure\", name)[]);\n             }\n             Normal => {\n                 self.sess.span_err(span,\n-                                   format!(\"`{}` outside of loop\", name).index(&FullRange));\n+                                   &format!(\"`{}` outside of loop\", name)[]);\n             }\n         }\n     }"}, {"sha": "43f39a67f5c41b1d78b34b74a602d0965c2d9f40", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -47,7 +47,7 @@ struct Matrix<'a>(Vec<Vec<&'a Pat>>);\n \n /// Pretty-printer for matrices of patterns, example:\n /// ++++++++++++++++++++++++++\n-/// + _     + .index(&FullRange)             +\n+/// + _     + []             +\n /// ++++++++++++++++++++++++++\n /// + true  + [First]        +\n /// ++++++++++++++++++++++++++\n@@ -161,7 +161,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                 // First, check legality of move bindings.\n                 check_legality_of_move_bindings(cx,\n                                                 arm.guard.is_some(),\n-                                                arm.pats.index(&FullRange));\n+                                                &arm.pats[]);\n \n                 // Second, if there is a guard on each arm, make sure it isn't\n                 // assigning or borrowing anything mutably.\n@@ -198,7 +198,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n             }\n \n             // Fourth, check for unreachable arms.\n-            check_arms(cx, inlined_arms.index(&FullRange), source);\n+            check_arms(cx, &inlined_arms[], source);\n \n             // Finally, check if the whole match expression is exhaustive.\n             // Check for empty enum, because is_useful only works on inhabited types.\n@@ -228,9 +228,9 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n             is_refutable(cx, &*static_inliner.fold_pat((*pat).clone()), |uncovered_pat| {\n                 cx.tcx.sess.span_err(\n                     pat.span,\n-                    format!(\"refutable pattern in `for` loop binding: \\\n+                    &format!(\"refutable pattern in `for` loop binding: \\\n                             `{}` not covered\",\n-                            pat_to_string(uncovered_pat)).index(&FullRange));\n+                            pat_to_string(uncovered_pat))[]);\n             });\n \n             // Check legality of move bindings.\n@@ -303,7 +303,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n         for pat in pats.iter() {\n             let v = vec![&**pat];\n \n-            match is_useful(cx, &seen, v.index(&FullRange), LeaveOutWitness) {\n+            match is_useful(cx, &seen, &v[], LeaveOutWitness) {\n                 NotUseful => {\n                     match source {\n                         ast::MatchSource::IfLetDesugar { .. } => {\n@@ -355,7 +355,7 @@ fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n     match is_useful(cx, matrix, &[DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n-            let witness = match pats.index(&FullRange) {\n+            let witness = match &pats[] {\n                 [ref witness] => &**witness,\n                 [] => DUMMY_WILD_PAT,\n                 _ => unreachable!()\n@@ -609,7 +609,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n                         UsefulWithWitness(pats) => UsefulWithWitness({\n                             let arity = constructor_arity(cx, &c, left_ty);\n                             let mut result = {\n-                                let pat_slice = pats.index(&FullRange);\n+                                let pat_slice = &pats[];\n                                 let subpats: Vec<_> = range(0, arity).map(|i| {\n                                     pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n                                 }).collect();\n@@ -656,10 +656,10 @@ fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n                          witness: WitnessPreference) -> Usefulness {\n     let arity = constructor_arity(cx, &ctor, lty);\n     let matrix = Matrix(m.iter().filter_map(|r| {\n-        specialize(cx, r.index(&FullRange), &ctor, 0u, arity)\n+        specialize(cx, &r[], &ctor, 0u, arity)\n     }).collect());\n     match specialize(cx, v, &ctor, 0u, arity) {\n-        Some(v) => is_useful(cx, &matrix, v.index(&FullRange), witness),\n+        Some(v) => is_useful(cx, &matrix, &v[], witness),\n         None => NotUseful\n     }\n }\n@@ -729,7 +729,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n /// This computes the arity of a constructor. The arity of a constructor\n /// is how many subpattern patterns of that constructor should be expanded to.\n ///\n-/// For instance, a tuple pattern (_, 42u, Some(.index(&FullRange))) has the arity of 3.\n+/// For instance, a tuple pattern (_, 42u, Some([])) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> uint {\n     match ty.sty {\n@@ -926,8 +926,8 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n     };\n     head.map(|mut head| {\n-        head.push_all(r.index(&(0..col)));\n-        head.push_all(r.index(&((col + 1)..)));\n+        head.push_all(&r[0..col]);\n+        head.push_all(&r[(col + 1)..]);\n         head\n     })\n }\n@@ -1041,10 +1041,10 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                     _ => {\n                         cx.tcx.sess.span_bug(\n                             p.span,\n-                            format!(\"binding pattern {} is not an \\\n+                            &format!(\"binding pattern {} is not an \\\n                                      identifier: {:?}\",\n                                     p.id,\n-                                    p.node).index(&FullRange));\n+                                    p.node)[]);\n                     }\n                 }\n             }"}, {"sha": "154272d2deb41caefec580c198a041ed889d8cbe", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -111,8 +111,8 @@ impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n             return\n         };\n \n-        self.tcx.sess.span_err(e.span, format!(\"mutable statics are not allowed \\\n-                                                to have {}\", suffix).index(&FullRange));\n+        self.tcx.sess.span_err(e.span, &format!(\"mutable statics are not allowed \\\n+                                                to have {}\", suffix)[]);\n     }\n \n     fn check_static_type(&self, e: &ast::Expr) {\n@@ -169,8 +169,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckStaticVisitor<'a, 'tcx> {\n             ty::ty_struct(did, _) |\n             ty::ty_enum(did, _) if ty::has_dtor(self.tcx, did) => {\n                 self.tcx.sess.span_err(e.span,\n-                                       format!(\"{} are not allowed to have \\\n-                                                destructors\", self.msg()).index(&FullRange))\n+                                       &format!(\"{} are not allowed to have \\\n+                                                destructors\", self.msg())[])\n             }\n             _ => {}\n         }\n@@ -234,7 +234,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckStaticVisitor<'a, 'tcx> {\n                         let msg = \"constants cannot refer to other statics, \\\n                                    insert an intermediate constant \\\n                                    instead\";\n-                        self.tcx.sess.span_err(e.span, msg.index(&FullRange));\n+                        self.tcx.sess.span_err(e.span, &msg[]);\n                     }\n                     _ => {}\n                 }"}, {"sha": "e2a0738def180dd2c47a28e5968c7d14a21bb511", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -104,8 +104,8 @@ impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n                           ast_map::NodeForeignItem(_) => {},\n                           _ => {\n                             self.sess.span_err(e.span,\n-                              format!(\"expected item, found {}\",\n-                                      self.ast_map.node_to_string(def_id.node)).index(&FullRange));\n+                              &format!(\"expected item, found {}\",\n+                                      self.ast_map.node_to_string(def_id.node))[]);\n                             return;\n                           },\n                         }"}, {"sha": "04d4b41b21aa4a273407b8390854ed8009cf71c0", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -48,7 +48,7 @@ use std::rc::Rc;\n //     target uses\". This _includes_ integer-constants, plus the following\n //     constructors:\n //\n-//        fixed-size vectors and strings: .index(&FullRange) and \"\"/_\n+//        fixed-size vectors and strings: [] and \"\"/_\n //        vector and string slices: &[] and &\"\"\n //        tuples: (,)\n //        enums: foo(...)\n@@ -117,7 +117,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n                 ast::ItemEnum(ast::EnumDef { ref variants }, _) => {\n-                    variant_expr(variants.index(&FullRange), variant_def.node)\n+                    variant_expr(&variants[], variant_def.node)\n                 }\n                 _ => None\n             },\n@@ -138,7 +138,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n                     // NOTE this doesn't do the right thing, it compares inlined\n                     // NodeId's to the original variant_def's NodeId, but they\n                     // come from different crates, so they will likely never match.\n-                    variant_expr(variants.index(&FullRange), variant_def.node).map(|e| e.id)\n+                    variant_expr(&variants[], variant_def.node).map(|e| e.id)\n                 }\n                 _ => None\n             },\n@@ -364,7 +364,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n     match eval_const_expr_partial(tcx, e) {\n         Ok(r) => r,\n-        Err(s) => tcx.sess.span_fatal(e.span, s.index(&FullRange))\n+        Err(s) => tcx.sess.span_fatal(e.span, &s[])\n     }\n }\n "}, {"sha": "4ae0aa434065fcc34fc338b01e52515b56994f2c", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -312,7 +312,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                 let mut t = on_entry.to_vec();\n                 self.apply_gen_kill(cfgidx, t.as_mut_slice());\n                 temp_bits = t;\n-                temp_bits.index(&FullRange)\n+                &temp_bits[]\n             }\n         };\n         debug!(\"{} each_bit_for_node({:?}, cfgidx={:?}) bits={}\",\n@@ -421,7 +421,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                 let bits = self.kills.slice_mut(start, end);\n                 debug!(\"{} add_kills_from_flow_exits flow_exit={:?} bits={} [before]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n-                bits.clone_from_slice(orig_kills.index(&FullRange));\n+                bits.clone_from_slice(&orig_kills[]);\n                 debug!(\"{} add_kills_from_flow_exits flow_exit={:?} bits={} [after]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n             }\n@@ -554,7 +554,7 @@ fn bits_to_string(words: &[uint]) -> String {\n         let mut v = word;\n         for _ in range(0u, uint::BYTES) {\n             result.push(sep);\n-            result.push_str(format!(\"{:02x}\", v & 0xFF).index(&FullRange));\n+            result.push_str(&format!(\"{:02x}\", v & 0xFF)[]);\n             v >>= 8;\n             sep = '-';\n         }"}, {"sha": "cca0b7d9ad02337e1c0cf049ffca1c0177d39334", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -117,8 +117,8 @@ fn calculate_type(sess: &session::Session,\n             sess.cstore.iter_crate_data(|cnum, data| {\n                 let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n                 if src.rlib.is_some() { return }\n-                sess.err(format!(\"dependency `{}` not found in rlib format\",\n-                                 data.name).index(&FullRange));\n+                sess.err(&format!(\"dependency `{}` not found in rlib format\",\n+                                 data.name)[]);\n             });\n             return Vec::new();\n         }\n@@ -191,13 +191,13 @@ fn calculate_type(sess: &session::Session,\n             Some(cstore::RequireDynamic) if src.dylib.is_some() => continue,\n             Some(kind) => {\n                 let data = sess.cstore.get_crate_data(cnum + 1);\n-                sess.err(format!(\"crate `{}` required to be available in {}, \\\n+                sess.err(&format!(\"crate `{}` required to be available in {}, \\\n                                   but it was not available in this form\",\n                                  data.name,\n                                  match kind {\n                                      cstore::RequireStatic => \"rlib\",\n                                      cstore::RequireDynamic => \"dylib\",\n-                                 }).index(&FullRange));\n+                                 })[]);\n             }\n         }\n     }\n@@ -220,9 +220,9 @@ fn add_library(sess: &session::Session,\n             // can be refined over time.\n             if link2 != link || link == cstore::RequireStatic {\n                 let data = sess.cstore.get_crate_data(cnum);\n-                sess.err(format!(\"cannot satisfy dependencies so `{}` only \\\n+                sess.err(&format!(\"cannot satisfy dependencies so `{}` only \\\n                                   shows up once\",\n-                                 data.name).index(&FullRange));\n+                                 data.name)[]);\n                 sess.help(\"having upstream crates all available in one format \\\n                            will likely make this go away\");\n             }"}, {"sha": "e5eb439d42c75a3fa6f20bb8b22e8bab50cc7059", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -857,8 +857,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     let (m, r) = match self_ty.sty {\n                         ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                         _ => self.tcx().sess.span_bug(expr.span,\n-                                format!(\"bad overloaded deref type {}\",\n-                                    method_ty.repr(self.tcx())).index(&FullRange))\n+                                &format!(\"bad overloaded deref type {}\",\n+                                    method_ty.repr(self.tcx()))[])\n                     };\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.delegate.borrow(expr.id, expr.span, cmt,\n@@ -1180,7 +1180,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                 let msg = format!(\"Pattern has unexpected def: {:?} and type {}\",\n                                                   def,\n                                                   cmt_pat.ty.repr(tcx));\n-                                tcx.sess.span_bug(pat.span, msg.index(&FullRange))\n+                                tcx.sess.span_bug(pat.span, &msg[])\n                             }\n                         }\n                     }"}, {"sha": "05f1da788484e923589897f9431a4d8e203f0021", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -142,7 +142,7 @@ pub trait Combine<'tcx> : Sized {\n                             for _ in a_regions.iter() {\n                                 invariance.push(ty::Invariant);\n                             }\n-                            invariance.index(&FullRange)\n+                            &invariance[]\n                         }\n                     };\n \n@@ -477,10 +477,10 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n       (&ty::ty_infer(TyVar(_)), _) |\n       (_, &ty::ty_infer(TyVar(_))) => {\n         tcx.sess.bug(\n-            format!(\"{}: bot and var types should have been handled ({},{})\",\n+            &format!(\"{}: bot and var types should have been handled ({},{})\",\n                     this.tag(),\n                     a.repr(this.infcx().tcx),\n-                    b.repr(this.infcx().tcx)).index(&FullRange));\n+                    b.repr(this.infcx().tcx))[]);\n       }\n \n       (&ty::ty_err, _) | (_, &ty::ty_err) => {\n@@ -855,8 +855,8 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n             ty::ReEarlyBound(..) => {\n                 self.tcx().sess.span_bug(\n                     self.span,\n-                    format!(\"Encountered early bound region when generalizing: {}\",\n-                            r.repr(self.tcx())).index(&FullRange));\n+                    &format!(\"Encountered early bound region when generalizing: {}\",\n+                            r.repr(self.tcx()))[]);\n             }\n \n             // Always make a fresh region variable for skolemized regions;"}, {"sha": "bbd12c9671d2855c7a58dd79d01264acb1546bbf", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -200,9 +200,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                 ref trace_origins,\n                                 ref same_regions) => {\n                     if !same_regions.is_empty() {\n-                        self.report_processed_errors(var_origins.index(&FullRange),\n-                                                     trace_origins.index(&FullRange),\n-                                                     same_regions.index(&FullRange));\n+                        self.report_processed_errors(&var_origins[],\n+                                                     &trace_origins[],\n+                                                     &same_regions[]);\n                     }\n                 }\n             }\n@@ -373,10 +373,10 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n         self.tcx.sess.span_err(\n             trace.origin.span(),\n-            format!(\"{}: {} ({})\",\n+            &format!(\"{}: {} ({})\",\n                  message_root_str,\n                  expected_found_str,\n-                 ty::type_err_to_str(self.tcx, terr)).index(&FullRange));\n+                 ty::type_err_to_str(self.tcx, terr))[]);\n \n         match trace.origin {\n             infer::MatchExpressionArm(_, arm_span) =>\n@@ -445,42 +445,42 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 // Does the required lifetime have a nice name we can print?\n                 self.tcx.sess.span_err(\n                     origin.span(),\n-                    format!(\"{} may not live long enough\", labeled_user_string).index(&FullRange));\n+                    &format!(\"{} may not live long enough\", labeled_user_string)[]);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n-                    format!(\n+                    &format!(\n                         \"consider adding an explicit lifetime bound `{}: {}`...\",\n                         bound_kind.user_string(self.tcx),\n-                        sub.user_string(self.tcx)).index(&FullRange));\n+                        sub.user_string(self.tcx))[]);\n             }\n \n             ty::ReStatic => {\n                 // Does the required lifetime have a nice name we can print?\n                 self.tcx.sess.span_err(\n                     origin.span(),\n-                    format!(\"{} may not live long enough\", labeled_user_string).index(&FullRange));\n+                    &format!(\"{} may not live long enough\", labeled_user_string)[]);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n-                    format!(\n+                    &format!(\n                         \"consider adding an explicit lifetime bound `{}: 'static`...\",\n-                        bound_kind.user_string(self.tcx)).index(&FullRange));\n+                        bound_kind.user_string(self.tcx))[]);\n             }\n \n             _ => {\n                 // If not, be less specific.\n                 self.tcx.sess.span_err(\n                     origin.span(),\n-                    format!(\n+                    &format!(\n                         \"{} may not live long enough\",\n-                        labeled_user_string).index(&FullRange));\n+                        labeled_user_string)[]);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n-                    format!(\n+                    &format!(\n                         \"consider adding an explicit lifetime bound for `{}`\",\n-                        bound_kind.user_string(self.tcx)).index(&FullRange));\n+                        bound_kind.user_string(self.tcx))[]);\n                 note_and_explain_region(\n                     self.tcx,\n-                    format!(\"{} must be valid for \", labeled_user_string).index(&FullRange),\n+                    &format!(\"{} must be valid for \", labeled_user_string)[],\n                     sub,\n                     \"...\");\n             }\n@@ -517,24 +517,24 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"lifetime of borrowed pointer outlives \\\n+                    &format!(\"lifetime of borrowed pointer outlives \\\n                             lifetime of captured variable `{}`...\",\n                             ty::local_var_name_str(self.tcx,\n                                                    upvar_id.var_id)\n                                 .get()\n-                                .to_string()).index(&FullRange));\n+                                .to_string())[]);\n                 note_and_explain_region(\n                     self.tcx,\n                     \"...the borrowed pointer is valid for \",\n                     sub,\n                     \"...\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    format!(\"...but `{}` is only valid for \",\n+                    &format!(\"...but `{}` is only valid for \",\n                             ty::local_var_name_str(self.tcx,\n                                                    upvar_id.var_id)\n                                 .get()\n-                                .to_string()).index(&FullRange),\n+                                .to_string())[],\n                     sup,\n                     \"\");\n             }\n@@ -576,11 +576,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::FreeVariable(span, id) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"captured variable `{}` does not \\\n+                    &format!(\"captured variable `{}` does not \\\n                             outlive the enclosing closure\",\n                             ty::local_var_name_str(self.tcx,\n                                                    id).get()\n-                                                      .to_string()).index(&FullRange));\n+                                                      .to_string())[]);\n                 note_and_explain_region(\n                     self.tcx,\n                     \"captured variable is valid for \",\n@@ -620,9 +620,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::RelateParamBound(span, ty) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"the type `{}` does not fulfill the \\\n+                    &format!(\"the type `{}` does not fulfill the \\\n                              required lifetime\",\n-                            self.ty_to_string(ty)).index(&FullRange));\n+                            self.ty_to_string(ty))[]);\n                 note_and_explain_region(self.tcx,\n                                         \"type must outlive \",\n                                         sub,\n@@ -646,9 +646,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::RelateDefaultParamBound(span, ty) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"the type `{}` (provided as the value of \\\n+                    &format!(\"the type `{}` (provided as the value of \\\n                              a type parameter) is not valid at this point\",\n-                            self.ty_to_string(ty)).index(&FullRange));\n+                            self.ty_to_string(ty))[]);\n                 note_and_explain_region(self.tcx,\n                                         \"type must outlive \",\n                                         sub,\n@@ -712,9 +712,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::ExprTypeIsNotInScope(t, span) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"type of expression contains references \\\n+                    &format!(\"type of expression contains references \\\n                              that are not valid during the expression: `{}`\",\n-                            self.ty_to_string(t)).index(&FullRange));\n+                            self.ty_to_string(t))[]);\n                 note_and_explain_region(\n                     self.tcx,\n                     \"type is only valid for \",\n@@ -734,9 +734,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::ReferenceOutlivesReferent(ty, span) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"in type `{}`, reference has a longer lifetime \\\n+                    &format!(\"in type `{}`, reference has a longer lifetime \\\n                              than the data it references\",\n-                            self.ty_to_string(ty)).index(&FullRange));\n+                            self.ty_to_string(ty))[]);\n                 note_and_explain_region(\n                     self.tcx,\n                     \"the pointer is valid for \",\n@@ -861,7 +861,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         let (fn_decl, generics, unsafety, ident, expl_self, span)\n                                     = node_inner.expect(\"expect item fn\");\n         let taken = lifetimes_in_scope(self.tcx, scope_id);\n-        let life_giver = LifeGiver::with_taken(taken.index(&FullRange));\n+        let life_giver = LifeGiver::with_taken(&taken[]);\n         let rebuilder = Rebuilder::new(self.tcx, fn_decl, expl_self,\n                                        generics, same_regions, &life_giver);\n         let (fn_decl, expl_self, generics) = rebuilder.rebuild();\n@@ -937,7 +937,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n             }\n             expl_self_opt = self.rebuild_expl_self(expl_self_opt, lifetime,\n                                                    &anon_nums, &region_names);\n-            inputs = self.rebuild_args_ty(inputs.index(&FullRange), lifetime,\n+            inputs = self.rebuild_args_ty(&inputs[], lifetime,\n                                           &anon_nums, &region_names);\n             output = self.rebuild_output(&output, lifetime, &anon_nums, &region_names);\n             ty_params = self.rebuild_ty_params(ty_params, lifetime,\n@@ -972,7 +972,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 names.push(lt_name);\n             }\n             names.sort();\n-            let name = token::str_to_ident(names[0].index(&FullRange)).name;\n+            let name = token::str_to_ident(&names[0][]).name;\n             return (name_to_dummy_lifetime(name), Kept);\n         }\n         return (self.life_giver.give_lifetime(), Fresh);\n@@ -1220,9 +1220,9 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                         None => {\n                             self.tcx\n                                 .sess\n-                                .fatal(format!(\n+                                .fatal(&format!(\n                                         \"unbound path {}\",\n-                                        pprust::path_to_string(path)).index(&FullRange))\n+                                        pprust::path_to_string(path))[])\n                         }\n                         Some(&d) => d\n                     };\n@@ -1420,7 +1420,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                                               opt_explicit_self, generics);\n         let msg = format!(\"consider using an explicit lifetime \\\n                            parameter as shown: {}\", suggested_fn);\n-        self.tcx.sess.span_help(span, msg.index(&FullRange));\n+        self.tcx.sess.span_help(span, &msg[]);\n     }\n \n     fn report_inference_failure(&self,\n@@ -1461,9 +1461,9 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n \n         self.tcx.sess.span_err(\n             var_origin.span(),\n-            format!(\"cannot infer an appropriate lifetime{} \\\n+            &format!(\"cannot infer an appropriate lifetime{} \\\n                     due to conflicting requirements\",\n-                    var_description).index(&FullRange));\n+                    var_description)[]);\n     }\n \n     fn note_region_origin(&self, origin: &SubregionOrigin<'tcx>) {\n@@ -1510,8 +1510,8 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     Some(values_str) => {\n                         self.tcx.sess.span_note(\n                             trace.origin.span(),\n-                            format!(\"...so that {} ({})\",\n-                                    desc, values_str).index(&FullRange));\n+                            &format!(\"...so that {} ({})\",\n+                                    desc, values_str)[]);\n                     }\n                     None => {\n                         // Really should avoid printing this error at\n@@ -1520,7 +1520,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                         // doing right now. - nmatsakis\n                         self.tcx.sess.span_note(\n                             trace.origin.span(),\n-                            format!(\"...so that {}\", desc).index(&FullRange));\n+                            &format!(\"...so that {}\", desc)[]);\n                     }\n                 }\n             }\n@@ -1533,11 +1533,11 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    format!(\n+                    &format!(\n                         \"...so that closure can access `{}`\",\n                         ty::local_var_name_str(self.tcx, upvar_id.var_id)\n                             .get()\n-                            .to_string()).index(&FullRange))\n+                            .to_string())[])\n             }\n             infer::InfStackClosure(span) => {\n                 self.tcx.sess.span_note(\n@@ -1558,11 +1558,11 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::FreeVariable(span, id) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    format!(\"...so that captured variable `{}` \\\n+                    &format!(\"...so that captured variable `{}` \\\n                             does not outlive the enclosing closure\",\n                             ty::local_var_name_str(\n                                 self.tcx,\n-                                id).get().to_string()).index(&FullRange));\n+                                id).get().to_string())[]);\n             }\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_note(\n@@ -1604,9 +1604,9 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::ExprTypeIsNotInScope(t, span) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    format!(\"...so type `{}` of expression is valid during the \\\n+                    &format!(\"...so type `{}` of expression is valid during the \\\n                              expression\",\n-                            self.ty_to_string(t)).index(&FullRange));\n+                            self.ty_to_string(t))[]);\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n                 self.tcx.sess.span_note(\n@@ -1616,30 +1616,30 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::ReferenceOutlivesReferent(ty, span) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    format!(\"...so that the reference type `{}` \\\n+                    &format!(\"...so that the reference type `{}` \\\n                              does not outlive the data it points at\",\n-                            self.ty_to_string(ty)).index(&FullRange));\n+                            self.ty_to_string(ty))[]);\n             }\n             infer::RelateParamBound(span, t) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    format!(\"...so that the type `{}` \\\n+                    &format!(\"...so that the type `{}` \\\n                              will meet the declared lifetime bounds\",\n-                            self.ty_to_string(t)).index(&FullRange));\n+                            self.ty_to_string(t))[]);\n             }\n             infer::RelateDefaultParamBound(span, t) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    format!(\"...so that type parameter \\\n+                    &format!(\"...so that type parameter \\\n                              instantiated with `{}`, \\\n                              will meet its declared lifetime bounds\",\n-                            self.ty_to_string(t)).index(&FullRange));\n+                            self.ty_to_string(t))[]);\n             }\n             infer::RelateRegionParamBound(span) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    format!(\"...so that the declared lifetime parameter bounds \\\n-                                are satisfied\").index(&FullRange));\n+                    &format!(\"...so that the declared lifetime parameter bounds \\\n+                                are satisfied\")[]);\n             }\n         }\n     }\n@@ -1691,15 +1691,15 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n         Some(node) => match node {\n             ast_map::NodeItem(item) => match item.node {\n                 ast::ItemFn(_, _, _, ref gen, _) => {\n-                    taken.push_all(gen.lifetimes.index(&FullRange));\n+                    taken.push_all(&gen.lifetimes[]);\n                     None\n                 },\n                 _ => None\n             },\n             ast_map::NodeImplItem(ii) => {\n                 match *ii {\n                     ast::MethodImplItem(ref m) => {\n-                        taken.push_all(m.pe_generics().lifetimes.index(&FullRange));\n+                        taken.push_all(&m.pe_generics().lifetimes[]);\n                         Some(m.id)\n                     }\n                     ast::TypeImplItem(_) => None,\n@@ -1758,10 +1758,10 @@ impl LifeGiver {\n         let mut lifetime;\n         loop {\n             let mut s = String::from_str(\"'\");\n-            s.push_str(num_to_string(self.counter.get()).index(&FullRange));\n+            s.push_str(&num_to_string(self.counter.get())[]);\n             if !self.taken.contains(&s) {\n                 lifetime = name_to_dummy_lifetime(\n-                                    token::str_to_ident(s.index(&FullRange)).name);\n+                                    token::str_to_ident(&s[]).name);\n                 self.generated.borrow_mut().push(lifetime);\n                 break;\n             }"}, {"sha": "5d3e2dc9c93e3149c175f5040dd09d8219fb2467", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -187,9 +187,9 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n \n             infcx.tcx.sess.span_bug(\n                 span,\n-                format!(\"region {:?} is not associated with \\\n+                &format!(\"region {:?} is not associated with \\\n                          any bound region from A!\",\n-                        r0).index(&FullRange))\n+                        r0)[])\n         }\n     }\n \n@@ -322,7 +322,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n             }\n             infcx.tcx.sess.span_bug(\n                 span,\n-                format!(\"could not find original bound region for {:?}\", r).index(&FullRange));\n+                &format!(\"could not find original bound region for {:?}\", r)[]);\n         }\n \n         fn fresh_bound_variable(infcx: &InferCtxt, debruijn: ty::DebruijnIndex) -> ty::Region {\n@@ -339,7 +339,7 @@ fn var_ids<'tcx, T: Combine<'tcx>>(combiner: &T,\n             r => {\n                 combiner.infcx().tcx.sess.span_bug(\n                     combiner.trace().origin.span(),\n-                    format!(\"found non-region-vid: {:?}\", r).index(&FullRange));\n+                    &format!(\"found non-region-vid: {:?}\", r)[]);\n             }\n         }).collect()\n }"}, {"sha": "c92168b070ef67f5534c8ceda41a8ffd2290ac49", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -1000,9 +1000,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     format!(\" ({})\", ty::type_err_to_str(self.tcx, t_err))\n                 });\n \n-                self.tcx.sess.span_err(sp, format!(\"{}{}\",\n+                self.tcx.sess.span_err(sp, &format!(\"{}{}\",\n                     mk_msg(resolved_expected.map(|t| self.ty_to_string(t)), actual_ty),\n-                    error_str).index(&FullRange));\n+                    error_str)[]);\n \n                 for err in err.iter() {\n                     ty::note_and_explain_type_err(self.tcx, *err)"}, {"sha": "d54d0ae87aec0e44cf7b5b8d6139d1d5ef94be6a", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -473,9 +473,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n           (_, ReLateBound(..)) => {\n             self.tcx.sess.span_bug(\n                 origin.span(),\n-                format!(\"cannot relate bound region: {} <= {}\",\n+                &format!(\"cannot relate bound region: {} <= {}\",\n                         sub.repr(self.tcx),\n-                        sup.repr(self.tcx)).index(&FullRange));\n+                        sup.repr(self.tcx))[]);\n           }\n           (_, ReStatic) => {\n             // all regions are subregions of static, so we can ignore this\n@@ -734,9 +734,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n           (ReEarlyBound(..), _) |\n           (_, ReEarlyBound(..)) => {\n             self.tcx.sess.bug(\n-                format!(\"cannot relate bound region: LUB({}, {})\",\n+                &format!(\"cannot relate bound region: LUB({}, {})\",\n                         a.repr(self.tcx),\n-                        b.repr(self.tcx)).index(&FullRange));\n+                        b.repr(self.tcx))[]);\n           }\n \n           (ReStatic, _) | (_, ReStatic) => {\n@@ -750,10 +750,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n           (ReInfer(ReVar(v_id)), _) | (_, ReInfer(ReVar(v_id))) => {\n             self.tcx.sess.span_bug(\n                 (*self.var_origins.borrow())[v_id.index as uint].span(),\n-                format!(\"lub_concrete_regions invoked with \\\n+                &format!(\"lub_concrete_regions invoked with \\\n                          non-concrete regions: {:?}, {:?}\",\n                         a,\n-                        b).index(&FullRange));\n+                        b)[]);\n           }\n \n           (ReFree(ref fr), ReScope(s_id)) |\n@@ -834,9 +834,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             (ReEarlyBound(..), _) |\n             (_, ReEarlyBound(..)) => {\n               self.tcx.sess.bug(\n-                  format!(\"cannot relate bound region: GLB({}, {})\",\n+                  &format!(\"cannot relate bound region: GLB({}, {})\",\n                           a.repr(self.tcx),\n-                          b.repr(self.tcx)).index(&FullRange));\n+                          b.repr(self.tcx))[]);\n             }\n \n             (ReStatic, r) | (r, ReStatic) => {\n@@ -853,10 +853,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             (_, ReInfer(ReVar(v_id))) => {\n                 self.tcx.sess.span_bug(\n                     (*self.var_origins.borrow())[v_id.index as uint].span(),\n-                    format!(\"glb_concrete_regions invoked with \\\n+                    &format!(\"glb_concrete_regions invoked with \\\n                              non-concrete regions: {:?}, {:?}\",\n                             a,\n-                            b).index(&FullRange));\n+                            b)[]);\n             }\n \n             (ReFree(ref fr), ReScope(s_id)) |\n@@ -977,7 +977,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.expansion(var_data.as_mut_slice());\n         self.contraction(var_data.as_mut_slice());\n         let values =\n-            self.extract_values_and_collect_conflicts(var_data.index(&FullRange),\n+            self.extract_values_and_collect_conflicts(&var_data[],\n                                                       errors);\n         self.collect_concrete_region_errors(&values, errors);\n         values\n@@ -1411,11 +1411,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         self.tcx.sess.span_bug(\n             (*self.var_origins.borrow())[node_idx.index as uint].span(),\n-            format!(\"collect_error_for_expanding_node() could not find error \\\n+            &format!(\"collect_error_for_expanding_node() could not find error \\\n                     for var {:?}, lower_bounds={}, upper_bounds={}\",\n                     node_idx,\n                     lower_bounds.repr(self.tcx),\n-                    upper_bounds.repr(self.tcx)).index(&FullRange));\n+                    upper_bounds.repr(self.tcx))[]);\n     }\n \n     fn collect_error_for_contracting_node(\n@@ -1456,10 +1456,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         self.tcx.sess.span_bug(\n             (*self.var_origins.borrow())[node_idx.index as uint].span(),\n-            format!(\"collect_error_for_contracting_node() could not find error \\\n+            &format!(\"collect_error_for_contracting_node() could not find error \\\n                      for var {:?}, upper_bounds={}\",\n                     node_idx,\n-                    upper_bounds.repr(self.tcx)).index(&FullRange));\n+                    upper_bounds.repr(self.tcx))[]);\n     }\n \n     fn collect_concrete_regions(&self,"}, {"sha": "7bb3106b0ba6ccfa3bfce9fccf199aff5c46e1a6", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -95,8 +95,8 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n                 }\n                 ty::ty_infer(_) => {\n                     self.infcx.tcx.sess.bug(\n-                        format!(\"Unexpected type in full type resolver: {}\",\n-                                t.repr(self.infcx.tcx)).index(&FullRange));\n+                        &format!(\"Unexpected type in full type resolver: {}\",\n+                                t.repr(self.infcx.tcx))[]);\n                 }\n                 _ => {\n                     ty_fold::super_fold_ty(self, t)"}, {"sha": "1b1dca004228eafb3d9e6074f254ae19b7128b15", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -326,8 +326,8 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n           None => {\n             self.tcx\n                 .sess\n-                .span_bug(span, format!(\"no variable registered for id {}\",\n-                                        node_id).index(&FullRange));\n+                .span_bug(span, &format!(\"no variable registered for id {}\",\n+                                        node_id)[]);\n           }\n         }\n     }\n@@ -597,8 +597,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             // creating liveness nodes for.\n             self.ir.tcx.sess.span_bug(\n                 span,\n-                format!(\"no live node registered for node {}\",\n-                        node_id).index(&FullRange));\n+                &format!(\"no live node registered for node {}\",\n+                        node_id)[]);\n           }\n         }\n     }\n@@ -1133,7 +1133,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           // Uninteresting cases: just propagate in rev exec order\n \n           ast::ExprVec(ref exprs) => {\n-            self.propagate_through_exprs(exprs.index(&FullRange), succ)\n+            self.propagate_through_exprs(&exprs[], succ)\n           }\n \n           ast::ExprRepeat(ref element, ref count) => {\n@@ -1157,7 +1157,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             } else {\n                 succ\n             };\n-            let succ = self.propagate_through_exprs(args.index(&FullRange), succ);\n+            let succ = self.propagate_through_exprs(&args[], succ);\n             self.propagate_through_expr(&**f, succ)\n           }\n \n@@ -1170,11 +1170,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             } else {\n                 succ\n             };\n-            self.propagate_through_exprs(args.index(&FullRange), succ)\n+            self.propagate_through_exprs(&args[], succ)\n           }\n \n           ast::ExprTup(ref exprs) => {\n-            self.propagate_through_exprs(exprs.index(&FullRange), succ)\n+            self.propagate_through_exprs(&exprs[], succ)\n           }\n \n           ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op) => {"}, {"sha": "fb9a16f86e5bcb730a4805155de58a871d969d4d", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -584,9 +584,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                   _ => {\n                       self.tcx().sess.span_bug(\n                           span,\n-                          format!(\"Upvar of non-closure {} - {}\",\n+                          &format!(\"Upvar of non-closure {} - {}\",\n                                   fn_node_id,\n-                                  ty.repr(self.tcx())).index(&FullRange));\n+                                  ty.repr(self.tcx()))[]);\n                   }\n               }\n           }"}, {"sha": "aa37c2fe348b586c178e121114ac47d79b41d027", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -615,10 +615,10 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         match result {\n             None => true,\n             Some((span, msg, note)) => {\n-                self.tcx.sess.span_err(span, msg.index(&FullRange));\n+                self.tcx.sess.span_err(span, &msg[]);\n                 match note {\n                     Some((span, msg)) => {\n-                        self.tcx.sess.span_note(span, msg.index(&FullRange))\n+                        self.tcx.sess.span_note(span, &msg[])\n                     }\n                     None => {},\n                 }\n@@ -720,7 +720,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             UnnamedField(idx) => format!(\"field #{} of {} is private\",\n                                          idx + 1, struct_desc),\n         };\n-        self.tcx.sess.span_err(span, msg.index(&FullRange));\n+        self.tcx.sess.span_err(span, &msg[]);\n     }\n \n     // Given the ID of a method, checks to ensure it's in scope.\n@@ -741,8 +741,8 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         self.report_error(self.ensure_public(span,\n                                              method_id,\n                                              None,\n-                                             format!(\"method `{}`\",\n-                                                     string).index(&FullRange)));\n+                                             &format!(\"method `{}`\",\n+                                                     string)[]));\n     }\n \n     // Checks that a path is in scope.\n@@ -756,7 +756,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 self.ensure_public(span,\n                                    def,\n                                    Some(origdid),\n-                                   format!(\"{} `{}`\", tyname, name).index(&FullRange))\n+                                   &format!(\"{} `{}`\", tyname, name)[])\n             };\n \n             match self.last_private_map[path_id] {"}, {"sha": "906607ddc5ba14e77e205064b5f67a2425fb914c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -50,7 +50,7 @@ fn generics_require_inlining(generics: &ast::Generics) -> bool {\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n fn item_might_be_inlined(item: &ast::Item) -> bool {\n-    if attributes_specify_inlining(item.attrs.index(&FullRange)) {\n+    if attributes_specify_inlining(&item.attrs[]) {\n         return true\n     }\n \n@@ -65,7 +65,7 @@ fn item_might_be_inlined(item: &ast::Item) -> bool {\n \n fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n                            impl_src: ast::DefId) -> bool {\n-    if attributes_specify_inlining(method.attrs.index(&FullRange)) ||\n+    if attributes_specify_inlining(&method.attrs[]) ||\n         generics_require_inlining(method.pe_generics()) {\n         return true\n     }\n@@ -202,7 +202,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     ast::MethodImplItem(ref method) => {\n                         if generics_require_inlining(method.pe_generics()) ||\n                                 attributes_specify_inlining(\n-                                    method.attrs.index(&FullRange)) {\n+                                    &method.attrs[]) {\n                             true\n                         } else {\n                             let impl_did = self.tcx\n@@ -247,9 +247,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 Some(ref item) => self.propagate_node(item, search_item),\n                 None if search_item == ast::CRATE_NODE_ID => {}\n                 None => {\n-                    self.tcx.sess.bug(format!(\"found unmapped ID in worklist: \\\n+                    self.tcx.sess.bug(&format!(\"found unmapped ID in worklist: \\\n                                                {}\",\n-                                              search_item).index(&FullRange))\n+                                              search_item)[])\n                 }\n             }\n         }\n@@ -338,10 +338,10 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             _ => {\n                 self.tcx\n                     .sess\n-                    .bug(format!(\"found unexpected thingy in worklist: {}\",\n+                    .bug(&format!(\"found unexpected thingy in worklist: {}\",\n                                  self.tcx\n                                      .map\n-                                     .node_to_string(search_item)).index(&FullRange))\n+                                     .node_to_string(search_item))[])\n             }\n         }\n     }"}, {"sha": "5d33a7efd3bee4c60eab14348c520feeee5e5cbc", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -643,7 +643,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n     // A, but the inner rvalues `a()` and `b()` have an extended lifetime\n     // due to rule C.\n     //\n-    // FIXME(#6308) -- Note that `.index(&FullRange)` patterns work more smoothly post-DST.\n+    // FIXME(#6308) -- Note that `[]` patterns work more smoothly post-DST.\n \n     match local.init {\n         Some(ref expr) => {"}, {"sha": "b670099ff962a37f9470fcd5326cfe6b081b5855", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -398,8 +398,8 @@ impl<'a> LifetimeContext<'a> {\n     fn unresolved_lifetime_ref(&self, lifetime_ref: &ast::Lifetime) {\n         self.sess.span_err(\n             lifetime_ref.span,\n-            format!(\"use of undeclared lifetime name `{}`\",\n-                    token::get_name(lifetime_ref.name)).index(&FullRange));\n+            &format!(\"use of undeclared lifetime name `{}`\",\n+                    token::get_name(lifetime_ref.name))[]);\n     }\n \n     fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &Vec<ast::LifetimeDef>) {\n@@ -411,9 +411,9 @@ impl<'a> LifetimeContext<'a> {\n                 if special_idents.iter().any(|&i| i.name == lifetime.lifetime.name) {\n                     self.sess.span_err(\n                         lifetime.lifetime.span,\n-                        format!(\"illegal lifetime parameter name: `{}`\",\n+                        &format!(\"illegal lifetime parameter name: `{}`\",\n                                 token::get_name(lifetime.lifetime.name))\n-                            .index(&FullRange));\n+                        []);\n                 }\n             }\n \n@@ -424,10 +424,10 @@ impl<'a> LifetimeContext<'a> {\n                 if lifetime_i.lifetime.name == lifetime_j.lifetime.name {\n                     self.sess.span_err(\n                         lifetime_j.lifetime.span,\n-                        format!(\"lifetime name `{}` declared twice in \\\n+                        &format!(\"lifetime name `{}` declared twice in \\\n                                 the same scope\",\n                                 token::get_name(lifetime_j.lifetime.name))\n-                            .index(&FullRange));\n+                        []);\n                 }\n             }\n "}, {"sha": "d019af50a7dada9d9032cbd3b9e82e8e8b665628", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -599,12 +599,12 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                                 let span = self.span.unwrap_or(DUMMY_SP);\n                                 self.tcx().sess.span_bug(\n                                     span,\n-                                    format!(\"Type parameter out of range \\\n+                                    &format!(\"Type parameter out of range \\\n                                      when substituting in region {} (root type={}) \\\n                                      (space={:?}, index={})\",\n                                     region_name.as_str(),\n                                     self.root_ty.repr(self.tcx()),\n-                                    space, i).index(&FullRange));\n+                                    space, i)[]);\n                             }\n                         }\n                 }\n@@ -654,14 +654,14 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n                 let span = self.span.unwrap_or(DUMMY_SP);\n                 self.tcx().sess.span_bug(\n                     span,\n-                    format!(\"Type parameter `{}` ({}/{:?}/{}) out of range \\\n+                    &format!(\"Type parameter `{}` ({}/{:?}/{}) out of range \\\n                                  when substituting (root type={}) substs={}\",\n                             p.repr(self.tcx()),\n                             source_ty.repr(self.tcx()),\n                             p.space,\n                             p.idx,\n                             self.root_ty.repr(self.tcx()),\n-                            self.substs.repr(self.tcx())).index(&FullRange));\n+                            self.substs.repr(self.tcx()))[]);\n             }\n         };\n "}, {"sha": "489731e755489227b8b260cb451c3ebf0b319752", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -136,8 +136,8 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::ty_open(..) |\n         ty::ty_err => {\n             tcx.sess.bug(\n-                format!(\"ty_is_local invoked on unexpected type: {}\",\n-                        ty.repr(tcx)).index(&FullRange))\n+                &format!(\"ty_is_local invoked on unexpected type: {}\",\n+                        ty.repr(tcx))[])\n         }\n     }\n }"}, {"sha": "02c913a9e81ae34991cb6405824558085ee6a936", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -337,7 +337,7 @@ pub fn suggest_new_overflow_limit(tcx: &ty::ctxt, span: Span) {\n     let suggested_limit = current_limit * 2;\n     tcx.sess.span_note(\n         span,\n-        format!(\n+        &format!(\n             \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n-            suggested_limit).index(&FullRange));\n+            suggested_limit)[]);\n }"}, {"sha": "c3b9be85eb5058cd8e92658d12ab3249ee1b24a4", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -227,7 +227,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     }\n \n     pub fn pending_obligations(&self) -> &[PredicateObligation<'tcx>] {\n-        self.predicates.index(&FullRange)\n+        &self.predicates[]\n     }\n \n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it"}, {"sha": "c0399112c33a9a62a2c6db76a1588a3bb8d500d4", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -178,7 +178,7 @@ fn object_safety_violations_for_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // The `Self` type is erased, so it should not appear in list of\n     // arguments or return type apart from the receiver.\n     let ref sig = method.fty.sig;\n-    for &input_ty in sig.0.inputs.index(&(1..)).iter() {\n+    for &input_ty in sig.0.inputs[1..].iter() {\n         if contains_illegal_self_type_reference(tcx, trait_def_id, input_ty) {\n             return Some(MethodViolationCode::ReferencesSelf);\n         }"}, {"sha": "f38b1ee975c7244e3f49930435f022af68099bdd", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -903,7 +903,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let all_bounds =\n             util::transitive_bounds(\n-                self.tcx(), caller_trait_refs.index(&FullRange));\n+                self.tcx(), &caller_trait_refs[]);\n \n         let matching_bounds =\n             all_bounds.filter(\n@@ -1465,9 +1465,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::ty_infer(ty::FreshTy(_)) |\n             ty::ty_infer(ty::FreshIntTy(_)) => {\n                 self.tcx().sess.bug(\n-                    format!(\n+                    &format!(\n                         \"asked to assemble builtin bounds of unexpected type: {}\",\n-                        self_ty.repr(self.tcx())).index(&FullRange));\n+                        self_ty.repr(self.tcx()))[]);\n             }\n         };\n \n@@ -1636,8 +1636,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             AmbiguousBuiltin | ParameterBuiltin => {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n-                    format!(\"builtin bound for {} was ambig\",\n-                            obligation.repr(self.tcx())).index(&FullRange));\n+                    &format!(\"builtin bound for {} was ambig\",\n+                            obligation.repr(self.tcx()))[]);\n             }\n         }\n     }\n@@ -1815,8 +1815,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             _ => {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n-                    format!(\"Fn pointer candidate for inappropriate self type: {}\",\n-                            self_ty.repr(self.tcx())).index(&FullRange));\n+                    &format!(\"Fn pointer candidate for inappropriate self type: {}\",\n+                            self_ty.repr(self.tcx()))[]);\n             }\n         };\n \n@@ -1944,9 +1944,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n             Err(()) => {\n                 self.tcx().sess.bug(\n-                    format!(\"Impl {} was matchable against {} but now is not\",\n+                    &format!(\"Impl {} was matchable against {} but now is not\",\n                             impl_def_id.repr(self.tcx()),\n-                            obligation.repr(self.tcx())).index(&FullRange));\n+                            obligation.repr(self.tcx()))[]);\n             }\n         }\n     }"}, {"sha": "be883ffdd5944bc06344c39fb6a1f801fe3d99c7", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -2043,8 +2043,8 @@ impl<'tcx> Predicate<'tcx> {\n ///     struct Foo<T,U:Bar<T>> { ... }\n ///\n /// Here, the `Generics` for `Foo` would contain a list of bounds like\n-/// `[.index(&FullRange), [U:Bar<T>]]`.  Now if there were some particular reference\n-/// like `Foo<int,uint>`, then the `GenericBounds` would be `[.index(&FullRange),\n+/// `[[], [U:Bar<T>]]`.  Now if there were some particular reference\n+/// like `Foo<int,uint>`, then the `GenericBounds` would be `[[],\n /// [uint:Bar<int>]]`.\n #[derive(Clone, Show)]\n pub struct GenericBounds<'tcx> {\n@@ -2219,9 +2219,9 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                 ParameterEnvironment::for_item(cx, cx.map.get_parent(id))\n             }\n             _ => {\n-                cx.sess.bug(format!(\"ParameterEnvironment::from_item(): \\\n+                cx.sess.bug(&format!(\"ParameterEnvironment::from_item(): \\\n                                      `{}` is not an item\",\n-                                    cx.map.node_to_string(id)).index(&FullRange))\n+                                    cx.map.node_to_string(id))[])\n             }\n         }\n     }\n@@ -2306,7 +2306,7 @@ impl UnboxedClosureKind {\n         };\n         match result {\n             Ok(trait_did) => trait_did,\n-            Err(err) => cx.sess.fatal(err.index(&FullRange)),\n+            Err(err) => cx.sess.fatal(&err[]),\n         }\n     }\n }\n@@ -2627,7 +2627,7 @@ impl FlagComputation {\n             }\n \n             &ty_tup(ref ts) => {\n-                self.add_tys(ts.index(&FullRange));\n+                self.add_tys(&ts[]);\n             }\n \n             &ty_bare_fn(_, ref f) => {\n@@ -2650,7 +2650,7 @@ impl FlagComputation {\n     fn add_fn_sig(&mut self, fn_sig: &PolyFnSig) {\n         let mut computation = FlagComputation::new();\n \n-        computation.add_tys(fn_sig.0.inputs.index(&FullRange));\n+        computation.add_tys(&fn_sig.0.inputs[]);\n \n         if let ty::FnConverging(output) = fn_sig.0.output {\n             computation.add_ty(output);\n@@ -2819,7 +2819,7 @@ pub fn mk_trait<'tcx>(cx: &ctxt<'tcx>,\n \n fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n     bounds.len() == 0 ||\n-        bounds.index(&(1..)).iter().enumerate().all(\n+        bounds[1..].iter().enumerate().all(\n             |(index, bound)| bounds[index].sort_key() <= bound.sort_key())\n }\n \n@@ -3073,8 +3073,8 @@ pub fn sequence_element_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n         ty_vec(ty, _) => ty,\n         ty_str => mk_mach_uint(cx, ast::TyU8),\n         ty_open(ty) => sequence_element_type(cx, ty),\n-        _ => cx.sess.bug(format!(\"sequence_element_type called on non-sequence value: {}\",\n-                                 ty_to_string(cx, ty)).index(&FullRange)),\n+        _ => cx.sess.bug(&format!(\"sequence_element_type called on non-sequence value: {}\",\n+                                 ty_to_string(cx, ty))[]),\n     }\n }\n \n@@ -3408,7 +3408,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             ty_struct(did, substs) => {\n                 let flds = struct_fields(cx, did, substs);\n                 let mut res =\n-                    TypeContents::union(flds.index(&FullRange),\n+                    TypeContents::union(&flds[],\n                                         |f| tc_mt(cx, f.mt, cache));\n \n                 if !lookup_repr_hints(cx, did).contains(&attr::ReprExtern) {\n@@ -3432,15 +3432,15 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             }\n \n             ty_tup(ref tys) => {\n-                TypeContents::union(tys.index(&FullRange),\n+                TypeContents::union(&tys[],\n                                     |ty| tc_ty(cx, *ty, cache))\n             }\n \n             ty_enum(did, substs) => {\n                 let variants = substd_enum_variants(cx, did, substs);\n                 let mut res =\n-                    TypeContents::union(variants.index(&FullRange), |variant| {\n-                        TypeContents::union(variant.args.index(&FullRange),\n+                    TypeContents::union(&variants[], |variant| {\n+                        TypeContents::union(&variant.args[],\n                                             |arg_ty| {\n                             tc_ty(cx, *arg_ty, cache)\n                         })\n@@ -4024,8 +4024,8 @@ pub fn deref<'tcx>(ty: Ty<'tcx>, explicit: bool) -> Option<mt<'tcx>> {\n pub fn close_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n         ty_open(ty) => mk_rptr(cx, cx.mk_region(ReStatic), mt {ty: ty, mutbl:ast::MutImmutable}),\n-        _ => cx.sess.bug(format!(\"Trying to close a non-open type {}\",\n-                                 ty_to_string(cx, ty)).index(&FullRange))\n+        _ => cx.sess.bug(&format!(\"Trying to close a non-open type {}\",\n+                                 ty_to_string(cx, ty))[])\n     }\n }\n \n@@ -4125,8 +4125,8 @@ pub fn node_id_to_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId)\n     match cx.trait_refs.borrow().get(&id) {\n         Some(ty) => ty.clone(),\n         None => cx.sess.bug(\n-            format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n-                    cx.map.node_to_string(id)).index(&FullRange))\n+            &format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n+                    cx.map.node_to_string(id))[])\n     }\n }\n \n@@ -4138,8 +4138,8 @@ pub fn node_id_to_type<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> Ty<'tcx> {\n     match try_node_id_to_type(cx, id) {\n        Some(ty) => ty,\n        None => cx.sess.bug(\n-           format!(\"node_id_to_type: no type for node `{}`\",\n-                   cx.map.node_to_string(id)).index(&FullRange))\n+           &format!(\"node_id_to_type: no type for node `{}`\",\n+                   cx.map.node_to_string(id))[])\n     }\n }\n \n@@ -4225,8 +4225,8 @@ pub fn ty_region(tcx: &ctxt,\n         ref s => {\n             tcx.sess.span_bug(\n                 span,\n-                format!(\"ty_region() invoked on an inappropriate ty: {:?}\",\n-                        s).index(&FullRange));\n+                &format!(\"ty_region() invoked on an inappropriate ty: {:?}\",\n+                        s)[]);\n         }\n     }\n }\n@@ -4285,13 +4285,13 @@ pub fn expr_span(cx: &ctxt, id: NodeId) -> Span {\n             e.span\n         }\n         Some(f) => {\n-            cx.sess.bug(format!(\"Node id {} is not an expr: {:?}\",\n+            cx.sess.bug(&format!(\"Node id {} is not an expr: {:?}\",\n                                 id,\n-                                f).index(&FullRange));\n+                                f)[]);\n         }\n         None => {\n-            cx.sess.bug(format!(\"Node id {} is not present \\\n-                                in the node map\", id).index(&FullRange));\n+            cx.sess.bug(&format!(\"Node id {} is not present \\\n+                                in the node map\", id)[]);\n         }\n     }\n }\n@@ -4305,16 +4305,16 @@ pub fn local_var_name_str(cx: &ctxt, id: NodeId) -> InternedString {\n                 }\n                 _ => {\n                     cx.sess.bug(\n-                        format!(\"Variable id {} maps to {:?}, not local\",\n+                        &format!(\"Variable id {} maps to {:?}, not local\",\n                                 id,\n-                                pat).index(&FullRange));\n+                                pat)[]);\n                 }\n             }\n         }\n         r => {\n-            cx.sess.bug(format!(\"Variable id {} maps to {:?}, not local\",\n+            cx.sess.bug(&format!(\"Variable id {} maps to {:?}, not local\",\n                                 id,\n-                                r).index(&FullRange));\n+                                r)[]);\n         }\n     }\n }\n@@ -4343,9 +4343,9 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                         }\n                         ref b => {\n                             cx.sess.bug(\n-                                format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n+                                &format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n                                          {:?}\",\n-                                        b).index(&FullRange));\n+                                        b)[]);\n                         }\n                     }\n                 }\n@@ -4372,11 +4372,11 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                                 None => {\n                                     cx.sess.span_bug(\n                                         span,\n-                                        format!(\"the {}th autoderef failed: \\\n+                                        &format!(\"the {}th autoderef failed: \\\n                                                 {}\",\n                                                 i,\n                                                 ty_to_string(cx, adjusted_ty))\n-                                                          .index(&FullRange));\n+                                        []);\n                                 }\n                             }\n                         }\n@@ -4438,8 +4438,8 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n                 mk_vec(cx, ty, None)\n             }\n             _ => cx.sess.span_bug(span,\n-                                  format!(\"UnsizeLength with bad sty: {:?}\",\n-                                          ty_to_string(cx, ty)).index(&FullRange))\n+                                  &format!(\"UnsizeLength with bad sty: {:?}\",\n+                                          ty_to_string(cx, ty))[])\n         },\n         &UnsizeStruct(box ref k, tp_index) => match ty.sty {\n             ty_struct(did, substs) => {\n@@ -4450,8 +4450,8 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n                 mk_struct(cx, did, cx.mk_substs(unsized_substs))\n             }\n             _ => cx.sess.span_bug(span,\n-                                  format!(\"UnsizeStruct with bad sty: {:?}\",\n-                                          ty_to_string(cx, ty)).index(&FullRange))\n+                                  &format!(\"UnsizeStruct with bad sty: {:?}\",\n+                                          ty_to_string(cx, ty))[])\n         },\n         &UnsizeVtable(TyTrait { ref principal, ref bounds }, _) => {\n             mk_trait(cx, principal.clone(), bounds.clone())\n@@ -4463,8 +4463,8 @@ pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> def::Def {\n     match tcx.def_map.borrow().get(&expr.id) {\n         Some(&def) => def,\n         None => {\n-            tcx.sess.span_bug(expr.span, format!(\n-                \"no def-map entry for expr {}\", expr.id).index(&FullRange));\n+            tcx.sess.span_bug(expr.span, &format!(\n+                \"no def-map entry for expr {}\", expr.id)[]);\n         }\n     }\n }\n@@ -4557,9 +4557,9 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                 def => {\n                     tcx.sess.span_bug(\n                         expr.span,\n-                        format!(\"uncategorized def for expr {}: {:?}\",\n+                        &format!(\"uncategorized def for expr {}: {:?}\",\n                                 expr.id,\n-                                def).index(&FullRange));\n+                                def)[]);\n                 }\n             }\n         }\n@@ -4679,12 +4679,12 @@ pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n                      -> uint {\n     let mut i = 0u;\n     for f in fields.iter() { if f.name == name { return i; } i += 1u; }\n-    tcx.sess.bug(format!(\n+    tcx.sess.bug(&format!(\n         \"no field named `{}` found in the list of fields `{:?}`\",\n         token::get_name(name),\n         fields.iter()\n               .map(|f| token::get_name(f.name).get().to_string())\n-              .collect::<Vec<String>>()).index(&FullRange));\n+              .collect::<Vec<String>>())[]);\n }\n \n pub fn impl_or_trait_item_idx(id: ast::Name, trait_items: &[ImplOrTraitItem])\n@@ -4939,7 +4939,7 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                 match item.node {\n                     ItemTrait(_, _, _, ref ms) => {\n                         let (_, p) =\n-                            ast_util::split_trait_methods(ms.index(&FullRange));\n+                            ast_util::split_trait_methods(&ms[]);\n                         p.iter()\n                          .map(|m| {\n                             match impl_or_trait_item(\n@@ -4956,16 +4956,16 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                          }).collect()\n                     }\n                     _ => {\n-                        cx.sess.bug(format!(\"provided_trait_methods: `{:?}` is \\\n+                        cx.sess.bug(&format!(\"provided_trait_methods: `{:?}` is \\\n                                              not a trait\",\n-                                            id).index(&FullRange))\n+                                            id)[])\n                     }\n                 }\n             }\n             _ => {\n-                cx.sess.bug(format!(\"provided_trait_methods: `{:?}` is not a \\\n+                cx.sess.bug(&format!(\"provided_trait_methods: `{:?}` is not a \\\n                                      trait\",\n-                                    id).index(&FullRange))\n+                                    id)[])\n             }\n         }\n     } else {\n@@ -5203,7 +5203,7 @@ impl<'tcx> VariantInfo<'tcx> {\n                 };\n             },\n             ast::StructVariantKind(ref struct_def) => {\n-                let fields: &[StructField] = struct_def.fields.index(&FullRange);\n+                let fields: &[StructField] = &struct_def.fields[];\n \n                 assert!(fields.len() > 0);\n \n@@ -5353,8 +5353,8 @@ pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                             Err(ref err) => {\n                                                 cx.sess\n                                                   .span_err(e.span,\n-                                                            format!(\"expected constant: {}\",\n-                                                                    *err).index(&FullRange));\n+                                                            &format!(\"expected constant: {}\",\n+                                                                    *err)[]);\n                                             }\n                                         },\n                                     None => {}\n@@ -5643,8 +5643,8 @@ pub fn lookup_struct_fields(cx: &ctxt, did: ast::DefId) -> Vec<field_ty> {\n             Some(fields) => (**fields).clone(),\n             _ => {\n                 cx.sess.bug(\n-                    format!(\"ID not mapped to struct fields: {}\",\n-                            cx.map.node_to_string(did.node)).index(&FullRange));\n+                    &format!(\"ID not mapped to struct fields: {}\",\n+                            cx.map.node_to_string(did.node))[]);\n             }\n         }\n     } else {\n@@ -5677,7 +5677,7 @@ pub fn struct_fields<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId, substs: &Substs<'tc\n pub fn tup_fields<'tcx>(v: &[Ty<'tcx>]) -> Vec<field<'tcx>> {\n     v.iter().enumerate().map(|(i, &f)| {\n        field {\n-            name: token::intern(i.to_string().index(&FullRange)),\n+            name: token::intern(&i.to_string()[]),\n             mt: mt {\n                 ty: f,\n                 mutbl: MutImmutable\n@@ -5852,9 +5852,9 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n                 const_eval::const_binary(_) =>\n                     \"binary array\"\n             };\n-            tcx.sess.span_err(count_expr.span, format!(\n+            tcx.sess.span_err(count_expr.span, &format!(\n                 \"expected positive integer for repeat count, found {}\",\n-                found).index(&FullRange));\n+                found)[]);\n         }\n         Err(_) => {\n             let found = match count_expr.node {\n@@ -5867,9 +5867,9 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n                 _ =>\n                     \"non-constant expression\"\n             };\n-            tcx.sess.span_err(count_expr.span, format!(\n+            tcx.sess.span_err(count_expr.span, &format!(\n                 \"expected constant integer for repeat count, found {}\",\n-                found).index(&FullRange));\n+                found)[]);\n         }\n     }\n     0\n@@ -6654,7 +6654,7 @@ pub fn with_freevars<T, F>(tcx: &ty::ctxt, fid: ast::NodeId, f: F) -> T where\n {\n     match tcx.freevars.borrow().get(&fid) {\n         None => f(&[]),\n-        Some(d) => f(d.index(&FullRange))\n+        Some(d) => f(&d[])\n     }\n }\n "}, {"sha": "87f5ba0246fc3d86c848a7e263ce1488376dc1fb", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -223,17 +223,17 @@ impl<'a> PluginLoader<'a> {\n             // this is fatal: there are almost certainly macros we need\n             // inside this crate, so continue would spew \"macro undefined\"\n             // errors\n-            Err(err) => self.sess.span_fatal(vi.span, err.index(&FullRange))\n+            Err(err) => self.sess.span_fatal(vi.span, &err[])\n         };\n \n         unsafe {\n             let registrar =\n-                match lib.symbol(symbol.index(&FullRange)) {\n+                match lib.symbol(&symbol[]) {\n                     Ok(registrar) => {\n                         mem::transmute::<*mut u8,PluginRegistrarFun>(registrar)\n                     }\n                     // again fatal if we can't register macros\n-                    Err(err) => self.sess.span_fatal(vi.span, err.index(&FullRange))\n+                    Err(err) => self.sess.span_fatal(vi.span, &err[])\n                 };\n \n             // Intentionally leak the dynamic library. We can't ever unload it"}, {"sha": "327d4446095ca84727a7c3ff55ea731be08113ab", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -576,18 +576,18 @@ pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n             if !setter(&mut cg, value) {\n                 match (value, opt_type_desc) {\n                     (Some(..), None) => {\n-                        early_error(format!(\"codegen option `{}` takes no \\\n-                                             value\", key).index(&FullRange))\n+                        early_error(&format!(\"codegen option `{}` takes no \\\n+                                             value\", key)[])\n                     }\n                     (None, Some(type_desc)) => {\n-                        early_error(format!(\"codegen option `{0}` requires \\\n+                        early_error(&format!(\"codegen option `{0}` requires \\\n                                              {1} (-C {0}=<value>)\",\n-                                            key, type_desc).index(&FullRange))\n+                                            key, type_desc)[])\n                     }\n                     (Some(value), Some(type_desc)) => {\n-                        early_error(format!(\"incorrect value `{}` for codegen \\\n+                        early_error(&format!(\"incorrect value `{}` for codegen \\\n                                              option `{}` - {} was expected\",\n-                                             value, key, type_desc).index(&FullRange))\n+                                             value, key, type_desc)[])\n                     }\n                     (None, None) => unreachable!()\n                 }\n@@ -596,8 +596,8 @@ pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n             break;\n         }\n         if !found {\n-            early_error(format!(\"unknown codegen option: `{}`\",\n-                                key).index(&FullRange));\n+            early_error(&format!(\"unknown codegen option: `{}`\",\n+                                key)[]);\n         }\n     }\n     return cg;\n@@ -610,10 +610,10 @@ pub fn default_lib_output() -> CrateType {\n pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     use syntax::parse::token::intern_and_get_ident as intern;\n \n-    let end = sess.target.target.target_endian.index(&FullRange);\n-    let arch = sess.target.target.arch.index(&FullRange);\n-    let wordsz = sess.target.target.target_pointer_width.index(&FullRange);\n-    let os = sess.target.target.target_os.index(&FullRange);\n+    let end = &sess.target.target.target_endian[];\n+    let arch = &sess.target.target.arch[];\n+    let wordsz = &sess.target.target.target_pointer_width[];\n+    let os = &sess.target.target.target_os[];\n \n     let fam = match sess.target.target.options.is_like_windows {\n         true  => InternedString::new(\"windows\"),\n@@ -649,23 +649,23 @@ pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n         append_configuration(&mut user_cfg, InternedString::new(\"test\"))\n     }\n     let mut v = user_cfg.into_iter().collect::<Vec<_>>();\n-    v.push_all(default_cfg.index(&FullRange));\n+    v.push_all(&default_cfg[]);\n     v\n }\n \n pub fn build_target_config(opts: &Options, sp: &SpanHandler) -> Config {\n-    let target = match Target::search(opts.target_triple.index(&FullRange)) {\n+    let target = match Target::search(&opts.target_triple[]) {\n         Ok(t) => t,\n         Err(e) => {\n             sp.handler().fatal((format!(\"Error loading target specification: {}\", e)).as_slice());\n     }\n     };\n \n-    let (int_type, uint_type) = match target.target_pointer_width.index(&FullRange) {\n+    let (int_type, uint_type) = match &target.target_pointer_width[] {\n         \"32\" => (ast::TyI32, ast::TyU32),\n         \"64\" => (ast::TyI64, ast::TyU64),\n-        w    => sp.handler().fatal((format!(\"target specification was invalid: unrecognized \\\n-                                            target-word-size {}\", w)).index(&FullRange))\n+        w    => sp.handler().fatal(&format!(\"target specification was invalid: unrecognized \\\n+                                            target-word-size {}\", w)[])\n     };\n \n     Config {\n@@ -863,7 +863,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n     let crate_types = parse_crate_types_from_list(unparsed_crate_types)\n-        .unwrap_or_else(|e| early_error(e.index(&FullRange)));\n+        .unwrap_or_else(|e| early_error(&e[]));\n \n     let mut lint_opts = vec!();\n     let mut describe_lints = false;\n@@ -890,8 +890,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             }\n         }\n         if this_bit == 0 {\n-            early_error(format!(\"unknown debug flag: {}\",\n-                                *debug_flag).index(&FullRange))\n+            early_error(&format!(\"unknown debug flag: {}\",\n+                                *debug_flag)[])\n         }\n         debugging_opts |= this_bit;\n     }\n@@ -935,8 +935,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                     \"link\" => OutputTypeExe,\n                     \"dep-info\" => OutputTypeDepInfo,\n                     _ => {\n-                        early_error(format!(\"unknown emission type: `{}`\",\n-                                            part).index(&FullRange))\n+                        early_error(&format!(\"unknown emission type: `{}`\",\n+                                            part)[])\n                     }\n                 };\n                 output_types.push(output_type)\n@@ -973,9 +973,9 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                 Some(\"2\") => Default,\n                 Some(\"3\") => Aggressive,\n                 Some(arg) => {\n-                    early_error(format!(\"optimization level needs to be \\\n+                    early_error(&format!(\"optimization level needs to be \\\n                                          between 0-3 (instead was `{}`)\",\n-                                        arg).index(&FullRange));\n+                                        arg)[]);\n                 }\n             }\n         } else {\n@@ -1011,9 +1011,9 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             None      |\n             Some(\"2\") => FullDebugInfo,\n             Some(arg) => {\n-                early_error(format!(\"debug info level needs to be between \\\n+                early_error(&format!(\"debug info level needs to be between \\\n                                      0-2 (instead was `{}`)\",\n-                                    arg).index(&FullRange));\n+                                    arg)[]);\n             }\n         }\n     } else {\n@@ -1031,7 +1031,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let mut search_paths = SearchPaths::new();\n     for s in matches.opt_strs(\"L\").iter() {\n-        search_paths.add_path(s.index(&FullRange));\n+        search_paths.add_path(&s[]);\n     }\n \n     let libs = matches.opt_strs(\"l\").into_iter().map(|s| {\n@@ -1061,9 +1061,9 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             (Some(name), \"framework\") => (name, cstore::NativeFramework),\n             (Some(name), \"static\") => (name, cstore::NativeStatic),\n             (_, s) => {\n-                early_error(format!(\"unknown library kind `{}`, expected \\\n+                early_error(&format!(\"unknown library kind `{}`, expected \\\n                                      one of dylib, framework, or static\",\n-                                    s).index(&FullRange));\n+                                    s)[]);\n             }\n         };\n         (name.to_string(), kind)\n@@ -1107,17 +1107,17 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                     --debuginfo\");\n     }\n \n-    let color = match matches.opt_str(\"color\").as_ref().map(|s| s.index(&FullRange)) {\n+    let color = match matches.opt_str(\"color\").as_ref().map(|s| &s[]) {\n         Some(\"auto\")   => Auto,\n         Some(\"always\") => Always,\n         Some(\"never\")  => Never,\n \n         None => Auto,\n \n         Some(arg) => {\n-            early_error(format!(\"argument for --color must be auto, always \\\n+            early_error(&format!(\"argument for --color must be auto, always \\\n                                  or never (instead was `{}`)\",\n-                                arg).index(&FullRange))\n+                                arg)[])\n         }\n     };\n \n@@ -1220,15 +1220,15 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test() {\n         let matches =\n-            &match getopts(&[\"--test\".to_string()], optgroups().index(&FullRange)) {\n+            &match getopts(&[\"--test\".to_string()], &optgroups()[]) {\n               Ok(m) => m,\n               Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f)\n             };\n         let registry = diagnostics::registry::Registry::new(&[]);\n         let sessopts = build_session_options(matches);\n         let sess = build_session(sessopts, None, registry);\n         let cfg = build_configuration(&sess);\n-        assert!((attr::contains_name(cfg.index(&FullRange), \"test\")));\n+        assert!((attr::contains_name(&cfg[], \"test\")));\n     }\n \n     // When the user supplies --test and --cfg test, don't implicitly add\n@@ -1237,7 +1237,7 @@ mod test {\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n             &match getopts(&[\"--test\".to_string(), \"--cfg=test\".to_string()],\n-                           optgroups().index(&FullRange)) {\n+                           &optgroups()[]) {\n               Ok(m) => m,\n               Err(f) => {\n                 panic!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f)\n@@ -1257,7 +1257,7 @@ mod test {\n         {\n             let matches = getopts(&[\n                 \"-Awarnings\".to_string()\n-            ], optgroups().index(&FullRange)).unwrap();\n+            ], &optgroups()[]).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);\n@@ -1268,7 +1268,7 @@ mod test {\n             let matches = getopts(&[\n                 \"-Awarnings\".to_string(),\n                 \"-Dwarnings\".to_string()\n-            ], optgroups().index(&FullRange)).unwrap();\n+            ], &optgroups()[]).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);\n@@ -1278,7 +1278,7 @@ mod test {\n         {\n             let matches = getopts(&[\n                 \"-Adead_code\".to_string()\n-            ], optgroups().index(&FullRange)).unwrap();\n+            ], &optgroups()[]).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);"}, {"sha": "65dac1a5fac886ed8d6b7d72459ff49e1122d5a8", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -174,7 +174,7 @@ impl Session {\n     // cases later on\n     pub fn impossible_case(&self, sp: Span, msg: &str) -> ! {\n         self.span_bug(sp,\n-                      format!(\"impossible case reached: {}\", msg).index(&FullRange));\n+                      &format!(\"impossible case reached: {}\", msg)[]);\n     }\n     pub fn verbose(&self) -> bool { self.debugging_opt(config::VERBOSE) }\n     pub fn time_passes(&self) -> bool { self.debugging_opt(config::TIME_PASSES) }\n@@ -216,7 +216,7 @@ impl Session {\n     }\n     pub fn target_filesearch(&self, kind: PathKind) -> filesearch::FileSearch {\n         filesearch::FileSearch::new(self.sysroot(),\n-                                    self.opts.target_triple.index(&FullRange),\n+                                    &self.opts.target_triple[],\n                                     &self.opts.search_paths,\n                                     kind)\n     }"}, {"sha": "ec840498ae6618eb86a8521b243fd01e9ada0024", "filename": "src/librustc/util/lev_distance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Flev_distance.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -48,7 +48,7 @@ fn test_lev_distance() {\n     for c in range(0u32, MAX as u32)\n              .filter_map(|i| from_u32(i))\n              .map(|i| i.to_string()) {\n-        assert_eq!(lev_distance(c.index(&FullRange), c.index(&FullRange)), 0);\n+        assert_eq!(lev_distance(&c[], &c[]), 0);\n     }\n \n     let a = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";"}, {"sha": "b510fedc5f95245307efb57253c21a40d407909d", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -56,12 +56,12 @@ pub fn note_and_explain_region(cx: &ctxt,\n       (ref str, Some(span)) => {\n         cx.sess.span_note(\n             span,\n-            format!(\"{}{}{}\", prefix, *str, suffix).index(&FullRange));\n+            &format!(\"{}{}{}\", prefix, *str, suffix)[]);\n         Some(span)\n       }\n       (ref str, None) => {\n         cx.sess.note(\n-            format!(\"{}{}{}\", prefix, *str, suffix).index(&FullRange));\n+            &format!(\"{}{}{}\", prefix, *str, suffix)[]);\n         None\n       }\n     }\n@@ -272,7 +272,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         };\n \n         if abi != abi::Rust {\n-            s.push_str(format!(\"extern {} \", abi.to_string()).index(&FullRange));\n+            s.push_str(&format!(\"extern {} \", abi.to_string())[]);\n         };\n \n         s.push_str(\"fn\");\n@@ -291,7 +291,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             Some(def_id) => {\n                 s.push_str(\" {\");\n                 let path_str = ty::item_path_str(cx, def_id);\n-                s.push_str(path_str.index(&FullRange));\n+                s.push_str(&path_str[]);\n                 s.push_str(\"}\");\n             }\n             None => { }\n@@ -306,7 +306,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         match cty.store {\n             ty::UniqTraitStore => {}\n             ty::RegionTraitStore(region, _) => {\n-                s.push_str(region_to_string(cx, \"\", true, region).index(&FullRange));\n+                s.push_str(&region_to_string(cx, \"\", true, region)[]);\n             }\n         }\n \n@@ -325,15 +325,15 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                 assert_eq!(cty.onceness, ast::Once);\n                 s.push_str(\"proc\");\n                 push_sig_to_string(cx, &mut s, '(', ')', &cty.sig,\n-                                   bounds_str.index(&FullRange));\n+                                   &bounds_str[]);\n             }\n             ty::RegionTraitStore(..) => {\n                 match cty.onceness {\n                     ast::Many => {}\n                     ast::Once => s.push_str(\"once \")\n                 }\n                 push_sig_to_string(cx, &mut s, '|', '|', &cty.sig,\n-                                   bounds_str.index(&FullRange));\n+                                   &bounds_str[]);\n             }\n         }\n \n@@ -366,7 +366,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             ty::FnConverging(t) => {\n                 if !ty::type_is_nil(t) {\n                    s.push_str(\" -> \");\n-                   s.push_str(ty_to_string(cx, t).index(&FullRange));\n+                   s.push_str(&ty_to_string(cx, t)[]);\n                 }\n             }\n             ty::FnDiverging => {\n@@ -403,7 +403,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         }\n         ty_rptr(r, ref tm) => {\n             let mut buf = region_ptr_to_string(cx, *r);\n-            buf.push_str(mt_to_string(cx, tm).index(&FullRange));\n+            buf.push_str(&mt_to_string(cx, tm)[]);\n             buf\n         }\n         ty_open(typ) =>\n@@ -413,7 +413,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                 .iter()\n                 .map(|elem| ty_to_string(cx, *elem))\n                 .collect::<Vec<_>>();\n-            match strs.index(&FullRange) {\n+            match &strs[] {\n                 [ref string] => format!(\"({},)\", string),\n                 strs => format!(\"({})\", strs.connect(\", \"))\n             }\n@@ -542,19 +542,19 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n         0\n     };\n \n-    for t in tps.index(&(0..(tps.len() - num_defaults))).iter() {\n+    for t in tps[0..(tps.len() - num_defaults)].iter() {\n         strs.push(ty_to_string(cx, *t))\n     }\n \n     if cx.lang_items.fn_trait_kind(did).is_some() {\n         format!(\"{}({}){}\",\n                 base,\n                 if strs[0].starts_with(\"(\") && strs[0].ends_with(\",)\") {\n-                    strs[0].index(&(1 .. (strs[0].len() - 2))) // Remove '(' and ',)'\n+                    &strs[0][1 .. (strs[0].len() - 2)] // Remove '(' and ',)'\n                 } else if strs[0].starts_with(\"(\") && strs[0].ends_with(\")\") {\n-                    strs[0].index(&(1 .. (strs[0].len() - 1))) // Remove '(' and ')'\n+                    &strs[0][1 .. (strs[0].len() - 1)] // Remove '(' and ')'\n                 } else {\n-                    strs[0].index(&FullRange)\n+                    &strs[0][]\n                 },\n                 if &*strs[1] == \"()\" { String::new() } else { format!(\" -> {}\", strs[1]) })\n     } else if strs.len() > 0 {\n@@ -567,7 +567,7 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n pub fn ty_to_short_str<'tcx>(cx: &ctxt<'tcx>, typ: Ty<'tcx>) -> String {\n     let mut s = typ.repr(cx).to_string();\n     if s.len() >= 32u {\n-        s = s.index(&(0u..32u)).to_string();\n+        s = (&s[0u..32u]).to_string();\n     }\n     return s;\n }\n@@ -632,15 +632,15 @@ impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for [T] {\n \n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for OwnedSlice<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        repr_vec(tcx, self.index(&FullRange))\n+        repr_vec(tcx, &self[])\n     }\n }\n \n // This is necessary to handle types like Option<~[T]>, for which\n // autoderef cannot convert the &[T] handler\n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Vec<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        repr_vec(tcx, self.index(&FullRange))\n+        repr_vec(tcx, &self[])\n     }\n }\n "}, {"sha": "8fc95529bc08796f37013b9778f8847b7ea11e5a", "filename": "src/librustc/util/snapshot_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -116,7 +116,7 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n     pub fn actions_since_snapshot(&self,\n                                   snapshot: &Snapshot)\n                                   -> &[UndoLog<T,U>] {\n-        self.undo_log.index(&(snapshot.length..))\n+        &self.undo_log[snapshot.length..]\n     }\n \n     fn assert_open_snapshot(&self, snapshot: &Snapshot) {"}, {"sha": "7ea192b8d6bc882ba37697bfd7d8ebc49172b633", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -53,7 +53,7 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n           args: &str, cwd: Option<&Path>,\n           paths: &[&Path]) -> ProcessOutput {\n     let ar = match *maybe_ar_prog {\n-        Some(ref ar) => ar.index(&FullRange),\n+        Some(ref ar) => &ar[],\n         None => \"ar\"\n     };\n     let mut cmd = Command::new(ar);\n@@ -73,24 +73,21 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n         Ok(prog) => {\n             let o = prog.wait_with_output().unwrap();\n             if !o.status.success() {\n-                handler.err(format!(\"{} failed with: {}\",\n+                handler.err(&format!(\"{} failed with: {}\",\n                                  cmd,\n-                                 o.status).index(&FullRange));\n-                handler.note(format!(\"stdout ---\\n{}\",\n-                                  str::from_utf8(o.output\n-                                                  .index(&FullRange)).unwrap())\n-                          .index(&FullRange));\n-                handler.note(format!(\"stderr ---\\n{}\",\n-                                  str::from_utf8(o.error\n-                                                  .index(&FullRange)).unwrap())\n-                          .index(&FullRange));\n+                                 o.status)[]);\n+                handler.note(&format!(\"stdout ---\\n{}\",\n+                                  str::from_utf8(&o.output[]).unwrap())[]);\n+                handler.note(&format!(\"stderr ---\\n{}\",\n+                                  str::from_utf8(&o.error[]).unwrap())\n+                             []);\n                 handler.abort_if_errors();\n             }\n             o\n         },\n         Err(e) => {\n-            handler.err(format!(\"could not exec `{}`: {}\", ar.index(&FullRange),\n-                             e).index(&FullRange));\n+            handler.err(&format!(\"could not exec `{}`: {}\", &ar[],\n+                             e)[]);\n             handler.abort_if_errors();\n             panic!(\"rustc::back::archive::run_ar() should not reach this point\");\n         }\n@@ -106,16 +103,16 @@ pub fn find_library(name: &str, osprefix: &str, ossuffix: &str,\n \n     for path in search_paths.iter() {\n         debug!(\"looking for {} inside {:?}\", name, path.display());\n-        let test = path.join(oslibname.index(&FullRange));\n+        let test = path.join(&oslibname[]);\n         if test.exists() { return test }\n         if oslibname != unixlibname {\n-            let test = path.join(unixlibname.index(&FullRange));\n+            let test = path.join(&unixlibname[]);\n             if test.exists() { return test }\n         }\n     }\n-    handler.fatal(format!(\"could not find native static library `{}`, \\\n+    handler.fatal(&format!(\"could not find native static library `{}`, \\\n                            perhaps an -L flag is missing?\",\n-                          name).index(&FullRange));\n+                          name)[]);\n }\n \n impl<'a> Archive<'a> {\n@@ -147,7 +144,7 @@ impl<'a> Archive<'a> {\n     /// Lists all files in an archive\n     pub fn files(&self) -> Vec<String> {\n         let output = run_ar(self.handler, &self.maybe_ar_prog, \"t\", None, &[&self.dst]);\n-        let output = str::from_utf8(output.output.index(&FullRange)).unwrap();\n+        let output = str::from_utf8(&output.output[]).unwrap();\n         // use lines_any because windows delimits output with `\\r\\n` instead of\n         // just `\\n`\n         output.lines_any().map(|s| s.to_string()).collect()\n@@ -179,9 +176,9 @@ impl<'a> ArchiveBuilder<'a> {\n     /// search in the relevant locations for a library named `name`.\n     pub fn add_native_library(&mut self, name: &str) -> io::IoResult<()> {\n         let location = find_library(name,\n-                                    self.archive.slib_prefix.index(&FullRange),\n-                                    self.archive.slib_suffix.index(&FullRange),\n-                                    self.archive.lib_search_paths.index(&FullRange),\n+                                    &self.archive.slib_prefix[],\n+                                    &self.archive.slib_suffix[],\n+                                    &self.archive.lib_search_paths[],\n                                     self.archive.handler);\n         self.add_archive(&location, name, |_| false)\n     }\n@@ -197,12 +194,12 @@ impl<'a> ArchiveBuilder<'a> {\n         // as simple comparison is not enough - there\n         // might be also an extra name suffix\n         let obj_start = format!(\"{}\", name);\n-        let obj_start = obj_start.index(&FullRange);\n+        let obj_start = &obj_start[];\n         // Ignoring all bytecode files, no matter of\n         // name\n         let bc_ext = \".bytecode.deflate\";\n \n-        self.add_archive(rlib, name.index(&FullRange), |fname: &str| {\n+        self.add_archive(rlib, &name[], |fname: &str| {\n             let skip_obj = lto && fname.starts_with(obj_start)\n                 && fname.ends_with(\".o\");\n             skip_obj || fname.ends_with(bc_ext) || fname == METADATA_FILENAME\n@@ -239,7 +236,7 @@ impl<'a> ArchiveBuilder<'a> {\n             // allow running `ar s file.a` to update symbols only.\n             if self.should_update_symbols {\n                 run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-                       \"s\", Some(self.work_dir.path()), args.index(&FullRange));\n+                       \"s\", Some(self.work_dir.path()), &args[]);\n             }\n             return self.archive;\n         }\n@@ -259,7 +256,7 @@ impl<'a> ArchiveBuilder<'a> {\n                 // Add the archive members seen so far, without updating the\n                 // symbol table (`S`).\n                 run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-                       \"cruS\", Some(self.work_dir.path()), args.index(&FullRange));\n+                       \"cruS\", Some(self.work_dir.path()), &args[]);\n \n                 args.clear();\n                 args.push(&abs_dst);\n@@ -274,7 +271,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // necessary.\n         let flags = if self.should_update_symbols { \"crus\" } else { \"cruS\" };\n         run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-               flags, Some(self.work_dir.path()), args.index(&FullRange));\n+               flags, Some(self.work_dir.path()), &args[]);\n \n         self.archive\n     }\n@@ -316,7 +313,7 @@ impl<'a> ArchiveBuilder<'a> {\n             } else {\n                 filename\n             };\n-            let new_filename = self.work_dir.path().join(filename.index(&FullRange));\n+            let new_filename = self.work_dir.path().join(&filename[]);\n             try!(fs::rename(file, &new_filename));\n             self.members.push(Path::new(filename));\n         }"}, {"sha": "d24fd6a5b3f0558bf8d0961d0bb83f866dc8a4da", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -44,15 +44,15 @@ pub fn get_rpath_flags<F, G>(config: RPathConfig<F, G>) -> Vec<String> where\n         l.map(|p| p.clone())\n     }).collect::<Vec<_>>();\n \n-    let rpaths = get_rpaths(config, libs.index(&FullRange));\n-    flags.push_all(rpaths_to_flags(rpaths.index(&FullRange)).index(&FullRange));\n+    let rpaths = get_rpaths(config, &libs[]);\n+    flags.push_all(&rpaths_to_flags(&rpaths[])[]);\n     flags\n }\n \n fn rpaths_to_flags(rpaths: &[String]) -> Vec<String> {\n     let mut ret = Vec::new();\n     for rpath in rpaths.iter() {\n-        ret.push(format!(\"-Wl,-rpath,{}\", (*rpath).index(&FullRange)));\n+        ret.push(format!(\"-Wl,-rpath,{}\", &(*rpath)[]));\n     }\n     return ret;\n }\n@@ -82,14 +82,14 @@ fn get_rpaths<F, G>(mut config: RPathConfig<F, G>, libs: &[Path]) -> Vec<String>\n         }\n     }\n \n-    log_rpaths(\"relative\", rel_rpaths.index(&FullRange));\n-    log_rpaths(\"fallback\", fallback_rpaths.index(&FullRange));\n+    log_rpaths(\"relative\", &rel_rpaths[]);\n+    log_rpaths(\"fallback\", &fallback_rpaths[]);\n \n     let mut rpaths = rel_rpaths;\n-    rpaths.push_all(fallback_rpaths.index(&FullRange));\n+    rpaths.push_all(&fallback_rpaths[]);\n \n     // Remove duplicates\n-    let rpaths = minimize_rpaths(rpaths.index(&FullRange));\n+    let rpaths = minimize_rpaths(&rpaths[]);\n     return rpaths;\n }\n \n@@ -140,7 +140,7 @@ fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n     let mut set = HashSet::new();\n     let mut minimized = Vec::new();\n     for rpath in rpaths.iter() {\n-        if set.insert(rpath.index(&FullRange)) {\n+        if set.insert(&rpath[]) {\n             minimized.push(rpath.clone());\n         }\n     }"}, {"sha": "ac5662f534c86c4fa229ac14eb590f679b6348af", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -140,7 +140,7 @@ impl FixedBuffer for FixedBuffer64 {\n             if input.len() >= buffer_remaining {\n                     copy_memory(\n                         self.buffer.slice_mut(self.buffer_idx, size),\n-                        input.index(&(0..buffer_remaining)));\n+                        &input[0..buffer_remaining]);\n                 self.buffer_idx = 0;\n                 func(&self.buffer);\n                 i += buffer_remaining;\n@@ -156,7 +156,7 @@ impl FixedBuffer for FixedBuffer64 {\n         // While we have at least a full buffer size chunk's worth of data, process that data\n         // without copying it into the buffer\n         while input.len() - i >= size {\n-            func(input.index(&(i..(i + size))));\n+            func(&input[i..(i + size)]);\n             i += size;\n         }\n \n@@ -166,7 +166,7 @@ impl FixedBuffer for FixedBuffer64 {\n         let input_remaining = input.len() - i;\n         copy_memory(\n             self.buffer.slice_to_mut(input_remaining),\n-            input.index(&(i..)));\n+            &input[i..]);\n         self.buffer_idx += input_remaining;\n     }\n \n@@ -188,7 +188,7 @@ impl FixedBuffer for FixedBuffer64 {\n     fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n         assert!(self.buffer_idx == 64);\n         self.buffer_idx = 0;\n-        return self.buffer.index(&(0..64));\n+        return &self.buffer[0..64];\n     }\n \n     fn position(&self) -> uint { self.buffer_idx }"}, {"sha": "4e260da2e4dedd3ff176f35473410da6b1894f28", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -64,7 +64,7 @@ impl Svh {\n     }\n \n     pub fn as_str<'a>(&'a self) -> &'a str {\n-        self.hash.index(&FullRange)\n+        &self.hash[]\n     }\n \n     pub fn calculate(metadata: &Vec<String>, krate: &ast::Crate) -> Svh {\n@@ -362,7 +362,7 @@ mod svh_visitor {\n             fn macro_name(mac: &Mac) -> token::InternedString {\n                 match &mac.node {\n                     &MacInvocTT(ref path, ref _tts, ref _stx_ctxt) => {\n-                        let s = path.segments.index(&FullRange);\n+                        let s = &path.segments[];\n                         assert_eq!(s.len(), 1);\n                         content(s[0].identifier)\n                     }"}, {"sha": "069e798887b93f8eb45146670a415b3e9551ab36", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -224,8 +224,7 @@ impl Target {\n                      .and_then(|os| os.map(|s| s.to_string())) {\n                 Some(val) => val,\n                 None =>\n-                    handler.fatal((format!(\"Field {} in target specification is required\", name))\n-                                  .index(&FullRange))\n+                    handler.fatal(&format!(\"Field {} in target specification is required\", name)[])\n             }\n         };\n \n@@ -242,18 +241,18 @@ impl Target {\n         macro_rules! key {\n             ($key_name:ident) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(name.index(&FullRange)).map(|o| o.as_string()\n+                obj.find(&name[]).map(|o| o.as_string()\n                                     .map(|s| base.options.$key_name = s.to_string()));\n             } );\n             ($key_name:ident, bool) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(name.index(&FullRange))\n+                obj.find(&name[])\n                     .map(|o| o.as_boolean()\n                          .map(|s| base.options.$key_name = s));\n             } );\n             ($key_name:ident, list) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(name.index(&FullRange)).map(|o| o.as_array()\n+                obj.find(&name[]).map(|o| o.as_array()\n                     .map(|v| base.options.$key_name = v.iter()\n                         .map(|a| a.as_string().unwrap().to_string()).collect()\n                         )\n@@ -369,7 +368,7 @@ impl Target {\n \n         let target_path = os::getenv(\"RUST_TARGET_PATH\").unwrap_or(String::new());\n \n-        let paths = os::split_paths(target_path.index(&FullRange));\n+        let paths = os::split_paths(&target_path[]);\n         // FIXME 16351: add a sane default search path?\n \n         for dir in paths.iter() {"}, {"sha": "d5ad201eabfaaa959768054b73f5568d893acb0f", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -463,47 +463,47 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 (ty::MutBorrow, ty::MutBorrow) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n-                        format!(\"cannot borrow `{}`{} as mutable \\\n+                        &format!(\"cannot borrow `{}`{} as mutable \\\n                                 more than once at a time\",\n-                                nl, new_loan_msg).index(&FullRange))\n+                                nl, new_loan_msg)[])\n                 }\n \n                 (ty::UniqueImmBorrow, _) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n-                        format!(\"closure requires unique access to `{}` \\\n+                        &format!(\"closure requires unique access to `{}` \\\n                                 but {} is already borrowed{}\",\n-                                nl, ol_pronoun, old_loan_msg).index(&FullRange));\n+                                nl, ol_pronoun, old_loan_msg)[]);\n                 }\n \n                 (_, ty::UniqueImmBorrow) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n-                        format!(\"cannot borrow `{}`{} as {} because \\\n+                        &format!(\"cannot borrow `{}`{} as {} because \\\n                                 previous closure requires unique access\",\n-                                nl, new_loan_msg, new_loan.kind.to_user_str()).index(&FullRange));\n+                                nl, new_loan_msg, new_loan.kind.to_user_str())[]);\n                 }\n \n                 (_, _) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n-                        format!(\"cannot borrow `{}`{} as {} because \\\n+                        &format!(\"cannot borrow `{}`{} as {} because \\\n                                 {} is also borrowed as {}{}\",\n                                 nl,\n                                 new_loan_msg,\n                                 new_loan.kind.to_user_str(),\n                                 ol_pronoun,\n                                 old_loan.kind.to_user_str(),\n-                                old_loan_msg).index(&FullRange));\n+                                old_loan_msg)[]);\n                 }\n             }\n \n             match new_loan.cause {\n                 euv::ClosureCapture(span) => {\n                     self.bccx.span_note(\n                         span,\n-                        format!(\"borrow occurs due to use of `{}` in closure\",\n-                                nl).index(&FullRange));\n+                        &format!(\"borrow occurs due to use of `{}` in closure\",\n+                                nl)[]);\n                 }\n                 _ => { }\n             }\n@@ -552,7 +552,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n             self.bccx.span_note(\n                 old_loan.span,\n-                format!(\"{}; {}\", borrow_summary, rule_summary).index(&FullRange));\n+                &format!(\"{}; {}\", borrow_summary, rule_summary)[]);\n \n             let old_loan_span = self.tcx().map.span(old_loan.kill_scope.node_id());\n             self.bccx.span_end_note(old_loan_span,\n@@ -621,14 +621,14 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             UseWhileBorrowed(loan_path, loan_span) => {\n                 self.bccx.span_err(\n                     span,\n-                    format!(\"cannot use `{}` because it was mutably borrowed\",\n-                            self.bccx.loan_path_to_string(copy_path).index(&FullRange))\n-                    .index(&FullRange));\n+                    &format!(\"cannot use `{}` because it was mutably borrowed\",\n+                            &self.bccx.loan_path_to_string(copy_path)[])\n+                    []);\n                 self.bccx.span_note(\n                     loan_span,\n-                    format!(\"borrow of `{}` occurs here\",\n-                            self.bccx.loan_path_to_string(&*loan_path).index(&FullRange))\n-                    .index(&FullRange));\n+                    &format!(\"borrow of `{}` occurs here\",\n+                            &self.bccx.loan_path_to_string(&*loan_path)[])\n+                    []);\n             }\n         }\n     }\n@@ -647,20 +647,20 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 let err_message = match move_kind {\n                     move_data::Captured =>\n                         format!(\"cannot move `{}` into closure because it is borrowed\",\n-                                self.bccx.loan_path_to_string(move_path).index(&FullRange)),\n+                                &self.bccx.loan_path_to_string(move_path)[]),\n                     move_data::Declared |\n                     move_data::MoveExpr |\n                     move_data::MovePat =>\n                         format!(\"cannot move out of `{}` because it is borrowed\",\n-                                self.bccx.loan_path_to_string(move_path).index(&FullRange))\n+                                &self.bccx.loan_path_to_string(move_path)[])\n                 };\n \n-                self.bccx.span_err(span, err_message.index(&FullRange));\n+                self.bccx.span_err(span, &err_message[]);\n                 self.bccx.span_note(\n                     loan_span,\n-                    format!(\"borrow of `{}` occurs here\",\n-                            self.bccx.loan_path_to_string(&*loan_path).index(&FullRange))\n-                    .index(&FullRange));\n+                    &format!(\"borrow of `{}` occurs here\",\n+                            &self.bccx.loan_path_to_string(&*loan_path)[])\n+                    []);\n             }\n         }\n     }\n@@ -809,34 +809,34 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 if kind == ty::FnUnboxedClosureKind {\n                     self.bccx.span_err(\n                         assignment_span,\n-                        format!(\"cannot assign to {}\",\n-                                self.bccx.cmt_to_string(&*assignee_cmt)).index(&FullRange));\n+                        &format!(\"cannot assign to {}\",\n+                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n                     self.bccx.span_help(\n                         self.tcx().map.span(upvar_id.closure_expr_id),\n                         \"consider changing this closure to take self by mutable reference\");\n                 } else {\n                     self.bccx.span_err(\n                         assignment_span,\n-                        format!(\"cannot assign to {} {}\",\n+                        &format!(\"cannot assign to {} {}\",\n                                 assignee_cmt.mutbl.to_user_str(),\n-                                self.bccx.cmt_to_string(&*assignee_cmt)).index(&FullRange));\n+                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n                 }\n             }\n             _ => match opt_loan_path(&assignee_cmt) {\n                 Some(lp) => {\n                     self.bccx.span_err(\n                         assignment_span,\n-                        format!(\"cannot assign to {} {} `{}`\",\n+                        &format!(\"cannot assign to {} {} `{}`\",\n                                 assignee_cmt.mutbl.to_user_str(),\n                                 self.bccx.cmt_to_string(&*assignee_cmt),\n-                                self.bccx.loan_path_to_string(&*lp)).index(&FullRange));\n+                                self.bccx.loan_path_to_string(&*lp))[]);\n                 }\n                 None => {\n                     self.bccx.span_err(\n                         assignment_span,\n-                        format!(\"cannot assign to {} {}\",\n+                        &format!(\"cannot assign to {} {}\",\n                                 assignee_cmt.mutbl.to_user_str(),\n-                                self.bccx.cmt_to_string(&*assignee_cmt)).index(&FullRange));\n+                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n                 }\n             }\n         }\n@@ -955,11 +955,11 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                    loan: &Loan) {\n         self.bccx.span_err(\n             span,\n-            format!(\"cannot assign to `{}` because it is borrowed\",\n-                    self.bccx.loan_path_to_string(loan_path)).index(&FullRange));\n+            &format!(\"cannot assign to `{}` because it is borrowed\",\n+                    self.bccx.loan_path_to_string(loan_path))[]);\n         self.bccx.span_note(\n             loan.span,\n-            format!(\"borrow of `{}` occurs here\",\n-                    self.bccx.loan_path_to_string(loan_path)).index(&FullRange));\n+            &format!(\"borrow of `{}` occurs here\",\n+                    self.bccx.loan_path_to_string(loan_path))[]);\n     }\n }"}, {"sha": "1b1202082177112e35ba939fa52196442f8d111c", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -38,7 +38,7 @@ enum Fragment {\n     // This represents the collection of all but one of the elements\n     // from an array at the path described by the move path index.\n     // Note that attached MovePathIndex should have mem_categorization\n-    // of InteriorElement (i.e. array dereference `.index(&FullRange)`).\n+    // of InteriorElement (i.e. array dereference `&foo[]`).\n     AllButOneFrom(MovePathIndex),\n }\n \n@@ -123,12 +123,12 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         let attrs : &[ast::Attribute];\n         attrs = match tcx.map.find(id) {\n             Some(ast_map::NodeItem(ref item)) =>\n-                item.attrs.index(&FullRange),\n+                &item.attrs[],\n             Some(ast_map::NodeImplItem(&ast::MethodImplItem(ref m))) =>\n-                m.attrs.index(&FullRange),\n+                &m.attrs[],\n             Some(ast_map::NodeTraitItem(&ast::ProvidedMethod(ref m))) =>\n-                m.attrs.index(&FullRange),\n-            _ => [].index(&FullRange),\n+                &m.attrs[],\n+            _ => &[][],\n         };\n \n         let span_err =\n@@ -144,7 +144,7 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         for (i, mpi) in vec_rc.iter().enumerate() {\n             let render = |&:| this.path_loan_path(*mpi).user_string(tcx);\n             if span_err {\n-                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render()).index(&FullRange));\n+                tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, render())[]);\n             }\n             if print {\n                 println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n@@ -156,7 +156,7 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         for (i, f) in vec_rc.iter().enumerate() {\n             let render = |&:| f.loan_path_user_string(this, tcx);\n             if span_err {\n-                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render()).index(&FullRange));\n+                tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, render())[]);\n             }\n             if print {\n                 println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n@@ -198,11 +198,11 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n     // First, filter out duplicates\n     moved.sort();\n     moved.dedup();\n-    debug!(\"fragments 1 moved: {:?}\", path_lps(moved.index(&FullRange)));\n+    debug!(\"fragments 1 moved: {:?}\", path_lps(&moved[]));\n \n     assigned.sort();\n     assigned.dedup();\n-    debug!(\"fragments 1 assigned: {:?}\", path_lps(assigned.index(&FullRange)));\n+    debug!(\"fragments 1 assigned: {:?}\", path_lps(&assigned[]));\n \n     // Second, build parents from the moved and assigned.\n     for m in moved.iter() {\n@@ -222,14 +222,14 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n \n     parents.sort();\n     parents.dedup();\n-    debug!(\"fragments 2 parents: {:?}\", path_lps(parents.index(&FullRange)));\n+    debug!(\"fragments 2 parents: {:?}\", path_lps(&parents[]));\n \n     // Third, filter the moved and assigned fragments down to just the non-parents\n-    moved.retain(|f| non_member(*f, parents.index(&FullRange)));\n-    debug!(\"fragments 3 moved: {:?}\", path_lps(moved.index(&FullRange)));\n+    moved.retain(|f| non_member(*f, &parents[]));\n+    debug!(\"fragments 3 moved: {:?}\", path_lps(&moved[]));\n \n-    assigned.retain(|f| non_member(*f, parents.index(&FullRange)));\n-    debug!(\"fragments 3 assigned: {:?}\", path_lps(assigned.index(&FullRange)));\n+    assigned.retain(|f| non_member(*f, &parents[]));\n+    debug!(\"fragments 3 assigned: {:?}\", path_lps(&assigned[]));\n \n     // Fourth, build the leftover from the moved, assigned, and parents.\n     for m in moved.iter() {\n@@ -247,16 +247,16 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n \n     unmoved.sort();\n     unmoved.dedup();\n-    debug!(\"fragments 4 unmoved: {:?}\", frag_lps(unmoved.index(&FullRange)));\n+    debug!(\"fragments 4 unmoved: {:?}\", frag_lps(&unmoved[]));\n \n     // Fifth, filter the leftover fragments down to its core.\n     unmoved.retain(|f| match *f {\n         AllButOneFrom(_) => true,\n-        Just(mpi) => non_member(mpi, parents.index(&FullRange)) &&\n-            non_member(mpi, moved.index(&FullRange)) &&\n-            non_member(mpi, assigned.index(&FullRange))\n+        Just(mpi) => non_member(mpi, &parents[]) &&\n+            non_member(mpi, &moved[]) &&\n+            non_member(mpi, &assigned[])\n     });\n-    debug!(\"fragments 5 unmoved: {:?}\", frag_lps(unmoved.index(&FullRange)));\n+    debug!(\"fragments 5 unmoved: {:?}\", frag_lps(&unmoved[]));\n \n     // Swap contents back in.\n     fragments.unmoved_fragments = unmoved;\n@@ -433,7 +433,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             let msg = format!(\"type {} ({:?}) is not fragmentable\",\n                               parent_ty.repr(tcx), sty_and_variant_info);\n             let opt_span = origin_id.and_then(|id|tcx.map.opt_span(id));\n-            tcx.sess.opt_span_bug(opt_span, msg.index(&FullRange))\n+            tcx.sess.opt_span_bug(opt_span, &msg[])\n         }\n     }\n }"}, {"sha": "889a359b019cd84abac5882e2ffc8e03fffc02e6", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -306,8 +306,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                     ty::ReInfer(..) => {\n                         self.tcx().sess.span_bug(\n                             cmt.span,\n-                            format!(\"invalid borrow lifetime: {:?}\",\n-                                    loan_region).index(&FullRange));\n+                            &format!(\"invalid borrow lifetime: {:?}\",\n+                                    loan_region)[]);\n                     }\n                 };\n                 debug!(\"loan_scope = {:?}\", loan_scope);"}, {"sha": "a7771fefec412c4453643eee6d4b70a60d7682e0", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -119,8 +119,8 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         mc::cat_static_item => {\n             bccx.span_err(\n                 move_from.span,\n-                format!(\"cannot move out of {}\",\n-                        bccx.cmt_to_string(&*move_from)).index(&FullRange));\n+                &format!(\"cannot move out of {}\",\n+                        bccx.cmt_to_string(&*move_from))[]);\n         }\n \n         mc::cat_downcast(ref b, _) |\n@@ -130,9 +130,9 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                 | ty::ty_enum(did, _) if ty::has_dtor(bccx.tcx, did) => {\n                     bccx.span_err(\n                         move_from.span,\n-                        format!(\"cannot move out of type `{}`, \\\n+                        &format!(\"cannot move out of type `{}`, \\\n                                  which defines the `Drop` trait\",\n-                                b.ty.user_string(bccx.tcx)).index(&FullRange));\n+                                b.ty.user_string(bccx.tcx))[]);\n                 },\n                 _ => panic!(\"this path should not cause illegal move\")\n             }\n@@ -152,13 +152,13 @@ fn note_move_destination(bccx: &BorrowckCtxt,\n             \"attempting to move value to here\");\n         bccx.span_help(\n             move_to_span,\n-            format!(\"to prevent the move, \\\n+            &format!(\"to prevent the move, \\\n                      use `ref {0}` or `ref mut {0}` to capture value by \\\n                      reference\",\n-                    pat_name).index(&FullRange));\n+                    pat_name)[]);\n     } else {\n         bccx.span_note(move_to_span,\n-                       format!(\"and here (use `ref {0}` or `ref mut {0}`)\",\n-                               pat_name).index(&FullRange));\n+                       &format!(\"and here (use `ref {0}` or `ref mut {0}`)\",\n+                               pat_name)[]);\n     }\n }"}, {"sha": "e734e8fb6ffb70c24b668becfb587d4485d4aeb1", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -137,7 +137,7 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n     check_loans::check_loans(this,\n                              &loan_dfcx,\n                              flowed_moves,\n-                             all_loans.index(&FullRange),\n+                             &all_loans[],\n                              id,\n                              decl,\n                              body);\n@@ -505,7 +505,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn report(&self, err: BckError<'tcx>) {\n         self.span_err(\n             err.span,\n-            self.bckerr_to_string(&err).index(&FullRange));\n+            &self.bckerr_to_string(&err)[]);\n         self.note_and_explain_bckerr(err);\n     }\n \n@@ -525,9 +525,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             move_data::Declared => {\n                 self.tcx.sess.span_err(\n                     use_span,\n-                    format!(\"{} of possibly uninitialized variable: `{}`\",\n+                    &format!(\"{} of possibly uninitialized variable: `{}`\",\n                             verb,\n-                            self.loan_path_to_string(lp)).index(&FullRange));\n+                            self.loan_path_to_string(lp))[]);\n                 (self.loan_path_to_string(moved_lp),\n                  String::new())\n             }\n@@ -566,10 +566,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                           else { \"\" };\n                 self.tcx.sess.span_err(\n                     use_span,\n-                    format!(\"{} of {}moved value: `{}`\",\n+                    &format!(\"{} of {}moved value: `{}`\",\n                             verb,\n                             msg,\n-                            nl).index(&FullRange));\n+                            nl)[]);\n                 (ol, moved_lp_msg)\n             }\n         };\n@@ -585,32 +585,32 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         (ty::expr_ty_adjusted(self.tcx, &*expr), expr.span)\n                     }\n                     r => {\n-                        self.tcx.sess.bug(format!(\"MoveExpr({}) maps to \\\n+                        self.tcx.sess.bug(&format!(\"MoveExpr({}) maps to \\\n                                                    {:?}, not Expr\",\n                                                   the_move.id,\n-                                                  r).index(&FullRange))\n+                                                  r)[])\n                     }\n                 };\n                 let (suggestion, _) =\n                     move_suggestion(param_env, expr_span, expr_ty, (\"moved by default\", \"\"));\n                 self.tcx.sess.span_note(\n                     expr_span,\n-                    format!(\"`{}` moved here{} because it has type `{}`, which is {}\",\n+                    &format!(\"`{}` moved here{} because it has type `{}`, which is {}\",\n                             ol,\n                             moved_lp_msg,\n                             expr_ty.user_string(self.tcx),\n-                            suggestion).index(&FullRange));\n+                            suggestion)[]);\n             }\n \n             move_data::MovePat => {\n                 let pat_ty = ty::node_id_to_type(self.tcx, the_move.id);\n                 let span = self.tcx.map.span(the_move.id);\n                 self.tcx.sess.span_note(span,\n-                    format!(\"`{}` moved here{} because it has type `{}`, \\\n+                    &format!(\"`{}` moved here{} because it has type `{}`, \\\n                              which is moved by default\",\n                             ol,\n                             moved_lp_msg,\n-                            pat_ty.user_string(self.tcx)).index(&FullRange));\n+                            pat_ty.user_string(self.tcx))[]);\n                 self.tcx.sess.span_help(span,\n                     \"use `ref` to override\");\n             }\n@@ -623,10 +623,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         (ty::expr_ty_adjusted(self.tcx, &*expr), expr.span)\n                     }\n                     r => {\n-                        self.tcx.sess.bug(format!(\"Captured({}) maps to \\\n+                        self.tcx.sess.bug(&format!(\"Captured({}) maps to \\\n                                                    {:?}, not Expr\",\n                                                   the_move.id,\n-                                                  r).index(&FullRange))\n+                                                  r)[])\n                     }\n                 };\n                 let (suggestion, help) =\n@@ -637,12 +637,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                      \"make a copy and capture that instead to override\"));\n                 self.tcx.sess.span_note(\n                     expr_span,\n-                    format!(\"`{}` moved into closure environment here{} because it \\\n+                    &format!(\"`{}` moved into closure environment here{} because it \\\n                             has type `{}`, which is {}\",\n                             ol,\n                             moved_lp_msg,\n                             expr_ty.user_string(self.tcx),\n-                            suggestion).index(&FullRange));\n+                            suggestion)[]);\n                 self.tcx.sess.span_help(expr_span, help);\n             }\n         }\n@@ -672,8 +672,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                 &move_data::Assignment) {\n         self.tcx.sess.span_err(\n             span,\n-            format!(\"re-assignment of immutable variable `{}`\",\n-                    self.loan_path_to_string(lp)).index(&FullRange));\n+            &format!(\"re-assignment of immutable variable `{}`\",\n+                    self.loan_path_to_string(lp))[]);\n         self.tcx.sess.span_note(assign.span, \"prior assignment occurs here\");\n     }\n \n@@ -798,8 +798,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             mc::AliasableOther => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"{} in an aliasable location\",\n-                             prefix).index(&FullRange));\n+                    &format!(\"{} in an aliasable location\",\n+                             prefix)[]);\n             }\n             mc::AliasableClosure(id) => {\n                 self.tcx.sess.span_err(span,\n@@ -812,12 +812,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             mc::AliasableStaticMut(..) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"{} in a static location\", prefix).index(&FullRange));\n+                    &format!(\"{} in a static location\", prefix)[]);\n             }\n             mc::AliasableBorrowed => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"{} in a `&` reference\", prefix).index(&FullRange));\n+                    &format!(\"{} in a `&` reference\", prefix)[]);\n             }\n         }\n \n@@ -884,13 +884,13 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 };\n                 note_and_explain_region(\n                     self.tcx,\n-                    format!(\"{} would have to be valid for \",\n-                            descr).index(&FullRange),\n+                    &format!(\"{} would have to be valid for \",\n+                            descr)[],\n                     loan_scope,\n                     \"...\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    format!(\"...but {} is only valid for \", descr).index(&FullRange),\n+                    &format!(\"...but {} is only valid for \", descr)[],\n                     ptr_scope,\n                     \"\");\n             }\n@@ -910,7 +910,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push('(');\n                 self.append_loan_path_to_string(&**lp_base, out);\n                 out.push_str(DOWNCAST_PRINTED_OPERATOR);\n-                out.push_str(ty::item_path_str(self.tcx, variant_def_id).index(&FullRange));\n+                out.push_str(&ty::item_path_str(self.tcx, variant_def_id)[]);\n                 out.push(')');\n             }\n \n@@ -924,7 +924,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     }\n                     mc::PositionalField(idx) => {\n                         out.push('.');\n-                        out.push_str(idx.to_string().index(&FullRange));\n+                        out.push_str(&idx.to_string()[]);\n                     }\n                 }\n             }\n@@ -956,7 +956,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push('(');\n                 self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n                 out.push(':');\n-                out.push_str(ty::item_path_str(self.tcx, variant_def_id).index(&FullRange));\n+                out.push_str(&ty::item_path_str(self.tcx, variant_def_id)[]);\n                 out.push(')');\n             }\n "}, {"sha": "20ad1307da3e2bbde98f72e5b639835914141500", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n             if seen_one { sets.push_str(\" \"); } else { seen_one = true; }\n             sets.push_str(variant.short_name());\n             sets.push_str(\": \");\n-            sets.push_str(self.dataflow_for_variant(e, n, variant).index(&FullRange));\n+            sets.push_str(&self.dataflow_for_variant(e, n, variant)[]);\n         }\n         sets\n     }\n@@ -89,7 +89,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n                 set.push_str(\", \");\n             }\n             let loan_str = self.borrowck_ctxt.loan_path_to_string(&*lp);\n-            set.push_str(loan_str.index(&FullRange));\n+            set.push_str(&loan_str[]);\n             saw_some = true;\n             true\n         });"}, {"sha": "019691c1e1027bc7c55fd914030fd21607efd77e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -58,12 +58,12 @@ pub fn compile_input(sess: Session,\n             let outputs = build_output_filenames(input,\n                                                  outdir,\n                                                  output,\n-                                                 krate.attrs.index(&FullRange),\n+                                                 &krate.attrs[],\n                                                  &sess);\n-            let id = link::find_crate_name(Some(&sess), krate.attrs.index(&FullRange),\n+            let id = link::find_crate_name(Some(&sess), &krate.attrs[],\n                                            input);\n             let expanded_crate\n-                = match phase_2_configure_and_expand(&sess, krate, id.index(&FullRange),\n+                = match phase_2_configure_and_expand(&sess, krate, &id[],\n                                                      addl_plugins) {\n                     None => return,\n                     Some(k) => k\n@@ -75,7 +75,7 @@ pub fn compile_input(sess: Session,\n         let mut forest = ast_map::Forest::new(expanded_crate);\n         let ast_map = assign_node_ids_and_map(&sess, &mut forest);\n \n-        write_out_deps(&sess, input, &outputs, id.index(&FullRange));\n+        write_out_deps(&sess, input, &outputs, &id[]);\n \n         if stop_after_phase_2(&sess) { return; }\n \n@@ -171,9 +171,9 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     let time_passes = sess.time_passes();\n \n     *sess.crate_types.borrow_mut() =\n-        collect_crate_types(sess, krate.attrs.index(&FullRange));\n+        collect_crate_types(sess, &krate.attrs[]);\n     *sess.crate_metadata.borrow_mut() =\n-        collect_crate_metadata(sess, krate.attrs.index(&FullRange));\n+        collect_crate_metadata(sess, &krate.attrs[]);\n \n     time(time_passes, \"recursion limit\", (), |_| {\n         middle::recursion_limit::update_recursion_limit(sess, &krate);\n@@ -268,8 +268,8 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             if cfg!(windows) {\n                 _old_path = os::getenv(\"PATH\").unwrap_or(_old_path);\n                 let mut new_path = sess.host_filesearch(PathKind::All).get_dylib_search_paths();\n-                new_path.extend(os::split_paths(_old_path.index(&FullRange)).into_iter());\n-                os::setenv(\"PATH\", os::join_paths(new_path.index(&FullRange)).unwrap());\n+                new_path.extend(os::split_paths(&_old_path[]).into_iter());\n+                os::setenv(\"PATH\", os::join_paths(&new_path[]).unwrap());\n             }\n             let cfg = syntax::ext::expand::ExpansionConfig {\n                 crate_name: crate_name.to_string(),\n@@ -533,7 +533,7 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n             write::run_passes(sess,\n                               trans,\n-                              sess.opts.output_types.index(&FullRange),\n+                              &sess.opts.output_types[],\n                               outputs));\n     }\n \n@@ -547,14 +547,14 @@ pub fn phase_6_link_output(sess: &Session,\n                            outputs: &OutputFilenames) {\n     let old_path = os::getenv(\"PATH\").unwrap_or_else(||String::new());\n     let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths();\n-    new_path.extend(os::split_paths(old_path.index(&FullRange)).into_iter());\n-    os::setenv(\"PATH\", os::join_paths(new_path.index(&FullRange)).unwrap());\n+    new_path.extend(os::split_paths(&old_path[]).into_iter());\n+    os::setenv(\"PATH\", os::join_paths(&new_path[]).unwrap());\n \n     time(sess.time_passes(), \"linking\", (), |_|\n          link::link_binary(sess,\n                            trans,\n                            outputs,\n-                           trans.link.crate_name.index(&FullRange)));\n+                           &trans.link.crate_name[]));\n \n     os::setenv(\"PATH\", old_path);\n }\n@@ -643,7 +643,7 @@ fn write_out_deps(sess: &Session,\n         // write Makefile-compatible dependency rules\n         let files: Vec<String> = sess.codemap().files.borrow()\n                                    .iter().filter(|fmap| fmap.is_real_file())\n-                                   .map(|fmap| escape_dep_filename(fmap.name.index(&FullRange)))\n+                                   .map(|fmap| escape_dep_filename(&fmap.name[]))\n                                    .collect();\n         let mut file = try!(io::File::create(&deps_filename));\n         for path in out_filenames.iter() {\n@@ -656,8 +656,8 @@ fn write_out_deps(sess: &Session,\n     match result {\n         Ok(()) => {}\n         Err(e) => {\n-            sess.fatal(format!(\"error writing dependencies to `{}`: {}\",\n-                               deps_filename.display(), e).index(&FullRange));\n+            sess.fatal(&format!(\"error writing dependencies to `{}`: {}\",\n+                               deps_filename.display(), e)[]);\n         }\n     }\n }\n@@ -726,9 +726,9 @@ pub fn collect_crate_types(session: &Session,\n         let res = !link::invalid_output_for_target(session, *crate_type);\n \n         if !res {\n-            session.warn(format!(\"dropping unsupported crate type `{:?}` \\\n+            session.warn(&format!(\"dropping unsupported crate type `{:?}` \\\n                                    for target `{}`\",\n-                                 *crate_type, session.opts.target_triple).index(&FullRange));\n+                                 *crate_type, session.opts.target_triple)[]);\n         }\n \n         res"}, {"sha": "f3a934857ec2b6695a6108b4186a3176286c4e9a", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -90,12 +90,12 @@ fn run_compiler(args: &[String]) {\n     let descriptions = diagnostics::registry::Registry::new(&DIAGNOSTICS);\n     match matches.opt_str(\"explain\") {\n         Some(ref code) => {\n-            match descriptions.find_description(code.index(&FullRange)) {\n+            match descriptions.find_description(&code[]) {\n                 Some(ref description) => {\n                     println!(\"{}\", description);\n                 }\n                 None => {\n-                    early_error(format!(\"no extended information for {}\", code).index(&FullRange));\n+                    early_error(&format!(\"no extended information for {}\", code)[]);\n                 }\n             }\n             return;\n@@ -121,7 +121,7 @@ fn run_compiler(args: &[String]) {\n             early_error(\"no input filename given\");\n         }\n         1u => {\n-            let ifile = matches.free[0].index(&FullRange);\n+            let ifile = &matches.free[0][];\n             if ifile == \"-\" {\n                 let contents = io::stdin().read_to_end().unwrap();\n                 let src = String::from_utf8(contents).unwrap();\n@@ -317,7 +317,7 @@ Available lint options:\n         for lint in lints.into_iter() {\n             let name = lint.name_lower().replace(\"_\", \"-\");\n             println!(\"    {}  {:7.7}  {}\",\n-                     padded(name.index(&FullRange)), lint.default_level.as_str(), lint.desc);\n+                     padded(&name[]), lint.default_level.as_str(), lint.desc);\n         }\n         println!(\"\\n\");\n     };\n@@ -347,7 +347,7 @@ Available lint options:\n             let desc = to.into_iter().map(|x| x.as_str().replace(\"_\", \"-\"))\n                          .collect::<Vec<String>>().connect(\", \");\n             println!(\"    {}  {}\",\n-                     padded(name.index(&FullRange)), desc);\n+                     padded(&name[]), desc);\n         }\n         println!(\"\\n\");\n     };\n@@ -413,7 +413,7 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     }\n \n     let matches =\n-        match getopts::getopts(args.index(&FullRange), config::optgroups().index(&FullRange)) {\n+        match getopts::getopts(&args[], &config::optgroups()[]) {\n             Ok(m) => m,\n             Err(f_stable_attempt) => {\n                 // redo option parsing, including unstable options this time,\n@@ -587,15 +587,15 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n                     \"run with `RUST_BACKTRACE=1` for a backtrace\".to_string(),\n                 ];\n                 for note in xs.iter() {\n-                    emitter.emit(None, note.index(&FullRange), None, diagnostic::Note)\n+                    emitter.emit(None, &note[], None, diagnostic::Note)\n                 }\n \n                 match r.read_to_string() {\n                     Ok(s) => println!(\"{}\", s),\n                     Err(e) => {\n                         emitter.emit(None,\n-                                     format!(\"failed to read internal \\\n-                                              stderr: {}\", e).index(&FullRange),\n+                                     &format!(\"failed to read internal \\\n+                                              stderr: {}\", e)[],\n                                      None,\n                                      diagnostic::Error)\n                     }"}, {"sha": "7592fbc05b3383afcf52457473095e2cec1d1f27", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -294,9 +294,9 @@ impl<'tcx> pprust::PpAnn for TypedAnnotation<'tcx> {\n                 try!(pp::word(&mut s.s, \"as\"));\n                 try!(pp::space(&mut s.s));\n                 try!(pp::word(&mut s.s,\n-                              ppaux::ty_to_string(\n+                              &ppaux::ty_to_string(\n                                   tcx,\n-                                  ty::expr_ty(tcx, expr)).index(&FullRange)));\n+                                  ty::expr_ty(tcx, expr))[]));\n                 s.pclose()\n             }\n             _ => Ok(())\n@@ -350,8 +350,8 @@ impl<'a, 'ast> Iterator for NodesMatchingUII<'a, 'ast> {\n \n     fn next(&mut self) -> Option<ast::NodeId> {\n         match self {\n-            &NodesMatchingDirect(ref mut iter) => iter.next(),\n-            &NodesMatchingSuffix(ref mut iter) => iter.next(),\n+            &mut NodesMatchingDirect(ref mut iter) => iter.next(),\n+            &mut NodesMatchingSuffix(ref mut iter) => iter.next(),\n         }\n     }\n }\n@@ -370,7 +370,7 @@ impl UserIdentifiedItem {\n             ItemViaNode(node_id) =>\n                 NodesMatchingDirect(Some(node_id).into_iter()),\n             ItemViaPath(ref parts) =>\n-                NodesMatchingSuffix(map.nodes_matching_suffix(parts.index(&FullRange))),\n+                NodesMatchingSuffix(map.nodes_matching_suffix(&parts[])),\n         }\n     }\n \n@@ -382,7 +382,7 @@ impl UserIdentifiedItem {\n                         user_option,\n                         self.reconstructed_input(),\n                         is_wrong_because);\n-            sess.fatal(message.index(&FullRange))\n+            sess.fatal(&message[])\n         };\n \n         let mut saw_node = ast::DUMMY_NODE_ID;\n@@ -509,7 +509,7 @@ pub fn pretty_print_input(sess: Session,\n     let is_expanded = needs_expansion(&ppm);\n     let compute_ast_map = needs_ast_map(&ppm, &opt_uii);\n     let krate = if compute_ast_map {\n-        match driver::phase_2_configure_and_expand(&sess, krate, id.index(&FullRange), None) {\n+        match driver::phase_2_configure_and_expand(&sess, krate, &id[], None) {\n             None => return,\n             Some(k) => k\n         }\n@@ -528,7 +528,7 @@ pub fn pretty_print_input(sess: Session,\n     };\n \n     let src_name = driver::source_name(input);\n-    let src = sess.codemap().get_filemap(src_name.index(&FullRange))\n+    let src = sess.codemap().get_filemap(&src_name[])\n                             .src.as_bytes().to_vec();\n     let mut rdr = MemReader::new(src);\n \n@@ -588,16 +588,16 @@ pub fn pretty_print_input(sess: Session,\n         (PpmFlowGraph, opt_uii) => {\n             debug!(\"pretty printing flow graph for {:?}\", opt_uii);\n             let uii = opt_uii.unwrap_or_else(|| {\n-                sess.fatal(format!(\"`pretty flowgraph=..` needs NodeId (int) or\n-                                     unique path suffix (b::c::d)\").index(&FullRange))\n+                sess.fatal(&format!(\"`pretty flowgraph=..` needs NodeId (int) or\n+                                     unique path suffix (b::c::d)\")[])\n \n             });\n             let ast_map = ast_map.expect(\"--pretty flowgraph missing ast_map\");\n             let nodeid = uii.to_one_node_id(\"--pretty\", &sess, &ast_map);\n \n             let node = ast_map.find(nodeid).unwrap_or_else(|| {\n-                sess.fatal(format!(\"--pretty flowgraph couldn't find id: {}\",\n-                                   nodeid).index(&FullRange))\n+                sess.fatal(&format!(\"--pretty flowgraph couldn't find id: {}\",\n+                                   nodeid)[])\n             });\n \n             let code = blocks::Code::from_node(node);\n@@ -615,8 +615,8 @@ pub fn pretty_print_input(sess: Session,\n                     // point to what was found, if there's an\n                     // accessible span.\n                     match ast_map.opt_span(nodeid) {\n-                        Some(sp) => sess.span_fatal(sp, message.index(&FullRange)),\n-                        None => sess.fatal(message.index(&FullRange))\n+                        Some(sp) => sess.span_fatal(sp, &message[]),\n+                        None => sess.fatal(&message[])\n                     }\n                 }\n             }"}, {"sha": "61a29e1e6f2cd68dc272ca369eacf2f27d3e3d19", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -279,7 +279,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     pub fn t_param(&self, space: subst::ParamSpace, index: u32) -> Ty<'tcx> {\n         let name = format!(\"T{}\", index);\n-        ty::mk_param(self.infcx.tcx, space, index, token::intern(name.index(&FullRange)))\n+        ty::mk_param(self.infcx.tcx, space, index, token::intern(&name[]))\n     }\n \n     pub fn re_early_bound(&self,"}, {"sha": "466bd608736ce52096ae12a3e1e12bf44b995f2c", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -219,16 +219,16 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     // had the duplicate.\n                     let ns = ns.unwrap();\n                     self.resolve_error(sp,\n-                        format!(\"duplicate definition of {} `{}`\",\n+                        &format!(\"duplicate definition of {} `{}`\",\n                              namespace_error_to_string(duplicate_type),\n-                             token::get_name(name)).index(&FullRange));\n+                             token::get_name(name))[]);\n                     {\n                         let r = child.span_for_namespace(ns);\n                         for sp in r.iter() {\n                             self.session.span_note(*sp,\n-                                 format!(\"first definition of {} `{}` here\",\n+                                 &format!(\"first definition of {} `{}` here\",\n                                       namespace_error_to_string(duplicate_type),\n-                                      token::get_name(name)).index(&FullRange));\n+                                      token::get_name(name))[]);\n                         }\n                     }\n                 }\n@@ -1200,8 +1200,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             SingleImport(target, _) => {\n                 debug!(\"(building import directive) building import \\\n                         directive: {}::{}\",\n-                       self.names_to_string(module_.imports.borrow().last().unwrap()\n-                                                 .module_path.index(&FullRange)),\n+                       self.names_to_string(&module_.imports.borrow().last().unwrap().\n+                                                             module_path[]),\n                        token::get_name(target));\n \n                 let mut import_resolutions = module_.import_resolutions"}, {"sha": "a1ae96490cad7c679a4f799d014b206797d63c8d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 73, "deletions": 74, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -1058,11 +1058,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     };\n                     let msg = format!(\"unresolved import `{}`{}\",\n                                       self.import_path_to_string(\n-                                          import_directive.module_path\n-                                                          .index(&FullRange),\n+                                          &import_directive.module_path[],\n                                           import_directive.subclass),\n                                       help);\n-                    self.resolve_error(span, msg.index(&FullRange));\n+                    self.resolve_error(span, &msg[]);\n                 }\n                 Indeterminate => break, // Bail out. We'll come around next time.\n                 Success(()) => () // Good. Continue.\n@@ -1092,7 +1091,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         .iter()\n                                         .map(|seg| seg.identifier.name)\n                                         .collect();\n-        self.names_to_string(names.index(&FullRange))\n+        self.names_to_string(&names[])\n     }\n \n     fn import_directive_subclass_to_string(&mut self,\n@@ -1156,7 +1155,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let module_path = &import_directive.module_path;\n \n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n-               self.names_to_string(module_path.index(&FullRange)),\n+               self.names_to_string(&module_path[]),\n                self.module_to_string(&*module_));\n \n         // First, resolve the module path for the directive, if necessary.\n@@ -1165,7 +1164,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Some((self.graph_root.get_module(), LastMod(AllPublic)))\n         } else {\n             match self.resolve_module_path(module_.clone(),\n-                                           module_path.index(&FullRange),\n+                                           &module_path[],\n                                            DontUseLexicalScope,\n                                            import_directive.span,\n                                            ImportSearch) {\n@@ -1762,7 +1761,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     ValueNS => \"value\",\n                                   },\n                                   token::get_name(name).get());\n-                self.session.span_err(import_span, msg.index(&FullRange));\n+                self.session.span_err(import_span, &msg[]);\n             }\n             Some(_) | None => {}\n         }\n@@ -1777,7 +1776,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if !name_bindings.defined_in_namespace_with(namespace, IMPORTABLE) {\n             let msg = format!(\"`{}` is not directly importable\",\n                               token::get_name(name));\n-            self.session.span_err(import_span, msg.index(&FullRange));\n+            self.session.span_err(import_span, &msg[]);\n         }\n     }\n \n@@ -1802,7 +1801,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                        crate in this module \\\n                                        (maybe you meant `use {0}::*`?)\",\n                                       token::get_name(name).get());\n-                    self.session.span_err(import_span, msg.index(&FullRange));\n+                    self.session.span_err(import_span, &msg[]);\n                 }\n                 Some(_) | None => {}\n             }\n@@ -1824,7 +1823,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let msg = format!(\"import `{}` conflicts with value \\\n                                        in this module\",\n                                       token::get_name(name).get());\n-                    self.session.span_err(import_span, msg.index(&FullRange));\n+                    self.session.span_err(import_span, &msg[]);\n                     if let Some(span) = value.value_span {\n                         self.session.span_note(span,\n                                                \"conflicting value here\");\n@@ -1842,7 +1841,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             let msg = format!(\"import `{}` conflicts with type in \\\n                                                this module\",\n                                               token::get_name(name).get());\n-                            self.session.span_err(import_span, msg.index(&FullRange));\n+                            self.session.span_err(import_span, &msg[]);\n                             if let Some(span) = ty.type_span {\n                                 self.session.span_note(span,\n                                                        \"note conflicting type here\")\n@@ -1855,7 +1854,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         let msg = format!(\"inherent implementations \\\n                                                            are only allowed on types \\\n                                                            defined in the current module\");\n-                                        self.session.span_err(span, msg.index(&FullRange));\n+                                        self.session.span_err(span, &msg[]);\n                                         self.session.span_note(import_span,\n                                                                \"import from other module here\")\n                                     }\n@@ -1864,7 +1863,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     let msg = format!(\"import `{}` conflicts with existing \\\n                                                        submodule\",\n                                                       token::get_name(name).get());\n-                                    self.session.span_err(import_span, msg.index(&FullRange));\n+                                    self.session.span_err(import_span, &msg[]);\n                                     if let Some(span) = ty.type_span {\n                                         self.session.span_note(span,\n                                                                \"note conflicting module here\")\n@@ -1892,9 +1891,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if module.external_module_children.borrow().contains_key(&name) {\n             self.session\n                 .span_err(span,\n-                          format!(\"an external crate named `{}` has already \\\n+                          &format!(\"an external crate named `{}` has already \\\n                                    been imported into this module\",\n-                                  token::get_name(name).get()).index(&FullRange));\n+                                  token::get_name(name).get())[]);\n         }\n     }\n \n@@ -1910,10 +1909,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if module.external_module_children.borrow().contains_key(&name) {\n             self.session\n                 .span_err(span,\n-                          format!(\"the name `{}` conflicts with an external \\\n+                          &format!(\"the name `{}` conflicts with an external \\\n                                    crate that has been imported into this \\\n                                    module\",\n-                                  token::get_name(name).get()).index(&FullRange));\n+                                  token::get_name(name).get())[]);\n         }\n     }\n \n@@ -1961,7 +1960,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let segment_name = token::get_name(name);\n                     let module_name = self.module_to_string(&*search_module);\n                     let mut span = span;\n-                    let msg = if \"???\" == module_name.index(&FullRange) {\n+                    let msg = if \"???\" == &module_name[] {\n                         span.hi = span.lo + Pos::from_uint(segment_name.get().len());\n \n                         match search_parent_externals(name,\n@@ -2074,14 +2073,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match module_prefix_result {\n             Failed(None) => {\n                 let mpath = self.names_to_string(module_path);\n-                let mpath = mpath.index(&FullRange);\n+                let mpath = &mpath[];\n                 match mpath.rfind(':') {\n                     Some(idx) => {\n                         let msg = format!(\"Could not find `{}` in `{}`\",\n                                             // idx +- 1 to account for the\n                                             // colons on either side\n-                                            mpath.index(&((idx + 1)..)),\n-                                            mpath.index(&(0..(idx - 1))));\n+                                            &mpath[(idx + 1)..],\n+                                            &mpath[0..(idx - 1)]);\n                         return Failed(Some((span, msg)));\n                     },\n                     None => {\n@@ -2255,8 +2254,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                               PathSearch,\n                                               true) {\n                 Failed(Some((span, msg))) =>\n-                    self.resolve_error(span, format!(\"failed to resolve. {}\",\n-                                                     msg).index(&FullRange)),\n+                    self.resolve_error(span, &format!(\"failed to resolve. {}\",\n+                                                     msg)[]),\n                 Failed(None) => (), // Continue up the search chain.\n                 Indeterminate => {\n                     // We couldn't see through the higher scope because of an\n@@ -2516,7 +2515,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             } else {\n                 let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n                                   sn);\n-                self.resolve_error((*imports)[index].span, err.index(&FullRange));\n+                self.resolve_error((*imports)[index].span, &err[]);\n             }\n         }\n \n@@ -2608,7 +2607,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match def_like {\n             DlDef(d @ DefUpvar(..)) => {\n                 self.session.span_bug(span,\n-                    format!(\"unexpected {:?} in bindings\", d).index(&FullRange))\n+                    &format!(\"unexpected {:?} in bindings\", d)[])\n             }\n             DlDef(d @ DefLocal(_)) => {\n                 let node_id = d.def_id().node;\n@@ -2754,7 +2753,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         for (i, rib) in ribs.iter().enumerate().rev() {\n             match rib.bindings.get(&name).cloned() {\n                 Some(def_like) => {\n-                    return self.upvarify(ribs.index(&((i + 1)..)), def_like, span);\n+                    return self.upvarify(&ribs[(i + 1)..], def_like, span);\n                 }\n                 None => {\n                     // Continue.\n@@ -2847,7 +2846,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                             generics,\n                                             implemented_traits,\n                                             &**self_type,\n-                                            impl_items.index(&FullRange));\n+                                            &impl_items[]);\n             }\n \n             ItemTrait(_, ref generics, ref bounds, ref trait_items) => {\n@@ -2925,7 +2924,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             ItemStruct(ref struct_def, ref generics) => {\n                 self.resolve_struct(item.id,\n                                     generics,\n-                                    struct_def.fields.index(&FullRange));\n+                                    &struct_def.fields[]);\n             }\n \n             ItemMod(ref module_) => {\n@@ -2996,12 +2995,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                     if seen_bindings.contains(&name) {\n                         self.resolve_error(type_parameter.span,\n-                                           format!(\"the name `{}` is already \\\n+                                           &format!(\"the name `{}` is already \\\n                                                     used for a type \\\n                                                     parameter in this type \\\n                                                     parameter list\",\n                                                    token::get_name(\n-                                                       name)).index(&FullRange))\n+                                                       name))[])\n                     }\n                     seen_bindings.insert(name);\n \n@@ -3173,7 +3172,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 };\n \n                 let msg = format!(\"attempt to {} a nonexistent trait `{}`\", usage_str, path_str);\n-                self.resolve_error(trait_reference.path.span, msg.index(&FullRange));\n+                self.resolve_error(trait_reference.path.span, &msg[]);\n             }\n             Some(def) => {\n                 match def {\n@@ -3183,16 +3182,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                     (def, _) => {\n                         self.resolve_error(trait_reference.path.span,\n-                                           format!(\"`{}` is not a trait\",\n+                                           &format!(\"`{}` is not a trait\",\n                                                    self.path_names_to_string(\n-                                                       &trait_reference.path)).index(&FullRange));\n+                                                       &trait_reference.path))[]);\n \n                         // If it's a typedef, give a note\n                         if let DefTy(..) = def {\n                             self.session.span_note(\n                                 trait_reference.path.span,\n-                                format!(\"`type` aliases cannot be used for traits\")\n-                                    .index(&FullRange));\n+                                &format!(\"`type` aliases cannot be used for traits\")\n+                                []);\n                         }\n                     }\n                 }\n@@ -3387,9 +3386,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             if self.trait_item_map.get(&(name, did)).is_none() {\n                 let path_str = self.path_names_to_string(&trait_ref.path);\n                 self.resolve_error(span,\n-                                    format!(\"method `{}` is not a member of trait `{}`\",\n+                                    &format!(\"method `{}` is not a member of trait `{}`\",\n                                             token::get_name(name),\n-                                            path_str).index(&FullRange));\n+                                            path_str)[]);\n             }\n         }\n     }\n@@ -3455,19 +3454,19 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                   None => {\n                     self.resolve_error(\n                         p.span,\n-                        format!(\"variable `{}` from pattern #1 is \\\n+                        &format!(\"variable `{}` from pattern #1 is \\\n                                   not bound in pattern #{}\",\n                                 token::get_name(key),\n-                                i + 1).index(&FullRange));\n+                                i + 1)[]);\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n                         self.resolve_error(\n                             binding_i.span,\n-                            format!(\"variable `{}` is bound with different \\\n+                            &format!(\"variable `{}` is bound with different \\\n                                       mode in pattern #{} than in pattern #1\",\n                                     token::get_name(key),\n-                                    i + 1).index(&FullRange));\n+                                    i + 1)[]);\n                     }\n                   }\n                 }\n@@ -3477,10 +3476,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 if !map_0.contains_key(&key) {\n                     self.resolve_error(\n                         binding.span,\n-                        format!(\"variable `{}` from pattern {}{} is \\\n+                        &format!(\"variable `{}` from pattern {}{} is \\\n                                   not bound in pattern {}1\",\n                                 token::get_name(key),\n-                                \"#\", i + 1, \"#\").index(&FullRange));\n+                                \"#\", i + 1, \"#\")[]);\n                 }\n             }\n         }\n@@ -3595,7 +3594,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None => {\n                         let msg = format!(\"use of undeclared type name `{}`\",\n                                           self.path_names_to_string(path));\n-                        self.resolve_error(ty.span, msg.index(&FullRange));\n+                        self.resolve_error(ty.span, &msg[]);\n                     }\n                 }\n             }\n@@ -3664,10 +3663,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         FoundStructOrEnumVariant(..) => {\n                             self.resolve_error(\n                                 pattern.span,\n-                                format!(\"declaration of `{}` shadows an enum \\\n+                                &format!(\"declaration of `{}` shadows an enum \\\n                                          variant or unit-like struct in \\\n                                          scope\",\n-                                        token::get_name(renamed)).index(&FullRange));\n+                                        token::get_name(renamed))[]);\n                         }\n                         FoundConst(ref def, lp) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n@@ -3712,23 +3711,23 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 // Forbid duplicate bindings in the same\n                                 // parameter list.\n                                 self.resolve_error(pattern.span,\n-                                                   format!(\"identifier `{}` \\\n+                                                   &format!(\"identifier `{}` \\\n                                                             is bound more \\\n                                                             than once in \\\n                                                             this parameter \\\n                                                             list\",\n                                                            token::get_ident(\n                                                                ident))\n-                                                   .index(&FullRange))\n+                                                   [])\n                             } else if bindings_list.get(&renamed) ==\n                                     Some(&pat_id) {\n                                 // Then this is a duplicate variable in the\n                                 // same disjunction, which is an error.\n                                 self.resolve_error(pattern.span,\n-                                    format!(\"identifier `{}` is bound \\\n+                                    &format!(\"identifier `{}` is bound \\\n                                              more than once in the same \\\n                                              pattern\",\n-                                            token::get_ident(ident)).index(&FullRange));\n+                                            token::get_ident(ident))[]);\n                             }\n                             // Else, not bound in the same pattern: do\n                             // nothing.\n@@ -3791,7 +3790,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     def: {:?}\", result);\n                             let msg = format!(\"`{}` does not name a structure\",\n                                               self.path_names_to_string(path));\n-                            self.resolve_error(path.span, msg.index(&FullRange));\n+                            self.resolve_error(path.span, &msg[]);\n                         }\n                     }\n                 }\n@@ -3852,8 +3851,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Failed(err) => {\n                 match err {\n                     Some((span, msg)) => {\n-                        self.resolve_error(span, format!(\"failed to resolve: {}\",\n-                                                         msg).index(&FullRange));\n+                        self.resolve_error(span, &format!(\"failed to resolve: {}\",\n+                                                         msg)[]);\n                     }\n                     None => ()\n                 }\n@@ -4048,7 +4047,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let last_private;\n         let module = self.current_module.clone();\n         match self.resolve_module_path(module,\n-                                       module_path.index(&FullRange),\n+                                       &module_path[],\n                                        UseLexicalScope,\n                                        path.span,\n                                        PathSearch) {\n@@ -4062,8 +4061,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 };\n \n-                self.resolve_error(span, format!(\"failed to resolve. {}\",\n-                                                 msg).index(&FullRange));\n+                self.resolve_error(span, &format!(\"failed to resolve. {}\",\n+                                                 msg)[]);\n                 return None;\n             }\n             Indeterminate => panic!(\"indeterminate unexpected\"),\n@@ -4106,7 +4105,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let containing_module;\n         let last_private;\n         match self.resolve_module_path_from_root(root_module,\n-                                                 module_path.index(&FullRange),\n+                                                 &module_path[],\n                                                  0,\n                                                  path.span,\n                                                  PathSearch,\n@@ -4116,13 +4115,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some((span, msg)) => (span, msg),\n                     None => {\n                         let msg = format!(\"Use of undeclared module `::{}`\",\n-                                          self.names_to_string(module_path.index(&FullRange)));\n+                                          self.names_to_string(&module_path[]));\n                         (path.span, msg)\n                     }\n                 };\n \n-                self.resolve_error(span, format!(\"failed to resolve. {}\",\n-                                                 msg).index(&FullRange));\n+                self.resolve_error(span, &format!(\"failed to resolve. {}\",\n+                                                 msg)[]);\n                 return None;\n             }\n \n@@ -4163,7 +4162,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n             TypeNS => {\n                 let name = ident.name;\n-                self.search_ribs(self.type_ribs.index(&FullRange), name, span)\n+                self.search_ribs(&self.type_ribs[], name, span)\n             }\n         };\n \n@@ -4217,8 +4216,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Failed(err) => {\n                 match err {\n                     Some((span, msg)) =>\n-                        self.resolve_error(span, format!(\"failed to resolve. {}\",\n-                                                         msg).index(&FullRange)),\n+                        self.resolve_error(span, &format!(\"failed to resolve. {}\",\n+                                                         msg)[]),\n                     None => ()\n                 }\n \n@@ -4275,7 +4274,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             } else {\n                 match this.resolve_module_path(root,\n-                                                name_path.index(&FullRange),\n+                                                &name_path[],\n                                                 UseLexicalScope,\n                                                 span,\n                                                 PathSearch) {\n@@ -4313,7 +4312,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let name_path = path.segments.iter().map(|seg| seg.identifier.name).collect::<Vec<_>>();\n \n         // Look for a method in the current self type's impl module.\n-        match get_module(self, path.span, name_path.index(&FullRange)) {\n+        match get_module(self, path.span, &name_path[]) {\n             Some(module) => match module.children.borrow().get(&name) {\n                 Some(binding) => {\n                     let p_str = self.path_names_to_string(&path);\n@@ -4524,7 +4523,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 def: {:?}\", result);\n                         let msg = format!(\"`{}` does not name a structure\",\n                                           self.path_names_to_string(path));\n-                        self.resolve_error(path.span, msg.index(&FullRange));\n+                        self.resolve_error(path.span, &msg[]);\n                     }\n                 }\n \n@@ -4584,8 +4583,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None => {\n                         self.resolve_error(\n                             expr.span,\n-                            format!(\"use of undeclared label `{}`\",\n-                                    token::get_ident(label)).index(&FullRange))\n+                            &format!(\"use of undeclared label `{}`\",\n+                                    token::get_ident(label))[])\n                     }\n                     Some(DlDef(def @ DefLabel(_))) => {\n                         // Since this def is a label, it is never read.\n@@ -4720,11 +4719,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             // the same conclusion! - nmatsakis\n             Occupied(entry) => if def != *entry.get() {\n                 self.session\n-                    .bug(format!(\"node_id {} resolved first to {:?} and \\\n+                    .bug(&format!(\"node_id {} resolved first to {:?} and \\\n                                   then {:?}\",\n                                  node_id,\n                                  *entry.get(),\n-                                 def).index(&FullRange));\n+                                 def)[]);\n             },\n             Vacant(entry) => { entry.insert(def); },\n         }\n@@ -4738,9 +4737,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             BindByValue(_) => {}\n             BindByRef(..) => {\n                 self.resolve_error(pat.span,\n-                                   format!(\"cannot use `ref` binding mode \\\n+                                   &format!(\"cannot use `ref` binding mode \\\n                                             with {}\",\n-                                           descr).index(&FullRange));\n+                                           descr)[]);\n             }\n         }\n     }\n@@ -4775,8 +4774,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if names.len() == 0 {\n             return \"???\".to_string();\n         }\n-        self.names_to_string(names.into_iter().rev()\n-                                  .collect::<Vec<ast::Name>>().index(&FullRange))\n+        self.names_to_string(&names.into_iter().rev()\n+                                  .collect::<Vec<ast::Name>>()[])\n     }\n \n     #[allow(dead_code)]   // useful for debugging"}, {"sha": "43f8c677e303bfd6c80476f6adde4a4c0bdf213a", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -128,7 +128,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n                        attrs: &[ast::Attribute],\n                        input: &Input) -> String {\n     let validate = |&: s: String, span: Option<Span>| {\n-        creader::validate_crate_name(sess, s.index(&FullRange), span);\n+        creader::validate_crate_name(sess, &s[], span);\n         s\n     };\n \n@@ -146,7 +146,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n                     let msg = format!(\"--crate-name and #[crate_name] are \\\n                                        required to match, but `{}` != `{}`\",\n                                       s, name);\n-                    sess.span_err(attr.span, msg.index(&FullRange));\n+                    sess.span_err(attr.span, &msg[]);\n                 }\n             }\n             return validate(s.clone(), None);\n@@ -192,17 +192,17 @@ fn symbol_hash<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // to be independent of one another in the crate.\n \n     symbol_hasher.reset();\n-    symbol_hasher.input_str(link_meta.crate_name.index(&FullRange));\n+    symbol_hasher.input_str(&link_meta.crate_name[]);\n     symbol_hasher.input_str(\"-\");\n     symbol_hasher.input_str(link_meta.crate_hash.as_str());\n     for meta in tcx.sess.crate_metadata.borrow().iter() {\n-        symbol_hasher.input_str(meta.index(&FullRange));\n+        symbol_hasher.input_str(&meta[]);\n     }\n     symbol_hasher.input_str(\"-\");\n-    symbol_hasher.input_str(encoder::encoded_ty(tcx, t).index(&FullRange));\n+    symbol_hasher.input_str(&encoder::encoded_ty(tcx, t)[]);\n     // Prefix with 'h' so that it never blends into adjacent digits\n     let mut hash = String::from_str(\"h\");\n-    hash.push_str(truncated_hash_result(symbol_hasher).index(&FullRange));\n+    hash.push_str(&truncated_hash_result(symbol_hasher)[]);\n     hash\n }\n \n@@ -251,7 +251,7 @@ pub fn sanitize(s: &str) -> String {\n                 let mut tstr = String::new();\n                 for c in c.escape_unicode() { tstr.push(c) }\n                 result.push('$');\n-                result.push_str(tstr.index(&(1..)));\n+                result.push_str(&tstr[1..]);\n             }\n         }\n     }\n@@ -260,7 +260,7 @@ pub fn sanitize(s: &str) -> String {\n     if result.len() > 0u &&\n         result.as_bytes()[0] != '_' as u8 &&\n         ! (result.as_bytes()[0] as char).is_xid_start() {\n-        return format!(\"_{}\", result.index(&FullRange));\n+        return format!(\"_{}\", &result[]);\n     }\n \n     return result;\n@@ -286,12 +286,12 @@ pub fn mangle<PI: Iterator<Item=PathElem>>(mut path: PI,\n \n     fn push(n: &mut String, s: &str) {\n         let sani = sanitize(s);\n-        n.push_str(format!(\"{}{}\", sani.len(), sani).index(&FullRange));\n+        n.push_str(&format!(\"{}{}\", sani.len(), sani)[]);\n     }\n \n     // First, connect each component with <len, name> pairs.\n     for e in path {\n-        push(&mut n, token::get_name(e.name()).get().index(&FullRange))\n+        push(&mut n, &token::get_name(e.name()).get()[])\n     }\n \n     match hash {\n@@ -329,17 +329,17 @@ pub fn mangle_exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, path: PathEl\n     hash.push(EXTRA_CHARS.as_bytes()[extra2] as char);\n     hash.push(EXTRA_CHARS.as_bytes()[extra3] as char);\n \n-    exported_name(path, hash.index(&FullRange))\n+    exported_name(path, &hash[])\n }\n \n pub fn mangle_internal_name_by_type_and_seq<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                       t: Ty<'tcx>,\n                                                       name: &str) -> String {\n     let s = ppaux::ty_to_string(ccx.tcx(), t);\n-    let path = [PathName(token::intern(s.index(&FullRange))),\n+    let path = [PathName(token::intern(&s[])),\n                 gensym_name(name)];\n     let hash = get_symbol_hash(ccx, t);\n-    mangle(ast_map::Values(path.iter()), Some(hash.index(&FullRange)))\n+    mangle(ast_map::Values(path.iter()), Some(&hash[]))\n }\n \n pub fn mangle_internal_name_by_path_and_seq(path: PathElems, flav: &str) -> String {\n@@ -357,9 +357,9 @@ pub fn remove(sess: &Session, path: &Path) {\n     match fs::unlink(path) {\n         Ok(..) => {}\n         Err(e) => {\n-            sess.err(format!(\"failed to remove {}: {}\",\n+            sess.err(&format!(\"failed to remove {}: {}\",\n                              path.display(),\n-                             e).index(&FullRange));\n+                             e)[]);\n         }\n     }\n }\n@@ -373,8 +373,8 @@ pub fn link_binary(sess: &Session,\n     let mut out_filenames = Vec::new();\n     for &crate_type in sess.crate_types.borrow().iter() {\n         if invalid_output_for_target(sess, crate_type) {\n-            sess.bug(format!(\"invalid output type `{:?}` for target os `{}`\",\n-                             crate_type, sess.opts.target_triple).index(&FullRange));\n+            sess.bug(&format!(\"invalid output type `{:?}` for target os `{}`\",\n+                             crate_type, sess.opts.target_triple)[]);\n         }\n         let out_file = link_binary_output(sess, trans, crate_type, outputs,\n                                           crate_name);\n@@ -439,8 +439,8 @@ pub fn filename_for_input(sess: &Session,\n             out_filename.with_filename(format!(\"lib{}.rlib\", libname))\n         }\n         config::CrateTypeDylib => {\n-            let (prefix, suffix) = (sess.target.target.options.dll_prefix.index(&FullRange),\n-                                    sess.target.target.options.dll_suffix.index(&FullRange));\n+            let (prefix, suffix) = (&sess.target.target.options.dll_prefix[],\n+                                    &sess.target.target.options.dll_suffix[]);\n             out_filename.with_filename(format!(\"{}{}{}\",\n                                                prefix,\n                                                libname,\n@@ -450,7 +450,7 @@ pub fn filename_for_input(sess: &Session,\n             out_filename.with_filename(format!(\"lib{}.a\", libname))\n         }\n         config::CrateTypeExecutable => {\n-            let suffix = sess.target.target.options.exe_suffix.index(&FullRange);\n+            let suffix = &sess.target.target.options.exe_suffix[];\n             out_filename.with_filename(format!(\"{}{}\", libname, suffix))\n         }\n     }\n@@ -477,14 +477,14 @@ fn link_binary_output(sess: &Session,\n     let obj_is_writeable = is_writeable(&obj_filename);\n     let out_is_writeable = is_writeable(&out_filename);\n     if !out_is_writeable {\n-        sess.fatal(format!(\"output file {} is not writeable -- check its \\\n+        sess.fatal(&format!(\"output file {} is not writeable -- check its \\\n                             permissions.\",\n-                           out_filename.display()).index(&FullRange));\n+                           out_filename.display())[]);\n     }\n     else if !obj_is_writeable {\n-        sess.fatal(format!(\"object file {} is not writeable -- check its \\\n+        sess.fatal(&format!(\"object file {} is not writeable -- check its \\\n                             permissions.\",\n-                           obj_filename.display()).index(&FullRange));\n+                           obj_filename.display())[]);\n     }\n \n     match crate_type {\n@@ -539,7 +539,7 @@ fn link_rlib<'a>(sess: &'a Session,\n     for &(ref l, kind) in sess.cstore.get_used_libraries().borrow().iter() {\n         match kind {\n             cstore::NativeStatic => {\n-                ab.add_native_library(l.index(&FullRange)).unwrap();\n+                ab.add_native_library(&l[]).unwrap();\n             }\n             cstore::NativeFramework | cstore::NativeUnknown => {}\n         }\n@@ -586,13 +586,13 @@ fn link_rlib<'a>(sess: &'a Session,\n             // the same filename for metadata (stomping over one another)\n             let tmpdir = TempDir::new(\"rustc\").ok().expect(\"needs a temp dir\");\n             let metadata = tmpdir.path().join(METADATA_FILENAME);\n-            match fs::File::create(&metadata).write(trans.metadata\n-                                                         .index(&FullRange)) {\n+            match fs::File::create(&metadata).write(&trans.metadata\n+                                                    []) {\n                 Ok(..) => {}\n                 Err(e) => {\n-                    sess.err(format!(\"failed to write {}: {}\",\n+                    sess.err(&format!(\"failed to write {}: {}\",\n                                      metadata.display(),\n-                                     e).index(&FullRange));\n+                                     e)[]);\n                     sess.abort_if_errors();\n                 }\n             }\n@@ -610,34 +610,34 @@ fn link_rlib<'a>(sess: &'a Session,\n                 // was exactly 16 bytes.\n                 let bc_filename = obj_filename.with_extension(format!(\"{}.bc\", i).as_slice());\n                 let bc_deflated_filename = obj_filename.with_extension(\n-                    format!(\"{}.bytecode.deflate\", i).index(&FullRange));\n+                    &format!(\"{}.bytecode.deflate\", i)[]);\n \n                 let bc_data = match fs::File::open(&bc_filename).read_to_end() {\n                     Ok(buffer) => buffer,\n-                    Err(e) => sess.fatal(format!(\"failed to read bytecode: {}\",\n-                                                 e).index(&FullRange))\n+                    Err(e) => sess.fatal(&format!(\"failed to read bytecode: {}\",\n+                                                 e)[])\n                 };\n \n-                let bc_data_deflated = match flate::deflate_bytes(bc_data.index(&FullRange)) {\n+                let bc_data_deflated = match flate::deflate_bytes(&bc_data[]) {\n                     Some(compressed) => compressed,\n-                    None => sess.fatal(format!(\"failed to compress bytecode from {}\",\n-                                               bc_filename.display()).index(&FullRange))\n+                    None => sess.fatal(&format!(\"failed to compress bytecode from {}\",\n+                                               bc_filename.display())[])\n                 };\n \n                 let mut bc_file_deflated = match fs::File::create(&bc_deflated_filename) {\n                     Ok(file) => file,\n                     Err(e) => {\n-                        sess.fatal(format!(\"failed to create compressed bytecode \\\n-                                            file: {}\", e).index(&FullRange))\n+                        sess.fatal(&format!(\"failed to create compressed bytecode \\\n+                                            file: {}\", e)[])\n                     }\n                 };\n \n                 match write_rlib_bytecode_object_v1(&mut bc_file_deflated,\n                                                     bc_data_deflated.as_slice()) {\n                     Ok(()) => {}\n                     Err(e) => {\n-                        sess.err(format!(\"failed to write compressed bytecode: \\\n-                                          {}\", e).index(&FullRange));\n+                        sess.err(&format!(\"failed to write compressed bytecode: \\\n+                                          {}\", e)[]);\n                         sess.abort_if_errors()\n                     }\n                 };\n@@ -677,7 +677,7 @@ fn write_rlib_bytecode_object_v1<T: Writer>(writer: &mut T,\n     try! { writer.write(RLIB_BYTECODE_OBJECT_MAGIC) };\n     try! { writer.write_le_u32(1) };\n     try! { writer.write_le_u64(bc_data_deflated_size) };\n-    try! { writer.write(bc_data_deflated.index(&FullRange)) };\n+    try! { writer.write(&bc_data_deflated[]) };\n \n     let number_of_bytes_written_so_far =\n         RLIB_BYTECODE_OBJECT_MAGIC.len() +                // magic id\n@@ -727,12 +727,12 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n         let ref name = sess.cstore.get_crate_data(cnum).name;\n         let p = match *path {\n             Some(ref p) => p.clone(), None => {\n-                sess.err(format!(\"could not find rlib for: `{}`\",\n-                                 name).index(&FullRange));\n+                sess.err(&format!(\"could not find rlib for: `{}`\",\n+                                 name)[]);\n                 continue\n             }\n         };\n-        ab.add_rlib(&p, name.index(&FullRange), sess.lto()).unwrap();\n+        ab.add_rlib(&p, &name[], sess.lto()).unwrap();\n \n         let native_libs = csearch::get_native_libraries(&sess.cstore, cnum);\n         all_native_libs.extend(native_libs.into_iter());\n@@ -754,7 +754,7 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n             cstore::NativeUnknown => \"library\",\n             cstore::NativeFramework => \"framework\",\n         };\n-        sess.note(format!(\"{}: {}\", name, *lib).index(&FullRange));\n+        sess.note(&format!(\"{}: {}\", name, *lib)[]);\n     }\n }\n \n@@ -768,12 +768,12 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n \n     // The invocations of cc share some flags across platforms\n     let pname = get_cc_prog(sess);\n-    let mut cmd = Command::new(pname.index(&FullRange));\n+    let mut cmd = Command::new(&pname[]);\n \n-    cmd.args(sess.target.target.options.pre_link_args.index(&FullRange));\n+    cmd.args(&sess.target.target.options.pre_link_args[]);\n     link_args(&mut cmd, sess, dylib, tmpdir.path(),\n               trans, obj_filename, out_filename);\n-    cmd.args(sess.target.target.options.post_link_args.index(&FullRange));\n+    cmd.args(&sess.target.target.options.post_link_args[]);\n     if !sess.target.target.options.no_compiler_rt {\n         cmd.arg(\"-lcompiler-rt\");\n     }\n@@ -791,22 +791,22 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n     match prog {\n         Ok(prog) => {\n             if !prog.status.success() {\n-                sess.err(format!(\"linking with `{}` failed: {}\",\n+                sess.err(&format!(\"linking with `{}` failed: {}\",\n                                  pname,\n-                                 prog.status).index(&FullRange));\n-                sess.note(format!(\"{}\", &cmd).index(&FullRange));\n+                                 prog.status)[]);\n+                sess.note(&format!(\"{}\", &cmd)[]);\n                 let mut output = prog.error.clone();\n-                output.push_all(prog.output.index(&FullRange));\n-                sess.note(str::from_utf8(output.index(&FullRange)).unwrap());\n+                output.push_all(&prog.output[]);\n+                sess.note(str::from_utf8(&output[]).unwrap());\n                 sess.abort_if_errors();\n             }\n             debug!(\"linker stderr:\\n{}\", String::from_utf8(prog.error).unwrap());\n             debug!(\"linker stdout:\\n{}\", String::from_utf8(prog.output).unwrap());\n         },\n         Err(e) => {\n-            sess.err(format!(\"could not exec the linker `{}`: {}\",\n+            sess.err(&format!(\"could not exec the linker `{}`: {}\",\n                              pname,\n-                             e).index(&FullRange));\n+                             e)[]);\n             sess.abort_if_errors();\n         }\n     }\n@@ -818,7 +818,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n         match Command::new(\"dsymutil\").arg(out_filename).output() {\n             Ok(..) => {}\n             Err(e) => {\n-                sess.err(format!(\"failed to run dsymutil: {}\", e).index(&FullRange));\n+                sess.err(&format!(\"failed to run dsymutil: {}\", e)[]);\n                 sess.abort_if_errors();\n             }\n         }\n@@ -867,7 +867,7 @@ fn link_args(cmd: &mut Command,\n \n             let mut v = b\"-Wl,-force_load,\".to_vec();\n             v.push_all(morestack.as_vec());\n-            cmd.arg(v.index(&FullRange));\n+            cmd.arg(&v[]);\n         } else {\n             cmd.args(&[\"-Wl,--whole-archive\", \"-lmorestack\", \"-Wl,--no-whole-archive\"]);\n         }\n@@ -992,7 +992,7 @@ fn link_args(cmd: &mut Command,\n             if sess.opts.cg.rpath {\n                 let mut v = \"-Wl,-install_name,@rpath/\".as_bytes().to_vec();\n                 v.push_all(out_filename.filename().unwrap());\n-                cmd.arg(v.index(&FullRange));\n+                cmd.arg(&v[]);\n             }\n         } else {\n             cmd.arg(\"-shared\");\n@@ -1004,7 +1004,7 @@ fn link_args(cmd: &mut Command,\n     // addl_lib_search_paths\n     if sess.opts.cg.rpath {\n         let sysroot = sess.sysroot();\n-        let target_triple = sess.opts.target_triple.index(&FullRange);\n+        let target_triple = &sess.opts.target_triple[];\n         let get_install_prefix_lib_path = |:| {\n             let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n             let tlib = filesearch::relative_target_lib_path(sysroot, target_triple);\n@@ -1021,14 +1021,14 @@ fn link_args(cmd: &mut Command,\n             get_install_prefix_lib_path: get_install_prefix_lib_path,\n             realpath: ::util::fs::realpath\n         };\n-        cmd.args(rpath::get_rpath_flags(rpath_config).index(&FullRange));\n+        cmd.args(&rpath::get_rpath_flags(rpath_config)[]);\n     }\n \n     // Finally add all the linker arguments provided on the command line along\n     // with any #[link_args] attributes found inside the crate\n     let empty = Vec::new();\n-    cmd.args(sess.opts.cg.link_args.as_ref().unwrap_or(&empty).index(&FullRange));\n-    cmd.args(used_link_args.index(&FullRange));\n+    cmd.args(&sess.opts.cg.link_args.as_ref().unwrap_or(&empty)[]);\n+    cmd.args(&used_link_args[]);\n }\n \n // # Native library linking\n@@ -1082,14 +1082,14 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n         } else {\n             // -force_load is the OSX equivalent of --whole-archive, but it\n             // involves passing the full path to the library to link.\n-            let lib = archive::find_library(l.index(&FullRange),\n+            let lib = archive::find_library(&l[],\n                                             sess.target.target.options.staticlib_prefix.as_slice(),\n                                             sess.target.target.options.staticlib_suffix.as_slice(),\n-                                            search_path.index(&FullRange),\n+                                            &search_path[],\n                                             &sess.diagnostic().handler);\n             let mut v = b\"-Wl,-force_load,\".to_vec();\n             v.push_all(lib.as_vec());\n-            cmd.arg(v.index(&FullRange));\n+            cmd.arg(&v[]);\n         }\n     }\n     if takes_hints {\n@@ -1102,7 +1102,7 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n                 cmd.arg(format!(\"-l{}\", l));\n             }\n             cstore::NativeFramework => {\n-                cmd.arg(\"-framework\").arg(l.index(&FullRange));\n+                cmd.arg(\"-framework\").arg(&l[]);\n             }\n             cstore::NativeStatic => unreachable!(),\n         }\n@@ -1158,7 +1158,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n     // Converts a library file-stem into a cc -l argument\n     fn unlib<'a>(config: &config::Config, stem: &'a [u8]) -> &'a [u8] {\n         if stem.starts_with(\"lib\".as_bytes()) && !config.target.options.is_like_windows {\n-            stem.index(&(3..))\n+            &stem[3..]\n         } else {\n             stem\n         }\n@@ -1183,18 +1183,18 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n         // against the archive.\n         if sess.lto() {\n             let name = cratepath.filename_str().unwrap();\n-            let name = name.index(&(3..(name.len() - 5))); // chop off lib/.rlib\n+            let name = &name[3..(name.len() - 5)]; // chop off lib/.rlib\n             time(sess.time_passes(),\n-                 format!(\"altering {}.rlib\", name).index(&FullRange),\n+                 &format!(\"altering {}.rlib\", name)[],\n                  (), |()| {\n                 let dst = tmpdir.join(cratepath.filename().unwrap());\n                 match fs::copy(&cratepath, &dst) {\n                     Ok(..) => {}\n                     Err(e) => {\n-                        sess.err(format!(\"failed to copy {} to {}: {}\",\n+                        sess.err(&format!(\"failed to copy {} to {}: {}\",\n                                          cratepath.display(),\n                                          dst.display(),\n-                                         e).index(&FullRange));\n+                                         e)[]);\n                         sess.abort_if_errors();\n                     }\n                 }\n@@ -1204,9 +1204,9 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                 match fs::chmod(&dst, io::USER_READ | io::USER_WRITE) {\n                     Ok(..) => {}\n                     Err(e) => {\n-                        sess.err(format!(\"failed to chmod {} when preparing \\\n+                        sess.err(&format!(\"failed to chmod {} when preparing \\\n                                           for LTO: {}\", dst.display(),\n-                                         e).index(&FullRange));\n+                                         e)[]);\n                         sess.abort_if_errors();\n                     }\n                 }\n@@ -1220,9 +1220,9 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                     maybe_ar_prog: sess.opts.cg.ar.clone()\n                 };\n                 let mut archive = Archive::open(config);\n-                archive.remove_file(format!(\"{}.o\", name).index(&FullRange));\n+                archive.remove_file(&format!(\"{}.o\", name)[]);\n                 let files = archive.files();\n-                if files.iter().any(|s| s.index(&FullRange).ends_with(\".o\")) {\n+                if files.iter().any(|s| s[].ends_with(\".o\")) {\n                     cmd.arg(dst);\n                 }\n             });\n@@ -1244,7 +1244,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n \n         let mut v = \"-l\".as_bytes().to_vec();\n         v.push_all(unlib(&sess.target, cratepath.filestem().unwrap()));\n-        cmd.arg(v.index(&FullRange));\n+        cmd.arg(&v[]);\n     }\n }\n \n@@ -1286,7 +1286,7 @@ fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n                 }\n                 cstore::NativeFramework => {\n                     cmd.arg(\"-framework\");\n-                    cmd.arg(lib.index(&FullRange));\n+                    cmd.arg(&lib[]);\n                 }\n                 cstore::NativeStatic => {\n                     sess.bug(\"statics shouldn't be propagated\");"}, {"sha": "e457de6bc771b0106e0ae84cea1fadd2d5b5d91b", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -53,30 +53,30 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n         let path = match path {\n             Some(p) => p,\n             None => {\n-                sess.fatal(format!(\"could not find rlib for: `{}`\",\n-                                   name).index(&FullRange));\n+                sess.fatal(&format!(\"could not find rlib for: `{}`\",\n+                                   name)[]);\n             }\n         };\n \n         let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n         let file = path.filename_str().unwrap();\n-        let file = file.index(&(3..(file.len() - 5))); // chop off lib/.rlib\n+        let file = &file[3..(file.len() - 5)]; // chop off lib/.rlib\n         debug!(\"reading {}\", file);\n         for i in iter::count(0u, 1) {\n             let bc_encoded = time(sess.time_passes(),\n                                   format!(\"check for {}.{}.bytecode.deflate\", name, i).as_slice(),\n                                   (),\n                                   |_| {\n-                                      archive.read(format!(\"{}.{}.bytecode.deflate\",\n-                                                           file, i).index(&FullRange))\n+                                      archive.read(&format!(\"{}.{}.bytecode.deflate\",\n+                                                           file, i)[])\n                                   });\n             let bc_encoded = match bc_encoded {\n                 Some(data) => data,\n                 None => {\n                     if i == 0 {\n                         // No bitcode was found at all.\n-                        sess.fatal(format!(\"missing compressed bytecode in {}\",\n-                                           path.display()).index(&FullRange));\n+                        sess.fatal(&format!(\"missing compressed bytecode in {}\",\n+                                           path.display())[]);\n                     }\n                     // No more bitcode files to read.\n                     break;\n@@ -91,20 +91,20 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                     if version == 1 {\n                         // The only version existing so far\n                         let data_size = extract_compressed_bytecode_size_v1(bc_encoded);\n-                        let compressed_data = bc_encoded.index(&(\n+                        let compressed_data = &bc_encoded[\n                             link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET..\n-                            (link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint)));\n+                            (link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint)];\n \n                         match flate::inflate_bytes(compressed_data) {\n                             Some(inflated) => inflated,\n                             None => {\n-                                sess.fatal(format!(\"failed to decompress bc of `{}`\",\n-                                                   name).index(&FullRange))\n+                                sess.fatal(&format!(\"failed to decompress bc of `{}`\",\n+                                                   name)[])\n                             }\n                         }\n                     } else {\n-                        sess.fatal(format!(\"Unsupported bytecode format version {}\",\n-                                           version).index(&FullRange))\n+                        sess.fatal(&format!(\"Unsupported bytecode format version {}\",\n+                                           version)[])\n                     }\n                 })\n             } else {\n@@ -114,8 +114,8 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                     match flate::inflate_bytes(bc_encoded) {\n                         Some(bc) => bc,\n                         None => {\n-                            sess.fatal(format!(\"failed to decompress bc of `{}`\",\n-                                               name).index(&FullRange))\n+                            sess.fatal(&format!(\"failed to decompress bc of `{}`\",\n+                                               name)[])\n                         }\n                     }\n                 })\n@@ -124,15 +124,15 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             let ptr = bc_decoded.as_slice().as_ptr();\n             debug!(\"linking {}, part {}\", name, i);\n             time(sess.time_passes(),\n-                 format!(\"ll link {}.{}\", name, i).index(&FullRange),\n+                 &format!(\"ll link {}.{}\", name, i)[],\n                  (),\n                  |()| unsafe {\n                 if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n                                                         ptr as *const libc::c_char,\n                                                         bc_decoded.len() as libc::size_t) {\n                     write::llvm_err(sess.diagnostic().handler(),\n                                     format!(\"failed to load bc of `{}`\",\n-                                            name.index(&FullRange)));\n+                                            &name[]));\n                 }\n             });\n         }\n@@ -186,7 +186,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n fn is_versioned_bytecode_format(bc: &[u8]) -> bool {\n     let magic_id_byte_count = link::RLIB_BYTECODE_OBJECT_MAGIC.len();\n     return bc.len() > magic_id_byte_count &&\n-           bc.index(&(0..magic_id_byte_count)) == link::RLIB_BYTECODE_OBJECT_MAGIC;\n+           &bc[0..magic_id_byte_count] == link::RLIB_BYTECODE_OBJECT_MAGIC;\n }\n \n fn extract_bytecode_format_version(bc: &[u8]) -> u32 {\n@@ -198,8 +198,7 @@ fn extract_compressed_bytecode_size_v1(bc: &[u8]) -> u64 {\n }\n \n fn read_from_le_bytes<T: Int>(bytes: &[u8], position_in_bytes: uint) -> T {\n-    let byte_data = bytes.index(&(position_in_bytes..\n-                                  (position_in_bytes + mem::size_of::<T>())));\n+    let byte_data = &bytes[position_in_bytes..(position_in_bytes + mem::size_of::<T>())];\n     let data = unsafe {\n         *(byte_data.as_ptr() as *const T)\n     };"}, {"sha": "e0ba6d569cc031cf7cabc5e82f85c3876635d1de", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -47,14 +47,14 @@ pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n         if cstr == ptr::null() {\n-            handler.fatal(msg.index(&FullRange));\n+            handler.fatal(&msg[]);\n         } else {\n             let err = ffi::c_str_to_bytes(&cstr);\n             let err = String::from_utf8_lossy(err.as_slice()).to_string();\n             libc::free(cstr as *mut _);\n-            handler.fatal(format!(\"{}: {}\",\n-                                  msg.index(&FullRange),\n-                                  err.index(&FullRange)).index(&FullRange));\n+            handler.fatal(&format!(\"{}: {}\",\n+                                  &msg[],\n+                                  &err[])[]);\n         }\n     }\n }\n@@ -104,13 +104,13 @@ impl SharedEmitter {\n             match diag.code {\n                 Some(ref code) => {\n                     handler.emit_with_code(None,\n-                                           diag.msg.index(&FullRange),\n-                                           code.index(&FullRange),\n+                                           &diag.msg[],\n+                                           &code[],\n                                            diag.lvl);\n                 },\n                 None => {\n                     handler.emit(None,\n-                                 diag.msg.index(&FullRange),\n+                                 &diag.msg[],\n                                  diag.lvl);\n                 },\n             }\n@@ -165,19 +165,19 @@ fn get_llvm_opt_level(optimize: config::OptLevel) -> llvm::CodeGenOptLevel {\n \n fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let reloc_model_arg = match sess.opts.cg.relocation_model {\n-        Some(ref s) => s.index(&FullRange),\n-        None => sess.target.target.options.relocation_model.index(&FullRange)\n+        Some(ref s) => &s[],\n+        None => &sess.target.target.options.relocation_model[]\n     };\n     let reloc_model = match reloc_model_arg {\n         \"pic\" => llvm::RelocPIC,\n         \"static\" => llvm::RelocStatic,\n         \"default\" => llvm::RelocDefault,\n         \"dynamic-no-pic\" => llvm::RelocDynamicNoPic,\n         _ => {\n-            sess.err(format!(\"{:?} is not a valid relocation mode\",\n+            sess.err(&format!(\"{:?} is not a valid relocation mode\",\n                              sess.opts\n                                  .cg\n-                                 .relocation_model).index(&FullRange));\n+                                 .relocation_model)[]);\n             sess.abort_if_errors();\n             unreachable!();\n         }\n@@ -198,8 +198,8 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let fdata_sections = ffunction_sections;\n \n     let code_model_arg = match sess.opts.cg.code_model {\n-        Some(ref s) => s.index(&FullRange),\n-        None => sess.target.target.options.code_model.index(&FullRange)\n+        Some(ref s) => &s[],\n+        None => &sess.target.target.options.code_model[]\n     };\n \n     let code_model = match code_model_arg {\n@@ -209,16 +209,16 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n         \"medium\" => llvm::CodeModelMedium,\n         \"large\" => llvm::CodeModelLarge,\n         _ => {\n-            sess.err(format!(\"{:?} is not a valid code model\",\n+            sess.err(&format!(\"{:?} is not a valid code model\",\n                              sess.opts\n                                  .cg\n-                                 .code_model).index(&FullRange));\n+                                 .code_model)[]);\n             sess.abort_if_errors();\n             unreachable!();\n         }\n     };\n \n-    let triple = sess.target.target.llvm_target.index(&FullRange);\n+    let triple = &sess.target.target.llvm_target[];\n \n     let tm = unsafe {\n         let triple = CString::from_slice(triple.as_bytes());\n@@ -350,13 +350,13 @@ unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n     match cgcx.lto_ctxt {\n         Some((sess, _)) => {\n             sess.codemap().with_expn_info(ExpnId::from_llvm_cookie(cookie), |info| match info {\n-                Some(ei) => sess.span_err(ei.call_site, msg.index(&FullRange)),\n-                None     => sess.err(msg.index(&FullRange)),\n+                Some(ei) => sess.span_err(ei.call_site, &msg[]),\n+                None     => sess.err(&msg[]),\n             });\n         }\n \n         None => {\n-            cgcx.handler.err(msg.index(&FullRange));\n+            cgcx.handler.err(&msg[]);\n             cgcx.handler.note(\"build without -C codegen-units for more exact errors\");\n         }\n     }\n@@ -518,14 +518,14 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         }\n \n         if config.emit_asm {\n-            let path = output_names.with_extension(format!(\"{}.s\", name_extra).index(&FullRange));\n+            let path = output_names.with_extension(&format!(\"{}.s\", name_extra)[]);\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::AssemblyFileType);\n             });\n         }\n \n         if config.emit_obj {\n-            let path = output_names.with_extension(format!(\"{}.o\", name_extra).index(&FullRange));\n+            let path = output_names.with_extension(&format!(\"{}.o\", name_extra)[]);\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::ObjectFileType);\n             });\n@@ -639,7 +639,7 @@ pub fn run_passes(sess: &Session,\n \n     // Process the work items, optionally using worker threads.\n     if sess.opts.cg.codegen_units == 1 {\n-        run_work_singlethreaded(sess, trans.reachable.index(&FullRange), work_items);\n+        run_work_singlethreaded(sess, &trans.reachable[], work_items);\n     } else {\n         run_work_multithreaded(sess, work_items, sess.opts.cg.codegen_units);\n     }\n@@ -666,8 +666,8 @@ pub fn run_passes(sess: &Session,\n             if crate_output.single_output_file.is_some() {\n                 // 2) Multiple codegen units, with `-o some_name`.  We have\n                 //    no good solution for this case, so warn the user.\n-                sess.warn(format!(\"ignoring -o because multiple .{} files were produced\",\n-                                  ext).index(&FullRange));\n+                sess.warn(&format!(\"ignoring -o because multiple .{} files were produced\",\n+                                  ext)[]);\n             } else {\n                 // 3) Multiple codegen units, but no `-o some_name`.  We\n                 //    just leave the `foo.0.x` files in place.\n@@ -700,20 +700,20 @@ pub fn run_passes(sess: &Session,\n             };\n \n         let pname = get_cc_prog(sess);\n-        let mut cmd = Command::new(pname.index(&FullRange));\n+        let mut cmd = Command::new(&pname[]);\n \n-        cmd.args(sess.target.target.options.pre_link_args.index(&FullRange));\n+        cmd.args(&sess.target.target.options.pre_link_args[]);\n         cmd.arg(\"-nostdlib\");\n \n         for index in range(0, trans.modules.len()) {\n-            cmd.arg(crate_output.with_extension(format!(\"{}.o\", index).index(&FullRange)));\n+            cmd.arg(crate_output.with_extension(&format!(\"{}.o\", index)[]));\n         }\n \n         cmd.arg(\"-r\")\n            .arg(\"-o\")\n            .arg(windows_output_path.as_ref().unwrap_or(output_path));\n \n-        cmd.args(sess.target.target.options.post_link_args.index(&FullRange));\n+        cmd.args(&sess.target.target.options.post_link_args[]);\n \n         if (sess.opts.debugging_opts & config::PRINT_LINK_ARGS) != 0 {\n             println!(\"{}\", &cmd);\n@@ -725,15 +725,15 @@ pub fn run_passes(sess: &Session,\n         match cmd.status() {\n             Ok(status) => {\n                 if !status.success() {\n-                    sess.err(format!(\"linking of {} with `{}` failed\",\n-                                     output_path.display(), cmd).index(&FullRange));\n+                    sess.err(&format!(\"linking of {} with `{}` failed\",\n+                                     output_path.display(), cmd)[]);\n                     sess.abort_if_errors();\n                 }\n             },\n             Err(e) => {\n-                sess.err(format!(\"could not exec the linker `{}`: {}\",\n+                sess.err(&format!(\"could not exec the linker `{}`: {}\",\n                                  pname,\n-                                 e).index(&FullRange));\n+                                 e)[]);\n                 sess.abort_if_errors();\n             },\n         }\n@@ -818,12 +818,12 @@ pub fn run_passes(sess: &Session,\n         for i in range(0, trans.modules.len()) {\n             if modules_config.emit_obj {\n                 let ext = format!(\"{}.o\", i);\n-                remove(sess, &crate_output.with_extension(ext.index(&FullRange)));\n+                remove(sess, &crate_output.with_extension(&ext[]));\n             }\n \n             if modules_config.emit_bc && !keep_numbered_bitcode {\n                 let ext = format!(\"{}.bc\", i);\n-                remove(sess, &crate_output.with_extension(ext.index(&FullRange)));\n+                remove(sess, &crate_output.with_extension(&ext[]));\n             }\n         }\n \n@@ -949,7 +949,7 @@ fn run_work_multithreaded(sess: &Session,\n \n pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n     let pname = get_cc_prog(sess);\n-    let mut cmd = Command::new(pname.index(&FullRange));\n+    let mut cmd = Command::new(&pname[]);\n \n     cmd.arg(\"-c\").arg(\"-o\").arg(outputs.path(config::OutputTypeObject))\n                            .arg(outputs.temp_path(config::OutputTypeAssembly));\n@@ -958,20 +958,20 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n     match cmd.output() {\n         Ok(prog) => {\n             if !prog.status.success() {\n-                sess.err(format!(\"linking with `{}` failed: {}\",\n+                sess.err(&format!(\"linking with `{}` failed: {}\",\n                                  pname,\n-                                 prog.status).index(&FullRange));\n-                sess.note(format!(\"{}\", &cmd).index(&FullRange));\n+                                 prog.status)[]);\n+                sess.note(&format!(\"{}\", &cmd)[]);\n                 let mut note = prog.error.clone();\n-                note.push_all(prog.output.index(&FullRange));\n-                sess.note(str::from_utf8(note.index(&FullRange)).unwrap());\n+                note.push_all(&prog.output[]);\n+                sess.note(str::from_utf8(&note[]).unwrap());\n                 sess.abort_if_errors();\n             }\n         },\n         Err(e) => {\n-            sess.err(format!(\"could not exec the linker `{}`: {}\",\n+            sess.err(&format!(\"could not exec the linker `{}`: {}\",\n                              pname,\n-                             e).index(&FullRange));\n+                             e)[]);\n             sess.abort_if_errors();\n         }\n     }\n@@ -1004,7 +1004,7 @@ unsafe fn configure_llvm(sess: &Session) {\n         if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n \n         for arg in sess.opts.cg.llvm_args.iter() {\n-            add((*arg).index(&FullRange));\n+            add(&(*arg)[]);\n         }\n     }\n "}, {"sha": "eb163ed7406f25597654631f13b9bfe80fb5fbea", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 86, "deletions": 86, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -94,7 +94,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n         // dump info about all the external crates referenced from this crate\n         self.sess.cstore.iter_crate_data(|n, cmd| {\n-            self.fmt.external_crate_str(krate.span, cmd.name.index(&FullRange), n);\n+            self.fmt.external_crate_str(krate.span, &cmd.name[], n);\n         });\n         self.fmt.recorder.record(\"end_external_crates\\n\");\n     }\n@@ -143,7 +143,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     qualname.index(&FullRange),\n+                                     &qualname[],\n                                      self.cur_scope);\n         }\n     }\n@@ -161,7 +161,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     qualname.index(&FullRange),\n+                                     &qualname[],\n                                      self.cur_scope);\n         }\n     }\n@@ -180,26 +180,26 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let (ref span, ref qualname) = sub_paths[len-2];\n         self.fmt.sub_type_ref_str(path.span,\n                                   *span,\n-                                  qualname.index(&FullRange));\n+                                  &qualname[]);\n \n         // write the other sub-paths\n         if len <= 2 {\n             return;\n         }\n-        let sub_paths = sub_paths.index(&(0..(len-2)));\n+        let sub_paths = &sub_paths[0..(len-2)];\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     qualname.index(&FullRange),\n+                                     &qualname[],\n                                      self.cur_scope);\n         }\n     }\n \n     // looks up anything, not just a type\n     fn lookup_type_ref(&self, ref_id: NodeId) -> Option<DefId> {\n         if !self.analysis.ty_cx.def_map.borrow().contains_key(&ref_id) {\n-            self.sess.bug(format!(\"def_map has no key for {} in lookup_type_ref\",\n-                                  ref_id).index(&FullRange));\n+            self.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n+                                  ref_id)[]);\n         }\n         let def = (*self.analysis.ty_cx.def_map.borrow())[ref_id];\n         match def {\n@@ -211,8 +211,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     fn lookup_def_kind(&self, ref_id: NodeId, span: Span) -> Option<recorder::Row> {\n         let def_map = self.analysis.ty_cx.def_map.borrow();\n         if !def_map.contains_key(&ref_id) {\n-            self.sess.span_bug(span, format!(\"def_map has no key for {} in lookup_def_kind\",\n-                                             ref_id).index(&FullRange));\n+            self.sess.span_bug(span, &format!(\"def_map has no key for {} in lookup_def_kind\",\n+                                             ref_id)[]);\n         }\n         let def = (*def_map)[ref_id];\n         match def {\n@@ -240,8 +240,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefUse(_) |\n             def::DefMethod(..) |\n             def::DefPrimTy(_) => {\n-                self.sess.span_bug(span, format!(\"lookup_def_kind for unexpected item: {:?}\",\n-                                                 def).index(&FullRange));\n+                self.sess.span_bug(span, &format!(\"lookup_def_kind for unexpected item: {:?}\",\n+                                                 def)[]);\n             },\n         }\n     }\n@@ -262,8 +262,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                     span_utils.span_for_last_ident(p.span),\n                                     id,\n                                     qualname,\n-                                    path_to_string(p).index(&FullRange),\n-                                    typ.index(&FullRange));\n+                                    &path_to_string(p)[],\n+                                    &typ[]);\n             }\n             self.collected_paths.clear();\n         }\n@@ -285,7 +285,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     match item.node {\n                         ast::ItemImpl(_, _, _, _, ref ty, _) => {\n                             let mut result = String::from_str(\"<\");\n-                            result.push_str(ty_to_string(&**ty).index(&FullRange));\n+                            result.push_str(&ty_to_string(&**ty)[]);\n \n                             match ty::trait_of_item(&self.analysis.ty_cx,\n                                                     ast_util::local_def(method.id)) {\n@@ -301,18 +301,18 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         }\n                         _ => {\n                             self.sess.span_bug(method.span,\n-                                               format!(\"Container {} for method {} not an impl?\",\n-                                                       impl_id.node, method.id).index(&FullRange));\n+                                               &format!(\"Container {} for method {} not an impl?\",\n+                                                       impl_id.node, method.id)[]);\n                         },\n                     }\n                 },\n                 _ => {\n                     self.sess.span_bug(method.span,\n-                                       format!(\"Container {} for method {} is not a node item {:?}\",\n-                                               impl_id.node,\n-                                               method.id,\n-                                               self.analysis.ty_cx.map.get(impl_id.node)\n-                                              ).index(&FullRange));\n+                                       &format!(\n+                                           \"Container {} for method {} is not a node item {:?}\",\n+                                           impl_id.node,\n+                                           method.id,\n+                                           self.analysis.ty_cx.map.get(impl_id.node))[]);\n                 },\n             },\n             None => match ty::trait_of_item(&self.analysis.ty_cx,\n@@ -327,21 +327,21 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         }\n                         _ => {\n                             self.sess.span_bug(method.span,\n-                                               format!(\"Could not find container {} for method {}\",\n-                                                       def_id.node, method.id).index(&FullRange));\n+                                               &format!(\"Could not find container {} for method {}\",\n+                                                       def_id.node, method.id)[]);\n                         }\n                     }\n                 },\n                 None => {\n                     self.sess.span_bug(method.span,\n-                                       format!(\"Could not find container for method {}\",\n-                                               method.id).index(&FullRange));\n+                                       &format!(\"Could not find container for method {}\",\n+                                               method.id)[]);\n                 },\n             },\n         };\n \n         qualname.push_str(get_ident(method.pe_ident()).get());\n-        let qualname = qualname.index(&FullRange);\n+        let qualname = &qualname[];\n \n         // record the decl for this def (if it has one)\n         let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n@@ -430,13 +430,13 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     Some(sub_span) => self.fmt.field_str(field.span,\n                                                          Some(sub_span),\n                                                          field.node.id,\n-                                                         name.get().index(&FullRange),\n-                                                         qualname.index(&FullRange),\n-                                                         typ.index(&FullRange),\n+                                                         &name.get()[],\n+                                                         &qualname[],\n+                                                         &typ[],\n                                                          scope_id),\n                     None => self.sess.span_bug(field.span,\n-                                               format!(\"Could not find sub-span for field {}\",\n-                                                       qualname).index(&FullRange)),\n+                                               &format!(\"Could not find sub-span for field {}\",\n+                                                       qualname)[]),\n                 }\n             },\n             _ => (),\n@@ -463,7 +463,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.fmt.typedef_str(full_span,\n                                  Some(*param_ss),\n                                  param.id,\n-                                 name.index(&FullRange),\n+                                 &name[],\n                                  \"\");\n         }\n         self.visit_generics(generics);\n@@ -480,10 +480,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.fn_str(item.span,\n                         sub_span,\n                         item.id,\n-                        qualname.index(&FullRange),\n+                        &qualname[],\n                         self.cur_scope);\n \n-        self.process_formals(&decl.inputs, qualname.index(&FullRange));\n+        self.process_formals(&decl.inputs, &qualname[]);\n \n         // walk arg and return types\n         for arg in decl.inputs.iter() {\n@@ -497,7 +497,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         // walk the body\n         self.nest(item.id, |v| v.visit_block(&*body));\n \n-        self.process_generic_params(ty_params, item.span, qualname.index(&FullRange), item.id);\n+        self.process_generic_params(ty_params, item.span, &qualname[], item.id);\n     }\n \n     fn process_static(&mut self,\n@@ -519,9 +519,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             get_ident(item.ident).get(),\n-                            qualname.index(&FullRange),\n-                            value.index(&FullRange),\n-                            ty_to_string(&*typ).index(&FullRange),\n+                            &qualname[],\n+                            &value[],\n+                            &ty_to_string(&*typ)[],\n                             self.cur_scope);\n \n         // walk type and init value\n@@ -542,9 +542,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             get_ident(item.ident).get(),\n-                            qualname.index(&FullRange),\n+                            &qualname[],\n                             \"\",\n-                            ty_to_string(&*typ).index(&FullRange),\n+                            &ty_to_string(&*typ)[],\n                             self.cur_scope);\n \n         // walk type and init value\n@@ -568,17 +568,17 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             ctor_id,\n-                            qualname.index(&FullRange),\n+                            &qualname[],\n                             self.cur_scope,\n-                            val.index(&FullRange));\n+                            &val[]);\n \n         // fields\n         for field in def.fields.iter() {\n-            self.process_struct_field_def(field, qualname.index(&FullRange), item.id);\n+            self.process_struct_field_def(field, &qualname[], item.id);\n             self.visit_ty(&*field.node.ty);\n         }\n \n-        self.process_generic_params(ty_params, item.span, qualname.index(&FullRange), item.id);\n+        self.process_generic_params(ty_params, item.span, &qualname[], item.id);\n     }\n \n     fn process_enum(&mut self,\n@@ -591,12 +591,12 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             Some(sub_span) => self.fmt.enum_str(item.span,\n                                                 Some(sub_span),\n                                                 item.id,\n-                                                enum_name.index(&FullRange),\n+                                                &enum_name[],\n                                                 self.cur_scope,\n-                                                val.index(&FullRange)),\n+                                                &val[]),\n             None => self.sess.span_bug(item.span,\n-                                       format!(\"Could not find subspan for enum {}\",\n-                                               enum_name).index(&FullRange)),\n+                                       &format!(\"Could not find subspan for enum {}\",\n+                                               enum_name)[]),\n         }\n         for variant in enum_definition.variants.iter() {\n             let name = get_ident(variant.node.name);\n@@ -612,9 +612,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                self.span.span_for_first_ident(variant.span),\n                                                variant.node.id,\n                                                name,\n-                                               qualname.index(&FullRange),\n-                                               enum_name.index(&FullRange),\n-                                               val.index(&FullRange),\n+                                               &qualname[],\n+                                               &enum_name[],\n+                                               &val[],\n                                                item.id);\n                     for arg in args.iter() {\n                         self.visit_ty(&*arg.ty);\n@@ -630,9 +630,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         self.span.span_for_first_ident(variant.span),\n                         variant.node.id,\n                         ctor_id,\n-                        qualname.index(&FullRange),\n-                        enum_name.index(&FullRange),\n-                        val.index(&FullRange),\n+                        &qualname[],\n+                        &enum_name[],\n+                        &val[],\n                         item.id);\n \n                     for field in struct_def.fields.iter() {\n@@ -643,7 +643,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             }\n         }\n \n-        self.process_generic_params(ty_params, item.span, enum_name.index(&FullRange), item.id);\n+        self.process_generic_params(ty_params, item.span, &enum_name[], item.id);\n     }\n \n     fn process_impl(&mut self,\n@@ -703,9 +703,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.trait_str(item.span,\n                            sub_span,\n                            item.id,\n-                           qualname.index(&FullRange),\n+                           &qualname[],\n                            self.cur_scope,\n-                           val.index(&FullRange));\n+                           &val[]);\n \n         // super-traits\n         for super_bound in trait_refs.iter() {\n@@ -737,7 +737,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         }\n \n         // walk generics and methods\n-        self.process_generic_params(generics, item.span, qualname.index(&FullRange), item.id);\n+        self.process_generic_params(generics, item.span, &qualname[], item.id);\n         for method in methods.iter() {\n             self.visit_trait_item(method)\n         }\n@@ -755,9 +755,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.mod_str(item.span,\n                          sub_span,\n                          item.id,\n-                         qualname.index(&FullRange),\n+                         &qualname[],\n                          self.cur_scope,\n-                         filename.index(&FullRange));\n+                         &filename[]);\n \n         self.nest(item.id, |v| visit::walk_mod(v, m));\n     }\n@@ -840,8 +840,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                           def_id,\n                                                           self.cur_scope),\n             _ => self.sess.span_bug(span,\n-                                    format!(\"Unexpected def kind while looking up path in '{}'\",\n-                                            self.span.snippet(span)).index(&FullRange)),\n+                                    &format!(\"Unexpected def kind while looking up path in '{}'\",\n+                                            self.span.snippet(span))[]),\n         }\n         // modules or types in the path prefix\n         match *def {\n@@ -959,7 +959,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                self.cur_scope);\n \n         // walk receiver and args\n-        visit::walk_exprs(self, args.index(&FullRange));\n+        visit::walk_exprs(self, &args[]);\n     }\n \n     fn process_pat(&mut self, p:&ast::Pat) {\n@@ -975,8 +975,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     Some(sd) => sd,\n                     None => {\n                         self.sess.span_bug(p.span,\n-                                           format!(\"Could not find struct_def for `{}`\",\n-                                                   self.span.snippet(p.span)).index(&FullRange));\n+                                           &format!(\"Could not find struct_def for `{}`\",\n+                                                   self.span.snippet(p.span))[]);\n                     }\n                 };\n                 for &Spanned { node: ref field, span } in fields.iter() {\n@@ -1061,8 +1061,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 self.fmt.typedef_str(item.span,\n                                      sub_span,\n                                      item.id,\n-                                     qualname.index(&FullRange),\n-                                     value.index(&FullRange));\n+                                     &qualname[],\n+                                     &value[]);\n \n                 self.visit_ty(&**ty);\n                 self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id);\n@@ -1121,13 +1121,13 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     },\n                     None => {\n                         self.sess.span_bug(method_type.span,\n-                                           format!(\"Could not find trait for method {}\",\n-                                                   method_type.id).index(&FullRange));\n+                                           &format!(\"Could not find trait for method {}\",\n+                                                   method_type.id)[]);\n                     },\n                 };\n \n                 qualname.push_str(get_ident(method_type.ident).get());\n-                let qualname = qualname.index(&FullRange);\n+                let qualname = &qualname[];\n \n                 let sub_span = self.span.sub_span_after_keyword(method_type.span, keywords::Fn);\n                 self.fmt.method_decl_str(method_type.span,\n@@ -1262,7 +1262,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                           id,\n                                           cnum,\n                                           name,\n-                                          s.index(&FullRange),\n+                                          &s[],\n                                           self.cur_scope);\n             },\n         }\n@@ -1371,8 +1371,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 }\n \n                 let mut id = String::from_str(\"$\");\n-                id.push_str(ex.id.to_string().index(&FullRange));\n-                self.process_formals(&decl.inputs, id.index(&FullRange));\n+                id.push_str(&ex.id.to_string()[]);\n+                self.process_formals(&decl.inputs, &id[]);\n \n                 // walk arg and return types\n                 for arg in decl.inputs.iter() {\n@@ -1418,8 +1418,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             let def_map = self.analysis.ty_cx.def_map.borrow();\n             if !def_map.contains_key(&id) {\n                 self.sess.span_bug(p.span,\n-                                   format!(\"def_map has no key for {} in visit_arm\",\n-                                           id).index(&FullRange));\n+                                   &format!(\"def_map has no key for {} in visit_arm\",\n+                                           id)[]);\n             }\n             let def = &(*def_map)[id];\n             match *def {\n@@ -1434,8 +1434,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     self.fmt.variable_str(p.span,\n                                           Some(p.span),\n                                           id,\n-                                          path_to_string(p).index(&FullRange),\n-                                          value.index(&FullRange),\n+                                          &path_to_string(p)[],\n+                                          &value[],\n                                           \"\")\n                 }\n                 def::DefVariant(..) => {\n@@ -1490,9 +1490,9 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             self.fmt.variable_str(p.span,\n                                   sub_span,\n                                   id,\n-                                  path_to_string(p).index(&FullRange),\n-                                  value.index(&FullRange),\n-                                  typ.index(&FullRange));\n+                                  &path_to_string(p)[],\n+                                  &value[],\n+                                  &typ[]);\n         }\n         self.collected_paths.clear();\n \n@@ -1511,7 +1511,7 @@ pub fn process_crate(sess: &Session,\n     }\n \n     assert!(analysis.glob_map.is_some());\n-    let cratename = match attr::find_crate_name(krate.attrs.index(&FullRange)) {\n+    let cratename = match attr::find_crate_name(&krate.attrs[]) {\n         Some(name) => name.get().to_string(),\n         None => {\n             info!(\"Could not find crate name, using 'unknown_crate'\");\n@@ -1531,8 +1531,8 @@ pub fn process_crate(sess: &Session,\n     };\n \n     match fs::mkdir_recursive(&root_path, io::USER_RWX) {\n-        Err(e) => sess.err(format!(\"Could not create directory {}: {}\",\n-                           root_path.display(), e).index(&FullRange)),\n+        Err(e) => sess.err(&format!(\"Could not create directory {}: {}\",\n+                           root_path.display(), e)[]),\n         _ => (),\n     }\n \n@@ -1549,7 +1549,7 @@ pub fn process_crate(sess: &Session,\n         Ok(f) => box f,\n         Err(e) => {\n             let disp = root_path.display();\n-            sess.fatal(format!(\"Could not open {}: {}\", disp, e).index(&FullRange));\n+            sess.fatal(&format!(\"Could not open {}: {}\", disp, e)[]);\n         }\n     };\n     root_path.pop();\n@@ -1575,7 +1575,7 @@ pub fn process_crate(sess: &Session,\n         cur_scope: 0\n     };\n \n-    visitor.dump_crate_info(cratename.index(&FullRange), krate);\n+    visitor.dump_crate_info(&cratename[], krate);\n \n     visit::walk_crate(&mut visitor, krate);\n }"}, {"sha": "23598751c08d73c724f0947d6bd0c312bc361723", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -41,7 +41,7 @@ impl Recorder {\n         assert!(self.dump_spans);\n         let result = format!(\"span,kind,{},{},text,\\\"{}\\\"\\n\",\n                              kind, su.extent_str(span), escape(su.snippet(span)));\n-        self.record(result.index(&FullRange));\n+        self.record(&result[]);\n     }\n }\n \n@@ -158,17 +158,17 @@ impl<'a> FmtStrs<'a> {\n                            values: Vec<String>,\n                            span: Span) -> Option<String> {\n         if values.len() != fields.len() {\n-            self.span.sess.span_bug(span, format!(\n+            self.span.sess.span_bug(span, &format!(\n                 \"Mismatch between length of fields for '{}', expected '{}', found '{}'\",\n-                kind, fields.len(), values.len()).index(&FullRange));\n+                kind, fields.len(), values.len())[]);\n         }\n \n         let values = values.iter().map(|s| {\n             // Never take more than 1020 chars\n             if s.len() > 1020 {\n-                s.index(&(0..1020))\n+                &s[0..1020]\n             } else {\n-                s.index(&FullRange)\n+                &s[]\n             }\n         });\n \n@@ -184,7 +184,7 @@ impl<'a> FmtStrs<'a> {\n             }\n         )));\n         Some(strs.fold(String::new(), |mut s, ss| {\n-            s.push_str(ss.index(&FullRange));\n+            s.push_str(&ss[]);\n             s\n         }))\n     }\n@@ -196,9 +196,9 @@ impl<'a> FmtStrs<'a> {\n         let (label, ref fields, needs_span, dump_spans) = FmtStrs::lookup_row(kind);\n \n         if needs_span {\n-            self.span.sess.span_bug(span, format!(\n+            self.span.sess.span_bug(span, &format!(\n                 \"Called record_without_span for '{}' which does requires a span\",\n-                label).index(&FullRange));\n+                label)[]);\n         }\n         assert!(!dump_spans);\n \n@@ -212,9 +212,9 @@ impl<'a> FmtStrs<'a> {\n         };\n \n         let mut result = String::from_str(label);\n-        result.push_str(values_str.index(&FullRange));\n+        result.push_str(&values_str[]);\n         result.push_str(\"\\n\");\n-        self.recorder.record(result.index(&FullRange));\n+        self.recorder.record(&result[]);\n     }\n \n     pub fn record_with_span(&mut self,\n@@ -245,7 +245,7 @@ impl<'a> FmtStrs<'a> {\n             None => return,\n         };\n         let result = format!(\"{},{}{}\\n\", label, self.span.extent_str(sub_span), values_str);\n-        self.recorder.record(result.index(&FullRange));\n+        self.recorder.record(&result[]);\n     }\n \n     pub fn check_and_record(&mut self,\n@@ -275,7 +275,7 @@ impl<'a> FmtStrs<'a> {\n         // variable def's node id\n         let mut qualname = String::from_str(name);\n         qualname.push_str(\"$\");\n-        qualname.push_str(id.to_string().index(&FullRange));\n+        qualname.push_str(&id.to_string()[]);\n         self.check_and_record(Variable,\n                               span,\n                               sub_span,"}, {"sha": "77343612ac88bd0010e3ee69eda2c8a0a536f517", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -217,8 +217,8 @@ impl<'a> SpanUtils<'a> {\n         if bracket_count != 0 {\n             let loc = self.sess.codemap().lookup_char_pos(span.lo);\n             self.sess.span_bug(span,\n-                format!(\"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n-                        self.snippet(span), loc.file.name, loc.line).index(&FullRange));\n+                &format!(\"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n+                        self.snippet(span), loc.file.name, loc.line)[]);\n         }\n         if result.is_none() && prev.tok.is_ident() && bracket_count == 0 {\n             return self.make_sub_span(span, Some(prev.sp));\n@@ -242,9 +242,9 @@ impl<'a> SpanUtils<'a> {\n             if ts.tok == token::Eof {\n                 if bracket_count != 0 {\n                     let loc = self.sess.codemap().lookup_char_pos(span.lo);\n-                    self.sess.span_bug(span, format!(\n+                    self.sess.span_bug(span, &format!(\n                         \"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n-                         self.snippet(span), loc.file.name, loc.line).index(&FullRange));\n+                         self.snippet(span), loc.file.name, loc.line)[]);\n                 }\n                 return result\n             }"}, {"sha": "fc19a582db2f5d070381891f816ee0bd699eb874", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -427,7 +427,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let _indenter = indenter();\n \n     m.iter().filter_map(|br| {\n-        e(br.pats.index(&FullRange)).map(|pats| {\n+        e(&br.pats[]).map(|pats| {\n             let this = br.pats[col];\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n@@ -471,8 +471,8 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Collect all of the matches that can match against anything.\n     enter_match(bcx, dm, m, col, val, |pats| {\n         if pat_is_binding_or_wild(dm, &*pats[col]) {\n-            let mut r = pats.index(&(0..col)).to_vec();\n-            r.push_all(pats.index(&((col + 1)..)));\n+            let mut r = pats[0..col].to_vec();\n+            r.push_all(&pats[(col + 1)..]);\n             Some(r)\n         } else {\n             None\n@@ -548,7 +548,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n         param_env: param_env,\n     };\n     enter_match(bcx, dm, m, col, val, |pats|\n-        check_match::specialize(&mcx, pats.index(&FullRange), &ctor, col, variant_size)\n+        check_match::specialize(&mcx, &pats[], &ctor, col, variant_size)\n     )\n }\n \n@@ -789,8 +789,8 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                -> Result<'blk, 'tcx> {\n         let did = langcall(cx,\n                            None,\n-                           format!(\"comparison of `{}`\",\n-                                   cx.ty_to_string(rhs_t)).index(&FullRange),\n+                           &format!(\"comparison of `{}`\",\n+                                   cx.ty_to_string(rhs_t))[],\n                            StrEqFnLangItem);\n         callee::trans_lang_call(cx, did, &[lhs, rhs], None)\n     }\n@@ -945,7 +945,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             if has_nested_bindings(m, col) {\n                 let expanded = expand_nested_bindings(bcx, m, col, val);\n                 compile_submatch_continue(bcx,\n-                                          expanded.index(&FullRange),\n+                                          &expanded[],\n                                           vals,\n                                           chk,\n                                           col,\n@@ -967,7 +967,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     bcx = compile_guard(bcx,\n                                         &**guard_expr,\n                                         m[0].data,\n-                                        m.index(&(1..m.len())),\n+                                        &m[1..m.len()],\n                                         vals,\n                                         chk,\n                                         has_genuine_default);\n@@ -990,8 +990,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n     let dm = &tcx.def_map;\n \n-    let mut vals_left = vals.index(&(0u..col)).to_vec();\n-    vals_left.push_all(vals.index(&((col + 1u)..)));\n+    let mut vals_left = vals[0u..col].to_vec();\n+    vals_left.push_all(&vals[(col + 1u)..]);\n     let ccx = bcx.fcx.ccx;\n \n     // Find a real id (we're adding placeholder wildcard patterns, but\n@@ -1191,10 +1191,10 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         let opt_ms = enter_opt(opt_cx, pat_id, dm, m, opt, col, size, val);\n         let mut opt_vals = unpacked;\n-        opt_vals.push_all(vals_left.index(&FullRange));\n+        opt_vals.push_all(&vals_left[]);\n         compile_submatch(opt_cx,\n-                         opt_ms.index(&FullRange),\n-                         opt_vals.index(&FullRange),\n+                         &opt_ms[],\n+                         &opt_vals[],\n                          branch_chk.as_ref().unwrap_or(chk),\n                          has_genuine_default);\n     }\n@@ -1213,8 +1213,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n             _ => {\n                 compile_submatch(else_cx,\n-                                 defaults.index(&FullRange),\n-                                 vals_left.index(&FullRange),\n+                                 &defaults[],\n+                                 &vals_left[],\n                                  chk,\n                                  has_genuine_default);\n             }\n@@ -1333,21 +1333,21 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n                                  \"__llmatch\");\n                 trmode = TrByCopy(alloca_no_lifetime(bcx,\n                                          llvariable_ty,\n-                                         bcx.ident(ident).index(&FullRange)));\n+                                         &bcx.ident(ident)[]));\n             }\n             ast::BindByValue(_) => {\n                 // in this case, the final type of the variable will be T,\n                 // but during matching we need to store a *T as explained\n                 // above\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty.ptr_to(),\n-                                 bcx.ident(ident).index(&FullRange));\n+                                 &bcx.ident(ident)[]);\n                 trmode = TrByMove;\n             }\n             ast::BindByRef(_) => {\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty,\n-                                 bcx.ident(ident).index(&FullRange));\n+                                 &bcx.ident(ident)[]);\n                 trmode = TrByRef;\n             }\n         };\n@@ -1415,7 +1415,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         && arm.pats.last().unwrap().node == ast::PatWild(ast::PatWildSingle)\n     });\n \n-    compile_submatch(bcx, matches.index(&FullRange), &[discr_datum.val], &chk, has_default);\n+    compile_submatch(bcx, &matches[], &[discr_datum.val], &chk, has_default);\n \n     let mut arm_cxs = Vec::new();\n     for arm_data in arm_datas.iter() {\n@@ -1429,7 +1429,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         arm_cxs.push(bcx);\n     }\n \n-    bcx = scope_cx.fcx.join_blocks(match_id, arm_cxs.index(&FullRange));\n+    bcx = scope_cx.fcx.join_blocks(match_id, &arm_cxs[]);\n     return bcx;\n }\n \n@@ -1582,7 +1582,7 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n     let var_ty = node_id_type(bcx, p_id);\n \n     // Allocate memory on stack for the binding.\n-    let llval = alloc_ty(bcx, var_ty, bcx.ident(*ident).index(&FullRange));\n+    let llval = alloc_ty(bcx, var_ty, &bcx.ident(*ident)[]);\n \n     // Subtle: be sure that we *populate* the memory *before*\n     // we schedule the cleanup.\n@@ -1619,8 +1619,8 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            pat.repr(bcx.tcx()));\n \n     if bcx.sess().asm_comments() {\n-        add_comment(bcx, format!(\"bind_irrefutable_pat(pat={})\",\n-                                 pat.repr(bcx.tcx())).index(&FullRange));\n+        add_comment(bcx, &format!(\"bind_irrefutable_pat(pat={})\",\n+                                 pat.repr(bcx.tcx()))[]);\n     }\n \n     let _indenter = indenter();"}, {"sha": "59b4643fdc5e43e8a50958dea3336424ef4d582c", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -154,7 +154,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      t: Ty<'tcx>) -> Repr<'tcx> {\n     match t.sty {\n         ty::ty_tup(ref elems) => {\n-            Univariant(mk_struct(cx, elems.index(&FullRange), false, t), false)\n+            Univariant(mk_struct(cx, &elems[], false, t), false)\n         }\n         ty::ty_struct(def_id, substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx(), def_id);\n@@ -165,17 +165,17 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n             if dtor { ftys.push(cx.tcx().types.bool); }\n \n-            Univariant(mk_struct(cx, ftys.index(&FullRange), packed, t), dtor)\n+            Univariant(mk_struct(cx, &ftys[], packed, t), dtor)\n         }\n         ty::ty_unboxed_closure(def_id, _, substs) => {\n             let typer = NormalizingUnboxedClosureTyper::new(cx.tcx());\n             let upvars = typer.unboxed_closure_upvars(def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n-            Univariant(mk_struct(cx, upvar_types.index(&FullRange), false, t), false)\n+            Univariant(mk_struct(cx, &upvar_types[], false, t), false)\n         }\n         ty::ty_enum(def_id, substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n-            let hint = *ty::lookup_repr_hints(cx.tcx(), def_id).index(&FullRange).get(0)\n+            let hint = *ty::lookup_repr_hints(cx.tcx(), def_id)[].get(0)\n                 .unwrap_or(&attr::ReprAny);\n \n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n@@ -185,7 +185,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n                 let ftys = if dtor { vec!(cx.tcx().types.bool) } else { vec!() };\n-                return Univariant(mk_struct(cx, ftys.index(&FullRange), false, t),\n+                return Univariant(mk_struct(cx, &ftys[], false, t),\n                                   dtor);\n             }\n \n@@ -205,10 +205,10 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // non-empty body, explicit discriminants should have\n             // been rejected by a checker before this point.\n             if !cases.iter().enumerate().all(|(i,c)| c.discr == (i as Disr)) {\n-                cx.sess().bug(format!(\"non-C-like enum {} with specified \\\n+                cx.sess().bug(&format!(\"non-C-like enum {} with specified \\\n                                       discriminants\",\n                                       ty::item_path_str(cx.tcx(),\n-                                                        def_id)).index(&FullRange));\n+                                                        def_id))[]);\n             }\n \n             if cases.len() == 1 {\n@@ -217,7 +217,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 assert_eq!(hint, attr::ReprAny);\n                 let mut ftys = cases[0].tys.clone();\n                 if dtor { ftys.push(cx.tcx().types.bool); }\n-                return Univariant(mk_struct(cx, ftys.index(&FullRange), false, t),\n+                return Univariant(mk_struct(cx, &ftys[], false, t),\n                                   dtor);\n             }\n \n@@ -226,7 +226,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let mut discr = 0;\n                 while discr < 2 {\n                     if cases[1 - discr].is_zerolen(cx, t) {\n-                        let st = mk_struct(cx, cases[discr].tys.index(&FullRange),\n+                        let st = mk_struct(cx, &cases[discr].tys[],\n                                            false, t);\n                         match cases[discr].find_ptr(cx) {\n                             Some(ref df) if df.len() == 1 && st.fields.len() == 1 => {\n@@ -316,17 +316,17 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(cx.tcx(), ity));\n-                ftys.push_all(c.tys.index(&FullRange));\n+                ftys.push_all(&c.tys[]);\n                 if dtor { ftys.push(cx.tcx().types.bool); }\n-                mk_struct(cx, ftys.index(&FullRange), false, t)\n+                mk_struct(cx, &ftys[], false, t)\n             }).collect();\n \n-            ensure_enum_fits_in_address_space(cx, ity, fields.index(&FullRange), t);\n+            ensure_enum_fits_in_address_space(cx, ity, &fields[], t);\n \n             General(ity, fields, dtor)\n         }\n-        _ => cx.sess().bug(format!(\"adt::represent_type called on non-ADT type: {}\",\n-                           ty_to_string(cx.tcx(), t)).index(&FullRange))\n+        _ => cx.sess().bug(&format!(\"adt::represent_type called on non-ADT type: {}\",\n+                           ty_to_string(cx.tcx(), t))[])\n     }\n }\n \n@@ -412,7 +412,7 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n impl<'tcx> Case<'tcx> {\n     fn is_zerolen<'a>(&self, cx: &CrateContext<'a, 'tcx>, scapegoat: Ty<'tcx>) -> bool {\n-        mk_struct(cx, self.tys.index(&FullRange), false, scapegoat).size == 0\n+        mk_struct(cx, &self.tys[], false, scapegoat).size == 0\n     }\n \n     fn find_ptr<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> Option<DiscrField> {\n@@ -451,9 +451,9 @@ fn mk_struct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n            .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     };\n \n-    ensure_struct_fits_in_address_space(cx, lltys.index(&FullRange), packed, scapegoat);\n+    ensure_struct_fits_in_address_space(cx, &lltys[], packed, scapegoat);\n \n-    let llty_rec = Type::struct_(cx, lltys.index(&FullRange), packed);\n+    let llty_rec = Type::struct_(cx, &lltys[], packed);\n     Struct {\n         size: machine::llsize_of_alloc(cx, llty_rec),\n         align: machine::llalign_of_min(cx, llty_rec),\n@@ -502,7 +502,7 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n             return ity;\n         }\n         attr::ReprExtern => {\n-            attempts = match cx.sess().target.target.arch.index(&FullRange) {\n+            attempts = match &cx.sess().target.target.arch[] {\n                 // WARNING: the ARM EABI has two variants; the one corresponding to `at_least_32`\n                 // appears to be used on Linux and NetBSD, but some systems may use the variant\n                 // corresponding to `choose_shortest`.  However, we don't run on those yet...?\n@@ -628,7 +628,7 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     match *r {\n         CEnum(..) | General(..) | RawNullablePointer { .. } => { }\n         Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } =>\n-            llty.set_struct_body(struct_llfields(cx, st, false, false).index(&FullRange),\n+            llty.set_struct_body(&struct_llfields(cx, st, false, false)[],\n                                  st.packed)\n     }\n }\n@@ -644,7 +644,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } => {\n             match name {\n                 None => {\n-                    Type::struct_(cx, struct_llfields(cx, st, sizing, dst).index(&FullRange),\n+                    Type::struct_(cx, &struct_llfields(cx, st, sizing, dst)[],\n                                   st.packed)\n                 }\n                 Some(name) => { assert_eq!(sizing, false); Type::named_struct(cx, name) }\n@@ -663,7 +663,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // of the size.\n             //\n             // FIXME #10604: this breaks when vector types are present.\n-            let (size, align) = union_size_and_align(sts.index(&FullRange));\n+            let (size, align) = union_size_and_align(&sts[]);\n             let align_s = align as u64;\n             let discr_ty = ll_inttype(cx, ity);\n             let discr_size = machine::llsize_of_alloc(cx, discr_ty);\n@@ -684,10 +684,10 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                           Type::array(&discr_ty, align_s / discr_size - 1),\n                           fill_ty];\n             match name {\n-                None => Type::struct_(cx, fields.index(&FullRange), false),\n+                None => Type::struct_(cx, &fields[], false),\n                 Some(name) => {\n                     let mut llty = Type::named_struct(cx, name);\n-                    llty.set_struct_body(fields.index(&FullRange), false);\n+                    llty.set_struct_body(&fields[], false);\n                     llty\n                 }\n             }\n@@ -765,7 +765,7 @@ pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n \n fn struct_wrapped_nullable_bitdiscr(bcx: Block, nndiscr: Disr, discrfield: &DiscrField,\n                                     scrutinee: ValueRef) -> ValueRef {\n-    let llptrptr = GEPi(bcx, scrutinee, discrfield.index(&FullRange));\n+    let llptrptr = GEPi(bcx, scrutinee, &discrfield[]);\n     let llptr = Load(bcx, llptrptr);\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     ICmp(bcx, cmp, llptr, C_null(val_ty(llptr)))\n@@ -853,7 +853,7 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n         }\n         StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n             if discr != nndiscr {\n-                let llptrptr = GEPi(bcx, val, discrfield.index(&FullRange));\n+                let llptrptr = GEPi(bcx, val, &discrfield[]);\n                 let llptrty = val_ty(llptrptr).element_type();\n                 Store(bcx, C_null(llptrty), llptrptr)\n             }\n@@ -935,7 +935,7 @@ pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, v\n     let val = if needs_cast {\n         let ccx = bcx.ccx();\n         let fields = st.fields.iter().map(|&ty| type_of::type_of(ccx, ty)).collect::<Vec<_>>();\n-        let real_ty = Type::struct_(ccx, fields.index(&FullRange), st.packed);\n+        let real_ty = Type::struct_(ccx, &fields[], st.packed);\n         PointerCast(bcx, val, real_ty.ptr_to())\n     } else {\n         val\n@@ -967,14 +967,14 @@ pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n             for (discr, case) in cases.iter().enumerate() {\n                 let mut variant_cx = fcx.new_temp_block(\n-                    format!(\"enum-variant-iter-{}\", discr.to_string()).index(&FullRange)\n+                    &format!(\"enum-variant-iter-{}\", &discr.to_string())[]\n                 );\n                 let rhs_val = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n                 AddCase(llswitch, rhs_val, variant_cx.llbb);\n \n                 let fields = case.fields.iter().map(|&ty|\n                     type_of::type_of(bcx.ccx(), ty)).collect::<Vec<_>>();\n-                let real_ty = Type::struct_(ccx, fields.index(&FullRange), case.packed);\n+                let real_ty = Type::struct_(ccx, &fields[], case.packed);\n                 let variant_value = PointerCast(variant_cx, value, real_ty.ptr_to());\n \n                 variant_cx = f(variant_cx, case, variant_value);\n@@ -1051,14 +1051,14 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n             let lldiscr = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n             let mut f = vec![lldiscr];\n             f.push_all(vals);\n-            let mut contents = build_const_struct(ccx, case, f.index(&FullRange));\n+            let mut contents = build_const_struct(ccx, case, &f[]);\n             contents.push_all(&[padding(ccx, max_sz - case.size)]);\n-            C_struct(ccx, contents.index(&FullRange), false)\n+            C_struct(ccx, &contents[], false)\n         }\n         Univariant(ref st, _dro) => {\n             assert!(discr == 0);\n             let contents = build_const_struct(ccx, st, vals);\n-            C_struct(ccx, contents.index(&FullRange), st.packed)\n+            C_struct(ccx, &contents[], st.packed)\n         }\n         RawNullablePointer { nndiscr, nnty, .. } => {\n             if discr == nndiscr {\n@@ -1070,19 +1070,19 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n         }\n         StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n             if discr == nndiscr {\n-                C_struct(ccx, build_const_struct(ccx,\n+                C_struct(ccx, &build_const_struct(ccx,\n                                                  nonnull,\n-                                                 vals).index(&FullRange),\n+                                                 vals)[],\n                          false)\n             } else {\n                 let vals = nonnull.fields.iter().map(|&ty| {\n                     // Always use null even if it's not the `discrfield`th\n                     // field; see #8506.\n                     C_null(type_of::sizing_type_of(ccx, ty))\n                 }).collect::<Vec<ValueRef>>();\n-                C_struct(ccx, build_const_struct(ccx,\n+                C_struct(ccx, &build_const_struct(ccx,\n                                                  nonnull,\n-                                                 vals.index(&FullRange)).index(&FullRange),\n+                                                 &vals[])[],\n                          false)\n             }\n         }"}, {"sha": "9b6fa32405ffb9c2247318779d675967f65a67a2", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -71,7 +71,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n                                     callee::DontAutorefArg)\n         })\n     }).collect::<Vec<_>>();\n-    inputs.push_all(ext_inputs.index(&FullRange));\n+    inputs.push_all(&ext_inputs[]);\n \n     // no failure occurred preparing operands, no need to cleanup\n     fcx.pop_custom_cleanup_scope(temp_scope);\n@@ -91,18 +91,18 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         if !clobbers.is_empty() {\n             clobbers.push(',');\n         }\n-        clobbers.push_str(more_clobbers.index(&FullRange));\n+        clobbers.push_str(&more_clobbers[]);\n     }\n \n     // Add the clobbers to our constraints list\n     if clobbers.len() != 0 && constraints.len() != 0 {\n         constraints.push(',');\n-        constraints.push_str(clobbers.index(&FullRange));\n+        constraints.push_str(&clobbers[]);\n     } else {\n-        constraints.push_str(clobbers.index(&FullRange));\n+        constraints.push_str(&clobbers[]);\n     }\n \n-    debug!(\"Asm Constraints: {}\", constraints.index(&FullRange));\n+    debug!(\"Asm Constraints: {}\", &constraints[]);\n \n     let num_outputs = outputs.len();\n \n@@ -112,7 +112,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     } else if num_outputs == 1 {\n         output_types[0]\n     } else {\n-        Type::struct_(bcx.ccx(), output_types.index(&FullRange), false)\n+        Type::struct_(bcx.ccx(), &output_types[], false)\n     };\n \n     let dialect = match ia.dialect {"}, {"sha": "78fe7861854dd351cfc548da43c849c9b708c638", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 60, "deletions": 61, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -249,7 +249,7 @@ fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>,\n     let f = decl_rust_fn(ccx, fn_ty, name);\n \n     csearch::get_item_attrs(&ccx.sess().cstore, did, |attrs| {\n-        set_llvm_fn_attrs(ccx, attrs.index(&FullRange), f)\n+        set_llvm_fn_attrs(ccx, &attrs[], f)\n     });\n \n     ccx.externs().borrow_mut().insert(name.to_string(), f);\n@@ -372,9 +372,9 @@ fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     match bcx.tcx().lang_items.require(it) {\n         Ok(id) => id,\n         Err(s) => {\n-            bcx.sess().fatal(format!(\"allocation of `{}` {}\",\n+            bcx.sess().fatal(&format!(\"allocation of `{}` {}\",\n                                      bcx.ty_to_string(info_ty),\n-                                     s).index(&FullRange));\n+                                     s)[]);\n         }\n     }\n }\n@@ -493,7 +493,7 @@ pub fn unset_split_stack(f: ValueRef) {\n // silently mangles such symbols, breaking our linkage model.\n pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: String) {\n     if ccx.all_llvm_symbols().borrow().contains(&sym) {\n-        ccx.sess().bug(format!(\"duplicate LLVM symbol: {}\", sym).index(&FullRange));\n+        ccx.sess().bug(&format!(\"duplicate LLVM symbol: {}\", sym)[]);\n     }\n     ccx.all_llvm_symbols().borrow_mut().insert(sym);\n }\n@@ -530,7 +530,7 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      ty::mk_nil(ccx.tcx()));\n         get_extern_fn(ccx,\n                       &mut *ccx.externs().borrow_mut(),\n-                      name.index(&FullRange),\n+                      &name[],\n                       llvm::CCallConv,\n                       llty,\n                       dtor_ty)\n@@ -778,9 +778,9 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                   for variant in (*variants).iter() {\n                       let variant_cx =\n                           fcx.new_temp_block(\n-                              format!(\"enum-iter-variant-{}\",\n-                                      variant.disr_val.to_string().index(&FullRange))\n-                                     .index(&FullRange));\n+                              &format!(\"enum-iter-variant-{}\",\n+                                      &variant.disr_val.to_string()[])\n+                              []);\n                       match adt::trans_case(cx, &*repr, variant.disr_val) {\n                           _match::SingleResult(r) => {\n                               AddCase(llswitch, r.val, variant_cx.llbb)\n@@ -804,8 +804,8 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n           }\n       }\n       _ => {\n-          cx.sess().unimpl(format!(\"type in iter_structural_ty: {}\",\n-                                   ty_to_string(cx.tcx(), t)).index(&FullRange))\n+          cx.sess().unimpl(&format!(\"type in iter_structural_ty: {}\",\n+                                   ty_to_string(cx.tcx(), t))[])\n       }\n     }\n     return cx;\n@@ -886,8 +886,8 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n             (ICmp(cx, llvm::IntEQ, rhs, zero), false)\n         }\n         _ => {\n-            cx.sess().bug(format!(\"fail-if-zero on unexpected type: {}\",\n-                                  ty_to_string(cx.tcx(), rhs_t)).index(&FullRange));\n+            cx.sess().bug(&format!(\"fail-if-zero on unexpected type: {}\",\n+                                  ty_to_string(cx.tcx(), rhs_t))[]);\n         }\n     };\n     let bcx = with_cond(cx, is_zero, |bcx| {\n@@ -941,14 +941,14 @@ pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::ty_bare_fn(_, ref fn_ty) => {\n             match ccx.sess().target.target.adjust_abi(fn_ty.abi) {\n                 Rust | RustCall => {\n-                    get_extern_rust_fn(ccx, t, name.index(&FullRange), did)\n+                    get_extern_rust_fn(ccx, t, &name[], did)\n                 }\n                 RustIntrinsic => {\n                     ccx.sess().bug(\"unexpected intrinsic in trans_external_path\")\n                 }\n                 _ => {\n                     foreign::register_foreign_item_fn(ccx, fn_ty.abi, t,\n-                                                      name.index(&FullRange))\n+                                                      &name[])\n                 }\n             }\n         }\n@@ -995,7 +995,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         let llresult = Invoke(bcx,\n                               llfn,\n-                              llargs.index(&FullRange),\n+                              &llargs[],\n                               normal_bcx.llbb,\n                               landing_pad,\n                               Some(attributes));\n@@ -1011,7 +1011,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             None => debuginfo::clear_source_location(bcx.fcx)\n         };\n \n-        let llresult = Call(bcx, llfn, llargs.index(&FullRange), Some(attributes));\n+        let llresult = Call(bcx, llfn, &llargs[], Some(attributes));\n         return (llresult, bcx);\n     }\n }\n@@ -1128,7 +1128,7 @@ pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n     let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n-    let key = match ccx.sess().target.target.target_pointer_width.index(&FullRange) {\n+    let key = match &ccx.sess().target.target.target_pointer_width[] {\n         \"32\" => \"llvm.memcpy.p0i8.p0i8.i32\",\n         \"64\" => \"llvm.memcpy.p0i8.p0i8.i64\",\n         tws => panic!(\"Unsupported target word size for memcpy: {}\", tws),\n@@ -1175,7 +1175,7 @@ fn memzero<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>) {\n \n     let llty = type_of::type_of(ccx, ty);\n \n-    let intrinsic_key = match ccx.sess().target.target.target_pointer_width.index(&FullRange) {\n+    let intrinsic_key = match &ccx.sess().target.target.target_pointer_width[] {\n         \"32\" => \"llvm.memset.p0i8.i32\",\n         \"64\" => \"llvm.memset.p0i8.i64\",\n         tws => panic!(\"Unsupported target word size for memset: {}\", tws),\n@@ -1663,7 +1663,7 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n                                                          \"argtuple\",\n                                                          arg_scope_id));\n     let untupled_arg_types = match monomorphized_arg_types[0].sty {\n-        ty::ty_tup(ref types) => types.index(&FullRange),\n+        ty::ty_tup(ref types) => &types[],\n         _ => {\n             bcx.tcx().sess.span_bug(args[0].pat.span,\n                                     \"first arg to `rust-call` ABI function \\\n@@ -1851,29 +1851,29 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let arg_datums = if abi != RustCall {\n         create_datums_for_fn_args(&fcx,\n-                                  monomorphized_arg_types.index(&FullRange))\n+                                  &monomorphized_arg_types[])\n     } else {\n         create_datums_for_fn_args_under_call_abi(\n             bcx,\n             arg_scope,\n-            monomorphized_arg_types.index(&FullRange))\n+            &monomorphized_arg_types[])\n     };\n \n     bcx = match closure_env.kind {\n         closure::NotClosure | closure::BoxedClosure(..) => {\n             copy_args_to_allocas(&fcx,\n                                  arg_scope,\n                                  bcx,\n-                                 decl.inputs.index(&FullRange),\n+                                 &decl.inputs[],\n                                  arg_datums)\n         }\n         closure::UnboxedClosure(..) => {\n             copy_unboxed_closure_args_to_allocas(\n                 bcx,\n                 arg_scope,\n-                decl.inputs.index(&FullRange),\n+                &decl.inputs[],\n                 arg_datums,\n-                monomorphized_arg_types.index(&FullRange))\n+                &monomorphized_arg_types[])\n         }\n     };\n \n@@ -1990,9 +1990,9 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             ty::erase_late_bound_regions(bcx.tcx(), &bft.sig.output()).unwrap()\n         }\n         _ => ccx.sess().bug(\n-            format!(\"trans_enum_variant_constructor: \\\n+            &format!(\"trans_enum_variant_constructor: \\\n                      unexpected ctor return type {}\",\n-                     ctor_ty.repr(tcx)).index(&FullRange))\n+                     ctor_ty.repr(tcx))[])\n     };\n \n     // Get location to store the result. If the user does not care about\n@@ -2015,7 +2015,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 bcx = expr::trans_adt(bcx,\n                                       result_ty,\n                                       disr,\n-                                      fields.index(&FullRange),\n+                                      &fields[],\n                                       None,\n                                       expr::SaveIn(llresult),\n                                       call_info);\n@@ -2064,9 +2064,9 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n             ty::erase_late_bound_regions(ccx.tcx(), &bft.sig.output())\n         }\n         _ => ccx.sess().bug(\n-            format!(\"trans_enum_variant_or_tuple_like_struct: \\\n+            &format!(\"trans_enum_variant_or_tuple_like_struct: \\\n                      unexpected ctor return type {}\",\n-                    ty_to_string(ccx.tcx(), ctor_ty)).index(&FullRange))\n+                    ty_to_string(ccx.tcx(), ctor_ty))[])\n     };\n \n     let arena = TypedArena::new();\n@@ -2080,7 +2080,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n         ty::erase_late_bound_regions(\n             ccx.tcx(), &ty::ty_fn_args(ctor_ty));\n \n-    let arg_datums = create_datums_for_fn_args(&fcx, arg_tys.index(&FullRange));\n+    let arg_datums = create_datums_for_fn_args(&fcx, &arg_tys[]);\n \n     if !type_is_zero_size(fcx.ccx, result_ty.unwrap()) {\n         let dest = fcx.get_ret_slot(bcx, result_ty, \"eret_slot\");\n@@ -2164,9 +2164,9 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n         // pass for the latter already ran.\n         lint::raw_emit_lint(&ccx.tcx().sess, lint::builtin::VARIANT_SIZE_DIFFERENCES,\n                             *lvlsrc.unwrap(), Some(sp),\n-                            format!(\"enum variant is more than three times larger \\\n+                            &format!(\"enum variant is more than three times larger \\\n                                      ({} bytes) than the next largest (ignoring padding)\",\n-                                    largest).index(&FullRange));\n+                                    largest)[]);\n \n         ccx.sess().span_note(enum_def.variants[largest_index].span,\n                              \"this variant is the largest\");\n@@ -2284,7 +2284,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n     match item.node {\n       ast::ItemFn(ref decl, _fn_style, abi, ref generics, ref body) => {\n         if !generics.is_type_parameterized() {\n-            let trans_everywhere = attr::requests_inline(item.attrs.index(&FullRange));\n+            let trans_everywhere = attr::requests_inline(&item.attrs[]);\n             // Ignore `trans_everywhere` for cross-crate inlined items\n             // (`from_external`).  `trans_item` will be called once for each\n             // compilation unit that references the item, so it will still get\n@@ -2295,7 +2295,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                     foreign::trans_rust_fn_with_foreign_abi(ccx,\n                                                             &**decl,\n                                                             &**body,\n-                                                            item.attrs.index(&FullRange),\n+                                                            &item.attrs[],\n                                                             llfn,\n                                                             &Substs::trans_empty(),\n                                                             item.id,\n@@ -2307,7 +2307,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                              llfn,\n                              &Substs::trans_empty(),\n                              item.id,\n-                             item.attrs.index(&FullRange));\n+                             &item.attrs[]);\n                 }\n                 update_linkage(ccx,\n                                llfn,\n@@ -2324,7 +2324,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n       ast::ItemImpl(_, _, ref generics, _, _, ref impl_items) => {\n         meth::trans_impl(ccx,\n                          item.ident,\n-                         impl_items.index(&FullRange),\n+                         &impl_items[],\n                          generics,\n                          item.id);\n       }\n@@ -2354,7 +2354,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n \n           // Do static_assert checking. It can't really be done much earlier\n           // because we need to get the value of the bool out of LLVM\n-          if attr::contains_name(item.attrs.index(&FullRange), \"static_assert\") {\n+          if attr::contains_name(&item.attrs[], \"static_assert\") {\n               if m == ast::MutMutable {\n                   ccx.sess().span_fatal(expr.span,\n                                         \"cannot have static_assert on a mutable \\\n@@ -2431,7 +2431,7 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         _ => panic!(\"expected bare rust fn\")\n     };\n \n-    let llfn = decl_rust_fn(ccx, node_type, sym.index(&FullRange));\n+    let llfn = decl_rust_fn(ccx, node_type, &sym[]);\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n@@ -2476,7 +2476,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n \n             match fn_sig.inputs[1].sty {\n                 ty::ty_tup(ref t_in) => {\n-                    inputs.push_all(t_in.index(&FullRange));\n+                    inputs.push_all(&t_in[]);\n                     inputs\n                 }\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n@@ -2612,7 +2612,7 @@ pub fn register_fn_llvmty(ccx: &CrateContext,\n     debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n \n     let llfn = decl_fn(ccx,\n-                       sym.index(&FullRange),\n+                       &sym[],\n                        cc,\n                        llfty,\n                        ty::FnConverging(ty::mk_nil(ccx.tcx())));\n@@ -2668,7 +2668,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n             let (start_fn, args) = if use_start_lang_item {\n                 let start_def_id = match ccx.tcx().lang_items.require(StartFnLangItem) {\n                     Ok(id) => id,\n-                    Err(s) => { ccx.sess().fatal(s.index(&FullRange)); }\n+                    Err(s) => { ccx.sess().fatal(&s[]); }\n                 };\n                 let start_fn = if start_def_id.krate == ast::LOCAL_CRATE {\n                     get_item_val(ccx, start_def_id.node)\n@@ -2760,7 +2760,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     let val = match item {\n         ast_map::NodeItem(i) => {\n             let ty = ty::node_id_to_type(ccx.tcx(), i.id);\n-            let sym = |&:| exported_name(ccx, id, ty, i.attrs.index(&FullRange));\n+            let sym = |&:| exported_name(ccx, id, ty, &i.attrs[]);\n \n             let v = match i.node {\n                 ast::ItemStatic(_, _, ref expr) => {\n@@ -2783,16 +2783,16 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                         } else {\n                             llvm::LLVMTypeOf(v)\n                         };\n-                        if contains_null(sym.index(&FullRange)) {\n+                        if contains_null(&sym[]) {\n                             ccx.sess().fatal(\n-                                format!(\"Illegal null byte in export_name \\\n-                                         value: `{}`\", sym).index(&FullRange));\n+                                &format!(\"Illegal null byte in export_name \\\n+                                         value: `{}`\", sym)[]);\n                         }\n                         let buf = CString::from_slice(sym.as_bytes());\n                         let g = llvm::LLVMAddGlobal(ccx.llmod(), llty,\n                                                     buf.as_ptr());\n \n-                        if attr::contains_name(i.attrs.index(&FullRange),\n+                        if attr::contains_name(&i.attrs[],\n                                                \"thread_local\") {\n                             llvm::set_thread_local(g, true);\n                         }\n@@ -2817,19 +2817,19 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                                                    sym,\n                                                                    i.id)\n                     };\n-                    set_llvm_fn_attrs(ccx, i.attrs.index(&FullRange), llfn);\n+                    set_llvm_fn_attrs(ccx, &i.attrs[], llfn);\n                     llfn\n                 }\n \n                 _ => panic!(\"get_item_val: weird result in table\")\n             };\n \n-            match attr::first_attr_value_str_by_name(i.attrs.index(&FullRange),\n+            match attr::first_attr_value_str_by_name(&i.attrs[],\n                                                      \"link_section\") {\n                 Some(sect) => {\n                     if contains_null(sect.get()) {\n-                        ccx.sess().fatal(format!(\"Illegal null byte in link_section value: `{}`\",\n-                                                 sect.get()).index(&FullRange));\n+                        ccx.sess().fatal(&format!(\"Illegal null byte in link_section value: `{}`\",\n+                                                 sect.get())[]);\n                     }\n                     unsafe {\n                         let buf = CString::from_slice(sect.get().as_bytes());\n@@ -2872,7 +2872,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     let abi = ccx.tcx().map.get_foreign_abi(id);\n                     let ty = ty::node_id_to_type(ccx.tcx(), ni.id);\n                     let name = foreign::link_name(&*ni);\n-                    foreign::register_foreign_item_fn(ccx, abi, ty, name.get().index(&FullRange))\n+                    foreign::register_foreign_item_fn(ccx, abi, ty, &name.get()[])\n                 }\n                 ast::ForeignItemStatic(..) => {\n                     foreign::register_static(ccx, &*ni)\n@@ -2895,7 +2895,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let sym = exported_name(ccx,\n                                     id,\n                                     ty,\n-                                    enm.attrs.index(&FullRange));\n+                                    &enm.attrs[]);\n \n             llfn = match enm.node {\n                 ast::ItemEnum(_, _) => {\n@@ -2922,17 +2922,16 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let sym = exported_name(ccx,\n                                     id,\n                                     ty,\n-                                    struct_item.attrs\n-                                               .index(&FullRange));\n+                                    &struct_item.attrs[]);\n             let llfn = register_fn(ccx, struct_item.span,\n                                    sym, ctor_id, ty);\n             set_inline_hint(llfn);\n             llfn\n         }\n \n         ref variant => {\n-            ccx.sess().bug(format!(\"get_item_val(): unexpected variant: {:?}\",\n-                                   variant).index(&FullRange))\n+            ccx.sess().bug(&format!(\"get_item_val(): unexpected variant: {:?}\",\n+                                   variant)[])\n         }\n     };\n \n@@ -2953,10 +2952,10 @@ fn register_method(ccx: &CrateContext, id: ast::NodeId,\n                    m: &ast::Method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx(), id);\n \n-    let sym = exported_name(ccx, id, mty, m.attrs.index(&FullRange));\n+    let sym = exported_name(ccx, id, mty, &m.attrs[]);\n \n     let llfn = register_fn(ccx, m.span, sym, id, mty);\n-    set_llvm_fn_attrs(ccx, m.attrs.index(&FullRange), llfn);\n+    set_llvm_fn_attrs(ccx, &m.attrs[], llfn);\n     llfn\n }\n \n@@ -2995,7 +2994,7 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n         Some(compressed) => compressed,\n         None => cx.sess().fatal(\"failed to compress metadata\"),\n     }.as_slice());\n-    let llmeta = C_bytes_in_context(cx.metadata_llcx(), compressed.index(&FullRange));\n+    let llmeta = C_bytes_in_context(cx.metadata_llcx(), &compressed[]);\n     let llconst = C_struct_in_context(cx.metadata_llcx(), &[llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}\",\n                        cx.link_meta().crate_name,\n@@ -3124,7 +3123,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n     let link_meta = link::build_link_meta(&tcx.sess, krate, name);\n \n     let codegen_units = tcx.sess.opts.cg.codegen_units;\n-    let shared_ccx = SharedCrateContext::new(link_meta.crate_name.index(&FullRange),\n+    let shared_ccx = SharedCrateContext::new(&link_meta.crate_name[],\n                                              codegen_units,\n                                              tcx,\n                                              export_map,\n@@ -3226,7 +3225,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n         llmod: shared_ccx.metadata_llmod(),\n     };\n     let formats = shared_ccx.tcx().dependency_formats.borrow().clone();\n-    let no_builtins = attr::contains_name(krate.attrs.index(&FullRange), \"no_builtins\");\n+    let no_builtins = attr::contains_name(&krate.attrs[], \"no_builtins\");\n \n     let translation = CrateTranslation {\n         modules: modules,"}, {"sha": "b80088e4690c966024257b8584535db71a0ad824", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -552,11 +552,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             for (small_vec_e, &ix) in small_vec.iter_mut().zip(ixs.iter()) {\n                 *small_vec_e = C_i32(self.ccx, ix as i32);\n             }\n-            self.inbounds_gep(base, small_vec.index(&(0..ixs.len())))\n+            self.inbounds_gep(base, &small_vec[0..ixs.len()])\n         } else {\n             let v = ixs.iter().map(|i| C_i32(self.ccx, *i as i32)).collect::<Vec<ValueRef>>();\n             self.count_insn(\"gepi\");\n-            self.inbounds_gep(base, v.index(&FullRange))\n+            self.inbounds_gep(base, &v[])\n         }\n     }\n \n@@ -764,8 +764,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let s = format!(\"{} ({})\",\n                             text,\n                             self.ccx.sess().codemap().span_to_string(sp));\n-            debug!(\"{}\", s.index(&FullRange));\n-            self.add_comment(s.index(&FullRange));\n+            debug!(\"{}\", &s[]);\n+            self.add_comment(&s[]);\n         }\n     }\n \n@@ -802,7 +802,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }).collect::<Vec<_>>();\n \n         debug!(\"Asm Output Type: {}\", self.ccx.tn().type_to_string(output));\n-        let fty = Type::func(argtys.index(&FullRange), &output);\n+        let fty = Type::func(&argtys[], &output);\n         unsafe {\n             let v = llvm::LLVMInlineAsm(\n                 fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);"}, {"sha": "8a2a2534cabd2c51a7cbcc2cf4063412ca81d119", "filename": "src/librustc_trans/trans/cabi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -108,7 +108,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n-    match ccx.sess().target.target.arch.index(&FullRange) {\n+    match &ccx.sess().target.target.arch[] {\n         \"x86\" => cabi_x86::compute_abi_info(ccx, atys, rty, ret_def),\n         \"x86_64\" => if ccx.sess().target.target.options.is_like_windows {\n             cabi_x86_win64::compute_abi_info(ccx, atys, rty, ret_def)\n@@ -118,7 +118,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n         \"arm\" => cabi_arm::compute_abi_info(ccx, atys, rty, ret_def),\n         \"aarch64\" => cabi_aarch64::compute_abi_info(ccx, atys, rty, ret_def),\n         \"mips\" => cabi_mips::compute_abi_info(ccx, atys, rty, ret_def),\n-        a => ccx.sess().fatal((format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n-                              .index(&FullRange)),\n+        a => ccx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a)\n+                              []),\n     }\n }"}, {"sha": "86190b1e56639f708253b4c803ab49414a67626a", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -318,7 +318,7 @@ fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n                 tys.push(Type::i64(ccx));\n             }\n             SSEFv => {\n-                let vec_len = llvec_len(cls.index(&((i + 1u)..)));\n+                let vec_len = llvec_len(&cls[(i + 1u)..]);\n                 let vec_ty = Type::vector(&Type::f32(ccx), (vec_len * 2u) as u64);\n                 tys.push(vec_ty);\n                 i += vec_len;"}, {"sha": "274c3e0a50ae3405ac1169c4b7b379e573949ae5", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -112,9 +112,9 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n             _ => {\n                 bcx.tcx().sess.span_bug(\n                     expr.span,\n-                    format!(\"type of callee is neither bare-fn nor closure: \\\n+                    &format!(\"type of callee is neither bare-fn nor closure: \\\n                              {}\",\n-                            bcx.ty_to_string(datum.ty)).index(&FullRange));\n+                            bcx.ty_to_string(datum.ty))[]);\n             }\n         }\n     }\n@@ -206,8 +206,8 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n             def::DefSelfTy(..) | def::DefAssociatedPath(..) => {\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n-                    format!(\"cannot translate def {:?} \\\n-                             to a callable thing!\", def).index(&FullRange));\n+                    &format!(\"cannot translate def {:?} \\\n+                             to a callable thing!\", def)[]);\n             }\n         }\n     }\n@@ -289,8 +289,8 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n             }\n \n             _ => {\n-                tcx.sess.bug(format!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n-                                           bare_fn_ty.repr(tcx)).index(&FullRange));\n+                tcx.sess.bug(&format!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n+                                           bare_fn_ty.repr(tcx))[]);\n             }\n         };\n     let sig = ty::erase_late_bound_regions(tcx, sig);\n@@ -315,7 +315,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let llfn =\n         decl_internal_rust_fn(ccx,\n                               tuple_fn_ty,\n-                              function_name.index(&FullRange));\n+                              &function_name[]);\n \n     //\n     let block_arena = TypedArena::new();\n@@ -350,7 +350,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                            None,\n                            bare_fn_ty,\n                            |bcx, _| Callee { bcx: bcx, data: Fn(llfnpointer) },\n-                           ArgVals(llargs.index(&FullRange)),\n+                           ArgVals(&llargs[]),\n                            dest).bcx;\n \n     finish_fn(&fcx, bcx, sig.output);\n@@ -776,7 +776,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         // Invoke the actual rust fn and update bcx/llresult.\n         let (llret, b) = base::invoke(bcx,\n                                       llfn,\n-                                      llargs.index(&FullRange),\n+                                      &llargs[],\n                                       callee_ty,\n                                       call_info);\n         bcx = b;\n@@ -815,7 +815,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n         bcx = foreign::trans_native_call(bcx, callee_ty,\n                                          llfn, opt_llretslot.unwrap(),\n-                                         llargs.index(&FullRange), arg_tys);\n+                                         &llargs[], arg_tys);\n     }\n \n     fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_cleanup_scope);"}, {"sha": "5658889aaf36856c4ee28d457997c6d33fd4aacb", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -403,8 +403,8 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         }\n \n         self.ccx.sess().bug(\n-            format!(\"no cleanup scope {} found\",\n-                    self.ccx.tcx().map.node_to_string(cleanup_scope)).index(&FullRange));\n+            &format!(\"no cleanup scope {} found\",\n+                    self.ccx.tcx().map.node_to_string(cleanup_scope))[]);\n     }\n \n     /// Schedules a cleanup to occur in the top-most scope, which must be a temporary scope.\n@@ -584,9 +584,9 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                     }\n \n                     LoopExit(id, _) => {\n-                        self.ccx.sess().bug(format!(\n+                        self.ccx.sess().bug(&format!(\n                                 \"cannot exit from scope {}, \\\n-                                not in scope\", id).index(&FullRange));\n+                                not in scope\", id)[]);\n                     }\n                 }\n             }\n@@ -655,7 +655,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 let name = scope.block_name(\"clean\");\n                 debug!(\"generating cleanups for {}\", name);\n                 let bcx_in = self.new_block(label.is_unwind(),\n-                                            name.index(&FullRange),\n+                                            &name[],\n                                             None);\n                 let mut bcx_out = bcx_in;\n                 for cleanup in scope.cleanups.iter().rev() {\n@@ -702,7 +702,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 Some(llbb) => { return llbb; }\n                 None => {\n                     let name = last_scope.block_name(\"unwind\");\n-                    pad_bcx = self.new_block(true, name.index(&FullRange), None);\n+                    pad_bcx = self.new_block(true, &name[], None);\n                     last_scope.cached_landing_pad = Some(pad_bcx.llbb);\n                 }\n             }\n@@ -1022,8 +1022,8 @@ pub fn temporary_scope(tcx: &ty::ctxt,\n             r\n         }\n         None => {\n-            tcx.sess.bug(format!(\"no temporary scope available for expr {}\",\n-                                 id).index(&FullRange))\n+            tcx.sess.bug(&format!(\"no temporary scope available for expr {}\",\n+                                 id)[])\n         }\n     }\n }"}, {"sha": "76f82c14e0a8a5b6f8dacd5daf5ffeed2c1873e6", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -154,7 +154,7 @@ pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let tcx = ccx.tcx();\n \n     // compute the type of the closure\n-    let cdata_ty = mk_closure_tys(tcx, bound_values.index(&FullRange));\n+    let cdata_ty = mk_closure_tys(tcx, &bound_values[]);\n \n     // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n     // tuple.  This could be a ptr in uniq or a box or on stack,\n@@ -182,8 +182,8 @@ pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         debug!(\"Copy {} into closure\", bv.to_string(ccx));\n \n         if ccx.sess().asm_comments() {\n-            add_comment(bcx, format!(\"Copy {} into closure\",\n-                                     bv.to_string(ccx)).index(&FullRange));\n+            add_comment(bcx, &format!(\"Copy {} into closure\",\n+                                     bv.to_string(ccx))[]);\n         }\n \n         let bound_data = GEPi(bcx, llbox, &[0u, abi::BOX_FIELD_BODY, i]);\n@@ -420,7 +420,7 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let s = tcx.map.with_path(id, |path| {\n         mangle_internal_name_by_path_and_seq(path, \"closure\")\n     });\n-    let llfn = decl_internal_rust_fn(ccx, fty, s.index(&FullRange));\n+    let llfn = decl_internal_rust_fn(ccx, fty, &s[]);\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n@@ -444,7 +444,7 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                   &[],\n                   ty::erase_late_bound_regions(ccx.tcx(), &ty::ty_fn_ret(fty)),\n                   ty::ty_fn_abi(fty),\n-                  ClosureEnv::new(freevars.index(&FullRange),\n+                  ClosureEnv::new(&freevars[],\n                                   BoxedClosure(cdata_ty, store)));\n     fill_fn_pair(bcx, dest_addr, llfn, llbox);\n     bcx\n@@ -489,7 +489,7 @@ pub fn get_or_create_declaration_if_unboxed_closure<'a, 'tcx>(ccx: &CrateContext\n         mangle_internal_name_by_path_and_seq(path, \"unboxed_closure\")\n     });\n \n-    let llfn = decl_internal_rust_fn(ccx, function_type, symbol.index(&FullRange));\n+    let llfn = decl_internal_rust_fn(ccx, function_type, &symbol[]);\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n@@ -544,7 +544,7 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n                   &[],\n                   sig.output,\n                   function_type.abi,\n-                  ClosureEnv::new(freevars.index(&FullRange),\n+                  ClosureEnv::new(&freevars[],\n                                   UnboxedClosure(freevar_mode)));\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate"}, {"sha": "9b65259ad516c9e1c2f9857ea4e0d9f853f02a93", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -273,7 +273,7 @@ pub fn gensym_name(name: &str) -> PathElem {\n let num = token::gensym(name).uint();\n // use one colon which will get translated to a period by the mangler, and\n // we're guaranteed that `num` is globally unique for this crate.\n-PathName(token::gensym(format!(\"{}:{}\", name, num).index(&FullRange)))\n+PathName(token::gensym(&format!(\"{}:{}\", name, num)[]))\n }\n \n #[derive(Copy)]\n@@ -600,8 +600,8 @@ pub fn def(&self, nid: ast::NodeId) -> def::Def {\n     match self.tcx().def_map.borrow().get(&nid) {\n         Some(v) => v.clone(),\n         None => {\n-            self.tcx().sess.bug(format!(\n-                \"no def associated with node id {}\", nid).index(&FullRange));\n+            self.tcx().sess.bug(&format!(\n+                \"no def associated with node id {}\", nid)[]);\n         }\n     }\n }\n@@ -1029,9 +1029,9 @@ let selection = match selcx.select(&obligation) {\n     Err(e) => {\n         tcx.sess.span_bug(\n             span,\n-            format!(\"Encountered error `{}` selecting `{}` during trans\",\n+            &format!(\"Encountered error `{}` selecting `{}` during trans\",\n                     e.repr(tcx),\n-                    trait_ref.repr(tcx)).index(&FullRange))\n+                    trait_ref.repr(tcx))[])\n     }\n };\n \n@@ -1123,8 +1123,8 @@ match fulfill_cx.select_all_or_error(infcx, &typer) {\n         } else {\n             infcx.tcx.sess.span_bug(\n                 span,\n-                format!(\"Encountered errors `{}` fulfilling during trans\",\n-                        errors.repr(infcx.tcx)).index(&FullRange));\n+                &format!(\"Encountered errors `{}` fulfilling during trans\",\n+                        errors.repr(infcx.tcx))[]);\n         }\n     }\n }\n@@ -1163,8 +1163,8 @@ let substs = match node {\n };\n \n if substs.types.any(|t| ty::type_needs_infer(*t)) {\n-        tcx.sess.bug(format!(\"type parameters for node {:?} include inference types: {:?}\",\n-                             node, substs.repr(tcx)).index(&FullRange));\n+        tcx.sess.bug(&format!(\"type parameters for node {:?} include inference types: {:?}\",\n+                             node, substs.repr(tcx))[]);\n     }\n \n     monomorphize::apply_param_substs(tcx,\n@@ -1182,8 +1182,8 @@ pub fn langcall(bcx: Block,\n         Err(s) => {\n             let msg = format!(\"{} {}\", msg, s);\n             match span {\n-                Some(span) => bcx.tcx().sess.span_fatal(span, msg.index(&FullRange)),\n-                None => bcx.tcx().sess.fatal(msg.index(&FullRange)),\n+                Some(span) => bcx.tcx().sess.span_fatal(span, &msg[]),\n+                None => bcx.tcx().sess.fatal(&msg[]),\n             }\n         }\n     }"}, {"sha": "00b97286de36780519e0471448cce156cb580991", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -52,9 +52,9 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n                     C_integral(Type::uint_from_ty(cx, t), i as u64, false)\n                 }\n                 _ => cx.sess().span_bug(lit.span,\n-                        format!(\"integer literal has type {} (expected int \\\n+                        &format!(\"integer literal has type {} (expected int \\\n                                  or uint)\",\n-                                ty_to_string(cx.tcx(), lit_int_ty)).index(&FullRange))\n+                                ty_to_string(cx.tcx(), lit_int_ty))[])\n             }\n         }\n         ast::LitFloat(ref fs, t) => {\n@@ -74,7 +74,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n         }\n         ast::LitBool(b) => C_bool(cx, b),\n         ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n-        ast::LitBinary(ref data) => C_binary_slice(cx, data.index(&FullRange)),\n+        ast::LitBinary(ref data) => C_binary_slice(cx, &data[]),\n     }\n }\n \n@@ -93,9 +93,9 @@ fn const_vec(cx: &CrateContext, e: &ast::Expr,\n                       .collect::<Vec<_>>();\n     // If the vector contains enums, an LLVM array won't work.\n     let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-        C_struct(cx, vs.index(&FullRange), false)\n+        C_struct(cx, &vs[], false)\n     } else {\n-        C_array(llunitty, vs.index(&FullRange))\n+        C_array(llunitty, &vs[])\n     };\n     (v, llunitty)\n }\n@@ -148,14 +148,14 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, v: ValueRef,\n                     (const_deref_newtype(cx, v, t), mt.ty)\n                 }\n                 _ => {\n-                    cx.sess().bug(format!(\"unexpected dereferenceable type {}\",\n-                                          ty_to_string(cx.tcx(), t)).index(&FullRange))\n+                    cx.sess().bug(&format!(\"unexpected dereferenceable type {}\",\n+                                          ty_to_string(cx.tcx(), t))[])\n                 }\n             }\n         }\n         None => {\n-            cx.sess().bug(format!(\"cannot dereference const of type {}\",\n-                                  ty_to_string(cx.tcx(), t)).index(&FullRange))\n+            cx.sess().bug(&format!(\"cannot dereference const of type {}\",\n+                                  ty_to_string(cx.tcx(), t))[])\n         }\n     }\n }\n@@ -251,16 +251,16 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n                                             ], false);\n                                         }\n                                         _ => cx.sess().span_bug(e.span,\n-                                            format!(\"unimplemented type in const unsize: {}\",\n-                                                    ty_to_string(cx.tcx(), ty)).index(&FullRange))\n+                                            &format!(\"unimplemented type in const unsize: {}\",\n+                                                    ty_to_string(cx.tcx(), ty))[])\n                                     }\n                                 }\n                                 _ => {\n                                     cx.sess()\n                                       .span_bug(e.span,\n-                                                format!(\"unimplemented const \\\n+                                                &format!(\"unimplemented const \\\n                                                          autoref {:?}\",\n-                                                        autoref).index(&FullRange))\n+                                                        autoref)[])\n                                 }\n                             }\n                         }\n@@ -279,9 +279,9 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n             llvm::LLVMDumpValue(llconst);\n             llvm::LLVMDumpValue(C_undef(llty));\n         }\n-        cx.sess().bug(format!(\"const {} of type {} has size {} instead of {}\",\n+        cx.sess().bug(&format!(\"const {} of type {} has size {} instead of {}\",\n                          e.repr(cx.tcx()), ty_to_string(cx.tcx(), ety),\n-                         csize, tsize).index(&FullRange));\n+                         csize, tsize)[]);\n     }\n     (llconst, ety_adjusted)\n }\n@@ -429,23 +429,23 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                           (const_deref_ptr(cx, e1), const_get_elt(cx, bv, &[1]))\n                       },\n                       _ => cx.sess().span_bug(base.span,\n-                                              format!(\"index-expr base must be a vector \\\n+                                              &format!(\"index-expr base must be a vector \\\n                                                        or string type, found {}\",\n-                                                      ty_to_string(cx.tcx(), bt)).index(&FullRange))\n+                                                      ty_to_string(cx.tcx(), bt))[])\n                   },\n                   ty::ty_rptr(_, mt) => match mt.ty.sty {\n                       ty::ty_vec(_, Some(u)) => {\n                           (const_deref_ptr(cx, bv), C_uint(cx, u))\n                       },\n                       _ => cx.sess().span_bug(base.span,\n-                                              format!(\"index-expr base must be a vector \\\n+                                              &format!(\"index-expr base must be a vector \\\n                                                        or string type, found {}\",\n-                                                      ty_to_string(cx.tcx(), bt)).index(&FullRange))\n+                                                      ty_to_string(cx.tcx(), bt))[])\n                   },\n                   _ => cx.sess().span_bug(base.span,\n-                                          format!(\"index-expr base must be a vector \\\n+                                          &format!(\"index-expr base must be a vector \\\n                                                    or string type, found {}\",\n-                                                  ty_to_string(cx.tcx(), bt)).index(&FullRange))\n+                                                  ty_to_string(cx.tcx(), bt))[])\n               };\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n@@ -546,8 +546,8 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n           ast::ExprTup(ref es) => {\n               let ety = ty::expr_ty(cx.tcx(), e);\n               let repr = adt::represent_type(cx, ety);\n-              let vals = map_list(es.index(&FullRange));\n-              adt::trans_const(cx, &*repr, 0, vals.index(&FullRange))\n+              let vals = map_list(&es[]);\n+              adt::trans_const(cx, &*repr, 0, &vals[])\n           }\n           ast::ExprStruct(_, ref fs, ref base_opt) => {\n               let ety = ty::expr_ty(cx.tcx(), e);\n@@ -578,7 +578,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                           }\n                       }\n                   }).collect::<Vec<_>>();\n-                  adt::trans_const(cx, &*repr, discr, cs.index(&FullRange))\n+                  adt::trans_const(cx, &*repr, discr, &cs[])\n               })\n           }\n           ast::ExprVec(ref es) => {\n@@ -595,9 +595,9 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n             };\n             let vs: Vec<_> = repeat(const_expr(cx, &**elem).0).take(n).collect();\n             if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-                C_struct(cx, vs.index(&FullRange), false)\n+                C_struct(cx, &vs[], false)\n             } else {\n-                C_array(llunitty, vs.index(&FullRange))\n+                C_array(llunitty, &vs[])\n             }\n           }\n           ast::ExprPath(_) => {\n@@ -645,20 +645,20 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                   Some(def::DefStruct(_)) => {\n                       let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n-                      let arg_vals = map_list(args.index(&FullRange));\n-                      adt::trans_const(cx, &*repr, 0, arg_vals.index(&FullRange))\n+                      let arg_vals = map_list(&args[]);\n+                      adt::trans_const(cx, &*repr, 0, &arg_vals[])\n                   }\n                   Some(def::DefVariant(enum_did, variant_did, _)) => {\n                       let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n                       let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                            enum_did,\n                                                            variant_did);\n-                      let arg_vals = map_list(args.index(&FullRange));\n+                      let arg_vals = map_list(&args[]);\n                       adt::trans_const(cx,\n                                        &*repr,\n                                        vinfo.disr_val,\n-                                       arg_vals.index(&FullRange))\n+                                       &arg_vals[])\n                   }\n                   _ => cx.sess().span_bug(e.span, \"expected a struct or variant def\")\n               }"}, {"sha": "1abf3b0b886cca3b5387f47590181f54f1679c83", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -284,7 +284,7 @@ impl<'tcx> SharedCrateContext<'tcx> {\n             // such as a function name in the module.\n             // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n             let llmod_id = format!(\"{}.{}.rs\", crate_name, i);\n-            let local_ccx = LocalCrateContext::new(&shared_ccx, llmod_id.index(&FullRange));\n+            let local_ccx = LocalCrateContext::new(&shared_ccx, &llmod_id[]);\n             shared_ccx.local_ccxs.push(local_ccx);\n         }\n \n@@ -369,12 +369,12 @@ impl<'tcx> LocalCrateContext<'tcx> {\n         unsafe {\n             let (llcx, llmod) = create_context_and_module(&shared.tcx.sess, name);\n \n-            let td = mk_target_data(shared.tcx\n+            let td = mk_target_data(&shared.tcx\n                                           .sess\n                                           .target\n                                           .target\n                                           .data_layout\n-                                          .index(&FullRange));\n+                                          []);\n \n             let dbg_cx = if shared.tcx.sess.opts.debuginfo != NoDebugInfo {\n                 Some(debuginfo::CrateDebugContext::new(llmod))\n@@ -721,7 +721,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     /// currently conservatively bounded to 1 << 47 as that is enough to cover the current usable\n     /// address space on 64-bit ARMv8 and x86_64.\n     pub fn obj_size_bound(&self) -> u64 {\n-        match self.sess().target.target.target_pointer_width.index(&FullRange) {\n+        match &self.sess().target.target.target_pointer_width[] {\n             \"32\" => 1 << 31,\n             \"64\" => 1 << 47,\n             _ => unreachable!() // error handled by config::build_target_config\n@@ -730,8 +730,8 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n \n     pub fn report_overbig_object(&self, obj: Ty<'tcx>) -> ! {\n         self.sess().fatal(\n-            format!(\"the type `{}` is too big for the current architecture\",\n-                    obj.repr(self.tcx())).index(&FullRange))\n+            &format!(\"the type `{}` is too big for the current architecture\",\n+                    obj.repr(self.tcx()))[])\n     }\n }\n "}, {"sha": "adf302501cd1f48b2c2a2bd50c3777db0ff4474d", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -48,7 +48,7 @@ pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     debug!(\"trans_stmt({})\", s.repr(cx.tcx()));\n \n     if cx.sess().asm_comments() {\n-        add_span_comment(cx, s.span, s.repr(cx.tcx()).index(&FullRange));\n+        add_span_comment(cx, s.span, &s.repr(cx.tcx())[]);\n     }\n \n     let mut bcx = cx;\n@@ -188,7 +188,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     let name = format!(\"then-block-{}-\", thn.id);\n-    let then_bcx_in = bcx.fcx.new_id_block(name.index(&FullRange), thn.id);\n+    let then_bcx_in = bcx.fcx.new_id_block(&name[], thn.id);\n     let then_bcx_out = trans_block(then_bcx_in, &*thn, dest);\n     trans::debuginfo::clear_source_location(bcx.fcx);\n \n@@ -439,8 +439,8 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match bcx.tcx().def_map.borrow().get(&expr_id) {\n                 Some(&def::DefLabel(loop_id)) => loop_id,\n                 ref r => {\n-                    bcx.tcx().sess.bug(format!(\"{:?} in def-map for label\",\n-                                               r).index(&FullRange))\n+                    bcx.tcx().sess.bug(&format!(\"{:?} in def-map for label\",\n+                                               r)[])\n                 }\n             }\n         }\n@@ -504,7 +504,7 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let v_str = C_str_slice(ccx, fail_str);\n     let loc = bcx.sess().codemap().lookup_char_pos(sp.lo);\n-    let filename = token::intern_and_get_ident(loc.file.name.index(&FullRange));\n+    let filename = token::intern_and_get_ident(&loc.file.name[]);\n     let filename = C_str_slice(ccx, filename);\n     let line = C_uint(ccx, loc.line);\n     let expr_file_line_const = C_struct(ccx, &[v_str, filename, line], false);\n@@ -513,7 +513,7 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let did = langcall(bcx, Some(sp), \"\", PanicFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n                                       did,\n-                                      args.index(&FullRange),\n+                                      &args[],\n                                       Some(expr::Ignore)).bcx;\n     Unreachable(bcx);\n     return bcx;\n@@ -529,7 +529,7 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Extract the file/line from the span\n     let loc = bcx.sess().codemap().lookup_char_pos(sp.lo);\n-    let filename = token::intern_and_get_ident(loc.file.name.index(&FullRange));\n+    let filename = token::intern_and_get_ident(&loc.file.name[]);\n \n     // Invoke the lang item\n     let filename = C_str_slice(ccx,  filename);\n@@ -540,7 +540,7 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let did = langcall(bcx, Some(sp), \"\", PanicBoundsCheckFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n                                       did,\n-                                      args.index(&FullRange),\n+                                      &args[],\n                                       Some(expr::Ignore)).bcx;\n     Unreachable(bcx);\n     return bcx;"}, {"sha": "8b52732f4ee972c7718cd4a26d5d1779d5e39b28", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -463,8 +463,8 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n                 gep(base)\n             }\n             _ => bcx.tcx().sess.bug(\n-                format!(\"Unexpected unsized type in get_element: {}\",\n-                        bcx.ty_to_string(self.ty)).index(&FullRange))\n+                &format!(\"Unexpected unsized type in get_element: {}\",\n+                        bcx.ty_to_string(self.ty))[])\n         };\n         Datum {\n             val: val,"}, {"sha": "3a6f4b47e4e1e7b2837be07b251e1a0727c61585", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 90, "deletions": 91, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -284,8 +284,8 @@ impl<'tcx> TypeMap<'tcx> {\n                                        type_: Ty<'tcx>,\n                                        metadata: DIType) {\n         if self.type_to_metadata.insert(type_, metadata).is_some() {\n-            cx.sess().bug(format!(\"Type metadata for Ty '{}' is already in the TypeMap!\",\n-                                   ppaux::ty_to_string(cx.tcx(), type_)).index(&FullRange));\n+            cx.sess().bug(&format!(\"Type metadata for Ty '{}' is already in the TypeMap!\",\n+                                   ppaux::ty_to_string(cx.tcx(), type_))[]);\n         }\n     }\n \n@@ -297,8 +297,8 @@ impl<'tcx> TypeMap<'tcx> {\n                                         metadata: DIType) {\n         if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n             let unique_type_id_str = self.get_unique_type_id_as_string(unique_type_id);\n-            cx.sess().bug(format!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n-                                  unique_type_id_str.index(&FullRange)).index(&FullRange));\n+            cx.sess().bug(&format!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n+                                  &unique_type_id_str[])[]);\n         }\n     }\n \n@@ -335,13 +335,13 @@ impl<'tcx> TypeMap<'tcx> {\n         // unique ptr (~)       -> {~ :pointee-uid:}\n         // @-ptr (@)            -> {@ :pointee-uid:}\n         // sized vec ([T; x])   -> {[:size:] :element-uid:}\n-        // unsized vec ([T])    -> {.index(&FullRange) :element-uid:}\n+        // unsized vec ([T])    -> {[] :element-uid:}\n         // trait (T)            -> {trait_:svh: / :node-id:_<(:param-uid:),*> }\n         // closure              -> {<unsafe_> <once_> :store-sigil: |(:param-uid:),* <,_...>| -> \\\n         //                             :return-type-uid: : (:bounds:)*}\n         // function             -> {<unsafe_> <abi_> fn( (:param-uid:)* <,_...> ) -> \\\n         //                             :return-type-uid:}\n-        // unique vec box (~.index(&FullRange)) -> {HEAP_VEC_BOX<:pointee-uid:>}\n+        // unique vec box (~[]) -> {HEAP_VEC_BOX<:pointee-uid:>}\n         // gc box               -> {GC_BOX<:pointee-uid:>}\n \n         match self.type_to_unique_id.get(&type_).cloned() {\n@@ -379,14 +379,14 @@ impl<'tcx> TypeMap<'tcx> {\n                         self.get_unique_type_id_of_type(cx, component_type);\n                     let component_type_id =\n                         self.get_unique_type_id_as_string(component_type_id);\n-                    unique_type_id.push_str(component_type_id.index(&FullRange));\n+                    unique_type_id.push_str(&component_type_id[]);\n                 }\n             },\n             ty::ty_uniq(inner_type) => {\n                 unique_type_id.push('~');\n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(inner_type_id.index(&FullRange));\n+                unique_type_id.push_str(&inner_type_id[]);\n             },\n             ty::ty_ptr(ty::mt { ty: inner_type, mutbl } ) => {\n                 unique_type_id.push('*');\n@@ -396,7 +396,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(inner_type_id.index(&FullRange));\n+                unique_type_id.push_str(&inner_type_id[]);\n             },\n             ty::ty_rptr(_, ty::mt { ty: inner_type, mutbl }) => {\n                 unique_type_id.push('&');\n@@ -406,12 +406,12 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(inner_type_id.index(&FullRange));\n+                unique_type_id.push_str(&inner_type_id[]);\n             },\n             ty::ty_vec(inner_type, optional_length) => {\n                 match optional_length {\n                     Some(len) => {\n-                        unique_type_id.push_str(format!(\"[{}]\", len).index(&FullRange));\n+                        unique_type_id.push_str(&format!(\"[{}]\", len)[]);\n                     }\n                     None => {\n                         unique_type_id.push_str(\"[]\");\n@@ -420,7 +420,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(inner_type_id.index(&FullRange));\n+                unique_type_id.push_str(&inner_type_id[]);\n             },\n             ty::ty_trait(ref trait_data) => {\n                 unique_type_id.push_str(\"trait \");\n@@ -451,7 +451,7 @@ impl<'tcx> TypeMap<'tcx> {\n                         self.get_unique_type_id_of_type(cx, parameter_type);\n                     let parameter_type_id =\n                         self.get_unique_type_id_as_string(parameter_type_id);\n-                    unique_type_id.push_str(parameter_type_id.index(&FullRange));\n+                    unique_type_id.push_str(&parameter_type_id[]);\n                     unique_type_id.push(',');\n                 }\n \n@@ -464,7 +464,7 @@ impl<'tcx> TypeMap<'tcx> {\n                     ty::FnConverging(ret_ty) => {\n                         let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n                         let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                        unique_type_id.push_str(return_type_id.index(&FullRange));\n+                        unique_type_id.push_str(&return_type_id[]);\n                     }\n                     ty::FnDiverging => {\n                         unique_type_id.push_str(\"!\");\n@@ -479,9 +479,9 @@ impl<'tcx> TypeMap<'tcx> {\n                                                         &mut unique_type_id);\n             },\n             _ => {\n-                cx.sess().bug(format!(\"get_unique_type_id_of_type() - unexpected type: {}, {:?}\",\n-                                      ppaux::ty_to_string(cx.tcx(), type_).index(&FullRange),\n-                                      type_.sty).index(&FullRange))\n+                cx.sess().bug(&format!(\"get_unique_type_id_of_type() - unexpected type: {}, {:?}\",\n+                                      &ppaux::ty_to_string(cx.tcx(), type_)[],\n+                                      type_.sty)[])\n             }\n         };\n \n@@ -524,7 +524,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n             output.push_str(crate_hash.as_str());\n             output.push_str(\"/\");\n-            output.push_str(format!(\"{:x}\", def_id.node).index(&FullRange));\n+            output.push_str(&format!(\"{:x}\", def_id.node)[]);\n \n             // Maybe check that there is no self type here.\n \n@@ -537,7 +537,7 @@ impl<'tcx> TypeMap<'tcx> {\n                         type_map.get_unique_type_id_of_type(cx, type_parameter);\n                     let param_type_id =\n                         type_map.get_unique_type_id_as_string(param_type_id);\n-                    output.push_str(param_type_id.index(&FullRange));\n+                    output.push_str(&param_type_id[]);\n                     output.push(',');\n                 }\n \n@@ -581,7 +581,7 @@ impl<'tcx> TypeMap<'tcx> {\n                 self.get_unique_type_id_of_type(cx, parameter_type);\n             let parameter_type_id =\n                 self.get_unique_type_id_as_string(parameter_type_id);\n-            unique_type_id.push_str(parameter_type_id.index(&FullRange));\n+            unique_type_id.push_str(&parameter_type_id[]);\n             unique_type_id.push(',');\n         }\n \n@@ -595,7 +595,7 @@ impl<'tcx> TypeMap<'tcx> {\n             ty::FnConverging(ret_ty) => {\n                 let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n                 let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                unique_type_id.push_str(return_type_id.index(&FullRange));\n+                unique_type_id.push_str(&return_type_id[]);\n             }\n             ty::FnDiverging => {\n                 unique_type_id.push_str(\"!\");\n@@ -625,8 +625,7 @@ impl<'tcx> TypeMap<'tcx> {\n                                               -> UniqueTypeId {\n         let enum_type_id = self.get_unique_type_id_of_type(cx, enum_type);\n         let enum_variant_type_id = format!(\"{}::{}\",\n-                                           self.get_unique_type_id_as_string(enum_type_id)\n-                                               .index(&FullRange),\n+                                           &self.get_unique_type_id_as_string(enum_type_id)[],\n                                            variant_name);\n         let interner_key = self.unique_id_interner.intern(Rc::new(enum_variant_type_id));\n         UniqueTypeId(interner_key)\n@@ -803,23 +802,23 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                 _ => {\n                     cx.sess()\n                       .span_bug(item.span,\n-                                format!(\"debuginfo::\\\n+                                &format!(\"debuginfo::\\\n                                          create_global_var_metadata() -\n                                          Captured var-id refers to \\\n                                          unexpected ast_item variant: {:?}\",\n-                                        var_item).index(&FullRange))\n+                                        var_item)[])\n                 }\n             }\n         },\n-        _ => cx.sess().bug(format!(\"debuginfo::create_global_var_metadata() \\\n+        _ => cx.sess().bug(&format!(\"debuginfo::create_global_var_metadata() \\\n                                     - Captured var-id refers to unexpected \\\n                                     ast_map variant: {:?}\",\n-                                   var_item).index(&FullRange))\n+                                   var_item)[])\n     };\n \n     let (file_metadata, line_number) = if span != codemap::DUMMY_SP {\n         let loc = span_start(cx, span);\n-        (file_metadata(cx, loc.file.name.index(&FullRange)), loc.line as c_uint)\n+        (file_metadata(cx, &loc.file.name[]), loc.line as c_uint)\n     } else {\n         (UNKNOWN_FILE_METADATA, UNKNOWN_LINE_NUMBER)\n     };\n@@ -830,7 +829,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let namespace_node = namespace_for_item(cx, ast_util::local_def(node_id));\n     let var_name = token::get_ident(ident).get().to_string();\n     let linkage_name =\n-        namespace_node.mangled_name_of_contained_item(var_name.index(&FullRange));\n+        namespace_node.mangled_name_of_contained_item(&var_name[]);\n     let var_scope = namespace_node.scope;\n \n     let var_name = CString::from_slice(var_name.as_bytes());\n@@ -868,8 +867,8 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n             Some(datum) => datum,\n             None => {\n                 bcx.sess().span_bug(span,\n-                    format!(\"no entry in lllocals table for {}\",\n-                            node_id).index(&FullRange));\n+                    &format!(\"no entry in lllocals table for {}\",\n+                            node_id)[]);\n             }\n         };\n \n@@ -919,21 +918,21 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 _ => {\n                     cx.sess()\n                       .span_bug(span,\n-                                format!(\n+                                &format!(\n                                 \"debuginfo::create_captured_var_metadata() - \\\n                                  Captured var-id refers to unexpected \\\n                                  ast_map variant: {:?}\",\n-                                 ast_item).index(&FullRange));\n+                                 ast_item)[]);\n                 }\n             }\n         }\n         _ => {\n             cx.sess()\n               .span_bug(span,\n-                        format!(\"debuginfo::create_captured_var_metadata() - \\\n+                        &format!(\"debuginfo::create_captured_var_metadata() - \\\n                                  Captured var-id refers to unexpected \\\n                                  ast_map variant: {:?}\",\n-                                ast_item).index(&FullRange));\n+                                ast_item)[]);\n         }\n     };\n \n@@ -963,7 +962,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let variable_access = IndirectVariable {\n         alloca: env_pointer,\n-        address_operations: address_operations.index(&(0..address_op_count))\n+        address_operations: &address_operations[0..address_op_count]\n     };\n \n     declare_local(bcx,\n@@ -1039,8 +1038,8 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n             Some(v) => v,\n             None => {\n                 bcx.sess().span_bug(span,\n-                    format!(\"no entry in lllocals table for {}\",\n-                            node_id).index(&FullRange));\n+                    &format!(\"no entry in lllocals table for {}\",\n+                            node_id)[]);\n             }\n         };\n \n@@ -1154,7 +1153,7 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         if let Some(code_snippet) = code_snippet {\n             let bytes = code_snippet.as_bytes();\n \n-            if bytes.len() > 0 && bytes.index(&((bytes.len()-1)..)) == b\"}\" {\n+            if bytes.len() > 0 && &bytes[(bytes.len()-1)..] == b\"}\" {\n                 cleanup_span = Span {\n                     lo: node_span.hi - codemap::BytePos(1),\n                     hi: node_span.hi,\n@@ -1298,7 +1297,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             match expr.node {\n                 ast::ExprClosure(_, _, ref fn_decl, ref top_level_block) => {\n                     let name = format!(\"fn{}\", token::gensym(\"fn\"));\n-                    let name = token::str_to_ident(name.index(&FullRange));\n+                    let name = token::str_to_ident(&name[]);\n                     (name, &**fn_decl,\n                         // This is not quite right. It should actually inherit\n                         // the generics of the enclosing function.\n@@ -1328,9 +1327,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n                 _ => {\n                     cx.sess()\n-                      .bug(format!(\"create_function_debug_context: \\\n+                      .bug(&format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {:?}\",\n-                                    fnitem).index(&FullRange))\n+                                    fnitem)[])\n                 }\n             }\n         }\n@@ -1339,9 +1338,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ast_map::NodeStructCtor(..) => {\n             return FunctionDebugContext::FunctionWithoutDebugInfo;\n         }\n-        _ => cx.sess().bug(format!(\"create_function_debug_context: \\\n+        _ => cx.sess().bug(&format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {:?}\",\n-                                   fnitem).index(&FullRange))\n+                                   fnitem)[])\n     };\n \n     // This can be the case for functions inlined from another crate\n@@ -1350,7 +1349,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name.index(&FullRange));\n+    let file_metadata = file_metadata(cx, &loc.file.name[]);\n \n     let function_type_metadata = unsafe {\n         let fn_signature = get_function_signature(cx,\n@@ -1377,7 +1376,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let (linkage_name, containing_scope) = if has_path {\n         let namespace_node = namespace_for_item(cx, ast_util::local_def(fn_ast_id));\n         let linkage_name = namespace_node.mangled_name_of_contained_item(\n-            function_name.index(&FullRange));\n+            &function_name[]);\n         let containing_scope = namespace_node.scope;\n         (linkage_name, containing_scope)\n     } else {\n@@ -1465,7 +1464,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             signature.push(type_metadata(cx, arg_type, codemap::DUMMY_SP));\n         }\n \n-        return create_DIArray(DIB(cx), signature.index(&FullRange));\n+        return create_DIArray(DIB(cx), &signature[]);\n     }\n \n     fn get_template_parameters<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n@@ -1500,7 +1499,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 actual_self_type,\n                 true);\n \n-            name_to_append_suffix_to.push_str(actual_self_type_name.index(&FullRange));\n+            name_to_append_suffix_to.push_str(&actual_self_type_name[]);\n \n             if generics.is_type_parameterized() {\n                 name_to_append_suffix_to.push_str(\",\");\n@@ -1539,7 +1538,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let actual_type_name = compute_debuginfo_type_name(cx,\n                                                                actual_type,\n                                                                true);\n-            name_to_append_suffix_to.push_str(actual_type_name.index(&FullRange));\n+            name_to_append_suffix_to.push_str(&actual_type_name[]);\n \n             if index != generics.ty_params.len() - 1 {\n                 name_to_append_suffix_to.push_str(\",\");\n@@ -1566,7 +1565,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n         name_to_append_suffix_to.push('>');\n \n-        return create_DIArray(DIB(cx), template_params.index(&FullRange));\n+        return create_DIArray(DIB(cx), &template_params[]);\n     }\n }\n \n@@ -1660,7 +1659,7 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let cx: &CrateContext = bcx.ccx();\n \n     let filename = span_start(cx, span).file.name.clone();\n-    let file_metadata = file_metadata(cx, filename.index(&FullRange));\n+    let file_metadata = file_metadata(cx, &filename[]);\n \n     let name = token::get_ident(variable_ident);\n     let loc = span_start(cx, span);\n@@ -1746,7 +1745,7 @@ fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n     let work_dir = cx.sess().working_dir.as_str().unwrap();\n     let file_name =\n         if full_path.starts_with(work_dir) {\n-            full_path.index(&((work_dir.len() + 1u)..full_path.len()))\n+            &full_path[(work_dir.len() + 1u)..full_path.len()]\n         } else {\n             full_path\n         };\n@@ -1777,8 +1776,8 @@ fn scope_metadata(fcx: &FunctionContext,\n             let node = fcx.ccx.tcx().map.get(node_id);\n \n             fcx.ccx.sess().span_bug(error_reporting_span,\n-                format!(\"debuginfo: Could not find scope info for node {:?}\",\n-                        node).index(&FullRange));\n+                &format!(\"debuginfo: Could not find scope info for node {:?}\",\n+                        node)[]);\n         }\n     }\n }\n@@ -1971,10 +1970,10 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                     let type_map = debug_context(cx).type_map.borrow();\n                     if type_map.find_metadata_for_unique_id(unique_type_id).is_none() ||\n                        type_map.find_metadata_for_type(unfinished_type).is_none() {\n-                        cx.sess().bug(format!(\"Forward declaration of potentially recursive type \\\n+                        cx.sess().bug(&format!(\"Forward declaration of potentially recursive type \\\n                                               '{}' was not found in TypeMap!\",\n                                               ppaux::ty_to_string(cx.tcx(), unfinished_type))\n-                                      .index(&FullRange));\n+                                      []);\n                     }\n                 }\n \n@@ -1986,7 +1985,7 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                 set_members_of_composite_type(cx,\n                                               metadata_stub,\n                                               llvm_type,\n-                                              member_descriptions.index(&FullRange));\n+                                              &member_descriptions[]);\n                 return MetadataCreationResult::new(metadata_stub, true);\n             }\n         }\n@@ -2058,7 +2057,7 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let struct_metadata_stub = create_struct_stub(cx,\n                                                   struct_llvm_type,\n-                                                  struct_name.index(&FullRange),\n+                                                  &struct_name[],\n                                                   unique_type_id,\n                                                   containing_scope);\n \n@@ -2119,7 +2118,7 @@ fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         unique_type_id,\n         create_struct_stub(cx,\n                            tuple_llvm_type,\n-                           tuple_name.index(&FullRange),\n+                           &tuple_name[],\n                            unique_type_id,\n                            UNKNOWN_SCOPE_METADATA),\n         tuple_llvm_type,\n@@ -2179,7 +2178,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         set_members_of_composite_type(cx,\n                                                       variant_type_metadata,\n                                                       variant_llvm_type,\n-                                                      member_descriptions.index(&FullRange));\n+                                                      &member_descriptions[]);\n                         MemberDescription {\n                             name: \"\".to_string(),\n                             llvm_type: variant_llvm_type,\n@@ -2212,7 +2211,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     set_members_of_composite_type(cx,\n                                                   variant_type_metadata,\n                                                   variant_llvm_type,\n-                                                  member_descriptions.index(&FullRange));\n+                                                  &member_descriptions[]);\n                     vec![\n                         MemberDescription {\n                             name: \"\".to_string(),\n@@ -2312,7 +2311,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 set_members_of_composite_type(cx,\n                                               variant_type_metadata,\n                                               variant_llvm_type,\n-                                              variant_member_descriptions.index(&FullRange));\n+                                              &variant_member_descriptions[]);\n \n                 // Encode the information about the null variant in the union\n                 // member's name.\n@@ -2387,11 +2386,11 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    span: Span)\n                                    -> (DICompositeType, Type, MemberDescriptionFactory<'tcx>) {\n     let variant_llvm_type =\n-        Type::struct_(cx, struct_def.fields\n+        Type::struct_(cx, &struct_def.fields\n                                     .iter()\n                                     .map(|&t| type_of::type_of(cx, t))\n                                     .collect::<Vec<_>>()\n-                                    .index(&FullRange),\n+                                    [],\n                       struct_def.packed);\n     // Could do some consistency checks here: size, align, field count, discr type\n \n@@ -2458,7 +2457,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, enum_def_id);\n     let loc = span_start(cx, definition_span);\n-    let file_metadata = file_metadata(cx, loc.file.name.index(&FullRange));\n+    let file_metadata = file_metadata(cx, &loc.file.name[]);\n \n     let variants = ty::enum_variants(cx.tcx(), enum_def_id);\n \n@@ -2638,14 +2637,14 @@ fn set_members_of_composite_type(cx: &CrateContext,\n             let min_supported_llvm_version = 3 * 1000000 + 4 * 1000;\n \n             if actual_llvm_version < min_supported_llvm_version {\n-                cx.sess().warn(format!(\"This version of rustc was built with LLVM \\\n+                cx.sess().warn(&format!(\"This version of rustc was built with LLVM \\\n                                         {}.{}. Rustc just ran into a known \\\n                                         debuginfo corruption problem thatoften \\\n                                         occurs with LLVM versions below 3.4. \\\n                                         Please use a rustc built with anewer \\\n                                         version of LLVM.\",\n                                        llvm_version_major,\n-                                       llvm_version_minor).index(&FullRange));\n+                                       llvm_version_minor)[]);\n             } else {\n                 cx.sess().bug(\"debuginfo::set_members_of_composite_type() - \\\n                                Already completed forward declaration re-encountered.\");\n@@ -2683,7 +2682,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n         .collect();\n \n     unsafe {\n-        let type_array = create_DIArray(DIB(cx), member_metadata.index(&FullRange));\n+        let type_array = create_DIArray(DIB(cx), &member_metadata[]);\n         llvm::LLVMDICompositeTypeSetTypeArray(composite_type_metadata, type_array);\n     }\n }\n@@ -2782,7 +2781,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let member_llvm_types = slice_llvm_type.field_types();\n     assert!(slice_layout_is_correct(cx,\n-                                    member_llvm_types.index(&FullRange),\n+                                    &member_llvm_types[],\n                                     element_type));\n     let member_descriptions = [\n         MemberDescription {\n@@ -2804,11 +2803,11 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     assert!(member_descriptions.len() == member_llvm_types.len());\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name.index(&FullRange));\n+    let file_metadata = file_metadata(cx, &loc.file.name[]);\n \n     let metadata = composite_type_metadata(cx,\n                                            slice_llvm_type,\n-                                           slice_type_name.index(&FullRange),\n+                                           &slice_type_name[],\n                                            unique_type_id,\n                                            &member_descriptions,\n                                            UNKNOWN_SCOPE_METADATA,\n@@ -2857,7 +2856,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             llvm::LLVMDIBuilderCreateSubroutineType(\n                 DIB(cx),\n                 UNKNOWN_FILE_METADATA,\n-                create_DIArray(DIB(cx), signature_metadata.index(&FullRange)))\n+                create_DIArray(DIB(cx), &signature_metadata[]))\n         },\n         false);\n }\n@@ -2881,9 +2880,9 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_trait(ref data) => data.principal_def_id(),\n         _ => {\n             let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_type);\n-            cx.sess().bug(format!(\"debuginfo: Unexpected trait-object type in \\\n+            cx.sess().bug(&format!(\"debuginfo: Unexpected trait-object type in \\\n                                    trait_pointer_metadata(): {}\",\n-                                   pp_type_name.index(&FullRange)).index(&FullRange));\n+                                   &pp_type_name[])[]);\n         }\n     };\n \n@@ -2897,7 +2896,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     composite_type_metadata(cx,\n                             trait_llvm_type,\n-                            trait_type_name.index(&FullRange),\n+                            &trait_type_name[],\n                             unique_type_id,\n                             &[],\n                             containing_scope,\n@@ -3017,13 +3016,13 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_tup(ref elements) => {\n             prepare_tuple_metadata(cx,\n                                    t,\n-                                   elements.index(&FullRange),\n+                                   &elements[],\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }\n         _ => {\n-            cx.sess().bug(format!(\"debuginfo: unexpected type in type_metadata: {:?}\",\n-                                  sty).index(&FullRange))\n+            cx.sess().bug(&format!(\"debuginfo: unexpected type in type_metadata: {:?}\",\n+                                  sty)[])\n         }\n     };\n \n@@ -3041,9 +3040,9 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                  type id '{}' to already be in \\\n                                                  the debuginfo::TypeMap but it \\\n                                                  was not. (Ty = {})\",\n-                                                unique_type_id_str.index(&FullRange),\n+                                                &unique_type_id_str[],\n                                                 ppaux::ty_to_string(cx.tcx(), t));\n-                    cx.sess().span_bug(usage_site_span, error_message.index(&FullRange));\n+                    cx.sess().span_bug(usage_site_span, &error_message[]);\n                 }\n             };\n \n@@ -3056,9 +3055,9 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                      UniqueTypeId maps in \\\n                                                      debuginfo::TypeMap. \\\n                                                      UniqueTypeId={}, Ty={}\",\n-                            unique_type_id_str.index(&FullRange),\n+                            &unique_type_id_str[],\n                             ppaux::ty_to_string(cx.tcx(), t));\n-                        cx.sess().span_bug(usage_site_span, error_message.index(&FullRange));\n+                        cx.sess().span_bug(usage_site_span, &error_message[]);\n                     }\n                 }\n                 None => {\n@@ -3264,7 +3263,7 @@ fn create_scope_map(cx: &CrateContext,\n     {\n         // Create a new lexical scope and push it onto the stack\n         let loc = cx.sess().codemap().lookup_char_pos(scope_span.lo);\n-        let file_metadata = file_metadata(cx, loc.file.name.index(&FullRange));\n+        let file_metadata = file_metadata(cx, &loc.file.name[]);\n         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n         let scope_metadata = unsafe {\n@@ -3386,7 +3385,7 @@ fn create_scope_map(cx: &CrateContext,\n                     if need_new_scope {\n                         // Create a new lexical scope and push it onto the stack\n                         let loc = cx.sess().codemap().lookup_char_pos(pat.span.lo);\n-                        let file_metadata = file_metadata(cx, loc.file.name.index(&FullRange));\n+                        let file_metadata = file_metadata(cx, &loc.file.name[]);\n                         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n                         let scope_metadata = unsafe {\n@@ -3861,8 +3860,8 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_open(_) |\n         ty::ty_projection(..) |\n         ty::ty_param(_) => {\n-            cx.sess().bug(format!(\"debuginfo: Trying to create type name for \\\n-                unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t)).index(&FullRange));\n+            cx.sess().bug(&format!(\"debuginfo: Trying to create type name for \\\n+                unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t))[]);\n         }\n     }\n \n@@ -3945,21 +3944,21 @@ impl NamespaceTreeNode {\n                 None => {}\n             }\n             let string = token::get_name(node.name);\n-            output.push_str(format!(\"{}\", string.get().len()).index(&FullRange));\n+            output.push_str(&format!(\"{}\", string.get().len())[]);\n             output.push_str(string.get());\n         }\n \n         let mut name = String::from_str(\"_ZN\");\n         fill_nested(self, &mut name);\n-        name.push_str(format!(\"{}\", item_name.len()).index(&FullRange));\n+        name.push_str(&format!(\"{}\", item_name.len())[]);\n         name.push_str(item_name);\n         name.push('E');\n         name\n     }\n }\n \n fn crate_root_namespace<'a>(cx: &'a CrateContext) -> &'a str {\n-    cx.link_meta().crate_name.index(&FullRange)\n+    &cx.link_meta().crate_name[]\n }\n \n fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTreeNode> {\n@@ -4034,9 +4033,9 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n         match parent_node {\n             Some(node) => node,\n             None => {\n-                cx.sess().bug(format!(\"debuginfo::namespace_for_item(): \\\n+                cx.sess().bug(&format!(\"debuginfo::namespace_for_item(): \\\n                                        path too short for {:?}\",\n-                                      def_id).index(&FullRange));\n+                                      def_id)[]);\n             }\n         }\n     })"}, {"sha": "2d1a151c2b839e8960cc7734675e115a87eddb01", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -317,8 +317,8 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     // should just be the identity function.\n                     unsized_info(bcx, k, id, ty_substs[tp_index], identity)\n                 }\n-                _ => bcx.sess().bug(format!(\"UnsizeStruct with bad sty: {}\",\n-                                          bcx.ty_to_string(unadjusted_ty)).index(&FullRange))\n+                _ => bcx.sess().bug(&format!(\"UnsizeStruct with bad sty: {}\",\n+                                          bcx.ty_to_string(unadjusted_ty))[])\n             },\n             &ty::UnsizeVtable(ty::TyTrait { ref principal, .. }, _) => {\n                 // Note that we preserve binding levels here:\n@@ -450,8 +450,8 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let datum_ty = datum.ty;\n         let unboxed_ty = match datum_ty.sty {\n             ty::ty_uniq(t) => t,\n-            _ => bcx.sess().bug(format!(\"Expected ty_uniq, found {}\",\n-                                        bcx.ty_to_string(datum_ty)).index(&FullRange))\n+            _ => bcx.sess().bug(&format!(\"Expected ty_uniq, found {}\",\n+                                        bcx.ty_to_string(datum_ty))[])\n         };\n         let result_ty = ty::mk_uniq(tcx, ty::unsize_ty(tcx, unboxed_ty, k, expr.span));\n \n@@ -622,9 +622,9 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                format!(\"trans_rvalue_datum_unadjusted reached \\\n+                &format!(\"trans_rvalue_datum_unadjusted reached \\\n                          fall-through case: {:?}\",\n-                        expr.node).index(&FullRange));\n+                        expr.node)[]);\n         }\n     }\n }\n@@ -975,9 +975,9 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                format!(\"trans_rvalue_stmt_unadjusted reached \\\n+                &format!(\"trans_rvalue_stmt_unadjusted reached \\\n                          fall-through case: {:?}\",\n-                        expr.node).index(&FullRange));\n+                        expr.node)[]);\n         }\n     }\n }\n@@ -1003,14 +1003,14 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             controlflow::trans_if(bcx, expr.id, &**cond, &**thn, els.as_ref().map(|e| &**e), dest)\n         }\n         ast::ExprMatch(ref discr, ref arms, _) => {\n-            _match::trans_match(bcx, expr, &**discr, arms.index(&FullRange), dest)\n+            _match::trans_match(bcx, expr, &**discr, &arms[], dest)\n         }\n         ast::ExprBlock(ref blk) => {\n             controlflow::trans_block(bcx, &**blk, dest)\n         }\n         ast::ExprStruct(_, ref fields, ref base) => {\n             trans_struct(bcx,\n-                         fields.index(&FullRange),\n+                         &fields[],\n                          base.as_ref().map(|e| &**e),\n                          expr.span,\n                          expr.id,\n@@ -1075,7 +1075,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans_adt(bcx,\n                       expr_ty(bcx, expr),\n                       0,\n-                      numbered_fields.index(&FullRange),\n+                      &numbered_fields[],\n                       None,\n                       dest,\n                       Some(NodeInfo { id: expr.id, span: expr.span }))\n@@ -1119,21 +1119,21 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 trans_overloaded_call(bcx,\n                                       expr,\n                                       &**f,\n-                                      args.index(&FullRange),\n+                                      &args[],\n                                       Some(dest))\n             } else {\n                 callee::trans_call(bcx,\n                                    expr,\n                                    &**f,\n-                                   callee::ArgExprs(args.index(&FullRange)),\n+                                   callee::ArgExprs(&args[]),\n                                    dest)\n             }\n         }\n         ast::ExprMethodCall(_, _, ref args) => {\n             callee::trans_method_call(bcx,\n                                       expr,\n                                       &*args[0],\n-                                      callee::ArgExprs(args.index(&FullRange)),\n+                                      callee::ArgExprs(&args[]),\n                                       dest)\n         }\n         ast::ExprBinary(op, ref lhs, ref rhs) => {\n@@ -1180,9 +1180,9 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                format!(\"trans_rvalue_dps_unadjusted reached fall-through \\\n+                &format!(\"trans_rvalue_dps_unadjusted reached fall-through \\\n                          case: {:?}\",\n-                        expr.node).index(&FullRange));\n+                        expr.node)[]);\n         }\n     }\n }\n@@ -1230,9 +1230,9 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx\n         }\n         _ => {\n-            bcx.tcx().sess.span_bug(ref_expr.span, format!(\n+            bcx.tcx().sess.span_bug(ref_expr.span, &format!(\n                 \"Non-DPS def {:?} referened by {}\",\n-                def, bcx.node_id_to_string(ref_expr.id)).index(&FullRange));\n+                def, bcx.node_id_to_string(ref_expr.id))[]);\n         }\n     }\n }\n@@ -1258,10 +1258,10 @@ pub fn trans_def_fn_unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                              param_substs)\n         }\n         _ => {\n-            ccx.tcx().sess.span_bug(ref_expr.span, format!(\n+            ccx.tcx().sess.span_bug(ref_expr.span, &format!(\n                     \"trans_def_fn_unadjusted invoked on: {:?} for {}\",\n                     def,\n-                    ref_expr.repr(ccx.tcx())).index(&FullRange));\n+                    ref_expr.repr(ccx.tcx()))[]);\n         }\n     }\n }\n@@ -1279,29 +1279,29 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match bcx.fcx.llupvars.borrow().get(&nid) {\n                 Some(&val) => Datum::new(val, local_ty, Lvalue),\n                 None => {\n-                    bcx.sess().bug(format!(\n+                    bcx.sess().bug(&format!(\n                         \"trans_local_var: no llval for upvar {} found\",\n-                        nid).index(&FullRange));\n+                        nid)[]);\n                 }\n             }\n         }\n         def::DefLocal(nid) => {\n             let datum = match bcx.fcx.lllocals.borrow().get(&nid) {\n                 Some(&v) => v,\n                 None => {\n-                    bcx.sess().bug(format!(\n+                    bcx.sess().bug(&format!(\n                         \"trans_local_var: no datum for local/arg {} found\",\n-                        nid).index(&FullRange));\n+                        nid)[]);\n                 }\n             };\n             debug!(\"take_local(nid={}, v={}, ty={})\",\n                    nid, bcx.val_to_string(datum.val), bcx.ty_to_string(datum.ty));\n             datum\n         }\n         _ => {\n-            bcx.sess().unimpl(format!(\n+            bcx.sess().unimpl(&format!(\n                 \"unsupported def type in trans_local_var: {:?}\",\n-                def).index(&FullRange));\n+                def)[]);\n         }\n     }\n }\n@@ -1318,21 +1318,21 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n {\n     match ty.sty {\n         ty::ty_struct(did, substs) => {\n-            op(0, struct_fields(tcx, did, substs).index(&FullRange))\n+            op(0, &struct_fields(tcx, did, substs)[])\n         }\n \n         ty::ty_tup(ref v) => {\n-            op(0, tup_fields(v.index(&FullRange)).index(&FullRange))\n+            op(0, &tup_fields(&v[])[])\n         }\n \n         ty::ty_enum(_, substs) => {\n             // We want the *variant* ID here, not the enum ID.\n             match node_id_opt {\n                 None => {\n-                    tcx.sess.bug(format!(\n+                    tcx.sess.bug(&format!(\n                         \"cannot get field types from the enum type {} \\\n                          without a node ID\",\n-                        ty.repr(tcx)).index(&FullRange));\n+                        ty.repr(tcx))[]);\n                 }\n                 Some(node_id) => {\n                     let def = tcx.def_map.borrow()[node_id].clone();\n@@ -1341,9 +1341,9 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n                             let variant_info = ty::enum_variant_with_id(\n                                 tcx, enum_id, variant_id);\n                             op(variant_info.disr_val,\n-                               struct_fields(tcx,\n+                               &struct_fields(tcx,\n                                              variant_id,\n-                                             substs).index(&FullRange))\n+                                             substs)[])\n                         }\n                         _ => {\n                             tcx.sess.bug(\"resolve didn't map this expr to a \\\n@@ -1355,9 +1355,9 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n         }\n \n         _ => {\n-            tcx.sess.bug(format!(\n+            tcx.sess.bug(&format!(\n                 \"cannot get field types from the type {}\",\n-                ty.repr(tcx)).index(&FullRange));\n+                ty.repr(tcx))[]);\n         }\n     }\n }\n@@ -2045,21 +2045,21 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           lldiscrim_a, true),\n                 cast_float => SIToFP(bcx, lldiscrim_a, ll_t_out),\n                 _ => {\n-                    ccx.sess().bug(format!(\"translating unsupported cast: \\\n+                    ccx.sess().bug(&format!(\"translating unsupported cast: \\\n                                             {} ({:?}) -> {} ({:?})\",\n                                             t_in.repr(bcx.tcx()),\n                                             k_in,\n                                             t_out.repr(bcx.tcx()),\n-                                            k_out).index(&FullRange))\n+                                            k_out)[])\n                 }\n             }\n         }\n-        _ => ccx.sess().bug(format!(\"translating unsupported cast: \\\n+        _ => ccx.sess().bug(&format!(\"translating unsupported cast: \\\n                                     {} ({:?}) -> {} ({:?})\",\n                                     t_in.repr(bcx.tcx()),\n                                     k_in,\n                                     t_out.repr(bcx.tcx()),\n-                                    k_out).index(&FullRange))\n+                                    k_out)[])\n     };\n     return immediate_rvalue_bcx(bcx, newval, t_out).to_expr_datumblock();\n }\n@@ -2224,8 +2224,8 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                format!(\"deref invoked on expr of illegal type {}\",\n-                        datum.ty.repr(bcx.tcx())).index(&FullRange));\n+                &format!(\"deref invoked on expr of illegal type {}\",\n+                        datum.ty.repr(bcx.tcx()))[]);\n         }\n     };\n "}, {"sha": "3dfb36c854b72bb775abed0dc7ab0b64b95961f8", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -109,7 +109,7 @@ pub fn register_static(ccx: &CrateContext,\n     let llty = type_of::type_of(ccx, ty);\n \n     let ident = link_name(foreign_item);\n-    match attr::first_attr_value_str_by_name(foreign_item.attrs.index(&FullRange),\n+    match attr::first_attr_value_str_by_name(&foreign_item.attrs[],\n                                              \"linkage\") {\n         // If this is a static with a linkage specified, then we need to handle\n         // it a little specially. The typesystem prevents things like &T and\n@@ -235,13 +235,13 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => ccx.sess().bug(\"trans_native_call called on non-function type\")\n     };\n     let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n-    let llsig = foreign_signature(ccx, &fn_sig, passed_arg_tys.index(&FullRange));\n+    let llsig = foreign_signature(ccx, &fn_sig, &passed_arg_tys[]);\n     let fn_type = cabi::compute_abi_info(ccx,\n-                                         llsig.llarg_tys.index(&FullRange),\n+                                         &llsig.llarg_tys[],\n                                          llsig.llret_ty,\n                                          llsig.ret_def);\n \n-    let arg_tys: &[cabi::ArgType] = fn_type.arg_tys.index(&FullRange);\n+    let arg_tys: &[cabi::ArgType] = &fn_type.arg_tys[];\n \n     let mut llargs_foreign = Vec::new();\n \n@@ -367,7 +367,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let llforeign_retval = CallWithConv(bcx,\n                                         llfn,\n-                                        llargs_foreign.index(&FullRange),\n+                                        &llargs_foreign[],\n                                         cc,\n                                         Some(attrs));\n \n@@ -437,7 +437,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n                 abi => {\n                     let ty = ty::node_id_to_type(ccx.tcx(), foreign_item.id);\n                     register_foreign_item_fn(ccx, abi, ty,\n-                                             lname.get().index(&FullRange));\n+                                             &lname.get()[]);\n                     // Unlike for other items, we shouldn't call\n                     // `base::update_linkage` here.  Foreign items have\n                     // special linkage requirements, which are handled\n@@ -566,18 +566,18 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 assert!(f.abi != Rust && f.abi != RustIntrinsic);\n             }\n             _ => {\n-                ccx.sess().bug(format!(\"build_rust_fn: extern fn {} has ty {}, \\\n+                ccx.sess().bug(&format!(\"build_rust_fn: extern fn {} has ty {}, \\\n                                         expected a bare fn ty\",\n                                        ccx.tcx().map.path_to_string(id),\n-                                       t.repr(tcx)).index(&FullRange));\n+                                       t.repr(tcx))[]);\n             }\n         };\n \n         debug!(\"build_rust_fn: path={} id={} t={}\",\n                ccx.tcx().map.path_to_string(id),\n                id, t.repr(tcx));\n \n-        let llfn = base::decl_internal_rust_fn(ccx, t, ps.index(&FullRange));\n+        let llfn = base::decl_internal_rust_fn(ccx, t, &ps[]);\n         base::set_llvm_fn_attrs(ccx, attrs, llfn);\n         base::trans_fn(ccx, decl, body, llfn, param_substs, id, &[]);\n         llfn\n@@ -817,9 +817,9 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n // the massive simplifications that have occurred.\n \n pub fn link_name(i: &ast::ForeignItem) -> InternedString {\n-    match attr::first_attr_value_str_by_name(i.attrs.index(&FullRange), \"link_name\") {\n+    match attr::first_attr_value_str_by_name(&i.attrs[], \"link_name\") {\n         Some(ln) => ln.clone(),\n-        None => match weak_lang_items::link_name(i.attrs.index(&FullRange)) {\n+        None => match weak_lang_items::link_name(&i.attrs[]) {\n             Some(name) => name,\n             None => token::get_ident(i.ident),\n         }\n@@ -862,7 +862,7 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n     let llsig = foreign_signature(ccx, &fn_sig, fn_sig.inputs.as_slice());\n     let fn_ty = cabi::compute_abi_info(ccx,\n-                                       llsig.llarg_tys.index(&FullRange),\n+                                       &llsig.llarg_tys[],\n                                        llsig.llret_ty,\n                                        llsig.ret_def);\n     debug!(\"foreign_types_for_fn_ty(\\\n@@ -871,7 +871,7 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            fn_ty={} -> {}, \\\n            ret_def={}\",\n            ty.repr(ccx.tcx()),\n-           ccx.tn().types_to_str(llsig.llarg_tys.index(&FullRange)),\n+           ccx.tn().types_to_str(&llsig.llarg_tys[]),\n            ccx.tn().type_to_string(llsig.llret_ty),\n            ccx.tn().types_to_str(fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>().as_slice()),\n            ccx.tn().type_to_string(fn_ty.ret_ty.ty),\n@@ -923,7 +923,7 @@ fn lltype_for_fn_from_foreign_types(ccx: &CrateContext, tys: &ForeignTypes) -> T\n     if tys.fn_sig.variadic {\n         Type::variadic_func(llargument_tys.as_slice(), &llreturn_ty)\n     } else {\n-        Type::func(llargument_tys.index(&FullRange), &llreturn_ty)\n+        Type::func(&llargument_tys[], &llreturn_ty)\n     }\n }\n "}, {"sha": "2219cd59263cc2648ecde6821500127d67e25735", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -161,7 +161,7 @@ pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Val\n \n     let (glue, new_sym) = match ccx.available_drop_glues().borrow().get(&t) {\n         Some(old_sym) => {\n-            let glue = decl_cdecl_fn(ccx, old_sym.index(&FullRange), llfnty, ty::mk_nil(ccx.tcx()));\n+            let glue = decl_cdecl_fn(ccx, &old_sym[], llfnty, ty::mk_nil(ccx.tcx()));\n             (glue, None)\n         },\n         None => {\n@@ -233,8 +233,8 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             assert!(sig.inputs.len() == 1);\n             sig.inputs[0]\n         }\n-        _ => bcx.sess().bug(format!(\"Expected function type, found {}\",\n-                                    bcx.ty_to_string(fty)).index(&FullRange))\n+        _ => bcx.sess().bug(&format!(\"Expected function type, found {}\",\n+                                    bcx.ty_to_string(fty))[])\n     };\n \n     let (struct_data, info) = if type_is_sized(bcx.tcx(), t) {\n@@ -295,7 +295,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      class_did,\n                                      &[get_drop_glue_type(bcx.ccx(), t)],\n                                      ty::mk_nil(bcx.tcx()));\n-        let (_, variant_cx) = invoke(variant_cx, dtor_addr, args.index(&FullRange), dtor_ty, None);\n+        let (_, variant_cx) = invoke(variant_cx, dtor_addr, &args[], dtor_ty, None);\n \n         variant_cx.fcx.pop_and_trans_custom_cleanup_scope(variant_cx, field_scope);\n         variant_cx\n@@ -353,8 +353,8 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n             let unit_size = llsize_of_alloc(bcx.ccx(), llunit_ty);\n             (Mul(bcx, info, C_uint(bcx.ccx(), unit_size)), C_uint(bcx.ccx(), 8u))\n         }\n-        _ => bcx.sess().bug(format!(\"Unexpected unsized type, found {}\",\n-                                    bcx.ty_to_string(t)).index(&FullRange))\n+        _ => bcx.sess().bug(&format!(\"Unexpected unsized type, found {}\",\n+                                    bcx.ty_to_string(t))[])\n     }\n }\n \n@@ -423,10 +423,10 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                     } else {\n                         // Give the user a heads up that we are doing something\n                         // stupid and dangerous.\n-                        bcx.sess().warn(format!(\"Ignoring drop flag in destructor for {}\\\n+                        bcx.sess().warn(&format!(\"Ignoring drop flag in destructor for {}\\\n                                                  because the struct is unsized. See issue\\\n                                                  #16758\",\n-                                                bcx.ty_to_string(t)).index(&FullRange));\n+                                                bcx.ty_to_string(t))[]);\n                         trans_struct_drop(bcx, t, v0, dtor, did, substs)\n                     }\n                 }\n@@ -496,7 +496,7 @@ pub fn declare_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n     note_unique_llvm_symbol(ccx, name);\n \n     let ty_name = token::intern_and_get_ident(\n-        ppaux::ty_to_string(ccx.tcx(), t).index(&FullRange));\n+        &ppaux::ty_to_string(ccx.tcx(), t)[]);\n     let ty_name = C_str_slice(ccx, ty_name);\n \n     debug!(\"--- declare_tydesc {}\", ppaux::ty_to_string(ccx.tcx(), t));\n@@ -515,8 +515,8 @@ fn declare_generic_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n     let fn_nm = mangle_internal_name_by_type_and_seq(\n         ccx,\n         t,\n-        format!(\"glue_{}\", name).index(&FullRange));\n-    let llfn = decl_cdecl_fn(ccx, fn_nm.index(&FullRange), llfnty, ty::mk_nil(ccx.tcx()));\n+        &format!(\"glue_{}\", name)[]);\n+    let llfn = decl_cdecl_fn(ccx, &fn_nm[], llfnty, ty::mk_nil(ccx.tcx()));\n     note_unique_llvm_symbol(ccx, fn_nm.clone());\n     return (fn_nm, llfn);\n }"}, {"sha": "7ac062108f3fb2c2f14d141ab2c07fadbdb19e89", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -77,7 +77,7 @@ pub fn trans_impl(ccx: &CrateContext,\n         match *impl_item {\n             ast::MethodImplItem(ref method) => {\n                 if method.pe_generics().ty_params.len() == 0u {\n-                    let trans_everywhere = attr::requests_inline(method.attrs.index(&FullRange));\n+                    let trans_everywhere = attr::requests_inline(&method.attrs[]);\n                     for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n                         let llfn = get_item_val(ccx, method.id);\n                         trans_fn(ccx,\n@@ -229,7 +229,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // Here, in this call, which I've written with explicit UFCS\n     // notation, the set of type parameters will be:\n     //\n-    //     rcvr_type: .index(&FullRange) <-- nothing declared on the trait itself\n+    //     rcvr_type: [] <-- nothing declared on the trait itself\n     //     rcvr_self: [Vec<int>] <-- the self type\n     //     rcvr_method: [String] <-- method type parameter\n     //\n@@ -268,11 +268,11 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             //\n             // Recall that we matched `<Vec<int> as Convert>`. Trait\n             // resolution will have given us a substitution\n-            // containing `impl_substs=[[T=int],.index(&FullRange),.index(&FullRange)]` (the type\n+            // containing `impl_substs=[[T=int],[],[]]` (the type\n             // parameters defined on the impl). We combine\n             // that with the `rcvr_method` from before, which tells us\n             // the type parameters from the *method*, to yield\n-            // `callee_substs=[[T=int],.index(&FullRange),[U=String]]`.\n+            // `callee_substs=[[T=int],[],[U=String]]`.\n             let subst::SeparateVecsPerParamSpace {\n                 types: impl_type,\n                 selfs: impl_self,\n@@ -289,8 +289,8 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      callee_substs)\n         }\n         _ => {\n-            tcx.sess.bug(format!(\"static call to invalid vtable: {}\",\n-                                 vtbl.repr(tcx)).index(&FullRange));\n+            tcx.sess.bug(&format!(\"static call to invalid vtable: {}\",\n+                                 vtbl.repr(tcx))[]);\n         }\n     }\n }\n@@ -377,8 +377,8 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         traits::VtableBuiltin(..) |\n         traits::VtableParam(..) => {\n             bcx.sess().bug(\n-                format!(\"resolved vtable bad vtable {} in trans\",\n-                        vtable.repr(bcx.tcx())).index(&FullRange));\n+                &format!(\"resolved vtable bad vtable {} in trans\",\n+                        vtable.repr(bcx.tcx()))[]);\n         }\n     }\n }\n@@ -738,9 +738,9 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n             traits::VtableParam => {\n                 bcx.sess().bug(\n-                    format!(\"resolved vtable for {} to bad vtable {} in trans\",\n+                    &format!(\"resolved vtable for {} to bad vtable {} in trans\",\n                             trait_ref.repr(bcx.tcx()),\n-                            vtable.repr(bcx.tcx())).index(&FullRange));\n+                            vtable.repr(bcx.tcx()))[]);\n             }\n         }\n     });\n@@ -772,7 +772,7 @@ pub fn make_vtable<I: Iterator<Item=ValueRef>>(ccx: &CrateContext,\n     let components: Vec<_> = head.into_iter().chain(ptrs).collect();\n \n     unsafe {\n-        let tbl = C_struct(ccx, components.index(&FullRange), false);\n+        let tbl = C_struct(ccx, &components[], false);\n         let sym = token::gensym(\"vtable\");\n         let buf = CString::from_vec(format!(\"vtable{}\", sym.uint()).into_bytes());\n         let vt_gvar = llvm::LLVMAddGlobal(ccx.llmod(), val_ty(tbl).to_ref(),"}, {"sha": "6d2288e913fb3f7d24465e13216a08e4ce396b6d", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -131,7 +131,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n         hash = format!(\"h{}\", state.finish());\n         ccx.tcx().map.with_path(fn_id.node, |path| {\n-            exported_name(path, hash.index(&FullRange))\n+            exported_name(path, &hash[])\n         })\n     };\n \n@@ -141,9 +141,9 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let mut hash_id = Some(hash_id);\n     let mut mk_lldecl = |&mut : abi: abi::Abi| {\n         let lldecl = if abi != abi::Rust {\n-            foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, s.index(&FullRange))\n+            foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, &s[])\n         } else {\n-            decl_internal_rust_fn(ccx, mono_ty, s.index(&FullRange))\n+            decl_internal_rust_fn(ccx, mono_ty, &s[])\n         };\n \n         ccx.monomorphized().borrow_mut().insert(hash_id.take().unwrap(), lldecl);\n@@ -177,12 +177,12 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                   ..\n               } => {\n                   let d = mk_lldecl(abi);\n-                  let needs_body = setup_lldecl(d, i.attrs.index(&FullRange));\n+                  let needs_body = setup_lldecl(d, &i.attrs[]);\n                   if needs_body {\n                       if abi != abi::Rust {\n                           foreign::trans_rust_fn_with_foreign_abi(\n                               ccx, &**decl, &**body, &[], d, psubsts, fn_id.node,\n-                              Some(hash.index(&FullRange)));\n+                              Some(&hash[]));\n                       } else {\n                           trans_fn(ccx, &**decl, &**body, d, psubsts, fn_id.node, &[]);\n                       }\n@@ -206,7 +206,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     trans_enum_variant(ccx,\n                                        parent,\n                                        &*v,\n-                                       args.index(&FullRange),\n+                                       &args[],\n                                        this_tv.disr_val,\n                                        psubsts,\n                                        d);\n@@ -220,7 +220,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             match *ii {\n                 ast::MethodImplItem(ref mth) => {\n                     let d = mk_lldecl(abi::Rust);\n-                    let needs_body = setup_lldecl(d, mth.attrs.index(&FullRange));\n+                    let needs_body = setup_lldecl(d, &mth.attrs[]);\n                     if needs_body {\n                         trans_fn(ccx,\n                                  mth.pe_fn_decl(),\n@@ -241,24 +241,24 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             match *method {\n                 ast::ProvidedMethod(ref mth) => {\n                     let d = mk_lldecl(abi::Rust);\n-                    let needs_body = setup_lldecl(d, mth.attrs.index(&FullRange));\n+                    let needs_body = setup_lldecl(d, &mth.attrs[]);\n                     if needs_body {\n                         trans_fn(ccx, mth.pe_fn_decl(), mth.pe_body(), d,\n                                  psubsts, mth.id, &[]);\n                     }\n                     d\n                 }\n                 _ => {\n-                    ccx.sess().bug(format!(\"can't monomorphize a {:?}\",\n-                                           map_node).index(&FullRange))\n+                    ccx.sess().bug(&format!(\"can't monomorphize a {:?}\",\n+                                           map_node)[])\n                 }\n             }\n         }\n         ast_map::NodeStructCtor(struct_def) => {\n             let d = mk_lldecl(abi::Rust);\n             set_inline_hint(d);\n             base::trans_tuple_struct(ccx,\n-                                     struct_def.fields.index(&FullRange),\n+                                     &struct_def.fields[],\n                                      struct_def.ctor_id.expect(\"ast-mapped tuple struct \\\n                                                                 didn't have a ctor id\"),\n                                      psubsts,\n@@ -275,8 +275,8 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ast_map::NodeBlock(..) |\n         ast_map::NodePat(..) |\n         ast_map::NodeLocal(..) => {\n-            ccx.sess().bug(format!(\"can't monomorphize a {:?}\",\n-                                   map_node).index(&FullRange))\n+            ccx.sess().bug(&format!(\"can't monomorphize a {:?}\",\n+                                   map_node)[])\n         }\n     };\n "}, {"sha": "e2ed275d4c0ccf278f25542f6159d0f3130678b5", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -103,7 +103,7 @@ impl Type {\n     }\n \n     pub fn int(ccx: &CrateContext) -> Type {\n-        match ccx.tcx().sess.target.target.target_pointer_width.index(&FullRange) {\n+        match &ccx.tcx().sess.target.target.target_pointer_width[] {\n             \"32\" => Type::i32(ccx),\n             \"64\" => Type::i64(ccx),\n             tws => panic!(\"Unsupported target word size for int: {}\", tws),"}, {"sha": "c908441e3662b686f8f2891495afa79431e5adc6", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -140,7 +140,7 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let input_tys = inputs.iter().map(|&arg_ty| type_of_explicit_arg(cx, arg_ty));\n     atys.extend(input_tys);\n \n-    Type::func(atys.index(&FullRange), &lloutputtype)\n+    Type::func(&atys[], &lloutputtype)\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n@@ -180,8 +180,8 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n \n     let llsizingty = match t.sty {\n         _ if !lltype_is_sized(cx.tcx(), t) => {\n-            cx.sess().bug(format!(\"trying to take the sizing type of {}, an unsized type\",\n-                                  ppaux::ty_to_string(cx.tcx(), t)).index(&FullRange))\n+            cx.sess().bug(&format!(\"trying to take the sizing type of {}, an unsized type\",\n+                                  ppaux::ty_to_string(cx.tcx(), t))[])\n         }\n \n         ty::ty_bool => Type::bool(cx),\n@@ -233,8 +233,8 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         }\n \n         ty::ty_projection(..) | ty::ty_infer(..) | ty::ty_param(..) | ty::ty_err(..) => {\n-            cx.sess().bug(format!(\"fictitious type {} in sizing_type_of()\",\n-                                  ppaux::ty_to_string(cx.tcx(), t)).index(&FullRange))\n+            cx.sess().bug(&format!(\"fictitious type {} in sizing_type_of()\",\n+                                  ppaux::ty_to_string(cx.tcx(), t))[])\n         }\n         ty::ty_vec(_, None) | ty::ty_trait(..) | ty::ty_str => panic!(\"unreachable\")\n     };\n@@ -313,7 +313,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           let repr = adt::represent_type(cx, t);\n           let tps = substs.types.get_slice(subst::TypeSpace);\n           let name = llvm_type_name(cx, an_enum, did, tps);\n-          adt::incomplete_type_of(cx, &*repr, name.index(&FullRange))\n+          adt::incomplete_type_of(cx, &*repr, &name[])\n       }\n       ty::ty_unboxed_closure(did, _, ref substs) => {\n           // Only create the named struct, but don't fill it in. We\n@@ -324,7 +324,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           // contents of the VecPerParamSpace to to construct the llvm\n           // name\n           let name = llvm_type_name(cx, an_unboxed_closure, did, substs.types.as_slice());\n-          adt::incomplete_type_of(cx, &*repr, name.index(&FullRange))\n+          adt::incomplete_type_of(cx, &*repr, &name[])\n       }\n \n       ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) | ty::ty_ptr(ty::mt{ty, ..}) => {\n@@ -380,7 +380,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n               let repr = adt::represent_type(cx, t);\n               let tps = substs.types.get_slice(subst::TypeSpace);\n               let name = llvm_type_name(cx, a_struct, did, tps);\n-              adt::incomplete_type_of(cx, &*repr, name.index(&FullRange))\n+              adt::incomplete_type_of(cx, &*repr, &name[])\n           }\n       }\n \n@@ -398,8 +398,8 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n               Type::struct_(cx, &[p_ty, type_of_unsize_info(cx, t)], false)\n           }\n           ty::ty_trait(..) => Type::opaque_trait(cx),\n-          _ => cx.sess().bug(format!(\"ty_open with sized type: {}\",\n-                                     ppaux::ty_to_string(cx.tcx(), t)).index(&FullRange))\n+          _ => cx.sess().bug(&format!(\"ty_open with sized type: {}\",\n+                                     ppaux::ty_to_string(cx.tcx(), t))[])\n       },\n \n       ty::ty_infer(..) => cx.sess().bug(\"type_of with ty_infer\"),"}, {"sha": "867d6f322d1edcf2a438dbec2f539942d3954668", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -193,11 +193,11 @@ pub fn opt_ast_region_to_region<'tcx>(\n                                     format!(\"`{}`\", name)\n                                 };\n \n-                                m.push_str(if n == 1 {\n+                                m.push_str(&(if n == 1 {\n                                     help_name\n                                 } else {\n                                     format!(\"one of {}'s {} elided lifetimes\", help_name, n)\n-                                }.index(&FullRange));\n+                                })[]);\n \n                                 if len == 2 && i == 0 {\n                                     m.push_str(\" or \");\n@@ -344,21 +344,21 @@ fn create_substs_for_ast_path<'tcx>(\n             \"expected\"\n         };\n         this.tcx().sess.span_fatal(span,\n-                                   format!(\"wrong number of type arguments: {} {}, found {}\",\n+                                   &format!(\"wrong number of type arguments: {} {}, found {}\",\n                                            expected,\n                                            required_ty_param_count,\n-                                           supplied_ty_param_count).index(&FullRange));\n+                                           supplied_ty_param_count)[]);\n     } else if supplied_ty_param_count > formal_ty_param_count {\n         let expected = if required_ty_param_count < formal_ty_param_count {\n             \"expected at most\"\n         } else {\n             \"expected\"\n         };\n         this.tcx().sess.span_fatal(span,\n-                                   format!(\"wrong number of type arguments: {} {}, found {}\",\n+                                   &format!(\"wrong number of type arguments: {} {}, found {}\",\n                                            expected,\n                                            formal_ty_param_count,\n-                                           supplied_ty_param_count).index(&FullRange));\n+                                           supplied_ty_param_count)[]);\n     }\n \n     let mut substs = Substs::new_type(types, regions);\n@@ -377,7 +377,7 @@ fn create_substs_for_ast_path<'tcx>(\n         }\n     }\n \n-    for param in ty_param_defs.index(&(supplied_ty_param_count..)).iter() {\n+    for param in ty_param_defs[supplied_ty_param_count..].iter() {\n         match param.default {\n             Some(default) => {\n                 // This is a default type parameter.\n@@ -556,8 +556,8 @@ pub fn instantiate_trait_ref<'tcx>(\n         _ => {\n             this.tcx().sess.span_fatal(\n                 ast_trait_ref.path.span,\n-                format!(\"`{}` is not a trait\",\n-                        ast_trait_ref.path.user_string(this.tcx())).index(&FullRange));\n+                &format!(\"`{}` is not a trait\",\n+                        ast_trait_ref.path.user_string(this.tcx()))[]);\n         }\n     }\n }\n@@ -825,8 +825,8 @@ pub fn ast_ty_to_builtin_ty<'tcx>(\n                     this.tcx()\n                         .sess\n                         .span_bug(ast_ty.span,\n-                                  format!(\"unbound path {}\",\n-                                          path.repr(this.tcx())).index(&FullRange))\n+                                  &format!(\"unbound path {}\",\n+                                          path.repr(this.tcx()))[])\n                 }\n                 Some(&d) => d\n             };\n@@ -847,8 +847,8 @@ pub fn ast_ty_to_builtin_ty<'tcx>(\n                         _ => {\n                             this.tcx().sess.span_bug(\n                                 path.span,\n-                                format!(\"converting `Box` to `{}`\",\n-                                        ty.repr(this.tcx())).index(&FullRange));\n+                                &format!(\"converting `Box` to `{}`\",\n+                                        ty.repr(this.tcx()))[]);\n                         }\n                     }\n                 }\n@@ -1068,14 +1068,14 @@ pub fn ast_ty_to_ty<'tcx>(\n                 ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty), None)\n             }\n             ast::TyObjectSum(ref ty, ref bounds) => {\n-                match ast_ty_to_trait_ref(this, rscope, &**ty, bounds.index(&FullRange)) {\n+                match ast_ty_to_trait_ref(this, rscope, &**ty, &bounds[]) {\n                     Ok((trait_ref, projection_bounds)) => {\n                         trait_ref_to_object_type(this,\n                                                  rscope,\n                                                  ast_ty.span,\n                                                  trait_ref,\n                                                  projection_bounds,\n-                                                 bounds.index(&FullRange))\n+                                                 &bounds[])\n                     }\n                     Err(ErrorReported) => {\n                         this.tcx().types.err\n@@ -1110,15 +1110,15 @@ pub fn ast_ty_to_ty<'tcx>(\n                 ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(bare_fn))\n             }\n             ast::TyPolyTraitRef(ref bounds) => {\n-                conv_ty_poly_trait_ref(this, rscope, ast_ty.span, bounds.index(&FullRange))\n+                conv_ty_poly_trait_ref(this, rscope, ast_ty.span, &bounds[])\n             }\n             ast::TyPath(ref path, id) => {\n                 let a_def = match tcx.def_map.borrow().get(&id) {\n                     None => {\n                         tcx.sess\n                            .span_bug(ast_ty.span,\n-                                     format!(\"unbound path {}\",\n-                                             path.repr(tcx)).index(&FullRange))\n+                                     &format!(\"unbound path {}\",\n+                                             path.repr(tcx))[])\n                     }\n                     Some(&d) => d\n                 };\n@@ -1156,8 +1156,8 @@ pub fn ast_ty_to_ty<'tcx>(\n                     }\n                     def::DefMod(id) => {\n                         tcx.sess.span_fatal(ast_ty.span,\n-                            format!(\"found module name used as a type: {}\",\n-                                    tcx.map.node_to_string(id.node)).index(&FullRange));\n+                            &format!(\"found module name used as a type: {}\",\n+                                    tcx.map.node_to_string(id.node))[]);\n                     }\n                     def::DefPrimTy(_) => {\n                         panic!(\"DefPrimTy arm missed in previous ast_ty_to_prim_ty call\");\n@@ -1166,7 +1166,7 @@ pub fn ast_ty_to_ty<'tcx>(\n                         let path_str = tcx.map.path_to_string(\n                             tcx.map.get_parent(trait_type_id.node));\n                         tcx.sess.span_err(ast_ty.span,\n-                                          format!(\"ambiguous associated \\\n+                                          &format!(\"ambiguous associated \\\n                                                    type; specify the type \\\n                                                    using the syntax `<Type \\\n                                                    as {}>::{}`\",\n@@ -1176,17 +1176,17 @@ pub fn ast_ty_to_ty<'tcx>(\n                                                           .last()\n                                                           .unwrap()\n                                                           .identifier)\n-                                                  .get()).index(&FullRange));\n+                                                  .get())[]);\n                         this.tcx().types.err\n                     }\n                     def::DefAssociatedPath(provenance, assoc_ident) => {\n                         associated_path_def_to_ty(this, ast_ty, provenance, assoc_ident.name)\n                     }\n                     _ => {\n                         tcx.sess.span_fatal(ast_ty.span,\n-                                            format!(\"found value name used \\\n+                                            &format!(\"found value name used \\\n                                                      as a type: {:?}\",\n-                                                    a_def).index(&FullRange));\n+                                                    a_def)[]);\n                     }\n                 }\n             }\n@@ -1212,9 +1212,9 @@ pub fn ast_ty_to_ty<'tcx>(\n                     Err(ref r) => {\n                         tcx.sess.span_fatal(\n                             ast_ty.span,\n-                            format!(\"expected constant expr for array \\\n+                            &format!(\"expected constant expr for array \\\n                                      length: {}\",\n-                                    *r).index(&FullRange));\n+                                    *r)[]);\n                     }\n                 }\n             }\n@@ -1336,7 +1336,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n     let input_params = if self_ty.is_some() {\n         decl.inputs.slice_from(1)\n     } else {\n-        decl.inputs.index(&FullRange)\n+        &decl.inputs[]\n     };\n     let input_tys = input_params.iter().map(|a| ty_of_arg(this, &rb, a, None));\n     let input_pats: Vec<String> = input_params.iter()\n@@ -1551,7 +1551,7 @@ fn conv_ty_poly_trait_ref<'tcx>(\n     ast_bounds: &[ast::TyParamBound])\n     -> Ty<'tcx>\n {\n-    let mut partitioned_bounds = partition_bounds(this.tcx(), span, ast_bounds.index(&FullRange));\n+    let mut partitioned_bounds = partition_bounds(this.tcx(), span, &ast_bounds[]);\n \n     let mut projection_bounds = Vec::new();\n     let main_trait_bound = if !partitioned_bounds.trait_bounds.is_empty() {\n@@ -1600,8 +1600,8 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n         let b = &trait_bounds[0];\n         this.tcx().sess.span_err(\n             b.trait_ref.path.span,\n-            format!(\"only the builtin traits can be used \\\n-                     as closure or object bounds\").index(&FullRange));\n+            &format!(\"only the builtin traits can be used \\\n+                     as closure or object bounds\")[]);\n     }\n \n     let region_bound = compute_region_bound(this,\n@@ -1673,8 +1673,8 @@ fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n     if derived_region_bounds.slice_from(1).iter().any(|r1| r != *r1) {\n         tcx.sess.span_err(\n             span,\n-            format!(\"ambiguous lifetime bound, \\\n-                     explicit lifetime bound required\").index(&FullRange));\n+            &format!(\"ambiguous lifetime bound, \\\n+                     explicit lifetime bound required\")[]);\n     }\n     return Some(r);\n }\n@@ -1700,7 +1700,7 @@ fn compute_region_bound<'tcx>(\n                 None => {\n                     this.tcx().sess.span_err(\n                         span,\n-                        format!(\"explicit lifetime bound required\").index(&FullRange));\n+                        &format!(\"explicit lifetime bound required\")[]);\n                     ty::ReStatic\n                 }\n             }"}, {"sha": "cacf9bb19d20faeabcedd73894b7b4ebe8bd7256", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -195,14 +195,6 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         ast::PatRegion(ref inner, mutbl) => {\n             let inner_ty = fcx.infcx().next_ty_var();\n \n-            // SNAP 9e4e524 remove this `if`-`else` entirely after next snapshot\n-            let mutbl = if mutbl == ast::MutImmutable {\n-                ty::deref(fcx.infcx().shallow_resolve(expected), true)\n-                   .map(|mt| mt.mutbl).unwrap_or(ast::MutImmutable)\n-            } else {\n-                mutbl\n-            };\n-\n             let mt = ty::mt { ty: inner_ty, mutbl: mutbl };\n             let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n             let rptr_ty = ty::mk_rptr(tcx, tcx.mk_region(region), mt);"}, {"sha": "7e72f300f417847ba7f071564d4710c5ae46d87a", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -314,8 +314,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             None => {\n                 self.tcx().sess.span_bug(\n                     self.span,\n-                    format!(\"self-type `{}` for ObjectPick never dereferenced to an object\",\n-                            self_ty.repr(self.tcx())).index(&FullRange))\n+                    &format!(\"self-type `{}` for ObjectPick never dereferenced to an object\",\n+                            self_ty.repr(self.tcx()))[])\n             }\n         }\n     }\n@@ -367,10 +367,10 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             Err(_) => {\n                 self.tcx().sess.span_bug(\n                     self.span,\n-                    format!(\n+                    &format!(\n                         \"{} was a subtype of {} but now is not?\",\n                         self_ty.repr(self.tcx()),\n-                        method_self_ty.repr(self.tcx())).index(&FullRange));\n+                        method_self_ty.repr(self.tcx()))[]);\n             }\n         }\n     }"}, {"sha": "bb000742def9290918c004e8273a133abfa136a5", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -264,19 +264,19 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                         _ => {\n                             fcx.tcx().sess.span_bug(\n                                 span,\n-                                format!(\n+                                &format!(\n                                     \"trait method is &self but first arg is: {}\",\n-                                    transformed_self_ty.repr(fcx.tcx())).index(&FullRange));\n+                                    transformed_self_ty.repr(fcx.tcx()))[]);\n                         }\n                     }\n                 }\n \n                 _ => {\n                     fcx.tcx().sess.span_bug(\n                         span,\n-                        format!(\n+                        &format!(\n                             \"unexpected explicit self type in operator method: {:?}\",\n-                            method_ty.explicit_self).index(&FullRange));\n+                            method_ty.explicit_self)[]);\n                 }\n             }\n         }\n@@ -329,8 +329,8 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // If the method has the name of a field, give a help note\n             if is_field {\n                 cx.sess.span_note(span,\n-                    format!(\"use `(s.{0})(...)` if you meant to call the \\\n-                            function stored in the `{0}` field\", method_ustring).index(&FullRange));\n+                    &format!(\"use `(s.{0})(...)` if you meant to call the \\\n+                            function stored in the `{0}` field\", method_ustring)[]);\n             }\n \n             if static_sources.len() > 0 {"}, {"sha": "36321e5e8c63c907ac7443a11eb0512853c7ca54", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -575,8 +575,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 None => {\n                     self.tcx().sess.span_bug(\n                         self.span,\n-                        format!(\"No entry for unboxed closure: {}\",\n-                                closure_def_id.repr(self.tcx())).index(&FullRange));\n+                        &format!(\"No entry for unboxed closure: {}\",\n+                                closure_def_id.repr(self.tcx()))[]);\n                 }\n             };\n \n@@ -745,15 +745,15 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         debug!(\"pick_method(self_ty={})\", self.infcx().ty_to_string(self_ty));\n \n         debug!(\"searching inherent candidates\");\n-        match self.consider_candidates(self_ty, self.inherent_candidates.index(&FullRange)) {\n+        match self.consider_candidates(self_ty, &self.inherent_candidates[]) {\n             None => {}\n             Some(pick) => {\n                 return Some(pick);\n             }\n         }\n \n         debug!(\"searching extension candidates\");\n-        self.consider_candidates(self_ty, self.extension_candidates.index(&FullRange))\n+        self.consider_candidates(self_ty, &self.extension_candidates[])\n     }\n \n     fn consider_candidates(&self,\n@@ -768,7 +768,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         debug!(\"applicable_candidates: {}\", applicable_candidates.repr(self.tcx()));\n \n         if applicable_candidates.len() > 1 {\n-            match self.collapse_candidates_to_trait_pick(applicable_candidates.index(&FullRange)) {\n+            match self.collapse_candidates_to_trait_pick(&applicable_candidates[]) {\n                 Some(pick) => { return Some(Ok(pick)); }\n                 None => { }\n             }\n@@ -864,7 +864,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             Some(data) => data,\n             None => return None,\n         };\n-        if probes.index(&(1..)).iter().any(|p| p.to_trait_data() != Some(trait_data)) {\n+        if probes[1..].iter().any(|p| p.to_trait_data() != Some(trait_data)) {\n             return None;\n         }\n "}, {"sha": "2b7f615dc1288c4f35614096258dfd926a51dbc1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -593,7 +593,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n     let tcx = ccx.tcx;\n     let err_count_on_creation = tcx.sess.err_count();\n \n-    let arg_tys = fn_sig.inputs.index(&FullRange);\n+    let arg_tys = &fn_sig.inputs[];\n     let ret_ty = fn_sig.output;\n \n     debug!(\"check_fn(arg_tys={}, ret_ty={}, fn_id={})\",\n@@ -691,7 +691,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n       ast::ItemEnum(ref enum_definition, _) => {\n         check_enum_variants(ccx,\n                             it.span,\n-                            enum_definition.variants.index(&FullRange),\n+                            &enum_definition.variants[],\n                             it.id);\n       }\n       ast::ItemFn(ref decl, _, _, _, ref body) => {\n@@ -985,21 +985,21 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         (&ty::StaticExplicitSelfCategory, _) => {\n             tcx.sess.span_err(\n                 impl_m_span,\n-                format!(\"method `{}` has a `{}` declaration in the impl, \\\n+                &format!(\"method `{}` has a `{}` declaration in the impl, \\\n                         but not in the trait\",\n                         token::get_name(trait_m.name),\n                         ppaux::explicit_self_category_to_str(\n-                            &impl_m.explicit_self)).index(&FullRange));\n+                            &impl_m.explicit_self))[]);\n             return;\n         }\n         (_, &ty::StaticExplicitSelfCategory) => {\n             tcx.sess.span_err(\n                 impl_m_span,\n-                format!(\"method `{}` has a `{}` declaration in the trait, \\\n+                &format!(\"method `{}` has a `{}` declaration in the trait, \\\n                         but not in the impl\",\n                         token::get_name(trait_m.name),\n                         ppaux::explicit_self_category_to_str(\n-                            &trait_m.explicit_self)).index(&FullRange));\n+                            &trait_m.explicit_self))[]);\n             return;\n         }\n         _ => {\n@@ -1358,9 +1358,9 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         if trait_params.len() != impl_params.len() {\n             tcx.sess.span_err(\n                 span,\n-                format!(\"lifetime parameters or bounds on method `{}` do \\\n+                &format!(\"lifetime parameters or bounds on method `{}` do \\\n                          not match the trait declaration\",\n-                        token::get_name(impl_m.name)).index(&FullRange));\n+                        token::get_name(impl_m.name))[]);\n             return false;\n         }\n \n@@ -1406,13 +1406,13 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             let err = if missing.len() != 0 || extra.len() != 0 {\n                 tcx.sess.span_err(\n                     span,\n-                    format!(\n+                    &format!(\n                         \"the lifetime parameter `{}` declared in the impl \\\n                          has a distinct set of bounds \\\n                          from its counterpart `{}` \\\n                          declared in the trait\",\n                         impl_param.name.user_string(tcx),\n-                        trait_param.name.user_string(tcx)).index(&FullRange));\n+                        trait_param.name.user_string(tcx))[]);\n                 true\n             } else {\n                 false\n@@ -1421,15 +1421,15 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             if missing.len() != 0 {\n                 tcx.sess.span_note(\n                     span,\n-                    format!(\"the impl is missing the following bounds: `{}`\",\n-                            missing.user_string(tcx)).index(&FullRange));\n+                    &format!(\"the impl is missing the following bounds: `{}`\",\n+                            missing.user_string(tcx))[]);\n             }\n \n             if extra.len() != 0 {\n                 tcx.sess.span_note(\n                     span,\n-                    format!(\"the impl has the following extra bounds: `{}`\",\n-                            extra.user_string(tcx)).index(&FullRange));\n+                    &format!(\"the impl has the following extra bounds: `{}`\",\n+                            extra.user_string(tcx))[]);\n             }\n \n             if err {\n@@ -1699,8 +1699,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             None => {\n                 self.tcx().sess.span_bug(\n                     span,\n-                    format!(\"no type for local variable {}\",\n-                            nid).index(&FullRange));\n+                    &format!(\"no type for local variable {}\",\n+                            nid)[]);\n             }\n         }\n     }\n@@ -1709,7 +1709,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// ! gets replaced with (), unconstrained ints with i32, and unconstrained floats with f64.\n     pub fn default_type_parameters(&self) {\n         use middle::ty::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat, Neither};\n-        for (_, &ref ty) in self.inh.node_types.borrow_mut().iter_mut() {\n+        for (_, &mut ref ty) in self.inh.node_types.borrow_mut().iter_mut() {\n             let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n             if self.infcx().type_var_diverges(resolved) {\n                 demand::eqtype(self, codemap::DUMMY_SP, *ty, ty::mk_nil(self.tcx()));\n@@ -2033,8 +2033,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match self.inh.node_types.borrow().get(&ex.id) {\n             Some(&t) => t,\n             None => {\n-                self.tcx().sess.bug(format!(\"no type for expr in fcx {}\",\n-                                            self.tag()).index(&FullRange));\n+                self.tcx().sess.bug(&format!(\"no type for expr in fcx {}\",\n+                                            self.tag())[]);\n             }\n         }\n     }\n@@ -2062,9 +2062,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(\n-                    format!(\"no type for node {}: {} in fcx {}\",\n+                    &format!(\"no type for node {}: {} in fcx {}\",\n                             id, self.tcx().map.node_to_string(id),\n-                            self.tag()).index(&FullRange));\n+                            self.tag())[]);\n             }\n         }\n     }\n@@ -2466,7 +2466,7 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         Ok(trait_did) => trait_did,\n         Err(ref err_string) => {\n             fcx.tcx().sess.span_err(iterator_expr.span,\n-                                    err_string.index(&FullRange));\n+                                    &err_string[]);\n             return fcx.tcx().types.err\n         }\n     };\n@@ -2490,10 +2490,10 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             if !ty::type_is_error(true_expr_type) {\n                 let ty_string = fcx.infcx().ty_to_string(true_expr_type);\n                 fcx.tcx().sess.span_err(iterator_expr.span,\n-                                        format!(\"`for` loop expression has type `{}` which does \\\n+                                        &format!(\"`for` loop expression has type `{}` which does \\\n                                                 not implement the `Iterator` trait; \\\n                                                 maybe try .iter()\",\n-                                                ty_string).index(&FullRange));\n+                                                ty_string)[]);\n             }\n             fcx.tcx().types.err\n         }\n@@ -2528,10 +2528,10 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 }\n                 _ => {\n                     fcx.tcx().sess.span_err(iterator_expr.span,\n-                                            format!(\"`next` method of the `Iterator` \\\n+                                            &format!(\"`next` method of the `Iterator` \\\n                                                     trait has an unexpected type `{}`\",\n                                                     fcx.infcx().ty_to_string(return_type))\n-                                            .index(&FullRange));\n+                                            []);\n                     fcx.tcx().types.err\n                 }\n             }\n@@ -2558,7 +2558,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n         check_argument_types(fcx,\n                              sp,\n-                             err_inputs.index(&FullRange),\n+                             &err_inputs[],\n                              args_no_rcvr,\n                              autoref_args,\n                              false,\n@@ -3010,7 +3010,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n \n         // Call the generic checker.\n-        let args: Vec<_> = args.index(&(1..)).iter().map(|x| x).collect();\n+        let args: Vec<_> = args[1..].iter().map(|x| x).collect();\n         let ret_ty = check_method_argument_types(fcx,\n                                                  method_name.span,\n                                                  fn_ty,\n@@ -3328,7 +3328,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     ty::ty_struct(base_id, substs) => {\n                         debug!(\"struct named {}\", ppaux::ty_to_string(tcx, base_t));\n                         let fields = ty::lookup_struct_fields(tcx, base_id);\n-                        lookup_field_ty(tcx, base_id, fields.index(&FullRange),\n+                        lookup_field_ty(tcx, base_id, &fields[],\n                                         field.node.name, &(*substs))\n                     }\n                     _ => None\n@@ -3391,7 +3391,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                         if tuple_like {\n                             debug!(\"tuple struct named {}\", ppaux::ty_to_string(tcx, base_t));\n                             let fields = ty::lookup_struct_fields(tcx, base_id);\n-                            lookup_tup_field_ty(tcx, base_id, fields.index(&FullRange),\n+                            lookup_tup_field_ty(tcx, base_id, &fields[],\n                                                 idx.node, &(*substs))\n                         } else {\n                             None\n@@ -3556,7 +3556,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                        class_id,\n                                        id,\n                                        fcx.ccx.tcx.mk_substs(struct_substs),\n-                                       class_fields.index(&FullRange),\n+                                       &class_fields[],\n                                        fields,\n                                        base_expr.is_none(),\n                                        None);\n@@ -3599,7 +3599,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                        variant_id,\n                                        id,\n                                        fcx.ccx.tcx.mk_substs(substitutions),\n-                                       variant_fields.index(&FullRange),\n+                                       &variant_fields[],\n                                        fields,\n                                        true,\n                                        Some(enum_id));\n@@ -4066,7 +4066,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let expected = expected.only_has_type();\n         let flds = expected.map_to_option(fcx, |ty| {\n             match ty.sty {\n-                ty::ty_tup(ref flds) => Some(flds.index(&FullRange)),\n+                ty::ty_tup(ref flds) => Some(&flds[]),\n                 _ => None\n             }\n         });\n@@ -4100,7 +4100,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let struct_id = match def {\n             Some(def::DefVariant(enum_id, variant_id, true)) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n-                                          variant_id, fields.index(&FullRange));\n+                                          variant_id, &fields[]);\n                 enum_id\n             }\n             Some(def::DefTrait(def_id)) => {\n@@ -4109,7 +4109,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     pprust::path_to_string(path));\n                 check_struct_fields_on_error(fcx,\n                                              id,\n-                                             fields.index(&FullRange),\n+                                             &fields[],\n                                              base_expr);\n                 def_id\n             },\n@@ -4122,7 +4122,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                  id,\n                                                  expr.span,\n                                                  struct_did,\n-                                                 fields.index(&FullRange),\n+                                                 &fields[],\n                                                  base_expr.as_ref().map(|e| &**e));\n                     }\n                     _ => {\n@@ -4131,7 +4131,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                             pprust::path_to_string(path));\n                         check_struct_fields_on_error(fcx,\n                                                      id,\n-                                                     fields.index(&FullRange),\n+                                                     &fields[],\n                                                      base_expr);\n                     }\n                 }\n@@ -4164,15 +4164,15 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     fcx.tcx()\n                        .sess\n                        .span_err(path.span,\n-                                 format!(\"structure constructor specifies a \\\n+                                 &format!(\"structure constructor specifies a \\\n                                          structure of type `{}`, but this \\\n                                          structure has type `{}`: {}\",\n                                          fcx.infcx()\n                                             .ty_to_string(type_and_substs.ty),\n                                          fcx.infcx()\n                                             .ty_to_string(\n                                                 actual_structure_type),\n-                                         type_error_description).index(&FullRange));\n+                                         type_error_description)[]);\n                     ty::note_and_explain_type_err(tcx, &type_error);\n                 }\n             }\n@@ -4847,7 +4847,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n     }\n \n     let hint = *ty::lookup_repr_hints(ccx.tcx, ast::DefId { krate: ast::LOCAL_CRATE, node: id })\n-                    .index(&FullRange).get(0).unwrap_or(&attr::ReprAny);\n+        [].get(0).unwrap_or(&attr::ReprAny);\n \n     if hint != attr::ReprAny && vs.len() <= 1 {\n         if vs.len() == 1 {\n@@ -5518,7 +5518,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"get_tydesc\" => {\n               let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {\n                   Ok(t) => t,\n-                  Err(s) => { tcx.sess.span_fatal(it.span, s.index(&FullRange)); }\n+                  Err(s) => { tcx.sess.span_fatal(it.span, &s[]); }\n               };\n               let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n                   ty: tydesc_ty,\n@@ -5534,7 +5534,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                                 ty::mk_struct(ccx.tcx, did,\n                                               ccx.tcx.mk_substs(subst::Substs::empty()))),\n                     Err(msg) => {\n-                        tcx.sess.span_fatal(it.span, msg.index(&FullRange));\n+                        tcx.sess.span_fatal(it.span, &msg[]);\n                     }\n                 }\n             },"}, {"sha": "112e00536422c2f26556addc082e2d29380c3771", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -188,8 +188,8 @@ fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n             }\n         }\n         _ => {\n-            tcx.sess.bug(format!(\"unexpected def in region_of_def: {:?}\",\n-                                 def).index(&FullRange))\n+            tcx.sess.bug(&format!(\"unexpected def in region_of_def: {:?}\",\n+                                 def)[])\n         }\n     }\n }\n@@ -282,13 +282,13 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             Some(f) => f,\n             None => {\n                 self.tcx().sess.bug(\n-                    format!(\"No fn-sig entry for id={}\", id).index(&FullRange));\n+                    &format!(\"No fn-sig entry for id={}\", id)[]);\n             }\n         };\n \n         let len = self.region_bound_pairs.len();\n-        self.relate_free_regions(fn_sig.index(&FullRange), body.id);\n-        link_fn_args(self, CodeExtent::from_node_id(body.id), fn_decl.inputs.index(&FullRange));\n+        self.relate_free_regions(&fn_sig[], body.id);\n+        link_fn_args(self, CodeExtent::from_node_id(body.id), &fn_decl.inputs[]);\n         self.visit_block(body);\n         self.visit_region_obligations(body.id);\n         self.region_bound_pairs.truncate(len);\n@@ -629,7 +629,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         }\n \n         ast::ExprMatch(ref discr, ref arms, _) => {\n-            link_match(rcx, &**discr, arms.index(&FullRange));\n+            link_match(rcx, &**discr, &arms[]);\n \n             visit::walk_expr(rcx, expr);\n         }\n@@ -953,8 +953,8 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 let (m, r) = match self_ty.sty {\n                     ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                     _ => rcx.tcx().sess.span_bug(deref_expr.span,\n-                            format!(\"bad overloaded deref type {}\",\n-                                    method.ty.repr(rcx.tcx())).index(&FullRange))\n+                            &format!(\"bad overloaded deref type {}\",\n+                                    method.ty.repr(rcx.tcx()))[])\n                 };\n                 {\n                     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n@@ -1318,9 +1318,9 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                 None => {\n                     rcx.tcx().sess.span_bug(\n                         span,\n-                        format!(\"Illegal upvar id: {}\",\n+                        &format!(\"Illegal upvar id: {}\",\n                                 upvar_id.repr(\n-                                    rcx.tcx())).index(&FullRange));\n+                                    rcx.tcx()))[]);\n                 }\n             }\n         }"}, {"sha": "8730858f66e7ced94b5c74ecc906b3517804ca87", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -146,8 +146,8 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n \n             ty::ty_open(_) => {\n                 self.tcx.sess.bug(\n-                    format!(\"Unexpected type encountered while doing wf check: {}\",\n-                            ty.repr(self.tcx)).index(&FullRange));\n+                    &format!(\"Unexpected type encountered while doing wf check: {}\",\n+                            ty.repr(self.tcx))[]);\n             }\n         }\n     }"}, {"sha": "3940092eb729100a2f579ad2c2a7e5ecc0864d46", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -72,17 +72,17 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         (_, &ty::ty_uniq(..)) => {\n             fcx.ccx.tcx.sess.span_err(\n                 source_expr.span,\n-                format!(\"can only cast an boxed pointer \\\n+                &format!(\"can only cast an boxed pointer \\\n                          to a boxed object, not a {}\",\n-                        ty::ty_sort_string(fcx.tcx(), source_ty)).index(&FullRange));\n+                        ty::ty_sort_string(fcx.tcx(), source_ty))[]);\n         }\n \n         (_, &ty::ty_rptr(..)) => {\n             fcx.ccx.tcx.sess.span_err(\n                 source_expr.span,\n-                format!(\"can only cast a &-pointer \\\n+                &format!(\"can only cast a &-pointer \\\n                          to an &-object, not a {}\",\n-                        ty::ty_sort_string(fcx.tcx(), source_ty)).index(&FullRange));\n+                        ty::ty_sort_string(fcx.tcx(), source_ty))[]);\n         }\n \n         _ => {"}, {"sha": "cb52795670f2e9a2f7cb031ea4822e46d71e466e", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -80,8 +80,8 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n             // that the user can type\n             inference_context.tcx.sess.span_bug(\n                 span,\n-                format!(\"coherence encountered unexpected type searching for base type: {}\",\n-                        ty.repr(inference_context.tcx)).index(&FullRange));\n+                &format!(\"coherence encountered unexpected type searching for base type: {}\",\n+                        ty.repr(inference_context.tcx))[]);\n         }\n     }\n }\n@@ -487,18 +487,18 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 Err(ty::FieldDoesNotImplementCopy(name)) => {\n                     tcx.sess\n                        .span_err(span,\n-                                 format!(\"the trait `Copy` may not be \\\n+                                 &format!(\"the trait `Copy` may not be \\\n                                           implemented for this type; field \\\n                                           `{}` does not implement `Copy`\",\n-                                         token::get_name(name)).index(&FullRange))\n+                                         token::get_name(name))[])\n                 }\n                 Err(ty::VariantDoesNotImplementCopy(name)) => {\n                     tcx.sess\n                        .span_err(span,\n-                                 format!(\"the trait `Copy` may not be \\\n+                                 &format!(\"the trait `Copy` may not be \\\n                                           implemented for this type; variant \\\n                                           `{}` does not implement `Copy`\",\n-                                         token::get_name(name)).index(&FullRange))\n+                                         token::get_name(name))[])\n                 }\n                 Err(ty::TypeIsStructural) => {\n                     tcx.sess"}, {"sha": "5902936ae30a1f17a0bcf01ad580ae4a8f2cf7e4", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -212,7 +212,7 @@ fn get_enum_variant_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let rs = ExplicitRscope;\n                 let input_tys: Vec<_> = args.iter().map(|va| ccx.to_ty(&rs, &*va.ty)).collect();\n-                ty::mk_ctor_fn(tcx, variant_def_id, input_tys.index(&FullRange), enum_ty)\n+                ty::mk_ctor_fn(tcx, variant_def_id, &input_tys[], enum_ty)\n             }\n \n             ast::TupleVariantKind(_) => {\n@@ -259,7 +259,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                     ccx,\n                                     trait_id,\n                                     &trait_def.generics,\n-                                    trait_items.index(&FullRange),\n+                                    &trait_items[],\n                                     &m.id,\n                                     &m.ident.name,\n                                     &m.explicit_self,\n@@ -273,7 +273,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                     ccx,\n                                     trait_id,\n                                     &trait_def.generics,\n-                                    trait_items.index(&FullRange),\n+                                    &trait_items[],\n                                     &m.id,\n                                     &m.pe_ident().name,\n                                     m.pe_explicit_self(),\n@@ -779,7 +779,7 @@ fn convert_struct<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                             local_def(field.node.id)].ty).collect();\n                 let ctor_fn_ty = ty::mk_ctor_fn(tcx,\n                                                 local_def(ctor_id),\n-                                                inputs.index(&FullRange),\n+                                                &inputs[],\n                                                 selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n                 tcx.tcache.borrow_mut().insert(local_def(ctor_id),\n@@ -819,8 +819,8 @@ fn get_trait_def<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     match ccx.tcx.map.get(trait_id.node) {\n         ast_map::NodeItem(item) => trait_def_of_item(ccx, &*item),\n         _ => {\n-            ccx.tcx.sess.bug(format!(\"get_trait_def({}): not an item\",\n-                                     trait_id.node).index(&FullRange))\n+            ccx.tcx.sess.bug(&format!(\"get_trait_def({}): not an item\",\n+                                     trait_id.node)[])\n         }\n     }\n }\n@@ -845,7 +845,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         ref s => {\n             tcx.sess.span_bug(\n                 it.span,\n-                format!(\"trait_def_of_item invoked on {:?}\", s).index(&FullRange));\n+                &format!(\"trait_def_of_item invoked on {:?}\", s)[]);\n         }\n     };\n \n@@ -1030,8 +1030,8 @@ fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                           -> ty::Generics<'tcx> {\n     ty_generics(ccx,\n                 subst::TypeSpace,\n-                generics.lifetimes.index(&FullRange),\n-                generics.ty_params.index(&FullRange),\n+                &generics.lifetimes[],\n+                &generics.ty_params[],\n                 ty::Generics::empty(),\n                 &generics.where_clause)\n }\n@@ -1049,8 +1049,8 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     let mut generics =\n         ty_generics(ccx,\n                     subst::TypeSpace,\n-                    ast_generics.lifetimes.index(&FullRange),\n-                    ast_generics.ty_params.index(&FullRange),\n+                    &ast_generics.lifetimes[],\n+                    &ast_generics.ty_params[],\n                     ty::Generics::empty(),\n                     &ast_generics.where_clause);\n \n@@ -1135,8 +1135,8 @@ fn ty_generics_for_fn_or_method<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n     ty_generics(ccx,\n                 subst::FnSpace,\n-                early_lifetimes.index(&FullRange),\n-                generics.ty_params.index(&FullRange),\n+                &early_lifetimes[],\n+                &generics.ty_params[],\n                 base_generics,\n                 &generics.where_clause)\n }\n@@ -1323,7 +1323,7 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     let param_ty = ty::ParamTy::new(space, index, param.ident.name);\n     let bounds = compute_bounds(ccx,\n                                 param_ty.to_ty(ccx.tcx),\n-                                param.bounds.index(&FullRange),\n+                                &param.bounds[],\n                                 SizedByDefault::Yes,\n                                 param.span);\n     let default = match param.default {\n@@ -1404,7 +1404,7 @@ fn check_bounds_compatible<'tcx>(tcx: &ty::ctxt<'tcx>,\n     if !param_bounds.builtin_bounds.contains(&ty::BoundSized) {\n         ty::each_bound_trait_and_supertraits(\n             tcx,\n-            param_bounds.trait_bounds.index(&FullRange),\n+            &param_bounds.trait_bounds[],\n             |trait_ref| {\n                 let trait_def = ty::lookup_trait_def(tcx, trait_ref.def_id());\n                 if trait_def.bounds.builtin_bounds.contains(&ty::BoundSized) {"}, {"sha": "d119885f1605e02e4f656ec257ea2aaa0bd40a66", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -191,10 +191,10 @@ fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n         Ok(_) => true,\n         Err(ref terr) => {\n             tcx.sess.span_err(span,\n-                              format!(\"{}: {}\",\n+                              &format!(\"{}: {}\",\n                                       msg(),\n                                       ty::type_err_to_str(tcx,\n-                                                          terr)).index(&FullRange));\n+                                                          terr))[]);\n             ty::note_and_explain_type_err(tcx, terr);\n             false\n         }\n@@ -240,10 +240,10 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n         }\n         _ => {\n             tcx.sess.span_bug(main_span,\n-                              format!(\"main has a non-function type: found \\\n+                              &format!(\"main has a non-function type: found \\\n                                        `{}`\",\n                                       ppaux::ty_to_string(tcx,\n-                                                       main_t)).index(&FullRange));\n+                                                       main_t))[]);\n         }\n     }\n }\n@@ -292,9 +292,9 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n         }\n         _ => {\n             tcx.sess.span_bug(start_span,\n-                              format!(\"start has a non-function type: found \\\n+                              &format!(\"start has a non-function type: found \\\n                                        `{}`\",\n-                                      ppaux::ty_to_string(tcx, start_t)).index(&FullRange));\n+                                      ppaux::ty_to_string(tcx, start_t))[]);\n         }\n     }\n }"}, {"sha": "b33921e07e8ddc444b9500e1e65acf687dd4fcc0", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -562,9 +562,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         match self.terms_cx.inferred_map.get(&param_id) {\n             Some(&index) => index,\n             None => {\n-                self.tcx().sess.bug(format!(\n+                self.tcx().sess.bug(&format!(\n                         \"no inferred index entry for {}\",\n-                        self.tcx().map.node_to_string(param_id)).index(&FullRange));\n+                        self.tcx().map.node_to_string(param_id))[]);\n             }\n         }\n     }\n@@ -837,9 +837,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::ty_infer(..) | ty::ty_err => {\n                 self.tcx().sess.bug(\n-                    format!(\"unexpected type encountered in \\\n+                    &format!(\"unexpected type encountered in \\\n                             variance inference: {}\",\n-                            ty.repr(self.tcx())).index(&FullRange));\n+                            ty.repr(self.tcx()))[]);\n             }\n         }\n     }\n@@ -917,9 +917,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // regions when visiting member types or method types.\n                 self.tcx()\n                     .sess\n-                    .bug(format!(\"unexpected region encountered in variance \\\n+                    .bug(&format!(\"unexpected region encountered in variance \\\n                                   inference: {}\",\n-                                 region.repr(self.tcx())).index(&FullRange));\n+                                 region.repr(self.tcx()))[]);\n             }\n         }\n     }\n@@ -1055,7 +1055,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             // attribute and report an error with various results if found.\n             if ty::has_attr(tcx, item_def_id, \"rustc_variance\") {\n                 let found = item_variances.repr(tcx);\n-                tcx.sess.span_err(tcx.map.span(item_id), found.index(&FullRange));\n+                tcx.sess.span_err(tcx.map.span(item_id), &found[]);\n             }\n \n             let newly_added = tcx.item_variance_map.borrow_mut()"}, {"sha": "d0e616aab62852011e42cb8af3fd57a55c30dda4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -800,7 +800,7 @@ impl Clean<Item> for ast::Method {\n         let all_inputs = &self.pe_fn_decl().inputs;\n         let inputs = match self.pe_explicit_self().node {\n             ast::SelfStatic => all_inputs.as_slice(),\n-            _ => all_inputs.index(&(1..))\n+            _ => &all_inputs[1..]\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n@@ -838,7 +838,7 @@ impl Clean<Item> for ast::TypeMethod {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inputs = match self.explicit_self.node {\n             ast::SelfStatic => self.decl.inputs.as_slice(),\n-            _ => self.decl.inputs.index(&(1..))\n+            _ => &self.decl.inputs[1..]\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n@@ -1134,7 +1134,7 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n                                                self.fty.sig.clone()),\n             s => {\n                 let sig = ty::Binder(ty::FnSig {\n-                    inputs: self.fty.sig.0.inputs.index(&(1..)).to_vec(),\n+                    inputs: self.fty.sig.0.inputs[1..].to_vec(),\n                     ..self.fty.sig.0.clone()\n                 });\n                 let s = match s {"}, {"sha": "2ae22b8fc0d81dd5b4eb95ba9ac007ccb6baf946", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -332,7 +332,7 @@ fn path<F, G>(w: &mut fmt::Formatter,\n         match rel_root {\n             Some(root) => {\n                 let mut root = String::from_str(root.as_slice());\n-                for seg in path.segments.index(&(0..amt)).iter() {\n+                for seg in path.segments[0..amt].iter() {\n                     if \"super\" == seg.name ||\n                             \"self\" == seg.name {\n                         try!(write!(w, \"{}::\", seg.name));\n@@ -347,7 +347,7 @@ fn path<F, G>(w: &mut fmt::Formatter,\n                 }\n             }\n             None => {\n-                for seg in path.segments.index(&(0..amt)).iter() {\n+                for seg in path.segments[0..amt].iter() {\n                     try!(write!(w, \"{}::\", seg.name));\n                 }\n             }"}, {"sha": "885017152de4f53ca1d8101ea6a9a986e813952e", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -34,7 +34,7 @@ pub fn highlight(src: &str, class: Option<&str>, id: Option<&str>) -> String {\n          class,\n          id,\n          &mut out).unwrap();\n-    String::from_utf8_lossy(out.index(&FullRange)).into_owned()\n+    String::from_utf8_lossy(&out[]).into_owned()\n }\n \n /// Exhausts the `lexer` writing the output into `out`."}, {"sha": "c6e90f3231343f41ef4b2ca6b10e279b32c42801", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -383,7 +383,7 @@ fn escape_str(wr: &mut fmt::Writer, v: &str) -> fmt::Result {\n         };\n \n         if start < i {\n-            try!(wr.write_str(v.index(&(start..i))));\n+            try!(wr.write_str(&v[start..i]));\n         }\n \n         try!(wr.write_str(escaped));\n@@ -392,7 +392,7 @@ fn escape_str(wr: &mut fmt::Writer, v: &str) -> fmt::Result {\n     }\n \n     if start != v.len() {\n-        try!(wr.write_str(v.index(&(start..))));\n+        try!(wr.write_str(&v[start..]));\n     }\n \n     wr.write_str(\"\\\"\")\n@@ -401,7 +401,7 @@ fn escape_str(wr: &mut fmt::Writer, v: &str) -> fmt::Result {\n fn escape_char(writer: &mut fmt::Writer, v: char) -> fmt::Result {\n     let mut buf = [0; 4];\n     let n = v.encode_utf8(&mut buf).unwrap();\n-    let buf = unsafe { str::from_utf8_unchecked(buf.index(&(0..n))) };\n+    let buf = unsafe { str::from_utf8_unchecked(&buf[0..n]) };\n     escape_str(writer, buf)\n }\n \n@@ -414,7 +414,7 @@ fn spaces(wr: &mut fmt::Writer, mut n: uint) -> fmt::Result {\n     }\n \n     if n > 0 {\n-        wr.write_str(BUF.index(&(0..n)))\n+        wr.write_str(&BUF[0..n])\n     } else {\n         Ok(())\n     }\n@@ -623,7 +623,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n             let mut check_encoder = Encoder::new(&mut buf);\n             try!(f(transmute(&mut check_encoder)));\n         }\n-        let out = str::from_utf8(buf.index(&FullRange)).unwrap();\n+        let out = str::from_utf8(&buf[]).unwrap();\n         let needs_wrapping = out.char_at(0) != '\"' && out.char_at_reverse(out.len()) != '\"';\n         if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n         try!(f(self));\n@@ -894,7 +894,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n             let mut check_encoder = PrettyEncoder::new(&mut buf);\n             try!(f(transmute(&mut check_encoder)));\n         }\n-        let out = str::from_utf8(buf.index(&FullRange)).unwrap();\n+        let out = str::from_utf8(&buf[]).unwrap();\n         let needs_wrapping = out.char_at(0) != '\"' && out.char_at_reverse(out.len()) != '\"';\n         if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n         try!(f(self));\n@@ -1027,7 +1027,7 @@ impl Json {\n     /// Returns None otherwise.\n     pub fn as_string<'a>(&'a self) -> Option<&'a str> {\n         match *self {\n-            Json::String(ref s) => Some(s.index(&FullRange)),\n+            Json::String(ref s) => Some(&s[]),\n             _ => None\n         }\n     }\n@@ -1137,7 +1137,7 @@ impl Index<uint> for Json {\n \n     fn index<'a>(&'a self, idx: &uint) -> &'a Json {\n         match self {\n-            &Json::Array(ref v) => v.index(idx),\n+            &Json::Array(ref v) => &v[*idx],\n             _ => panic!(\"can only index Json with uint if it is an array\")\n         }\n     }\n@@ -1222,7 +1222,7 @@ impl Stack {\n             InternalIndex(i) => StackElement::Index(i),\n             InternalKey(start, size) => {\n                 StackElement::Key(str::from_utf8(\n-                    self.str_buffer.index(&((start as uint) .. (start as uint + size as uint))))\n+                    &self.str_buffer[(start as uint) .. (start as uint + size as uint)])\n                         .unwrap())\n             }\n         }\n@@ -1265,7 +1265,7 @@ impl Stack {\n             Some(&InternalIndex(i)) => Some(StackElement::Index(i)),\n             Some(&InternalKey(start, size)) => {\n                 Some(StackElement::Key(str::from_utf8(\n-                    self.str_buffer.index(&((start as uint) .. (start+size) as uint))\n+                    &self.str_buffer[(start as uint) .. (start+size) as uint]\n                 ).unwrap()))\n             }\n         }\n@@ -2144,7 +2144,7 @@ impl ::Decoder for Decoder {\n                 return Err(ExpectedError(\"String or Object\".to_string(), format!(\"{}\", json)))\n             }\n         };\n-        let idx = match names.iter().position(|n| *n == name.index(&FullRange)) {\n+        let idx = match names.iter().position(|n| *n == &name[]) {\n             Some(idx) => idx,\n             None => return Err(UnknownVariantError(name))\n         };\n@@ -2511,7 +2511,6 @@ mod tests {\n     use std::{i64, u64, f32, f64, io};\n     use std::collections::BTreeMap;\n     use std::num::Float;\n-    use std::ops::Index;\n     use std::string;\n \n     #[derive(RustcDecodable, Eq, PartialEq, Show)]\n@@ -3353,7 +3352,7 @@ mod tests {\n         hm.insert(1, true);\n         let mut mem_buf = Vec::new();\n         write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n-        let json_str = from_utf8(mem_buf.index(&FullRange)).unwrap();\n+        let json_str = from_utf8(&mem_buf[]).unwrap();\n         match from_str(json_str) {\n             Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n             _ => {} // it parsed and we are good to go\n@@ -3369,7 +3368,7 @@ mod tests {\n         hm.insert(1, true);\n         let mut mem_buf = Vec::new();\n         write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n-        let json_str = from_utf8(mem_buf.index(&FullRange)).unwrap();\n+        let json_str = from_utf8(&mem_buf[]).unwrap();\n         match from_str(json_str) {\n             Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n             _ => {} // it parsed and we are good to go\n@@ -3409,7 +3408,7 @@ mod tests {\n             write!(&mut writer, \"{}\",\n                    super::as_pretty_json(&json).indent(i)).unwrap();\n \n-            let printed = from_utf8(writer.index(&FullRange)).unwrap();\n+            let printed = from_utf8(&writer[]).unwrap();\n \n             // Check for indents at each line\n             let lines: Vec<&str> = printed.lines().collect();"}, {"sha": "fe2d57486a88ec0e4d305c9679df347e220c4fa9", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -326,7 +326,7 @@ impl Encodable for str {\n \n impl Encodable for String {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(self.index(&FullRange))\n+        s.emit_str(&self[])\n     }\n }\n "}, {"sha": "dbc88ddf0a0404c131fb6779f7a61b54ecb4fb02", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -37,7 +37,7 @@ pub fn on_fail(obj: &(Any+Send), file: &'static str, line: uint) {\n     let msg = match obj.downcast_ref::<&'static str>() {\n         Some(s) => *s,\n         None => match obj.downcast_ref::<String>() {\n-            Some(s) => s.index(&FullRange),\n+            Some(s) => &s[],\n             None => \"Box<Any>\",\n         }\n     };"}, {"sha": "ba13bd05dc5dc1334879c128f18ed61d0c682799", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -15,7 +15,7 @@\n use cmp;\n use io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE, IoResult};\n use iter::{IteratorExt, ExactSizeIterator};\n-use ops::{Drop, Index};\n+use ops::Drop;\n use option::Option;\n use option::Option::{Some, None};\n use result::Result::Ok;\n@@ -97,7 +97,7 @@ impl<R: Reader> Buffer for BufferedReader<R> {\n             self.cap = try!(self.inner.read(self.buf.as_mut_slice()));\n             self.pos = 0;\n         }\n-        Ok(self.buf.index(&(self.pos..self.cap)))\n+        Ok(&self.buf[self.pos..self.cap])\n     }\n \n     fn consume(&mut self, amt: uint) {\n@@ -114,7 +114,7 @@ impl<R: Reader> Reader for BufferedReader<R> {\n         let nread = {\n             let available = try!(self.fill_buf());\n             let nread = cmp::min(available.len(), buf.len());\n-            slice::bytes::copy_memory(buf, available.index(&(0..nread)));\n+            slice::bytes::copy_memory(buf, &available[0..nread]);\n             nread\n         };\n         self.pos += nread;\n@@ -168,7 +168,7 @@ impl<W: Writer> BufferedWriter<W> {\n \n     fn flush_buf(&mut self) -> IoResult<()> {\n         if self.pos != 0 {\n-            let ret = self.inner.as_mut().unwrap().write(self.buf.index(&(0..self.pos)));\n+            let ret = self.inner.as_mut().unwrap().write(&self.buf[0..self.pos]);\n             self.pos = 0;\n             ret\n         } else {\n@@ -260,9 +260,9 @@ impl<W: Writer> Writer for LineBufferedWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         match buf.iter().rposition(|&b| b == b'\\n') {\n             Some(i) => {\n-                try!(self.inner.write(buf.index(&(0..(i + 1)))));\n+                try!(self.inner.write(&buf[0..(i + 1)]));\n                 try!(self.inner.flush());\n-                try!(self.inner.write(buf.index(&((i + 1)..))));\n+                try!(self.inner.write(&buf[(i + 1)..]));\n                 Ok(())\n             }\n             None => self.inner.write(buf),\n@@ -510,7 +510,7 @@ mod test {\n         assert_eq!(a, &w.get_ref()[]);\n         let w = w.into_inner();\n         let a: &[_] = &[0, 1];\n-        assert_eq!(a, w.index(&FullRange));\n+        assert_eq!(a, &w[]);\n     }\n \n     // This is just here to make sure that we don't infinite loop in the\n@@ -607,14 +607,14 @@ mod test {\n     #[test]\n     fn read_char_buffered() {\n         let buf = [195u8, 159u8];\n-        let mut reader = BufferedReader::with_capacity(1, buf.index(&FullRange));\n+        let mut reader = BufferedReader::with_capacity(1, &buf[]);\n         assert_eq!(reader.read_char(), Ok('\u00df'));\n     }\n \n     #[test]\n     fn test_chars() {\n         let buf = [195u8, 159u8, b'a'];\n-        let mut reader = BufferedReader::with_capacity(1, buf.index(&FullRange));\n+        let mut reader = BufferedReader::with_capacity(1, &buf[]);\n         let mut it = reader.chars();\n         assert_eq!(it.next(), Some(Ok('\u00df')));\n         assert_eq!(it.next(), Some(Ok('a')));"}, {"sha": "b578f4d5adcba81f5f84491abf8b60fa54256414", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -13,7 +13,6 @@ use cmp;\n use sync::mpsc::{Sender, Receiver};\n use io;\n use option::Option::{None, Some};\n-use ops::Index;\n use result::Result::{Ok, Err};\n use slice::{bytes, SliceExt};\n use super::{Buffer, Reader, Writer, IoResult};\n@@ -91,7 +90,7 @@ impl Reader for ChanReader {\n                 Some(src) => {\n                     let dst = buf.slice_from_mut(num_read);\n                     let count = cmp::min(src.len(), dst.len());\n-                    bytes::copy_memory(dst, src.index(&(0..count)));\n+                    bytes::copy_memory(dst, &src[0..count]);\n                     count\n                 },\n                 None => 0,"}, {"sha": "dbccc81c4cc72ea45a5fa218c43de82d4453259a", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -889,7 +889,7 @@ mod test {\n             let mut read_buf = [0; 1028];\n             let read_str = match check!(read_stream.read(&mut read_buf)) {\n                 -1|0 => panic!(\"shouldn't happen\"),\n-                n => str::from_utf8(read_buf.index(&(0..n))).unwrap().to_string()\n+                n => str::from_utf8(&read_buf[0..n]).unwrap().to_string()\n             };\n             assert_eq!(read_str.as_slice(), message);\n         }"}, {"sha": "c5e289398e0466bc5faa2fa9a2f5da4feb8b516a", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -13,7 +13,6 @@\n //! Readers and Writers for in-memory buffers\n \n use cmp::min;\n-use ops::Index;\n use option::Option::None;\n use result::Result::{Err, Ok};\n use io;\n@@ -160,7 +159,7 @@ impl Reader for MemReader {\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n-            let input = self.buf.index(&(self.pos.. (self.pos + write_len)));\n+            let input = &self.buf[self.pos.. (self.pos + write_len)];\n             let output = buf.slice_to_mut(write_len);\n             assert_eq!(input.len(), output.len());\n             slice::bytes::copy_memory(output, input);\n@@ -188,7 +187,7 @@ impl Buffer for MemReader {\n     #[inline]\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos < self.buf.len() {\n-            Ok(self.buf.index(&(self.pos..)))\n+            Ok(&self.buf[self.pos..])\n         } else {\n             Err(io::standard_error(io::EndOfFile))\n         }\n@@ -205,7 +204,7 @@ impl<'a> Reader for &'a [u8] {\n \n         let write_len = min(buf.len(), self.len());\n         {\n-            let input = self.index(&(0..write_len));\n+            let input = &self[0..write_len];\n             let output = buf.slice_to_mut(write_len);\n             slice::bytes::copy_memory(output, input);\n         }\n@@ -228,7 +227,7 @@ impl<'a> Buffer for &'a [u8] {\n \n     #[inline]\n     fn consume(&mut self, amt: uint) {\n-        *self = self.index(&(amt..));\n+        *self = &self[amt..];\n     }\n }\n \n@@ -287,7 +286,7 @@ impl<'a> Writer for BufWriter<'a> {\n \n             Ok(())\n         } else {\n-            slice::bytes::copy_memory(dst, src.index(&(0..dst_len)));\n+            slice::bytes::copy_memory(dst, &src[0..dst_len]);\n \n             self.pos += dst_len;\n \n@@ -350,7 +349,7 @@ impl<'a> Reader for BufReader<'a> {\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n-            let input = self.buf.index(&(self.pos.. (self.pos + write_len)));\n+            let input = &self.buf[self.pos.. (self.pos + write_len)];\n             let output = buf.slice_to_mut(write_len);\n             assert_eq!(input.len(), output.len());\n             slice::bytes::copy_memory(output, input);\n@@ -378,7 +377,7 @@ impl<'a> Buffer for BufReader<'a> {\n     #[inline]\n     fn fill_buf(&mut self) -> IoResult<&[u8]> {\n         if self.pos < self.buf.len() {\n-            Ok(self.buf.index(&(self.pos..)))\n+            Ok(&self.buf[self.pos..])\n         } else {\n             Err(io::standard_error(io::EndOfFile))\n         }\n@@ -393,7 +392,7 @@ mod test {\n     extern crate \"test\" as test_crate;\n     use io::{SeekSet, SeekCur, SeekEnd, Reader, Writer, Seek};\n     use prelude::v1::{Ok, Err, range,  Vec, Buffer,  AsSlice, SliceExt};\n-    use prelude::v1::{IteratorExt, Index};\n+    use prelude::v1::IteratorExt;\n     use io;\n     use iter::repeat;\n     use self::test_crate::Bencher;\n@@ -499,7 +498,7 @@ mod test {\n         assert_eq!(buf, b);\n         assert_eq!(reader.read(&mut buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n-        assert_eq!(buf.index(&(0..3)), b);\n+        assert_eq!(&buf[0..3], b);\n         assert!(reader.read(&mut buf).is_err());\n         let mut reader = MemReader::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n@@ -525,7 +524,7 @@ mod test {\n         assert_eq!(buf.as_slice(), b);\n         assert_eq!(reader.read(&mut buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n-        assert_eq!(buf.index(&(0..3)), b);\n+        assert_eq!(&buf[0..3], b);\n         assert!(reader.read(&mut buf).is_err());\n         let mut reader = &mut in_buf.as_slice();\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n@@ -552,7 +551,7 @@ mod test {\n         assert_eq!(buf, b);\n         assert_eq!(reader.read(&mut buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n-        assert_eq!(buf.index(&(0..3)), b);\n+        assert_eq!(&buf[0..3], b);\n         assert!(reader.read(&mut buf).is_err());\n         let mut reader = BufReader::new(in_buf.as_slice());\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));"}, {"sha": "c71ab514695da91e7495813af1ead9d6ba1d6e72", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -236,7 +236,7 @@ use int;\n use iter::{Iterator, IteratorExt};\n use marker::Sized;\n use mem::transmute;\n-use ops::{FnOnce, Index};\n+use ops::FnOnce;\n use option::Option;\n use option::Option::{Some, None};\n use os;\n@@ -1069,7 +1069,7 @@ pub trait Writer {\n     fn write_char(&mut self, c: char) -> IoResult<()> {\n         let mut buf = [0u8; 4];\n         let n = c.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n-        self.write(buf.index(&(0..n)))\n+        self.write(&buf[0..n])\n     }\n \n     /// Write the result of passing n through `int::to_str_bytes`.\n@@ -1454,7 +1454,7 @@ pub trait Buffer: Reader {\n                 };\n                 match available.iter().position(|&b| b == byte) {\n                     Some(i) => {\n-                        res.push_all(available.index(&(0..(i + 1))));\n+                        res.push_all(&available[0..(i + 1)]);\n                         used = i + 1;\n                         break\n                     }\n@@ -1493,7 +1493,7 @@ pub trait Buffer: Reader {\n                 }\n             }\n         }\n-        match str::from_utf8(buf.index(&(0..width))).ok() {\n+        match str::from_utf8(&buf[0..width]).ok() {\n             Some(s) => Ok(s.char_at(0)),\n             None => Err(standard_error(InvalidInput))\n         }"}, {"sha": "d09afea94dcc1023827c4157f49062bd69e04195", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -22,7 +22,7 @@ use fmt;\n use io::{self, IoResult, IoError};\n use io::net;\n use iter::{Iterator, IteratorExt};\n-use ops::{FnOnce, FnMut, Index};\n+use ops::{FnOnce, FnMut};\n use option::Option;\n use option::Option::{None, Some};\n use result::Result::{Ok, Err};\n@@ -313,7 +313,7 @@ impl<'a> Parser<'a> {\n \n         let mut tail = [0u16; 8];\n         let (tail_size, _) = read_groups(self, &mut tail, 8 - head_size);\n-        Some(ipv6_addr_from_head_tail(head.index(&(0..head_size)), tail.index(&(0..tail_size))))\n+        Some(ipv6_addr_from_head_tail(&head[0..head_size], &tail[0..tail_size]))\n     }\n \n     fn read_ipv6_addr(&mut self) -> Option<IpAddr> {"}, {"sha": "5a7219495f56264833faa6df1b07ca7ed7b292bf", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -59,7 +59,7 @@ impl<R: Reader> Reader for LimitReader<R> {\n impl<R: Buffer> Buffer for LimitReader<R> {\n     fn fill_buf<'a>(&'a mut self) -> io::IoResult<&'a [u8]> {\n         let amt = try!(self.inner.fill_buf());\n-        let buf = amt.index(&(0..cmp::min(amt.len(), self.limit)));\n+        let buf = &amt[0..cmp::min(amt.len(), self.limit)];\n         if buf.len() == 0 {\n             Err(io::standard_error(io::EndOfFile))\n         } else {\n@@ -220,7 +220,7 @@ impl<R: Reader, W: Writer> TeeReader<R, W> {\n impl<R: Reader, W: Writer> Reader for TeeReader<R, W> {\n     fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n         self.reader.read(buf).and_then(|len| {\n-            self.writer.write(buf.index_mut(&(0..len))).map(|()| len)\n+            self.writer.write(&mut buf[0..len]).map(|()| len)\n         })\n     }\n }\n@@ -234,7 +234,7 @@ pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> {\n             Err(ref e) if e.kind == io::EndOfFile => return Ok(()),\n             Err(e) => return Err(e),\n         };\n-        try!(w.write(buf.index(&(0..len))));\n+        try!(w.write(&buf[0..len]));\n     }\n }\n "}, {"sha": "b474ae4e37195b78bb4b3376edbac6b36c751a8f", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -68,7 +68,7 @@ use fmt;\n use iter::IteratorExt;\n use option::Option;\n use option::Option::{None, Some};\n-use ops::{FullRange, Index};\n+use ops::FullRange;\n use str;\n use str::StrExt;\n use string::{String, CowString};\n@@ -352,7 +352,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                 match name.rposition_elem(&dot) {\n                     None | Some(0) => name,\n                     Some(1) if name == b\"..\" => name,\n-                    Some(pos) => name.index(&(0..pos))\n+                    Some(pos) => &name[0..pos]\n                 }\n             })\n         }\n@@ -399,7 +399,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                 match name.rposition_elem(&dot) {\n                     None | Some(0) => None,\n                     Some(1) if name == b\"..\" => None,\n-                    Some(pos) => Some(name.index(&((pos+1)..)))\n+                    Some(pos) => Some(&name[(pos+1)..])\n                 }\n             }\n         }\n@@ -475,7 +475,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             let extlen = extension.container_as_bytes().len();\n             match (name.rposition_elem(&dot), extlen) {\n                 (None, 0) | (Some(0), 0) => None,\n-                (Some(idx), 0) => Some(name.index(&(0..idx)).to_vec()),\n+                (Some(idx), 0) => Some(name[0..idx].to_vec()),\n                 (idx, extlen) => {\n                     let idx = match idx {\n                         None | Some(0) => name.len(),\n@@ -484,7 +484,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n \n                     let mut v;\n                     v = Vec::with_capacity(idx + extlen + 1);\n-                    v.push_all(name.index(&(0..idx)));\n+                    v.push_all(&name[0..idx]);\n                     v.push(dot);\n                     v.push_all(extension.container_as_bytes());\n                     Some(v)\n@@ -876,7 +876,7 @@ impl BytesContainer for String {\n     }\n     #[inline]\n     fn container_as_str(&self) -> Option<&str> {\n-        Some(self.index(&FullRange))\n+        Some(&self[])\n     }\n     #[inline]\n     fn is_str(_: Option<&String>) -> bool { true }\n@@ -892,7 +892,7 @@ impl BytesContainer for [u8] {\n impl BytesContainer for Vec<u8> {\n     #[inline]\n     fn container_as_bytes(&self) -> &[u8] {\n-        self.index(&FullRange)\n+        &self[]\n     }\n }\n "}, {"sha": "293696d5ccada853d2393f525e3460527d3fa89e", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -17,7 +17,6 @@ use hash;\n use io::Writer;\n use iter::{AdditiveIterator, Extend};\n use iter::{Iterator, IteratorExt, Map};\n-use ops::Index;\n use marker::Sized;\n use option::Option::{self, Some, None};\n use slice::{AsSlice, Split, SliceExt, SliceConcatExt};\n@@ -127,7 +126,7 @@ impl GenericPathUnsafe for Path {\n             None => {\n                 self.repr = Path::normalize(filename);\n             }\n-            Some(idx) if self.repr.index(&((idx+1)..)) == b\"..\" => {\n+            Some(idx) if &self.repr[(idx+1)..] == b\"..\" => {\n                 let mut v = Vec::with_capacity(self.repr.len() + 1 + filename.len());\n                 v.push_all(self.repr.as_slice());\n                 v.push(SEP_BYTE);\n@@ -137,7 +136,7 @@ impl GenericPathUnsafe for Path {\n             }\n             Some(idx) => {\n                 let mut v = Vec::with_capacity(idx + 1 + filename.len());\n-                v.push_all(self.repr.index(&(0..(idx+1))));\n+                v.push_all(&self.repr[0..(idx+1)]);\n                 v.push_all(filename);\n                 // FIXME: this is slow\n                 self.repr = Path::normalize(v.as_slice());\n@@ -178,9 +177,9 @@ impl GenericPath for Path {\n         match self.sepidx {\n             None if b\"..\" == self.repr => self.repr.as_slice(),\n             None => dot_static,\n-            Some(0) => self.repr.index(&(0..1)),\n-            Some(idx) if self.repr.index(&((idx+1)..)) == b\"..\" => self.repr.as_slice(),\n-            Some(idx) => self.repr.index(&(0..idx))\n+            Some(0) => &self.repr[0..1],\n+            Some(idx) if &self.repr[(idx+1)..] == b\"..\" => self.repr.as_slice(),\n+            Some(idx) => &self.repr[0..idx]\n         }\n     }\n \n@@ -189,9 +188,9 @@ impl GenericPath for Path {\n             None if b\".\" == self.repr ||\n                 b\"..\" == self.repr => None,\n             None => Some(self.repr.as_slice()),\n-            Some(idx) if self.repr.index(&((idx+1)..)) == b\"..\" => None,\n-            Some(0) if self.repr.index(&(1..)).is_empty() => None,\n-            Some(idx) => Some(self.repr.index(&((idx+1)..)))\n+            Some(idx) if &self.repr[(idx+1)..] == b\"..\" => None,\n+            Some(0) if self.repr[1..].is_empty() => None,\n+            Some(idx) => Some(&self.repr[(idx+1)..])\n         }\n     }\n \n@@ -333,7 +332,7 @@ impl Path {\n         // borrowck is being very picky\n         let val = {\n             let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == SEP_BYTE;\n-            let v_ = if is_abs { v.as_slice().index(&(1..)) } else { v.as_slice() };\n+            let v_ = if is_abs { &v.as_slice()[1..] } else { v.as_slice() };\n             let comps = normalize_helper(v_, is_abs);\n             match comps {\n                 None => None,\n@@ -372,7 +371,7 @@ impl Path {\n     /// A path of \"/\" yields no components. A path of \".\" yields one component.\n     pub fn components<'a>(&'a self) -> Components<'a> {\n         let v = if self.repr[0] == SEP_BYTE {\n-            self.repr.index(&(1..))\n+            &self.repr[1..]\n         } else { self.repr.as_slice() };\n         let is_sep_byte: fn(&u8) -> bool = is_sep_byte; // coerce to fn ptr\n         let mut ret = v.split(is_sep_byte);"}, {"sha": "2a1f1794e49e7c059342940d02c006b9f17fffd7", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 63, "deletions": 64, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -25,7 +25,7 @@ use iter::{AdditiveIterator, Extend};\n use iter::{Iterator, IteratorExt, Map, repeat};\n use mem;\n use option::Option::{self, Some, None};\n-use ops::{FullRange, Index};\n+use ops::FullRange;\n use slice::{SliceExt, SliceConcatExt};\n use str::{SplitTerminator, FromStr, StrExt};\n use string::{String, ToString};\n@@ -173,30 +173,30 @@ impl GenericPathUnsafe for Path {\n                 s.push_str(\"..\");\n                 s.push(SEP);\n                 s.push_str(filename);\n-                self.update_normalized(s.index(&FullRange));\n+                self.update_normalized(&s[]);\n             }\n             None => {\n                 self.update_normalized(filename);\n             }\n-            Some((_,idxa,end)) if self.repr.index(&(idxa..end)) == \"..\" => {\n+            Some((_,idxa,end)) if &self.repr[idxa..end] == \"..\" => {\n                 let mut s = String::with_capacity(end + 1 + filename.len());\n-                s.push_str(self.repr.index(&(0..end)));\n+                s.push_str(&self.repr[0..end]);\n                 s.push(SEP);\n                 s.push_str(filename);\n-                self.update_normalized(s.index(&FullRange));\n+                self.update_normalized(&s[]);\n             }\n             Some((idxb,idxa,_)) if self.prefix == Some(DiskPrefix) && idxa == self.prefix_len() => {\n                 let mut s = String::with_capacity(idxb + filename.len());\n-                s.push_str(self.repr.index(&(0..idxb)));\n+                s.push_str(&self.repr[0..idxb]);\n                 s.push_str(filename);\n-                self.update_normalized(s.index(&FullRange));\n+                self.update_normalized(&s[]);\n             }\n             Some((idxb,_,_)) => {\n                 let mut s = String::with_capacity(idxb + 1 + filename.len());\n-                s.push_str(self.repr.index(&(0..idxb)));\n+                s.push_str(&self.repr[0..idxb]);\n                 s.push(SEP);\n                 s.push_str(filename);\n-                self.update_normalized(s.index(&FullRange));\n+                self.update_normalized(&s[]);\n             }\n         }\n     }\n@@ -215,12 +215,12 @@ impl GenericPathUnsafe for Path {\n         let path = path.container_as_str().unwrap();\n         fn is_vol_abs(path: &str, prefix: Option<PathPrefix>) -> bool {\n             // assume prefix is Some(DiskPrefix)\n-            let rest = path.index(&(prefix_len(prefix)..));\n+            let rest = &path[prefix_len(prefix)..];\n             !rest.is_empty() && rest.as_bytes()[0].is_ascii() && is_sep(rest.as_bytes()[0] as char)\n         }\n         fn shares_volume(me: &Path, path: &str) -> bool {\n             // path is assumed to have a prefix of Some(DiskPrefix)\n-            let repr = me.repr.index(&FullRange);\n+            let repr = &me.repr[];\n             match me.prefix {\n                 Some(DiskPrefix) => {\n                     repr.as_bytes()[0] == path.as_bytes()[0].to_ascii_uppercase()\n@@ -252,7 +252,7 @@ impl GenericPathUnsafe for Path {\n                         else { None };\n             let pathlen = path_.as_ref().map_or(path.len(), |p| p.len());\n             let mut s = String::with_capacity(me.repr.len() + 1 + pathlen);\n-            s.push_str(me.repr.index(&FullRange));\n+            s.push_str(&me.repr[]);\n             let plen = me.prefix_len();\n             // if me is \"C:\" we don't want to add a path separator\n             match me.prefix {\n@@ -264,17 +264,17 @@ impl GenericPathUnsafe for Path {\n             }\n             match path_ {\n                 None => s.push_str(path),\n-                Some(p) => s.push_str(p.index(&FullRange)),\n+                Some(p) => s.push_str(&p[]),\n             };\n-            me.update_normalized(s.index(&FullRange))\n+            me.update_normalized(&s[])\n         }\n \n         if !path.is_empty() {\n             let prefix = parse_prefix(path);\n             match prefix {\n                 Some(DiskPrefix) if !is_vol_abs(path, prefix) && shares_volume(self, path) => {\n                     // cwd-relative path, self is on the same volume\n-                    append_path(self, path.index(&(prefix_len(prefix)..)));\n+                    append_path(self, &path[prefix_len(prefix)..]);\n                 }\n                 Some(_) => {\n                     // absolute path, or cwd-relative and self is not same volume\n@@ -320,7 +320,7 @@ impl GenericPath for Path {\n     /// Always returns a `Some` value.\n     #[inline]\n     fn as_str<'a>(&'a self) -> Option<&'a str> {\n-        Some(self.repr.index(&FullRange))\n+        Some(&self.repr[])\n     }\n \n     #[inline]\n@@ -342,21 +342,21 @@ impl GenericPath for Path {\n     /// Always returns a `Some` value.\n     fn dirname_str<'a>(&'a self) -> Option<&'a str> {\n         Some(match self.sepidx_or_prefix_len() {\n-            None if \"..\" == self.repr => self.repr.index(&FullRange),\n+            None if \"..\" == self.repr => &self.repr[],\n             None => \".\",\n-            Some((_,idxa,end)) if self.repr.index(&(idxa..end)) == \"..\" => {\n-                self.repr.index(&FullRange)\n+            Some((_,idxa,end)) if &self.repr[idxa..end] == \"..\" => {\n+                &self.repr[]\n             }\n-            Some((idxb,_,end)) if self.repr.index(&(idxb..end)) == \"\\\\\" => {\n-                self.repr.index(&FullRange)\n+            Some((idxb,_,end)) if &self.repr[idxb..end] == \"\\\\\" => {\n+                &self.repr[]\n             }\n-            Some((0,idxa,_)) => self.repr.index(&(0..idxa)),\n+            Some((0,idxa,_)) => &self.repr[0..idxa],\n             Some((idxb,idxa,_)) => {\n                 match self.prefix {\n                     Some(DiskPrefix) | Some(VerbatimDiskPrefix) if idxb == self.prefix_len() => {\n-                        self.repr.index(&(0..idxa))\n+                        &self.repr[0..idxa]\n                     }\n-                    _ => self.repr.index(&(0..idxb))\n+                    _ => &self.repr[0..idxb]\n                 }\n             }\n         })\n@@ -370,13 +370,13 @@ impl GenericPath for Path {\n     /// See `GenericPath::filename_str` for info.\n     /// Always returns a `Some` value if `filename` returns a `Some` value.\n     fn filename_str<'a>(&'a self) -> Option<&'a str> {\n-        let repr = self.repr.index(&FullRange);\n+        let repr = &self.repr[];\n         match self.sepidx_or_prefix_len() {\n             None if \".\" == repr || \"..\" == repr => None,\n             None => Some(repr),\n-            Some((_,idxa,end)) if repr.index(&(idxa..end)) == \"..\" => None,\n+            Some((_,idxa,end)) if &repr[idxa..end] == \"..\" => None,\n             Some((_,idxa,end)) if idxa == end => None,\n-            Some((_,idxa,end)) => Some(repr.index(&(idxa..end)))\n+            Some((_,idxa,end)) => Some(&repr[idxa..end])\n         }\n     }\n \n@@ -408,7 +408,7 @@ impl GenericPath for Path {\n                 true\n             }\n             Some((idxb,idxa,end)) if idxb == idxa && idxb == end => false,\n-            Some((idxb,_,end)) if self.repr.index(&(idxb..end)) == \"\\\\\" => false,\n+            Some((idxb,_,end)) if &self.repr[idxb..end] == \"\\\\\" => false,\n             Some((idxb,idxa,_)) => {\n                 let trunc = match self.prefix {\n                     Some(DiskPrefix) | Some(VerbatimDiskPrefix) | None => {\n@@ -428,15 +428,15 @@ impl GenericPath for Path {\n         if self.prefix.is_some() {\n             Some(Path::new(match self.prefix {\n                 Some(DiskPrefix) if self.is_absolute() => {\n-                    self.repr.index(&(0..(self.prefix_len()+1)))\n+                    &self.repr[0..(self.prefix_len()+1)]\n                 }\n                 Some(VerbatimDiskPrefix) => {\n-                    self.repr.index(&(0..(self.prefix_len()+1)))\n+                    &self.repr[0..(self.prefix_len()+1)]\n                 }\n-                _ => self.repr.index(&(0..self.prefix_len()))\n+                _ => &self.repr[0..self.prefix_len()]\n             }))\n         } else if is_vol_relative(self) {\n-            Some(Path::new(self.repr.index(&(0..1))))\n+            Some(Path::new(&self.repr[0..1]))\n         } else {\n             None\n         }\n@@ -455,7 +455,7 @@ impl GenericPath for Path {\n     fn is_absolute(&self) -> bool {\n         match self.prefix {\n             Some(DiskPrefix) => {\n-                let rest = self.repr.index(&(self.prefix_len()..));\n+                let rest = &self.repr[self.prefix_len()..];\n                 rest.len() > 0 && rest.as_bytes()[0] == SEP_BYTE\n             }\n             Some(_) => true,\n@@ -630,15 +630,15 @@ impl Path {\n     /// Does not distinguish between absolute and cwd-relative paths, e.g.\n     /// C:\\foo and C:foo.\n     pub fn str_components<'a>(&'a self) -> StrComponents<'a> {\n-        let repr = self.repr.index(&FullRange);\n+        let repr = &self.repr[];\n         let s = match self.prefix {\n             Some(_) => {\n                 let plen = self.prefix_len();\n                 if repr.len() > plen && repr.as_bytes()[plen] == SEP_BYTE {\n-                    repr.index(&((plen+1)..))\n-                } else { repr.index(&(plen..)) }\n+                    &repr[(plen+1)..]\n+                } else { &repr[plen..] }\n             }\n-            None if repr.as_bytes()[0] == SEP_BYTE => repr.index(&(1..)),\n+            None if repr.as_bytes()[0] == SEP_BYTE => &repr[1..],\n             None => repr\n         };\n         let some: fn(&'a str) -> Option<&'a str> = Some; // coerce to fn ptr\n@@ -658,8 +658,8 @@ impl Path {\n     }\n \n     fn equiv_prefix(&self, other: &Path) -> bool {\n-        let s_repr = self.repr.index(&FullRange);\n-        let o_repr = other.repr.index(&FullRange);\n+        let s_repr = &self.repr[];\n+        let o_repr = &other.repr[];\n         match (self.prefix, other.prefix) {\n             (Some(DiskPrefix), Some(VerbatimDiskPrefix)) => {\n                 self.is_absolute() &&\n@@ -676,14 +676,14 @@ impl Path {\n                     o_repr.as_bytes()[4].to_ascii_lowercase()\n             }\n             (Some(UNCPrefix(_,_)), Some(VerbatimUNCPrefix(_,_))) => {\n-                s_repr.index(&(2..self.prefix_len())) == o_repr.index(&(8..other.prefix_len()))\n+                &s_repr[2..self.prefix_len()] == &o_repr[8..other.prefix_len()]\n             }\n             (Some(VerbatimUNCPrefix(_,_)), Some(UNCPrefix(_,_))) => {\n-                s_repr.index(&(8..self.prefix_len())) == o_repr.index(&(2..other.prefix_len()))\n+                &s_repr[8..self.prefix_len()] == &o_repr[2..other.prefix_len()]\n             }\n             (None, None) => true,\n             (a, b) if a == b => {\n-                s_repr.index(&(0..self.prefix_len())) == o_repr.index(&(0..other.prefix_len()))\n+                &s_repr[0..self.prefix_len()] == &o_repr[0..other.prefix_len()]\n             }\n             _ => false\n         }\n@@ -737,7 +737,7 @@ impl Path {\n                         match prefix.unwrap() {\n                             DiskPrefix => {\n                                 let len = prefix_len(prefix) + is_abs as uint;\n-                                let mut s = String::from_str(s.index(&(0..len)));\n+                                let mut s = String::from_str(&s[0..len]);\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n                                     v[0] = (*v)[0].to_ascii_uppercase();\n@@ -752,7 +752,7 @@ impl Path {\n                             }\n                             VerbatimDiskPrefix => {\n                                 let len = prefix_len(prefix) + is_abs as uint;\n-                                let mut s = String::from_str(s.index(&(0..len)));\n+                                let mut s = String::from_str(&s[0..len]);\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n                                     v[4] = (*v)[4].to_ascii_uppercase();\n@@ -762,14 +762,14 @@ impl Path {\n                             _ => {\n                                 let plen = prefix_len(prefix);\n                                 if s.len() > plen {\n-                                    Some(String::from_str(s.index(&(0..plen))))\n+                                    Some(String::from_str(&s[0..plen]))\n                                 } else { None }\n                             }\n                         }\n                     } else if is_abs && comps.is_empty() {\n                         Some(repeat(SEP).take(1).collect())\n                     } else {\n-                        let prefix_ = s.index(&(0..prefix_len(prefix)));\n+                        let prefix_ = &s[0..prefix_len(prefix)];\n                         let n = prefix_.len() +\n                                 if is_abs { comps.len() } else { comps.len() - 1} +\n                                 comps.iter().map(|v| v.len()).sum();\n@@ -780,15 +780,15 @@ impl Path {\n                                 s.push(':');\n                             }\n                             Some(VerbatimDiskPrefix) => {\n-                                s.push_str(prefix_.index(&(0..4)));\n+                                s.push_str(&prefix_[0..4]);\n                                 s.push(prefix_.as_bytes()[4].to_ascii_uppercase() as char);\n-                                s.push_str(prefix_.index(&(5..)));\n+                                s.push_str(&prefix_[5..]);\n                             }\n                             Some(UNCPrefix(a,b)) => {\n                                 s.push_str(\"\\\\\\\\\");\n-                                s.push_str(prefix_.index(&(2..(a+2))));\n+                                s.push_str(&prefix_[2..(a+2)]);\n                                 s.push(SEP);\n-                                s.push_str(prefix_.index(&((3+a)..(3+a+b))));\n+                                s.push_str(&prefix_[(3+a)..(3+a+b)]);\n                             }\n                             Some(_) => s.push_str(prefix_),\n                             None => ()\n@@ -813,8 +813,8 @@ impl Path {\n \n     fn update_sepidx(&mut self) {\n         let s = if self.has_nonsemantic_trailing_slash() {\n-                    self.repr.index(&(0..(self.repr.len()-1)))\n-                } else { self.repr.index(&FullRange) };\n+                    &self.repr[0..(self.repr.len()-1)]\n+                } else { &self.repr[] };\n         let sep_test: fn(char) -> bool = if !prefix_is_verbatim(self.prefix) {\n             is_sep\n         } else {\n@@ -893,17 +893,17 @@ pub fn is_verbatim(path: &Path) -> bool {\n /// non-verbatim, the non-verbatim version is returned.\n /// Otherwise, None is returned.\n pub fn make_non_verbatim(path: &Path) -> Option<Path> {\n-    let repr = path.repr.index(&FullRange);\n+    let repr = &path.repr[];\n     let new_path = match path.prefix {\n         Some(VerbatimPrefix(_)) | Some(DeviceNSPrefix(_)) => return None,\n         Some(UNCPrefix(_,_)) | Some(DiskPrefix) | None => return Some(path.clone()),\n         Some(VerbatimDiskPrefix) => {\n             // \\\\?\\D:\\\n-            Path::new(repr.index(&(4..)))\n+            Path::new(&repr[4..])\n         }\n         Some(VerbatimUNCPrefix(_,_)) => {\n             // \\\\?\\UNC\\server\\share\n-            Path::new(format!(r\"\\{}\", repr.index(&(7..))))\n+            Path::new(format!(r\"\\{}\", &repr[7..]))\n         }\n     };\n     if new_path.prefix.is_none() {\n@@ -912,8 +912,7 @@ pub fn make_non_verbatim(path: &Path) -> Option<Path> {\n         return None;\n     }\n     // now ensure normalization didn't change anything\n-    if repr.index(&(path.prefix_len()..)) ==\n-        new_path.repr.index(&(new_path.prefix_len()..)) {\n+    if &repr[path.prefix_len()..] == &new_path.repr[new_path.prefix_len()..] {\n         Some(new_path)\n     } else {\n         None\n@@ -978,13 +977,13 @@ pub enum PathPrefix {\n fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n     if path.starts_with(\"\\\\\\\\\") {\n         // \\\\\n-        path = path.index(&(2..));\n+        path = &path[2..];\n         if path.starts_with(\"?\\\\\") {\n             // \\\\?\\\n-            path = path.index(&(2..));\n+            path = &path[2..];\n             if path.starts_with(\"UNC\\\\\") {\n                 // \\\\?\\UNC\\server\\share\n-                path = path.index(&(4..));\n+                path = &path[4..];\n                 let (idx_a, idx_b) = match parse_two_comps(path, is_sep_verbatim) {\n                     Some(x) => x,\n                     None => (path.len(), 0)\n@@ -1005,7 +1004,7 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n             }\n         } else if path.starts_with(\".\\\\\") {\n             // \\\\.\\path\n-            path = path.index(&(2..));\n+            path = &path[2..];\n             let idx = path.find('\\\\').unwrap_or(path.len());\n             return Some(DeviceNSPrefix(idx));\n         }\n@@ -1030,7 +1029,7 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n             None => return None,\n             Some(x) => x\n         };\n-        path = path.index(&((idx_a+1)..));\n+        path = &path[(idx_a+1)..];\n         let idx_b = path.find(f).unwrap_or(path.len());\n         Some((idx_a, idx_b))\n     }\n@@ -1044,8 +1043,8 @@ fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool, Option\n         is_sep_verbatim\n     };\n     let is_abs = s.len() > prefix_len(prefix) && f(s.char_at(prefix_len(prefix)));\n-    let s_ = s.index(&(prefix_len(prefix)..));\n-    let s_ = if is_abs { s_.index(&(1..)) } else { s_ };\n+    let s_ = &s[prefix_len(prefix)..];\n+    let s_ = if is_abs { &s_[1..] } else { s_ };\n \n     if is_abs && s_.is_empty() {\n         return (is_abs, match prefix {"}, {"sha": "d9c942c0185140df57c11893b69a8c5768a77938", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -17,7 +17,7 @@\n #[stable] #[doc(no_inline)] pub use ops::{Drop, Fn, FnMut, FnOnce};\n \n // TEMPORARY\n-#[unstable] #[doc(no_inline)] pub use ops::{Index, IndexMut, FullRange};\n+#[unstable] #[doc(no_inline)] pub use ops::FullRange;\n \n // Reexported functions\n #[stable] #[doc(no_inline)] pub use mem::drop;"}, {"sha": "03876189da9ccd6bf393538dc1909c3e7a2fe50c", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -544,7 +544,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n     // MAX_CALLBACKS, so we're sure to clamp it as necessary.\n     let callbacks = {\n         let amt = CALLBACK_CNT.load(Ordering::SeqCst);\n-        CALLBACKS.index(&(0..cmp::min(amt, MAX_CALLBACKS)))\n+        &CALLBACKS[0..cmp::min(amt, MAX_CALLBACKS)]\n     };\n     for cb in callbacks.iter() {\n         match cb.load(Ordering::SeqCst) {"}, {"sha": "c076f0a7c6ca026f494c1e26a10cab7b49cc076a", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -131,7 +131,7 @@ pub fn abort(args: fmt::Arguments) -> ! {\n     impl<'a> fmt::Writer for BufWriter<'a> {\n         fn write_str(&mut self, bytes: &str) -> fmt::Result {\n             let left = self.buf.slice_from_mut(self.pos);\n-            let to_write = bytes.as_bytes().index(&(0..cmp::min(bytes.len(), left.len())));\n+            let to_write = &bytes.as_bytes()[0..cmp::min(bytes.len(), left.len())];\n             slice::bytes::copy_memory(left, to_write);\n             self.pos += to_write.len();\n             Ok(())\n@@ -142,7 +142,7 @@ pub fn abort(args: fmt::Arguments) -> ! {\n     let mut msg = [0u8; 512];\n     let mut w = BufWriter { buf: &mut msg, pos: 0 };\n     let _ = write!(&mut w, \"{}\", args);\n-    let msg = str::from_utf8(w.buf.index_mut(&(0..w.pos))).unwrap_or(\"aborted\");\n+    let msg = str::from_utf8(&w.buf[0..w.pos]).unwrap_or(\"aborted\");\n     let msg = if msg.is_empty() {\"aborted\"} else {msg};\n \n     // Give some context to the message"}, {"sha": "f4b20c7b74235613c9334d974a7636a183e89c16", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -338,7 +338,7 @@ impl<T: Send> Packet<T> {\n         // upgrade pending, then go through the whole recv rigamarole to update\n         // the internal state.\n         match self.queue.peek() {\n-            Some(&GoUp(..)) => {\n+            Some(&mut GoUp(..)) => {\n                 match self.recv() {\n                     Err(Upgraded(port)) => Err(port),\n                     _ => unreachable!(),\n@@ -367,7 +367,7 @@ impl<T: Send> Packet<T> {\n             Ok(()) => SelSuccess,\n             Err(token) => {\n                 let ret = match self.queue.peek() {\n-                    Some(&GoUp(..)) => {\n+                    Some(&mut GoUp(..)) => {\n                         match self.queue.pop() {\n                             Some(GoUp(port)) => SelUpgraded(token, port),\n                             _ => unreachable!(),\n@@ -457,7 +457,7 @@ impl<T: Send> Packet<T> {\n         // upgraded port.\n         if has_data {\n             match self.queue.peek() {\n-                Some(&GoUp(..)) => {\n+                Some(&mut GoUp(..)) => {\n                     match self.queue.pop() {\n                         Some(GoUp(port)) => Err(port),\n                         _ => unreachable!(),"}, {"sha": "4cf891ac4985eba360859a1cff038719ce3ca9a8", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -469,7 +469,7 @@ pub fn write<T, L, W>(fd: sock_t,\n             // Also as with read(), we use MSG_DONTWAIT to guard ourselves\n             // against unforeseen circumstances.\n             let _guard = lock();\n-            let ptr = buf.index(&(written..)).as_ptr();\n+            let ptr = buf[written..].as_ptr();\n             let len = buf.len() - written;\n             match retry(|| write(deadline.is_some(), ptr, len)) {\n                 -1 if wouldblock() => {}"}, {"sha": "ee2dd14955b6983ae862be709036746ac0e4f047", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -362,7 +362,7 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n             let bytes = unsafe { ffi::c_str_to_bytes(&ptr) };\n             match str::from_utf8(bytes) {\n                 Ok(s) => try!(demangle(w, s)),\n-                Err(..) => try!(w.write(bytes.index(&(..(bytes.len()-1))))),\n+                Err(..) => try!(w.write(&bytes[..(bytes.len()-1)])),\n             }\n         }\n         try!(w.write(&['\\n' as u8]));"}, {"sha": "064633f321c19b1ed4689258eacb60f9ff4f5e65", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -36,7 +36,7 @@ const BUF_BYTES : uint = 2048u;\n pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n     match v.iter().position(|c| *c == 0) {\n         // don't include the 0\n-        Some(i) => v.index(&(0..i)),\n+        Some(i) => &v[0..i],\n         None => v\n     }\n }"}, {"sha": "9996909f2f5bbc18a9781018bd4dd4aaaf952fd1", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -453,7 +453,7 @@ impl UnixStream {\n             }\n             let ret = unsafe {\n                 libc::WriteFile(self.handle(),\n-                                buf.index(&(offset..)).as_ptr() as libc::LPVOID,\n+                                buf[offset..].as_ptr() as libc::LPVOID,\n                                 (buf.len() - offset) as libc::DWORD,\n                                 &mut bytes_written,\n                                 &mut overlapped)"}, {"sha": "3d00518d9471ef63e074d54c3b2cb35fa0eaf675", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -202,7 +202,7 @@ impl Encodable for Ident {\n \n impl Decodable for Ident {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Ident, D::Error> {\n-        Ok(str_to_ident(try!(d.read_str()).index(&FullRange)))\n+        Ok(str_to_ident(&try!(d.read_str())[]))\n     }\n }\n "}, {"sha": "3ef572791752bfd7420ed17ec5b4622cda88ba45", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -83,7 +83,7 @@ impl<'a, T: Copy> Iterator for Values<'a, T> {\n     type Item = T;\n \n     fn next(&mut self) -> Option<T> {\n-        let &Values(ref mut items) = self;\n+        let &mut Values(ref mut items) = self;\n         items.next().map(|&x| x)\n     }\n }\n@@ -99,7 +99,7 @@ pub fn path_to_string<PI: Iterator<Item=PathElem>>(path: PI) -> String {\n         if !s.is_empty() {\n             s.push_str(\"::\");\n         }\n-        s.push_str(e.index(&FullRange));\n+        s.push_str(&e[]);\n         s\n     }).to_string()\n }\n@@ -476,20 +476,20 @@ impl<'ast> Map<'ast> {\n         F: FnOnce(Option<&[Attribute]>) -> T,\n     {\n         let attrs = match self.get(id) {\n-            NodeItem(i) => Some(i.attrs.index(&FullRange)),\n-            NodeForeignItem(fi) => Some(fi.attrs.index(&FullRange)),\n+            NodeItem(i) => Some(&i.attrs[]),\n+            NodeForeignItem(fi) => Some(&fi.attrs[]),\n             NodeTraitItem(ref tm) => match **tm {\n-                RequiredMethod(ref type_m) => Some(type_m.attrs.index(&FullRange)),\n-                ProvidedMethod(ref m) => Some(m.attrs.index(&FullRange)),\n-                TypeTraitItem(ref typ) => Some(typ.attrs.index(&FullRange)),\n+                RequiredMethod(ref type_m) => Some(&type_m.attrs[]),\n+                ProvidedMethod(ref m) => Some(&m.attrs[]),\n+                TypeTraitItem(ref typ) => Some(&typ.attrs[]),\n             },\n             NodeImplItem(ref ii) => {\n                 match **ii {\n-                    MethodImplItem(ref m) => Some(m.attrs.index(&FullRange)),\n-                    TypeImplItem(ref t) => Some(t.attrs.index(&FullRange)),\n+                    MethodImplItem(ref m) => Some(&m.attrs[]),\n+                    TypeImplItem(ref t) => Some(&t.attrs[]),\n                 }\n             }\n-            NodeVariant(ref v) => Some(v.node.attrs.index(&FullRange)),\n+            NodeVariant(ref v) => Some(&v.node.attrs[]),\n             // unit/tuple structs take the attributes straight from\n             // the struct definition.\n             // FIXME(eddyb) make this work again (requires access to the map).\n@@ -513,7 +513,7 @@ impl<'ast> Map<'ast> {\n         NodesMatchingSuffix {\n             map: self,\n             item_name: parts.last().unwrap(),\n-            in_which: parts.index(&(0..(parts.len() - 1))),\n+            in_which: &parts[0..(parts.len() - 1)],\n             idx: 0,\n         }\n     }\n@@ -590,7 +590,7 @@ impl<'a, 'ast> NodesMatchingSuffix<'a, 'ast> {\n                 None => return false,\n                 Some((node_id, name)) => (node_id, name),\n             };\n-            if part.index(&FullRange) != mod_name.as_str() {\n+            if &part[] != mod_name.as_str() {\n                 return false;\n             }\n             cursor = self.map.get_parent(mod_id);\n@@ -628,7 +628,7 @@ impl<'a, 'ast> NodesMatchingSuffix<'a, 'ast> {\n     // We are looking at some node `n` with a given name and parent\n     // id; do their names match what I am seeking?\n     fn matches_names(&self, parent_of_n: NodeId, name: Name) -> bool {\n-        name.as_str() == self.item_name.index(&FullRange) &&\n+        name.as_str() == &self.item_name[] &&\n             self.suffix_matches(parent_of_n)\n     }\n }\n@@ -1040,7 +1040,7 @@ impl<'a> NodePrinter for pprust::State<'a> {\n \n fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n     let id_str = format!(\" (id={})\", id);\n-    let id_str = if include_id { id_str.index(&FullRange) } else { \"\" };\n+    let id_str = if include_id { &id_str[] } else { \"\" };\n \n     match map.find(id) {\n         Some(NodeItem(item)) => {"}, {"sha": "b4e917e28cb24a9ed0c849b780a8daeae70839de", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -245,11 +245,11 @@ pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> Ident {\n     match *trait_ref {\n         Some(ref trait_ref) => {\n             pretty.push('.');\n-            pretty.push_str(pprust::path_to_string(&trait_ref.path).index(&FullRange));\n+            pretty.push_str(&pprust::path_to_string(&trait_ref.path)[]);\n         }\n         None => {}\n     }\n-    token::gensym_ident(pretty.index(&FullRange))\n+    token::gensym_ident(&pretty[])\n }\n \n pub fn trait_method_to_ty_method(method: &Method) -> TypeMethod {\n@@ -710,7 +710,7 @@ pub fn pat_is_ident(pat: P<ast::Pat>) -> bool {\n pub fn path_name_eq(a : &ast::Path, b : &ast::Path) -> bool {\n     (a.span == b.span)\n     && (a.global == b.global)\n-    && (segments_name_eq(a.segments.index(&FullRange), b.segments.index(&FullRange)))\n+    && (segments_name_eq(&a.segments[], &b.segments[]))\n }\n \n // are two arrays of segments equal when compared unhygienically?\n@@ -797,14 +797,14 @@ mod test {\n \n     #[test] fn idents_name_eq_test() {\n         assert!(segments_name_eq(\n-            [Ident{name:Name(3),ctxt:4}, Ident{name:Name(78),ctxt:82}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().index(&FullRange),\n-            [Ident{name:Name(3),ctxt:104}, Ident{name:Name(78),ctxt:182}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().index(&FullRange)));\n+            &[Ident{name:Name(3),ctxt:4}, Ident{name:Name(78),ctxt:82}]\n+                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>()[],\n+            &[Ident{name:Name(3),ctxt:104}, Ident{name:Name(78),ctxt:182}]\n+                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>()[]));\n         assert!(!segments_name_eq(\n-            [Ident{name:Name(3),ctxt:4}, Ident{name:Name(78),ctxt:82}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().index(&FullRange),\n-            [Ident{name:Name(3),ctxt:104}, Ident{name:Name(77),ctxt:182}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().index(&FullRange)));\n+            &[Ident{name:Name(3),ctxt:4}, Ident{name:Name(78),ctxt:82}]\n+                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>()[],\n+            &[Ident{name:Name(3),ctxt:104}, Ident{name:Name(77),ctxt:182}]\n+                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>()[]));\n     }\n }"}, {"sha": "2cea55dfc55efa6ae5bf890fac8296ef8e2ca804", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -98,7 +98,7 @@ impl AttrMetaMethods for MetaItem {\n \n     fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]> {\n         match self.node {\n-            MetaList(_, ref l) => Some(l.index(&FullRange)),\n+            MetaList(_, ref l) => Some(&l[]),\n             _ => None\n         }\n     }\n@@ -136,8 +136,8 @@ impl AttributeMethods for Attribute {\n             let comment = self.value_str().unwrap();\n             let meta = mk_name_value_item_str(\n                 InternedString::new(\"doc\"),\n-                token::intern_and_get_ident(strip_doc_comment_decoration(\n-                        comment.get()).index(&FullRange)));\n+                token::intern_and_get_ident(&strip_doc_comment_decoration(\n+                        comment.get())[]));\n             if self.node.style == ast::AttrOuter {\n                 f(&mk_attr_outer(self.node.id, meta))\n             } else {\n@@ -297,9 +297,9 @@ pub fn find_inline_attr(attrs: &[Attribute]) -> InlineAttr {\n             }\n             MetaList(ref n, ref items) if *n == \"inline\" => {\n                 mark_used(attr);\n-                if contains_name(items.index(&FullRange), \"always\") {\n+                if contains_name(&items[], \"always\") {\n                     InlineAlways\n-                } else if contains_name(items.index(&FullRange), \"never\") {\n+                } else if contains_name(&items[], \"never\") {\n                     InlineNever\n                 } else {\n                     InlineHint\n@@ -403,7 +403,7 @@ pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[P<MetaItem>]) {\n \n         if !set.insert(name.clone()) {\n             diagnostic.span_fatal(meta.span,\n-                                  format!(\"duplicate meta item `{}`\", name).index(&FullRange));\n+                                  &format!(\"duplicate meta item `{}`\", name)[]);\n         }\n     }\n }"}, {"sha": "d1768867f0da2a613947dc2cee44282547a9e29c", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -304,9 +304,9 @@ impl FileMap {\n         lines.get(line_number).map(|&line| {\n             let begin: BytePos = line - self.start_pos;\n             let begin = begin.to_uint();\n-            let slice = self.src.index(&(begin..));\n+            let slice = &self.src[begin..];\n             match slice.find('\\n') {\n-                Some(e) => slice.index(&(0..e)),\n+                Some(e) => &slice[0..e],\n                 None => slice\n             }.to_string()\n         })\n@@ -351,9 +351,9 @@ impl CodeMap {\n         // FIXME #12884: no efficient/safe way to remove from the start of a string\n         // and reuse the allocation.\n         let mut src = if src.starts_with(\"\\u{feff}\") {\n-            String::from_str(src.index(&(3..)))\n+            String::from_str(&src[3..])\n         } else {\n-            String::from_str(src.index(&FullRange))\n+            String::from_str(&src[])\n         };\n \n         // Append '\\n' in case it's not already there.\n@@ -440,8 +440,7 @@ impl CodeMap {\n         if begin.fm.start_pos != end.fm.start_pos {\n             None\n         } else {\n-            Some(begin.fm.src.index(&(begin.pos.to_uint()..\n-                                      end.pos.to_uint())).to_string())\n+            Some((&begin.fm.src[begin.pos.to_uint()..end.pos.to_uint()]).to_string())\n         }\n     }\n "}, {"sha": "7e57709f33d0af07bc929752c0f730d504486def", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -123,7 +123,7 @@ impl SpanHandler {\n         panic!(ExplicitBug);\n     }\n     pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n-        self.span_bug(sp, format!(\"unimplemented {}\", msg).index(&FullRange));\n+        self.span_bug(sp, &format!(\"unimplemented {}\", msg)[]);\n     }\n     pub fn handler<'a>(&'a self) -> &'a Handler {\n         &self.handler\n@@ -166,7 +166,7 @@ impl Handler {\n                         self.err_count.get());\n           }\n         }\n-        self.fatal(s.index(&FullRange));\n+        self.fatal(&s[]);\n     }\n     pub fn warn(&self, msg: &str) {\n         self.emit.borrow_mut().emit(None, msg, None, Warning);\n@@ -182,7 +182,7 @@ impl Handler {\n         panic!(ExplicitBug);\n     }\n     pub fn unimpl(&self, msg: &str) -> ! {\n-        self.bug(format!(\"unimplemented {}\", msg).index(&FullRange));\n+        self.bug(&format!(\"unimplemented {}\", msg)[]);\n     }\n     pub fn emit(&self,\n                 cmsp: Option<(&codemap::CodeMap, Span)>,\n@@ -277,7 +277,7 @@ fn print_maybe_styled(w: &mut EmitterWriter,\n             // to be miscolored. We assume this is rare enough that we don't\n             // have to worry about it.\n             if msg.ends_with(\"\\n\") {\n-                try!(t.write_str(msg.index(&(0..(msg.len()-1)))));\n+                try!(t.write_str(&msg[0..(msg.len()-1)]));\n                 try!(t.reset());\n                 try!(t.write_str(\"\\n\"));\n             } else {\n@@ -299,16 +299,16 @@ fn print_diagnostic(dst: &mut EmitterWriter, topic: &str, lvl: Level,\n     }\n \n     try!(print_maybe_styled(dst,\n-                            format!(\"{}: \", lvl.to_string()).index(&FullRange),\n+                            &format!(\"{}: \", lvl.to_string())[],\n                             term::attr::ForegroundColor(lvl.color())));\n     try!(print_maybe_styled(dst,\n-                            format!(\"{}\", msg).index(&FullRange),\n+                            &format!(\"{}\", msg)[],\n                             term::attr::Bold));\n \n     match code {\n         Some(code) => {\n             let style = term::attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n-            try!(print_maybe_styled(dst, format!(\" [{}]\", code.clone()).index(&FullRange), style));\n+            try!(print_maybe_styled(dst, &format!(\" [{}]\", code.clone())[], style));\n         }\n         None => ()\n     }\n@@ -398,12 +398,12 @@ fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n         // the span)\n         let span_end = Span { lo: sp.hi, hi: sp.hi, expn_id: sp.expn_id};\n         let ses = cm.span_to_string(span_end);\n-        try!(print_diagnostic(dst, ses.index(&FullRange), lvl, msg, code));\n+        try!(print_diagnostic(dst, &ses[], lvl, msg, code));\n         if rsp.is_full_span() {\n             try!(custom_highlight_lines(dst, cm, sp, lvl, lines));\n         }\n     } else {\n-        try!(print_diagnostic(dst, ss.index(&FullRange), lvl, msg, code));\n+        try!(print_diagnostic(dst, &ss[], lvl, msg, code));\n         if rsp.is_full_span() {\n             try!(highlight_lines(dst, cm, sp, lvl, lines));\n         }\n@@ -413,9 +413,9 @@ fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n         Some(code) =>\n             match dst.registry.as_ref().and_then(|registry| registry.find_description(code)) {\n                 Some(_) => {\n-                    try!(print_diagnostic(dst, ss.index(&FullRange), Help,\n-                                          format!(\"pass `--explain {}` to see a detailed \\\n-                                                   explanation\", code).index(&FullRange), None));\n+                    try!(print_diagnostic(dst, &ss[], Help,\n+                                          &format!(\"pass `--explain {}` to see a detailed \\\n+                                                   explanation\", code)[], None));\n                 }\n                 None => ()\n             },\n@@ -432,9 +432,9 @@ fn highlight_lines(err: &mut EmitterWriter,\n     let fm = &*lines.file;\n \n     let mut elided = false;\n-    let mut display_lines = lines.lines.index(&FullRange);\n+    let mut display_lines = &lines.lines[];\n     if display_lines.len() > MAX_LINES {\n-        display_lines = display_lines.index(&(0u..MAX_LINES));\n+        display_lines = &display_lines[0u..MAX_LINES];\n         elided = true;\n     }\n     // Print the offending lines\n@@ -494,7 +494,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n             }\n         }\n         try!(print_maybe_styled(err,\n-                                format!(\"{}\\n\", s).index(&FullRange),\n+                                &format!(\"{}\\n\", s)[],\n                                 term::attr::ForegroundColor(lvl.color())));\n     }\n     Ok(())\n@@ -514,7 +514,7 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n                           -> io::IoResult<()> {\n     let fm = &*lines.file;\n \n-    let lines = lines.lines.index(&FullRange);\n+    let lines = &lines.lines[];\n     if lines.len() > MAX_LINES {\n         if let Some(line) = fm.get_line(lines[0]) {\n             try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n@@ -545,7 +545,7 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n     s.push('^');\n     s.push('\\n');\n     print_maybe_styled(w,\n-                       s.index(&FullRange),\n+                       &s[],\n                        term::attr::ForegroundColor(lvl.color()))\n }\n \n@@ -560,12 +560,12 @@ fn print_macro_backtrace(w: &mut EmitterWriter,\n                 codemap::MacroAttribute => (\"#[\", \"]\"),\n                 codemap::MacroBang => (\"\", \"!\")\n             };\n-            try!(print_diagnostic(w, ss.index(&FullRange), Note,\n-                                  format!(\"in expansion of {}{}{}\", pre,\n+            try!(print_diagnostic(w, &ss[], Note,\n+                                  &format!(\"in expansion of {}{}{}\", pre,\n                                           ei.callee.name,\n-                                          post).index(&FullRange), None));\n+                                          post)[], None));\n             let ss = cm.span_to_string(ei.call_site);\n-            try!(print_diagnostic(w, ss.index(&FullRange), Note, \"expansion site\", None));\n+            try!(print_diagnostic(w, &ss[], Note, \"expansion site\", None));\n             Ok(Some(ei.call_site))\n         }\n         None => Ok(None)\n@@ -578,6 +578,6 @@ pub fn expect<T, M>(diag: &SpanHandler, opt: Option<T>, msg: M) -> T where\n {\n     match opt {\n         Some(t) => t,\n-        None => diag.handler().bug(msg().index(&FullRange)),\n+        None => diag.handler().bug(&msg()[]),\n     }\n }"}, {"sha": "1469c50061cc75dc449bb1e11e339c24d7b9a159", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -56,9 +56,9 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n     with_used_diagnostics(|diagnostics| {\n         match diagnostics.insert(code.name, span) {\n             Some(previous_span) => {\n-                ecx.span_warn(span, format!(\n+                ecx.span_warn(span, &format!(\n                     \"diagnostic code {} already used\", token::get_ident(code).get()\n-                ).index(&FullRange));\n+                )[]);\n                 ecx.span_note(previous_span, \"previous invocation\");\n             },\n             None => ()\n@@ -85,14 +85,14 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n     };\n     with_registered_diagnostics(|diagnostics| {\n         if diagnostics.insert(code.name, description).is_some() {\n-            ecx.span_err(span, format!(\n+            ecx.span_err(span, &format!(\n                 \"diagnostic code {} already registered\", token::get_ident(*code).get()\n-            ).index(&FullRange));\n+            )[]);\n         }\n     });\n-    let sym = Ident::new(token::gensym((\n+    let sym = Ident::new(token::gensym(&(\n         \"__register_diagnostic_\".to_string() + token::get_ident(*code).get()\n-    ).index(&FullRange)));\n+    )[]));\n     MacItems::new(vec![quote_item!(ecx, mod $sym {}).unwrap()].into_iter())\n }\n "}, {"sha": "fd3bac5b2fc7bce38d0304d2880e1e685593f6b3", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -99,8 +99,8 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     let output = match constraint.get().slice_shift_char() {\n                         Some(('=', _)) => None,\n                         Some(('+', operand)) => {\n-                            Some(token::intern_and_get_ident(format!(\n-                                        \"={}\", operand).index(&FullRange)))\n+                            Some(token::intern_and_get_ident(&format!(\n+                                        \"={}\", operand)[]))\n                         }\n                         _ => {\n                             cx.span_err(span, \"output operand constraint lacks '=' or '+'\");"}, {"sha": "11edf214435f5c7e6676ca6179dd39327be8ab3f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -539,16 +539,16 @@ impl<'a> ExtCtxt<'a> {\n     pub fn mod_pop(&mut self) { self.mod_path.pop().unwrap(); }\n     pub fn mod_path(&self) -> Vec<ast::Ident> {\n         let mut v = Vec::new();\n-        v.push(token::str_to_ident(self.ecfg.crate_name.index(&FullRange)));\n+        v.push(token::str_to_ident(&self.ecfg.crate_name[]));\n         v.extend(self.mod_path.iter().map(|a| *a));\n         return v;\n     }\n     pub fn bt_push(&mut self, ei: ExpnInfo) {\n         self.recursion_count += 1;\n         if self.recursion_count > self.ecfg.recursion_limit {\n             self.span_fatal(ei.call_site,\n-                            format!(\"recursion limit reached while expanding the macro `{}`\",\n-                                    ei.callee.name).index(&FullRange));\n+                            &format!(\"recursion limit reached while expanding the macro `{}`\",\n+                                    ei.callee.name)[]);\n         }\n \n         let mut call_site = ei.call_site;\n@@ -670,7 +670,7 @@ pub fn check_zero_tts(cx: &ExtCtxt,\n                       tts: &[ast::TokenTree],\n                       name: &str) {\n     if tts.len() != 0 {\n-        cx.span_err(sp, format!(\"{} takes no arguments\", name).index(&FullRange));\n+        cx.span_err(sp, &format!(\"{} takes no arguments\", name)[]);\n     }\n }\n \n@@ -683,12 +683,12 @@ pub fn get_single_str_from_tts(cx: &mut ExtCtxt,\n                                -> Option<String> {\n     let mut p = cx.new_parser_from_tts(tts);\n     if p.token == token::Eof {\n-        cx.span_err(sp, format!(\"{} takes 1 argument\", name).index(&FullRange));\n+        cx.span_err(sp, &format!(\"{} takes 1 argument\", name)[]);\n         return None\n     }\n     let ret = cx.expander().fold_expr(p.parse_expr());\n     if p.token != token::Eof {\n-        cx.span_err(sp, format!(\"{} takes 1 argument\", name).index(&FullRange));\n+        cx.span_err(sp, &format!(\"{} takes 1 argument\", name)[]);\n     }\n     expr_to_string(cx, ret, \"argument must be a string literal\").map(|(s, _)| {\n         s.get().to_string()"}, {"sha": "27523ea453585aa180cbb5b21407608772dfd782", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -708,8 +708,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn expr_fail(&self, span: Span, msg: InternedString) -> P<ast::Expr> {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n         let expr_file = self.expr_str(span,\n-                                      token::intern_and_get_ident(loc.file\n-                                                                  .name.index(&FullRange)));\n+                                      token::intern_and_get_ident(&loc.file.name[]));\n         let expr_line = self.expr_uint(span, loc.line);\n         let expr_file_line_tuple = self.expr_tuple(span, vec!(expr_file, expr_line));\n         let expr_file_line_ptr = self.expr_addr_of(span, expr_file_line_tuple);"}, {"sha": "39895a3946a564397fa4c5fbceb991cfe6b9e125", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -40,14 +40,14 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                     ast::LitInt(i, ast::UnsignedIntLit(_)) |\n                     ast::LitInt(i, ast::SignedIntLit(_, ast::Plus)) |\n                     ast::LitInt(i, ast::UnsuffixedIntLit(ast::Plus)) => {\n-                        accumulator.push_str(format!(\"{}\", i).index(&FullRange));\n+                        accumulator.push_str(&format!(\"{}\", i)[]);\n                     }\n                     ast::LitInt(i, ast::SignedIntLit(_, ast::Minus)) |\n                     ast::LitInt(i, ast::UnsuffixedIntLit(ast::Minus)) => {\n-                        accumulator.push_str(format!(\"-{}\", i).index(&FullRange));\n+                        accumulator.push_str(&format!(\"-{}\", i)[]);\n                     }\n                     ast::LitBool(b) => {\n-                        accumulator.push_str(format!(\"{}\", b).index(&FullRange));\n+                        accumulator.push_str(&format!(\"{}\", b)[]);\n                     }\n                     ast::LitByte(..) |\n                     ast::LitBinary(..) => {\n@@ -62,5 +62,5 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n     }\n     base::MacExpr::new(cx.expr_str(\n             sp,\n-            token::intern_and_get_ident(accumulator.index(&FullRange))))\n+            token::intern_and_get_ident(&accumulator[])))\n }"}, {"sha": "1af3ba1d326bc7ae062f565a38ea91e58b83a60b", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -40,7 +40,7 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]\n             }\n         }\n     }\n-    let res = str_to_ident(res_str.index(&FullRange));\n+    let res = str_to_ident(&res_str[]);\n \n     let e = P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,"}, {"sha": "784a92b9a0e555fea760a56daf81a7ff64278aaa", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -79,12 +79,12 @@ fn cs_clone(\n         },\n         EnumNonMatchingCollapsed (..) => {\n             cx.span_bug(trait_span,\n-                        format!(\"non-matching enum variants in \\\n-                                 `deriving({})`\", name).index(&FullRange))\n+                        &format!(\"non-matching enum variants in \\\n+                                 `deriving({})`\", name)[])\n         }\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span,\n-                        format!(\"static method in `deriving({})`\", name).index(&FullRange))\n+                        &format!(\"static method in `deriving({})`\", name)[])\n         }\n     }\n \n@@ -100,8 +100,8 @@ fn cs_clone(\n                 Some(i) => i,\n                 None => {\n                     cx.span_bug(trait_span,\n-                                format!(\"unnamed field in normal struct in \\\n-                                         `deriving({})`\", name).index(&FullRange))\n+                                &format!(\"unnamed field in normal struct in \\\n+                                         `deriving({})`\", name)[])\n                 }\n             };\n             cx.field_imm(field.span, ident, subcall(field))"}, {"sha": "7c65d2b4ff483d55a1d3b101a83f6c6e1c9f8a52", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -197,8 +197,7 @@ fn decode_static_fields<F>(cx: &mut ExtCtxt,\n             } else {\n                 let fields = fields.iter().enumerate().map(|(i, &span)| {\n                     getarg(cx, span,\n-                           token::intern_and_get_ident(format!(\"_field{}\",\n-                                                               i).index(&FullRange)),\n+                           token::intern_and_get_ident(&format!(\"_field{}\", i)[]),\n                            i)\n                 }).collect();\n "}, {"sha": "616390467f06fc2b897dd646ef7022d1974ed0f4", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -183,7 +183,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                 let name = match name {\n                     Some(id) => token::get_ident(id),\n                     None => {\n-                        token::intern_and_get_ident(format!(\"_field{}\", i).index(&FullRange))\n+                        token::intern_and_get_ident(&format!(\"_field{}\", i)[])\n                     }\n                 };\n                 let enc = cx.expr_method_call(span, self_.clone(),"}, {"sha": "47b29a4db3e27fbffd18dc6bb635aef05bd20883", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -510,15 +510,15 @@ impl<'a> TraitDef<'a> {\n                     self,\n                     struct_def,\n                     type_ident,\n-                    self_args.index(&FullRange),\n-                    nonself_args.index(&FullRange))\n+                    &self_args[],\n+                    &nonself_args[])\n             } else {\n                 method_def.expand_struct_method_body(cx,\n                                                      self,\n                                                      struct_def,\n                                                      type_ident,\n-                                                     self_args.index(&FullRange),\n-                                                     nonself_args.index(&FullRange))\n+                                                     &self_args[],\n+                                                     &nonself_args[])\n             };\n \n             method_def.create_method(cx,\n@@ -550,15 +550,15 @@ impl<'a> TraitDef<'a> {\n                     self,\n                     enum_def,\n                     type_ident,\n-                    self_args.index(&FullRange),\n-                    nonself_args.index(&FullRange))\n+                    &self_args[],\n+                    &nonself_args[])\n             } else {\n                 method_def.expand_enum_method_body(cx,\n                                                    self,\n                                                    enum_def,\n                                                    type_ident,\n                                                    self_args,\n-                                                   nonself_args.index(&FullRange))\n+                                                   &nonself_args[])\n             };\n \n             method_def.create_method(cx,\n@@ -645,7 +645,7 @@ impl<'a> MethodDef<'a> {\n \n         for (i, ty) in self.args.iter().enumerate() {\n             let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n-            let ident = cx.ident_of(format!(\"__arg_{}\", i).index(&FullRange));\n+            let ident = cx.ident_of(&format!(\"__arg_{}\", i)[]);\n             arg_tys.push((ident, ast_ty));\n \n             let arg_expr = cx.expr_ident(trait_.span, ident);\n@@ -751,8 +751,8 @@ impl<'a> MethodDef<'a> {\n                 trait_.create_struct_pattern(cx,\n                                              struct_path,\n                                              struct_def,\n-                                             format!(\"__self_{}\",\n-                                                     i).index(&FullRange),\n+                                             &format!(\"__self_{}\",\n+                                                     i)[],\n                                              ast::MutImmutable);\n             patterns.push(pat);\n             raw_fields.push(ident_expr);\n@@ -908,22 +908,22 @@ impl<'a> MethodDef<'a> {\n             .collect::<Vec<String>>();\n \n         let self_arg_idents = self_arg_names.iter()\n-            .map(|name|cx.ident_of(name.index(&FullRange)))\n+            .map(|name|cx.ident_of(&name[]))\n             .collect::<Vec<ast::Ident>>();\n \n         // The `vi_idents` will be bound, solely in the catch-all, to\n         // a series of let statements mapping each self_arg to a uint\n         // corresponding to its variant index.\n         let vi_idents: Vec<ast::Ident> = self_arg_names.iter()\n-            .map(|name| { let vi_suffix = format!(\"{}_vi\", name.index(&FullRange));\n-                          cx.ident_of(vi_suffix.index(&FullRange)) })\n+            .map(|name| { let vi_suffix = format!(\"{}_vi\", &name[]);\n+                          cx.ident_of(&vi_suffix[]) })\n             .collect::<Vec<ast::Ident>>();\n \n         // Builds, via callback to call_substructure_method, the\n         // delegated expression that handles the catch-all case,\n         // using `__variants_tuple` to drive logic if necessary.\n         let catch_all_substructure = EnumNonMatchingCollapsed(\n-            self_arg_idents, variants.index(&FullRange), vi_idents.index(&FullRange));\n+            self_arg_idents, &variants[], &vi_idents[]);\n \n         // These arms are of the form:\n         // (Variant1, Variant1, ...) => Body1\n@@ -945,12 +945,12 @@ impl<'a> MethodDef<'a> {\n                 let mut subpats = Vec::with_capacity(self_arg_names.len());\n                 let mut self_pats_idents = Vec::with_capacity(self_arg_names.len() - 1);\n                 let first_self_pat_idents = {\n-                    let (p, idents) = mk_self_pat(cx, self_arg_names[0].index(&FullRange));\n+                    let (p, idents) = mk_self_pat(cx, &self_arg_names[0][]);\n                     subpats.push(p);\n                     idents\n                 };\n                 for self_arg_name in self_arg_names.tail().iter() {\n-                    let (p, idents) = mk_self_pat(cx, self_arg_name.index(&FullRange));\n+                    let (p, idents) = mk_self_pat(cx, &self_arg_name[]);\n                     subpats.push(p);\n                     self_pats_idents.push(idents);\n                 }\n@@ -1006,7 +1006,7 @@ impl<'a> MethodDef<'a> {\n                                                 &**variant,\n                                                 field_tuples);\n                 let arm_expr = self.call_substructure_method(\n-                    cx, trait_, type_ident, self_args.index(&FullRange), nonself_args,\n+                    cx, trait_, type_ident, &self_args[], nonself_args,\n                     &substructure);\n \n                 cx.arm(sp, vec![single_pat], arm_expr)\n@@ -1059,7 +1059,7 @@ impl<'a> MethodDef<'a> {\n             }\n \n             let arm_expr = self.call_substructure_method(\n-                cx, trait_, type_ident, self_args.index(&FullRange), nonself_args,\n+                cx, trait_, type_ident, &self_args[], nonself_args,\n                 &catch_all_substructure);\n \n             // Builds the expression:\n@@ -1263,7 +1263,7 @@ impl<'a> TraitDef<'a> {\n                     cx.span_bug(sp, \"a struct with named and unnamed fields in `derive`\");\n                 }\n             };\n-            let ident = cx.ident_of(format!(\"{}_{}\", prefix, i).index(&FullRange));\n+            let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i)[]);\n             paths.push(codemap::Spanned{span: sp, node: ident});\n             let val = cx.expr(\n                 sp, ast::ExprParen(cx.expr_deref(sp, cx.expr_path(cx.path_ident(sp,ident)))));\n@@ -1309,7 +1309,7 @@ impl<'a> TraitDef<'a> {\n                 let mut ident_expr = Vec::new();\n                 for (i, va) in variant_args.iter().enumerate() {\n                     let sp = self.set_expn_info(cx, va.ty.span);\n-                    let ident = cx.ident_of(format!(\"{}_{}\", prefix, i).index(&FullRange));\n+                    let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i)[]);\n                     let path1 = codemap::Spanned{span: sp, node: ident};\n                     paths.push(path1);\n                     let expr_path = cx.expr_path(cx.path_ident(sp, ident));\n@@ -1352,20 +1352,20 @@ pub fn cs_fold<F>(use_foldl: bool,\n                       field.span,\n                       old,\n                       field.self_.clone(),\n-                      field.other.index(&FullRange))\n+                      &field.other[])\n                 })\n             } else {\n                 all_fields.iter().rev().fold(base, |old, field| {\n                     f(cx,\n                       field.span,\n                       old,\n                       field.self_.clone(),\n-                      field.other.index(&FullRange))\n+                      &field.other[])\n                 })\n             }\n         },\n         EnumNonMatchingCollapsed(ref all_args, _, tuple) =>\n-            enum_nonmatch_f(cx, trait_span, (all_args.index(&FullRange), tuple),\n+            enum_nonmatch_f(cx, trait_span, (&all_args[], tuple),\n                             substructure.nonself_args),\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span, \"static function in `derive`\")\n@@ -1405,7 +1405,7 @@ pub fn cs_same_method<F>(f: F,\n             f(cx, trait_span, called)\n         },\n         EnumNonMatchingCollapsed(ref all_self_args, _, tuple) =>\n-            enum_nonmatch_f(cx, trait_span, (all_self_args.index(&FullRange), tuple),\n+            enum_nonmatch_f(cx, trait_span, (&all_self_args[], tuple),\n                             substructure.nonself_args),\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span, \"static function in `derive`\")"}, {"sha": "6040d4ee547b6501c0001bfae78e02c1da607810", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -121,9 +121,9 @@ pub fn expand_meta_derive(cx: &mut ExtCtxt,\n \n                             ref tname => {\n                                 cx.span_err(titem.span,\n-                                            format!(\"unknown `derive` \\\n+                                            &format!(\"unknown `derive` \\\n                                                      trait: `{}`\",\n-                                                    *tname).index(&FullRange));\n+                                                    *tname)[]);\n                             }\n                         };\n                     }"}, {"sha": "48034ce50ab51b1b67bf1c0c1722f96b23960c59", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -127,7 +127,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n     let formatter = substr.nonself_args[0].clone();\n \n     let meth = cx.ident_of(\"write_fmt\");\n-    let s = token::intern_and_get_ident(format_string.index(&FullRange));\n+    let s = token::intern_and_get_ident(&format_string[]);\n     let format_string = cx.expr_str(span, s);\n \n     // phew, not our responsibility any more!"}, {"sha": "9b54e259761db82f42d35d24bd7c9fef6abf497f", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -30,7 +30,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenT\n         Some(v) => v\n     };\n \n-    let e = match os::getenv(var.index(&FullRange)) {\n+    let e = match os::getenv(&var[]) {\n       None => {\n           cx.expr_path(cx.path_all(sp,\n                                    true,\n@@ -56,7 +56,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenT\n                                    cx.ident_of(\"Some\")),\n                               vec!(cx.expr_str(sp,\n                                                token::intern_and_get_ident(\n-                                          s.index(&FullRange)))))\n+                                          &s[]))))\n       }\n     };\n     MacExpr::new(e)\n@@ -81,9 +81,9 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     };\n     let msg = match exprs.next() {\n         None => {\n-            token::intern_and_get_ident(format!(\"environment variable `{}` \\\n+            token::intern_and_get_ident(&format!(\"environment variable `{}` \\\n                                                  not defined\",\n-                                                var).index(&FullRange))\n+                                                var)[])\n         }\n         Some(second) => {\n             match expr_to_string(cx, second, \"expected string literal\") {\n@@ -106,7 +106,7 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             cx.span_err(sp, msg.get());\n             cx.expr_uint(sp, 0)\n         }\n-        Some(s) => cx.expr_str(sp, token::intern_and_get_ident(s.index(&FullRange)))\n+        Some(s) => cx.expr_str(sp, token::intern_and_get_ident(&s[]))\n     };\n     MacExpr::new(e)\n }"}, {"sha": "1393e54d597151e322a20430577aebd5c1789ec5", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -286,8 +286,8 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                 None => {\n                     fld.cx.span_err(\n                         pth.span,\n-                        format!(\"macro undefined: '{}!'\",\n-                                extnamestr.get()).index(&FullRange));\n+                        &format!(\"macro undefined: '{}!'\",\n+                                extnamestr.get())[]);\n \n                     // let compilation continue\n                     None\n@@ -303,7 +303,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                                 },\n                             });\n                         let fm = fresh_mark();\n-                        let marked_before = mark_tts(tts.index(&FullRange), fm);\n+                        let marked_before = mark_tts(&tts[], fm);\n \n                         // The span that we pass to the expanders we want to\n                         // be the root of the call stack. That's the most\n@@ -314,17 +314,17 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                         let opt_parsed = {\n                             let expanded = expandfun.expand(fld.cx,\n                                                             mac_span,\n-                                                            marked_before.index(&FullRange));\n+                                                            &marked_before[]);\n                             parse_thunk(expanded)\n                         };\n                         let parsed = match opt_parsed {\n                             Some(e) => e,\n                             None => {\n                                 fld.cx.span_err(\n                                     pth.span,\n-                                    format!(\"non-expression macro in expression position: {}\",\n-                                            extnamestr.get().index(&FullRange)\n-                                            ).index(&FullRange));\n+                                    &format!(\"non-expression macro in expression position: {}\",\n+                                            &extnamestr.get()[]\n+                                            )[]);\n                                 return None;\n                             }\n                         };\n@@ -333,8 +333,8 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                     _ => {\n                         fld.cx.span_err(\n                             pth.span,\n-                            format!(\"'{}' is not a tt-style macro\",\n-                                    extnamestr.get()).index(&FullRange));\n+                            &format!(\"'{}' is not a tt-style macro\",\n+                                    extnamestr.get())[]);\n                         None\n                     }\n                 }\n@@ -439,7 +439,7 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n             if valid_ident {\n                 fld.cx.mod_push(it.ident);\n             }\n-            let macro_use = contains_macro_use(fld, new_attrs.index(&FullRange));\n+            let macro_use = contains_macro_use(fld, &new_attrs[]);\n             let result = with_exts_frame!(fld.cx.syntax_env,\n                                           macro_use,\n                                           noop_fold_item(it, fld));\n@@ -565,8 +565,8 @@ pub fn expand_item_mac(it: P<ast::Item>,\n         let expanded = match fld.cx.syntax_env.find(&extname.name) {\n             None => {\n                 fld.cx.span_err(path_span,\n-                                format!(\"macro undefined: '{}!'\",\n-                                        extnamestr).index(&FullRange));\n+                                &format!(\"macro undefined: '{}!'\",\n+                                        extnamestr)[]);\n                 // let compilation continue\n                 return SmallVector::zero();\n             }\n@@ -576,10 +576,10 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     if it.ident.name != parse::token::special_idents::invalid.name {\n                         fld.cx\n                             .span_err(path_span,\n-                                      format!(\"macro {}! expects no ident argument, \\\n+                                      &format!(\"macro {}! expects no ident argument, \\\n                                         given '{}'\",\n                                       extnamestr,\n-                                      token::get_ident(it.ident)).index(&FullRange));\n+                                      token::get_ident(it.ident))[]);\n                         return SmallVector::zero();\n                     }\n                     fld.cx.bt_push(ExpnInfo {\n@@ -591,14 +591,14 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                         }\n                     });\n                     // mark before expansion:\n-                    let marked_before = mark_tts(tts.index(&FullRange), fm);\n-                    expander.expand(fld.cx, it.span, marked_before.index(&FullRange))\n+                    let marked_before = mark_tts(&tts[], fm);\n+                    expander.expand(fld.cx, it.span, &marked_before[])\n                 }\n                 IdentTT(ref expander, span) => {\n                     if it.ident.name == parse::token::special_idents::invalid.name {\n                         fld.cx.span_err(path_span,\n-                                        format!(\"macro {}! expects an ident argument\",\n-                                                extnamestr.get()).index(&FullRange));\n+                                        &format!(\"macro {}! expects an ident argument\",\n+                                                extnamestr.get())[]);\n                         return SmallVector::zero();\n                     }\n                     fld.cx.bt_push(ExpnInfo {\n@@ -610,14 +610,14 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                         }\n                     });\n                     // mark before expansion:\n-                    let marked_tts = mark_tts(tts.index(&FullRange), fm);\n+                    let marked_tts = mark_tts(&tts[], fm);\n                     expander.expand(fld.cx, it.span, it.ident, marked_tts)\n                 }\n                 MacroRulesTT => {\n                     if it.ident.name == parse::token::special_idents::invalid.name {\n                         fld.cx.span_err(path_span,\n-                                        format!(\"macro_rules! expects an ident argument\")\n-                                            .index(&FullRange));\n+                                        &format!(\"macro_rules! expects an ident argument\")\n+                                        []);\n                         return SmallVector::zero();\n                     }\n                     fld.cx.bt_push(ExpnInfo {\n@@ -648,8 +648,8 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                 }\n                 _ => {\n                     fld.cx.span_err(it.span,\n-                                    format!(\"{}! is not legal in item position\",\n-                                            extnamestr.get()).index(&FullRange));\n+                                    &format!(\"{}! is not legal in item position\",\n+                                            extnamestr.get())[]);\n                     return SmallVector::zero();\n                 }\n             }\n@@ -667,8 +667,8 @@ pub fn expand_item_mac(it: P<ast::Item>,\n         }\n         None => {\n             fld.cx.span_err(path_span,\n-                            format!(\"non-item macro in item position: {}\",\n-                                    extnamestr.get()).index(&FullRange));\n+                            &format!(\"non-item macro in item position: {}\",\n+                                    extnamestr.get())[]);\n             return SmallVector::zero();\n         }\n     };\n@@ -913,8 +913,8 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n         let marked_after = match fld.cx.syntax_env.find(&extname.name) {\n             None => {\n                 fld.cx.span_err(pth.span,\n-                                format!(\"macro undefined: '{}!'\",\n-                                        extnamestr).index(&FullRange));\n+                                &format!(\"macro undefined: '{}!'\",\n+                                        extnamestr)[]);\n                 // let compilation continue\n                 return DummyResult::raw_pat(span);\n             }\n@@ -931,19 +931,19 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                     });\n \n                     let fm = fresh_mark();\n-                    let marked_before = mark_tts(tts.index(&FullRange), fm);\n+                    let marked_before = mark_tts(&tts[], fm);\n                     let mac_span = fld.cx.original_span();\n                     let expanded = match expander.expand(fld.cx,\n                                         mac_span,\n-                                        marked_before.index(&FullRange)).make_pat() {\n+                                        &marked_before[]).make_pat() {\n                         Some(e) => e,\n                         None => {\n                             fld.cx.span_err(\n                                 pth.span,\n-                                format!(\n+                                &format!(\n                                     \"non-pattern macro in pattern position: {}\",\n                                     extnamestr.get()\n-                                ).index(&FullRange)\n+                                    )[]\n                             );\n                             return DummyResult::raw_pat(span);\n                         }\n@@ -954,8 +954,8 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                 }\n                 _ => {\n                     fld.cx.span_err(span,\n-                                    format!(\"{}! is not legal in pattern position\",\n-                                            extnamestr.get()).index(&FullRange));\n+                                    &format!(\"{}! is not legal in pattern position\",\n+                                            extnamestr.get())[]);\n                     return DummyResult::raw_pat(span);\n                 }\n             }\n@@ -1232,7 +1232,7 @@ impl Folder for Marker {\n             node: match node {\n                 MacInvocTT(path, tts, ctxt) => {\n                     MacInvocTT(self.fold_path(path),\n-                               self.fold_tts(tts.index(&FullRange)),\n+                               self.fold_tts(&tts[]),\n                                mtwt::apply_mark(self.mark, ctxt))\n                 }\n             },\n@@ -1713,7 +1713,7 @@ foo_module!();\n                 let string = ident.get();\n                 \"xx\" == string\n             }).collect();\n-        let cxbinds: &[&ast::Ident] = cxbinds.index(&FullRange);\n+        let cxbinds: &[&ast::Ident] = &cxbinds[];\n         let cxbind = match cxbinds {\n             [b] => b,\n             _ => panic!(\"expected just one binding for ext_cx\")"}, {"sha": "637b6d4649d209a9c45a9a71eb3bbe1b131506b8", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -112,8 +112,8 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                 }\n                 _ => {\n                     ecx.span_err(p.span,\n-                                 format!(\"expected ident for named argument, found `{}`\",\n-                                         p.this_token_to_string()).index(&FullRange));\n+                                 &format!(\"expected ident for named argument, found `{}`\",\n+                                         p.this_token_to_string())[]);\n                     return None;\n                 }\n             };\n@@ -125,8 +125,8 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                 None => {}\n                 Some(prev) => {\n                     ecx.span_err(e.span,\n-                                 format!(\"duplicate argument named `{}`\",\n-                                         name).index(&FullRange));\n+                                 &format!(\"duplicate argument named `{}`\",\n+                                         name)[]);\n                     ecx.parse_sess.span_diagnostic.span_note(prev.span, \"previously here\");\n                     continue\n                 }\n@@ -217,7 +217,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     let msg = format!(\"invalid reference to argument `{}` ({})\",\n                                       arg, self.describe_num_args());\n \n-                    self.ecx.span_err(self.fmtsp, msg.index(&FullRange));\n+                    self.ecx.span_err(self.fmtsp, &msg[]);\n                     return;\n                 }\n                 {\n@@ -237,7 +237,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     Some(e) => e.span,\n                     None => {\n                         let msg = format!(\"there is no argument named `{}`\", name);\n-                        self.ecx.span_err(self.fmtsp, msg.index(&FullRange));\n+                        self.ecx.span_err(self.fmtsp, &msg[]);\n                         return;\n                     }\n                 };\n@@ -277,22 +277,22 @@ impl<'a, 'b> Context<'a, 'b> {\n         match (cur, ty) {\n             (&Known(ref cur), &Known(ref ty)) => {\n                 self.ecx.span_err(sp,\n-                                  format!(\"argument redeclared with type `{}` when \\\n+                                  &format!(\"argument redeclared with type `{}` when \\\n                                            it was previously `{}`\",\n                                           *ty,\n-                                          *cur).index(&FullRange));\n+                                          *cur)[]);\n             }\n             (&Known(ref cur), _) => {\n                 self.ecx.span_err(sp,\n-                                  format!(\"argument used to format with `{}` was \\\n+                                  &format!(\"argument used to format with `{}` was \\\n                                            attempted to not be used for formatting\",\n-                                           *cur).index(&FullRange));\n+                                           *cur)[]);\n             }\n             (_, &Known(ref ty)) => {\n                 self.ecx.span_err(sp,\n-                                  format!(\"argument previously used as a format \\\n+                                  &format!(\"argument previously used as a format \\\n                                            argument attempted to be used as `{}`\",\n-                                           *ty).index(&FullRange));\n+                                           *ty)[]);\n             }\n             (_, _) => {\n                 self.ecx.span_err(sp, \"argument declared with multiple formats\");\n@@ -357,7 +357,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// Translate the accumulated string literals to a literal expression\n     fn trans_literal_string(&mut self) -> P<ast::Expr> {\n         let sp = self.fmtsp;\n-        let s = token::intern_and_get_ident(self.literal.index(&FullRange));\n+        let s = token::intern_and_get_ident(&self.literal[]);\n         self.literal.clear();\n         self.ecx.expr_str(sp, s)\n     }\n@@ -509,7 +509,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 None => continue // error already generated\n             };\n \n-            let name = self.ecx.ident_of(format!(\"__arg{}\", i).index(&FullRange));\n+            let name = self.ecx.ident_of(&format!(\"__arg{}\", i)[]);\n             pats.push(self.ecx.pat_ident(e.span, name));\n             locals.push(Context::format_arg(self.ecx, e.span, arg_ty,\n                                             self.ecx.expr_ident(e.span, name)));\n@@ -525,8 +525,8 @@ impl<'a, 'b> Context<'a, 'b> {\n                 None => continue\n             };\n \n-            let lname = self.ecx.ident_of(format!(\"__arg{}\",\n-                                                  *name).index(&FullRange));\n+            let lname = self.ecx.ident_of(&format!(\"__arg{}\",\n+                                                  *name)[]);\n             pats.push(self.ecx.pat_ident(e.span, lname));\n             names[self.name_positions[*name]] =\n                 Some(Context::format_arg(self.ecx, e.span, arg_ty,\n@@ -606,7 +606,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                   -> P<ast::Expr> {\n         let trait_ = match *ty {\n             Known(ref tyname) => {\n-                match tyname.index(&FullRange) {\n+                match &tyname[] {\n                     \"\"  => \"String\",\n                     \"?\" => \"Show\",\n                     \"e\" => \"LowerExp\",\n@@ -618,8 +618,8 @@ impl<'a, 'b> Context<'a, 'b> {\n                     \"X\" => \"UpperHex\",\n                     _ => {\n                         ecx.span_err(sp,\n-                                     format!(\"unknown format trait `{}`\",\n-                                             *tyname).index(&FullRange));\n+                                     &format!(\"unknown format trait `{}`\",\n+                                             *tyname)[]);\n                         \"Dummy\"\n                     }\n                 }\n@@ -709,8 +709,8 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         }\n     }\n     if !parser.errors.is_empty() {\n-        cx.ecx.span_err(cx.fmtsp, format!(\"invalid format string: {}\",\n-                                          parser.errors.remove(0)).index(&FullRange));\n+        cx.ecx.span_err(cx.fmtsp, &format!(\"invalid format string: {}\",\n+                                          parser.errors.remove(0))[]);\n         return DummyResult::raw_expr(sp);\n     }\n     if !cx.literal.is_empty() {"}, {"sha": "ae8ff118fcc0fefced187de569f65a8a1d016318", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -223,7 +223,7 @@ pub fn marksof(ctxt: SyntaxContext, stopname: Name) -> Vec<Mrk> {\n }\n \n // the internal function for computing marks\n-// it's not clear to me whether it's better to use a .index(&FullRange) mutable\n+// it's not clear to me whether it's better to use a [] mutable\n // vector or a cons-list for this.\n fn marksof_internal(ctxt: SyntaxContext,\n                     stopname: Name,"}, {"sha": "2dbf29c145c8ab1dea9d534284b644ca6f20aacf", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -473,7 +473,7 @@ pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n }\n \n fn ids_ext(strs: Vec<String> ) -> Vec<ast::Ident> {\n-    strs.iter().map(|str| str_to_ident((*str).index(&FullRange))).collect()\n+    strs.iter().map(|str| str_to_ident(&(*str)[])).collect()\n }\n \n fn id_ext(str: &str) -> ast::Ident {\n@@ -675,7 +675,7 @@ fn mk_tt(cx: &ExtCtxt, tt: &ast::TokenTree) -> Vec<P<ast::Stmt>> {\n             for i in range(0, tt.len()) {\n                 seq.push(tt.get_tt(i));\n             }\n-            mk_tts(cx, seq.index(&FullRange))\n+            mk_tts(cx, &seq[])\n         }\n         ast::TtToken(sp, ref tok) => {\n             let e_sp = cx.expr_ident(sp, id_ext(\"_sp\"));\n@@ -764,7 +764,7 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     let stmt_let_tt = cx.stmt_let(sp, true, id_ext(\"tt\"), cx.expr_vec_ng(sp));\n \n     let mut vector = vec!(stmt_let_sp, stmt_let_tt);\n-    vector.extend(mk_tts(cx, tts.index(&FullRange)).into_iter());\n+    vector.extend(mk_tts(cx, &tts[]).into_iter());\n     let block = cx.expr_block(\n         cx.block_all(sp,\n                      Vec::new(),"}, {"sha": "b671b1a71b0452fc1c753429bd3da23dc3edaa99", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -57,15 +57,15 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n     let topmost = cx.original_span_in_file();\n     let loc = cx.codemap().lookup_char_pos(topmost.lo);\n-    let filename = token::intern_and_get_ident(loc.file.name.index(&FullRange));\n+    let filename = token::intern_and_get_ident(&loc.file.name[]);\n     base::MacExpr::new(cx.expr_str(topmost, filename))\n }\n \n pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                         -> Box<base::MacResult+'static> {\n     let s = pprust::tts_to_string(tts);\n     base::MacExpr::new(cx.expr_str(sp,\n-                                   token::intern_and_get_ident(s.index(&FullRange))))\n+                                   token::intern_and_get_ident(&s[])))\n }\n \n pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n@@ -78,7 +78,7 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                    .connect(\"::\");\n     base::MacExpr::new(cx.expr_str(\n             sp,\n-            token::intern_and_get_ident(string.index(&FullRange))))\n+            token::intern_and_get_ident(&string[])))\n }\n \n /// include! : parse the given file as an expr\n@@ -135,9 +135,9 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     let bytes = match File::open(&file).read_to_end() {\n         Err(e) => {\n             cx.span_err(sp,\n-                        format!(\"couldn't read {:?}: {}\",\n+                        &format!(\"couldn't read {:?}: {}\",\n                                 file.display(),\n-                                e).index(&FullRange));\n+                                e)[]);\n             return DummyResult::expr(sp);\n         }\n         Ok(bytes) => bytes,\n@@ -147,15 +147,15 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             // Add this input file to the code map to make it available as\n             // dependency information\n             let filename = format!(\"{:?}\", file.display());\n-            let interned = token::intern_and_get_ident(src.index(&FullRange));\n+            let interned = token::intern_and_get_ident(&src[]);\n             cx.codemap().new_filemap(filename, src);\n \n             base::MacExpr::new(cx.expr_str(sp, interned))\n         }\n         Err(_) => {\n             cx.span_err(sp,\n-                        format!(\"{:?} wasn't a utf-8 file\",\n-                                file.display()).index(&FullRange));\n+                        &format!(\"{:?} wasn't a utf-8 file\",\n+                                file.display())[]);\n             return DummyResult::expr(sp);\n         }\n     }\n@@ -177,7 +177,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     match File::open(&file).read_to_end() {\n         Err(e) => {\n             cx.span_err(sp,\n-                        format!(\"couldn't read {:?}: {}\", file.display(), e).index(&FullRange));\n+                        &format!(\"couldn't read {:?}: {}\", file.display(), e)[]);\n             return DummyResult::expr(sp);\n         }\n         Ok(bytes) => {"}, {"sha": "9eda4bcef9942fcfa442588b327a96df47a8ea00", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -153,7 +153,7 @@ pub fn count_names(ms: &[TokenTree]) -> uint {\n                 seq.num_captures\n             }\n             &TtDelimited(_, ref delim) => {\n-                count_names(delim.tts.index(&FullRange))\n+                count_names(&delim.tts[])\n             }\n             &TtToken(_, MatchNt(..)) => {\n                 1\n@@ -165,7 +165,7 @@ pub fn count_names(ms: &[TokenTree]) -> uint {\n \n pub fn initial_matcher_pos(ms: Rc<Vec<TokenTree>>, sep: Option<Token>, lo: BytePos)\n                            -> Box<MatcherPos> {\n-    let match_idx_hi = count_names(ms.index(&FullRange));\n+    let match_idx_hi = count_names(&ms[]);\n     let matches: Vec<_> = range(0, match_idx_hi).map(|_| Vec::new()).collect();\n     box MatcherPos {\n         stack: vec![],\n@@ -228,8 +228,8 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n                         let string = token::get_ident(bind_name);\n                         p_s.span_diagnostic\n                            .span_fatal(sp,\n-                                       format!(\"duplicated bind name: {}\",\n-                                               string.get()).index(&FullRange))\n+                                       &format!(\"duplicated bind name: {}\",\n+                                               string.get())[])\n                     }\n                 }\n             }\n@@ -254,13 +254,13 @@ pub fn parse_or_else(sess: &ParseSess,\n                      rdr: TtReader,\n                      ms: Vec<TokenTree> )\n                      -> HashMap<Ident, Rc<NamedMatch>> {\n-    match parse(sess, cfg, rdr, ms.index(&FullRange)) {\n+    match parse(sess, cfg, rdr, &ms[]) {\n         Success(m) => m,\n         Failure(sp, str) => {\n-            sess.span_diagnostic.span_fatal(sp, str.index(&FullRange))\n+            sess.span_diagnostic.span_fatal(sp, &str[])\n         }\n         Error(sp, str) => {\n-            sess.span_diagnostic.span_fatal(sp, str.index(&FullRange))\n+            sess.span_diagnostic.span_fatal(sp, &str[])\n         }\n     }\n }\n@@ -447,7 +447,7 @@ pub fn parse(sess: &ParseSess,\n                 for dv in (&mut eof_eis[0]).matches.iter_mut() {\n                     v.push(dv.pop().unwrap());\n                 }\n-                return Success(nameize(sess, ms, v.index(&FullRange)));\n+                return Success(nameize(sess, ms, &v[]));\n             } else if eof_eis.len() > 1u {\n                 return Error(sp, \"ambiguity: multiple successful parses\".to_string());\n             } else {\n@@ -532,16 +532,16 @@ pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n         token::Ident(sn,b) => { p.bump(); token::NtIdent(box sn,b) }\n         _ => {\n             let token_str = pprust::token_to_string(&p.token);\n-            p.fatal((format!(\"expected ident, found {}\",\n-                             token_str.index(&FullRange))).index(&FullRange))\n+            p.fatal(&format!(\"expected ident, found {}\",\n+                             &token_str[])[])\n         }\n       },\n       \"path\" => {\n         token::NtPath(box p.parse_path(LifetimeAndTypesWithoutColons))\n       }\n       \"meta\" => token::NtMeta(p.parse_meta_item()),\n       _ => {\n-          p.fatal(format!(\"unsupported builtin nonterminal parser: {}\", name).index(&FullRange))\n+          p.fatal(&format!(\"unsupported builtin nonterminal parser: {}\", name)[])\n       }\n     }\n }"}, {"sha": "fc341e3bd8559e623f51cbc86874a328e563a83e", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -52,7 +52,7 @@ impl<'a> ParserAnyMacro<'a> {\n                                following\",\n                               token_str);\n             let span = parser.span;\n-            parser.span_err(span, msg.index(&FullRange));\n+            parser.span_err(span, &msg[]);\n         }\n     }\n }\n@@ -126,8 +126,8 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n                           self.name,\n                           self.imported_from,\n                           arg,\n-                          self.lhses.index(&FullRange),\n-                          self.rhses.index(&FullRange))\n+                          &self.lhses[],\n+                          &self.rhses[])\n     }\n }\n \n@@ -154,7 +154,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n         match **lhs {\n           MatchedNonterminal(NtTT(ref lhs_tt)) => {\n             let lhs_tt = match **lhs_tt {\n-                TtDelimited(_, ref delim) => delim.tts.index(&FullRange),\n+                TtDelimited(_, ref delim) => &delim.tts[],\n                 _ => cx.span_fatal(sp, \"malformed macro lhs\")\n             };\n             // `None` is because we're not interpolating\n@@ -195,13 +195,13 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 best_fail_spot = sp;\n                 best_fail_msg = (*msg).clone();\n               },\n-              Error(sp, ref msg) => cx.span_fatal(sp, msg.index(&FullRange))\n+              Error(sp, ref msg) => cx.span_fatal(sp, &msg[])\n             }\n           }\n           _ => cx.bug(\"non-matcher found in parsed lhses\")\n         }\n     }\n-    cx.span_fatal(best_fail_spot, best_fail_msg.index(&FullRange));\n+    cx.span_fatal(best_fail_spot, &best_fail_msg[]);\n }\n \n // Note that macro-by-example's input is also matched against a token tree:"}, {"sha": "94b8356130aeb576ecd7d53445f5186d2e404005", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -255,7 +255,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                     }\n                     LisContradiction(ref msg) => {\n                         // FIXME #2887 blame macro invoker instead\n-                        r.sp_diag.span_fatal(sp.clone(), msg.index(&FullRange));\n+                        r.sp_diag.span_fatal(sp.clone(), &msg[]);\n                     }\n                     LisConstraint(len, _) => {\n                         if len == 0 {\n@@ -308,8 +308,8 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                             MatchedSeq(..) => {\n                                 r.sp_diag.span_fatal(\n                                     r.cur_span, /* blame the macro writer */\n-                                    format!(\"variable '{:?}' is still repeating at this depth\",\n-                                            token::get_ident(ident)).index(&FullRange));\n+                                    &format!(\"variable '{:?}' is still repeating at this depth\",\n+                                            token::get_ident(ident))[]);\n                             }\n                         }\n                     }"}, {"sha": "21d3e4fef7f9675f0930fd4f4f76e5e0fef931cf", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -69,7 +69,7 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"tuple_indexing\", Accepted),\n     (\"associated_types\", Accepted),\n     (\"visible_private_types\", Active),\n-    (\"slicing_syntax\", Active),\n+    (\"slicing_syntax\", Accepted),\n \n     (\"if_let\", Accepted),\n     (\"while_let\", Accepted),\n@@ -150,9 +150,9 @@ impl<'a> Context<'a> {\n     fn gate_feature(&self, feature: &str, span: Span, explain: &str) {\n         if !self.has_feature(feature) {\n             self.span_handler.span_err(span, explain);\n-            self.span_handler.span_help(span, format!(\"add #![feature({})] to the \\\n+            self.span_handler.span_help(span, &format!(\"add #![feature({})] to the \\\n                                                        crate attributes to enable\",\n-                                                      feature).index(&FullRange));\n+                                                      feature)[]);\n         }\n     }\n \n@@ -243,7 +243,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n         }\n         match i.node {\n             ast::ItemForeignMod(ref foreign_module) => {\n-                if attr::contains_name(i.attrs.index(&FullRange), \"link_args\") {\n+                if attr::contains_name(&i.attrs[], \"link_args\") {\n                     self.gate_feature(\"link_args\", i.span,\n                                       \"the `link_args` attribute is not portable \\\n                                        across platforms, it is recommended to \\\n@@ -257,14 +257,14 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemFn(..) => {\n-                if attr::contains_name(i.attrs.index(&FullRange), \"plugin_registrar\") {\n+                if attr::contains_name(&i.attrs[], \"plugin_registrar\") {\n                     self.gate_feature(\"plugin_registrar\", i.span,\n                                       \"compiler plugins are experimental and possibly buggy\");\n                 }\n             }\n \n             ast::ItemStruct(..) => {\n-                if attr::contains_name(i.attrs.index(&FullRange), \"simd\") {\n+                if attr::contains_name(&i.attrs[], \"simd\") {\n                     self.gate_feature(\"simd\", i.span,\n                                       \"SIMD types are experimental and possibly buggy\");\n                 }\n@@ -290,15 +290,15 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                                        removed in the future\");\n                 }\n \n-                if attr::contains_name(i.attrs.index(&FullRange),\n+                if attr::contains_name(&i.attrs[],\n                                        \"old_orphan_check\") {\n                     self.gate_feature(\n                         \"old_orphan_check\",\n                         i.span,\n                         \"the new orphan check rules will eventually be strictly enforced\");\n                 }\n \n-                if attr::contains_name(i.attrs.index(&FullRange),\n+                if attr::contains_name(&i.attrs[],\n                                        \"old_impl_check\") {\n                     self.gate_feature(\"old_impl_check\",\n                                       i.span,\n@@ -313,7 +313,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n-        if attr::contains_name(i.attrs.index(&FullRange), \"linkage\") {\n+        if attr::contains_name(&i.attrs[], \"linkage\") {\n             self.gate_feature(\"linkage\", i.span,\n                               \"the `linkage` attribute is experimental \\\n                                and not portable across platforms\")\n@@ -337,14 +337,6 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_expr(&mut self, e: &ast::Expr) {\n-        match e.node {\n-            ast::ExprRange(..) => {\n-                self.gate_feature(\"slicing_syntax\",\n-                                  e.span,\n-                                  \"range syntax is experimental\");\n-            }\n-            _ => {}\n-        }\n         visit::walk_expr(self, e);\n     }\n "}, {"sha": "54ec9c7b146d79b610c234a791a36f043d891e1b", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -92,7 +92,7 @@ impl<'a> ParserAttr for Parser<'a> {\n             }\n             _ => {\n                 let token_str = self.this_token_to_string();\n-                self.fatal(format!(\"expected `#`, found `{}`\", token_str).index(&FullRange));\n+                self.fatal(&format!(\"expected `#`, found `{}`\", token_str)[]);\n             }\n         };\n "}, {"sha": "16ade904be8834ee707a80fea10821f2be8a8e62", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -82,7 +82,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n         while j > i && lines[j - 1].trim().is_empty() {\n             j -= 1;\n         }\n-        return lines.index(&(i..j)).iter().map(|x| (*x).clone()).collect();\n+        return lines[i..j].iter().map(|x| (*x).clone()).collect();\n     }\n \n     /// remove a \"[ \\t]*\\*\" block from each line, if possible\n@@ -116,7 +116,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n \n         if can_trim {\n             lines.iter().map(|line| {\n-                line.index(&((i + 1)..line.len())).to_string()\n+                (&line[(i + 1)..line.len()]).to_string()\n             }).collect()\n         } else {\n             lines\n@@ -127,12 +127,12 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n     static ONLINERS: &'static [&'static str] = &[\"///!\", \"///\", \"//!\", \"//\"];\n     for prefix in ONLINERS.iter() {\n         if comment.starts_with(*prefix) {\n-            return comment.index(&(prefix.len()..)).to_string();\n+            return (&comment[prefix.len()..]).to_string();\n         }\n     }\n \n     if comment.starts_with(\"/*\") {\n-        let lines = comment.index(&(3u..(comment.len() - 2u)))\n+        let lines = comment[3u..(comment.len() - 2u)]\n             .lines_any()\n             .map(|s| s.to_string())\n             .collect::<Vec<String> >();\n@@ -187,7 +187,7 @@ fn read_line_comments(rdr: &mut StringReader, code_to_the_left: bool,\n         let line = rdr.read_one_line_comment();\n         debug!(\"{}\", line);\n         // Doc comments are not put in comments.\n-        if is_doc_comment(line.index(&FullRange)) {\n+        if is_doc_comment(&line[]) {\n             break;\n         }\n         lines.push(line);\n@@ -224,10 +224,10 @@ fn all_whitespace(s: &str, col: CharPos) -> Option<uint> {\n fn trim_whitespace_prefix_and_push_line(lines: &mut Vec<String> ,\n                                         s: String, col: CharPos) {\n     let len = s.len();\n-    let s1 = match all_whitespace(s.index(&FullRange), col) {\n+    let s1 = match all_whitespace(&s[], col) {\n         Some(col) => {\n             if col < len {\n-                s.index(&(col..len)).to_string()\n+                (&s[col..len]).to_string()\n             } else {\n                 \"\".to_string()\n             }\n@@ -261,7 +261,7 @@ fn read_block_comment(rdr: &mut StringReader,\n             rdr.bump();\n             rdr.bump();\n         }\n-        if is_block_doc_comment(curr_line.index(&FullRange)) {\n+        if is_block_doc_comment(&curr_line[]) {\n             return\n         }\n         assert!(!curr_line.contains_char('\\n'));"}, {"sha": "4cdafb36eecc4b9ddf937b436bfdcdba23341db5", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -196,7 +196,7 @@ impl<'a> StringReader<'a> {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n         for c in c.escape_default() { m.push(c) }\n-        self.fatal_span_(from_pos, to_pos, m.index(&FullRange));\n+        self.fatal_span_(from_pos, to_pos, &m[]);\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n@@ -205,7 +205,7 @@ impl<'a> StringReader<'a> {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n         for c in c.escape_default() { m.push(c) }\n-        self.err_span_(from_pos, to_pos, m.index(&FullRange));\n+        self.err_span_(from_pos, to_pos, &m[]);\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending the\n@@ -214,8 +214,8 @@ impl<'a> StringReader<'a> {\n         m.push_str(\": \");\n         let from = self.byte_offset(from_pos).to_uint();\n         let to = self.byte_offset(to_pos).to_uint();\n-        m.push_str(self.filemap.src.index(&(from..to)));\n-        self.fatal_span_(from_pos, to_pos, m.index(&FullRange));\n+        m.push_str(&self.filemap.src[from..to]);\n+        self.fatal_span_(from_pos, to_pos, &m[]);\n     }\n \n     /// Advance peek_tok and peek_span to refer to the next token, and\n@@ -301,7 +301,7 @@ impl<'a> StringReader<'a> {\n             while i < s.len() {\n                 let str::CharRange { ch, next } = s.char_range_at(i);\n                 if ch == '\\r' {\n-                    if j < i { buf.push_str(s.index(&(j..i))); }\n+                    if j < i { buf.push_str(&s[j..i]); }\n                     j = next;\n                     if next >= s.len() || s.char_at(next) != '\\n' {\n                         let pos = start + BytePos(i as u32);\n@@ -311,7 +311,7 @@ impl<'a> StringReader<'a> {\n                 }\n                 i = next;\n             }\n-            if j < s.len() { buf.push_str(s.index(&(j..))); }\n+            if j < s.len() { buf.push_str(&s[j..]); }\n             buf\n         }\n     }\n@@ -556,7 +556,7 @@ impl<'a> StringReader<'a> {\n                     self.translate_crlf(start_bpos, string,\n                                         \"bare CR not allowed in block doc-comment\")\n                 } else { string.into_cow() };\n-                token::DocComment(token::intern(string.index(&FullRange)))\n+                token::DocComment(token::intern(&string[]))\n             } else {\n                 token::Comment\n             };\n@@ -1110,7 +1110,7 @@ impl<'a> StringReader<'a> {\n                 // expansion purposes. See #12512 for the gory details of why\n                 // this is necessary.\n                 let ident = self.with_str_from(start, |lifetime_name| {\n-                    str_to_ident(format!(\"'{}\", lifetime_name).index(&FullRange))\n+                    str_to_ident(&format!(\"'{}\", lifetime_name)[])\n                 });\n \n                 // Conjure up a \"keyword checking ident\" to make sure that"}, {"sha": "c42a6beea2d447baec345b07f218ff1bc4da721e", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -253,19 +253,19 @@ pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n     let bytes = match File::open(path).read_to_end() {\n         Ok(bytes) => bytes,\n         Err(e) => {\n-            err(format!(\"couldn't read {:?}: {:?}\",\n+            err(&format!(\"couldn't read {:?}: {:?}\",\n                         path.display(),\n-                        e).index(&FullRange));\n+                        e)[]);\n             unreachable!()\n         }\n     };\n-    match str::from_utf8(bytes.index(&FullRange)).ok() {\n+    match str::from_utf8(&bytes[]).ok() {\n         Some(s) => {\n             return string_to_filemap(sess, s.to_string(),\n                                      path.as_str().unwrap().to_string())\n         }\n         None => {\n-            err(format!(\"{:?} is not UTF-8 encoded\", path.display()).index(&FullRange))\n+            err(&format!(\"{:?} is not UTF-8 encoded\", path.display())[])\n         }\n     }\n     unreachable!()\n@@ -399,18 +399,18 @@ pub fn char_lit(lit: &str) -> (char, int) {\n     }\n \n     let msg = format!(\"lexer should have rejected a bad character escape {}\", lit);\n-    let msg2 = msg.index(&FullRange);\n+    let msg2 = &msg[];\n \n     fn esc(len: uint, lit: &str) -> Option<(char, int)> {\n-        num::from_str_radix(lit.index(&(2..len)), 16)\n+        num::from_str_radix(&lit[2..len], 16)\n         .and_then(char::from_u32)\n         .map(|x| (x, len as int))\n     }\n \n     let unicode_escape = |&: | -> Option<(char, int)>\n         if lit.as_bytes()[2] == b'{' {\n             let idx = lit.find('}').expect(msg2);\n-            let subslice = lit.index(&(3..idx));\n+            let subslice = &lit[3..idx];\n             num::from_str_radix(subslice, 16)\n                 .and_then(char::from_u32)\n                 .map(|x| (x, subslice.chars().count() as int + 4))\n@@ -472,7 +472,7 @@ pub fn str_lit(lit: &str) -> String {\n                             eat(&mut chars);\n                         } else {\n                             // otherwise, a normal escape\n-                            let (c, n) = char_lit(lit.index(&(i..)));\n+                            let (c, n) = char_lit(&lit[i..]);\n                             for _ in range(0, n - 1) { // we don't need to move past the first \\\n                                 chars.next();\n                             }\n@@ -535,7 +535,7 @@ pub fn raw_str_lit(lit: &str) -> String {\n fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n     s.len() > 1 &&\n         first_chars.contains(&s.char_at(0)) &&\n-        s.index(&(1..)).chars().all(|c| '0' <= c && c <= '9')\n+        s[1..].chars().all(|c| '0' <= c && c <= '9')\n }\n \n fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n@@ -548,7 +548,7 @@ fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n             if suf.len() >= 2 && looks_like_width_suffix(&['f'], suf) {\n                 // if it looks like a width, lets try to be helpful.\n                 sd.span_err(sp, &*format!(\"illegal width `{}` for float literal, \\\n-                                          valid widths are 32 and 64\", suf.index(&(1..))));\n+                                          valid widths are 32 and 64\", &suf[1..]));\n             } else {\n                 sd.span_err(sp, &*format!(\"illegal suffix `{}` for float literal, \\\n                                           valid suffixes are `f32` and `f64`\", suf));\n@@ -584,7 +584,7 @@ pub fn byte_lit(lit: &str) -> (u8, uint) {\n             b'\\'' => b'\\'',\n             b'0' => b'\\0',\n             _ => {\n-                match ::std::num::from_str_radix::<u64>(lit.index(&(2..4)), 16) {\n+                match ::std::num::from_str_radix::<u64>(&lit[2..4], 16) {\n                     Some(c) =>\n                         if c > 0xFF {\n                             panic!(err(2))\n@@ -634,7 +634,7 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n                     }\n                     _ => {\n                         // otherwise, a normal escape\n-                        let (c, n) = byte_lit(lit.index(&(i..)));\n+                        let (c, n) = byte_lit(&lit[i..]);\n                         // we don't need to move past the first \\\n                         for _ in range(0, n - 1) {\n                             chars.next();\n@@ -663,7 +663,7 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n     // s can only be ascii, byte indexing is fine\n \n     let s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n-    let mut s = s2.index(&FullRange);\n+    let mut s = &s2[];\n \n     debug!(\"integer_lit: {}, {:?}\", s, suffix);\n \n@@ -696,7 +696,7 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n     }\n \n     if base != 10 {\n-        s = s.index(&(2..));\n+        s = &s[2..];\n     }\n \n     if let Some(suf) = suffix {\n@@ -720,7 +720,7 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n                 if looks_like_width_suffix(&['i', 'u'], suf) {\n                     sd.span_err(sp, &*format!(\"illegal width `{}` for integer literal; \\\n                                               valid widths are 8, 16, 32 and 64\",\n-                                              suf.index(&(1..))));\n+                                              &suf[1..]));\n                 } else {\n                     sd.span_err(sp, &*format!(\"illegal suffix `{}` for numeric literal\", suf));\n                 }\n@@ -818,27 +818,27 @@ mod test {\n     #[test]\n     fn string_to_tts_macro () {\n         let tts = string_to_tts(\"macro_rules! zip (($a)=>($a))\".to_string());\n-        let tts: &[ast::TokenTree] = tts.index(&FullRange);\n+        let tts: &[ast::TokenTree] = &tts[];\n         match tts {\n             [ast::TtToken(_, token::Ident(name_macro_rules, token::Plain)),\n              ast::TtToken(_, token::Not),\n              ast::TtToken(_, token::Ident(name_zip, token::Plain)),\n              ast::TtDelimited(_, ref macro_delimed)]\n             if name_macro_rules.as_str() == \"macro_rules\"\n             && name_zip.as_str() == \"zip\" => {\n-                match macro_delimed.tts.index(&FullRange) {\n+                match &macro_delimed.tts[] {\n                     [ast::TtDelimited(_, ref first_delimed),\n                      ast::TtToken(_, token::FatArrow),\n                      ast::TtDelimited(_, ref second_delimed)]\n                     if macro_delimed.delim == token::Paren => {\n-                        match first_delimed.tts.index(&FullRange) {\n+                        match &first_delimed.tts[] {\n                             [ast::TtToken(_, token::Dollar),\n                              ast::TtToken(_, token::Ident(name, token::Plain))]\n                             if first_delimed.delim == token::Paren\n                             && name.as_str() == \"a\" => {},\n                             _ => panic!(\"value 3: {:?}\", **first_delimed),\n                         }\n-                        match second_delimed.tts.index(&FullRange) {\n+                        match &second_delimed.tts[] {\n                             [ast::TtToken(_, token::Dollar),\n                              ast::TtToken(_, token::Ident(name, token::Plain))]\n                             if second_delimed.delim == token::Paren\n@@ -1116,24 +1116,24 @@ mod test {\n         let use_s = \"use foo::bar::baz;\";\n         let vitem = string_to_view_item(use_s.to_string());\n         let vitem_s = view_item_to_string(&vitem);\n-        assert_eq!(vitem_s.index(&FullRange), use_s);\n+        assert_eq!(&vitem_s[], use_s);\n \n         let use_s = \"use foo::bar as baz;\";\n         let vitem = string_to_view_item(use_s.to_string());\n         let vitem_s = view_item_to_string(&vitem);\n-        assert_eq!(vitem_s.index(&FullRange), use_s);\n+        assert_eq!(&vitem_s[], use_s);\n     }\n \n     #[test] fn parse_extern_crate() {\n         let ex_s = \"extern crate foo;\";\n         let vitem = string_to_view_item(ex_s.to_string());\n         let vitem_s = view_item_to_string(&vitem);\n-        assert_eq!(vitem_s.index(&FullRange), ex_s);\n+        assert_eq!(&vitem_s[], ex_s);\n \n         let ex_s = \"extern crate \\\"foo\\\" as bar;\";\n         let vitem = string_to_view_item(ex_s.to_string());\n         let vitem_s = view_item_to_string(&vitem);\n-        assert_eq!(vitem_s.index(&FullRange), ex_s);\n+        assert_eq!(&vitem_s[], ex_s);\n     }\n \n     fn get_spans_of_pat_idents(src: &str) -> Vec<Span> {\n@@ -1212,7 +1212,7 @@ mod test {\n         let docs = item.attrs.iter().filter(|a| a.name().get() == \"doc\")\n                     .map(|a| a.value_str().unwrap().get().to_string()).collect::<Vec<_>>();\n         let b: &[_] = &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()];\n-        assert_eq!(docs.index(&FullRange), b);\n+        assert_eq!(&docs[], b);\n \n         let source = \"/** doc comment\\r\\n *  with CRLF */\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name, source, Vec::new(), &sess).unwrap();"}, {"sha": "e9e207e7dbc3ba15fbbb3de1ba1edbac07176530", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -127,13 +127,13 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n               kind_str: &str,\n               desc: &str) {\n         self.span_err(sp,\n-                      format!(\"obsolete syntax: {}\", kind_str).index(&FullRange));\n+                      &format!(\"obsolete syntax: {}\", kind_str)[]);\n \n         if !self.obsolete_set.contains(&kind) {\n             self.sess\n                 .span_diagnostic\n                 .handler()\n-                .note(format!(\"{}\", desc).index(&FullRange));\n+                .note(&format!(\"{}\", desc)[]);\n             self.obsolete_set.insert(kind);\n         }\n     }"}, {"sha": "3497bebd0bbae1076f77332b411e63c52e838501", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 108, "deletions": 109, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -388,13 +388,13 @@ impl<'a> Parser<'a> {\n     pub fn unexpected_last(&mut self, t: &token::Token) -> ! {\n         let token_str = Parser::token_to_string(t);\n         let last_span = self.last_span;\n-        self.span_fatal(last_span, format!(\"unexpected token: `{}`\",\n-                                                token_str).index(&FullRange));\n+        self.span_fatal(last_span, &format!(\"unexpected token: `{}`\",\n+                                                token_str)[]);\n     }\n \n     pub fn unexpected(&mut self) -> ! {\n         let this_token = self.this_token_to_string();\n-        self.fatal(format!(\"unexpected token: `{}`\", this_token).index(&FullRange));\n+        self.fatal(&format!(\"unexpected token: `{}`\", this_token)[]);\n     }\n \n     /// Expect and consume the token t. Signal an error if\n@@ -406,9 +406,9 @@ impl<'a> Parser<'a> {\n             } else {\n                 let token_str = Parser::token_to_string(t);\n                 let this_token_str = self.this_token_to_string();\n-                self.fatal(format!(\"expected `{}`, found `{}`\",\n+                self.fatal(&format!(\"expected `{}`, found `{}`\",\n                                    token_str,\n-                                   this_token_str).index(&FullRange))\n+                                   this_token_str)[])\n             }\n         } else {\n             self.expect_one_of(slice::ref_slice(t), &[]);\n@@ -449,18 +449,18 @@ impl<'a> Parser<'a> {\n             expected.push_all(&*self.expected_tokens);\n             expected.sort_by(|a, b| a.to_string().cmp(&b.to_string()));\n             expected.dedup();\n-            let expect = tokens_to_string(expected.index(&FullRange));\n+            let expect = tokens_to_string(&expected[]);\n             let actual = self.this_token_to_string();\n             self.fatal(\n-                (if expected.len() != 1 {\n+                &(if expected.len() != 1 {\n                     (format!(\"expected one of {}, found `{}`\",\n                              expect,\n                              actual))\n                 } else {\n                     (format!(\"expected {}, found `{}`\",\n                              expect,\n                              actual))\n-                }).index(&FullRange)\n+                }[])\n             )\n         }\n     }\n@@ -493,7 +493,7 @@ impl<'a> Parser<'a> {\n             // might be unit-struct construction; check for recoverableinput error.\n             let mut expected = edible.iter().map(|x| x.clone()).collect::<Vec<_>>();\n             expected.push_all(inedible);\n-            self.check_for_erroneous_unit_struct_expecting(expected.index(&FullRange));\n+            self.check_for_erroneous_unit_struct_expecting(&expected[]);\n         }\n         self.expect_one_of(edible, inedible)\n     }\n@@ -510,9 +510,9 @@ impl<'a> Parser<'a> {\n                .as_ref()\n                .map_or(false, |t| t.is_ident() || t.is_path()) {\n             let mut expected = edible.iter().map(|x| x.clone()).collect::<Vec<_>>();\n-            expected.push_all(inedible.index(&FullRange));\n+            expected.push_all(&inedible[]);\n             self.check_for_erroneous_unit_struct_expecting(\n-                expected.index(&FullRange));\n+                &expected[]);\n         }\n         self.expect_one_of(edible, inedible)\n     }\n@@ -534,8 +534,8 @@ impl<'a> Parser<'a> {\n             }\n             _ => {\n                 let token_str = self.this_token_to_string();\n-                self.fatal((format!(\"expected ident, found `{}`\",\n-                                    token_str)).index(&FullRange))\n+                self.fatal(&format!(\"expected ident, found `{}`\",\n+                                    token_str)[])\n             }\n         }\n     }\n@@ -592,8 +592,8 @@ impl<'a> Parser<'a> {\n         if !self.eat_keyword(kw) {\n             let id_interned_str = token::get_name(kw.to_name());\n             let token_str = self.this_token_to_string();\n-            self.fatal(format!(\"expected `{}`, found `{}`\",\n-                               id_interned_str, token_str).index(&FullRange))\n+            self.fatal(&format!(\"expected `{}`, found `{}`\",\n+                               id_interned_str, token_str)[])\n         }\n     }\n \n@@ -603,17 +603,17 @@ impl<'a> Parser<'a> {\n             let token_str = self.this_token_to_string();\n             let span = self.span;\n             self.span_err(span,\n-                          format!(\"expected identifier, found keyword `{}`\",\n-                                  token_str).index(&FullRange));\n+                          &format!(\"expected identifier, found keyword `{}`\",\n+                                  token_str)[]);\n         }\n     }\n \n     /// Signal an error if the current token is a reserved keyword\n     pub fn check_reserved_keywords(&mut self) {\n         if self.token.is_reserved_keyword() {\n             let token_str = self.this_token_to_string();\n-            self.fatal(format!(\"`{}` is a reserved keyword\",\n-                               token_str).index(&FullRange))\n+            self.fatal(&format!(\"`{}` is a reserved keyword\",\n+                               token_str)[])\n         }\n     }\n \n@@ -631,9 +631,9 @@ impl<'a> Parser<'a> {\n                 let token_str = self.this_token_to_string();\n                 let found_token =\n                     Parser::token_to_string(&token::BinOp(token::And));\n-                self.fatal(format!(\"expected `{}`, found `{}`\",\n+                self.fatal(&format!(\"expected `{}`, found `{}`\",\n                                    found_token,\n-                                   token_str).index(&FullRange))\n+                                   token_str)[])\n             }\n         }\n     }\n@@ -652,9 +652,9 @@ impl<'a> Parser<'a> {\n                 let found_token = self.this_token_to_string();\n                 let token_str =\n                     Parser::token_to_string(&token::BinOp(token::Or));\n-                self.fatal(format!(\"expected `{}`, found `{}`\",\n+                self.fatal(&format!(\"expected `{}`, found `{}`\",\n                                    token_str,\n-                                   found_token).index(&FullRange))\n+                                   found_token)[])\n             }\n         }\n     }\n@@ -695,9 +695,9 @@ impl<'a> Parser<'a> {\n         if !self.eat_lt() {\n             let found_token = self.this_token_to_string();\n             let token_str = Parser::token_to_string(&token::Lt);\n-            self.fatal(format!(\"expected `{}`, found `{}`\",\n+            self.fatal(&format!(\"expected `{}`, found `{}`\",\n                                token_str,\n-                               found_token).index(&FullRange))\n+                               found_token)[])\n         }\n     }\n \n@@ -747,9 +747,9 @@ impl<'a> Parser<'a> {\n             _ => {\n                 let gt_str = Parser::token_to_string(&token::Gt);\n                 let this_token_str = self.this_token_to_string();\n-                self.fatal(format!(\"expected `{}`, found `{}`\",\n+                self.fatal(&format!(\"expected `{}`, found `{}`\",\n                                    gt_str,\n-                                   this_token_str).index(&FullRange))\n+                                   this_token_str)[])\n             }\n         }\n     }\n@@ -1371,7 +1371,7 @@ impl<'a> Parser<'a> {\n                     let (inner_attrs, body) =\n                         p.parse_inner_attrs_and_block();\n                     let mut attrs = attrs;\n-                    attrs.push_all(inner_attrs.index(&FullRange));\n+                    attrs.push_all(&inner_attrs[]);\n                     ProvidedMethod(P(ast::Method {\n                         attrs: attrs,\n                         id: ast::DUMMY_NODE_ID,\n@@ -1389,8 +1389,8 @@ impl<'a> Parser<'a> {\n \n                   _ => {\n                       let token_str = p.this_token_to_string();\n-                      p.fatal((format!(\"expected `;` or `{{`, found `{}`\",\n-                                       token_str)).index(&FullRange))\n+                      p.fatal(&format!(\"expected `;` or `{{`, found `{}`\",\n+                                       token_str)[])\n                   }\n                 }\n             }\n@@ -1586,7 +1586,7 @@ impl<'a> Parser<'a> {\n         } else {\n             let this_token_str = self.this_token_to_string();\n             let msg = format!(\"expected type, found `{}`\", this_token_str);\n-            self.fatal(msg.index(&FullRange));\n+            self.fatal(&msg[]);\n         };\n \n         let sp = mk_sp(lo, self.last_span.hi);\n@@ -1734,8 +1734,7 @@ impl<'a> Parser<'a> {\n                     token::StrRaw(s, n) => {\n                         (true,\n                          LitStr(\n-                            token::intern_and_get_ident(\n-                                parse::raw_str_lit(s.as_str()).index(&FullRange)),\n+                            token::intern_and_get_ident(&parse::raw_str_lit(s.as_str())[]),\n                             ast::RawStr(n)))\n                     }\n                     token::Binary(i) =>\n@@ -1979,7 +1978,7 @@ impl<'a> Parser<'a> {\n                 };\n             }\n             _ => {\n-                self.fatal(format!(\"expected a lifetime name\").index(&FullRange));\n+                self.fatal(&format!(\"expected a lifetime name\")[]);\n             }\n         }\n     }\n@@ -2017,7 +2016,7 @@ impl<'a> Parser<'a> {\n                     let msg = format!(\"expected `,` or `>` after lifetime \\\n                                       name, found `{}`\",\n                                       this_token_str);\n-                    self.fatal(msg.index(&FullRange));\n+                    self.fatal(&msg[]);\n                 }\n             }\n         }\n@@ -2501,16 +2500,16 @@ impl<'a> Parser<'a> {\n                     let last_span = self.last_span;\n                     let fstr = n.as_str();\n                     self.span_err(last_span,\n-                                  format!(\"unexpected token: `{}`\", n.as_str()).index(&FullRange));\n+                                  &format!(\"unexpected token: `{}`\", n.as_str())[]);\n                     if fstr.chars().all(|x| \"0123456789.\".contains_char(x)) {\n                         let float = match fstr.parse::<f64>() {\n                             Some(f) => f,\n                             None => continue,\n                         };\n                         self.span_help(last_span,\n-                            format!(\"try parenthesizing the first index; e.g., `(foo.{}){}`\",\n+                            &format!(\"try parenthesizing the first index; e.g., `(foo.{}){}`\",\n                                     float.trunc() as uint,\n-                                    float.fract().to_string().index(&(1..))).index(&FullRange));\n+                                    &float.fract().to_string()[1..])[]);\n                     }\n                     self.abort_if_errors();\n \n@@ -2655,8 +2654,8 @@ impl<'a> Parser<'a> {\n         if self.quote_depth == 0u {\n             match self.token {\n                 token::SubstNt(name, _) =>\n-                    self.fatal(format!(\"unknown macro variable `{}`\",\n-                                       token::get_ident(name)).index(&FullRange)),\n+                    self.fatal(&format!(\"unknown macro variable `{}`\",\n+                                       token::get_ident(name))[]),\n                 _ => {}\n             }\n         }\n@@ -2717,8 +2716,8 @@ impl<'a> Parser<'a> {\n                         Some(&sp) => p.span_note(sp, \"unclosed delimiter\"),\n                     };\n                     let token_str = p.this_token_to_string();\n-                    p.fatal(format!(\"incorrect close delimiter: `{}`\",\n-                                    token_str).index(&FullRange))\n+                    p.fatal(&format!(\"incorrect close delimiter: `{}`\",\n+                                    token_str)[])\n                 },\n                 /* we ought to allow different depths of unquotation */\n                 token::Dollar | token::SubstNt(..) if p.quote_depth > 0u => {\n@@ -2858,8 +2857,8 @@ impl<'a> Parser<'a> {\n                         let span = self.span;\n                         let this_token_to_string = self.this_token_to_string();\n                         self.span_err(span,\n-                                      format!(\"expected expression, found `{}`\",\n-                                              this_token_to_string).index(&FullRange));\n+                                      &format!(\"expected expression, found `{}`\",\n+                                              this_token_to_string)[]);\n                         let box_span = mk_sp(lo, self.last_span.hi);\n                         self.span_help(box_span,\n                                        \"perhaps you meant `box() (foo)` instead?\");\n@@ -3263,8 +3262,8 @@ impl<'a> Parser<'a> {\n                 self.bump();\n                 if self.token != token::CloseDelim(token::Brace) {\n                     let token_str = self.this_token_to_string();\n-                    self.fatal(format!(\"expected `{}`, found `{}`\", \"}\",\n-                                       token_str).index(&FullRange))\n+                    self.fatal(&format!(\"expected `{}`, found `{}`\", \"}\",\n+                                       token_str)[])\n                 }\n                 etc = true;\n                 break;\n@@ -3284,8 +3283,8 @@ impl<'a> Parser<'a> {\n                 match bind_type {\n                     BindByRef(..) | BindByValue(MutMutable) => {\n                         let token_str = self.this_token_to_string();\n-                        self.fatal(format!(\"unexpected `{}`\",\n-                                           token_str).index(&FullRange))\n+                        self.fatal(&format!(\"unexpected `{}`\",\n+                                           token_str)[])\n                     }\n                     _ => {}\n                 }\n@@ -3568,7 +3567,7 @@ impl<'a> Parser<'a> {\n             let span = self.span;\n             let tok_str = self.this_token_to_string();\n             self.span_fatal(span,\n-                            format!(\"expected identifier, found `{}`\", tok_str).index(&FullRange));\n+                            &format!(\"expected identifier, found `{}`\", tok_str)[]);\n         }\n         let ident = self.parse_ident();\n         let last_span = self.last_span;\n@@ -3665,7 +3664,7 @@ impl<'a> Parser<'a> {\n \n         let lo = self.span.lo;\n         if self.token.is_keyword(keywords::Let) {\n-            check_expected_item(self, item_attrs.index(&FullRange));\n+            check_expected_item(self, &item_attrs[]);\n             self.expect_keyword(keywords::Let);\n             let decl = self.parse_let();\n             P(spanned(lo, decl.span.hi, StmtDecl(decl, ast::DUMMY_NODE_ID)))\n@@ -3674,7 +3673,7 @@ impl<'a> Parser<'a> {\n             && self.look_ahead(1, |t| *t == token::Not) {\n             // it's a macro invocation:\n \n-            check_expected_item(self, item_attrs.index(&FullRange));\n+            check_expected_item(self, &item_attrs[]);\n \n             // Potential trouble: if we allow macros with paths instead of\n             // idents, we'd need to look ahead past the whole path here...\n@@ -3700,9 +3699,9 @@ impl<'a> Parser<'a> {\n                         \"\"\n                     };\n                     let tok_str = self.this_token_to_string();\n-                    self.fatal(format!(\"expected {}`(` or `{{`, found `{}`\",\n+                    self.fatal(&format!(\"expected {}`(` or `{{`, found `{}`\",\n                                        ident_str,\n-                                       tok_str).index(&FullRange))\n+                                       tok_str)[])\n                 },\n             };\n \n@@ -3750,7 +3749,7 @@ impl<'a> Parser<'a> {\n             }\n         } else {\n             let found_attrs = !item_attrs.is_empty();\n-            let item_err = Parser::expected_item_err(item_attrs.index(&FullRange));\n+            let item_err = Parser::expected_item_err(&item_attrs[]);\n             match self.parse_item_or_view_item(item_attrs, false) {\n                 IoviItem(i) => {\n                     let hi = i.span.hi;\n@@ -3794,7 +3793,7 @@ impl<'a> Parser<'a> {\n             let sp = self.span;\n             let tok = self.this_token_to_string();\n             self.span_fatal_help(sp,\n-                                 format!(\"expected `{{`, found `{}`\", tok).index(&FullRange),\n+                                 &format!(\"expected `{{`, found `{}`\", tok)[],\n                                  \"place this code inside a block\");\n         }\n \n@@ -3848,13 +3847,13 @@ impl<'a> Parser<'a> {\n         while self.token != token::CloseDelim(token::Brace) {\n             // parsing items even when they're not allowed lets us give\n             // better error messages and recover more gracefully.\n-            attributes_box.push_all(self.parse_outer_attributes().index(&FullRange));\n+            attributes_box.push_all(&self.parse_outer_attributes()[]);\n             match self.token {\n                 token::Semi => {\n                     if !attributes_box.is_empty() {\n                         let last_span = self.last_span;\n                         self.span_err(last_span,\n-                                      Parser::expected_item_err(attributes_box.index(&FullRange)));\n+                                      Parser::expected_item_err(&attributes_box[]));\n                         attributes_box = Vec::new();\n                     }\n                     self.bump(); // empty\n@@ -3946,7 +3945,7 @@ impl<'a> Parser<'a> {\n         if !attributes_box.is_empty() {\n             let last_span = self.last_span;\n             self.span_err(last_span,\n-                          Parser::expected_item_err(attributes_box.index(&FullRange)));\n+                          Parser::expected_item_err(&attributes_box[]));\n         }\n \n         let hi = self.span.hi;\n@@ -4389,8 +4388,8 @@ impl<'a> Parser<'a> {\n             },\n             _ => {\n                 let token_str = self.this_token_to_string();\n-                self.fatal(format!(\"expected `self`, found `{}`\",\n-                                   token_str).index(&FullRange))\n+                self.fatal(&format!(\"expected `self`, found `{}`\",\n+                                   token_str)[])\n             }\n         }\n     }\n@@ -4543,8 +4542,8 @@ impl<'a> Parser<'a> {\n                 }\n                 _ => {\n                     let token_str = self.this_token_to_string();\n-                    self.fatal(format!(\"expected `,` or `)`, found `{}`\",\n-                                       token_str).index(&FullRange))\n+                    self.fatal(&format!(\"expected `,` or `)`, found `{}`\",\n+                                       token_str)[])\n                 }\n             }\n             }\n@@ -4720,7 +4719,7 @@ impl<'a> Parser<'a> {\n                 let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n                 let body_span = body.span;\n                 let mut new_attrs = attrs;\n-                new_attrs.push_all(inner_attrs.index(&FullRange));\n+                new_attrs.push_all(&inner_attrs[]);\n                 (ast::MethDecl(ident,\n                                generics,\n                                abi,\n@@ -4937,17 +4936,17 @@ impl<'a> Parser<'a> {\n             }\n \n             if fields.len() == 0 {\n-                self.fatal(format!(\"unit-like struct definition should be \\\n+                self.fatal(&format!(\"unit-like struct definition should be \\\n                     written as `struct {};`\",\n-                    token::get_ident(class_name.clone())).index(&FullRange));\n+                    token::get_ident(class_name.clone()))[]);\n             }\n \n             self.bump();\n         } else {\n             let token_str = self.this_token_to_string();\n-            self.fatal(format!(\"expected `where`, or `{}` after struct \\\n+            self.fatal(&format!(\"expected `where`, or `{}` after struct \\\n                                 name, found `{}`\", \"{\",\n-                                token_str).index(&FullRange));\n+                                token_str)[]);\n         }\n \n         fields\n@@ -4976,9 +4975,9 @@ impl<'a> Parser<'a> {\n                 });\n \n             if fields.len() == 0 {\n-                self.fatal(format!(\"unit-like struct definition should be \\\n+                self.fatal(&format!(\"unit-like struct definition should be \\\n                     written as `struct {};`\",\n-                    token::get_ident(class_name.clone())).index(&FullRange));\n+                    token::get_ident(class_name.clone()))[]);\n             }\n \n             self.parse_where_clause(generics);\n@@ -4992,8 +4991,8 @@ impl<'a> Parser<'a> {\n         // This case is where we see: `struct Foo<T>;`\n         } else {\n             let token_str = self.this_token_to_string();\n-            self.fatal(format!(\"expected `where`, `{}`, `(`, or `;` after struct \\\n-                name, found `{}`\", \"{\", token_str).index(&FullRange));\n+            self.fatal(&format!(\"expected `where`, `{}`, `(`, or `;` after struct \\\n+                name, found `{}`\", \"{\", token_str)[]);\n         }\n     }\n \n@@ -5012,8 +5011,8 @@ impl<'a> Parser<'a> {\n                 let span = self.span;\n                 let token_str = self.this_token_to_string();\n                 self.span_fatal_help(span,\n-                                     format!(\"expected `,`, or `}}`, found `{}`\",\n-                                             token_str).index(&FullRange),\n+                                     &format!(\"expected `,`, or `}}`, found `{}`\",\n+                                             token_str)[],\n                                      \"struct fields should be separated by commas\")\n             }\n         }\n@@ -5100,7 +5099,7 @@ impl<'a> Parser<'a> {\n             let mut attrs = self.parse_outer_attributes();\n             if first {\n                 let mut tmp = attrs_remaining.clone();\n-                tmp.push_all(attrs.index(&FullRange));\n+                tmp.push_all(&attrs[]);\n                 attrs = tmp;\n                 first = false;\n             }\n@@ -5116,8 +5115,8 @@ impl<'a> Parser<'a> {\n               }\n               _ => {\n                   let token_str = self.this_token_to_string();\n-                  self.fatal(format!(\"expected item, found `{}`\",\n-                                     token_str).index(&FullRange))\n+                  self.fatal(&format!(\"expected item, found `{}`\",\n+                                     token_str)[])\n               }\n             }\n         }\n@@ -5126,7 +5125,7 @@ impl<'a> Parser<'a> {\n             // We parsed attributes for the first item but didn't find it\n             let last_span = self.last_span;\n             self.span_err(last_span,\n-                          Parser::expected_item_err(attrs_remaining.index(&FullRange)));\n+                          Parser::expected_item_err(&attrs_remaining[]));\n         }\n \n         ast::Mod {\n@@ -5196,7 +5195,7 @@ impl<'a> Parser<'a> {\n                     -> (ast::Item_, Vec<ast::Attribute> ) {\n         let mut prefix = Path::new(self.sess.span_diagnostic.cm.span_to_filename(self.span));\n         prefix.pop();\n-        let mod_path = Path::new(\".\").join_many(self.mod_path_stack.index(&FullRange));\n+        let mod_path = Path::new(\".\").join_many(&self.mod_path_stack[]);\n         let dir_path = prefix.join(&mod_path);\n         let mod_string = token::get_ident(id);\n         let (file_path, owns_directory) = match ::attr::first_attr_value_str_by_name(\n@@ -5206,8 +5205,8 @@ impl<'a> Parser<'a> {\n                 let mod_name = mod_string.get().to_string();\n                 let default_path_str = format!(\"{}.rs\", mod_name);\n                 let secondary_path_str = format!(\"{}/mod.rs\", mod_name);\n-                let default_path = dir_path.join(default_path_str.index(&FullRange));\n-                let secondary_path = dir_path.join(secondary_path_str.index(&FullRange));\n+                let default_path = dir_path.join(&default_path_str[]);\n+                let secondary_path = dir_path.join(&secondary_path_str[]);\n                 let default_exists = default_path.exists();\n                 let secondary_exists = secondary_path.exists();\n \n@@ -5219,16 +5218,16 @@ impl<'a> Parser<'a> {\n                         None => self.root_module_name.as_ref().unwrap().clone(),\n                     };\n                     self.span_note(id_sp,\n-                                   format!(\"maybe move this module `{0}` \\\n+                                   &format!(\"maybe move this module `{0}` \\\n                                             to its own directory via \\\n                                             `{0}/mod.rs`\",\n-                                           this_module).index(&FullRange));\n+                                           this_module)[]);\n                     if default_exists || secondary_exists {\n                         self.span_note(id_sp,\n-                                       format!(\"... or maybe `use` the module \\\n+                                       &format!(\"... or maybe `use` the module \\\n                                                 `{}` instead of possibly \\\n                                                 redeclaring it\",\n-                                               mod_name).index(&FullRange));\n+                                               mod_name)[]);\n                     }\n                     self.abort_if_errors();\n                 }\n@@ -5238,22 +5237,22 @@ impl<'a> Parser<'a> {\n                     (false, true) => (secondary_path, true),\n                     (false, false) => {\n                         self.span_fatal_help(id_sp,\n-                                             format!(\"file not found for module `{}`\",\n-                                                     mod_name).index(&FullRange),\n-                                             format!(\"name the file either {} or {} inside \\\n+                                             &format!(\"file not found for module `{}`\",\n+                                                     mod_name)[],\n+                                             &format!(\"name the file either {} or {} inside \\\n                                                      the directory {:?}\",\n                                                      default_path_str,\n                                                      secondary_path_str,\n-                                                     dir_path.display()).index(&FullRange));\n+                                                     dir_path.display())[]);\n                     }\n                     (true, true) => {\n                         self.span_fatal_help(\n                             id_sp,\n-                            format!(\"file for module `{}` found at both {} \\\n+                            &format!(\"file for module `{}` found at both {} \\\n                                      and {}\",\n                                     mod_name,\n                                     default_path_str,\n-                                    secondary_path_str).index(&FullRange),\n+                                    secondary_path_str)[],\n                             \"delete or rename one of them to remove the ambiguity\");\n                     }\n                 }\n@@ -5275,11 +5274,11 @@ impl<'a> Parser<'a> {\n                 let mut err = String::from_str(\"circular modules: \");\n                 let len = included_mod_stack.len();\n                 for p in included_mod_stack.slice(i, len).iter() {\n-                    err.push_str(p.display().as_cow().index(&FullRange));\n+                    err.push_str(&p.display().as_cow()[]);\n                     err.push_str(\" -> \");\n                 }\n-                err.push_str(path.display().as_cow().index(&FullRange));\n-                self.span_fatal(id_sp, err.index(&FullRange));\n+                err.push_str(&path.display().as_cow()[]);\n+                self.span_fatal(id_sp, &err[]);\n             }\n             None => ()\n         }\n@@ -5360,7 +5359,7 @@ impl<'a> Parser<'a> {\n         if !attrs_remaining.is_empty() {\n             let last_span = self.last_span;\n             self.span_err(last_span,\n-                          Parser::expected_item_err(attrs_remaining.index(&FullRange)));\n+                          Parser::expected_item_err(&attrs_remaining[]));\n         }\n         assert!(self.token == token::CloseDelim(token::Brace));\n         ast::ForeignMod {\n@@ -5399,9 +5398,9 @@ impl<'a> Parser<'a> {\n \n                     self.span_err(span, \"expected `;`, found `as`\");\n                     self.span_help(span,\n-                                   format!(\"perhaps you meant to enclose the crate name `{}` in \\\n+                                   &format!(\"perhaps you meant to enclose the crate name `{}` in \\\n                                            a string?\",\n-                                          the_ident.as_str()).index(&FullRange));\n+                                          the_ident.as_str())[]);\n                     None\n                 } else {\n                     None\n@@ -5425,9 +5424,9 @@ impl<'a> Parser<'a> {\n                 let span = self.span;\n                 let token_str = self.this_token_to_string();\n                 self.span_fatal(span,\n-                                format!(\"expected extern crate name but \\\n+                                &format!(\"expected extern crate name but \\\n                                          found `{}`\",\n-                                        token_str).index(&FullRange));\n+                                        token_str)[]);\n             }\n         };\n \n@@ -5523,9 +5522,9 @@ impl<'a> Parser<'a> {\n                 let struct_def = self.parse_struct_def();\n                 if struct_def.fields.len() == 0 {\n                     self.span_err(start_span,\n-                        format!(\"unit-like struct variant should be written \\\n+                        &format!(\"unit-like struct variant should be written \\\n                                  without braces, as `{},`\",\n-                                token::get_ident(ident)).index(&FullRange));\n+                                token::get_ident(ident))[]);\n                 }\n                 kind = StructVariantKind(struct_def);\n             } else if self.check(&token::OpenDelim(token::Paren)) {\n@@ -5607,10 +5606,10 @@ impl<'a> Parser<'a> {\n                         let last_span = self.last_span;\n                         self.span_err(\n                             last_span,\n-                            format!(\"illegal ABI: expected one of [{}], \\\n+                            &format!(\"illegal ABI: expected one of [{}], \\\n                                      found `{}`\",\n                                     abi::all_names().connect(\", \"),\n-                                    the_string).index(&FullRange));\n+                                    the_string)[]);\n                         None\n                     }\n                 }\n@@ -5669,10 +5668,10 @@ impl<'a> Parser<'a> {\n                 if next_is_mod {\n                     let last_span = self.last_span;\n                     self.span_err(mk_sp(lo, last_span.hi),\n-                                 format!(\"`extern mod` is obsolete, use \\\n+                                 &format!(\"`extern mod` is obsolete, use \\\n                                           `extern crate` instead \\\n                                           to refer to external \\\n-                                          crates.\").index(&FullRange))\n+                                          crates.\")[])\n                 }\n                 return self.parse_item_extern_crate(lo, visibility, attrs);\n             }\n@@ -5699,8 +5698,8 @@ impl<'a> Parser<'a> {\n             let span = self.span;\n             let token_str = self.this_token_to_string();\n             self.span_fatal(span,\n-                            format!(\"expected `{}` or `fn`, found `{}`\", \"{\",\n-                                    token_str).index(&FullRange));\n+                            &format!(\"expected `{}` or `fn`, found `{}`\", \"{\",\n+                                    token_str)[]);\n         }\n \n         if self.eat_keyword(keywords::Virtual) {\n@@ -5813,7 +5812,7 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::Mod) {\n             // MODULE ITEM\n             let (ident, item_, extra_attrs) =\n-                self.parse_item_mod(attrs.index(&FullRange));\n+                self.parse_item_mod(&attrs[]);\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,\n                                     last_span.hi,\n@@ -6153,7 +6152,7 @@ impl<'a> Parser<'a> {\n                                   macros_allowed: bool)\n                                   -> ParsedItemsAndViewItems {\n         let mut attrs = first_item_attrs;\n-        attrs.push_all(self.parse_outer_attributes().index(&FullRange));\n+        attrs.push_all(&self.parse_outer_attributes()[]);\n         // First, parse view items.\n         let mut view_items : Vec<ast::ViewItem> = Vec::new();\n         let mut items = Vec::new();\n@@ -6235,7 +6234,7 @@ impl<'a> Parser<'a> {\n                            macros_allowed: bool)\n         -> ParsedItemsAndViewItems {\n         let mut attrs = first_item_attrs;\n-        attrs.push_all(self.parse_outer_attributes().index(&FullRange));\n+        attrs.push_all(&self.parse_outer_attributes()[]);\n         let mut foreign_items = Vec::new();\n         loop {\n             match self.parse_foreign_item(attrs, macros_allowed) {"}, {"sha": "4b3573f84c57125573b883b6a5bd11f9b342e611", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -480,7 +480,7 @@ macro_rules! declare_special_idents_and_keywords {(\n         $(init_vec.push($si_str);)*\n         $(init_vec.push($sk_str);)*\n         $(init_vec.push($rk_str);)*\n-        interner::StrInterner::prefill(init_vec.index(&FullRange))\n+        interner::StrInterner::prefill(&init_vec[])\n     }\n }}\n \n@@ -629,7 +629,7 @@ impl InternedString {\n \n     #[inline]\n     pub fn get<'a>(&'a self) -> &'a str {\n-        self.string.index(&FullRange)\n+        &self.string[]\n     }\n }\n \n@@ -659,41 +659,41 @@ impl fmt::Show for InternedString {\n \n impl fmt::String for InternedString {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.string.index(&FullRange))\n+        write!(f, \"{}\", &self.string[])\n     }\n }\n \n impl<'a> PartialEq<&'a str> for InternedString {\n     #[inline(always)]\n     fn eq(&self, other: & &'a str) -> bool {\n-        PartialEq::eq(self.string.index(&FullRange), *other)\n+        PartialEq::eq(&self.string[], *other)\n     }\n     #[inline(always)]\n     fn ne(&self, other: & &'a str) -> bool {\n-        PartialEq::ne(self.string.index(&FullRange), *other)\n+        PartialEq::ne(&self.string[], *other)\n     }\n }\n \n impl<'a> PartialEq<InternedString > for &'a str {\n     #[inline(always)]\n     fn eq(&self, other: &InternedString) -> bool {\n-        PartialEq::eq(*self, other.string.index(&FullRange))\n+        PartialEq::eq(*self, &other.string[])\n     }\n     #[inline(always)]\n     fn ne(&self, other: &InternedString) -> bool {\n-        PartialEq::ne(*self, other.string.index(&FullRange))\n+        PartialEq::ne(*self, &other.string[])\n     }\n }\n \n impl Decodable for InternedString {\n     fn decode<D: Decoder>(d: &mut D) -> Result<InternedString, D::Error> {\n-        Ok(get_name(get_ident_interner().intern(try!(d.read_str()).index(&FullRange))))\n+        Ok(get_name(get_ident_interner().intern(&try!(d.read_str())[])))\n     }\n }\n \n impl Encodable for InternedString {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(self.string.index(&FullRange))\n+        s.emit_str(&self.string[])\n     }\n }\n "}, {"sha": "b69b812c9586e7f4abb485699544d343ff65c8a8", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -138,9 +138,9 @@ pub fn buf_str(toks: Vec<Token>,\n         if i != left {\n             s.push_str(\", \");\n         }\n-        s.push_str(format!(\"{}={}\",\n+        s.push_str(&format!(\"{}={}\",\n                            szs[i],\n-                           tok_str(toks[i].clone())).index(&FullRange));\n+                           tok_str(toks[i].clone()))[]);\n         i += 1u;\n         i %= n;\n     }\n@@ -602,7 +602,7 @@ impl Printer {\n             assert_eq!(l, len);\n             // assert!(l <= space);\n             self.space -= len;\n-            self.print_str(s.index(&FullRange))\n+            self.print_str(&s[])\n           }\n           Eof => {\n             // Eof should never get here."}, {"sha": "9b6f8e6002d8aa894b2502a7a818d752be75fae0", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 84, "deletions": 85, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -114,7 +114,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n                                       out,\n                                       ann,\n                                       is_expanded);\n-    try!(s.print_mod(&krate.module, krate.attrs.index(&FullRange)));\n+    try!(s.print_mod(&krate.module, &krate.attrs[]));\n     try!(s.print_remaining_comments());\n     eof(&mut s.s)\n }\n@@ -580,7 +580,7 @@ impl<'a> State<'a> {\n     pub fn synth_comment(&mut self, text: String) -> IoResult<()> {\n         try!(word(&mut self.s, \"/*\"));\n         try!(space(&mut self.s));\n-        try!(word(&mut self.s, text.index(&FullRange)));\n+        try!(word(&mut self.s, &text[]));\n         try!(space(&mut self.s));\n         word(&mut self.s, \"*/\")\n     }\n@@ -685,7 +685,7 @@ impl<'a> State<'a> {\n             }\n             ast::TyTup(ref elts) => {\n                 try!(self.popen());\n-                try!(self.commasep(Inconsistent, elts.index(&FullRange),\n+                try!(self.commasep(Inconsistent, &elts[],\n                                    |s, ty| s.print_type(&**ty)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n@@ -721,10 +721,10 @@ impl<'a> State<'a> {\n             }\n             ast::TyObjectSum(ref ty, ref bounds) => {\n                 try!(self.print_type(&**ty));\n-                try!(self.print_bounds(\"+\", bounds.index(&FullRange)));\n+                try!(self.print_bounds(\"+\", &bounds[]));\n             }\n             ast::TyPolyTraitRef(ref bounds) => {\n-                try!(self.print_bounds(\"\", bounds.index(&FullRange)));\n+                try!(self.print_bounds(\"\", &bounds[]));\n             }\n             ast::TyQPath(ref qpath) => {\n                 try!(word(&mut self.s, \"<\"));\n@@ -759,7 +759,7 @@ impl<'a> State<'a> {\n                               item: &ast::ForeignItem) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(item.span.lo));\n-        try!(self.print_outer_attributes(item.attrs.index(&FullRange)));\n+        try!(self.print_outer_attributes(&item.attrs[]));\n         match item.node {\n             ast::ForeignItemFn(ref decl, ref generics) => {\n                 try!(self.print_fn(&**decl, None, abi::Rust, item.ident, generics,\n@@ -769,8 +769,8 @@ impl<'a> State<'a> {\n                 self.end() // end the outer fn box\n             }\n             ast::ForeignItemStatic(ref t, m) => {\n-                try!(self.head(visibility_qualified(item.vis,\n-                                                    \"static\").index(&FullRange)));\n+                try!(self.head(&visibility_qualified(item.vis,\n+                                                    \"static\")[]));\n                 if m {\n                     try!(self.word_space(\"mut\"));\n                 }\n@@ -787,7 +787,7 @@ impl<'a> State<'a> {\n     fn print_associated_type(&mut self, typedef: &ast::AssociatedType)\n                              -> IoResult<()>\n     {\n-        try!(self.print_outer_attributes(typedef.attrs.index(&FullRange)));\n+        try!(self.print_outer_attributes(&typedef.attrs[]));\n         try!(self.word_space(\"type\"));\n         try!(self.print_ty_param(&typedef.ty_param));\n         word(&mut self.s, \";\")\n@@ -806,12 +806,12 @@ impl<'a> State<'a> {\n     pub fn print_item(&mut self, item: &ast::Item) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(item.span.lo));\n-        try!(self.print_outer_attributes(item.attrs.index(&FullRange)));\n+        try!(self.print_outer_attributes(&item.attrs[]));\n         try!(self.ann.pre(self, NodeItem(item)));\n         match item.node {\n             ast::ItemStatic(ref ty, m, ref expr) => {\n-                try!(self.head(visibility_qualified(item.vis,\n-                                                    \"static\").index(&FullRange)));\n+                try!(self.head(&visibility_qualified(item.vis,\n+                                                    \"static\")[]));\n                 if m == ast::MutMutable {\n                     try!(self.word_space(\"mut\"));\n                 }\n@@ -827,8 +827,8 @@ impl<'a> State<'a> {\n                 try!(self.end()); // end the outer cbox\n             }\n             ast::ItemConst(ref ty, ref expr) => {\n-                try!(self.head(visibility_qualified(item.vis,\n-                                                    \"const\").index(&FullRange)));\n+                try!(self.head(&visibility_qualified(item.vis,\n+                                                    \"const\")[]));\n                 try!(self.print_ident(item.ident));\n                 try!(self.word_space(\":\"));\n                 try!(self.print_type(&**ty));\n@@ -851,29 +851,28 @@ impl<'a> State<'a> {\n                     item.vis\n                 ));\n                 try!(word(&mut self.s, \" \"));\n-                try!(self.print_block_with_attrs(&**body, item.attrs.index(&FullRange)));\n+                try!(self.print_block_with_attrs(&**body, &item.attrs[]));\n             }\n             ast::ItemMod(ref _mod) => {\n-                try!(self.head(visibility_qualified(item.vis,\n-                                                    \"mod\").index(&FullRange)));\n+                try!(self.head(&visibility_qualified(item.vis,\n+                                                    \"mod\")[]));\n                 try!(self.print_ident(item.ident));\n                 try!(self.nbsp());\n                 try!(self.bopen());\n-                try!(self.print_mod(_mod, item.attrs.index(&FullRange)));\n+                try!(self.print_mod(_mod, &item.attrs[]));\n                 try!(self.bclose(item.span));\n             }\n             ast::ItemForeignMod(ref nmod) => {\n                 try!(self.head(\"extern\"));\n-                try!(self.word_nbsp(nmod.abi.to_string().index(&FullRange)));\n+                try!(self.word_nbsp(&nmod.abi.to_string()[]));\n                 try!(self.bopen());\n-                try!(self.print_foreign_mod(nmod, item.attrs.index(&FullRange)));\n+                try!(self.print_foreign_mod(nmod, &item.attrs[]));\n                 try!(self.bclose(item.span));\n             }\n             ast::ItemTy(ref ty, ref params) => {\n                 try!(self.ibox(indent_unit));\n                 try!(self.ibox(0u));\n-                try!(self.word_nbsp(visibility_qualified(item.vis,\n-                                                         \"type\").index(&FullRange)));\n+                try!(self.word_nbsp(&visibility_qualified(item.vis, \"type\")[]));\n                 try!(self.print_ident(item.ident));\n                 try!(self.print_generics(params));\n                 try!(self.end()); // end the inner ibox\n@@ -895,7 +894,7 @@ impl<'a> State<'a> {\n                 ));\n             }\n             ast::ItemStruct(ref struct_def, ref generics) => {\n-                try!(self.head(visibility_qualified(item.vis,\"struct\").index(&FullRange)));\n+                try!(self.head(&visibility_qualified(item.vis,\"struct\")[]));\n                 try!(self.print_struct(&**struct_def, generics, item.ident, item.span));\n             }\n \n@@ -936,7 +935,7 @@ impl<'a> State<'a> {\n \n                 try!(space(&mut self.s));\n                 try!(self.bopen());\n-                try!(self.print_inner_attributes(item.attrs.index(&FullRange)));\n+                try!(self.print_inner_attributes(&item.attrs[]));\n                 for impl_item in impl_items.iter() {\n                     match *impl_item {\n                         ast::MethodImplItem(ref meth) => {\n@@ -967,7 +966,7 @@ impl<'a> State<'a> {\n                         real_bounds.push(b);\n                     }\n                 }\n-                try!(self.print_bounds(\":\", real_bounds.index(&FullRange)));\n+                try!(self.print_bounds(\":\", &real_bounds[]));\n                 try!(self.print_where_clause(generics));\n                 try!(word(&mut self.s, \" \"));\n                 try!(self.bopen());\n@@ -985,7 +984,7 @@ impl<'a> State<'a> {\n                 try!(self.print_ident(item.ident));\n                 try!(self.cbox(indent_unit));\n                 try!(self.popen());\n-                try!(self.print_tts(tts.index(&FullRange)));\n+                try!(self.print_tts(&tts[]));\n                 try!(self.pclose());\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end());\n@@ -1019,12 +1018,12 @@ impl<'a> State<'a> {\n                           generics: &ast::Generics, ident: ast::Ident,\n                           span: codemap::Span,\n                           visibility: ast::Visibility) -> IoResult<()> {\n-        try!(self.head(visibility_qualified(visibility, \"enum\").index(&FullRange)));\n+        try!(self.head(&visibility_qualified(visibility, \"enum\")[]));\n         try!(self.print_ident(ident));\n         try!(self.print_generics(generics));\n         try!(self.print_where_clause(generics));\n         try!(space(&mut self.s));\n-        self.print_variants(enum_definition.variants.index(&FullRange), span)\n+        self.print_variants(&enum_definition.variants[], span)\n     }\n \n     pub fn print_variants(&mut self,\n@@ -1034,7 +1033,7 @@ impl<'a> State<'a> {\n         for v in variants.iter() {\n             try!(self.space_if_not_bol());\n             try!(self.maybe_print_comment(v.span.lo));\n-            try!(self.print_outer_attributes(v.node.attrs.index(&FullRange)));\n+            try!(self.print_outer_attributes(&v.node.attrs[]));\n             try!(self.ibox(indent_unit));\n             try!(self.print_variant(&**v));\n             try!(word(&mut self.s, \",\"));\n@@ -1062,7 +1061,7 @@ impl<'a> State<'a> {\n             if !struct_def.fields.is_empty() {\n                 try!(self.popen());\n                 try!(self.commasep(\n-                    Inconsistent, struct_def.fields.index(&FullRange),\n+                    Inconsistent, &struct_def.fields[],\n                     |s, field| {\n                         match field.node.kind {\n                             ast::NamedField(..) => panic!(\"unexpected named field\"),\n@@ -1092,7 +1091,7 @@ impl<'a> State<'a> {\n                     ast::NamedField(ident, visibility) => {\n                         try!(self.hardbreak_if_not_bol());\n                         try!(self.maybe_print_comment(field.span.lo));\n-                        try!(self.print_outer_attributes(field.node.attrs.index(&FullRange)));\n+                        try!(self.print_outer_attributes(&field.node.attrs[]));\n                         try!(self.print_visibility(visibility));\n                         try!(self.print_ident(ident));\n                         try!(self.word_nbsp(\":\"));\n@@ -1116,7 +1115,7 @@ impl<'a> State<'a> {\n     pub fn print_tt(&mut self, tt: &ast::TokenTree) -> IoResult<()> {\n         match *tt {\n             ast::TtToken(_, ref tk) => {\n-                try!(word(&mut self.s, token_to_string(tk).index(&FullRange)));\n+                try!(word(&mut self.s, &token_to_string(tk)[]));\n                 match *tk {\n                     parse::token::DocComment(..) => {\n                         hardbreak(&mut self.s)\n@@ -1125,11 +1124,11 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::TtDelimited(_, ref delimed) => {\n-                try!(word(&mut self.s, token_to_string(&delimed.open_token()).index(&FullRange)));\n+                try!(word(&mut self.s, &token_to_string(&delimed.open_token())[]));\n                 try!(space(&mut self.s));\n-                try!(self.print_tts(delimed.tts.index(&FullRange)));\n+                try!(self.print_tts(&delimed.tts[]));\n                 try!(space(&mut self.s));\n-                word(&mut self.s, token_to_string(&delimed.close_token()).index(&FullRange))\n+                word(&mut self.s, &token_to_string(&delimed.close_token())[])\n             },\n             ast::TtSequence(_, ref seq) => {\n                 try!(word(&mut self.s, \"$(\"));\n@@ -1139,7 +1138,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \")\"));\n                 match seq.separator {\n                     Some(ref tk) => {\n-                        try!(word(&mut self.s, token_to_string(tk).index(&FullRange)));\n+                        try!(word(&mut self.s, &token_to_string(tk)[]));\n                     }\n                     None => {},\n                 }\n@@ -1170,7 +1169,7 @@ impl<'a> State<'a> {\n                 if !args.is_empty() {\n                     try!(self.popen());\n                     try!(self.commasep(Consistent,\n-                                       args.index(&FullRange),\n+                                       &args[],\n                                        |s, arg| s.print_type(&*arg.ty)));\n                     try!(self.pclose());\n                 }\n@@ -1194,7 +1193,7 @@ impl<'a> State<'a> {\n     pub fn print_ty_method(&mut self, m: &ast::TypeMethod) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(m.span.lo));\n-        try!(self.print_outer_attributes(m.attrs.index(&FullRange)));\n+        try!(self.print_outer_attributes(&m.attrs[]));\n         try!(self.print_ty_fn(None,\n                               None,\n                               m.unsafety,\n@@ -1226,7 +1225,7 @@ impl<'a> State<'a> {\n     pub fn print_method(&mut self, meth: &ast::Method) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(meth.span.lo));\n-        try!(self.print_outer_attributes(meth.attrs.index(&FullRange)));\n+        try!(self.print_outer_attributes(&meth.attrs[]));\n         match meth.node {\n             ast::MethDecl(ident,\n                           ref generics,\n@@ -1244,7 +1243,7 @@ impl<'a> State<'a> {\n                                    Some(&explicit_self.node),\n                                    vis));\n                 try!(word(&mut self.s, \" \"));\n-                self.print_block_with_attrs(&**body, meth.attrs.index(&FullRange))\n+                self.print_block_with_attrs(&**body, &meth.attrs[])\n             },\n             ast::MethMac(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),\n                                             ..}) => {\n@@ -1253,7 +1252,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \"! \"));\n                 try!(self.cbox(indent_unit));\n                 try!(self.popen());\n-                try!(self.print_tts(tts.index(&FullRange)));\n+                try!(self.print_tts(&tts[]));\n                 try!(self.pclose());\n                 try!(word(&mut self.s, \";\"));\n                 self.end()\n@@ -1520,7 +1519,7 @@ impl<'a> State<'a> {\n             ast::ExprVec(ref exprs) => {\n                 try!(self.ibox(indent_unit));\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.commasep_exprs(Inconsistent, exprs.index(&FullRange)));\n+                try!(self.commasep_exprs(Inconsistent, &exprs[]));\n                 try!(word(&mut self.s, \"]\"));\n                 try!(self.end());\n             }\n@@ -1541,7 +1540,7 @@ impl<'a> State<'a> {\n                     try!(word(&mut self.s, \"{\"));\n                     try!(self.commasep_cmnt(\n                         Consistent,\n-                        fields.index(&FullRange),\n+                        &fields[],\n                         |s, field| {\n                             try!(s.ibox(indent_unit));\n                             try!(s.print_ident(field.ident.node));\n@@ -1568,15 +1567,15 @@ impl<'a> State<'a> {\n             }\n             ast::ExprTup(ref exprs) => {\n                 try!(self.popen());\n-                try!(self.commasep_exprs(Inconsistent, exprs.index(&FullRange)));\n+                try!(self.commasep_exprs(Inconsistent, &exprs[]));\n                 if exprs.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n                 }\n                 try!(self.pclose());\n             }\n             ast::ExprCall(ref func, ref args) => {\n                 try!(self.print_expr_maybe_paren(&**func));\n-                try!(self.print_call_post(args.index(&FullRange)));\n+                try!(self.print_call_post(&args[]));\n             }\n             ast::ExprMethodCall(ident, ref tys, ref args) => {\n                 let base_args = args.slice_from(1);\n@@ -1585,7 +1584,7 @@ impl<'a> State<'a> {\n                 try!(self.print_ident(ident.node));\n                 if tys.len() > 0u {\n                     try!(word(&mut self.s, \"::<\"));\n-                    try!(self.commasep(Inconsistent, tys.index(&FullRange),\n+                    try!(self.commasep(Inconsistent, &tys[],\n                                        |s, ty| s.print_type(&**ty)));\n                     try!(word(&mut self.s, \">\"));\n                 }\n@@ -1782,11 +1781,11 @@ impl<'a> State<'a> {\n                 try!(self.print_string(a.asm.get(), a.asm_str_style));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, a.outputs.index(&FullRange),\n+                try!(self.commasep(Inconsistent, &a.outputs[],\n                                    |s, &(ref co, ref o, is_rw)| {\n                     match co.get().slice_shift_char() {\n                         Some(('=', operand)) if is_rw => {\n-                            try!(s.print_string(format!(\"+{}\", operand).index(&FullRange),\n+                            try!(s.print_string(&format!(\"+{}\", operand)[],\n                                                 ast::CookedStr))\n                         }\n                         _ => try!(s.print_string(co.get(), ast::CookedStr))\n@@ -1799,7 +1798,7 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, a.inputs.index(&FullRange),\n+                try!(self.commasep(Inconsistent, &a.inputs[],\n                                    |s, &(ref co, ref o)| {\n                     try!(s.print_string(co.get(), ast::CookedStr));\n                     try!(s.popen());\n@@ -1810,7 +1809,7 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, a.clobbers.index(&FullRange),\n+                try!(self.commasep(Inconsistent, &a.clobbers[],\n                                    |s, co| {\n                     try!(s.print_string(co.get(), ast::CookedStr));\n                     Ok(())\n@@ -1884,15 +1883,15 @@ impl<'a> State<'a> {\n     pub fn print_ident(&mut self, ident: ast::Ident) -> IoResult<()> {\n         if self.encode_idents_with_hygiene {\n             let encoded = ident.encode_with_hygiene();\n-            try!(word(&mut self.s, encoded.index(&FullRange)))\n+            try!(word(&mut self.s, &encoded[]))\n         } else {\n             try!(word(&mut self.s, token::get_ident(ident).get()))\n         }\n         self.ann.post(self, NodeIdent(&ident))\n     }\n \n     pub fn print_uint(&mut self, i: uint) -> IoResult<()> {\n-        word(&mut self.s, i.to_string().index(&FullRange))\n+        word(&mut self.s, &i.to_string()[])\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) -> IoResult<()> {\n@@ -1966,7 +1965,7 @@ impl<'a> State<'a> {\n                     }\n                     try!(self.commasep(\n                         Inconsistent,\n-                        data.types.index(&FullRange),\n+                        &data.types[],\n                         |s, ty| s.print_type(&**ty)));\n                         comma = true;\n                 }\n@@ -1989,7 +1988,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \"(\"));\n                 try!(self.commasep(\n                     Inconsistent,\n-                    data.inputs.index(&FullRange),\n+                    &data.inputs[],\n                     |s, ty| s.print_type(&**ty)));\n                 try!(word(&mut self.s, \")\"));\n \n@@ -2042,7 +2041,7 @@ impl<'a> State<'a> {\n                     Some(ref args) => {\n                         if !args.is_empty() {\n                             try!(self.popen());\n-                            try!(self.commasep(Inconsistent, args.index(&FullRange),\n+                            try!(self.commasep(Inconsistent, &args[],\n                                               |s, p| s.print_pat(&**p)));\n                             try!(self.pclose());\n                         }\n@@ -2054,7 +2053,7 @@ impl<'a> State<'a> {\n                 try!(self.nbsp());\n                 try!(self.word_space(\"{\"));\n                 try!(self.commasep_cmnt(\n-                    Consistent, fields.index(&FullRange),\n+                    Consistent, &fields[],\n                     |s, f| {\n                         try!(s.cbox(indent_unit));\n                         if !f.node.is_shorthand {\n@@ -2075,7 +2074,7 @@ impl<'a> State<'a> {\n             ast::PatTup(ref elts) => {\n                 try!(self.popen());\n                 try!(self.commasep(Inconsistent,\n-                                   elts.index(&FullRange),\n+                                   &elts[],\n                                    |s, p| s.print_pat(&**p)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n@@ -2103,7 +2102,7 @@ impl<'a> State<'a> {\n             ast::PatVec(ref before, ref slice, ref after) => {\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.commasep(Inconsistent,\n-                                   before.index(&FullRange),\n+                                   &before[],\n                                    |s, p| s.print_pat(&**p)));\n                 for p in slice.iter() {\n                     if !before.is_empty() { try!(self.word_space(\",\")); }\n@@ -2117,7 +2116,7 @@ impl<'a> State<'a> {\n                     if !after.is_empty() { try!(self.word_space(\",\")); }\n                 }\n                 try!(self.commasep(Inconsistent,\n-                                   after.index(&FullRange),\n+                                   &after[],\n                                    |s, p| s.print_pat(&**p)));\n                 try!(word(&mut self.s, \"]\"));\n             }\n@@ -2134,7 +2133,7 @@ impl<'a> State<'a> {\n         }\n         try!(self.cbox(indent_unit));\n         try!(self.ibox(0u));\n-        try!(self.print_outer_attributes(arm.attrs.index(&FullRange)));\n+        try!(self.print_outer_attributes(&arm.attrs[]));\n         let mut first = true;\n         for p in arm.pats.iter() {\n             if first {\n@@ -2234,7 +2233,7 @@ impl<'a> State<'a> {\n \n         // HACK(eddyb) ignore the separately printed self argument.\n         let args = if first {\n-            decl.inputs.index(&FullRange)\n+            &decl.inputs[]\n         } else {\n             decl.inputs.slice_from(1)\n         };\n@@ -2400,7 +2399,7 @@ impl<'a> State<'a> {\n             ints.push(i);\n         }\n \n-        try!(self.commasep(Inconsistent, ints.index(&FullRange), |s, &idx| {\n+        try!(self.commasep(Inconsistent, &ints[], |s, &idx| {\n             if idx < generics.lifetimes.len() {\n                 let lifetime = &generics.lifetimes[idx];\n                 s.print_lifetime_def(lifetime)\n@@ -2417,7 +2416,7 @@ impl<'a> State<'a> {\n \n     pub fn print_ty_param(&mut self, param: &ast::TyParam) -> IoResult<()> {\n         try!(self.print_ident(param.ident));\n-        try!(self.print_bounds(\":\", param.bounds.index(&FullRange)));\n+        try!(self.print_bounds(\":\", &param.bounds[]));\n         match param.default {\n             Some(ref default) => {\n                 try!(space(&mut self.s));\n@@ -2493,7 +2492,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, name.get()));\n                 try!(self.popen());\n                 try!(self.commasep(Consistent,\n-                                   items.index(&FullRange),\n+                                   &items[],\n                                    |s, i| s.print_meta_item(&**i)));\n                 try!(self.pclose());\n             }\n@@ -2529,7 +2528,7 @@ impl<'a> State<'a> {\n                     try!(self.print_path(path, false));\n                     try!(word(&mut self.s, \"::{\"));\n                 }\n-                try!(self.commasep(Inconsistent, idents.index(&FullRange), |s, w| {\n+                try!(self.commasep(Inconsistent, &idents[], |s, w| {\n                     match w.node {\n                         ast::PathListIdent { name, .. } => {\n                             s.print_ident(name)\n@@ -2547,7 +2546,7 @@ impl<'a> State<'a> {\n     pub fn print_view_item(&mut self, item: &ast::ViewItem) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(item.span.lo));\n-        try!(self.print_outer_attributes(item.attrs.index(&FullRange)));\n+        try!(self.print_outer_attributes(&item.attrs[]));\n         try!(self.print_visibility(item.vis));\n         match item.node {\n             ast::ViewItemExternCrate(id, ref optional_path, _) => {\n@@ -2689,7 +2688,7 @@ impl<'a> State<'a> {\n             try!(self.pclose());\n         }\n \n-        try!(self.print_bounds(\":\", bounds.index(&FullRange)));\n+        try!(self.print_bounds(\":\", &bounds[]));\n \n         try!(self.print_fn_output(decl));\n \n@@ -2748,7 +2747,7 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(lit.span.lo));\n         match self.next_lit(lit.span.lo) {\n             Some(ref ltrl) => {\n-                return word(&mut self.s, (*ltrl).lit.index(&FullRange));\n+                return word(&mut self.s, &(*ltrl).lit[]);\n             }\n             _ => ()\n         }\n@@ -2758,44 +2757,44 @@ impl<'a> State<'a> {\n                 let mut res = String::from_str(\"b'\");\n                 ascii::escape_default(byte, |c| res.push(c as char));\n                 res.push('\\'');\n-                word(&mut self.s, res.index(&FullRange))\n+                word(&mut self.s, &res[])\n             }\n             ast::LitChar(ch) => {\n                 let mut res = String::from_str(\"'\");\n                 for c in ch.escape_default() {\n                     res.push(c);\n                 }\n                 res.push('\\'');\n-                word(&mut self.s, res.index(&FullRange))\n+                word(&mut self.s, &res[])\n             }\n             ast::LitInt(i, t) => {\n                 match t {\n                     ast::SignedIntLit(st, ast::Plus) => {\n                         word(&mut self.s,\n-                             ast_util::int_ty_to_string(st, Some(i as i64)).index(&FullRange))\n+                             &ast_util::int_ty_to_string(st, Some(i as i64))[])\n                     }\n                     ast::SignedIntLit(st, ast::Minus) => {\n                         let istr = ast_util::int_ty_to_string(st, Some(-(i as i64)));\n                         word(&mut self.s,\n-                             format!(\"-{}\", istr).index(&FullRange))\n+                             &format!(\"-{}\", istr)[])\n                     }\n                     ast::UnsignedIntLit(ut) => {\n                         word(&mut self.s, ast_util::uint_ty_to_string(ut, Some(i)).as_slice())\n                     }\n                     ast::UnsuffixedIntLit(ast::Plus) => {\n-                        word(&mut self.s, format!(\"{}\", i).index(&FullRange))\n+                        word(&mut self.s, &format!(\"{}\", i)[])\n                     }\n                     ast::UnsuffixedIntLit(ast::Minus) => {\n-                        word(&mut self.s, format!(\"-{}\", i).index(&FullRange))\n+                        word(&mut self.s, &format!(\"-{}\", i)[])\n                     }\n                 }\n             }\n             ast::LitFloat(ref f, t) => {\n                 word(&mut self.s,\n-                     format!(\n+                     &format!(\n                          \"{}{}\",\n                          f.get(),\n-                         ast_util::float_ty_to_string(t).index(&FullRange)).index(&FullRange))\n+                         &ast_util::float_ty_to_string(t)[])[])\n             }\n             ast::LitFloatUnsuffixed(ref f) => word(&mut self.s, f.get()),\n             ast::LitBool(val) => {\n@@ -2807,7 +2806,7 @@ impl<'a> State<'a> {\n                     ascii::escape_default(ch as u8,\n                                           |ch| escaped.push(ch as char));\n                 }\n-                word(&mut self.s, format!(\"b\\\"{}\\\"\", escaped).index(&FullRange))\n+                word(&mut self.s, &format!(\"b\\\"{}\\\"\", escaped)[])\n             }\n         }\n     }\n@@ -2848,7 +2847,7 @@ impl<'a> State<'a> {\n             comments::Mixed => {\n                 assert_eq!(cmnt.lines.len(), 1u);\n                 try!(zerobreak(&mut self.s));\n-                try!(word(&mut self.s, cmnt.lines[0].index(&FullRange)));\n+                try!(word(&mut self.s, &cmnt.lines[0][]));\n                 zerobreak(&mut self.s)\n             }\n             comments::Isolated => {\n@@ -2857,7 +2856,7 @@ impl<'a> State<'a> {\n                     // Don't print empty lines because they will end up as trailing\n                     // whitespace\n                     if !line.is_empty() {\n-                        try!(word(&mut self.s, line.index(&FullRange)));\n+                        try!(word(&mut self.s, &line[]));\n                     }\n                     try!(hardbreak(&mut self.s));\n                 }\n@@ -2866,13 +2865,13 @@ impl<'a> State<'a> {\n             comments::Trailing => {\n                 try!(word(&mut self.s, \" \"));\n                 if cmnt.lines.len() == 1u {\n-                    try!(word(&mut self.s, cmnt.lines[0].index(&FullRange)));\n+                    try!(word(&mut self.s, &cmnt.lines[0][]));\n                     hardbreak(&mut self.s)\n                 } else {\n                     try!(self.ibox(0u));\n                     for line in cmnt.lines.iter() {\n                         if !line.is_empty() {\n-                            try!(word(&mut self.s, line.index(&FullRange)));\n+                            try!(word(&mut self.s, &line[]));\n                         }\n                         try!(hardbreak(&mut self.s));\n                     }\n@@ -2905,7 +2904,7 @@ impl<'a> State<'a> {\n                          string=st))\n             }\n         };\n-        word(&mut self.s, st.index(&FullRange))\n+        word(&mut self.s, &st[])\n     }\n \n     pub fn next_comment(&mut self) -> Option<comments::Comment> {\n@@ -2936,7 +2935,7 @@ impl<'a> State<'a> {\n             Some(abi::Rust) => Ok(()),\n             Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n-                self.word_nbsp(abi.to_string().index(&FullRange))\n+                self.word_nbsp(&abi.to_string()[])\n             }\n             None => Ok(())\n         }\n@@ -2947,7 +2946,7 @@ impl<'a> State<'a> {\n         match opt_abi {\n             Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n-                self.word_nbsp(abi.to_string().index(&FullRange))\n+                self.word_nbsp(&abi.to_string()[])\n             }\n             None => Ok(())\n         }\n@@ -2963,7 +2962,7 @@ impl<'a> State<'a> {\n \n         if abi != abi::Rust {\n             try!(self.word_nbsp(\"extern\"));\n-            try!(self.word_nbsp(abi.to_string().index(&FullRange)));\n+            try!(self.word_nbsp(&abi.to_string()[]));\n         }\n \n         word(&mut self.s, \"fn\")"}, {"sha": "1d8f62abc087592ecc4261e4bba314a38f13a944", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -40,7 +40,7 @@ pub fn maybe_inject_prelude(krate: ast::Crate) -> ast::Crate {\n }\n \n fn use_std(krate: &ast::Crate) -> bool {\n-    !attr::contains_name(krate.attrs.index(&FullRange), \"no_std\")\n+    !attr::contains_name(&krate.attrs[], \"no_std\")\n }\n \n fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n@@ -56,7 +56,7 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n \n         // The name to use in `extern crate \"name\" as std;`\n         let actual_crate_name = match self.alt_std_name {\n-            Some(ref s) => token::intern_and_get_ident(s.index(&FullRange)),\n+            Some(ref s) => token::intern_and_get_ident(&s[]),\n             None => token::intern_and_get_ident(\"std\"),\n         };\n \n@@ -106,14 +106,27 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n         // only add `use std::prelude::*;` if there wasn't a\n         // `#![no_implicit_prelude]` at the crate level.\n         // fold_mod() will insert glob path.\n-        if !no_prelude(krate.attrs.index(&FullRange)) {\n+        if !no_prelude(&krate.attrs[]) {\n+            // only add `use std::prelude::*;` if there wasn't a\n+            // `#![no_implicit_prelude]` at the crate level.\n+            // fold_mod() will insert glob path.\n+            let globs_attr = attr::mk_attr_inner(attr::mk_attr_id(),\n+                                                 attr::mk_list_item(\n+                InternedString::new(\"feature\"),\n+                vec!(\n+                    attr::mk_word_item(InternedString::new(\"globs\")),\n+                )));\n+            // std_inject runs after feature checking so manually mark this attr\n+            attr::mark_used(&globs_attr);\n+            krate.attrs.push(globs_attr);\n+\n             krate.module = self.fold_mod(krate.module);\n         }\n         krate\n     }\n \n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n-        if !no_prelude(item.attrs.index(&FullRange)) {\n+        if !no_prelude(&item.attrs[]) {\n             // only recur if there wasn't `#![no_implicit_prelude]`\n             // on this item, i.e. this means that the prelude is not\n             // implicitly imported though the whole subtree"}, {"sha": "bacfa0bbfce4f65d163955fab958a27fffa7dc8d", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -73,14 +73,14 @@ pub fn modify_for_testing(sess: &ParseSess,\n     // We generate the test harness when building in the 'test'\n     // configuration, either with the '--test' or '--cfg test'\n     // command line options.\n-    let should_test = attr::contains_name(krate.config.index(&FullRange), \"test\");\n+    let should_test = attr::contains_name(&krate.config[], \"test\");\n \n     // Check for #[reexport_test_harness_main = \"some_name\"] which\n     // creates a `use some_name = __test::main;`. This needs to be\n     // unconditional, so that the attribute is still marked as used in\n     // non-test builds.\n     let reexport_test_harness_main =\n-        attr::first_attr_value_str_by_name(krate.attrs.index(&FullRange),\n+        attr::first_attr_value_str_by_name(&krate.attrs[],\n                                            \"reexport_test_harness_main\");\n \n     if should_test {\n@@ -119,7 +119,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n             self.cx.path.push(ident);\n         }\n         debug!(\"current path: {}\",\n-               ast_util::path_name_i(self.cx.path.index(&FullRange)));\n+               ast_util::path_name_i(&self.cx.path[]));\n \n         if is_test_fn(&self.cx, &*i) || is_bench_fn(&self.cx, &*i) {\n             match i.node {\n@@ -277,8 +277,8 @@ fn strip_test_functions(krate: ast::Crate) -> ast::Crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n     config::strip_items(krate, |attrs| {\n-        !attr::contains_name(attrs.index(&FullRange), \"test\") &&\n-        !attr::contains_name(attrs.index(&FullRange), \"bench\")\n+        !attr::contains_name(&attrs[], \"test\") &&\n+        !attr::contains_name(&attrs[], \"bench\")\n     })\n }\n \n@@ -291,7 +291,7 @@ enum HasTestSignature {\n \n \n fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n-    let has_test_attr = attr::contains_name(i.attrs.index(&FullRange), \"test\");\n+    let has_test_attr = attr::contains_name(&i.attrs[], \"test\");\n \n     fn has_test_signature(i: &ast::Item) -> HasTestSignature {\n         match &i.node {\n@@ -329,7 +329,7 @@ fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n }\n \n fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n-    let has_bench_attr = attr::contains_name(i.attrs.index(&FullRange), \"bench\");\n+    let has_bench_attr = attr::contains_name(&i.attrs[], \"bench\");\n \n     fn has_test_signature(i: &ast::Item) -> bool {\n         match i.node {\n@@ -384,7 +384,7 @@ We're going to be building a module that looks more or less like:\n mod __test {\n   extern crate test (name = \"test\", vers = \"...\");\n   fn main() {\n-    test::test_main_static(::os::args().index(&FullRange), tests)\n+    test::test_main_static(&::os::args()[], tests)\n   }\n \n   static tests : &'static [test::TestDescAndFn] = &[\n@@ -510,8 +510,8 @@ fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n }\n \n fn is_test_crate(krate: &ast::Crate) -> bool {\n-    match attr::find_crate_name(krate.attrs.index(&FullRange)) {\n-        Some(ref s) if \"test\" == s.get().index(&FullRange) => true,\n+    match attr::find_crate_name(&krate.attrs[]) {\n+        Some(ref s) if \"test\" == &s.get()[] => true,\n         _ => false\n     }\n }\n@@ -551,11 +551,11 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n     // creates $name: $expr\n     let field = |&: name, expr| ecx.field_imm(span, ecx.ident_of(name), expr);\n \n-    debug!(\"encoding {}\", ast_util::path_name_i(path.index(&FullRange)));\n+    debug!(\"encoding {}\", ast_util::path_name_i(&path[]));\n \n     // path to the #[test] function: \"foo::bar::baz\"\n-    let path_string = ast_util::path_name_i(path.index(&FullRange));\n-    let name_expr = ecx.expr_str(span, token::intern_and_get_ident(path_string.index(&FullRange)));\n+    let path_string = ast_util::path_name_i(&path[]);\n+    let name_expr = ecx.expr_str(span, token::intern_and_get_ident(&path_string[]));\n \n     // self::test::StaticTestName($name_expr)\n     let name_expr = ecx.expr_call(span,"}, {"sha": "5dca39f1aea063f57779bcb71015708f2c458576", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -110,27 +110,27 @@ impl Eq for RcStr {}\n \n impl Ord for RcStr {\n     fn cmp(&self, other: &RcStr) -> Ordering {\n-        self.index(&FullRange).cmp(other.index(&FullRange))\n+        self[].cmp(&other[])\n     }\n }\n \n impl fmt::Show for RcStr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         use std::fmt::Show;\n-        self.index(&FullRange).fmt(f)\n+        self[].fmt(f)\n     }\n }\n \n impl BorrowFrom<RcStr> for str {\n     fn borrow_from(owned: &RcStr) -> &str {\n-        owned.string.index(&FullRange)\n+        &owned.string[]\n     }\n }\n \n impl Deref for RcStr {\n     type Target = str;\n \n-    fn deref(&self) -> &str { self.string.index(&FullRange) }\n+    fn deref(&self) -> &str { &self.string[] }\n }\n \n /// A StrInterner differs from Interner<String> in that it accepts\n@@ -140,7 +140,7 @@ pub struct StrInterner {\n     vect: RefCell<Vec<RcStr> >,\n }\n \n-/// When traits can extend traits, we should extend index<Name,T> to get .index(&FullRange)\n+/// When traits can extend traits, we should extend index<Name,T> to get []\n impl StrInterner {\n     pub fn new() -> StrInterner {\n         StrInterner {"}, {"sha": "4933938f33836142d2c01ba31aea9991d7147200", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -180,7 +180,7 @@ impl<T: Writer+Send> TerminfoTerminal<T> {\n             }\n         };\n \n-        let entry = open(term.index(&FullRange));\n+        let entry = open(&term[]);\n         if entry.is_err() {\n             if os::getenv(\"MSYSCON\").map_or(false, |s| {\n                     \"mintty.exe\" == s"}, {"sha": "4735b6e8f2ad9a82e17d666a7e699772edab0dd9", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -284,13 +284,13 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n \n \n             // Find the offset of the NUL we want to go to\n-            let nulpos = string_table.index(&((offset as uint) .. (string_table_bytes as uint)))\n+            let nulpos = string_table[(offset as uint) .. (string_table_bytes as uint)]\n                 .iter().position(|&b| b == 0);\n             match nulpos {\n                 Some(len) => {\n                     string_map.insert(name.to_string(),\n-                                      string_table.index(&((offset as uint) ..\n-                                          (offset as uint + len))).to_vec())\n+                                      string_table[(offset as uint) ..\n+                                                   (offset as uint + len)].to_vec())\n                 },\n                 None => {\n                     return Err(\"invalid file: missing NUL in \\"}, {"sha": "1fca3c62f78ca62032cda2277788ba52cc9876df", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -61,13 +61,13 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n     for p in dirs_to_search.iter() {\n         if p.exists() {\n             let f = first_char.to_string();\n-            let newp = p.join_many(&[f.index(&FullRange), term]);\n+            let newp = p.join_many(&[&f[], term]);\n             if newp.exists() {\n                 return Some(box newp);\n             }\n             // on some installations the dir is named after the hex of the char (e.g. OS X)\n             let f = format!(\"{:x}\", first_char as uint);\n-            let newp = p.join_many(&[f.index(&FullRange), term]);\n+            let newp = p.join_many(&[&f[], term]);\n             if newp.exists() {\n                 return Some(box newp);\n             }"}, {"sha": "b6fc6462aa4bfb7f6228ff22f135ebcad193d4af", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -949,7 +949,7 @@ fn should_sort_failures_before_printing_them() {\n \n     st.write_failures().unwrap();\n     let s = match st.out {\n-        Raw(ref m) => String::from_utf8_lossy(m.index(&FullRange)),\n+        Raw(ref m) => String::from_utf8_lossy(&m[]),\n         Pretty(_) => unreachable!()\n     };\n "}, {"sha": "bd4b8e5e97f4922fc44235e749e26d1f478d5616", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -38,8 +38,6 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-#![feature(slicing_syntax)]\n-\n use std::{cmp, iter, mem};\n use std::thread::Thread;\n "}, {"sha": "5a47f9fbc573a7f5ecbac739de55d877bdc9e402", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -38,8 +38,6 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-#![feature(slicing_syntax)]\n-\n use std::cmp::min;\n use std::io::{stdout, IoResult};\n use std::iter::repeat;"}, {"sha": "e9da34615c19237a9651959565c5f9785f710be0", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -38,8 +38,6 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-#![feature(slicing_syntax)]\n-\n use std::cmp::min;\n use std::io::{BufferedWriter, File};\n use std::io;"}, {"sha": "7bca722e53ef3985bfcc9b3ab2d3918b13be98fc", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -13,8 +13,6 @@\n \n // multi tasking k-nucleotide\n \n-#![feature(slicing_syntax)]\n-\n use std::ascii::{AsciiExt, OwnedAsciiExt};\n use std::cmp::Ordering::{self, Less, Greater, Equal};\n use std::collections::HashMap;"}, {"sha": "25a23ffed4eacb55f571a98d37b00b9076debde9", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -40,8 +40,6 @@\n \n // ignore-android see #10393 #13206\n \n-#![feature(slicing_syntax)]\n-\n use std::ascii::OwnedAsciiExt;\n use std::iter::repeat;\n use std::slice;"}, {"sha": "0480c9d884ad001d84dabb6ae80f642c4adebb16", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -118,7 +118,7 @@ fn transform(piece: Vec<(int, int)> , all: bool) -> Vec<Vec<(int, int)>> {\n     // translating to (0, 0) as minimum coordinates.\n     for cur_piece in res.iter_mut() {\n         let (dy, dx) = *cur_piece.iter().min_by(|e| *e).unwrap();\n-        for &(ref mut y, ref mut x) in cur_piece.iter_mut() {\n+        for &mut (ref mut y, ref mut x) in cur_piece.iter_mut() {\n             *y -= dy; *x -= dx;\n         }\n     }"}, {"sha": "60d33d92549284202363e8cf6fbeddc1922ceba7", "filename": "src/test/bench/shootout-regex-dna.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -41,8 +41,6 @@\n // ignore-stage1\n // ignore-cross-compile #12102\n \n-#![feature(plugin, slicing_syntax)]\n-\n extern crate regex;\n \n use std::io;"}, {"sha": "841f70e13c4f919a019e4ce9ff7f28ec5c1cf93e", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -40,7 +40,7 @@\n \n // ignore-android see #10393 #13206\n \n-#![feature(slicing_syntax, unboxed_closures)]\n+#![feature(unboxed_closures)]\n \n extern crate libc;\n "}, {"sha": "02ccf9c0e08e7af6fd4daa7a6b6b49a4d61933bc", "filename": "src/test/compile-fail/issue-15756.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fcompile-fail%2Fissue-15756.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fcompile-fail%2Fissue-15756.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15756.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -14,7 +14,7 @@ use std::slice::ChunksMut;\n fn dft_iter<'a, T>(arg1: Chunks<'a,T>, arg2: ChunksMut<'a,T>)\n {\n     for\n-    &something\n+    &mut something\n //~^ ERROR the trait `core::marker::Sized` is not implemented for the type `[T]`\n     in arg2\n     {"}, {"sha": "9f1d3d1fb391298559d99fc576f4b23b3304ea9a", "filename": "src/test/compile-fail/mut-pattern-mismatched.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fcompile-fail%2Fmut-pattern-mismatched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fcompile-fail%2Fmut-pattern-mismatched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-pattern-mismatched.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -13,10 +13,8 @@ fn main() {\n \n     // (separate lines to ensure the spans are accurate)\n \n-    // SNAP 9e4e524 uncomment this after the next snapshot\n-    // NOTE(stage0) just in case tidy doesn't check snap's in tests\n-    // let &_ // ~ ERROR expected `&mut isize`, found `&_`\n-    //    = foo;\n+     let &_ //~ ERROR expected `&mut isize`, found `&_`\n+        = foo;\n     let &mut _ = foo;\n \n     let bar = &1is;"}, {"sha": "6b6ab3f29701953fc326385f8be4464df2092077", "filename": "src/test/compile-fail/packed-struct-generic-transmute.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -15,8 +15,6 @@\n \n // error-pattern: transmute called on types with different size\n \n-#![feature(slicing_syntax)]\n-\n use std::mem;\n \n #[repr(packed)]"}, {"sha": "54ac3cba636f24abc6ddbf28dc75bda565d6f754", "filename": "src/test/compile-fail/pattern-bindings-after-at.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fcompile-fail%2Fpattern-bindings-after-at.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fcompile-fail%2Fpattern-bindings-after-at.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-bindings-after-at.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -15,7 +15,7 @@ enum Option<T> {\n \n fn main() {\n     match &mut Some(1i) {\n-        ref mut z @ &Some(ref a) => {\n+        ref mut z @ &mut Some(ref a) => {\n         //~^ ERROR pattern bindings are not allowed after an `@`\n             **z = None;\n             println!(\"{}\", *a);"}, {"sha": "1668b868e641ec9d2f8b58fefe4fb34b202d4917", "filename": "src/test/compile-fail/range-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-1.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // Test range syntax - type errors.\n-#![feature(slicing_syntax)]\n \n pub fn main() {\n     // Mixed types."}, {"sha": "40690bd844bce6f6980e95b770b41c18fa75bcd2", "filename": "src/test/compile-fail/range-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fcompile-fail%2Frange-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fcompile-fail%2Frange-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-2.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // Test range syntax - borrow errors.\n-#![feature(slicing_syntax)]\n \n pub fn main() {\n     let r = {"}, {"sha": "07162293565ed2c9e3f93e4d89521212497bda44", "filename": "src/test/compile-fail/slice-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fcompile-fail%2Fslice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fcompile-fail%2Fslice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-2.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -10,8 +10,6 @@\n \n // Test that slicing syntax gives errors if we have not implemented the trait.\n \n-#![feature(slicing_syntax)]\n-\n struct Foo;\n \n fn main() {"}, {"sha": "43c4326628d338f24af8fe61b69fc3752a59a187", "filename": "src/test/compile-fail/slice-borrow.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fcompile-fail%2Fslice-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fcompile-fail%2Fslice-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-borrow.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -10,8 +10,6 @@\n \n // Test slicing expressions doesn't defeat the borrow checker.\n \n-#![feature(slicing_syntax)]\n-\n fn main() {\n     let y;\n     {"}, {"sha": "12f184d410c900e3539021c81c6a77c115941c0e", "filename": "src/test/compile-fail/slice-mut-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -10,8 +10,6 @@\n \n // Test mutability and slicing syntax.\n \n-#![feature(slicing_syntax)]\n-\n fn main() {\n     let x: &[int] = &[1, 2, 3, 4, 5];\n     // Can't mutably slice an immutable slice"}, {"sha": "9bd9a752e4e890e0574db32ca22e0975d7871f77", "filename": "src/test/compile-fail/slice-mut.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -10,8 +10,6 @@\n \n // Test mutability and slicing syntax.\n \n-#![feature(slicing_syntax)]\n-\n fn main() {\n     let x: &[int] = &[1, 2, 3, 4, 5];\n     // Immutable slices are not mutable."}, {"sha": "949dffaac068f474bda3a2649f0a4fcfc43d6068", "filename": "src/test/debuginfo/vec-slices.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -77,7 +77,6 @@\n // lldb-check:[...]$5 = &[AStruct { x: 10, y: 11, z: 12 }, AStruct { x: 13, y: 14, z: 15 }]\n \n #![allow(unused_variables)]\n-#![feature(slicing_syntax)]\n #![omit_gdb_pretty_printer_section]\n \n struct AStruct {"}, {"sha": "c024b6ce86171da354e8bc2b67cc79945e8f301e", "filename": "src/test/run-pass/drop-trait-enum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fdrop-trait-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fdrop-trait-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-trait-enum.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -36,13 +36,13 @@ enum Foo {\n impl Drop for Foo {\n     fn drop(&mut self) {\n         match self {\n-            &Foo::SimpleVariant(ref mut sender) => {\n+            &mut Foo::SimpleVariant(ref mut sender) => {\n                 sender.send(Message::DestructorRan).unwrap();\n             }\n-            &Foo::NestedVariant(_, _, ref mut sender) => {\n+            &mut Foo::NestedVariant(_, _, ref mut sender) => {\n                 sender.send(Message::DestructorRan).unwrap();\n             }\n-            &Foo::FailingVariant { .. } => {\n+            &mut Foo::FailingVariant { .. } => {\n                 panic!(\"Failed\");\n             }\n         }"}, {"sha": "72daa0cba4104abcb20783e2f34d66589fabdb16", "filename": "src/test/run-pass/issue-15730.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fissue-15730.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fissue-15730.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15730.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(slicing_syntax)]\n-\n fn main() {\n     let mut array = [1, 2, 3];\n     let pie_slice = &array[1..2];"}, {"sha": "4246fced26c66e02ae9886405705458f2387f599", "filename": "src/test/run-pass/issue-16774.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fissue-16774.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fissue-16774.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16774.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -36,7 +36,7 @@ impl Deref for X {\n \n impl DerefMut for X {\n     fn deref_mut(&mut self) -> &mut int {\n-        let &X(box ref mut x) = self;\n+        let &mut X(box ref mut x) = self;\n         x\n     }\n }"}, {"sha": "65bf088786efb927273a95a3f2e0418cbe3da9f9", "filename": "src/test/run-pass/issue-17503.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fissue-17503.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fissue-17503.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17503.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(slicing_syntax)]\n-\n fn main() {\n     let s: &[int] = &[0, 1, 2, 3, 4];\n     let ss: &&[int] = &s;"}, {"sha": "f74b09a3d246fb540652facc940710b27832ea0f", "filename": "src/test/run-pass/issue-20644.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fissue-20644.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fissue-20644.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20644.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -11,7 +11,6 @@\n // A reduced version of the rustbook ice. The problem this encountered\n // had to do with trans ignoring binders.\n \n-#![feature(slicing_syntax)]\n #![feature(associated_types)]\n #![feature(macro_rules)]\n "}, {"sha": "bf3d0b786af65c48b53ce212626d61732bc305b7", "filename": "src/test/run-pass/issue-3888-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(slicing_syntax)]\n-\n fn vec_peek<'r, T>(v: &'r [T]) -> &'r [T] {\n     &v[1..5]\n }"}, {"sha": "33a5c7a167f9991ab9a121c95dd3bae5188cc6ab", "filename": "src/test/run-pass/issue-4464.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fissue-4464.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fissue-4464.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4464.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(slicing_syntax)]\n-\n fn broken(v: &[u8], i: uint, j: uint) -> &[u8] { &v[i..j] }\n \n pub fn main() {}"}, {"sha": "42739628eed75c8dcb8f8dbd47316131a266c4e4", "filename": "src/test/run-pass/issue-8898.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8898.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(slicing_syntax)]\n-\n fn assert_repr_eq<T: std::fmt::Show>(obj : T, expected : String) {\n     assert_eq!(expected, format!(\"{:?}\", obj));\n }"}, {"sha": "90e871689908256f21eb237506693b7a86e597c5", "filename": "src/test/run-pass/range.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frange.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -10,8 +10,6 @@\n \n // Test range syntax.\n \n-#![feature(slicing_syntax)]\n-\n fn foo() -> int { 42 }\n \n pub fn main() {"}, {"sha": "d1d37ea5bb099b28a6cebf22bca9494e3900fa35", "filename": "src/test/run-pass/repeated-vector-syntax.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Frepeated-vector-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Frepeated-vector-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frepeated-vector-syntax.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(slicing_syntax)]\n-\n pub fn main() {\n     let x = [ [true]; 512 ];\n     let y = [ 0i; 1 ];"}, {"sha": "8f031d2e97e3ffd90d61a671466b9a32ff4cdef2", "filename": "src/test/run-pass/slice-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fslice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fslice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-2.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -10,8 +10,6 @@\n \n // Test slicing expressions on slices and Vecs.\n \n-#![feature(slicing_syntax)]\n-\n fn main() {\n     let x: &[int] = &[1, 2, 3, 4, 5];\n     let cmp: &[int] = &[1, 2, 3, 4, 5];"}, {"sha": "b2e3d83ca9b36791513f748c6b3c9e07464c91bf", "filename": "src/test/run-pass/slice-panic-1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fslice-panic-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fslice-panic-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-panic-1.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -10,8 +10,6 @@\n \n // Test that if a slicing expr[..] fails, the correct cleanups happen.\n \n-#![feature(slicing_syntax)]\n-\n use std::thread::Thread;\n \n struct Foo;"}, {"sha": "dea45e63ab000db72e4614059cc3d40d9e2d60f0", "filename": "src/test/run-pass/slice-panic-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fslice-panic-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fslice-panic-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-panic-2.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -10,8 +10,6 @@\n \n // Test that if a slicing expr[..] fails, the correct cleanups happen.\n \n-#![feature(slicing_syntax)]\n-\n use std::thread::Thread;\n \n struct Foo;"}, {"sha": "9cb7cfd7fe98bc80a41efc7544424e49076f26ce", "filename": "src/test/run-pass/slice.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec/src%2Ftest%2Frun-pass%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice.rs?ref=6e806bdefde91af102567ef4b5dbd3ccf0c5c2ec", "patch": "@@ -10,11 +10,10 @@\n \n // Test slicing sugar.\n \n-#![feature(slicing_syntax)]\n #![feature(associated_types)]\n \n extern crate core;\n-use core::ops::{Index, Range, RangeTo, RangeFrom, FullRange};\n+use core::ops::{Index, IndexMut, Range, RangeTo, RangeFrom, FullRange};\n \n static mut COUNT: uint = 0;\n "}]}