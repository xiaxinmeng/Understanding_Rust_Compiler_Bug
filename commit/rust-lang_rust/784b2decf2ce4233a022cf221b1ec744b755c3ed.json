{"sha": "784b2decf2ce4233a022cf221b1ec744b755c3ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4NGIyZGVjZjJjZTQyMzNhMDIyY2YyMjFiMWVjNzQ0Yjc1NWMzZWQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-31T23:03:05Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-31T23:03:05Z"}, "message": "Majority of the remaining work for derived tydescs. Not quite working yet.", "tree": {"sha": "ff607220362a54ba370bb08cab6fa1ffb140ba78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff607220362a54ba370bb08cab6fa1ffb140ba78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/784b2decf2ce4233a022cf221b1ec744b755c3ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/784b2decf2ce4233a022cf221b1ec744b755c3ed", "html_url": "https://github.com/rust-lang/rust/commit/784b2decf2ce4233a022cf221b1ec744b755c3ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/784b2decf2ce4233a022cf221b1ec744b755c3ed/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21418230cd9f670740e0db52f76e0b38067c0dbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/21418230cd9f670740e0db52f76e0b38067c0dbc", "html_url": "https://github.com/rust-lang/rust/commit/21418230cd9f670740e0db52f76e0b38067c0dbc"}], "stats": {"total": 265, "additions": 159, "deletions": 106}, "files": [{"sha": "8eb614e5da385b8f2eb711cc47caa44396861d60", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 159, "deletions": 106, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/784b2decf2ce4233a022cf221b1ec744b755c3ed/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/784b2decf2ce4233a022cf221b1ec744b755c3ed/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=784b2decf2ce4233a022cf221b1ec744b755c3ed", "patch": "@@ -63,6 +63,7 @@ type tag_info = rec(type_handle th,\n state type crate_ctxt = rec(session.session sess,\n                             ModuleRef llmod,\n                             target_data td,\n+                            ValueRef crate_ptr,\n                             hashmap[str, ValueRef] upcalls,\n                             hashmap[str, ValueRef] intrinsics,\n                             hashmap[str, ValueRef] item_names,\n@@ -687,25 +688,25 @@ fn llalign_of(TypeRef t) -> ValueRef {\n     ret llvm.LLVMConstIntCast(lib.llvm.llvm.LLVMAlignOf(t), T_int(), False);\n }\n \n-fn size_of(@block_ctxt cx, @ty.t t) -> ValueRef {\n+fn size_of(@block_ctxt cx, @ty.t t) -> result {\n     if (!ty.type_has_dynamic_size(t)) {\n-        ret llsize_of(type_of(cx.fcx.ccx, t));\n+        ret res(cx, llsize_of(type_of(cx.fcx.ccx, t)));\n     }\n     ret dynamic_size_of(cx, t);\n }\n \n-fn align_of(@block_ctxt cx, @ty.t t) -> ValueRef {\n+fn align_of(@block_ctxt cx, @ty.t t) -> result {\n     if (!ty.type_has_dynamic_size(t)) {\n-        ret llalign_of(type_of(cx.fcx.ccx, t));\n+        ret res(cx, llalign_of(type_of(cx.fcx.ccx, t)));\n     }\n     ret dynamic_align_of(cx, t);\n }\n \n-fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> ValueRef {\n+fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> result {\n     alt (t.struct) {\n         case (ty.ty_param(?p)) {\n             auto szptr = field_of_tydesc(cx, t, abi.tydesc_field_size);\n-            ret cx.build.Load(szptr);\n+            ret res(szptr.bcx, szptr.bcx.build.Load(szptr.val));\n         }\n         case (ty.ty_tup(?elts)) {\n             //\n@@ -718,51 +719,63 @@ fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> ValueRef {\n             //\n             auto off = C_int(0);\n             auto max_align = C_int(1);\n+            auto bcx = cx;\n             for (@ty.t e in elts) {\n-                auto elt_align = align_of(cx, e);\n-                auto elt_size = size_of(cx, e);\n-                auto aligned_off = align_to(cx, off, elt_align);\n-                off = cx.build.Add(aligned_off, elt_size);\n-                max_align = umax(cx, max_align, elt_align);\n+                auto elt_align = align_of(bcx, e);\n+                bcx = elt_align.bcx;\n+                auto elt_size = size_of(bcx, e);\n+                bcx = elt_size.bcx;\n+                auto aligned_off = align_to(bcx, off, elt_align.val);\n+                off = cx.build.Add(aligned_off, elt_size.val);\n+                max_align = umax(bcx, max_align, elt_align.val);\n             }\n-            off = align_to(cx, off, max_align);\n-            ret off;\n+            off = align_to(bcx, off, max_align);\n+            ret res(bcx, off);\n         }\n         case (ty.ty_rec(?flds)) {\n             auto off = C_int(0);\n             auto max_align = C_int(1);\n+            auto bcx = cx;\n             for (ty.field f in flds) {\n-                auto elt_align = align_of(cx, f.ty);\n-                auto elt_size = size_of(cx, f.ty);\n-                auto aligned_off = align_to(cx, off, elt_align);\n-                off = cx.build.Add(aligned_off, elt_size);\n-                max_align = umax(cx, max_align, elt_align);\n+                auto elt_align = align_of(bcx, f.ty);\n+                bcx = elt_align.bcx;\n+                auto elt_size = size_of(bcx, f.ty);\n+                bcx = elt_size.bcx;\n+                auto aligned_off = align_to(bcx, off, elt_align.val);\n+                off = cx.build.Add(aligned_off, elt_size.val);\n+                max_align = umax(bcx, max_align, elt_align.val);\n             }\n-            off = align_to(cx, off, max_align);\n-            ret off;\n+            off = align_to(bcx, off, max_align);\n+            ret res(bcx, off);\n         }\n     }\n }\n \n-fn dynamic_align_of(@block_ctxt cx, @ty.t t) -> ValueRef {\n+fn dynamic_align_of(@block_ctxt cx, @ty.t t) -> result {\n     alt (t.struct) {\n         case (ty.ty_param(?p)) {\n             auto aptr = field_of_tydesc(cx, t, abi.tydesc_field_align);\n-            ret cx.build.Load(aptr);\n+            ret res(aptr.bcx, aptr.bcx.build.Load(aptr.val));\n         }\n         case (ty.ty_tup(?elts)) {\n             auto a = C_int(1);\n+            auto bcx = cx;\n             for (@ty.t e in elts) {\n-                a = umax(cx, a, align_of(cx, e));\n+                auto align = align_of(bcx, e);\n+                bcx = align.bcx;\n+                a = umax(bcx, a, align.val);\n             }\n-            ret a;\n+            ret res(bcx, a);\n         }\n         case (ty.ty_rec(?flds)) {\n             auto a = C_int(1);\n+            auto bcx = cx;\n             for (ty.field f in flds) {\n-                a = umax(cx, a, align_of(cx, f.ty));\n+                auto align = align_of(bcx, f.ty);\n+                bcx = align.bcx;\n+                a = umax(bcx, a, align.val);\n             }\n-            ret a;\n+            ret res(bcx, a);\n         }\n     }\n }\n@@ -774,7 +787,7 @@ fn dynamic_align_of(@block_ctxt cx, @ty.t t) -> ValueRef {\n // align_of, above.\n \n fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n-                ValueRef base, vec[int] ixs) -> ValueRef {\n+                ValueRef base, vec[int] ixs) -> result {\n \n     check (ty.type_is_tup_like(t));\n \n@@ -785,7 +798,7 @@ fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n         for (int i in ixs) {\n             v += C_int(i);\n         }\n-        ret cx.build.GEP(base, v);\n+        ret res(cx, cx.build.GEP(base, v));\n     }\n \n     // It is a dynamic-containing type that, if we convert directly to an LLVM\n@@ -856,14 +869,16 @@ fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n \n     auto s = split_type(t, ixs, 0u);\n     auto prefix_ty = ty.plain_ty(ty.ty_tup(s.prefix));\n-    auto sz = size_of(cx, prefix_ty);\n-    auto raw = cx.build.PointerCast(base, T_ptr(T_i8()));\n-    auto bumped = cx.build.GEP(raw, vec(sz));\n+    auto bcx = cx;\n+    auto sz = size_of(bcx, prefix_ty);\n+    bcx = sz.bcx;\n+    auto raw = bcx.build.PointerCast(base, T_ptr(T_i8()));\n+    auto bumped = bcx.build.GEP(raw, vec(sz.val));\n     alt (s.target.struct) {\n-        case (ty.ty_param(_)) { ret bumped; }\n+        case (ty.ty_param(_)) { ret res(bcx, bumped); }\n         case (_) {\n-            auto ty = T_ptr(type_of(cx.fcx.ccx, s.target));\n-            ret cx.build.PointerCast(bumped, ty);\n+            auto ty = T_ptr(type_of(bcx.fcx.ccx, s.target));\n+            ret res(bcx, bcx.build.PointerCast(bumped, ty));\n         }\n     }\n }\n@@ -893,9 +908,10 @@ fn trans_malloc(@block_ctxt cx, @ty.t t) -> result {\n // Given a type and a field index into its corresponding type descriptor,\n // returns an LLVM ValueRef of that field from the tydesc, generating the\n // tydesc if necessary.\n-fn field_of_tydesc(@block_ctxt cx, @ty.t t, int field) -> ValueRef {\n+fn field_of_tydesc(@block_ctxt cx, @ty.t t, int field) -> result {\n     auto tydesc = get_tydesc(cx, t);\n-    ret cx.build.GEP(tydesc, vec(C_int(0), C_int(field)));\n+    ret res(tydesc.bcx,\n+            tydesc.bcx.build.GEP(tydesc.val, vec(C_int(0), C_int(field))));\n }\n \n // Given a type containing ty params, build a vector containing a ValueRef for\n@@ -940,10 +956,12 @@ fn linearize_ty_params(@block_ctxt cx, @ty.t t)\n     ret tup(x.defs, x.vals);\n }\n \n-fn get_tydesc(&@block_ctxt cx, @ty.t t) -> ValueRef {\n+fn get_tydesc(&@block_ctxt cx, @ty.t t) -> result {\n     // Is the supplied type a type param? If so, return the passed-in tydesc.\n     alt (ty.type_param(t)) {\n-        case (some[ast.def_id](?id)) { ret cx.fcx.lltydescs.get(id); }\n+        case (some[ast.def_id](?id)) {\n+            ret res(cx, cx.fcx.lltydescs.get(id));\n+        }\n         case (none[ast.def_id])      { /* fall through */ }\n     }\n \n@@ -953,21 +971,44 @@ fn get_tydesc(&@block_ctxt cx, @ty.t t) -> ValueRef {\n     if (ty.count_ty_params(t) > 0u) {\n         auto tys = linearize_ty_params(cx, t);\n \n+        check (n_params == _vec.len[ast.def_id](tys._0));\n+        check (n_params == _vec.len[ValueRef](tys._1));\n+\n         if (!cx.fcx.ccx.tydescs.contains_key(t)) {\n             make_tydesc(cx.fcx.ccx, t, tys._0);\n         }\n \n         auto root = cx.fcx.ccx.tydescs.get(t);\n \n-        cx.fcx.ccx.sess.unimpl(\"derived type descriptors\");\n+        auto tydescs = cx.build.Alloca(T_array(T_ptr(T_tydesc()), n_params));\n+        auto i = 0;\n+        for (ValueRef td in tys._1) {\n+            auto tdp = cx.build.GEP(tydescs, vec(C_int(0), C_int(i)));\n+            cx.build.Store(td, tdp);\n+        }\n+\n+        auto bcx = cx;\n+        auto sz = size_of(bcx, t);\n+        bcx = sz.bcx;\n+        auto align = align_of(bcx, t);\n+        bcx = align.bcx;\n+\n+        auto v = trans_upcall(bcx, \"upcall_get_type_desc\",\n+                              vec(p2i(bcx.fcx.ccx.crate_ptr),\n+                                  sz.val,\n+                                  align.val,\n+                                  C_int(n_params as int),\n+                                  bcx.build.PtrToInt(tydescs, T_int())));\n+\n+        ret res(v.bcx, v.bcx.build.IntToPtr(v.val, T_ptr(T_tydesc())));\n     }\n \n     // Otherwise, generate a tydesc if necessary, and return it.\n     if (!cx.fcx.ccx.tydescs.contains_key(t)) {\n         let vec[ast.def_id] defs = vec();\n         make_tydesc(cx.fcx.ccx, t, defs);\n     }\n-    ret cx.fcx.ccx.tydescs.get(t);\n+    ret res(cx, cx.fcx.ccx.tydescs.get(t));\n }\n \n fn make_tydesc(@crate_ctxt cx, @ty.t t, vec[ast.def_id] typaram_defs) {\n@@ -1437,20 +1478,20 @@ fn iter_sequence(@block_ctxt cx,\n                                           C_int(abi.vec_elt_fill)));\n \n         auto llunit_ty = type_of(cx.fcx.ccx, elt_ty);\n-        auto unit_sz = size_of(cx, elt_ty);\n+        auto bcx = cx;\n+        auto unit_sz = size_of(bcx, elt_ty);\n+        bcx = unit_sz.bcx;\n \n-        auto len = cx.build.Load(lenptr);\n+        auto len = bcx.build.Load(lenptr);\n         if (trailing_null) {\n-            len = cx.build.Sub(len, unit_sz);\n+            len = bcx.build.Sub(len, unit_sz.val);\n         }\n \n-        auto r = res(cx, C_nil());\n-\n         auto cond_cx = new_scope_block_ctxt(cx, \"sequence-iter cond\");\n         auto body_cx = new_scope_block_ctxt(cx, \"sequence-iter body\");\n         auto next_cx = new_sub_block_ctxt(cx, \"next\");\n \n-        cx.build.Br(cond_cx.llbb);\n+        bcx.build.Br(cond_cx.llbb);\n \n         auto ix = cond_cx.build.Phi(T_int(), vec(C_int(0)), vec(cx.llbb));\n         auto scaled_ix = cond_cx.build.Phi(T_int(),\n@@ -1465,7 +1506,7 @@ fn iter_sequence(@block_ctxt cx,\n                           load_scalar_or_boxed(body_cx, elt, elt_ty),\n                           elt_ty);\n         auto next_ix = body_res.bcx.build.Add(ix, C_int(1));\n-        auto next_scaled_ix = body_res.bcx.build.Add(scaled_ix, unit_sz);\n+        auto next_scaled_ix = body_res.bcx.build.Add(scaled_ix, unit_sz.val);\n \n         cond_cx.build.AddIncomingToPhi(ix, vec(next_ix),\n                                        vec(body_res.bcx.llbb));\n@@ -1504,7 +1545,8 @@ fn call_tydesc_glue_full(@block_ctxt cx, ValueRef v,\n }\n \n fn call_tydesc_glue(@block_ctxt cx, ValueRef v, @ty.t t, int field) {\n-    call_tydesc_glue_full(cx, v, get_tydesc(cx, t), field);\n+    auto td = get_tydesc(cx, t);\n+    call_tydesc_glue_full(td.bcx, v, td.val, field);\n }\n \n fn incr_all_refcnts(@block_ctxt cx,\n@@ -1565,8 +1607,8 @@ fn memcpy_ty(@block_ctxt cx,\n              @ty.t t) -> result {\n     if (ty.type_has_dynamic_size(t)) {\n         auto llszptr = field_of_tydesc(cx, t, abi.tydesc_field_size);\n-        auto llsz = cx.build.Load(llszptr);\n-        ret call_memcpy(cx, dst, src, llsz);\n+        auto llsz = llszptr.bcx.build.Load(llszptr.val);\n+        ret call_memcpy(llszptr.bcx, dst, src, llsz);\n \n     } else {\n         ret res(cx, cx.build.Store(cx.build.Load(src), dst));\n@@ -2182,14 +2224,17 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                     auto tys = ty.resolve_ty_params(fn_item, monoty);\n \n                     if (_vec.len[@ty.t](tys) != 0u) {\n+                        auto bcx = cx;\n                         let vec[ValueRef] tydescs = vec();\n                         for (@ty.t t in tys) {\n-                            append[ValueRef](tydescs,\n-                                             get_tydesc(cx, t));\n+                            auto td = get_tydesc(bcx, t);\n+                            bcx = td.bcx;\n+                            append[ValueRef](tydescs, td.val);\n                         }\n                         auto gen = rec( item_type = ty.item_ty(fn_item)._1,\n                                         tydescs = tydescs );\n-                        lv = rec(generic = some[generic_info](gen)\n+                        lv = rec(res = res(bcx, lv.res.val),\n+                                 generic = some[generic_info](gen)\n                                  with lv);\n                     }\n \n@@ -2236,12 +2281,12 @@ fn trans_field(@block_ctxt cx, &ast.span sp, @ast.expr base,\n         case (ty.ty_tup(?fields)) {\n             let uint ix = ty.field_num(cx.fcx.ccx.sess, sp, field);\n             auto v = GEP_tup_like(r.bcx, t, r.val, vec(0, ix as int));\n-            ret lval_mem(r.bcx, v);\n+            ret lval_mem(v.bcx, v.val);\n         }\n         case (ty.ty_rec(?fields)) {\n             let uint ix = ty.field_idx(cx.fcx.ccx.sess, sp, field, fields);\n             auto v = GEP_tup_like(r.bcx, t, r.val, vec(0, ix as int));\n-            ret lval_mem(r.bcx, v);\n+            ret lval_mem(v.bcx, v.val);\n         }\n         case (ty.ty_obj(?methods)) {\n             let uint ix = ty.method_idx(cx.fcx.ccx.sess, sp, field, methods);\n@@ -2267,20 +2312,22 @@ fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n     lv = autoderef(lv.bcx, lv.val, ty.expr_ty(base));\n     auto ix = trans_expr(lv.bcx, idx);\n     auto v = lv.val;\n+    auto bcx = ix.bcx;\n \n     auto llunit_ty = node_type(cx.fcx.ccx, ann);\n-    auto unit_sz = size_of(cx, node_ann_type(cx.fcx.ccx, ann));\n-    auto scaled_ix = ix.bcx.build.Mul(ix.val, unit_sz);\n+    auto unit_sz = size_of(bcx, node_ann_type(cx.fcx.ccx, ann));\n+    bcx = unit_sz.bcx;\n+    auto scaled_ix = bcx.build.Mul(ix.val, unit_sz.val);\n \n-    auto lim = ix.bcx.build.GEP(v, vec(C_int(0), C_int(abi.vec_elt_fill)));\n-    lim = ix.bcx.build.Load(lim);\n+    auto lim = bcx.build.GEP(v, vec(C_int(0), C_int(abi.vec_elt_fill)));\n+    lim = bcx.build.Load(lim);\n \n-    auto bounds_check = ix.bcx.build.ICmp(lib.llvm.LLVMIntULT,\n-                                          scaled_ix, lim);\n+    auto bounds_check = bcx.build.ICmp(lib.llvm.LLVMIntULT,\n+                                       scaled_ix, lim);\n \n-    auto fail_cx = new_sub_block_ctxt(ix.bcx, \"fail\");\n-    auto next_cx = new_sub_block_ctxt(ix.bcx, \"next\");\n-    ix.bcx.build.CondBr(bounds_check, next_cx.llbb, fail_cx.llbb);\n+    auto fail_cx = new_sub_block_ctxt(bcx, \"fail\");\n+    auto next_cx = new_sub_block_ctxt(bcx, \"next\");\n+    bcx.build.CondBr(bounds_check, next_cx.llbb, fail_cx.llbb);\n \n     // fail: bad bounds check.\n     auto fail_res = trans_fail(fail_cx, sp, \"bounds check\");\n@@ -2590,7 +2637,8 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                               vec(C_int(0),\n                                   C_int(abi.closure_elt_tydesc)));\n             auto bindings_tydesc = get_tydesc(bcx, bindings_ty);\n-            bcx.build.Store(bindings_tydesc, bound_tydesc);\n+            bcx = bindings_tydesc.bcx;\n+            bcx.build.Store(bindings_tydesc.val, bound_tydesc);\n \n             // Store thunk-target.\n             auto bound_target =\n@@ -2740,16 +2788,18 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n     }\n \n     auto llunit_ty = type_of(cx.fcx.ccx, unit_ty);\n-    auto unit_sz = size_of(cx, unit_ty);\n+    auto bcx = cx;\n+    auto unit_sz = size_of(bcx, unit_ty);\n+    bcx = unit_sz.bcx;\n     auto data_sz = llvm.LLVMConstMul(C_int(_vec.len[@ast.expr](args) as int),\n-                                     unit_sz);\n+                                     unit_sz.val);\n \n     // FIXME: pass tydesc properly.\n-    auto sub = trans_upcall(cx, \"upcall_new_vec\", vec(data_sz, C_int(0)));\n+    auto sub = trans_upcall(bcx, \"upcall_new_vec\", vec(data_sz, C_int(0)));\n \n-    auto llty = type_of(cx.fcx.ccx, t);\n+    auto llty = type_of(bcx.fcx.ccx, t);\n     auto vec_val = sub.bcx.build.IntToPtr(sub.val, llty);\n-    find_scope_cx(cx).cleanups += clean(bind drop_ty(_, vec_val, t));\n+    find_scope_cx(bcx).cleanups += clean(bind drop_ty(_, vec_val, t));\n \n     auto body = sub.bcx.build.GEP(vec_val, vec(C_int(0),\n                                                C_int(abi.vec_elt_data)));\n@@ -3044,8 +3094,8 @@ fn init_local(@block_ctxt cx, @ast.local local) -> result {\n         }\n         case (_) {\n             if (middle.ty.type_has_dynamic_size(ty)) {\n-                auto llsz = size_of(cx, ty);\n-                bcx = call_bzero(cx, llptr, llsz).bcx;\n+                auto llsz = size_of(bcx, ty);\n+                bcx = call_bzero(llsz.bcx, llptr, llsz.val).bcx;\n \n             } else {\n                 auto llty = type_of(bcx.fcx.ccx, ty);\n@@ -3179,14 +3229,16 @@ iter block_locals(&ast.block b) -> @ast.local {\n fn alloc_local(@block_ctxt cx, @ast.local local) -> result {\n     auto t = node_ann_type(cx.fcx.ccx, local.ann);\n     auto val = C_int(0);\n+    auto bcx = cx;\n     if (ty.type_has_dynamic_size(t)) {\n-        auto n = size_of(cx, t);\n-        val = cx.build.ArrayAlloca(T_i8(), n);\n+        auto n = size_of(bcx, t);\n+        bcx = n.bcx;\n+        val = bcx.build.ArrayAlloca(T_i8(), n.val);\n     } else {\n-        val = cx.build.Alloca(type_of(cx.fcx.ccx, t));\n+        val = bcx.build.Alloca(type_of(cx.fcx.ccx, t));\n     }\n-    cx.fcx.lllocals.insert(local.id, val);\n-    ret res(cx, val);\n+    bcx.fcx.lllocals.insert(local.id, val);\n+    ret res(bcx, val);\n }\n \n fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n@@ -3526,43 +3578,45 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n \n         // Malloc a box for the body.\n         auto r = trans_malloc_inner(bcx, llobj_body_ty);\n+        bcx = r.bcx;\n         auto box = r.val;\n-        auto rc = r.bcx.build.GEP(box,\n+        auto rc = bcx.build.GEP(box,\n+                                vec(C_int(0),\n+                                    C_int(abi.box_rc_field_refcnt)));\n+        auto body = bcx.build.GEP(box,\n                                   vec(C_int(0),\n-                                      C_int(abi.box_rc_field_refcnt)));\n-        auto body = r.bcx.build.GEP(box,\n-                                    vec(C_int(0),\n-                                        C_int(abi.box_rc_field_body)));\n-        r.bcx.build.Store(C_int(1), rc);\n+                                      C_int(abi.box_rc_field_body)));\n+        bcx.build.Store(C_int(1), rc);\n \n         // Store body tydesc.\n         auto body_tydesc =\n-            r.bcx.build.GEP(body,\n-                            vec(C_int(0),\n-                                C_int(abi.obj_body_elt_tydesc)));\n+            bcx.build.GEP(body,\n+                          vec(C_int(0),\n+                              C_int(abi.obj_body_elt_tydesc)));\n \n         auto fields_tydesc = get_tydesc(r.bcx, fields_ty);\n-        r.bcx.build.Store(fields_tydesc, body_tydesc);\n+        bcx = fields_tydesc.bcx;\n+        bcx.build.Store(fields_tydesc.val, body_tydesc);\n \n         // Copy args into body fields.\n         auto body_fields =\n-            r.bcx.build.GEP(body,\n-                            vec(C_int(0),\n-                                C_int(abi.obj_body_elt_fields)));\n+            bcx.build.GEP(body,\n+                          vec(C_int(0),\n+                              C_int(abi.obj_body_elt_fields)));\n \n         let int i = 0;\n         for (ast.obj_field f in ob.fields) {\n-            auto arg = r.bcx.fcx.llargs.get(f.id);\n-            arg = load_scalar_or_boxed(r.bcx, arg, arg_tys.(i).ty);\n-            auto field = r.bcx.build.GEP(body_fields,\n+            auto arg = bcx.fcx.llargs.get(f.id);\n+            arg = load_scalar_or_boxed(bcx, arg, arg_tys.(i).ty);\n+            auto field = bcx.build.GEP(body_fields,\n                                          vec(C_int(0),C_int(i)));\n-            r = copy_ty(r.bcx, INIT, field, arg, arg_tys.(i).ty);\n+            bcx = copy_ty(bcx, INIT, field, arg, arg_tys.(i).ty).bcx;\n             i += 1;\n         }\n \n         // Store box ptr in outer pair.\n-        auto p = r.bcx.build.PointerCast(box, llbox_ty);\n-        r.bcx.build.Store(p, pair_box);\n+        auto p = bcx.build.PointerCast(box, llbox_ty);\n+        bcx.build.Store(p, pair_box);\n     }\n     bcx.build.Ret(bcx.build.Load(pair));\n }\n@@ -3983,13 +4037,9 @@ fn create_typedefs(@crate_ctxt cx) {\n     llvm.LLVMAddTypeName(cx.llmod, _str.buf(\"rust_tydesc\"), T_tydesc());\n }\n \n-fn crate_constant(@crate_ctxt cx) -> ValueRef {\n-\n-    let ValueRef crate_ptr =\n-        llvm.LLVMAddGlobal(cx.llmod, T_crate(),\n-                           _str.buf(\"rust_crate\"));\n+fn create_crate_constant(@crate_ctxt cx) {\n \n-    let ValueRef crate_addr = p2i(crate_ptr);\n+    let ValueRef crate_addr = p2i(cx.crate_ptr);\n \n     let ValueRef activate_glue_off =\n         llvm.LLVMConstSub(p2i(cx.glues.activate_glue), crate_addr);\n@@ -4002,7 +4052,7 @@ fn crate_constant(@crate_ctxt cx) -> ValueRef {\n \n     let ValueRef crate_val =\n         C_struct(vec(C_null(T_int()),     // ptrdiff_t image_base_off\n-                     p2i(crate_ptr),      // uintptr_t self_addr\n+                     p2i(cx.crate_ptr),   // uintptr_t self_addr\n                      C_null(T_int()),     // ptrdiff_t debug_abbrev_off\n                      C_null(T_int()),     // size_t debug_abbrev_sz\n                      C_null(T_int()),     // ptrdiff_t debug_info_off\n@@ -4017,8 +4067,7 @@ fn crate_constant(@crate_ctxt cx) -> ValueRef {\n                      C_null(T_int())      // int n_libs\n                      ));\n \n-    llvm.LLVMSetInitializer(crate_ptr, crate_val);\n-    ret crate_ptr;\n+    llvm.LLVMSetInitializer(cx.crate_ptr, crate_val);\n }\n \n fn trans_main_fn(@crate_ctxt cx, ValueRef llcrate) {\n@@ -4207,6 +4256,8 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n     llvm.LLVMSetDataLayout(llmod, _str.buf(x86.get_data_layout()));\n     llvm.LLVMSetTarget(llmod, _str.buf(x86.get_target_triple()));\n     auto td = mk_target_data(x86.get_data_layout());\n+    let ValueRef crate_ptr =\n+        llvm.LLVMAddGlobal(llmod, T_crate(), _str.buf(\"rust_crate\"));\n \n     llvm.LLVMSetModuleInlineAsm(llmod, _str.buf(x86.get_module_asm()));\n \n@@ -4221,6 +4272,7 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n     auto cx = @rec(sess = sess,\n                    llmod = llmod,\n                    td = td,\n+                   crate_ptr = crate_ptr,\n                    upcalls = new_str_hash[ValueRef](),\n                    intrinsics = intrinsics,\n                    item_names = new_str_hash[ValueRef](),\n@@ -4245,8 +4297,9 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n \n     trans_mod(cx, crate.node.module);\n     trans_exit_task_glue(cx);\n+    create_crate_constant(cx);\n     if (!shared) {\n-        trans_main_fn(cx, crate_constant(cx));\n+        trans_main_fn(cx, cx.crate_ptr);\n     }\n \n     check_module(llmod);"}]}