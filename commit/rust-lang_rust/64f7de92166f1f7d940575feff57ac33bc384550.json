{"sha": "64f7de92166f1f7d940575feff57ac33bc384550", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ZjdkZTkyMTY2ZjFmN2Q5NDA1NzVmZWZmNTdhYzMzYmMzODQ1NTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-12T19:39:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-12T19:39:04Z"}, "message": "Auto merge of #51339 - sdroege:exact-chunks-remainder, r=alexcrichton\n\nAdd ExactChunks::remainder and ExactChunks::into_remainder\n\nThese allow to get the leftover items of the slice that are not being\niterated as part of the iterator due to not filling a complete chunk.\n\nThe mutable version consumes the slice because otherwise we would either\na) have to borrow the iterator instead of taking the lifetime of\nthe underlying slice, which is not what *any* of the other iterator\nfunctions is doing, or\nb) would allow returning multiple mutable references to the same data\n\nThe current behaviour of consuming the iterator is consistent with\nIterMut::into_slice for the normal iterator.\n\n----\n\nThis is related to https://github.com/rust-lang/rust/issues/47115#issuecomment-392685177 and the following comments.\n\nWhile there the discussion was first about a way to get the \"tail\" of the iterator (everything from the slice that is still not iterated yet), this gives kind of unintuitive behaviour and is inconsistent with how the other slice iterators work.\n\nUnintuitive because the `next_back` would have no effect on the tail (or otherwise the tail could not include the remainder items), inconsistent because a) generally the idea of the slice iterators seems to be to only ever return items that were not iterated yet (and don't provide a way to access the same item twice) and b) we would return a \"flat\" `&[T]` slice but the iterator's shape is `&[[T]]` instead, c) the mutable variant would have to borrow from the iterator instead of the underlying slice (all other iterator functions borrow from the underlying slice!)\n\nAs such, I've only implemented functions to get the remainder. This also allows the implementation to be completely safe still (and around slices instead of raw pointers), while getting the tail would either be inefficient or would have to be implemented around raw pointers.\n\nCC @kerollmops", "tree": {"sha": "47d3bac0007dc1d99287165c751f9ce958862dbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47d3bac0007dc1d99287165c751f9ce958862dbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64f7de92166f1f7d940575feff57ac33bc384550", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64f7de92166f1f7d940575feff57ac33bc384550", "html_url": "https://github.com/rust-lang/rust/commit/64f7de92166f1f7d940575feff57ac33bc384550", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64f7de92166f1f7d940575feff57ac33bc384550/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cc42a4488d5dbc4c4109ed4a2f2ea81efa77f86", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cc42a4488d5dbc4c4109ed4a2f2ea81efa77f86", "html_url": "https://github.com/rust-lang/rust/commit/6cc42a4488d5dbc4c4109ed4a2f2ea81efa77f86"}, {"sha": "903624fb8d845afac62b1fca2d9114c04ef35fea", "url": "https://api.github.com/repos/rust-lang/rust/commits/903624fb8d845afac62b1fca2d9114c04ef35fea", "html_url": "https://github.com/rust-lang/rust/commit/903624fb8d845afac62b1fca2d9114c04ef35fea"}], "stats": {"total": 62, "additions": 54, "deletions": 8}, "files": [{"sha": "f6ef4a79dc786683380382b4d57bd5d087dda26e", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/64f7de92166f1f7d940575feff57ac33bc384550/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f7de92166f1f7d940575feff57ac33bc384550/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=64f7de92166f1f7d940575feff57ac33bc384550", "patch": "@@ -729,7 +729,8 @@ impl<T> [T] {\n     /// Returns an iterator over `chunk_size` elements of the slice at a\n     /// time. The chunks are slices and do not overlap. If `chunk_size` does\n     /// not divide the length of the slice, then the last up to `chunk_size-1`\n-    /// elements will be omitted.\n+    /// elements will be omitted and can be retrieved from the `remainder`\n+    /// function of the iterator.\n     ///\n     /// Due to each chunk having exactly `chunk_size` elements, the compiler\n     /// can often optimize the resulting code better than in the case of\n@@ -758,14 +759,15 @@ impl<T> [T] {\n         assert!(chunk_size != 0);\n         let rem = self.len() % chunk_size;\n         let len = self.len() - rem;\n-        ExactChunks { v: &self[..len], chunk_size: chunk_size}\n+        let (fst, snd) = self.split_at(len);\n+        ExactChunks { v: fst, rem: snd, chunk_size: chunk_size}\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n     /// The chunks are mutable slices, and do not overlap. If `chunk_size` does\n     /// not divide the length of the slice, then the last up to `chunk_size-1`\n-    /// elements will be omitted.\n-    ///\n+    /// elements will be omitted and can be retrieved from the `into_remainder`\n+    /// function of the iterator.\n     ///\n     /// Due to each chunk having exactly `chunk_size` elements, the compiler\n     /// can often optimize the resulting code better than in the case of\n@@ -799,7 +801,8 @@ impl<T> [T] {\n         assert!(chunk_size != 0);\n         let rem = self.len() % chunk_size;\n         let len = self.len() - rem;\n-        ExactChunksMut { v: &mut self[..len], chunk_size: chunk_size}\n+        let (fst, snd) = self.split_at_mut(len);\n+        ExactChunksMut { v: fst, rem: snd, chunk_size: chunk_size}\n     }\n \n     /// Divides one slice into two at an index.\n@@ -3657,25 +3660,39 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksMut<'a, T> {\n /// time).\n ///\n /// When the slice len is not evenly divided by the chunk size, the last\n-/// up to `chunk_size-1` elements will be omitted.\n+/// up to `chunk_size-1` elements will be omitted but can be retrieved from\n+/// the [`remainder`] function from the iterator.\n ///\n /// This struct is created by the [`exact_chunks`] method on [slices].\n ///\n /// [`exact_chunks`]: ../../std/primitive.slice.html#method.exact_chunks\n+/// [`remainder`]: ../../std/slice/struct.ExactChunks.html#method.remainder\n /// [slices]: ../../std/primitive.slice.html\n #[derive(Debug)]\n #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n pub struct ExactChunks<'a, T:'a> {\n     v: &'a [T],\n+    rem: &'a [T],\n     chunk_size: usize\n }\n \n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> ExactChunks<'a, T> {\n+    /// Return the remainder of the original slice that is not going to be\n+    /// returned by the iterator. The returned slice has at most `chunk_size-1`\n+    /// elements.\n+    pub fn remainder(&self) -> &'a [T] {\n+        self.rem\n+    }\n+}\n+\n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n impl<'a, T> Clone for ExactChunks<'a, T> {\n     fn clone(&self) -> ExactChunks<'a, T> {\n         ExactChunks {\n             v: self.v,\n+            rem: self.rem,\n             chunk_size: self.chunk_size,\n         }\n     }\n@@ -3763,20 +3780,35 @@ unsafe impl<'a, T> TrustedRandomAccess for ExactChunks<'a, T> {\n }\n \n /// An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n-/// elements at a time). When the slice len is not evenly divided by the chunk\n-/// size, the last up to `chunk_size-1` elements will be omitted.\n+/// elements at a time).\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last up to\n+/// `chunk_size-1` elements will be omitted but can be retrieved from the\n+/// [`into_remainder`] function from the iterator.\n ///\n /// This struct is created by the [`exact_chunks_mut`] method on [slices].\n ///\n /// [`exact_chunks_mut`]: ../../std/primitive.slice.html#method.exact_chunks_mut\n+/// [`into_remainder`]: ../../std/slice/struct.ExactChunksMut.html#method.into_remainder\n /// [slices]: ../../std/primitive.slice.html\n #[derive(Debug)]\n #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n pub struct ExactChunksMut<'a, T:'a> {\n     v: &'a mut [T],\n+    rem: &'a mut [T],\n     chunk_size: usize\n }\n \n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> ExactChunksMut<'a, T> {\n+    /// Return the remainder of the original slice that is not going to be\n+    /// returned by the iterator. The returned slice has at most `chunk_size-1`\n+    /// elements.\n+    pub fn into_remainder(self) -> &'a mut [T] {\n+        self.rem\n+    }\n+}\n+\n #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n impl<'a, T> Iterator for ExactChunksMut<'a, T> {\n     type Item = &'a mut [T];"}, {"sha": "2b37acdfe3e81386d4a4c3b5d6a7bb606df29e3d", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/64f7de92166f1f7d940575feff57ac33bc384550/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f7de92166f1f7d940575feff57ac33bc384550/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=64f7de92166f1f7d940575feff57ac33bc384550", "patch": "@@ -259,6 +259,13 @@ fn test_exact_chunks_last() {\n     assert_eq!(c2.last().unwrap(), &[2, 3]);\n }\n \n+#[test]\n+fn test_exact_chunks_remainder() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4];\n+    let c = v.exact_chunks(2);\n+    assert_eq!(c.remainder(), &[4]);\n+}\n+\n #[test]\n fn test_exact_chunks_zip() {\n     let v1: &[i32] = &[0, 1, 2, 3, 4];\n@@ -310,6 +317,13 @@ fn test_exact_chunks_mut_last() {\n     assert_eq!(c2.last().unwrap(), &[2, 3]);\n }\n \n+#[test]\n+fn test_exact_chunks_mut_remainder() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let c = v.exact_chunks_mut(2);\n+    assert_eq!(c.into_remainder(), &[4]);\n+}\n+\n #[test]\n fn test_exact_chunks_mut_zip() {\n     let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];"}]}