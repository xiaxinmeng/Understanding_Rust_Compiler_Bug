{"sha": "8672a235dd5b4677a6ff0ede1e3ce39b076b5414", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2NzJhMjM1ZGQ1YjQ2NzdhNmZmMGVkZTFlM2NlMzliMDc2YjU0MTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-19T21:46:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-19T21:46:37Z"}, "message": "auto merge of #15650 : jakub-/rust/patterns-statics, r=pcwalton\n\nThis is accomplished by rewriting static expressions into equivalent patterns.\r\nThis way, patterns referencing static variables can both participate\r\nin exhaustiveness analysis as well as be compiled down into the appropriate\r\nbranch of the decision trees that match expressions are codegened to.\r\n\r\nFixes #6533.\r\nFixes #13626.\r\nFixes #13731.\r\nFixes #14576.\r\nFixes #15393.", "tree": {"sha": "c9d805ee9e0d9863969a1d64e0ca89b162594758", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9d805ee9e0d9863969a1d64e0ca89b162594758"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8672a235dd5b4677a6ff0ede1e3ce39b076b5414", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8672a235dd5b4677a6ff0ede1e3ce39b076b5414", "html_url": "https://github.com/rust-lang/rust/commit/8672a235dd5b4677a6ff0ede1e3ce39b076b5414", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8672a235dd5b4677a6ff0ede1e3ce39b076b5414/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab610226aa150102771b5c18b3adc335fd9374dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab610226aa150102771b5c18b3adc335fd9374dc", "html_url": "https://github.com/rust-lang/rust/commit/ab610226aa150102771b5c18b3adc335fd9374dc"}, {"sha": "fba1194841fd8f31c3b93315b2cb53d1ce87fe98", "url": "https://api.github.com/repos/rust-lang/rust/commits/fba1194841fd8f31c3b93315b2cb53d1ce87fe98", "html_url": "https://github.com/rust-lang/rust/commit/fba1194841fd8f31c3b93315b2cb53d1ce87fe98"}], "stats": {"total": 651, "additions": 489, "deletions": 162}, "files": [{"sha": "2a7f7e8c54dd1f66bfb07e10df12e630a06b1bad", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8672a235dd5b4677a6ff0ede1e3ce39b076b5414/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8672a235dd5b4677a6ff0ede1e3ce39b076b5414/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=8672a235dd5b4677a6ff0ede1e3ce39b076b5414", "patch": "@@ -68,42 +68,42 @@ pub mod back {\n }\n \n pub mod middle {\n-    pub mod def;\n-    pub mod trans;\n-    pub mod ty;\n-    pub mod ty_fold;\n-    pub mod subst;\n-    pub mod resolve;\n-    pub mod resolve_lifetime;\n-    pub mod typeck;\n+    pub mod astencode;\n+    pub mod borrowck;\n+    pub mod cfg;\n+    pub mod check_const;\n     pub mod check_loop;\n     pub mod check_match;\n-    pub mod check_const;\n     pub mod check_static;\n-    pub mod borrowck;\n+    pub mod const_eval;\n     pub mod dataflow;\n-    pub mod mem_categorization;\n-    pub mod liveness;\n-    pub mod kind;\n+    pub mod dead;\n+    pub mod def;\n+    pub mod dependency_format;\n+    pub mod effect;\n+    pub mod entry;\n+    pub mod expr_use_visitor;\n     pub mod freevars;\n-    pub mod pat_util;\n-    pub mod region;\n-    pub mod const_eval;\n-    pub mod astencode;\n+    pub mod graph;\n+    pub mod intrinsicck;\n+    pub mod kind;\n     pub mod lang_items;\n+    pub mod liveness;\n+    pub mod mem_categorization;\n+    pub mod pat_util;\n     pub mod privacy;\n-    pub mod entry;\n-    pub mod effect;\n     pub mod reachable;\n-    pub mod graph;\n-    pub mod cfg;\n-    pub mod dead;\n-    pub mod expr_use_visitor;\n-    pub mod dependency_format;\n-    pub mod weak_lang_items;\n+    pub mod region;\n+    pub mod resolve;\n+    pub mod resolve_lifetime;\n     pub mod save;\n-    pub mod intrinsicck;\n     pub mod stability;\n+    pub mod subst;\n+    pub mod trans;\n+    pub mod ty;\n+    pub mod ty_fold;\n+    pub mod typeck;\n+    pub mod weak_lang_items;\n }\n \n pub mod front {"}, {"sha": "67208e33372867a67b1680dabdb315031ccc57b3", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 78, "deletions": 82, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/8672a235dd5b4677a6ff0ede1e3ce39b076b5414/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8672a235dd5b4677a6ff0ede1e3ce39b076b5414/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=8672a235dd5b4677a6ff0ede1e3ce39b076b5414", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use middle::const_eval::{compare_const_vals, const_bool, const_float, const_nil, const_val};\n-use middle::const_eval::{eval_const_expr, lookup_const_by_id};\n+use middle::const_eval::{const_expr_to_pat, eval_const_expr, lookup_const_by_id};\n use middle::def::*;\n use middle::pat_util::*;\n use middle::ty::*;\n@@ -21,8 +21,9 @@ use std::iter::range_inclusive;\n use syntax::ast::*;\n use syntax::ast_util::{is_unguarded, walk_pat};\n use syntax::codemap::{Span, Spanned, DUMMY_SP};\n-use syntax::owned_slice::OwnedSlice;\n+use syntax::fold::{Folder, noop_fold_pat};\n use syntax::print::pprust::pat_to_string;\n+use syntax::parse::token;\n use syntax::visit;\n use syntax::visit::{Visitor, FnKind};\n use util::ppaux::ty_to_string;\n@@ -76,6 +77,12 @@ impl fmt::Show for Matrix {\n     }\n }\n \n+impl FromIterator<Vec<Gc<Pat>>> for Matrix {\n+    fn from_iter<T: Iterator<Vec<Gc<Pat>>>>(mut iterator: T) -> Matrix {\n+        Matrix(iterator.collect())\n+    }\n+}\n+\n pub struct MatchCheckCtxt<'a> {\n     pub tcx: &'a ty::ctxt\n }\n@@ -120,10 +127,8 @@ impl<'a> Visitor<()> for MatchCheckCtxt<'a> {\n }\n \n pub fn check_crate(tcx: &ty::ctxt, krate: &Crate) {\n-    let mut cx = MatchCheckCtxt { tcx: tcx, };\n-\n+    let mut cx = MatchCheckCtxt { tcx: tcx };\n     visit::walk_crate(&mut cx, krate, ());\n-\n     tcx.sess.abort_if_errors();\n }\n \n@@ -155,48 +160,49 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n                 // If the type *is* empty, it's vacuously exhaustive\n                 return;\n             }\n-            let m: Matrix = Matrix(arms\n+\n+            let mut static_inliner = StaticInliner { tcx: cx.tcx };\n+            let matrix: Matrix = arms\n                 .iter()\n                 .filter(|&arm| is_unguarded(arm))\n                 .flat_map(|arm| arm.pats.iter())\n-                .map(|pat| vec!(pat.clone()))\n-                .collect());\n-            check_exhaustive(cx, ex.span, &m);\n+                .map(|pat| vec![static_inliner.fold_pat(*pat)])\n+                .collect();\n+            check_exhaustive(cx, ex.span, &matrix);\n         },\n         _ => ()\n     }\n }\n \n+fn is_expr_const_nan(tcx: &ty::ctxt, expr: &Expr) -> bool {\n+    match eval_const_expr(tcx, expr) {\n+        const_float(f) => f.is_nan(),\n+        _ => false\n+    }\n+}\n+\n // Check for unreachable patterns\n fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n     let mut seen = Matrix(vec!());\n+    let mut static_inliner = StaticInliner { tcx: cx.tcx };\n     for arm in arms.iter() {\n         for pat in arm.pats.iter() {\n+            let inlined = static_inliner.fold_pat(*pat);\n+\n             // Check that we do not match against a static NaN (#6804)\n-            let pat_matches_nan: |&Pat| -> bool = |p| {\n-                let opt_def = cx.tcx.def_map.borrow().find_copy(&p.id);\n-                match opt_def {\n-                    Some(DefStatic(did, false)) => {\n-                        let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-                        match eval_const_expr(cx.tcx, &*const_expr) {\n-                            const_float(f) if f.is_nan() => true,\n-                            _ => false\n-                        }\n+            walk_pat(&*inlined, |p| {\n+                match p.node {\n+                    PatLit(expr) if is_expr_const_nan(cx.tcx, &*expr) => {\n+                        span_warn!(cx.tcx.sess, pat.span, E0003,\n+                            \"unmatchable NaN in pattern, \\\n+                             use the is_nan method in a guard instead\");\n                     }\n-                    _ => false\n-                }\n-            };\n-\n-            walk_pat(&**pat, |p| {\n-                if pat_matches_nan(p) {\n-                    span_warn!(cx.tcx.sess, p.span, E0003,\n-                        \"unmatchable NaN in pattern, use the is_nan method in a guard instead\"\n-                    );\n+                    _ => ()\n                 }\n                 true\n             });\n \n-            let v = vec!(*pat);\n+            let v = vec![inlined];\n             match is_useful(cx, &seen, v.as_slice(), LeaveOutWitness) {\n                 NotUseful => span_err!(cx.tcx.sess, pat.span, E0001, \"unreachable pattern\"),\n                 Useful => (),\n@@ -218,8 +224,8 @@ fn raw_pat(p: Gc<Pat>) -> Gc<Pat> {\n     }\n }\n \n-fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, m: &Matrix) {\n-    match is_useful(cx, m, [wild()], ConstructWitness) {\n+fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n+    match is_useful(cx, matrix, [wild()], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             let witness = match pats.as_slice() {\n                 [witness] => witness,\n@@ -251,16 +257,26 @@ fn const_val_to_expr(value: &const_val) -> Gc<Expr> {\n     }\n }\n \n-fn def_to_path(tcx: &ty::ctxt, id: DefId) -> Path {\n-    ty::with_path(tcx, id, |mut path| Path {\n-        global: false,\n-        segments: path.last().map(|elem| PathSegment {\n-            identifier: Ident::new(elem.name()),\n-            lifetimes: vec!(),\n-            types: OwnedSlice::empty()\n-        }).move_iter().collect(),\n-        span: DUMMY_SP,\n-    })\n+pub struct StaticInliner<'a> {\n+    pub tcx: &'a ty::ctxt\n+}\n+\n+impl<'a> Folder for StaticInliner<'a> {\n+    fn fold_pat(&mut self, pat: Gc<Pat>) -> Gc<Pat> {\n+        match pat.node {\n+            PatIdent(..) | PatEnum(..) => {\n+                let def = self.tcx.def_map.borrow().find_copy(&pat.id);\n+                match def {\n+                    Some(DefStatic(did, _)) => {\n+                        let const_expr = lookup_const_by_id(self.tcx, did).unwrap();\n+                        const_expr_to_pat(self.tcx, const_expr)\n+                    },\n+                    _ => noop_fold_pat(pat, self)\n+                }\n+            }\n+            _ => noop_fold_pat(pat, self)\n+        }\n+    }\n }\n \n /// Constructs a partial witness for a pattern given a list of\n@@ -283,9 +299,11 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n \n         ty::ty_enum(cid, _) | ty::ty_struct(cid, _)  => {\n             let (vid, is_structure) = match ctor {\n-                &Variant(vid) => (vid,\n-                    ty::enum_variant_with_id(cx.tcx, cid, vid).arg_names.is_some()),\n-                _ => (cid, true)\n+                &Variant(vid) =>\n+                    (vid, ty::enum_variant_with_id(cx.tcx, cid, vid).arg_names.is_some()),\n+                _ =>\n+                    (cid, ty::lookup_struct_fields(cx.tcx, cid).iter()\n+                        .any(|field| field.name != token::special_idents::unnamed_field.name))\n             };\n             if is_structure {\n                 let fields = ty::lookup_struct_fields(cx.tcx, vid);\n@@ -459,8 +477,7 @@ fn is_useful(cx: &MatchCheckCtxt, matrix @ &Matrix(ref rows): &Matrix,\n             },\n \n             Some(constructor) => {\n-                let matrix = Matrix(rows.iter().filter_map(|r|\n-                    default(cx, r.as_slice())).collect());\n+                let matrix = rows.iter().filter_map(|r| default(cx, r.as_slice())).collect();\n                 match is_useful(cx, &matrix, v.tail(), witness) {\n                     UsefulWithWitness(pats) => {\n                         let arity = constructor_arity(cx, &constructor, left_ty);\n@@ -506,25 +523,23 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: Gc<Pat>,\n     match pat.node {\n         PatIdent(..) =>\n             match cx.tcx.def_map.borrow().find(&pat.id) {\n-                Some(&DefStatic(did, false)) => {\n-                    let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-                    vec!(ConstantValue(eval_const_expr(cx.tcx, &*const_expr)))\n-                },\n+                Some(&DefStatic(..)) =>\n+                    cx.tcx.sess.span_bug(pat.span, \"static pattern should've been rewritten\"),\n                 Some(&DefStruct(_)) => vec!(Single),\n                 Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!()\n             },\n         PatEnum(..) =>\n             match cx.tcx.def_map.borrow().find(&pat.id) {\n-                Some(&DefStatic(did, false)) => {\n-                    let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-                    vec!(ConstantValue(eval_const_expr(cx.tcx, &*const_expr)))\n-                },\n+                Some(&DefStatic(..)) =>\n+                    cx.tcx.sess.span_bug(pat.span, \"static pattern should've been rewritten\"),\n                 Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n         PatStruct(..) =>\n             match cx.tcx.def_map.borrow().find(&pat.id) {\n+                Some(&DefStatic(..)) =>\n+                    cx.tcx.sess.span_bug(pat.span, \"static pattern should've been rewritten\"),\n                 Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n@@ -583,7 +598,7 @@ pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: ty::t) ->\n }\n \n fn range_covered_by_constructor(ctor: &Constructor,\n-                                from: &const_val,to: &const_val) -> Option<bool> {\n+                                from: &const_val, to: &const_val) -> Option<bool> {\n     let (c_from, c_to) = match *ctor {\n         ConstantValue(ref value)        => (value, value),\n         ConstantRange(ref from, ref to) => (from, to),\n@@ -621,44 +636,22 @@ pub fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n         &PatIdent(_, _, _) => {\n             let opt_def = cx.tcx.def_map.borrow().find_copy(&pat_id);\n             match opt_def {\n+                Some(DefStatic(..)) =>\n+                    cx.tcx.sess.span_bug(pat_span, \"static pattern should've been rewritten\"),\n                 Some(DefVariant(_, id, _)) => if *constructor == Variant(id) {\n                     Some(vec!())\n                 } else {\n                     None\n                 },\n-                Some(DefStatic(did, _)) => {\n-                    let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-                    let e_v = eval_const_expr(cx.tcx, &*const_expr);\n-                    match range_covered_by_constructor(constructor, &e_v, &e_v) {\n-                        Some(true) => Some(vec!()),\n-                        Some(false) => None,\n-                        None => {\n-                            cx.tcx.sess.span_err(pat_span, \"mismatched types between arms\");\n-                            None\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    Some(Vec::from_elem(arity, wild()))\n-                }\n+                _ => Some(Vec::from_elem(arity, wild()))\n             }\n         }\n \n         &PatEnum(_, ref args) => {\n             let def = cx.tcx.def_map.borrow().get_copy(&pat_id);\n             match def {\n-                DefStatic(did, _) => {\n-                    let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-                    let e_v = eval_const_expr(cx.tcx, &*const_expr);\n-                    match range_covered_by_constructor(constructor, &e_v, &e_v) {\n-                        Some(true) => Some(vec!()),\n-                        Some(false) => None,\n-                        None => {\n-                            cx.tcx.sess.span_err(pat_span, \"mismatched types between arms\");\n-                            None\n-                        }\n-                    }\n-                }\n+                DefStatic(..) =>\n+                    cx.tcx.sess.span_bug(pat_span, \"static pattern should've been rewritten\"),\n                 DefVariant(_, id, _) if *constructor != Variant(id) => None,\n                 DefVariant(..) | DefFn(..) | DefStruct(..) => {\n                     Some(match args {\n@@ -674,6 +667,8 @@ pub fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n             // Is this a struct or an enum variant?\n             let def = cx.tcx.def_map.borrow().get_copy(&pat_id);\n             let class_id = match def {\n+                DefStatic(..) =>\n+                    cx.tcx.sess.span_bug(pat_span, \"static pattern should've been rewritten\"),\n                 DefVariant(_, variant_id, _) => if *constructor == Variant(variant_id) {\n                     Some(variant_id)\n                 } else {\n@@ -782,7 +777,8 @@ fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {\n         LocalFor => \"`for` loop\"\n     };\n \n-    match is_refutable(cx, loc.pat) {\n+    let mut static_inliner = StaticInliner { tcx: cx.tcx };\n+    match is_refutable(cx, static_inliner.fold_pat(loc.pat)) {\n         Some(pat) => {\n             span_err!(cx.tcx.sess, loc.pat.span, E0005,\n                 \"refutable pattern in {} binding: `{}` not covered\","}, {"sha": "4d256549a64650cd44e6a1f87a888541a02ebc2f", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8672a235dd5b4677a6ff0ede1e3ce39b076b5414/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8672a235dd5b4677a6ff0ede1e3ce39b076b5414/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=8672a235dd5b4677a6ff0ede1e3ce39b076b5414", "patch": "@@ -13,8 +13,8 @@\n \n use metadata::csearch;\n use middle::astencode;\n-\n use middle::def;\n+use middle::pat_util::def_to_path;\n use middle::ty;\n use middle::typeck::astconv;\n use util::nodemap::{DefIdMap};\n@@ -26,7 +26,7 @@ use syntax::visit;\n use syntax::{ast, ast_map, ast_util};\n \n use std::rc::Rc;\n-use std::gc::Gc;\n+use std::gc::{Gc, GC};\n \n //\n // This pass classifies expressions by their constant-ness.\n@@ -303,6 +303,57 @@ pub enum const_val {\n     const_nil\n }\n \n+pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: Gc<Expr>) -> Gc<Pat> {\n+    let pat = match expr.node {\n+        ExprTup(ref exprs) =>\n+            PatTup(exprs.iter().map(|&expr| const_expr_to_pat(tcx, expr)).collect()),\n+\n+        ExprCall(callee, ref args) => {\n+            let def = tcx.def_map.borrow().get_copy(&callee.id);\n+            tcx.def_map.borrow_mut().find_or_insert(expr.id, def);\n+            let path = match def {\n+                def::DefStruct(def_id) => def_to_path(tcx, def_id),\n+                def::DefVariant(_, variant_did, _) => def_to_path(tcx, variant_did),\n+                _ => unreachable!()\n+            };\n+            let pats = args.iter().map(|&expr| const_expr_to_pat(tcx, expr)).collect();\n+            PatEnum(path, Some(pats))\n+        }\n+\n+        ExprStruct(ref path, ref fields, None) => {\n+            let field_pats = fields.iter().map(|field| FieldPat {\n+                ident: field.ident.node,\n+                pat: const_expr_to_pat(tcx, field.expr)\n+            }).collect();\n+            PatStruct(path.clone(), field_pats, false)\n+        }\n+\n+        ExprVec(ref exprs) => {\n+            let pats = exprs.iter().map(|&expr| const_expr_to_pat(tcx, expr)).collect();\n+            PatVec(pats, None, vec![])\n+        }\n+\n+        ExprPath(ref path) => {\n+            let opt_def = tcx.def_map.borrow().find_copy(&expr.id);\n+            match opt_def {\n+                Some(def::DefStruct(..)) =>\n+                    PatStruct(path.clone(), vec![], false),\n+                Some(def::DefVariant(..)) =>\n+                    PatEnum(path.clone(), None),\n+                _ => {\n+                    match lookup_const(tcx, &*expr) {\n+                        Some(actual) => return const_expr_to_pat(tcx, actual),\n+                        _ => unreachable!()\n+                    }\n+                }\n+            }\n+        }\n+\n+        _ => PatLit(expr)\n+    };\n+    box (GC) Pat { id: expr.id, node: pat, span: expr.span }\n+}\n+\n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n     match eval_const_expr_partial(tcx, e) {\n         Ok(r) => r,"}, {"sha": "faaffc7525786da0d0283ae6261a55b5829fe348", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8672a235dd5b4677a6ff0ede1e3ce39b076b5414/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8672a235dd5b4677a6ff0ede1e3ce39b076b5414/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=8672a235dd5b4677a6ff0ede1e3ce39b076b5414", "patch": "@@ -10,12 +10,14 @@\n \n use middle::def::*;\n use middle::resolve;\n+use middle::ty;\n \n use std::collections::HashMap;\n use std::gc::{Gc, GC};\n use syntax::ast::*;\n use syntax::ast_util::{walk_pat};\n use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::owned_slice::OwnedSlice;\n \n pub type PatIdMap = HashMap<Ident, NodeId>;\n \n@@ -116,3 +118,15 @@ pub fn simple_identifier<'a>(pat: &'a Pat) -> Option<&'a Ident> {\n pub fn wild() -> Gc<Pat> {\n     box (GC) Pat { id: 0, node: PatWild, span: DUMMY_SP }\n }\n+\n+pub fn def_to_path(tcx: &ty::ctxt, id: DefId) -> Path {\n+    ty::with_path(tcx, id, |mut path| Path {\n+        global: false,\n+        segments: path.last().map(|elem| PathSegment {\n+            identifier: Ident::new(elem.name()),\n+            lifetimes: vec!(),\n+            types: OwnedSlice::empty()\n+        }).move_iter().collect(),\n+        span: DUMMY_SP,\n+    })\n+}"}, {"sha": "a0adbf6e920ea935ab6a9a45655b72c6f4e23491", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8672a235dd5b4677a6ff0ede1e3ce39b076b5414/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8672a235dd5b4677a6ff0ede1e3ce39b076b5414/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=8672a235dd5b4677a6ff0ede1e3ce39b076b5414", "patch": "@@ -4397,7 +4397,7 @@ impl<'a> Resolver<'a> {\n                     let ident = path1.node;\n                     let renamed = mtwt::resolve(ident);\n \n-                    match self.resolve_bare_identifier_pattern(ident) {\n+                    match self.resolve_bare_identifier_pattern(ident, pattern.span) {\n                         FoundStructOrEnumVariant(def, lp)\n                                 if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n@@ -4561,7 +4561,7 @@ impl<'a> Resolver<'a> {\n         });\n     }\n \n-    fn resolve_bare_identifier_pattern(&mut self, name: Ident)\n+    fn resolve_bare_identifier_pattern(&mut self, name: Ident, span: Span)\n                                        -> BareIdentifierPatternResolution {\n         let module = self.current_module.clone();\n         match self.resolve_item_in_lexical_scope(module,\n@@ -4588,6 +4588,11 @@ impl<'a> Resolver<'a> {\n                             def @ DefStatic(_, false) => {\n                                 return FoundConst(def, LastMod(AllPublic));\n                             }\n+                            DefStatic(_, true) => {\n+                                self.resolve_error(span,\n+                                    \"mutable static variables cannot be referenced in a pattern\");\n+                                return BareIdentifierPatternUnresolved;\n+                            }\n                             _ => {\n                                 return BareIdentifierPatternUnresolved;\n                             }"}, {"sha": "aeb171c068a85016a01d2ecc5f799f4a24f6aa9b", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 18, "deletions": 48, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8672a235dd5b4677a6ff0ede1e3ce39b076b5414/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8672a235dd5b4677a6ff0ede1e3ce39b076b5414/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=8672a235dd5b4677a6ff0ede1e3ce39b076b5414", "patch": "@@ -195,6 +195,7 @@ use llvm::{ValueRef, BasicBlockRef};\n use middle::const_eval;\n use middle::def;\n use middle::check_match;\n+use middle::check_match::StaticInliner;\n use middle::lang_items::StrEqFnLangItem;\n use middle::pat_util::*;\n use middle::resolve::DefMap;\n@@ -225,14 +226,9 @@ use std::gc::{Gc};\n use syntax::ast;\n use syntax::ast::Ident;\n use syntax::codemap::Span;\n+use syntax::fold::Folder;\n use syntax::parse::token::InternedString;\n \n-// An option identifying a literal: either an expression or a DefId of a static expression.\n-enum Lit {\n-    ExprLit(Gc<ast::Expr>),\n-    ConstLit(ast::DefId),              // the def ID of the constant\n-}\n-\n #[deriving(PartialEq)]\n pub enum VecLenOpt {\n     vec_len_eq,\n@@ -242,24 +238,15 @@ pub enum VecLenOpt {\n // An option identifying a branch (either a literal, an enum variant or a\n // range)\n enum Opt {\n-    lit(Lit),\n+    lit(Gc<ast::Expr>),\n     var(ty::Disr, Rc<adt::Repr>, ast::DefId),\n     range(Gc<ast::Expr>, Gc<ast::Expr>),\n     vec_len(/* length */ uint, VecLenOpt, /*range of matches*/(uint, uint))\n }\n \n-fn lit_to_expr(tcx: &ty::ctxt, a: &Lit) -> Gc<ast::Expr> {\n-    match *a {\n-        ExprLit(existing_a_expr) => existing_a_expr,\n-        ConstLit(a_const) => const_eval::lookup_const_by_id(tcx, a_const).unwrap()\n-    }\n-}\n-\n fn opt_eq(tcx: &ty::ctxt, a: &Opt, b: &Opt) -> bool {\n     match (a, b) {\n-        (&lit(a), &lit(b)) => {\n-            let a_expr = lit_to_expr(tcx, &a);\n-            let b_expr = lit_to_expr(tcx, &b);\n+        (&lit(a_expr), &lit(b_expr)) => {\n             match const_eval::compare_lit_exprs(tcx, &*a_expr, &*b_expr) {\n                 Some(val1) => val1 == 0,\n                 None => fail!(\"compare_list_exprs: type mismatch\"),\n@@ -286,20 +273,13 @@ pub enum opt_result<'a> {\n     range_result(Result<'a>, Result<'a>),\n }\n \n-fn trans_opt<'a>(bcx: &'a Block<'a>, o: &Opt) -> opt_result<'a> {\n+fn trans_opt<'a>(mut bcx: &'a Block<'a>, o: &Opt) -> opt_result<'a> {\n     let _icx = push_ctxt(\"match::trans_opt\");\n     let ccx = bcx.ccx();\n-    let mut bcx = bcx;\n     match *o {\n-        lit(ExprLit(ref lit_expr)) => {\n-            let lit_datum = unpack_datum!(bcx, expr::trans(bcx, &**lit_expr));\n-            let lit_datum = lit_datum.assert_rvalue(bcx); // literals are rvalues\n-            let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n-            return single_result(Result::new(bcx, lit_datum.val));\n-        }\n-        lit(l @ ConstLit(ref def_id)) => {\n-            let lit_ty = ty::node_id_to_type(bcx.tcx(), lit_to_expr(bcx.tcx(), &l).id);\n-            let (llval, _) = consts::get_const_val(bcx.ccx(), *def_id);\n+        lit(lit_expr) => {\n+            let lit_ty = ty::node_id_to_type(bcx.tcx(), lit_expr.id);\n+            let (llval, _) = consts::const_expr(ccx, &*lit_expr, true);\n             let lit_datum = immediate_rvalue(llval, lit_ty);\n             let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n             return single_result(Result::new(bcx, lit_datum.val));\n@@ -546,13 +526,12 @@ fn enter_opt<'a, 'b>(\n     let _indenter = indenter();\n \n     let ctor = match opt {\n-        &lit(x) => {\n-            check_match::ConstantValue(const_eval::eval_const_expr(\n-                bcx.tcx(), &*lit_to_expr(bcx.tcx(), &x)))\n-        }\n-        &range(ref lo, ref hi) => check_match::ConstantRange(\n-            const_eval::eval_const_expr(bcx.tcx(), &**lo),\n-            const_eval::eval_const_expr(bcx.tcx(), &**hi)\n+        &lit(expr) => check_match::ConstantValue(\n+            const_eval::eval_const_expr(bcx.tcx(), &*expr)\n+        ),\n+        &range(lo, hi) => check_match::ConstantRange(\n+            const_eval::eval_const_expr(bcx.tcx(), &*lo),\n+            const_eval::eval_const_expr(bcx.tcx(), &*hi)\n         ),\n         &vec_len(len, _, _) => check_match::Slice(len),\n         &var(_, _, def_id) => check_match::Variant(def_id)\n@@ -649,7 +628,7 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n         let cur = *br.pats.get(col);\n         match cur.node {\n             ast::PatLit(l) => {\n-                add_to_set(ccx.tcx(), &mut found, lit(ExprLit(l)));\n+                add_to_set(ccx.tcx(), &mut found, lit(l));\n             }\n             ast::PatIdent(..) => {\n                 // This is either an enum variant or a variable binding.\n@@ -659,10 +638,6 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n                         add_to_set(ccx.tcx(), &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n-                    Some(def::DefStatic(const_did, false)) => {\n-                        add_to_set(ccx.tcx(), &mut found,\n-                                   lit(ConstLit(const_did)));\n-                    }\n                     _ => {}\n                 }\n             }\n@@ -676,10 +651,6 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n                         add_to_set(ccx.tcx(), &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n-                    Some(def::DefStatic(const_did, false)) => {\n-                        add_to_set(ccx.tcx(), &mut found,\n-                                   lit(ConstLit(const_did)));\n-                    }\n                     _ => {}\n                 }\n             }\n@@ -1447,10 +1418,11 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n         bindings_map: create_bindings_map(bcx, *arm.pats.get(0))\n     }).collect();\n \n+    let mut static_inliner = StaticInliner { tcx: scope_cx.tcx() };\n     let mut matches = Vec::new();\n     for arm_data in arm_datas.iter() {\n-        matches.extend(arm_data.arm.pats.iter().map(|p| Match {\n-            pats: vec!(*p),\n+        matches.extend(arm_data.arm.pats.iter().map(|&p| Match {\n+            pats: vec![static_inliner.fold_pat(p)],\n             data: arm_data,\n             bound_ptrs: Vec::new(),\n         }));\n@@ -1754,8 +1726,6 @@ fn bind_irrefutable_pat<'a>(\n                         }\n                     }\n                 }\n-                Some(def::DefStatic(_, false)) => {\n-                }\n                 _ => {\n                     // Nothing to do here.\n                 }"}, {"sha": "69cb626b75a466d586c54e1d535e77d8318222a5", "filename": "src/test/compile-fail/match-arm-statics.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/8672a235dd5b4677a6ff0ede1e3ce39b076b5414/src%2Ftest%2Fcompile-fail%2Fmatch-arm-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8672a235dd5b4677a6ff0ede1e3ce39b076b5414/src%2Ftest%2Fcompile-fail%2Fmatch-arm-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-arm-statics.rs?ref=8672a235dd5b4677a6ff0ede1e3ce39b076b5414", "patch": "@@ -0,0 +1,108 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct NewBool(bool);\n+\n+enum Direction {\n+    North,\n+    East,\n+    South,\n+    West\n+}\n+\n+static TRUE_TRUE: (bool, bool) = (true, true);\n+\n+fn nonexhaustive_1() {\n+    match (true, false) {\n+    //~^ ERROR non-exhaustive patterns: `(true, false)` not covered\n+        TRUE_TRUE => (),\n+        (false, false) => (),\n+        (false, true) => ()\n+    }\n+}\n+\n+fn unreachable_1() {\n+    match (true, false) {\n+        TRUE_TRUE => (),\n+        (false, false) => (),\n+        (false, true) => (),\n+        (true, false) => (),\n+        (true, true) => ()\n+        //~^ ERROR unreachable pattern\n+    }\n+}\n+\n+static NONE: Option<Direction> = None;\n+static EAST: Direction = East;\n+\n+fn nonexhaustive_2() {\n+    match Some(Some(North)) {\n+    //~^ ERROR non-exhaustive patterns: `Some(Some(West))` not covered\n+        Some(NONE) => (),\n+        Some(Some(North)) => (),\n+        Some(Some(EAST)) => (),\n+        Some(Some(South)) => (),\n+        None => ()\n+    }\n+}\n+\n+fn unreachable_2() {\n+    match Some(Some(North)) {\n+        Some(NONE) => (),\n+        Some(Some(North)) => (),\n+        Some(Some(EAST)) => (),\n+        Some(Some(South)) => (),\n+        Some(Some(West)) => (),\n+        Some(Some(East)) => (),\n+        //~^ ERROR unreachable pattern\n+        None => ()\n+    }\n+}\n+\n+static NEW_FALSE: NewBool = NewBool(false);\n+struct Foo {\n+    bar: Option<Direction>,\n+    baz: NewBool\n+}\n+\n+static STATIC_FOO: Foo = Foo { bar: None, baz: NEW_FALSE };\n+\n+fn nonexhaustive_3() {\n+    match (Foo { bar: Some(North), baz: NewBool(true) }) {\n+    //~^ ERROR non-exhaustive patterns: `Foo { bar: Some(North), baz: NewBool(true) }`\n+        Foo { bar: None, baz: NewBool(true) } => (),\n+        Foo { bar: _, baz: NEW_FALSE } => (),\n+        Foo { bar: Some(West), baz: NewBool(true) } => (),\n+        Foo { bar: Some(South), .. } => (),\n+        Foo { bar: Some(EAST), .. } => ()\n+    }\n+}\n+\n+fn unreachable_3() {\n+    match (Foo { bar: Some(EAST), baz: NewBool(true) }) {\n+        Foo { bar: None, baz: NewBool(true) } => (),\n+        Foo { bar: _, baz: NEW_FALSE } => (),\n+        Foo { bar: Some(West), baz: NewBool(true) } => (),\n+        Foo { bar: Some(South), .. } => (),\n+        Foo { bar: Some(EAST), .. } => (),\n+        Foo { bar: Some(North), baz: NewBool(true) } => (),\n+        Foo { bar: Some(EAST), baz: NewBool(false) } => ()\n+        //~^ ERROR unreachable pattern\n+    }\n+}\n+\n+fn main() {\n+    nonexhaustive_1();\n+    nonexhaustive_2();\n+    nonexhaustive_3();\n+    unreachable_1();\n+    unreachable_2();\n+    unreachable_3();\n+}"}, {"sha": "b3e93daccab8df2288d703eb41692c208b1f6b38", "filename": "src/test/compile-fail/static-mut-not-pat.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8672a235dd5b4677a6ff0ede1e3ce39b076b5414/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8672a235dd5b4677a6ff0ede1e3ce39b076b5414/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-pat.rs?ref=8672a235dd5b4677a6ff0ede1e3ce39b076b5414", "patch": "@@ -20,7 +20,34 @@ fn main() {\n     // instead of spitting out a custom error about some identifier collisions\n     // (we should allow shadowing)\n     match 4i {\n-        a => {}\n-        _ => {} //~ ERROR: unreachable pattern\n+        a => {} //~ ERROR mutable static variables cannot be referenced in a pattern\n+        _ => {}\n+    }\n+}\n+\n+struct NewBool(bool);\n+enum Direction {\n+    North,\n+    East,\n+    South,\n+    West\n+}\n+static NEW_FALSE: NewBool = NewBool(false);\n+struct Foo {\n+    bar: Option<Direction>,\n+    baz: NewBool\n+}\n+\n+static mut STATIC_MUT_FOO: Foo = Foo { bar: Some(West), baz: NEW_FALSE };\n+\n+fn mutable_statics() {\n+    match (Foo { bar: Some(North), baz: NewBool(true) }) {\n+        Foo { bar: None, baz: NewBool(true) } => (),\n+        STATIC_MUT_FOO => (),\n+        //~^ ERROR mutable static variables cannot be referenced in a pattern\n+        Foo { bar: Some(South), .. } => (),\n+        Foo { bar: Some(EAST), .. } => (),\n+        Foo { bar: Some(North), baz: NewBool(true) } => (),\n+        Foo { bar: Some(EAST), baz: NewBool(false) } => ()\n     }\n }"}, {"sha": "a8f6d9c39174489ce3e7fb9f7863bdc52e24d901", "filename": "src/test/run-pass/match-arm-statics.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/8672a235dd5b4677a6ff0ede1e3ce39b076b5414/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8672a235dd5b4677a6ff0ede1e3ce39b076b5414/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs?ref=8672a235dd5b4677a6ff0ede1e3ce39b076b5414", "patch": "@@ -0,0 +1,156 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(struct_variant)]\n+\n+struct NewBool(bool);\n+\n+enum Direction {\n+    North,\n+    East,\n+    South,\n+    West\n+}\n+struct Foo {\n+    bar: Option<Direction>,\n+    baz: NewBool\n+}\n+enum EnumWithStructVariants {\n+    Variant1(bool),\n+    Variant2 {\n+        dir: Direction\n+    }\n+}\n+\n+static TRUE_TRUE: (bool, bool) = (true, true);\n+static NONE: Option<Direction> = None;\n+static EAST: Direction = East;\n+static NEW_FALSE: NewBool = NewBool(false);\n+static STATIC_FOO: Foo = Foo { bar: Some(South), baz: NEW_FALSE };\n+static VARIANT2_NORTH: EnumWithStructVariants = Variant2 { dir: North };\n+\n+pub mod glfw {\n+    pub struct InputState(uint);\n+\n+    pub static RELEASE  : InputState = InputState(0);\n+    pub static PRESS    : InputState = InputState(1);\n+    pub static REPEAT   : InputState = InputState(2);\n+}\n+\n+fn issue_6533() {\n+    use glfw;\n+\n+    fn action_to_str(state: glfw::InputState) -> &'static str {\n+        use glfw::{RELEASE, PRESS, REPEAT};\n+        match state {\n+            RELEASE => { \"Released\" }\n+            PRESS   => { \"Pressed\"  }\n+            REPEAT  => { \"Repeated\" }\n+            _       => { \"Unknown\"  }\n+        }\n+    }\n+\n+    assert_eq!(action_to_str(glfw::RELEASE), \"Released\");\n+    assert_eq!(action_to_str(glfw::PRESS), \"Pressed\");\n+    assert_eq!(action_to_str(glfw::REPEAT), \"Repeated\");\n+}\n+\n+fn issue_13626() {\n+    static VAL: [u8, ..1] = [0];\n+    match [1] {\n+        VAL => unreachable!(),\n+        _ => ()\n+    }\n+}\n+\n+fn issue_14576() {\n+    type Foo = (i32, i32);\n+    static ON: Foo = (1, 1);\n+    static OFF: Foo = (0, 0);\n+\n+    match (1, 1) {\n+        OFF => unreachable!(),\n+        ON => (),\n+        _ => unreachable!()\n+    }\n+\n+    enum C { D = 3, E = 4 }\n+    static F : C = D;\n+\n+    assert_eq!(match D { F => 1i, _ => 2, }, 1);\n+}\n+\n+fn issue_13731() {\n+    enum A { A(()) }\n+    static B: A = A(());\n+\n+    match A(()) {\n+        B => ()\n+    }\n+}\n+\n+fn issue_15393() {\n+    #![allow(dead_code)]\n+    struct Flags {\n+        bits: uint\n+    }\n+\n+    static FOO: Flags = Flags { bits: 0x01 };\n+    static BAR: Flags = Flags { bits: 0x02 };\n+    match (Flags { bits: 0x02 }) {\n+        FOO => unreachable!(),\n+        BAR => (),\n+        _ => unreachable!()\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(match (true, false) {\n+        TRUE_TRUE => 1i,\n+        (false, false) => 2,\n+        (false, true) => 3,\n+        (true, false) => 4\n+    }, 4);\n+\n+    assert_eq!(match Some(Some(North)) {\n+        Some(NONE) => 1i,\n+        Some(Some(North)) => 2,\n+        Some(Some(EAST)) => 3,\n+        Some(Some(South)) => 4,\n+        Some(Some(West)) => 5,\n+        None => 6\n+    }, 2);\n+\n+    assert_eq!(match (Foo { bar: Some(West), baz: NewBool(true) }) {\n+        Foo { bar: None, baz: NewBool(true) } => 1i,\n+        Foo { bar: NONE, baz: NEW_FALSE } => 2,\n+        STATIC_FOO => 3,\n+        Foo { bar: _, baz: NEW_FALSE } => 4,\n+        Foo { bar: Some(West), baz: NewBool(true) } => 5,\n+        Foo { bar: Some(South), baz: NewBool(true) } => 6,\n+        Foo { bar: Some(EAST), .. } => 7,\n+        Foo { bar: Some(North), baz: NewBool(true) } => 8\n+    }, 5);\n+\n+    assert_eq!(match (Variant2 { dir: North }) {\n+        Variant1(true) => 1i,\n+        Variant1(false) => 2,\n+        Variant2 { dir: West } => 3,\n+        VARIANT2_NORTH => 4,\n+        Variant2 { dir: South } => 5,\n+        Variant2 { dir: East } => 6\n+    }, 4);\n+\n+    issue_6533();\n+    issue_13626();\n+    issue_13731();\n+    issue_14576();\n+    issue_15393();\n+}"}]}