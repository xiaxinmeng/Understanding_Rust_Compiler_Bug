{"sha": "c3fd0e12297d9e535f8e8e70eb942babfc11901d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzZmQwZTEyMjk3ZDllNTM1ZjhlOGU3MGViOTQyYmFiZmMxMTkwMWQ=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2015-07-08T20:55:22Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2015-07-09T22:00:08Z"}, "message": "Remove token::get_name when unneeded", "tree": {"sha": "a14a21a83a7234953524660d1acd37d3afa6d8a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a14a21a83a7234953524660d1acd37d3afa6d8a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3fd0e12297d9e535f8e8e70eb942babfc11901d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3fd0e12297d9e535f8e8e70eb942babfc11901d", "html_url": "https://github.com/rust-lang/rust/commit/c3fd0e12297d9e535f8e8e70eb942babfc11901d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3fd0e12297d9e535f8e8e70eb942babfc11901d/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50df2a09b8b9dd4883eb27d833a8482799175a3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/50df2a09b8b9dd4883eb27d833a8482799175a3b", "html_url": "https://github.com/rust-lang/rust/commit/50df2a09b8b9dd4883eb27d833a8482799175a3b"}], "stats": {"total": 110, "additions": 60, "deletions": 50}, "files": [{"sha": "f879f1c09f68a2eec047b90d820a80d31c8b7905", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 45, "deletions": 35, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/c3fd0e12297d9e535f8e8e70eb942babfc11901d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3fd0e12297d9e535f8e8e70eb942babfc11901d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c3fd0e12297d9e535f8e8e70eb942babfc11901d", "patch": "@@ -109,6 +109,14 @@ mod record_exports;\n mod build_reduced_graph;\n mod resolve_imports;\n \n+macro_rules! resolve_err {\n+    ($this:expr, $($rest:tt)*) => {\n+        if $this.emit_errors {\n+            span_err!($this.session, $($rest)*);\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone)]\n struct BindingInfo {\n     span: Span,\n@@ -947,8 +955,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if module.external_module_children.borrow().contains_key(&name) {\n                 span_err!(self.session, span, E0259,\n                           \"an external crate named `{}` has already \\\n-                                   been imported into this module\",\n-                                  &token::get_name(name));\n+                           been imported into this module\",\n+                          name);\n         }\n     }\n \n@@ -960,9 +968,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if module.external_module_children.borrow().contains_key(&name) {\n                 span_err!(self.session, span, E0260,\n                           \"the name `{}` conflicts with an external \\\n-                                   crate that has been imported into this \\\n-                                   module\",\n-                                  &token::get_name(name));\n+                           crate that has been imported into this \\\n+                           module\",\n+                           name);\n         }\n     }\n \n@@ -1041,7 +1049,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 Indeterminate => {\n                     debug!(\"(resolving module path for import) module \\\n                             resolution is indeterminate: {}\",\n-                            token::get_name(name));\n+                            name);\n                     return Indeterminate;\n                 }\n                 Success((target, used_proxy)) => {\n@@ -1052,7 +1060,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             match type_def.module_def {\n                                 None => {\n                                     let msg = format!(\"Not a module `{}`\",\n-                                                        token::get_name(name));\n+                                                        name);\n \n                                     return Failed(Some((span, msg)));\n                                 }\n@@ -1078,7 +1086,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         None => {\n                             // There are no type bindings at all.\n                             let msg = format!(\"Not a module `{}`\",\n-                                              token::get_name(name));\n+                                              name);\n                             return Failed(Some((span, msg)));\n                         }\n                     }\n@@ -1200,7 +1208,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     -> ResolveResult<(Target, bool)> {\n         debug!(\"(resolving item in lexical scope) resolving `{}` in \\\n                 namespace {:?} in `{}`\",\n-               token::get_name(name),\n+               name,\n                namespace,\n                module_to_string(&*module_));\n \n@@ -1302,9 +1310,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                               namespace,\n                                               PathSearch,\n                                               true) {\n-                Failed(Some((span, msg))) =>\n-                    self.resolve_error(span, &format!(\"failed to resolve. {}\",\n-                                                     msg)),\n+                Failed(Some((span, msg))) => {\n+                    self.resolve_error(span,\n+                                       &format!(\"failed to resolve. {}\",\n+                                                msg));\n+                },\n                 Failed(None) => (), // Continue up the search chain.\n                 Indeterminate => {\n                     // We couldn't see through the higher scope because of an\n@@ -1469,7 +1479,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                               allow_private_imports: bool)\n                               -> ResolveResult<(Target, bool)> {\n         debug!(\"(resolving name in module) resolving `{}` in `{}`\",\n-               &token::get_name(name),\n+               name,\n                module_to_string(&*module_));\n \n         // First, check the direct children of the module.\n@@ -1547,7 +1557,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // We're out of luck.\n         debug!(\"(resolving name in module) failed to resolve `{}`\",\n-               &token::get_name(name));\n+               name);\n         return Failed(None);\n     }\n \n@@ -1623,15 +1633,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 match orig_module.children.borrow().get(&name) {\n                     None => {\n                         debug!(\"!!! (with scope) didn't find `{}` in `{}`\",\n-                               token::get_name(name),\n+                               name,\n                                module_to_string(&*orig_module));\n                     }\n                     Some(name_bindings) => {\n                         match (*name_bindings).get_module_if_available() {\n                             None => {\n                                 debug!(\"!!! (with scope) didn't find module \\\n                                         for `{}` in `{}`\",\n-                                       token::get_name(name),\n+                                       name,\n                                        module_to_string(&*orig_module));\n                             }\n                             Some(module_) => {\n@@ -1795,7 +1805,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let name = item.ident.name;\n \n         debug!(\"(resolving item) resolving {}\",\n-               token::get_name(name));\n+               name);\n \n         match item.node {\n             ItemEnum(_, ref generics) |\n@@ -1931,7 +1941,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                      used for a type \\\n                                                      parameter in this type \\\n                                                      parameter list\",\n-                                                    token::get_name(name)))\n+                                                    name))\n                     }\n                     seen_bindings.insert(name);\n \n@@ -2177,7 +2187,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let path_str = path_names_to_string(&trait_ref.path, 0);\n                 self.resolve_error(span,\n                                     &format!(\"method `{}` is not a member of trait `{}`\",\n-                                            token::get_name(name),\n+                                            name,\n                                             path_str));\n             }\n         }\n@@ -2229,7 +2239,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         p.span,\n                         &format!(\"variable `{}` from pattern #1 is \\\n                                   not bound in pattern #{}\",\n-                                token::get_name(key),\n+                                key,\n                                 i + 1));\n                   }\n                   Some(binding_i) => {\n@@ -2238,7 +2248,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             binding_i.span,\n                             &format!(\"variable `{}` is bound with different \\\n                                       mode in pattern #{} than in pattern #1\",\n-                                    token::get_name(key),\n+                                    key,\n                                     i + 1));\n                     }\n                   }\n@@ -2251,7 +2261,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         binding.span,\n                         &format!(\"variable `{}` from pattern {}{} is \\\n                                   not bound in pattern {}1\",\n-                                token::get_name(key),\n+                                key,\n                                 \"#\", i + 1, \"#\"));\n                 }\n             }\n@@ -2410,7 +2420,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n                                     struct or enum variant\",\n-                                   token::get_name(renamed));\n+                                   renamed);\n \n                             self.enforce_default_binding_mode(\n                                 pattern,\n@@ -2428,12 +2438,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 &format!(\"declaration of `{}` shadows an enum \\\n                                          variant or unit-like struct in \\\n                                          scope\",\n-                                        token::get_name(renamed)));\n+                                        renamed));\n                         }\n                         FoundConst(def, lp) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n                                     constant\",\n-                                   token::get_name(renamed));\n+                                   renamed);\n \n                             self.enforce_default_binding_mode(\n                                 pattern,\n@@ -2452,7 +2462,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         }\n                         BareIdentifierPatternUnresolved => {\n                             debug!(\"(resolving pattern) binding `{}`\",\n-                                   token::get_name(renamed));\n+                                   renamed);\n \n                             let def = DefLocal(pattern.id);\n \n@@ -2639,7 +2649,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Success((target, _)) => {\n                 debug!(\"(resolve bare identifier pattern) succeeded in \\\n                          finding {} at {:?}\",\n-                        token::get_name(name),\n+                        name,\n                         target.bindings.value_def.borrow());\n                 match *target.bindings.value_def.borrow() {\n                     None => {\n@@ -2685,7 +2695,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n \n                 debug!(\"(resolve bare identifier pattern) failed to find {}\",\n-                        token::get_name(name));\n+                        name);\n                 return BareIdentifierPatternUnresolved;\n             }\n         }\n@@ -3043,13 +3053,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // found a module instead. Modules don't have defs.\n                         debug!(\"(resolving item path by identifier in lexical \\\n                                  scope) failed to resolve {} after success...\",\n-                                 token::get_name(name));\n+                                 name);\n                         return None;\n                     }\n                     Some(def) => {\n                         debug!(\"(resolving item path in lexical scope) \\\n                                 resolved `{}` to item\",\n-                               token::get_name(name));\n+                               name);\n                         // This lookup is \"all public\" because it only searched\n                         // for one identifier in the current module (couldn't\n                         // have passed through reexports or anything like that.\n@@ -3062,7 +3072,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n             Failed(err) => {\n                 debug!(\"(resolving item path by identifier in lexical scope) \\\n-                         failed to resolve {}\", token::get_name(name));\n+                         failed to resolve {}\", name);\n \n                 if let Some((span, msg)) = err {\n                     self.resolve_error(span, &format!(\"failed to resolve. {}\", msg))\n@@ -3472,15 +3482,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn get_traits_containing_item(&mut self, name: Name) -> Vec<DefId> {\n         debug!(\"(getting traits containing item) looking for '{}'\",\n-               token::get_name(name));\n+               name);\n \n         fn add_trait_info(found_traits: &mut Vec<DefId>,\n                           trait_def_id: DefId,\n                           name: Name) {\n             debug!(\"(adding trait info) found trait {}:{} for method '{}'\",\n                 trait_def_id.krate,\n                 trait_def_id.node,\n-                token::get_name(name));\n+                name);\n             found_traits.push(trait_def_id);\n         }\n \n@@ -3591,7 +3601,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         debug!(\"Children:\");\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n         for (&name, _) in module_.children.borrow().iter() {\n-            debug!(\"* {}\", token::get_name(name));\n+            debug!(\"* {}\", name);\n         }\n \n         debug!(\"Import resolutions:\");\n@@ -3615,7 +3625,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             }\n \n-            debug!(\"* {}:{}{}\", token::get_name(name), value_repr, type_repr);\n+            debug!(\"* {}:{}{}\", name, value_repr, type_repr);\n         }\n     }\n }"}, {"sha": "a08d022ffcd7e2b859dabc05b0f7245ed6719a66", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c3fd0e12297d9e535f8e8e70eb942babfc11901d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3fd0e12297d9e535f8e8e70eb942babfc11901d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=c3fd0e12297d9e535f8e8e70eb942babfc11901d", "patch": "@@ -394,9 +394,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                              -> ResolveResult<()> {\n         debug!(\"(resolving single import) resolving `{}` = `{}::{}` from \\\n                 `{}` id {}, last private {:?}\",\n-               token::get_name(target),\n+               target,\n                module_to_string(&*target_module),\n-               token::get_name(source),\n+               source,\n                module_to_string(module_),\n                directive.id,\n                lp);\n@@ -431,7 +431,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     value_result = BoundResult(target_module.clone(),\n                                                (*child_name_bindings).clone());\n                     if directive.is_public && !child_name_bindings.is_public(ValueNS) {\n-                        let msg = format!(\"`{}` is private\", token::get_name(source));\n+                        let msg = format!(\"`{}` is private\", source);\n                         span_err!(self.resolver.session, directive.span, E0364, \"{}\", &msg);\n                         pub_err = true;\n                     }\n@@ -441,7 +441,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     type_result = BoundResult(target_module.clone(),\n                                               (*child_name_bindings).clone());\n                     if !pub_err && directive.is_public && !child_name_bindings.is_public(TypeNS) {\n-                        let msg = format!(\"`{}` is private\", token::get_name(source));\n+                        let msg = format!(\"`{}` is private\", source);\n                         span_err!(self.resolver.session, directive.span, E0365, \"{}\", &msg);\n                     }\n                 }\n@@ -655,7 +655,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         if value_result.is_unbound() && type_result.is_unbound() {\n             let msg = format!(\"There is no `{}` in `{}`\",\n-                              token::get_name(source),\n+                              source,\n                               module_to_string(&target_module));\n             return ResolveResult::Failed(Some((directive.span, msg)));\n         }\n@@ -736,7 +736,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         for (ident, target_import_resolution) in import_resolutions.iter() {\n             debug!(\"(resolving glob import) writing module resolution \\\n                     {} into `{}`\",\n-                   token::get_name(*ident),\n+                   *ident,\n                    module_to_string(module_));\n \n             if !target_import_resolution.is_public {\n@@ -842,7 +842,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n                to `{}`\",\n-               &token::get_name(name),\n+               name,\n                module_to_string(&*containing_module),\n                module_to_string(module_));\n \n@@ -861,7 +861,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         let msg = format!(\"a {} named `{}` has already been imported \\\n                                            in this module\",\n                                           namespace_name,\n-                                          &token::get_name(name));\n+                                          name);\n                         span_err!(self.resolver.session, import_directive.span, E0251, \"{}\", msg);\n                     } else {\n                         let target = Target::new(containing_module.clone(),\n@@ -894,7 +894,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                     namespace: Namespace) {\n         let target = import_resolution.target_for_namespace(namespace);\n         debug!(\"check_for_conflicting_import: {}; target exists: {}\",\n-               &token::get_name(name),\n+               name,\n                target.is_some());\n \n         match target {\n@@ -918,13 +918,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 span_err!(self.resolver.session, import_span, E0252,\n                           \"a {} named `{}` has already been imported \\\n                            in this module\", ns_word,\n-                                  &token::get_name(name));\n+                                  name);\n                 let use_id = import_resolution.id(namespace);\n                 let item = self.resolver.ast_map.expect_item(use_id);\n                 // item is syntax::ast::Item;\n                 span_note!(self.resolver.session, item.span,\n                             \"previous import of `{}` here\",\n-                            token::get_name(name));\n+                            name);\n             }\n             Some(_) | None => {}\n         }\n@@ -938,7 +938,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                        namespace: Namespace) {\n         if !name_bindings.defined_in_namespace_with(namespace, DefModifiers::IMPORTABLE) {\n             let msg = format!(\"`{}` is not directly importable\",\n-                              token::get_name(name));\n+                              name);\n             span_err!(self.resolver.session, import_span, E0253, \"{}\", &msg[..]);\n         }\n     }\n@@ -959,7 +959,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     let msg = format!(\"import `{0}` conflicts with imported \\\n                                        crate in this module \\\n                                        (maybe you meant `use {0}::*`?)\",\n-                                      &token::get_name(name));\n+                                      name);\n                     span_err!(self.resolver.session, import_span, E0254, \"{}\", &msg[..]);\n                 }\n                 Some(_) | None => {}\n@@ -981,7 +981,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 if let Some(ref value) = *name_bindings.value_def.borrow() {\n                     span_err!(self.resolver.session, import_span, E0255,\n                               \"import `{}` conflicts with value in this module\",\n-                              &token::get_name(name));\n+                              name);\n                     if let Some(span) = value.value_span {\n                         self.resolver.session.span_note(span, \"conflicting value here\");\n                     }\n@@ -1004,7 +1004,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     };\n                     span_err!(self.resolver.session, import_span, E0256,\n                               \"import `{}` conflicts with {}\",\n-                              &token::get_name(name), what);\n+                              name, what);\n                     if let Some(span) = ty.type_span {\n                         self.resolver.session.span_note(span, note);\n                     }"}]}