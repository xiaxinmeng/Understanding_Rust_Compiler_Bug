{"sha": "fa6c981606b89ebed80b0dd5e829d86cdb3078d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhNmM5ODE2MDZiODllYmVkODBiMGRkNWU4MjlkODZjZGIzMDc4ZDg=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-06-25T18:40:51Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-09-06T20:35:06Z"}, "message": "add hygiene support fns, move them around.\n\nalso adds test cases", "tree": {"sha": "f2c690f19fd740604139ce9cf8d080218bff4e1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2c690f19fd740604139ce9cf8d080218bff4e1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa6c981606b89ebed80b0dd5e829d86cdb3078d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa6c981606b89ebed80b0dd5e829d86cdb3078d8", "html_url": "https://github.com/rust-lang/rust/commit/fa6c981606b89ebed80b0dd5e829d86cdb3078d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa6c981606b89ebed80b0dd5e829d86cdb3078d8/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fd5bdcb9a6d090276c0366f2c55975c153ac088", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fd5bdcb9a6d090276c0366f2c55975c153ac088", "html_url": "https://github.com/rust-lang/rust/commit/7fd5bdcb9a6d090276c0366f2c55975c153ac088"}], "stats": {"total": 235, "additions": 175, "deletions": 60}, "files": [{"sha": "ef5282551a11b767fff65d69ef474067dd453dd8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa6c981606b89ebed80b0dd5e829d86cdb3078d8/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6c981606b89ebed80b0dd5e829d86cdb3078d8/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=fa6c981606b89ebed80b0dd5e829d86cdb3078d8", "patch": "@@ -571,7 +571,7 @@ pub enum token_tree {\n     // These only make sense for right-hand-sides of MBE macros:\n \n     // a kleene-style repetition sequence with a span, a tt_forest,\n-    // an optional separator (?), and a boolean where true indicates\n+    // an optional separator, and a boolean where true indicates\n     // zero or more (*), and false indicates one or more (+).\n     tt_seq(Span, @mut ~[token_tree], Option<::parse::token::Token>, bool),\n "}, {"sha": "aeca145ea180bbd33f6e59ad8a33ec1a6d9e6fbe", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa6c981606b89ebed80b0dd5e829d86cdb3078d8/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6c981606b89ebed80b0dd5e829d86cdb3078d8/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=fa6c981606b89ebed80b0dd5e829d86cdb3078d8", "patch": "@@ -825,9 +825,6 @@ pub fn pat_is_ident(pat: @ast::Pat) -> bool {\n \n // HYGIENE FUNCTIONS\n \n-/// Construct an identifier with the given name and an empty context:\n-pub fn new_ident(name: Name) -> Ident { Ident {name: name, ctxt: 0}}\n-\n /// Extend a syntax context with a given mark\n pub fn new_mark(m:Mrk, tail:SyntaxContext) -> SyntaxContext {\n     new_mark_internal(m,tail,get_sctable())"}, {"sha": "81a47e0e4859855424d706d0457131e1c50c43fa", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 164, "deletions": 41, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/fa6c981606b89ebed80b0dd5e829d86cdb3078d8/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6c981606b89ebed80b0dd5e829d86cdb3078d8/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=fa6c981606b89ebed80b0dd5e829d86cdb3078d8", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Block, Crate, NodeId, Expr_, ExprMac, Ident, mac_invoc_tt};\n-use ast::{item_mac, Stmt_, StmtMac, StmtExpr, StmtSemi};\n-use ast::{ILLEGAL_CTXT};\n+use ast::{Block, Crate, NodeId, DeclLocal, Expr_, ExprMac, Local, Ident, mac_invoc_tt};\n+use ast::{item_mac, Mrk, Stmt_, StmtDecl, StmtMac, StmtExpr, StmtSemi};\n+use ast::{ILLEGAL_CTXT, SCTable, token_tree};\n use ast;\n use ast_util::{new_rename, new_mark, mtwt_resolve};\n use attr;\n@@ -23,7 +23,7 @@ use opt_vec;\n use parse;\n use parse::{parse_item_from_source_str};\n use parse::token;\n-use parse::token::{ident_to_str, intern};\n+use parse::token::{fresh_name, ident_to_str, intern};\n use visit;\n use visit::Visitor;\n \n@@ -521,6 +521,71 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n \n }\n \n+// expand a non-macro stmt. this is essentially the fallthrough for\n+// expand_stmt, above.\n+fn expand_non_macro_stmt (exts: SyntaxEnv,\n+                          s: &Stmt_,\n+                          sp: Span,\n+                          fld: @ast_fold,\n+                          orig: @fn(&Stmt_, Span, @ast_fold) -> (Option<Stmt_>, Span))\n+    -> (Option<Stmt_>,Span) {\n+    // is it a let?\n+    match *s {\n+        StmtDecl(@Spanned{node: DeclLocal(ref local), span: stmt_span}, node_id) => {\n+            let block_info = get_block_info(exts);\n+            let pending_renames = block_info.pending_renames;\n+\n+            // take it apart:\n+            let @Local{is_mutbl:is_mutbl,\n+                       ty:_,\n+                       pat:pat,\n+                       init:init,\n+                       id:id,\n+                       span:span\n+                      } = *local;\n+            // types can't be copied automatically because of the owned ptr in ty_tup...\n+            let ty = local.ty.clone();\n+            // expand the pat (it might contain exprs... #:(o)>\n+            let expanded_pat = fld.fold_pat(pat);\n+            // find the pat_idents in the pattern:\n+            // oh dear heaven... this is going to include the enum names, as well....\n+            let idents = @mut ~[];\n+            let name_finder = new_name_finder(idents);\n+            name_finder.visit_pat(expanded_pat,());\n+            // generate fresh names, push them to a new pending list\n+            let new_pending_renames = @mut ~[];\n+            for ident in idents.iter() {\n+                let new_name = fresh_name(ident);\n+                new_pending_renames.push((*ident,new_name));\n+            }\n+            let mut rename_fld = renames_to_fold(new_pending_renames);\n+            // rewrite the pattern using the new names (the old ones\n+            // have already been applied):\n+            let rewritten_pat = rename_fld.fold_pat(expanded_pat);\n+            // add them to the existing pending renames:\n+            for pr in new_pending_renames.iter() {pending_renames.push(*pr)}\n+            // also, don't forget to expand the init:\n+            let new_init_opt = init.map(|e| fld.fold_expr(*e));\n+            let rewritten_local =\n+                @Local{is_mutbl:is_mutbl,\n+                       ty:ty,\n+                       pat:rewritten_pat,\n+                       init:new_init_opt,\n+                       id:id,\n+                       span:span};\n+            (Some(StmtDecl(@Spanned{node:DeclLocal(rewritten_local),\n+                                     span: stmt_span},node_id)),\n+             sp)\n+        },\n+        _ => {\n+            orig(s, sp, fld)\n+        }\n+    }\n+}\n+\n+// a visitor that extracts the pat_ident paths\n+// from a given pattern and puts them in a mutable\n+// array (passed in to the traversal)\n #[deriving(Clone)]\n struct NewNameFinderContext {\n     ident_accumulator: @mut ~[ast::Ident],\n@@ -674,30 +739,10 @@ pub fn new_name_finder(idents: @mut ~[ast::Ident]) -> @mut Visitor<()> {\n     context as @mut Visitor<()>\n }\n \n-pub fn expand_block(extsbox: @mut SyntaxEnv,\n-                    _cx: @ExtCtxt,\n-                    blk: &Block,\n-                    fld: @ast_fold,\n-                    orig: @fn(&Block, @ast_fold) -> Block)\n-                 -> Block {\n-    // see note below about treatment of exts table\n-    with_exts_frame!(extsbox,false,orig(blk,fld))\n-}\n-\n-\n-// get the (innermost) BlockInfo from an exts stack\n-fn get_block_info(exts : SyntaxEnv) -> BlockInfo {\n-    match exts.find_in_topmost_frame(&intern(special_block_name)) {\n-        Some(@BlockInfo(bi)) => bi,\n-        _ => fail!(fmt!(\"special identifier %? was bound to a non-BlockInfo\",\n-                       @\" block\"))\n-    }\n-}\n-\n-\n // given a mutable list of renames, return a tree-folder that applies those\n // renames.\n-fn renames_to_fold(renames : @mut ~[(ast::Ident,ast::Name)]) -> @ast_fold {\n+// FIXME #4536: currently pub to allow testing\n+pub fn renames_to_fold(renames : @mut ~[(ast::Ident,ast::Name)]) -> @ast_fold {\n     let afp = default_ast_fold();\n     let f_pre = @AstFoldFns {\n         fold_ident: |id,_| {\n@@ -713,15 +758,56 @@ fn renames_to_fold(renames : @mut ~[(ast::Ident,ast::Name)]) -> @ast_fold {\n     make_fold(f_pre)\n }\n \n-// perform a bunch of renames\n-fn apply_pending_renames(folder : @ast_fold, stmt : ast::Stmt) -> @ast::Stmt {\n-    match folder.fold_stmt(&stmt) {\n-        Some(s) => s,\n-        None => fail!(fmt!(\"renaming of stmt produced None\"))\n+pub fn expand_block(extsbox: @mut SyntaxEnv,\n+                    _cx: @ExtCtxt,\n+                    blk: &Block,\n+                    fld: @ast_fold,\n+                    orig: @fn(&Block, @ast_fold) -> Block)\n+                 -> Block {\n+    // see note below about treatment of exts table\n+    with_exts_frame!(extsbox,false,orig(blk,fld))\n+}\n+\n+\n+pub fn expand_block_elts(exts: SyntaxEnv, b: &Block, fld: @ast_fold) -> Block {\n+    let block_info = get_block_info(exts);\n+    let pending_renames = block_info.pending_renames;\n+    let mut rename_fld = renames_to_fold(pending_renames);\n+    let new_view_items = b.view_items.map(|x| fld.fold_view_item(x));\n+    let mut new_stmts = ~[];\n+    for x in b.stmts.iter() {\n+        match fld.fold_stmt(mustbesome(rename_fld.fold_stmt(*x))) {\n+            Some(s) => new_stmts.push(s),\n+            None => ()\n+        }\n+    }\n+    let new_expr = b.expr.map(|x| fld.fold_expr(rename_fld.fold_expr(*x)));\n+    Block{\n+        view_items: new_view_items,\n+        stmts: new_stmts,\n+        expr: new_expr,\n+        id: fld.new_id(b.id),\n+        rules: b.rules,\n+        span: b.span,\n     }\n }\n \n+// rename_fold should never return \"None\".\n+fn mustbesome<T>(val : Option<T>) -> T {\n+    match val {\n+        Some(v) => v,\n+        None => fail!(\"rename_fold returned None\")\n+    }\n+}\n \n+// get the (innermost) BlockInfo from an exts stack\n+fn get_block_info(exts : SyntaxEnv) -> BlockInfo {\n+    match exts.find_in_topmost_frame(&intern(special_block_name)) {\n+        Some(@BlockInfo(bi)) => bi,\n+        _ => fail!(fmt!(\"special identifier %? was bound to a non-BlockInfo\",\n+                       @\" block\"))\n+    }\n+}\n \n pub fn new_span(cx: @ExtCtxt, sp: Span) -> Span {\n     /* this discards information in the case of macro-defining macros */\n@@ -1228,12 +1314,15 @@ mod test {\n     use super::*;\n     use ast;\n     use ast::{Attribute_, AttrOuter, MetaWord, EMPTY_CTXT};\n+    use ast_util::{get_sctable, new_rename};\n     use codemap;\n     use codemap::Spanned;\n     use parse;\n-    use parse::token::{intern, get_ident_interner};\n+    use parse::token::{gensym, intern, get_ident_interner};\n     use print::pprust;\n-    use util::parser_testing::{string_to_item, string_to_pat, strs_to_idents};\n+    use std;\n+    use util::parser_testing::{string_to_crate_and_sess, string_to_item, string_to_pat};\n+    use util::parser_testing::{strs_to_idents};\n \n     // make sure that fail! is present\n     #[test] fn fail_exists_test () {\n@@ -1333,26 +1422,60 @@ mod test {\n \n     #[test]\n     fn renaming () {\n-        let maybe_item_ast = string_to_item(@\"fn a() -> int { let b = 13; b }\");\n-        let item_ast = match maybe_item_ast {\n-            Some(x) => x,\n-            None => fail!(\"test case fail\")\n-        };\n+        let item_ast = string_to_item(@\"fn a() -> int { let b = 13; b }\").unwrap();\n         let a_name = intern(\"a\");\n-        let a2_name = intern(\"a2\");\n+        let a2_name = gensym(\"a2\");\n         let renamer = new_ident_renamer(ast::Ident{name:a_name,ctxt:EMPTY_CTXT},\n                                         a2_name);\n         let renamed_ast = fun_to_ident_folder(renamer).fold_item(item_ast).unwrap();\n         let resolver = new_ident_resolver();\n-        let resolved_ast = fun_to_ident_folder(resolver).fold_item(renamed_ast).unwrap();\n+        let resolver_fold = fun_to_ident_folder(resolver);\n+        let resolved_ast = resolver_fold.fold_item(renamed_ast).unwrap();\n         let resolved_as_str = pprust::item_to_str(resolved_ast,\n                                                   get_ident_interner());\n         assert_eq!(resolved_as_str,~\"fn a2() -> int { let b = 13; b }\");\n \n+        // try a double-rename, with pending_renames.\n+        let a3_name = gensym(\"a3\");\n+        let ctxt2 = new_rename(ast::Ident::new(a_name),a2_name,EMPTY_CTXT);\n+        let pending_renames = @mut ~[(ast::Ident::new(a_name),a2_name),\n+                                     (ast::Ident{name:a_name,ctxt:ctxt2},a3_name)];\n+        let double_renamed = renames_to_fold(pending_renames).fold_item(item_ast).unwrap();\n+        let resolved_again = resolver_fold.fold_item(double_renamed).unwrap();\n+        let double_renamed_as_str = pprust::item_to_str(resolved_again,\n+                                                        get_ident_interner());\n+        assert_eq!(double_renamed_as_str,~\"fn a3() -> int { let b = 13; b }\");\n+\n+    }\n \n+    fn fake_print_crate(s: @pprust::ps, crate: &ast::Crate) {\n+        pprust::print_mod(s, &crate.module, crate.attrs);\n     }\n \n-    // sigh... it looks like I have two different renaming mechanisms, now...\n+    // \"fn a() -> int { let b = 13; let c = b; b+c }\" --> b & c should get new names, in the expr too.\n+    // \"macro_rules! f (($x:ident) => ($x + b)) fn a() -> int { let b = 13; f!(b)}\" --> one should\n+    //     be renamed, one should not.\n+\n+    fn expand_and_resolve_and_pretty_print (crate_str : @str) -> ~str {\n+        let resolver = new_ident_resolver();\n+        let resolver_fold = fun_to_ident_folder(resolver);\n+        let (crate_ast,ps) = string_to_crate_and_sess(crate_str);\n+        // the cfg argument actually does matter, here...\n+        let expanded_ast = expand_crate(ps,~[],crate_ast);\n+        // std::io::println(fmt!(\"expanded: %?\\n\",expanded_ast));\n+        let resolved_ast = resolver_fold.fold_crate(expanded_ast);\n+        pprust::to_str(&resolved_ast,fake_print_crate,get_ident_interner())\n+    }\n+\n+    #[test]\n+    fn automatic_renaming () {\n+        let teststrs =\n+            ~[@\"fn a() -> int { let b = 13; let c = b; b+c }\",\n+              @\"macro_rules! f (($x:ident) => ($x + b)) fn a() -> int { let b = 13; f!(b)}\"];\n+        for s in teststrs.iter() {\n+            std::io::println(expand_and_resolve_and_pretty_print(*s));\n+        }\n+    }\n \n     #[test]\n     fn pat_idents(){"}, {"sha": "8de597733ae6088b48c8d4b604268fcd80619560", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa6c981606b89ebed80b0dd5e829d86cdb3078d8/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6c981606b89ebed80b0dd5e829d86cdb3078d8/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=fa6c981606b89ebed80b0dd5e829d86cdb3078d8", "patch": "@@ -552,9 +552,9 @@ pub fn gensym_ident(str : &str) -> ast::Ident {\n // by using a gensym with a name that has a random number\n // at the end. So, the gensym guarantees the uniqueness,\n // and the int helps to avoid confusion.\n-pub fn fresh_name(src_name : &str) -> Name {\n+pub fn fresh_name(src_name : &ast::Ident) -> Name {\n     let num = rand::rng().gen_uint_range(0,0xffff);\n-   gensym(fmt!(\"%s_%u\",src_name,num))\n+    gensym(fmt!(\"%s_%u\",ident_to_str(src_name),num))\n }\n \n /**\n@@ -697,9 +697,5 @@ pub fn is_reserved_keyword(tok: &Token) -> bool {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    #[test] fn t1() {\n-        let a = fresh_name(\"ghi\");\n-        printfln!(\"interned name: %u,\\ntextual name: %s\\n\",\n-                  a, interner_get(a));\n-    }\n+\n }"}, {"sha": "51fd5be71ab3f63bed6a0896045e7935273d2a6f", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fa6c981606b89ebed80b0dd5e829d86cdb3078d8/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6c981606b89ebed80b0dd5e829d86cdb3078d8/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=fa6c981606b89ebed80b0dd5e829d86cdb3078d8", "patch": "@@ -40,12 +40,19 @@ fn with_error_checking_parse<T>(s: @str, f: &fn(&mut Parser) -> T) -> T {\n     x\n }\n \n+// parse a string, return a crate.\n pub fn string_to_crate (source_str : @str) -> @ast::Crate {\n     do with_error_checking_parse(source_str) |p| {\n         p.parse_crate_mod()\n     }\n }\n \n+// parse a string, return a crate and the ParseSess\n+pub fn string_to_crate_and_sess (source_str : @str) -> (@ast::Crate,@mut ParseSess) {\n+    let (p,ps) = string_to_parser_and_sess(source_str);\n+    (p.parse_crate_mod(),ps)\n+}\n+\n // parse a string, return an expr\n pub fn string_to_expr (source_str : @str) -> @ast::Expr {\n     do with_error_checking_parse(source_str) |p| {\n@@ -60,14 +67,6 @@ pub fn string_to_item (source_str : @str) -> Option<@ast::item> {\n     }\n }\n \n-// parse a string, return an item and the ParseSess\n-pub fn string_to_item_and_sess (source_str : @str) -> (Option<@ast::item>,@mut ParseSess) {\n-    let (p,ps) = string_to_parser_and_sess(source_str);\n-    let io = p.parse_item(~[]);\n-    p.abort_if_errors();\n-    (io,ps)\n-}\n-\n // parse a string, return a stmt\n pub fn string_to_stmt(source_str : @str) -> @ast::Stmt {\n     do with_error_checking_parse(source_str) |p| {"}]}