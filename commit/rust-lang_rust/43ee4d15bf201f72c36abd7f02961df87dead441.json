{"sha": "43ee4d15bf201f72c36abd7f02961df87dead441", "node_id": "C_kwDOAAsO6NoAKDQzZWU0ZDE1YmYyMDFmNzJjMzZhYmQ3ZjAyOTYxZGY4N2RlYWQ0NDE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-26T09:44:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-26T09:44:54Z"}, "message": "Auto merge of #108375 - Zoxc:query-inline, r=cjgillot\n\nAdd inlining attributes for query system functions\n\nThese only have a single caller, but don't always get inlined.", "tree": {"sha": "129c3d2af19f712f7e2e9204c2e0d1f8a744e499", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/129c3d2af19f712f7e2e9204c2e0d1f8a744e499"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43ee4d15bf201f72c36abd7f02961df87dead441", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43ee4d15bf201f72c36abd7f02961df87dead441", "html_url": "https://github.com/rust-lang/rust/commit/43ee4d15bf201f72c36abd7f02961df87dead441", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43ee4d15bf201f72c36abd7f02961df87dead441/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70fd012439d75fd6ce561a6518b9b8fd399f455f", "url": "https://api.github.com/repos/rust-lang/rust/commits/70fd012439d75fd6ce561a6518b9b8fd399f455f", "html_url": "https://github.com/rust-lang/rust/commit/70fd012439d75fd6ce561a6518b9b8fd399f455f"}, {"sha": "dd73080cc037678410ae7e016298a6bbafaae3a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd73080cc037678410ae7e016298a6bbafaae3a6", "html_url": "https://github.com/rust-lang/rust/commit/dd73080cc037678410ae7e016298a6bbafaae3a6"}], "stats": {"total": 46, "additions": 24, "deletions": 22}, "files": [{"sha": "433c9ab9aa2efc9d9a41ac9a17144623b3e6e820", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43ee4d15bf201f72c36abd7f02961df87dead441/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ee4d15bf201f72c36abd7f02961df87dead441/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=43ee4d15bf201f72c36abd7f02961df87dead441", "patch": "@@ -1012,6 +1012,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Note that this is *untracked* and should only be used within the query\n     /// system if the result is otherwise tracked through queries\n+    #[inline]\n     pub fn cstore_untracked(self) -> MappedReadGuard<'tcx, CrateStoreDyn> {\n         ReadGuard::map(self.untracked.cstore.read(), |c| &**c)\n     }"}, {"sha": "a8592bd70862cf8660911068d054910d5b76d924", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43ee4d15bf201f72c36abd7f02961df87dead441/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ee4d15bf201f72c36abd7f02961df87dead441/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=43ee4d15bf201f72c36abd7f02961df87dead441", "patch": "@@ -124,9 +124,7 @@ impl QueryContext for QueryCtxt<'_> {\n             };\n \n             // Use the `ImplicitCtxt` while we execute the query.\n-            tls::enter_context(&new_icx, || {\n-                rustc_data_structures::stack::ensure_sufficient_stack(compute)\n-            })\n+            tls::enter_context(&new_icx, compute)\n         })\n     }\n "}, {"sha": "59e0c35974559c1e4ce46b0d53eb796c81683668", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43ee4d15bf201f72c36abd7f02961df87dead441/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ee4d15bf201f72c36abd7f02961df87dead441/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=43ee4d15bf201f72c36abd7f02961df87dead441", "patch": "@@ -279,6 +279,7 @@ impl<K: DepKind> DepGraph<K> {\n     ///   `arg` parameter.\n     ///\n     /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/incremental-compilation.html\n+    #[inline(always)]\n     pub fn with_task<Ctxt: HasDepContext<DepKind = K>, A: Debug, R>(\n         &self,\n         key: DepNode<K>,\n@@ -298,6 +299,7 @@ impl<K: DepKind> DepGraph<K> {\n         }\n     }\n \n+    #[inline(always)]\n     fn with_task_impl<Ctxt: HasDepContext<DepKind = K>, A: Debug, R>(\n         &self,\n         key: DepNode<K>,\n@@ -598,6 +600,7 @@ impl<K: DepKind> DepGraph<K> {\n         self.data.is_some() && self.dep_node_index_of_opt(dep_node).is_some()\n     }\n \n+    #[inline]\n     pub fn prev_fingerprint_of(&self, dep_node: &DepNode<K>) -> Option<Fingerprint> {\n         self.data.as_ref().unwrap().previous.fingerprint_of(dep_node)\n     }\n@@ -1127,6 +1130,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n \n     /// Writes the node to the current dep-graph and allocates a `DepNodeIndex` for it.\n     /// Assumes that this is a node that has no equivalent in the previous dep-graph.\n+    #[inline(always)]\n     fn intern_new_node(\n         &self,\n         profiler: &SelfProfilerRef,\n@@ -1365,6 +1369,7 @@ impl DepNodeColorMap {\n         }\n     }\n \n+    #[inline]\n     fn insert(&self, index: SerializedDepNodeIndex, color: DepNodeColor) {\n         self.values[index].store(\n             match color {"}, {"sha": "586bd38fbb80bb95be6cebbbf8ffd6afd9a38039", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/43ee4d15bf201f72c36abd7f02961df87dead441/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ee4d15bf201f72c36abd7f02961df87dead441/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=43ee4d15bf201f72c36abd7f02961df87dead441", "patch": "@@ -15,6 +15,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::TimingGuard;\n #[cfg(parallel_compiler)]\n use rustc_data_structures::sharded::Sharded;\n+use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::sync::Lock;\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed, FatalError};\n use rustc_session::Session;\n@@ -188,12 +189,12 @@ where\n         #[cfg(not(parallel_compiler))]\n         let mut state_lock = state.active.lock();\n         let lock = &mut *state_lock;\n+        let current_job_id = qcx.current_query_job();\n \n         match lock.entry(key) {\n             Entry::Vacant(entry) => {\n                 let id = qcx.next_job_id();\n-                let job = qcx.current_query_job();\n-                let job = QueryJob::new(id, span, job);\n+                let job = QueryJob::new(id, span, current_job_id);\n \n                 let key = *entry.key();\n                 entry.insert(QueryResult::Started(job));\n@@ -212,7 +213,7 @@ where\n                         // so we just return the error.\n                         return TryGetJob::Cycle(id.find_cycle_in_stack(\n                             qcx.try_collect_active_jobs().unwrap(),\n-                            &qcx.current_query_job(),\n+                            &current_job_id,\n                             span,\n                         ));\n                     }\n@@ -230,7 +231,7 @@ where\n \n                         // With parallel queries we might just have to wait on some other\n                         // thread.\n-                        let result = latch.wait_on(qcx.current_query_job(), span);\n+                        let result = latch.wait_on(current_job_id, span);\n \n                         match result {\n                             Ok(()) => TryGetJob::JobCompleted(query_blocked_prof_timer),\n@@ -346,10 +347,9 @@ where\n     }\n }\n \n+#[inline(never)]\n fn try_execute_query<Q, Qcx>(\n     qcx: Qcx,\n-    state: &QueryState<Q::Key, Qcx::DepKind>,\n-    cache: &Q::Cache,\n     span: Span,\n     key: Q::Key,\n     dep_node: Option<DepNode<Qcx::DepKind>>,\n@@ -358,9 +358,11 @@ where\n     Q: QueryConfig<Qcx>,\n     Qcx: QueryContext,\n {\n+    let state = Q::query_state(qcx);\n     match JobOwner::<'_, Q::Key, Qcx::DepKind>::try_start(&qcx, state, span, key) {\n         TryGetJob::NotYetStarted(job) => {\n             let (result, dep_node_index) = execute_job::<Q, Qcx>(qcx, key, dep_node, job.id);\n+            let cache = Q::query_cache(qcx);\n             if Q::FEEDABLE {\n                 // We should not compute queries that also got a value via feeding.\n                 // This can't happen, as query feeding adds the very dependencies to the fed query\n@@ -381,7 +383,7 @@ where\n         }\n         #[cfg(parallel_compiler)]\n         TryGetJob::JobCompleted(query_blocked_prof_timer) => {\n-            let Some((v, index)) = cache.lookup(&key) else {\n+            let Some((v, index)) = Q::query_cache(qcx).lookup(&key) else {\n                 panic!(\"value must be in cache after waiting\")\n             };\n \n@@ -393,6 +395,7 @@ where\n     }\n }\n \n+#[inline(always)]\n fn execute_job<Q, Qcx>(\n     qcx: Qcx,\n     key: Q::Key,\n@@ -478,6 +481,7 @@ where\n     (result, dep_node_index)\n }\n \n+#[inline(always)]\n fn try_load_from_disk_and_cache_in_memory<Q, Qcx>(\n     qcx: Qcx,\n     key: &Q::Key,\n@@ -568,6 +572,7 @@ where\n     Some((result, dep_node_index))\n }\n \n+#[inline]\n #[instrument(skip(tcx, result, hash_result), level = \"debug\")]\n pub(crate) fn incremental_verify_ich<Tcx, V: Debug>(\n     tcx: Tcx,\n@@ -722,6 +727,7 @@ pub enum QueryMode {\n     Ensure,\n }\n \n+#[inline(always)]\n pub fn get_query<Q, Qcx, D>(qcx: Qcx, span: Span, key: Q::Key, mode: QueryMode) -> Option<Q::Value>\n where\n     D: DepKind,\n@@ -739,14 +745,8 @@ where\n         None\n     };\n \n-    let (result, dep_node_index) = try_execute_query::<Q, Qcx>(\n-        qcx,\n-        Q::query_state(qcx),\n-        Q::query_cache(qcx),\n-        span,\n-        key,\n-        dep_node,\n-    );\n+    let (result, dep_node_index) =\n+        ensure_sufficient_stack(|| try_execute_query::<Q, Qcx>(qcx, span, key, dep_node));\n     if let Some(dep_node_index) = dep_node_index {\n         qcx.dep_context().dep_graph().read_index(dep_node_index)\n     }\n@@ -762,14 +762,12 @@ where\n {\n     // We may be concurrently trying both execute and force a query.\n     // Ensure that only one of them runs the query.\n-    let cache = Q::query_cache(qcx);\n-    if let Some((_, index)) = cache.lookup(&key) {\n+    if let Some((_, index)) = Q::query_cache(qcx).lookup(&key) {\n         qcx.dep_context().profiler().query_cache_hit(index.into());\n         return;\n     }\n \n-    let state = Q::query_state(qcx);\n     debug_assert!(!Q::ANON);\n \n-    try_execute_query::<Q, _>(qcx, state, cache, DUMMY_SP, key, Some(dep_node));\n+    ensure_sufficient_stack(|| try_execute_query::<Q, _>(qcx, DUMMY_SP, key, Some(dep_node)));\n }"}]}