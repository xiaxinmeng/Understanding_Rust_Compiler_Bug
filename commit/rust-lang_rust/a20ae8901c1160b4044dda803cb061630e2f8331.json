{"sha": "a20ae8901c1160b4044dda803cb061630e2f8331", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyMGFlODkwMWMxMTYwYjQwNDRkZGE4MDNjYjA2MTYzMGUyZjgzMzE=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-09-26T16:41:53Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-10-11T16:09:48Z"}, "message": "Move pprust code to a 'state' submodule", "tree": {"sha": "92167ca419a477790611d9e3f92983f04d02753a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92167ca419a477790611d9e3f92983f04d02753a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a20ae8901c1160b4044dda803cb061630e2f8331", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl+DLkwACgkQtAh+UQ6Y\nsWQA4Q//T8tIIORJQBOdbgxXGH+NNxZRuq2wJBJpEz31WgIYoy+bZTIHVZvQ/Tw7\n02fyu+Z0BMlVEVtFksi1PbmDrq21W+SIILPkvYAYqFbZml6oCZ/eQwB34uv5xl/x\nEVE1UQ9mevBayiCxqRbDQ5VbE4j9QVfNy1L9qZa2tzYfKlw3NiJnHFkx0wcQ8MBI\ngQ216/osZ/66qIjjC72THDJgfxsQOvSU5m3TWXuzU7y5x/rrkuSFfJOgZ4IKMcFi\nhMD4Sv+LlLJwbU0ALcOf2fcb+XJpS73uheSgRHV7UwV4H0xwDK0WpwDShtWduY8z\nOTpg0VmBh4WFuYYGNESJ3Qqz+N0qZq6C7LaoUsdujZ/rm7jjL2eF5efX64doLsGj\n4mes7GciYZwovI9ZXrpsWIoOYK1JBuZ6+a3xjievKJ0St2LOQw/KPH029XMhkidf\nCWXgYd8VsA/29Asly4OfwzGWHbRedVQ7SoL1dMfVZPMC2mA8nfDU8K8lAFPxE4yZ\nDFPj16oZDUct+EN93FgZKbmOuI3VfvRhPNO/c1YbkoK7lrSW09XKWonqmruIBSOG\nEbPk5Cw3UKgBJL0AnWeqPg7Ymb1lD/a+G8R0OSuj2DmWSrNZrW4oW1d3vKeuddkf\nbc3LQ3RPUktqA1GpP3ZjDAUVRtD3H7/pVGtZO3+5kps60rE+T04=\n=RscY\n-----END PGP SIGNATURE-----", "payload": "tree 92167ca419a477790611d9e3f92983f04d02753a\nparent bc74dd711fd154555dea3b110dfed39c4dc37bc6\nauthor Aaron Hill <aa1ronham@gmail.com> 1601138513 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1602432588 -0400\n\nMove pprust code to a 'state' submodule\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a20ae8901c1160b4044dda803cb061630e2f8331", "html_url": "https://github.com/rust-lang/rust/commit/a20ae8901c1160b4044dda803cb061630e2f8331", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a20ae8901c1160b4044dda803cb061630e2f8331/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc74dd711fd154555dea3b110dfed39c4dc37bc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc74dd711fd154555dea3b110dfed39c4dc37bc6", "html_url": "https://github.com/rust-lang/rust/commit/bc74dd711fd154555dea3b110dfed39c4dc37bc6"}], "stats": {"total": 478, "additions": 299, "deletions": 179}, "files": [{"sha": "b88699f6ee176c5ba8185f72b644687c67009c20", "filename": "compiler/rustc_ast_pretty/src/pprust/mod.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/a20ae8901c1160b4044dda803cb061630e2f8331/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a20ae8901c1160b4044dda803cb061630e2f8331/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs?ref=a20ae8901c1160b4044dda803cb061630e2f8331", "patch": "@@ -0,0 +1,99 @@\n+#[cfg(test)]\n+mod tests;\n+\n+pub mod state;\n+pub use state::{print_crate, AnnNode, Comments, PpAnn, PrintState, State};\n+\n+use rustc_ast as ast;\n+use rustc_ast::token::{Nonterminal, Token, TokenKind};\n+use rustc_ast::tokenstream::{TokenStream, TokenTree};\n+\n+pub fn nonterminal_to_string(nt: &Nonterminal) -> String {\n+    State::new().nonterminal_to_string(nt)\n+}\n+\n+/// Print the token kind precisely, without converting `$crate` into its respective crate name.\n+pub fn token_kind_to_string(tok: &TokenKind) -> String {\n+    State::new().token_kind_to_string(tok)\n+}\n+\n+/// Print the token precisely, without converting `$crate` into its respective crate name.\n+pub fn token_to_string(token: &Token) -> String {\n+    State::new().token_to_string(token)\n+}\n+\n+pub fn token_to_string_ext(token: &Token, convert_dollar_crate: bool) -> String {\n+    State::new().token_to_string_ext(token, convert_dollar_crate)\n+}\n+\n+pub fn ty_to_string(ty: &ast::Ty) -> String {\n+    State::new().ty_to_string(ty)\n+}\n+\n+pub fn bounds_to_string(bounds: &[ast::GenericBound]) -> String {\n+    State::new().bounds_to_string(bounds)\n+}\n+\n+pub fn pat_to_string(pat: &ast::Pat) -> String {\n+    State::new().pat_to_string(pat)\n+}\n+\n+pub fn expr_to_string(e: &ast::Expr) -> String {\n+    State::new().expr_to_string(e)\n+}\n+\n+pub fn tt_to_string(tt: &TokenTree) -> String {\n+    State::new().tt_to_string(tt)\n+}\n+\n+pub fn tts_to_string(tokens: &TokenStream) -> String {\n+    State::new().tts_to_string(tokens)\n+}\n+\n+pub fn stmt_to_string(stmt: &ast::Stmt) -> String {\n+    State::new().stmt_to_string(stmt)\n+}\n+\n+pub fn item_to_string(i: &ast::Item) -> String {\n+    State::new().item_to_string(i)\n+}\n+\n+pub fn generic_params_to_string(generic_params: &[ast::GenericParam]) -> String {\n+    State::new().generic_params_to_string(generic_params)\n+}\n+\n+pub fn path_to_string(p: &ast::Path) -> String {\n+    State::new().path_to_string(p)\n+}\n+\n+pub fn path_segment_to_string(p: &ast::PathSegment) -> String {\n+    State::new().path_segment_to_string(p)\n+}\n+\n+pub fn vis_to_string(v: &ast::Visibility) -> String {\n+    State::new().vis_to_string(v)\n+}\n+\n+pub fn block_to_string(blk: &ast::Block) -> String {\n+    State::new().block_to_string(blk)\n+}\n+\n+pub fn meta_list_item_to_string(li: &ast::NestedMetaItem) -> String {\n+    State::new().meta_list_item_to_string(li)\n+}\n+\n+pub fn attr_item_to_string(ai: &ast::AttrItem) -> String {\n+    State::new().attr_item_to_string(ai)\n+}\n+\n+pub fn attribute_to_string(attr: &ast::Attribute) -> String {\n+    State::new().attribute_to_string(attr)\n+}\n+\n+pub fn param_to_string(arg: &ast::Param) -> String {\n+    State::new().param_to_string(arg)\n+}\n+\n+pub fn to_string(f: impl FnOnce(&mut State<'_>)) -> String {\n+    State::new().to_string(f)\n+}"}, {"sha": "14feb4989035c570defa5d273d14c22f07e6fe63", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "renamed", "additions": 200, "deletions": 179, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/a20ae8901c1160b4044dda803cb061630e2f8331/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a20ae8901c1160b4044dda803cb061630e2f8331/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=a20ae8901c1160b4044dda803cb061630e2f8331", "patch": "@@ -142,13 +142,6 @@ pub fn print_crate<'a>(\n     s.s.eof()\n }\n \n-pub fn to_string(f: impl FnOnce(&mut State<'_>)) -> String {\n-    let mut printer =\n-        State { s: pp::mk_printer(), comments: None, ann: &NoAnn, is_expanded: false };\n-    f(&mut printer);\n-    printer.s.eof()\n-}\n-\n // This makes printed token streams look slightly nicer,\n // and also addresses some specific regressions described in #63896 and #73345.\n fn tt_prepend_space(tt: &TokenTree, prev: &TokenTree) -> bool {\n@@ -231,173 +224,8 @@ pub fn literal_to_string(lit: token::Lit) -> String {\n     out\n }\n \n-/// Print the token kind precisely, without converting `$crate` into its respective crate name.\n-pub fn token_kind_to_string(tok: &TokenKind) -> String {\n-    token_kind_to_string_ext(tok, None)\n-}\n-\n-fn token_kind_to_string_ext(tok: &TokenKind, convert_dollar_crate: Option<Span>) -> String {\n-    match *tok {\n-        token::Eq => \"=\".to_string(),\n-        token::Lt => \"<\".to_string(),\n-        token::Le => \"<=\".to_string(),\n-        token::EqEq => \"==\".to_string(),\n-        token::Ne => \"!=\".to_string(),\n-        token::Ge => \">=\".to_string(),\n-        token::Gt => \">\".to_string(),\n-        token::Not => \"!\".to_string(),\n-        token::Tilde => \"~\".to_string(),\n-        token::OrOr => \"||\".to_string(),\n-        token::AndAnd => \"&&\".to_string(),\n-        token::BinOp(op) => binop_to_string(op).to_string(),\n-        token::BinOpEq(op) => format!(\"{}=\", binop_to_string(op)),\n-\n-        /* Structural symbols */\n-        token::At => \"@\".to_string(),\n-        token::Dot => \".\".to_string(),\n-        token::DotDot => \"..\".to_string(),\n-        token::DotDotDot => \"...\".to_string(),\n-        token::DotDotEq => \"..=\".to_string(),\n-        token::Comma => \",\".to_string(),\n-        token::Semi => \";\".to_string(),\n-        token::Colon => \":\".to_string(),\n-        token::ModSep => \"::\".to_string(),\n-        token::RArrow => \"->\".to_string(),\n-        token::LArrow => \"<-\".to_string(),\n-        token::FatArrow => \"=>\".to_string(),\n-        token::OpenDelim(token::Paren) => \"(\".to_string(),\n-        token::CloseDelim(token::Paren) => \")\".to_string(),\n-        token::OpenDelim(token::Bracket) => \"[\".to_string(),\n-        token::CloseDelim(token::Bracket) => \"]\".to_string(),\n-        token::OpenDelim(token::Brace) => \"{\".to_string(),\n-        token::CloseDelim(token::Brace) => \"}\".to_string(),\n-        token::OpenDelim(token::NoDelim) | token::CloseDelim(token::NoDelim) => \"\".to_string(),\n-        token::Pound => \"#\".to_string(),\n-        token::Dollar => \"$\".to_string(),\n-        token::Question => \"?\".to_string(),\n-        token::SingleQuote => \"'\".to_string(),\n-\n-        /* Literals */\n-        token::Literal(lit) => literal_to_string(lit),\n-\n-        /* Name components */\n-        token::Ident(s, is_raw) => IdentPrinter::new(s, is_raw, convert_dollar_crate).to_string(),\n-        token::Lifetime(s) => s.to_string(),\n-\n-        /* Other */\n-        token::DocComment(comment_kind, attr_style, data) => {\n-            doc_comment_to_string(comment_kind, attr_style, data)\n-        }\n-        token::Eof => \"<eof>\".to_string(),\n-\n-        token::Interpolated(ref nt) => nonterminal_to_string(nt),\n-    }\n-}\n-\n-/// Print the token precisely, without converting `$crate` into its respective crate name.\n-pub fn token_to_string(token: &Token) -> String {\n-    token_to_string_ext(token, false)\n-}\n-\n-fn token_to_string_ext(token: &Token, convert_dollar_crate: bool) -> String {\n-    let convert_dollar_crate = convert_dollar_crate.then_some(token.span);\n-    token_kind_to_string_ext(&token.kind, convert_dollar_crate)\n-}\n-\n-pub fn nonterminal_to_string(nt: &Nonterminal) -> String {\n-    match *nt {\n-        token::NtExpr(ref e) => expr_to_string(e),\n-        token::NtMeta(ref e) => attr_item_to_string(e),\n-        token::NtTy(ref e) => ty_to_string(e),\n-        token::NtPath(ref e) => path_to_string(e),\n-        token::NtItem(ref e) => item_to_string(e),\n-        token::NtBlock(ref e) => block_to_string(e),\n-        token::NtStmt(ref e) => stmt_to_string(e),\n-        token::NtPat(ref e) => pat_to_string(e),\n-        token::NtIdent(e, is_raw) => IdentPrinter::for_ast_ident(e, is_raw).to_string(),\n-        token::NtLifetime(e) => e.to_string(),\n-        token::NtLiteral(ref e) => expr_to_string(e),\n-        token::NtTT(ref tree) => tt_to_string(tree),\n-        token::NtVis(ref e) => vis_to_string(e),\n-    }\n-}\n-\n-pub fn ty_to_string(ty: &ast::Ty) -> String {\n-    to_string(|s| s.print_type(ty))\n-}\n-\n-pub fn bounds_to_string(bounds: &[ast::GenericBound]) -> String {\n-    to_string(|s| s.print_type_bounds(\"\", bounds))\n-}\n-\n-pub fn pat_to_string(pat: &ast::Pat) -> String {\n-    to_string(|s| s.print_pat(pat))\n-}\n-\n-pub fn expr_to_string(e: &ast::Expr) -> String {\n-    to_string(|s| s.print_expr(e))\n-}\n-\n-pub fn tt_to_string(tt: &TokenTree) -> String {\n-    to_string(|s| s.print_tt(tt, false))\n-}\n-\n-pub fn tts_to_string(tokens: &TokenStream) -> String {\n-    to_string(|s| s.print_tts(tokens, false))\n-}\n-\n-pub fn stmt_to_string(stmt: &ast::Stmt) -> String {\n-    to_string(|s| s.print_stmt(stmt))\n-}\n-\n-pub fn item_to_string(i: &ast::Item) -> String {\n-    to_string(|s| s.print_item(i))\n-}\n-\n-pub fn generic_params_to_string(generic_params: &[ast::GenericParam]) -> String {\n-    to_string(|s| s.print_generic_params(generic_params))\n-}\n-\n-pub fn path_to_string(p: &ast::Path) -> String {\n-    to_string(|s| s.print_path(p, false, 0))\n-}\n-\n-pub fn path_segment_to_string(p: &ast::PathSegment) -> String {\n-    to_string(|s| s.print_path_segment(p, false))\n-}\n-\n-pub fn vis_to_string(v: &ast::Visibility) -> String {\n-    to_string(|s| s.print_visibility(v))\n-}\n-\n-fn block_to_string(blk: &ast::Block) -> String {\n-    to_string(|s| {\n-        // Containing cbox, will be closed by `print_block` at `}`.\n-        s.cbox(INDENT_UNIT);\n-        // Head-ibox, will be closed by `print_block` after `{`.\n-        s.ibox(0);\n-        s.print_block(blk)\n-    })\n-}\n-\n-pub fn meta_list_item_to_string(li: &ast::NestedMetaItem) -> String {\n-    to_string(|s| s.print_meta_list_item(li))\n-}\n-\n-fn attr_item_to_string(ai: &ast::AttrItem) -> String {\n-    to_string(|s| s.print_attr_item(ai, ai.path.span))\n-}\n-\n-pub fn attribute_to_string(attr: &ast::Attribute) -> String {\n-    to_string(|s| s.print_attribute(attr))\n-}\n-\n-pub fn param_to_string(arg: &ast::Param) -> String {\n-    to_string(|s| s.print_param(arg, false))\n-}\n-\n fn visibility_qualified(vis: &ast::Visibility, s: &str) -> String {\n-    format!(\"{}{}\", to_string(|s| s.print_visibility(vis)), s)\n+    format!(\"{}{}\", State::new().to_string(|s| s.print_visibility(vis)), s) \n }\n \n impl std::ops::Deref for State<'_> {\n@@ -679,7 +507,8 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     fn print_tt(&mut self, tt: &TokenTree, convert_dollar_crate: bool) {\n         match tt {\n             TokenTree::Token(token) => {\n-                self.word(token_to_string_ext(&token, convert_dollar_crate));\n+                let token_str = self.token_to_string_ext(&token, convert_dollar_crate);\n+                self.word(token_str);\n                 if let token::DocComment(..) = token.kind {\n                     self.hardbreak()\n                 }\n@@ -745,14 +574,20 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                     self.space();\n                 }\n             }\n-            _ => self.word(token_kind_to_string(&token::OpenDelim(delim))),\n+            _ => {\n+                let token_str = self.token_kind_to_string(&token::OpenDelim(delim));\n+                self.word(token_str)\n+            }\n         }\n         self.ibox(0);\n         self.print_tts(tts, convert_dollar_crate);\n         self.end();\n         match delim {\n             DelimToken::Brace => self.bclose(span),\n-            _ => self.word(token_kind_to_string(&token::CloseDelim(delim))),\n+            _ => {\n+                let token_str = self.token_kind_to_string(&token::CloseDelim(delim));\n+                self.word(token_str)\n+            }\n         }\n     }\n \n@@ -818,6 +653,183 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             }\n         }\n     }\n+\n+    fn nonterminal_to_string(&self, nt: &Nonterminal) -> String {\n+        match *nt {\n+            token::NtExpr(ref e) => self.expr_to_string(e),\n+            token::NtMeta(ref e) => self.attr_item_to_string(e),\n+            token::NtTy(ref e) => self.ty_to_string(e),\n+            token::NtPath(ref e) => self.path_to_string(e),\n+            token::NtItem(ref e) => self.item_to_string(e),\n+            token::NtBlock(ref e) => self.block_to_string(e),\n+            token::NtStmt(ref e) => self.stmt_to_string(e),\n+            token::NtPat(ref e) => self.pat_to_string(e),\n+            token::NtIdent(e, is_raw) => IdentPrinter::for_ast_ident(e, is_raw).to_string(),\n+            token::NtLifetime(e) => e.to_string(),\n+            token::NtLiteral(ref e) => self.expr_to_string(e),\n+            token::NtTT(ref tree) => self.tt_to_string(tree),\n+            token::NtVis(ref e) => self.vis_to_string(e),\n+        }\n+    }\n+\n+    /// Print the token kind precisely, without converting `$crate` into its respective crate name.\n+    fn token_kind_to_string(&self, tok: &TokenKind) -> String {\n+        self.token_kind_to_string_ext(tok, None)\n+    }\n+\n+    fn token_kind_to_string_ext(\n+        &self,\n+        tok: &TokenKind,\n+        convert_dollar_crate: Option<Span>,\n+    ) -> String {\n+        match *tok {\n+            token::Eq => \"=\".to_string(),\n+            token::Lt => \"<\".to_string(),\n+            token::Le => \"<=\".to_string(),\n+            token::EqEq => \"==\".to_string(),\n+            token::Ne => \"!=\".to_string(),\n+            token::Ge => \">=\".to_string(),\n+            token::Gt => \">\".to_string(),\n+            token::Not => \"!\".to_string(),\n+            token::Tilde => \"~\".to_string(),\n+            token::OrOr => \"||\".to_string(),\n+            token::AndAnd => \"&&\".to_string(),\n+            token::BinOp(op) => binop_to_string(op).to_string(),\n+            token::BinOpEq(op) => format!(\"{}=\", binop_to_string(op)),\n+\n+            /* Structural symbols */\n+            token::At => \"@\".to_string(),\n+            token::Dot => \".\".to_string(),\n+            token::DotDot => \"..\".to_string(),\n+            token::DotDotDot => \"...\".to_string(),\n+            token::DotDotEq => \"..=\".to_string(),\n+            token::Comma => \",\".to_string(),\n+            token::Semi => \";\".to_string(),\n+            token::Colon => \":\".to_string(),\n+            token::ModSep => \"::\".to_string(),\n+            token::RArrow => \"->\".to_string(),\n+            token::LArrow => \"<-\".to_string(),\n+            token::FatArrow => \"=>\".to_string(),\n+            token::OpenDelim(token::Paren) => \"(\".to_string(),\n+            token::CloseDelim(token::Paren) => \")\".to_string(),\n+            token::OpenDelim(token::Bracket) => \"[\".to_string(),\n+            token::CloseDelim(token::Bracket) => \"]\".to_string(),\n+            token::OpenDelim(token::Brace) => \"{\".to_string(),\n+            token::CloseDelim(token::Brace) => \"}\".to_string(),\n+            token::OpenDelim(token::NoDelim) | token::CloseDelim(token::NoDelim) => \"\".to_string(),\n+            token::Pound => \"#\".to_string(),\n+            token::Dollar => \"$\".to_string(),\n+            token::Question => \"?\".to_string(),\n+            token::SingleQuote => \"'\".to_string(),\n+\n+            /* Literals */\n+            token::Literal(lit) => literal_to_string(lit),\n+\n+            /* Name components */\n+            token::Ident(s, is_raw) => {\n+                IdentPrinter::new(s, is_raw, convert_dollar_crate).to_string()\n+            }\n+            token::Lifetime(s) => s.to_string(),\n+\n+            /* Other */\n+            token::DocComment(comment_kind, attr_style, data) => {\n+                doc_comment_to_string(comment_kind, attr_style, data)\n+            }\n+            token::Eof => \"<eof>\".to_string(),\n+\n+            token::Interpolated(ref nt) => self.nonterminal_to_string(nt),\n+        }\n+    }\n+\n+    /// Print the token precisely, without converting `$crate` into its respective crate name.\n+    fn token_to_string(&self, token: &Token) -> String {\n+        self.token_to_string_ext(token, false)\n+    }\n+\n+    fn token_to_string_ext(&self, token: &Token, convert_dollar_crate: bool) -> String {\n+        let convert_dollar_crate = convert_dollar_crate.then_some(token.span);\n+        self.token_kind_to_string_ext(&token.kind, convert_dollar_crate)\n+    }\n+\n+    fn ty_to_string(&self, ty: &ast::Ty) -> String {\n+        self.to_string(|s| s.print_type(ty))\n+    }\n+\n+    fn bounds_to_string(&self, bounds: &[ast::GenericBound]) -> String {\n+        self.to_string(|s| s.print_type_bounds(\"\", bounds))\n+    }\n+\n+    fn pat_to_string(&self, pat: &ast::Pat) -> String {\n+        self.to_string(|s| s.print_pat(pat))\n+    }\n+\n+    fn expr_to_string(&self, e: &ast::Expr) -> String {\n+        self.to_string(|s| s.print_expr(e))\n+    }\n+\n+    fn tt_to_string(&self, tt: &TokenTree) -> String {\n+        self.to_string(|s| s.print_tt(tt, false))\n+    }\n+\n+    fn tts_to_string(&self, tokens: &TokenStream) -> String {\n+        self.to_string(|s| s.print_tts(tokens, false))\n+    }\n+\n+    fn stmt_to_string(&self, stmt: &ast::Stmt) -> String {\n+        self.to_string(|s| s.print_stmt(stmt))\n+    }\n+\n+    fn item_to_string(&self, i: &ast::Item) -> String {\n+        self.to_string(|s| s.print_item(i))\n+    }\n+\n+    fn generic_params_to_string(&self, generic_params: &[ast::GenericParam]) -> String {\n+        self.to_string(|s| s.print_generic_params(generic_params))\n+    }\n+\n+    fn path_to_string(&self, p: &ast::Path) -> String {\n+        self.to_string(|s| s.print_path(p, false, 0))\n+    }\n+\n+    fn path_segment_to_string(&self, p: &ast::PathSegment) -> String {\n+        self.to_string(|s| s.print_path_segment(p, false))\n+    }\n+\n+    fn vis_to_string(&self, v: &ast::Visibility) -> String {\n+        self.to_string(|s| s.print_visibility(v))\n+    }\n+\n+    fn block_to_string(&self, blk: &ast::Block) -> String {\n+        self.to_string(|s| {\n+            // Containing cbox, will be closed by `print_block` at `}`.\n+            s.cbox(INDENT_UNIT);\n+            // Head-ibox, will be closed by `print_block` after `{`.\n+            s.ibox(0);\n+            s.print_block(blk)\n+        })\n+    }\n+\n+    fn meta_list_item_to_string(&self, li: &ast::NestedMetaItem) -> String {\n+        self.to_string(|s| s.print_meta_list_item(li))\n+    }\n+\n+    fn attr_item_to_string(&self, ai: &ast::AttrItem) -> String {\n+        self.to_string(|s| s.print_attr_item(ai, ai.path.span))\n+    }\n+\n+    fn attribute_to_string(&self, attr: &ast::Attribute) -> String {\n+        self.to_string(|s| s.print_attribute(attr))\n+    }\n+\n+    fn param_to_string(&self, arg: &ast::Param) -> String {\n+        self.to_string(|s| s.print_param(arg, false))\n+    }\n+\n+    fn to_string(&self, f: impl FnOnce(&mut State<'_>)) -> String {\n+        let mut printer = State::new();\n+        f(&mut printer);\n+        printer.s.eof()\n+    }\n }\n \n impl<'a> PrintState<'a> for State<'a> {\n@@ -856,6 +868,15 @@ impl<'a> PrintState<'a> for State<'a> {\n }\n \n impl<'a> State<'a> {\n+    pub fn new() -> State<'a> {\n+        State {\n+            s: pp::mk_printer(),\n+            comments: None,\n+            ann: &NoAnn,\n+            is_expanded: false,\n+        }\n+    }\n+\n     // Synthesizes a comment that was not textually present in the original source\n     // file.\n     pub fn synth_comment(&mut self, text: String) {\n@@ -1139,7 +1160,7 @@ impl<'a> State<'a> {\n                 self.print_fn_full(sig, item.ident, gen, &item.vis, def, body, &item.attrs);\n             }\n             ast::ItemKind::Mod(ref _mod) => {\n-                self.head(to_string(|s| {\n+                self.head(self.to_string(|s| {\n                     s.print_visibility(&item.vis);\n                     s.print_unsafety(_mod.unsafety);\n                     s.word(\"mod\");\n@@ -1158,7 +1179,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::ItemKind::ForeignMod(ref nmod) => {\n-                self.head(to_string(|s| {\n+                self.head(self.to_string(|s| {\n                     s.print_unsafety(nmod.unsafety);\n                     s.word(\"extern\");\n                 }));\n@@ -1366,7 +1387,7 @@ impl<'a> State<'a> {\n                 ast::CrateSugar::JustCrate => self.word_nbsp(\"crate\"),\n             },\n             ast::VisibilityKind::Restricted { ref path, .. } => {\n-                let path = to_string(|s| s.print_path(path, false, 0));\n+                let path = self.to_string(|s| s.print_path(path, false, 0));\n                 if path == \"self\" || path == \"super\" {\n                     self.word_nbsp(format!(\"pub({})\", path))\n                 } else {", "previous_filename": "compiler/rustc_ast_pretty/src/pprust.rs"}]}