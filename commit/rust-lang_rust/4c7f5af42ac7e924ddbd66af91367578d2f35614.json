{"sha": "4c7f5af42ac7e924ddbd66af91367578d2f35614", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjN2Y1YWY0MmFjN2U5MjRkZGJkNjZhZjkxMzY3NTc4ZDJmMzU2MTQ=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2019-12-16T02:11:59Z"}, "committer": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2019-12-18T19:12:58Z"}, "message": "Separate region inference logic from error handling better", "tree": {"sha": "61860041a3d581d8b02c70e38959d80795dd611c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61860041a3d581d8b02c70e38959d80795dd611c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c7f5af42ac7e924ddbd66af91367578d2f35614", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c7f5af42ac7e924ddbd66af91367578d2f35614", "html_url": "https://github.com/rust-lang/rust/commit/4c7f5af42ac7e924ddbd66af91367578d2f35614", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c7f5af42ac7e924ddbd66af91367578d2f35614/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19bd93467617a447c22ec32cc1cf14d40cb84ccf", "url": "https://api.github.com/repos/rust-lang/rust/commits/19bd93467617a447c22ec32cc1cf14d40cb84ccf", "html_url": "https://github.com/rust-lang/rust/commit/19bd93467617a447c22ec32cc1cf14d40cb84ccf"}], "stats": {"total": 184, "additions": 96, "deletions": 88}, "files": [{"sha": "b78cd6bccf8ca9ff80ee9f8931c93bd378b303aa", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4c7f5af42ac7e924ddbd66af91367578d2f35614/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7f5af42ac7e924ddbd66af91367578d2f35614/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=4c7f5af42ac7e924ddbd66af91367578d2f35614", "patch": "@@ -1,10 +1,13 @@\n //! Error reporting machinery for lifetime errors.\n \n use rustc::hir::def_id::DefId;\n-use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n-use rustc::infer::InferCtxt;\n-use rustc::infer::NLLRegionVariableOrigin;\n-use rustc::mir::{ConstraintCategory, Local, Location, Body};\n+use rustc::infer::{\n+    error_reporting::nice_region_error::NiceRegionError,\n+    InferCtxt, NLLRegionVariableOrigin,\n+};\n+use rustc::mir::{\n+    ConstraintCategory, Local, Location, Body,\n+};\n use rustc::ty::{self, RegionVid};\n use rustc_index::vec::IndexVec;\n use rustc_errors::DiagnosticBuilder;\n@@ -93,6 +96,32 @@ pub struct ErrorConstraintInfo {\n }\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n+    /// Converts a region inference variable into a `ty::Region` that\n+    /// we can use for error reporting. If `r` is universally bound,\n+    /// then we use the name that we have on record for it. If `r` is\n+    /// existentially bound, then we check its inferred value and try\n+    /// to find a good name from that. Returns `None` if we can't find\n+    /// one (e.g., this is just some random part of the CFG).\n+    pub fn to_error_region(&self, r: RegionVid) -> Option<ty::Region<'tcx>> {\n+        self.to_error_region_vid(r).and_then(|r| self.definitions[r].external_name)\n+    }\n+\n+    /// Returns the [RegionVid] corresponding to the region returned by\n+    /// `to_error_region`.\n+    pub fn to_error_region_vid(&self, r: RegionVid) -> Option<RegionVid> {\n+        if self.universal_regions.is_universal_region(r) {\n+            Some(r)\n+        } else {\n+            let r_scc = self.constraint_sccs.scc(r);\n+            let upper_bound = self.universal_upper_bound(r);\n+            if self.scc_values.contains(r_scc, upper_bound) {\n+                self.to_error_region_vid(upper_bound)\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+\n     /// Tries to find the best constraint to blame for the fact that\n     /// `R: from_region`, where `R` is some region that meets\n     /// `target_test`. This works by following the constraint graph,"}, {"sha": "ca29b552733d1457527591c751cce5bad7879a85", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 63, "deletions": 84, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/4c7f5af42ac7e924ddbd66af91367578d2f35614/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7f5af42ac7e924ddbd66af91367578d2f35614/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=4c7f5af42ac7e924ddbd66af91367578d2f35614", "patch": "@@ -928,32 +928,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    /// Converts a region inference variable into a `ty::Region` that\n-    /// we can use for error reporting. If `r` is universally bound,\n-    /// then we use the name that we have on record for it. If `r` is\n-    /// existentially bound, then we check its inferred value and try\n-    /// to find a good name from that. Returns `None` if we can't find\n-    /// one (e.g., this is just some random part of the CFG).\n-    pub fn to_error_region(&self, r: RegionVid) -> Option<ty::Region<'tcx>> {\n-        self.to_error_region_vid(r).and_then(|r| self.definitions[r].external_name)\n-    }\n-\n-    /// Returns the [RegionVid] corresponding to the region returned by\n-    /// `to_error_region`.\n-    pub fn to_error_region_vid(&self, r: RegionVid) -> Option<RegionVid> {\n-        if self.universal_regions.is_universal_region(r) {\n-            Some(r)\n-        } else {\n-            let r_scc = self.constraint_sccs.scc(r);\n-            let upper_bound = self.universal_upper_bound(r);\n-            if self.scc_values.contains(r_scc, upper_bound) {\n-                self.to_error_region_vid(upper_bound)\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-\n     /// Invoked when we have some type-test (e.g., `T: 'X`) that we cannot\n     /// prove to be satisfied. If this is a closure, we will attempt to\n     /// \"promote\" this type-test into our `ClosureRegionRequirements` and\n@@ -1164,7 +1138,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///   include the CFG anyhow.\n     /// - For each `end('x)` element in `'r`, compute the mutual LUB, yielding\n     ///   a result `'y`.\n-    fn universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n+    pub (in crate::borrow_check) fn universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n         debug!(\"universal_upper_bound(r={:?}={})\", r, self.region_value_str(r));\n \n         // Find the smallest universal region that contains all other\n@@ -1458,19 +1432,34 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             debug!(\"check_polonius_subset_errors: subset_error longer_fr={:?},\\\n                 shorter_fr={:?}\", longer_fr, shorter_fr);\n \n-            self.report_or_propagate_universal_region_error(\n+            let propagated = self.try_propagate_universal_region_error(\n                 *longer_fr,\n                 *shorter_fr,\n-                infcx,\n                 body,\n-                local_names,\n-                upvars,\n-                mir_def_id,\n                 &mut propagated_outlives_requirements,\n-                &mut outlives_suggestion,\n-                errors_buffer,\n-                region_naming,\n             );\n+            if !propagated {\n+                // If we are not in a context where we can't propagate errors, or we\n+                // could not shrink `fr` to something smaller, then just report an\n+                // error.\n+                //\n+                // Note: in this case, we use the unapproximated regions to report the\n+                // error. This gives better error messages in some cases.\n+                let db = self.report_error(\n+                    body,\n+                    local_names,\n+                    upvars,\n+                    infcx,\n+                    mir_def_id,\n+                    *longer_fr,\n+                    NLLRegionVariableOrigin::FreeRegion,\n+                    *shorter_fr,\n+                    &mut outlives_suggestion,\n+                    region_naming,\n+                );\n+\n+                db.buffer(errors_buffer);\n+            }\n         }\n \n         // Handle the placeholder errors as usual, until the chalk-rustc-polonius triumvirate has\n@@ -1594,48 +1583,59 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return None;\n         }\n \n-        self.report_or_propagate_universal_region_error(\n+        let propagated = self.try_propagate_universal_region_error(\n             longer_fr,\n             shorter_fr,\n-            infcx,\n             body,\n-            local_names,\n-            upvars,\n-            mir_def_id,\n             propagated_outlives_requirements,\n-            outlives_suggestion,\n-            errors_buffer,\n-            region_naming,\n-        )\n+        );\n+\n+        if propagated {\n+            None\n+        } else {\n+            // If we are not in a context where we can't propagate errors, or we\n+            // could not shrink `fr` to something smaller, then just report an\n+            // error.\n+            //\n+            // Note: in this case, we use the unapproximated regions to report the\n+            // error. This gives better error messages in some cases.\n+            let db = self.report_error(\n+                body,\n+                local_names,\n+                upvars,\n+                infcx,\n+                mir_def_id,\n+                longer_fr,\n+                NLLRegionVariableOrigin::FreeRegion,\n+                shorter_fr,\n+                outlives_suggestion,\n+                region_naming,\n+            );\n+\n+            db.buffer(errors_buffer);\n+\n+            Some(ErrorReported)\n+        }\n     }\n \n-    fn report_or_propagate_universal_region_error(\n+    /// Attempt to propagate a region error (e.g. `'a: 'b`) that is not met to a closure's\n+    /// creator. If we cannot, then we report an error to the user.\n+    ///\n+    /// Returns `true` if the error was propagated, and `false` otherwise.\n+    fn try_propagate_universal_region_error(\n         &self,\n         longer_fr: RegionVid,\n         shorter_fr: RegionVid,\n-        infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n-        local_names: &IndexVec<Local, Option<Symbol>>,\n-        upvars: &[Upvar],\n-        mir_def_id: DefId,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n-        outlives_suggestion: &mut OutlivesSuggestionBuilder<'_>,\n-        errors_buffer: &mut Vec<Diagnostic>,\n-        region_naming: &mut RegionErrorNamingCtx,\n-    ) -> Option<ErrorReported> {\n-        debug!(\n-            \"report_or_propagate_universal_region_error: fr={:?} does not outlive shorter_fr={:?}\",\n-            longer_fr, shorter_fr,\n-        );\n-\n+    ) -> bool {\n         if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n             // Shrink `longer_fr` until we find a non-local region (if we do).\n             // We'll call it `fr-` -- it's ever so slightly smaller than\n             // `longer_fr`.\n-\n             if let Some(fr_minus) =\n                 self.universal_region_relations.non_local_lower_bound(longer_fr) {\n-                debug!(\"report_or_propagate_universal_region_error: fr_minus={:?}\", fr_minus);\n+                debug!(\"try_propagate_universal_region_error: fr_minus={:?}\", fr_minus);\n \n                 let blame_span_category =\n                     self.find_outlives_blame_span(body, longer_fr,\n@@ -1648,7 +1648,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     .universal_region_relations\n                     .non_local_upper_bounds(&shorter_fr);\n                 debug!(\n-                    \"report_or_propagate_universal_region_error: shorter_fr_plus={:?}\",\n+                    \"try_propagate_universal_region_error: shorter_fr_plus={:?}\",\n                     shorter_fr_plus\n                 );\n                 for &&fr in &shorter_fr_plus {\n@@ -1660,32 +1660,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         category: blame_span_category.0,\n                     });\n                 }\n-                return None;\n+                return true;\n             }\n         }\n \n-        // If we are not in a context where we can't propagate errors, or we\n-        // could not shrink `fr` to something smaller, then just report an\n-        // error.\n-        //\n-        // Note: in this case, we use the unapproximated regions to report the\n-        // error. This gives better error messages in some cases.\n-        let db = self.report_error(\n-            body,\n-            local_names,\n-            upvars,\n-            infcx,\n-            mir_def_id,\n-            longer_fr,\n-            NLLRegionVariableOrigin::FreeRegion,\n-            shorter_fr,\n-            outlives_suggestion,\n-            region_naming,\n-        );\n-\n-        db.buffer(errors_buffer);\n-\n-        Some(ErrorReported)\n+        false\n     }\n \n     fn check_bound_universal_region("}]}