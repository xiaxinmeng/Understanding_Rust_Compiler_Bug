{"sha": "a637db2aa18f0dc18616c7837de1e60972f20112", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MzdkYjJhYTE4ZjBkYzE4NjE2Yzc4MzdkZTFlNjA5NzJmMjAxMTI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-07-18T00:47:20Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-07-22T21:16:33Z"}, "message": "extra: Add url module\n\nUsed to be under extra::net, which no longer exists", "tree": {"sha": "41b0d0676079e11947068992b0b74e511220f5f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41b0d0676079e11947068992b0b74e511220f5f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a637db2aa18f0dc18616c7837de1e60972f20112", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a637db2aa18f0dc18616c7837de1e60972f20112", "html_url": "https://github.com/rust-lang/rust/commit/a637db2aa18f0dc18616c7837de1e60972f20112", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a637db2aa18f0dc18616c7837de1e60972f20112/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "219c1c71dacc2de22b58094071f62613ef2c7f4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/219c1c71dacc2de22b58094071f62613ef2c7f4c", "html_url": "https://github.com/rust-lang/rust/commit/219c1c71dacc2de22b58094071f62613ef2c7f4c"}], "stats": {"total": 1072, "additions": 1072, "deletions": 0}, "files": [{"sha": "f4fb7bcd76c9972db24ed320e6a82d7afecc30d4", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a637db2aa18f0dc18616c7837de1e60972f20112/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a637db2aa18f0dc18616c7837de1e60972f20112/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=a637db2aa18f0dc18616c7837de1e60972f20112", "patch": "@@ -76,6 +76,7 @@ pub mod sha2;\n \n // And ... other stuff\n \n+pub mod url;\n pub mod ebml;\n pub mod dbg;\n pub mod getopts;"}, {"sha": "563619bb52d60ba182e09468a62d83eaf3eb7a5f", "filename": "src/libextra/url.rs", "status": "added", "additions": 1071, "deletions": 0, "changes": 1071, "blob_url": "https://github.com/rust-lang/rust/blob/a637db2aa18f0dc18616c7837de1e60972f20112/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a637db2aa18f0dc18616c7837de1e60972f20112/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=a637db2aa18f0dc18616c7837de1e60972f20112", "patch": "@@ -0,0 +1,1071 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Types/fns concerning URLs (see RFC 3986)\n+\n+#[allow(missing_doc)];\n+\n+\n+use std::cmp::Eq;\n+use std::io::{Reader, ReaderUtil};\n+use std::io;\n+use std::hashmap::HashMap;\n+use std::to_bytes;\n+use std::uint;\n+\n+#[deriving(Clone, Eq)]\n+struct Url {\n+    scheme: ~str,\n+    user: Option<UserInfo>,\n+    host: ~str,\n+    port: Option<~str>,\n+    path: ~str,\n+    query: Query,\n+    fragment: Option<~str>\n+}\n+\n+#[deriving(Clone, Eq)]\n+struct UserInfo {\n+    user: ~str,\n+    pass: Option<~str>\n+}\n+\n+pub type Query = ~[(~str, ~str)];\n+\n+impl Url {\n+    pub fn new(scheme: ~str,\n+               user: Option<UserInfo>,\n+               host: ~str,\n+               port: Option<~str>,\n+               path: ~str,\n+               query: Query,\n+               fragment: Option<~str>)\n+               -> Url {\n+        Url {\n+            scheme: scheme,\n+            user: user,\n+            host: host,\n+            port: port,\n+            path: path,\n+            query: query,\n+            fragment: fragment,\n+        }\n+    }\n+}\n+\n+impl UserInfo {\n+    pub fn new(user: ~str, pass: Option<~str>) -> UserInfo {\n+        UserInfo { user: user, pass: pass }\n+    }\n+}\n+\n+fn encode_inner(s: &str, full_url: bool) -> ~str {\n+    do io::with_str_reader(s) |rdr| {\n+        let mut out = ~\"\";\n+\n+        while !rdr.eof() {\n+            let ch = rdr.read_byte() as char;\n+            match ch {\n+              // unreserved:\n+              'A' .. 'Z' |\n+              'a' .. 'z' |\n+              '0' .. '9' |\n+              '-' | '.' | '_' | '~' => {\n+                out.push_char(ch);\n+              }\n+              _ => {\n+                  if full_url {\n+                    match ch {\n+                      // gen-delims:\n+                      ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n+\n+                      // sub-delims:\n+                      '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n+                      '+' | ',' | ';' | '=' => {\n+                        out.push_char(ch);\n+                      }\n+\n+                      _ => out.push_str(fmt!(\"%%%X\", ch as uint))\n+                    }\n+                } else {\n+                    out.push_str(fmt!(\"%%%X\", ch as uint));\n+                }\n+              }\n+            }\n+        }\n+\n+        out\n+    }\n+}\n+\n+/**\n+ * Encodes a URI by replacing reserved characters with percent encoded\n+ * character sequences.\n+ *\n+ * This function is compliant with RFC 3986.\n+ */\n+pub fn encode(s: &str) -> ~str {\n+    encode_inner(s, true)\n+}\n+\n+/**\n+ * Encodes a URI component by replacing reserved characters with percent\n+ * encoded character sequences.\n+ *\n+ * This function is compliant with RFC 3986.\n+ */\n+\n+pub fn encode_component(s: &str) -> ~str {\n+    encode_inner(s, false)\n+}\n+\n+fn decode_inner(s: &str, full_url: bool) -> ~str {\n+    do io::with_str_reader(s) |rdr| {\n+        let mut out = ~\"\";\n+\n+        while !rdr.eof() {\n+            match rdr.read_char() {\n+              '%' => {\n+                let bytes = rdr.read_bytes(2u);\n+                let ch = uint::parse_bytes(bytes, 16u).get() as char;\n+\n+                if full_url {\n+                    // Only decode some characters:\n+                    match ch {\n+                      // gen-delims:\n+                      ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n+\n+                      // sub-delims:\n+                      '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n+                      '+' | ',' | ';' | '=' => {\n+                        out.push_char('%');\n+                        out.push_char(bytes[0u] as char);\n+                        out.push_char(bytes[1u] as char);\n+                      }\n+\n+                      ch => out.push_char(ch)\n+                    }\n+                } else {\n+                      out.push_char(ch);\n+                }\n+              }\n+              ch => out.push_char(ch)\n+            }\n+        }\n+\n+        out\n+    }\n+}\n+\n+/**\n+ * Decode a string encoded with percent encoding.\n+ *\n+ * This will only decode escape sequences generated by encode.\n+ */\n+pub fn decode(s: &str) -> ~str {\n+    decode_inner(s, true)\n+}\n+\n+/**\n+ * Decode a string encoded with percent encoding.\n+ */\n+pub fn decode_component(s: &str) -> ~str {\n+    decode_inner(s, false)\n+}\n+\n+fn encode_plus(s: &str) -> ~str {\n+    do io::with_str_reader(s) |rdr| {\n+        let mut out = ~\"\";\n+\n+        while !rdr.eof() {\n+            let ch = rdr.read_byte() as char;\n+            match ch {\n+              'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '_' | '.' | '-' => {\n+                out.push_char(ch);\n+              }\n+              ' ' => out.push_char('+'),\n+              _ => out.push_str(fmt!(\"%%%X\", ch as uint))\n+            }\n+        }\n+\n+        out\n+    }\n+}\n+\n+/**\n+ * Encode a hashmap to the 'application/x-www-form-urlencoded' media type.\n+ */\n+pub fn encode_form_urlencoded(m: &HashMap<~str, ~[~str]>) -> ~str {\n+    let mut out = ~\"\";\n+    let mut first = true;\n+\n+    for m.iter().advance |(key, values)| {\n+        let key = encode_plus(*key);\n+\n+        for values.iter().advance |value| {\n+            if first {\n+                first = false;\n+            } else {\n+                out.push_char('&');\n+                first = false;\n+            }\n+\n+            out.push_str(fmt!(\"%s=%s\", key, encode_plus(*value)));\n+        }\n+    }\n+\n+    out\n+}\n+\n+/**\n+ * Decode a string encoded with the 'application/x-www-form-urlencoded' media\n+ * type into a hashmap.\n+ */\n+pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, ~[~str]> {\n+    do io::with_bytes_reader(s) |rdr| {\n+        let mut m = HashMap::new();\n+        let mut key = ~\"\";\n+        let mut value = ~\"\";\n+        let mut parsing_key = true;\n+\n+        while !rdr.eof() {\n+            match rdr.read_char() {\n+                '&' | ';' => {\n+                    if key != ~\"\" && value != ~\"\" {\n+                        let mut values = match m.pop(&key) {\n+                            Some(values) => values,\n+                            None => ~[],\n+                        };\n+\n+                        values.push(value);\n+                        m.insert(key, values);\n+                    }\n+\n+                    parsing_key = true;\n+                    key = ~\"\";\n+                    value = ~\"\";\n+                }\n+                '=' => parsing_key = false,\n+                ch => {\n+                    let ch = match ch {\n+                        '%' => {\n+                            let bytes = rdr.read_bytes(2u);\n+                            uint::parse_bytes(bytes, 16u).get() as char\n+                        }\n+                        '+' => ' ',\n+                        ch => ch\n+                    };\n+\n+                    if parsing_key {\n+                        key.push_char(ch)\n+                    } else {\n+                        value.push_char(ch)\n+                    }\n+                }\n+            }\n+        }\n+\n+        if key != ~\"\" && value != ~\"\" {\n+            let mut values = match m.pop(&key) {\n+                Some(values) => values,\n+                None => ~[],\n+            };\n+\n+            values.push(value);\n+            m.insert(key, values);\n+        }\n+\n+        m\n+    }\n+}\n+\n+\n+fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n+    let len = s.len();\n+    let mut index = len;\n+    let mut mat = 0;\n+    do io::with_str_reader(s) |rdr| {\n+        let mut ch;\n+        while !rdr.eof() {\n+            ch = rdr.read_byte() as char;\n+            if ch == c {\n+                // found a match, adjust markers\n+                index = rdr.tell()-1;\n+                mat = 1;\n+                break;\n+            }\n+        }\n+    }\n+    if index+mat == len {\n+        return (s.slice(0, index).to_owned(), ~\"\");\n+    } else {\n+        return (s.slice(0, index).to_owned(),\n+             s.slice(index + mat, s.len()).to_owned());\n+    }\n+}\n+\n+fn userinfo_from_str(uinfo: &str) -> UserInfo {\n+    let (user, p) = split_char_first(uinfo, ':');\n+    let pass = if p.is_empty() {\n+        None\n+    } else {\n+        Some(p)\n+    };\n+    return UserInfo::new(user, pass);\n+}\n+\n+fn userinfo_to_str(userinfo: &UserInfo) -> ~str {\n+    match userinfo.pass {\n+        Some(ref pass) => fmt!(\"%s:%s@\", userinfo.user, *pass),\n+        None => fmt!(\"%s@\", userinfo.user),\n+    }\n+}\n+\n+fn query_from_str(rawquery: &str) -> Query {\n+    let mut query: Query = ~[];\n+    if !rawquery.is_empty() {\n+        for rawquery.split_iter('&').advance |p| {\n+            let (k, v) = split_char_first(p, '=');\n+            query.push((decode_component(k), decode_component(v)));\n+        };\n+    }\n+    return query;\n+}\n+\n+pub fn query_to_str(query: &Query) -> ~str {\n+    let mut strvec = ~[];\n+    for query.iter().advance |kv| {\n+        match kv {\n+            &(ref k, ref v) => {\n+                strvec.push(fmt!(\"%s=%s\",\n+                    encode_component(*k),\n+                    encode_component(*v))\n+                );\n+            }\n+        }\n+    }\n+    return strvec.connect(\"&\");\n+}\n+\n+// returns the scheme and the rest of the url, or a parsing error\n+pub fn get_scheme(rawurl: &str) -> Result<(~str, ~str), ~str> {\n+    for rawurl.iter().enumerate().advance |(i,c)| {\n+        match c {\n+          'A' .. 'Z' | 'a' .. 'z' => loop,\n+          '0' .. '9' | '+' | '-' | '.' => {\n+            if i == 0 {\n+                return Err(~\"url: Scheme must begin with a letter.\");\n+            }\n+            loop;\n+          }\n+          ':' => {\n+            if i == 0 {\n+                return Err(~\"url: Scheme cannot be empty.\");\n+            } else {\n+                return Ok((rawurl.slice(0,i).to_owned(),\n+                                rawurl.slice(i+1,rawurl.len()).to_owned()));\n+            }\n+          }\n+          _ => {\n+            return Err(~\"url: Invalid character in scheme.\");\n+          }\n+        }\n+    };\n+    return Err(~\"url: Scheme must be terminated with a colon.\");\n+}\n+\n+#[deriving(Clone, Eq)]\n+enum Input {\n+    Digit, // all digits\n+    Hex, // digits and letters a-f\n+    Unreserved // all other legal characters\n+}\n+\n+// returns userinfo, host, port, and unparsed part, or an error\n+fn get_authority(rawurl: &str) ->\n+    Result<(Option<UserInfo>, ~str, Option<~str>, ~str), ~str> {\n+    if !rawurl.starts_with(\"//\") {\n+        // there is no authority.\n+        return Ok((None, ~\"\", None, rawurl.to_str()));\n+    }\n+\n+    enum State {\n+        Start, // starting state\n+        PassHostPort, // could be in user or port\n+        Ip6Port, // either in ipv6 host or port\n+        Ip6Host, // are in an ipv6 host\n+        InHost, // are in a host - may be ipv6, but don't know yet\n+        InPort // are in port\n+    }\n+\n+    let len = rawurl.len();\n+    let mut st = Start;\n+    let mut in = Digit; // most restricted, start here.\n+\n+    let mut userinfo = None;\n+    let mut host = ~\"\";\n+    let mut port = None;\n+\n+    let mut colon_count = 0;\n+    let mut pos = 0;\n+    let mut begin = 2;\n+    let mut end = len;\n+\n+    for rawurl.iter().enumerate().advance |(i,c)| {\n+        if i < 2 { loop; } // ignore the leading //\n+\n+        // deal with input class first\n+        match c {\n+          '0' .. '9' => (),\n+          'A' .. 'F' | 'a' .. 'f' => {\n+            if in == Digit {\n+                in = Hex;\n+            }\n+          }\n+          'G' .. 'Z' | 'g' .. 'z' | '-' | '.' | '_' | '~' | '%' |\n+          '&' |'\\'' | '(' | ')' | '+' | '!' | '*' | ',' | ';' | '=' => {\n+            in = Unreserved;\n+          }\n+          ':' | '@' | '?' | '#' | '/' => {\n+            // separators, don't change anything\n+          }\n+          _ => {\n+            return Err(~\"Illegal character in authority\");\n+          }\n+        }\n+\n+        // now process states\n+        match c {\n+          ':' => {\n+            colon_count += 1;\n+            match st {\n+              Start => {\n+                pos = i;\n+                st = PassHostPort;\n+              }\n+              PassHostPort => {\n+                // multiple colons means ipv6 address.\n+                if in == Unreserved {\n+                    return Err(\n+                        ~\"Illegal characters in IPv6 address.\");\n+                }\n+                st = Ip6Host;\n+              }\n+              InHost => {\n+                pos = i;\n+                // can't be sure whether this is an ipv6 address or a port\n+                if in == Unreserved {\n+                    return Err(~\"Illegal characters in authority.\");\n+                }\n+                st = Ip6Port;\n+              }\n+              Ip6Port => {\n+                if in == Unreserved {\n+                    return Err(~\"Illegal characters in authority.\");\n+                }\n+                st = Ip6Host;\n+              }\n+              Ip6Host => {\n+                if colon_count > 7 {\n+                    host = rawurl.slice(begin, i).to_owned();\n+                    pos = i;\n+                    st = InPort;\n+                }\n+              }\n+              _ => {\n+                return Err(~\"Invalid ':' in authority.\");\n+              }\n+            }\n+            in = Digit; // reset input class\n+          }\n+\n+          '@' => {\n+            in = Digit; // reset input class\n+            colon_count = 0; // reset count\n+            match st {\n+              Start => {\n+                let user = rawurl.slice(begin, i).to_owned();\n+                userinfo = Some(UserInfo::new(user, None));\n+                st = InHost;\n+              }\n+              PassHostPort => {\n+                let user = rawurl.slice(begin, pos).to_owned();\n+                let pass = rawurl.slice(pos+1, i).to_owned();\n+                userinfo = Some(UserInfo::new(user, Some(pass)));\n+                st = InHost;\n+              }\n+              _ => {\n+                return Err(~\"Invalid '@' in authority.\");\n+              }\n+            }\n+            begin = i+1;\n+          }\n+\n+          '?' | '#' | '/' => {\n+            end = i;\n+            break;\n+          }\n+          _ => ()\n+        }\n+        end = i;\n+    }\n+\n+    let end = end; // make end immutable so it can be captured\n+\n+    let host_is_end_plus_one: &fn() -> bool = || {\n+        let xs = ['?', '#', '/'];\n+        end+1 == len\n+            && !xs.iter().any(|x| *x == (rawurl[end] as char))\n+    };\n+\n+    // finish up\n+    match st {\n+      Start => {\n+        if host_is_end_plus_one() {\n+            host = rawurl.slice(begin, end+1).to_owned();\n+        } else {\n+            host = rawurl.slice(begin, end).to_owned();\n+        }\n+      }\n+      PassHostPort | Ip6Port => {\n+        if in != Digit {\n+            return Err(~\"Non-digit characters in port.\");\n+        }\n+        host = rawurl.slice(begin, pos).to_owned();\n+        port = Some(rawurl.slice(pos+1, end).to_owned());\n+      }\n+      Ip6Host | InHost => {\n+        host = rawurl.slice(begin, end).to_owned();\n+      }\n+      InPort => {\n+        if in != Digit {\n+            return Err(~\"Non-digit characters in port.\");\n+        }\n+        port = Some(rawurl.slice(pos+1, end).to_owned());\n+      }\n+    }\n+\n+    let rest = if host_is_end_plus_one() { ~\"\" }\n+    else { rawurl.slice(end, len).to_owned() };\n+    return Ok((userinfo, host, port, rest));\n+}\n+\n+\n+// returns the path and unparsed part of url, or an error\n+fn get_path(rawurl: &str, authority: bool) ->\n+    Result<(~str, ~str), ~str> {\n+    let len = rawurl.len();\n+    let mut end = len;\n+    for rawurl.iter().enumerate().advance |(i,c)| {\n+        match c {\n+          'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '&' |'\\'' | '(' | ')' | '.'\n+          | '@' | ':' | '%' | '/' | '+' | '!' | '*' | ',' | ';' | '='\n+          | '_' | '-' => {\n+            loop;\n+          }\n+          '?' | '#' => {\n+            end = i;\n+            break;\n+          }\n+          _ => return Err(~\"Invalid character in path.\")\n+        }\n+    }\n+\n+    if authority {\n+        if end != 0 && !rawurl.starts_with(\"/\") {\n+            return Err(~\"Non-empty path must begin with\\\n+                               '/' in presence of authority.\");\n+        }\n+    }\n+\n+    return Ok((decode_component(rawurl.slice(0, end)),\n+                    rawurl.slice(end, len).to_owned()));\n+}\n+\n+// returns the parsed query and the fragment, if present\n+fn get_query_fragment(rawurl: &str) ->\n+    Result<(Query, Option<~str>), ~str> {\n+    if !rawurl.starts_with(\"?\") {\n+        if rawurl.starts_with(\"#\") {\n+            let f = decode_component(rawurl.slice(\n+                                                1,\n+                                                rawurl.len()));\n+            return Ok((~[], Some(f)));\n+        } else {\n+            return Ok((~[], None));\n+        }\n+    }\n+    let (q, r) = split_char_first(rawurl.slice(1, rawurl.len()), '#');\n+    let f = if r.len() != 0 {\n+        Some(decode_component(r)) } else { None };\n+    return Ok((query_from_str(q), f));\n+}\n+\n+/**\n+ * Parse a `str` to a `url`\n+ *\n+ * # Arguments\n+ *\n+ * `rawurl` - a string representing a full url, including scheme.\n+ *\n+ * # Returns\n+ *\n+ * a `url` that contains the parsed representation of the url.\n+ *\n+ */\n+\n+pub fn from_str(rawurl: &str) -> Result<Url, ~str> {\n+    // scheme\n+    let (scheme, rest) = match get_scheme(rawurl) {\n+        Ok(val) => val,\n+        Err(e) => return Err(e),\n+    };\n+\n+    // authority\n+    let (userinfo, host, port, rest) = match get_authority(rest) {\n+        Ok(val) => val,\n+        Err(e) => return Err(e),\n+    };\n+\n+    // path\n+    let has_authority = if host == ~\"\" { false } else { true };\n+    let (path, rest) = match get_path(rest, has_authority) {\n+        Ok(val) => val,\n+        Err(e) => return Err(e),\n+    };\n+\n+    // query and fragment\n+    let (query, fragment) = match get_query_fragment(rest) {\n+        Ok(val) => val,\n+        Err(e) => return Err(e),\n+    };\n+\n+    Ok(Url::new(scheme, userinfo, host, port, path, query, fragment))\n+}\n+\n+impl FromStr for Url {\n+    fn from_str(s: &str) -> Option<Url> {\n+        match from_str(s) {\n+            Ok(url) => Some(url),\n+            Err(_) => None\n+        }\n+    }\n+}\n+\n+/**\n+ * Format a `url` as a string\n+ *\n+ * # Arguments\n+ *\n+ * `url` - a url.\n+ *\n+ * # Returns\n+ *\n+ * a `str` that contains the formatted url. Note that this will usually\n+ * be an inverse of `from_str` but might strip out unneeded separators.\n+ * for example, \"http://somehost.com?\", when parsed and formatted, will\n+ * result in just \"http://somehost.com\".\n+ *\n+ */\n+pub fn to_str(url: &Url) -> ~str {\n+    let user = match url.user {\n+        Some(ref user) => userinfo_to_str(user),\n+        None => ~\"\",\n+    };\n+\n+    let authority = if url.host.is_empty() {\n+        ~\"\"\n+    } else {\n+        fmt!(\"//%s%s\", user, url.host)\n+    };\n+\n+    let query = if url.query.is_empty() {\n+        ~\"\"\n+    } else {\n+        fmt!(\"?%s\", query_to_str(&url.query))\n+    };\n+\n+    let fragment = match url.fragment {\n+        Some(ref fragment) => fmt!(\"#%s\", encode_component(*fragment)),\n+        None => ~\"\",\n+    };\n+\n+    fmt!(\"%s:%s%s%s%s\", url.scheme, authority, url.path, query, fragment)\n+}\n+\n+impl ToStr for Url {\n+    pub fn to_str(&self) -> ~str {\n+        to_str(self)\n+    }\n+}\n+\n+impl IterBytes for Url {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        self.to_str().iter_bytes(lsb0, f)\n+    }\n+}\n+\n+// Put a few tests outside of the 'test' module so they can test the internal\n+// functions and those functions don't need 'pub'\n+\n+#[test]\n+fn test_split_char_first() {\n+    let (u,v) = split_char_first(\"hello, sweet world\", ',');\n+    assert_eq!(u, ~\"hello\");\n+    assert_eq!(v, ~\" sweet world\");\n+\n+    let (u,v) = split_char_first(\"hello sweet world\", ',');\n+    assert_eq!(u, ~\"hello sweet world\");\n+    assert_eq!(v, ~\"\");\n+}\n+\n+#[test]\n+fn test_get_authority() {\n+    let (u, h, p, r) = get_authority(\n+        \"//user:pass@rust-lang.org/something\").unwrap();\n+    assert_eq!(u, Some(UserInfo::new(~\"user\", Some(~\"pass\"))));\n+    assert_eq!(h, ~\"rust-lang.org\");\n+    assert!(p.is_none());\n+    assert_eq!(r, ~\"/something\");\n+\n+    let (u, h, p, r) = get_authority(\n+        \"//rust-lang.org:8000?something\").unwrap();\n+    assert!(u.is_none());\n+    assert_eq!(h, ~\"rust-lang.org\");\n+    assert_eq!(p, Some(~\"8000\"));\n+    assert_eq!(r, ~\"?something\");\n+\n+    let (u, h, p, r) = get_authority(\n+        \"//rust-lang.org#blah\").unwrap();\n+    assert!(u.is_none());\n+    assert_eq!(h, ~\"rust-lang.org\");\n+    assert!(p.is_none());\n+    assert_eq!(r, ~\"#blah\");\n+\n+    // ipv6 tests\n+    let (_, h, _, _) = get_authority(\n+        \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334#blah\").unwrap();\n+    assert_eq!(h, ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n+\n+    let (_, h, p, _) = get_authority(\n+        \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\").unwrap();\n+    assert_eq!(h, ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n+    assert_eq!(p, Some(~\"8000\"));\n+\n+    let (u, h, p, _) = get_authority(\n+        \"//us:p@2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\"\n+    ).unwrap();\n+    assert_eq!(u, Some(UserInfo::new(~\"us\", Some(~\"p\"))));\n+    assert_eq!(h, ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n+    assert_eq!(p, Some(~\"8000\"));\n+\n+    // invalid authorities;\n+    assert!(get_authority(\"//user:pass@rust-lang:something\").is_err());\n+    assert!(get_authority(\"//user@rust-lang:something:/path\").is_err());\n+    assert!(get_authority(\n+        \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:800a\").is_err());\n+    assert!(get_authority(\n+        \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000:00\").is_err());\n+\n+    // these parse as empty, because they don't start with '//'\n+    let (_, h, _, _) = get_authority(\"user:pass@rust-lang\").unwrap();\n+    assert_eq!(h, ~\"\");\n+    let (_, h, _, _) = get_authority(\"rust-lang.org\").unwrap();\n+    assert_eq!(h, ~\"\");\n+}\n+\n+#[test]\n+fn test_get_path() {\n+    let (p, r) = get_path(\"/something+%20orother\", true).unwrap();\n+    assert_eq!(p, ~\"/something+ orother\");\n+    assert_eq!(r, ~\"\");\n+    let (p, r) = get_path(\"test@email.com#fragment\", false).unwrap();\n+    assert_eq!(p, ~\"test@email.com\");\n+    assert_eq!(r, ~\"#fragment\");\n+    let (p, r) = get_path(\"/gen/:addr=?q=v\", false).unwrap();\n+    assert_eq!(p, ~\"/gen/:addr=\");\n+    assert_eq!(r, ~\"?q=v\");\n+\n+    //failure cases\n+    assert!(get_path(\"something?q\", true).is_err());\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    use super::*;\n+\n+    use std::hashmap::HashMap;\n+\n+    #[test]\n+    fn test_url_parse() {\n+        let url = ~\"http://user:pass@rust-lang.org/doc?s=v#something\";\n+\n+        let up = from_str(url);\n+        let u = up.unwrap();\n+        assert!(u.scheme == ~\"http\");\n+        let userinfo = u.user.get_ref();\n+        assert!(userinfo.user == ~\"user\");\n+        assert!(userinfo.pass.get_ref() == &~\"pass\");\n+        assert!(u.host == ~\"rust-lang.org\");\n+        assert!(u.path == ~\"/doc\");\n+        assert!(u.query == ~[(~\"s\", ~\"v\")]);\n+        assert!(u.fragment.get_ref() == &~\"something\");\n+    }\n+\n+    #[test]\n+    fn test_url_parse_host_slash() {\n+        let urlstr = ~\"http://0.42.42.42/\";\n+        let url = from_str(urlstr).unwrap();\n+        assert!(url.host == ~\"0.42.42.42\");\n+        assert!(url.path == ~\"/\");\n+    }\n+\n+    #[test]\n+    fn test_url_with_underscores() {\n+        let urlstr = ~\"http://dotcom.com/file_name.html\";\n+        let url = from_str(urlstr).unwrap();\n+        assert!(url.path == ~\"/file_name.html\");\n+    }\n+\n+    #[test]\n+    fn test_url_with_dashes() {\n+        let urlstr = ~\"http://dotcom.com/file-name.html\";\n+        let url = from_str(urlstr).unwrap();\n+        assert!(url.path == ~\"/file-name.html\");\n+    }\n+\n+    #[test]\n+    fn test_no_scheme() {\n+        assert!(get_scheme(\"noschemehere.html\").is_err());\n+    }\n+\n+    #[test]\n+    fn test_invalid_scheme_errors() {\n+        assert!(from_str(\"99://something\").is_err());\n+        assert!(from_str(\"://something\").is_err());\n+    }\n+\n+    #[test]\n+    fn test_full_url_parse_and_format() {\n+        let url = ~\"http://user:pass@rust-lang.org/doc?s=v#something\";\n+        assert_eq!(from_str(url).unwrap().to_str(), url);\n+    }\n+\n+    #[test]\n+    fn test_userless_url_parse_and_format() {\n+        let url = ~\"http://rust-lang.org/doc?s=v#something\";\n+        assert_eq!(from_str(url).unwrap().to_str(), url);\n+    }\n+\n+    #[test]\n+    fn test_queryless_url_parse_and_format() {\n+        let url = ~\"http://user:pass@rust-lang.org/doc#something\";\n+        assert_eq!(from_str(url).unwrap().to_str(), url);\n+    }\n+\n+    #[test]\n+    fn test_empty_query_url_parse_and_format() {\n+        let url = ~\"http://user:pass@rust-lang.org/doc?#something\";\n+        let should_be = ~\"http://user:pass@rust-lang.org/doc#something\";\n+        assert_eq!(from_str(url).unwrap().to_str(), should_be);\n+    }\n+\n+    #[test]\n+    fn test_fragmentless_url_parse_and_format() {\n+        let url = ~\"http://user:pass@rust-lang.org/doc?q=v\";\n+        assert_eq!(from_str(url).unwrap().to_str(), url);\n+    }\n+\n+    #[test]\n+    fn test_minimal_url_parse_and_format() {\n+        let url = ~\"http://rust-lang.org/doc\";\n+        assert_eq!(from_str(url).unwrap().to_str(), url);\n+    }\n+\n+    #[test]\n+    fn test_scheme_host_only_url_parse_and_format() {\n+        let url = ~\"http://rust-lang.org\";\n+        assert_eq!(from_str(url).unwrap().to_str(), url);\n+    }\n+\n+    #[test]\n+    fn test_pathless_url_parse_and_format() {\n+        let url = ~\"http://user:pass@rust-lang.org?q=v#something\";\n+        assert_eq!(from_str(url).unwrap().to_str(), url);\n+    }\n+\n+    #[test]\n+    fn test_scheme_host_fragment_only_url_parse_and_format() {\n+        let url = ~\"http://rust-lang.org#something\";\n+        assert_eq!(from_str(url).unwrap().to_str(), url);\n+    }\n+\n+    #[test]\n+    fn test_url_component_encoding() {\n+        let url = ~\"http://rust-lang.org/doc%20uments?ba%25d%20=%23%26%2B\";\n+        let u = from_str(url).unwrap();\n+        assert!(u.path == ~\"/doc uments\");\n+        assert!(u.query == ~[(~\"ba%d \", ~\"#&+\")]);\n+    }\n+\n+    #[test]\n+    fn test_url_without_authority() {\n+        let url = ~\"mailto:test@email.com\";\n+        assert_eq!(from_str(url).unwrap().to_str(), url);\n+    }\n+\n+    #[test]\n+    fn test_encode() {\n+        assert_eq!(encode(\"\"), ~\"\");\n+        assert_eq!(encode(\"http://example.com\"), ~\"http://example.com\");\n+        assert_eq!(encode(\"foo bar% baz\"), ~\"foo%20bar%25%20baz\");\n+        assert_eq!(encode(\" \"), ~\"%20\");\n+        assert_eq!(encode(\"!\"), ~\"!\");\n+        assert_eq!(encode(\"\\\"\"), ~\"\\\"\");\n+        assert_eq!(encode(\"#\"), ~\"#\");\n+        assert_eq!(encode(\"$\"), ~\"$\");\n+        assert_eq!(encode(\"%\"), ~\"%25\");\n+        assert_eq!(encode(\"&\"), ~\"&\");\n+        assert_eq!(encode(\"'\"), ~\"%27\");\n+        assert_eq!(encode(\"(\"), ~\"(\");\n+        assert_eq!(encode(\")\"), ~\")\");\n+        assert_eq!(encode(\"*\"), ~\"*\");\n+        assert_eq!(encode(\"+\"), ~\"+\");\n+        assert_eq!(encode(\",\"), ~\",\");\n+        assert_eq!(encode(\"/\"), ~\"/\");\n+        assert_eq!(encode(\":\"), ~\":\");\n+        assert_eq!(encode(\";\"), ~\";\");\n+        assert_eq!(encode(\"=\"), ~\"=\");\n+        assert_eq!(encode(\"?\"), ~\"?\");\n+        assert_eq!(encode(\"@\"), ~\"@\");\n+        assert_eq!(encode(\"[\"), ~\"[\");\n+        assert_eq!(encode(\"]\"), ~\"]\");\n+    }\n+\n+    #[test]\n+    fn test_encode_component() {\n+        assert_eq!(encode_component(\"\"), ~\"\");\n+        assert!(encode_component(\"http://example.com\") ==\n+            ~\"http%3A%2F%2Fexample.com\");\n+        assert!(encode_component(\"foo bar% baz\") ==\n+            ~\"foo%20bar%25%20baz\");\n+        assert_eq!(encode_component(\" \"), ~\"%20\");\n+        assert_eq!(encode_component(\"!\"), ~\"%21\");\n+        assert_eq!(encode_component(\"#\"), ~\"%23\");\n+        assert_eq!(encode_component(\"$\"), ~\"%24\");\n+        assert_eq!(encode_component(\"%\"), ~\"%25\");\n+        assert_eq!(encode_component(\"&\"), ~\"%26\");\n+        assert_eq!(encode_component(\"'\"), ~\"%27\");\n+        assert_eq!(encode_component(\"(\"), ~\"%28\");\n+        assert_eq!(encode_component(\")\"), ~\"%29\");\n+        assert_eq!(encode_component(\"*\"), ~\"%2A\");\n+        assert_eq!(encode_component(\"+\"), ~\"%2B\");\n+        assert_eq!(encode_component(\",\"), ~\"%2C\");\n+        assert_eq!(encode_component(\"/\"), ~\"%2F\");\n+        assert_eq!(encode_component(\":\"), ~\"%3A\");\n+        assert_eq!(encode_component(\";\"), ~\"%3B\");\n+        assert_eq!(encode_component(\"=\"), ~\"%3D\");\n+        assert_eq!(encode_component(\"?\"), ~\"%3F\");\n+        assert_eq!(encode_component(\"@\"), ~\"%40\");\n+        assert_eq!(encode_component(\"[\"), ~\"%5B\");\n+        assert_eq!(encode_component(\"]\"), ~\"%5D\");\n+    }\n+\n+    #[test]\n+    fn test_decode() {\n+        assert_eq!(decode(\"\"), ~\"\");\n+        assert_eq!(decode(\"abc/def 123\"), ~\"abc/def 123\");\n+        assert_eq!(decode(\"abc%2Fdef%20123\"), ~\"abc%2Fdef 123\");\n+        assert_eq!(decode(\"%20\"), ~\" \");\n+        assert_eq!(decode(\"%21\"), ~\"%21\");\n+        assert_eq!(decode(\"%22\"), ~\"%22\");\n+        assert_eq!(decode(\"%23\"), ~\"%23\");\n+        assert_eq!(decode(\"%24\"), ~\"%24\");\n+        assert_eq!(decode(\"%25\"), ~\"%\");\n+        assert_eq!(decode(\"%26\"), ~\"%26\");\n+        assert_eq!(decode(\"%27\"), ~\"'\");\n+        assert_eq!(decode(\"%28\"), ~\"%28\");\n+        assert_eq!(decode(\"%29\"), ~\"%29\");\n+        assert_eq!(decode(\"%2A\"), ~\"%2A\");\n+        assert_eq!(decode(\"%2B\"), ~\"%2B\");\n+        assert_eq!(decode(\"%2C\"), ~\"%2C\");\n+        assert_eq!(decode(\"%2F\"), ~\"%2F\");\n+        assert_eq!(decode(\"%3A\"), ~\"%3A\");\n+        assert_eq!(decode(\"%3B\"), ~\"%3B\");\n+        assert_eq!(decode(\"%3D\"), ~\"%3D\");\n+        assert_eq!(decode(\"%3F\"), ~\"%3F\");\n+        assert_eq!(decode(\"%40\"), ~\"%40\");\n+        assert_eq!(decode(\"%5B\"), ~\"%5B\");\n+        assert_eq!(decode(\"%5D\"), ~\"%5D\");\n+    }\n+\n+    #[test]\n+    fn test_decode_component() {\n+        assert_eq!(decode_component(\"\"), ~\"\");\n+        assert_eq!(decode_component(\"abc/def 123\"), ~\"abc/def 123\");\n+        assert_eq!(decode_component(\"abc%2Fdef%20123\"), ~\"abc/def 123\");\n+        assert_eq!(decode_component(\"%20\"), ~\" \");\n+        assert_eq!(decode_component(\"%21\"), ~\"!\");\n+        assert_eq!(decode_component(\"%22\"), ~\"\\\"\");\n+        assert_eq!(decode_component(\"%23\"), ~\"#\");\n+        assert_eq!(decode_component(\"%24\"), ~\"$\");\n+        assert_eq!(decode_component(\"%25\"), ~\"%\");\n+        assert_eq!(decode_component(\"%26\"), ~\"&\");\n+        assert_eq!(decode_component(\"%27\"), ~\"'\");\n+        assert_eq!(decode_component(\"%28\"), ~\"(\");\n+        assert_eq!(decode_component(\"%29\"), ~\")\");\n+        assert_eq!(decode_component(\"%2A\"), ~\"*\");\n+        assert_eq!(decode_component(\"%2B\"), ~\"+\");\n+        assert_eq!(decode_component(\"%2C\"), ~\",\");\n+        assert_eq!(decode_component(\"%2F\"), ~\"/\");\n+        assert_eq!(decode_component(\"%3A\"), ~\":\");\n+        assert_eq!(decode_component(\"%3B\"), ~\";\");\n+        assert_eq!(decode_component(\"%3D\"), ~\"=\");\n+        assert_eq!(decode_component(\"%3F\"), ~\"?\");\n+        assert_eq!(decode_component(\"%40\"), ~\"@\");\n+        assert_eq!(decode_component(\"%5B\"), ~\"[\");\n+        assert_eq!(decode_component(\"%5D\"), ~\"]\");\n+    }\n+\n+    #[test]\n+    fn test_encode_form_urlencoded() {\n+        let mut m = HashMap::new();\n+        assert_eq!(encode_form_urlencoded(&m), ~\"\");\n+\n+        m.insert(~\"\", ~[]);\n+        m.insert(~\"foo\", ~[]);\n+        assert_eq!(encode_form_urlencoded(&m), ~\"\");\n+\n+        let mut m = HashMap::new();\n+        m.insert(~\"foo\", ~[~\"bar\", ~\"123\"]);\n+        assert_eq!(encode_form_urlencoded(&m), ~\"foo=bar&foo=123\");\n+\n+        let mut m = HashMap::new();\n+        m.insert(~\"foo bar\", ~[~\"abc\", ~\"12 = 34\"]);\n+        assert!(encode_form_urlencoded(&m) ==\n+            ~\"foo+bar=abc&foo+bar=12+%3D+34\");\n+    }\n+\n+    #[test]\n+    fn test_decode_form_urlencoded() {\n+        // FIXME #4449: Commented out because this causes an ICE, but only\n+        // on FreeBSD\n+        /*\n+        assert_eq!(decode_form_urlencoded([]).len(), 0);\n+\n+        let s = \"a=1&foo+bar=abc&foo+bar=12+%3D+34\".as_bytes();\n+        let form = decode_form_urlencoded(s);\n+        assert_eq!(form.len(), 2);\n+        assert_eq!(form.get_ref(&~\"a\"), &~[~\"1\"]);\n+        assert_eq!(form.get_ref(&~\"foo bar\"), &~[~\"abc\", ~\"12 = 34\"]);\n+        */\n+    }\n+}"}]}