{"sha": "2833ca478c19d2f8f150570a6d60b93488debdcc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4MzNjYTQ3OGMxOWQyZjhmMTUwNTcwYTZkNjBiOTM0ODhkZWJkY2M=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-16T14:27:50Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-16T15:17:23Z"}, "message": "reorder args to the various vec, option fns so blk comes last", "tree": {"sha": "041865de99eb77a1d4504ee29c38691a7f872f34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/041865de99eb77a1d4504ee29c38691a7f872f34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2833ca478c19d2f8f150570a6d60b93488debdcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2833ca478c19d2f8f150570a6d60b93488debdcc", "html_url": "https://github.com/rust-lang/rust/commit/2833ca478c19d2f8f150570a6d60b93488debdcc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2833ca478c19d2f8f150570a6d60b93488debdcc/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a3626161d5ebb1d2c6839773b0e533d3ec4589c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a3626161d5ebb1d2c6839773b0e533d3ec4589c", "html_url": "https://github.com/rust-lang/rust/commit/0a3626161d5ebb1d2c6839773b0e533d3ec4589c"}], "stats": {"total": 339, "additions": 170, "deletions": 169}, "files": [{"sha": "4fb7488a8f85b733f4ead31243890cbc58112eee", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -155,13 +155,13 @@ fn install_one_crate(c: cargo, _path: str, cf: str, _p: pkg) {\n         name = str::slice(name, 0u, ri as uint);\n     }\n     log #fmt[\"Installing: %s\", name];\n-    let old = vec::map({|x| str::slice(x, 2u, str::byte_len(x))},\n-                       fs::list_dir(\".\"));\n+    let old = vec::map(fs::list_dir(\".\"),\n+                       {|x| str::slice(x, 2u, str::byte_len(x))});\n     run::run_program(\"rustc\", [name + \".rc\"]);\n-    let new = vec::map({|x| str::slice(x, 2u, str::byte_len(x))},\n-                       fs::list_dir(\".\"));\n+    let new = vec::map(fs::list_dir(\".\"),\n+                       {|x| str::slice(x, 2u, str::byte_len(x))});\n     let created =\n-        vec::filter::<str>({ |n| !vec::member::<str>(n, old) }, new);\n+        vec::filter::<str>(new, { |n| !vec::member::<str>(n, old) });\n     let exec_suffix = os::exec_suffix();\n     for ct: str in created {\n         if (exec_suffix != \"\" && str::ends_with(ct, exec_suffix)) ||\n@@ -184,7 +184,7 @@ fn install_source(c: cargo, path: str) {\n     log #fmt[\"contents: %s\", str::connect(contents, \", \")];\n \n     let cratefiles =\n-        vec::filter::<str>({ |n| str::ends_with(n, \".rc\") }, contents);\n+        vec::filter::<str>(contents, { |n| str::ends_with(n, \".rc\") });\n \n     if vec::is_empty(cratefiles) {\n         fail \"This doesn't look like a rust package (no .rc files).\";"}, {"sha": "7aa271090dd0709454f0b5cd46b52ec2d9ebaa2d", "filename": "src/comp/back/rpath.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Frpath.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -47,7 +47,7 @@ fn get_sysroot_absolute_rt_lib(sess: session::session) -> fs::path {\n }\n \n fn rpaths_to_flags(rpaths: [str]) -> [str] {\n-    vec::map({ |rpath| #fmt(\"-Wl,-rpath,%s\",rpath)}, rpaths)\n+    vec::map(rpaths, { |rpath| #fmt(\"-Wl,-rpath,%s\",rpath)})\n }\n \n fn get_rpaths(os: session::os, cwd: fs::path, sysroot: fs::path,\n@@ -96,7 +96,7 @@ fn get_rpaths_relative_to_output(os: session::os,\n                                  cwd: fs::path,\n                                  output: fs::path,\n                                  libs: [fs::path]) -> [str] {\n-    vec::map(bind get_rpath_relative_to_output(os, cwd, output, _), libs)\n+    vec::map(libs, bind get_rpath_relative_to_output(os, cwd, output, _))\n }\n \n fn get_rpath_relative_to_output(os: session::os,\n@@ -150,7 +150,7 @@ fn get_relative_to(abs1: fs::path, abs2: fs::path) -> fs::path {\n }\n \n fn get_absolute_rpaths(cwd: fs::path, libs: [fs::path]) -> [str] {\n-    vec::map(bind get_absolute_rpath(cwd, _), libs)\n+    vec::map(libs, bind get_absolute_rpath(cwd, _))\n }\n \n fn get_absolute_rpath(cwd: fs::path, &&lib: fs::path) -> str {"}, {"sha": "a97afa7cb83318f0cd23082d3fbdd790c2533a62", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -650,10 +650,9 @@ fn main(args: [str]) {\n     let ofile = getopts::opt_maybe_str(match, \"o\");\n     let cfg = build_configuration(sess, binary, ifile);\n     let pretty =\n-        option::map::<str,\n-                      pp_mode>(bind parse_pretty(sess, _),\n-                               getopts::opt_default(match, \"pretty\",\n-                                                    \"normal\"));\n+        option::map(getopts::opt_default(match, \"pretty\",\n+                                         \"normal\"),\n+                    bind parse_pretty(sess, _));\n     alt pretty {\n       some::<pp_mode>(ppm) { pretty_print_input(sess, cfg, ifile, ppm); ret; }\n       none::<pp_mode>. {/* continue */ }"}, {"sha": "6992c7312052cd129aa5973851d6000a903d22df", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -50,7 +50,7 @@ fn find_attrs_by_name(attrs: [ast::attribute], name: ast::ident) ->\n                      option::some(a)\n                  } else { option::none }\n              }(_, name);\n-    ret vec::filter_map(filter, attrs);\n+    ret vec::filter_map(attrs, filter);\n }\n \n fn get_attr_name(attr: ast::attribute) -> ast::ident {\n@@ -66,7 +66,7 @@ fn find_meta_items_by_name(metas: [@ast::meta_item], name: ast::ident) ->\n                      option::some(m)\n                  } else { option::none }\n              }(_, name);\n-    ret vec::filter_map(filter, metas);\n+    ret vec::filter_map(metas, filter);\n }\n \n fn get_meta_item_name(meta: @ast::meta_item) -> ast::ident {\n@@ -186,7 +186,7 @@ fn remove_meta_items_by_name(items: [@ast::meta_item], name: str) ->\n                  } else { option::none }\n              }(_, name);\n \n-    ret vec::filter_map(filter, items);\n+    ret vec::filter_map(items, filter);\n }\n \n fn require_unique_names(sess: session::session, metas: [@ast::meta_item]) {"}, {"sha": "13f6f07849e2af18142525961091da3a10eb4257", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -29,9 +29,9 @@ fn filter_item(cfg: ast::crate_cfg, &&item: @ast::item) ->\n fn fold_mod(cfg: ast::crate_cfg, m: ast::_mod, fld: fold::ast_fold) ->\n    ast::_mod {\n     let filter = bind filter_item(cfg, _);\n-    let filtered_items = vec::filter_map(filter, m.items);\n-    ret {view_items: vec::map(fld.fold_view_item, m.view_items),\n-         items: vec::map(fld.fold_item, filtered_items)};\n+    let filtered_items = vec::filter_map(m.items, filter);\n+    ret {view_items: vec::map(m.view_items, fld.fold_view_item),\n+         items: vec::map(filtered_items, fld.fold_item)};\n }\n \n fn filter_native_item(cfg: ast::crate_cfg, &&item: @ast::native_item) ->\n@@ -44,8 +44,8 @@ fn filter_native_item(cfg: ast::crate_cfg, &&item: @ast::native_item) ->\n fn fold_native_mod(cfg: ast::crate_cfg, nm: ast::native_mod,\n                    fld: fold::ast_fold) -> ast::native_mod {\n     let filter = bind filter_native_item(cfg, _);\n-    let filtered_items = vec::filter_map(filter, nm.items);\n-    ret {view_items: vec::map(fld.fold_view_item, nm.view_items),\n+    let filtered_items = vec::filter_map(nm.items, filter);\n+    ret {view_items: vec::map(nm.view_items, fld.fold_view_item),\n          items: filtered_items};\n }\n \n@@ -69,10 +69,10 @@ fn filter_stmt(cfg: ast::crate_cfg, &&stmt: @ast::stmt) ->\n fn fold_block(cfg: ast::crate_cfg, b: ast::blk_, fld: fold::ast_fold) ->\n    ast::blk_ {\n     let filter = bind filter_stmt(cfg, _);\n-    let filtered_stmts = vec::filter_map(filter, b.stmts);\n+    let filtered_stmts = vec::filter_map(b.stmts, filter);\n     ret {view_items: b.view_items,\n-         stmts: vec::map(fld.fold_stmt, filtered_stmts),\n-         expr: option::map(fld.fold_expr, b.expr),\n+         stmts: vec::map(filtered_stmts, fld.fold_stmt),\n+         expr: option::map(b.expr, fld.fold_expr),\n          id: b.id,\n          rules: b.rules};\n }\n@@ -99,8 +99,8 @@ fn metas_in_cfg(cfg: ast::crate_cfg, metas: [@ast::meta_item]) -> bool {\n     // Pull the inner meta_items from the #[cfg(meta_item, ...)]  attributes,\n     // so we can match against them. This is the list of configurations for\n     // which the item is valid\n-    let cfg_metas = vec::concat(vec::filter_map(\n-        {|&&i| attr::get_meta_item_list(i)}, cfg_metas));\n+    let cfg_metas = vec::concat(vec::filter_map(cfg_metas,\n+        {|&&i| attr::get_meta_item_list(i)}));\n \n     let has_cfg_metas = vec::len(cfg_metas) > 0u;\n     if !has_cfg_metas { ret true; }"}, {"sha": "3e87cc1f78b9353f66bc7b55d29ff0e431c564ab", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -61,7 +61,7 @@ fn fold_mod(_cx: test_ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n     }\n \n     let mod_nomain =\n-        {view_items: m.view_items, items: vec::filter_map(nomain, m.items)};\n+        {view_items: m.view_items, items: vec::filter_map(m.items, nomain)};\n     ret fold::noop_fold_mod(mod_nomain, fld);\n }\n \n@@ -126,8 +126,8 @@ fn is_test_fn(i: @ast::item) -> bool {\n fn is_ignored(cx: test_ctxt, i: @ast::item) -> bool {\n     let ignoreattrs = attr::find_attrs_by_name(i.attrs, \"ignore\");\n     let ignoreitems = attr::attr_metas(ignoreattrs);\n-    let cfg_metas = vec::concat(vec::filter_map(\n-        {|&&i| attr::get_meta_item_list(i)}, ignoreitems));\n+    let cfg_metas = vec::concat(vec::filter_map(ignoreitems,\n+        {|&&i| attr::get_meta_item_list(i)}));\n     ret if vec::is_not_empty(ignoreitems) {\n         config::metas_in_cfg(cx.crate.node.config, cfg_metas)\n     } else {"}, {"sha": "7e2cc1d1cd75de377b80bf302e86fcea447f4b44", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -140,7 +140,7 @@ fn get_dep_hashes(cstore: cstore) -> [str] {\n         log #fmt(\"  hash[%s]: %s\", x.name, x.hash);\n     }\n     fn mapper(ch: crate_hash) -> str { ret ch.hash; }\n-    ret vec::map(mapper, sorted);\n+    ret vec::map(sorted, mapper);\n }\n // Local Variables:\n // mode: rust"}, {"sha": "2451a567ea71b8ef7c8558fe49b26deb03ed18e4", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -159,7 +159,6 @@ fn resolve_path(path: [ast::ident], data: @[u8]) -> [ast::def_id] {\n     ret result;\n }\n \n-\n // FIXME doesn't yet handle renamed re-exported externals\n fn lookup_def(cnum: ast::crate_num, data: @[u8], did_: ast::def_id) ->\n    ast::def {"}, {"sha": "340328f666ada8ec492a97e90836078717ad75c3", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -610,7 +610,7 @@ fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n         fn name(kv: numname) -> str { kv.ident }\n         // mutable -> immutable hack for vec::map\n         let immpairs = vec::slice(pairs, 0u, vec::len(pairs));\n-        ret vec::map(name, immpairs);\n+        ret vec::map(immpairs, name);\n     }\n \n     // We're just going to write a list of crate names, with the assumption"}, {"sha": "3616ba9e867eaee6ca52b5d421e9bf3dc41032a7", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -325,7 +325,7 @@ fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n         for pat in a.pats {\n             for proot in pattern_roots(cx.tcx, root.mut, pat) {\n                 let canon_id = pat_id_map.get(proot.name);\n-                alt vec::find({|x| x.id == canon_id}, binding_info) {\n+                alt vec::find(binding_info, {|x| x.id == canon_id}) {\n                   some(s) { s.unsafe_tys += unsafe_set(proot.mut); }\n                   none. {\n                       binding_info += [\n@@ -683,7 +683,7 @@ fn filter_invalid(src: list<@invalid>, bs: [binding]) -> list<@invalid> {\n     while cur != list::nil {\n         alt cur {\n           list::cons(head, tail) {\n-            let p = vec::position_pred({|b| b.node_id == head.node_id}, bs);\n+            let p = vec::position_pred(bs, {|b| b.node_id == head.node_id});\n             if !is_none(p) { out = list::cons(head, @out); }\n             cur = *tail;\n           }"}, {"sha": "36dc4d9f65acbde4a5bce56cd7517fcd3410e5d3", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -78,7 +78,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n             let t = ty::expr_ty(cx.tcx, ex);\n             let ty_fields = alt ty::struct(cx.tcx, t) { ty::ty_rec(f) { f } };\n             for tf in ty_fields {\n-                if !vec::any({|f| f.node.ident == tf.ident}, fields) &&\n+                if !vec::any(fields, {|f| f.node.ident == tf.ident}) &&\n                     !kind_can_be_copied(ty::type_kind(cx.tcx, tf.mt.ty)) {\n                     cx.tcx.sess.span_err(ex.span,\n                                          \"copying a noncopyable value\");"}, {"sha": "c6879898cc3f8507670e707c5d40d488a993207a", "filename": "src/comp/middle/last_use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flast_use.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -197,7 +197,7 @@ fn join_branches(branches: [set]) -> set {\n     for set in branches {\n         i += 1u;\n         for {def, exprs} in set {\n-            if !vec::any({|v| v.def == def}, found) {\n+            if !vec::any(found, {|v| v.def == def}) {\n                 let j = i, ne = exprs;\n                 while j < l {\n                     for {def: d2, exprs} in branches[j] {\n@@ -234,8 +234,8 @@ fn clear_in_current(cx: ctx, my_def: node_id, to: bool) {\n                      cx.last_uses.insert(expr, to);\n                 }\n             }\n-            cx.current = vec::filter({|x| x.def != my_def},\n-                                     copy cx.current);\n+            cx.current = vec::filter(copy cx.current,\n+                                     {|x| x.def != my_def});\n             break;\n         }\n     }"}, {"sha": "7b3db277ef6b9beed2967056eeaa0c629c4c563d", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -1152,8 +1152,8 @@ fn lookup_in_globs(e: env, globs: [glob_imp_def], sp: span, id: ident,\n           none. { none }\n         }\n     }\n-    let matches = vec::filter_map(bind lookup_in_mod_(e, _, sp, id, ns, dr),\n-                                  copy globs);\n+    let matches = vec::filter_map(copy globs,\n+                                  bind lookup_in_mod_(e, _, sp, id, ns, dr));\n     if vec::len(matches) == 0u {\n         ret none;\n     } else if vec::len(matches) == 1u {\n@@ -1448,7 +1448,7 @@ fn check_arm(e: @env, a: ast::arm, &&x: (), v: vt<()>) {\n                             \"inconsistent number of bindings\");\n         } else {\n             for name: ident in ch.seen {\n-                if is_none(vec::find(bind str::eq(name, _), seen0)) {\n+                if is_none(vec::find(seen0, bind str::eq(name, _))) {\n                     // Fight the alias checker\n                     let name_ = name;\n                     e.sess.span_err(a.pats[i].span,"}, {"sha": "42930b6c0311819f247dec159a2a332895a5fc44", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -3428,9 +3428,9 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n     let ty_fields = alt ty::struct(bcx_tcx(bcx), t) { ty::ty_rec(f) { f } };\n     let temp_cleanups = [];\n     for fld in fields {\n-        let ix = option::get(vec::position_pred({|ft|\n+        let ix = option::get(vec::position_pred(ty_fields, {|ft|\n             str::eq(fld.node.ident, ft.ident)\n-        }, ty_fields));\n+        }));\n         let dst = GEP_tup_like_1(bcx, t, addr, [0, ix as int]);\n         bcx = trans_expr_save_in(dst.bcx, fld.node.expr, dst.val);\n         add_clean_temp_mem(bcx, dst.val, ty_fields[ix].mt.ty);\n@@ -3442,7 +3442,7 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n         bcx = cx;\n         // Copy over inherited fields\n         for tf in ty_fields {\n-            if !vec::any({|f| str::eq(f.node.ident, tf.ident)}, fields) {\n+            if !vec::any(fields, {|f| str::eq(f.node.ident, tf.ident)}) {\n                 let dst = GEP_tup_like_1(bcx, t, addr, [0, i]);\n                 let base = GEP_tup_like_1(bcx, t, base_val, [0, i]);\n                 let val = load_if_immediate(base.bcx, base.val, tf.mt.ty);"}, {"sha": "baf81ba296d339f1a953b1c74eea9f25d73879cc", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -291,7 +291,7 @@ fn collect_record_fields(m: match, col: uint) -> [ast::ident] {\n         alt br.pats[col].node {\n           ast::pat_rec(fs, _) {\n             for f: ast::field_pat in fs {\n-                if !vec::any(bind str::eq(f.ident, _), fields) {\n+                if !vec::any(fields, bind str::eq(f.ident, _)) {\n                     fields += [f.ident];\n                 }\n             }"}, {"sha": "a82524485af3f9f758b4ae8a23ab3a19bf843201", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -426,7 +426,7 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n     // Actually construct the closure\n     let {llbox, box_ty, bcx} = store_environment(\n         bcx, lltydescs,\n-        env_vals + vec::map({|x| env_expr(x)}, bound),\n+        env_vals + vec::map(bound, {|x| env_expr(x)}),\n         ty::closure_shared);\n \n     // Make thunk"}, {"sha": "72015faab22d7f9fdd96e44a0c6a9f1ba1877575", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -244,8 +244,8 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: span, anon_obj: ast::anon_obj,\n     // methods, not inner ones.\n     let wrapper_obj: ast::_obj =\n         {fields:\n-             vec::map(ast_util::obj_field_from_anon_obj_field,\n-                           additional_fields),\n+             vec::map(additional_fields,\n+                      ast_util::obj_field_from_anon_obj_field),\n          methods: anon_obj.methods};\n \n     let inner_obj_ty: ty::t;\n@@ -481,7 +481,7 @@ fn create_vtbl(cx: @local_ctxt, sp: span, outer_obj_ty: ty::t, ob: ast::_obj,\n         // Filter out any methods that we don't need forwarding slots for\n         // because they're being overridden.\n         let f = bind filtering_fn(cx, _, ob.methods);\n-        meths = vec::filter_map(f, meths);\n+        meths = vec::filter_map(meths, f);\n \n         // And now add the additional ones, both overriding ones and entirely\n         // new ones.  These will just be normal methods."}, {"sha": "579d4bdd813255caf23065e1f28d4b1a233be1b0", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -1083,7 +1083,7 @@ fn callee_arg_init_ops(fcx: fn_ctxt, callee: node_id) -> [init_op] {\n     fn mode_to_op(m: ty::mode) -> init_op {\n         alt m { by_move. { init_move } _ { init_assign } }\n     }\n-    vec::map(mode_to_op, callee_modes(fcx, callee))\n+    vec::map(callee_modes(fcx, callee), mode_to_op)\n }\n \n fn anon_bindings(ops: [init_op], es: [@expr]) -> [binding] {"}, {"sha": "d341e90f8166ac4ad4ef93190d498b821ca6f894", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -95,10 +95,10 @@ fn find_pre_post_exprs(fcx: fn_ctxt, args: [@expr], id: node_id) {\n     fn get_pp(ccx: crate_ctxt, &&e: @expr) -> pre_and_post {\n         ret expr_pp(ccx, e);\n     }\n-    let pps = vec::map(bind get_pp(fcx.ccx, _), args);\n+    let pps = vec::map(args, bind get_pp(fcx.ccx, _));\n \n     set_pre_and_post(fcx.ccx, id, seq_preconds(fcx, pps),\n-                     seq_postconds(fcx, vec::map(get_post, pps)));\n+                     seq_postconds(fcx, vec::map(pps, get_post)));\n }\n \n fn find_pre_post_loop(fcx: fn_ctxt, l: @local, index: @expr, body: blk,\n@@ -472,7 +472,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n               postcondition: false_postcond(num_local_vars)};\n         let g = bind combine_pp(antec_pp, fcx, _, _);\n         let alts_overall_pp =\n-            vec::foldl::<pre_and_post, pre_and_post>(g, e_pp, alt_pps);\n+            vec::foldl(e_pp, alt_pps, g);\n         set_pre_and_post(fcx.ccx, e.id, alts_overall_pp.precondition,\n                          alts_overall_pp.postcondition);\n       }\n@@ -669,7 +669,7 @@ fn find_pre_post_block(fcx: fn_ctxt, b: blk) {\n     for s: @stmt in b.node.stmts { do_one_(fcx, s); }\n     fn do_inner_(fcx: fn_ctxt, &&e: @expr) { find_pre_post_expr(fcx, e); }\n     let do_inner = bind do_inner_(fcx, _);\n-    option::map::<@expr, ()>(do_inner, b.node.expr);\n+    option::map::<@expr, ()>(b.node.expr, do_inner);\n \n     let pps: [pre_and_post] = [];\n     for s: @stmt in b.node.stmts { pps += [stmt_pp(fcx.ccx, *s)]; }"}, {"sha": "d27f3d79b75b4e2e55fa50e5899730579f09cb46", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -1708,7 +1708,7 @@ fn field_idx(sess: session::session, sp: span, id: ast::ident,\n fn get_field(tcx: ctxt, rec_ty: t, id: ast::ident) -> field {\n     alt struct(tcx, rec_ty) {\n       ty_rec(fields) {\n-        alt vec::find({|f| str::eq(f.ident, id) }, fields) {\n+        alt vec::find(fields, {|f| str::eq(f.ident, id) }) {\n             some(f) { ret f; }\n         }\n       }"}, {"sha": "580930e561ba29e60db0f6986390943129e4d6ae", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -323,7 +323,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n         typ = ty::mk_ptr(tcx, ast_mt_to_mt(tcx, mode, mt));\n       }\n       ast::ty_tup(fields) {\n-        let flds = vec::map(bind ast_ty_to_ty(tcx, mode, _), fields);\n+        let flds = vec::map(fields, bind ast_ty_to_ty(tcx, mode, _));\n         typ = ty::mk_tup(tcx, flds);\n       }\n       ast::ty_rec(fields) {\n@@ -516,8 +516,8 @@ fn ty_of_native_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n     ret tpt;\n }\n fn ty_of_method(tcx: ty::ctxt, mode: mode, m: @ast::method) -> ty::method {\n-    let inputs = vec::map({|i| ty_of_arg(tcx, mode, i)},\n-                          m.node.meth.decl.inputs);\n+    let inputs = vec::map(m.node.meth.decl.inputs,\n+                          {|i| ty_of_arg(tcx, mode, i)});\n     let output = ast_ty_to_ty(tcx, mode, m.node.meth.decl.output);\n \n     let out_constrs = [];\n@@ -540,7 +540,7 @@ fn ty_of_obj(tcx: ty::ctxt, mode: mode, id: ast::ident, ob: ast::_obj,\n }\n fn ty_of_obj_methods(tcx: ty::ctxt, mode: mode, object: ast::_obj)\n     -> [ty::method] {\n-    vec::map({|m| ty_of_method(tcx, mode, m)}, object.methods)\n+    vec::map(object.methods, {|m| ty_of_method(tcx, mode, m)})\n }\n fn ty_of_obj_ctor(tcx: ty::ctxt, mode: mode, id: ast::ident, ob: ast::_obj,\n             ctor_id: ast::node_id, ty_params: [ast::ty_param])\n@@ -1331,7 +1331,7 @@ fn check_pat(fcx: @fn_ctxt, map: ast_util::pat_id_map, pat: @ast::pat,\n             ret str::eq(name, f.ident);\n         }\n         for f: ast::field_pat in fields {\n-            alt vec::find(bind matches(f.ident, _), ex_fields) {\n+            alt vec::find(ex_fields, bind matches(f.ident, _)) {\n               some(field) { check_pat(fcx, map, f.pat, field.mt.ty); }\n               none. {\n                 fcx.ccx.tcx.sess.span_fatal(pat.span,\n@@ -2091,7 +2091,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         alt base {\n           none. {\n             fn get_node(f: spanned<field>) -> field { f.node }\n-            let typ = ty::mk_rec(tcx, vec::map(get_node, fields_t));\n+            let typ = ty::mk_rec(tcx, vec::map(fields_t, get_node));\n             write::ty_only_fixup(fcx, id, typ);\n           }\n           some(bexpr) {\n@@ -2140,7 +2140,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                 ids += b.ids;\n                 fty = b.ty;\n             }\n-            let substs = vec::map({|id| ty::mk_var(tcx, id)}, ids);\n+            let substs = vec::map(ids, {|id| ty::mk_var(tcx, id)});\n             write::ty_fixup(fcx, id, {substs: some(substs), ty: fty});\n             fcx.ccx.method_map.insert(id, local_def(method.node.id));\n           }\n@@ -2268,7 +2268,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             }\n \n             let f = bind filtering_fn(fcx.ccx, _, ao.methods);\n-            inner_obj_methods = vec::filter_map(f, inner_obj_methods);\n+            inner_obj_methods = vec::filter_map(inner_obj_methods, f);\n \n             method_types += inner_obj_methods;\n         }\n@@ -2287,8 +2287,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         }\n \n         fcx.ccx.self_infos +=\n-            [self_obj(vec::map(ast_util::obj_field_from_anon_obj_field,\n-                               fields), ot)];\n+            [self_obj(\n+                vec::map(fields, ast_util::obj_field_from_anon_obj_field),\n+                ot)];\n         // Typecheck the methods.\n         for method: @ast::method in ao.methods {\n             check_method(fcx.ccx, method);"}, {"sha": "371370c5eda668d72ebb4f838757f5286db2be68", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -265,7 +265,7 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n                     recur: fn@(&&@expr) -> @expr, exprs: [@expr]) -> [@expr] {\n     alt elts_to_ell(cx, exprs) {\n       {pre: pre, rep: repeat_me_maybe, post: post} {\n-        let res = vec::map(recur, pre);\n+        let res = vec::map(pre, recur);\n         alt repeat_me_maybe {\n           none. { }\n           some(repeat_me) {\n@@ -314,7 +314,7 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n             }\n           }\n         }\n-        res += vec::map(recur, post);\n+        res += vec::map(post, recur);\n         ret res;\n       }\n     }"}, {"sha": "5f4ebbf3da3d83108a2ef1143a8f4ef832f972d3", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -110,7 +110,7 @@ fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n                 meta_word(id) { meta_word(fld.fold_ident(id)) }\n                 meta_list(id, mis) {\n                   let fold_meta_item = bind fold_meta_item_(_, fld);\n-                  meta_list(id, vec::map(fold_meta_item, mis))\n+                  meta_list(id, vec::map(mis, fold_meta_item))\n                 }\n                 meta_name_value(id, s) {\n                   meta_name_value(fld.fold_ident(id), s)\n@@ -150,10 +150,10 @@ fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n     let fold_meta_item = bind fold_meta_item_(_, fld);\n     let fold_attribute = bind fold_attribute_(_, fold_meta_item);\n \n-    ret {directives: vec::map(fld.fold_crate_directive, c.directives),\n+    ret {directives: vec::map(c.directives, fld.fold_crate_directive),\n          module: fld.fold_mod(c.module),\n-         attrs: vec::map(fold_attribute, c.attrs),\n-         config: vec::map(fold_meta_item, c.config)};\n+         attrs: vec::map(c.attrs, fold_attribute),\n+         config: vec::map(c.config, fold_meta_item)};\n }\n \n fn noop_fold_crate_directive(cd: crate_directive_, fld: ast_fold) ->\n@@ -164,7 +164,7 @@ fn noop_fold_crate_directive(cd: crate_directive_, fld: ast_fold) ->\n           }\n           cdir_dir_mod(id, cds, attrs) {\n             cdir_dir_mod(fld.fold_ident(id),\n-                         vec::map(fld.fold_crate_directive, cds), attrs)\n+                         vec::map(cds, fld.fold_crate_directive), attrs)\n           }\n           cdir_view_item(vi) { cdir_view_item(fld.fold_view_item(vi)) }\n           cdir_syntax(_) { cd }\n@@ -182,19 +182,19 @@ fn noop_fold_native_item(&&ni: @native_item, fld: ast_fold) -> @native_item {\n     let fold_attribute = bind fold_attribute_(_, fold_meta_item);\n \n     ret @{ident: fld.fold_ident(ni.ident),\n-          attrs: vec::map(fold_attribute, ni.attrs),\n+          attrs: vec::map(ni.attrs, fold_attribute),\n           node:\n               alt ni.node {\n                 native_item_ty. { native_item_ty }\n                 native_item_fn(fdec, typms) {\n-                  native_item_fn({inputs: vec::map(fold_arg, fdec.inputs),\n+                  native_item_fn({inputs: vec::map(fdec.inputs, fold_arg),\n                                   output: fld.fold_ty(fdec.output),\n                                   purity: fdec.purity,\n                                   il: fdec.il,\n                                   cf: fdec.cf,\n                                   constraints:\n-                                      vec::map(fld.fold_constr,\n-                                                   fdec.constraints)}, typms)\n+                                      vec::map(fdec.constraints,\n+                                               fld.fold_constr)}, typms)\n                 }\n               },\n           id: ni.id,\n@@ -206,7 +206,7 @@ fn noop_fold_item(&&i: @item, fld: ast_fold) -> @item {\n     let fold_attribute = bind fold_attribute_(_, fold_meta_item);\n \n     ret @{ident: fld.fold_ident(i.ident),\n-          attrs: vec::map(fold_attribute, i.attrs),\n+          attrs: vec::map(i.attrs, fold_attribute),\n           id: i.id,\n           node: fld.fold_item_underscore(i.node),\n           span: i.span};\n@@ -228,16 +228,16 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n           item_native_mod(nm) { item_native_mod(fld.fold_native_mod(nm)) }\n           item_ty(t, typms) { item_ty(fld.fold_ty(t), typms) }\n           item_tag(variants, typms) {\n-            item_tag(vec::map(fld.fold_variant, variants), typms)\n+            item_tag(vec::map(variants, fld.fold_variant), typms)\n           }\n           item_obj(o, typms, d) {\n-            item_obj({fields: vec::map(fold_obj_field, o.fields),\n-                      methods: vec::map(fld.fold_method, o.methods)},\n+            item_obj({fields: vec::map(o.fields, fold_obj_field),\n+                      methods: vec::map(o.methods, fld.fold_method)},\n                      typms, d)\n           }\n           item_impl(tps, ty, methods) {\n             item_impl(tps, fld.fold_ty(ty),\n-                      vec::map(fld.fold_method, methods))\n+                      vec::map(methods, fld.fold_method))\n           }\n           item_res(dtor, did, typms, cid) {\n             item_res(fld.fold_fn(dtor), did, typms, cid)\n@@ -252,9 +252,9 @@ fn noop_fold_method(m: method_, fld: ast_fold) -> method_ {\n \n \n fn noop_fold_block(b: blk_, fld: ast_fold) -> blk_ {\n-    ret {view_items: vec::map(fld.fold_view_item, b.view_items),\n-         stmts: vec::map(fld.fold_stmt, b.stmts),\n-         expr: option::map(fld.fold_expr, b.expr),\n+    ret {view_items: vec::map(b.view_items, fld.fold_view_item),\n+         stmts: vec::map(b.stmts, fld.fold_stmt),\n+         expr: option::map(b.expr, fld.fold_expr),\n          id: b.id,\n          rules: b.rules};\n }\n@@ -267,20 +267,20 @@ fn noop_fold_stmt(s: stmt_, fld: ast_fold) -> stmt_ {\n }\n \n fn noop_fold_arm(a: arm, fld: ast_fold) -> arm {\n-    ret {pats: vec::map(fld.fold_pat, a.pats),\n-         guard: option::map(fld.fold_expr, a.guard),\n+    ret {pats: vec::map(a.pats, fld.fold_pat),\n+         guard: option::map(a.guard, fld.fold_expr),\n          body: fld.fold_block(a.body)};\n }\n \n fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n     ret alt p {\n           pat_wild. { p }\n           pat_bind(ident, sub) {\n-            pat_bind(fld.fold_ident(ident), option::map(fld.fold_pat, sub))\n+            pat_bind(fld.fold_ident(ident), option::map(sub, fld.fold_pat))\n           }\n           pat_lit(_) { p }\n           pat_tag(pth, pats) {\n-            pat_tag(fld.fold_path(pth), vec::map(fld.fold_pat, pats))\n+            pat_tag(fld.fold_path(pth), vec::map(pats, fld.fold_pat))\n           }\n           pat_rec(fields, etc) {\n             let fs = [];\n@@ -289,7 +289,7 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n             }\n             pat_rec(fs, etc)\n           }\n-          pat_tup(elts) { pat_tup(vec::map(fld.fold_pat, elts)) }\n+          pat_tup(elts) { pat_tup(vec::map(elts, fld.fold_pat)) }\n           pat_box(inner) { pat_box(fld.fold_pat(inner)) }\n           pat_uniq(inner) { pat_uniq(fld.fold_pat(inner)) }\n           pat_range(_, _) { p }\n@@ -299,8 +299,8 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n fn noop_fold_decl(d: decl_, fld: ast_fold) -> decl_ {\n     ret alt d {\n           decl_local(ls) {\n-            decl_local(vec::map({|l| let (st, lc) = l;\n-                                 (st, fld.fold_local(lc))}, ls))\n+            decl_local(vec::map(ls, {|l| let (st, lc) = l;\n+                                 (st, fld.fold_local(lc))}))\n           }\n           decl_item(it) { decl_item(fld.fold_item(it)) }\n         }\n@@ -331,11 +331,11 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n                  alt ao.fields {\n                    option::none. { ao.fields }\n                    option::some(v) {\n-                     option::some(vec::map(fold_anon_obj_field, v))\n+                     option::some(vec::map(v, fold_anon_obj_field))\n                    }\n                  },\n-             methods: vec::map(fld.fold_method, ao.methods),\n-             inner_obj: option::map(fld.fold_expr, ao.inner_obj)}\n+             methods: vec::map(ao.methods, fld.fold_method),\n+             inner_obj: option::map(ao.inner_obj, fld.fold_expr)}\n     }\n     let fold_anon_obj = bind fold_anon_obj_(_, fld);\n \n@@ -346,17 +346,17 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n             expr_vec(fld.map_exprs(fld.fold_expr, exprs), mut)\n           }\n           expr_rec(fields, maybe_expr) {\n-            expr_rec(vec::map(fold_field, fields),\n-                     option::map(fld.fold_expr, maybe_expr))\n+            expr_rec(vec::map(fields, fold_field),\n+                     option::map(maybe_expr, fld.fold_expr))\n           }\n-          expr_tup(elts) { expr_tup(vec::map(fld.fold_expr, elts)) }\n+          expr_tup(elts) { expr_tup(vec::map(elts, fld.fold_expr)) }\n           expr_call(f, args, blk) {\n             expr_call(fld.fold_expr(f), fld.map_exprs(fld.fold_expr, args),\n                       blk)\n           }\n           expr_bind(f, args) {\n-            let opt_map_se = bind option::map(fld.fold_expr, _);\n-            expr_bind(fld.fold_expr(f), vec::map(opt_map_se, args))\n+            let opt_map_se = bind option::map(_, fld.fold_expr);\n+            expr_bind(fld.fold_expr(f), vec::map(args, opt_map_se))\n           }\n           expr_binary(binop, lhs, rhs) {\n             expr_binary(binop, fld.fold_expr(lhs), fld.fold_expr(rhs))\n@@ -366,7 +366,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           expr_cast(expr, ty) { expr_cast(fld.fold_expr(expr), ty) }\n           expr_if(cond, tr, fl) {\n             expr_if(fld.fold_expr(cond), fld.fold_block(tr),\n-                    option::map(fld.fold_expr, fl))\n+                    option::map(fl, fld.fold_expr))\n           }\n           expr_ternary(cond, tr, fl) {\n             expr_ternary(fld.fold_expr(cond), fld.fold_expr(tr),\n@@ -383,7 +383,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n             expr_do_while(fld.fold_block(blk), fld.fold_expr(expr))\n           }\n           expr_alt(expr, arms) {\n-            expr_alt(fld.fold_expr(expr), vec::map(fld.fold_arm, arms))\n+            expr_alt(fld.fold_expr(expr), vec::map(arms, fld.fold_arm))\n           }\n           // NDM fold_captures\n           expr_fn(f, captures) { expr_fn(fld.fold_fn(f), captures) }\n@@ -408,17 +408,17 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n             expr_index(fld.fold_expr(el), fld.fold_expr(er))\n           }\n           expr_path(pth) { expr_path(fld.fold_path(pth)) }\n-          expr_fail(e) { expr_fail(option::map(fld.fold_expr, e)) }\n+          expr_fail(e) { expr_fail(option::map(e, fld.fold_expr)) }\n           expr_break. { e }\n           expr_cont. { e }\n-          expr_ret(e) { expr_ret(option::map(fld.fold_expr, e)) }\n+          expr_ret(e) { expr_ret(option::map(e, fld.fold_expr)) }\n           expr_be(e) { expr_be(fld.fold_expr(e)) }\n           expr_log(lv, e) { expr_log(lv, fld.fold_expr(e)) }\n           expr_assert(e) { expr_assert(fld.fold_expr(e)) }\n           expr_check(m, e) { expr_check(m, fld.fold_expr(e)) }\n           expr_if_check(cond, tr, fl) {\n             expr_if_check(fld.fold_expr(cond), fld.fold_block(tr),\n-                          option::map(fld.fold_expr, fl))\n+                          option::map(fl, fld.fold_expr))\n           }\n           expr_anon_obj(ao) { expr_anon_obj(fold_anon_obj(ao)) }\n           expr_mac(mac) { expr_mac(fold_mac(mac)) }\n@@ -439,41 +439,41 @@ fn noop_fold_fn(f: _fn, fld: ast_fold) -> _fn {\n     let fold_arg = bind fold_arg_(_, fld);\n \n     ret {decl:\n-             {inputs: vec::map(fold_arg, f.decl.inputs),\n+             {inputs: vec::map(f.decl.inputs, fold_arg),\n               output: fld.fold_ty(f.decl.output),\n               purity: f.decl.purity,\n               il: f.decl.il,\n               cf: f.decl.cf,\n-              constraints: vec::map(fld.fold_constr, f.decl.constraints)},\n+              constraints: vec::map(f.decl.constraints, fld.fold_constr)},\n          proto: f.proto,\n          body: fld.fold_block(f.body)};\n }\n \n // ...nor do modules\n fn noop_fold_mod(m: _mod, fld: ast_fold) -> _mod {\n-    ret {view_items: vec::map(fld.fold_view_item, m.view_items),\n-         items: vec::map(fld.fold_item, m.items)};\n+    ret {view_items: vec::map(m.view_items, fld.fold_view_item),\n+         items: vec::map(m.items, fld.fold_item)};\n }\n \n fn noop_fold_native_mod(nm: native_mod, fld: ast_fold) -> native_mod {\n-    ret {view_items: vec::map(fld.fold_view_item, nm.view_items),\n-         items: vec::map(fld.fold_native_item, nm.items)}\n+    ret {view_items: vec::map(nm.view_items, fld.fold_view_item),\n+         items: vec::map(nm.items, fld.fold_native_item)}\n }\n \n fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n     fn fold_variant_arg_(va: variant_arg, fld: ast_fold) -> variant_arg {\n         ret {ty: fld.fold_ty(va.ty), id: va.id};\n     }\n     let fold_variant_arg = bind fold_variant_arg_(_, fld);\n-    ret {name: v.name, args: vec::map(fold_variant_arg, v.args), id: v.id};\n+    ret {name: v.name, args: vec::map(v.args, fold_variant_arg), id: v.id};\n }\n \n fn noop_fold_ident(&&i: ident, _fld: ast_fold) -> ident { ret i; }\n \n fn noop_fold_path(p: path_, fld: ast_fold) -> path_ {\n     ret {global: p.global,\n-         idents: vec::map(fld.fold_ident, p.idents),\n-         types: vec::map(fld.fold_ty, p.types)};\n+         idents: vec::map(p.idents, fld.fold_ident),\n+         types: vec::map(p.types, fld.fold_ty)};\n }\n \n fn noop_fold_local(l: local_, fld: ast_fold) -> local_ {\n@@ -493,7 +493,7 @@ fn noop_fold_local(l: local_, fld: ast_fold) -> local_ {\n /* temporarily eta-expand because of a compiler bug with using `fn<T>` as a\n    value */\n fn noop_map_exprs(f: fn@(&&@expr) -> @expr, es: [@expr]) -> [@expr] {\n-    ret vec::map(f, es);\n+    ret vec::map(es, f);\n }\n \n fn noop_id(i: node_id) -> node_id { ret i; }"}, {"sha": "1295f2ed5ae68f06b143350e2be0bb4e3fe8c46c", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -281,7 +281,7 @@ fn split_maybe_args(argstr: option::t<str>) -> [str] {\n             for c: u8 in s { if c != ' ' as u8 { ret false; } }\n             ret true;\n         }\n-        vec::filter_map(flt, v)\n+        vec::filter_map(v, flt)\n     }\n \n     alt argstr {"}, {"sha": "983d2b5e9f3ecb71deabffb5370ed8697f3f8653", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -220,7 +220,8 @@ fn as_str(f: fn@(io::writer)) -> str {\n fn check_variants_of_ast(crate: ast::crate, codemap: codemap::codemap,\n                          filename: str, cx: context) {\n     let stolen = steal(crate, cx.mode);\n-    let extra_exprs = vec::filter(bind safe_to_use_expr(_, cx.mode), common_exprs());\n+    let extra_exprs = vec::filter(common_exprs(),\n+                                  bind safe_to_use_expr(_, cx.mode));\n     check_variants_T(crate, codemap, filename, \"expr\", extra_exprs + stolen.exprs, pprust::expr_to_str, replace_expr_in_crate, cx);\n     check_variants_T(crate, codemap, filename, \"ty\", stolen.tys, pprust::ty_to_str, replace_ty_in_crate, cx);\n }"}, {"sha": "b46798894b71d4abbf73eee699da0ed8ffa65853", "filename": "src/libcore/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -36,7 +36,7 @@ fn get<copy T>(opt: t<T>) -> T {\n \n /*\n */\n-fn map<T, U>(f: block(T) -> U, opt: t<T>) -> t<U> {\n+fn map<T, U>(opt: t<T>, f: block(T) -> U) -> t<U> {\n     alt opt { some(x) { some(f(x)) } none. { none } }\n }\n \n@@ -70,7 +70,7 @@ Function: maybe\n \n Applies a function to the contained value or returns a default\n */\n-fn maybe<T, U>(def: U, f: block(T) -> U, opt: t<T>) -> U {\n+fn maybe<T, U>(def: U, opt: t<T>, f: block(T) -> U) -> U {\n     alt opt { none. { def } some(t) { f(t) } }\n }\n \n@@ -80,7 +80,7 @@ Function: may\n \n Performs an operation on the contained value or does nothing\n */\n-fn may<T>(f: block(T), opt: t<T>) {\n+fn may<T>(opt: t<T>, f: block(T)) {\n     alt opt { none. {/* nothing */ } some(t) { f(t); } }\n }\n "}, {"sha": "9fe10692cc63be3a0046329dd8ed0f3c46f8f710", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -384,7 +384,7 @@ Function: map\n \n Apply a function to each element of a vector and return the results\n */\n-fn map<T, U>(f: block(T) -> U, v: [T]) -> [U] {\n+fn map<T, U>(v: [T], f: block(T) -> U) -> [U] {\n     let result = [];\n     reserve(result, len(v));\n     for elem: T in v { result += [f(elem)]; }\n@@ -396,7 +396,7 @@ Function: map_mut\n \n Apply a function to each element of a mutable vector and return the results\n */\n-fn map_mut<copy T, U>(f: block(T) -> U, v: [const T]) -> [U] {\n+fn map_mut<copy T, U>(v: [const T], f: block(T) -> U) -> [U] {\n     let result = [];\n     reserve(result, len(v));\n     for elem: T in v {\n@@ -411,7 +411,7 @@ Function: map2\n \n Apply a function to each pair of elements and return the results\n */\n-fn map2<copy T, copy U, V>(f: block(T, U) -> V, v0: [T], v1: [U]) -> [V] {\n+fn map2<copy T, copy U, V>(v0: [T], v1: [U], f: block(T, U) -> V) -> [V] {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { fail; }\n     let u: [V] = [];\n@@ -428,7 +428,7 @@ Apply a function to each element of a vector and return the results\n If function `f` returns `none` then that element is excluded from\n the resulting vector.\n */\n-fn filter_map<copy T, copy U>(f: block(T) -> option::t<U>, v: [const T])\n+fn filter_map<copy T, copy U>(v: [const T], f: block(T) -> option::t<U>)\n     -> [U] {\n     let result = [];\n     for elem: T in v {\n@@ -449,7 +449,7 @@ holds.\n Apply function `f` to each element of `v` and return a vector containing\n only those elements for which `f` returned true.\n */\n-fn filter<copy T>(f: block(T) -> bool, v: [T]) -> [T] {\n+fn filter<copy T>(v: [T], f: block(T) -> bool) -> [T] {\n     let result = [];\n     for elem: T in v {\n         if f(elem) { result += [elem]; }\n@@ -474,7 +474,7 @@ Function: foldl\n \n Reduce a vector from left to right\n */\n-fn foldl<copy T, U>(p: block(T, U) -> T, z: T, v: [const U]) -> T {\n+fn foldl<copy T, U>(z: T, v: [const U], p: block(T, U) -> T) -> T {\n     let accum = z;\n     iter(v) { |elt|\n         accum = p(accum, elt);\n@@ -487,7 +487,7 @@ Function: foldr\n \n Reduce a vector from right to left\n */\n-fn foldr<T, copy U>(p: block(T, U) -> U, z: U, v: [const T]) -> U {\n+fn foldr<T, copy U>(v: [const T], z: U, p: block(T, U) -> U) -> U {\n     let accum = z;\n     riter(v) { |elt|\n         accum = p(elt, accum);\n@@ -502,7 +502,7 @@ Return true if a predicate matches any elements\n \n If the vector contains no elements then false is returned.\n */\n-fn any<T>(f: block(T) -> bool, v: [T]) -> bool {\n+fn any<T>(v: [T], f: block(T) -> bool) -> bool {\n     for elem: T in v { if f(elem) { ret true; } }\n     ret false;\n }\n@@ -514,7 +514,7 @@ Return true if a predicate matches all elements\n \n If the vector contains no elements then true is returned.\n */\n-fn all<T>(f: block(T) -> bool, v: [T]) -> bool {\n+fn all<T>(v: [T], f: block(T) -> bool) -> bool {\n     for elem: T in v { if !f(elem) { ret false; } }\n     ret true;\n }\n@@ -549,7 +549,7 @@ Apply function `f` to each element of `v`, starting from the first.\n When function `f` returns true then an option containing the element\n is returned. If `f` matches no elements then none is returned.\n */\n-fn find<copy T>(f: block(T) -> bool, v: [T]) -> option::t<T> {\n+fn find<copy T>(v: [T], f: block(T) -> bool) -> option::t<T> {\n     for elt: T in v { if f(elt) { ret some(elt); } }\n     ret none;\n }\n@@ -575,7 +575,7 @@ Function: position_pred\n \n Find the first index for which the value matches some predicate\n */\n-fn position_pred<T>(f: block(T) -> bool, v: [T]) -> option::t<uint> {\n+fn position_pred<T>(v: [T], f: block(T) -> bool) -> option::t<uint> {\n     let i: uint = 0u;\n     while i < len(v) { if f(v[i]) { ret some::<uint>(i); } i += 1u; }\n     ret none;"}, {"sha": "eac2347748e196240163da0e802a2cbe482be41f", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -317,13 +317,13 @@ fn normalize(p: path) -> path {\n     ret s;\n \n     fn strip_dots(s: [path]) -> [path] {\n-        vec::filter_map({ |elem|\n+        vec::filter_map(s, { |elem|\n             if elem == \".\" {\n                 option::none\n             } else {\n                 option::some(elem)\n             }\n-        }, s)\n+        })\n     }\n \n     fn rollup_doubledots(s: [path]) -> [path] {"}, {"sha": "e0b559ec7471ff9bbb9da9f814df3c9388144741", "filename": "src/libstd/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -50,7 +50,7 @@ fn to_str(j: json) -> str {\n         list(@js) {\n             str::concat([\"[\",\n                     str::connect(\n-                        vec::map::<json,str>({ |e| to_str(e) }, js),\n+                        vec::map::<json,str>(js, { |e| to_str(e) }),\n                         \", \"),\n                     \"]\"])\n         }"}, {"sha": "420e078172349c2b27682dfdc18fe973992415f3", "filename": "src/libstd/list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -28,7 +28,7 @@ Function: from_vec\n Create a list from a vector\n */\n fn from_vec<copy T>(v: [const T]) -> list<T> {\n-    *vec::foldr({ |h, t| @cons(h, t) }, @nil::<T>, v)\n+    *vec::foldr(v, @nil::<T>, { |h, t| @cons(h, t) })\n }\n \n /*"}, {"sha": "359e9838e28f15baf3339b3f84fc83aea3cd91fb", "filename": "src/libstd/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Flibstd%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Flibstd%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -49,7 +49,7 @@ Failure:\n String must be a valid IPv4 address\n */\n fn parse_addr(ip: str) -> ip_addr {\n-    let parts = vec::map({|s| uint::from_str(s) }, str::split(ip, \".\"[0]));\n+    let parts = vec::map(str::split(ip, \".\"[0]), {|s| uint::from_str(s) });\n     if vec::len(parts) != 4u { fail \"Too many dots in IP address\"; }\n     for i in parts { if i > 255u { fail \"Invalid IP Address part.\"; } }\n     ipv4(parts[0] as u8, parts[1] as u8, parts[2] as u8, parts[3] as u8)"}, {"sha": "55163696579a2ae891589099dc28eee65b136cd5", "filename": "src/libstd/run_program.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Flibstd%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Flibstd%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun_program.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -122,7 +122,7 @@ fn spawn_process(prog: str, args: [str], in_fd: fd_t,\n     // Note: we have to hold on to these vector references while we hold a\n     // pointer to their buffers\n     let prog = prog;\n-    let args = vec::map({|arg| @arg }, args);\n+    let args = vec::map(args, {|arg| @arg });\n     let argv = arg_vec(prog, args);\n     let pid =\n         rustrt::rust_run_program(vec::unsafe::to_ptr(argv), in_fd, out_fd,"}, {"sha": "fbb63844847c10ffe9d4c3c96c10e2da73b58ac5", "filename": "src/libstd/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -276,7 +276,7 @@ fn filter_tests<copy T>(opts: test_opts,\n \n         let filter = bind filter_fn(_, filter_str);\n \n-        vec::filter_map(filter, filtered)\n+        vec::filter_map(filtered, filter)\n     };\n \n     // Maybe pull out the ignored test and unignore them\n@@ -292,7 +292,7 @@ fn filter_tests<copy T>(opts: test_opts,\n             } else { ret option::none; }\n         };\n \n-        vec::filter_map(bind filter(_), filtered)\n+        vec::filter_map(filtered, bind filter(_))\n     };\n \n     // Sort the tests alphabetically"}, {"sha": "57c90637208267438d64c9466b48de14cd5646d5", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -192,8 +192,8 @@ fn main(argv: [str]) {\n     let inputs = if vec::len(argv) < 2u {\n         [input1(), input2(), input3()]\n     } else {\n-        vec::map({|f| result::get(io::read_whole_file_str(f)) },\n-                 vec::slice(argv, 1u, vec::len(argv)))\n+        vec::map(vec::slice(argv, 1u, vec::len(argv)),\n+                 {|f| result::get(io::read_whole_file_str(f)) })\n     };\n \n     let start = time::precise_time_ns();"}, {"sha": "07eebc192973a164186da5b0254c370668955a04", "filename": "src/test/run-pass/block-vec-map2.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Ftest%2Frun-pass%2Fblock-vec-map2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Ftest%2Frun-pass%2Fblock-vec-map2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-vec-map2.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -3,8 +3,9 @@ import vec;\n \n fn main() {\n     let v =\n-        vec::map2({|i, b| if b { -i } else { i } }, [1, 2, 3, 4, 5],\n-                       [true, false, false, true, true]);\n+        vec::map2([1, 2, 3, 4, 5],\n+                  [true, false, false, true, true],\n+                  {|i, b| if b { -i } else { i } });\n     log_err v;\n     assert (v == [-1, 2, 3, -4, -5]);\n }"}, {"sha": "1ad69e9a897500e07fa79c697e1b25107aca8f0f", "filename": "src/test/run-pass/test-ignore-cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -22,10 +22,10 @@ fn checktests() {\n     let tests = __test::tests();\n \n     let shouldignore = option::get(\n-        vec::find({|t| t.name == \"shouldignore\"}, tests));\n+        vec::find(tests, {|t| t.name == \"shouldignore\"}));\n     assert shouldignore.ignore == true;\n \n     let shouldnotignore = option::get(\n-        vec::find({|t| t.name == \"shouldnotignore\"}, tests));\n+        vec::find(tests, {|t| t.name == \"shouldnotignore\"}));\n     assert shouldnotignore.ignore == false;\n }\n\\ No newline at end of file"}, {"sha": "3a839592431103fb5ef694add6dc17091caae1d7", "filename": "src/test/stdtest/vec.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Ftest%2Fstdtest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2833ca478c19d2f8f150570a6d60b93488debdcc/src%2Ftest%2Fstdtest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fvec.rs?ref=2833ca478c19d2f8f150570a6d60b93488debdcc", "patch": "@@ -213,15 +213,15 @@ fn test_grow_set() {\n fn test_map() {\n     // Test on-stack map.\n     let v = [1u, 2u, 3u];\n-    let w = vec::map(square_ref, v);\n+    let w = vec::map(v, square_ref);\n     assert (vec::len(w) == 3u);\n     assert (w[0] == 1u);\n     assert (w[1] == 4u);\n     assert (w[2] == 9u);\n \n     // Test on-heap map.\n     v = [1u, 2u, 3u, 4u, 5u];\n-    w = vec::map(square_ref, v);\n+    w = vec::map(v, square_ref);\n     assert (vec::len(w) == 5u);\n     assert (w[0] == 1u);\n     assert (w[1] == 4u);\n@@ -236,7 +236,7 @@ fn test_map2() {\n     let f = times;\n     let v0 = [1, 2, 3, 4, 5];\n     let v1 = [5, 4, 3, 2, 1];\n-    let u = vec::map2::<int, int, int>(f, v0, v1);\n+    let u = vec::map2::<int, int, int>(v0, v1, f);\n     let i = 0;\n     while i < 5 { assert (v0[i] * v1[i] == u[i]); i += 1; }\n }\n@@ -245,14 +245,14 @@ fn test_map2() {\n fn test_filter_map() {\n     // Test on-stack filter-map.\n     let v = [1u, 2u, 3u];\n-    let w = vec::filter_map(square_if_odd, v);\n+    let w = vec::filter_map(v, square_if_odd);\n     assert (vec::len(w) == 2u);\n     assert (w[0] == 1u);\n     assert (w[1] == 9u);\n \n     // Test on-heap filter-map.\n     v = [1u, 2u, 3u, 4u, 5u];\n-    w = vec::filter_map(square_if_odd, v);\n+    w = vec::filter_map(v, square_if_odd);\n     assert (vec::len(w) == 3u);\n     assert (w[0] == 1u);\n     assert (w[1] == 9u);\n@@ -269,28 +269,28 @@ fn test_filter_map() {\n     let all_odd2: [int] = [];\n     let mix: [int] = [9, 2, 6, 7, 1, 0, 0, 3];\n     let mix_dest: [int] = [1, 3, 0, 0];\n-    assert (filter_map(halve, all_even) == map(halve_for_sure, all_even));\n-    assert (filter_map(halve, all_odd1) == []);\n-    assert (filter_map(halve, all_odd2) == []);\n-    assert (filter_map(halve, mix) == mix_dest);\n+    assert (filter_map(all_even, halve) == map(all_even, halve_for_sure));\n+    assert (filter_map(all_odd1, halve) == []);\n+    assert (filter_map(all_odd2, halve) == []);\n+    assert (filter_map(mix, halve) == mix_dest);\n }\n \n #[test]\n fn test_filter() {\n-    assert filter(is_odd, [1u, 2u, 3u]) == [1u, 3u];\n-    assert filter(is_three, [1u, 2u, 4u, 8u, 16u]) == [];\n+    assert filter([1u, 2u, 3u], is_odd) == [1u, 3u];\n+    assert filter([1u, 2u, 4u, 8u, 16u], is_three) == [];\n }\n \n #[test]\n fn test_foldl() {\n     // Test on-stack fold.\n     let v = [1u, 2u, 3u];\n-    let sum = vec::foldl(add, 0u, v);\n+    let sum = vec::foldl(0u, v, add);\n     assert (sum == 6u);\n \n     // Test on-heap fold.\n     v = [1u, 2u, 3u, 4u, 5u];\n-    sum = vec::foldl(add, 0u, v);\n+    sum = vec::foldl(0u, v, add);\n     assert (sum == 15u);\n }\n \n@@ -300,7 +300,7 @@ fn test_foldl2() {\n         a - b\n     }\n     let v = [1, 2, 3, 4];\n-    let sum = vec::foldl(sub, 0, v);\n+    let sum = vec::foldl(0, v, sub);\n     assert sum == -10;\n }\n \n@@ -310,7 +310,7 @@ fn test_foldr() {\n         a - b\n     }\n     let v = [1, 2, 3, 4];\n-    let sum = vec::foldr(sub, 0, v);\n+    let sum = vec::foldr(v, 0, sub);\n     assert sum == -2;\n }\n \n@@ -390,15 +390,15 @@ fn test_permute() {\n \n #[test]\n fn test_any_and_all() {\n-    assert (vec::any(is_three, [1u, 2u, 3u]));\n-    assert (!vec::any(is_three, [0u, 1u, 2u]));\n-    assert (vec::any(is_three, [1u, 2u, 3u, 4u, 5u]));\n-    assert (!vec::any(is_three, [1u, 2u, 4u, 5u, 6u]));\n+    assert (vec::any([1u, 2u, 3u], is_three));\n+    assert (!vec::any([0u, 1u, 2u], is_three));\n+    assert (vec::any([1u, 2u, 3u, 4u, 5u], is_three));\n+    assert (!vec::any([1u, 2u, 4u, 5u, 6u], is_three));\n \n-    assert (vec::all(is_three, [3u, 3u, 3u]));\n-    assert (!vec::all(is_three, [3u, 3u, 2u]));\n-    assert (vec::all(is_three, [3u, 3u, 3u, 3u, 3u]));\n-    assert (!vec::all(is_three, [3u, 3u, 0u, 1u, 2u]));\n+    assert (vec::all([3u, 3u, 3u], is_three));\n+    assert (!vec::all([3u, 3u, 2u], is_three));\n+    assert (vec::all([3u, 3u, 3u, 3u, 3u], is_three));\n+    assert (!vec::all([3u, 3u, 0u, 1u, 2u], is_three));\n }\n \n #[test]\n@@ -434,8 +434,8 @@ fn test_position_pred() {\n     fn less_than_three(&&i: int) -> bool { ret i < 3; }\n     fn is_eighteen(&&i: int) -> bool { ret i == 18; }\n     let v1: [int] = [5, 4, 3, 2, 1];\n-    assert (position_pred(less_than_three, v1) == option::some::<uint>(3u));\n-    assert (position_pred(is_eighteen, v1) == option::none::<uint>);\n+    assert (position_pred(v1, less_than_three) == option::some::<uint>(3u));\n+    assert (position_pred(v1, is_eighteen) == option::none::<uint>);\n }\n \n #[test]"}]}