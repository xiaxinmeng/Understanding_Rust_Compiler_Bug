{"sha": "0833a89a3eea21152a5d7fbfa5418da4057f6acd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4MzNhODlhM2VlYTIxMTUyYTVkN2ZiZmE1NDE4ZGE0MDU3ZjZhY2Q=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-11T05:35:18Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-14T04:58:32Z"}, "message": "resolve: refactor away `PRIVATE_VARIANT` and ensure that restricted\nreexports of private variants are handled correctly.", "tree": {"sha": "0238637a9d6cd3a8950d9196d86ef9d0bf254884", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0238637a9d6cd3a8950d9196d86ef9d0bf254884"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0833a89a3eea21152a5d7fbfa5418da4057f6acd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0833a89a3eea21152a5d7fbfa5418da4057f6acd", "html_url": "https://github.com/rust-lang/rust/commit/0833a89a3eea21152a5d7fbfa5418da4057f6acd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0833a89a3eea21152a5d7fbfa5418da4057f6acd/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0c3ce342427371c447730c56f395db888087179", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0c3ce342427371c447730c56f395db888087179", "html_url": "https://github.com/rust-lang/rust/commit/a0c3ce342427371c447730c56f395db888087179"}], "stats": {"total": 62, "additions": 32, "deletions": 30}, "files": [{"sha": "2bec7725b76b72c1e3c8e4003ec19c77a73750bf", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0833a89a3eea21152a5d7fbfa5418da4057f6acd/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0833a89a3eea21152a5d7fbfa5418da4057f6acd/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=0833a89a3eea21152a5d7fbfa5418da4057f6acd", "patch": "@@ -291,14 +291,9 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                 let module = self.new_module(parent_link, Some(def), false, vis);\n                 self.define(parent, name, TypeNS, (module, sp));\n \n-                let variant_modifiers = match vis {\n-                    ty::Visibility::Public => DefModifiers::empty(),\n-                    _ => DefModifiers::PRIVATE_VARIANT,\n-                };\n                 for variant in &(*enum_definition).variants {\n                     let item_def_id = self.ast_map.local_def_id(item.id);\n-                    self.build_reduced_graph_for_variant(variant, item_def_id,\n-                                                         module, variant_modifiers);\n+                    self.build_reduced_graph_for_variant(variant, item_def_id, module);\n                 }\n             }\n \n@@ -358,8 +353,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n     fn build_reduced_graph_for_variant(&mut self,\n                                        variant: &Variant,\n                                        item_id: DefId,\n-                                       parent: Module<'b>,\n-                                       variant_modifiers: DefModifiers) {\n+                                       parent: Module<'b>) {\n         let name = variant.node.name;\n         if variant.node.data.is_struct() {\n             // Not adding fields for variants as they are not accessed with a self receiver\n@@ -369,12 +363,11 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n \n         // Variants are always treated as importable to allow them to be glob used.\n         // All variants are defined in both type and value namespaces as future-proofing.\n-        let modifiers = DefModifiers::IMPORTABLE | variant_modifiers;\n+        let modifiers = DefModifiers::IMPORTABLE;\n         let def = Def::Variant(item_id, self.ast_map.local_def_id(variant.node.data.id()));\n-        let vis = ty::Visibility::Public;\n \n-        self.define(parent, name, ValueNS, (def, variant.span, modifiers, vis));\n-        self.define(parent, name, TypeNS, (def, variant.span, modifiers, vis));\n+        self.define(parent, name, ValueNS, (def, variant.span, modifiers, parent.vis));\n+        self.define(parent, name, TypeNS, (def, variant.span, modifiers, parent.vis));\n     }\n \n     /// Constructs the reduced graph for one foreign item."}, {"sha": "2147331d441d98b729c8e570b21148e2f31065f3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0833a89a3eea21152a5d7fbfa5418da4057f6acd/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0833a89a3eea21152a5d7fbfa5418da4057f6acd/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0833a89a3eea21152a5d7fbfa5418da4057f6acd", "patch": "@@ -919,9 +919,6 @@ bitflags! {\n     #[derive(Debug)]\n     flags DefModifiers: u8 {\n         const IMPORTABLE = 1 << 1,\n-        // Variants are considered `PUBLIC`, but some of them live in private enums.\n-        // We need to track them to prohibit reexports like `pub use PrivEnum::Variant`.\n-        const PRIVATE_VARIANT = 1 << 2,\n         const GLOB_IMPORTED = 1 << 3,\n     }\n }\n@@ -932,8 +929,6 @@ pub struct NameBinding<'a> {\n     modifiers: DefModifiers,\n     kind: NameBindingKind<'a>,\n     span: Option<Span>,\n-    // Enum variants are always considered `PUBLIC`, this is needed for `use Enum::Variant`\n-    // or `use Enum::*` to work on private enums.\n     vis: ty::Visibility,\n }\n \n@@ -982,8 +977,20 @@ impl<'a> NameBinding<'a> {\n         self.modifiers.contains(modifiers)\n     }\n \n-    fn is_public(&self) -> bool {\n-        self.vis == ty::Visibility::Public\n+    fn is_pseudo_public(&self) -> bool {\n+        self.pseudo_vis() == ty::Visibility::Public\n+    }\n+\n+    // We sometimes need to treat variants as `pub` for backwards compatibility\n+    fn pseudo_vis(&self) -> ty::Visibility {\n+        if self.is_variant() { ty::Visibility::Public } else { self.vis }\n+    }\n+\n+    fn is_variant(&self) -> bool {\n+        match self.kind {\n+            NameBindingKind::Def(Def::Variant(..)) => true,\n+            _ => false,\n+        }\n     }\n \n     fn is_extern_crate(&self) -> bool {\n@@ -3301,7 +3308,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // only if both the module is public and the entity is\n                         // declared as public (due to pruning, we don't explore\n                         // outside crate private modules => no need to check this)\n-                        if !in_module_is_extern || name_binding.is_public() {\n+                        if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                             lookup_results.push(path);\n                         }\n                     }\n@@ -3326,7 +3333,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         _ => bug!(),\n                     };\n \n-                    if !in_module_is_extern || name_binding.is_public() {\n+                    if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                         // add the module to the lookup\n                         let is_extern = in_module_is_extern || name_binding.is_extern_crate();\n                         worklist.push((module, path_segments, is_extern));"}, {"sha": "e712dbdcbf7af52a7d7597f29f12ece959d9f276", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0833a89a3eea21152a5d7fbfa5418da4057f6acd/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0833a89a3eea21152a5d7fbfa5418da4057f6acd/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=0833a89a3eea21152a5d7fbfa5418da4057f6acd", "patch": "@@ -184,7 +184,7 @@ impl<'a> NameResolution<'a> {\n                 // the name, and (3) no public glob has defined the name, the resolution depends\n                 // on whether more globs can define the name.\n                 if !allow_private_imports && directive.vis != ty::Visibility::Public &&\n-                   !self.binding.map(NameBinding::is_public).unwrap_or(false) {\n+                   !self.binding.map(NameBinding::is_pseudo_public).unwrap_or(false) {\n                     return None;\n                 }\n \n@@ -242,7 +242,8 @@ impl<'a> ::ModuleS<'a> {\n         if let Some(result) = resolution.try_result(ns, allow_private_imports) {\n             // If the resolution doesn't depend on glob definability, check privacy and return.\n             return result.and_then(|binding| {\n-                let allowed = allow_private_imports || !binding.is_import() || binding.is_public();\n+                let allowed = allow_private_imports || !binding.is_import() ||\n+                                                       binding.is_pseudo_public();\n                 if allowed { Success(binding) } else { Failed(None) }\n             });\n         }\n@@ -336,7 +337,7 @@ impl<'a> ::ModuleS<'a> {\n     }\n \n     fn define_in_glob_importers(&self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>) {\n-        if !binding.defined_with(DefModifiers::IMPORTABLE) || !binding.is_public() { return }\n+        if !binding.defined_with(DefModifiers::IMPORTABLE) || !binding.is_pseudo_public() { return }\n         for &(importer, directive) in self.glob_importers.borrow_mut().iter() {\n             let _ = importer.try_define_child(name, ns, directive.import(binding, None));\n         }\n@@ -569,7 +570,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         let ast_map = self.resolver.ast_map;\n         match (&value_result, &type_result) {\n-            (&Success(binding), _) if !binding.vis.is_at_least(directive.vis, ast_map) &&\n+            (&Success(binding), _) if !binding.pseudo_vis().is_at_least(directive.vis, ast_map) &&\n                                       self.resolver.is_accessible(binding.vis) => {\n                 let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                 let note_msg = format!(\"consider marking `{}` as `pub` in the imported module\",\n@@ -579,7 +580,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     .emit();\n             }\n \n-            (_, &Success(binding)) if !binding.vis.is_at_least(directive.vis, ast_map) &&\n+            (_, &Success(binding)) if !binding.pseudo_vis().is_at_least(directive.vis, ast_map) &&\n                                       self.resolver.is_accessible(binding.vis) => {\n                 if binding.is_extern_crate() {\n                     let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n@@ -661,7 +662,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             resolution.borrow().binding().map(|binding| (*name, binding))\n         }).collect::<Vec<_>>();\n         for ((name, ns), binding) in bindings {\n-            if binding.defined_with(DefModifiers::IMPORTABLE) && binding.is_public() {\n+            if binding.defined_with(DefModifiers::IMPORTABLE) && binding.is_pseudo_public() {\n                 let _ = module_.try_define_child(name, ns, directive.import(binding, None));\n             }\n         }\n@@ -697,15 +698,16 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 None => continue,\n             };\n \n-            if binding.is_public() && (binding.is_import() || binding.is_extern_crate()) {\n+            if binding.vis == ty::Visibility::Public &&\n+               (binding.is_import() || binding.is_extern_crate()) {\n                 if let Some(def) = binding.def() {\n                     reexports.push(Export { name: name, def_id: def.def_id() });\n                 }\n             }\n \n             if let NameBindingKind::Import { binding: orig_binding, id, .. } = binding.kind {\n-                if ns == TypeNS && binding.is_public() &&\n-                   orig_binding.defined_with(DefModifiers::PRIVATE_VARIANT) {\n+                if ns == TypeNS && orig_binding.is_variant() &&\n+                   !orig_binding.vis.is_at_least(binding.vis, &self.resolver.ast_map) {\n                     let msg = format!(\"variant `{}` is private, and cannot be reexported \\\n                                        (error E0364), consider declaring its enum as `pub`\",\n                                       name);"}]}