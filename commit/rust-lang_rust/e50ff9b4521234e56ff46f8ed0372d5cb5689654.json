{"sha": "e50ff9b4521234e56ff46f8ed0372d5cb5689654", "node_id": "C_kwDOAAsO6NoAKGU1MGZmOWI0NTIxMjM0ZTU2ZmY0NmY4ZWQwMzcyZDVjYjU2ODk2NTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-30T10:09:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-30T10:09:10Z"}, "message": "Auto merge of #95241 - Gankra:cleaned-provenance, r=workingjubilee\n\nStrict Provenance MVP\n\nThis patch series examines the question: how bad would it be if we adopted\nan extremely strict pointer provenance model that completely banished all\nint<->ptr casts.\n\nThe key insight to making this approach even *vaguely* pallatable is the\n\nptr.with_addr(addr) -> ptr\n\nfunction, which takes a pointer and an address and creates a new pointer\nwith that address and the provenance of the input pointer. In this way\nthe \"chain of custody\" is completely and dynamically restored, making the\nmodel suitable even for dynamic checkers like CHERI and Miri.\n\nThis is not a formal model, but lots of the docs discussing the model\nhave been updated to try to the *concept* of this design in the hopes\nthat it can be iterated on.\n\nSee #95228", "tree": {"sha": "cbdc3072e4ed48fb9ffbae2c29438a7c37ae1f06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbdc3072e4ed48fb9ffbae2c29438a7c37ae1f06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e50ff9b4521234e56ff46f8ed0372d5cb5689654", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e50ff9b4521234e56ff46f8ed0372d5cb5689654", "html_url": "https://github.com/rust-lang/rust/commit/e50ff9b4521234e56ff46f8ed0372d5cb5689654", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e50ff9b4521234e56ff46f8ed0372d5cb5689654/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05142a7e4495f09141fdd65f140fe44d8c200a9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/05142a7e4495f09141fdd65f140fe44d8c200a9e", "html_url": "https://github.com/rust-lang/rust/commit/05142a7e4495f09141fdd65f140fe44d8c200a9e"}, {"sha": "e3a3afe05099dc1f9078fa1f65ade467b92f42c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3a3afe05099dc1f9078fa1f65ade467b92f42c3", "html_url": "https://github.com/rust-lang/rust/commit/e3a3afe05099dc1f9078fa1f65ade467b92f42c3"}], "stats": {"total": 747, "additions": 621, "deletions": 126}, "files": [{"sha": "62995dfd2e2f0b96f731dee1ff9f06c060f779f5", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -18,6 +18,7 @@\n #![feature(decl_macro)]\n #![feature(rustc_attrs)]\n #![cfg_attr(test, feature(test))]\n+#![feature(strict_provenance)]\n \n use smallvec::SmallVec;\n \n@@ -87,7 +88,7 @@ impl<T> ArenaChunk<T> {\n         unsafe {\n             if mem::size_of::<T>() == 0 {\n                 // A pointer as large as possible for zero-sized elements.\n-                !0 as *mut T\n+                ptr::invalid_mut(!0)\n             } else {\n                 self.start().add(self.storage.len())\n             }\n@@ -199,7 +200,7 @@ impl<T> TypedArena<T> {\n         unsafe {\n             if mem::size_of::<T>() == 0 {\n                 self.ptr.set((self.ptr.get() as *mut u8).wrapping_offset(1) as *mut T);\n-                let ptr = mem::align_of::<T>() as *mut T;\n+                let ptr = ptr::NonNull::<T>::dangling().as_ptr();\n                 // Don't drop the object. This `write` is equivalent to `forget`.\n                 ptr::write(ptr, object);\n                 &mut *ptr\n@@ -216,7 +217,9 @@ impl<T> TypedArena<T> {\n \n     #[inline]\n     fn can_allocate(&self, additional: usize) -> bool {\n-        let available_bytes = self.end.get() as usize - self.ptr.get() as usize;\n+        // FIXME: this should *likely* use `offset_from`, but more\n+        // investigation is needed (including running tests in miri).\n+        let available_bytes = self.end.get().addr() - self.ptr.get().addr();\n         let additional_bytes = additional.checked_mul(mem::size_of::<T>()).unwrap();\n         available_bytes >= additional_bytes\n     }\n@@ -262,7 +265,9 @@ impl<T> TypedArena<T> {\n                 // If a type is `!needs_drop`, we don't need to keep track of how many elements\n                 // the chunk stores - the field will be ignored anyway.\n                 if mem::needs_drop::<T>() {\n-                    let used_bytes = self.ptr.get() as usize - last_chunk.start() as usize;\n+                    // FIXME: this should *likely* use `offset_from`, but more\n+                    // investigation is needed (including running tests in miri).\n+                    let used_bytes = self.ptr.get().addr() - last_chunk.start().addr();\n                     last_chunk.entries = used_bytes / mem::size_of::<T>();\n                 }\n \n@@ -288,9 +293,9 @@ impl<T> TypedArena<T> {\n     // chunks.\n     fn clear_last_chunk(&self, last_chunk: &mut ArenaChunk<T>) {\n         // Determine how much was filled.\n-        let start = last_chunk.start() as usize;\n+        let start = last_chunk.start().addr();\n         // We obtain the value of the pointer to the first uninitialized element.\n-        let end = self.ptr.get() as usize;\n+        let end = self.ptr.get().addr();\n         // We then calculate the number of elements to be dropped in the last chunk,\n         // which is the filled area's length.\n         let diff = if mem::size_of::<T>() == 0 {\n@@ -299,6 +304,8 @@ impl<T> TypedArena<T> {\n             // Recall that `end` was incremented for each allocated value.\n             end - start\n         } else {\n+            // FIXME: this should *likely* use `offset_from`, but more\n+            // investigation is needed (including running tests in miri).\n             (end - start) / mem::size_of::<T>()\n         };\n         // Pass that to the `destroy` method.\n@@ -395,15 +402,16 @@ impl DroplessArena {\n     /// request.\n     #[inline]\n     fn alloc_raw_without_grow(&self, layout: Layout) -> Option<*mut u8> {\n-        let start = self.start.get() as usize;\n-        let end = self.end.get() as usize;\n+        let start = self.start.get().addr();\n+        let old_end = self.end.get();\n+        let end = old_end.addr();\n \n         let align = layout.align();\n         let bytes = layout.size();\n \n         let new_end = end.checked_sub(bytes)? & !(align - 1);\n         if start <= new_end {\n-            let new_end = new_end as *mut u8;\n+            let new_end = old_end.with_addr(new_end);\n             self.end.set(new_end);\n             Some(new_end)\n         } else {"}, {"sha": "6cf6be79a8628d55e28f1083686eb390dc2f508b", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -6,6 +6,7 @@\n #![feature(once_cell)]\n #![feature(nll)]\n #![feature(associated_type_bounds)]\n+#![feature(strict_provenance)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n "}, {"sha": "5414c619dcbcaabd2354aaf8ed722664612a87fe", "filename": "compiler/rustc_codegen_ssa/src/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmono_item.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -116,7 +116,7 @@ impl<'a, 'tcx: 'a> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {\n     fn to_raw_string(&self) -> String {\n         match *self {\n             MonoItem::Fn(instance) => {\n-                format!(\"Fn({:?}, {})\", instance.def, instance.substs.as_ptr() as usize)\n+                format!(\"Fn({:?}, {})\", instance.def, instance.substs.as_ptr().addr())\n             }\n             MonoItem::Static(id) => format!(\"Static({:?})\", id),\n             MonoItem::GlobalAsm(id) => format!(\"GlobalAsm({:?})\", id),"}, {"sha": "065d071a2e3607019406961b33a4f8c1f2cc4e78", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -127,6 +127,7 @@\n #![feature(slice_ptr_len)]\n #![feature(slice_range)]\n #![feature(str_internals)]\n+#![feature(strict_provenance)]\n #![feature(trusted_len)]\n #![feature(trusted_random_access)]\n #![feature(try_trait_v2)]"}, {"sha": "0b57c36247e431a86b8ea947bfa5f1e65ae1e722", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -2115,13 +2115,12 @@ impl<T> Weak<T> {\n     #[rustc_const_unstable(feature = \"const_weak_new\", issue = \"95091\", reason = \"recently added\")]\n     #[must_use]\n     pub const fn new() -> Weak<T> {\n-        Weak { ptr: unsafe { NonNull::new_unchecked(usize::MAX as *mut RcBox<T>) } }\n+        Weak { ptr: unsafe { NonNull::new_unchecked(ptr::invalid_mut::<RcBox<T>>(usize::MAX)) } }\n     }\n }\n \n pub(crate) fn is_dangling<T: ?Sized>(ptr: *mut T) -> bool {\n-    let address = ptr as *mut () as usize;\n-    address == usize::MAX\n+    (ptr as *mut ()).addr() == usize::MAX\n }\n \n /// Helper type to allow accessing the reference counts without"}, {"sha": "31365562ddb50bbb8a1af3831ac534c120ced0d3", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -1043,9 +1043,9 @@ where\n \n     impl<T> Drop for MergeHole<T> {\n         fn drop(&mut self) {\n-            // `T` is not a zero-sized type, so it's okay to divide by its size.\n-            let len = (self.end as usize - self.start as usize) / mem::size_of::<T>();\n+            // `T` is not a zero-sized type, and these are pointers into a slice's elements.\n             unsafe {\n+                let len = self.end.offset_from(self.start) as usize;\n                 ptr::copy_nonoverlapping(self.start, self.dest, len);\n             }\n         }"}, {"sha": "f8b4d46ac105dec22f53adac86078c7aa87c2b19", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -1746,7 +1746,7 @@ impl<T> Weak<T> {\n     #[rustc_const_unstable(feature = \"const_weak_new\", issue = \"95091\", reason = \"recently added\")]\n     #[must_use]\n     pub const fn new() -> Weak<T> {\n-        Weak { ptr: unsafe { NonNull::new_unchecked(usize::MAX as *mut ArcInner<T>) } }\n+        Weak { ptr: unsafe { NonNull::new_unchecked(ptr::invalid_mut::<ArcInner<T>>(usize::MAX)) } }\n     }\n }\n "}, {"sha": "cc6dfb0e330176b43a2455d89e949076546456a7", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -159,7 +159,7 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let exact = if mem::size_of::<T>() == 0 {\n-            (self.end as usize).wrapping_sub(self.ptr as usize)\n+            self.end.addr().wrapping_sub(self.ptr.addr())\n         } else {\n             unsafe { self.end.offset_from(self.ptr) as usize }\n         };"}, {"sha": "0639d6eed62a540cec06f536c1061158ce01becc", "filename": "library/core/src/alloc/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -194,7 +194,7 @@ impl Layout {\n     #[inline]\n     pub const fn dangling(&self) -> NonNull<u8> {\n         // SAFETY: align is guaranteed to be non-zero\n-        unsafe { NonNull::new_unchecked(self.align() as *mut u8) }\n+        unsafe { NonNull::new_unchecked(crate::ptr::invalid_mut::<u8>(self.align())) }\n     }\n \n     /// Creates a layout describing the record that can hold a value"}, {"sha": "6c1d20f36e2f6aa1e182f5280dc97c03c97a865d", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -352,6 +352,10 @@ impl<'a> ArgumentV1<'a> {\n     }\n \n     fn as_usize(&self) -> Option<usize> {\n+        // We are type punning a bit here: USIZE_MARKER only takes an &usize but\n+        // formatter takes an &Opaque. Rust understandably doesn't think we should compare\n+        // the function pointers if they don't have the same signature, so we cast to\n+        // usizes to tell it that we just want to compare addresses.\n         if self.formatter as usize == USIZE_MARKER as usize {\n             // SAFETY: The `formatter` field is only set to USIZE_MARKER if\n             // the value is a usize, so this is safe\n@@ -2246,7 +2250,7 @@ impl<T: ?Sized> Pointer for *const T {\n             }\n             f.flags |= 1 << (FlagV1::Alternate as u32);\n \n-            let ret = LowerHex::fmt(&(ptr as usize), f);\n+            let ret = LowerHex::fmt(&(ptr.addr()), f);\n \n             f.width = old_width;\n             f.flags = old_flags;"}, {"sha": "45c9df0c930b900baca7c161504ea2b0f794703a", "filename": "library/core/src/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -793,7 +793,7 @@ mod impls {\n         #[inline]\n         fn hash<H: Hasher>(&self, state: &mut H) {\n             let (address, metadata) = self.to_raw_parts();\n-            state.write_usize(address as usize);\n+            state.write_usize(address.addr());\n             metadata.hash(state);\n         }\n     }\n@@ -803,7 +803,7 @@ mod impls {\n         #[inline]\n         fn hash<H: Hasher>(&self, state: &mut H) {\n             let (address, metadata) = self.to_raw_parts();\n-            state.write_usize(address as usize);\n+            state.write_usize(address.addr());\n             metadata.hash(state);\n         }\n     }"}, {"sha": "8ad4317c145ac7d78bbf6ea46b18dfd64639253a", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -1972,15 +1972,15 @@ extern \"rust-intrinsic\" {\n /// Checks whether `ptr` is properly aligned with respect to\n /// `align_of::<T>()`.\n pub(crate) fn is_aligned_and_not_null<T>(ptr: *const T) -> bool {\n-    !ptr.is_null() && ptr as usize % mem::align_of::<T>() == 0\n+    !ptr.is_null() && ptr.addr() % mem::align_of::<T>() == 0\n }\n \n /// Checks whether the regions of memory starting at `src` and `dst` of size\n /// `count * size_of::<T>()` do *not* overlap.\n #[cfg(debug_assertions)]\n pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -> bool {\n-    let src_usize = src as usize;\n-    let dst_usize = dst as usize;\n+    let src_usize = src.addr();\n+    let dst_usize = dst.addr();\n     let size = mem::size_of::<T>().checked_mul(count).unwrap();\n     let diff = if src_usize > dst_usize { src_usize - dst_usize } else { dst_usize - src_usize };\n     // If the absolute distance between the ptrs is at least as big as the size of the buffer,"}, {"sha": "20ee12802642169b7605f86bef50ec95ef80a38d", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 74, "deletions": 1, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -150,6 +150,79 @@ impl<T: ?Sized> *const T {\n         bits as Self\n     }\n \n+    /// Gets the \"address\" portion of the pointer.\n+    ///\n+    /// This is equivalent to `self as usize`, which semantically discards\n+    /// *provenance* and *address-space* information. To properly restore that information,\n+    /// use [`with_addr`][pointer::with_addr] or [`map_addr`][pointer::map_addr].\n+    ///\n+    /// On most platforms this will produce a value with the same bytes as the original\n+    /// pointer, because all the bytes are dedicated to describing the address.\n+    /// Platforms which need to store additional information in the pointer may\n+    /// perform a change of representation to produce a value containing only the address\n+    /// portion of the pointer. What that means is up to the platform to define.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n+    /// see the [module documentation][crate::ptr] for details.\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn addr(self) -> usize\n+    where\n+        T: Sized,\n+    {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        self as usize\n+    }\n+\n+    /// Creates a new pointer with the given address.\n+    ///\n+    /// This performs the same operation as an `addr as ptr` cast, but copies\n+    /// the *address-space* and *provenance* of `self` to the new pointer.\n+    /// This allows us to dynamically preserve and propagate this important\n+    /// information in a way that is otherwise impossible with a unary cast.\n+    ///\n+    /// This is equivalent to using [`wrapping_offset`][pointer::wrapping_offset] to offset\n+    /// `self` to the given address, and therefore has all the same capabilities and restrictions.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n+    /// see the [module documentation][crate::ptr] for details.\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn with_addr(self, addr: usize) -> Self\n+    where\n+        T: Sized,\n+    {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        //\n+        // In the mean-time, this operation is defined to be \"as if\" it was\n+        // a wrapping_offset, so we can emulate it as such. This should properly\n+        // restore pointer provenance even under today's compiler.\n+        let self_addr = self.addr() as isize;\n+        let dest_addr = addr as isize;\n+        let offset = dest_addr.wrapping_sub(self_addr);\n+\n+        // This is the canonical desugarring of this operation\n+        self.cast::<u8>().wrapping_offset(offset).cast::<T>()\n+    }\n+\n+    /// Creates a new pointer by mapping `self`'s address to a new one.\n+    ///\n+    /// This is a convenience for [`with_addr`][pointer::with_addr], see that method for details.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n+    /// see the [module documentation][crate::ptr] for details.\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn map_addr(self, f: impl FnOnce(usize) -> usize) -> Self\n+    where\n+        T: Sized,\n+    {\n+        self.with_addr(f(self.addr()))\n+    }\n+\n     /// Decompose a (possibly wide) pointer into its address and metadata components.\n     ///\n     /// The pointer can be later reconstructed with [`from_raw_parts`].\n@@ -1006,7 +1079,7 @@ impl<T> *const [T] {\n     /// use std::ptr;\n     ///\n     /// let slice: *const [i8] = ptr::slice_from_raw_parts(ptr::null(), 3);\n-    /// assert_eq!(slice.as_ptr(), 0 as *const i8);\n+    /// assert_eq!(slice.as_ptr(), ptr::null());\n     /// ```\n     #[inline]\n     #[unstable(feature = \"slice_ptr_get\", issue = \"74265\")]"}, {"sha": "6a7841d3de6af1b4c0b2db384513739412f4c91b", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 323, "deletions": 8, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -63,12 +63,269 @@\n //! separate allocated object), heap allocations (each allocation created by the global allocator is\n //! a separate allocated object), and `static` variables.\n //!\n+//!\n+//! # Strict Provenance\n+//!\n+//! **The following text is non-normative, insufficiently formal, and is an extremely strict\n+//! interpretation of provenance. It's ok if your code doesn't strictly conform to it.**\n+//!\n+//! [Strict Provenance][] is an experimental set of APIs that help tools that try\n+//! to validate the memory-safety of your program's execution. Notably this includes [miri][]\n+//! and [CHERI][], which can detect when you access out of bounds memory or otherwise violate\n+//! Rust's memory model.\n+//!\n+//! Provenance must exist in some form for any programming\n+//! language compiled for modern computer architectures, but specifying a model for provenance\n+//! in a way that is useful to both compilers and programmers is an ongoing challenge.\n+//! The [Strict Provenance][] experiment seeks to explore the question: *what if we just said you\n+//! couldn't do all the nasty operations that make provenance so messy?*\n+//!\n+//! What APIs would have to be removed? What APIs would have to be added? How much would code\n+//! have to change, and is it worse or better now? Would any patterns become truly inexpressible?\n+//! Could we carve out special exceptions for those patterns? Should we?\n+//!\n+//! A secondary goal of this project is to see if we can disamiguate the many functions of\n+//! pointer<->integer casts enough for the definition of `usize` to be loosened so that it\n+//! isn't *pointer*-sized but address-space/offset/allocation-sized (we'll probably continue\n+//! to conflate these notions). This would potentially make it possible to more efficiently\n+//! target platforms where pointers are larger than offsets, such as CHERI and maybe some\n+//! segmented architecures.\n+//!\n+//! ## Provenance\n+//!\n+//! **This section is *non-normative* and is part of the [Strict Provenance][] experiment.**\n+//!\n+//! Pointers are not *simply* an \"integer\" or \"address\". For instance, it's uncontroversial\n+//! to say that a Use After Free is clearly Undefined Behaviour, even if you \"get lucky\"\n+//! and the freed memory gets reallocated before your read/write (in fact this is the\n+//! worst-case scenario, UAFs would be much less concerning if this didn't happen!).\n+//! To rationalize this claim, pointers need to somehow be *more* than just their addresses:\n+//! they must have provenance.\n+//!\n+//! When an allocation is created, that allocation has a unique Original Pointer. For alloc\n+//! APIs this is literally the pointer the call returns, and for local variables and statics,\n+//! this is the name of the variable/static. This is mildly overloading the term \"pointer\"\n+//! for the sake of brevity/exposition.\n+//!\n+//! The Original Pointer for an allocation is guaranteed to have unique access to the entire\n+//! allocation and *only* that allocation. In this sense, an allocation can be thought of\n+//! as a \"sandbox\" that cannot be broken into or out of. *Provenance* is the permission\n+//! to access an allocation's sandbox and has both a *spatial* and *temporal* component:\n+//!\n+//! * Spatial: A range of bytes that the pointer is allowed to access.\n+//! * Temporal: The lifetime (of the allocation) that access to these bytes is tied to.\n+//!\n+//! Spatial provenance makes sure you don't go beyond your sandbox, while temporal provenance\n+//! makes sure that you can't \"get lucky\" after your permission to access some memory\n+//! has been revoked (either through deallocations or borrows expiring).\n+//!\n+//! Provenance is implicitly shared with all pointers transitively derived from\n+//! The Original Pointer through operations like [`offset`], borrowing, and pointer casts.\n+//! Some operations may *shrink* the derived provenance, limiting how much memory it can\n+//! access or how long it's valid for (i.e. borrowing a subfield and subslicing).\n+//!\n+//! Shrinking provenance cannot be undone: even if you \"know\" there is a larger allocation, you\n+//! can't derive a pointer with a larger provenance. Similarly, you cannot \"recombine\"\n+//! two contiguous provenances back into one (i.e. with a `fn merge(&[T], &[T]) -> &[T]`).\n+//!\n+//! A reference to a value always has provenance over exactly the memory that field occupies.\n+//! A reference to a slice always has provenance over exactly the range that slice describes.\n+//!\n+//! If an allocation is deallocated, all pointers with provenance to that allocation become\n+//! invalidated, and effectively lose their provenance.\n+//!\n+//! The strict provenance experiment is mostly only interested in exploring stricter *spatial*\n+//! provenance. In this sense it can be thought of as a subset of the more ambitious and\n+//! formal [Stacked Borrows][] research project, which is what tools like [miri][] are based on.\n+//! In particular, Stacked Borrows is necessary to properly describe what borrows are allowed\n+//! to do and when they become invalidated. This necessarily involves much more complex\n+//! *temporal* reasoning than simply identifying allocations. Adjusting APIs and code\n+//! for the strict provenance experiment will also greatly help Stacked Borrows.\n+//!\n+//!\n+//! ## Pointer Vs Addresses\n+//!\n+//! **This section is *non-normative* and is part of the [Strict Provenance][] experiment.**\n+//!\n+//! One of the largest historical issues with trying to define provenance is that programmers\n+//! freely convert between pointers and integers. Once you allow for this, it generally becomes\n+//! impossible to accurately track and preserve provenance information, and you need to appeal\n+//! to very complex and unreliable heuristics. But of course, converting between pointers and\n+//! integers is very useful, so what can we do?\n+//!\n+//! Also did you know WASM is actually a \"Harvard Architecture\"? As in function pointers are\n+//! handled completely differently from data pointers? And we kind of just shipped Rust on WASM\n+//! without really addressing the fact that we let you freely convert between function pointers\n+//! and data pointers, because it mostly Just Works? Let's just put that on the \"pointer casts\n+//! are dubious\" pile.\n+//!\n+//! Strict Provenance attempts to square these circles by decoupling Rust's traditional conflation\n+//! of pointers and `usize` (and `isize`), and defining a pointer to semantically contain the\n+//! following information:\n+//!\n+//! * The **address-space** it is part of (i.e. \"data\" vs \"code\" in WASM).\n+//! * The **address** it points to, which can be represented by a `usize`.\n+//! * The **provenance** it has, defining the memory it has permission to access.\n+//!\n+//! Under Strict Provenance, a usize *cannot* accurately represent a pointer, and converting from\n+//! a pointer to a usize is generally an operation which *only* extracts the address. It is\n+//! therefore *impossible* to construct a valid pointer from a usize because there is no way\n+//! to restore the address-space and provenance.\n+//!\n+//! The key insight to making this model *at all* viable is the [`with_addr`][] method:\n+//!\n+//! ```text\n+//!     /// Creates a new pointer with the given address.\n+//!     ///\n+//!     /// This performs the same operation as an `addr as ptr` cast, but copies\n+//!     /// the *address-space* and *provenance* of `self` to the new pointer.\n+//!     /// This allows us to dynamically preserve and propagate this important\n+//!     /// information in a way that is otherwise impossible with a unary cast.\n+//!     ///\n+//!     /// This is equivalent to using `wrapping_offset` to offset `self` to the\n+//!     /// given address, and therefore has all the same capabilities and restrictions.\n+//!     pub fn with_addr(self, addr: usize) -> Self;\n+//! ```\n+//!\n+//! So you're still able to drop down to the address representation and do whatever\n+//! clever bit tricks you want *as long as* you're able to keep around a pointer\n+//! into the allocation you care about that can \"reconstitute\" the other parts of the pointer.\n+//! Usually this is very easy, because you only are taking a pointer, messing with the address,\n+//! and then immediately converting back to a pointer. To make this use case more ergonomic,\n+//! we provide the [`map_addr`][] method.\n+//!\n+//! To help make it clear that code is \"following\" Strict Provenance semantics, we also\n+//! provide an [`addr`][] method which is currently equivalent to `ptr as usize`. In the\n+//! future we may provide a lint for pointer<->integer casts to help you audit if your\n+//! code conforms to strict provenance.\n+//!\n+//!\n+//! ## Using Strict Provenance\n+//!\n+//! Most code needs no changes to conform to strict provenance, as the only really concerning\n+//! operation that *wasn't* obviously already Undefined Behaviour is casts from usize to a\n+//! pointer. For code which *does* cast a usize to a pointer, the scope of the change depends\n+//! on exactly what you're doing.\n+//!\n+//! In general you just need to make sure that if you want to convert a usize address to a\n+//! pointer and then use that pointer to read/write memory, you need to keep around a pointer\n+//! that has sufficient provenance to perform that read/write itself. In this way all of your\n+//! casts from an address to a pointer are essentially just applying offsets/indexing.\n+//!\n+//! This is generally trivial to do for simple cases like tagged pointers *as long as you\n+//! represent the tagged pointer as an actual pointer and not a usize*. For instance:\n+//!\n+//! ```\n+//! #![feature(strict_provenance)]\n+//!\n+//! unsafe {\n+//!     // A flag we want to pack into our pointer\n+//!     static HAS_DATA: usize = 0x1;\n+//!     static FLAG_MASK: usize = !HAS_DATA;\n+//!\n+//!     // Our value, which must have enough alignment to have spare least-significant-bits.\n+//!     let my_precious_data: u32 = 17;\n+//!     assert!(core::mem::align_of::<u32>() > 1);\n+//!\n+//!     // Create a tagged pointer\n+//!     let ptr = &my_precious_data as *const u32;\n+//!     let tagged = ptr.map_addr(|addr| addr | HAS_DATA);\n+//!\n+//!     // Check the flag:\n+//!     if tagged.addr() & HAS_DATA != 0 {\n+//!         // Untag and read the pointer\n+//!         let data = *tagged.map_addr(|addr| addr & FLAG_MASK);\n+//!         assert_eq!(data, 17);\n+//!     } else {\n+//!         unreachable!()\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! (Yes, if you've been using AtomicUsize for pointers in concurrent datastructures, you should\n+//! be using AtomicPtr instead. If that messes up the way you atomically manipulate pointers,\n+//! we would like to know why, and what needs to be done to fix it.)\n+//!\n+//! Something more complicated and just generally *evil* like a XOR-List requires more significant\n+//! changes like allocating all nodes in a pre-allocated Vec or Arena and using a pointer\n+//! to the whole allocation to reconstitute the XORed addresses.\n+//!\n+//! Situations where a valid pointer *must* be created from just an address, such as baremetal code\n+//! accessing a memory-mapped interface at a fixed address, are an open question on how to support.\n+//! These situations *will* still be allowed, but we might require some kind of \"I know what I'm\n+//! doing\" annotation to explain the situation to the compiler. It's also possible they need no\n+//! special attention at all, because they're generally accessing memory outside the scope of\n+//! \"the abstract machine\", or already using \"I know what I'm doing\" annotations like \"volatile\".\n+//!\n+//! Under [Strict Provenance] is is Undefined Behaviour to:\n+//!\n+//! * Access memory through a pointer that does not have provenance over that memory.\n+//!\n+//! * [`offset`] a pointer to or from an address it doesn't have provenance over.\n+//!   This means it's always UB to offset a pointer derived from something deallocated,\n+//!   even if the offset is 0. Note that a pointer \"one past the end\" of its provenance\n+//!   is not actually outside its provenance, it just has 0 bytes it can load/store.\n+//!\n+//! But it *is* still sound to:\n+//!\n+//! * Create an invalid pointer from just an address (see [`ptr::invalid`][]). This can\n+//!   be used for sentinel values like `null` *or* to represent a tagged pointer that will\n+//!   never be dereferencable. In general, it is always sound for an integer to pretend\n+//!   to be a pointer \"for fun\" as long as you don't use operations on it which require\n+//!   it to be valid (offset, read, write, etc).\n+//!\n+//! * Forge an allocation of size zero at any sufficiently aligned non-null address.\n+//!   i.e. the usual \"ZSTs are fake, do what you want\" rules apply *but* this only applies\n+//!   for actual forgery (integers cast to pointers). If you borrow some struct's field\n+//!   that *happens* to be zero-sized, the resulting pointer will have provenance tied to\n+//!   that allocation and it will still get invalidated if the allocation gets deallocated.\n+//!   In the future we may introduce an API to make such a forged allocation explicit.\n+//!\n+//! * [`wrapping_offset`][] a pointer outside its provenance. This includes invalid pointers\n+//!   which have \"no\" provenance. Unfortunately there may be practical limits on this for a\n+//!   particular platform, and it's an open question as to how to specify this (if at all).\n+//!   Notably, [CHERI][] relies on a compression scheme that can't handle a\n+//!   pointer getting offset \"too far\" out of bounds. If this happens, the address\n+//!   returned by `addr` will be the value you expect, but the provenance will get invalidated\n+//!   and using it to read/write will fault. The details of this are architecture-specific\n+//!   and based on alignment, but the buffer on either side of the pointer's range is pretty\n+//!   generous (think kilobytes, not bytes).\n+//!\n+//! * Compare arbitrary pointers by address. Addresses *are* just integers and so there is\n+//!   always a coherent answer, even if the pointers are invalid or from different\n+//!   address-spaces/provenances. Of course, comparing addresses from different address-spaces\n+//!   is generally going to be *meaningless*, but so is comparing Kilograms to Meters, and Rust\n+//!   doesn't prevent that either. Similarly, if you get \"lucky\" and notice that a pointer\n+//!   one-past-the-end is the \"same\" address as the start of an unrelated allocation, anything\n+//!   you do with that fact is *probably* going to be gibberish. The scope of that gibberish\n+//!   is kept under control by the fact that the two pointers *still* aren't allowed to access\n+//!   the other's allocation (bytes), because they still have different provenance.\n+//!\n+//! * Perform pointer tagging tricks. This falls out of [`wrapping_offset`] but is worth\n+//!   mentioning in more detail because of the limitations of [CHERI][]. Low-bit tagging\n+//!   is very robust, and often doesn't even go out of bounds because types ensure\n+//!   size >= align (and over-aligning actually gives CHERI more flexibility). Anything\n+//!   more complex than this rapidly enters \"extremely platform-specific\" territory as\n+//!   certain things may or may not be allowed based on specific supported operations.\n+//!   For instance, ARM explicitly supports high-bit tagging, and so CHERI on ARM inherits\n+//!   that and should support it.\n+//!\n+//!\n //! [aliasing]: ../../nomicon/aliasing.html\n //! [book]: ../../book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer\n //! [ub]: ../../reference/behavior-considered-undefined.html\n //! [zst]: ../../nomicon/exotic-sizes.html#zero-sized-types-zsts\n //! [atomic operations]: crate::sync::atomic\n //! [`offset`]: pointer::offset\n+//! [`wrapping_offset`]: pointer::wrapping_offset\n+//! [`with_addr`]: pointer::with_addr\n+//! [`map_addr`]: pointer::map_addr\n+//! [`addr`]: pointer::addr\n+//! [`ptr::invalid`]: core::ptr::invalid\n+//! [miri]: https://github.com/rust-lang/miri\n+//! [CHERI]: https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/\n+//! [Strict Provenance]: https://github.com/rust-lang/rust/issues/95228\n+//! [Stacked Borrows]: https://plv.mpi-sws.org/rustbelt/stacked-borrows/\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -210,7 +467,7 @@ pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n #[rustc_const_stable(feature = \"const_ptr_null\", since = \"1.24.0\")]\n #[rustc_diagnostic_item = \"ptr_null\"]\n pub const fn null<T>() -> *const T {\n-    0 as *const T\n+    invalid(0)\n }\n \n /// Creates a null mutable raw pointer.\n@@ -230,7 +487,61 @@ pub const fn null<T>() -> *const T {\n #[rustc_const_stable(feature = \"const_ptr_null\", since = \"1.24.0\")]\n #[rustc_diagnostic_item = \"ptr_null_mut\"]\n pub const fn null_mut<T>() -> *mut T {\n-    0 as *mut T\n+    invalid_mut(0)\n+}\n+\n+/// Creates an invalid pointer with the given address.\n+///\n+/// This is *currently* equivalent to `addr as *const T` but it expresses the intended semantic\n+/// more clearly, and may become important under future memory models.\n+///\n+/// The module's top-level documentation discusses the precise meaning of an \"invalid\"\n+/// pointer but essentially this expresses that the pointer is not associated\n+/// with any actual allocation and is little more than a usize address in disguise.\n+///\n+/// This pointer will have no provenance associated with it and is therefore\n+/// UB to read/write/offset. This mostly exists to facilitate things\n+/// like ptr::null and NonNull::dangling which make invalid pointers.\n+///\n+/// (Standard \"Zero-Sized-Types get to cheat and lie\" caveats apply, although it\n+/// may be desirable to give them their own API just to make that 100% clear.)\n+///\n+/// This API and its claimed semantics are part of the Strict Provenance experiment,\n+/// see the [module documentation][crate::ptr] for details.\n+#[inline(always)]\n+#[must_use]\n+#[rustc_const_stable(feature = \"strict_provenance\", since = \"1.61.0\")]\n+#[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+pub const fn invalid<T>(addr: usize) -> *const T {\n+    // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+    addr as *const T\n+}\n+\n+/// Creates an invalid mutable pointer with the given address.\n+///\n+/// This is *currently* equivalent to `addr as *mut T` but it expresses the intended semantic\n+/// more clearly, and may become important under future memory models.\n+///\n+/// The module's top-level documentation discusses the precise meaning of an \"invalid\"\n+/// pointer but essentially this expresses that the pointer is not associated\n+/// with any actual allocation and is little more than a usize address in disguise.\n+///\n+/// This pointer will have no provenance associated with it and is therefore\n+/// UB to read/write/offset. This mostly exists to facilitate things\n+/// like ptr::null and NonNull::dangling which make invalid pointers.\n+///\n+/// (Standard \"Zero-Sized-Types get to cheat and lie\" caveats apply, although it\n+/// may be desirable to give them their own API just to make that 100% clear.)\n+///\n+/// This API and its claimed semantics are part of the Strict Provenance experiment,\n+/// see the [module documentation][crate::ptr] for details.\n+#[inline(always)]\n+#[must_use]\n+#[rustc_const_stable(feature = \"strict_provenance\", since = \"1.61.0\")]\n+#[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+pub const fn invalid_mut<T>(addr: usize) -> *mut T {\n+    // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+    addr as *mut T\n }\n \n /// Forms a raw slice from a pointer and a length.\n@@ -1110,6 +1421,8 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n         unchecked_shl, unchecked_shr, unchecked_sub, wrapping_add, wrapping_mul, wrapping_sub,\n     };\n \n+    let addr = p.addr();\n+\n     /// Calculate multiplicative modular inverse of `x` modulo `m`.\n     ///\n     /// This implementation is tailored for `align_offset` and has following preconditions:\n@@ -1170,13 +1483,10 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n         //\n         // which distributes operations around the load-bearing, but pessimizing `and` sufficiently\n         // for LLVM to be able to utilize the various optimizations it knows about.\n-        return wrapping_sub(\n-            wrapping_add(p as usize, a_minus_one) & wrapping_sub(0, a),\n-            p as usize,\n-        );\n+        return wrapping_sub(wrapping_add(addr, a_minus_one) & wrapping_sub(0, a), addr);\n     }\n \n-    let pmoda = p as usize & a_minus_one;\n+    let pmoda = addr & a_minus_one;\n     if pmoda == 0 {\n         // Already aligned. Yay!\n         return 0;\n@@ -1193,7 +1503,7 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     let gcd = unsafe { unchecked_shl(1usize, gcdpow) };\n \n     // SAFETY: gcd is always greater or equal to 1.\n-    if p as usize & unsafe { unchecked_sub(gcd, 1) } == 0 {\n+    if addr & unsafe { unchecked_sub(gcd, 1) } == 0 {\n         // This branch solves for the following linear congruence equation:\n         //\n         // ` p + so = 0 mod a `\n@@ -1347,6 +1657,11 @@ pub fn hash<T: ?Sized, S: hash::Hasher>(hashee: *const T, into: &mut S) {\n     hashee.hash(into);\n }\n \n+// FIXME(strict_provenance_magic): function pointers have buggy codegen that\n+// necessitates casting to a usize to get the backend to do the right thing.\n+// for now I will break AVR to silence *a billion* lints. We should probably\n+// have a proper \"opaque function pointer type\" to handle this kind of thing.\n+\n // Impls for function pointers\n macro_rules! fnptr_impls_safety_abi {\n     ($FnTy: ty, $($Arg: ident),*) => {"}, {"sha": "547208025214a173718216202e3dbecb7eac1510", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 74, "deletions": 1, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -154,6 +154,79 @@ impl<T: ?Sized> *mut T {\n         bits as Self\n     }\n \n+    /// Gets the \"address\" portion of the pointer.\n+    ///\n+    /// This is equivalent to `self as usize`, which semantically discards\n+    /// *provenance* and *address-space* information. To properly restore that information,\n+    /// use [`with_addr`][pointer::with_addr] or [`map_addr`][pointer::map_addr].\n+    ///\n+    /// On most platforms this will produce a value with the same bytes as the original\n+    /// pointer, because all the bytes are dedicated to describing the address.\n+    /// Platforms which need to store additional information in the pointer may\n+    /// perform a change of representation to produce a value containing only the address\n+    /// portion of the pointer. What that means is up to the platform to define.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n+    /// see the [module documentation][crate::ptr] for details.\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn addr(self) -> usize\n+    where\n+        T: Sized,\n+    {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        self as usize\n+    }\n+\n+    /// Creates a new pointer with the given address.\n+    ///\n+    /// This performs the same operation as an `addr as ptr` cast, but copies\n+    /// the *address-space* and *provenance* of `self` to the new pointer.\n+    /// This allows us to dynamically preserve and propagate this important\n+    /// information in a way that is otherwise impossible with a unary cast.\n+    ///\n+    /// This is equivalent to using [`wrapping_offset`][pointer::wrapping_offset] to offset\n+    /// `self` to the given address, and therefore has all the same capabilities and restrictions.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n+    /// see the [module documentation][crate::ptr] for details.\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn with_addr(self, addr: usize) -> Self\n+    where\n+        T: Sized,\n+    {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        //\n+        // In the mean-time, this operation is defined to be \"as if\" it was\n+        // a wrapping_offset, so we can emulate it as such. This should properly\n+        // restore pointer provenance even under today's compiler.\n+        let self_addr = self.addr() as isize;\n+        let dest_addr = addr as isize;\n+        let offset = dest_addr.wrapping_sub(self_addr);\n+\n+        // This is the canonical desugarring of this operation\n+        self.cast::<u8>().wrapping_offset(offset).cast::<T>()\n+    }\n+\n+    /// Creates a new pointer by mapping `self`'s address to a new one.\n+    ///\n+    /// This is a convenience for [`with_addr`][pointer::with_addr], see that method for details.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n+    /// see the [module documentation][crate::ptr] for details.\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn map_addr(self, f: impl FnOnce(usize) -> usize) -> Self\n+    where\n+        T: Sized,\n+    {\n+        self.with_addr(f(self.addr()))\n+    }\n+\n     /// Decompose a (possibly wide) pointer into its address and metadata components.\n     ///\n     /// The pointer can be later reconstructed with [`from_raw_parts_mut`].\n@@ -1276,7 +1349,7 @@ impl<T> *mut [T] {\n     /// use std::ptr;\n     ///\n     /// let slice: *mut [i8] = ptr::slice_from_raw_parts_mut(ptr::null_mut(), 3);\n-    /// assert_eq!(slice.as_mut_ptr(), 0 as *mut i8);\n+    /// assert_eq!(slice.as_mut_ptr(), ptr::null_mut());\n     /// ```\n     #[inline(always)]\n     #[unstable(feature = \"slice_ptr_get\", issue = \"74265\")]"}, {"sha": "c1b19895f006cf25af904765e4f7a5b9975b7ed4", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -90,7 +90,7 @@ impl<T: Sized> NonNull<T> {\n         // to a *mut T. Therefore, `ptr` is not null and the conditions for\n         // calling new_unchecked() are respected.\n         unsafe {\n-            let ptr = mem::align_of::<T>() as *mut T;\n+            let ptr = crate::ptr::invalid_mut::<T>(mem::align_of::<T>());\n             NonNull::new_unchecked(ptr)\n         }\n     }\n@@ -469,7 +469,7 @@ impl<T> NonNull<[T]> {\n     /// use std::ptr::NonNull;\n     ///\n     /// let slice: NonNull<[i8]> = NonNull::slice_from_raw_parts(NonNull::dangling(), 3);\n-    /// assert_eq!(slice.as_non_null_ptr(), NonNull::new(1 as *mut i8).unwrap());\n+    /// assert_eq!(slice.as_non_null_ptr(), NonNull::<i8>::dangling());\n     /// ```\n     #[inline]\n     #[must_use]\n@@ -489,7 +489,7 @@ impl<T> NonNull<[T]> {\n     /// use std::ptr::NonNull;\n     ///\n     /// let slice: NonNull<[i8]> = NonNull::slice_from_raw_parts(NonNull::dangling(), 3);\n-    /// assert_eq!(slice.as_mut_ptr(), 1 as *mut i8);\n+    /// assert_eq!(slice.as_mut_ptr(), NonNull::<i8>::dangling().as_ptr());\n     /// ```\n     #[inline]\n     #[must_use]"}, {"sha": "29398cbeb238dbeee8bd49f0e9285bd02e7792af", "filename": "library/core/src/ptr/unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Funique.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -73,7 +73,7 @@ impl<T: Sized> Unique<T> {\n     pub const fn dangling() -> Self {\n         // SAFETY: mem::align_of() returns a valid, non-null pointer. The\n         // conditions to call new_unchecked() are thus respected.\n-        unsafe { Unique::new_unchecked(mem::align_of::<T>() as *mut T) }\n+        unsafe { Unique::new_unchecked(crate::ptr::invalid_mut::<T>(mem::align_of::<T>())) }\n     }\n }\n "}, {"sha": "6c9107401fda659c556d8d7d9d00ebe7f8b0bd4a", "filename": "library/core/src/slice/ascii.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -294,17 +294,17 @@ fn is_ascii(s: &[u8]) -> bool {\n     // Paranoia check about alignment, since we're about to do a bunch of\n     // unaligned loads. In practice this should be impossible barring a bug in\n     // `align_offset` though.\n-    debug_assert_eq!((word_ptr as usize) % mem::align_of::<usize>(), 0);\n+    debug_assert_eq!(word_ptr.addr() % mem::align_of::<usize>(), 0);\n \n     // Read subsequent words until the last aligned word, excluding the last\n     // aligned word by itself to be done in tail check later, to ensure that\n     // tail is always one `usize` at most to extra branch `byte_pos == len`.\n     while byte_pos < len - USIZE_SIZE {\n         debug_assert!(\n             // Sanity check that the read is in bounds\n-            (word_ptr as usize + USIZE_SIZE) <= (start.wrapping_add(len) as usize) &&\n+            (word_ptr.addr() + USIZE_SIZE) <= start.addr().wrapping_add(len) &&\n             // And that our assumptions about `byte_pos` hold.\n-            (word_ptr as usize) - (start as usize) == byte_pos\n+            (word_ptr.addr() - start.addr()) == byte_pos\n         );\n \n         // SAFETY: We know `word_ptr` is properly aligned (because of"}, {"sha": "b74ab28fc092a9599e276016d4af985f3e184f2d", "filename": "library/core/src/slice/iter/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -20,13 +20,13 @@ macro_rules! len {\n         if size == 0 {\n             // This _cannot_ use `unchecked_sub` because we depend on wrapping\n             // to represent the length of long ZST slice iterators.\n-            ($self.end as usize).wrapping_sub(start.as_ptr() as usize)\n+            $self.end.addr().wrapping_sub(start.as_ptr().addr())\n         } else {\n             // We know that `start <= end`, so can do better than `offset_from`,\n             // which needs to deal in signed.  By setting appropriate flags here\n             // we can tell LLVM this, which helps it remove bounds checks.\n             // SAFETY: By the type invariant, `start <= end`\n-            let diff = unsafe { unchecked_sub($self.end as usize, start.as_ptr() as usize) };\n+            let diff = unsafe { unchecked_sub($self.end.addr(), start.as_ptr().addr()) };\n             // By also telling LLVM that the pointers are apart by an exact\n             // multiple of the type size, it can optimize `len() == 0` down to\n             // `start == end` instead of `(end - start) < size`."}, {"sha": "1f392a079718c252a6989c60dd952cbe8845bd7b", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -269,7 +269,9 @@ where\n     // Returns the number of elements between pointers `l` (inclusive) and `r` (exclusive).\n     fn width<T>(l: *mut T, r: *mut T) -> usize {\n         assert!(mem::size_of::<T>() > 0);\n-        (r as usize - l as usize) / mem::size_of::<T>()\n+        // FIXME: this should *likely* use `offset_from`, but more\n+        // investigation is needed (including running tests in miri).\n+        (r.addr() - l.addr()) / mem::size_of::<T>()\n     }\n \n     loop {"}, {"sha": "05e9b2eb6bc3cb64b513a7d0a1b454ce4d475f5d", "filename": "library/std/src/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fbacktrace.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -330,7 +330,7 @@ impl Backtrace {\n                     frame: RawFrame::Actual(frame.clone()),\n                     symbols: Vec::new(),\n                 });\n-                if frame.symbol_address() as usize == ip && actual_start.is_none() {\n+                if frame.symbol_address().addr() == ip && actual_start.is_none() {\n                     actual_start = Some(frames.len());\n                 }\n                 true\n@@ -493,7 +493,7 @@ impl RawFrame {\n         match self {\n             RawFrame::Actual(frame) => frame.ip(),\n             #[cfg(test)]\n-            RawFrame::Fake => 1 as *mut c_void,\n+            RawFrame::Fake => crate::ptr::invalid_mut(1),\n         }\n     }\n }"}, {"sha": "e80068b46abb9f360f34957c5b3f1ea01c0ca641", "filename": "library/std/src/io/error/repr_bitpacked.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -106,7 +106,7 @@ use super::{Custom, ErrorData, ErrorKind, SimpleMessage};\n use alloc::boxed::Box;\n use core::marker::PhantomData;\n use core::mem::{align_of, size_of};\n-use core::ptr::NonNull;\n+use core::ptr::{self, NonNull};\n \n // The 2 least-significant bits are used as tag.\n const TAG_MASK: usize = 0b11;\n@@ -136,7 +136,7 @@ impl Repr {\n         let p = Box::into_raw(b).cast::<u8>();\n         // Should only be possible if an allocator handed out a pointer with\n         // wrong alignment.\n-        debug_assert_eq!((p as usize & TAG_MASK), 0);\n+        debug_assert_eq!(p.addr() & TAG_MASK, 0);\n         // Note: We know `TAG_CUSTOM <= size_of::<Custom>()` (static_assert at\n         // end of file), and both the start and end of the expression must be\n         // valid without address space wraparound due to `Box`'s semantics.\n@@ -166,7 +166,7 @@ impl Repr {\n     pub(super) fn new_os(code: i32) -> Self {\n         let utagged = ((code as usize) << 32) | TAG_OS;\n         // Safety: `TAG_OS` is not zero, so the result of the `|` is not 0.\n-        let res = Self(unsafe { NonNull::new_unchecked(utagged as *mut ()) }, PhantomData);\n+        let res = Self(unsafe { NonNull::new_unchecked(ptr::invalid_mut(utagged)) }, PhantomData);\n         // quickly smoke-check we encoded the right thing (This generally will\n         // only run in libstd's tests, unless the user uses -Zbuild-std)\n         debug_assert!(\n@@ -180,7 +180,7 @@ impl Repr {\n     pub(super) fn new_simple(kind: ErrorKind) -> Self {\n         let utagged = ((kind as usize) << 32) | TAG_SIMPLE;\n         // Safety: `TAG_SIMPLE` is not zero, so the result of the `|` is not 0.\n-        let res = Self(unsafe { NonNull::new_unchecked(utagged as *mut ()) }, PhantomData);\n+        let res = Self(unsafe { NonNull::new_unchecked(ptr::invalid_mut(utagged)) }, PhantomData);\n         // quickly smoke-check we encoded the right thing (This generally will\n         // only run in libstd's tests, unless the user uses -Zbuild-std)\n         debug_assert!(\n@@ -238,7 +238,7 @@ unsafe fn decode_repr<C, F>(ptr: NonNull<()>, make_custom: F) -> ErrorData<C>\n where\n     F: FnOnce(*mut Custom) -> C,\n {\n-    let bits = ptr.as_ptr() as usize;\n+    let bits = ptr.as_ptr().addr();\n     match bits & TAG_MASK {\n         TAG_OS => {\n             let code = ((bits as i64) >> 32) as i32;"}, {"sha": "133ced5f26cfbdbf5df83d3cd011929503f925ee", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -275,6 +275,7 @@\n #![feature(extend_one)]\n #![feature(float_minimum_maximum)]\n #![feature(format_args_nl)]\n+#![feature(strict_provenance)]\n #![feature(get_mut_unchecked)]\n #![feature(hashmap_internals)]\n #![feature(int_error_internals)]"}, {"sha": "9aeae4b2cae691f1a578fa69ffb80337de5f92e7", "filename": "library/std/src/os/unix/net/addr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -17,8 +17,8 @@ mod libc {\n \n fn sun_path_offset(addr: &libc::sockaddr_un) -> usize {\n     // Work with an actual instance of the type since using a null pointer is UB\n-    let base = addr as *const _ as usize;\n-    let path = &addr.sun_path as *const _ as usize;\n+    let base = (addr as *const libc::sockaddr_un).addr();\n+    let path = (&addr.sun_path as *const libc::c_char).addr();\n     path - base\n }\n "}, {"sha": "ee30cc8be6b57c442c6114d9918aa9bbdc66d0e5", "filename": "library/std/src/os/windows/io/handle.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -9,6 +9,7 @@ use crate::fs;\n use crate::io;\n use crate::marker::PhantomData;\n use crate::mem::forget;\n+use crate::ptr;\n use crate::sys::c;\n use crate::sys::cvt;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n@@ -182,7 +183,7 @@ impl OwnedHandle {\n             return unsafe { Ok(Self::from_raw_handle(handle)) };\n         }\n \n-        let mut ret = 0 as c::HANDLE;\n+        let mut ret = ptr::null_mut();\n         cvt(unsafe {\n             let cur_proc = c::GetCurrentProcess();\n             c::DuplicateHandle("}, {"sha": "db93cd15d4ab77abe708d1a063b6e63cfadeb8f1", "filename": "library/std/src/os/windows/io/socket.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -129,6 +129,7 @@ impl OwnedSocket {\n         }\n     }\n \n+    // FIXME(strict_provenance_magic): we defined RawSocket to be a u64 ;-;\n     #[cfg(not(target_vendor = \"uwp\"))]\n     pub(crate) fn set_no_inherit(&self) -> io::Result<()> {\n         cvt(unsafe {"}, {"sha": "8ecea8ce07f6b7aa7560788f3945c05bfc71d6f4", "filename": "library/std/src/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -1449,8 +1449,8 @@ impl PathBuf {\n         };\n \n         // truncate until right after the file stem\n-        let end_file_stem = file_stem[file_stem.len()..].as_ptr() as usize;\n-        let start = os_str_as_u8_slice(&self.inner).as_ptr() as usize;\n+        let end_file_stem = file_stem[file_stem.len()..].as_ptr().addr();\n+        let start = os_str_as_u8_slice(&self.inner).as_ptr().addr();\n         let v = self.as_mut_vec();\n         v.truncate(end_file_stem.wrapping_sub(start));\n "}, {"sha": "d2dd4c075d2a942eadb4f626ba96d3b003628b0b", "filename": "library/std/src/sync/once.rs", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -91,9 +91,12 @@ use crate::cell::Cell;\n use crate::fmt;\n use crate::marker;\n use crate::panic::{RefUnwindSafe, UnwindSafe};\n-use crate::sync::atomic::{AtomicBool, AtomicUsize, Ordering};\n+use crate::ptr;\n+use crate::sync::atomic::{AtomicBool, AtomicPtr, Ordering};\n use crate::thread::{self, Thread};\n \n+type Masked = ();\n+\n /// A synchronization primitive which can be used to run a one-time global\n /// initialization. Useful for one-time initialization for FFI or related\n /// functionality. This type can only be constructed with [`Once::new()`].\n@@ -113,7 +116,7 @@ use crate::thread::{self, Thread};\n pub struct Once {\n     // `state_and_queue` is actually a pointer to a `Waiter` with extra state\n     // bits, so we add the `PhantomData` appropriately.\n-    state_and_queue: AtomicUsize,\n+    state_and_queue: AtomicPtr<Masked>,\n     _marker: marker::PhantomData<*const Waiter>,\n }\n \n@@ -136,7 +139,7 @@ impl RefUnwindSafe for Once {}\n #[derive(Debug)]\n pub struct OnceState {\n     poisoned: bool,\n-    set_state_on_drop_to: Cell<usize>,\n+    set_state_on_drop_to: Cell<*mut Masked>,\n }\n \n /// Initialization value for static [`Once`] values.\n@@ -184,8 +187,8 @@ struct Waiter {\n // Every node is a struct on the stack of a waiting thread.\n // Will wake up the waiters when it gets dropped, i.e. also on panic.\n struct WaiterQueue<'a> {\n-    state_and_queue: &'a AtomicUsize,\n-    set_state_on_drop_to: usize,\n+    state_and_queue: &'a AtomicPtr<Masked>,\n+    set_state_on_drop_to: *mut Masked,\n }\n \n impl Once {\n@@ -195,7 +198,10 @@ impl Once {\n     #[rustc_const_stable(feature = \"const_once_new\", since = \"1.32.0\")]\n     #[must_use]\n     pub const fn new() -> Once {\n-        Once { state_and_queue: AtomicUsize::new(INCOMPLETE), _marker: marker::PhantomData }\n+        Once {\n+            state_and_queue: AtomicPtr::new(ptr::invalid_mut(INCOMPLETE)),\n+            _marker: marker::PhantomData,\n+        }\n     }\n \n     /// Performs an initialization routine once and only once. The given closure\n@@ -376,7 +382,7 @@ impl Once {\n         // operations visible to us, and, this being a fast path, weaker\n         // ordering helps with performance. This `Acquire` synchronizes with\n         // `Release` operations on the slow path.\n-        self.state_and_queue.load(Ordering::Acquire) == COMPLETE\n+        self.state_and_queue.load(Ordering::Acquire).addr() == COMPLETE\n     }\n \n     // This is a non-generic function to reduce the monomorphization cost of\n@@ -395,7 +401,7 @@ impl Once {\n     fn call_inner(&self, ignore_poisoning: bool, init: &mut dyn FnMut(&OnceState)) {\n         let mut state_and_queue = self.state_and_queue.load(Ordering::Acquire);\n         loop {\n-            match state_and_queue {\n+            match state_and_queue.addr() {\n                 COMPLETE => break,\n                 POISONED if !ignore_poisoning => {\n                     // Panic to propagate the poison.\n@@ -405,7 +411,7 @@ impl Once {\n                     // Try to register this thread as the one RUNNING.\n                     let exchange_result = self.state_and_queue.compare_exchange(\n                         state_and_queue,\n-                        RUNNING,\n+                        ptr::invalid_mut(RUNNING),\n                         Ordering::Acquire,\n                         Ordering::Acquire,\n                     );\n@@ -417,13 +423,13 @@ impl Once {\n                     // wake them up on drop.\n                     let mut waiter_queue = WaiterQueue {\n                         state_and_queue: &self.state_and_queue,\n-                        set_state_on_drop_to: POISONED,\n+                        set_state_on_drop_to: ptr::invalid_mut(POISONED),\n                     };\n                     // Run the initialization function, letting it know if we're\n                     // poisoned or not.\n                     let init_state = OnceState {\n-                        poisoned: state_and_queue == POISONED,\n-                        set_state_on_drop_to: Cell::new(COMPLETE),\n+                        poisoned: state_and_queue.addr() == POISONED,\n+                        set_state_on_drop_to: Cell::new(ptr::invalid_mut(COMPLETE)),\n                     };\n                     init(&init_state);\n                     waiter_queue.set_state_on_drop_to = init_state.set_state_on_drop_to.get();\n@@ -432,7 +438,7 @@ impl Once {\n                 _ => {\n                     // All other values must be RUNNING with possibly a\n                     // pointer to the waiter queue in the more significant bits.\n-                    assert!(state_and_queue & STATE_MASK == RUNNING);\n+                    assert!(state_and_queue.addr() & STATE_MASK == RUNNING);\n                     wait(&self.state_and_queue, state_and_queue);\n                     state_and_queue = self.state_and_queue.load(Ordering::Acquire);\n                 }\n@@ -441,29 +447,29 @@ impl Once {\n     }\n }\n \n-fn wait(state_and_queue: &AtomicUsize, mut current_state: usize) {\n+fn wait(state_and_queue: &AtomicPtr<Masked>, mut current_state: *mut Masked) {\n     // Note: the following code was carefully written to avoid creating a\n     // mutable reference to `node` that gets aliased.\n     loop {\n         // Don't queue this thread if the status is no longer running,\n         // otherwise we will not be woken up.\n-        if current_state & STATE_MASK != RUNNING {\n+        if current_state.addr() & STATE_MASK != RUNNING {\n             return;\n         }\n \n         // Create the node for our current thread.\n         let node = Waiter {\n             thread: Cell::new(Some(thread::current())),\n             signaled: AtomicBool::new(false),\n-            next: (current_state & !STATE_MASK) as *const Waiter,\n+            next: current_state.with_addr(current_state.addr() & !STATE_MASK) as *const Waiter,\n         };\n-        let me = &node as *const Waiter as usize;\n+        let me = &node as *const Waiter as *const Masked as *mut Masked;\n \n         // Try to slide in the node at the head of the linked list, making sure\n         // that another thread didn't just replace the head of the linked list.\n         let exchange_result = state_and_queue.compare_exchange(\n             current_state,\n-            me | RUNNING,\n+            me.with_addr(me.addr() | RUNNING),\n             Ordering::Release,\n             Ordering::Relaxed,\n         );\n@@ -502,7 +508,7 @@ impl Drop for WaiterQueue<'_> {\n             self.state_and_queue.swap(self.set_state_on_drop_to, Ordering::AcqRel);\n \n         // We should only ever see an old state which was RUNNING.\n-        assert_eq!(state_and_queue & STATE_MASK, RUNNING);\n+        assert_eq!(state_and_queue.addr() & STATE_MASK, RUNNING);\n \n         // Walk the entire linked list of waiters and wake them up (in lifo\n         // order, last to register is first to wake up).\n@@ -511,7 +517,8 @@ impl Drop for WaiterQueue<'_> {\n             // free `node` if there happens to be has a spurious wakeup.\n             // So we have to take out the `thread` field and copy the pointer to\n             // `next` first.\n-            let mut queue = (state_and_queue & !STATE_MASK) as *const Waiter;\n+            let mut queue =\n+                state_and_queue.with_addr(state_and_queue.addr() & !STATE_MASK) as *const Waiter;\n             while !queue.is_null() {\n                 let next = (*queue).next;\n                 let thread = (*queue).thread.take().unwrap();\n@@ -568,6 +575,6 @@ impl OnceState {\n     /// Poison the associated [`Once`] without explicitly panicking.\n     // NOTE: This is currently only exposed for the `lazy` module\n     pub(crate) fn poison(&self) {\n-        self.set_state_on_drop_to.set(POISONED);\n+        self.set_state_on_drop_to.set(ptr::invalid_mut(POISONED));\n     }\n }"}, {"sha": "73ba604eccba2fc8feed75879c3fcfef972f9d30", "filename": "library/std/src/sys/unix/memchr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmemchr.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -9,7 +9,7 @@ pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n             haystack.len(),\n         )\n     };\n-    if p.is_null() { None } else { Some(p as usize - (haystack.as_ptr() as usize)) }\n+    if p.is_null() { None } else { Some(p.addr() - haystack.as_ptr().addr()) }\n }\n \n pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n@@ -26,7 +26,9 @@ pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n                 haystack.len(),\n             )\n         };\n-        if p.is_null() { None } else { Some(p as usize - (haystack.as_ptr() as usize)) }\n+        // FIXME: this should *likely* use `offset_from`, but more\n+        // investigation is needed (including running tests in miri).\n+        if p.is_null() { None } else { Some(p.addr() - haystack.as_ptr().addr()) }\n     }\n \n     #[cfg(not(target_os = \"linux\"))]"}, {"sha": "be70d00cb1ace5c622849ed2242f5b1468d2185c", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -505,24 +505,24 @@ pub mod guard {\n     #[cfg(target_os = \"macos\")]\n     unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n         let th = libc::pthread_self();\n-        let stackaddr =\n-            libc::pthread_get_stackaddr_np(th) as usize - libc::pthread_get_stacksize_np(th);\n-        Some(stackaddr as *mut libc::c_void)\n+        let stackptr = libc::pthread_get_stackaddr_np(th);\n+        Some(stackptr.map_addr(|addr| addr - libc::pthread_get_stacksize_np(th)))\n     }\n \n     #[cfg(target_os = \"openbsd\")]\n     unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n         let mut current_stack: libc::stack_t = crate::mem::zeroed();\n         assert_eq!(libc::pthread_stackseg_np(libc::pthread_self(), &mut current_stack), 0);\n \n+        let stack_ptr = current_stack.ss_sp;\n         let stackaddr = if libc::pthread_main_np() == 1 {\n             // main thread\n-            current_stack.ss_sp as usize - current_stack.ss_size + PAGE_SIZE.load(Ordering::Relaxed)\n+            stack_ptr.addr() - current_stack.ss_size + PAGE_SIZE.load(Ordering::Relaxed)\n         } else {\n             // new thread\n-            current_stack.ss_sp as usize - current_stack.ss_size\n+            stack_ptr.addr() - current_stack.ss_size\n         };\n-        Some(stackaddr as *mut libc::c_void)\n+        Some(stack_ptr.with_addr(stack_addr))\n     }\n \n     #[cfg(any(\n@@ -557,19 +557,20 @@ pub mod guard {\n     unsafe fn get_stack_start_aligned() -> Option<*mut libc::c_void> {\n         let page_size = PAGE_SIZE.load(Ordering::Relaxed);\n         assert!(page_size != 0);\n-        let stackaddr = get_stack_start()?;\n+        let stackptr = get_stack_start()?;\n+        let stackaddr = stackptr.addr();\n \n         // Ensure stackaddr is page aligned! A parent process might\n         // have reset RLIMIT_STACK to be non-page aligned. The\n         // pthread_attr_getstack() reports the usable stack area\n         // stackaddr < stackaddr + stacksize, so if stackaddr is not\n         // page-aligned, calculate the fix such that stackaddr <\n         // new_page_aligned_stackaddr < stackaddr + stacksize\n-        let remainder = (stackaddr as usize) % page_size;\n+        let remainder = stackaddr % page_size;\n         Some(if remainder == 0 {\n-            stackaddr\n+            stackptr\n         } else {\n-            ((stackaddr as usize) + page_size - remainder) as *mut libc::c_void\n+            stackptr.with_addr(stackaddr + page_size - remainder)\n         })\n     }\n \n@@ -588,8 +589,8 @@ pub mod guard {\n             // Instead, we'll just note where we expect rlimit to start\n             // faulting, so our handler can report \"stack overflow\", and\n             // trust that the kernel's own stack guard will work.\n-            let stackaddr = get_stack_start_aligned()?;\n-            let stackaddr = stackaddr as usize;\n+            let stackptr = get_stack_start_aligned()?;\n+            let stackaddr = stackptr.addr();\n             Some(stackaddr - page_size..stackaddr)\n         } else if cfg!(all(target_os = \"linux\", target_env = \"musl\")) {\n             // For the main thread, the musl's pthread_attr_getstack\n@@ -602,8 +603,8 @@ pub mod guard {\n             // at the bottom.  If we try to remap the bottom of the stack\n             // ourselves, FreeBSD's guard page moves upwards.  So we'll just use\n             // the builtin guard page.\n-            let stackaddr = get_stack_start_aligned()?;\n-            let guardaddr = stackaddr as usize;\n+            let stackptr = get_stack_start_aligned()?;\n+            let guardaddr = stackptr.addr();\n             // Technically the number of guard pages is tunable and controlled\n             // by the security.bsd.stack_guard_page sysctl, but there are\n             // few reasons to change it from the default.  The default value has\n@@ -620,33 +621,34 @@ pub mod guard {\n             // than the initial mmap() used, so we mmap() here with\n             // read/write permissions and only then mprotect() it to\n             // no permissions at all. See issue #50313.\n-            let stackaddr = get_stack_start_aligned()?;\n+            let stackptr = get_stack_start_aligned()?;\n             let result = mmap(\n-                stackaddr,\n+                stackptr,\n                 page_size,\n                 PROT_READ | PROT_WRITE,\n                 MAP_PRIVATE | MAP_ANON | MAP_FIXED,\n                 -1,\n                 0,\n             );\n-            if result != stackaddr || result == MAP_FAILED {\n+            if result != stackptr || result == MAP_FAILED {\n                 panic!(\"failed to allocate a guard page: {}\", io::Error::last_os_error());\n             }\n \n-            let result = mprotect(stackaddr, page_size, PROT_NONE);\n+            let result = mprotect(stackptr, page_size, PROT_NONE);\n             if result != 0 {\n                 panic!(\"failed to protect the guard page: {}\", io::Error::last_os_error());\n             }\n \n-            let guardaddr = stackaddr as usize;\n+            let guardaddr = stackptr.addr();\n \n             Some(guardaddr..guardaddr + page_size)\n         }\n     }\n \n     #[cfg(any(target_os = \"macos\", target_os = \"openbsd\", target_os = \"solaris\"))]\n     pub unsafe fn current() -> Option<Guard> {\n-        let stackaddr = get_stack_start()? as usize;\n+        let stackptr = get_stack_start()?;\n+        let stackaddr = stackptr.addr();\n         Some(stackaddr - PAGE_SIZE.load(Ordering::Relaxed)..stackaddr)\n     }\n \n@@ -679,11 +681,11 @@ pub mod guard {\n                     panic!(\"there is no guard page\");\n                 }\n             }\n-            let mut stackaddr = crate::ptr::null_mut();\n+            let mut stackptr = crate::ptr::null_mut::<libc::c_void>();\n             let mut size = 0;\n-            assert_eq!(libc::pthread_attr_getstack(&attr, &mut stackaddr, &mut size), 0);\n+            assert_eq!(libc::pthread_attr_getstack(&attr, &mut stackptr, &mut size), 0);\n \n-            let stackaddr = stackaddr as usize;\n+            let stackaddr = stackptr.addr();\n             ret = if cfg!(any(target_os = \"freebsd\", target_os = \"netbsd\")) {\n                 Some(stackaddr - guardsize..stackaddr)\n             } else if cfg!(all(target_os = \"linux\", target_env = \"musl\")) {"}, {"sha": "fdc81cdea7dec36fcb690dabffb4d88dc4d6f246", "filename": "library/std/src/sys/windows/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -159,7 +159,7 @@ unsafe fn allocate(layout: Layout, zeroed: bool) -> *mut u8 {\n         // Create a correctly aligned pointer offset from the start of the allocated block,\n         // and write a header before it.\n \n-        let offset = layout.align() - (ptr as usize & (layout.align() - 1));\n+        let offset = layout.align() - (ptr.addr() & (layout.align() - 1));\n         // SAFETY: `MIN_ALIGN` <= `offset` <= `layout.align()` and the size of the allocated\n         // block is `layout.align() + layout.size()`. `aligned` will thus be a correctly aligned\n         // pointer inside the allocated block with at least `layout.size()` bytes after it and at"}, {"sha": "0edf43e5d9dd5f2993aad353665c894c81bcb256", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -173,7 +173,7 @@ pub const PROGRESS_CONTINUE: DWORD = 0;\n \n pub const E_NOTIMPL: HRESULT = 0x80004001u32 as HRESULT;\n \n-pub const INVALID_HANDLE_VALUE: HANDLE = !0 as HANDLE;\n+pub const INVALID_HANDLE_VALUE: HANDLE = ptr::invalid_mut(!0);\n \n pub const FACILITY_NT_BIT: DWORD = 0x1000_0000;\n "}, {"sha": "a914a3bcc120be35b45ee7cecd6c9b7b71c4720c", "filename": "library/std/src/sys/windows/compat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -88,7 +88,7 @@ macro_rules! compat_fn {\n                 let symbol_name: *const u8 = concat!(stringify!($symbol), \"\\0\").as_ptr();\n                 let module_handle = $crate::sys::c::GetModuleHandleA(module_name as *const i8);\n                 if !module_handle.is_null() {\n-                    match $crate::sys::c::GetProcAddress(module_handle, symbol_name as *const i8) as usize {\n+                    match $crate::sys::c::GetProcAddress(module_handle, symbol_name as *const i8).addr() {\n                         0 => {}\n                         n => {\n                             PTR = Some(mem::transmute::<usize, F>(n));"}, {"sha": "95903899297b601a8ad84679c8699b21d492c497", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -57,6 +57,9 @@ pub struct DirEntry {\n     data: c::WIN32_FIND_DATAW,\n }\n \n+unsafe impl Send for OpenOptions {}\n+unsafe impl Sync for OpenOptions {}\n+\n #[derive(Clone, Debug)]\n pub struct OpenOptions {\n     // generic\n@@ -72,7 +75,7 @@ pub struct OpenOptions {\n     attributes: c::DWORD,\n     share_mode: c::DWORD,\n     security_qos_flags: c::DWORD,\n-    security_attributes: usize, // FIXME: should be a reference\n+    security_attributes: c::LPSECURITY_ATTRIBUTES,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n@@ -187,7 +190,7 @@ impl OpenOptions {\n             share_mode: c::FILE_SHARE_READ | c::FILE_SHARE_WRITE | c::FILE_SHARE_DELETE,\n             attributes: 0,\n             security_qos_flags: 0,\n-            security_attributes: 0,\n+            security_attributes: ptr::null_mut(),\n         }\n     }\n \n@@ -228,7 +231,7 @@ impl OpenOptions {\n         self.security_qos_flags = flags | c::SECURITY_SQOS_PRESENT;\n     }\n     pub fn security_attributes(&mut self, attrs: c::LPSECURITY_ATTRIBUTES) {\n-        self.security_attributes = attrs as usize;\n+        self.security_attributes = attrs;\n     }\n \n     fn get_access_mode(&self) -> io::Result<c::DWORD> {\n@@ -289,7 +292,7 @@ impl File {\n                 path.as_ptr(),\n                 opts.get_access_mode()?,\n                 opts.share_mode,\n-                opts.security_attributes as *mut _,\n+                opts.security_attributes,\n                 opts.get_creation_mode()?,\n                 opts.get_flags_and_attributes(),\n                 ptr::null_mut(),"}, {"sha": "87e3fec6353f9e7e72fe0ea69c9ab5785bdd9005", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -136,7 +136,7 @@ pub fn unrolled_find_u16s(needle: u16, haystack: &[u16]) -> Option<usize> {\n             ($($n:literal,)+) => {\n                 $(\n                     if start[$n] == needle {\n-                        return Some((&start[$n] as *const u16 as usize - ptr as usize) / 2);\n+                        return Some(((&start[$n] as *const u16).addr() - ptr.addr()) / 2);\n                     }\n                 )+\n             }\n@@ -149,7 +149,7 @@ pub fn unrolled_find_u16s(needle: u16, haystack: &[u16]) -> Option<usize> {\n \n     for c in start {\n         if *c == needle {\n-            return Some((c as *const u16 as usize - ptr as usize) / 2);\n+            return Some(((c as *const u16).addr() - ptr.addr()) / 2);\n         }\n     }\n     None"}, {"sha": "bcac996c024ec34fe84d70b249b22082e68a44ac", "filename": "library/std/src/sys/windows/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -134,7 +134,7 @@ impl Drop for Env {\n pub fn env() -> Env {\n     unsafe {\n         let ch = c::GetEnvironmentStringsW();\n-        if ch as usize == 0 {\n+        if ch.is_null() {\n             panic!(\"failure getting env string from OS: {}\", io::Error::last_os_error());\n         }\n         Env { base: ch, cur: ch }"}, {"sha": "3497da51deeda54d9d391bfc9064abafed912418", "filename": "library/std/src/sys/windows/thread_parker.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -60,7 +60,7 @@\n use crate::convert::TryFrom;\n use crate::ptr;\n use crate::sync::atomic::{\n-    AtomicI8, AtomicUsize,\n+    AtomicI8, AtomicPtr,\n     Ordering::{Acquire, Relaxed, Release},\n };\n use crate::sys::{c, dur2timeout};\n@@ -217,8 +217,8 @@ impl Parker {\n }\n \n fn keyed_event_handle() -> c::HANDLE {\n-    const INVALID: usize = !0;\n-    static HANDLE: AtomicUsize = AtomicUsize::new(INVALID);\n+    const INVALID: c::HANDLE = ptr::invalid_mut(!0);\n+    static HANDLE: AtomicPtr<libc::c_void> = AtomicPtr::new(INVALID);\n     match HANDLE.load(Relaxed) {\n         INVALID => {\n             let mut handle = c::INVALID_HANDLE_VALUE;\n@@ -233,18 +233,18 @@ fn keyed_event_handle() -> c::HANDLE {\n                     r => panic!(\"Unable to create keyed event handle: error {r}\"),\n                 }\n             }\n-            match HANDLE.compare_exchange(INVALID, handle as usize, Relaxed, Relaxed) {\n+            match HANDLE.compare_exchange(INVALID, handle, Relaxed, Relaxed) {\n                 Ok(_) => handle,\n                 Err(h) => {\n                     // Lost the race to another thread initializing HANDLE before we did.\n                     // Closing our handle and using theirs instead.\n                     unsafe {\n                         c::CloseHandle(handle);\n                     }\n-                    h as c::HANDLE\n+                    h\n                 }\n             }\n         }\n-        handle => handle as c::HANDLE,\n+        handle => handle,\n     }\n }"}, {"sha": "7671850ac55b8502d7c8187399baecec2520576e", "filename": "library/std/src/sys_common/condvar/check.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar%2Fcheck.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -1,4 +1,5 @@\n-use crate::sync::atomic::{AtomicUsize, Ordering};\n+use crate::ptr;\n+use crate::sync::atomic::{AtomicPtr, Ordering};\n use crate::sys::locks as imp;\n use crate::sys_common::mutex::MovableMutex;\n \n@@ -13,17 +14,18 @@ impl CondvarCheck for Box<imp::Mutex> {\n }\n \n pub struct SameMutexCheck {\n-    addr: AtomicUsize,\n+    addr: AtomicPtr<()>,\n }\n \n #[allow(dead_code)]\n impl SameMutexCheck {\n     pub const fn new() -> Self {\n-        Self { addr: AtomicUsize::new(0) }\n+        Self { addr: AtomicPtr::new(ptr::null_mut()) }\n     }\n     pub fn verify(&self, mutex: &MovableMutex) {\n-        let addr = mutex.raw() as *const imp::Mutex as usize;\n-        match self.addr.compare_exchange(0, addr, Ordering::SeqCst, Ordering::SeqCst) {\n+        let addr = mutex.raw() as *const imp::Mutex as *const () as *mut _;\n+        match self.addr.compare_exchange(ptr::null_mut(), addr, Ordering::SeqCst, Ordering::SeqCst)\n+        {\n             Ok(_) => {}               // Stored the address\n             Err(n) if n == addr => {} // Lost a race to store the same address\n             _ => panic!(\"attempted to use a condition variable with two mutexes\"),"}, {"sha": "ca29261b1c98d05082d1fe3d50aae3a532672736", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -1071,7 +1071,7 @@ pub mod os {\n         pub unsafe fn get(&'static self, init: impl FnOnce() -> T) -> Option<&'static T> {\n             // SAFETY: See the documentation for this method.\n             let ptr = unsafe { self.os.get() as *mut Value<T> };\n-            if ptr as usize > 1 {\n+            if ptr.addr() > 1 {\n                 // SAFETY: the check ensured the pointer is safe (its destructor\n                 // is not running) + it is coming from a trusted source (self).\n                 if let Some(ref value) = unsafe { (*ptr).inner.get() } {\n@@ -1090,7 +1090,7 @@ pub mod os {\n             // SAFETY: No mutable references are ever handed out meaning getting\n             // the value is ok.\n             let ptr = unsafe { self.os.get() as *mut Value<T> };\n-            if ptr as usize == 1 {\n+            if ptr.addr() == 1 {\n                 // destructor is running\n                 return None;\n             }\n@@ -1130,7 +1130,7 @@ pub mod os {\n         unsafe {\n             let ptr = Box::from_raw(ptr as *mut Value<T>);\n             let key = ptr.key;\n-            key.os.set(1 as *mut u8);\n+            key.os.set(ptr::invalid_mut(1));\n             drop(ptr);\n             key.os.set(ptr::null_mut());\n         }"}]}