{"sha": "bcdf57e220e022e9507b97299f5f0d3f1a5c027a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjZGY1N2UyMjBlMDIyZTk1MDdiOTcyOTlmNWYwZDNmMWE1YzAyN2E=", "commit": {"author": {"name": "laurent", "email": "laurent.mazare@gmail.com", "date": "2017-11-05T14:43:28Z"}, "committer": {"name": "laurent", "email": "laurent.mazare@gmail.com", "date": "2017-11-05T14:43:28Z"}, "message": "Refactor the never-loop detection, fixes #1991.", "tree": {"sha": "4eec5f9f63fc1f72c85ef0e70a14c4524d90a08e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4eec5f9f63fc1f72c85ef0e70a14c4524d90a08e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcdf57e220e022e9507b97299f5f0d3f1a5c027a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcdf57e220e022e9507b97299f5f0d3f1a5c027a", "html_url": "https://github.com/rust-lang/rust/commit/bcdf57e220e022e9507b97299f5f0d3f1a5c027a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcdf57e220e022e9507b97299f5f0d3f1a5c027a/comments", "author": {"login": "LaurentMazare", "id": 1041292, "node_id": "MDQ6VXNlcjEwNDEyOTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1041292?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LaurentMazare", "html_url": "https://github.com/LaurentMazare", "followers_url": "https://api.github.com/users/LaurentMazare/followers", "following_url": "https://api.github.com/users/LaurentMazare/following{/other_user}", "gists_url": "https://api.github.com/users/LaurentMazare/gists{/gist_id}", "starred_url": "https://api.github.com/users/LaurentMazare/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LaurentMazare/subscriptions", "organizations_url": "https://api.github.com/users/LaurentMazare/orgs", "repos_url": "https://api.github.com/users/LaurentMazare/repos", "events_url": "https://api.github.com/users/LaurentMazare/events{/privacy}", "received_events_url": "https://api.github.com/users/LaurentMazare/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LaurentMazare", "id": 1041292, "node_id": "MDQ6VXNlcjEwNDEyOTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1041292?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LaurentMazare", "html_url": "https://github.com/LaurentMazare", "followers_url": "https://api.github.com/users/LaurentMazare/followers", "following_url": "https://api.github.com/users/LaurentMazare/following{/other_user}", "gists_url": "https://api.github.com/users/LaurentMazare/gists{/gist_id}", "starred_url": "https://api.github.com/users/LaurentMazare/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LaurentMazare/subscriptions", "organizations_url": "https://api.github.com/users/LaurentMazare/orgs", "repos_url": "https://api.github.com/users/LaurentMazare/repos", "events_url": "https://api.github.com/users/LaurentMazare/events{/privacy}", "received_events_url": "https://api.github.com/users/LaurentMazare/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c43b60dd4870f92e0a3938ddbb9276fe6814b68", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c43b60dd4870f92e0a3938ddbb9276fe6814b68", "html_url": "https://github.com/rust-lang/rust/commit/0c43b60dd4870f92e0a3938ddbb9276fe6814b68"}], "stats": {"total": 173, "additions": 121, "deletions": 52}, "files": [{"sha": "f13941bffc2f2f59e000ea9f0dbe08652e19504c", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 104, "deletions": 52, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/bcdf57e220e022e9507b97299f5f0d3f1a5c027a/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcdf57e220e022e9507b97299f5f0d3f1a5c027a/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=bcdf57e220e022e9507b97299f5f0d3f1a5c027a", "patch": "@@ -379,13 +379,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         match expr.node {\n             ExprWhile(_, ref block, _) |\n             ExprLoop(ref block, _, _) => {\n-                let mut state = NeverLoopState {\n-                    breaks: HashSet::new(),\n-                    continues: HashSet::new(),\n-                };\n-                let may_complete = never_loop_block(block, &mut state);\n-                if !may_complete && !state.continues.contains(&expr.id) {\n-                    span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\");\n+                match never_loop_block(block, &expr.id) {\n+                    NeverLoopResult::AlwaysBreak =>\n+                        span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\"),\n+                    NeverLoopResult::MayContinueMainLoop | NeverLoopResult::Otherwise => (),\n                 }\n             },\n             _ => (),\n@@ -491,16 +488,59 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-struct NeverLoopState {\n-    breaks: HashSet<NodeId>,\n-    continues: HashSet<NodeId>,\n+enum NeverLoopResult {\n+    // A break/return always get triggered but not necessarily for the main loop.\n+    AlwaysBreak,\n+    // A continue may occur for the main loop.\n+    MayContinueMainLoop,\n+    Otherwise,\n+}\n+\n+fn absorb_break(arg: NeverLoopResult) -> NeverLoopResult {\n+    match arg {\n+        NeverLoopResult::AlwaysBreak |\n+        NeverLoopResult::Otherwise => NeverLoopResult::Otherwise,\n+        NeverLoopResult::MayContinueMainLoop => NeverLoopResult::MayContinueMainLoop,\n+    }\n+}\n+\n+// Combine two results for parts that are called in order.\n+fn combine_seq(first: NeverLoopResult, second: NeverLoopResult) -> NeverLoopResult {\n+    match first {\n+        NeverLoopResult::AlwaysBreak | NeverLoopResult::MayContinueMainLoop => first,\n+        NeverLoopResult::Otherwise => second,\n+    }\n+}\n+\n+// Combine two results where both parts are called but not necessarily in order.\n+fn combine_both(left: NeverLoopResult, right: NeverLoopResult) -> NeverLoopResult {\n+    match (left, right) {\n+        (NeverLoopResult::MayContinueMainLoop, _) | (_, NeverLoopResult::MayContinueMainLoop) =>\n+            NeverLoopResult::MayContinueMainLoop,\n+        (NeverLoopResult::AlwaysBreak, _) | (_, NeverLoopResult::AlwaysBreak) =>\n+            NeverLoopResult::AlwaysBreak,\n+        (NeverLoopResult::Otherwise, NeverLoopResult::Otherwise) =>\n+            NeverLoopResult::Otherwise,\n+    }\n+}\n+\n+// Combine two results where only one of the part may have been executed.\n+fn combine_branches(b1: NeverLoopResult, b2: NeverLoopResult) -> NeverLoopResult {\n+    match (b1, b2) {\n+        (NeverLoopResult::AlwaysBreak, NeverLoopResult::AlwaysBreak) =>\n+            NeverLoopResult::AlwaysBreak,\n+        (NeverLoopResult::MayContinueMainLoop, _) | (_, NeverLoopResult::MayContinueMainLoop) =>\n+            NeverLoopResult::MayContinueMainLoop,\n+        (NeverLoopResult::Otherwise, _) | (_, NeverLoopResult::Otherwise) =>\n+            NeverLoopResult::Otherwise,\n+    }\n }\n \n-fn never_loop_block(block: &Block, state: &mut NeverLoopState) -> bool {\n+fn never_loop_block(block: &Block, main_loop_id: &NodeId) -> NeverLoopResult {\n     let stmts = block.stmts.iter().map(stmt_to_expr);\n     let expr = once(block.expr.as_ref().map(|p| &**p));\n     let mut iter = stmts.chain(expr).filter_map(|e| e);\n-    never_loop_expr_seq(&mut iter, state)\n+    never_loop_expr_seq(&mut iter, main_loop_id)\n }\n \n fn stmt_to_expr(stmt: &Stmt) -> Option<&Expr> {\n@@ -518,7 +558,7 @@ fn decl_to_expr(decl: &Decl) -> Option<&Expr> {\n     }\n }\n \n-fn never_loop_expr(expr: &Expr, state: &mut NeverLoopState) -> bool {\n+fn never_loop_expr(expr: &Expr, main_loop_id: &NodeId) -> NeverLoopResult {\n     match expr.node {\n         ExprBox(ref e) |\n         ExprUnary(_, ref e) |\n@@ -527,71 +567,83 @@ fn never_loop_expr(expr: &Expr, state: &mut NeverLoopState) -> bool {\n         ExprField(ref e, _) |\n         ExprTupField(ref e, _) |\n         ExprAddrOf(_, ref e) |\n-        ExprRepeat(ref e, _) => never_loop_expr(e, state),\n+        ExprStruct(_, _, Some(ref e)) |\n+        ExprRepeat(ref e, _) => never_loop_expr(e, main_loop_id),\n         ExprArray(ref es) |\n         ExprMethodCall(_, _, ref es) |\n-        ExprTup(ref es) => never_loop_expr_seq(&mut es.iter(), state),\n-        ExprCall(ref e, ref es) => never_loop_expr_seq(&mut once(&**e).chain(es.iter()), state),\n+        ExprTup(ref es) => never_loop_expr_all(&mut es.iter(), main_loop_id),\n+        ExprCall(ref e, ref es) => never_loop_expr_all(&mut once(&**e).chain(es.iter()), main_loop_id),\n         ExprBinary(_, ref e1, ref e2) |\n         ExprAssign(ref e1, ref e2) |\n         ExprAssignOp(_, ref e1, ref e2) |\n-        ExprIndex(ref e1, ref e2) => never_loop_expr_seq(&mut [&**e1, &**e2].iter().cloned(), state),\n+        ExprIndex(ref e1, ref e2) => never_loop_expr_all(&mut [&**e1, &**e2].iter().cloned(), main_loop_id),\n         ExprIf(ref e, ref e2, ref e3) => {\n-            let e1 = never_loop_expr(e, state);\n-            let e2 = never_loop_expr(e2, state);\n-            match *e3 {\n-                Some(ref e3) => {\n-                    let e3 = never_loop_expr(e3, state);\n-                    e1 && (e2 || e3)\n-                },\n-                None => e1,\n-            }\n+            let e1 = never_loop_expr(e, main_loop_id);\n+            let e2 = never_loop_expr(e2, main_loop_id);\n+            let e3 =\n+                match *e3 {\n+                    Some(ref e3) => never_loop_expr(e3, main_loop_id),\n+                    None => NeverLoopResult::Otherwise,\n+                };\n+            combine_seq(e1, combine_branches(e2, e3))\n         },\n         ExprLoop(ref b, _, _) => {\n-            let block_may_complete = never_loop_block(b, state);\n-            let has_break = state.breaks.remove(&expr.id);\n-            state.continues.remove(&expr.id);\n-            block_may_complete || has_break\n+            // Break can come from the inner loop so remove them.\n+            absorb_break(never_loop_block(b, main_loop_id))\n         },\n         ExprWhile(ref e, ref b, _) => {\n-            let e = never_loop_expr(e, state);\n-            let block_may_complete = never_loop_block(b, state);\n-            let has_break = state.breaks.remove(&expr.id);\n-            let has_continue = state.continues.remove(&expr.id);\n-            e && (block_may_complete || has_break || has_continue)\n+            let e = never_loop_expr(e, main_loop_id);\n+            let result = never_loop_block(b, main_loop_id);\n+            // Break can come from the inner loop so remove them.\n+            combine_seq(e, absorb_break(result))\n         },\n         ExprMatch(ref e, ref arms, _) => {\n-            let e = never_loop_expr(e, state);\n-            let arms = never_loop_expr_branch(&mut arms.iter().map(|a| &*a.body), state);\n-            e && arms\n+            let e = never_loop_expr(e, main_loop_id);\n+            if arms.is_empty() {\n+                NeverLoopResult::Otherwise\n+            } else {\n+                let arms = never_loop_expr_branch(&mut arms.iter().map(|a| &*a.body), main_loop_id);\n+                combine_seq(e, arms)\n+            }\n         },\n-        ExprBlock(ref b) => never_loop_block(b, state),\n+        ExprBlock(ref b) => never_loop_block(b, main_loop_id),\n         ExprAgain(d) => {\n             let id = d.target_id.opt_id().expect(\"target id can only be missing in the presence of compilation errors\");\n-            state.continues.insert(id);\n-            false\n+            if id == *main_loop_id {\n+                NeverLoopResult::MayContinueMainLoop\n+            } else {\n+                NeverLoopResult::AlwaysBreak\n+            }\n         },\n-        ExprBreak(d, _) => {\n-            let id = d.target_id.opt_id().expect(\"target id can only be missing in the presence of compilation errors\");\n-            state.breaks.insert(id);\n-            false\n+        ExprBreak(_, _) => {\n+            NeverLoopResult::AlwaysBreak\n         },\n         ExprRet(ref e) => {\n             if let Some(ref e) = *e {\n-                never_loop_expr(e, state);\n+                combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n+            } else {\n+                NeverLoopResult::AlwaysBreak\n             }\n-            false\n         },\n-        _ => true,\n+        ExprStruct(_, _, None) |\n+        ExprYield(_) |\n+        ExprClosure(_, _, _, _, _) |\n+        ExprInlineAsm(_, _, _) |\n+        ExprPath(_) |\n+        ExprLit(_) => NeverLoopResult::Otherwise,\n     }\n }\n \n-fn never_loop_expr_seq<'a, T: Iterator<Item=&'a Expr>>(es: &mut T, state: &mut NeverLoopState) -> bool {\n-    es.map(|e| never_loop_expr(e, state)).fold(true, |a, b| a && b)\n+fn never_loop_expr_seq<'a, T: Iterator<Item=&'a Expr>>(es: &mut T, main_loop_id: &NodeId) -> NeverLoopResult {\n+    es.map(|e| never_loop_expr(e, main_loop_id)).fold(NeverLoopResult::Otherwise, combine_seq)\n+}\n+\n+fn never_loop_expr_all<'a, T: Iterator<Item=&'a Expr>>(es: &mut T, main_loop_id: &NodeId) -> NeverLoopResult {\n+    es.map(|e| never_loop_expr(e, main_loop_id)).fold(NeverLoopResult::Otherwise, combine_both)\n }\n \n-fn never_loop_expr_branch<'a, T: Iterator<Item=&'a Expr>>(e: &mut T, state: &mut NeverLoopState) -> bool {\n-    e.map(|e| never_loop_expr(e, state)).fold(false, |a, b| a || b)\n+fn never_loop_expr_branch<'a, T: Iterator<Item=&'a Expr>>(e: &mut T, main_loop_id: &NodeId) -> NeverLoopResult {\n+    e.map(|e| never_loop_expr(e, main_loop_id)).fold(NeverLoopResult::AlwaysBreak, combine_branches)\n }\n \n fn check_for_loop<'a, 'tcx>("}, {"sha": "2712db2bd318657e7af092f798838e08c51f04b4", "filename": "tests/ui/never_loop.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bcdf57e220e022e9507b97299f5f0d3f1a5c027a/tests%2Fui%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcdf57e220e022e9507b97299f5f0d3f1a5c027a/tests%2Fui%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnever_loop.rs?ref=bcdf57e220e022e9507b97299f5f0d3f1a5c027a", "patch": "@@ -152,6 +152,15 @@ pub fn test14() {\n     }\n }\n \n+// Issue #1991: the outter loop should not warn.\n+pub fn test15() {\n+    'label: loop {\n+        while false {\n+            break 'label;\n+        }\n+    }\n+}\n+\n fn main() {\n     test1();\n     test2();"}, {"sha": "1f9df6f9ccc99820fdaa0e985549600a1326cea1", "filename": "tests/ui/never_loop.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bcdf57e220e022e9507b97299f5f0d3f1a5c027a/tests%2Fui%2Fnever_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bcdf57e220e022e9507b97299f5f0d3f1a5c027a/tests%2Fui%2Fnever_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnever_loop.stderr?ref=bcdf57e220e022e9507b97299f5f0d3f1a5c027a", "patch": "@@ -80,3 +80,11 @@ error: this loop never actually loops\n 152 | |     }\n     | |_____^\n \n+error: this loop never actually loops\n+   --> $DIR/never_loop.rs:158:9\n+    |\n+158 | /         while false {\n+159 | |             break 'label;\n+160 | |         }\n+    | |_________^\n+"}]}