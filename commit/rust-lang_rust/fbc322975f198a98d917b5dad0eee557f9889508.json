{"sha": "fbc322975f198a98d917b5dad0eee557f9889508", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYzMyMjk3NWYxOThhOThkOTE3YjVkYWQwZWVlNTU3Zjk4ODk1MDg=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-15T08:19:09Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-18T03:31:10Z"}, "message": "Refactor out `finalize_import()` from `resolve_import()`.", "tree": {"sha": "67fc9aa6242f718fec9c08b643bdd2ed5a50d3bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67fc9aa6242f718fec9c08b643bdd2ed5a50d3bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbc322975f198a98d917b5dad0eee557f9889508", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbc322975f198a98d917b5dad0eee557f9889508", "html_url": "https://github.com/rust-lang/rust/commit/fbc322975f198a98d917b5dad0eee557f9889508", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbc322975f198a98d917b5dad0eee557f9889508/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "165b0b618cbe83bf15d40742bd2cb9db935097d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/165b0b618cbe83bf15d40742bd2cb9db935097d6", "html_url": "https://github.com/rust-lang/rust/commit/165b0b618cbe83bf15d40742bd2cb9db935097d6"}], "stats": {"total": 226, "additions": 125, "deletions": 101}, "files": [{"sha": "a0f0fccac8651c173e3efd111b1bfaecc2f48b31", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbc322975f198a98d917b5dad0eee557f9889508/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc322975f198a98d917b5dad0eee557f9889508/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=fbc322975f198a98d917b5dad0eee557f9889508", "patch": "@@ -957,7 +957,10 @@ pub struct Resolver<'a> {\n \n     structs: FnvHashMap<DefId, Vec<Name>>,\n \n-    // All indeterminate imports (i.e. imports not known to succeed or fail).\n+    // All imports known to succeed or fail.\n+    determined_imports: Vec<&'a ImportDirective<'a>>,\n+\n+    // All non-determined imports.\n     indeterminate_imports: Vec<&'a ImportDirective<'a>>,\n \n     // The module that represents the current item scope.\n@@ -1149,6 +1152,7 @@ impl<'a> Resolver<'a> {\n             trait_item_map: FnvHashMap(),\n             structs: FnvHashMap(),\n \n+            determined_imports: Vec::new(),\n             indeterminate_imports: Vec::new(),\n \n             current_module: graph_root,"}, {"sha": "c2f8e31277c3f545b8c1fddd4f99596658e0ae3c", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 120, "deletions": 100, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/fbc322975f198a98d917b5dad0eee557f9889508/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc322975f198a98d917b5dad0eee557f9889508/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=fbc322975f198a98d917b5dad0eee557f9889508", "patch": "@@ -144,6 +144,7 @@ impl<'a> Resolver<'a> {\n \n     /// Attempts to resolve the supplied name in the given module for the given namespace.\n     /// If successful, returns the binding corresponding to the name.\n+    /// Invariant: if `record_used` is `Some`, import resolution must be complete.\n     pub fn resolve_name_in_module(&mut self,\n                                   module: Module<'a>,\n                                   name: Name,\n@@ -159,32 +160,46 @@ impl<'a> Resolver<'a> {\n             _ => return Failed(None), // This happens when there is a cycle of imports\n         };\n \n-        if let Some(result) = self.try_result(&resolution, ns, allow_private_imports) {\n-            // If the resolution doesn't depend on glob definability, check privacy and return.\n-            return result.and_then(|binding| {\n-                if !allow_private_imports && binding.is_import() && !binding.is_pseudo_public() {\n+        let is_disallowed_private_import = |binding: &NameBinding| {\n+            !allow_private_imports && !binding.is_pseudo_public() && binding.is_import()\n+        };\n+\n+        if let Some(span) = record_used {\n+            if let Some(binding) = resolution.binding {\n+                if is_disallowed_private_import(binding) {\n                     return Failed(None);\n                 }\n-                if let Some(span) = record_used {\n-                    self.record_use(name, ns, binding);\n-                    if !self.is_accessible(binding.vis) {\n-                        self.privacy_errors.push(PrivacyError(span, name, binding));\n-                    }\n+                self.record_use(name, ns, binding);\n+                if !self.is_accessible(binding.vis) {\n+                    self.privacy_errors.push(PrivacyError(span, name, binding));\n+                }\n+            }\n+\n+            return resolution.binding.map(Success).unwrap_or(Failed(None));\n+        }\n+\n+        // If the resolution doesn't depend on glob definability, check privacy and return.\n+        if let Some(result) = self.try_result(&resolution, ns) {\n+            return result.and_then(|binding| {\n+                if self.is_accessible(binding.vis) && !is_disallowed_private_import(binding) {\n+                    Success(binding)\n+                } else {\n+                    Failed(None)\n                 }\n-                Success(binding)\n             });\n         }\n \n         // Check if the globs are determined\n         for directive in module.globs.borrow().iter() {\n-            if !allow_private_imports && directive.vis != ty::Visibility::Public { continue }\n-            if let Some(target_module) = directive.target_module.get() {\n-                let result = self.resolve_name_in_module(target_module, name, ns, false, None);\n-                if let Indeterminate = result {\n+            if self.is_accessible(directive.vis) {\n+                if let Some(target_module) = directive.target_module.get() {\n+                    let result = self.resolve_name_in_module(target_module, name, ns, true, None);\n+                    if let Indeterminate = result {\n+                        return Indeterminate;\n+                    }\n+                } else {\n                     return Indeterminate;\n                 }\n-            } else {\n-                return Indeterminate;\n             }\n         }\n \n@@ -193,10 +208,7 @@ impl<'a> Resolver<'a> {\n \n     // Returns Some(the resolution of the name), or None if the resolution depends\n     // on whether more globs can define the name.\n-    fn try_result(&mut self,\n-                  resolution: &NameResolution<'a>,\n-                  ns: Namespace,\n-                  allow_private_imports: bool)\n+    fn try_result(&mut self, resolution: &NameResolution<'a>, ns: Namespace)\n                   -> Option<ResolveResult<&'a NameBinding<'a>>> {\n         match resolution.binding {\n             Some(binding) if !binding.is_glob_import() =>\n@@ -206,17 +218,8 @@ impl<'a> Resolver<'a> {\n \n         // Check if a single import can still define the name.\n         match resolution.single_imports {\n-            SingleImports::None => {},\n             SingleImports::AtLeastOne => return Some(Indeterminate),\n-            SingleImports::MaybeOne(directive) => {\n-                // If (1) we don't allow private imports, (2) no public single import can define\n-                // the name, and (3) no public glob has defined the name, the resolution depends\n-                // on whether more globs can define the name.\n-                if !allow_private_imports && directive.vis != ty::Visibility::Public &&\n-                   !resolution.binding.map(NameBinding::is_pseudo_public).unwrap_or(false) {\n-                    return None;\n-                }\n-\n+            SingleImports::MaybeOne(directive) if self.is_accessible(directive.vis) => {\n                 let target_module = match directive.target_module.get() {\n                     Some(target_module) => target_module,\n                     None => return Some(Indeterminate),\n@@ -225,11 +228,12 @@ impl<'a> Resolver<'a> {\n                     SingleImport { source, .. } => source,\n                     GlobImport { .. } => unreachable!(),\n                 };\n-                match self.resolve_name_in_module(target_module, name, ns, false, None) {\n+                match self.resolve_name_in_module(target_module, name, ns, true, None) {\n                     Failed(_) => {}\n                     _ => return Some(Indeterminate),\n                 }\n             }\n+            SingleImports::MaybeOne(_) | SingleImports::None => {},\n         }\n \n         resolution.binding.map(Success)\n@@ -389,7 +393,6 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     fn resolve_imports(&mut self) {\n         let mut i = 0;\n         let mut prev_num_indeterminates = self.indeterminate_imports.len() + 1;\n-        let mut errors = Vec::new();\n \n         while self.indeterminate_imports.len() < prev_num_indeterminates {\n             prev_num_indeterminates = self.indeterminate_imports.len();\n@@ -400,19 +403,9 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n             for import in imports {\n                 match self.resolve_import(&import) {\n-                    Failed(err) => {\n-                        let (span, help) = match err {\n-                            Some((span, msg)) => (span, format!(\". {}\", msg)),\n-                            None => (import.span, String::new()),\n-                        };\n-                        errors.push(ImportResolvingError {\n-                            import_directive: import,\n-                            span: span,\n-                            help: help,\n-                        });\n-                    }\n+                    Failed(_) => self.determined_imports.push(import),\n                     Indeterminate => self.indeterminate_imports.push(import),\n-                    Success(()) => {}\n+                    Success(()) => self.determined_imports.push(import),\n                 }\n             }\n \n@@ -423,6 +416,22 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             self.finalize_resolutions_in(module);\n         }\n \n+        let mut errors = Vec::new();\n+        for i in 0 .. self.determined_imports.len() {\n+            let import = self.determined_imports[i];\n+            if let Failed(err) = self.finalize_import(import) {\n+                let (span, help) = match err {\n+                    Some((span, msg)) => (span, format!(\". {}\", msg)),\n+                    None => (import.span, String::new()),\n+                };\n+                errors.push(ImportResolvingError {\n+                    import_directive: import,\n+                    span: span,\n+                    help: help,\n+                });\n+            }\n+        }\n+\n         // Report unresolved imports only if no hard error was already reported\n         // to avoid generating multiple errors on the same import.\n         if errors.len() == 0 {\n@@ -481,9 +490,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n         let target_module = match directive.target_module.get() {\n             Some(module) => module,\n-            _ => match self.resolve_module_path(&directive.module_path,\n-                                                DontUseLexicalScope,\n-                                                Some(directive.span)) {\n+            _ => match self.resolve_module_path(&directive.module_path, DontUseLexicalScope, None) {\n                 Success(module) => module,\n                 Indeterminate => return Indeterminate,\n                 Failed(err) => return Failed(err),\n@@ -494,27 +501,29 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let (source, target, value_result, type_result) = match directive.subclass {\n             SingleImport { source, target, ref value_result, ref type_result } =>\n                 (source, target, value_result, type_result),\n-            GlobImport { .. } => return self.resolve_glob_import(target_module, directive),\n+            GlobImport { .. } => {\n+                self.resolve_glob_import(directive);\n+                return Success(());\n+            }\n         };\n \n-        let mut privacy_error = true;\n+        let mut indeterminate = false;\n         for &(ns, result) in &[(ValueNS, value_result), (TypeNS, type_result)] {\n-            let was_determined = if let Err(false) = result.get() {\n+            if let Err(false) = result.get() {\n                 result.set({\n-                    let span = Some(directive.span);\n-                    match self.resolve_name_in_module(target_module, source, ns, false, span) {\n+                    match self.resolve_name_in_module(target_module, source, ns, false, None) {\n                         Success(binding) => Ok(binding),\n                         Indeterminate => Err(false),\n                         Failed(_) => Err(true),\n                     }\n                 });\n-                false\n             } else {\n-                true\n+                continue\n             };\n \n             match result.get() {\n-                Err(true) if !was_determined => {\n+                Err(false) => indeterminate = true,\n+                Err(true) => {\n                     self.update_resolution(module, target, ns, |_, resolution| {\n                         resolution.single_imports.directive_failed()\n                     });\n@@ -529,26 +538,55 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     self.import_dummy_binding(directive);\n                     return Success(());\n                 }\n-                Ok(binding) if !self.is_accessible(binding.vis) => {}\n-                Ok(binding) if !was_determined => {\n+                Ok(binding) => {\n                     let imported_binding = self.import(binding, directive);\n                     let conflict = self.try_define(module, target, ns, imported_binding);\n                     if let Err(old_binding) = conflict {\n                         let binding = &self.import(binding, directive);\n                         self.report_conflict(module, target, ns, binding, old_binding);\n                     }\n-                    privacy_error = false;\n                 }\n-                Ok(_) => privacy_error = false,\n-                _ => {}\n             }\n         }\n \n-        let (value_result, type_result) = (value_result.get(), type_result.get());\n-        match (value_result, type_result) {\n-            (Err(false), _) | (_, Err(false)) => return Indeterminate,\n-            (Err(true), Err(true)) => {\n-                let resolutions = target_module.resolutions.borrow();\n+        if indeterminate { Indeterminate } else { Success(()) }\n+    }\n+\n+    fn finalize_import(&mut self, directive: &'b ImportDirective<'b>) -> ResolveResult<()> {\n+        self.set_current_module(directive.parent);\n+\n+        let ImportDirective { ref module_path, span, .. } = *directive;\n+        let module_result = self.resolve_module_path(&module_path, DontUseLexicalScope, Some(span));\n+        let module = match module_result {\n+            Success(module) => module,\n+            Indeterminate => return Indeterminate,\n+            Failed(err) => return Failed(err),\n+        };\n+\n+        let (source, value_result, type_result) = match directive.subclass {\n+            SingleImport { source, ref value_result, ref type_result, .. } =>\n+                (source, value_result.get(), type_result.get()),\n+            GlobImport { .. } if module.def_id() == directive.parent.def_id() => {\n+                // Importing a module into itself is not allowed.\n+                let msg = \"Cannot glob-import a module into itself.\".into();\n+                return Failed(Some((directive.span, msg)));\n+            }\n+            GlobImport { .. } => return Success(()),\n+        };\n+\n+        for &(ns, result) in &[(ValueNS, value_result), (TypeNS, type_result)] {\n+            if let Ok(binding) = result {\n+                self.record_use(source, ns, binding);\n+            }\n+        }\n+\n+        if value_result.is_err() && type_result.is_err() {\n+            let (value_result, type_result);\n+            value_result = self.resolve_name_in_module(module, source, ValueNS, false, Some(span));\n+            type_result = self.resolve_name_in_module(module, source, TypeNS, false, Some(span));\n+\n+            return if let (Failed(_), Failed(_)) = (value_result, type_result) {\n+                let resolutions = module.resolutions.borrow();\n                 let names = resolutions.iter().filter_map(|(&(ref name, _), resolution)| {\n                     if *name == source { return None; } // Never suggest the same name\n                     match *resolution.borrow() {\n@@ -561,29 +599,22 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     Some(name) => format!(\". Did you mean to use `{}`?\", name),\n                     None => \"\".to_owned(),\n                 };\n-                let module_str = module_to_string(target_module);\n+                let module_str = module_to_string(module);\n                 let msg = if &module_str == \"???\" {\n                     format!(\"There is no `{}` in the crate root{}\", source, lev_suggestion)\n                 } else {\n                     format!(\"There is no `{}` in `{}`{}\", source, module_str, lev_suggestion)\n                 };\n-                return Failed(Some((directive.span, msg)));\n-            }\n-            _ => (),\n-        }\n-\n-        if privacy_error {\n-            for &(ns, result) in &[(ValueNS, value_result), (TypeNS, type_result)] {\n-                let binding = match result { Ok(binding) => binding, _ => continue };\n-                self.privacy_errors.push(PrivacyError(directive.span, source, binding));\n-                let imported_binding = self.import(binding, directive);\n-                let _ = self.try_define(module, target, ns, imported_binding);\n+                Failed(Some((directive.span, msg)))\n+            } else {\n+                // `resolve_name_in_module` reported a privacy error.\n+                self.import_dummy_binding(directive);\n+                Success(())\n             }\n         }\n \n         match (value_result, type_result) {\n-            (Ok(binding), _) if !binding.pseudo_vis().is_at_least(directive.vis, self) &&\n-                                self.is_accessible(binding.vis) => {\n+            (Ok(binding), _) if !binding.pseudo_vis().is_at_least(directive.vis, self) => {\n                 let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                 let note_msg = format!(\"consider marking `{}` as `pub` in the imported module\",\n                                         source);\n@@ -592,8 +623,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     .emit();\n             }\n \n-            (_, Ok(binding)) if !binding.pseudo_vis().is_at_least(directive.vis, self) &&\n-                                self.is_accessible(binding.vis) => {\n+            (_, Ok(binding)) if !binding.pseudo_vis().is_at_least(directive.vis, self) => {\n                 if binding.is_extern_crate() {\n                     let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n                                        (error E0364), consider declaring with `pub`\",\n@@ -626,27 +656,20 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         return Success(());\n     }\n \n-    // Resolves a glob import. Note that this function cannot fail; it either\n-    // succeeds or bails out (as importing * from an empty module or a module\n-    // that exports nothing is valid). target_module is the module we are\n-    // actually importing, i.e., `foo` in `use foo::*`.\n-    fn resolve_glob_import(&mut self, target_module: Module<'b>, directive: &'b ImportDirective<'b>)\n-                           -> ResolveResult<()> {\n+    fn resolve_glob_import(&mut self, directive: &'b ImportDirective<'b>) {\n+        let target_module = directive.target_module.get().unwrap();\n+        self.populate_module_if_necessary(target_module);\n+\n         if let Some(Def::Trait(_)) = target_module.def {\n             self.session.span_err(directive.span, \"items in traits are not importable.\");\n         }\n \n-        let module = self.current_module;\n-        if module.def_id() == target_module.def_id() {\n-            // This means we are trying to glob import a module into itself, and it is a no-go\n-            let msg = \"Cannot glob-import a module into itself.\".into();\n-            return Failed(Some((directive.span, msg)));\n-        }\n-        self.populate_module_if_necessary(target_module);\n-\n-        if let GlobImport { is_prelude: true } = directive.subclass {\n+        let module = directive.parent;\n+        if target_module.def_id() == module.def_id()  {\n+            return;\n+        } else if let GlobImport { is_prelude: true } = directive.subclass {\n             self.prelude = Some(target_module);\n-            return Success(());\n+            return;\n         }\n \n         // Add to target_module's glob_importers\n@@ -669,9 +692,6 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             let resolution = PathResolution::new(Def::Mod(did));\n             self.def_map.insert(directive.id, resolution);\n         }\n-\n-        debug!(\"(resolving glob import) successfully resolved import\");\n-        return Success(());\n     }\n \n     // Miscellaneous post-processing, including recording reexports, reporting conflicts,"}]}