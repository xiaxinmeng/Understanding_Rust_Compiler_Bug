{"sha": "b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1OTJiMzdmYTMxYzBkODFjYTIzZmVhOWZlNzk5OGMzZjBmNGJkMGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-26T01:12:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-26T01:12:20Z"}, "message": "Auto merge of #71566 - Dylan-DPC:rollup-9xoz6fg, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #70043 (Add all remaining `DefKind`s.)\n - #71140 ([breaking change] Disallow statics initializing themselves)\n - #71392 (Don't hold the predecessor cache lock longer than necessary)\n - #71541 (Add regression test for #26376)\n - #71554 (Replace thread_local with generator resume arguments in box_region.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "065f6ab256a55a6cbc1826ddc1aa75ecbca043b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/065f6ab256a55a6cbc1826ddc1aa75ecbca043b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "html_url": "https://github.com/rust-lang/rust/commit/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0862458dad90a0d80827e22e3f86e33add6d847c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0862458dad90a0d80827e22e3f86e33add6d847c", "html_url": "https://github.com/rust-lang/rust/commit/0862458dad90a0d80827e22e3f86e33add6d847c"}, {"sha": "f70c9dba22df28b606ee413a82a3fe4305855620", "url": "https://api.github.com/repos/rust-lang/rust/commits/f70c9dba22df28b606ee413a82a3fe4305855620", "html_url": "https://github.com/rust-lang/rust/commit/f70c9dba22df28b606ee413a82a3fe4305855620"}], "stats": {"total": 676, "additions": 369, "deletions": 307}, "files": [{"sha": "00b4bf96afa594b75e55115647bb84b9410c6179", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -157,7 +157,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n     // Allocate a `Block` for every basic block, except\n     // the start block, if nothing loops back to it.\n-    let reentrant_start_block = !mir.predecessors_for(mir::START_BLOCK).is_empty();\n+    let reentrant_start_block = !mir.predecessors()[mir::START_BLOCK].is_empty();\n     let block_bxs: IndexVec<mir::BasicBlock, Bx::BasicBlock> = mir\n         .basic_blocks()\n         .indices()"}, {"sha": "eb6f4e8213ec711dac0b945cc5c2f751c9511451", "filename": "src/librustc_data_structures/box_region.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_data_structures%2Fbox_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_data_structures%2Fbox_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbox_region.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -1,4 +1,15 @@\n-use std::cell::Cell;\n+//! This module provides a way to deal with self-referential data.\n+//!\n+//! The main idea is to allocate such data in a generator frame and then\n+//! give access to it by executing user-provided closures inside that generator.\n+//! The module provides a safe abstraction for the latter task.\n+//!\n+//! The interface consists of two exported macros meant to be used together:\n+//! * `declare_box_region_type` wraps a generator inside a struct with `access`\n+//!   method which accepts closures.\n+//! * `box_region_allow_access` is a helper which should be called inside\n+//!   a generator to actually execute those closures.\n+\n use std::marker::PhantomData;\n use std::ops::{Generator, GeneratorState};\n use std::pin::Pin;\n@@ -14,24 +25,23 @@ impl AccessAction {\n \n #[derive(Copy, Clone)]\n pub enum Action {\n+    Initial,\n     Access(AccessAction),\n     Complete,\n }\n \n-thread_local!(pub static BOX_REGION_ARG: Cell<Action> = Cell::new(Action::Complete));\n-\n pub struct PinnedGenerator<I, A, R> {\n-    generator: Pin<Box<dyn Generator<Yield = YieldType<I, A>, Return = R>>>,\n+    generator: Pin<Box<dyn Generator<Action, Yield = YieldType<I, A>, Return = R>>>,\n }\n \n impl<I, A, R> PinnedGenerator<I, A, R> {\n-    pub fn new<T: Generator<Yield = YieldType<I, A>, Return = R> + 'static>(\n+    pub fn new<T: Generator<Action, Yield = YieldType<I, A>, Return = R> + 'static>(\n         generator: T,\n     ) -> (I, Self) {\n         let mut result = PinnedGenerator { generator: Box::pin(generator) };\n \n         // Run it to the first yield to set it up\n-        let init = match Pin::new(&mut result.generator).resume(()) {\n+        let init = match Pin::new(&mut result.generator).resume(Action::Initial) {\n             GeneratorState::Yielded(YieldType::Initial(y)) => y,\n             _ => panic!(),\n         };\n@@ -40,21 +50,17 @@ impl<I, A, R> PinnedGenerator<I, A, R> {\n     }\n \n     pub unsafe fn access(&mut self, closure: *mut dyn FnMut()) {\n-        BOX_REGION_ARG.with(|i| {\n-            i.set(Action::Access(AccessAction(closure)));\n-        });\n-\n-        // Call the generator, which in turn will call the closure in BOX_REGION_ARG\n-        if let GeneratorState::Complete(_) = Pin::new(&mut self.generator).resume(()) {\n+        // Call the generator, which in turn will call the closure\n+        if let GeneratorState::Complete(_) =\n+            Pin::new(&mut self.generator).resume(Action::Access(AccessAction(closure)))\n+        {\n             panic!()\n         }\n     }\n \n     pub fn complete(&mut self) -> R {\n         // Tell the generator we want it to complete, consuming it and yielding a result\n-        BOX_REGION_ARG.with(|i| i.set(Action::Complete));\n-\n-        let result = Pin::new(&mut self.generator).resume(());\n+        let result = Pin::new(&mut self.generator).resume(Action::Complete);\n         if let GeneratorState::Complete(r) = result { r } else { panic!() }\n     }\n }\n@@ -89,7 +95,7 @@ macro_rules! declare_box_region_type {\n         >);\n \n         impl $name {\n-            fn new<T: ::std::ops::Generator<Yield = $yield_type, Return = $retc> + 'static>(\n+            fn new<T: ::std::ops::Generator<$crate::box_region::Action, Yield = $yield_type, Return = $retc> + 'static>(\n                 generator: T\n             ) -> ($reti, Self) {\n                 let (initial, pinned) = $crate::box_region::PinnedGenerator::new(generator);\n@@ -98,7 +104,7 @@ macro_rules! declare_box_region_type {\n \n             $v fn access<F: for<$($lifetimes)*> FnOnce($($args,)*) -> R, R>(&mut self, f: F) -> R {\n                 // Turn the FnOnce closure into *mut dyn FnMut()\n-                // so we can pass it in to the generator using the BOX_REGION_ARG thread local\n+                // so we can pass it in to the generator\n                 let mut r = None;\n                 let mut f = Some(f);\n                 let mut_f: &mut dyn for<$($lifetimes)*> FnMut(($($args,)*)) =\n@@ -140,9 +146,9 @@ macro_rules! declare_box_region_type {\n #[macro_export]\n #[allow_internal_unstable(fn_traits)]\n macro_rules! box_region_allow_access {\n-    (for($($lifetimes:tt)*), ($($args:ty),*), ($($exprs:expr),*) ) => {\n+    (for($($lifetimes:tt)*), ($($args:ty),*), ($($exprs:expr),*), $action:ident) => {\n         loop {\n-            match $crate::box_region::BOX_REGION_ARG.with(|i| i.get()) {\n+            match $action {\n                 $crate::box_region::Action::Access(accessor) => {\n                     let accessor: &mut dyn for<$($lifetimes)*> FnMut($($args),*) = unsafe {\n                         ::std::mem::transmute(accessor.get())\n@@ -152,10 +158,11 @@ macro_rules! box_region_allow_access {\n                         let marker = $crate::box_region::Marker::<\n                             for<$($lifetimes)*> fn(($($args,)*))\n                         >::new();\n-                        yield $crate::box_region::YieldType::Accessor(marker)\n+                        $action = yield $crate::box_region::YieldType::Accessor(marker);\n                     };\n                 }\n                 $crate::box_region::Action::Complete => break,\n+                $crate::box_region::Action::Initial => panic!(\"unexpected box_region action: Initial\"),\n             }\n         }\n     }"}, {"sha": "88049f85f45e42ef25a1fc92efbf61afaeca44eb", "filename": "src/librustc_hir/def.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_hir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_hir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdef.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -77,6 +77,18 @@ pub enum DefKind {\n \n     // Macro namespace\n     Macro(MacroKind),\n+\n+    // Not namespaced (or they are, but we don't treat them so)\n+    ExternCrate,\n+    Use,\n+    ForeignMod,\n+    AnonConst,\n+    Field,\n+    LifetimeParam,\n+    GlobalAsm,\n+    Impl,\n+    Closure,\n+    Generator,\n }\n \n impl DefKind {\n@@ -113,6 +125,16 @@ impl DefKind {\n             DefKind::TyParam => \"type parameter\",\n             DefKind::ConstParam => \"const parameter\",\n             DefKind::Macro(macro_kind) => macro_kind.descr(),\n+            DefKind::LifetimeParam => \"lifetime parameter\",\n+            DefKind::Use => \"import\",\n+            DefKind::ForeignMod => \"foreign module\",\n+            DefKind::AnonConst => \"constant expression\",\n+            DefKind::Field => \"field\",\n+            DefKind::Impl => \"implementation\",\n+            DefKind::Closure => \"closure\",\n+            DefKind::Generator => \"generator\",\n+            DefKind::ExternCrate => \"extern crate\",\n+            DefKind::GlobalAsm => \"global assembly block\",\n         }\n     }\n \n@@ -124,7 +146,10 @@ impl DefKind {\n             | DefKind::AssocOpaqueTy\n             | DefKind::AssocFn\n             | DefKind::Enum\n-            | DefKind::OpaqueTy => \"an\",\n+            | DefKind::OpaqueTy\n+            | DefKind::Impl\n+            | DefKind::Use\n+            | DefKind::ExternCrate => \"an\",\n             DefKind::Macro(macro_kind) => macro_kind.article(),\n             _ => \"a\",\n         }\n@@ -155,6 +180,18 @@ impl DefKind {\n             | DefKind::AssocConst => ns == Namespace::ValueNS,\n \n             DefKind::Macro(..) => ns == Namespace::MacroNS,\n+\n+            // Not namespaced.\n+            DefKind::AnonConst\n+            | DefKind::Field\n+            | DefKind::LifetimeParam\n+            | DefKind::ExternCrate\n+            | DefKind::Closure\n+            | DefKind::Generator\n+            | DefKind::Use\n+            | DefKind::ForeignMod\n+            | DefKind::GlobalAsm\n+            | DefKind::Impl => false,\n         }\n     }\n }"}, {"sha": "d342f8b0ad21c3d601b4470316bbf82be44252e8", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -2452,27 +2452,6 @@ pub enum ItemKind<'hir> {\n }\n \n impl ItemKind<'_> {\n-    pub fn descr(&self) -> &str {\n-        match *self {\n-            ItemKind::ExternCrate(..) => \"extern crate\",\n-            ItemKind::Use(..) => \"`use` import\",\n-            ItemKind::Static(..) => \"static item\",\n-            ItemKind::Const(..) => \"constant item\",\n-            ItemKind::Fn(..) => \"function\",\n-            ItemKind::Mod(..) => \"module\",\n-            ItemKind::ForeignMod(..) => \"extern block\",\n-            ItemKind::GlobalAsm(..) => \"global asm item\",\n-            ItemKind::TyAlias(..) => \"type alias\",\n-            ItemKind::OpaqueTy(..) => \"opaque type\",\n-            ItemKind::Enum(..) => \"enum\",\n-            ItemKind::Struct(..) => \"struct\",\n-            ItemKind::Union(..) => \"union\",\n-            ItemKind::Trait(..) => \"trait\",\n-            ItemKind::TraitAlias(..) => \"trait alias\",\n-            ItemKind::Impl { .. } => \"implementation\",\n-        }\n-    }\n-\n     pub fn generics(&self) -> Option<&Generics<'_>> {\n         Some(match *self {\n             ItemKind::Fn(_, ref generics, _)\n@@ -2551,16 +2530,6 @@ pub enum ForeignItemKind<'hir> {\n     Type,\n }\n \n-impl ForeignItemKind<'hir> {\n-    pub fn descriptive_variant(&self) -> &str {\n-        match *self {\n-            ForeignItemKind::Fn(..) => \"foreign function\",\n-            ForeignItemKind::Static(..) => \"foreign static item\",\n-            ForeignItemKind::Type => \"foreign type\",\n-        }\n-    }\n-}\n-\n /// A variable captured by a closure.\n #[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable_Generic)]\n pub struct Upvar {"}, {"sha": "1986838e4016c97af94c3fb01a56f766b23aef1e", "filename": "src/librustc_infer/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -207,12 +207,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         .get_opt_name()\n                         .map(|parent_symbol| parent_symbol.to_string());\n \n-                    let type_parent_desc = self\n-                        .tcx\n-                        .def_kind(parent_def_id)\n-                        .map(|parent_def_kind| parent_def_kind.descr(parent_def_id));\n-\n-                    (parent_name, type_parent_desc)\n+                    (parent_name, Some(self.tcx.def_kind(parent_def_id).descr(parent_def_id)))\n                 } else {\n                     (None, None)\n                 };"}, {"sha": "4b09148eab61f8269c1c5a95e91650906fd8d969", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -109,7 +109,8 @@ pub fn configure_and_expand(\n     // its contents but the results of name resolution on those contents. Hopefully we'll push\n     // this back at some point.\n     let crate_name = crate_name.to_string();\n-    let (result, resolver) = BoxedResolver::new(static move || {\n+    let (result, resolver) = BoxedResolver::new(static move |mut action| {\n+        let _ = action;\n         let sess = &*sess;\n         let resolver_arenas = Resolver::arenas();\n         let res = configure_and_expand_inner(\n@@ -126,11 +127,11 @@ pub fn configure_and_expand(\n                 panic!()\n             }\n             Ok((krate, resolver)) => {\n-                yield BoxedResolver::initial_yield(Ok(krate));\n+                action = yield BoxedResolver::initial_yield(Ok(krate));\n                 resolver\n             }\n         };\n-        box_region_allow_access!(for(), (&mut Resolver<'_>), (&mut resolver));\n+        box_region_allow_access!(for(), (&mut Resolver<'_>), (&mut resolver), action);\n         resolver.into_outputs()\n     });\n     result.map(|k| (k, resolver))"}, {"sha": "39d8213f2629b44df34f5ad221368f41ec1e1884", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -562,8 +562,8 @@ impl MetadataBlob {\n }\n \n impl EntryKind {\n-    fn def_kind(&self) -> Option<DefKind> {\n-        Some(match *self {\n+    fn def_kind(&self) -> DefKind {\n+        match *self {\n             EntryKind::Const(..) => DefKind::Const,\n             EntryKind::AssocConst(..) => DefKind::AssocConst,\n             EntryKind::ImmStatic\n@@ -587,14 +587,13 @@ impl EntryKind {\n             EntryKind::Enum(..) => DefKind::Enum,\n             EntryKind::MacroDef(_) => DefKind::Macro(MacroKind::Bang),\n             EntryKind::ForeignType => DefKind::ForeignTy,\n-\n-            EntryKind::ForeignMod\n-            | EntryKind::GlobalAsm\n-            | EntryKind::Impl(_)\n-            | EntryKind::Field\n-            | EntryKind::Generator(_)\n-            | EntryKind::Closure => return None,\n-        })\n+            EntryKind::Impl(_) => DefKind::Impl,\n+            EntryKind::Closure => DefKind::Closure,\n+            EntryKind::ForeignMod => DefKind::ForeignMod,\n+            EntryKind::GlobalAsm => DefKind::GlobalAsm,\n+            EntryKind::Field => DefKind::Field,\n+            EntryKind::Generator(_) => DefKind::Generator,\n+        }\n     }\n }\n \n@@ -679,11 +678,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn def_kind(&self, index: DefIndex) -> Option<DefKind> {\n+    fn def_kind(&self, index: DefIndex) -> DefKind {\n         if !self.is_proc_macro(index) {\n             self.kind(index).def_kind()\n         } else {\n-            Some(DefKind::Macro(macro_kind(self.raw_proc_macro(index))))\n+            DefKind::Macro(macro_kind(self.raw_proc_macro(index)))\n         }\n     }\n \n@@ -1009,20 +1008,19 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                             .get(self, child_index)\n                             .unwrap_or(Lazy::empty());\n                         for child_index in child_children.decode((self, sess)) {\n-                            if let Some(kind) = self.def_kind(child_index) {\n-                                callback(Export {\n-                                    res: Res::Def(kind, self.local_def_id(child_index)),\n-                                    ident: self.item_ident(child_index, sess),\n-                                    vis: self.get_visibility(child_index),\n-                                    span: self\n-                                        .root\n-                                        .tables\n-                                        .span\n-                                        .get(self, child_index)\n-                                        .unwrap()\n-                                        .decode((self, sess)),\n-                                });\n-                            }\n+                            let kind = self.def_kind(child_index);\n+                            callback(Export {\n+                                res: Res::Def(kind, self.local_def_id(child_index)),\n+                                ident: self.item_ident(child_index, sess),\n+                                vis: self.get_visibility(child_index),\n+                                span: self\n+                                    .root\n+                                    .tables\n+                                    .span\n+                                    .get(self, child_index)\n+                                    .unwrap()\n+                                    .decode((self, sess)),\n+                            });\n                         }\n                         continue;\n                     }\n@@ -1033,10 +1031,8 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n                 let def_key = self.def_key(child_index);\n                 let span = self.get_span(child_index, sess);\n-                if let (Some(kind), true) = (\n-                    self.def_kind(child_index),\n-                    def_key.disambiguated_data.data.get_opt_name().is_some(),\n-                ) {\n+                if def_key.disambiguated_data.data.get_opt_name().is_some() {\n+                    let kind = self.def_kind(child_index);\n                     let ident = self.item_ident(child_index, sess);\n                     let vis = self.get_visibility(child_index);\n                     let def_id = self.local_def_id(child_index);"}, {"sha": "1c71fc57bea5a23effe7bd60521ebb80572456c0", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -6,7 +6,7 @@ use crate::ty::TyCtxt;\n use rustc_ast::ast::{self, Name, NodeId};\n use rustc_data_structures::svh::Svh;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, Definitions};\n use rustc_hir::intravisit;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n@@ -227,10 +227,14 @@ impl<'hir> Map<'hir> {\n         self.tcx.definitions.opt_local_def_id_to_hir_id(def_id)\n     }\n \n-    pub fn def_kind(&self, hir_id: HirId) -> Option<DefKind> {\n-        let node = self.find(hir_id)?;\n+    pub fn def_kind(&self, local_def_id: LocalDefId) -> DefKind {\n+        // FIXME(eddyb) support `find` on the crate root.\n+        if local_def_id.to_def_id().index == CRATE_DEF_INDEX {\n+            return DefKind::Mod;\n+        }\n \n-        Some(match node {\n+        let hir_id = self.local_def_id_to_hir_id(local_def_id);\n+        match self.get(hir_id) {\n             Node::Item(item) => match item.kind {\n                 ItemKind::Static(..) => DefKind::Static,\n                 ItemKind::Const(..) => DefKind::Const,\n@@ -243,11 +247,11 @@ impl<'hir> Map<'hir> {\n                 ItemKind::Union(..) => DefKind::Union,\n                 ItemKind::Trait(..) => DefKind::Trait,\n                 ItemKind::TraitAlias(..) => DefKind::TraitAlias,\n-                ItemKind::ExternCrate(_)\n-                | ItemKind::Use(..)\n-                | ItemKind::ForeignMod(..)\n-                | ItemKind::GlobalAsm(..)\n-                | ItemKind::Impl { .. } => return None,\n+                ItemKind::ExternCrate(_) => DefKind::ExternCrate,\n+                ItemKind::Use(..) => DefKind::Use,\n+                ItemKind::ForeignMod(..) => DefKind::ForeignMod,\n+                ItemKind::GlobalAsm(..) => DefKind::GlobalAsm,\n+                ItemKind::Impl { .. } => DefKind::Impl,\n             },\n             Node::ForeignItem(item) => match item.kind {\n                 ForeignItemKind::Fn(..) => DefKind::Fn,\n@@ -268,7 +272,7 @@ impl<'hir> Map<'hir> {\n             Node::Variant(_) => DefKind::Variant,\n             Node::Ctor(variant_data) => {\n                 // FIXME(eddyb) is this even possible, if we have a `Node::Ctor`?\n-                variant_data.ctor_hir_id()?;\n+                assert_ne!(variant_data.ctor_hir_id(), None);\n \n                 let ctor_of = match self.find(self.get_parent_node(hir_id)) {\n                     Some(Node::Item(..)) => def::CtorOf::Struct,\n@@ -277,10 +281,20 @@ impl<'hir> Map<'hir> {\n                 };\n                 DefKind::Ctor(ctor_of, def::CtorKind::from_hir(variant_data))\n             }\n-            Node::AnonConst(_)\n-            | Node::Field(_)\n-            | Node::Expr(_)\n-            | Node::Stmt(_)\n+            Node::AnonConst(_) => DefKind::AnonConst,\n+            Node::Field(_) => DefKind::Field,\n+            Node::Expr(expr) => match expr.kind {\n+                ExprKind::Closure(.., None) => DefKind::Closure,\n+                ExprKind::Closure(.., Some(_)) => DefKind::Generator,\n+                _ => bug!(\"def_kind: unsupported node: {}\", self.node_to_string(hir_id)),\n+            },\n+            Node::MacroDef(_) => DefKind::Macro(MacroKind::Bang),\n+            Node::GenericParam(param) => match param.kind {\n+                GenericParamKind::Lifetime { .. } => DefKind::LifetimeParam,\n+                GenericParamKind::Type { .. } => DefKind::TyParam,\n+                GenericParamKind::Const { .. } => DefKind::ConstParam,\n+            },\n+            Node::Stmt(_)\n             | Node::PathSegment(_)\n             | Node::Ty(_)\n             | Node::TraitRef(_)\n@@ -292,14 +306,8 @@ impl<'hir> Map<'hir> {\n             | Node::Lifetime(_)\n             | Node::Visibility(_)\n             | Node::Block(_)\n-            | Node::Crate(_) => return None,\n-            Node::MacroDef(_) => DefKind::Macro(MacroKind::Bang),\n-            Node::GenericParam(param) => match param.kind {\n-                GenericParamKind::Lifetime { .. } => return None,\n-                GenericParamKind::Type { .. } => DefKind::TyParam,\n-                GenericParamKind::Const { .. } => DefKind::ConstParam,\n-            },\n-        })\n+            | Node::Crate(_) => bug!(\"def_kind: unsupported node: {}\", self.node_to_string(hir_id)),\n+        }\n     }\n \n     fn find_entry(&self, id: HirId) -> Option<Entry<'hir>> {\n@@ -1082,6 +1090,5 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId) -> String {\n }\n \n pub fn provide(providers: &mut Providers<'_>) {\n-    providers.def_kind =\n-        |tcx, def_id| tcx.hir().def_kind(tcx.hir().as_local_hir_id(def_id.expect_local()));\n+    providers.def_kind = |tcx, def_id| tcx.hir().def_kind(def_id.expect_local());\n }"}, {"sha": "54c05bca3bd2bbfac04dbc72c1b0e5422e55ef80", "filename": "src/librustc_middle/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -246,7 +246,7 @@ pub enum EvalResult {\n fn skip_stability_check_due_to_privacy(tcx: TyCtxt<'_>, mut def_id: DefId) -> bool {\n     // Check if `def_id` is a trait method.\n     match tcx.def_kind(def_id) {\n-        Some(DefKind::AssocFn) | Some(DefKind::AssocTy) | Some(DefKind::AssocConst) => {\n+        DefKind::AssocFn | DefKind::AssocTy | DefKind::AssocConst => {\n             if let ty::TraitContainer(trait_def_id) = tcx.associated_item(def_id).container {\n                 // Trait methods do not declare visibility (even\n                 // for visibility info in cstore). Use containing"}, {"sha": "34c05ec59f38812438f8825514521b932b2eae04", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -23,14 +23,12 @@ use rustc_ast::ast::Name;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::dominators::{dominators, Dominators};\n use rustc_data_structures::graph::{self, GraphSuccessors};\n-use rustc_data_structures::sync::MappedLockGuard;\n use rustc_index::bit_set::BitMatrix;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n use rustc_serialize::{Decodable, Encodable};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n-use smallvec::SmallVec;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n use std::ops::{Index, IndexMut};\n@@ -170,7 +168,7 @@ pub struct Body<'tcx> {\n     /// FIXME(oli-obk): rewrite the promoted during promotion to eliminate the cell components.\n     pub ignore_interior_mut_in_const_validation: bool,\n \n-    pub predecessor_cache: PredecessorCache,\n+    predecessor_cache: PredecessorCache,\n }\n \n impl<'tcx> Body<'tcx> {\n@@ -398,15 +396,6 @@ impl<'tcx> Body<'tcx> {\n         Location { block: bb, statement_index: self[bb].statements.len() }\n     }\n \n-    #[inline]\n-    pub fn predecessors_for(\n-        &self,\n-        bb: BasicBlock,\n-    ) -> impl std::ops::Deref<Target = SmallVec<[BasicBlock; 4]>> + '_ {\n-        let predecessors = self.predecessor_cache.compute(&self.basic_blocks);\n-        MappedLockGuard::map(predecessors, |preds| &mut preds[bb])\n-    }\n-\n     #[inline]\n     pub fn predecessors(&self) -> impl std::ops::Deref<Target = Predecessors> + '_ {\n         self.predecessor_cache.compute(&self.basic_blocks)\n@@ -2684,7 +2673,7 @@ impl graph::GraphPredecessors<'graph> for Body<'tcx> {\n impl graph::WithPredecessors for Body<'tcx> {\n     #[inline]\n     fn predecessors(&self, node: Self::Node) -> <Self as graph::GraphPredecessors<'_>>::Iter {\n-        self.predecessors_for(node).clone().into_iter()\n+        self.predecessors()[node].clone().into_iter()\n     }\n }\n "}, {"sha": "9508365886aa790f3f83d029d9cf7106afac8fca", "filename": "src/librustc_middle/mir/predecessors.rs", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -1,5 +1,7 @@\n+//! Lazily compute the reverse control-flow graph for the MIR.\n+\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::sync::{Lock, LockGuard, MappedLockGuard};\n+use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_index::vec::IndexVec;\n use rustc_serialize as serialize;\n use smallvec::SmallVec;\n@@ -10,40 +12,49 @@ use crate::mir::{BasicBlock, BasicBlockData};\n pub type Predecessors = IndexVec<BasicBlock, SmallVec<[BasicBlock; 4]>>;\n \n #[derive(Clone, Debug)]\n-pub struct PredecessorCache {\n-    cache: Lock<Option<Predecessors>>,\n+pub(super) struct PredecessorCache {\n+    cache: Lock<Option<Lrc<Predecessors>>>,\n }\n \n impl PredecessorCache {\n     #[inline]\n-    pub fn new() -> Self {\n+    pub(super) fn new() -> Self {\n         PredecessorCache { cache: Lock::new(None) }\n     }\n \n+    /// Invalidates the predecessor cache.\n+    ///\n+    /// Invalidating the predecessor cache requires mutating the MIR, which in turn requires a\n+    /// unique reference (`&mut`) to the `mir::Body`. Because of this, we can assume that all\n+    /// callers of `invalidate` have a unique reference to the MIR and thus to the predecessor\n+    /// cache. This means we don't actually need to take a lock when `invalidate` is called.\n     #[inline]\n-    pub fn invalidate(&mut self) {\n+    pub(super) fn invalidate(&mut self) {\n         *self.cache.get_mut() = None;\n     }\n \n+    /// Returns a ref-counted smart pointer containing the predecessor graph for this MIR.\n+    ///\n+    /// We use ref-counting instead of a mapped `LockGuard` here to ensure that the lock for\n+    /// `cache` is only held inside this function. As long as no other locks are taken while\n+    /// computing the predecessor graph, deadlock is impossible.\n     #[inline]\n-    pub fn compute(\n+    pub(super) fn compute(\n         &self,\n         basic_blocks: &IndexVec<BasicBlock, BasicBlockData<'_>>,\n-    ) -> MappedLockGuard<'_, Predecessors> {\n-        LockGuard::map(self.cache.lock(), |cache| {\n-            cache.get_or_insert_with(|| {\n-                let mut preds = IndexVec::from_elem(SmallVec::new(), basic_blocks);\n-                for (bb, data) in basic_blocks.iter_enumerated() {\n-                    if let Some(term) = &data.terminator {\n-                        for &succ in term.successors() {\n-                            preds[succ].push(bb);\n-                        }\n+    ) -> Lrc<Predecessors> {\n+        Lrc::clone(self.cache.lock().get_or_insert_with(|| {\n+            let mut preds = IndexVec::from_elem(SmallVec::new(), basic_blocks);\n+            for (bb, data) in basic_blocks.iter_enumerated() {\n+                if let Some(term) = &data.terminator {\n+                    for &succ in term.successors() {\n+                        preds[succ].push(bb);\n                     }\n                 }\n+            }\n \n-                preds\n-            })\n-        })\n+            Lrc::new(preds)\n+        }))\n     }\n }\n "}, {"sha": "8b0509e314ce6eb2e2e5c7da5d8d95ef18f73ad1", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -620,7 +620,7 @@ rustc_queries! {\n             cache_on_disk_if { true }\n         }\n \n-        query def_kind(_: DefId) -> Option<DefKind> {}\n+        query def_kind(_: DefId) -> DefKind {}\n         query def_span(_: DefId) -> Span {\n             // FIXME(mw): DefSpans are not really inputs since they are derived from\n             // HIR. But at the moment HIR hashing still contains some hacks that allow"}, {"sha": "eae4055877b2a8f9fe4c036e84744b7a6951841a", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -48,7 +48,7 @@ use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId, LOCAL_CRATE};\n-use rustc_hir::definitions::{DefPathData, DefPathHash, Definitions};\n+use rustc_hir::definitions::{DefPathHash, Definitions};\n use rustc_hir::lang_items;\n use rustc_hir::lang_items::PanicLocationLangItem;\n use rustc_hir::{HirId, Node, TraitCandidate};\n@@ -1492,21 +1492,13 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Returns a displayable description and article for the given `def_id` (e.g. `(\"a\", \"struct\")`).\n     pub fn article_and_description(&self, def_id: DefId) -> (&'static str, &'static str) {\n-        self.def_kind(def_id)\n-            .map(|def_kind| (def_kind.article(), def_kind.descr(def_id)))\n-            .unwrap_or_else(|| match self.def_key(def_id).disambiguated_data.data {\n-                DefPathData::ClosureExpr => match self.generator_kind(def_id) {\n-                    None => (\"a\", \"closure\"),\n-                    Some(rustc_hir::GeneratorKind::Async(..)) => (\"an\", \"async closure\"),\n-                    Some(rustc_hir::GeneratorKind::Gen) => (\"a\", \"generator\"),\n-                },\n-                DefPathData::LifetimeNs(..) => (\"a\", \"lifetime\"),\n-                DefPathData::Impl => (\"an\", \"implementation\"),\n-                DefPathData::TypeNs(..) | DefPathData::ValueNs(..) | DefPathData::MacroNs(..) => {\n-                    unreachable!()\n-                }\n-                _ => bug!(\"article_and_description called on def_id {:?}\", def_id),\n-            })\n+        match self.def_kind(def_id) {\n+            DefKind::Generator => match self.generator_kind(def_id).unwrap() {\n+                rustc_hir::GeneratorKind::Async(..) => (\"an\", \"async closure\"),\n+                rustc_hir::GeneratorKind::Gen => (\"a\", \"generator\"),\n+            },\n+            def_kind => (def_kind.article(), def_kind.descr(def_id)),\n+        }\n     }\n }\n "}, {"sha": "d6c8ccf5ea62a98ededf5498ee8b0f5a7c813c1c", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -2680,7 +2680,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         } else {\n             match self.def_kind(def_id) {\n-                Some(DefKind::AssocConst | DefKind::AssocFn | DefKind::AssocTy) => true,\n+                DefKind::AssocConst | DefKind::AssocFn | DefKind::AssocTy => true,\n                 _ => false,\n             }\n         };"}, {"sha": "2d2704fc2bd8915f5286ff420e445a9317bbdf7d", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -888,7 +888,7 @@ pub trait PrettyPrinter<'tcx>:\n                     p!(write(\"::{:?}\", promoted));\n                 } else {\n                     match self.tcx().def_kind(did) {\n-                        Some(DefKind::Static | DefKind::Const | DefKind::AssocConst) => {\n+                        DefKind::Static | DefKind::Const | DefKind::AssocConst => {\n                             p!(print_value_path(did, substs))\n                         }\n                         _ => {"}, {"sha": "b46caf7985208472e21f7deb67b4f83b4d26b2b5", "filename": "src/librustc_middle/ty/util.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_middle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_middle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Futil.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -16,7 +16,6 @@ use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::definitions::DefPathData;\n use rustc_macros::HashStable;\n use rustc_span::Span;\n use rustc_target::abi::{Integer, Size, TargetDataLayout};\n@@ -446,24 +445,24 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// those are not yet phased out). The parent of the closure's\n     /// `DefId` will also be the context where it appears.\n     pub fn is_closure(self, def_id: DefId) -> bool {\n-        self.def_key(def_id).disambiguated_data.data == DefPathData::ClosureExpr\n+        matches!(self.def_kind(def_id), DefKind::Closure | DefKind::Generator)\n     }\n \n     /// Returns `true` if `def_id` refers to a trait (i.e., `trait Foo { ... }`).\n     pub fn is_trait(self, def_id: DefId) -> bool {\n-        self.def_kind(def_id) == Some(DefKind::Trait)\n+        self.def_kind(def_id) == DefKind::Trait\n     }\n \n     /// Returns `true` if `def_id` refers to a trait alias (i.e., `trait Foo = ...;`),\n     /// and `false` otherwise.\n     pub fn is_trait_alias(self, def_id: DefId) -> bool {\n-        self.def_kind(def_id) == Some(DefKind::TraitAlias)\n+        self.def_kind(def_id) == DefKind::TraitAlias\n     }\n \n     /// Returns `true` if this `DefId` refers to the implicit constructor for\n     /// a tuple struct like `struct Foo(u32)`, and `false` otherwise.\n     pub fn is_constructor(self, def_id: DefId) -> bool {\n-        self.def_key(def_id).disambiguated_data.data == DefPathData::Ctor\n+        matches!(self.def_kind(def_id), DefKind::Ctor(..))\n     }\n \n     /// Given the def-ID of a fn or closure, returns the def-ID of"}, {"sha": "d424d0525fdd8eef306efb796af23ec2dbc7506a", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -1269,7 +1269,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             location: Location,\n         ) -> impl Iterator<Item = Location> + 'a {\n             if location.statement_index == 0 {\n-                let predecessors = body.predecessors_for(location.block).to_vec();\n+                let predecessors = body.predecessors()[location.block].to_vec();\n                 Either::Left(predecessors.into_iter().map(move |bb| body.terminator_loc(bb)))\n             } else {\n                 Either::Right(std::iter::once(Location {"}, {"sha": "6cd814962c6133fac8e86a8d544b5984327c19d8", "filename": "src/librustc_mir/borrow_check/region_infer/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -89,7 +89,7 @@ impl RegionValueElements {\n             // If this is a basic block head, then the predecessors are\n             // the terminators of other basic blocks\n             stack.extend(\n-                body.predecessors_for(block)\n+                body.predecessors()[block]\n                     .iter()\n                     .map(|&pred_bb| body.terminator_loc(pred_bb))\n                     .map(|pred_loc| self.point_from_location(pred_loc)),"}, {"sha": "ec52a08c7b2162094da07e03d8f0e203c42947cb", "filename": "src/librustc_mir/borrow_check/type_check/liveness/trace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -303,7 +303,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         }\n \n         let body = self.cx.body;\n-        for &pred_block in body.predecessors_for(block).iter() {\n+        for &pred_block in body.predecessors()[block].iter() {\n             debug!(\"compute_drop_live_points_for_block: pred_block = {:?}\", pred_block,);\n \n             // Check whether the variable is (at least partially)"}, {"sha": "b6d10d1e3701da886b68a6f82af30ef380e0e8f1", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -341,7 +341,7 @@ pub fn const_eval_raw_provider<'tcx>(\n                     // because any code that existed before validation could not have failed\n                     // validation thus preventing such a hard error from being a backwards\n                     // compatibility hazard\n-                    Some(DefKind::Const | DefKind::AssocConst) => {\n+                    DefKind::Const | DefKind::AssocConst => {\n                         let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n                         err.report_as_lint(\n                             tcx.at(tcx.def_span(def_id)),"}, {"sha": "a497a6784ff6bc1bd143a06078c48dc506fa8599", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -632,7 +632,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // FIXME: The above is likely untrue. See\n             // <https://github.com/rust-lang/rust/pull/70004#issuecomment-602022110>. Is it\n             // okay to ignore `StorageDead`/`StorageLive` annotations during CTFE?\n-            Some(DefKind::Static | DefKind::Const | DefKind::AssocConst) => {}\n+            DefKind::Static | DefKind::Const | DefKind::AssocConst => {}\n             _ => {\n                 // Mark locals that use `Storage*` annotations as dead on function entry.\n                 let always_live = AlwaysLiveLocals::new(self.body());"}, {"sha": "0d0ed465c1cc6a1e9b4b0045e08a5ee525e2b1b1", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -400,7 +400,18 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n                 // We can still be zero-sized in this branch, in which case we have to\n                 // return `None`.\n-                if size.bytes() == 0 { None } else { Some(ptr) }\n+                if size.bytes() == 0 {\n+                    // We may be reading from a static.\n+                    // In order to ensure that `static FOO: Type = FOO;` causes a cycle error\n+                    // instead of magically pulling *any* ZST value from the ether, we need to\n+                    // actually access the referenced allocation. The caller is likely\n+                    // to short-circuit on `None`, so we trigger the access here to\n+                    // make sure it happens.\n+                    self.get_raw(ptr.alloc_id)?;\n+                    None\n+                } else {\n+                    Some(ptr)\n+                }\n             }\n         })\n     }"}, {"sha": "4d76a23005065be3317121b21d12addfafc10755", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -248,13 +248,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         };\n \n+        let alloc = self.memory.get_raw(ptr.alloc_id)?;\n+\n         match mplace.layout.abi {\n             Abi::Scalar(..) => {\n-                let scalar = self.memory.get_raw(ptr.alloc_id)?.read_scalar(\n-                    self,\n-                    ptr,\n-                    mplace.layout.size,\n-                )?;\n+                let scalar = alloc.read_scalar(self, ptr, mplace.layout.size)?;\n                 Ok(Some(ImmTy { imm: scalar.into(), layout: mplace.layout }))\n             }\n             Abi::ScalarPair(ref a, ref b) => {\n@@ -267,8 +265,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let b_offset = a_size.align_to(b.align(self).abi);\n                 assert!(b_offset.bytes() > 0); // we later use the offset to tell apart the fields\n                 let b_ptr = ptr.offset(b_offset, self)?;\n-                let a_val = self.memory.get_raw(ptr.alloc_id)?.read_scalar(self, a_ptr, a_size)?;\n-                let b_val = self.memory.get_raw(ptr.alloc_id)?.read_scalar(self, b_ptr, b_size)?;\n+                let a_val = alloc.read_scalar(self, a_ptr, a_size)?;\n+                let b_val = alloc.read_scalar(self, b_ptr, b_size)?;\n                 Ok(Some(ImmTy { imm: Immediate::ScalarPair(a_val, b_val), layout: mplace.layout }))\n             }\n             _ => Ok(None),"}, {"sha": "db1ea72c0a53101af30755e93ef5934c80d82947", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -779,7 +779,7 @@ fn compute_codegen_unit_name(\n                 cgu_def_id = Some(DefId { krate: def_id.krate, index: CRATE_DEF_INDEX });\n             }\n             break;\n-        } else if tcx.def_kind(current_def_id) == Some(DefKind::Mod) {\n+        } else if tcx.def_kind(current_def_id) == DefKind::Mod {\n             if cgu_def_id.is_none() {\n                 cgu_def_id = Some(current_def_id);\n             }"}, {"sha": "bad0b94f3ece71b03eead3f0a98c188418356fa4", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -69,10 +69,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n         let hir_id = tcx.hir().as_local_hir_id(source.def_id().expect_local());\n \n         let is_fn_like = FnLikeNode::from_node(tcx.hir().get(hir_id)).is_some();\n-        let is_assoc_const = match tcx.def_kind(source.def_id()) {\n-            Some(DefKind::AssocConst) => true,\n-            _ => false,\n-        };\n+        let is_assoc_const = tcx.def_kind(source.def_id()) == DefKind::AssocConst;\n \n         // Only run const prop on functions, methods, closures and associated constants\n         if !is_fn_like && !is_assoc_const {"}, {"sha": "8829b10d5dd79c3d09f049ebc0b789c1e817e9bb", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -807,17 +807,17 @@ fn write_mir_sig(\n     trace!(\"write_mir_sig: {:?}\", src.instance);\n     let kind = tcx.def_kind(src.def_id());\n     let is_function = match kind {\n-        Some(DefKind::Fn | DefKind::AssocFn | DefKind::Ctor(..)) => true,\n+        DefKind::Fn | DefKind::AssocFn | DefKind::Ctor(..) => true,\n         _ => tcx.is_closure(src.def_id()),\n     };\n     match (kind, src.promoted) {\n         (_, Some(i)) => write!(w, \"{:?} in \", i)?,\n-        (Some(DefKind::Const | DefKind::AssocConst), _) => write!(w, \"const \")?,\n-        (Some(DefKind::Static), _) => {\n+        (DefKind::Const | DefKind::AssocConst, _) => write!(w, \"const \")?,\n+        (DefKind::Static, _) => {\n             write!(w, \"static {}\", if tcx.is_mutable_static(src.def_id()) { \"mut \" } else { \"\" })?\n         }\n         (_, _) if is_function => write!(w, \"fn \")?,\n-        (None, _) => {} // things like anon const, not an item\n+        (DefKind::AnonConst, _) => {} // things like anon const, not an item\n         _ => bug!(\"Unexpected def kind {:?}\", kind),\n     }\n "}, {"sha": "3b778cacefe13f7f5940a54b68679481250d71e9", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -553,12 +553,13 @@ impl DeadVisitor<'tcx> {\n         id: hir::HirId,\n         span: rustc_span::Span,\n         name: ast::Name,\n-        node_type: &str,\n         participle: &str,\n     ) {\n         if !name.as_str().starts_with('_') {\n             self.tcx.struct_span_lint_hir(lint::builtin::DEAD_CODE, id, span, |lint| {\n-                lint.build(&format!(\"{} is never {}: `{}`\", node_type, participle, name)).emit()\n+                let def_id = self.tcx.hir().local_def_id(id);\n+                let descr = self.tcx.def_kind(def_id).descr(def_id.to_def_id());\n+                lint.build(&format!(\"{} is never {}: `{}`\", descr, participle, name)).emit()\n             });\n         }\n     }\n@@ -604,7 +605,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n                 hir::ItemKind::Struct(..) => \"constructed\", // Issue #52325\n                 _ => \"used\",\n             };\n-            self.warn_dead_code(item.hir_id, span, item.ident.name, item.kind.descr(), participle);\n+            self.warn_dead_code(item.hir_id, span, item.ident.name, participle);\n         } else {\n             // Only continue if we didn't warn\n             intravisit::walk_item(self, item);\n@@ -618,34 +619,22 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n         id: hir::HirId,\n     ) {\n         if self.should_warn_about_variant(&variant) {\n-            self.warn_dead_code(\n-                variant.id,\n-                variant.span,\n-                variant.ident.name,\n-                \"variant\",\n-                \"constructed\",\n-            );\n+            self.warn_dead_code(variant.id, variant.span, variant.ident.name, \"constructed\");\n         } else {\n             intravisit::walk_variant(self, variant, g, id);\n         }\n     }\n \n     fn visit_foreign_item(&mut self, fi: &'tcx hir::ForeignItem<'tcx>) {\n         if self.should_warn_about_foreign_item(fi) {\n-            self.warn_dead_code(\n-                fi.hir_id,\n-                fi.span,\n-                fi.ident.name,\n-                fi.kind.descriptive_variant(),\n-                \"used\",\n-            );\n+            self.warn_dead_code(fi.hir_id, fi.span, fi.ident.name, \"used\");\n         }\n         intravisit::walk_foreign_item(self, fi);\n     }\n \n     fn visit_struct_field(&mut self, field: &'tcx hir::StructField<'tcx>) {\n         if self.should_warn_about_field(&field) {\n-            self.warn_dead_code(field.hir_id, field.span, field.ident.name, \"field\", \"read\");\n+            self.warn_dead_code(field.hir_id, field.span, field.ident.name, \"read\");\n         }\n         intravisit::walk_struct_field(self, field);\n     }\n@@ -658,7 +647,6 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n                         impl_item.hir_id,\n                         impl_item.span,\n                         impl_item.ident.name,\n-                        \"associated const\",\n                         \"used\",\n                     );\n                 }\n@@ -667,13 +655,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n             hir::ImplItemKind::Fn(_, body_id) => {\n                 if !self.symbol_is_live(impl_item.hir_id) {\n                     let span = self.tcx.sess.source_map().guess_head_span(impl_item.span);\n-                    self.warn_dead_code(\n-                        impl_item.hir_id,\n-                        span,\n-                        impl_item.ident.name,\n-                        \"method\",\n-                        \"used\",\n-                    );\n+                    self.warn_dead_code(impl_item.hir_id, span, impl_item.ident.name, \"used\");\n                 }\n                 self.visit_nested_body(body_id)\n             }"}, {"sha": "ad9934d379ac5780aed566a8dea4a57595310d59", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -337,12 +337,14 @@ struct MissingStabilityAnnotations<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> MissingStabilityAnnotations<'a, 'tcx> {\n-    fn check_missing_stability(&self, hir_id: HirId, span: Span, name: &str) {\n+    fn check_missing_stability(&self, hir_id: HirId, span: Span) {\n         let stab = self.tcx.stability().local_stability(hir_id);\n         let is_error =\n             !self.tcx.sess.opts.test && stab.is_none() && self.access_levels.is_reachable(hir_id);\n         if is_error {\n-            self.tcx.sess.span_err(span, &format!(\"{} has missing stability attribute\", name));\n+            let def_id = self.tcx.hir().local_def_id(hir_id);\n+            let descr = self.tcx.def_kind(def_id).descr(def_id.to_def_id());\n+            self.tcx.sess.span_err(span, &format!(\"{} has missing stability attribute\", descr));\n         }\n     }\n }\n@@ -362,42 +364,42 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n             // optional. They inherit stability from their parents when unannotated.\n             hir::ItemKind::Impl { of_trait: None, .. } | hir::ItemKind::ForeignMod(..) => {}\n \n-            _ => self.check_missing_stability(i.hir_id, i.span, i.kind.descr()),\n+            _ => self.check_missing_stability(i.hir_id, i.span),\n         }\n \n         intravisit::walk_item(self, i)\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem<'tcx>) {\n-        self.check_missing_stability(ti.hir_id, ti.span, \"item\");\n+        self.check_missing_stability(ti.hir_id, ti.span);\n         intravisit::walk_trait_item(self, ti);\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem<'tcx>) {\n         let impl_def_id = self.tcx.hir().local_def_id(self.tcx.hir().get_parent_item(ii.hir_id));\n         if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n-            self.check_missing_stability(ii.hir_id, ii.span, \"item\");\n+            self.check_missing_stability(ii.hir_id, ii.span);\n         }\n         intravisit::walk_impl_item(self, ii);\n     }\n \n     fn visit_variant(&mut self, var: &'tcx Variant<'tcx>, g: &'tcx Generics<'tcx>, item_id: HirId) {\n-        self.check_missing_stability(var.id, var.span, \"variant\");\n+        self.check_missing_stability(var.id, var.span);\n         intravisit::walk_variant(self, var, g, item_id);\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx StructField<'tcx>) {\n-        self.check_missing_stability(s.hir_id, s.span, \"field\");\n+        self.check_missing_stability(s.hir_id, s.span);\n         intravisit::walk_struct_field(self, s);\n     }\n \n     fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem<'tcx>) {\n-        self.check_missing_stability(i.hir_id, i.span, i.kind.descriptive_variant());\n+        self.check_missing_stability(i.hir_id, i.span);\n         intravisit::walk_foreign_item(self, i);\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n-        self.check_missing_stability(md.hir_id, md.span, \"macro\");\n+        self.check_missing_stability(md.hir_id, md.span);\n     }\n }\n \n@@ -585,7 +587,7 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n     if tcx.stability().staged_api[&LOCAL_CRATE] {\n         let krate = tcx.hir().krate();\n         let mut missing = MissingStabilityAnnotations { tcx, access_levels };\n-        missing.check_missing_stability(hir::CRATE_HIR_ID, krate.item.span, \"crate\");\n+        missing.check_missing_stability(hir::CRATE_HIR_ID, krate.item.span);\n         intravisit::walk_crate(&mut missing, krate);\n         krate.visit_all_item_likes(&mut missing.as_deep_visitor());\n     }"}, {"sha": "e4501b5c3b562d1a0d0047769b732793bc902867", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -1,6 +1,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n+#![feature(or_patterns)]\n #![recursion_limit = \"256\"]\n \n use rustc_ast::ast::Ident;\n@@ -537,11 +538,10 @@ impl EmbargoVisitor<'tcx> {\n         for item_id in module.item_ids {\n             let hir_id = item_id.id;\n             let item_def_id = self.tcx.hir().local_def_id(hir_id);\n-            if let Some(def_kind) = self.tcx.def_kind(item_def_id) {\n-                let item = self.tcx.hir().expect_item(hir_id);\n-                let vis = ty::Visibility::from_hir(&item.vis, hir_id, self.tcx);\n-                self.update_macro_reachable_def(hir_id, def_kind, vis, defining_mod);\n-            }\n+            let def_kind = self.tcx.def_kind(item_def_id);\n+            let item = self.tcx.hir().expect_item(hir_id);\n+            let vis = ty::Visibility::from_hir(&item.vis, hir_id, self.tcx);\n+            self.update_macro_reachable_def(hir_id, def_kind, vis, defining_mod);\n         }\n         if let Some(exports) = self.tcx.module_exports(module_def_id) {\n             for export in exports {\n@@ -613,7 +613,7 @@ impl EmbargoVisitor<'tcx> {\n             }\n \n             // These have type privacy, so are not reachable unless they're\n-            // public\n+            // public, or are not namespaced at all.\n             DefKind::AssocConst\n             | DefKind::AssocTy\n             | DefKind::AssocOpaqueTy\n@@ -626,7 +626,17 @@ impl EmbargoVisitor<'tcx> {\n             | DefKind::AssocFn\n             | DefKind::Trait\n             | DefKind::TyParam\n-            | DefKind::Variant => (),\n+            | DefKind::Variant\n+            | DefKind::LifetimeParam\n+            | DefKind::ExternCrate\n+            | DefKind::Use\n+            | DefKind::ForeignMod\n+            | DefKind::AnonConst\n+            | DefKind::Field\n+            | DefKind::GlobalAsm\n+            | DefKind::Impl\n+            | DefKind::Closure\n+            | DefKind::Generator => (),\n         }\n     }\n "}, {"sha": "bd484fc7a90cf1c569279331b8221dda6830cfe8", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -906,7 +906,21 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             Res::Def(DefKind::Macro(..), _) | Res::NonMacroAttr(..) => {\n                 self.r.define(parent, ident, MacroNS, (res, vis, span, expansion))\n             }\n-            Res::Def(DefKind::TyParam | DefKind::ConstParam, _)\n+            Res::Def(\n+                DefKind::TyParam\n+                | DefKind::ConstParam\n+                | DefKind::ExternCrate\n+                | DefKind::Use\n+                | DefKind::ForeignMod\n+                | DefKind::AnonConst\n+                | DefKind::Field\n+                | DefKind::LifetimeParam\n+                | DefKind::GlobalAsm\n+                | DefKind::Closure\n+                | DefKind::Impl\n+                | DefKind::Generator,\n+                _,\n+            )\n             | Res::Local(..)\n             | Res::SelfTy(..)\n             | Res::SelfCtor(..)"}, {"sha": "26ea75ad7ef6471d26baf3e21ee31f99fec70724", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -2504,10 +2504,8 @@ impl<'a> Resolver<'a> {\n         }\n \n         let container = match parent.kind {\n-            ModuleKind::Def(DefKind::Mod, _, _) => \"module\",\n-            ModuleKind::Def(DefKind::Trait, _, _) => \"trait\",\n+            ModuleKind::Def(kind, _, _) => kind.descr(parent.def_id().unwrap()),\n             ModuleKind::Block(..) => \"block\",\n-            _ => \"enum\",\n         };\n \n         let old_noun = match old_binding.is_import() {"}, {"sha": "8456a0304fec6e9f00db0290919dcdd41969e09b", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -760,9 +760,23 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             Res::Def(HirDefKind::Mod, def_id) => {\n                 Some(Ref { kind: RefKind::Mod, span, ref_id: id_from_def_id(def_id) })\n             }\n-            Res::PrimTy(..)\n+\n+            Res::Def(\n+                HirDefKind::Macro(..)\n+                | HirDefKind::ExternCrate\n+                | HirDefKind::ForeignMod\n+                | HirDefKind::LifetimeParam\n+                | HirDefKind::AnonConst\n+                | HirDefKind::Use\n+                | HirDefKind::Field\n+                | HirDefKind::GlobalAsm\n+                | HirDefKind::Impl\n+                | HirDefKind::Closure\n+                | HirDefKind::Generator,\n+                _,\n+            )\n+            | Res::PrimTy(..)\n             | Res::SelfTy(..)\n-            | Res::Def(HirDefKind::Macro(..), _)\n             | Res::ToolMod\n             | Res::NonMacroAttr(..)\n             | Res::SelfCtor(..)"}, {"sha": "19260f4d573ac446a42af6dacfe6c61a8560f266", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -1487,7 +1487,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 // ```\n                 debug!(\"parent_def_kind: {:?}\", self.tcx.def_kind(parent_did));\n                 let is_raw_borrow_inside_fn_like_call = match self.tcx.def_kind(parent_did) {\n-                    Some(DefKind::Fn | DefKind::Ctor(..)) => target_ty.is_unsafe_ptr(),\n+                    DefKind::Fn | DefKind::Ctor(..) => target_ty.is_unsafe_ptr(),\n                     _ => false,\n                 };\n "}, {"sha": "19765c36ae26a7166a4233b292a65803df84cbba", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -150,24 +150,22 @@ crate fn program_clauses_for(tcx: TyCtxt<'_>, def_id: DefId) -> Clauses<'_> {\n     // FIXME(eddyb) this should only be using `def_kind`.\n     match tcx.def_key(def_id).disambiguated_data.data {\n         DefPathData::TypeNs(..) => match tcx.def_kind(def_id) {\n-            Some(DefKind::Trait | DefKind::TraitAlias) => program_clauses_for_trait(tcx, def_id),\n+            DefKind::Trait | DefKind::TraitAlias => program_clauses_for_trait(tcx, def_id),\n             // FIXME(eddyb) deduplicate this `associated_item` call with\n             // `program_clauses_for_associated_type_{value,def}`.\n-            Some(DefKind::AssocTy) => match tcx.associated_item(def_id).container {\n+            DefKind::AssocTy => match tcx.associated_item(def_id).container {\n                 ty::AssocItemContainer::ImplContainer(_) => {\n                     program_clauses_for_associated_type_value(tcx, def_id)\n                 }\n                 ty::AssocItemContainer::TraitContainer(_) => {\n                     program_clauses_for_associated_type_def(tcx, def_id)\n                 }\n             },\n-            Some(\n-                DefKind::Struct\n-                | DefKind::Enum\n-                | DefKind::TyAlias\n-                | DefKind::Union\n-                | DefKind::OpaqueTy,\n-            ) => program_clauses_for_type_def(tcx, def_id),\n+            DefKind::Struct\n+            | DefKind::Enum\n+            | DefKind::TyAlias\n+            | DefKind::Union\n+            | DefKind::OpaqueTy => program_clauses_for_type_def(tcx, def_id),\n             _ => List::empty(),\n         },\n         DefPathData::Impl => program_clauses_for_impl(tcx, def_id),"}, {"sha": "478a848cf09ddab28f40af8cc6f82699b3a86e53", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -94,10 +94,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n             }\n             Err(_) => {\n                 let item_span = tcx.def_span(self_type_did);\n-                let self_descr = tcx\n-                    .def_kind(self_type_did)\n-                    .map(|kind| kind.descr(self_type_did))\n-                    .unwrap_or(\"type\");\n+                let self_descr = tcx.def_kind(self_type_did).descr(self_type_did);\n                 struct_span_err!(\n                     tcx.sess,\n                     drop_impl_span,\n@@ -244,10 +241,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n \n         if !assumptions_in_impl_context.iter().any(predicate_matches_closure) {\n             let item_span = tcx.hir().span(self_type_hir_id);\n-            let self_descr = tcx\n-                .def_kind(self_type_did)\n-                .map(|kind| kind.descr(self_type_did.to_def_id()))\n-                .unwrap_or(\"type\");\n+            let self_descr = tcx.def_kind(self_type_did).descr(self_type_did.to_def_id());\n             struct_span_err!(\n                 tcx.sess,\n                 *predicate_sp,"}, {"sha": "d287589789e2d0103e812f7990bda22a32f0b2de", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -1564,10 +1564,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         base_did: DefId,\n     ) {\n         let struct_path = self.tcx().def_path_str(base_did);\n-        let kind_name = match self.tcx().def_kind(base_did) {\n-            Some(def_kind) => def_kind.descr(base_did),\n-            _ => \" \",\n-        };\n+        let kind_name = self.tcx().def_kind(base_did).descr(base_did);\n         let mut err = struct_span_err!(\n             self.tcx().sess,\n             field.span,"}, {"sha": "d631d3c33405ec8f420f68d928b357411fe1c935", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -831,18 +831,22 @@ fn primary_body_of(\n }\n \n fn has_typeck_tables(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    // FIXME(#71104) some `LocalDefId` do not seem to have a corresponding `HirId`.\n+    if let Some(def_id) = def_id.as_local() {\n+        if tcx.hir().opt_local_def_id_to_hir_id(def_id).is_none() {\n+            return false;\n+        }\n+    }\n+\n     // Closures' tables come from their outermost function,\n     // as they are part of the same \"inference environment\".\n     let outer_def_id = tcx.closure_base_def_id(def_id);\n     if outer_def_id != def_id {\n         return tcx.has_typeck_tables(outer_def_id);\n     }\n \n-    // FIXME(#71104) Should really be using just `as_local_hir_id` but\n-    // some `LocalDefId` do not seem to have a corresponding HirId.\n-    if let Some(id) =\n-        def_id.as_local().and_then(|def_id| tcx.hir().opt_local_def_id_to_hir_id(def_id))\n-    {\n+    if let Some(def_id) = def_id.as_local() {\n+        let id = tcx.hir().local_def_id_to_hir_id(def_id);\n         primary_body_of(tcx, id).is_some()\n     } else {\n         false\n@@ -4971,15 +4975,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 Some(Node::Ctor(hir::VariantData::Tuple(fields, _))) => {\n                     sugg_call = fields.iter().map(|_| \"_\").collect::<Vec<_>>().join(\", \");\n-                    match def_id\n-                        .as_local()\n-                        .map(|def_id| hir.as_local_hir_id(def_id))\n-                        .and_then(|hir_id| hir.def_kind(hir_id))\n-                    {\n-                        Some(hir::def::DefKind::Ctor(hir::def::CtorOf::Variant, _)) => {\n+                    match def_id.as_local().map(|def_id| hir.def_kind(def_id)) {\n+                        Some(DefKind::Ctor(hir::def::CtorOf::Variant, _)) => {\n                             msg = \"instantiate this tuple variant\";\n                         }\n-                        Some(hir::def::DefKind::Ctor(hir::def::CtorOf::Struct, _)) => {\n+                        Some(DefKind::Ctor(CtorOf::Struct, _)) => {\n                             msg = \"instantiate this tuple struct\";\n                         }\n                         _ => {}"}, {"sha": "cd098936ed6a519c260e16f30e2a12e4dbfa4d49", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -278,7 +278,7 @@ fn build_type_alias_type(cx: &DocContext<'_>, did: DefId) -> Option<clean::Type>\n }\n \n pub fn build_ty(cx: &DocContext, did: DefId) -> Option<clean::Type> {\n-    match cx.tcx.def_kind(did)? {\n+    match cx.tcx.def_kind(did) {\n         DefKind::Struct | DefKind::Union | DefKind::Enum | DefKind::Const | DefKind::Static => {\n             Some(cx.tcx.type_of(did).clean(cx))\n         }"}, {"sha": "55c32e917f25ce916e0e29669da6af4a0939afbd", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -2135,7 +2135,7 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n \n         let for_ = self.for_.clean(cx);\n         let type_alias = for_.def_id().and_then(|did| match cx.tcx.def_kind(did) {\n-            Some(DefKind::TyAlias) => Some(cx.tcx.type_of(did).clean(cx)),\n+            DefKind::TyAlias => Some(cx.tcx.type_of(did).clean(cx)),\n             _ => None,\n         });\n         let make_item = |trait_: Option<Type>, for_: Type, items: Vec<Item>| Item {"}, {"sha": "c4e4802db6c0716f85d731689289ee37e9327c51", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -209,7 +209,7 @@ pub fn get_real_types(\n                                 res.extend(adds);\n                             } else if !ty.is_full_generic() {\n                                 if let Some(kind) =\n-                                    ty.def_id().and_then(|did| cx.tcx.def_kind(did).clean(cx))\n+                                    ty.def_id().map(|did| cx.tcx.def_kind(did).clean(cx))\n                                 {\n                                     res.insert((ty, kind));\n                                 }\n@@ -226,17 +226,15 @@ pub fn get_real_types(\n                     if !adds.is_empty() {\n                         res.extend(adds);\n                     } else if !ty.is_full_generic() {\n-                        if let Some(kind) =\n-                            ty.def_id().and_then(|did| cx.tcx.def_kind(did).clean(cx))\n-                        {\n+                        if let Some(kind) = ty.def_id().map(|did| cx.tcx.def_kind(did).clean(cx)) {\n                             res.insert((ty.clone(), kind));\n                         }\n                     }\n                 }\n             }\n         }\n     } else {\n-        if let Some(kind) = arg.def_id().and_then(|did| cx.tcx.def_kind(did).clean(cx)) {\n+        if let Some(kind) = arg.def_id().map(|did| cx.tcx.def_kind(did).clean(cx)) {\n             res.insert((arg.clone(), kind));\n         }\n         if let Some(gens) = arg.generics() {\n@@ -246,9 +244,7 @@ pub fn get_real_types(\n                     if !adds.is_empty() {\n                         res.extend(adds);\n                     }\n-                } else if let Some(kind) =\n-                    gen.def_id().and_then(|did| cx.tcx.def_kind(did).clean(cx))\n-                {\n+                } else if let Some(kind) = gen.def_id().map(|did| cx.tcx.def_kind(did).clean(cx)) {\n                     res.insert((gen.clone(), kind));\n                 }\n             }\n@@ -275,7 +271,7 @@ pub fn get_all_types(\n         if !args.is_empty() {\n             all_types.extend(args);\n         } else {\n-            if let Some(kind) = arg.type_.def_id().and_then(|did| cx.tcx.def_kind(did).clean(cx)) {\n+            if let Some(kind) = arg.type_.def_id().map(|did| cx.tcx.def_kind(did).clean(cx)) {\n                 all_types.insert((arg.type_.clone(), kind));\n             }\n         }\n@@ -285,9 +281,7 @@ pub fn get_all_types(\n         FnRetTy::Return(ref return_type) => {\n             let mut ret = get_real_types(generics, &return_type, cx, 0);\n             if ret.is_empty() {\n-                if let Some(kind) =\n-                    return_type.def_id().and_then(|did| cx.tcx.def_kind(did).clean(cx))\n-                {\n+                if let Some(kind) = return_type.def_id().map(|did| cx.tcx.def_kind(did).clean(cx)) {\n                     ret.insert((return_type.clone(), kind));\n                 }\n             }"}, {"sha": "e659bdb83f9c1886ea471fbd28d725909d0e6c85", "filename": "src/test/ui/associated-const/associated-const-dead-code.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-dead-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-dead-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-dead-code.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -4,7 +4,7 @@ struct MyFoo;\n \n impl MyFoo {\n     const BAR: u32 = 1;\n-    //~^ ERROR associated const is never used: `BAR`\n+    //~^ ERROR associated constant is never used: `BAR`\n }\n \n fn main() {"}, {"sha": "9b6bbb68a71f770d6d8fb978b1e3bcb6621d7c84", "filename": "src/test/ui/associated-const/associated-const-dead-code.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-dead-code.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-dead-code.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-dead-code.stderr?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -1,4 +1,4 @@\n-error: associated const is never used: `BAR`\n+error: associated constant is never used: `BAR`\n   --> $DIR/associated-const-dead-code.rs:6:5\n    |\n LL |     const BAR: u32 = 1;"}, {"sha": "768df58e1e32e65ed229813af56a6b2309a32c63", "filename": "src/test/ui/consts/recursive-zst-static.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -1,6 +1,10 @@\n-// build-pass\n+// This test ensures that we do not allow ZST statics to initialize themselves without ever\n+// actually creating a value of that type. This is important, as the ZST may have private fields\n+// that users can reasonably expect to only get initialized by their own code. Thus unsafe code\n+// can depend on this fact and will thus do unsound things when it is violated.\n+// See https://github.com/rust-lang/rust/issues/71078 for more details.\n \n-static FOO: () = FOO;\n+static FOO: () = FOO; //~ cycle detected when const-evaluating `FOO`\n \n fn main() {\n     FOO"}, {"sha": "e21dcf691ab0af41a084a28200f7fe6d1ce390da", "filename": "src/test/ui/consts/recursive-zst-static.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.stderr?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -0,0 +1,21 @@\n+error[E0391]: cycle detected when const-evaluating `FOO`\n+  --> $DIR/recursive-zst-static.rs:7:18\n+   |\n+LL | static FOO: () = FOO;\n+   |                  ^^^\n+   |\n+note: ...which requires const-evaluating `FOO`...\n+  --> $DIR/recursive-zst-static.rs:7:1\n+   |\n+LL | static FOO: () = FOO;\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which again requires const-evaluating `FOO`, completing the cycle\n+note: cycle used when const-evaluating + checking `FOO`\n+  --> $DIR/recursive-zst-static.rs:7:1\n+   |\n+LL | static FOO: () = FOO;\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0391`."}, {"sha": "7386478f9f08c83970236cac22dac15390dfdc54", "filename": "src/test/ui/issues/issue-17718-const-naming.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-naming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-naming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-naming.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -3,6 +3,6 @@\n \n const foo: isize = 3;\n //~^ ERROR: should have an upper case name\n-//~^^ ERROR: constant item is never used\n+//~^^ ERROR: constant is never used\n \n fn main() {}"}, {"sha": "ce4ebcb5e3ef692431f66a03f790372d742cd939", "filename": "src/test/ui/issues/issue-17718-const-naming.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-naming.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-naming.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-naming.stderr?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -1,4 +1,4 @@\n-error: constant item is never used: `foo`\n+error: constant is never used: `foo`\n   --> $DIR/issue-17718-const-naming.rs:4:1\n    |\n LL | const foo: isize = 3;"}, {"sha": "896147fcc7738caa3e39614e4a31cc8cee592408", "filename": "src/test/ui/lint/dead-code/lint-dead-code-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Flint%2Fdead-code%2Flint-dead-code-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Flint%2Fdead-code%2Flint-dead-code-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Flint-dead-code-1.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -17,14 +17,14 @@ mod foo2 {\n }\n \n pub static pub_static: isize = 0;\n-static priv_static: isize = 0; //~ ERROR: static item is never used\n+static priv_static: isize = 0; //~ ERROR: static is never used\n const used_static: isize = 0;\n pub static used_static2: isize = used_static;\n const USED_STATIC: isize = 0;\n const STATIC_USED_IN_ENUM_DISCRIMINANT: isize = 10;\n \n pub const pub_const: isize = 0;\n-const priv_const: isize = 0; //~ ERROR: constant item is never used\n+const priv_const: isize = 0; //~ ERROR: constant is never used\n const used_const: isize = 0;\n pub const used_const2: isize = used_const;\n const USED_CONST: isize = 1;"}, {"sha": "af97ea98b2b6d0a595308333c8330c78974298e8", "filename": "src/test/ui/lint/dead-code/lint-dead-code-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Flint%2Fdead-code%2Flint-dead-code-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Flint%2Fdead-code%2Flint-dead-code-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Flint-dead-code-1.stderr?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -10,13 +10,13 @@ note: the lint level is defined here\n LL | #![deny(dead_code)]\n    |         ^^^^^^^^^\n \n-error: static item is never used: `priv_static`\n+error: static is never used: `priv_static`\n   --> $DIR/lint-dead-code-1.rs:20:1\n    |\n LL | static priv_static: isize = 0;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: constant item is never used: `priv_const`\n+error: constant is never used: `priv_const`\n   --> $DIR/lint-dead-code-1.rs:27:1\n    |\n LL | const priv_const: isize = 0;"}, {"sha": "6826d2cd67eb9489f251b21038e0c15e6dd1fa1d", "filename": "src/test/ui/lint/dead-code/lint-dead-code-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Flint%2Fdead-code%2Flint-dead-code-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Flint%2Fdead-code%2Flint-dead-code-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Flint-dead-code-3.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -12,7 +12,7 @@ extern {\n \n struct Foo; //~ ERROR: struct is never constructed\n impl Foo {\n-    fn foo(&self) { //~ ERROR: method is never used\n+    fn foo(&self) { //~ ERROR: associated function is never used\n         bar()\n     }\n }\n@@ -58,7 +58,7 @@ mod blah {\n \n enum c_void {} //~ ERROR: enum is never used\n extern {\n-    fn free(p: *const c_void); //~ ERROR: foreign function is never used\n+    fn free(p: *const c_void); //~ ERROR: function is never used\n }\n \n // Check provided method"}, {"sha": "a2614a0bf74b318fef357975129d8ca93c53caaf", "filename": "src/test/ui/lint/dead-code/lint-dead-code-3.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Flint%2Fdead-code%2Flint-dead-code-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Flint%2Fdead-code%2Flint-dead-code-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Flint-dead-code-3.stderr?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -10,7 +10,7 @@ note: the lint level is defined here\n LL | #![deny(dead_code)]\n    |         ^^^^^^^^^\n \n-error: method is never used: `foo`\n+error: associated function is never used: `foo`\n   --> $DIR/lint-dead-code-3.rs:15:5\n    |\n LL |     fn foo(&self) {\n@@ -28,7 +28,7 @@ error: enum is never used: `c_void`\n LL | enum c_void {}\n    |      ^^^^^^\n \n-error: foreign function is never used: `free`\n+error: function is never used: `free`\n   --> $DIR/lint-dead-code-3.rs:61:5\n    |\n LL |     fn free(p: *const c_void);"}, {"sha": "38faa24691604331294d0b020e3c1d3db0b4fe86", "filename": "src/test/ui/stability-attribute/missing-stability-attr-at-top-level.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Fstability-attribute%2Fmissing-stability-attr-at-top-level.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Fstability-attribute%2Fmissing-stability-attr-at-top-level.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fmissing-stability-attr-at-top-level.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -1,4 +1,4 @@\n #![feature(staged_api)]\n-//~^ ERROR crate has missing stability attribute\n+//~^ ERROR module has missing stability attribute\n \n fn main() {}"}, {"sha": "c7ade234d3dccb072aeadf0c3a3b661f83c5b23a", "filename": "src/test/ui/stability-attribute/missing-stability-attr-at-top-level.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Fstability-attribute%2Fmissing-stability-attr-at-top-level.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Fstability-attribute%2Fmissing-stability-attr-at-top-level.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fmissing-stability-attr-at-top-level.stderr?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -1,4 +1,4 @@\n-error: crate has missing stability attribute\n+error: module has missing stability attribute\n   --> $DIR/missing-stability-attr-at-top-level.rs:1:1\n    |\n LL | / #![feature(staged_api)]"}, {"sha": "2d265d5db5c14ce3d4a08c28b33009896622f2af", "filename": "src/test/ui/unsized/return-unsized-from-trait-method.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Funsized%2Freturn-unsized-from-trait-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Funsized%2Freturn-unsized-from-trait-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Freturn-unsized-from-trait-method.rs?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -0,0 +1,16 @@\n+// ignore-tidy-linelength\n+\n+// regression test for #26376\n+\n+trait Foo {\n+    fn foo(&self) -> [u8];\n+}\n+\n+fn foo(f: Option<&dyn Foo>) {\n+    if let Some(f) = f {\n+        let _ = f.foo();\n+        //~^ ERROR cannot move a value of type [u8]: the size of [u8] cannot be statically determined\n+    }\n+}\n+\n+fn main() { foo(None) }"}, {"sha": "7ecdd28616674f8e9e86596d26a766d0a717f252", "filename": "src/test/ui/unsized/return-unsized-from-trait-method.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Funsized%2Freturn-unsized-from-trait-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b/src%2Ftest%2Fui%2Funsized%2Freturn-unsized-from-trait-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Freturn-unsized-from-trait-method.stderr?ref=b592b37fa31c0d81ca23fea9fe7998c3f0f4bd0b", "patch": "@@ -0,0 +1,9 @@\n+error[E0161]: cannot move a value of type [u8]: the size of [u8] cannot be statically determined\n+  --> $DIR/return-unsized-from-trait-method.rs:11:17\n+   |\n+LL |         let _ = f.foo();\n+   |                 ^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0161`."}]}