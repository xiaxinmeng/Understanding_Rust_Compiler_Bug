{"sha": "454d13badf6a5d423ba1cc56d106137752db719c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1NGQxM2JhZGY2YTVkNDIzYmExY2M1NmQxMDYxMzc3NTJkYjcxOWM=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-11-23T16:26:01Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-11-23T17:46:07Z"}, "message": "Handle anchor errors", "tree": {"sha": "698d869619c05a1dc0e6e68b6b56538c6794f0cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/698d869619c05a1dc0e6e68b6b56538c6794f0cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/454d13badf6a5d423ba1cc56d106137752db719c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/454d13badf6a5d423ba1cc56d106137752db719c", "html_url": "https://github.com/rust-lang/rust/commit/454d13badf6a5d423ba1cc56d106137752db719c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/454d13badf6a5d423ba1cc56d106137752db719c/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09293bec925241782e5d173292fad68735d6961a", "url": "https://api.github.com/repos/rust-lang/rust/commits/09293bec925241782e5d173292fad68735d6961a", "html_url": "https://github.com/rust-lang/rust/commit/09293bec925241782e5d173292fad68735d6961a"}], "stats": {"total": 303, "additions": 190, "deletions": 113}, "files": [{"sha": "811596505c1fd856a60ae536e4692bde9d57224a", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 190, "deletions": 113, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/454d13badf6a5d423ba1cc56d106137752db719c/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/454d13badf6a5d423ba1cc56d106137752db719c/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=454d13badf6a5d423ba1cc56d106137752db719c", "patch": "@@ -38,6 +38,11 @@ pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     }\n }\n \n+enum ErrorKind {\n+    ResolutionFailure,\n+    AnchorFailure(&'static str),\n+}\n+\n struct LinkCollector<'a, 'tcx> {\n     cx: &'a DocContext<'tcx>,\n     mod_ids: Vec<hir::HirId>,\n@@ -53,14 +58,14 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n     /// Resolves a string as a path within a particular namespace. Also returns an optional\n     /// URL fragment in the case of variants and methods.\n-    fn resolve(&self,\n-               path_str: &str,\n-               ns: Namespace,\n-               current_item: &Option<String>,\n-               parent_id: Option<hir::HirId>,\n-               extra_fragment: &Option<String>)\n-        -> Result<(Res, Option<String>), ()>\n-    {\n+    fn resolve(\n+        &self,\n+        path_str: &str,\n+        ns: Namespace,\n+        current_item: &Option<String>,\n+        parent_id: Option<hir::HirId>,\n+        extra_fragment: &Option<String>,\n+    ) -> Result<(Res, Option<String>), ErrorKind> {\n         let cx = self.cx;\n \n         // In case we're in a module, try to resolve the relative path.\n@@ -70,8 +75,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n             });\n             let result = match result {\n-                Ok((_, Res::Err)) => Err(()),\n-                _ => result,\n+                Ok((_, Res::Err)) => Err(ErrorKind::ResolutionFailure),\n+                _ => result.map_err(|_| ErrorKind::ResolutionFailure),\n             };\n \n             if let Ok((_, res)) = result {\n@@ -81,30 +86,36 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 let value = match res {\n                     Res::Def(DefKind::Method, _) | Res::Def(DefKind::AssocConst, _) => true,\n                     Res::Def(DefKind::AssocTy, _) => false,\n-                    Res::Def(DefKind::Variant, _) => return handle_variant(cx, res, extra_fragment),\n+                    Res::Def(DefKind::Variant, _) => {\n+                        return handle_variant(cx, res, extra_fragment);\n+                    }\n                     // Not a trait item; just return what we found.\n-                    Res::PrimTy(..) if extra_fragment.is_some() => {\n-                        // TODO: warn in here! (and don't return Ok)\n-                        return Ok((res, Some(path_str.to_owned())))\n+                    Res::PrimTy(..) => {\n+                        if extra_fragment.is_some() {\n+                            return Err(\n+                                ErrorKind::AnchorFailure(\n+                                    \"primitive types cannot be followed by anchors\"));\n+                        }\n+                        return Ok((res, Some(path_str.to_owned())));\n                     }\n-                    Res::PrimTy(..) => return Ok((res, Some(path_str.to_owned()))),\n                     _ => return Ok((res, extra_fragment.clone()))\n                 };\n \n                 if value != (ns == ValueNS) {\n-                    return Err(())\n+                    return Err(ErrorKind::ResolutionFailure)\n                 }\n             } else if let Some(prim) = is_primitive(path_str, ns) {\n-                //if extra_fragment.is_some() {\n-                    // TODO: warn in here! (and don't return Ok)\n-                //}\n+                if extra_fragment.is_some() {\n+                    return Err(\n+                        ErrorKind::AnchorFailure(\"primitive types cannot be followed by anchors\"));\n+                }\n                 return Ok((prim, Some(path_str.to_owned())))\n             } else {\n                 // If resolution failed, it may still be a method\n                 // because methods are not handled by the resolver\n                 // If so, bail when we're not looking for a value.\n                 if ns != ValueNS {\n-                    return Err(())\n+                    return Err(ErrorKind::ResolutionFailure)\n                 }\n             }\n \n@@ -113,13 +124,13 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             let item_name = if let Some(first) = split.next() {\n                 Symbol::intern(first)\n             } else {\n-                return Err(())\n+                return Err(ErrorKind::ResolutionFailure)\n             };\n \n             let mut path = if let Some(second) = split.next() {\n                 second.to_owned()\n             } else {\n-                return Err(())\n+                return Err(ErrorKind::ResolutionFailure)\n             };\n \n             if path == \"self\" || path == \"Self\" {\n@@ -128,22 +139,22 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 }\n             }\n             if let Some(prim) = is_primitive(&path, TypeNS) {\n-                let did = primitive_impl(cx, &path).ok_or(())?;\n+                let did = primitive_impl(cx, &path).ok_or(ErrorKind::ResolutionFailure)?;\n                 return cx.tcx.associated_items(did)\n                     .find(|item| item.ident.name == item_name)\n                     .and_then(|item| match item.kind {\n                         ty::AssocKind::Method => Some(\"method\"),\n                         _ => None,\n                     })\n                     .map(|out| (prim, Some(format!(\"{}#{}.{}\", path, out, item_name))))\n-                    .ok_or(());\n+                    .ok_or(ErrorKind::ResolutionFailure);\n             }\n \n             let (_, ty_res) = cx.enter_resolver(|resolver| {\n                 resolver.resolve_str_path_error(DUMMY_SP, &path, TypeNS, module_id)\n-            })?;\n+            }).map_err(|_| ErrorKind::ResolutionFailure)?;\n             if let Res::Err = ty_res {\n-                return Err(());\n+                return Err(ErrorKind::ResolutionFailure);\n             }\n             let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n             match ty_res {\n@@ -159,12 +170,18 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         let out = match item.kind {\n                             ty::AssocKind::Method if ns == ValueNS => \"method\",\n                             ty::AssocKind::Const if ns == ValueNS => \"associatedconstant\",\n-                            _ => return Err(())\n+                            _ => return Err(ErrorKind::ResolutionFailure)\n                         };\n-                        //if extra_fragment.is_some() {\n-                            // TODO: warn in here! (and don't return Ok)\n-                        //}\n-                        Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n+                        if extra_fragment.is_some() {\n+                            Err(ErrorKind::AnchorFailure(\n+                                if item.kind == ty::AssocKind::Method {\n+                                    \"methods cannot be followed by anchors\"\n+                                } else {\n+                                    \"associated constants cannot be followed by anchors\"\n+                                }))\n+                        } else {\n+                            Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n+                        }\n                     } else {\n                         match cx.tcx.type_of(did).kind {\n                             ty::Adt(def, _) => {\n@@ -176,22 +193,28 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                        .iter()\n                                        .find(|item| item.ident.name == item_name)\n                                 } {\n-                                    //if extra_fragment.is_some() {\n-                                        // TODO: warn in here! (and don't return Ok)\n-                                    //}\n-                                    Ok((ty_res,\n-                                        Some(format!(\"{}.{}\",\n-                                                     if def.is_enum() {\n-                                                         \"variant\"\n-                                                     } else {\n-                                                         \"structfield\"\n-                                                     },\n-                                                     item.ident))))\n+                                    if extra_fragment.is_some() {\n+                                        Err(ErrorKind::AnchorFailure(\n+                                            if def.is_enum() {\n+                                                \"enum variants cannot be followed by anchors\"\n+                                            } else {\n+                                                \"struct fields cannot be followed by anchors\"\n+                                            }))\n+                                    } else {\n+                                        Ok((ty_res,\n+                                            Some(format!(\"{}.{}\",\n+                                                         if def.is_enum() {\n+                                                             \"variant\"\n+                                                         } else {\n+                                                             \"structfield\"\n+                                                         },\n+                                                         item.ident))))\n+                                    }\n                                 } else {\n-                                    Err(())\n+                                    Err(ErrorKind::ResolutionFailure)\n                                 }\n                             }\n-                            _ => Err(()),\n+                            _ => Err(ErrorKind::ResolutionFailure),\n                         }\n                     }\n                 }\n@@ -210,22 +233,30 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                     \"tymethod\"\n                                 }\n                             }\n-                            _ => return Err(())\n+                            _ => return Err(ErrorKind::ResolutionFailure)\n                         };\n \n-                        //if extra_fragment.is_some() {\n-                            // TODO: warn in here! (and don't return Ok)\n-                        //}\n-                        Ok((ty_res, Some(format!(\"{}.{}\", kind, item_name))))\n+                        if extra_fragment.is_some() {\n+                            Err(ErrorKind::AnchorFailure(\n+                                if item.kind == ty::AssocKind::Const {\n+                                    \"associated constants cannot be followed by anchors\"\n+                                } else if item.kind == ty::AssocKind::Type {\n+                                    \"associated types cannot be followed by anchors\"\n+                                } else {\n+                                    \"methods cannot be followed by anchors\"\n+                                }))\n+                        } else {\n+                            Ok((ty_res, Some(format!(\"{}.{}\", kind, item_name))))\n+                        }\n                     } else {\n-                        Err(())\n+                        Err(ErrorKind::ResolutionFailure)\n                     }\n                 }\n-                _ => Err(())\n+                _ => Err(ErrorKind::ResolutionFailure)\n             }\n         } else {\n             debug!(\"attempting to resolve item without parent module: {}\", path_str);\n-            Err(())\n+            Err(ErrorKind::ResolutionFailure)\n         }\n     }\n }\n@@ -308,15 +339,10 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             let link = ori_link.replace(\"`\", \"\");\n             let parts = link.split('#').collect::<Vec<_>>();\n             let (link, extra_fragment) = if parts.len() > 2 {\n-                let mut diag = cx.tcx.struct_span_lint_hir(\n-                    lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n-                    item_hir_id.unwrap(),\n-                    span_of_attrs(&item.attrs).unwrap_or(item.source.span()),\n-                    &format!(\"`[{}]` cannot be resolved, ignoring it...\", ori_link),\n-                );\n-                // TODO: use the correct span!\n-                diag.span_label(DUMMY_SP, \"only one `#` is allowed in a link\");\n-                diag.emit();\n+                build_diagnostic(cx, &item, &link, &dox, link_range,\n+                                 \"has an anchor issue...\",\n+                                 \"only one `#` is allowed in a link\",\n+                                 None);\n                 continue;\n             } else if parts.len() == 2 {\n                 if parts[0].trim().is_empty() {\n@@ -379,53 +405,73 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n                 match kind {\n                     Some(ns @ ValueNS) => {\n-                        if let Ok(res) = self.resolve(path_str, ns, &current_item, base_node,\n-                                                      &extra_fragment) {\n-                            res\n-                        } else {\n-                            resolution_failure(cx, &item, path_str, &dox, link_range);\n-                            // This could just be a normal link or a broken link\n-                            // we could potentially check if something is\n-                            // \"intra-doc-link-like\" and warn in that case.\n-                            continue;\n+                        match self.resolve(path_str, ns, &current_item, base_node,\n+                                           &extra_fragment) {\n+                            Ok(res) => res,\n+                            Err(ErrorKind::ResolutionFailure) => {\n+                                resolution_failure(cx, &item, path_str, &dox, link_range);\n+                                // This could just be a normal link or a broken link\n+                                // we could potentially check if something is\n+                                // \"intra-doc-link-like\" and warn in that case.\n+                                continue;\n+                            }\n+                            Err(ErrorKind::AnchorFailure(msg)) => {\n+                                anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n+                                continue\n+                            }\n                         }\n                     }\n                     Some(ns @ TypeNS) => {\n-                        if let Ok(res) = self.resolve(path_str, ns, &current_item, base_node,\n-                                                      &extra_fragment) {\n-                            res\n-                        } else {\n-                            resolution_failure(cx, &item, path_str, &dox, link_range);\n-                            // This could just be a normal link.\n-                            continue;\n+                        match self.resolve(path_str, ns, &current_item, base_node,\n+                                           &extra_fragment) {\n+                            Ok(res) => res,\n+                            Err(ErrorKind::ResolutionFailure) => {\n+                                resolution_failure(cx, &item, path_str, &dox, link_range);\n+                                // This could just be a normal link.\n+                                continue;\n+                            }\n+                            Err(ErrorKind::AnchorFailure(msg)) => {\n+                                anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n+                                continue\n+                            }\n                         }\n                     }\n                     None => {\n                         // Try everything!\n                         let candidates = PerNS {\n                             macro_ns: macro_resolve(cx, path_str)\n                                         .map(|res| (res, extra_fragment.clone())),\n-                            type_ns: self\n-                                .resolve(path_str, TypeNS, &current_item, base_node, &extra_fragment)\n-                                .ok(),\n-                            value_ns: self\n-                                .resolve(path_str, ValueNS, &current_item, base_node, &extra_fragment)\n-                                .ok()\n-                                .and_then(|(res, fragment)| {\n-                                    // Constructors are picked up in the type namespace.\n-                                    match res {\n-                                        Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) => None,\n-                                        _ => match (fragment, extra_fragment) {\n-                                            (Some(fragment), Some(_)) => {\n-                                                // Shouldn't happen but who knows?\n-                                                Some((res, Some(fragment)))\n-                                            }\n-                                            (fragment, None) | (None, fragment) => {\n-                                                Some((res, fragment))\n-                                            }\n-                                        },\n-                                    }\n-                                }),\n+                            type_ns: match self.resolve(path_str, TypeNS, &current_item, base_node,\n+                                                        &extra_fragment) {\n+                                Err(ErrorKind::AnchorFailure(msg)) => {\n+                                    anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n+                                    continue;\n+                                }\n+                                x => x.ok(),\n+                            },\n+                            value_ns: match self.resolve(path_str, ValueNS, &current_item,\n+                                                         base_node, &extra_fragment) {\n+                                Err(ErrorKind::AnchorFailure(msg)) => {\n+                                    anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n+                                    continue;\n+                                }\n+                                x => x.ok(),\n+                            }\n+                            .and_then(|(res, fragment)| {\n+                                // Constructors are picked up in the type namespace.\n+                                match res {\n+                                    Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) => None,\n+                                    _ => match (fragment, extra_fragment) {\n+                                        (Some(fragment), Some(_)) => {\n+                                            // Shouldn't happen but who knows?\n+                                            Some((res, Some(fragment)))\n+                                        }\n+                                        (fragment, None) | (None, fragment) => {\n+                                            Some((res, fragment))\n+                                        }\n+                                    },\n+                                }\n+                            }),\n                         };\n \n                         if candidates.is_empty() {\n@@ -511,17 +557,15 @@ fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n     })\n }\n \n-/// Reports a resolution failure diagnostic.\n-///\n-/// If we cannot find the exact source span of the resolution failure, we use the span of the\n-/// documentation attributes themselves. This is a little heavy-handed, so we display the markdown\n-/// line containing the failure as a note as well.\n-fn resolution_failure(\n+fn build_diagnostic(\n     cx: &DocContext<'_>,\n     item: &Item,\n     path_str: &str,\n     dox: &str,\n     link_range: Option<Range<usize>>,\n+    err_msg: &str,\n+    short_err_msg: &str,\n+    help_msg: Option<&str>,\n ) {\n     let hir_id = match cx.as_local_hir_id(item.def_id) {\n         Some(hir_id) => hir_id,\n@@ -537,12 +581,12 @@ fn resolution_failure(\n         lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n         hir_id,\n         sp,\n-        &format!(\"`[{}]` cannot be resolved, ignoring it...\", path_str),\n+        &format!(\"`[{}]` {}\", path_str, err_msg),\n     );\n     if let Some(link_range) = link_range {\n         if let Some(sp) = super::source_span_for_markdown_range(cx, dox, &link_range, attrs) {\n             diag.set_span(sp);\n-            diag.span_label(sp, \"cannot be resolved, ignoring\");\n+            diag.span_label(sp, short_err_msg);\n         } else {\n             // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n             //                       ^     ~~~~\n@@ -562,11 +606,44 @@ fn resolution_failure(\n             ));\n         }\n     };\n-    diag.help(\"to escape `[` and `]` characters, just add '\\\\' before them like \\\n-               `\\\\[` or `\\\\]`\");\n+    if let Some(help_msg) = help_msg {\n+        diag.help(help_msg);\n+    }\n     diag.emit();\n }\n \n+/// Reports a resolution failure diagnostic.\n+///\n+/// If we cannot find the exact source span of the resolution failure, we use the span of the\n+/// documentation attributes themselves. This is a little heavy-handed, so we display the markdown\n+/// line containing the failure as a note as well.\n+fn resolution_failure(\n+    cx: &DocContext<'_>,\n+    item: &Item,\n+    path_str: &str,\n+    dox: &str,\n+    link_range: Option<Range<usize>>,\n+) {\n+    build_diagnostic(cx, item, path_str, dox, link_range,\n+         \"cannot be resolved, ignoring it...\",\n+         \"cannot be resolved, ignoring\",\n+         Some(\"to escape `[` and `]` characters, just add '\\\\' before them like `\\\\[` or `\\\\]`\"));\n+}\n+\n+fn anchor_failure(\n+    cx: &DocContext<'_>,\n+    item: &Item,\n+    path_str: &str,\n+    dox: &str,\n+    link_range: Option<Range<usize>>,\n+    msg: &str,\n+) {\n+    build_diagnostic(cx, item, path_str, dox, link_range,\n+         \"has an anchor issue...\",\n+         msg,\n+         None);\n+}\n+\n fn ambiguity_error(\n     cx: &DocContext<'_>,\n     item: &Item,\n@@ -690,19 +767,19 @@ fn handle_variant(\n     cx: &DocContext<'_>,\n     res: Res,\n     extra_fragment: &Option<String>,\n-) -> Result<(Res, Option<String>), ()> {\n+) -> Result<(Res, Option<String>), ErrorKind> {\n     use rustc::ty::DefIdTree;\n \n+    if extra_fragment.is_some() {\n+        return Err(ErrorKind::AnchorFailure(\"variants cannot be followed by anchors\"));\n+    }\n     let parent = if let Some(parent) = cx.tcx.parent(res.def_id()) {\n         parent\n     } else {\n-        return Err(())\n+        return Err(ErrorKind::ResolutionFailure)\n     };\n     let parent_def = Res::Def(DefKind::Enum, parent);\n     let variant = cx.tcx.expect_variant_res(res);\n-    if extra_fragment.is_some() {\n-        // TODO warn in here! (and don't return ok)\n-    }\n     Ok((parent_def, Some(format!(\"{}.v\", variant.ident.name))))\n }\n "}]}