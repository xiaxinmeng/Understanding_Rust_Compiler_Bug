{"sha": "8ee1dec77b89d6341a147d91af8733f8e0b5efc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlZTFkZWM3N2I4OWQ2MzQxYTE0N2Q5MWFmODczM2Y4ZTBiNWVmYzc=", "commit": {"author": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2020-06-21T22:54:46Z"}, "committer": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2020-06-30T14:42:57Z"}, "message": "Deny unsafe ops in unsafe fns, part 1", "tree": {"sha": "ebb689b9d02af4dc8d9032f024ea4d9323061f4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebb689b9d02af4dc8d9032f024ea4d9323061f4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ee1dec77b89d6341a147d91af8733f8e0b5efc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ee1dec77b89d6341a147d91af8733f8e0b5efc7", "html_url": "https://github.com/rust-lang/rust/commit/8ee1dec77b89d6341a147d91af8733f8e0b5efc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "665190b34609c5204a3bd57c571c1dff4d8bc5f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/665190b34609c5204a3bd57c571c1dff4d8bc5f2", "html_url": "https://github.com/rust-lang/rust/commit/665190b34609c5204a3bd57c571c1dff4d8bc5f2"}], "stats": {"total": 142, "additions": 111, "deletions": 31}, "files": [{"sha": "c198797e650f6f05e263fc850f0fd2820c44533c", "filename": "src/libcore/alloc/global.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/src%2Flibcore%2Falloc%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/src%2Flibcore%2Falloc%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fglobal.rs?ref=8ee1dec77b89d6341a147d91af8733f8e0b5efc7", "patch": "@@ -127,9 +127,12 @@ pub unsafe trait GlobalAlloc {\n     #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n     unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n         let size = layout.size();\n-        let ptr = self.alloc(layout);\n+        // SAFETY: the safety contract for `alloc` must be upheld by the caller.\n+        let ptr = unsafe { self.alloc(layout) };\n         if !ptr.is_null() {\n-            ptr::write_bytes(ptr, 0, size);\n+            // SAFETY: as allocation succeeded, the region from `ptr`\n+            // of size `size` is guaranteed to be valid for writes.\n+            unsafe { ptr::write_bytes(ptr, 0, size) };\n         }\n         ptr\n     }\n@@ -187,11 +190,18 @@ pub unsafe trait GlobalAlloc {\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n     unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n-        let new_ptr = self.alloc(new_layout);\n+        // SAFETY: the caller must ensure that the `new_size` does not overflow.\n+        // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid.\n+        let new_layout = unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n+        // SAFETY: the caller must ensure that `new_layout` is greater than zero.\n+        let new_ptr = unsafe { self.alloc(new_layout) };\n         if !new_ptr.is_null() {\n-            ptr::copy_nonoverlapping(ptr, new_ptr, cmp::min(layout.size(), new_size));\n-            self.dealloc(ptr, layout);\n+            // SAFETY: the previously allocated block cannot overlap the newly allocated block.\n+            // The safety contract for `dealloc` must be upheld by the caller.\n+            unsafe {\n+                ptr::copy_nonoverlapping(ptr, new_ptr, cmp::min(layout.size(), new_size));\n+                self.dealloc(ptr, layout);\n+            }\n         }\n         new_ptr\n     }"}, {"sha": "ae7ae7044655bae38bfd4e7dae87938e31e3b726", "filename": "src/libcore/alloc/layout.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/src%2Flibcore%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/src%2Flibcore%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Flayout.rs?ref=8ee1dec77b89d6341a147d91af8733f8e0b5efc7", "patch": "@@ -90,7 +90,8 @@ impl Layout {\n     #[rustc_const_stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n     #[inline]\n     pub const unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {\n-        Layout { size_: size, align_: NonZeroUsize::new_unchecked(align) }\n+        // SAFETY: the caller must ensure that `align` is greater than zero.\n+        Layout { size_: size, align_: unsafe { NonZeroUsize::new_unchecked(align) } }\n     }\n \n     /// The minimum size in bytes for a memory block of this layout."}, {"sha": "d00dbd2c34d5699c21f371a58e1b43ffaf62ca91", "filename": "src/libcore/alloc/mod.rs", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/src%2Flibcore%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/src%2Flibcore%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fmod.rs?ref=8ee1dec77b89d6341a147d91af8733f8e0b5efc7", "patch": "@@ -1,6 +1,7 @@\n //! Memory allocation APIs\n \n #![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n mod global;\n mod layout;\n@@ -54,7 +55,9 @@ impl AllocInit {\n     #[inline]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     pub unsafe fn init(self, memory: MemoryBlock) {\n-        self.init_offset(memory, 0)\n+        // SAFETY: the safety contract for `init_offset` must be\n+        // upheld by the caller.\n+        unsafe { self.init_offset(memory, 0) }\n     }\n \n     /// Initialize the memory block like specified by `init` at the specified `offset`.\n@@ -78,7 +81,10 @@ impl AllocInit {\n         match self {\n             AllocInit::Uninitialized => (),\n             AllocInit::Zeroed => {\n-                memory.ptr.as_ptr().add(offset).write_bytes(0, memory.size - offset)\n+                // SAFETY: the caller must guarantee that `offset` is smaller than or equal to `memory.size`,\n+                // so the memory from `memory.ptr + offset` of length `memory.size - offset`\n+                // is guaranteed to be contaned in `memory` and thus valid for writes.\n+                unsafe { memory.ptr.as_ptr().add(offset).write_bytes(0, memory.size - offset) }\n             }\n         }\n     }\n@@ -281,11 +287,23 @@ pub unsafe trait AllocRef {\n                     return Ok(MemoryBlock { ptr, size });\n                 }\n \n-                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+                let new_layout =\n+                    // SAFETY: the caller must ensure that the `new_size` does not overflow.\n+                    // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n+                    // The caller must ensure that `new_size` is greater than zero.\n+                    unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n                 let new_memory = self.alloc(new_layout, init)?;\n-                ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), size);\n-                self.dealloc(ptr, layout);\n-                Ok(new_memory)\n+\n+                // SAFETY: because `new_size` must be greater than or equal to `size`, both the old and new\n+                // memory allocation are valid for reads and writes for `size` bytes. Also, because the old\n+                // allocation wasn't yet deallocated, it cannot overlap `new_memory`. Thus, the call to\n+                // `copy_nonoverlapping` is safe.\n+                // The safety contract for `dealloc` must be upheld by the caller.\n+                unsafe {\n+                    ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), size);\n+                    self.dealloc(ptr, layout);\n+                    Ok(new_memory)\n+                }\n             }\n         }\n     }\n@@ -356,11 +374,23 @@ pub unsafe trait AllocRef {\n                     return Ok(MemoryBlock { ptr, size });\n                 }\n \n-                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+                let new_layout =\n+                // SAFETY: the caller must ensure that the `new_size` does not overflow.\n+                // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n+                // The caller must ensure that `new_size` is greater than zero.\n+                    unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n                 let new_memory = self.alloc(new_layout, AllocInit::Uninitialized)?;\n-                ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), new_size);\n-                self.dealloc(ptr, layout);\n-                Ok(new_memory)\n+\n+                // SAFETY: because `new_size` must be lower than or equal to `size`, both the old and new\n+                // memory allocation are valid for reads and writes for `new_size` bytes. Also, because the\n+                // old allocation wasn't yet deallocated, it cannot overlap `new_memory`. Thus, the call to\n+                // `copy_nonoverlapping` is safe.\n+                // The safety contract for `dealloc` must be upheld by the caller.\n+                unsafe {\n+                    ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), new_size);\n+                    self.dealloc(ptr, layout);\n+                    Ok(new_memory)\n+                }\n             }\n         }\n     }\n@@ -386,7 +416,8 @@ where\n \n     #[inline]\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n-        (**self).dealloc(ptr, layout)\n+        // SAFETY: the safety contract must be upheld by the caller\n+        unsafe { (**self).dealloc(ptr, layout) }\n     }\n \n     #[inline]\n@@ -398,7 +429,8 @@ where\n         placement: ReallocPlacement,\n         init: AllocInit,\n     ) -> Result<MemoryBlock, AllocErr> {\n-        (**self).grow(ptr, layout, new_size, placement, init)\n+        // SAFETY: the safety contract must be upheld by the caller\n+        unsafe { (**self).grow(ptr, layout, new_size, placement, init) }\n     }\n \n     #[inline]\n@@ -409,6 +441,7 @@ where\n         new_size: usize,\n         placement: ReallocPlacement,\n     ) -> Result<MemoryBlock, AllocErr> {\n-        (**self).shrink(ptr, layout, new_size, placement)\n+        // SAFETY: the safety contract must be upheld by the caller\n+        unsafe { (**self).shrink(ptr, layout, new_size, placement) }\n     }\n }"}, {"sha": "caaf940b62cb2984b2e0a8f9986d827a0649061f", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=8ee1dec77b89d6341a147d91af8733f8e0b5efc7", "patch": "@@ -187,6 +187,7 @@\n //!\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n use crate::cmp::Ordering;\n use crate::fmt::{self, Debug, Display};\n@@ -1005,7 +1006,12 @@ impl<T: ?Sized> RefCell<T> {\n     #[inline]\n     pub unsafe fn try_borrow_unguarded(&self) -> Result<&T, BorrowError> {\n         if !is_writing(self.borrow.get()) {\n-            Ok(&*self.value.get())\n+            // SAFETY: We check that nobody is actively writing now, but it is\n+            // the caller's responsibility to ensure that nobody writes until\n+            // the returned reference is no longer in use.\n+            // Also, `self.value.get()` refers to the value owned by `self`\n+            // and is thus guaranteed to be valid for the lifetime of `self`.\n+            Ok(unsafe { &*self.value.get() })\n         } else {\n             Err(BorrowError { _private: () })\n         }"}, {"sha": "001362ba1c375eb4c8c769669b9f5fe4fd4554a7", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=8ee1dec77b89d6341a147d91af8733f8e0b5efc7", "patch": "@@ -1,5 +1,7 @@\n //! Character conversions.\n \n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n use crate::convert::TryFrom;\n use crate::fmt;\n use crate::mem::transmute;\n@@ -99,7 +101,8 @@ pub fn from_u32(i: u32) -> Option<char> {\n #[inline]\n #[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\n pub unsafe fn from_u32_unchecked(i: u32) -> char {\n-    if cfg!(debug_assertions) { char::from_u32(i).unwrap() } else { transmute(i) }\n+    // SAFETY: the caller must guarantee that `i` is a valid char value.\n+    if cfg!(debug_assertions) { char::from_u32(i).unwrap() } else { unsafe { transmute(i) } }\n }\n \n #[stable(feature = \"char_convert\", since = \"1.13.0\")]"}, {"sha": "5a62c92694fadbd34e102346e4074df4d59f648f", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=8ee1dec77b89d6341a147d91af8733f8e0b5efc7", "patch": "@@ -1,5 +1,7 @@\n //! impl char {}\n \n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n use crate::slice;\n use crate::str::from_utf8_unchecked_mut;\n use crate::unicode::printable::is_printable;\n@@ -183,7 +185,8 @@ impl char {\n     #[unstable(feature = \"assoc_char_funcs\", reason = \"recently added\", issue = \"71763\")]\n     #[inline]\n     pub unsafe fn from_u32_unchecked(i: u32) -> char {\n-        super::convert::from_u32_unchecked(i)\n+        // SAFETY: the safety contract must be upheld by the caller.\n+        unsafe { super::convert::from_u32_unchecked(i) }\n     }\n \n     /// Converts a digit in the given radix to a `char`."}, {"sha": "094618acc58859cd38ccf3a7be23e8553b98d9ae", "filename": "src/libcore/convert/num.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/src%2Flibcore%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/src%2Flibcore%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fnum.rs?ref=8ee1dec77b89d6341a147d91af8733f8e0b5efc7", "patch": "@@ -1,3 +1,5 @@\n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n use super::{From, TryFrom};\n use crate::num::TryFromIntError;\n \n@@ -28,7 +30,8 @@ macro_rules! impl_float_to_int {\n                 #[doc(hidden)]\n                 #[inline]\n                 unsafe fn to_int_unchecked(self) -> $Int {\n-                    crate::intrinsics::float_to_int_unchecked(self)\n+                    // SAFETY: the safety contract must be upheld by the caller.\n+                    unsafe { crate::intrinsics::float_to_int_unchecked(self) }\n                 }\n             }\n         )+"}, {"sha": "fd2d443dde8d869d024833db33aed94ced3d9d88", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=8ee1dec77b89d6341a147d91af8733f8e0b5efc7", "patch": "@@ -2,6 +2,8 @@\n \n //! Hints to compiler that affects how code should be emitted or optimized.\n \n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n use crate::intrinsics;\n \n /// Informs the compiler that this point in the code is not reachable, enabling\n@@ -46,7 +48,9 @@ use crate::intrinsics;\n #[inline]\n #[stable(feature = \"unreachable\", since = \"1.27.0\")]\n pub unsafe fn unreachable_unchecked() -> ! {\n-    intrinsics::unreachable()\n+    // SAFETY: the safety contract for `intrinsics::unreachable` must\n+    // be upheld by the caller.\n+    unsafe { intrinsics::unreachable() }\n }\n \n /// Emits a machine instruction hinting to the processor that it is running in busy-wait"}, {"sha": "237c6e0545f8fa669651123ad0ade4406d7ad732", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=8ee1dec77b89d6341a147d91af8733f8e0b5efc7", "patch": "@@ -53,6 +53,7 @@\n     issue = \"none\"\n )]\n #![allow(missing_docs)]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n use crate::marker::DiscriminantKind;\n use crate::mem;\n@@ -2097,7 +2098,10 @@ pub unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n         // Not panicking to keep codegen impact smaller.\n         abort();\n     }\n-    copy_nonoverlapping(src, dst, count)\n+\n+    // SAFETY: the safety contract for `copy_nonoverlapping` must be\n+    // upheld by the caller.\n+    unsafe { copy_nonoverlapping(src, dst, count) }\n }\n \n /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n@@ -2163,7 +2167,9 @@ pub unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n         // Not panicking to keep codegen impact smaller.\n         abort();\n     }\n-    copy(src, dst, count)\n+\n+    // SAFETY: the safety contract for `copy` must be upheld by the caller.\n+    unsafe { copy(src, dst, count) }\n }\n \n /// Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n@@ -2246,5 +2252,7 @@ pub unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n     }\n \n     debug_assert!(is_aligned_and_not_null(dst), \"attempt to write to unaligned or null pointer\");\n-    write_bytes(dst, val, count)\n+\n+    // SAFETY: the safety contract for `write_bytes` must be upheld by the caller.\n+    unsafe { write_bytes(dst, val, count) }\n }"}, {"sha": "1459a6b2f16f748656417b65278f6054b43a478d", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=8ee1dec77b89d6341a147d91af8733f8e0b5efc7", "patch": "@@ -148,6 +148,7 @@\n #![feature(const_type_id)]\n #![feature(const_caller_location)]\n #![feature(no_niche)] // rust-lang/rust#68303\n+#![feature(unsafe_block_in_unsafe_fn)]\n \n #[prelude_import]\n #[allow(unused)]"}, {"sha": "b042bed681e38e5f33ccd7b0775c3a07fa2f64b6", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee1dec77b89d6341a147d91af8733f8e0b5efc7/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=8ee1dec77b89d6341a147d91af8733f8e0b5efc7", "patch": "@@ -375,6 +375,7 @@\n //! [`i32`]: ../../std/primitive.i32.html\n \n #![stable(feature = \"pin\", since = \"1.33.0\")]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n use crate::cmp::{self, PartialEq, PartialOrd};\n use crate::fmt;\n@@ -679,7 +680,10 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n     {\n         let pointer = &*self.pointer;\n         let new_pointer = func(pointer);\n-        Pin::new_unchecked(new_pointer)\n+\n+        // SAFETY: the safety contract for `new_unchecked` must be\n+        // upheld by the caller.\n+        unsafe { Pin::new_unchecked(new_pointer) }\n     }\n \n     /// Gets a shared reference out of a pin.\n@@ -769,9 +773,13 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n         U: ?Sized,\n         F: FnOnce(&mut T) -> &mut U,\n     {\n-        let pointer = Pin::get_unchecked_mut(self);\n+        // SAFETY: the caller is responsible for not moving the\n+        // value out of this reference.\n+        let pointer = unsafe { Pin::get_unchecked_mut(self) };\n         let new_pointer = func(pointer);\n-        Pin::new_unchecked(new_pointer)\n+        // SAFETY: as the value of `this` is guaranteed to not have\n+        // been moved out, this call to `new_unchecked` is safe.\n+        unsafe { Pin::new_unchecked(new_pointer) }\n     }\n }\n "}]}