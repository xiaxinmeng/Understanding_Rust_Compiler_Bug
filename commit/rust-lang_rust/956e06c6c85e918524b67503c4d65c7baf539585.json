{"sha": "956e06c6c85e918524b67503c4d65c7baf539585", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1NmUwNmM2Yzg1ZTkxODUyNGI2NzUwM2M0ZDY1YzdiYWY1Mzk1ODU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-21T10:26:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-21T10:26:59Z"}, "message": "Auto merge of #77004 - RalfJung:rollup-usac4nv, r=RalfJung\n\nRollup of 13 pull requests\n\nSuccessful merges:\n\n - #76135 (Stabilize some Option methods as const)\n - #76628 (Add sample defaults for config.toml )\n - #76846 (Avoiding unnecesary allocations at rustc_errors)\n - #76867 (Use intra-doc links in core/src/iter when possible)\n - #76868 (Finish moving to intra doc links for std::sync)\n - #76872 (Remove DeclareMethods)\n - #76936 (Add non-`unsafe` `.get_mut()` for `Unsafecell`)\n - #76958 (Replace manual as_nanos and as_secs_f64 reimplementations)\n - #76959 (Replace write_fmt with write!)\n - #76961 (Add test for issue #34634)\n - #76962 (Use const_cstr macro in consts.rs)\n - #76963 (Remove unused static_assert macro)\n - #77000 (update Miri)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "0edc34da941991acaf64cafca07d0348178c8414", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0edc34da941991acaf64cafca07d0348178c8414"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/956e06c6c85e918524b67503c4d65c7baf539585", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/956e06c6c85e918524b67503c4d65c7baf539585", "html_url": "https://github.com/rust-lang/rust/commit/956e06c6c85e918524b67503c4d65c7baf539585", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/956e06c6c85e918524b67503c4d65c7baf539585/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0433fdf93b0346e136c03ed49c0e90346035f191", "url": "https://api.github.com/repos/rust-lang/rust/commits/0433fdf93b0346e136c03ed49c0e90346035f191", "html_url": "https://github.com/rust-lang/rust/commit/0433fdf93b0346e136c03ed49c0e90346035f191"}, {"sha": "d337074d0992533c02e077c562fc3ea279bd165c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d337074d0992533c02e077c562fc3ea279bd165c", "html_url": "https://github.com/rust-lang/rust/commit/d337074d0992533c02e077c562fc3ea279bd165c"}], "stats": {"total": 1096, "additions": 592, "deletions": 504}, "files": [{"sha": "136ccf8ec4acac9f7849ef9af311f762fc3784ae", "filename": "Cargo.lock", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -207,6 +207,7 @@ dependencies = [\n  \"ignore\",\n  \"lazy_static\",\n  \"libc\",\n+ \"merge\",\n  \"num_cpus\",\n  \"opener\",\n  \"pretty_assertions\",\n@@ -1909,6 +1910,28 @@ dependencies = [\n  \"autocfg\",\n ]\n \n+[[package]]\n+name = \"merge\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"10bbef93abb1da61525bbc45eeaff6473a41907d19f8f9aa5168d214e10693e9\"\n+dependencies = [\n+ \"merge_derive\",\n+ \"num-traits\",\n+]\n+\n+[[package]]\n+name = \"merge_derive\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"209d075476da2e63b4b29e72a2ef627b840589588e71400a25e3565c4f849d07\"\n+dependencies = [\n+ \"proc-macro-error\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"minifier\"\n version = \"0.0.33\""}, {"sha": "f35708b1d0965c4bc734a8f417ae9faf1d202102", "filename": "compiler/rustc_codegen_llvm/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -108,7 +108,7 @@ pub fn compile_codegen_unit(\n \n     // We assume that the cost to run LLVM on a CGU is proportional to\n     // the time we needed for codegenning it.\n-    let cost = time_to_codegen.as_secs() * 1_000_000_000 + time_to_codegen.subsec_nanos() as u64;\n+    let cost = time_to_codegen.as_nanos() as u64;\n \n     fn module_codegen(tcx: TyCtxt<'_>, cgu_name: Symbol) -> ModuleCodegen<ModuleLlvm> {\n         let cgu = tcx.codegen_unit(cgu_name);"}, {"sha": "6d3582d30276e87880f99aecd26339c8ac29430e", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -7,6 +7,7 @@ use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n use libc::c_uint;\n use rustc_codegen_ssa::traits::*;\n+use rustc_data_structures::const_cstr;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::Node;\n@@ -22,8 +23,6 @@ use rustc_span::Span;\n use rustc_target::abi::{AddressSpace, Align, HasDataLayout, LayoutOf, Primitive, Scalar, Size};\n use tracing::debug;\n \n-use std::ffi::CStr;\n-\n pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n     let mut llvals = Vec::with_capacity(alloc.relocations().len() + 1);\n     let dl = cx.data_layout();\n@@ -454,9 +453,9 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                             .all(|&byte| byte == 0);\n \n                     let sect_name = if all_bytes_are_zero {\n-                        CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_bss\\0\")\n+                        const_cstr!(\"__DATA,__thread_bss\")\n                     } else {\n-                        CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_data\\0\")\n+                        const_cstr!(\"__DATA,__thread_data\")\n                     };\n                     llvm::LLVMSetSection(g, sect_name.as_ptr());\n                 }"}, {"sha": "1696f35563d91a21448426ad6389b18481426db2", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -433,6 +433,17 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             llvm::LLVMSetSection(g, section.as_ptr());\n         }\n     }\n+\n+    fn declare_c_main(&self, fn_type: Self::Type) -> Option<Self::Function> {\n+        if self.get_declared_value(\"main\").is_none() {\n+            Some(self.declare_cfn(\"main\", fn_type))\n+        } else {\n+            // If the symbol already exists, it is an error: for example, the user wrote\n+            // #[no_mangle] extern \"C\" fn main(..) {..}\n+            // instead of #[start]\n+            None\n+        }\n+    }\n }\n \n impl CodegenCx<'b, 'tcx> {"}, {"sha": "a3d6882940a09b6e7f33822d32fe57e82bd180f3", "filename": "compiler/rustc_codegen_llvm/src/declare.rs", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -51,42 +51,69 @@ fn declare_raw_fn(\n     llfn\n }\n \n-impl DeclareMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n-    fn declare_global(&self, name: &str, ty: &'ll Type) -> &'ll Value {\n+impl CodegenCx<'ll, 'tcx> {\n+    /// Declare a global value.\n+    ///\n+    /// If there\u2019s a value with the same name already declared, the function will\n+    /// return its Value instead.\n+    pub fn declare_global(&self, name: &str, ty: &'ll Type) -> &'ll Value {\n         debug!(\"declare_global(name={:?})\", name);\n         unsafe { llvm::LLVMRustGetOrInsertGlobal(self.llmod, name.as_ptr().cast(), name.len(), ty) }\n     }\n \n-    fn declare_cfn(&self, name: &str, fn_type: &'ll Type) -> &'ll Value {\n+    /// Declare a C ABI function.\n+    ///\n+    /// Only use this for foreign function ABIs and glue. For Rust functions use\n+    /// `declare_fn` instead.\n+    ///\n+    /// If there\u2019s a value with the same name already declared, the function will\n+    /// update the declaration and return existing Value instead.\n+    pub fn declare_cfn(&self, name: &str, fn_type: &'ll Type) -> &'ll Value {\n         declare_raw_fn(self, name, llvm::CCallConv, fn_type)\n     }\n \n-    fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> &'ll Value {\n+    /// Declare a Rust function.\n+    ///\n+    /// If there\u2019s a value with the same name already declared, the function will\n+    /// update the declaration and return existing Value instead.\n+    pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> &'ll Value {\n         debug!(\"declare_rust_fn(name={:?}, fn_abi={:?})\", name, fn_abi);\n \n         let llfn = declare_raw_fn(self, name, fn_abi.llvm_cconv(), fn_abi.llvm_type(self));\n         fn_abi.apply_attrs_llfn(self, llfn);\n         llfn\n     }\n \n-    fn define_global(&self, name: &str, ty: &'ll Type) -> Option<&'ll Value> {\n+    /// Declare a global with an intention to define it.\n+    ///\n+    /// Use this function when you intend to define a global. This function will\n+    /// return `None` if the name already has a definition associated with it. In that\n+    /// case an error should be reported to the user, because it usually happens due\n+    /// to user\u2019s fault (e.g., misuse of `#[no_mangle]` or `#[export_name]` attributes).\n+    pub fn define_global(&self, name: &str, ty: &'ll Type) -> Option<&'ll Value> {\n         if self.get_defined_value(name).is_some() {\n             None\n         } else {\n             Some(self.declare_global(name, ty))\n         }\n     }\n \n-    fn define_private_global(&self, ty: &'ll Type) -> &'ll Value {\n+    /// Declare a private global\n+    ///\n+    /// Use this function when you intend to define a global without a name.\n+    pub fn define_private_global(&self, ty: &'ll Type) -> &'ll Value {\n         unsafe { llvm::LLVMRustInsertPrivateGlobal(self.llmod, ty) }\n     }\n \n-    fn get_declared_value(&self, name: &str) -> Option<&'ll Value> {\n+    /// Gets declared value by name.\n+    pub fn get_declared_value(&self, name: &str) -> Option<&'ll Value> {\n         debug!(\"get_declared_value(name={:?})\", name);\n         unsafe { llvm::LLVMRustGetNamedValue(self.llmod, name.as_ptr().cast(), name.len()) }\n     }\n \n-    fn get_defined_value(&self, name: &str) -> Option<&'ll Value> {\n+    /// Gets defined or externally defined (AvailableExternally linkage) value by\n+    /// name.\n+    pub fn get_defined_value(&self, name: &str) -> Option<&'ll Value> {\n         self.get_declared_value(name).and_then(|val| {\n             let declaration = unsafe { llvm::LLVMIsDeclaration(val) != 0 };\n             if !declaration { Some(val) } else { None }"}, {"sha": "d82fc2c9f63d9a1746727b578909776c29d94915", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -407,16 +407,18 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         // listing.\n         let main_ret_ty = cx.tcx().erase_regions(&main_ret_ty.no_bound_vars().unwrap());\n \n-        if cx.get_declared_value(\"main\").is_some() {\n-            // FIXME: We should be smart and show a better diagnostic here.\n-            cx.sess()\n-                .struct_span_err(sp, \"entry symbol `main` declared multiple times\")\n-                .help(\"did you use `#[no_mangle]` on `fn main`? Use `#[start]` instead\")\n-                .emit();\n-            cx.sess().abort_if_errors();\n-            bug!();\n-        }\n-        let llfn = cx.declare_cfn(\"main\", llfty);\n+        let llfn = match cx.declare_c_main(llfty) {\n+            Some(llfn) => llfn,\n+            None => {\n+                // FIXME: We should be smart and show a better diagnostic here.\n+                cx.sess()\n+                    .struct_span_err(sp, \"entry symbol `main` declared multiple times\")\n+                    .help(\"did you use `#[no_mangle]` on `fn main`? Use `#[start]` instead\")\n+                    .emit();\n+                cx.sess().abort_if_errors();\n+                bug!();\n+            }\n+        };\n \n         // `main` should respect same config for frame pointer elimination as rest of code\n         cx.set_frame_pointer_elimination(llfn);"}, {"sha": "655afcd17f0da75784e4bd5b85851e1b538182d9", "filename": "compiler/rustc_codegen_ssa/src/traits/declare.rs", "status": "modified", "additions": 1, "deletions": 45, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdeclare.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -1,51 +1,7 @@\n use super::BackendTypes;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n-use rustc_middle::ty::{Instance, Ty};\n-use rustc_target::abi::call::FnAbi;\n-\n-pub trait DeclareMethods<'tcx>: BackendTypes {\n-    /// Declare a global value.\n-    ///\n-    /// If there\u2019s a value with the same name already declared, the function will\n-    /// return its Value instead.\n-    fn declare_global(&self, name: &str, ty: Self::Type) -> Self::Value;\n-\n-    /// Declare a C ABI function.\n-    ///\n-    /// Only use this for foreign function ABIs and glue. For Rust functions use\n-    /// `declare_fn` instead.\n-    ///\n-    /// If there\u2019s a value with the same name already declared, the function will\n-    /// update the declaration and return existing Value instead.\n-    fn declare_cfn(&self, name: &str, fn_type: Self::Type) -> Self::Function;\n-\n-    /// Declare a Rust function.\n-    ///\n-    /// If there\u2019s a value with the same name already declared, the function will\n-    /// update the declaration and return existing Value instead.\n-    fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> Self::Function;\n-\n-    /// Declare a global with an intention to define it.\n-    ///\n-    /// Use this function when you intend to define a global. This function will\n-    /// return `None` if the name already has a definition associated with it. In that\n-    /// case an error should be reported to the user, because it usually happens due\n-    /// to user\u2019s fault (e.g., misuse of `#[no_mangle]` or `#[export_name]` attributes).\n-    fn define_global(&self, name: &str, ty: Self::Type) -> Option<Self::Value>;\n-\n-    /// Declare a private global\n-    ///\n-    /// Use this function when you intend to define a global without a name.\n-    fn define_private_global(&self, ty: Self::Type) -> Self::Value;\n-\n-    /// Gets declared value by name.\n-    fn get_declared_value(&self, name: &str) -> Option<Self::Value>;\n-\n-    /// Gets defined or externally defined (AvailableExternally linkage) value by\n-    /// name.\n-    fn get_defined_value(&self, name: &str) -> Option<Self::Value>;\n-}\n+use rustc_middle::ty::Instance;\n \n pub trait PreDefineMethods<'tcx>: BackendTypes {\n     fn predefine_static("}, {"sha": "6fff64bfcb6c5a4bdce2848d784b39e81ce866fb", "filename": "compiler/rustc_codegen_ssa/src/traits/misc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmisc.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -19,4 +19,6 @@ pub trait MiscMethods<'tcx>: BackendTypes {\n     fn set_frame_pointer_elimination(&self, llfn: Self::Function);\n     fn apply_target_cpu_attr(&self, llfn: Self::Function);\n     fn create_used_variable(&self);\n+    /// Declares the extern \"C\" main function for the entry point. Returns None if the symbol already exists.\n+    fn declare_c_main(&self, fn_type: Self::Type) -> Option<Self::Function>;\n }"}, {"sha": "698ef6083e674ba201b92f3079fe62cbf795e7aa", "filename": "compiler/rustc_codegen_ssa/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -35,7 +35,7 @@ pub use self::builder::{BuilderMethods, OverflowOp};\n pub use self::consts::ConstMethods;\n pub use self::coverageinfo::{CoverageInfoBuilderMethods, CoverageInfoMethods};\n pub use self::debuginfo::{DebugInfoBuilderMethods, DebugInfoMethods};\n-pub use self::declare::{DeclareMethods, PreDefineMethods};\n+pub use self::declare::PreDefineMethods;\n pub use self::intrinsic::IntrinsicCallMethods;\n pub use self::misc::MiscMethods;\n pub use self::statics::{StaticBuilderMethods, StaticMethods};\n@@ -60,7 +60,6 @@ pub trait CodegenMethods<'tcx>:\n     + StaticMethods\n     + CoverageInfoMethods\n     + DebugInfoMethods<'tcx>\n-    + DeclareMethods<'tcx>\n     + AsmMethods\n     + PreDefineMethods<'tcx>\n     + HasParamEnv<'tcx>\n@@ -77,7 +76,6 @@ impl<'tcx, T> CodegenMethods<'tcx> for T where\n         + StaticMethods\n         + CoverageInfoMethods\n         + DebugInfoMethods<'tcx>\n-        + DeclareMethods<'tcx>\n         + AsmMethods\n         + PreDefineMethods<'tcx>\n         + HasParamEnv<'tcx>"}, {"sha": "b918ed9458cdae1d0bd405e7a9fea783e0844aa2", "filename": "compiler/rustc_data_structures/src/macros.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_data_structures%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_data_structures%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmacros.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -1,15 +1,3 @@\n-/// A simple static assertion macro.\n-#[macro_export]\n-#[allow_internal_unstable(type_ascription)]\n-macro_rules! static_assert {\n-    ($test:expr) => {\n-        // Use the bool to access an array such that if the bool is false, the access\n-        // is out-of-bounds.\n-        #[allow(dead_code)]\n-        const _: () = [()][!($test: bool) as usize];\n-    };\n-}\n-\n /// Type size assertion. The first argument is a type and the second argument is its expected size.\n #[macro_export]\n macro_rules! static_assert_size {"}, {"sha": "363879cbb1d197329ba35419a3917f398b3d6b32", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -600,10 +600,7 @@ pub fn print_time_passes_entry(do_it: bool, what: &str, dur: Duration) {\n // Hack up our own formatting for the duration to make it easier for scripts\n // to parse (always use the same number of decimal places and the same unit).\n pub fn duration_to_secs_str(dur: std::time::Duration) -> String {\n-    const NANOS_PER_SEC: f64 = 1_000_000_000.0;\n-    let secs = dur.as_secs() as f64 + dur.subsec_nanos() as f64 / NANOS_PER_SEC;\n-\n-    format!(\"{:.3}\", secs)\n+    format!(\"{:.3}\", dur.as_secs_f64())\n }\n \n // Memory reporting"}, {"sha": "98cbf98df92b4d0888e20c3d95adf40923138998", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -1227,26 +1227,22 @@ impl EmitterWriter {\n             }\n             draw_note_separator(&mut buffer, 0, max_line_num_len + 1);\n             if *level != Level::FailureNote {\n-                let level_str = level.to_string();\n-                if !level_str.is_empty() {\n-                    buffer.append(0, &level_str, Style::MainHeaderMsg);\n-                    buffer.append(0, \": \", Style::NoStyle);\n-                }\n+                buffer.append(0, level.to_str(), Style::MainHeaderMsg);\n+                buffer.append(0, \": \", Style::NoStyle);\n             }\n             self.msg_to_buffer(&mut buffer, msg, max_line_num_len, \"note\", None);\n         } else {\n-            let level_str = level.to_string();\n             // The failure note level itself does not provide any useful diagnostic information\n-            if *level != Level::FailureNote && !level_str.is_empty() {\n-                buffer.append(0, &level_str, Style::Level(*level));\n+            if *level != Level::FailureNote {\n+                buffer.append(0, level.to_str(), Style::Level(*level));\n             }\n             // only render error codes, not lint codes\n             if let Some(DiagnosticId::Error(ref code)) = *code {\n                 buffer.append(0, \"[\", Style::Level(*level));\n                 buffer.append(0, &code, Style::Level(*level));\n                 buffer.append(0, \"]\", Style::Level(*level));\n             }\n-            if *level != Level::FailureNote && !level_str.is_empty() {\n+            if *level != Level::FailureNote {\n                 buffer.append(0, \": \", header_style);\n             }\n             for &(ref text, _) in msg.iter() {\n@@ -1548,11 +1544,9 @@ impl EmitterWriter {\n         let mut buffer = StyledBuffer::new();\n \n         // Render the suggestion message\n-        let level_str = level.to_string();\n-        if !level_str.is_empty() {\n-            buffer.append(0, &level_str, Style::Level(*level));\n-            buffer.append(0, \": \", Style::HeaderMsg);\n-        }\n+        buffer.append(0, level.to_str(), Style::Level(*level));\n+        buffer.append(0, \": \", Style::HeaderMsg);\n+\n         self.msg_to_buffer(\n             &mut buffer,\n             &[(suggestion.msg.to_owned(), Style::NoStyle)],"}, {"sha": "b16fe5603c1001f74868b926bf126f99f0d83075", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -973,16 +973,14 @@ impl HandlerInner {\n \n     fn panic_if_treat_err_as_bug(&self) {\n         if self.treat_err_as_bug() {\n-            let s = match (self.err_count(), self.flags.treat_err_as_bug.unwrap_or(0)) {\n-                (0, _) => return,\n-                (1, 1) => \"aborting due to `-Z treat-err-as-bug=1`\".to_string(),\n-                (1, _) => return,\n-                (count, as_bug) => format!(\n+            match (self.err_count(), self.flags.treat_err_as_bug.unwrap_or(0)) {\n+                (1, 1) => panic!(\"aborting due to `-Z treat-err-as-bug=1`\"),\n+                (0, _) | (1, _) => {}\n+                (count, as_bug) => panic!(\n                     \"aborting after {} errors due to `-Z treat-err-as-bug={}`\",\n                     count, as_bug,\n                 ),\n-            };\n-            panic!(s);\n+            }\n         }\n     }\n }"}, {"sha": "8bf1b48ce830ee3741086337bf50940bd777e821", "filename": "config.toml.example", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -9,6 +9,16 @@\n # a custom configuration file can also be specified with `--config` to the build\n # system.\n \n+# =============================================================================\n+# Global Settings\n+# =============================================================================\n+\n+# Use different pre-set defaults than the global defaults.\n+#\n+# See `src/bootstrap/defaults` for more information.\n+# Note that this has no default value (x.py uses the defaults in `config.toml.example`).\n+#profile = <none>\n+\n # =============================================================================\n # Tweaking how LLVM is compiled\n # ============================================================================="}, {"sha": "f60aa2d24c5cafd0599f933cd758f63f9dddf0dc", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 86, "deletions": 15, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -496,10 +496,7 @@ impl<T: ?Sized> Cell<T> {\n     #[inline]\n     #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n     pub fn get_mut(&mut self) -> &mut T {\n-        // SAFETY: This can cause data races if called from a separate thread,\n-        // but `Cell` is `!Sync` so this won't happen, and `&mut` guarantees\n-        // unique access.\n-        unsafe { &mut *self.value.get() }\n+        self.value.get_mut()\n     }\n \n     /// Returns a `&Cell<T>` from a `&mut T`\n@@ -945,8 +942,7 @@ impl<T: ?Sized> RefCell<T> {\n     #[inline]\n     #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n     pub fn get_mut(&mut self) -> &mut T {\n-        // SAFETY: `&mut` guarantees unique access.\n-        unsafe { &mut *self.value.get() }\n+        self.value.get_mut()\n     }\n \n     /// Undo the effect of leaked guards on the borrow state of the `RefCell`.\n@@ -1543,8 +1539,11 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n /// allow internal mutability, such as `Cell<T>` and `RefCell<T>`, use `UnsafeCell` to wrap their\n /// internal data. There is *no* legal way to obtain aliasing `&mut`, not even with `UnsafeCell<T>`.\n ///\n-/// The `UnsafeCell` API itself is technically very simple: it gives you a raw pointer `*mut T` to\n-/// its contents. It is up to _you_ as the abstraction designer to use that raw pointer correctly.\n+/// The `UnsafeCell` API itself is technically very simple: [`.get()`] gives you a raw pointer\n+/// `*mut T` to its contents. It is up to _you_ as the abstraction designer to use that raw pointer\n+/// correctly.\n+///\n+/// [`.get()`]: `UnsafeCell::get`\n ///\n /// The precise Rust aliasing rules are somewhat in flux, but the main points are not contentious:\n ///\n@@ -1571,21 +1570,70 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n /// 2. A `&mut T` reference may be released to safe code provided neither other `&mut T` nor `&T`\n /// co-exist with it. A `&mut T` must always be unique.\n ///\n-/// Note that while mutating or mutably aliasing the contents of an `&UnsafeCell<T>` is\n-/// ok (provided you enforce the invariants some other way), it is still undefined behavior\n-/// to have multiple `&mut UnsafeCell<T>` aliases.\n+/// Note that whilst mutating the contents of an `&UnsafeCell<T>` (even while other\n+/// `&UnsafeCell<T>` references alias the cell) is\n+/// ok (provided you enforce the above invariants some other way), it is still undefined behavior\n+/// to have multiple `&mut UnsafeCell<T>` aliases. That is, `UnsafeCell` is a wrapper\n+/// designed to have a special interaction with _shared_ accesses (_i.e._, through an\n+/// `&UnsafeCell<_>` reference); there is no magic whatsoever when dealing with _exclusive_\n+/// accesses (_e.g._, through an `&mut UnsafeCell<_>`): neither the cell nor the wrapped value\n+/// may be aliased for the duration of that `&mut` borrow.\n+/// This is showcased by the [`.get_mut()`] accessor, which is a non-`unsafe` getter that yields\n+/// a `&mut T`.\n+///\n+/// [`.get_mut()`]: `UnsafeCell::get_mut`\n ///\n /// # Examples\n ///\n+/// Here is an example showcasing how to soundly mutate the contents of an `UnsafeCell<_>` despite\n+/// there being multiple references aliasing the cell:\n+///\n /// ```\n /// use std::cell::UnsafeCell;\n ///\n-/// # #[allow(dead_code)]\n-/// struct NotThreadSafe<T> {\n-///     value: UnsafeCell<T>,\n+/// let x: UnsafeCell<i32> = 42.into();\n+/// // Get multiple / concurrent / shared references to the same `x`.\n+/// let (p1, p2): (&UnsafeCell<i32>, &UnsafeCell<i32>) = (&x, &x);\n+///\n+/// unsafe {\n+///     // SAFETY: within this scope there are no other references to `x`'s contents,\n+///     // so ours is effectively unique.\n+///     let p1_exclusive: &mut i32 = &mut *p1.get(); // -- borrow --+\n+///     *p1_exclusive += 27; //                                     |\n+/// } // <---------- cannot go beyond this point -------------------+\n+///\n+/// unsafe {\n+///     // SAFETY: within this scope nobody expects to have exclusive access to `x`'s contents,\n+///     // so we can have multiple shared accesses concurrently.\n+///     let p2_shared: &i32 = &*p2.get();\n+///     assert_eq!(*p2_shared, 42 + 27);\n+///     let p1_shared: &i32 = &*p1.get();\n+///     assert_eq!(*p1_shared, *p2_shared);\n /// }\n+/// ```\n ///\n-/// unsafe impl<T> Sync for NotThreadSafe<T> {}\n+/// The following example showcases the fact that exclusive access to an `UnsafeCell<T>`\n+/// implies exclusive access to its `T`:\n+///\n+/// ```rust\n+/// #![feature(unsafe_cell_get_mut)]\n+/// #![forbid(unsafe_code)] // with exclusive accesses,\n+///                         // `UnsafeCell` is a transparent no-op wrapper,\n+///                         // so no need for `unsafe` here.\n+/// use std::cell::UnsafeCell;\n+///\n+/// let mut x: UnsafeCell<i32> = 42.into();\n+///\n+/// // Get a compile-time-checked unique reference to `x`.\n+/// let p_unique: &mut UnsafeCell<i32> = &mut x;\n+/// // With an exclusive reference, we can mutate the contents for free.\n+/// *p_unique.get_mut() = 0;\n+/// // Or, equivalently:\n+/// x = UnsafeCell::new(0);\n+///\n+/// // When we own the value, we can extract the contents for free.\n+/// let contents: i32 = x.into_inner();\n+/// assert_eq!(contents, 0);\n /// ```\n #[lang = \"unsafe_cell\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1663,6 +1711,29 @@ impl<T: ?Sized> UnsafeCell<T> {\n         self as *const UnsafeCell<T> as *const T as *mut T\n     }\n \n+    /// Returns a mutable reference to the underlying data.\n+    ///\n+    /// This call borrows the `UnsafeCell` mutably (at compile-time) which\n+    /// guarantees that we possess the only reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(unsafe_cell_get_mut)]\n+    /// use std::cell::UnsafeCell;\n+    ///\n+    /// let mut c = UnsafeCell::new(5);\n+    /// *c.get_mut() += 1;\n+    ///\n+    /// assert_eq!(*c.get_mut(), 6);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"unsafe_cell_get_mut\", issue = \"76943\")]\n+    pub fn get_mut(&mut self) -> &mut T {\n+        // SAFETY: (outer) `&mut` guarantees unique access.\n+        unsafe { &mut *self.get() }\n+    }\n+\n     /// Gets a mutable pointer to the wrapped value.\n     /// The difference to [`get`] is that this function accepts a raw pointer,\n     /// which is useful to avoid the creation of temporary references."}, {"sha": "97562cf73b869ee1d5901ccfa0cf4f83d0d465ad", "filename": "library/core/src/iter/sources.rs", "status": "modified", "additions": 29, "deletions": 47, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fcore%2Fsrc%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fcore%2Fsrc%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -5,9 +5,7 @@ use super::{FusedIterator, TrustedLen};\n \n /// An iterator that repeats an element endlessly.\n ///\n-/// This `struct` is created by the [`repeat`] function. See its documentation for more.\n-///\n-/// [`repeat`]: fn.repeat.html\n+/// This `struct` is created by the [`repeat()`] function. See its documentation for more.\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Repeat<A> {\n@@ -47,15 +45,11 @@ unsafe impl<A: Clone> TrustedLen for Repeat<A> {}\n /// The `repeat()` function repeats a single value over and over again.\n ///\n /// Infinite iterators like `repeat()` are often used with adapters like\n-/// [`take`], in order to make them finite.\n-///\n-/// [`take`]: trait.Iterator.html#method.take\n+/// [`Iterator::take()`], in order to make them finite.\n ///\n /// If the element type of the iterator you need does not implement `Clone`,\n /// or if you do not want to keep the repeated element in memory, you can\n-/// instead use the [`repeat_with`] function.\n-///\n-/// [`repeat_with`]: fn.repeat_with.html\n+/// instead use the [`repeat_with()`] function.\n ///\n /// # Examples\n ///\n@@ -77,7 +71,7 @@ unsafe impl<A: Clone> TrustedLen for Repeat<A> {}\n /// assert_eq!(Some(4), fours.next());\n /// ```\n ///\n-/// Going finite with [`take`]:\n+/// Going finite with [`Iterator::take()`]:\n ///\n /// ```\n /// use std::iter;\n@@ -102,10 +96,8 @@ pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n /// An iterator that repeats elements of type `A` endlessly by\n /// applying the provided closure `F: FnMut() -> A`.\n ///\n-/// This `struct` is created by the [`repeat_with`] function.\n+/// This `struct` is created by the [`repeat_with()`] function.\n /// See its documentation for more.\n-///\n-/// [`repeat_with`]: fn.repeat_with.html\n #[derive(Copy, Clone, Debug)]\n #[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n pub struct RepeatWith<F> {\n@@ -139,20 +131,18 @@ unsafe impl<A, F: FnMut() -> A> TrustedLen for RepeatWith<F> {}\n /// The `repeat_with()` function calls the repeater over and over again.\n ///\n /// Infinite iterators like `repeat_with()` are often used with adapters like\n-/// [`take`], in order to make them finite.\n-///\n-/// [`take`]: trait.Iterator.html#method.take\n+/// [`Iterator::take()`], in order to make them finite.\n ///\n-/// If the element type of the iterator you need implements `Clone`, and\n+/// If the element type of the iterator you need implements [`Clone`], and\n /// it is OK to keep the source element in memory, you should instead use\n-/// the [`repeat`] function.\n-///\n-/// [`repeat`]: fn.repeat.html\n+/// the [`repeat()`] function.\n ///\n-/// An iterator produced by `repeat_with()` is not a `DoubleEndedIterator`.\n-/// If you need `repeat_with()` to return a `DoubleEndedIterator`,\n+/// An iterator produced by `repeat_with()` is not a [`DoubleEndedIterator`].\n+/// If you need `repeat_with()` to return a [`DoubleEndedIterator`],\n /// please open a GitHub issue explaining your use case.\n ///\n+/// [`DoubleEndedIterator`]: crate::iter::DoubleEndedIterator\n+///\n /// # Examples\n ///\n /// Basic usage:\n@@ -201,9 +191,7 @@ pub fn repeat_with<A, F: FnMut() -> A>(repeater: F) -> RepeatWith<F> {\n \n /// An iterator that yields nothing.\n ///\n-/// This `struct` is created by the [`empty`] function. See its documentation for more.\n-///\n-/// [`empty`]: fn.empty.html\n+/// This `struct` is created by the [`empty()`] function. See its documentation for more.\n #[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n pub struct Empty<T>(marker::PhantomData<T>);\n \n@@ -292,9 +280,7 @@ pub const fn empty<T>() -> Empty<T> {\n \n /// An iterator that yields an element exactly once.\n ///\n-/// This `struct` is created by the [`once`] function. See its documentation for more.\n-///\n-/// [`once`]: fn.once.html\n+/// This `struct` is created by the [`once()`] function. See its documentation for more.\n #[derive(Clone, Debug)]\n #[stable(feature = \"iter_once\", since = \"1.2.0\")]\n pub struct Once<T> {\n@@ -336,12 +322,12 @@ impl<T> FusedIterator for Once<T> {}\n \n /// Creates an iterator that yields an element exactly once.\n ///\n-/// This is commonly used to adapt a single value into a [`chain`] of other\n+/// This is commonly used to adapt a single value into a [`chain()`] of other\n /// kinds of iteration. Maybe you have an iterator that covers almost\n /// everything, but you need an extra special case. Maybe you have a function\n /// which works on iterators, but you only need to process one value.\n ///\n-/// [`chain`]: trait.Iterator.html#method.chain\n+/// [`chain()`]: Iterator::chain\n ///\n /// # Examples\n ///\n@@ -393,10 +379,8 @@ pub fn once<T>(value: T) -> Once<T> {\n /// An iterator that yields a single element of type `A` by\n /// applying the provided closure `F: FnOnce() -> A`.\n ///\n-/// This `struct` is created by the [`once_with`] function.\n+/// This `struct` is created by the [`once_with()`] function.\n /// See its documentation for more.\n-///\n-/// [`once_with`]: fn.once_with.html\n #[derive(Clone, Debug)]\n #[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n pub struct OnceWith<F> {\n@@ -442,15 +426,14 @@ unsafe impl<A, F: FnOnce() -> A> TrustedLen for OnceWith<F> {}\n /// Creates an iterator that lazily generates a value exactly once by invoking\n /// the provided closure.\n ///\n-/// This is commonly used to adapt a single value generator into a [`chain`] of\n+/// This is commonly used to adapt a single value generator into a [`chain()`] of\n /// other kinds of iteration. Maybe you have an iterator that covers almost\n /// everything, but you need an extra special case. Maybe you have a function\n /// which works on iterators, but you only need to process one value.\n ///\n-/// Unlike [`once`], this function will lazily generate the value on request.\n+/// Unlike [`once()`], this function will lazily generate the value on request.\n ///\n-/// [`once`]: fn.once.html\n-/// [`chain`]: trait.Iterator.html#method.chain\n+/// [`chain()`]: Iterator::chain\n ///\n /// # Examples\n ///\n@@ -505,17 +488,16 @@ pub fn once_with<A, F: FnOnce() -> A>(gen: F) -> OnceWith<F> {\n ///\n /// This allows creating a custom iterator with any behavior\n /// without using the more verbose syntax of creating a dedicated type\n-/// and implementing the `Iterator` trait for it.\n+/// and implementing the [`Iterator`] trait for it.\n ///\n /// Note that the `FromFn` iterator doesn\u2019t make assumptions about the behavior of the closure,\n /// and therefore conservatively does not implement [`FusedIterator`],\n-/// or override [`Iterator::size_hint`] from its default `(0, None)`.\n-///\n-/// [`FusedIterator`]: trait.FusedIterator.html\n-/// [`Iterator::size_hint`]: trait.Iterator.html#method.size_hint\n+/// or override [`Iterator::size_hint()`] from its default `(0, None)`.\n ///\n /// The closure can use captures and its environment to track state across iterations. Depending on\n-/// how the iterator is used, this may require specifying the `move` keyword on the closure.\n+/// how the iterator is used, this may require specifying the [`move`] keyword on the closure.\n+///\n+/// [`move`]: ../../std/keyword.move.html\n ///\n /// # Examples\n ///\n@@ -549,10 +531,10 @@ where\n \n /// An iterator where each iteration calls the provided closure `F: FnMut() -> Option<T>`.\n ///\n-/// This `struct` is created by the [`iter::from_fn`] function.\n+/// This `struct` is created by the [`iter::from_fn()`] function.\n /// See its documentation for more.\n ///\n-/// [`iter::from_fn`]: fn.from_fn.html\n+/// [`iter::from_fn()`]: from_fn\n #[derive(Clone)]\n #[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n pub struct FromFn<F>(F);\n@@ -601,10 +583,10 @@ where\n \n /// An new iterator where each successive item is computed based on the preceding one.\n ///\n-/// This `struct` is created by the [`successors`] function.\n+/// This `struct` is created by the [`iter::successors()`] function.\n /// See its documentation for more.\n ///\n-/// [`successors`]: fn.successors.html\n+/// [`iter::successors()`]: successors\n #[derive(Clone)]\n #[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n pub struct Successors<T, F> {"}, {"sha": "dc0d8087ffbff4e739543ee8ab7f91e56f311f7a", "filename": "library/core/src/iter/traits/accum.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Faccum.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -4,14 +4,13 @@ use crate::ops::{Add, Mul};\n \n /// Trait to represent types that can be created by summing up an iterator.\n ///\n-/// This trait is used to implement the [`sum`] method on iterators. Types which\n-/// implement the trait can be generated by the [`sum`] method. Like\n+/// This trait is used to implement the [`sum()`] method on iterators. Types which\n+/// implement the trait can be generated by the [`sum()`] method. Like\n /// [`FromIterator`] this trait should rarely be called directly and instead\n-/// interacted with through [`Iterator::sum`].\n+/// interacted with through [`Iterator::sum()`].\n ///\n-/// [`sum`]: #tymethod.sum\n-/// [`FromIterator`]: crate::iter::FromIterator\n-/// [`Iterator::sum`]: crate::iter::Iterator::sum\n+/// [`sum()`]: Sum::sum\n+/// [`FromIterator`]: iter::FromIterator\n #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n pub trait Sum<A = Self>: Sized {\n     /// Method which takes an iterator and generates `Self` from the elements by\n@@ -23,14 +22,13 @@ pub trait Sum<A = Self>: Sized {\n /// Trait to represent types that can be created by multiplying elements of an\n /// iterator.\n ///\n-/// This trait is used to implement the [`product`] method on iterators. Types\n-/// which implement the trait can be generated by the [`product`] method. Like\n+/// This trait is used to implement the [`product()`] method on iterators. Types\n+/// which implement the trait can be generated by the [`product()`] method. Like\n /// [`FromIterator`] this trait should rarely be called directly and instead\n-/// interacted with through [`Iterator::product`].\n+/// interacted with through [`Iterator::product()`].\n ///\n-/// [`product`]: #tymethod.product\n-/// [`FromIterator`]: crate::iter::FromIterator\n-/// [`Iterator::product`]: crate::iter::Iterator::product\n+/// [`product()`]: Product::product\n+/// [`FromIterator`]: iter::FromIterator\n #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n pub trait Product<A = Self>: Sized {\n     /// Method which takes an iterator and generates `Self` from the elements by\n@@ -120,9 +118,9 @@ impl<T, U, E> Sum<Result<U, E>> for Result<T, E>\n where\n     T: Sum<U>,\n {\n-    /// Takes each element in the `Iterator`: if it is an `Err`, no further\n-    /// elements are taken, and the `Err` is returned. Should no `Err` occur,\n-    /// the sum of all elements is returned.\n+    /// Takes each element in the [`Iterator`]: if it is an [`Err`], no further\n+    /// elements are taken, and the [`Err`] is returned. Should no [`Err`]\n+    /// occur, the sum of all elements is returned.\n     ///\n     /// # Examples\n     ///\n@@ -150,9 +148,9 @@ impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n where\n     T: Product<U>,\n {\n-    /// Takes each element in the `Iterator`: if it is an `Err`, no further\n-    /// elements are taken, and the `Err` is returned. Should no `Err` occur,\n-    /// the product of all elements is returned.\n+    /// Takes each element in the [`Iterator`]: if it is an [`Err`], no further\n+    /// elements are taken, and the [`Err`] is returned. Should no [`Err`]\n+    /// occur, the product of all elements is returned.\n     fn product<I>(iter: I) -> Result<T, E>\n     where\n         I: Iterator<Item = Result<U, E>>,\n@@ -166,9 +164,9 @@ impl<T, U> Sum<Option<U>> for Option<T>\n where\n     T: Sum<U>,\n {\n-    /// Takes each element in the `Iterator`: if it is a `None`, no further\n-    /// elements are taken, and the `None` is returned. Should no `None` occur,\n-    /// the sum of all elements is returned.\n+    /// Takes each element in the [`Iterator`]: if it is a [`None`], no further\n+    /// elements are taken, and the [`None`] is returned. Should no [`None`]\n+    /// occur, the sum of all elements is returned.\n     ///\n     /// # Examples\n     ///\n@@ -193,9 +191,9 @@ impl<T, U> Product<Option<U>> for Option<T>\n where\n     T: Product<U>,\n {\n-    /// Takes each element in the `Iterator`: if it is a `None`, no further\n-    /// elements are taken, and the `None` is returned. Should no `None` occur,\n-    /// the product of all elements is returned.\n+    /// Takes each element in the [`Iterator`]: if it is a [`None`], no further\n+    /// elements are taken, and the [`None`] is returned. Should no [`None`]\n+    /// occur, the product of all elements is returned.\n     fn product<I>(iter: I) -> Option<T>\n     where\n         I: Iterator<Item = Option<U>>,"}, {"sha": "41a503c4abb4fbb14938ce3d4c670a7823d6798c", "filename": "library/core/src/iter/traits/collect.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -1,21 +1,15 @@\n-/// Conversion from an `Iterator`.\n+/// Conversion from an [`Iterator`].\n ///\n /// By implementing `FromIterator` for a type, you define how it will be\n /// created from an iterator. This is common for types which describe a\n /// collection of some kind.\n ///\n-/// `FromIterator`'s [`from_iter`] is rarely called explicitly, and is instead\n-/// used through [`Iterator`]'s [`collect`] method. See [`collect`]'s\n+/// [`FromIterator::from_iter()`] is rarely called explicitly, and is instead\n+/// used through [`Iterator::collect()`] method. See [`Iterator::collect()`]'s\n /// documentation for more examples.\n ///\n-/// [`from_iter`]: #tymethod.from_iter\n-/// [`Iterator`]: trait.Iterator.html\n-/// [`collect`]: trait.Iterator.html#method.collect\n-///\n /// See also: [`IntoIterator`].\n ///\n-/// [`IntoIterator`]: trait.IntoIterator.html\n-///\n /// # Examples\n ///\n /// Basic usage:\n@@ -30,7 +24,7 @@\n /// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n /// ```\n ///\n-/// Using [`collect`] to implicitly use `FromIterator`:\n+/// Using [`Iterator::collect()`] to implicitly use `FromIterator`:\n ///\n /// ```\n /// let five_fives = std::iter::repeat(5).take(5);\n@@ -119,7 +113,7 @@ pub trait FromIterator<A>: Sized {\n     fn from_iter<T: IntoIterator<Item = A>>(iter: T) -> Self;\n }\n \n-/// Conversion into an `Iterator`.\n+/// Conversion into an [`Iterator`].\n ///\n /// By implementing `IntoIterator` for a type, you define how it will be\n /// converted to an iterator. This is common for types which describe a\n@@ -130,8 +124,6 @@ pub trait FromIterator<A>: Sized {\n ///\n /// See also: [`FromIterator`].\n ///\n-/// [`FromIterator`]: trait.FromIterator.html\n-///\n /// # Examples\n ///\n /// Basic usage:\n@@ -326,7 +318,7 @@ pub trait Extend<A> {\n     /// As this is the only required method for this trait, the [trait-level] docs\n     /// contain more details.\n     ///\n-    /// [trait-level]: trait.Extend.html\n+    /// [trait-level]: Extend\n     ///\n     /// # Examples\n     ///"}, {"sha": "bc03c143d6afb8b1727c62d08efa84f445e3dea3", "filename": "library/core/src/iter/traits/double_ended.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -10,11 +10,12 @@ use crate::ops::{ControlFlow, Try};\n /// and do not cross: iteration is over when they meet in the middle.\n ///\n /// In a similar fashion to the [`Iterator`] protocol, once a\n-/// `DoubleEndedIterator` returns `None` from a `next_back()`, calling it again\n-/// may or may not ever return `Some` again. `next()` and `next_back()` are\n-/// interchangeable for this purpose.\n+/// `DoubleEndedIterator` returns [`None`] from a [`next_back()`], calling it\n+/// again may or may not ever return [`Some`] again. [`next()`] and\n+/// [`next_back()`] are interchangeable for this purpose.\n ///\n-/// [`Iterator`]: trait.Iterator.html\n+/// [`next_back()`]: DoubleEndedIterator::next_back\n+/// [`next()`]: Iterator::next\n ///\n /// # Examples\n ///\n@@ -42,7 +43,7 @@ pub trait DoubleEndedIterator: Iterator {\n     ///\n     /// The [trait-level] docs contain more details.\n     ///\n-    /// [trait-level]: trait.DoubleEndedIterator.html\n+    /// [trait-level]: DoubleEndedIterator\n     ///\n     /// # Examples\n     ///\n@@ -66,7 +67,7 @@ pub trait DoubleEndedIterator: Iterator {\n     /// # Remarks\n     ///\n     /// The elements yielded by `DoubleEndedIterator`'s methods may differ from\n-    /// the ones yielded by `Iterator`'s methods:\n+    /// the ones yielded by [`Iterator`]'s methods:\n     ///\n     /// ```\n     /// let vec = vec![(1, 'a'), (1, 'b'), (1, 'c'), (2, 'a'), (2, 'b')];\n@@ -87,25 +88,23 @@ pub trait DoubleEndedIterator: Iterator {\n     ///     vec![(2, 'b'), (1, 'c')]\n     /// );\n     /// ```\n-    ///\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn next_back(&mut self) -> Option<Self::Item>;\n \n     /// Returns the `n`th element from the end of the iterator.\n     ///\n-    /// This is essentially the reversed version of [`nth`]. Although like most indexing\n-    /// operations, the count starts from zero, so `nth_back(0)` returns the first value from\n-    /// the end, `nth_back(1)` the second, and so on.\n+    /// This is essentially the reversed version of [`Iterator::nth()`].\n+    /// Although like most indexing operations, the count starts from zero, so\n+    /// `nth_back(0)` returns the first value from the end, `nth_back(1)` the\n+    /// second, and so on.\n     ///\n     /// Note that all elements between the end and the returned element will be\n     /// consumed, including the returned element. This also means that calling\n     /// `nth_back(0)` multiple times on the same iterator will return different\n     /// elements.\n     ///\n-    /// `nth_back()` will return [`None`] if `n` is greater than or equal to the length of the\n-    /// iterator.\n-    ///\n-    /// [`nth`]: crate::iter::Iterator::nth\n+    /// `nth_back()` will return [`None`] if `n` is greater than or equal to the\n+    /// length of the iterator.\n     ///\n     /// # Examples\n     ///\n@@ -145,10 +144,8 @@ pub trait DoubleEndedIterator: Iterator {\n         None\n     }\n \n-    /// This is the reverse version of [`try_fold()`]: it takes elements\n-    /// starting from the back of the iterator.\n-    ///\n-    /// [`try_fold()`]: Iterator::try_fold\n+    /// This is the reverse version of [`Iterator::try_fold()`]: it takes\n+    /// elements starting from the back of the iterator.\n     ///\n     /// # Examples\n     ///\n@@ -195,8 +192,8 @@ pub trait DoubleEndedIterator: Iterator {\n     /// An iterator method that reduces the iterator's elements to a single,\n     /// final value, starting from the back.\n     ///\n-    /// This is the reverse version of [`fold()`]: it takes elements starting from\n-    /// the back of the iterator.\n+    /// This is the reverse version of [`Iterator::fold()`]: it takes elements\n+    /// starting from the back of the iterator.\n     ///\n     /// `rfold()` takes two arguments: an initial value, and a closure with two\n     /// arguments: an 'accumulator', and an element. The closure returns the value that\n@@ -213,8 +210,6 @@ pub trait DoubleEndedIterator: Iterator {\n     /// Folding is useful whenever you have a collection of something, and want\n     /// to produce a single value from it.\n     ///\n-    /// [`fold()`]: Iterator::fold\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:"}, {"sha": "33ace60a27419e6b2d4759437f36c6bcca732f3f", "filename": "library/core/src/iter/traits/exact_size.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fexact_size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fexact_size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fexact_size.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -6,17 +6,14 @@\n /// backwards, a good start is to know where the end is.\n ///\n /// When implementing an `ExactSizeIterator`, you must also implement\n-/// [`Iterator`]. When doing so, the implementation of [`size_hint`] *must*\n-/// return the exact size of the iterator.\n-///\n-/// [`Iterator`]: trait.Iterator.html\n-/// [`size_hint`]: trait.Iterator.html#method.size_hint\n+/// [`Iterator`]. When doing so, the implementation of [`Iterator::size_hint`]\n+/// *must* return the exact size of the iterator.\n ///\n /// The [`len`] method has a default implementation, so you usually shouldn't\n /// implement it. However, you may be able to provide a more performant\n /// implementation than the default, so overriding it in this case makes sense.\n ///\n-/// [`len`]: #method.len\n+/// [`len`]: ExactSizeIterator::len\n ///\n /// # Examples\n ///\n@@ -72,17 +69,17 @@ pub trait ExactSizeIterator: Iterator {\n     /// Returns the exact length of the iterator.\n     ///\n     /// The implementation ensures that the iterator will return exactly `len()`\n-    /// more times a `Some(T)` value, before returning `None`.\n+    /// more times a [`Some(T)`] value, before returning [`None`].\n     /// This method has a default implementation, so you usually should not\n     /// implement it directly. However, if you can provide a more efficient\n     /// implementation, you can do so. See the [trait-level] docs for an\n     /// example.\n     ///\n-    /// This function has the same safety guarantees as the [`size_hint`]\n-    /// function.\n+    /// This function has the same safety guarantees as the\n+    /// [`Iterator::size_hint`] function.\n     ///\n-    /// [trait-level]: trait.ExactSizeIterator.html\n-    /// [`size_hint`]: trait.Iterator.html#method.size_hint\n+    /// [trait-level]: ExactSizeIterator\n+    /// [`Some(T)`]: Some\n     ///\n     /// # Examples\n     ///\n@@ -108,8 +105,8 @@ pub trait ExactSizeIterator: Iterator {\n \n     /// Returns `true` if the iterator is empty.\n     ///\n-    /// This method has a default implementation using `self.len()`, so you\n-    /// don't need to implement it yourself.\n+    /// This method has a default implementation using\n+    /// [`ExactSizeIterator::len()`], so you don't need to implement it yourself.\n     ///\n     /// # Examples\n     ///"}, {"sha": "f70e92f0ffafefcf41a5080e991d2fd5741d3447", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -2203,7 +2203,6 @@ pub trait Iterator {\n     ///\n     /// `iter.find_map(f)` is equivalent to `iter.filter_map(f).next()`.\n     ///\n-    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "0900676146c0d7c63dd590bf1d96da2954dbecc1", "filename": "library/core/src/iter/traits/marker.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -2,14 +2,13 @@\n ///\n /// Calling next on a fused iterator that has returned `None` once is guaranteed\n /// to return [`None`] again. This trait should be implemented by all iterators\n-/// that behave this way because it allows optimizing [`Iterator::fuse`].\n+/// that behave this way because it allows optimizing [`Iterator::fuse()`].\n ///\n /// Note: In general, you should not use `FusedIterator` in generic bounds if\n-/// you need a fused iterator. Instead, you should just call [`Iterator::fuse`]\n+/// you need a fused iterator. Instead, you should just call [`Iterator::fuse()`]\n /// on the iterator. If the iterator is already fused, the additional [`Fuse`]\n /// wrapper will be a no-op with no performance penalty.\n ///\n-/// [`Iterator::fuse`]: crate::iter::Iterator::fuse\n /// [`Fuse`]: crate::iter::Fuse\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n #[rustc_unsafe_specialization_marker]\n@@ -24,18 +23,18 @@ impl<I: FusedIterator + ?Sized> FusedIterator for &mut I {}\n /// (lower bound is equal to upper bound), or the upper bound is [`None`].\n /// The upper bound must only be [`None`] if the actual iterator length is\n /// larger than [`usize::MAX`]. In that case, the lower bound must be\n-/// [`usize::MAX`], resulting in a [`.size_hint`] of `(usize::MAX, None)`.\n+/// [`usize::MAX`], resulting in a [`Iterator::size_hint()`] of\n+/// `(usize::MAX, None)`.\n ///\n /// The iterator must produce exactly the number of elements it reported\n /// or diverge before reaching the end.\n ///\n /// # Safety\n ///\n-/// This trait must only be implemented when the contract is upheld.\n-/// Consumers of this trait must inspect [`.size_hint`]\u2019s upper bound.\n+/// This trait must only be implemented when the contract is upheld. Consumers\n+/// of this trait must inspect [`Iterator::size_hint()`]\u2019s upper bound.\n ///\n /// [`usize::MAX`]: crate::usize::MAX\n-/// [`.size_hint`]: crate::iter::Iterator::size_hint\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n #[rustc_unsafe_specialization_marker]\n pub unsafe trait TrustedLen: Iterator {}\n@@ -46,11 +45,12 @@ unsafe impl<I: TrustedLen + ?Sized> TrustedLen for &mut I {}\n /// An iterator that when yielding an item will have taken at least one element\n /// from its underlying [`SourceIter`].\n ///\n-/// Calling next() guarantees that at least one value of the iterator's underlying source\n+/// Calling [`next()`] guarantees that at least one value of the iterator's underlying source\n /// has been moved out and the result of the iterator chain could be inserted in its place,\n /// assuming structural constraints of the source allow such an insertion.\n /// In other words this trait indicates that an iterator pipeline can be collected in place.\n ///\n-/// [`SourceIter`]: ../../std/iter/trait.SourceIter.html\n+/// [`SourceIter`]: crate::iter::SourceIter\n+/// [`next()`]: Iterator::next\n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n pub unsafe trait InPlaceIterable: Iterator {}"}, {"sha": "b1589008be073d123c1c2f4a8292ca0a02adc7cf", "filename": "library/core/src/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -175,7 +175,7 @@ impl<T> Option<T> {\n     /// ```\n     #[must_use = \"if you intended to assert that this has a value, consider `.unwrap()` instead\"]\n     #[inline]\n-    #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n+    #[rustc_const_stable(feature = \"const_option\", since = \"1.48.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn is_some(&self) -> bool {\n         matches!(*self, Some(_))\n@@ -195,7 +195,7 @@ impl<T> Option<T> {\n     #[must_use = \"if you intended to assert that this doesn't have a value, consider \\\n                   `.and_then(|| panic!(\\\"`Option` had a value when expected `None`\\\"))` instead\"]\n     #[inline]\n-    #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n+    #[rustc_const_stable(feature = \"const_option\", since = \"1.48.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn is_none(&self) -> bool {\n         !self.is_some()\n@@ -254,7 +254,7 @@ impl<T> Option<T> {\n     /// println!(\"still can print text: {:?}\", text);\n     /// ```\n     #[inline]\n-    #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n+    #[rustc_const_stable(feature = \"const_option\", since = \"1.48.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn as_ref(&self) -> Option<&T> {\n         match *self {"}, {"sha": "c67d6422c01ec9f6dc107eae1b821eb35a7537d1", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -838,8 +838,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n     pub fn get_mut(&mut self) -> &mut *mut T {\n-        // SAFETY: the mutable reference guarantees unique ownership.\n-        unsafe { &mut *self.p.get() }\n+        self.p.get_mut()\n     }\n \n     /// Get atomic access to a pointer.\n@@ -1275,8 +1274,7 @@ assert_eq!(some_var.load(Ordering::SeqCst), 5);\n                 #[inline]\n                 #[$stable_access]\n                 pub fn get_mut(&mut self) -> &mut $int_type {\n-                    // SAFETY: the mutable reference guarantees unique ownership.\n-                    unsafe { &mut *self.v.get() }\n+                    self.v.get_mut()\n                 }\n             }\n "}, {"sha": "9e86e07dd91a3cf51cc9b938f5fc270fb7594845", "filename": "library/core/tests/option.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fcore%2Ftests%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fcore%2Ftests%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Foption.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -356,3 +356,19 @@ fn test_replace() {\n     assert_eq!(x, Some(3));\n     assert_eq!(old, None);\n }\n+\n+#[test]\n+fn option_const() {\n+    // test that the methods of `Option` are usable in a const context\n+\n+    const OPTION: Option<usize> = Some(32);\n+\n+    const REF: Option<&usize> = OPTION.as_ref();\n+    assert_eq!(REF, Some(&32));\n+\n+    const IS_SOME: bool = OPTION.is_some();\n+    assert!(IS_SOME);\n+\n+    const IS_NONE: bool = OPTION.is_none();\n+    assert!(!IS_NONE);\n+}"}, {"sha": "70533189d8e0b9de487121c31d82bcdfe3b8791c", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -312,6 +312,7 @@\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(unsafe_block_in_unsafe_fn)]\n+#![feature(unsafe_cell_get_mut)]\n #![feature(unsafe_cell_raw_get)]\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]"}, {"sha": "eab26b6c7150ca69feba282d03556a66b8868f54", "filename": "library/std/src/sync/barrier.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fstd%2Fsrc%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fstd%2Fsrc%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fbarrier.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -43,11 +43,8 @@ struct BarrierState {\n     generation_id: usize,\n }\n \n-/// A `BarrierWaitResult` is returned by [`wait`] when all threads in the [`Barrier`]\n-/// have rendezvoused.\n-///\n-/// [`wait`]: struct.Barrier.html#method.wait\n-/// [`Barrier`]: struct.Barrier.html\n+/// A `BarrierWaitResult` is returned by [`Barrier::wait()`] when all threads\n+/// in the [`Barrier`] have rendezvoused.\n ///\n /// # Examples\n ///\n@@ -70,10 +67,10 @@ impl fmt::Debug for Barrier {\n impl Barrier {\n     /// Creates a new barrier that can block a given number of threads.\n     ///\n-    /// A barrier will block `n`-1 threads which call [`wait`] and then wake up\n-    /// all threads at once when the `n`th thread calls [`wait`].\n+    /// A barrier will block `n`-1 threads which call [`wait()`] and then wake\n+    /// up all threads at once when the `n`th thread calls [`wait()`].\n     ///\n-    /// [`wait`]: #method.wait\n+    /// [`wait()`]: Barrier::wait\n     ///\n     /// # Examples\n     ///\n@@ -97,12 +94,9 @@ impl Barrier {\n     /// be used continuously.\n     ///\n     /// A single (arbitrary) thread will receive a [`BarrierWaitResult`] that\n-    /// returns `true` from [`is_leader`] when returning from this function, and\n-    /// all other threads will receive a result that will return `false` from\n-    /// [`is_leader`].\n-    ///\n-    /// [`BarrierWaitResult`]: struct.BarrierWaitResult.html\n-    /// [`is_leader`]: struct.BarrierWaitResult.html#method.is_leader\n+    /// returns `true` from [`BarrierWaitResult::is_leader()`] when returning\n+    /// from this function, and all other threads will receive a result that\n+    /// will return `false` from [`BarrierWaitResult::is_leader()`].\n     ///\n     /// # Examples\n     ///\n@@ -156,13 +150,12 @@ impl fmt::Debug for BarrierWaitResult {\n }\n \n impl BarrierWaitResult {\n-    /// Returns `true` if this thread from [`wait`] is the \"leader thread\".\n+    /// Returns `true` if this thread is the \"leader thread\" for the call to\n+    /// [`Barrier::wait()`].\n     ///\n     /// Only one thread will have `true` returned from their result, all other\n     /// threads will have `false` returned.\n     ///\n-    /// [`wait`]: struct.Barrier.html#method.wait\n-    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "a1703c731d44d3b0fbd5f673ddc37bccc37807c6", "filename": "library/std/src/sync/mutex.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -406,9 +406,7 @@ impl<T: ?Sized> Mutex<T> {\n     /// ```\n     #[stable(feature = \"mutex_get_mut\", since = \"1.6.0\")]\n     pub fn get_mut(&mut self) -> LockResult<&mut T> {\n-        // We know statically that there are no other references to `self`, so\n-        // there's no need to lock the inner mutex.\n-        let data = unsafe { &mut *self.data.get() };\n+        let data = self.data.get_mut();\n         poison::map_result(self.poison.borrow(), |_| data)\n     }\n }"}, {"sha": "de5ddf1daf27b5d76e1cc46d075a4658518c1421", "filename": "library/std/src/sync/once.rs", "status": "modified", "additions": 26, "deletions": 37, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -95,10 +95,7 @@ use crate::thread::{self, Thread};\n \n /// A synchronization primitive which can be used to run a one-time global\n /// initialization. Useful for one-time initialization for FFI or related\n-/// functionality. This type can only be constructed with the [`Once::new`]\n-/// constructor.\n-///\n-/// [`Once::new`]: struct.Once.html#method.new\n+/// functionality. This type can only be constructed with [`Once::new()`].\n ///\n /// # Examples\n ///\n@@ -126,11 +123,8 @@ unsafe impl Sync for Once {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl Send for Once {}\n \n-/// State yielded to [`call_once_force`]\u2019s closure parameter. The state can be\n-/// used to query the poison status of the [`Once`].\n-///\n-/// [`call_once_force`]: struct.Once.html#method.call_once_force\n-/// [`Once`]: struct.Once.html\n+/// State yielded to [`Once::call_once_force()`]\u2019s closure parameter. The state\n+/// can be used to query the poison status of the [`Once`].\n #[unstable(feature = \"once_poison\", issue = \"33577\")]\n #[derive(Debug)]\n pub struct OnceState {\n@@ -140,8 +134,6 @@ pub struct OnceState {\n \n /// Initialization value for static [`Once`] values.\n ///\n-/// [`Once`]: struct.Once.html\n-///\n /// # Examples\n ///\n /// ```\n@@ -212,7 +204,7 @@ impl Once {\n     /// happens-before relation between the closure and code executing after the\n     /// return).\n     ///\n-    /// If the given closure recursively invokes `call_once` on the same `Once`\n+    /// If the given closure recursively invokes `call_once` on the same [`Once`]\n     /// instance the exact behavior is not specified, allowed outcomes are\n     /// a panic or a deadlock.\n     ///\n@@ -249,7 +241,7 @@ impl Once {\n     ///\n     /// The closure `f` will only be executed once if this is called\n     /// concurrently amongst many threads. If that closure panics, however, then\n-    /// it will *poison* this `Once` instance, causing all future invocations of\n+    /// it will *poison* this [`Once`] instance, causing all future invocations of\n     /// `call_once` to also panic.\n     ///\n     /// This is similar to [poisoning with mutexes][poison].\n@@ -269,21 +261,21 @@ impl Once {\n         self.call_inner(false, &mut |_| f.take().unwrap()());\n     }\n \n-    /// Performs the same function as [`call_once`] except ignores poisoning.\n+    /// Performs the same function as [`call_once()`] except ignores poisoning.\n     ///\n-    /// Unlike [`call_once`], if this `Once` has been poisoned (i.e., a previous\n-    /// call to `call_once` or `call_once_force` caused a panic), calling\n-    /// `call_once_force` will still invoke the closure `f` and will _not_\n-    /// result in an immediate panic. If `f` panics, the `Once` will remain\n-    /// in a poison state. If `f` does _not_ panic, the `Once` will no\n-    /// longer be in a poison state and all future calls to `call_once` or\n-    /// `call_once_force` will be no-ops.\n+    /// Unlike [`call_once()`], if this [`Once`] has been poisoned (i.e., a previous\n+    /// call to [`call_once()`] or [`call_once_force()`] caused a panic), calling\n+    /// [`call_once_force()`] will still invoke the closure `f` and will _not_\n+    /// result in an immediate panic. If `f` panics, the [`Once`] will remain\n+    /// in a poison state. If `f` does _not_ panic, the [`Once`] will no\n+    /// longer be in a poison state and all future calls to [`call_once()`] or\n+    /// [`call_once_force()`] will be no-ops.\n     ///\n     /// The closure `f` is yielded a [`OnceState`] structure which can be used\n-    /// to query the poison status of the `Once`.\n+    /// to query the poison status of the [`Once`].\n     ///\n-    /// [`call_once`]: struct.Once.html#method.call_once\n-    /// [`OnceState`]: struct.OnceState.html\n+    /// [`call_once()`]: Once::call_once\n+    /// [`call_once_force()`]: Once::call_once_force\n     ///\n     /// # Examples\n     ///\n@@ -329,18 +321,20 @@ impl Once {\n         self.call_inner(true, &mut |p| f.take().unwrap()(p));\n     }\n \n-    /// Returns `true` if some `call_once` call has completed\n+    /// Returns `true` if some [`call_once()`] call has completed\n     /// successfully. Specifically, `is_completed` will return false in\n     /// the following situations:\n-    ///   * `call_once` was not called at all,\n-    ///   * `call_once` was called, but has not yet completed,\n-    ///   * the `Once` instance is poisoned\n+    ///   * [`call_once()`] was not called at all,\n+    ///   * [`call_once()`] was called, but has not yet completed,\n+    ///   * the [`Once`] instance is poisoned\n     ///\n-    /// This function returning `false` does not mean that `Once` has not been\n+    /// This function returning `false` does not mean that [`Once`] has not been\n     /// executed. For example, it may have been executed in the time between\n     /// when `is_completed` starts executing and when it returns, in which case\n     /// the `false` return value would be stale (but still permissible).\n     ///\n+    /// [`call_once()`]: Once::call_once\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -519,14 +513,11 @@ impl Drop for WaiterQueue<'_> {\n \n impl OnceState {\n     /// Returns `true` if the associated [`Once`] was poisoned prior to the\n-    /// invocation of the closure passed to [`call_once_force`].\n-    ///\n-    /// [`call_once_force`]: struct.Once.html#method.call_once_force\n-    /// [`Once`]: struct.Once.html\n+    /// invocation of the closure passed to [`Once::call_once_force()`].\n     ///\n     /// # Examples\n     ///\n-    /// A poisoned `Once`:\n+    /// A poisoned [`Once`]:\n     ///\n     /// ```\n     /// #![feature(once_poison)]\n@@ -547,7 +538,7 @@ impl OnceState {\n     /// });\n     /// ```\n     ///\n-    /// An unpoisoned `Once`:\n+    /// An unpoisoned [`Once`]:\n     ///\n     /// ```\n     /// #![feature(once_poison)]\n@@ -565,8 +556,6 @@ impl OnceState {\n     }\n \n     /// Poison the associated [`Once`] without explicitly panicking.\n-    ///\n-    /// [`Once`]: struct.Once.html\n     // NOTE: This is currently only exposed for the `lazy` module\n     pub(crate) fn poison(&self) {\n         self.set_state_on_drop_to.set(POISONED);"}, {"sha": "d967779ce361de0bf1da126434cf518a7d02963b", "filename": "library/std/src/sync/rwlock.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -404,9 +404,7 @@ impl<T: ?Sized> RwLock<T> {\n     /// ```\n     #[stable(feature = \"rwlock_get_mut\", since = \"1.6.0\")]\n     pub fn get_mut(&mut self) -> LockResult<&mut T> {\n-        // We know statically that there are no other references to `self`, so\n-        // there's no need to lock the inner lock.\n-        let data = unsafe { &mut *self.data.get() };\n+        let data = self.data.get_mut();\n         poison::map_result(self.poison.borrow(), |_| data)\n     }\n }"}, {"sha": "a03cf9dd791156077329232a1be4e3e36ee7a96b", "filename": "library/test/src/bench.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/library%2Ftest%2Fsrc%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/library%2Ftest%2Fsrc%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fbench.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -61,15 +61,15 @@ pub fn fmt_bench_samples(bs: &BenchSamples) -> String {\n     let median = bs.ns_iter_summ.median as usize;\n     let deviation = (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as usize;\n \n-    output\n-        .write_fmt(format_args!(\n-            \"{:>11} ns/iter (+/- {})\",\n-            fmt_thousands_sep(median, ','),\n-            fmt_thousands_sep(deviation, ',')\n-        ))\n-        .unwrap();\n+    write!(\n+        output,\n+        \"{:>11} ns/iter (+/- {})\",\n+        fmt_thousands_sep(median, ','),\n+        fmt_thousands_sep(deviation, ',')\n+    )\n+    .unwrap();\n     if bs.mb_s != 0 {\n-        output.write_fmt(format_args!(\" = {} MB/s\", bs.mb_s)).unwrap();\n+        write!(output, \" = {} MB/s\", bs.mb_s).unwrap();\n     }\n     output\n }\n@@ -83,9 +83,9 @@ fn fmt_thousands_sep(mut n: usize, sep: char) -> String {\n         let base = 10_usize.pow(pow);\n         if pow == 0 || trailing || n / base != 0 {\n             if !trailing {\n-                output.write_fmt(format_args!(\"{}\", n / base)).unwrap();\n+                write!(output, \"{}\", n / base).unwrap();\n             } else {\n-                output.write_fmt(format_args!(\"{:03}\", n / base)).unwrap();\n+                write!(output, \"{:03}\", n / base).unwrap();\n             }\n             if pow != 0 {\n                 output.push(sep);\n@@ -98,10 +98,6 @@ fn fmt_thousands_sep(mut n: usize, sep: char) -> String {\n     output\n }\n \n-fn ns_from_dur(dur: Duration) -> u64 {\n-    dur.as_secs() * 1_000_000_000 + (dur.subsec_nanos() as u64)\n-}\n-\n fn ns_iter_inner<T, F>(inner: &mut F, k: u64) -> u64\n where\n     F: FnMut() -> T,\n@@ -110,7 +106,7 @@ where\n     for _ in 0..k {\n         black_box(inner());\n     }\n-    ns_from_dur(start.elapsed())\n+    start.elapsed().as_nanos() as u64\n }\n \n pub fn iter<T, F>(inner: &mut F) -> stats::Summary"}, {"sha": "e04128d1b0b2569409c05de9de37a268a1a3c331", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -49,6 +49,7 @@ lazy_static = \"1.3.0\"\n time = \"0.1\"\n ignore = \"0.4.10\"\n opener = \"0.4\"\n+merge = \"0.1.0\"\n \n [target.'cfg(windows)'.dependencies.winapi]\n version = \"0.3\""}, {"sha": "801ed5ac6eeea600de34ac40d28221e5fec52c0c", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 51, "deletions": 25, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -16,6 +16,7 @@ use crate::flags::Flags;\n pub use crate::flags::Subcommand;\n use crate::util::exe;\n use build_helper::t;\n+use merge::Merge;\n use serde::Deserialize;\n \n macro_rules! check_ci_llvm {\n@@ -278,10 +279,31 @@ struct TomlConfig {\n     rust: Option<Rust>,\n     target: Option<HashMap<String, TomlTarget>>,\n     dist: Option<Dist>,\n+    profile: Option<String>,\n+}\n+\n+impl Merge for TomlConfig {\n+    fn merge(&mut self, TomlConfig { build, install, llvm, rust, dist, target, profile: _ }: Self) {\n+        fn do_merge<T: Merge>(x: &mut Option<T>, y: Option<T>) {\n+            if let Some(new) = y {\n+                if let Some(original) = x {\n+                    original.merge(new);\n+                } else {\n+                    *x = Some(new);\n+                }\n+            }\n+        };\n+        do_merge(&mut self.build, build);\n+        do_merge(&mut self.install, install);\n+        do_merge(&mut self.llvm, llvm);\n+        do_merge(&mut self.rust, rust);\n+        do_merge(&mut self.dist, dist);\n+        assert!(target.is_none(), \"merging target-specific config is not currently supported\");\n+    }\n }\n \n /// TOML representation of various global build decisions.\n-#[derive(Deserialize, Default, Clone)]\n+#[derive(Deserialize, Default, Clone, Merge)]\n #[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n struct Build {\n     build: Option<String>,\n@@ -321,7 +343,7 @@ struct Build {\n }\n \n /// TOML representation of various global install decisions.\n-#[derive(Deserialize, Default, Clone)]\n+#[derive(Deserialize, Default, Clone, Merge)]\n #[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n struct Install {\n     prefix: Option<String>,\n@@ -338,7 +360,7 @@ struct Install {\n }\n \n /// TOML representation of how the LLVM build is configured.\n-#[derive(Deserialize, Default)]\n+#[derive(Deserialize, Default, Merge)]\n #[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n struct Llvm {\n     skip_rebuild: Option<bool>,\n@@ -365,7 +387,7 @@ struct Llvm {\n     download_ci_llvm: Option<bool>,\n }\n \n-#[derive(Deserialize, Default, Clone)]\n+#[derive(Deserialize, Default, Clone, Merge)]\n #[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n struct Dist {\n     sign_folder: Option<String>,\n@@ -389,7 +411,7 @@ impl Default for StringOrBool {\n }\n \n /// TOML representation of how the Rust build is configured.\n-#[derive(Deserialize, Default)]\n+#[derive(Deserialize, Default, Merge)]\n #[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n struct Rust {\n     optimize: Option<bool>,\n@@ -434,7 +456,7 @@ struct Rust {\n }\n \n /// TOML representation of how each build target is configured.\n-#[derive(Deserialize, Default)]\n+#[derive(Deserialize, Default, Merge)]\n #[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n struct TomlTarget {\n     cc: Option<String>,\n@@ -524,27 +546,31 @@ impl Config {\n         }\n \n         #[cfg(test)]\n-        let toml = TomlConfig::default();\n+        let get_toml = |_| TomlConfig::default();\n         #[cfg(not(test))]\n-        let toml = flags\n-            .config\n-            .map(|file| {\n-                use std::process;\n-\n-                let contents = t!(fs::read_to_string(&file));\n-                match toml::from_str(&contents) {\n-                    Ok(table) => table,\n-                    Err(err) => {\n-                        println!(\n-                            \"failed to parse TOML configuration '{}': {}\",\n-                            file.display(),\n-                            err\n-                        );\n-                        process::exit(2);\n-                    }\n+        let get_toml = |file: PathBuf| {\n+            use std::process;\n+\n+            let contents = t!(fs::read_to_string(&file), \"configuration file did not exist\");\n+            match toml::from_str(&contents) {\n+                Ok(table) => table,\n+                Err(err) => {\n+                    println!(\"failed to parse TOML configuration '{}': {}\", file.display(), err);\n+                    process::exit(2);\n                 }\n-            })\n-            .unwrap_or_else(TomlConfig::default);\n+            }\n+        };\n+\n+        let mut toml = flags.config.map(get_toml).unwrap_or_else(TomlConfig::default);\n+        if let Some(include) = &toml.profile {\n+            let mut include_path = config.src.clone();\n+            include_path.push(\"src\");\n+            include_path.push(\"bootstrap\");\n+            include_path.push(\"defaults\");\n+            include_path.push(format!(\"config.toml.{}\", include));\n+            let included_toml = get_toml(include_path);\n+            toml.merge(included_toml);\n+        }\n \n         let build = toml.build.unwrap_or_default();\n "}, {"sha": "a91fc3538eb55f0e3aed94377d5a08cb1f23ac0f", "filename": "src/bootstrap/defaults/README.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/src%2Fbootstrap%2Fdefaults%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/src%2Fbootstrap%2Fdefaults%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdefaults%2FREADME.md?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -0,0 +1,11 @@\n+# About bootstrap defaults\n+\n+These defaults are intended to be a good starting point for working with x.py,\n+with the understanding that no one set of defaults make sense for everyone.\n+\n+They are still experimental, and we'd appreciate your help improving them!\n+If you use a setting that's not in these defaults that you think others would benefit from, please [file an issue] or make a PR with the changes.\n+Similarly, if one of these defaults doesn't match what you use personally,\n+please open an issue to get it changed.\n+\n+[file an issue]: https://github.com/rust-lang/rust/issues/new/choose"}, {"sha": "a9505922ca7fc9a81232ae8404320503f838bc6c", "filename": "src/bootstrap/defaults/config.toml.codegen", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/src%2Fbootstrap%2Fdefaults%2Fconfig.toml.codegen", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/src%2Fbootstrap%2Fdefaults%2Fconfig.toml.codegen", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdefaults%2Fconfig.toml.codegen?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -0,0 +1,13 @@\n+# These defaults are meant for contributors to the compiler who modify codegen or LLVM\n+[llvm]\n+# This enables debug-assertions in LLVM,\n+# catching logic errors in codegen much earlier in the process.\n+assertions = true\n+\n+[rust]\n+# This enables `RUSTC_LOG=debug`, avoiding confusing situations\n+# where adding `debug!()` appears to do nothing.\n+# However, it makes running the compiler slightly slower.\n+debug-logging = true\n+# This greatly increases the speed of rebuilds, especially when there are only minor changes. However, it makes the initial build slightly slower.\n+incremental = true"}, {"sha": "4772de8a2cb22c27a40890009555f54a7ecda134", "filename": "src/bootstrap/defaults/config.toml.compiler", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/src%2Fbootstrap%2Fdefaults%2Fconfig.toml.compiler", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/src%2Fbootstrap%2Fdefaults%2Fconfig.toml.compiler", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdefaults%2Fconfig.toml.compiler?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -0,0 +1,8 @@\n+# These defaults are meant for contributors to the compiler who do not modify codegen or LLVM\n+[rust]\n+# This enables `RUSTC_LOG=debug`, avoiding confusing situations\n+# where adding `debug!()` appears to do nothing.\n+# However, it makes running the compiler slightly slower.\n+debug-logging = true\n+# This greatly increases the speed of rebuilds, especially when there are only minor changes. However, it makes the initial build slightly slower.\n+incremental = true"}, {"sha": "e4316f4d8644050ea15b0d803351b76874967bde", "filename": "src/bootstrap/defaults/config.toml.library", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/src%2Fbootstrap%2Fdefaults%2Fconfig.toml.library", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/src%2Fbootstrap%2Fdefaults%2Fconfig.toml.library", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdefaults%2Fconfig.toml.library?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -0,0 +1,10 @@\n+# These defaults are meant for contributors to the standard library and documentation.\n+[build]\n+# When building the standard library, you almost never want to build the compiler itself.\n+build-stage = 0\n+test-stage = 0\n+bench-stage = 0\n+\n+[rust]\n+# This greatly increases the speed of rebuilds, especially when there are only minor changes. However, it makes the initial build slightly slower.\n+incremental = true"}, {"sha": "6647061d88fcbc99005ed446871d4ab2c420273c", "filename": "src/bootstrap/defaults/config.toml.user", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/src%2Fbootstrap%2Fdefaults%2Fconfig.toml.user", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/src%2Fbootstrap%2Fdefaults%2Fconfig.toml.user", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdefaults%2Fconfig.toml.user?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -0,0 +1,9 @@\n+# These defaults are meant for users and distro maintainers building from source, without intending to make multiple changes.\n+[build]\n+# When compiling from source, you almost always want a full stage 2 build,\n+# which has all the latest optimizations from nightly.\n+build-stage = 2\n+test-stage = 2\n+doc-stage = 2\n+# When compiling from source, you usually want all tools.\n+extended = true"}, {"sha": "6c18adbcb3c92b5efc46cdc5122ab49e646c9ea4", "filename": "src/test/codegen/issue-34634.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/src%2Ftest%2Fcodegen%2Fissue-34634.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/src%2Ftest%2Fcodegen%2Fissue-34634.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-34634.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -0,0 +1,16 @@\n+// Test that `wrapping_div` only checks divisor once.\n+// This test checks that there is only a single compare agains -1 and -1 is not present as a\n+// switch case (the second check present until rustc 1.12).\n+// This test also verifies that a single panic call is generated (for the division by zero case).\n+\n+// compile-flags: -O\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: @f\n+#[no_mangle]\n+pub fn f(x: i32, y: i32) -> i32 {\n+    // CHECK-COUNT-1: icmp eq i32 %y, -1\n+    // CHECK-COUNT-1: panic\n+    // CHECK-NOT: i32 -1, label\n+    x.wrapping_div(y)\n+}"}, {"sha": "fbf20b9db67415434e49cdb1313922b870846efe", "filename": "src/test/ui/consts/const-option.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0433fdf93b0346e136c03ed49c0e90346035f191/src%2Ftest%2Fui%2Fconsts%2Fconst-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0433fdf93b0346e136c03ed49c0e90346035f191/src%2Ftest%2Fui%2Fconsts%2Fconst-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-option.rs?ref=0433fdf93b0346e136c03ed49c0e90346035f191", "patch": "@@ -1,14 +0,0 @@\n-// run-pass\n-\n-#![feature(const_option)]\n-\n-const X: Option<i32> = Some(32);\n-const Y: Option<&i32> = X.as_ref();\n-\n-const IS_SOME: bool = X.is_some();\n-const IS_NONE: bool = Y.is_none();\n-\n-fn main() {\n-    assert!(IS_SOME);\n-    assert!(!IS_NONE)\n-}"}, {"sha": "819846ebc793becfe6d8a999a3a5f419300e1e66", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "modified", "additions": 16, "deletions": 62, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -1440,15 +1440,12 @@ where\n \n mod redundant_pattern_match {\n     use super::REDUNDANT_PATTERN_MATCHING;\n-    use crate::utils::{in_constant, match_qpath, match_trait_method, paths, snippet, span_lint_and_then};\n+    use crate::utils::{match_qpath, match_trait_method, paths, snippet, span_lint_and_then};\n     use if_chain::if_chain;\n     use rustc_ast::ast::LitKind;\n     use rustc_errors::Applicability;\n-    use rustc_hir::{Arm, Expr, ExprKind, HirId, MatchSource, PatKind, QPath};\n+    use rustc_hir::{Arm, Expr, ExprKind, MatchSource, PatKind, QPath};\n     use rustc_lint::LateContext;\n-    use rustc_middle::ty;\n-    use rustc_mir::const_eval::is_const_fn;\n-    use rustc_span::source_map::Symbol;\n \n     pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Match(op, arms, ref match_source) = &expr.kind {\n@@ -1468,37 +1465,24 @@ mod redundant_pattern_match {\n         arms: &[Arm<'_>],\n         keyword: &'static str,\n     ) {\n-        fn find_suggestion(cx: &LateContext<'_>, hir_id: HirId, path: &QPath<'_>) -> Option<&'static str> {\n-            if match_qpath(path, &paths::RESULT_OK) {\n-                return Some(\"is_ok()\");\n-            }\n-            if match_qpath(path, &paths::RESULT_ERR) {\n-                return Some(\"is_err()\");\n-            }\n-            if match_qpath(path, &paths::OPTION_SOME) && can_suggest(cx, hir_id, sym!(option_type), \"is_some\") {\n-                return Some(\"is_some()\");\n-            }\n-            if match_qpath(path, &paths::OPTION_NONE) && can_suggest(cx, hir_id, sym!(option_type), \"is_none\") {\n-                return Some(\"is_none()\");\n-            }\n-            None\n-        }\n-\n-        let hir_id = expr.hir_id;\n         let good_method = match arms[0].pat.kind {\n             PatKind::TupleStruct(ref path, ref patterns, _) if patterns.len() == 1 => {\n                 if let PatKind::Wild = patterns[0].kind {\n-                    find_suggestion(cx, hir_id, path)\n+                    if match_qpath(path, &paths::RESULT_OK) {\n+                        \"is_ok()\"\n+                    } else if match_qpath(path, &paths::RESULT_ERR) {\n+                        \"is_err()\"\n+                    } else if match_qpath(path, &paths::OPTION_SOME) {\n+                        \"is_some()\"\n+                    } else {\n+                        return;\n+                    }\n                 } else {\n-                    None\n+                    return;\n                 }\n             },\n-            PatKind::Path(ref path) => find_suggestion(cx, hir_id, path),\n-            _ => None,\n-        };\n-        let good_method = match good_method {\n-            Some(method) => method,\n-            None => return,\n+            PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE) => \"is_none()\",\n+            _ => return,\n         };\n \n         // check that `while_let_on_iterator` lint does not trigger\n@@ -1547,7 +1531,6 @@ mod redundant_pattern_match {\n         if arms.len() == 2 {\n             let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n \n-            let hir_id = expr.hir_id;\n             let found_good_method = match node_pair {\n                 (\n                     PatKind::TupleStruct(ref path_left, ref patterns_left, _),\n@@ -1562,8 +1545,6 @@ mod redundant_pattern_match {\n                             &paths::RESULT_ERR,\n                             \"is_ok()\",\n                             \"is_err()\",\n-                            || true,\n-                            || true,\n                         )\n                     } else {\n                         None\n@@ -1582,8 +1563,6 @@ mod redundant_pattern_match {\n                             &paths::OPTION_NONE,\n                             \"is_some()\",\n                             \"is_none()\",\n-                            || can_suggest(cx, hir_id, sym!(option_type), \"is_some\"),\n-                            || can_suggest(cx, hir_id, sym!(option_type), \"is_none\"),\n                         )\n                     } else {\n                         None\n@@ -1616,7 +1595,6 @@ mod redundant_pattern_match {\n         }\n     }\n \n-    #[allow(clippy::too_many_arguments)]\n     fn find_good_method_for_match<'a>(\n         arms: &[Arm<'_>],\n         path_left: &QPath<'_>,\n@@ -1625,8 +1603,6 @@ mod redundant_pattern_match {\n         expected_right: &[&str],\n         should_be_left: &'a str,\n         should_be_right: &'a str,\n-        can_suggest_left: impl Fn() -> bool,\n-        can_suggest_right: impl Fn() -> bool,\n     ) -> Option<&'a str> {\n         let body_node_pair = if match_qpath(path_left, expected_left) && match_qpath(path_right, expected_right) {\n             (&(*arms[0].body).kind, &(*arms[1].body).kind)\n@@ -1638,35 +1614,13 @@ mod redundant_pattern_match {\n \n         match body_node_pair {\n             (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => match (&lit_left.node, &lit_right.node) {\n-                (LitKind::Bool(true), LitKind::Bool(false)) if can_suggest_left() => Some(should_be_left),\n-                (LitKind::Bool(false), LitKind::Bool(true)) if can_suggest_right() => Some(should_be_right),\n+                (LitKind::Bool(true), LitKind::Bool(false)) => Some(should_be_left),\n+                (LitKind::Bool(false), LitKind::Bool(true)) => Some(should_be_right),\n                 _ => None,\n             },\n             _ => None,\n         }\n     }\n-\n-    fn can_suggest(cx: &LateContext<'_>, hir_id: HirId, diag_item: Symbol, name: &str) -> bool {\n-        if !in_constant(cx, hir_id) {\n-            return true;\n-        }\n-\n-        // Avoid suggesting calls to non-`const fn`s in const contexts, see #5697.\n-        cx.tcx\n-            .get_diagnostic_item(diag_item)\n-            .and_then(|def_id| {\n-                cx.tcx.inherent_impls(def_id).iter().find_map(|imp| {\n-                    cx.tcx\n-                        .associated_items(*imp)\n-                        .in_definition_order()\n-                        .find_map(|item| match item.kind {\n-                            ty::AssocKind::Fn if item.ident.name.as_str() == name => Some(item.def_id),\n-                            _ => None,\n-                        })\n-                })\n-            })\n-            .map_or(false, |def_id| is_const_fn(cx.tcx, def_id))\n-    }\n }\n \n #[test]"}, {"sha": "8084fdefdc23eced3f6b2a54643b16b637f667d8", "filename": "src/tools/clippy/tests/ui/redundant_pattern_matching.fixed", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.fixed?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -76,7 +76,6 @@ fn main() {\n     takes_bool(x);\n \n     issue5504();\n-    issue5697();\n     issue6067();\n \n     let _ = if gen_opt().is_some() {\n@@ -129,41 +128,31 @@ fn issue5504() {\n     while m!().is_some() {}\n }\n \n-// None of these should be linted because none of the suggested methods\n-// are `const fn` without toggling a feature.\n-const fn issue5697() {\n-    if let Some(_) = Some(42) {}\n-\n-    if let None = None::<()> {}\n-\n-    while let Some(_) = Some(42) {}\n-\n-    while let None = None::<()> {}\n-\n-    match Some(42) {\n-        Some(_) => true,\n-        None => false,\n-    };\n-\n-    match None::<()> {\n-        Some(_) => false,\n-        None => true,\n-    };\n-}\n-\n // Methods that are unstable const should not be suggested within a const context, see issue #5697.\n-// However, in Rust 1.48.0 the methods `is_ok` and `is_err` of `Result` were stabilized as const,\n-// so the following should be linted.\n+// However, in Rust 1.48.0 the methods `is_ok` and `is_err` of `Result`, and `is_some` and `is_none`\n+// of `Option` were stabilized as const, so the following should be linted.\n const fn issue6067() {\n     if Ok::<i32, i32>(42).is_ok() {}\n \n     if Err::<i32, i32>(42).is_err() {}\n \n+    if Some(42).is_some() {}\n+\n+    if None::<()>.is_none() {}\n+\n     while Ok::<i32, i32>(10).is_ok() {}\n \n     while Ok::<i32, i32>(10).is_err() {}\n \n+    while Some(42).is_some() {}\n+\n+    while None::<()>.is_none() {}\n+\n     Ok::<i32, i32>(42).is_ok();\n \n     Err::<i32, i32>(42).is_err();\n+\n+    Some(42).is_some();\n+\n+    None::<()>.is_none();\n }"}, {"sha": "48a32cb1c7b7d9452908407aaa345a592fa2baf6", "filename": "src/tools/clippy/tests/ui/redundant_pattern_matching.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -97,7 +97,6 @@ fn main() {\n     takes_bool(x);\n \n     issue5504();\n-    issue5697();\n     issue6067();\n \n     let _ = if let Some(_) = gen_opt() {\n@@ -150,40 +149,26 @@ fn issue5504() {\n     while let Some(_) = m!() {}\n }\n \n-// None of these should be linted because none of the suggested methods\n-// are `const fn` without toggling a feature.\n-const fn issue5697() {\n-    if let Some(_) = Some(42) {}\n-\n-    if let None = None::<()> {}\n-\n-    while let Some(_) = Some(42) {}\n-\n-    while let None = None::<()> {}\n-\n-    match Some(42) {\n-        Some(_) => true,\n-        None => false,\n-    };\n-\n-    match None::<()> {\n-        Some(_) => false,\n-        None => true,\n-    };\n-}\n-\n // Methods that are unstable const should not be suggested within a const context, see issue #5697.\n-// However, in Rust 1.48.0 the methods `is_ok` and `is_err` of `Result` were stabilized as const,\n-// so the following should be linted.\n+// However, in Rust 1.48.0 the methods `is_ok` and `is_err` of `Result`, and `is_some` and `is_none`\n+// of `Option` were stabilized as const, so the following should be linted.\n const fn issue6067() {\n     if let Ok(_) = Ok::<i32, i32>(42) {}\n \n     if let Err(_) = Err::<i32, i32>(42) {}\n \n+    if let Some(_) = Some(42) {}\n+\n+    if let None = None::<()> {}\n+\n     while let Ok(_) = Ok::<i32, i32>(10) {}\n \n     while let Err(_) = Ok::<i32, i32>(10) {}\n \n+    while let Some(_) = Some(42) {}\n+\n+    while let None = None::<()> {}\n+\n     match Ok::<i32, i32>(42) {\n         Ok(_) => true,\n         Err(_) => false,\n@@ -193,4 +178,14 @@ const fn issue6067() {\n         Ok(_) => false,\n         Err(_) => true,\n     };\n+\n+    match Some(42) {\n+        Some(_) => true,\n+        None => false,\n+    };\n+\n+    match None::<()> {\n+        Some(_) => false,\n+        None => true,\n+    };\n }"}, {"sha": "17185217e8950de05cf517424230ee39bd7ca400", "filename": "src/tools/clippy/tests/ui/redundant_pattern_matching.stderr", "status": "modified", "additions": 57, "deletions": 15, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.stderr?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -149,79 +149,103 @@ LL |     let x = if let Some(_) = opt { true } else { false };\n    |             -------^^^^^^^------ help: try this: `if opt.is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:103:20\n+  --> $DIR/redundant_pattern_matching.rs:102:20\n    |\n LL |     let _ = if let Some(_) = gen_opt() {\n    |             -------^^^^^^^------------ help: try this: `if gen_opt().is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:105:19\n+  --> $DIR/redundant_pattern_matching.rs:104:19\n    |\n LL |     } else if let None = gen_opt() {\n    |            -------^^^^------------ help: try this: `if gen_opt().is_none()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:107:19\n+  --> $DIR/redundant_pattern_matching.rs:106:19\n    |\n LL |     } else if let Ok(_) = gen_res() {\n    |            -------^^^^^------------ help: try this: `if gen_res().is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:109:19\n+  --> $DIR/redundant_pattern_matching.rs:108:19\n    |\n LL |     } else if let Err(_) = gen_res() {\n    |            -------^^^^^^------------ help: try this: `if gen_res().is_err()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:142:19\n+  --> $DIR/redundant_pattern_matching.rs:141:19\n    |\n LL |         while let Some(_) = r#try!(result_opt()) {}\n    |         ----------^^^^^^^----------------------- help: try this: `while r#try!(result_opt()).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:143:16\n+  --> $DIR/redundant_pattern_matching.rs:142:16\n    |\n LL |         if let Some(_) = r#try!(result_opt()) {}\n    |         -------^^^^^^^----------------------- help: try this: `if r#try!(result_opt()).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:149:12\n+  --> $DIR/redundant_pattern_matching.rs:148:12\n    |\n LL |     if let Some(_) = m!() {}\n    |     -------^^^^^^^------- help: try this: `if m!().is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:150:15\n+  --> $DIR/redundant_pattern_matching.rs:149:15\n    |\n LL |     while let Some(_) = m!() {}\n    |     ----------^^^^^^^------- help: try this: `while m!().is_some()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:179:12\n+  --> $DIR/redundant_pattern_matching.rs:156:12\n    |\n LL |     if let Ok(_) = Ok::<i32, i32>(42) {}\n    |     -------^^^^^--------------------- help: try this: `if Ok::<i32, i32>(42).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:181:12\n+  --> $DIR/redundant_pattern_matching.rs:158:12\n    |\n LL |     if let Err(_) = Err::<i32, i32>(42) {}\n    |     -------^^^^^^---------------------- help: try this: `if Err::<i32, i32>(42).is_err()`\n \n+error: redundant pattern matching, consider using `is_some()`\n+  --> $DIR/redundant_pattern_matching.rs:160:12\n+   |\n+LL |     if let Some(_) = Some(42) {}\n+   |     -------^^^^^^^----------- help: try this: `if Some(42).is_some()`\n+\n+error: redundant pattern matching, consider using `is_none()`\n+  --> $DIR/redundant_pattern_matching.rs:162:12\n+   |\n+LL |     if let None = None::<()> {}\n+   |     -------^^^^------------- help: try this: `if None::<()>.is_none()`\n+\n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:183:15\n+  --> $DIR/redundant_pattern_matching.rs:164:15\n    |\n LL |     while let Ok(_) = Ok::<i32, i32>(10) {}\n    |     ----------^^^^^--------------------- help: try this: `while Ok::<i32, i32>(10).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:185:15\n+  --> $DIR/redundant_pattern_matching.rs:166:15\n    |\n LL |     while let Err(_) = Ok::<i32, i32>(10) {}\n    |     ----------^^^^^^--------------------- help: try this: `while Ok::<i32, i32>(10).is_err()`\n \n+error: redundant pattern matching, consider using `is_some()`\n+  --> $DIR/redundant_pattern_matching.rs:168:15\n+   |\n+LL |     while let Some(_) = Some(42) {}\n+   |     ----------^^^^^^^----------- help: try this: `while Some(42).is_some()`\n+\n+error: redundant pattern matching, consider using `is_none()`\n+  --> $DIR/redundant_pattern_matching.rs:170:15\n+   |\n+LL |     while let None = None::<()> {}\n+   |     ----------^^^^------------- help: try this: `while None::<()>.is_none()`\n+\n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:187:5\n+  --> $DIR/redundant_pattern_matching.rs:172:5\n    |\n LL | /     match Ok::<i32, i32>(42) {\n LL | |         Ok(_) => true,\n@@ -230,13 +254,31 @@ LL | |     };\n    | |_____^ help: try this: `Ok::<i32, i32>(42).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:192:5\n+  --> $DIR/redundant_pattern_matching.rs:177:5\n    |\n LL | /     match Err::<i32, i32>(42) {\n LL | |         Ok(_) => false,\n LL | |         Err(_) => true,\n LL | |     };\n    | |_____^ help: try this: `Err::<i32, i32>(42).is_err()`\n \n-error: aborting due to 35 previous errors\n+error: redundant pattern matching, consider using `is_some()`\n+  --> $DIR/redundant_pattern_matching.rs:182:5\n+   |\n+LL | /     match Some(42) {\n+LL | |         Some(_) => true,\n+LL | |         None => false,\n+LL | |     };\n+   | |_____^ help: try this: `Some(42).is_some()`\n+\n+error: redundant pattern matching, consider using `is_none()`\n+  --> $DIR/redundant_pattern_matching.rs:187:5\n+   |\n+LL | /     match None::<()> {\n+LL | |         Some(_) => false,\n+LL | |         None => true,\n+LL | |     };\n+   | |_____^ help: try this: `None::<()>.is_none()`\n+\n+error: aborting due to 41 previous errors\n "}, {"sha": "cbc7560ae2d44669ef6ba0f43014e10ce881180e", "filename": "src/tools/miri", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -1 +1 @@\n-Subproject commit 5a15c8a6dd62033f69688f9d1c6eacd674158539\n+Subproject commit cbc7560ae2d44669ef6ba0f43014e10ce881180e"}, {"sha": "e10f72a47b2c427d73011f7024e0d8cd7fb33c01", "filename": "src/tools/unstable-book-gen/src/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/956e06c6c85e918524b67503c4d65c7baf539585/src%2Ftools%2Funstable-book-gen%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e06c6c85e918524b67503c4d65c7baf539585/src%2Ftools%2Funstable-book-gen%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Funstable-book-gen%2Fsrc%2Fmain.rs?ref=956e06c6c85e918524b67503c4d65c7baf539585", "patch": "@@ -27,12 +27,12 @@ macro_rules! t {\n \n fn generate_stub_issue(path: &Path, name: &str, issue: u32) {\n     let mut file = t!(File::create(path));\n-    t!(file.write_fmt(format_args!(include_str!(\"stub-issue.md\"), name = name, issue = issue)));\n+    t!(write!(file, include_str!(\"stub-issue.md\"), name = name, issue = issue));\n }\n \n fn generate_stub_no_issue(path: &Path, name: &str) {\n     let mut file = t!(File::create(path));\n-    t!(file.write_fmt(format_args!(include_str!(\"stub-no-issue.md\"), name = name)));\n+    t!(write!(file, include_str!(\"stub-no-issue.md\"), name = name));\n }\n \n fn set_to_summary_str(set: &BTreeSet<String>, dir: &str) -> String {"}]}