{"sha": "a4a908eafd49236e9b887031e3474fc5148b4e82", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0YTkwOGVhZmQ0OTIzNmU5Yjg4NzAzMWUzNDc0ZmM1MTQ4YjRlODI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-12T00:31:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-12T00:31:48Z"}, "message": "auto merge of #11961 : niftynif/rust/btree, r=brson\n\nI implemented an add method for the btree in progress.  It is intended to be refactored later using an alternative to .clone() that passes the borrow checker, but for now, it works as intended. r? @catamorphism", "tree": {"sha": "73e19fa3b844f8fb87979f9ad092e10f191d20e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73e19fa3b844f8fb87979f9ad092e10f191d20e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4a908eafd49236e9b887031e3474fc5148b4e82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4a908eafd49236e9b887031e3474fc5148b4e82", "html_url": "https://github.com/rust-lang/rust/commit/a4a908eafd49236e9b887031e3474fc5148b4e82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4a908eafd49236e9b887031e3474fc5148b4e82/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "html_url": "https://github.com/rust-lang/rust/commit/0ac6e5afda2a9741d50d6b5c557ee16fee44878f"}, {"sha": "184367093f635dccac64d0fb5d7d534a19555194", "url": "https://api.github.com/repos/rust-lang/rust/commits/184367093f635dccac64d0fb5d7d534a19555194", "html_url": "https://github.com/rust-lang/rust/commit/184367093f635dccac64d0fb5d7d534a19555194"}], "stats": {"total": 500, "additions": 385, "deletions": 115}, "files": [{"sha": "34aee6459a809320256de791b34155c7b48210c4", "filename": "src/libcollections/btree.rs", "status": "modified", "additions": 385, "deletions": 115, "changes": 500, "blob_url": "https://github.com/rust-lang/rust/blob/a4a908eafd49236e9b887031e3474fc5148b4e82/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a908eafd49236e9b887031e3474fc5148b4e82/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=a4a908eafd49236e9b887031e3474fc5148b4e82", "patch": "@@ -14,12 +14,12 @@\n //! Starting implementation of a btree for rust.\n //! Structure inspired by github user davidhalperin's gist.\n \n-#[allow(dead_code)];\n-#[allow(unused_variable)];\n-\n ///A B-tree contains a root node (which contains a vector of elements),\n ///a length (the height of the tree), and lower and upper bounds on the\n ///number of elements that a given node can contain.\n+\n+use std::vec::OwnedVector;\n+\n #[allow(missing_doc)]\n pub struct BTree<K, V> {\n     priv root: Node<K, V>,\n@@ -28,14 +28,10 @@ pub struct BTree<K, V> {\n     priv upper_bound: uint\n }\n \n-//We would probably want to remove the dependence on the Clone trait in the future.\n-//It is here as a crutch to ensure values can be passed around through the tree's nodes\n-//especially during insertions and deletions.\n-//Using the swap or replace methods is one option for replacing dependence on Clone, or\n-//changing the way in which the BTree is stored could also potentially work.\n impl<K: TotalOrd, V> BTree<K, V> {\n \n     ///Returns new BTree with root node (leaf) and user-supplied lower bound\n+    ///The lower bound applies to every node except the root node.\n     pub fn new(k: K, v: V, lb: uint) -> BTree<K, V> {\n         BTree {\n             root: Node::new_leaf(~[LeafElt::new(k, v)]),\n@@ -57,22 +53,34 @@ impl<K: TotalOrd, V> BTree<K, V> {\n             upper_bound: 2 * lb\n         }\n     }\n-\n-\n-    ///Stub for add method in progress.\n-    pub fn add(self, k: K, v: V) -> BTree<K, V> {\n-        //replace(&self.root,self.root.add(k, v));\n-        return BTree::new(k, v, 2);\n-    }\n }\n \n-impl<K: TotalOrd, V: Clone> BTree<K, V> {\n-\n+//We would probably want to remove the dependence on the Clone trait in the future.\n+//It is here as a crutch to ensure values can be passed around through the tree's nodes\n+//especially during insertions and deletions.\n+impl<K: Clone + TotalOrd, V: Clone> BTree<K, V> {\n     ///Returns the value of a given key, which may not exist in the tree.\n     ///Calls the root node's get method.\n     pub fn get(self, k: K) -> Option<V> {\n         return self.root.get(k);\n     }\n+\n+    ///An insert method that uses the clone() feature for support.\n+    pub fn insert(mut self, k: K, v: V) -> BTree<K, V> {\n+        let (a, b) = self.root.clone().insert(k, v, self.upper_bound.clone());\n+        if b {\n+            match a.clone() {\n+                LeafNode(leaf) => {\n+                    self.root = Node::new_leaf(leaf.clone().elts);\n+                }\n+                BranchNode(branch) => {\n+                    self.root = Node::new_branch(branch.clone().elts,\n+                                                 branch.clone().rightmost_child);\n+                }\n+            }\n+        }\n+        self\n+    }\n }\n \n impl<K: Clone + TotalOrd, V: Clone> Clone for BTree<K, V> {\n@@ -120,34 +128,36 @@ enum Node<K, V> {\n \n //Node functions/methods\n impl<K: TotalOrd, V> Node<K, V> {\n-\n-    ///Differentiates between leaf and branch nodes.\n-    fn is_leaf(&self) -> bool {\n-        match self{\n-            &LeafNode(..) => true,\n-            &BranchNode(..) => false\n-        }\n-    }\n-\n     ///Creates a new leaf node given a vector of elements.\n     fn new_leaf(vec: ~[LeafElt<K, V>]) -> Node<K,V> {\n         LeafNode(Leaf::new(vec))\n     }\n \n-\n     ///Creates a new branch node given a vector of an elements and a pointer to a rightmost child.\n     fn new_branch(vec: ~[BranchElt<K, V>], right: ~Node<K, V>) -> Node<K, V> {\n         BranchNode(Branch::new(vec, right))\n     }\n \n-    ///A placeholder/stub for add\n-    ///Currently returns a leaf node with a single value (the added one)\n-    fn add(self, k: K, v: V) -> Node<K, V> {\n-        return Node::new_leaf(~[LeafElt::new(k, v)]);\n+    ///Determines whether the given Node contains a Branch or a Leaf.\n+    ///Used in testing.\n+    fn is_leaf(&self) -> bool {\n+        match self {\n+            &LeafNode(..) => true,\n+            &BranchNode(..) => false\n+        }\n     }\n+\n+    ///A binary search function for Nodes.\n+    ///Calls either the Branch's or the Leaf's bsearch function.\n+    fn bsearch_node(&self, k: K) -> Option<uint> {\n+         match self {\n+             &LeafNode(ref leaf) => leaf.bsearch_leaf(k),\n+             &BranchNode(ref branch) => branch.bsearch_branch(k)\n+         }\n+     }\n }\n \n-impl<K: TotalOrd, V: Clone> Node<K, V> {\n+impl<K: Clone + TotalOrd, V: Clone> Node<K, V> {\n     ///Returns the corresponding value to the provided key.\n     ///get() is called in different ways on a branch or a leaf.\n     fn get(&self, k: K) -> Option<V> {\n@@ -156,6 +166,14 @@ impl<K: TotalOrd, V: Clone> Node<K, V> {\n             BranchNode(ref branch) => return branch.get(k)\n         }\n     }\n+\n+    ///Matches on the Node, then performs and returns the appropriate insert method.\n+    fn insert(self, k: K, v: V, ub: uint) -> (Node<K, V>, bool) {\n+        match self {\n+            LeafNode(leaf) => leaf.insert(k, v, ub),\n+            BranchNode(branch) => branch.insert(k, v, ub)\n+        }\n+    }\n }\n \n impl<K: Clone + TotalOrd, V: Clone> Clone for Node<K, V> {\n@@ -174,20 +192,23 @@ impl<K: Clone + TotalOrd, V: Clone> Clone for Node<K, V> {\n }\n \n impl<K: TotalOrd, V: TotalEq> TotalEq for Node<K, V> {\n-    ///Returns whether two nodes are equal\n+    ///Returns whether two nodes are equal based on the keys of each element.\n+    ///Two nodes are equal if all of their keys are the same.\n     fn equals(&self, other: &Node<K, V>) -> bool{\n         match *self{\n             BranchNode(ref branch) => {\n-                match *other{\n+                if other.is_leaf() {\n+                    return false;\n+                }\n+                match *other {\n                     BranchNode(ref branch2) => branch.cmp(branch2) == Equal,\n-                    LeafNode(ref leaf) => false\n+                    LeafNode(..) => false\n                 }\n             }\n-\n             LeafNode(ref leaf) => {\n-                match *other{\n+                match *other {\n                     LeafNode(ref leaf2) => leaf.cmp(leaf2) == Equal,\n-                    BranchNode(ref branch) => false\n+                    BranchNode(..) => false\n                 }\n             }\n         }\n@@ -216,7 +237,9 @@ impl<K: TotalOrd, V: TotalEq> TotalOrd for Node<K, V> {\n \n impl<K: ToStr + TotalOrd, V: ToStr> ToStr for Node<K, V> {\n     ///Returns a string representation of a Node.\n-    ///The Branch's to_str() is not implemented yet.\n+    ///Will iterate over the Node and show \"Key: x, value: y, child: () // \"\n+    ///for all elements in the Node. \"Child\" only exists if the Node contains\n+    ///a branch.\n     fn to_str(&self) -> ~str {\n         match *self {\n             LeafNode(ref leaf) => leaf.to_str(),\n@@ -247,15 +270,59 @@ impl<K: TotalOrd, V> Leaf<K, V> {\n         }\n     }\n \n-    ///Placeholder for add method in progress.\n-    ///Currently returns a new Leaf containing a single LeafElt.\n-    fn add(&self, k: K, v: V) -> Node<K, V> {\n-        return Node::new_leaf(~[LeafElt::new(k, v)]);\n+    ///Searches a leaf for a spot for a new element using a binary search.\n+    ///Returns None if the element is already in the vector.\n+    fn bsearch_leaf(&self, k: K) -> Option<uint> {\n+        let mut high: uint = self.elts.len();\n+        let mut low: uint = 0;\n+        let mut midpoint: uint = (high - low) / 2 ;\n+        if midpoint == high {\n+            midpoint = 0;\n+        }\n+        loop {\n+            let order = self.elts[midpoint].key.cmp(&k);\n+            match order {\n+                Equal => {\n+                    return None;\n+                }\n+                Greater => {\n+                    if midpoint > 0 {\n+                        if self.elts[midpoint - 1].key.cmp(&k) == Less {\n+                            return Some(midpoint);\n+                        }\n+                        else {\n+                            let tmp = midpoint;\n+                            midpoint = midpoint / 2;\n+                            high = tmp;\n+                            continue;\n+                        }\n+                    }\n+                    else {\n+                        return Some(0);\n+                    }\n+                }\n+                Less => {\n+                    if midpoint + 1 < self.elts.len() {\n+                        if self.elts[midpoint + 1].key.cmp(&k) == Greater {\n+                            return Some(midpoint);\n+                        }\n+                        else {\n+                            let tmp = midpoint;\n+                            midpoint = (high + low) / 2;\n+                            low = tmp;\n+                        }\n+                    }\n+                    else {\n+                        return Some(self.elts.len());\n+                    }\n+                }\n+            }\n+        }\n     }\n-\n }\n \n-impl<K: TotalOrd, V: Clone> Leaf<K, V> {\n+\n+impl<K: Clone + TotalOrd, V: Clone> Leaf<K, V> {\n     ///Returns the corresponding value to the supplied key.\n     fn get(&self, k: K) -> Option<V> {\n         for s in self.elts.iter() {\n@@ -267,6 +334,43 @@ impl<K: TotalOrd, V: Clone> Leaf<K, V> {\n         }\n         return None;\n     }\n+\n+    ///Uses clone() to facilitate inserting new elements into a tree.\n+    fn insert(mut self, k: K, v: V, ub: uint) -> (Node<K, V>, bool) {\n+        let to_insert = LeafElt::new(k, v);\n+        let index: Option<uint> = self.bsearch_leaf(to_insert.clone().key);\n+        //Check index to see whether we actually inserted the element into the vector.\n+        match index {\n+            //If the index is None, the new element already exists in the vector.\n+            None => {\n+                return (Node::new_leaf(self.clone().elts), false);\n+            }\n+            //If there is an index, insert at that index.\n+            _ => {\n+                if index.unwrap() >= self.elts.len() {\n+                    self.elts.push(to_insert.clone());\n+                }\n+                else {\n+                    self.elts.insert(index.unwrap(), to_insert.clone());\n+                }\n+            }\n+        }\n+        //If we have overfilled the vector (by making its size greater than the\n+        //upper bound), we return a new Branch with one element and two children.\n+        if self.elts.len() > ub {\n+            let midpoint_opt = self.elts.remove(ub / 2);\n+            let midpoint = midpoint_opt.unwrap();\n+            let (left_leaf, right_leaf) = self.elts.partition(|le|\n+                                                              le.key.cmp(&midpoint.key.clone())\n+                                                              == Less);\n+            let branch_return = Node::new_branch(~[BranchElt::new(midpoint.key.clone(),\n+                                                                  midpoint.value.clone(),\n+                                                             ~Node::new_leaf(left_leaf))],\n+                                            ~Node::new_leaf(right_leaf));\n+            return (branch_return, true);\n+        }\n+        (Node::new_leaf(self.elts.clone()), true)\n+    }\n }\n \n impl<K: Clone + TotalOrd, V: Clone> Clone for Leaf<K, V> {\n@@ -314,13 +418,56 @@ impl<K: TotalOrd, V> Branch<K, V> {\n         }\n     }\n \n-    ///Placeholder for add method in progress\n-    fn add(&self, k: K, v: V) -> Node<K, V> {\n-        return Node::new_leaf(~[LeafElt::new(k, v)]);\n+    fn bsearch_branch(&self, k: K) -> Option<uint> {\n+        let mut midpoint: uint = self.elts.len() / 2;\n+        let mut high: uint = self.elts.len();\n+        let mut low: uint = 0u;\n+        if midpoint == high {\n+            midpoint = 0u;\n+        }\n+        loop {\n+            let order = self.elts[midpoint].key.cmp(&k);\n+            match order {\n+                Equal => {\n+                    return None;\n+                }\n+                Greater => {\n+                    if midpoint > 0 {\n+                        if self.elts[midpoint - 1].key.cmp(&k) == Less {\n+                            return Some(midpoint);\n+                        }\n+                        else {\n+                            let tmp = midpoint;\n+                            midpoint = (midpoint - low) / 2;\n+                            high = tmp;\n+                            continue;\n+                        }\n+                    }\n+                    else {\n+                        return Some(0);\n+                    }\n+                }\n+                Less => {\n+                    if midpoint + 1 < self.elts.len() {\n+                        if self.elts[midpoint + 1].key.cmp(&k) == Greater {\n+                            return Some(midpoint);\n+                        }\n+                        else {\n+                            let tmp = midpoint;\n+                            midpoint = (high - midpoint) / 2;\n+                            low = tmp;\n+                        }\n+                    }\n+                    else {\n+                        return Some(self.elts.len());\n+                    }\n+                }\n+            }\n+        }\n     }\n }\n \n-impl<K: TotalOrd, V: Clone> Branch<K, V> {\n+impl<K: Clone + TotalOrd, V: Clone> Branch<K, V> {\n     ///Returns the corresponding value to the supplied key.\n     ///If the key is not there, find the child that might hold it.\n     fn get(&self, k: K) -> Option<V> {\n@@ -334,6 +481,114 @@ impl<K: TotalOrd, V: Clone> Branch<K, V> {\n         }\n         self.rightmost_child.get(k)\n     }\n+\n+    ///An insert method that uses .clone() for support.\n+    fn insert(mut self, k: K, v: V, ub: uint) -> (Node<K, V>, bool) {\n+        let mut new_branch = Node::new_branch(self.clone().elts, self.clone().rightmost_child);\n+        let mut outcome = false;\n+        let index: Option<uint> = new_branch.bsearch_node(k.clone());\n+        //First, find which path down the tree will lead to the appropriate leaf\n+        //for the key-value pair.\n+        match index.clone() {\n+            None => {\n+                return (Node::new_branch(self.clone().elts,\n+                                         self.clone().rightmost_child),\n+                        outcome);\n+            }\n+            _ => {\n+                if index.unwrap() == self.elts.len() {\n+                    let new_outcome = self.clone().rightmost_child.insert(k.clone(),\n+                                                                       v.clone(),\n+                                                                       ub.clone());\n+                    new_branch = new_outcome.clone().n0();\n+                    outcome = new_outcome.n1();\n+                }\n+                else {\n+                    let new_outcome = self.clone().elts[index.unwrap()].left.insert(k.clone(),\n+                                                                                 v.clone(),\n+                                                                                 ub.clone());\n+                    new_branch = new_outcome.clone().n0();\n+                    outcome = new_outcome.n1();\n+                }\n+                //Check to see whether a branch or a leaf was returned from the\n+                //tree traversal.\n+                match new_branch.clone() {\n+                    //If we have a leaf, we do not need to resize the tree,\n+                    //so we can return false.\n+                    LeafNode(..) => {\n+                        if index.unwrap() == self.elts.len() {\n+                            self.rightmost_child = ~new_branch.clone();\n+                        }\n+                        else {\n+                            self.elts[index.unwrap()].left = ~new_branch.clone();\n+                        }\n+                        return (Node::new_branch(self.clone().elts,\n+                                                 self.clone().rightmost_child),\n+                                true);\n+                    }\n+                    //If we have a branch, we might need to refactor the tree.\n+                    BranchNode(..) => {}\n+                }\n+            }\n+        }\n+        //If we inserted something into the tree, do the following:\n+        if outcome {\n+            match new_branch.clone() {\n+                //If we have a new leaf node, integrate it into the current branch\n+                //and return it, saying we have inserted a new element.\n+                LeafNode(..) => {\n+                    if index.unwrap() == self.elts.len() {\n+                        self.rightmost_child = ~new_branch;\n+                    }\n+                    else {\n+                        self.elts[index.unwrap()].left = ~new_branch;\n+                    }\n+                    return (Node::new_branch(self.clone().elts,\n+                                             self.clone().rightmost_child),\n+                            true);\n+                }\n+                //If we have a new branch node, attempt to insert it into the tree\n+                //as with the key-value pair, then check to see if the node is overfull.\n+                BranchNode(branch) => {\n+                    let new_elt = branch.clone().elts[0];\n+                    let new_elt_index = self.bsearch_branch(new_elt.clone().key);\n+                    match new_elt_index {\n+                        None => {\n+                            return (Node::new_branch(self.clone().elts,\n+                                                     self.clone().rightmost_child),\n+                                    false);\n+                            }\n+                        _ => {\n+                            self.elts.insert(new_elt_index.unwrap(), new_elt);\n+                            if new_elt_index.unwrap() + 1 >= self.elts.len() {\n+                                self.rightmost_child = branch.clone().rightmost_child;\n+                            }\n+                            else {\n+                                self.elts[new_elt_index.unwrap() + 1].left =\n+                                    branch.clone().rightmost_child;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            //If the current node is overfilled, create a new branch with one element\n+            //and two children.\n+            if self.elts.len() > ub {\n+                let midpoint = self.elts.remove(ub / 2).unwrap();\n+                let (new_left, new_right) = self.clone().elts.partition(|le|\n+                                                                midpoint.key.cmp(&le.key)\n+                                                                        == Greater);\n+                new_branch = Node::new_branch(\n+                    ~[BranchElt::new(midpoint.clone().key,\n+                                     midpoint.clone().value,\n+                                     ~Node::new_branch(new_left,\n+                                                       midpoint.clone().left))],\n+                    ~Node::new_branch(new_right, self.clone().rightmost_child));\n+                return (new_branch, true);\n+            }\n+        }\n+        (Node::new_branch(self.elts.clone(), self.rightmost_child.clone()), outcome)\n+    }\n }\n \n impl<K: Clone + TotalOrd, V: Clone> Clone for Branch<K, V> {\n@@ -368,7 +623,7 @@ impl<K: ToStr + TotalOrd, V: ToStr> ToStr for Branch<K, V> {\n     fn to_str(&self) -> ~str {\n         let mut ret = self.elts.iter().map(|s| s.to_str()).to_owned_vec().connect(\" // \");\n         ret.push_str(\" // \");\n-        ret.push_str(self.rightmost_child.to_str());\n+        ret.push_str(\"rightmost child: (\"+ self.rightmost_child.to_str() +\") \");\n         ret\n     }\n }\n@@ -379,9 +634,9 @@ struct LeafElt<K, V> {\n     value: V\n }\n \n-//A BranchElt has a left child in addition to a key-value pair.\n+//A BranchElt has a left child in insertition to a key-value pair.\n struct BranchElt<K, V> {\n-    left: Node<K, V>,\n+    left: ~Node<K, V>,\n     key: K,\n     value: V\n }\n@@ -394,36 +649,6 @@ impl<K: TotalOrd, V> LeafElt<K, V> {\n             value: v\n         }\n     }\n-\n-    ///Compares another LeafElt against itself and determines whether\n-    ///the original LeafElt's key is less than the other one's key.\n-    fn less_than(&self, other: LeafElt<K, V>) -> bool {\n-        let order = self.key.cmp(&other.key);\n-        match order {\n-            Less => true,\n-            _ => false\n-        }\n-    }\n-\n-    ///Compares another LeafElt against itself and determines whether\n-    ///the original LeafElt's key is greater than the other one's key.\n-    fn greater_than(&self, other: LeafElt<K, V>) -> bool {\n-        let order = self.key.cmp(&other.key);\n-        match order {\n-            Greater => true,\n-            _ => false\n-        }\n-    }\n-\n-    ///Takes a key and determines whether its own key and the supplied key\n-    ///are the same.\n-    fn has_key(&self, other: K) -> bool {\n-        let order = self.key.cmp(&other);\n-        match order {\n-            Equal => true,\n-            _ => false\n-        }\n-    }\n }\n \n impl<K: Clone + TotalOrd, V: Clone> Clone for LeafElt<K, V> {\n@@ -457,19 +682,13 @@ impl<K: ToStr + TotalOrd, V: ToStr> ToStr for LeafElt<K, V> {\n \n impl<K: TotalOrd, V> BranchElt<K, V> {\n     ///Creates a new BranchElt from a supplied key, value, and left child.\n-    fn new(k: K, v: V, n: Node<K, V>) -> BranchElt<K, V> {\n+    fn new(k: K, v: V, n: ~Node<K, V>) -> BranchElt<K, V> {\n         BranchElt {\n             left: n,\n             key: k,\n             value: v\n         }\n     }\n-\n-    ///Placeholder for add method in progress.\n-    ///Overall implementation will determine the actual return value of this method.\n-    fn add(&self, k: K, v: V) -> LeafElt<K, V> {\n-        return LeafElt::new(k, v);\n-    }\n }\n \n \n@@ -500,54 +719,105 @@ impl<K: ToStr + TotalOrd, V: ToStr> ToStr for BranchElt<K, V> {\n     ///Returns string containing key, value, and child (which should recur to a leaf)\n     ///Consider changing in future to be more readable.\n     fn to_str(&self) -> ~str {\n-        format!(\"Key: {}, value: {}, child: {};\",\n+        format!(\"Key: {}, value: {}, (child: {})\",\n             self.key.to_str(), self.value.to_str(), self.left.to_str())\n     }\n }\n \n #[cfg(test)]\n mod test_btree {\n \n-    use super::{BTree, LeafElt};\n+    use super::{BTree, Node, LeafElt};\n \n-    //Tests the functionality of the add methods (which are unfinished).\n-    /*#[test]\n-    fn add_test(){\n+    //Tests the functionality of the insert methods (which are unfinished).\n+    #[test]\n+    fn insert_test_one() {\n         let b = BTree::new(1, ~\"abc\", 2);\n-        let is_add = b.add(2, ~\"xyz\");\n-        assert!(is_add);\n-    }*/\n+        let is_insert = b.insert(2, ~\"xyz\");\n+        //println!(\"{}\", is_insert.clone().to_str());\n+        assert!(is_insert.root.is_leaf());\n+    }\n \n-    //Tests the functionality of the get method.\n     #[test]\n-    fn get_test() {\n+    fn insert_test_two() {\n+        let leaf_elt_1 = LeafElt::new(1, ~\"aaa\");\n+        let leaf_elt_2 = LeafElt::new(2, ~\"bbb\");\n+        let leaf_elt_3 = LeafElt::new(3, ~\"ccc\");\n+        let n = Node::new_leaf(~[leaf_elt_1, leaf_elt_2, leaf_elt_3]);\n+        let b = BTree::new_with_node_len(n, 3, 2);\n+        //println!(\"{}\", b.clone().insert(4, ~\"ddd\").to_str());\n+        assert!(b.insert(4, ~\"ddd\").root.is_leaf());\n+    }\n+\n+    #[test]\n+    fn insert_test_three() {\n+        let leaf_elt_1 = LeafElt::new(1, ~\"aaa\");\n+        let leaf_elt_2 = LeafElt::new(2, ~\"bbb\");\n+        let leaf_elt_3 = LeafElt::new(3, ~\"ccc\");\n+        let leaf_elt_4 = LeafElt::new(4, ~\"ddd\");\n+        let n = Node::new_leaf(~[leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4]);\n+        let b = BTree::new_with_node_len(n, 3, 2);\n+        //println!(\"{}\", b.clone().insert(5, ~\"eee\").to_str());\n+        assert!(!b.insert(5, ~\"eee\").root.is_leaf());\n+    }\n+\n+    #[test]\n+    fn insert_test_four() {\n+        let leaf_elt_1 = LeafElt::new(1, ~\"aaa\");\n+        let leaf_elt_2 = LeafElt::new(2, ~\"bbb\");\n+        let leaf_elt_3 = LeafElt::new(3, ~\"ccc\");\n+        let leaf_elt_4 = LeafElt::new(4, ~\"ddd\");\n+        let n = Node::new_leaf(~[leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4]);\n+        let mut b = BTree::new_with_node_len(n, 3, 2);\n+        b = b.clone().insert(5, ~\"eee\");\n+        b = b.clone().insert(6, ~\"fff\");\n+        b = b.clone().insert(7, ~\"ggg\");\n+        b = b.clone().insert(8, ~\"hhh\");\n+        b = b.clone().insert(0, ~\"omg\");\n+        //println!(\"{}\", b.clone().to_str());\n+        assert!(!b.root.is_leaf());\n+    }\n+\n+    #[test]\n+    fn bsearch_test_one() {\n         let b = BTree::new(1, ~\"abc\", 2);\n-        let val = b.get(1);\n-        assert_eq!(val, Some(~\"abc\"));\n+        assert_eq!(Some(1), b.root.bsearch_node(2));\n     }\n \n-    //Tests the LeafElt's less_than() method.\n     #[test]\n-    fn leaf_lt() {\n-        let l1 = LeafElt::new(1, ~\"abc\");\n-        let l2 = LeafElt::new(2, ~\"xyz\");\n-        assert!(l1.less_than(l2));\n+    fn bsearch_test_two() {\n+        let b = BTree::new(1, ~\"abc\", 2);\n+        assert_eq!(Some(0), b.root.bsearch_node(0));\n     }\n \n+    #[test]\n+    fn bsearch_test_three() {\n+        let leaf_elt_1 = LeafElt::new(1, ~\"aaa\");\n+        let leaf_elt_2 = LeafElt::new(2, ~\"bbb\");\n+        let leaf_elt_3 = LeafElt::new(4, ~\"ccc\");\n+        let leaf_elt_4 = LeafElt::new(5, ~\"ddd\");\n+        let n = Node::new_leaf(~[leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4]);\n+        let b = BTree::new_with_node_len(n, 3, 2);\n+        assert_eq!(Some(2), b.root.bsearch_node(3));\n+    }\n \n-    //Tests the LeafElt's greater_than() method.\n     #[test]\n-    fn leaf_gt() {\n-        let l1 = LeafElt::new(1, ~\"abc\");\n-        let l2 = LeafElt::new(2, ~\"xyz\");\n-        assert!(l2.greater_than(l1));\n+    fn bsearch_test_four() {\n+        let leaf_elt_1 = LeafElt::new(1, ~\"aaa\");\n+        let leaf_elt_2 = LeafElt::new(2, ~\"bbb\");\n+        let leaf_elt_3 = LeafElt::new(4, ~\"ccc\");\n+        let leaf_elt_4 = LeafElt::new(5, ~\"ddd\");\n+        let n = Node::new_leaf(~[leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4]);\n+        let b = BTree::new_with_node_len(n, 3, 2);\n+        assert_eq!(Some(4), b.root.bsearch_node(800));\n     }\n \n-    //Tests the LeafElt's has_key() method.\n+    //Tests the functionality of the get method.\n     #[test]\n-    fn leaf_hk() {\n-        let l1 = LeafElt::new(1, ~\"abc\");\n-        assert!(l1.has_key(1));\n+    fn get_test() {\n+        let b = BTree::new(1, ~\"abc\", 2);\n+        let val = b.get(1);\n+        assert_eq!(val, Some(~\"abc\"));\n     }\n \n     //Tests the BTree's clone() method."}]}