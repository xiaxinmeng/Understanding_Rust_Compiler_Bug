{"sha": "3fb80e33a89709e3457ad0943f5847eb5800d620", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmYjgwZTMzYTg5NzA5ZTM0NTdhZDA5NDNmNTg0N2ViNTgwMGQ2MjA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-02T09:16:30Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-02T10:16:26Z"}, "message": "thread revision identifier around in test output", "tree": {"sha": "8a4491c3d84637f510b03fdf6fc978911a246f4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a4491c3d84637f510b03fdf6fc978911a246f4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fb80e33a89709e3457ad0943f5847eb5800d620", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fb80e33a89709e3457ad0943f5847eb5800d620", "html_url": "https://github.com/rust-lang/rust/commit/3fb80e33a89709e3457ad0943f5847eb5800d620", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fb80e33a89709e3457ad0943f5847eb5800d620/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cffa9b4e3f8a733cf77de844489afa2ccaef5d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cffa9b4e3f8a733cf77de844489afa2ccaef5d0", "html_url": "https://github.com/rust-lang/rust/commit/4cffa9b4e3f8a733cf77de844489afa2ccaef5d0"}], "stats": {"total": 225, "additions": 134, "deletions": 91}, "files": [{"sha": "0987e6a20dbff8faaf150a1a71d931966312e371", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 134, "deletions": 91, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/3fb80e33a89709e3457ad0943f5847eb5800d620/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb80e33a89709e3457ad0943f5847eb5800d620/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=3fb80e33a89709e3457ad0943f5847eb5800d620", "patch": "@@ -103,28 +103,30 @@ fn run_cfail_test_revision(config: &Config,\n     let proc_res = compile_test(config, props, testpaths);\n \n     if proc_res.status.success() {\n-        fatal_proc_rec(&format!(\"{} test compiled successfully!\", config.mode)[..],\n-                      &proc_res);\n+        fatal_proc_rec(\n+            revision,\n+            &format!(\"{} test compiled successfully!\", config.mode)[..],\n+            &proc_res);\n     }\n \n-    check_correct_failure_status(&proc_res);\n+    check_correct_failure_status(revision, &proc_res);\n \n     if proc_res.status.success() {\n-        fatal(\"process did not return an error status\");\n+        fatal(revision, \"process did not return an error status\");\n     }\n \n     let output_to_check = get_output(props, &proc_res);\n     let expected_errors = errors::load_errors(&testpaths.file, revision);\n     if !expected_errors.is_empty() {\n         if !props.error_patterns.is_empty() {\n-            fatal(\"both error pattern and expected errors specified\");\n+            fatal(revision, \"both error pattern and expected errors specified\");\n         }\n-        check_expected_errors(expected_errors, testpaths, &proc_res);\n+        check_expected_errors(revision, expected_errors, testpaths, &proc_res);\n     } else {\n-        check_error_patterns(props, testpaths, &output_to_check, &proc_res);\n+        check_error_patterns(revision, props, testpaths, &output_to_check, &proc_res);\n     }\n-    check_no_compiler_crash(&proc_res);\n-    check_forbid_output(props, &output_to_check, &proc_res);\n+    check_no_compiler_crash(revision, &proc_res);\n+    check_forbid_output(revision, props, &output_to_check, &proc_res);\n }\n \n fn run_rfail_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n@@ -134,31 +136,32 @@ fn run_rfail_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n fn run_rfail_test_revision(config: &Config,\n                            props: &TestProps,\n                            testpaths: &TestPaths,\n-                           _revision: Option<&str>) {\n+                           revision: Option<&str>) {\n     let proc_res = compile_test(config, props, testpaths);\n \n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"compilation failed!\", &proc_res);\n+        fatal_proc_rec(revision, \"compilation failed!\", &proc_res);\n     }\n \n     let proc_res = exec_compiled_test(config, props, testpaths);\n \n     // The value our Makefile configures valgrind to return on failure\n     const VALGRIND_ERR: i32 = 100;\n     if proc_res.status.code() == Some(VALGRIND_ERR) {\n-        fatal_proc_rec(\"run-fail test isn't valgrind-clean!\", &proc_res);\n+        fatal_proc_rec(revision, \"run-fail test isn't valgrind-clean!\", &proc_res);\n     }\n \n     let output_to_check = get_output(props, &proc_res);\n-    check_correct_failure_status(&proc_res);\n-    check_error_patterns(props, testpaths, &output_to_check, &proc_res);\n+    check_correct_failure_status(revision, &proc_res);\n+    check_error_patterns(revision, props, testpaths, &output_to_check, &proc_res);\n }\n \n-fn check_correct_failure_status(proc_res: &ProcRes) {\n+fn check_correct_failure_status(revision: Option<&str>, proc_res: &ProcRes) {\n     // The value the rust runtime returns on failure\n     const RUST_ERR: i32 = 101;\n     if proc_res.status.code() != Some(RUST_ERR) {\n         fatal_proc_rec(\n+            revision,\n             &format!(\"failure produced the wrong error: {}\",\n                      proc_res.status),\n             proc_res);\n@@ -172,22 +175,22 @@ fn run_rpass_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n fn run_rpass_test_revision(config: &Config,\n                            props: &TestProps,\n                            testpaths: &TestPaths,\n-                           _revision: Option<&str>) {\n+                           revision: Option<&str>) {\n     let proc_res = compile_test(config, props, testpaths);\n \n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"compilation failed!\", &proc_res);\n+        fatal_proc_rec(revision, \"compilation failed!\", &proc_res);\n     }\n \n     let proc_res = exec_compiled_test(config, props, testpaths);\n \n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"test run failed!\", &proc_res);\n+        fatal_proc_rec(revision, \"test run failed!\", &proc_res);\n     }\n }\n \n fn run_valgrind_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n-    assert!(props.revisions.is_empty(), \"revisions not relevant to rpass tests\");\n+    assert!(props.revisions.is_empty(), \"revisions not relevant here\");\n \n     if config.valgrind_path.is_none() {\n         assert!(!config.force_valgrind);\n@@ -197,19 +200,21 @@ fn run_valgrind_test(config: &Config, props: &TestProps, testpaths: &TestPaths)\n     let mut proc_res = compile_test(config, props, testpaths);\n \n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"compilation failed!\", &proc_res);\n+        fatal_proc_rec(None, \"compilation failed!\", &proc_res);\n     }\n \n     let mut new_config = config.clone();\n     new_config.runtool = new_config.valgrind_path.clone();\n     proc_res = exec_compiled_test(&new_config, props, testpaths);\n \n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"test run failed!\", &proc_res);\n+        fatal_proc_rec(None, \"test run failed!\", &proc_res);\n     }\n }\n \n fn run_pretty_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n+    assert!(props.revisions.is_empty(), \"revisions not relevant here\");\n+\n     if props.pp_exact.is_some() {\n         logv(config, \"testing for exact pretty-printing\".to_owned());\n     } else {\n@@ -233,8 +238,9 @@ fn run_pretty_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n                                     &props.pretty_mode);\n \n         if !proc_res.status.success() {\n-            fatal_proc_rec(&format!(\"pretty-printing failed in round {}\", round),\n-                          &proc_res);\n+            fatal_proc_rec(None,\n+                           &format!(\"pretty-printing failed in round {}\", round),\n+                           &proc_res);\n         }\n \n         let ProcRes{ stdout, .. } = proc_res;\n@@ -269,21 +275,23 @@ fn run_pretty_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n     let proc_res = typecheck_source(config, props, testpaths, actual);\n \n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"pretty-printed source does not typecheck\", &proc_res);\n+        fatal_proc_rec(None, \"pretty-printed source does not typecheck\", &proc_res);\n     }\n     if !props.pretty_expanded { return }\n \n     // additionally, run `--pretty expanded` and try to build it.\n     let proc_res = print_source(config, props, testpaths, srcs[round].clone(), \"expanded\");\n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"pretty-printing (expanded) failed\", &proc_res);\n+        fatal_proc_rec(None, \"pretty-printing (expanded) failed\", &proc_res);\n     }\n \n     let ProcRes{ stdout: expanded_src, .. } = proc_res;\n     let proc_res = typecheck_source(config, props, testpaths, expanded_src);\n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"pretty-printed source (expanded) does not typecheck\",\n-                      &proc_res);\n+        fatal_proc_rec(\n+            None,\n+            \"pretty-printed source (expanded) does not typecheck\",\n+            &proc_res);\n     }\n \n     return;\n@@ -329,7 +337,7 @@ fn run_pretty_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n \n     fn compare_source(expected: &str, actual: &str) {\n         if expected != actual {\n-            error(\"pretty-printed source does not match expected source\");\n+            error(None, \"pretty-printed source does not match expected source\");\n             println!(\"\\n\\\n expected:\\n\\\n ------------------------------------------\\n\\\n@@ -377,6 +385,8 @@ actual:\\n\\\n }\n \n fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n+    assert!(props.revisions.is_empty(), \"revisions not relevant here\");\n+\n     let mut config = Config {\n         target_rustcflags: cleanup_debug_info_options(&config.target_rustcflags),\n         host_rustcflags: cleanup_debug_info_options(&config.host_rustcflags),\n@@ -394,7 +404,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testpaths: &TestPa\n     // compile test file (it should have 'compile-flags:-g' in the header)\n     let compiler_run_result = compile_test(config, props, testpaths);\n     if !compiler_run_result.status.success() {\n-        fatal_proc_rec(\"compilation failed!\", &compiler_run_result);\n+        fatal_proc_rec(None, \"compilation failed!\", &compiler_run_result);\n     }\n \n     let exe_file = make_exe_name(config, testpaths);\n@@ -486,7 +496,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testpaths: &TestPa\n \n             let tool_path = match config.android_cross_path.to_str() {\n                 Some(x) => x.to_owned(),\n-                None => fatal(\"cannot find android cross path\")\n+                None => fatal(None, \"cannot find android cross path\")\n             };\n \n             let debugger_script = make_out_name(config, testpaths, \"debugger.script\");\n@@ -625,7 +635,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testpaths: &TestPa\n     }\n \n     if !debugger_run_result.status.success() {\n-        fatal(\"gdb failed to execute\");\n+        fatal(None, \"gdb failed to execute\");\n     }\n \n     check_debugger_output(&debugger_run_result, &check_lines);\n@@ -645,8 +655,10 @@ fn find_rust_src_root(config: &Config) -> Option<PathBuf> {\n }\n \n fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n+    assert!(props.revisions.is_empty(), \"revisions not relevant here\");\n+\n     if config.lldb_python_dir.is_none() {\n-        fatal(\"Can't run LLDB test because LLDB's python path is not set.\");\n+        fatal(None, \"Can't run LLDB test because LLDB's python path is not set.\");\n     }\n \n     let mut config = Config {\n@@ -660,7 +672,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testpaths: &TestP\n     // compile test file (it should have 'compile-flags:-g' in the header)\n     let compile_result = compile_test(config, props, testpaths);\n     if !compile_result.status.success() {\n-        fatal_proc_rec(\"compilation failed!\", &compile_result);\n+        fatal_proc_rec(None, \"compilation failed!\", &compile_result);\n     }\n \n     let exe_file = make_exe_name(config, testpaths);\n@@ -737,7 +749,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testpaths: &TestP\n                                        &rust_src_root);\n \n     if !debugger_run_result.status.success() {\n-        fatal_proc_rec(\"Error while running LLDB\", &debugger_run_result);\n+        fatal_proc_rec(None, \"Error while running LLDB\", &debugger_run_result);\n     }\n \n     check_debugger_output(&debugger_run_result, &check_lines);\n@@ -770,7 +782,7 @@ fn cmd2procres(config: &Config, testpaths: &TestPaths, cmd: &mut Command)\n              String::from_utf8(stderr).unwrap())\n         },\n         Err(e) => {\n-            fatal(&format!(\"Failed to setup Python process for \\\n+            fatal(None, &format!(\"Failed to setup Python process for \\\n                             LLDB script: {}\", e))\n         }\n     };\n@@ -820,7 +832,7 @@ fn parse_debugger_commands(testpaths: &TestPaths, debugger_prefix: &str)\n                 });\n             }\n             Err(e) => {\n-                fatal(&format!(\"Error while parsing debugger commands: {}\", e))\n+                fatal(None, &format!(\"Error while parsing debugger commands: {}\", e))\n             }\n         }\n         counter += 1;\n@@ -902,19 +914,21 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n             }\n         }\n         if i != num_check_lines {\n-            fatal_proc_rec(&format!(\"line not found in debugger output: {}\",\n+            fatal_proc_rec(None, &format!(\"line not found in debugger output: {}\",\n                                     check_lines.get(i).unwrap()),\n                           debugger_run_result);\n         }\n     }\n }\n \n-fn check_error_patterns(props: &TestProps,\n+fn check_error_patterns(revision: Option<&str>,\n+                        props: &TestProps,\n                         testpaths: &TestPaths,\n                         output_to_check: &str,\n                         proc_res: &ProcRes) {\n     if props.error_patterns.is_empty() {\n-        fatal(&format!(\"no error pattern specified in {:?}\",\n+        fatal(revision,\n+              &format!(\"no error pattern specified in {:?}\",\n                        testpaths.file.display()));\n     }\n     let mut next_err_idx = 0;\n@@ -936,44 +950,50 @@ fn check_error_patterns(props: &TestProps,\n \n     let missing_patterns = &props.error_patterns[next_err_idx..];\n     if missing_patterns.len() == 1 {\n-        fatal_proc_rec(&format!(\"error pattern '{}' not found!\", missing_patterns[0]),\n-                      proc_res);\n+        fatal_proc_rec(\n+            revision,\n+            &format!(\"error pattern '{}' not found!\", missing_patterns[0]),\n+            proc_res);\n     } else {\n         for pattern in missing_patterns {\n-            error(&format!(\"error pattern '{}' not found!\", *pattern));\n+            error(revision, &format!(\"error pattern '{}' not found!\", *pattern));\n         }\n-        fatal_proc_rec(\"multiple error patterns not found\", proc_res);\n+        fatal_proc_rec(revision, \"multiple error patterns not found\", proc_res);\n     }\n }\n \n-fn check_no_compiler_crash(proc_res: &ProcRes) {\n+fn check_no_compiler_crash(revision: Option<&str>, proc_res: &ProcRes) {\n     for line in proc_res.stderr.lines() {\n         if line.starts_with(\"error: internal compiler error:\") {\n-            fatal_proc_rec(\"compiler encountered internal error\",\n-                          proc_res);\n+            fatal_proc_rec(revision,\n+                           \"compiler encountered internal error\",\n+                           proc_res);\n         }\n     }\n }\n \n-fn check_forbid_output(props: &TestProps,\n+fn check_forbid_output(revision: Option<&str>,\n+                       props: &TestProps,\n                        output_to_check: &str,\n                        proc_res: &ProcRes) {\n     for pat in &props.forbid_output {\n         if output_to_check.contains(pat) {\n-            fatal_proc_rec(\"forbidden pattern found in compiler output\", proc_res);\n+            fatal_proc_rec(revision,\n+                           \"forbidden pattern found in compiler output\",\n+                           proc_res);\n         }\n     }\n }\n \n-fn check_expected_errors(expected_errors: Vec<errors::ExpectedError>,\n+fn check_expected_errors(revision: Option<&str>,\n+                         expected_errors: Vec<errors::ExpectedError>,\n                          testpaths: &TestPaths,\n                          proc_res: &ProcRes) {\n-\n     // true if we found the error in question\n     let mut found_flags = vec![false; expected_errors.len()];\n \n     if proc_res.status.success() {\n-        fatal(\"process did not return an error status\");\n+        fatal_proc_rec(revision, \"process did not return an error status\", proc_res);\n     }\n \n     let prefixes = expected_errors.iter().map(|ee| {\n@@ -989,23 +1009,6 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError>,\n                                   (acc_help || ee.kind == \"help:\", acc_note ||\n                                    ee.kind == \"note:\"));\n \n-    fn prefix_matches(line: &str, prefix: &str) -> bool {\n-        use std::ascii::AsciiExt;\n-        // On windows just translate all '\\' path separators to '/'\n-        let line = line.replace(r\"\\\", \"/\");\n-        if cfg!(windows) {\n-            line.to_ascii_lowercase().starts_with(&prefix.to_ascii_lowercase())\n-        } else {\n-            line.starts_with(prefix)\n-        }\n-    }\n-\n-    // A multi-line error will have followup lines which start with a space\n-    // or open paren.\n-    fn continuation( line: &str) -> bool {\n-        line.starts_with(\" \") || line.starts_with(\"(\")\n-    }\n-\n     // Scan and extract our error/warning messages,\n     // which look like:\n     //    filename:line1:col1: line2:col2: *error:* msg\n@@ -1015,6 +1018,8 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError>,\n     //\n     // This pattern is ambiguous on windows, because filename may contain\n     // a colon, so any path prefix must be detected and removed first.\n+    let mut unexpected = 0;\n+    let mut not_found = 0;\n     for line in proc_res.stderr.lines() {\n         let mut was_expected = false;\n         let mut prev = 0;\n@@ -1036,9 +1041,11 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError>,\n                         break;\n                     }\n                 }\n-                if (prefix_matches(line, &prefixes[i]) || continuation(line)) &&\n+                if\n+                    (prefix_matches(line, &prefixes[i]) || continuation(line)) &&\n                     line.contains(&ee.kind) &&\n-                    line.contains(&ee.msg) {\n+                    line.contains(&ee.msg)\n+                {\n                     found_flags[i] = true;\n                     was_expected = true;\n                     break;\n@@ -1053,20 +1060,44 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError>,\n         }\n \n         if !was_expected && is_unexpected_compiler_message(line, expect_help, expect_note) {\n-            fatal_proc_rec(&format!(\"unexpected compiler message: '{}'\",\n-                                    line),\n-                          proc_res);\n+            error(revision, &format!(\"unexpected compiler message: '{}'\", line));\n+            unexpected += 1;\n         }\n     }\n \n     for (i, &flag) in found_flags.iter().enumerate() {\n         if !flag {\n             let ee = &expected_errors[i];\n-            fatal_proc_rec(&format!(\"expected {} on line {} not found: {}\",\n-                                    ee.kind, ee.line, ee.msg),\n-                          proc_res);\n+            error(revision, &format!(\"expected {} on line {} not found: {}\",\n+                                     ee.kind, ee.line, ee.msg));\n+            not_found += 1;\n+        }\n+    }\n+\n+    if unexpected > 0 || not_found > 0 {\n+        fatal_proc_rec(\n+            revision,\n+            &format!(\"{} unexpected errors found, {} expected errors not found\",\n+                     unexpected, not_found),\n+            proc_res);\n+    }\n+\n+    fn prefix_matches(line: &str, prefix: &str) -> bool {\n+        use std::ascii::AsciiExt;\n+        // On windows just translate all '\\' path separators to '/'\n+        let line = line.replace(r\"\\\", \"/\");\n+        if cfg!(windows) {\n+            line.to_ascii_lowercase().starts_with(&prefix.to_ascii_lowercase())\n+        } else {\n+            line.starts_with(prefix)\n         }\n     }\n+\n+    // A multi-line error will have followup lines which start with a space\n+    // or open paren.\n+    fn continuation( line: &str) -> bool {\n+        line.starts_with(\" \") || line.starts_with(\"(\")\n+    }\n }\n \n fn is_unexpected_compiler_message(line: &str, expect_help: bool, expect_note: bool) -> bool {\n@@ -1331,6 +1362,7 @@ fn compose_and_run_compiler(config: &Config, props: &TestProps,\n                                      None);\n         if !auxres.status.success() {\n             fatal_proc_rec(\n+                None,\n                 &format!(\"auxiliary build of {:?} failed to compile: \",\n                         aux_testpaths.file.display()),\n                 &auxres);\n@@ -1582,13 +1614,20 @@ fn maybe_dump_to_stdout(config: &Config, out: &str, err: &str) {\n     }\n }\n \n-fn error(err: &str) { println!(\"\\nerror: {}\", err); }\n+fn error(revision: Option<&str>, err: &str) {\n+    match revision {\n+        Some(rev) => println!(\"\\nerror in revision `{}`: {}\", rev, err),\n+        None => println!(\"\\nerror: {}\", err)\n+    }\n+}\n \n-fn fatal(err: &str) -> ! { error(err); panic!(); }\n+fn fatal(revision: Option<&str>, err: &str) -> ! {\n+    error(revision, err); panic!();\n+}\n \n-fn fatal_proc_rec(err: &str, proc_res: &ProcRes) -> ! {\n-    print!(\"\\n\\\n-error: {}\\n\\\n+fn fatal_proc_rec(revision: Option<&str>, err: &str, proc_res: &ProcRes) -> ! {\n+    error(revision, err);\n+    print!(\"\\\n status: {}\\n\\\n command: {}\\n\\\n stdout:\\n\\\n@@ -1600,7 +1639,7 @@ stderr:\\n\\\n {}\\n\\\n ------------------------------------------\\n\\\n \\n\",\n-             err, proc_res.status, proc_res.cmdline, proc_res.stdout,\n+             proc_res.status, proc_res.cmdline, proc_res.stdout,\n              proc_res.stderr);\n     panic!();\n }\n@@ -1798,20 +1837,22 @@ fn check_ir_with_filecheck(config: &Config, testpaths: &TestPaths) -> ProcRes {\n }\n \n fn run_codegen_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n+    assert!(props.revisions.is_empty(), \"revisions not relevant here\");\n \n     if config.llvm_bin_path.is_none() {\n-        fatal(\"missing --llvm-bin-path\");\n+        fatal(None, \"missing --llvm-bin-path\");\n     }\n \n     let mut proc_res = compile_test_and_save_ir(config, props, testpaths);\n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"compilation failed!\", &proc_res);\n+        fatal_proc_rec(None, \"compilation failed!\", &proc_res);\n     }\n \n     proc_res = check_ir_with_filecheck(config, testpaths);\n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"verification with 'FileCheck' failed\",\n-                      &proc_res);\n+        fatal_proc_rec(None,\n+                       \"verification with 'FileCheck' failed\",\n+                       &proc_res);\n     }\n }\n \n@@ -1827,13 +1868,15 @@ fn charset() -> &'static str {\n }\n \n fn run_rustdoc_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n+    assert!(props.revisions.is_empty(), \"revisions not relevant here\");\n+\n     let out_dir = output_base_name(config, testpaths);\n     let _ = fs::remove_dir_all(&out_dir);\n     ensure_dir(&out_dir);\n \n     let proc_res = document(config, props, testpaths, &out_dir);\n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"rustdoc failed!\", &proc_res);\n+        fatal_proc_rec(None, \"rustdoc failed!\", &proc_res);\n     }\n     let root = find_rust_src_root(config).unwrap();\n \n@@ -1844,20 +1887,20 @@ fn run_rustdoc_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n                                   .arg(out_dir)\n                                   .arg(&testpaths.file));\n     if !res.status.success() {\n-        fatal_proc_rec(\"htmldocck failed!\", &res);\n+        fatal_proc_rec(None, \"htmldocck failed!\", &res);\n     }\n }\n \n fn run_codegen_units_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n-    assert!(props.revisions.is_empty(), \"revisions not relevant to codegen units\");\n+    assert!(props.revisions.is_empty(), \"revisions not relevant here\");\n \n     let proc_res = compile_test(config, props, testpaths);\n \n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"compilation failed!\", &proc_res);\n+        fatal_proc_rec(None, \"compilation failed!\", &proc_res);\n     }\n \n-    check_no_compiler_crash(&proc_res);\n+    check_no_compiler_crash(None, &proc_res);\n \n     let prefix = \"TRANS_ITEM \";\n "}]}