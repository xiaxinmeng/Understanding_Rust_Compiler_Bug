{"sha": "9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljMDljMWY3Y2ZjZjlkZTA1MjJiY2QxY2ZkYTMyYjU1MjE5NWM0NjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-26T19:17:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-26T19:17:00Z"}, "message": "Auto merge of #82552 - GuillaumeGomez:rollup-8dn1ztn, r=GuillaumeGomez\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #81940 (Stabilize str_split_once)\n - #82165 (Reword labels on E0308 involving async fn return type)\n - #82456 (Replaced some unwrap_or and map_or with lazy variants)\n - #82491 (Consider inexpensive inlining criteria first)\n - #82506 (Properly account for non-shorthand pattern field in unused variable lint)\n - #82535 (Set codegen thread names)\n - #82545 (rustdoc: add optional woff2 versions of FiraSans.)\n - #82549 (Revert \"Update normalize.css to 8.0.1\")\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "7fbf5611f6306f6ea0bb25d163d234cf17c3ac38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fbf5611f6306f6ea0bb25d163d234cf17c3ac38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "html_url": "https://github.com/rust-lang/rust/commit/9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cecdb181ade91c0a5ffab9a148dba68fc7d00ee3", "url": "https://api.github.com/repos/rust-lang/rust/commits/cecdb181ade91c0a5ffab9a148dba68fc7d00ee3", "html_url": "https://github.com/rust-lang/rust/commit/cecdb181ade91c0a5ffab9a148dba68fc7d00ee3"}, {"sha": "0da9b474de36bf7954ceb51a0e483cc39e9d60da", "url": "https://api.github.com/repos/rust-lang/rust/commits/0da9b474de36bf7954ceb51a0e483cc39e9d60da", "html_url": "https://github.com/rust-lang/rust/commit/0da9b474de36bf7954ceb51a0e483cc39e9d60da"}], "stats": {"total": 629, "additions": 382, "deletions": 247}, "files": [{"sha": "1480ab251337822c6f2333c59a1d4eebf1c59db5", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -5,8 +5,7 @@\n     associated_type_bounds,\n     never_type,\n     try_blocks,\n-    hash_drain_filter,\n-    str_split_once\n+    hash_drain_filter\n )]\n #![warn(rust_2018_idioms)]\n #![warn(unused_lifetimes)]"}, {"sha": "1464784ae288c494cf7394a70db8d31fddbe2338", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -2372,7 +2372,7 @@ fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> &'ll DIAr\n     fn get_parameter_names(cx: &CodegenCx<'_, '_>, generics: &ty::Generics) -> Vec<Symbol> {\n         let mut names = generics\n             .parent\n-            .map_or(vec![], |def_id| get_parameter_names(cx, cx.tcx.generics_of(def_id)));\n+            .map_or_else(Vec::new, |def_id| get_parameter_names(cx, cx.tcx.generics_of(def_id)));\n         names.extend(generics.params.iter().map(|param| param.name));\n         names\n     }"}, {"sha": "c28b0d64651e350a15390843ee581ef99db7a305", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -481,9 +481,9 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n \n         fn get_parameter_names(cx: &CodegenCx<'_, '_>, generics: &ty::Generics) -> Vec<Symbol> {\n-            let mut names = generics\n-                .parent\n-                .map_or(vec![], |def_id| get_parameter_names(cx, cx.tcx.generics_of(def_id)));\n+            let mut names = generics.parent.map_or_else(Vec::new, |def_id| {\n+                get_parameter_names(cx, cx.tcx.generics_of(def_id))\n+            });\n             names.extend(generics.params.iter().map(|param| param.name));\n             names\n         }"}, {"sha": "b007df5730621e7e368067afcd68a5055f721f15", "filename": "compiler/rustc_codegen_llvm/src/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmetadata.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -65,8 +65,8 @@ fn search_meta_section<'a>(\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n             let mut name_buf = None;\n             let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n-            let name = name_buf.map_or(\n-                String::new(), // We got a NULL ptr, ignore `name_len`.\n+            let name = name_buf.map_or_else(\n+                String::new, // We got a NULL ptr, ignore `name_len`.\n                 |buf| {\n                     String::from_utf8(\n                         slice::from_raw_parts(buf.as_ptr() as *const u8, name_len as usize)"}, {"sha": "caa6a6a8e3a2661cdcfe1dd845b46df346db607d", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -2082,7 +2082,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n         let filestem = cratepath.file_stem().unwrap().to_str().unwrap();\n         cmd.link_rust_dylib(\n             Symbol::intern(&unlib(&sess.target, filestem)),\n-            parent.unwrap_or(Path::new(\"\")),\n+            parent.unwrap_or_else(|| Path::new(\"\")),\n         );\n     }\n }"}, {"sha": "7b8ce157fc2b43d30c3c5f702274d7cb84e275b3", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 77, "deletions": 47, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -712,6 +712,33 @@ impl<B: WriteBackendMethods> WorkItem<B> {\n             }\n         }\n     }\n+\n+    /// Generate a short description of this work item suitable for use as a thread name.\n+    fn short_description(&self) -> String {\n+        // `pthread_setname()` on *nix is limited to 15 characters and longer names are ignored.\n+        // Use very short descriptions in this case to maximize the space available for the module name.\n+        // Windows does not have that limitation so use slightly more descriptive names there.\n+        match self {\n+            WorkItem::Optimize(m) => {\n+                #[cfg(windows)]\n+                return format!(\"optimize module {}\", m.name);\n+                #[cfg(not(windows))]\n+                return format!(\"opt {}\", m.name);\n+            }\n+            WorkItem::CopyPostLtoArtifacts(m) => {\n+                #[cfg(windows)]\n+                return format!(\"copy LTO artifacts for {}\", m.name);\n+                #[cfg(not(windows))]\n+                return format!(\"copy {}\", m.name);\n+            }\n+            WorkItem::LTO(m) => {\n+                #[cfg(windows)]\n+                return format!(\"LTO module {}\", m.name());\n+                #[cfg(not(windows))]\n+                return format!(\"LTO {}\", m.name());\n+            }\n+        }\n+    }\n }\n \n enum WorkItemResult<B: WriteBackendMethods> {\n@@ -1609,56 +1636,59 @@ fn start_executing_work<B: ExtraBackendMethods>(\n pub struct WorkerFatalError;\n \n fn spawn_work<B: ExtraBackendMethods>(cgcx: CodegenContext<B>, work: WorkItem<B>) {\n-    thread::spawn(move || {\n-        // Set up a destructor which will fire off a message that we're done as\n-        // we exit.\n-        struct Bomb<B: ExtraBackendMethods> {\n-            coordinator_send: Sender<Box<dyn Any + Send>>,\n-            result: Option<Result<WorkItemResult<B>, FatalError>>,\n-            worker_id: usize,\n-        }\n-        impl<B: ExtraBackendMethods> Drop for Bomb<B> {\n-            fn drop(&mut self) {\n-                let worker_id = self.worker_id;\n-                let msg = match self.result.take() {\n-                    Some(Ok(WorkItemResult::Compiled(m))) => {\n-                        Message::Done::<B> { result: Ok(m), worker_id }\n-                    }\n-                    Some(Ok(WorkItemResult::NeedsLink(m))) => {\n-                        Message::NeedsLink::<B> { module: m, worker_id }\n-                    }\n-                    Some(Ok(WorkItemResult::NeedsFatLTO(m))) => {\n-                        Message::NeedsFatLTO::<B> { result: m, worker_id }\n-                    }\n-                    Some(Ok(WorkItemResult::NeedsThinLTO(name, thin_buffer))) => {\n-                        Message::NeedsThinLTO::<B> { name, thin_buffer, worker_id }\n-                    }\n-                    Some(Err(FatalError)) => {\n-                        Message::Done::<B> { result: Err(Some(WorkerFatalError)), worker_id }\n-                    }\n-                    None => Message::Done::<B> { result: Err(None), worker_id },\n-                };\n-                drop(self.coordinator_send.send(Box::new(msg)));\n+    let builder = thread::Builder::new().name(work.short_description());\n+    builder\n+        .spawn(move || {\n+            // Set up a destructor which will fire off a message that we're done as\n+            // we exit.\n+            struct Bomb<B: ExtraBackendMethods> {\n+                coordinator_send: Sender<Box<dyn Any + Send>>,\n+                result: Option<Result<WorkItemResult<B>, FatalError>>,\n+                worker_id: usize,\n+            }\n+            impl<B: ExtraBackendMethods> Drop for Bomb<B> {\n+                fn drop(&mut self) {\n+                    let worker_id = self.worker_id;\n+                    let msg = match self.result.take() {\n+                        Some(Ok(WorkItemResult::Compiled(m))) => {\n+                            Message::Done::<B> { result: Ok(m), worker_id }\n+                        }\n+                        Some(Ok(WorkItemResult::NeedsLink(m))) => {\n+                            Message::NeedsLink::<B> { module: m, worker_id }\n+                        }\n+                        Some(Ok(WorkItemResult::NeedsFatLTO(m))) => {\n+                            Message::NeedsFatLTO::<B> { result: m, worker_id }\n+                        }\n+                        Some(Ok(WorkItemResult::NeedsThinLTO(name, thin_buffer))) => {\n+                            Message::NeedsThinLTO::<B> { name, thin_buffer, worker_id }\n+                        }\n+                        Some(Err(FatalError)) => {\n+                            Message::Done::<B> { result: Err(Some(WorkerFatalError)), worker_id }\n+                        }\n+                        None => Message::Done::<B> { result: Err(None), worker_id },\n+                    };\n+                    drop(self.coordinator_send.send(Box::new(msg)));\n+                }\n             }\n-        }\n \n-        let mut bomb = Bomb::<B> {\n-            coordinator_send: cgcx.coordinator_send.clone(),\n-            result: None,\n-            worker_id: cgcx.worker,\n-        };\n+            let mut bomb = Bomb::<B> {\n+                coordinator_send: cgcx.coordinator_send.clone(),\n+                result: None,\n+                worker_id: cgcx.worker,\n+            };\n \n-        // Execute the work itself, and if it finishes successfully then flag\n-        // ourselves as a success as well.\n-        //\n-        // Note that we ignore any `FatalError` coming out of `execute_work_item`,\n-        // as a diagnostic was already sent off to the main thread - just\n-        // surface that there was an error in this worker.\n-        bomb.result = {\n-            let _prof_timer = work.start_profiling(&cgcx);\n-            Some(execute_work_item(&cgcx, work))\n-        };\n-    });\n+            // Execute the work itself, and if it finishes successfully then flag\n+            // ourselves as a success as well.\n+            //\n+            // Note that we ignore any `FatalError` coming out of `execute_work_item`,\n+            // as a diagnostic was already sent off to the main thread - just\n+            // surface that there was an error in this worker.\n+            bomb.result = {\n+                let _prof_timer = work.start_profiling(&cgcx);\n+                Some(execute_work_item(&cgcx, work))\n+            };\n+        })\n+        .expect(\"failed to spawn thread\");\n }\n \n enum SharedEmitterMessage {"}, {"sha": "2d5f43e5890d0ab3681d47e4b83ccddeaf2f999d", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -1484,13 +1484,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 for (key, values) in types.iter() {\n                     let count = values.len();\n                     let kind = key.descr();\n+                    let mut returned_async_output_error = false;\n                     for sp in values {\n                         err.span_label(\n                             *sp,\n                             format!(\n                                 \"{}{}{} {}{}\",\n-                                if sp.is_desugaring(DesugaringKind::Async) {\n-                                    \"the `Output` of this `async fn`'s \"\n+                                if sp.is_desugaring(DesugaringKind::Async)\n+                                    && !returned_async_output_error\n+                                {\n+                                    \"checked the `Output` of this `async fn`, \"\n                                 } else if count == 1 {\n                                     \"the \"\n                                 } else {\n@@ -1502,6 +1505,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                 pluralize!(count),\n                             ),\n                         );\n+                        if sp.is_desugaring(DesugaringKind::Async)\n+                            && returned_async_output_error == false\n+                        {\n+                            err.note(\"while checking the return type of the `async fn`\");\n+                            returned_async_output_error = true;\n+                        }\n                     }\n                 }\n             }"}, {"sha": "5a27135581747f15e5d91d1412996406502c69f6", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -201,7 +201,7 @@ fn check_panic_str<'tcx>(\n             Some(v) if v.len() == 1 => \"panic message contains a brace\",\n             _ => \"panic message contains braces\",\n         };\n-        cx.struct_span_lint(NON_FMT_PANIC, brace_spans.unwrap_or(vec![span]), |lint| {\n+        cx.struct_span_lint(NON_FMT_PANIC, brace_spans.unwrap_or_else(|| vec![span]), |lint| {\n             let mut l = lint.build(msg);\n             l.note(\"this message is not used as a format string, but will be in Rust 2021\");\n             if span.contains(arg.span) {"}, {"sha": "291e7ef045e4f6c9f7e390c745110dbfa8f89d43", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -378,14 +378,14 @@ fn add_query_description_impl(\n                 let t = &(t.0).0;\n                 quote! { #t }\n             })\n-            .unwrap_or(quote! { _ });\n+            .unwrap_or_else(|| quote! { _ });\n         let value = args\n             .as_ref()\n             .map(|t| {\n                 let t = &(t.1).0;\n                 quote! { #t }\n             })\n-            .unwrap_or(quote! { _ });\n+            .unwrap_or_else(|| quote! { _ });\n         // expr is a `Block`, meaning that `{ #expr }` gets expanded\n         // to `{ { stmts... } }`, which triggers the `unused_braces` lint.\n         quote! {\n@@ -409,7 +409,7 @@ fn add_query_description_impl(\n     };\n \n     let (tcx, desc) = modifiers.desc;\n-    let tcx = tcx.as_ref().map_or(quote! { _ }, |t| quote! { #t });\n+    let tcx = tcx.as_ref().map_or_else(|| quote! { _ }, |t| quote! { #t });\n \n     let desc = quote! {\n         #[allow(unused_variables)]"}, {"sha": "8a0fce209b7fbeb0a9b6ddfea32a78c909864d61", "filename": "compiler/rustc_macros/src/session_diagnostic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -473,9 +473,9 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n                                         .map(\n                                             |applicability_idx| quote!(#binding.#applicability_idx),\n                                         )\n-                                        .unwrap_or(quote!(\n-                                            rustc_errors::Applicability::Unspecified\n-                                        ));\n+                                        .unwrap_or_else(|| {\n+                                            quote!(rustc_errors::Applicability::Unspecified)\n+                                        });\n                                     return Ok((span, applicability));\n                                 }\n                                 throw_span_err!("}, {"sha": "fa234ff5feb64095d10f6a3c3bcffed3c432c0ac", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -50,7 +50,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n \n     let name =\n         with_no_trimmed_paths(|| ty::tls::with(|tcx| tcx.def_path_str(cid.instance.def_id())));\n-    let prom = cid.promoted.map_or(String::new(), |p| format!(\"::promoted[{:?}]\", p));\n+    let prom = cid.promoted.map_or_else(String::new, |p| format!(\"::promoted[{:?}]\", p));\n     trace!(\"eval_body_using_ecx: pushing stack frame for global: {}{}\", name, prom);\n \n     ecx.push_stack_frame("}, {"sha": "508510a81e1fb5fc6192574d8a34821ad2de2861", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -28,7 +28,6 @@ Rust MIR: a lowered representation of Rust.\n #![feature(or_patterns)]\n #![feature(once_cell)]\n #![feature(control_flow_enum)]\n-#![feature(str_split_once)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "16279040a1c3f48e6cd9f8dada35223fffd066a1", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 146, "deletions": 124, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -1,6 +1,6 @@\n //! Inlining pass for MIR functions\n \n-use rustc_attr as attr;\n+use rustc_attr::InlineAttr;\n use rustc_hir as hir;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n@@ -106,72 +106,90 @@ struct Inliner<'tcx> {\n impl Inliner<'tcx> {\n     fn process_blocks(&mut self, caller_body: &mut Body<'tcx>, blocks: Range<BasicBlock>) {\n         for bb in blocks {\n-            let callsite = match self.get_valid_function_call(bb, &caller_body[bb], caller_body) {\n+            let bb_data = &caller_body[bb];\n+            if bb_data.is_cleanup {\n+                continue;\n+            }\n+\n+            let callsite = match self.resolve_callsite(caller_body, bb, bb_data) {\n                 None => continue,\n                 Some(it) => it,\n             };\n+\n             let span = trace_span!(\"process_blocks\", %callsite.callee, ?bb);\n             let _guard = span.enter();\n \n-            trace!(\n-                \"checking for self recursion ({:?} vs body_source: {:?})\",\n-                callsite.callee.def_id(),\n-                caller_body.source.def_id()\n-            );\n-            if callsite.callee.def_id() == caller_body.source.def_id() {\n-                debug!(\"Not inlining a function into itself\");\n-                continue;\n-            }\n-\n-            if !self.is_mir_available(callsite.callee, caller_body) {\n-                debug!(\"MIR unavailable {}\", callsite.callee);\n-                continue;\n+            match self.try_inlining(caller_body, &callsite) {\n+                Err(reason) => {\n+                    debug!(\"not-inlined {} [{}]\", callsite.callee, reason);\n+                    continue;\n+                }\n+                Ok(new_blocks) => {\n+                    debug!(\"inlined {}\", callsite.callee);\n+                    self.changed = true;\n+                    self.history.push(callsite.callee);\n+                    self.process_blocks(caller_body, new_blocks);\n+                    self.history.pop();\n+                }\n             }\n+        }\n+    }\n \n-            let span = trace_span!(\"instance_mir\", %callsite.callee);\n-            let instance_mir_guard = span.enter();\n-            let callee_body = self.tcx.instance_mir(callsite.callee.def);\n-            drop(instance_mir_guard);\n-            if !self.should_inline(callsite, callee_body) {\n-                continue;\n-            }\n+    /// Attempts to inline a callsite into the caller body. When successful returns basic blocks\n+    /// containing the inlined body. Otherwise returns an error describing why inlining didn't take\n+    /// place.\n+    fn try_inlining(\n+        &self,\n+        caller_body: &mut Body<'tcx>,\n+        callsite: &CallSite<'tcx>,\n+    ) -> Result<std::ops::Range<BasicBlock>, &'static str> {\n+        let callee_attrs = self.tcx.codegen_fn_attrs(callsite.callee.def_id());\n+        self.check_codegen_attributes(callsite, callee_attrs)?;\n+        self.check_mir_is_available(caller_body, &callsite.callee)?;\n+        let callee_body = self.tcx.instance_mir(callsite.callee.def);\n+        self.check_mir_body(callsite, callee_body, callee_attrs)?;\n+\n+        if !self.tcx.consider_optimizing(|| {\n+            format!(\"Inline {:?} into {}\", callee_body.span, callsite.callee)\n+        }) {\n+            return Err(\"optimization fuel exhausted\");\n+        }\n \n-            if !self.tcx.consider_optimizing(|| {\n-                format!(\"Inline {:?} into {}\", callee_body.span, callsite.callee)\n-            }) {\n-                return;\n-            }\n+        let callee_body = callsite.callee.subst_mir_and_normalize_erasing_regions(\n+            self.tcx,\n+            self.param_env,\n+            callee_body.clone(),\n+        );\n \n-            let callee_body = callsite.callee.subst_mir_and_normalize_erasing_regions(\n-                self.tcx,\n-                self.param_env,\n-                callee_body.clone(),\n-            );\n+        let old_blocks = caller_body.basic_blocks().next_index();\n+        self.inline_call(caller_body, &callsite, callee_body);\n+        let new_blocks = old_blocks..caller_body.basic_blocks().next_index();\n \n-            let old_blocks = caller_body.basic_blocks().next_index();\n-            self.inline_call(callsite, caller_body, callee_body);\n-            let new_blocks = old_blocks..caller_body.basic_blocks().next_index();\n-            self.changed = true;\n+        Ok(new_blocks)\n+    }\n \n-            self.history.push(callsite.callee);\n-            self.process_blocks(caller_body, new_blocks);\n-            self.history.pop();\n+    fn check_mir_is_available(\n+        &self,\n+        caller_body: &Body<'tcx>,\n+        callee: &Instance<'tcx>,\n+    ) -> Result<(), &'static str> {\n+        if callee.def_id() == caller_body.source.def_id() {\n+            return Err(\"self-recursion\");\n         }\n-    }\n \n-    #[instrument(level = \"debug\", skip(self, caller_body))]\n-    fn is_mir_available(&self, callee: Instance<'tcx>, caller_body: &Body<'tcx>) -> bool {\n         match callee.def {\n             InstanceDef::Item(_) => {\n                 // If there is no MIR available (either because it was not in metadata or\n                 // because it has no MIR because it's an extern function), then the inliner\n                 // won't cause cycles on this.\n                 if !self.tcx.is_mir_available(callee.def_id()) {\n-                    return false;\n+                    return Err(\"item MIR unavailable\");\n                 }\n             }\n             // These have no own callable MIR.\n-            InstanceDef::Intrinsic(_) | InstanceDef::Virtual(..) => return false,\n+            InstanceDef::Intrinsic(_) | InstanceDef::Virtual(..) => {\n+                return Err(\"instance without MIR (intrinsic / virtual)\");\n+            }\n             // This cannot result in an immediate cycle since the callee MIR is a shim, which does\n             // not get any optimizations run on it. Any subsequent inlining may cause cycles, but we\n             // do not need to catch this here, we can wait until the inliner decides to continue\n@@ -181,13 +199,13 @@ impl Inliner<'tcx> {\n             | InstanceDef::FnPtrShim(..)\n             | InstanceDef::ClosureOnceShim { .. }\n             | InstanceDef::DropGlue(..)\n-            | InstanceDef::CloneShim(..) => return true,\n+            | InstanceDef::CloneShim(..) => return Ok(()),\n         }\n \n         if self.tcx.is_constructor(callee.def_id()) {\n             trace!(\"constructors always have MIR\");\n             // Constructor functions cannot cause a query cycle.\n-            return true;\n+            return Ok(());\n         }\n \n         if let Some(callee_def_id) = callee.def_id().as_local() {\n@@ -196,39 +214,44 @@ impl Inliner<'tcx> {\n             // since their `optimized_mir` is used for layout computation, which can\n             // create a cycle, even when no attempt is made to inline the function\n             // in the other direction.\n-            caller_body.generator_kind.is_none()\n-                && (\n-                    // Avoid a cycle here by only using `instance_mir` only if we have\n-                    // a lower `HirId` than the callee. This ensures that the callee will\n-                    // not inline us. This trick only works without incremental compilation.\n-                    // So don't do it if that is enabled.\n-                    !self.tcx.dep_graph.is_fully_enabled()\n-                && self.hir_id < callee_hir_id\n-                // If we know for sure that the function we're calling will itself try to\n-                // call us, then we avoid inlining that function.\n-                || !self.tcx.mir_callgraph_reachable((callee, caller_body.source.def_id().expect_local()))\n-                )\n+            if caller_body.generator_kind.is_some() {\n+                return Err(\"local generator (query cycle avoidance)\");\n+            }\n+\n+            // Avoid a cycle here by only using `instance_mir` only if we have\n+            // a lower `HirId` than the callee. This ensures that the callee will\n+            // not inline us. This trick only works without incremental compilation.\n+            // So don't do it if that is enabled.\n+            if !self.tcx.dep_graph.is_fully_enabled() && self.hir_id < callee_hir_id {\n+                return Ok(());\n+            }\n+\n+            // If we know for sure that the function we're calling will itself try to\n+            // call us, then we avoid inlining that function.\n+            if self\n+                .tcx\n+                .mir_callgraph_reachable((*callee, caller_body.source.def_id().expect_local()))\n+            {\n+                return Err(\"caller might be reachable from callee (query cycle avoidance)\");\n+            }\n+\n+            Ok(())\n         } else {\n             // This cannot result in an immediate cycle since the callee MIR is from another crate\n             // and is already optimized. Any subsequent inlining may cause cycles, but we do\n             // not need to catch this here, we can wait until the inliner decides to continue\n             // inlining a second time.\n             trace!(\"functions from other crates always have MIR\");\n-            true\n+            Ok(())\n         }\n     }\n \n-    fn get_valid_function_call(\n+    fn resolve_callsite(\n         &self,\n+        caller_body: &Body<'tcx>,\n         bb: BasicBlock,\n         bb_data: &BasicBlockData<'tcx>,\n-        caller_body: &Body<'tcx>,\n     ) -> Option<CallSite<'tcx>> {\n-        // Don't inline calls that are in cleanup blocks.\n-        if bb_data.is_cleanup {\n-            return None;\n-        }\n-\n         // Only consider direct calls to functions\n         let terminator = bb_data.terminator();\n         if let TerminatorKind::Call { ref func, ref destination, .. } = terminator.kind {\n@@ -258,73 +281,73 @@ impl Inliner<'tcx> {\n         None\n     }\n \n-    #[instrument(level = \"debug\", skip(self, callee_body))]\n-    fn should_inline(&self, callsite: CallSite<'tcx>, callee_body: &Body<'tcx>) -> bool {\n-        let tcx = self.tcx;\n+    /// Returns an error if inlining is not possible based on codegen attributes alone. A success\n+    /// indicates that inlining decision should be based on other criteria.\n+    fn check_codegen_attributes(\n+        &self,\n+        callsite: &CallSite<'tcx>,\n+        callee_attrs: &CodegenFnAttrs,\n+    ) -> Result<(), &'satic str> {\n+        if let InlineAttr::Never = callee_attrs.inline {\n+            return Err(\"never inline hint\");\n+        }\n+\n+        // Only inline local functions if they would be eligible for cross-crate\n+        // inlining. This is to ensure that the final crate doesn't have MIR that\n+        // reference unexported symbols\n+        if callsite.callee.def_id().is_local() {\n+            let is_generic = callsite.callee.substs.non_erasable_generics().next().is_some();\n+            if !is_generic && !callee_attrs.requests_inline() {\n+                return Err(\"not exported\");\n+            }\n+        }\n \n         if callsite.fn_sig.c_variadic() {\n-            debug!(\"callee is variadic - not inlining\");\n-            return false;\n+            return Err(\"C variadic\");\n         }\n \n-        let codegen_fn_attrs = tcx.codegen_fn_attrs(callsite.callee.def_id());\n+        if callee_attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n+            return Err(\"naked\");\n+        }\n \n-        let self_features = &self.codegen_fn_attrs.target_features;\n-        let callee_features = &codegen_fn_attrs.target_features;\n-        if callee_features.iter().any(|feature| !self_features.contains(feature)) {\n-            debug!(\"`callee has extra target features - not inlining\");\n-            return false;\n+        if callee_attrs.flags.contains(CodegenFnAttrFlags::COLD) {\n+            return Err(\"cold\");\n         }\n \n-        if self.codegen_fn_attrs.no_sanitize != codegen_fn_attrs.no_sanitize {\n-            debug!(\"`callee has incompatible no_sanitize attribute - not inlining\");\n-            return false;\n+        if callee_attrs.no_sanitize != self.codegen_fn_attrs.no_sanitize {\n+            return Err(\"incompatible sanitizer set\");\n         }\n \n-        if self.codegen_fn_attrs.instruction_set != codegen_fn_attrs.instruction_set {\n-            debug!(\"`callee has incompatible instruction set - not inlining\");\n-            return false;\n+        if callee_attrs.instruction_set != self.codegen_fn_attrs.instruction_set {\n+            return Err(\"incompatible instruction set\");\n         }\n \n-        let hinted = match codegen_fn_attrs.inline {\n-            // Just treat inline(always) as a hint for now,\n-            // there are cases that prevent inlining that we\n-            // need to check for first.\n-            attr::InlineAttr::Always => true,\n-            attr::InlineAttr::Never => {\n-                debug!(\"`#[inline(never)]` present - not inlining\");\n-                return false;\n-            }\n-            attr::InlineAttr::Hint => true,\n-            attr::InlineAttr::None => false,\n-        };\n-\n-        // Only inline local functions if they would be eligible for cross-crate\n-        // inlining. This is to ensure that the final crate doesn't have MIR that\n-        // reference unexported symbols\n-        if callsite.callee.def_id().is_local() {\n-            if callsite.callee.substs.non_erasable_generics().count() == 0 && !hinted {\n-                debug!(\"    callee is an exported function - not inlining\");\n-                return false;\n+        for feature in &callee_attrs.target_features {\n+            if !self.codegen_fn_attrs.target_features.contains(feature) {\n+                return Err(\"incompatible target feature\");\n             }\n         }\n \n-        let mut threshold = if hinted {\n+        Ok(())\n+    }\n+\n+    /// Returns inlining decision that is based on the examination of callee MIR body.\n+    /// Assumes that codegen attributes have been checked for compatibility already.\n+    #[instrument(level = \"debug\", skip(self, callee_body))]\n+    fn check_mir_body(\n+        &self,\n+        callsite: &CallSite<'tcx>,\n+        callee_body: &Body<'tcx>,\n+        callee_attrs: &CodegenFnAttrs,\n+    ) -> Result<(), &'static str> {\n+        let tcx = self.tcx;\n+\n+        let mut threshold = if callee_attrs.requests_inline() {\n             self.tcx.sess.opts.debugging_opts.inline_mir_hint_threshold\n         } else {\n             self.tcx.sess.opts.debugging_opts.inline_mir_threshold\n         };\n \n-        if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n-            debug!(\"#[naked] present - not inlining\");\n-            return false;\n-        }\n-\n-        if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::COLD) {\n-            debug!(\"#[cold] present - not inlining\");\n-            return false;\n-        }\n-\n         // Give a bonus functions with a small number of blocks,\n         // We normally have two or three blocks for even\n         // very small functions.\n@@ -393,11 +416,10 @@ impl Inliner<'tcx> {\n                         if let Ok(Some(instance)) =\n                             Instance::resolve(self.tcx, self.param_env, def_id, substs)\n                         {\n-                            if callsite.callee.def_id() == instance.def_id()\n-                                || self.history.contains(&instance)\n-                            {\n-                                debug!(\"`callee is recursive - not inlining\");\n-                                return false;\n+                            if callsite.callee.def_id() == instance.def_id() {\n+                                return Err(\"self-recursion\");\n+                            } else if self.history.contains(&instance) {\n+                                return Err(\"already inlined\");\n                             }\n                         }\n                         // Don't give intrinsics the extra penalty for calls\n@@ -450,24 +472,24 @@ impl Inliner<'tcx> {\n             }\n         }\n \n-        if let attr::InlineAttr::Always = codegen_fn_attrs.inline {\n+        if let InlineAttr::Always = callee_attrs.inline {\n             debug!(\"INLINING {:?} because inline(always) [cost={}]\", callsite, cost);\n-            true\n+            Ok(())\n         } else {\n             if cost <= threshold {\n                 debug!(\"INLINING {:?} [cost={} <= threshold={}]\", callsite, cost, threshold);\n-                true\n+                Ok(())\n             } else {\n                 debug!(\"NOT inlining {:?} [cost={} > threshold={}]\", callsite, cost, threshold);\n-                false\n+                Err(\"cost above threshold\")\n             }\n         }\n     }\n \n     fn inline_call(\n         &self,\n-        callsite: CallSite<'tcx>,\n         caller_body: &mut Body<'tcx>,\n+        callsite: &CallSite<'tcx>,\n         mut callee_body: Body<'tcx>,\n     ) {\n         let terminator = caller_body[callsite.block].terminator.take().unwrap();"}, {"sha": "5b4939b740726449237ae38ec81004140f86946b", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -223,7 +223,7 @@ impl<'a> Parser<'a> {\n         fn tokens_to_string(tokens: &[TokenType]) -> String {\n             let mut i = tokens.iter();\n             // This might be a sign we need a connect method on `Iterator`.\n-            let b = i.next().map_or(String::new(), |t| t.to_string());\n+            let b = i.next().map_or_else(String::new, |t| t.to_string());\n             i.enumerate().fold(b, |mut b, (i, a)| {\n                 if tokens.len() > 2 && i == tokens.len() - 2 {\n                     b.push_str(\", or \");"}, {"sha": "82f19770a123b3c1f3a2b122fbf7b729103bb5d6", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -367,12 +367,17 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n     }\n \n     fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n-        let is_shorthand = matches!(param.pat.kind, rustc_hir::PatKind::Struct(..));\n         param.pat.each_binding(|_bm, hir_id, _x, ident| {\n-            let var = if is_shorthand {\n-                Local(LocalInfo { id: hir_id, name: ident.name, is_shorthand: true })\n-            } else {\n-                Param(hir_id, ident.name)\n+            let var = match param.pat.kind {\n+                rustc_hir::PatKind::Struct(_, fields, _) => Local(LocalInfo {\n+                    id: hir_id,\n+                    name: ident.name,\n+                    is_shorthand: fields\n+                        .iter()\n+                        .find(|f| f.ident == ident)\n+                        .map_or(false, |f| f.is_shorthand),\n+                }),\n+                _ => Param(hir_id, ident.name),\n             };\n             self.add_variable(var);\n         });"}, {"sha": "493f25f4992d1f261f905759ba34881e865f0001", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -1971,7 +1971,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // Therefore, we would compute `object_lifetime_defaults` to a\n         // vector like `['x, 'static]`. Note that the vector only\n         // includes type parameters.\n-        let object_lifetime_defaults = type_def_id.map_or(vec![], |def_id| {\n+        let object_lifetime_defaults = type_def_id.map_or_else(Vec::new, |def_id| {\n             let in_body = {\n                 let mut scope = self.scope;\n                 loop {"}, {"sha": "2df326628e7872962571110dab50d0b109975970", "filename": "compiler/rustc_session/src/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -169,7 +169,7 @@ pub fn get_or_default_sysroot() -> PathBuf {\n \n     // Check if sysroot is found using env::args().next(), and if is not found,\n     // use env::current_exe() to imply sysroot.\n-    from_env_args_next().unwrap_or(from_current_exe())\n+    from_env_args_next().unwrap_or_else(from_current_exe)\n }\n \n // The name of the directory rustc expects libraries to be located."}, {"sha": "d002f5973916618bc6e64d7d5678ac0125f8bc92", "filename": "compiler/rustc_session/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_session%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_session%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Flib.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -1,7 +1,6 @@\n #![feature(crate_visibility_modifier)]\n #![feature(once_cell)]\n #![feature(or_patterns)]\n-#![feature(str_split_once)]\n \n #[macro_use]\n extern crate bitflags;"}, {"sha": "4dce029e86b5013b7a1b2f02edf9a5192c435519", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -22,7 +22,6 @@\n #![feature(nll)]\n #![feature(min_specialization)]\n #![feature(option_expect_none)]\n-#![feature(str_split_once)]\n \n #[macro_use]\n extern crate rustc_macros;"}, {"sha": "fb747dfcbd337a4eb4b045711c2504d4f8a3e2d3", "filename": "compiler/rustc_target/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_target%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_target%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Flib.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -15,7 +15,6 @@\n #![feature(never_type)]\n #![feature(associated_type_bounds)]\n #![feature(exhaustive_patterns)]\n-#![feature(str_split_once)]\n \n #[macro_use]\n extern crate rustc_macros;"}, {"sha": "264cc4f248cec9fe14ecbc19e36f097051c87a61", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -349,7 +349,7 @@ fn report_negative_positive_conflict(\n         E0751,\n         \"found both positive and negative implementation of trait `{}`{}:\",\n         overlap.trait_desc,\n-        overlap.self_desc.clone().map_or(String::new(), |ty| format!(\" for type `{}`\", ty))\n+        overlap.self_desc.clone().map_or_else(String::new, |ty| format!(\" for type `{}`\", ty))\n     );\n \n     match tcx.span_of_impl(negative_impl_def_id) {\n@@ -397,7 +397,10 @@ fn report_conflicting_impls(\n         let msg = format!(\n             \"conflicting implementations of trait `{}`{}:{}\",\n             overlap.trait_desc,\n-            overlap.self_desc.clone().map_or(String::new(), |ty| { format!(\" for type `{}`\", ty) }),\n+            overlap\n+                .self_desc\n+                .clone()\n+                .map_or_else(String::new, |ty| { format!(\" for type `{}`\", ty) }),\n             match used_to_be_allowed {\n                 Some(FutureCompatOverlapErrorKind::Issue33140) => \" (E0119)\",\n                 _ => \"\",\n@@ -415,7 +418,7 @@ fn report_conflicting_impls(\n                     impl_span,\n                     format!(\n                         \"conflicting implementation{}\",\n-                        overlap.self_desc.map_or(String::new(), |ty| format!(\" for `{}`\", ty))\n+                        overlap.self_desc.map_or_else(String::new, |ty| format!(\" for `{}`\", ty))\n                     ),\n                 );\n             }"}, {"sha": "38ff88553e8d1e77218a174b56cb208c02b9c3dc", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -1716,7 +1716,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             } else {\n                 self.fcx\n                     .associated_item(def_id, name, Namespace::ValueNS)\n-                    .map_or(Vec::new(), |x| vec![x])\n+                    .map_or_else(Vec::new, |x| vec![x])\n             }\n         } else {\n             self.tcx.associated_items(def_id).in_definition_order().copied().collect()"}, {"sha": "bb85336d7fb2d681ae9be5769ed1591ea577c390", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -1062,7 +1062,10 @@ fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, span: Span) {\n         E0533,\n         \"expected unit struct, unit variant or constant, found {}{}\",\n         res.descr(),\n-        tcx.sess.source_map().span_to_snippet(span).map_or(String::new(), |s| format!(\" `{}`\", s)),\n+        tcx.sess\n+            .source_map()\n+            .span_to_snippet(span)\n+            .map_or_else(|_| String::new(), |s| format!(\" `{}`\", s)),\n     )\n     .emit();\n }"}, {"sha": "f8ca916caf127b5f13c248478f9b50183437b017", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -879,7 +879,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let sm = tcx.sess.source_map();\n             let path_str = sm\n                 .span_to_snippet(sm.span_until_char(pat.span, '('))\n-                .map_or(String::new(), |s| format!(\" `{}`\", s.trim_end()));\n+                .map_or_else(|_| String::new(), |s| format!(\" `{}`\", s.trim_end()));\n             let msg = format!(\n                 \"expected tuple struct or tuple variant, found {}{}\",\n                 res.descr(),"}, {"sha": "af82a3bb4f59a31189f79518dec55b238ab1ff78", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -348,9 +348,9 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 let min_list_wb = min_list\n                     .iter()\n                     .map(|captured_place| {\n-                        let locatable = captured_place.info.path_expr_id.unwrap_or(\n-                            self.tcx().hir().local_def_id_to_hir_id(closure_def_id.expect_local()),\n-                        );\n+                        let locatable = captured_place.info.path_expr_id.unwrap_or_else(|| {\n+                            self.tcx().hir().local_def_id_to_hir_id(closure_def_id.expect_local())\n+                        });\n \n                         self.resolve(captured_place.clone(), &locatable)\n                     })"}, {"sha": "9fbc56f051beba0f20033b61cbf225001c528605", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -2387,7 +2387,7 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n                     .sess\n                     .source_map()\n                     .span_to_snippet(ast_ty.span)\n-                    .map_or(String::new(), |s| format!(\" `{}`\", s));\n+                    .map_or_else(|_| String::new(), |s| format!(\" `{}`\", s));\n                 tcx.sess\n                     .struct_span_err(\n                         ast_ty.span,"}, {"sha": "9c92d96dc70594bc8c34a3d668c715d81e0d66dd", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -6,7 +6,6 @@\n #![feature(exact_size_is_empty)]\n #![feature(new_uninit)]\n #![feature(pattern)]\n-#![feature(str_split_once)]\n #![feature(trusted_len)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]"}, {"sha": "50ccc2a2eaba1973cfd938a43fd5546010f65386", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -1506,13 +1506,11 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(str_split_once)]\n-    ///\n     /// assert_eq!(\"cfg\".split_once('='), None);\n     /// assert_eq!(\"cfg=foo\".split_once('='), Some((\"cfg\", \"foo\")));\n     /// assert_eq!(\"cfg=foo=bar\".split_once('='), Some((\"cfg\", \"foo=bar\")));\n     /// ```\n-    #[unstable(feature = \"str_split_once\", reason = \"newly added\", issue = \"74773\")]\n+    #[stable(feature = \"str_split_once\", since = \"1.52.0\")]\n     #[inline]\n     pub fn split_once<'a, P: Pattern<'a>>(&'a self, delimiter: P) -> Option<(&'a str, &'a str)> {\n         let (start, end) = delimiter.into_searcher(self).next_match()?;\n@@ -1525,13 +1523,11 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(str_split_once)]\n-    ///\n     /// assert_eq!(\"cfg\".rsplit_once('='), None);\n     /// assert_eq!(\"cfg=foo\".rsplit_once('='), Some((\"cfg\", \"foo\")));\n     /// assert_eq!(\"cfg=foo=bar\".rsplit_once('='), Some((\"cfg=foo\", \"bar\")));\n     /// ```\n-    #[unstable(feature = \"str_split_once\", reason = \"newly added\", issue = \"74773\")]\n+    #[stable(feature = \"str_split_once\", since = \"1.52.0\")]\n     #[inline]\n     pub fn rsplit_once<'a, P>(&'a self, delimiter: P) -> Option<(&'a str, &'a str)>\n     where"}, {"sha": "63b65d8b413837b10cac4551873f28defa23865a", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -314,7 +314,6 @@\n #![feature(stdsimd)]\n #![feature(stmt_expr_attributes)]\n #![feature(str_internals)]\n-#![feature(str_split_once)]\n #![feature(test)]\n #![feature(thread_local)]\n #![feature(thread_local_internals)]"}, {"sha": "3415eaa9fb345cfae0ed73bd2ccd3d6cc00db0b9", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -31,7 +31,6 @@\n #![feature(termination_trait_lib)]\n #![feature(test)]\n #![feature(total_cmp)]\n-#![feature(str_split_once)]\n \n // Public reexports\n pub use self::bench::{black_box, Bencher};"}, {"sha": "58e9e41e6a53ce5eae5fa1c28d039e1abfd2eed2", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -883,6 +883,8 @@ themePicker.onblur = handleThemeButtonsBlur;\n         static_files::NORMALIZE_CSS,\n         options.enable_minification,\n     )?;\n+    write(cx.dst.join(\"FiraSans-Regular.woff2\"), static_files::fira_sans::REGULAR2)?;\n+    write(cx.dst.join(\"FiraSans-Medium.woff2\"), static_files::fira_sans::MEDIUM2)?;\n     write(cx.dst.join(\"FiraSans-Regular.woff\"), static_files::fira_sans::REGULAR)?;\n     write(cx.dst.join(\"FiraSans-Medium.woff\"), static_files::fira_sans::MEDIUM)?;\n     write(cx.dst.join(\"FiraSans-LICENSE.txt\"), static_files::fira_sans::LICENSE)?;"}, {"sha": "7a1e5fc548ef28137a32150b6aa50a568cd53d02", "filename": "src/librustdoc/html/static/FiraSans-Medium.woff2", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Flibrustdoc%2Fhtml%2Fstatic%2FFiraSans-Medium.woff2", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Flibrustdoc%2Fhtml%2Fstatic%2FFiraSans-Medium.woff2", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2FFiraSans-Medium.woff2?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464"}, {"sha": "e766e06ccb0d457fcdc8d4428efb796c7772a497", "filename": "src/librustdoc/html/static/FiraSans-Regular.woff2", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Flibrustdoc%2Fhtml%2Fstatic%2FFiraSans-Regular.woff2", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Flibrustdoc%2Fhtml%2Fstatic%2FFiraSans-Regular.woff2", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2FFiraSans-Regular.woff2?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464"}, {"sha": "0e0426279183f631fd297c1d4b4bb0c65b475457", "filename": "src/librustdoc/html/static/normalize.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fnormalize.css", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fnormalize.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fnormalize.css?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -1,2 +1,2 @@\n /* ignore-tidy-linelength */\n-/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}main{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details{display:block}summary{display:list-item}template{display:none}[hidden]{display:none}\n+/*! normalize.css v3.0.0 | MIT License | git.io/normalize */html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-0.5em}sub{bottom:-0.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type=\"button\"],input[type=\"reset\"],input[type=\"submit\"]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=\"checkbox\"],input[type=\"radio\"]{box-sizing:border-box;padding:0}input[type=\"number\"]::-webkit-inner-spin-button,input[type=\"number\"]::-webkit-outer-spin-button{height:auto}input[type=\"search\"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type=\"search\"]::-webkit-search-cancel-button,input[type=\"search\"]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:bold}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}"}, {"sha": "e3d63fa2308e256387198780067fdd3cd3a3d472", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -3,13 +3,17 @@\n \tfont-family: 'Fira Sans';\n \tfont-style: normal;\n \tfont-weight: 400;\n-\tsrc: local('Fira Sans'), url(\"FiraSans-Regular.woff\") format('woff');\n+\tsrc: local('Fira Sans'),\n+\t\turl(\"FiraSans-Regular.woff2\") format(\"woff2\"),\n+\t\turl(\"FiraSans-Regular.woff\") format('woff');\n }\n @font-face {\n \tfont-family: 'Fira Sans';\n \tfont-style: normal;\n \tfont-weight: 500;\n-\tsrc: local('Fira Sans Medium'), url(\"FiraSans-Medium.woff\") format('woff');\n+\tsrc: local('Fira Sans Medium'),\n+\t\turl(\"FiraSans-Medium.woff2\") format(\"woff2\"),\n+\t\turl(\"FiraSans-Medium.woff\") format('woff');\n }\n \n /* See SourceSerifPro-LICENSE.txt for the Source Serif Pro license. */"}, {"sha": "701e106df67f3d765813aadc4d69c8a0ee48077a", "filename": "src/librustdoc/html/static_files.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -76,9 +76,15 @@ crate mod fira_sans {\n     /// The file `FiraSans-Regular.woff`, the Regular variant of the Fira Sans font.\n     crate static REGULAR: &[u8] = include_bytes!(\"static/FiraSans-Regular.woff\");\n \n+    /// The file `FiraSans-Regular.woff2`, the Regular variant of the Fira Sans font in woff2.\n+    crate static REGULAR2: &[u8] = include_bytes!(\"static/FiraSans-Regular.woff2\");\n+\n     /// The file `FiraSans-Medium.woff`, the Medium variant of the Fira Sans font.\n     crate static MEDIUM: &[u8] = include_bytes!(\"static/FiraSans-Medium.woff\");\n \n+    /// The file `FiraSans-Medium.woff2`, the Medium variant of the Fira Sans font in woff2.\n+    crate static MEDIUM2: &[u8] = include_bytes!(\"static/FiraSans-Medium.woff2\");\n+\n     /// The file `FiraSans-LICENSE.txt`, the license text for the Fira Sans font.\n     crate static LICENSE: &[u8] = include_bytes!(\"static/FiraSans-LICENSE.txt\");\n }"}, {"sha": "2342ed3ab670de0c9373f8b1c2704db2039e0058", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -14,7 +14,6 @@\n #![feature(never_type)]\n #![feature(once_cell)]\n #![feature(type_ascription)]\n-#![feature(str_split_once)]\n #![feature(iter_intersperse)]\n #![recursion_limit = \"256\"]\n #![deny(rustc::internal)]"}, {"sha": "654a3bcc92dd83dc6b7b3eb387056c65aa52bbdd", "filename": "src/test/ui/async-await/dont-suggest-missing-await.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -2,11 +2,12 @@ error[E0308]: mismatched types\n   --> $DIR/dont-suggest-missing-await.rs:14:18\n    |\n LL | async fn make_u32() -> u32 {\n-   |                        --- the `Output` of this `async fn`'s found opaque type\n+   |                        --- checked the `Output` of this `async fn`, found opaque type\n ...\n LL |         take_u32(x)\n    |                  ^ expected `u32`, found opaque type\n    |\n+   = note: while checking the return type of the `async fn`\n    = note:     expected type `u32`\n            found opaque type `impl Future`\n help: consider `await`ing on the `Future`"}, {"sha": "04f191cc5e8cb4cd72d44f71d80e3d6c96a5797d", "filename": "src/test/ui/async-await/generator-desc.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Fasync-await%2Fgenerator-desc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Fasync-await%2Fgenerator-desc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fgenerator-desc.stderr?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -13,13 +13,15 @@ error[E0308]: mismatched types\n   --> $DIR/generator-desc.rs:12:16\n    |\n LL | async fn one() {}\n-   |                - the `Output` of this `async fn`'s expected opaque type\n+   |                - checked the `Output` of this `async fn`, expected opaque type\n LL | async fn two() {}\n-   |                - the `Output` of this `async fn`'s found opaque type\n+   |                - checked the `Output` of this `async fn`, found opaque type\n ...\n LL |     fun(one(), two());\n    |                ^^^^^ expected opaque type, found a different opaque type\n    |\n+   = note: while checking the return type of the `async fn`\n+   = note: while checking the return type of the `async fn`\n    = note: expected opaque type `impl Future` (opaque type at <$DIR/generator-desc.rs:5:16>)\n               found opaque type `impl Future` (opaque type at <$DIR/generator-desc.rs:6:16>)\n    = help: consider `await`ing on both `Future`s"}, {"sha": "4a8e841b33d49c5a32afbe6f7802afa11e4bce35", "filename": "src/test/ui/async-await/issue-61076.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -56,7 +56,7 @@ async fn struct_() -> Struct {\n }\n \n async fn tuple() -> Tuple {\n-    //~^ NOTE the `Output` of this `async fn`'s expected opaque type\n+    //~^ NOTE checked the `Output` of this `async fn`, expected opaque type\n     Tuple(1i32)\n }\n \n@@ -92,6 +92,7 @@ async fn match_() {\n         Tuple(_) => {} //~ ERROR mismatched types\n         //~^ NOTE expected opaque type, found struct `Tuple`\n         //~| NOTE expected opaque type `impl Future`\n+        //~| NOTE while checking the return type of the `async fn`\n     }\n }\n "}, {"sha": "fd00522fac70317cabfe065c2a6c4c9d10362173", "filename": "src/test/ui/async-await/issue-61076.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -61,11 +61,12 @@ error[E0308]: mismatched types\n   --> $DIR/issue-61076.rs:92:9\n    |\n LL | async fn tuple() -> Tuple {\n-   |                     ----- the `Output` of this `async fn`'s expected opaque type\n+   |                     ----- checked the `Output` of this `async fn`, expected opaque type\n ...\n LL |         Tuple(_) => {}\n    |         ^^^^^^^^ expected opaque type, found struct `Tuple`\n    |\n+   = note: while checking the return type of the `async fn`\n    = note: expected opaque type `impl Future`\n                    found struct `Tuple`\n help: consider `await`ing on the `Future`"}, {"sha": "483e52536a1b4eb8ba6d785ed957a8be35a6e6be", "filename": "src/test/ui/async-await/suggest-missing-await-closure.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.stderr?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -2,11 +2,12 @@ error[E0308]: mismatched types\n   --> $DIR/suggest-missing-await-closure.rs:16:18\n    |\n LL | async fn make_u32() -> u32 {\n-   |                        --- the `Output` of this `async fn`'s found opaque type\n+   |                        --- checked the `Output` of this `async fn`, found opaque type\n ...\n LL |         take_u32(x)\n    |                  ^ expected `u32`, found opaque type\n    |\n+   = note: while checking the return type of the `async fn`\n    = note:     expected type `u32`\n            found opaque type `impl Future`\n help: consider `await`ing on the `Future`"}, {"sha": "14b5ee95ee8ba6fa3df34fb88be34eadf9e23886", "filename": "src/test/ui/async-await/suggest-missing-await.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -2,11 +2,12 @@ error[E0308]: mismatched types\n   --> $DIR/suggest-missing-await.rs:12:14\n    |\n LL | async fn make_u32() -> u32 {\n-   |                        --- the `Output` of this `async fn`'s found opaque type\n+   |                        --- checked the `Output` of this `async fn`, found opaque type\n ...\n LL |     take_u32(x)\n    |              ^ expected `u32`, found opaque type\n    |\n+   = note: while checking the return type of the `async fn`\n    = note:     expected type `u32`\n            found opaque type `impl Future`\n help: consider `await`ing on the `Future`\n@@ -18,11 +19,12 @@ error[E0308]: mismatched types\n   --> $DIR/suggest-missing-await.rs:22:5\n    |\n LL | async fn dummy() {}\n-   |                  - the `Output` of this `async fn`'s found opaque type\n+   |                  - checked the `Output` of this `async fn`, found opaque type\n ...\n LL |     dummy()\n    |     ^^^^^^^ expected `()`, found opaque type\n    |\n+   = note: while checking the return type of the `async fn`\n    = note: expected unit type `()`\n             found opaque type `impl Future`\n help: consider `await`ing on the `Future`"}, {"sha": "3cb2c90d0d34822f5ac271bbf6ab7d8e9b57116a", "filename": "src/test/ui/lint/unused_variables-issue-82488.fixed", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Flint%2Funused_variables-issue-82488.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Flint%2Funused_variables-issue-82488.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_variables-issue-82488.fixed?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+#![deny(unused_variables)]\n+\n+struct Point {\n+    x: u32,\n+    y: u32\n+}\n+\n+fn process_point(Point { x, y: _renamed }: Point) {\n+//~^ ERROR unused variable: `renamed`\n+    let _ = x;\n+}\n+\n+fn main() {\n+    process_point(Point { x: 0, y: 0 });\n+}"}, {"sha": "007b0799bbb0d9e81eca0a5412332b2d037381f9", "filename": "src/test/ui/lint/unused_variables-issue-82488.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Flint%2Funused_variables-issue-82488.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Flint%2Funused_variables-issue-82488.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_variables-issue-82488.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+#![deny(unused_variables)]\n+\n+struct Point {\n+    x: u32,\n+    y: u32\n+}\n+\n+fn process_point(Point { x, y: renamed }: Point) {\n+//~^ ERROR unused variable: `renamed`\n+    let _ = x;\n+}\n+\n+fn main() {\n+    process_point(Point { x: 0, y: 0 });\n+}"}, {"sha": "dce03a0f738b3957bf67394def902b1fdd2c9349", "filename": "src/test/ui/lint/unused_variables-issue-82488.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Flint%2Funused_variables-issue-82488.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Flint%2Funused_variables-issue-82488.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_variables-issue-82488.stderr?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -0,0 +1,14 @@\n+error: unused variable: `renamed`\n+  --> $DIR/unused_variables-issue-82488.rs:9:32\n+   |\n+LL | fn process_point(Point { x, y: renamed }: Point) {\n+   |                                ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_renamed`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unused_variables-issue-82488.rs:2:9\n+   |\n+LL | #![deny(unused_variables)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "2e513415e6c64fdbcf862e3fe1a333ba2781ccf2", "filename": "src/test/ui/parser/fn-header-semantic-fail.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -189,9 +189,10 @@ LL |         async fn ft1();\n LL |         async fn ft1() {}\n    |                        ^\n    |                        |\n-   |                        the `Output` of this `async fn`'s found opaque type\n+   |                        checked the `Output` of this `async fn`, found opaque type\n    |                        expected `()`, found opaque type\n    |\n+   = note: while checking the return type of the `async fn`\n    = note: expected fn pointer `fn()`\n               found fn pointer `fn() -> impl Future`\n \n@@ -204,9 +205,10 @@ LL |         const async unsafe extern \"C\" fn ft5();\n LL |         const async unsafe extern \"C\" fn ft5() {}\n    |                                                ^\n    |                                                |\n-   |                                                the `Output` of this `async fn`'s found opaque type\n+   |                                                checked the `Output` of this `async fn`, found opaque type\n    |                                                expected `()`, found opaque type\n    |\n+   = note: while checking the return type of the `async fn`\n    = note: expected fn pointer `unsafe extern \"C\" fn()`\n               found fn pointer `unsafe extern \"C\" fn() -> impl Future`\n "}, {"sha": "4025b5030dc0fc8b49f6eb4ea7768a62e062da00", "filename": "src/test/ui/resolve/issue-70736-async-fn-no-body-def-collector.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.stderr?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -53,9 +53,10 @@ LL |     async fn associated();\n LL |     async fn associated();\n    |                          ^\n    |                          |\n-   |                          the `Output` of this `async fn`'s found opaque type\n+   |                          checked the `Output` of this `async fn`, found opaque type\n    |                          expected `()`, found opaque type\n    |\n+   = note: while checking the return type of the `async fn`\n    = note: expected fn pointer `fn()`\n               found fn pointer `fn() -> impl Future`\n "}, {"sha": "f90765870873010b5d5562e90cb4e85ec9554ee8", "filename": "src/test/ui/suggestions/issue-81839.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Fsuggestions%2Fissue-81839.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Fsuggestions%2Fissue-81839.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-81839.stderr?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -17,8 +17,9 @@ LL | |     }\n   ::: $DIR/auxiliary/issue-81839.rs:6:49\n    |\n LL |       pub async fn answer_str(&self, _s: &str) -> Test {\n-   |                                                   ---- the `Output` of this `async fn`'s found opaque type\n+   |                                                   ---- checked the `Output` of this `async fn`, found opaque type\n    |\n+   = note: while checking the return type of the `async fn`\n    = note:     expected type `()`\n            found opaque type `impl Future`\n "}, {"sha": "3b2cff3140d639c45f64a85e52e71e92bfa8b944", "filename": "src/test/ui/suggestions/match-prev-arm-needing-semi.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -13,9 +13,9 @@ fn extra_semicolon() {\n     };\n }\n \n-async fn async_dummy() {} //~ NOTE the `Output` of this `async fn`'s found opaque type\n-async fn async_dummy2() {} //~ NOTE the `Output` of this `async fn`'s found opaque type\n-//~^ NOTE the `Output` of this `async fn`'s found opaque type\n+async fn async_dummy() {} //~ NOTE checked the `Output` of this `async fn`, found opaque type\n+async fn async_dummy2() {} //~ NOTE checked the `Output` of this `async fn`, found opaque type\n+//~| NOTE checked the `Output` of this `async fn`, found opaque type\n \n async fn async_extra_semicolon_same() {\n     let _ = match true { //~ NOTE `match` arms have incompatible types\n@@ -26,6 +26,7 @@ async fn async_extra_semicolon_same() {\n         false => async_dummy(), //~ ERROR `match` arms have incompatible types\n         //~^ NOTE expected `()`, found opaque type\n         //~| NOTE expected type `()`\n+        //~| NOTE while checking the return type of the `async fn`\n         //~| HELP consider `await`ing on the `Future`\n     };\n }\n@@ -39,6 +40,7 @@ async fn async_extra_semicolon_different() {\n         false => async_dummy2(), //~ ERROR `match` arms have incompatible types\n         //~^ NOTE expected `()`, found opaque type\n         //~| NOTE expected type `()`\n+        //~| NOTE while checking the return type of the `async fn`\n         //~| HELP consider `await`ing on the `Future`\n     };\n }\n@@ -51,6 +53,7 @@ async fn async_different_futures() {\n         //~^ NOTE expected opaque type, found a different opaque type\n         //~| NOTE expected type `impl Future`\n         //~| NOTE distinct uses of `impl Trait` result in different opaque types\n+        //~| NOTE while checking the return type of the `async fn`\n     };\n }\n "}, {"sha": "e31ea9679b51dca13f6af09618a6050f4d6531cb", "filename": "src/test/ui/suggestions/match-prev-arm-needing-semi.stderr", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -2,7 +2,7 @@ error[E0308]: `match` arms have incompatible types\n   --> $DIR/match-prev-arm-needing-semi.rs:26:18\n    |\n LL |   async fn async_dummy() {}\n-   |                          - the `Output` of this `async fn`'s found opaque type\n+   |                          - checked the `Output` of this `async fn`, found opaque type\n ...\n LL |       let _ = match true {\n    |  _____________-\n@@ -18,6 +18,7 @@ LL | |\n LL | |     };\n    | |_____- `match` arms have incompatible types\n    |\n+   = note: while checking the return type of the `async fn`\n    = note:     expected type `()`\n            found opaque type `impl Future`\n help: consider `await`ing on the `Future`\n@@ -30,10 +31,10 @@ LL |             async_dummy()\n    |                         --\n \n error[E0308]: `match` arms have incompatible types\n-  --> $DIR/match-prev-arm-needing-semi.rs:39:18\n+  --> $DIR/match-prev-arm-needing-semi.rs:40:18\n    |\n LL |   async fn async_dummy2() {}\n-   |                           - the `Output` of this `async fn`'s found opaque type\n+   |                           - checked the `Output` of this `async fn`, found opaque type\n ...\n LL |       let _ = match true {\n    |  _____________-\n@@ -49,6 +50,7 @@ LL | |\n LL | |     };\n    | |_____- `match` arms have incompatible types\n    |\n+   = note: while checking the return type of the `async fn`\n    = note:     expected type `()`\n            found opaque type `impl Future`\n help: consider `await`ing on the `Future`\n@@ -64,10 +66,10 @@ LL |         false => Box::new(async_dummy2()),\n    |\n \n error[E0308]: `match` arms have incompatible types\n-  --> $DIR/match-prev-arm-needing-semi.rs:50:18\n+  --> $DIR/match-prev-arm-needing-semi.rs:52:18\n    |\n LL |   async fn async_dummy2() {}\n-   |                           - the `Output` of this `async fn`'s found opaque type\n+   |                           - checked the `Output` of this `async fn`, found opaque type\n ...\n LL |       let _ = match true {\n    |  _____________-\n@@ -81,6 +83,7 @@ LL | |\n LL | |     };\n    | |_____- `match` arms have incompatible types\n    |\n+   = note: while checking the return type of the `async fn`\n    = note:     expected type `impl Future` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:16:24>)\n            found opaque type `impl Future` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:17:25>)\n    = note: distinct uses of `impl Trait` result in different opaque types"}, {"sha": "01e067ea0b803f81023735b918d457f314c548f4", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -14,7 +14,7 @@\n //! A few exceptions are allowed as there's known bugs in rustdoc, but this\n //! should catch the majority of \"broken link\" cases.\n \n-#![feature(str_split_once)]\n+#![cfg_attr(bootstrap, feature(str_split_once))]\n \n use std::collections::hash_map::Entry;\n use std::collections::{HashMap, HashSet};"}, {"sha": "11d36751f67bb0b6a2b725d877a2e152164a3f0d", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c09c1f7cfcf9de0522bcd1cfda32b552195c464/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=9c09c1f7cfcf9de0522bcd1cfda32b552195c464", "patch": "@@ -3,7 +3,7 @@\n //! This library contains the tidy lints and exposes it\n //! to be used by tools.\n \n-#![feature(str_split_once)]\n+#![cfg_attr(bootstrap, feature(str_split_once))]\n \n use std::fs::File;\n use std::io::Read;"}]}