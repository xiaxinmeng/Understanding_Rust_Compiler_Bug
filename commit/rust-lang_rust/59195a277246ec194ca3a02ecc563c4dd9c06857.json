{"sha": "59195a277246ec194ca3a02ecc563c4dd9c06857", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5MTk1YTI3NzI0NmVjMTk0Y2EzYTAyZWNjNTYzYzRkZDljMDY4NTc=", "commit": {"author": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2021-01-25T05:23:38Z"}, "committer": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2021-01-25T05:27:41Z"}, "message": "rustc_codegen_ssa: use wall time for codegen_to_LLVM_IR time-passes entry\n\nUse elapsed wall time spent on codegen_to_LLVM_IR for all CGUs as a\nwhole, rather than the sum for each CGU (the distinction matters for\nparallel builds, where some CGUs are processed in parallel).", "tree": {"sha": "4fd5d6079aa7adddaba174c1638d090b9623b9f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fd5d6079aa7adddaba174c1638d090b9623b9f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59195a277246ec194ca3a02ecc563c4dd9c06857", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59195a277246ec194ca3a02ecc563c4dd9c06857", "html_url": "https://github.com/rust-lang/rust/commit/59195a277246ec194ca3a02ecc563c4dd9c06857", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59195a277246ec194ca3a02ecc563c4dd9c06857/comments", "author": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14265f9c5558e599ba8908cffc717f26389420e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/14265f9c5558e599ba8908cffc717f26389420e1", "html_url": "https://github.com/rust-lang/rust/commit/14265f9c5558e599ba8908cffc717f26389420e1"}], "stats": {"total": 31, "additions": 14, "deletions": 17}, "files": [{"sha": "ad72dc0086b61996957af98ddd30c3d1f3aca306", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/59195a277246ec194ca3a02ecc563c4dd9c06857/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59195a277246ec194ca3a02ecc563c4dd9c06857/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=59195a277246ec194ca3a02ecc563c4dd9c06857", "patch": "@@ -13,7 +13,7 @@ use crate::{CachedModuleCodegen, CrateInfo, MemFlags, ModuleCodegen, ModuleKind}\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::print_time_passes_entry;\n-use rustc_data_structures::sync::{par_iter, Lock, ParallelIterator};\n+use rustc_data_structures::sync::{par_iter, ParallelIterator};\n use rustc_hir as hir;\n use rustc_hir::def_id::{LocalDefId, LOCAL_CRATE};\n use rustc_hir::lang_items::LangItem;\n@@ -554,8 +554,6 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         codegen_units\n     };\n \n-    let total_codegen_time = Lock::new(Duration::new(0, 0));\n-\n     // The non-parallel compiler can only translate codegen units to LLVM IR\n     // on a single thread, leading to a staircase effect where the N LLVM\n     // threads have to wait on the single codegen threads to generate work\n@@ -578,23 +576,25 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n                     .collect();\n \n                 // Compile the found CGUs in parallel.\n-                par_iter(cgus)\n+                let start_time = Instant::now();\n+\n+                let pre_compiled_cgus = par_iter(cgus)\n                     .map(|(i, _)| {\n-                        let start_time = Instant::now();\n                         let module = backend.compile_codegen_unit(tcx, codegen_units[i].name());\n-                        let mut time = total_codegen_time.lock();\n-                        *time += start_time.elapsed();\n                         (i, module)\n                     })\n-                    .collect()\n+                    .collect();\n+\n+                (pre_compiled_cgus, start_time.elapsed())\n             })\n         } else {\n-            FxHashMap::default()\n+            (FxHashMap::default(), Duration::new(0, 0))\n         }\n     };\n \n     let mut cgu_reuse = Vec::new();\n     let mut pre_compiled_cgus: Option<FxHashMap<usize, _>> = None;\n+    let mut total_codegen_time = Duration::new(0, 0);\n \n     for (i, cgu) in codegen_units.iter().enumerate() {\n         ongoing_codegen.wait_for_signal_to_codegen_item();\n@@ -607,7 +607,9 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n                 codegen_units.iter().map(|cgu| determine_cgu_reuse(tcx, &cgu)).collect()\n             });\n             // Pre compile some CGUs\n-            pre_compiled_cgus = Some(pre_compile_cgus(&cgu_reuse));\n+            let (compiled_cgus, codegen_time) = pre_compile_cgus(&cgu_reuse);\n+            pre_compiled_cgus = Some(compiled_cgus);\n+            total_codegen_time += codegen_time;\n         }\n \n         let cgu_reuse = cgu_reuse[i];\n@@ -621,8 +623,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n                     } else {\n                         let start_time = Instant::now();\n                         let module = backend.compile_codegen_unit(tcx, cgu.name());\n-                        let mut time = total_codegen_time.lock();\n-                        *time += start_time.elapsed();\n+                        total_codegen_time += start_time.elapsed();\n                         module\n                     };\n                 submit_codegened_module_to_llvm(\n@@ -663,11 +664,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n     // Since the main thread is sometimes blocked during codegen, we keep track\n     // -Ztime-passes output manually.\n-    print_time_passes_entry(\n-        tcx.sess.time_passes(),\n-        \"codegen_to_LLVM_IR\",\n-        total_codegen_time.into_inner(),\n-    );\n+    print_time_passes_entry(tcx.sess.time_passes(), \"codegen_to_LLVM_IR\", total_codegen_time);\n \n     ongoing_codegen.check_for_errors(tcx.sess);\n "}]}