{"sha": "eb69593f73be1e41d9e2ef065010a47478c14924", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNjk1OTNmNzNiZTFlNDFkOWUyZWYwNjUwMTBhNDc0NzhjMTQ5MjQ=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-03T15:51:03Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-12T20:53:03Z"}, "message": "Implement GlobalAlloc for System", "tree": {"sha": "993962e4a31a1616f969ea4118ed77ba57e51347", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/993962e4a31a1616f969ea4118ed77ba57e51347"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb69593f73be1e41d9e2ef065010a47478c14924", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb69593f73be1e41d9e2ef065010a47478c14924", "html_url": "https://github.com/rust-lang/rust/commit/eb69593f73be1e41d9e2ef065010a47478c14924", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb69593f73be1e41d9e2ef065010a47478c14924/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba7081a033de4981ccad1e1525c8b5191ce02208", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba7081a033de4981ccad1e1525c8b5191ce02208", "html_url": "https://github.com/rust-lang/rust/commit/ba7081a033de4981ccad1e1525c8b5191ce02208"}], "stats": {"total": 273, "additions": 145, "deletions": 128}, "files": [{"sha": "0480be8d913ae047ab64ac63072fc84d07d5b886", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 141, "deletions": 128, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/eb69593f73be1e41d9e2ef065010a47478c14924/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb69593f73be1e41d9e2ef065010a47478c14924/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=eb69593f73be1e41d9e2ef065010a47478c14924", "patch": "@@ -50,152 +50,197 @@ pub struct System;\n unsafe impl Alloc for System {\n     #[inline]\n     unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n-        (&*self).alloc(layout)\n+        Alloc::alloc(&mut &*self, layout)\n     }\n \n     #[inline]\n     unsafe fn alloc_zeroed(&mut self, layout: Layout)\n         -> Result<*mut u8, AllocErr>\n     {\n-        (&*self).alloc_zeroed(layout)\n+        Alloc::alloc_zeroed(&mut &*self, layout)\n     }\n \n     #[inline]\n     unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n-        (&*self).dealloc(ptr, layout)\n+        Alloc::dealloc(&mut &*self, ptr, layout)\n     }\n \n     #[inline]\n     unsafe fn realloc(&mut self,\n                       ptr: *mut u8,\n                       old_layout: Layout,\n                       new_layout: Layout) -> Result<*mut u8, AllocErr> {\n-        (&*self).realloc(ptr, old_layout, new_layout)\n+        Alloc::realloc(&mut &*self, ptr, old_layout, new_layout)\n     }\n \n     fn oom(&mut self, err: AllocErr) -> ! {\n-        (&*self).oom(err)\n+        Alloc::oom(&mut &*self, err)\n     }\n \n     #[inline]\n     fn usable_size(&self, layout: &Layout) -> (usize, usize) {\n-        (&self).usable_size(layout)\n+        Alloc::usable_size(&mut &*self, layout)\n     }\n \n     #[inline]\n     unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n-        (&*self).alloc_excess(layout)\n+        Alloc::alloc_excess(&mut &*self, layout)\n     }\n \n     #[inline]\n     unsafe fn realloc_excess(&mut self,\n                              ptr: *mut u8,\n                              layout: Layout,\n                              new_layout: Layout) -> Result<Excess, AllocErr> {\n-        (&*self).realloc_excess(ptr, layout, new_layout)\n+        Alloc::realloc_excess(&mut &*self, ptr, layout, new_layout)\n     }\n \n     #[inline]\n     unsafe fn grow_in_place(&mut self,\n                             ptr: *mut u8,\n                             layout: Layout,\n                             new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-        (&*self).grow_in_place(ptr, layout, new_layout)\n+        Alloc::grow_in_place(&mut &*self, ptr, layout, new_layout)\n     }\n \n     #[inline]\n     unsafe fn shrink_in_place(&mut self,\n                               ptr: *mut u8,\n                               layout: Layout,\n                               new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-        (&*self).shrink_in_place(ptr, layout, new_layout)\n+        Alloc::shrink_in_place(&mut &*self, ptr, layout, new_layout)\n+    }\n+}\n+\n+#[cfg(any(windows, unix, target_os = \"cloudabi\", target_os = \"redox\"))]\n+mod realloc_fallback {\n+    use core::alloc::{GlobalAlloc, Void, Layout};\n+    use core::cmp;\n+    use core::ptr;\n+\n+    impl super::System {\n+        pub(crate) unsafe fn realloc_fallback(&self, ptr: *mut Void, old_layout: Layout,\n+                                              new_size: usize) -> *mut Void {\n+            // Docs for GlobalAlloc::realloc require this to be valid:\n+            let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n+\n+            let new_ptr = GlobalAlloc::alloc(self, new_layout);\n+            if !new_ptr.is_null() {\n+                let size = cmp::min(old_layout.size(), new_size);\n+                ptr::copy_nonoverlapping(ptr as *mut u8, new_ptr as *mut u8, size);\n+                GlobalAlloc::dealloc(self, ptr, old_layout);\n+            }\n+            new_ptr\n+        }\n+    }\n+}\n+\n+macro_rules! alloc_methods_based_on_global_alloc {\n+    () => {\n+        #[inline]\n+        unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+            let ptr = GlobalAlloc::alloc(*self, layout);\n+            if !ptr.is_null() {\n+                Ok(ptr as *mut u8)\n+            } else {\n+                Err(AllocErr)\n+            }\n+        }\n+\n+        #[inline]\n+        unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+            let ptr = GlobalAlloc::alloc_zeroed(*self, layout);\n+            if !ptr.is_null() {\n+                Ok(ptr as *mut u8)\n+            } else {\n+                Err(AllocErr)\n+            }\n+        }\n+\n+        #[inline]\n+        unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n+            GlobalAlloc::dealloc(*self, ptr as *mut Void, layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn realloc(&mut self,\n+                          ptr: *mut u8,\n+                          old_layout: Layout,\n+                          new_layout: Layout) -> Result<*mut u8, AllocErr> {\n+            if old_layout.align() != new_layout.align() {\n+                return Err(AllocErr)\n+            }\n+\n+            let ptr = GlobalAlloc::realloc(*self, ptr as *mut Void, old_layout, new_layout.size());\n+            if !ptr.is_null() {\n+                Ok(ptr as *mut u8)\n+            } else {\n+                Err(AllocErr)\n+            }\n+        }\n     }\n }\n \n #[cfg(any(unix, target_os = \"cloudabi\", target_os = \"redox\"))]\n mod platform {\n     extern crate libc;\n \n-    use core::cmp;\n     use core::ptr;\n \n     use MIN_ALIGN;\n     use System;\n-    use core::alloc::{Alloc, AllocErr, Layout};\n+    use core::alloc::{GlobalAlloc, Alloc, AllocErr, Layout, Void};\n \n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    unsafe impl<'a> Alloc for &'a System {\n+    unsafe impl GlobalAlloc for System {\n         #[inline]\n-        unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n-            let ptr = if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-                libc::malloc(layout.size()) as *mut u8\n+        unsafe fn alloc(&self, layout: Layout) -> *mut Void {\n+            if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n+                libc::malloc(layout.size()) as *mut Void\n             } else {\n                 #[cfg(target_os = \"macos\")]\n                 {\n                     if layout.align() > (1 << 31) {\n-                        return Err(AllocErr)\n+                        // FIXME: use Void::null_mut https://github.com/rust-lang/rust/issues/49659\n+                        return 0 as *mut Void\n                     }\n                 }\n                 aligned_malloc(&layout)\n-            };\n-            if !ptr.is_null() {\n-                Ok(ptr)\n-            } else {\n-                Err(AllocErr)\n             }\n         }\n \n         #[inline]\n-        unsafe fn alloc_zeroed(&mut self, layout: Layout)\n-            -> Result<*mut u8, AllocErr>\n-        {\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Void {\n             if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-                let ptr = libc::calloc(layout.size(), 1) as *mut u8;\n-                if !ptr.is_null() {\n-                    Ok(ptr)\n-                } else {\n-                    Err(AllocErr)\n-                }\n+                libc::calloc(layout.size(), 1) as *mut Void\n             } else {\n-                let ret = self.alloc(layout.clone());\n-                if let Ok(ptr) = ret {\n-                    ptr::write_bytes(ptr, 0, layout.size());\n+                let ptr = self.alloc(layout.clone());\n+                if !ptr.is_null() {\n+                    ptr::write_bytes(ptr as *mut u8, 0, layout.size());\n                 }\n-                ret\n+                ptr\n             }\n         }\n \n         #[inline]\n-        unsafe fn dealloc(&mut self, ptr: *mut u8, _layout: Layout) {\n+        unsafe fn dealloc(&self, ptr: *mut Void, _layout: Layout) {\n             libc::free(ptr as *mut libc::c_void)\n         }\n \n         #[inline]\n-        unsafe fn realloc(&mut self,\n-                          ptr: *mut u8,\n-                          old_layout: Layout,\n-                          new_layout: Layout) -> Result<*mut u8, AllocErr> {\n-            if old_layout.align() != new_layout.align() {\n-                return Err(AllocErr)\n-            }\n-\n-            if new_layout.align() <= MIN_ALIGN  && new_layout.align() <= new_layout.size(){\n-                let ptr = libc::realloc(ptr as *mut libc::c_void, new_layout.size());\n-                if !ptr.is_null() {\n-                    Ok(ptr as *mut u8)\n-                } else {\n-                    Err(AllocErr)\n-                }\n+        unsafe fn realloc(&self, ptr: *mut Void, old_layout: Layout, new_size: usize) -> *mut Void {\n+            let align = old_layout.align();\n+            if align <= MIN_ALIGN && align <= new_size {\n+                libc::realloc(ptr as *mut libc::c_void, new_size) as *mut Void\n             } else {\n-                let res = self.alloc(new_layout.clone());\n-                if let Ok(new_ptr) = res {\n-                    let size = cmp::min(old_layout.size(), new_layout.size());\n-                    ptr::copy_nonoverlapping(ptr, new_ptr, size);\n-                    self.dealloc(ptr, old_layout);\n-                }\n-                res\n+                self.realloc_fallback(ptr, old_layout, new_size)\n             }\n         }\n+    }\n+\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    unsafe impl<'a> Alloc for &'a System {\n+        alloc_methods_based_on_global_alloc!();\n \n         fn oom(&mut self, err: AllocErr) -> ! {\n             use core::fmt::{self, Write};\n@@ -237,7 +282,7 @@ mod platform {\n \n     #[cfg(any(target_os = \"android\", target_os = \"redox\", target_os = \"solaris\"))]\n     #[inline]\n-    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+    unsafe fn aligned_malloc(layout: &Layout) -> *mut Void {\n         // On android we currently target API level 9 which unfortunately\n         // doesn't have the `posix_memalign` API used below. Instead we use\n         // `memalign`, but this unfortunately has the property on some systems\n@@ -255,31 +300,30 @@ mod platform {\n         // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n         // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n         //                                       /memory/aligned_memory.cc\n-        libc::memalign(layout.align(), layout.size()) as *mut u8\n+        libc::memalign(layout.align(), layout.size()) as *mut Void\n     }\n \n     #[cfg(not(any(target_os = \"android\", target_os = \"redox\", target_os = \"solaris\")))]\n     #[inline]\n-    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+    unsafe fn aligned_malloc(layout: &Layout) -> *mut Void {\n         let mut out = ptr::null_mut();\n         let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n         if ret != 0 {\n-            ptr::null_mut()\n+            0 as *mut Void\n         } else {\n-            out as *mut u8\n+            out as *mut Void\n         }\n     }\n }\n \n #[cfg(windows)]\n #[allow(bad_style)]\n mod platform {\n-    use core::cmp;\n     use core::ptr;\n \n     use MIN_ALIGN;\n     use System;\n-    use core::alloc::{Alloc, AllocErr, Layout, CannotReallocInPlace};\n+    use core::alloc::{GlobalAlloc, Alloc, Void, AllocErr, Layout, CannotReallocInPlace};\n \n     type LPVOID = *mut u8;\n     type HANDLE = LPVOID;\n@@ -323,9 +367,7 @@ mod platform {\n     }\n \n     #[inline]\n-    unsafe fn allocate_with_flags(layout: Layout, flags: DWORD)\n-        -> Result<*mut u8, AllocErr>\n-    {\n+    unsafe fn allocate_with_flags(layout: Layout, flags: DWORD) -> *mut Void {\n         let ptr = if layout.align() <= MIN_ALIGN {\n             HeapAlloc(GetProcessHeap(), flags, layout.size())\n         } else {\n@@ -337,70 +379,49 @@ mod platform {\n                 align_ptr(ptr, layout.align())\n             }\n         };\n-        if ptr.is_null() {\n-            Err(AllocErr)\n-        } else {\n-            Ok(ptr as *mut u8)\n-        }\n+        ptr as *mut Void\n     }\n \n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    unsafe impl<'a> Alloc for &'a System {\n+    unsafe impl GlobalAlloc for System {\n         #[inline]\n-        unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+        unsafe fn alloc(&self, layout: Layout) -> *mut Void {\n             allocate_with_flags(layout, 0)\n         }\n \n         #[inline]\n-        unsafe fn alloc_zeroed(&mut self, layout: Layout)\n-            -> Result<*mut u8, AllocErr>\n-        {\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Void {\n             allocate_with_flags(layout, HEAP_ZERO_MEMORY)\n         }\n \n         #[inline]\n-        unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n+        unsafe fn dealloc(&self, ptr: *mut Void, layout: Layout) {\n             if layout.align() <= MIN_ALIGN {\n                 let err = HeapFree(GetProcessHeap(), 0, ptr as LPVOID);\n                 debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n                               GetLastError());\n             } else {\n-                let header = get_header(ptr);\n+                let header = get_header(ptr as *mut u8);\n                 let err = HeapFree(GetProcessHeap(), 0, header.0 as LPVOID);\n                 debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n                               GetLastError());\n             }\n         }\n \n         #[inline]\n-        unsafe fn realloc(&mut self,\n-                          ptr: *mut u8,\n-                          old_layout: Layout,\n-                          new_layout: Layout) -> Result<*mut u8, AllocErr> {\n-            if old_layout.align() != new_layout.align() {\n-                return Err(AllocErr)\n-            }\n-\n-            if new_layout.align() <= MIN_ALIGN {\n-                let ptr = HeapReAlloc(GetProcessHeap(),\n-                                      0,\n-                                      ptr as LPVOID,\n-                                      new_layout.size());\n-                if !ptr.is_null() {\n-                    Ok(ptr as *mut u8)\n-                } else {\n-                    Err(AllocErr)\n-                }\n+        unsafe fn realloc(&self, ptr: *mut Void, old_layout: Layout, new_size: usize) -> *mut Void {\n+            let align = old_layout.align();\n+            if align <= MIN_ALIGN {\n+                HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, new_size) as *mut Void\n             } else {\n-                let res = self.alloc(new_layout.clone());\n-                if let Ok(new_ptr) = res {\n-                    let size = cmp::min(old_layout.size(), new_layout.size());\n-                    ptr::copy_nonoverlapping(ptr, new_ptr, size);\n-                    self.dealloc(ptr, old_layout);\n-                }\n-                res\n+                self.realloc_fallback(ptr, old_layout, new_size)\n             }\n         }\n+    }\n+\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    unsafe impl<'a> Alloc for &'a System {\n+        alloc_methods_based_on_global_alloc!();\n \n         #[inline]\n         unsafe fn grow_in_place(&mut self,\n@@ -489,45 +510,37 @@ mod platform {\n mod platform {\n     extern crate dlmalloc;\n \n-    use core::alloc::{Alloc, AllocErr, Layout};\n+    use core::alloc::{GlobalAlloc, Alloc, AllocErr, Layout, Void};\n     use System;\n \n     // No need for synchronization here as wasm is currently single-threaded\n     static mut DLMALLOC: dlmalloc::Dlmalloc = dlmalloc::DLMALLOC_INIT;\n \n-    fn to_result(ptr: *mut u8) -> Result<*mut u8, AllocErr> {\n-        if !ptr.is_null() {\n-            Ok(ptr)\n-        } else {\n-            Err(AllocErr)\n-        }\n-    }\n-\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    unsafe impl<'a> Alloc for &'a System {\n+    unsafe impl GlobalAlloc for System {\n         #[inline]\n-        unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n-            to_result(DLMALLOC.malloc(layout.size(), layout.align()))\n+        unsafe fn alloc(&self, layout: Layout) -> *mut Void {\n+            DLMALLOC.malloc(layout.size(), layout.align()) as *mut Void\n         }\n \n         #[inline]\n-        unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n-            to_result(DLMALLOC.calloc(layout.size(), layout.align()))\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Void {\n+            DLMALLOC.calloc(layout.size(), layout.align()) as *mut Void\n         }\n \n         #[inline]\n-        unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n-            DLMALLOC.free(ptr, layout.size(), layout.align())\n+        unsafe fn dealloc(&self, ptr: *mut Void, layout: Layout) {\n+            DLMALLOC.free(ptr as *mut u8, layout.size(), layout.align())\n         }\n \n         #[inline]\n-        unsafe fn realloc(&mut self,\n-                          ptr: *mut u8,\n-                          old_layout: Layout,\n-                          new_layout: Layout) -> Result<*mut u8, AllocErr> {\n-            to_result(DLMALLOC.realloc(\n-                ptr, old_layout.size(), old_layout.align(), new_layout.size(),\n-            ))\n+        unsafe fn realloc(&self, ptr: *mut Void, layout: Layout, new_size: usize) -> *mut Void {\n+            DLMALLOC.realloc(ptr as *mut u8, layout.size(), layout.align(), new_size) as *mut Void\n         }\n     }\n+\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    unsafe impl<'a> Alloc for &'a System {\n+        alloc_methods_based_on_global_alloc!();\n+    }\n }"}, {"sha": "1c764dab000f8d857a1434d8f3204860a66fa441", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb69593f73be1e41d9e2ef065010a47478c14924/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb69593f73be1e41d9e2ef065010a47478c14924/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=eb69593f73be1e41d9e2ef065010a47478c14924", "patch": "@@ -381,6 +381,10 @@ pub unsafe trait GlobalAlloc {\n         ptr\n     }\n \n+    /// # Safety\n+    ///\n+    /// `new_size`, when rounded up to the nearest multiple of `old_layout.align()`,\n+    /// must not overflow (i.e. the rounded value must be less than `usize::MAX`).\n     unsafe fn realloc(&self, ptr: *mut Void, old_layout: Layout, new_size: usize) -> *mut Void {\n         let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n         let new_ptr = self.alloc(new_layout);"}]}