{"sha": "6cc49e51de7ea9b0cc4aff437975544233c57107", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjYzQ5ZTUxZGU3ZWE5YjBjYzRhZmY0Mzc5NzU1NDQyMzNjNTcxMDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-18T05:12:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-18T05:12:59Z"}, "message": "Auto merge of #34860 - jseyfried:encapsulate_hygiene, r=nrc\n\nClean up and encapsulate `syntax::ext::mtwt`, rename `mtwt` to `hygiene`\n\nr? @nrc", "tree": {"sha": "78fe6d19a51ef5a98b18e7198af09fba539fd219", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78fe6d19a51ef5a98b18e7198af09fba539fd219"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cc49e51de7ea9b0cc4aff437975544233c57107", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cc49e51de7ea9b0cc4aff437975544233c57107", "html_url": "https://github.com/rust-lang/rust/commit/6cc49e51de7ea9b0cc4aff437975544233c57107", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cc49e51de7ea9b0cc4aff437975544233c57107/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f441bca4993450e4a2f63bac382f9ebc4be274d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f441bca4993450e4a2f63bac382f9ebc4be274d1", "html_url": "https://github.com/rust-lang/rust/commit/f441bca4993450e4a2f63bac382f9ebc4be274d1"}, {"sha": "275d321ab099b4d7b0de71aa72a87eb27de120af", "url": "https://api.github.com/repos/rust-lang/rust/commits/275d321ab099b4d7b0de71aa72a87eb27de120af", "html_url": "https://github.com/rust-lang/rust/commit/275d321ab099b4d7b0de71aa72a87eb27de120af"}], "stats": {"total": 390, "additions": 157, "deletions": 233}, "files": [{"sha": "65b97abfccbd75f5cb456115f24431e70340939a", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6cc49e51de7ea9b0cc4aff437975544233c57107/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc49e51de7ea9b0cc4aff437975544233c57107/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=6cc49e51de7ea9b0cc4aff437975544233c57107", "patch": "@@ -735,8 +735,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"for every macro invocation, print its name and arguments\"),\n     enable_nonzeroing_move_hints: bool = (false, parse_bool,\n           \"force nonzeroing move optimization on\"),\n-    keep_mtwt_tables: bool = (false, parse_bool,\n-          \"don't clear the resolution tables after analysis\"),\n+    keep_hygiene_data: bool = (false, parse_bool,\n+          \"don't clear the hygiene data after analysis\"),\n     keep_ast: bool = (false, parse_bool,\n           \"keep the AST after lowering it to HIR\"),\n     show_span: Option<String> = (None, parse_opt_string,"}, {"sha": "ab3b20e08c8099130c1b5c3a874a519f9b29fddb", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6cc49e51de7ea9b0cc4aff437975544233c57107/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc49e51de7ea9b0cc4aff437975544233c57107/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=6cc49e51de7ea9b0cc4aff437975544233c57107", "patch": "@@ -236,8 +236,8 @@ pub fn compile_input(sess: &Session,\n     Ok(())\n }\n \n-fn keep_mtwt_tables(sess: &Session) -> bool {\n-    sess.opts.debugging_opts.keep_mtwt_tables\n+fn keep_hygiene_data(sess: &Session) -> bool {\n+    sess.opts.debugging_opts.keep_hygiene_data\n }\n \n fn keep_ast(sess: &Session) -> bool {\n@@ -479,9 +479,8 @@ pub fn phase_1_parse_input<'a>(sess: &'a Session,\n                                input: &Input)\n                                -> PResult<'a, ast::Crate> {\n     // These may be left in an incoherent state after a previous compile.\n-    // `clear_tables` and `clear_ident_interner` can be used to free\n-    // memory, but they do not restore the initial state.\n-    syntax::ext::mtwt::reset_tables();\n+    syntax::ext::hygiene::reset_hygiene_data();\n+    // `clear_ident_interner` can be used to free memory, but it does not restore the initial state.\n     token::reset_ident_interner();\n     let continue_after_error = sess.opts.continue_parse_after_error;\n     sess.diagnostic().set_continue_after_error(continue_after_error);\n@@ -761,9 +760,9 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n         hir_map::Forest::new(lower_crate(sess, &krate, &mut resolver), &sess.dep_graph)\n     });\n \n-    // Discard MTWT tables that aren't required past lowering to HIR.\n-    if !keep_mtwt_tables(sess) {\n-        syntax::ext::mtwt::clear_tables();\n+    // Discard hygiene data, which isn't required past lowering to HIR.\n+    if !keep_hygiene_data(sess) {\n+        syntax::ext::hygiene::reset_hygiene_data();\n     }\n \n     Ok(ExpansionResult {"}, {"sha": "14476cc997ff3eb35968e2540a7a99902d81205c", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cc49e51de7ea9b0cc4aff437975544233c57107/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc49e51de7ea9b0cc4aff437975544233c57107/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=6cc49e51de7ea9b0cc4aff437975544233c57107", "patch": "@@ -456,7 +456,7 @@ impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n                 pp::space(&mut s.s)?;\n                 // FIXME #16420: this doesn't display the connections\n                 // between syntax contexts\n-                s.synth_comment(format!(\"{}#{}\", nm, ctxt.0))\n+                s.synth_comment(format!(\"{}{:?}\", nm, ctxt))\n             }\n             pprust::NodeName(&ast::Name(nm)) => {\n                 pp::space(&mut s.s)?;"}, {"sha": "70e566de8a7be5ab9a53900cd82678e7268329fe", "filename": "src/librustc_resolve/assign_ids.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6cc49e51de7ea9b0cc4aff437975544233c57107/src%2Flibrustc_resolve%2Fassign_ids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc49e51de7ea9b0cc4aff437975544233c57107/src%2Flibrustc_resolve%2Fassign_ids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fassign_ids.rs?ref=6cc49e51de7ea9b0cc4aff437975544233c57107", "patch": "@@ -11,7 +11,7 @@\n use Resolver;\n use rustc::session::Session;\n use syntax::ast;\n-use syntax::ext::mtwt;\n+use syntax::ext::hygiene::Mark;\n use syntax::fold::{self, Folder};\n use syntax::ptr::P;\n use syntax::util::move_map::MoveMap;\n@@ -31,7 +31,7 @@ impl<'a> Resolver<'a> {\n \n struct NodeIdAssigner<'a> {\n     sess: &'a Session,\n-    macros_at_scope: &'a mut HashMap<ast::NodeId, Vec<ast::Mrk>>,\n+    macros_at_scope: &'a mut HashMap<ast::NodeId, Vec<Mark>>,\n }\n \n impl<'a> Folder for NodeIdAssigner<'a> {\n@@ -49,7 +49,7 @@ impl<'a> Folder for NodeIdAssigner<'a> {\n             block.stmts = block.stmts.move_flat_map(|stmt| {\n                 if let ast::StmtKind::Item(ref item) = stmt.node {\n                     if let ast::ItemKind::Mac(..) = item.node {\n-                        macros.push(mtwt::outer_mark(item.ident.ctxt));\n+                        macros.push(item.ident.ctxt.data().outer_mark);\n                         return None;\n                     }\n                 }"}, {"sha": "aa8c706ea1e27b9cb73978f7248864c3627ee7e8", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6cc49e51de7ea9b0cc4aff437975544233c57107/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc49e51de7ea9b0cc4aff437975544233c57107/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6cc49e51de7ea9b0cc4aff437975544233c57107", "patch": "@@ -53,7 +53,7 @@ use rustc::ty::subst::{ParamSpace, FnSpace, TypeSpace};\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n \n-use syntax::ext::mtwt;\n+use syntax::ext::hygiene::Mark;\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, CrateNum, IntTy, UintTy};\n use syntax::parse::token::{self, keywords};\n@@ -654,7 +654,7 @@ enum RibKind<'a> {\n     ModuleRibKind(Module<'a>),\n \n     // We passed through a `macro_rules!` statement with the given expansion\n-    MacroDefinition(ast::Mrk),\n+    MacroDefinition(Mark),\n }\n \n #[derive(Copy, Clone)]\n@@ -933,7 +933,7 @@ pub struct Resolver<'a> {\n \n     // Maps the node id of a statement to the expansions of the `macro_rules!`s\n     // immediately above the statement (if appropriate).\n-    macros_at_scope: HashMap<NodeId, Vec<ast::Mrk>>,\n+    macros_at_scope: HashMap<NodeId, Vec<Mark>>,\n \n     graph_root: Module<'a>,\n \n@@ -1434,10 +1434,9 @@ impl<'a> Resolver<'a> {\n             if let MacroDefinition(mac) = self.get_ribs(ns)[i].kind {\n                 // If an invocation of this macro created `ident`, give up on `ident`\n                 // and switch to `ident`'s source from the macro definition.\n-                if let Some((source_ident, source_macro)) = mtwt::source(ident) {\n-                    if mac == source_macro {\n-                        ident = source_ident;\n-                    }\n+                let (source_ctxt, source_macro) = ident.ctxt.source();\n+                if source_macro == mac {\n+                    ident.ctxt = source_ctxt;\n                 }\n             }\n         }\n@@ -1585,10 +1584,9 @@ impl<'a> Resolver<'a> {\n                 MacroDefinition(mac) => {\n                     // If an invocation of this macro created `ident`, give up on `ident`\n                     // and switch to `ident`'s source from the macro definition.\n-                    if let Some((source_ident, source_macro)) = mtwt::source(ident) {\n-                        if mac == source_macro {\n-                            ident = source_ident;\n-                        }\n+                    let (source_ctxt, source_macro) = ident.ctxt.source();\n+                    if source_macro == mac {\n+                        ident.ctxt = source_ctxt;\n                     }\n                 }\n                 _ => {"}, {"sha": "a8bb255fba4a4d4b099c936239dee1abdc7fee7c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6cc49e51de7ea9b0cc4aff437975544233c57107/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc49e51de7ea9b0cc4aff437975544233c57107/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=6cc49e51de7ea9b0cc4aff437975544233c57107", "patch": "@@ -19,6 +19,7 @@ pub use util::ThinVec;\n use syntax_pos::{mk_sp, Span, DUMMY_SP, ExpnId};\n use codemap::{respan, Spanned};\n use abi::Abi;\n+use ext::hygiene::SyntaxContext;\n use parse::token::{self, keywords, InternedString};\n use print::pprust;\n use ptr::P;\n@@ -33,15 +34,6 @@ use serialize::{Encodable, Decodable, Encoder, Decoder};\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Name(pub u32);\n \n-/// A SyntaxContext represents a chain of macro-expandings\n-/// and renamings. Each macro expansion corresponds to\n-/// a fresh u32. This u32 is a reference to a table stored\n-/// in thread-local storage.\n-/// The special value EMPTY_CTXT is used to indicate an empty\n-/// syntax context.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct SyntaxContext(pub u32);\n-\n /// An identifier contains a Name (index into the interner\n /// table) and a SyntaxContext to track renaming and\n /// macro expansion per Flatt et al., \"Macros That Work Together\"\n@@ -81,20 +73,15 @@ impl Decodable for Name {\n     }\n }\n \n-pub const EMPTY_CTXT : SyntaxContext = SyntaxContext(0);\n-\n impl Ident {\n-    pub fn new(name: Name, ctxt: SyntaxContext) -> Ident {\n-        Ident {name: name, ctxt: ctxt}\n-    }\n     pub const fn with_empty_ctxt(name: Name) -> Ident {\n-        Ident {name: name, ctxt: EMPTY_CTXT}\n+        Ident { name: name, ctxt: SyntaxContext::empty() }\n     }\n }\n \n impl fmt::Debug for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}#{}\", self.name, self.ctxt.0)\n+        write!(f, \"{}{:?}\", self.name, self.ctxt)\n     }\n }\n \n@@ -116,9 +103,6 @@ impl Decodable for Ident {\n     }\n }\n \n-/// A mark represents a unique id associated with a macro expansion\n-pub type Mrk = u32;\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,"}, {"sha": "18342f2e38c1be8c51be9d662fed96c24ef83e7a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6cc49e51de7ea9b0cc4aff437975544233c57107/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc49e51de7ea9b0cc4aff437975544233c57107/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=6cc49e51de7ea9b0cc4aff437975544233c57107", "patch": "@@ -9,20 +9,19 @@\n // except according to those terms.\n \n use ast::{Block, Crate, Ident, Mac_, Name, PatKind};\n-use ast::{MacStmtStyle, Mrk, Stmt, StmtKind, ItemKind};\n+use ast::{MacStmtStyle, Stmt, StmtKind, ItemKind};\n use ast;\n-use attr::HasAttrs;\n-use ext::mtwt;\n-use attr;\n+use ext::hygiene::Mark;\n+use attr::{self, HasAttrs};\n use attr::AttrMetaMethods;\n-use codemap::{dummy_spanned, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n+use codemap::{dummy_spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use syntax_pos::{self, Span, ExpnId};\n use config::StripUnconfigured;\n use ext::base::*;\n use feature_gate::{self, Features};\n use fold;\n use fold::*;\n-use parse::token::{fresh_mark, intern, keywords};\n+use parse::token::{intern, keywords};\n use ptr::P;\n use tokenstream::TokenTree;\n use util::small_vector::SmallVector;\n@@ -130,9 +129,9 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n     // It would almost certainly be cleaner to pass the whole macro invocation in,\n     // rather than pulling it apart and marking the tts and the ctxt separately.\n     let Mac_ { path, tts, .. } = mac.node;\n-    let mark = fresh_mark();\n+    let mark = Mark::fresh();\n \n-    fn mac_result<'a>(path: &ast::Path, ident: Option<Ident>, tts: Vec<TokenTree>, mark: Mrk,\n+    fn mac_result<'a>(path: &ast::Path, ident: Option<Ident>, tts: Vec<TokenTree>, mark: Mark,\n                       attrs: Vec<ast::Attribute>, call_site: Span, fld: &'a mut MacroExpander)\n                       -> Option<Box<MacResult + 'a>> {\n         // Detect use of feature-gated or invalid attributes on macro invoations\n@@ -708,30 +707,17 @@ pub fn expand_crate(mut cx: ExtCtxt,\n     return (ret, cx.syntax_env.names);\n }\n \n-// HYGIENIC CONTEXT EXTENSION:\n-// all of these functions are for walking over\n-// ASTs and making some change to the context of every\n-// element that has one. a CtxtFn is a trait-ified\n-// version of a closure in (SyntaxContext -> SyntaxContext).\n-// the ones defined here include:\n-// Marker - add a mark to a context\n-\n // A Marker adds the given mark to the syntax context and\n // sets spans' `expn_id` to the given expn_id (unless it is `None`).\n-struct Marker { mark: Mrk, expn_id: Option<ExpnId> }\n+struct Marker { mark: Mark, expn_id: Option<ExpnId> }\n \n impl Folder for Marker {\n-    fn fold_ident(&mut self, id: Ident) -> Ident {\n-        ast::Ident::new(id.name, mtwt::apply_mark(self.mark, id.ctxt))\n-    }\n-    fn fold_mac(&mut self, Spanned {node, span}: ast::Mac) -> ast::Mac {\n-        Spanned {\n-            node: Mac_ {\n-                path: self.fold_path(node.path),\n-                tts: self.fold_tts(&node.tts),\n-            },\n-            span: self.new_span(span),\n-        }\n+    fn fold_ident(&mut self, mut ident: Ident) -> Ident {\n+        ident.ctxt = ident.ctxt.apply_mark(self.mark);\n+        ident\n+    }\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+        noop_fold_mac(mac, self)\n     }\n \n     fn new_span(&mut self, mut span: Span) -> Span {\n@@ -743,7 +729,7 @@ impl Folder for Marker {\n }\n \n // apply a given mark to the given token trees. Used prior to expansion of a macro.\n-fn mark_tts(tts: &[TokenTree], m: Mrk) -> Vec<TokenTree> {\n+fn mark_tts(tts: &[TokenTree], m: Mark) -> Vec<TokenTree> {\n     noop_fold_tts(tts, &mut Marker{mark:m, expn_id: None})\n }\n "}, {"sha": "ade165e0ef9c896b9ab607e523d1d11cfc23324b", "filename": "src/libsyntax/ext/hygiene.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/6cc49e51de7ea9b0cc4aff437975544233c57107/src%2Flibsyntax%2Fext%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc49e51de7ea9b0cc4aff437975544233c57107/src%2Flibsyntax%2Fext%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fhygiene.rs?ref=6cc49e51de7ea9b0cc4aff437975544233c57107", "patch": "@@ -0,0 +1,116 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Machinery for hygienic macros, inspired by the MTWT[1] paper.\n+//!\n+//! [1] Matthew Flatt, Ryan Culpepper, David Darais, and Robert Bruce Findler.\n+//! 2012. *Macros that work together: Compile-time bindings, partial expansion,\n+//! and definition contexts*. J. Funct. Program. 22, 2 (March 2012), 181-216.\n+//! DOI=10.1017/S0956796812000093 http://dx.doi.org/10.1017/S0956796812000093\n+\n+use std::cell::RefCell;\n+use std::collections::HashMap;\n+use std::fmt;\n+\n+/// A SyntaxContext represents a chain of macro expansions (represented by marks).\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Default)]\n+pub struct SyntaxContext(u32);\n+\n+#[derive(Copy, Clone)]\n+pub struct SyntaxContextData {\n+    pub outer_mark: Mark,\n+    pub prev_ctxt: SyntaxContext,\n+}\n+\n+/// A mark represents a unique id associated with a macro expansion.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Default)]\n+pub struct Mark(u32);\n+\n+impl Mark {\n+    pub fn fresh() -> Self {\n+        HygieneData::with(|data| {\n+            let next_mark = Mark(data.next_mark.0 + 1);\n+            ::std::mem::replace(&mut data.next_mark, next_mark)\n+        })\n+    }\n+}\n+\n+struct HygieneData {\n+    syntax_contexts: Vec<SyntaxContextData>,\n+    markings: HashMap<(SyntaxContext, Mark), SyntaxContext>,\n+    next_mark: Mark,\n+}\n+\n+impl HygieneData {\n+    fn new() -> Self {\n+        HygieneData {\n+            syntax_contexts: vec![SyntaxContextData {\n+                outer_mark: Mark(0), // the null mark\n+                prev_ctxt: SyntaxContext(0), // the empty context\n+            }],\n+            markings: HashMap::new(),\n+            next_mark: Mark(1),\n+        }\n+    }\n+\n+    fn with<T, F: FnOnce(&mut HygieneData) -> T>(f: F) -> T {\n+        thread_local! {\n+            static HYGIENE_DATA: RefCell<HygieneData> = RefCell::new(HygieneData::new());\n+        }\n+        HYGIENE_DATA.with(|data| f(&mut *data.borrow_mut()))\n+    }\n+}\n+\n+pub fn reset_hygiene_data() {\n+    HygieneData::with(|data| *data = HygieneData::new())\n+}\n+\n+impl SyntaxContext {\n+    pub const fn empty() -> Self {\n+        SyntaxContext(0)\n+    }\n+\n+    pub fn data(self) -> SyntaxContextData {\n+        HygieneData::with(|data| data.syntax_contexts[self.0 as usize])\n+    }\n+\n+    /// Extend a syntax context with a given mark\n+    pub fn apply_mark(self, mark: Mark) -> SyntaxContext {\n+        // Applying the same mark twice is a no-op\n+        let ctxt_data = self.data();\n+        if mark == ctxt_data.outer_mark {\n+            return ctxt_data.prev_ctxt;\n+        }\n+\n+        HygieneData::with(|data| {\n+            let syntax_contexts = &mut data.syntax_contexts;\n+            *data.markings.entry((self, mark)).or_insert_with(|| {\n+                syntax_contexts.push(SyntaxContextData {\n+                    outer_mark: mark,\n+                    prev_ctxt: self,\n+                });\n+                SyntaxContext(syntax_contexts.len() as u32 - 1)\n+            })\n+        })\n+    }\n+\n+   /// If `ident` is macro expanded, return the source ident from the macro definition\n+   /// and the mark of the expansion that created the macro definition.\n+   pub fn source(self) -> (Self /* source context */, Mark /* source macro */) {\n+        let macro_def_ctxt = self.data().prev_ctxt.data();\n+        (macro_def_ctxt.prev_ctxt, macro_def_ctxt.outer_mark)\n+   }\n+}\n+\n+impl fmt::Debug for SyntaxContext {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"#{}\", self.0)\n+    }\n+}"}, {"sha": "d2f6df9d5dbd3f1936609ee2b613a257c70fe5eb", "filename": "src/libsyntax/ext/mtwt.rs", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/f441bca4993450e4a2f63bac382f9ebc4be274d1/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f441bca4993450e4a2f63bac382f9ebc4be274d1/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=f441bca4993450e4a2f63bac382f9ebc4be274d1", "patch": "@@ -1,154 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Machinery for hygienic macros, as described in the MTWT[1] paper.\n-//!\n-//! [1] Matthew Flatt, Ryan Culpepper, David Darais, and Robert Bruce Findler.\n-//! 2012. *Macros that work together: Compile-time bindings, partial expansion,\n-//! and definition contexts*. J. Funct. Program. 22, 2 (March 2012), 181-216.\n-//! DOI=10.1017/S0956796812000093 http://dx.doi.org/10.1017/S0956796812000093\n-\n-pub use self::SyntaxContext_::*;\n-\n-use ast::{Ident, Mrk, SyntaxContext};\n-\n-use std::cell::RefCell;\n-use std::collections::HashMap;\n-\n-/// The SCTable contains a table of SyntaxContext_'s. It\n-/// represents a flattened tree structure, to avoid having\n-/// managed pointers everywhere (that caused an ICE).\n-/// The `marks` ensures that adding the same mark to the\n-/// same context gives you back the same context as before.\n-pub struct SCTable {\n-    table: RefCell<Vec<SyntaxContext_>>,\n-    marks: RefCell<HashMap<(SyntaxContext,Mrk),SyntaxContext>>,\n-}\n-\n-#[derive(PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy, Clone)]\n-pub enum SyntaxContext_ {\n-    EmptyCtxt,\n-    Mark (Mrk,SyntaxContext),\n-}\n-\n-/// Extend a syntax context with a given mark\n-pub fn apply_mark(m: Mrk, ctxt: SyntaxContext) -> SyntaxContext {\n-    with_sctable(|table| apply_mark_internal(m, ctxt, table))\n-}\n-\n-/// Extend a syntax context with a given mark and sctable (explicit memoization)\n-fn apply_mark_internal(m: Mrk, ctxt: SyntaxContext, table: &SCTable) -> SyntaxContext {\n-    let ctxts = &mut *table.table.borrow_mut();\n-    match ctxts[ctxt.0 as usize] {\n-        // Applying the same mark twice is a no-op.\n-        Mark(outer_mark, prev_ctxt) if outer_mark == m => return prev_ctxt,\n-        _ => *table.marks.borrow_mut().entry((ctxt, m)).or_insert_with(|| {\n-            SyntaxContext(idx_push(ctxts, Mark(m, ctxt)))\n-        }),\n-    }\n-}\n-\n-/// Fetch the SCTable from TLS, create one if it doesn't yet exist.\n-pub fn with_sctable<T, F>(op: F) -> T where\n-    F: FnOnce(&SCTable) -> T,\n-{\n-    thread_local!(static SCTABLE_KEY: SCTable = new_sctable_internal());\n-    SCTABLE_KEY.with(move |slot| op(slot))\n-}\n-\n-// Make a fresh syntax context table with EmptyCtxt in slot zero.\n-fn new_sctable_internal() -> SCTable {\n-    SCTable {\n-        table: RefCell::new(vec![EmptyCtxt]),\n-        marks: RefCell::new(HashMap::new()),\n-    }\n-}\n-\n-/// Clear the tables from TLD to reclaim memory.\n-pub fn clear_tables() {\n-    with_sctable(|table| {\n-        *table.table.borrow_mut() = Vec::new();\n-        *table.marks.borrow_mut() = HashMap::new();\n-    });\n-}\n-\n-/// Reset the tables to their initial state\n-pub fn reset_tables() {\n-    with_sctable(|table| {\n-        *table.table.borrow_mut() = vec![EmptyCtxt];\n-        *table.marks.borrow_mut() = HashMap::new();\n-    });\n-}\n-\n-/// Add a value to the end of a vec, return its index\n-fn idx_push<T>(vec: &mut Vec<T>, val: T) -> u32 {\n-    vec.push(val);\n-    (vec.len() - 1) as u32\n-}\n-\n-/// Return the outer mark for a context with a mark at the outside.\n-/// FAILS when outside is not a mark.\n-pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n-    with_sctable(|sctable| {\n-        match (*sctable.table.borrow())[ctxt.0 as usize] {\n-            Mark(mrk, _) => mrk,\n-            _ => panic!(\"can't retrieve outer mark when outside is not a mark\")\n-        }\n-    })\n-}\n-\n-/// If `ident` is macro expanded, return the source ident from the macro definition\n-/// and the mark of the expansion that created the macro definition.\n-pub fn source(ident: Ident) -> Option<(Ident /* source ident */, Mrk /* source macro */)> {\n-    with_sctable(|sctable| {\n-        let ctxts = sctable.table.borrow();\n-        if let Mark(_expansion_mark, macro_ctxt) = ctxts[ident.ctxt.0 as usize] {\n-            if let Mark(definition_mark, orig_ctxt) = ctxts[macro_ctxt.0 as usize] {\n-                return Some((Ident::new(ident.name, orig_ctxt), definition_mark));\n-            }\n-        }\n-        None\n-    })\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use ast::{EMPTY_CTXT, Mrk, SyntaxContext};\n-    use super::{apply_mark_internal, new_sctable_internal, Mark, SCTable};\n-\n-    // extend a syntax context with a sequence of marks given\n-    // in a vector. v[0] will be the outermost mark.\n-    fn unfold_marks(mrks: Vec<Mrk> , tail: SyntaxContext, table: &SCTable)\n-                    -> SyntaxContext {\n-        mrks.iter().rev().fold(tail, |tail:SyntaxContext, mrk:&Mrk|\n-                   {apply_mark_internal(*mrk,tail,table)})\n-    }\n-\n-    #[test] fn unfold_marks_test() {\n-        let mut t = new_sctable_internal();\n-\n-        assert_eq!(unfold_marks(vec!(3,7),EMPTY_CTXT,&mut t),SyntaxContext(2));\n-        {\n-            let table = t.table.borrow();\n-            assert!((*table)[1] == Mark(7,EMPTY_CTXT));\n-            assert!((*table)[2] == Mark(3,SyntaxContext(1)));\n-        }\n-    }\n-\n-    #[test]\n-    fn hashing_tests () {\n-        let mut t = new_sctable_internal();\n-        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),SyntaxContext(1));\n-        assert_eq!(apply_mark_internal(13,EMPTY_CTXT,&mut t),SyntaxContext(2));\n-        // using the same one again should result in the same index:\n-        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),SyntaxContext(1));\n-        // I'm assuming that the rename table will behave the same....\n-    }\n-}"}, {"sha": "5ad1744418890b21f46e0b68139f04bf5386ce51", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cc49e51de7ea9b0cc4aff437975544233c57107/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc49e51de7ea9b0cc4aff437975544233c57107/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=6cc49e51de7ea9b0cc4aff437975544233c57107", "patch": "@@ -127,7 +127,7 @@ pub mod ext {\n     pub mod base;\n     pub mod build;\n     pub mod expand;\n-    pub mod mtwt;\n+    pub mod hygiene;\n     pub mod quote;\n     pub mod source_util;\n "}, {"sha": "f0a6f8edeec73a241622a50a937b604c5896c6bd", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6cc49e51de7ea9b0cc4aff437975544233c57107/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc49e51de7ea9b0cc4aff437975544233c57107/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=6cc49e51de7ea9b0cc4aff437975544233c57107", "patch": "@@ -633,8 +633,3 @@ pub fn fresh_name(src: ast::Ident) -> ast::Name {\n     /*let num = rand::thread_rng().gen_uint_range(0,0xffff);\n     gensym(format!(\"{}_{}\",ident_to_string(src),num))*/\n }\n-\n-// create a fresh mark.\n-pub fn fresh_mark() -> ast::Mrk {\n-    gensym(\"mark\").0\n-}"}]}