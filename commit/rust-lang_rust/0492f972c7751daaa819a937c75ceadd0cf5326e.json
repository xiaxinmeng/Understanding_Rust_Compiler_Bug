{"sha": "0492f972c7751daaa819a937c75ceadd0cf5326e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0OTJmOTcyYzc3NTFkYWFhODE5YTkzN2M3NWNlYWRkMGNmNTMyNmU=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2019-07-09T01:25:19Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2019-07-09T19:39:25Z"}, "message": "Return the true count from partition_in_place", "tree": {"sha": "d08f12079d00ac4b1bf235a3f07e3b516ad5f3ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d08f12079d00ac4b1bf235a3f07e3b516ad5f3ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0492f972c7751daaa819a937c75ceadd0cf5326e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0492f972c7751daaa819a937c75ceadd0cf5326e", "html_url": "https://github.com/rust-lang/rust/commit/0492f972c7751daaa819a937c75ceadd0cf5326e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0492f972c7751daaa819a937c75ceadd0cf5326e/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd0ebc43c7f0238d09bdf722409e8d77a41a37db", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd0ebc43c7f0238d09bdf722409e8d77a41a37db", "html_url": "https://github.com/rust-lang/rust/commit/cd0ebc43c7f0238d09bdf722409e8d77a41a37db"}], "stats": {"total": 41, "additions": 35, "deletions": 6}, "files": [{"sha": "b123d4a14699997af5ca31f629876d229f6e778d", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0492f972c7751daaa819a937c75ceadd0cf5326e/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0492f972c7751daaa819a937c75ceadd0cf5326e/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=0492f972c7751daaa819a937c75ceadd0cf5326e", "patch": "@@ -1513,6 +1513,7 @@ pub trait Iterator {\n \n     /// Reorder the elements of this iterator *in-place* according to the given predicate,\n     /// such that all those that return `true` precede all those that return `false`.\n+    /// Returns the number of `true` elements found.\n     ///\n     /// The relative order of partitioned items is not maintained.\n     ///\n@@ -1529,25 +1530,53 @@ pub trait Iterator {\n     /// let mut a = [1, 2, 3, 4, 5, 6, 7];\n     ///\n     /// // Partition in-place between evens and odds\n-    /// a.iter_mut().partition_in_place(|&n| n % 2 == 0);\n+    /// let i = a.iter_mut().partition_in_place(|&n| n % 2 == 0);\n     ///\n-    /// assert!(a[..3].iter().all(|&n| n % 2 == 0)); // evens\n-    /// assert!(a[3..].iter().all(|&n| n % 2 == 1)); // odds\n+    /// assert_eq!(i, 3);\n+    /// assert!(a[..i].iter().all(|&n| n % 2 == 0)); // evens\n+    /// assert!(a[i..].iter().all(|&n| n % 2 == 1)); // odds\n     /// ```\n     #[unstable(feature = \"iter_partition_in_place\", reason = \"new API\", issue = \"0\")]\n-    fn partition_in_place<'a, T: 'a, P>(mut self, mut predicate: P)\n+    fn partition_in_place<'a, T: 'a, P>(mut self, ref mut predicate: P) -> usize\n     where\n         Self: Sized + DoubleEndedIterator<Item = &'a mut T>,\n         P: FnMut(&T) -> bool,\n     {\n+        // FIXME: should we worry about the count overflowing? The only way to have more than\n+        // `usize::MAX` mutable references is with ZSTs, which aren't useful to partition...\n+\n+        // These closure \"factory\" functions exist to avoid genericity in `Self`.\n+\n+        #[inline]\n+        fn is_false<'a, T>(\n+            predicate: &'a mut impl FnMut(&T) -> bool,\n+            true_count: &'a mut usize,\n+        ) -> impl FnMut(&&mut T) -> bool + 'a {\n+            move |x| {\n+                let p = predicate(&**x);\n+                *true_count += p as usize;\n+                !p\n+            }\n+        }\n+\n+        #[inline]\n+        fn is_true<T>(\n+            predicate: &mut impl FnMut(&T) -> bool\n+        ) -> impl FnMut(&&mut T) -> bool + '_ {\n+            move |x| predicate(&**x)\n+        }\n+\n         // Repeatedly find the first `false` and swap it with the last `true`.\n-        while let Some(head) = self.find(|x| !predicate(x)) {\n-            if let Some(tail) = self.rfind(|x| predicate(x)) {\n+        let mut true_count = 0;\n+        while let Some(head) = self.find(is_false(predicate, &mut true_count)) {\n+            if let Some(tail) = self.rfind(is_true(predicate)) {\n                 crate::mem::swap(head, tail);\n+                true_count += 1;\n             } else {\n                 break;\n             }\n         }\n+        true_count\n     }\n \n     /// Checks if the elements of this iterator are partitioned according to the given predicate,"}]}