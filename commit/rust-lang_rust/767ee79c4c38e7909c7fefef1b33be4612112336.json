{"sha": "767ee79c4c38e7909c7fefef1b33be4612112336", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2N2VlNzljNGMzOGU3OTA5YzdmZWZlZjFiMzNiZTQ2MTIxMTIzMzY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-17T22:32:12Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-19T00:22:18Z"}, "message": "Refactor the HIR so that items are stored in a map in the `Crate`,\nrather being stored inline. Refactor (and rename) the visitor so that\n(by default) it only visits the interior content of an item not nested\nitems.\n\nThis is a [breaking-change] for anyone who uses the HIR visitor. Besides\nchanging `visit::` to `intravisit::`, you need to refactor your visitor\nin one of two ways, depending on what it requires:\n\n1. If you just want to visit all items (most common), you should call\n   `krate.visit_all_items(&mut visitor)`.\n\n2. If you need to visit nested items in the middle of the parent items,\n   you should override `visit_nested_item` with something like:\n   `self.visit_item(self.tcx.map.expect_item(item.id))`, presuming you\n   have access to a tcx (or at least a HIR map).", "tree": {"sha": "9932fa75f5cd2e12ba06c157f7677b634a092fbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9932fa75f5cd2e12ba06c157f7677b634a092fbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/767ee79c4c38e7909c7fefef1b33be4612112336", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/767ee79c4c38e7909c7fefef1b33be4612112336", "html_url": "https://github.com/rust-lang/rust/commit/767ee79c4c38e7909c7fefef1b33be4612112336", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/767ee79c4c38e7909c7fefef1b33be4612112336/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66326bc66572ca753bbb1d81a67d43488f6695f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/66326bc66572ca753bbb1d81a67d43488f6695f3", "html_url": "https://github.com/rust-lang/rust/commit/66326bc66572ca753bbb1d81a67d43488f6695f3"}], "stats": {"total": 341, "additions": 229, "deletions": 112}, "files": [{"sha": "d77d99a4a1a0cb038a57708080b0d991c1aac636", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/767ee79c4c38e7909c7fefef1b33be4612112336/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/767ee79c4c38e7909c7fefef1b33be4612112336/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=767ee79c4c38e7909c7fefef1b33be4612112336", "patch": "@@ -96,7 +96,7 @@ DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_bo\n                      rustc_typeck rustc_mir rustc_resolve log syntax serialize rustc_llvm \\\n \t\t             rustc_trans rustc_privacy rustc_lint rustc_front\n \n-DEPS_rustc_front := std syntax log serialize\n+DEPS_rustc_front := std syntax log serialize rustc_data_structures\n DEPS_rustc_lint := rustc log syntax\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n DEPS_rustc_mir := rustc rustc_front syntax"}, {"sha": "7ec4e1ba33121d99f67fa8de3b78c1c8397ba6b9", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 54, "deletions": 32, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/767ee79c4c38e7909c7fefef1b33be4612112336/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767ee79c4c38e7909c7fefef1b33be4612112336/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=767ee79c4c38e7909c7fefef1b33be4612112336", "patch": "@@ -77,10 +77,14 @@ pub trait Folder : Sized {\n         noop_fold_foreign_item(ni, self)\n     }\n \n-    fn fold_item(&mut self, i: P<Item>) -> P<Item> {\n+    fn fold_item(&mut self, i: Item) -> Item {\n         noop_fold_item(i, self)\n     }\n \n+    fn fold_item_id(&mut self, i: ItemId) -> ItemId {\n+        noop_fold_item_id(i, self)\n+    }\n+\n     fn fold_struct_field(&mut self, sf: StructField) -> StructField {\n         noop_fold_struct_field(sf, self)\n     }\n@@ -271,10 +275,16 @@ pub trait Folder : Sized {\n         noop_fold_where_predicate(where_predicate, self)\n     }\n \n+    /// called for the `id` on each declaration\n     fn new_id(&mut self, i: NodeId) -> NodeId {\n         i\n     }\n \n+    /// called for ids that are references (e.g., ItemDef)\n+    fn map_id(&mut self, i: NodeId) -> NodeId {\n+        i\n+    }\n+\n     fn new_span(&mut self, sp: Span) -> Span {\n         sp\n     }\n@@ -342,7 +352,7 @@ pub fn noop_fold_decl<T: Folder>(d: P<Decl>, fld: &mut T) -> P<Decl> {\n                 span: fld.new_span(span),\n             },\n             DeclItem(it) => Spanned {\n-                node: DeclItem(fld.fold_item(it)),\n+                node: DeclItem(fld.fold_item_id(it)),\n                 span: fld.new_span(span),\n             },\n         }\n@@ -879,66 +889,78 @@ pub fn noop_fold_impl_item<T: Folder>(i: P<ImplItem>, folder: &mut T) -> P<ImplI\n     })\n }\n \n-pub fn noop_fold_mod<T: Folder>(Mod { inner, items }: Mod, folder: &mut T) -> Mod {\n+pub fn noop_fold_mod<T: Folder>(Mod { inner, item_ids }: Mod, folder: &mut T) -> Mod {\n     Mod {\n         inner: folder.new_span(inner),\n-        items: items.into_iter().map(|x| folder.fold_item(x)).collect(),\n+        item_ids: item_ids.into_iter().map(|x| folder.fold_item_id(x)).collect(),\n     }\n }\n \n-pub fn noop_fold_crate<T: Folder>(Crate { module, attrs, config, span, exported_macros }: Crate,\n+pub fn noop_fold_crate<T: Folder>(Crate { module, attrs, config, span,\n+                                          exported_macros, items }: Crate,\n                                   folder: &mut T)\n                                   -> Crate {\n     let config = folder.fold_meta_items(config);\n \n-    let crate_mod = folder.fold_item(P(hir::Item {\n+    let crate_mod = folder.fold_item(hir::Item {\n         name: token::special_idents::invalid.name,\n         attrs: attrs,\n         id: DUMMY_NODE_ID,\n         vis: hir::Public,\n         span: span,\n         node: hir::ItemMod(module),\n-    }));\n+    });\n \n-    let (module, attrs, span) =\n-        crate_mod.and_then(|hir::Item { attrs, span, node, .. }| {\n+    let (module, attrs, span) = match crate_mod {\n+        hir::Item { attrs, span, node, .. } => {\n             match node {\n                 hir::ItemMod(m) => (m, attrs, span),\n                 _ => panic!(\"fold converted a module to not a module\"),\n             }\n-        });\n+        }\n+    };\n+\n+    let items = items.into_iter()\n+                     .map(|(id, item)| (id, folder.fold_item(item)))\n+                     .collect();\n \n     Crate {\n         module: module,\n         attrs: attrs,\n         config: config,\n         span: span,\n         exported_macros: exported_macros,\n+        items: items,\n     }\n }\n \n-pub fn noop_fold_item<T: Folder>(item: P<Item>, folder: &mut T) -> P<Item> {\n-    item.map(|Item { id, name, attrs, node, vis, span }| {\n-        let id = folder.new_id(id);\n-        let node = folder.fold_item_underscore(node);\n-        // FIXME: we should update the impl_pretty_name, but it uses pretty printing.\n-        // let ident = match node {\n-        //     // The node may have changed, recompute the \"pretty\" impl name.\n-        //     ItemImpl(_, _, _, ref maybe_trait, ref ty, _) => {\n-        //         impl_pretty_name(maybe_trait, Some(&**ty))\n-        //     }\n-        //     _ => ident\n-        // };\n-\n-        Item {\n-            id: id,\n-            name: folder.fold_name(name),\n-            attrs: fold_attrs(attrs, folder),\n-            node: node,\n-            vis: vis,\n-            span: folder.new_span(span),\n-        }\n-    })\n+pub fn noop_fold_item_id<T: Folder>(i: ItemId, folder: &mut T) -> ItemId {\n+    let id = folder.map_id(i.id);\n+    ItemId { id: id }\n+}\n+\n+// fold one item into one item\n+pub fn noop_fold_item<T: Folder>(item: Item, folder: &mut T) -> Item {\n+    let Item { id, name, attrs, node, vis, span } = item;\n+    let id = folder.new_id(id);\n+    let node = folder.fold_item_underscore(node);\n+    // FIXME: we should update the impl_pretty_name, but it uses pretty printing.\n+    // let ident = match node {\n+    //     // The node may have changed, recompute the \"pretty\" impl name.\n+    //     ItemImpl(_, _, _, ref maybe_trait, ref ty, _) => {\n+    //         impl_pretty_name(maybe_trait, Some(&**ty))\n+    //     }\n+    //     _ => ident\n+    // };\n+\n+    Item {\n+        id: id,\n+        name: folder.fold_name(name),\n+        attrs: fold_attrs(attrs, folder),\n+        node: node,\n+        vis: vis,\n+        span: folder.new_span(span),\n+    }\n }\n \n pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) -> P<ForeignItem> {"}, {"sha": "4232254327cdec14221f85577018cc2c17603016", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/767ee79c4c38e7909c7fefef1b33be4612112336/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767ee79c4c38e7909c7fefef1b33be4612112336/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=767ee79c4c38e7909c7fefef1b33be4612112336", "patch": "@@ -35,6 +35,8 @@ pub use self::ViewPath_::*;\n pub use self::Visibility::*;\n pub use self::PathParameters::*;\n \n+use intravisit::Visitor;\n+use rustc_data_structures::fnv::FnvHashMap;\n use syntax::codemap::{self, Span, Spanned, DUMMY_SP, ExpnId};\n use syntax::abi::Abi;\n use syntax::ast::{Name, Ident, NodeId, DUMMY_NODE_ID, TokenTree, AsmDialect};\n@@ -320,13 +322,42 @@ pub struct WhereEqPredicate {\n     pub ty: P<Ty>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n pub struct Crate {\n     pub module: Mod,\n     pub attrs: Vec<Attribute>,\n     pub config: CrateConfig,\n     pub span: Span,\n     pub exported_macros: Vec<MacroDef>,\n+    pub items: FnvHashMap<NodeId, Item>,\n+}\n+\n+impl Crate {\n+    pub fn item(&self, id: NodeId) -> &Item {\n+        &self.items[&id]\n+    }\n+\n+    /// Visits all items in the crate in some determinstic (but\n+    /// unspecified) order. If you just need to process every item,\n+    /// but don't care about nesting, this method is the best choice.\n+    ///\n+    /// If you do care about nesting -- usually because your algorithm\n+    /// follows lexical scoping rules -- then you want a different\n+    /// approach. You should override `visit_nested_item` in your\n+    /// visitor and then call `intravisit::walk_crate` instead.\n+    pub fn visit_all_items<'hir, V:Visitor<'hir>>(&'hir self, visitor: &mut V) {\n+        // In principle, we could just iterate over the hashmap, but\n+        // in practice that makes the order of error reporting vary\n+        // with small changes in the input etc etc, which makes the\n+        // test base hard to maintain. So instead we sort by node-id\n+        // so as to get reproducible results.\n+        let mut pairs: Vec<_> = self.items.iter().collect();\n+        pairs.sort_by(|&(id1, _), &(id2, _)| id1.cmp(id2));\n+\n+        for (_, item) in pairs {\n+            visitor.visit_item(item);\n+        }\n+    }\n }\n \n /// A macro definition, in this crate or imported from another.\n@@ -537,7 +568,7 @@ pub enum Decl_ {\n     /// A local (let) binding:\n     DeclLocal(P<Local>),\n     /// An item binding:\n-    DeclItem(P<Item>),\n+    DeclItem(ItemId),\n }\n \n /// represents one arm of a 'match'\n@@ -992,7 +1023,7 @@ pub struct Mod {\n     /// For `mod foo;`, the inner span ranges from the first token\n     /// to the last token in the external file.\n     pub inner: Span,\n-    pub items: Vec<P<Item>>,\n+    pub item_ids: Vec<ItemId>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -1205,7 +1236,13 @@ impl VariantData {\n     }\n }\n \n-\n+// The bodies for items are stored \"out of line\", in a separate\n+// hashmap in the `Crate`. Here we just record the node-id of the item\n+// so it can fetched later.\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct ItemId {\n+    pub id: NodeId,\n+}\n \n //  FIXME (#3300): Should allow items to be anonymous. Right now\n //  we just use dummy names for anon items."}, {"sha": "9c923ea32ef5dbdca1f5f62778e39a8e9136e390", "filename": "src/librustc_front/intravisit.rs", "status": "renamed", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/767ee79c4c38e7909c7fefef1b33be4612112336/src%2Flibrustc_front%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767ee79c4c38e7909c7fefef1b33be4612112336/src%2Flibrustc_front%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fintravisit.rs?ref=767ee79c4c38e7909c7fefef1b33be4612112336", "patch": "@@ -45,11 +45,37 @@ pub enum FnKind<'a> {\n /// the substructure of the input via the corresponding `walk` method;\n /// e.g. the `visit_mod` method by default calls `visit::walk_mod`.\n ///\n+/// Note that this visitor does NOT visit nested items by default. If\n+/// you simply want to visit all items in the crate in some order, you\n+/// should call `Crate::visit_all_items`. Otherwise, see the comment\n+/// on `visit_nested_item` for details on how to visit nested items.\n+///\n /// If you want to ensure that your code handles every variant\n /// explicitly, you need to override each method.  (And you also need\n /// to monitor future changes to `Visitor` in case a new method with a\n /// new default implementation gets introduced.)\n pub trait Visitor<'v> : Sized {\n+    ///////////////////////////////////////////////////////////////////////////\n+    // Nested items.\n+\n+    /// Invoked when a nested item is encountered. By default, does\n+    /// nothing. If you want a deep walk, you need to override to\n+    /// fetch the item contents. But most of the time, it is easier\n+    /// (and better) to invoke `Crate::visit_all_items`, which visits\n+    /// all items in the crate in some order (but doesn't respect\n+    /// nesting).\n+    #[allow(unused_variables)]\n+    fn visit_nested_item(&mut self, id: ItemId) {\n+    }\n+\n+    /// Visit the top-level item and (optionally) nested items. See\n+    /// `visit_nested_item` for details.\n+    fn visit_item(&mut self, i: &'v Item) {\n+        walk_item(self, i)\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+\n     fn visit_name(&mut self, _span: Span, _name: Name) {\n         // Nothing to do.\n     }\n@@ -62,9 +88,6 @@ pub trait Visitor<'v> : Sized {\n     fn visit_foreign_item(&mut self, i: &'v ForeignItem) {\n         walk_foreign_item(self, i)\n     }\n-    fn visit_item(&mut self, i: &'v Item) {\n-        walk_item(self, i)\n-    }\n     fn visit_local(&mut self, l: &'v Local) {\n         walk_local(self, l)\n     }\n@@ -180,6 +203,7 @@ pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, ident: Ident)\n     visitor.visit_name(span, ident.name);\n }\n \n+/// Walks the contents of a crate. See also `Crate::visit_all_items`.\n pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n     visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n     walk_list!(visitor, visit_attribute, &krate.attrs);\n@@ -193,7 +217,9 @@ pub fn walk_macro_def<'v, V: Visitor<'v>>(visitor: &mut V, macro_def: &'v MacroD\n }\n \n pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod) {\n-    walk_list!(visitor, visit_item, &module.items);\n+    for &item_id in &module.item_ids {\n+        visitor.visit_nested_item(item_id);\n+    }\n }\n \n pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n@@ -658,7 +684,7 @@ pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n pub fn walk_decl<'v, V: Visitor<'v>>(visitor: &mut V, declaration: &'v Decl) {\n     match declaration.node {\n         DeclLocal(ref local) => visitor.visit_local(local),\n-        DeclItem(ref item) => visitor.visit_item(item),\n+        DeclItem(item) => visitor.visit_nested_item(item),\n     }\n }\n ", "previous_filename": "src/librustc_front/visit.rs"}, {"sha": "d8c5eac1feb5ab2bab278590528b9a638fd63507", "filename": "src/librustc_front/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/767ee79c4c38e7909c7fefef1b33be4612112336/src%2Flibrustc_front%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767ee79c4c38e7909c7fefef1b33be4612112336/src%2Flibrustc_front%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flib.rs?ref=767ee79c4c38e7909c7fefef1b33be4612112336", "patch": "@@ -45,13 +45,14 @@ extern crate syntax;\n #[macro_use]\n #[no_link]\n extern crate rustc_bitflags;\n+extern crate rustc_data_structures;\n \n extern crate serialize as rustc_serialize; // used by deriving\n \n pub mod hir;\n pub mod lowering;\n pub mod fold;\n-pub mod visit;\n+pub mod intravisit;\n pub mod util;\n \n pub mod print {"}, {"sha": "ad081598c1124a479221b9fe97d1914716aa9652", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/767ee79c4c38e7909c7fefef1b33be4612112336/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767ee79c4c38e7909c7fefef1b33be4612112336/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=767ee79c4c38e7909c7fefef1b33be4612112336", "patch": "@@ -71,6 +71,8 @@ use syntax::codemap::{respan, Spanned, Span};\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::{self, str_to_ident};\n use syntax::std_inject;\n+use syntax::visit::{self, Visitor};\n+use rustc_data_structures::fnv::FnvHashMap;\n \n use std::cell::{Cell, RefCell};\n \n@@ -191,7 +193,7 @@ pub fn lower_decl(lctx: &LoweringContext, d: &Decl) -> P<hir::Decl> {\n             span: d.span,\n         }),\n         DeclItem(ref it) => P(Spanned {\n-            node: hir::DeclItem(lower_item(lctx, it)),\n+            node: hir::DeclItem(lower_item_id(lctx, it)),\n             span: d.span,\n         }),\n     }\n@@ -693,17 +695,36 @@ pub fn lower_impl_item(lctx: &LoweringContext, i: &ImplItem) -> P<hir::ImplItem>\n pub fn lower_mod(lctx: &LoweringContext, m: &Mod) -> hir::Mod {\n     hir::Mod {\n         inner: m.inner,\n-        items: m.items.iter().map(|x| lower_item(lctx, x)).collect(),\n+        item_ids: m.items.iter().map(|x| lower_item_id(lctx, x)).collect(),\n+    }\n+}\n+\n+struct ItemLowerer<'lcx, 'interner: 'lcx> {\n+    items: FnvHashMap<NodeId, hir::Item>,\n+    lctx: &'lcx LoweringContext<'interner>,\n+}\n+\n+impl<'lcx, 'interner> Visitor<'lcx> for ItemLowerer<'lcx, 'interner> {\n+    fn visit_item(&mut self, item: &'lcx Item) {\n+        self.items.insert(item.id, lower_item(self.lctx, item));\n+        visit::walk_item(self, item);\n     }\n }\n \n pub fn lower_crate(lctx: &LoweringContext, c: &Crate) -> hir::Crate {\n+    let items = {\n+        let mut item_lowerer = ItemLowerer { items: FnvHashMap(), lctx: lctx };\n+        visit::walk_crate(&mut item_lowerer, c);\n+        item_lowerer.items\n+    };\n+\n     hir::Crate {\n         module: lower_mod(lctx, &c.module),\n         attrs: c.attrs.clone(),\n         config: c.config.clone(),\n         span: c.span,\n         exported_macros: c.exported_macros.iter().map(|m| lower_macro_def(lctx, m)).collect(),\n+        items: items,\n     }\n }\n \n@@ -721,13 +742,11 @@ pub fn lower_macro_def(_lctx: &LoweringContext, m: &MacroDef) -> hir::MacroDef {\n     }\n }\n \n-// fold one item into possibly many items\n-pub fn lower_item(lctx: &LoweringContext, i: &Item) -> P<hir::Item> {\n-    P(lower_item_simple(lctx, i))\n+pub fn lower_item_id(_lctx: &LoweringContext, i: &Item) -> hir::ItemId {\n+    hir::ItemId { id: i.id }\n }\n \n-// fold one item into exactly one item\n-pub fn lower_item_simple(lctx: &LoweringContext, i: &Item) -> hir::Item {\n+pub fn lower_item(lctx: &LoweringContext, i: &Item) -> hir::Item {\n     let node = lower_item_underscore(lctx, &i.node);\n \n     hir::Item {"}, {"sha": "f29ef0e821752e29fab8c56ba4f653c3b6fd839a", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/767ee79c4c38e7909c7fefef1b33be4612112336/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767ee79c4c38e7909c7fefef1b33be4612112336/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=767ee79c4c38e7909c7fefef1b33be4612112336", "patch": "@@ -25,7 +25,7 @@ use syntax::print::pprust::{self as ast_pp, PrintState};\n use syntax::ptr::P;\n \n use hir;\n-use hir::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n+use hir::{Crate, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n \n use std::io::{self, Write, Read};\n \n@@ -54,6 +54,7 @@ impl PpAnn for NoAnn {}\n \n \n pub struct State<'a> {\n+    krate: Option<&'a Crate>,\n     pub s: pp::Printer<'a>,\n     cm: Option<&'a CodeMap>,\n     comments: Option<Vec<comments::Comment>>,\n@@ -85,13 +86,14 @@ impl<'a> PrintState<'a> for State<'a> {\n     }\n }\n \n-pub fn rust_printer<'a>(writer: Box<Write + 'a>) -> State<'a> {\n+pub fn rust_printer<'a>(writer: Box<Write + 'a>, krate: Option<&'a Crate>) -> State<'a> {\n     static NO_ANN: NoAnn = NoAnn;\n-    rust_printer_annotated(writer, &NO_ANN)\n+    rust_printer_annotated(writer, &NO_ANN, krate)\n }\n \n-pub fn rust_printer_annotated<'a>(writer: Box<Write + 'a>, ann: &'a PpAnn) -> State<'a> {\n+pub fn rust_printer_annotated<'a>(writer: Box<Write + 'a>, ann: &'a PpAnn, krate: Option<&'a Crate>) -> State<'a> {\n     State {\n+        krate: krate,\n         s: pp::mk_printer(writer, default_columns),\n         cm: None,\n         comments: None,\n@@ -124,7 +126,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n                        ann: &'a PpAnn,\n                        is_expanded: bool)\n                        -> io::Result<()> {\n-    let mut s = State::new_from_input(cm, span_diagnostic, filename, input, out, ann, is_expanded);\n+    let mut s = State::new_from_input(cm, span_diagnostic, filename, input, out, ann, is_expanded, Some(krate));\n \n     // When printing the AST, we sometimes need to inject `#[no_std]` here.\n     // Since you can't compile the HIR, it's not necessary.\n@@ -141,7 +143,8 @@ impl<'a> State<'a> {\n                           input: &mut Read,\n                           out: Box<Write + 'a>,\n                           ann: &'a PpAnn,\n-                          is_expanded: bool)\n+                          is_expanded: bool,\n+                          krate: Option<&'a Crate>)\n                           -> State<'a> {\n         let (cmnts, lits) = comments::gather_comments_and_literals(span_diagnostic,\n                                                                    filename,\n@@ -158,16 +161,19 @@ impl<'a> State<'a> {\n                        None\n                    } else {\n                        Some(lits)\n-                   })\n+                   },\n+                   krate)\n     }\n \n     pub fn new(cm: &'a CodeMap,\n                out: Box<Write + 'a>,\n                ann: &'a PpAnn,\n                comments: Option<Vec<comments::Comment>>,\n-               literals: Option<Vec<comments::Literal>>)\n+               literals: Option<Vec<comments::Literal>>,\n+               krate: Option<&'a Crate>)\n                -> State<'a> {\n         State {\n+            krate: krate,\n             s: pp::mk_printer(out, default_columns),\n             cm: Some(cm),\n             comments: comments.clone(),\n@@ -187,7 +193,7 @@ pub fn to_string<F>(f: F) -> String\n {\n     let mut wr = Vec::new();\n     {\n-        let mut printer = rust_printer(Box::new(&mut wr));\n+        let mut printer = rust_printer(Box::new(&mut wr), None);\n         f(&mut printer).unwrap();\n         eof(&mut printer.s).unwrap();\n     }\n@@ -451,8 +457,8 @@ impl<'a> State<'a> {\n \n     pub fn print_mod(&mut self, _mod: &hir::Mod, attrs: &[ast::Attribute]) -> io::Result<()> {\n         try!(self.print_inner_attributes(attrs));\n-        for item in &_mod.items {\n-            try!(self.print_item(&**item));\n+        for item_id in &_mod.item_ids {\n+            try!(self.print_item_id(item_id));\n         }\n         Ok(())\n     }\n@@ -620,6 +626,16 @@ impl<'a> State<'a> {\n         word(&mut self.s, \";\")\n     }\n \n+    pub fn print_item_id(&mut self, item_id: &hir::ItemId) -> io::Result<()> {\n+        if let Some(krate) = self.krate {\n+            // skip nested items if krate context was not provided\n+            let item = &krate.items[&item_id.id];\n+            self.print_item(item)\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n     /// Pretty-print an item\n     pub fn print_item(&mut self, item: &hir::Item) -> io::Result<()> {\n         try!(self.hardbreak_if_not_bol());\n@@ -1566,7 +1582,9 @@ impl<'a> State<'a> {\n                 }\n                 self.end()\n             }\n-            hir::DeclItem(ref item) => self.print_item(&**item),\n+            hir::DeclItem(ref item) => {\n+                self.print_item_id(item)\n+            }\n         }\n     }\n "}, {"sha": "97b25dafb6decddf74c0b7d494652a7edc29ee82", "filename": "src/librustc_front/util.rs", "status": "modified", "additions": 44, "deletions": 50, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/767ee79c4c38e7909c7fefef1b33be4612112336/src%2Flibrustc_front%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767ee79c4c38e7909c7fefef1b33be4612112336/src%2Flibrustc_front%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Futil.rs?ref=767ee79c4c38e7909c7fefef1b33be4612112336", "patch": "@@ -10,7 +10,7 @@\n \n use hir;\n use hir::*;\n-use visit::{self, Visitor, FnKind};\n+use intravisit::{self, Visitor, FnKind};\n use syntax::ast_util;\n use syntax::ast::{Ident, Name, NodeId, DUMMY_NODE_ID};\n use syntax::codemap::Span;\n@@ -145,12 +145,26 @@ pub fn unop_to_string(op: UnOp) -> &'static str {\n }\n \n pub struct IdVisitor<'a, O: 'a> {\n-    pub operation: &'a mut O,\n-    pub pass_through_items: bool,\n-    pub visited_outermost: bool,\n+    operation: &'a mut O,\n+\n+    // In general, the id visitor visits the contents of an item, but\n+    // not including nested trait/impl items, nor other nested items.\n+    // The base visitor itself always skips nested items, but not\n+    // trait/impl items. This means in particular that if you start by\n+    // visiting a trait or an impl, you should not visit the\n+    // trait/impl items respectively.  This is handled by setting\n+    // `skip_members` to true when `visit_item` is on the stack. This\n+    // way, if the user begins by calling `visit_trait_item`, we will\n+    // visit the trait item, but if they begin with `visit_item`, we\n+    // won't visit the (nested) trait items.\n+    skip_members: bool,\n }\n \n impl<'a, O: ast_util::IdVisitingOperation> IdVisitor<'a, O> {\n+    pub fn new(operation: &'a mut O) -> IdVisitor<'a, O> {\n+        IdVisitor { operation: operation, skip_members: false }\n+    }\n+\n     fn visit_generics_helper(&mut self, generics: &Generics) {\n         for type_parameter in generics.ty_params.iter() {\n             self.operation.visit_id(type_parameter.id)\n@@ -164,22 +178,17 @@ impl<'a, O: ast_util::IdVisitingOperation> IdVisitor<'a, O> {\n impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n     fn visit_mod(&mut self, module: &Mod, _: Span, node_id: NodeId) {\n         self.operation.visit_id(node_id);\n-        visit::walk_mod(self, module)\n+        intravisit::walk_mod(self, module)\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n         self.operation.visit_id(foreign_item.id);\n-        visit::walk_foreign_item(self, foreign_item)\n+        intravisit::walk_foreign_item(self, foreign_item)\n     }\n \n     fn visit_item(&mut self, item: &Item) {\n-        if !self.pass_through_items {\n-            if self.visited_outermost {\n-                return;\n-            } else {\n-                self.visited_outermost = true\n-            }\n-        }\n+        assert!(!self.skip_members);\n+        self.skip_members = true;\n \n         self.operation.visit_id(item.id);\n         match item.node {\n@@ -196,45 +205,44 @@ impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O>\n             }\n             _ => {}\n         }\n+        intravisit::walk_item(self, item);\n \n-        visit::walk_item(self, item);\n-\n-        self.visited_outermost = false\n+        self.skip_members = false;\n     }\n \n     fn visit_local(&mut self, local: &Local) {\n         self.operation.visit_id(local.id);\n-        visit::walk_local(self, local)\n+        intravisit::walk_local(self, local)\n     }\n \n     fn visit_block(&mut self, block: &Block) {\n         self.operation.visit_id(block.id);\n-        visit::walk_block(self, block)\n+        intravisit::walk_block(self, block)\n     }\n \n     fn visit_stmt(&mut self, statement: &Stmt) {\n         self.operation.visit_id(stmt_id(statement));\n-        visit::walk_stmt(self, statement)\n+        intravisit::walk_stmt(self, statement)\n     }\n \n     fn visit_pat(&mut self, pattern: &Pat) {\n         self.operation.visit_id(pattern.id);\n-        visit::walk_pat(self, pattern)\n+        intravisit::walk_pat(self, pattern)\n     }\n \n     fn visit_expr(&mut self, expression: &Expr) {\n         self.operation.visit_id(expression.id);\n-        visit::walk_expr(self, expression)\n+        intravisit::walk_expr(self, expression)\n     }\n \n     fn visit_ty(&mut self, typ: &Ty) {\n         self.operation.visit_id(typ.id);\n-        visit::walk_ty(self, typ)\n+        intravisit::walk_ty(self, typ)\n     }\n \n     fn visit_generics(&mut self, generics: &Generics) {\n         self.visit_generics_helper(generics);\n-        visit::walk_generics(self, generics)\n+        intravisit::walk_generics(self, generics)\n     }\n \n     fn visit_fn(&mut self,\n@@ -243,14 +251,6 @@ impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O>\n                 block: &'v Block,\n                 span: Span,\n                 node_id: NodeId) {\n-        if !self.pass_through_items {\n-            match function_kind {\n-                FnKind::Method(..) if self.visited_outermost => return,\n-                FnKind::Method(..) => self.visited_outermost = true,\n-                _ => {}\n-            }\n-        }\n-\n         self.operation.visit_id(node_id);\n \n         match function_kind {\n@@ -267,18 +267,12 @@ impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O>\n             self.operation.visit_id(argument.id)\n         }\n \n-        visit::walk_fn(self, function_kind, function_declaration, block, span);\n-\n-        if !self.pass_through_items {\n-            if let FnKind::Method(..) = function_kind {\n-                self.visited_outermost = false;\n-            }\n-        }\n+        intravisit::walk_fn(self, function_kind, function_declaration, block, span);\n     }\n \n     fn visit_struct_field(&mut self, struct_field: &StructField) {\n         self.operation.visit_id(struct_field.node.id);\n-        visit::walk_struct_field(self, struct_field)\n+        intravisit::walk_struct_field(self, struct_field)\n     }\n \n     fn visit_variant_data(&mut self,\n@@ -288,17 +282,21 @@ impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O>\n                           _: NodeId,\n                           _: Span) {\n         self.operation.visit_id(struct_def.id());\n-        visit::walk_struct_def(self, struct_def);\n+        intravisit::walk_struct_def(self, struct_def);\n     }\n \n     fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n-        self.operation.visit_id(ti.id);\n-        visit::walk_trait_item(self, ti);\n+        if !self.skip_members {\n+            self.operation.visit_id(ti.id);\n+            intravisit::walk_trait_item(self, ti);\n+        }\n     }\n \n     fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n-        self.operation.visit_id(ii.id);\n-        visit::walk_impl_item(self, ii);\n+        if !self.skip_members {\n+            self.operation.visit_id(ii.id);\n+            intravisit::walk_impl_item(self, ii);\n+        }\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &Lifetime) {\n@@ -311,7 +309,7 @@ impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O>\n \n     fn visit_trait_ref(&mut self, trait_ref: &TraitRef) {\n         self.operation.visit_id(trait_ref.ref_id);\n-        visit::walk_trait_ref(self, trait_ref);\n+        intravisit::walk_trait_ref(self, trait_ref);\n     }\n }\n \n@@ -323,11 +321,7 @@ pub fn compute_id_range_for_fn_body(fk: FnKind,\n                                     id: NodeId)\n                                     -> ast_util::IdRange {\n     let mut visitor = ast_util::IdRangeComputingVisitor { result: ast_util::IdRange::max() };\n-    let mut id_visitor = IdVisitor {\n-        operation: &mut visitor,\n-        pass_through_items: false,\n-        visited_outermost: false,\n-    };\n+    let mut id_visitor = IdVisitor::new(&mut visitor);\n     id_visitor.visit_fn(fk, decl, body, sp, id);\n     id_visitor.operation.result\n }"}]}