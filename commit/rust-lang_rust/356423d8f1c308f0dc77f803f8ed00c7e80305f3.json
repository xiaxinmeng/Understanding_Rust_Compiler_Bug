{"sha": "356423d8f1c308f0dc77f803f8ed00c7e80305f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NjQyM2Q4ZjFjMzA4ZjBkYzc3ZjgwM2Y4ZWQwMGM3ZTgwMzA1ZjM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-28T00:12:48Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-01T04:59:50Z"}, "message": "rustdoc: Refactor structure of html::run\n\nInstead of one giant function, this breaks it up into several smaller functions\nwhich have explicit dependencies among one another.\n\nThere are no code changes as a result of this commit.", "tree": {"sha": "7b83c100d298f39c57499ef45bf71269164717cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b83c100d298f39c57499ef45bf71269164717cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/356423d8f1c308f0dc77f803f8ed00c7e80305f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/356423d8f1c308f0dc77f803f8ed00c7e80305f3", "html_url": "https://github.com/rust-lang/rust/commit/356423d8f1c308f0dc77f803f8ed00c7e80305f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/356423d8f1c308f0dc77f803f8ed00c7e80305f3/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee97698f854f42b4921ac7dca9cbeaaf2decae98", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee97698f854f42b4921ac7dca9cbeaaf2decae98", "html_url": "https://github.com/rust-lang/rust/commit/ee97698f854f42b4921ac7dca9cbeaaf2decae98"}], "stats": {"total": 345, "additions": 179, "deletions": 166}, "files": [{"sha": "7f1e42ce602847ac627a2f775d223b00aedef8f0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 179, "deletions": 166, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/356423d8f1c308f0dc77f803f8ed00c7e80305f3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/356423d8f1c308f0dc77f803f8ed00c7e80305f3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=356423d8f1c308f0dc77f803f8ed00c7e80305f3", "patch": "@@ -229,6 +229,8 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     };\n     try!(mkdir(&cx.dst));\n \n+    // Crawl the crate attributes looking for attributes which control how we're\n+    // going to emit HTML\n     match krate.module.as_ref().map(|m| m.doc_list().unwrap_or(&[])) {\n         Some(attrs) => {\n             for attr in attrs.iter() {\n@@ -297,19 +299,37 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     cache.stack.push(krate.name.clone());\n     krate = cache.fold_crate(krate);\n \n+\n+    for &(n, ref e) in krate.externs.iter() {\n+        cache.extern_locations.insert(n, extern_location(e, &cx.dst));\n+        let did = ast::DefId { krate: n, node: ast::CRATE_NODE_ID };\n+        cache.paths.insert(did, (vec![e.name.to_string()], item_type::Module));\n+    }\n+\n+    let index = try!(build_index(&krate, &mut cache));\n+    try!(write_shared(&cx, &krate, &cache, index));\n+    let krate = try!(render_sources(&mut cx, krate));\n+\n+    // And finally render the whole crate's documentation\n+    cx.krate(krate, cache)\n+}\n+\n+fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String> {\n+    // Build the search index from the collected metadata\n     let mut nodeid_to_pathid = HashMap::new();\n     let mut pathid_to_nodeid = Vec::new();\n     {\n-        let Cache { search_index: ref mut index,\n-                    orphan_methods: ref meths, paths: ref mut paths, ..} = cache;\n+        let Cache { ref mut search_index,\n+                    ref orphan_methods,\n+                    ref mut paths, .. } = *cache;\n \n         // Attach all orphan methods to the type's definition if the type\n         // has since been learned.\n-        for &(pid, ref item) in meths.iter() {\n+        for &(pid, ref item) in orphan_methods.iter() {\n             let did = ast_util::local_def(pid);\n             match paths.find(&did) {\n                 Some(&(ref fqp, _)) => {\n-                    index.push(IndexItem {\n+                    search_index.push(IndexItem {\n                         ty: shortty(item),\n                         name: item.name.clone().unwrap(),\n                         path: fqp.slice_to(fqp.len() - 1).connect(\"::\")\n@@ -324,7 +344,7 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n \n         // Reduce `NodeId` in paths into smaller sequential numbers,\n         // and prune the paths that do not appear in the index.\n-        for item in index.iter() {\n+        for item in search_index.iter() {\n             match item.parent {\n                 Some(nodeid) => {\n                     if !nodeid_to_pathid.contains_key(&nodeid) {\n@@ -339,189 +359,182 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         assert_eq!(nodeid_to_pathid.len(), pathid_to_nodeid.len());\n     }\n \n-    // Publish the search index\n-    let index = {\n-        let mut w = MemWriter::new();\n-        try!(write!(&mut w, r#\"searchIndex['{}'] = \\{\"items\":[\"#, krate.name));\n-\n-        let mut lastpath = \"\".to_string();\n-        for (i, item) in cache.search_index.iter().enumerate() {\n-            // Omit the path if it is same to that of the prior item.\n-            let path;\n-            if lastpath.as_slice() == item.path.as_slice() {\n-                path = \"\";\n-            } else {\n-                lastpath = item.path.to_string();\n-                path = item.path.as_slice();\n-            };\n+    // Collect the index into a string\n+    let mut w = MemWriter::new();\n+    try!(write!(&mut w, r#\"searchIndex['{}'] = \\{\"items\":[\"#, krate.name));\n \n-            if i > 0 {\n-                try!(write!(&mut w, \",\"));\n-            }\n-            try!(write!(&mut w, r#\"[{:u},\"{}\",\"{}\",{}\"#,\n-                        item.ty, item.name, path,\n-                        item.desc.to_json().to_str()));\n-            match item.parent {\n-                Some(nodeid) => {\n-                    let pathid = *nodeid_to_pathid.find(&nodeid).unwrap();\n-                    try!(write!(&mut w, \",{}\", pathid));\n-                }\n-                None => {}\n+    let mut lastpath = \"\".to_string();\n+    for (i, item) in cache.search_index.iter().enumerate() {\n+        // Omit the path if it is same to that of the prior item.\n+        let path;\n+        if lastpath.as_slice() == item.path.as_slice() {\n+            path = \"\";\n+        } else {\n+            lastpath = item.path.to_string();\n+            path = item.path.as_slice();\n+        };\n+\n+        if i > 0 {\n+            try!(write!(&mut w, \",\"));\n+        }\n+        try!(write!(&mut w, r#\"[{:u},\"{}\",\"{}\",{}\"#,\n+                    item.ty, item.name, path,\n+                    item.desc.to_json().to_str()));\n+        match item.parent {\n+            Some(nodeid) => {\n+                let pathid = *nodeid_to_pathid.find(&nodeid).unwrap();\n+                try!(write!(&mut w, \",{}\", pathid));\n             }\n-            try!(write!(&mut w, \"]\"));\n+            None => {}\n         }\n+        try!(write!(&mut w, \"]\"));\n+    }\n \n-        try!(write!(&mut w, r#\"],\"paths\":[\"#));\n+    try!(write!(&mut w, r#\"],\"paths\":[\"#));\n \n-        for (i, &did) in pathid_to_nodeid.iter().enumerate() {\n-            let &(ref fqp, short) = cache.paths.find(&did).unwrap();\n-            if i > 0 {\n-                try!(write!(&mut w, \",\"));\n-            }\n-            try!(write!(&mut w, r#\"[{:u},\"{}\"]\"#,\n-                        short, *fqp.last().unwrap()));\n+    for (i, &did) in pathid_to_nodeid.iter().enumerate() {\n+        let &(ref fqp, short) = cache.paths.find(&did).unwrap();\n+        if i > 0 {\n+            try!(write!(&mut w, \",\"));\n         }\n+        try!(write!(&mut w, r#\"[{:u},\"{}\"]\"#,\n+                    short, *fqp.last().unwrap()));\n+    }\n \n-        try!(write!(&mut w, r\"]\\};\"));\n+    try!(write!(&mut w, r\"]\\};\"));\n \n-        str::from_utf8(w.unwrap().as_slice()).unwrap().to_string()\n-    };\n+    Ok(str::from_utf8(w.unwrap().as_slice()).unwrap().to_string())\n+}\n \n+fn write_shared(cx: &Context,\n+                krate: &clean::Crate,\n+                cache: &Cache,\n+                search_index: String) -> io::IoResult<()> {\n     // Write out the shared files. Note that these are shared among all rustdoc\n     // docs placed in the output directory, so this needs to be a synchronized\n     // operation with respect to all other rustdocs running around.\n-    {\n-        try!(mkdir(&cx.dst));\n-        let _lock = ::flock::Lock::new(&cx.dst.join(\".lock\"));\n-\n-        // Add all the static files. These may already exist, but we just\n-        // overwrite them anyway to make sure that they're fresh and up-to-date.\n-        try!(write(cx.dst.join(\"jquery.js\"),\n-                   include_bin!(\"static/jquery-2.1.0.min.js\")));\n-        try!(write(cx.dst.join(\"main.js\"), include_bin!(\"static/main.js\")));\n-        try!(write(cx.dst.join(\"main.css\"), include_bin!(\"static/main.css\")));\n-        try!(write(cx.dst.join(\"normalize.css\"),\n-                   include_bin!(\"static/normalize.css\")));\n-        try!(write(cx.dst.join(\"FiraSans-Regular.woff\"),\n-                   include_bin!(\"static/FiraSans-Regular.woff\")));\n-        try!(write(cx.dst.join(\"FiraSans-Medium.woff\"),\n-                   include_bin!(\"static/FiraSans-Medium.woff\")));\n-        try!(write(cx.dst.join(\"Heuristica-Regular.woff\"),\n-                   include_bin!(\"static/Heuristica-Regular.woff\")));\n-        try!(write(cx.dst.join(\"Heuristica-Italic.woff\"),\n-                   include_bin!(\"static/Heuristica-Italic.woff\")));\n-        try!(write(cx.dst.join(\"Heuristica-Bold.woff\"),\n-                   include_bin!(\"static/Heuristica-Bold.woff\")));\n-\n-        fn collect(path: &Path, krate: &str,\n-                   key: &str) -> io::IoResult<Vec<String>> {\n-            let mut ret = Vec::new();\n-            if path.exists() {\n-                for line in BufferedReader::new(File::open(path)).lines() {\n-                    let line = try!(line);\n-                    if !line.as_slice().starts_with(key) {\n-                        continue\n-                    }\n-                    if line.as_slice().starts_with(\n-                            format!(\"{}['{}']\", key, krate).as_slice()) {\n-                        continue\n-                    }\n-                    ret.push(line.to_string());\n+    try!(mkdir(&cx.dst));\n+    let _lock = ::flock::Lock::new(&cx.dst.join(\".lock\"));\n+\n+    // Add all the static files. These may already exist, but we just\n+    // overwrite them anyway to make sure that they're fresh and up-to-date.\n+    try!(write(cx.dst.join(\"jquery.js\"),\n+               include_bin!(\"static/jquery-2.1.0.min.js\")));\n+    try!(write(cx.dst.join(\"main.js\"), include_bin!(\"static/main.js\")));\n+    try!(write(cx.dst.join(\"main.css\"), include_bin!(\"static/main.css\")));\n+    try!(write(cx.dst.join(\"normalize.css\"),\n+               include_bin!(\"static/normalize.css\")));\n+    try!(write(cx.dst.join(\"FiraSans-Regular.woff\"),\n+               include_bin!(\"static/FiraSans-Regular.woff\")));\n+    try!(write(cx.dst.join(\"FiraSans-Medium.woff\"),\n+               include_bin!(\"static/FiraSans-Medium.woff\")));\n+    try!(write(cx.dst.join(\"Heuristica-Regular.woff\"),\n+               include_bin!(\"static/Heuristica-Regular.woff\")));\n+    try!(write(cx.dst.join(\"Heuristica-Italic.woff\"),\n+               include_bin!(\"static/Heuristica-Italic.woff\")));\n+    try!(write(cx.dst.join(\"Heuristica-Bold.woff\"),\n+               include_bin!(\"static/Heuristica-Bold.woff\")));\n+\n+    fn collect(path: &Path, krate: &str,\n+               key: &str) -> io::IoResult<Vec<String>> {\n+        let mut ret = Vec::new();\n+        if path.exists() {\n+            for line in BufferedReader::new(File::open(path)).lines() {\n+                let line = try!(line);\n+                if !line.as_slice().starts_with(key) {\n+                    continue\n+                }\n+                if line.as_slice().starts_with(\n+                        format!(\"{}['{}']\", key, krate).as_slice()) {\n+                    continue\n                 }\n+                ret.push(line.to_string());\n             }\n-            return Ok(ret);\n         }\n+        return Ok(ret);\n+    }\n \n-        // Update the search index\n-        let dst = cx.dst.join(\"search-index.js\");\n-        let all_indexes = try!(collect(&dst, krate.name.as_slice(),\n-                                       \"searchIndex\"));\n-        let mut w = try!(File::create(&dst));\n-        try!(writeln!(&mut w, r\"var searchIndex = \\{\\};\"));\n-        try!(writeln!(&mut w, \"{}\", index));\n-        for index in all_indexes.iter() {\n-            try!(writeln!(&mut w, \"{}\", *index));\n+    // Update the search index\n+    let dst = cx.dst.join(\"search-index.js\");\n+    let all_indexes = try!(collect(&dst, krate.name.as_slice(),\n+                                   \"searchIndex\"));\n+    let mut w = try!(File::create(&dst));\n+    try!(writeln!(&mut w, r\"var searchIndex = \\{\\};\"));\n+    try!(writeln!(&mut w, \"{}\", search_index));\n+    for index in all_indexes.iter() {\n+        try!(writeln!(&mut w, \"{}\", *index));\n+    }\n+    try!(writeln!(&mut w, \"initSearch(searchIndex);\"));\n+\n+    // Update the list of all implementors for traits\n+    let dst = cx.dst.join(\"implementors\");\n+    try!(mkdir(&dst));\n+    for (&did, imps) in cache.implementors.iter() {\n+        if ast_util::is_local(did) { continue }\n+        let &(ref remote_path, remote_item_type) = cache.paths.get(&did);\n+\n+        let mut mydst = dst.clone();\n+        for part in remote_path.slice_to(remote_path.len() - 1).iter() {\n+            mydst.push(part.as_slice());\n+            try!(mkdir(&mydst));\n+        }\n+        mydst.push(format!(\"{}.{}.js\",\n+                           remote_item_type.to_static_str(),\n+                           *remote_path.get(remote_path.len() - 1)));\n+        let all_implementors = try!(collect(&mydst, krate.name.as_slice(),\n+                                            \"implementors\"));\n+\n+        try!(mkdir(&mydst.dir_path()));\n+        let mut f = BufferedWriter::new(try!(File::create(&mydst)));\n+        try!(writeln!(&mut f, r\"(function() \\{var implementors = \\{\\};\"));\n+\n+        for implementor in all_implementors.iter() {\n+            try!(writeln!(&mut f, \"{}\", *implementor));\n         }\n-        try!(writeln!(&mut w, \"initSearch(searchIndex);\"));\n-\n-        // Update the list of all implementors for traits\n-        let dst = cx.dst.join(\"implementors\");\n-        try!(mkdir(&dst));\n-        for (&did, imps) in cache.implementors.iter() {\n-            if ast_util::is_local(did) { continue }\n-            let &(ref remote_path, remote_item_type) = cache.paths.get(&did);\n-\n-            let mut mydst = dst.clone();\n-            for part in remote_path.slice_to(remote_path.len() - 1).iter() {\n-                mydst.push(part.as_slice());\n-                try!(mkdir(&mydst));\n-            }\n-            mydst.push(format!(\"{}.{}.js\",\n-                               remote_item_type.to_static_str(),\n-                               *remote_path.get(remote_path.len() - 1)));\n-            let all_implementors = try!(collect(&mydst, krate.name.as_slice(),\n-                                                \"implementors\"));\n-\n-            try!(mkdir(&mydst.dir_path()));\n-            let mut f = BufferedWriter::new(try!(File::create(&mydst)));\n-            try!(writeln!(&mut f, r\"(function() \\{var implementors = \\{\\};\"));\n-\n-            for implementor in all_implementors.iter() {\n-                try!(writeln!(&mut f, \"{}\", *implementor));\n-            }\n \n-            try!(write!(&mut f, r\"implementors['{}'] = \\{\", krate.name));\n-            for imp in imps.iter() {\n-                let &(ref path, item_type) = match *imp {\n-                    PathType(clean::ResolvedPath { did, .. }) => {\n-                        cache.paths.get(&did)\n-                    }\n-                    PathType(..) | OtherType(..) => continue,\n-                };\n-                try!(write!(&mut f, r#\"{}:\"#, *path.get(path.len() - 1)));\n-                try!(write!(&mut f, r#\"\"{}\"#,\n-                            path.slice_to(path.len() - 1).connect(\"/\")));\n-                try!(write!(&mut f, r#\"/{}.{}.html\",\"#,\n-                            item_type.to_static_str(),\n-                            *path.get(path.len() - 1)));\n-            }\n-            try!(writeln!(&mut f, r\"\\};\"));\n-            try!(writeln!(&mut f, \"{}\", r\"\n-                if (window.register_implementors) {\n-                    window.register_implementors(implementors);\n-                } else {\n-                    window.pending_implementors = implementors;\n+        try!(write!(&mut f, r\"implementors['{}'] = \\{\", krate.name));\n+        for imp in imps.iter() {\n+            let &(ref path, item_type) = match *imp {\n+                PathType(clean::ResolvedPath { did, .. }) => {\n+                    cache.paths.get(&did)\n                 }\n-            \"));\n-            try!(writeln!(&mut f, r\"\\})()\"));\n+                PathType(..) | OtherType(..) => continue,\n+            };\n+            try!(write!(&mut f, r#\"{}:\"#, *path.get(path.len() - 1)));\n+            try!(write!(&mut f, r#\"\"{}\"#,\n+                        path.slice_to(path.len() - 1).connect(\"/\")));\n+            try!(write!(&mut f, r#\"/{}.{}.html\",\"#,\n+                        item_type.to_static_str(),\n+                        *path.get(path.len() - 1)));\n         }\n+        try!(writeln!(&mut f, r\"\\};\"));\n+        try!(writeln!(&mut f, \"{}\", r\"\n+            if (window.register_implementors) {\n+                window.register_implementors(implementors);\n+            } else {\n+                window.pending_implementors = implementors;\n+            }\n+        \"));\n+        try!(writeln!(&mut f, r\"\\})()\"));\n     }\n+    Ok(())\n+}\n \n-    // Render all source files (this may turn into a giant no-op)\n-    {\n-        info!(\"emitting source files\");\n-        let dst = cx.dst.join(\"src\");\n-        try!(mkdir(&dst));\n-        let dst = dst.join(krate.name.as_slice());\n-        try!(mkdir(&dst));\n-        let mut folder = SourceCollector {\n-            dst: dst,\n-            seen: HashSet::new(),\n-            cx: &mut cx,\n-        };\n-        // skip all invalid spans\n-        folder.seen.insert(\"\".to_string());\n-        krate = folder.fold_crate(krate);\n-    }\n-\n-    for &(n, ref e) in krate.externs.iter() {\n-        cache.extern_locations.insert(n, extern_location(e, &cx.dst));\n-        let did = ast::DefId { krate: n, node: ast::CRATE_NODE_ID };\n-        cache.paths.insert(did, (vec![e.name.to_string()], item_type::Module));\n-    }\n-\n-    // And finally render the whole crate's documentation\n-    cx.krate(krate, cache)\n+fn render_sources(cx: &mut Context,\n+                  krate: clean::Crate) -> io::IoResult<clean::Crate> {\n+    info!(\"emitting source files\");\n+    let dst = cx.dst.join(\"src\");\n+    try!(mkdir(&dst));\n+    let dst = dst.join(krate.name.as_slice());\n+    try!(mkdir(&dst));\n+    let mut folder = SourceCollector {\n+        dst: dst,\n+        seen: HashSet::new(),\n+        cx: cx,\n+    };\n+    // skip all invalid spans\n+    folder.seen.insert(\"\".to_string());\n+    Ok(folder.fold_crate(krate))\n }\n \n /// Writes the entire contents of a string to a destination, not attempting to"}]}