{"sha": "ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlOWFlOTcxM2MwMWY5YWNhNDM4OGE3MWNkOGY2YjczNmM2OWE5YmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-04T14:17:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-04T14:17:24Z"}, "message": "Auto merge of #6507 - bengsparks:lint/issue6410, r=flip1995\n\nNeedless Question Mark Lint\n\nFixes #6410, i.e the needless question mark lint\n\nchangelog: [`needless_question_mark`] New lint", "tree": {"sha": "a1b727429e09b058be6230aae173a83c7e3d9b23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1b727429e09b058be6230aae173a83c7e3d9b23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf", "html_url": "https://github.com/rust-lang/rust/commit/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd1929e1f23ddbc9693db1ea5886a83c6179f311", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd1929e1f23ddbc9693db1ea5886a83c6179f311", "html_url": "https://github.com/rust-lang/rust/commit/dd1929e1f23ddbc9693db1ea5886a83c6179f311"}, {"sha": "ba87acb44090412f5ace0a5ca655e8298d82b874", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba87acb44090412f5ace0a5ca655e8298d82b874", "html_url": "https://github.com/rust-lang/rust/commit/ba87acb44090412f5ace0a5ca655e8298d82b874"}], "stats": {"total": 679, "additions": 666, "deletions": 13}, "files": [{"sha": "7d4a4f0e41bbda05499d9fc155e4ea00dfec1092", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf", "patch": "@@ -2101,6 +2101,7 @@ Released 2018-09-13\n [`needless_doctest_main`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_doctest_main\n [`needless_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_lifetimes\n [`needless_pass_by_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_pass_by_value\n+[`needless_question_mark`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_question_mark\n [`needless_range_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_range_loop\n [`needless_return`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_return\n [`needless_update`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_update"}, {"sha": "f0b730346a0f9a52674b5b8d1bfd72fa46bfd5f9", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf", "patch": "@@ -271,6 +271,7 @@ mod needless_borrow;\n mod needless_borrowed_ref;\n mod needless_continue;\n mod needless_pass_by_value;\n+mod needless_question_mark;\n mod needless_update;\n mod neg_cmp_op_on_partial_ord;\n mod neg_multiply;\n@@ -800,6 +801,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE,\n         &needless_continue::NEEDLESS_CONTINUE,\n         &needless_pass_by_value::NEEDLESS_PASS_BY_VALUE,\n+        &needless_question_mark::NEEDLESS_QUESTION_MARK,\n         &needless_update::NEEDLESS_UPDATE,\n         &neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD,\n         &neg_multiply::NEG_MULTIPLY,\n@@ -1020,6 +1022,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || box from_over_into::FromOverInto::new(msrv));\n     store.register_late_pass(move || box use_self::UseSelf::new(msrv));\n     store.register_late_pass(move || box missing_const_for_fn::MissingConstForFn::new(msrv));\n+    store.register_late_pass(move || box needless_question_mark::NeedlessQuestionMark::new(msrv));\n \n     store.register_late_pass(|| box size_of_in_element_count::SizeOfInElementCount);\n     store.register_late_pass(|| box map_clone::MapClone);\n@@ -1547,6 +1550,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&needless_bool::BOOL_COMPARISON),\n         LintId::of(&needless_bool::NEEDLESS_BOOL),\n         LintId::of(&needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE),\n+        LintId::of(&needless_question_mark::NEEDLESS_QUESTION_MARK),\n         LintId::of(&needless_update::NEEDLESS_UPDATE),\n         LintId::of(&neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD),\n         LintId::of(&neg_multiply::NEG_MULTIPLY),\n@@ -1806,6 +1810,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&needless_bool::BOOL_COMPARISON),\n         LintId::of(&needless_bool::NEEDLESS_BOOL),\n         LintId::of(&needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE),\n+        LintId::of(&needless_question_mark::NEEDLESS_QUESTION_MARK),\n         LintId::of(&needless_update::NEEDLESS_UPDATE),\n         LintId::of(&neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD),\n         LintId::of(&no_effect::NO_EFFECT),"}, {"sha": "783e6b716d463ca7d4e8a241a9540fcd72ac4645", "filename": "clippy_lints/src/needless_question_mark.rs", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_question_mark.rs?ref=ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf", "patch": "@@ -0,0 +1,232 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::{Body, Expr, ExprKind, LangItem, MatchSource, QPath};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::ty::DefIdTree;\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::sym;\n+\n+use crate::utils;\n+use if_chain::if_chain;\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Suggests alternatives for useless applications of `?` in terminating expressions\n+    ///\n+    /// **Why is this bad?** There's no reason to use ? to short-circuit when execution of the body will end there anyway.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// struct TO {\n+    ///     magic: Option<usize>,\n+    /// }\n+    ///\n+    /// fn f(to: TO) -> Option<usize> {\n+    ///     Some(to.magic?)\n+    /// }\n+    ///\n+    /// struct TR {\n+    ///     magic: Result<usize, bool>,\n+    /// }\n+    ///\n+    /// fn g(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    ///     tr.and_then(|t| Ok(t.magic?))\n+    /// }\n+    ///\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// struct TO {\n+    ///     magic: Option<usize>,\n+    /// }\n+    ///\n+    /// fn f(to: TO) -> Option<usize> {\n+    ///    to.magic\n+    /// }\n+    ///\n+    /// struct TR {\n+    ///     magic: Result<usize, bool>,\n+    /// }\n+    ///\n+    /// fn g(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    ///     tr.and_then(|t| t.magic)\n+    /// }\n+    /// ```\n+    pub NEEDLESS_QUESTION_MARK,\n+    complexity,\n+    \"Suggest value.inner_option instead of Some(value.inner_option?). The same goes for Result<T, E>.\"\n+}\n+\n+const NEEDLESS_QUESTION_MARK_RESULT_MSRV: RustcVersion = RustcVersion::new(1, 13, 0);\n+const NEEDLESS_QUESTION_MARK_OPTION_MSRV: RustcVersion = RustcVersion::new(1, 22, 0);\n+\n+pub struct NeedlessQuestionMark {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl NeedlessQuestionMark {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(NeedlessQuestionMark => [NEEDLESS_QUESTION_MARK]);\n+\n+#[derive(Debug)]\n+enum SomeOkCall<'a> {\n+    SomeCall(&'a Expr<'a>, &'a Expr<'a>),\n+    OkCall(&'a Expr<'a>, &'a Expr<'a>),\n+}\n+\n+impl LateLintPass<'_> for NeedlessQuestionMark {\n+    /*\n+     * The question mark operator is compatible with both Result<T, E> and Option<T>,\n+     * from Rust 1.13 and 1.22 respectively.\n+     */\n+\n+    /*\n+     * What do we match:\n+     * Expressions that look like this:\n+     * Some(option?), Ok(result?)\n+     *\n+     * Where do we match:\n+     *      Last expression of a body\n+     *      Return statement\n+     *      A body's value (single line closure)\n+     *\n+     * What do we not match:\n+     *      Implicit calls to `from(..)` on the error value\n+     */\n+\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'_ Expr<'_>) {\n+        let e = match &expr.kind {\n+            ExprKind::Ret(Some(e)) => e,\n+            _ => return,\n+        };\n+\n+        if let Some(ok_some_call) = is_some_or_ok_call(self, cx, e) {\n+            emit_lint(cx, &ok_some_call);\n+        }\n+    }\n+\n+    fn check_body(&mut self, cx: &LateContext<'_>, body: &'_ Body<'_>) {\n+        // Function / Closure block\n+        let expr_opt = if let ExprKind::Block(block, _) = &body.value.kind {\n+            block.expr\n+        } else {\n+            // Single line closure\n+            Some(&body.value)\n+        };\n+\n+        if_chain! {\n+            if let Some(expr) = expr_opt;\n+            if let Some(ok_some_call) = is_some_or_ok_call(self, cx, expr);\n+            then {\n+                emit_lint(cx, &ok_some_call);\n+            }\n+        };\n+    }\n+\n+    extract_msrv_attr!(LateContext);\n+}\n+\n+fn emit_lint(cx: &LateContext<'_>, expr: &SomeOkCall<'_>) {\n+    let (entire_expr, inner_expr) = match expr {\n+        SomeOkCall::OkCall(outer, inner) | SomeOkCall::SomeCall(outer, inner) => (outer, inner),\n+    };\n+\n+    utils::span_lint_and_sugg(\n+        cx,\n+        NEEDLESS_QUESTION_MARK,\n+        entire_expr.span,\n+        \"Question mark operator is useless here\",\n+        \"try\",\n+        format!(\"{}\", utils::snippet(cx, inner_expr.span, r#\"\"...\"\"#)),\n+        Applicability::MachineApplicable,\n+    );\n+}\n+\n+fn is_some_or_ok_call<'a>(\n+    nqml: &NeedlessQuestionMark,\n+    cx: &'a LateContext<'_>,\n+    expr: &'a Expr<'_>,\n+) -> Option<SomeOkCall<'a>> {\n+    if_chain! {\n+        // Check outer expression matches CALL_IDENT(ARGUMENT) format\n+        if let ExprKind::Call(path, args) = &expr.kind;\n+        if let ExprKind::Path(QPath::Resolved(None, path)) = &path.kind;\n+        if is_some_ctor(cx, path.res) || is_ok_ctor(cx, path.res);\n+\n+        // Extract inner expression from ARGUMENT\n+        if let ExprKind::Match(inner_expr_with_q, _, MatchSource::TryDesugar) = &args[0].kind;\n+        if let ExprKind::Call(called, args) = &inner_expr_with_q.kind;\n+        if args.len() == 1;\n+\n+        if let ExprKind::Path(QPath::LangItem(LangItem::TryIntoResult, _)) = &called.kind;\n+        then {\n+            // Extract inner expr type from match argument generated by\n+            // question mark operator\n+            let inner_expr = &args[0];\n+\n+            let inner_ty = cx.typeck_results().expr_ty(inner_expr);\n+            let outer_ty = cx.typeck_results().expr_ty(expr);\n+\n+            // Check if outer and inner type are Option\n+            let outer_is_some = utils::is_type_diagnostic_item(cx, outer_ty, sym::option_type);\n+            let inner_is_some = utils::is_type_diagnostic_item(cx, inner_ty, sym::option_type);\n+\n+            // Check for Option MSRV\n+            let meets_option_msrv = utils::meets_msrv(nqml.msrv.as_ref(), &NEEDLESS_QUESTION_MARK_OPTION_MSRV);\n+            if outer_is_some && inner_is_some && meets_option_msrv {\n+                return Some(SomeOkCall::SomeCall(expr, inner_expr));\n+            }\n+\n+            // Check if outer and inner type are Result\n+            let outer_is_result = utils::is_type_diagnostic_item(cx, outer_ty, sym::result_type);\n+            let inner_is_result = utils::is_type_diagnostic_item(cx, inner_ty, sym::result_type);\n+\n+            // Additional check: if the error type of the Result can be converted\n+            // via the From trait, then don't match\n+            let does_not_call_from = !has_implicit_error_from(cx, expr, inner_expr);\n+\n+            // Must meet Result MSRV\n+            let meets_result_msrv = utils::meets_msrv(nqml.msrv.as_ref(), &NEEDLESS_QUESTION_MARK_RESULT_MSRV);\n+            if outer_is_result && inner_is_result && does_not_call_from && meets_result_msrv {\n+                return Some(SomeOkCall::OkCall(expr, inner_expr));\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn has_implicit_error_from(cx: &LateContext<'_>, entire_expr: &Expr<'_>, inner_result_expr: &Expr<'_>) -> bool {\n+    return cx.typeck_results().expr_ty(entire_expr) != cx.typeck_results().expr_ty(inner_result_expr);\n+}\n+\n+fn is_ok_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n+    if let Some(ok_id) = cx.tcx.lang_items().result_ok_variant() {\n+        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n+            if let Some(variant_id) = cx.tcx.parent(id) {\n+                return variant_id == ok_id;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+fn is_some_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n+    if let Some(some_id) = cx.tcx.lang_items().option_some_variant() {\n+        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n+            if let Some(variant_id) = cx.tcx.parent(id) {\n+                return variant_id == some_id;\n+            }\n+        }\n+    }\n+    false\n+}"}, {"sha": "70218f3f041d8675cbb8c5d74800e66462f904ed", "filename": "tests/ui/needless_question_mark.fixed", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf/tests%2Fui%2Fneedless_question_mark.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf/tests%2Fui%2Fneedless_question_mark.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_question_mark.fixed?ref=ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf", "patch": "@@ -0,0 +1,163 @@\n+// run-rustfix\n+\n+#![warn(clippy::needless_question_mark)]\n+#![allow(clippy::needless_return, clippy::unnecessary_unwrap, dead_code, unused_must_use)]\n+#![feature(custom_inner_attributes)]\n+\n+struct TO {\n+    magic: Option<usize>,\n+}\n+\n+struct TR {\n+    magic: Result<usize, bool>,\n+}\n+\n+fn simple_option_bad1(to: TO) -> Option<usize> {\n+    // return as a statement\n+    return to.magic;\n+}\n+\n+// formatting will add a semi-colon, which would make\n+// this identical to the test case above\n+#[rustfmt::skip]\n+fn simple_option_bad2(to: TO) -> Option<usize> {\n+    // return as an expression\n+    return to.magic\n+}\n+\n+fn simple_option_bad3(to: TO) -> Option<usize> {\n+    // block value \"return\"\n+    to.magic\n+}\n+\n+fn simple_option_bad4(to: Option<TO>) -> Option<usize> {\n+    // single line closure\n+    to.and_then(|t| t.magic)\n+}\n+\n+// formatting this will remove the block brackets, making\n+// this test identical to the one above\n+#[rustfmt::skip]\n+fn simple_option_bad5(to: Option<TO>) -> Option<usize> {\n+    // closure with body\n+    to.and_then(|t| {\n+        t.magic\n+    })\n+}\n+\n+fn simple_result_bad1(tr: TR) -> Result<usize, bool> {\n+    return tr.magic;\n+}\n+\n+// formatting will add a semi-colon, which would make\n+// this identical to the test case above\n+#[rustfmt::skip]\n+fn simple_result_bad2(tr: TR) -> Result<usize, bool> {\n+    return tr.magic\n+}\n+\n+fn simple_result_bad3(tr: TR) -> Result<usize, bool> {\n+    tr.magic\n+}\n+\n+fn simple_result_bad4(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    tr.and_then(|t| t.magic)\n+}\n+\n+// formatting this will remove the block brackets, making\n+// this test identical to the one above\n+#[rustfmt::skip]\n+fn simple_result_bad5(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    tr.and_then(|t| {\n+        t.magic\n+    })\n+}\n+\n+fn also_bad(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    if tr.is_ok() {\n+        let t = tr.unwrap();\n+        return t.magic;\n+    }\n+    Err(false)\n+}\n+\n+fn false_positive_test<U, T>(x: Result<(), U>) -> Result<(), T>\n+where\n+    T: From<U>,\n+{\n+    Ok(x?)\n+}\n+\n+fn main() {}\n+\n+mod question_mark_none {\n+    #![clippy::msrv = \"1.12.0\"]\n+    fn needless_question_mark_option() -> Option<usize> {\n+        struct TO {\n+            magic: Option<usize>,\n+        }\n+        let to = TO { magic: None };\n+        Some(to.magic?) // should not be triggered\n+    }\n+\n+    fn needless_question_mark_result() -> Result<usize, bool> {\n+        struct TO {\n+            magic: Result<usize, bool>,\n+        }\n+        let to = TO { magic: Ok(1_usize) };\n+        Ok(to.magic?) // should not be triggered\n+    }\n+\n+    fn main() {\n+        needless_question_mark_option();\n+        needless_question_mark_result();\n+    }\n+}\n+\n+mod question_mark_result {\n+    #![clippy::msrv = \"1.21.0\"]\n+    fn needless_question_mark_option() -> Option<usize> {\n+        struct TO {\n+            magic: Option<usize>,\n+        }\n+        let to = TO { magic: None };\n+        Some(to.magic?) // should not be triggered\n+    }\n+\n+    fn needless_question_mark_result() -> Result<usize, bool> {\n+        struct TO {\n+            magic: Result<usize, bool>,\n+        }\n+        let to = TO { magic: Ok(1_usize) };\n+        to.magic // should be triggered\n+    }\n+\n+    fn main() {\n+        needless_question_mark_option();\n+        needless_question_mark_result();\n+    }\n+}\n+\n+mod question_mark_both {\n+    #![clippy::msrv = \"1.22.0\"]\n+    fn needless_question_mark_option() -> Option<usize> {\n+        struct TO {\n+            magic: Option<usize>,\n+        }\n+        let to = TO { magic: None };\n+        to.magic // should be triggered\n+    }\n+\n+    fn needless_question_mark_result() -> Result<usize, bool> {\n+        struct TO {\n+            magic: Result<usize, bool>,\n+        }\n+        let to = TO { magic: Ok(1_usize) };\n+        to.magic // should be triggered\n+    }\n+\n+    fn main() {\n+        needless_question_mark_option();\n+        needless_question_mark_result();\n+    }\n+}"}, {"sha": "60ac2c8d72eac920afe0a46b4253f8ac5594b316", "filename": "tests/ui/needless_question_mark.rs", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf/tests%2Fui%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf/tests%2Fui%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_question_mark.rs?ref=ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf", "patch": "@@ -0,0 +1,163 @@\n+// run-rustfix\n+\n+#![warn(clippy::needless_question_mark)]\n+#![allow(clippy::needless_return, clippy::unnecessary_unwrap, dead_code, unused_must_use)]\n+#![feature(custom_inner_attributes)]\n+\n+struct TO {\n+    magic: Option<usize>,\n+}\n+\n+struct TR {\n+    magic: Result<usize, bool>,\n+}\n+\n+fn simple_option_bad1(to: TO) -> Option<usize> {\n+    // return as a statement\n+    return Some(to.magic?);\n+}\n+\n+// formatting will add a semi-colon, which would make\n+// this identical to the test case above\n+#[rustfmt::skip]\n+fn simple_option_bad2(to: TO) -> Option<usize> {\n+    // return as an expression\n+    return Some(to.magic?)\n+}\n+\n+fn simple_option_bad3(to: TO) -> Option<usize> {\n+    // block value \"return\"\n+    Some(to.magic?)\n+}\n+\n+fn simple_option_bad4(to: Option<TO>) -> Option<usize> {\n+    // single line closure\n+    to.and_then(|t| Some(t.magic?))\n+}\n+\n+// formatting this will remove the block brackets, making\n+// this test identical to the one above\n+#[rustfmt::skip]\n+fn simple_option_bad5(to: Option<TO>) -> Option<usize> {\n+    // closure with body\n+    to.and_then(|t| {\n+        Some(t.magic?)\n+    })\n+}\n+\n+fn simple_result_bad1(tr: TR) -> Result<usize, bool> {\n+    return Ok(tr.magic?);\n+}\n+\n+// formatting will add a semi-colon, which would make\n+// this identical to the test case above\n+#[rustfmt::skip]\n+fn simple_result_bad2(tr: TR) -> Result<usize, bool> {\n+    return Ok(tr.magic?)\n+}\n+\n+fn simple_result_bad3(tr: TR) -> Result<usize, bool> {\n+    Ok(tr.magic?)\n+}\n+\n+fn simple_result_bad4(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    tr.and_then(|t| Ok(t.magic?))\n+}\n+\n+// formatting this will remove the block brackets, making\n+// this test identical to the one above\n+#[rustfmt::skip]\n+fn simple_result_bad5(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    tr.and_then(|t| {\n+        Ok(t.magic?)\n+    })\n+}\n+\n+fn also_bad(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    if tr.is_ok() {\n+        let t = tr.unwrap();\n+        return Ok(t.magic?);\n+    }\n+    Err(false)\n+}\n+\n+fn false_positive_test<U, T>(x: Result<(), U>) -> Result<(), T>\n+where\n+    T: From<U>,\n+{\n+    Ok(x?)\n+}\n+\n+fn main() {}\n+\n+mod question_mark_none {\n+    #![clippy::msrv = \"1.12.0\"]\n+    fn needless_question_mark_option() -> Option<usize> {\n+        struct TO {\n+            magic: Option<usize>,\n+        }\n+        let to = TO { magic: None };\n+        Some(to.magic?) // should not be triggered\n+    }\n+\n+    fn needless_question_mark_result() -> Result<usize, bool> {\n+        struct TO {\n+            magic: Result<usize, bool>,\n+        }\n+        let to = TO { magic: Ok(1_usize) };\n+        Ok(to.magic?) // should not be triggered\n+    }\n+\n+    fn main() {\n+        needless_question_mark_option();\n+        needless_question_mark_result();\n+    }\n+}\n+\n+mod question_mark_result {\n+    #![clippy::msrv = \"1.21.0\"]\n+    fn needless_question_mark_option() -> Option<usize> {\n+        struct TO {\n+            magic: Option<usize>,\n+        }\n+        let to = TO { magic: None };\n+        Some(to.magic?) // should not be triggered\n+    }\n+\n+    fn needless_question_mark_result() -> Result<usize, bool> {\n+        struct TO {\n+            magic: Result<usize, bool>,\n+        }\n+        let to = TO { magic: Ok(1_usize) };\n+        Ok(to.magic?) // should be triggered\n+    }\n+\n+    fn main() {\n+        needless_question_mark_option();\n+        needless_question_mark_result();\n+    }\n+}\n+\n+mod question_mark_both {\n+    #![clippy::msrv = \"1.22.0\"]\n+    fn needless_question_mark_option() -> Option<usize> {\n+        struct TO {\n+            magic: Option<usize>,\n+        }\n+        let to = TO { magic: None };\n+        Some(to.magic?) // should be triggered\n+    }\n+\n+    fn needless_question_mark_result() -> Result<usize, bool> {\n+        struct TO {\n+            magic: Result<usize, bool>,\n+        }\n+        let to = TO { magic: Ok(1_usize) };\n+        Ok(to.magic?) // should be triggered\n+    }\n+\n+    fn main() {\n+        needless_question_mark_option();\n+        needless_question_mark_result();\n+    }\n+}"}, {"sha": "b4eb21882ece95a30fa14fe7493c991df2556887", "filename": "tests/ui/needless_question_mark.stderr", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf/tests%2Fui%2Fneedless_question_mark.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf/tests%2Fui%2Fneedless_question_mark.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_question_mark.stderr?ref=ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf", "patch": "@@ -0,0 +1,88 @@\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:17:12\n+   |\n+LL |     return Some(to.magic?);\n+   |            ^^^^^^^^^^^^^^^ help: try: `to.magic`\n+   |\n+   = note: `-D clippy::needless-question-mark` implied by `-D warnings`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:25:12\n+   |\n+LL |     return Some(to.magic?)\n+   |            ^^^^^^^^^^^^^^^ help: try: `to.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:30:5\n+   |\n+LL |     Some(to.magic?)\n+   |     ^^^^^^^^^^^^^^^ help: try: `to.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:35:21\n+   |\n+LL |     to.and_then(|t| Some(t.magic?))\n+   |                     ^^^^^^^^^^^^^^ help: try: `t.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:44:9\n+   |\n+LL |         Some(t.magic?)\n+   |         ^^^^^^^^^^^^^^ help: try: `t.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:49:12\n+   |\n+LL |     return Ok(tr.magic?);\n+   |            ^^^^^^^^^^^^^ help: try: `tr.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:56:12\n+   |\n+LL |     return Ok(tr.magic?)\n+   |            ^^^^^^^^^^^^^ help: try: `tr.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:60:5\n+   |\n+LL |     Ok(tr.magic?)\n+   |     ^^^^^^^^^^^^^ help: try: `tr.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:64:21\n+   |\n+LL |     tr.and_then(|t| Ok(t.magic?))\n+   |                     ^^^^^^^^^^^^ help: try: `t.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:72:9\n+   |\n+LL |         Ok(t.magic?)\n+   |         ^^^^^^^^^^^^ help: try: `t.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:79:16\n+   |\n+LL |         return Ok(t.magic?);\n+   |                ^^^^^^^^^^^^ help: try: `t.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:132:9\n+   |\n+LL |         Ok(to.magic?) // should be triggered\n+   |         ^^^^^^^^^^^^^ help: try: `to.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:148:9\n+   |\n+LL |         Some(to.magic?) // should be triggered\n+   |         ^^^^^^^^^^^^^^^ help: try: `to.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:156:9\n+   |\n+LL |         Ok(to.magic?) // should be triggered\n+   |         ^^^^^^^^^^^^^ help: try: `to.magic`\n+\n+error: aborting due to 14 previous errors\n+"}, {"sha": "5b96bb59c5f188beda95e9f595bb496114dd7706", "filename": "tests/ui/try_err.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf/tests%2Fui%2Ftry_err.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf/tests%2Fui%2Ftry_err.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftry_err.fixed?ref=ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf", "patch": "@@ -2,7 +2,7 @@\n // aux-build:macro_rules.rs\n \n #![deny(clippy::try_err)]\n-#![allow(clippy::unnecessary_wraps)]\n+#![allow(clippy::unnecessary_wraps, clippy::needless_question_mark)]\n \n #[macro_use]\n extern crate macro_rules;"}, {"sha": "f220d697d2cd7e5e0592596605bb0b038ef6a468", "filename": "tests/ui/try_err.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf/tests%2Fui%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf/tests%2Fui%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftry_err.rs?ref=ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf", "patch": "@@ -2,7 +2,7 @@\n // aux-build:macro_rules.rs\n \n #![deny(clippy::try_err)]\n-#![allow(clippy::unnecessary_wraps)]\n+#![allow(clippy::unnecessary_wraps, clippy::needless_question_mark)]\n \n #[macro_use]\n extern crate macro_rules;"}, {"sha": "b6a7bc5a1cc95466bd3f3d4fa0c28a6998053753", "filename": "tests/ui/unit_arg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf/tests%2Fui%2Funit_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf/tests%2Fui%2Funit_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funit_arg.rs?ref=ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf", "patch": "@@ -5,7 +5,8 @@\n     unused_variables,\n     clippy::unused_unit,\n     clippy::unnecessary_wraps,\n-    clippy::or_fun_call\n+    clippy::or_fun_call,\n+    clippy::needless_question_mark\n )]\n \n use std::fmt::Debug;"}, {"sha": "094cff8c98591146dd7558d321afed17894cd9d6", "filename": "tests/ui/unit_arg.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf/tests%2Fui%2Funit_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf/tests%2Fui%2Funit_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funit_arg.stderr?ref=ae9ae9713c01f9aca4388a71cd8f6b736c69a9bf", "patch": "@@ -1,5 +1,5 @@\n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:30:5\n+  --> $DIR/unit_arg.rs:31:5\n    |\n LL | /     foo({\n LL | |         1;\n@@ -20,7 +20,7 @@ LL |     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:33:5\n+  --> $DIR/unit_arg.rs:34:5\n    |\n LL |     foo(foo(1));\n    |     ^^^^^^^^^^^\n@@ -32,7 +32,7 @@ LL |     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:34:5\n+  --> $DIR/unit_arg.rs:35:5\n    |\n LL | /     foo({\n LL | |         foo(1);\n@@ -54,7 +54,7 @@ LL |     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:39:5\n+  --> $DIR/unit_arg.rs:40:5\n    |\n LL | /     b.bar({\n LL | |         1;\n@@ -74,7 +74,7 @@ LL |     b.bar(());\n    |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:42:5\n+  --> $DIR/unit_arg.rs:43:5\n    |\n LL |     taking_multiple_units(foo(0), foo(1));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -87,7 +87,7 @@ LL |     taking_multiple_units((), ());\n    |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:43:5\n+  --> $DIR/unit_arg.rs:44:5\n    |\n LL | /     taking_multiple_units(foo(0), {\n LL | |         foo(1);\n@@ -110,7 +110,7 @@ LL |     taking_multiple_units((), ());\n    |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:47:5\n+  --> $DIR/unit_arg.rs:48:5\n    |\n LL | /     taking_multiple_units(\n LL | |         {\n@@ -140,7 +140,7 @@ LL |         foo(2);\n  ...\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:58:13\n+  --> $DIR/unit_arg.rs:59:13\n    |\n LL |     None.or(Some(foo(2)));\n    |             ^^^^^^^^^^^^\n@@ -154,7 +154,7 @@ LL |     });\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:61:5\n+  --> $DIR/unit_arg.rs:62:5\n    |\n LL |     foo(foo(()))\n    |     ^^^^^^^^^^^^\n@@ -166,7 +166,7 @@ LL |     foo(())\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:94:5\n+  --> $DIR/unit_arg.rs:95:5\n    |\n LL |     Some(foo(1))\n    |     ^^^^^^^^^^^^"}]}