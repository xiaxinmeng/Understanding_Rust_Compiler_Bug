{"sha": "2616581863ea71ecc23f1f126cb409e047139b6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MTY1ODE4NjNlYTcxZWNjMjNmMWYxMjZjYjQwOWUwNDcxMzliNmM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-29T20:32:07Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-30T13:47:15Z"}, "message": "Refactor helper routines to be less tied to match syntax", "tree": {"sha": "0e5b2b4ec5cf263f35c5c4287beb3f9106f53f4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e5b2b4ec5cf263f35c5c4287beb3f9106f53f4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2616581863ea71ecc23f1f126cb409e047139b6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2616581863ea71ecc23f1f126cb409e047139b6c", "html_url": "https://github.com/rust-lang/rust/commit/2616581863ea71ecc23f1f126cb409e047139b6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2616581863ea71ecc23f1f126cb409e047139b6c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcd84901c674eda61fefc363a0adc44790b4e24f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcd84901c674eda61fefc363a0adc44790b4e24f", "html_url": "https://github.com/rust-lang/rust/commit/dcd84901c674eda61fefc363a0adc44790b4e24f"}], "stats": {"total": 117, "additions": 64, "deletions": 53}, "files": [{"sha": "153eec1bc7be1b89822d4ce855b2f431176e1c21", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 64, "deletions": 53, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/2616581863ea71ecc23f1f126cb409e047139b6c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2616581863ea71ecc23f1f126cb409e047139b6c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=2616581863ea71ecc23f1f126cb409e047139b6c", "patch": "@@ -1124,10 +1124,10 @@ pub fn compare_values(cx: block,\n     }\n }\n \n-pub fn store_non_ref_bindings(bcx: block,\n-                              data: &ArmData,\n-                              opt_temp_cleanups: Option<&mut ~[ValueRef]>)\n-    -> block\n+fn store_non_ref_bindings(bcx: block,\n+                          bindings_map: &BindingsMap,\n+                          mut opt_temp_cleanups: Option<&mut ~[ValueRef]>)\n+                          -> block\n {\n     /*!\n      *\n@@ -1139,8 +1139,7 @@ pub fn store_non_ref_bindings(bcx: block,\n      */\n \n     let mut bcx = bcx;\n-    let mut opt_temp_cleanups = opt_temp_cleanups;\n-    for data.bindings_map.each_value |&binding_info| {\n+    for bindings_map.each_value |&binding_info| {\n         match binding_info.trmode {\n             TrByValue(is_move, lldest) => {\n                 let llval = Load(bcx, binding_info.llmatch); // get a T*\n@@ -1166,16 +1165,22 @@ pub fn store_non_ref_bindings(bcx: block,\n     return bcx;\n }\n \n-pub fn insert_lllocals(bcx: block,\n-                       data: &ArmData,\n-                       add_cleans: bool) -> block {\n+fn insert_lllocals(bcx: block,\n+                   bindings_map: &BindingsMap,\n+                   binding_mode: IrrefutablePatternBindingMode,\n+                   add_cleans: bool) -> block {\n     /*!\n-     *\n      * For each binding in `data.bindings_map`, adds an appropriate entry into\n      * the `fcx.lllocals` map.  If add_cleans is true, then adds cleanups for\n-     * the bindings. */\n+     * the bindings.\n+     */\n \n-    for data.bindings_map.each_value |&binding_info| {\n+    let llmap = match binding_mode {\n+        BindLocal => bcx.fcx.lllocals,\n+        BindArgument => bcx.fcx.llargs\n+    };\n+\n+    for bindings_map.each_value |&binding_info| {\n         let llval = match binding_info.trmode {\n             // By value bindings: use the stack slot that we\n             // copied/moved the value into\n@@ -1193,8 +1198,10 @@ pub fn insert_lllocals(bcx: block,\n             }\n         };\n \n-        bcx.fcx.lllocals.insert(binding_info.id,\n-                                local_mem(llval));\n+        debug!(\"binding %? to %s\",\n+               binding_info.id,\n+               val_str(bcx.ccx().tn, llval));\n+        llmap.insert(binding_info.id, local_mem(llval));\n     }\n     return bcx;\n }\n@@ -1215,8 +1222,8 @@ pub fn compile_guard(bcx: block,\n \n     let mut bcx = bcx;\n     let mut temp_cleanups = ~[];\n-    bcx = store_non_ref_bindings(bcx, data, Some(&mut temp_cleanups));\n-    bcx = insert_lllocals(bcx, data, false);\n+    bcx = store_non_ref_bindings(bcx, &data.bindings_map, Some(&mut temp_cleanups));\n+    bcx = insert_lllocals(bcx, &data.bindings_map, BindLocal, false);\n \n     let val = unpack_result!(bcx, {\n         do with_scope_result(bcx, guard_expr.info(),\n@@ -1613,6 +1620,42 @@ pub fn trans_match(bcx: block,\n     }\n }\n \n+fn create_bindings_map(bcx: block, pat: @ast::pat) -> BindingsMap {\n+    // Create the bindings map, which is a mapping from each binding name\n+    // to an alloca() that will be the value for that local variable.\n+    // Note that we use the names because each binding will have many ids\n+    // from the various alternatives.\n+    let ccx = bcx.ccx();\n+    let tcx = bcx.tcx();\n+    let mut bindings_map = HashMap::new();\n+    do pat_bindings(tcx.def_map, pat) |bm, p_id, _s, path| {\n+        let ident = path_to_ident(path);\n+        let variable_ty = node_id_type(bcx, p_id);\n+        let llvariable_ty = type_of::type_of(ccx, variable_ty);\n+\n+        let llmatch, trmode;\n+        match bm {\n+            ast::bind_by_copy | ast::bind_infer => {\n+                // in this case, the final type of the variable will be T,\n+                // but during matching we need to store a *T as explained\n+                // above\n+                let is_move = ccx.maps.moves_map.contains(&p_id);\n+                llmatch = alloca(bcx, T_ptr(llvariable_ty));\n+                trmode = TrByValue(is_move, alloca(bcx, llvariable_ty));\n+            }\n+            ast::bind_by_ref(_) => {\n+                llmatch = alloca(bcx, llvariable_ty);\n+                trmode = TrByRef;\n+            }\n+        };\n+        bindings_map.insert(ident, BindingInfo {\n+            llmatch: llmatch, trmode: trmode,\n+            id: p_id, ty: variable_ty\n+        });\n+    }\n+    return bindings_map;\n+}\n+\n pub fn trans_match_inner(scope_cx: block,\n                          discr_expr: @ast::expr,\n                          arms: &[ast::arm],\n@@ -1629,41 +1672,9 @@ pub fn trans_match_inner(scope_cx: block,\n     }\n \n     let mut arm_datas = ~[], matches = ~[];\n-    for arms.each |arm| {\n-        let body = scope_block(bcx, arm.body.info(), \"case_body\");\n-\n-        // Create the bindings map, which is a mapping from each binding name\n-        // to an alloca() that will be the value for that local variable.\n-        // Note that we use the names because each binding will have many ids\n-        // from the various alternatives.\n-        let mut bindings_map = HashMap::new();\n-        do pat_bindings(tcx.def_map, arm.pats[0]) |bm, p_id, _s, path| {\n-            let ident = path_to_ident(path);\n-            let variable_ty = node_id_type(bcx, p_id);\n-            let llvariable_ty = type_of::type_of(bcx.ccx(), variable_ty);\n-\n-            let llmatch, trmode;\n-            match bm {\n-                ast::bind_by_copy | ast::bind_infer => {\n-                    // in this case, the final type of the variable will be T,\n-                    // but during matching we need to store a *T as explained\n-                    // above\n-                    let is_move =\n-                        scope_cx.ccx().maps.moves_map.contains(&p_id);\n-                    llmatch = alloca(bcx, T_ptr(llvariable_ty));\n-                    trmode = TrByValue(is_move, alloca(bcx, llvariable_ty));\n-                }\n-                ast::bind_by_ref(_) => {\n-                    llmatch = alloca(bcx, llvariable_ty);\n-                    trmode = TrByRef;\n-                }\n-            };\n-            bindings_map.insert(ident, BindingInfo {\n-                llmatch: llmatch, trmode: trmode,\n-                id: p_id, ty: variable_ty\n-            });\n-        }\n-\n+    for vec::each(arms) |arm| {\n+        let body = scope_block(bcx, arm.body.info(), ~\"case_body\");\n+        let bindings_map = create_bindings_map(bcx, arm.pats[0]);\n         let arm_data = @ArmData {bodycx: body,\n                                  arm: arm,\n                                  bindings_map: bindings_map};\n@@ -1697,11 +1708,11 @@ pub fn trans_match_inner(scope_cx: block,\n         // is just to reduce code space.  See extensive comment at the start\n         // of the file for more details.\n         if arm_data.arm.guard.is_none() {\n-            bcx = store_non_ref_bindings(bcx, *arm_data, None);\n+            bcx = store_non_ref_bindings(bcx, &arm_data.bindings_map, None);\n         }\n \n         // insert bindings into the lllocals map and add cleanups\n-        bcx = insert_lllocals(bcx, *arm_data, true);\n+        bcx = insert_lllocals(bcx, &arm_data.bindings_map, BindLocal, true);\n \n         bcx = controlflow::trans_block(bcx, &arm_data.arm.body, dest);\n         bcx = trans_block_cleanups(bcx, block_cleanups(arm_data.bodycx));"}]}