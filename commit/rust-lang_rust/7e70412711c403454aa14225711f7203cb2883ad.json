{"sha": "7e70412711c403454aa14225711f7203cb2883ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlNzA0MTI3MTFjNDAzNDU0YWExNDIyNTcxMWY3MjAzY2IyODgzYWQ=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-05-23T21:12:40Z"}, "committer": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-05-24T23:48:44Z"}, "message": "Some refactoring and WIP on issue #2263.", "tree": {"sha": "8f5f878962ce71d463f433fb7cc4c75931f4fd4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f5f878962ce71d463f433fb7cc4c75931f4fd4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e70412711c403454aa14225711f7203cb2883ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e70412711c403454aa14225711f7203cb2883ad", "html_url": "https://github.com/rust-lang/rust/commit/7e70412711c403454aa14225711f7203cb2883ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e70412711c403454aa14225711f7203cb2883ad/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef33c5c9bcd1d0e4f5d08a931fa1d8034345ea07", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef33c5c9bcd1d0e4f5d08a931fa1d8034345ea07", "html_url": "https://github.com/rust-lang/rust/commit/ef33c5c9bcd1d0e4f5d08a931fa1d8034345ea07"}], "stats": {"total": 178, "additions": 120, "deletions": 58}, "files": [{"sha": "33a5808639f2cce2c5bce3f6e23613d5ba1b0d27", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e70412711c403454aa14225711f7203cb2883ad/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e70412711c403454aa14225711f7203cb2883ad/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=7e70412711c403454aa14225711f7203cb2883ad", "patch": "@@ -81,7 +81,7 @@ export ty_opaque_box, mk_opaque_box;\n export ty_constr_arg;\n export ty_float, mk_float, mk_mach_float, type_is_fp;\n export ty_fn, fn_ty, mk_fn;\n-export ty_fn_proto, ty_fn_ret, ty_fn_ret_style;\n+export ty_fn_proto, ty_fn_ret, ty_fn_ret_style, tys_in_fn_ty;\n export ty_int, mk_int, mk_mach_int, mk_char;\n export ty_str, mk_str, type_is_str;\n export ty_vec, mk_vec, type_is_vec;\n@@ -2090,6 +2090,11 @@ fn is_fn_ty(fty: t) -> bool {\n     }\n }\n \n+// Returns a vec of all the input and output types of fty.\n+fn tys_in_fn_ty(fty: fn_ty) -> [t] {\n+    fty.inputs.map({|a| a.ty}) + [fty.output]\n+}\n+\n // Just checks whether it's a fn that returns bool,\n // not its purity.\n fn is_pred_ty(fty: t) -> bool {"}, {"sha": "072972c871a54efa75ba0cef0c12763a1b5727a5", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7e70412711c403454aa14225711f7203cb2883ad/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e70412711c403454aa14225711f7203cb2883ad/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=7e70412711c403454aa14225711f7203cb2883ad", "patch": "@@ -69,7 +69,8 @@ type parameter).\n import astconv::{ast_conv, ast_ty_to_ty};\n import collect::{methods}; // ccx.to_ty()\n import method::{methods};  // methods for method::lookup\n-import regionmanip::{universally_quantify_regions_before_call,\n+import middle::ty::tys_in_fn_ty;\n+import regionmanip::{universally_quantify_from_sty,\n                      region_of, replace_bound_regions,\n                      collect_bound_regions_in_tys};\n import rscope::*;\n@@ -718,7 +719,31 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         let mut bot = false;\n \n-        let fty = universally_quantify_regions_before_call(fcx, sp, fty);\n+        // Replace all region parameters in the arguments and return\n+        // type with fresh region variables.\n+\n+        #debug[\"check_call_or_bind: before universal quant., fty=%s\",\n+               fcx.ty_to_str(fty)];\n+\n+        // This is subtle: we expect `fty` to be a function type, which\n+        // normally introduce a level of binding.  In this case, we want to\n+        // process the types bound by the function but not by any nested\n+        // functions.  Therefore, we match one level of structure.\n+        let fty =\n+            alt structure_of(fcx, sp, fty) {\n+              sty @ ty::ty_fn(inner_fty) {\n+                let all_tys = tys_in_fn_ty(inner_fty);\n+                universally_quantify_from_sty(fcx, sp, all_tys, sty)\n+              }\n+              sty {\n+                #debug[\"not a fn ty: %?\", sty];\n+\n+                // if not a function type, we're gonna' report an error at\n+                // some point, since the user is trying to call this thing\n+                fty\n+              }\n+            };\n+\n         #debug[\"check_call_or_bind: after universal quant., fty=%s\",\n                fcx.ty_to_str(fty)];\n "}, {"sha": "f3f5a9b60db207b99d7007403a11bf53f73e6655", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e70412711c403454aa14225711f7203cb2883ad/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e70412711c403454aa14225711f7203cb2883ad/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=7e70412711c403454aa14225711f7203cb2883ad", "patch": "@@ -1,7 +1,7 @@\n /* Code to handle method lookups (which can be quite complex) */\n \n import syntax::ast_map;\n-import regionmanip::universally_quantify_regions;\n+import regionmanip::universally_quantify_from_sty;\n import middle::typeck::infer::{ty_and_region_var_methods};\n \n enum lookup = {\n@@ -188,13 +188,12 @@ impl methods for lookup {\n \n                     // Here \"self\" refers to the callee side...\n                     let self_ty =\n-                        universally_quantify_regions(\n-                            self.fcx, self.expr.span, self_ty);\n+                        universally_quantify_from_sty(\n+                            self.fcx, self.expr.span, [self_ty],\n+                            ty::get(self_ty).struct);\n \n                     // ... and \"ty\" refers to the caller side.\n-                    let ty =\n-                        universally_quantify_regions(\n-                            self.fcx, self.expr.span, self.self_ty);\n+                    let ty = self.self_ty;\n \n                     // if we can assign the caller to the callee, that's a\n                     // potential match.  Collect those in the vector."}, {"sha": "3b7096c3d5420d86d77a9af49283631a87781cc9", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 4, "deletions": 42, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7e70412711c403454aa14225711f7203cb2883ad/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e70412711c403454aa14225711f7203cb2883ad/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=7e70412711c403454aa14225711f7203cb2883ad", "patch": "@@ -1,11 +1,11 @@\n-import middle::typeck::infer::{ty_and_region_var_methods};\n import syntax::print::pprust::{expr_to_str};\n \n // Helper functions related to manipulating region types.\n \n-// Helper for the other universally_quantify_*() routines.  Extracts the bound\n-// regions from bound_tys and then replaces those same regions with fresh\n-// variables in `sty`, returning the resulting type.\n+// Extracts the bound regions from bound_tys and then replaces those same\n+// regions in `sty` with fresh region variables, returning the resulting type.\n+// Does not descend into fn types.  This is used when deciding whether an impl\n+// applies at a given call site.  See also universally_quantify_before_call().\n fn universally_quantify_from_sty(fcx: @fn_ctxt,\n                                  span: span,\n                                  bound_tys: [ty::t],\n@@ -30,44 +30,6 @@ fn universally_quantify_from_sty(fcx: @fn_ctxt,\n     }\n }\n \n-// Replaces all region parameters in the given type with region variables.\n-// Does not descend into fn types.  This is used when deciding whether an impl\n-// applies at a given call site.  See also universally_quantify_before_call().\n-fn universally_quantify_regions(fcx: @fn_ctxt,\n-                                span: span,\n-                                ty: ty::t) -> ty::t {\n-    universally_quantify_from_sty(fcx, span, [ty], ty::get(ty).struct)\n-}\n-\n-// Expects a function type.  Replaces all region parameters in the arguments\n-// and return type with fresh region variables. This is used when typechecking\n-// function calls, bind expressions, and method calls.\n-fn universally_quantify_regions_before_call(fcx: @fn_ctxt,\n-                                            span: span,\n-                                            ty: ty::t) -> ty::t {\n-\n-    #debug[\"universally_quantify_before_call(ty=%s)\",\n-           fcx.ty_to_str(ty)];\n-\n-    // This is subtle: we expect `ty` to be a function type, which normally\n-    // introduce a level of binding.  In this case, we want to process the\n-    // types bound by the function but not by any nested functions.\n-    // Therefore, we match one level of structure.\n-    alt structure_of(fcx, span, ty) {\n-      sty @ ty::ty_fn(fty) {\n-        let all_tys = fty.inputs.map({|a| a.ty}) + [fty.output];\n-        universally_quantify_from_sty(fcx, span, all_tys, sty)\n-      }\n-      sty {\n-        #debug[\"not a fn ty: %?\", sty];\n-\n-        // if not a function type, we're gonna' report an error\n-        // at some point, since the user is trying to call this thing\n-        ty\n-      }\n-    }\n-}\n-\n fn replace_bound_regions(\n     tcx: ty::ctxt,\n     span: span,"}, {"sha": "d1e3a4934933d222b561c47ab8db04fff1e1df75", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 78, "deletions": 7, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/7e70412711c403454aa14225711f7203cb2883ad/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e70412711c403454aa14225711f7203cb2883ad/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=7e70412711c403454aa14225711f7203cb2883ad", "patch": "@@ -147,12 +147,14 @@ import std::smallintmap::smallintmap;\n import std::smallintmap::map;\n import std::map::hashmap;\n import middle::ty;\n-import middle::ty::{ty_vid, region_vid, vid};\n-import syntax::ast;\n+import middle::ty::{ty_vid, tys_in_fn_ty, region_vid, vid};\n+import syntax::{ast, ast_util};\n import syntax::ast::{ret_style};\n import util::ppaux::{ty_to_str, mt_to_str};\n import result::{result, extensions, ok, err, map, map2, iter2};\n-import ty::type_is_bot;\n+import ty::{mk_fn, type_is_bot};\n+import check::regionmanip::{collect_bound_regions_in_tys,\n+                            replace_bound_regions};\n import driver::session::session;\n import util::common::{indent, indenter};\n \n@@ -453,6 +455,18 @@ impl ty_and_region_var_methods for infer_ctxt {\n     fn next_region_var() -> ty::region {\n         ret ty::re_var(self.next_region_var_id());\n     }\n+\n+    fn ty_to_str(t: ty::t) -> str {\n+        ty_to_str(self.tcx,\n+                  self.resolve_type_vars_if_possible(t))\n+    }\n+\n+    fn resolve_type_vars_if_possible(typ: ty::t) -> ty::t {\n+        alt infer::resolve_deep(self, typ, false) {\n+          result::ok(new_type) { ret new_type; }\n+          result::err(_) { ret typ; }\n+        }\n+    }\n }\n \n impl unify_methods for infer_ctxt {\n@@ -1579,6 +1593,67 @@ impl of combine for sub {\n         }\n     }\n \n+    fn fns(a: ty::fn_ty, b: ty::fn_ty) -> cres<ty::fn_ty> {\n+        // Rather than checking the subtype relationship between `a` and `b`\n+        // as-is, we need to do some extra work here in order to make sure\n+        // that function subtyping works correctly with respect to regions\n+        // (issue #2263).\n+\n+        // First, we instantiate each bound region in the subtype with a fresh\n+        // region variable.\n+        let a_isr =\n+            collect_bound_regions_in_tys(self.tcx,\n+                                         @nil,\n+                                         tys_in_fn_ty(a)) {\n+            |br|\n+            let rvar = self.infcx().next_region_var();\n+            #debug[\"Bound region %s maps to %s\",\n+                   bound_region_to_str(self.tcx, br),\n+                   region_to_str(self.tcx, rvar)];\n+            rvar\n+        };\n+\n+        let a_ty = replace_bound_regions(self.tcx,\n+                                         ast_util::dummy_sp(),\n+                                         a_isr,\n+                                         mk_fn(self.tcx, a));\n+        #debug[\"a_ty: %s\", self.infcx().ty_to_str(a_ty)];\n+\n+        // Second, we instantiate each bound region in the supertype with a\n+        // fresh concrete region.\n+        let b_isr =\n+            collect_bound_regions_in_tys(self.tcx,\n+                                         @nil,\n+                                         tys_in_fn_ty(b)) {\n+            |br| ty::re_bound(br) };\n+            // FIXME: or maybe re_skolemized? What would that look like?\n+            // (issue #2263)\n+\n+        let b_ty = replace_bound_regions(self.tcx,\n+                                         ast_util::dummy_sp(),\n+                                         b_isr,\n+                                         mk_fn(self.tcx, b));\n+        #debug[\"b_ty: %s\", self.infcx().ty_to_str(b_ty)];\n+\n+        // Turn back into ty::fn_ty.\n+        alt (ty::get(a_ty).struct, ty::get(b_ty).struct) {\n+          (ty::ty_fn(a_fn_ty), ty::ty_fn(b_fn_ty)) {\n+            // Try to compare the supertype and subtype now that they've been\n+            // instantiated.\n+            super_fns(self, a_fn_ty, b_fn_ty)\n+\n+          }\n+          _ {\n+            // Shouldn't happen.\n+            self.infcx().tcx.sess.bug(\n+                #fmt[\"%s: at least one of %s and %s isn't a fn_ty\",\n+                     self.tag(),\n+                     self.infcx().ty_to_str(a_ty),\n+                     self.infcx().ty_to_str(b_ty)]);\n+          }\n+        }\n+    }\n+\n     // Traits please:\n \n     fn flds(a: ty::field, b: ty::field) -> cres<ty::field> {\n@@ -1598,10 +1673,6 @@ impl of combine for sub {\n         super_args(self, a, b)\n     }\n \n-    fn fns(a: ty::fn_ty, b: ty::fn_ty) -> cres<ty::fn_ty> {\n-        super_fns(self, a, b)\n-    }\n-\n     fn substs(as: ty::substs, bs: ty::substs) -> cres<ty::substs> {\n         super_substs(self, as, bs)\n     }"}]}