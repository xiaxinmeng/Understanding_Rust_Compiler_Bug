{"sha": "a2b27c19dad8b90063b56eff7b6433ba3f390d96", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyYjI3YzE5ZGFkOGI5MDA2M2I1NmVmZjdiNjQzM2JhM2YzOTBkOTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-26T07:38:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-26T07:38:19Z"}, "message": "Auto merge of #54497 - ralexstokes:stabilize_pattern_parentheses, r=nikomatsakis\n\nStabilize pattern_parentheses feature\n\nAddresses #51087 .\n\nStabilizes the previously unstable feature `pattern_parentheses` which enables the use of `()` in match patterns.", "tree": {"sha": "e5c2b57922beb88af06a57fff1a4114d5e3443ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5c2b57922beb88af06a57fff1a4114d5e3443ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2b27c19dad8b90063b56eff7b6433ba3f390d96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2b27c19dad8b90063b56eff7b6433ba3f390d96", "html_url": "https://github.com/rust-lang/rust/commit/a2b27c19dad8b90063b56eff7b6433ba3f390d96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2b27c19dad8b90063b56eff7b6433ba3f390d96/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "beff387601fef141e7b6716a6cd50728d079a0c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/beff387601fef141e7b6716a6cd50728d079a0c1", "html_url": "https://github.com/rust-lang/rust/commit/beff387601fef141e7b6716a6cd50728d079a0c1"}, {"sha": "a3818685e412435d6faecfcf9b016b4eb7627e90", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3818685e412435d6faecfcf9b016b4eb7627e90", "html_url": "https://github.com/rust-lang/rust/commit/a3818685e412435d6faecfcf9b016b4eb7627e90"}], "stats": {"total": 358, "additions": 197, "deletions": 161}, "files": [{"sha": "cd2efb4c747285f605e351e94a4fef8126ee1d8b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 193, "deletions": 123, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/a2b27c19dad8b90063b56eff7b6433ba3f390d96/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b27c19dad8b90063b56eff7b6433ba3f390d96/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a2b27c19dad8b90063b56eff7b6433ba3f390d96", "patch": "@@ -10,27 +10,27 @@\n \n // The Rust abstract syntax tree.\n \n-pub use self::UnsafeSource::*;\n pub use self::GenericArgs::*;\n+pub use self::UnsafeSource::*;\n pub use symbol::{Ident, Symbol as Name};\n pub use util::parser::ExprPrecedence;\n \n-use syntax_pos::{Span, DUMMY_SP};\n-use source_map::{dummy_spanned, respan, Spanned};\n-use rustc_target::spec::abi::Abi;\n use ext::hygiene::{Mark, SyntaxContext};\n use print::pprust;\n use ptr::P;\n use rustc_data_structures::indexed_vec;\n use rustc_data_structures::indexed_vec::Idx;\n-use symbol::{Symbol, keywords};\n-use ThinVec;\n+use rustc_target::spec::abi::Abi;\n+use source_map::{dummy_spanned, respan, Spanned};\n+use symbol::{keywords, Symbol};\n+use syntax_pos::{Span, DUMMY_SP};\n use tokenstream::{ThinTokenStream, TokenStream};\n+use ThinVec;\n \n-use serialize::{self, Encoder, Decoder};\n-use std::fmt;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n+use serialize::{self, Decoder, Encoder};\n+use std::fmt;\n use std::u32;\n \n pub use rustc_target::abi::FloatTy;\n@@ -54,7 +54,12 @@ pub struct Lifetime {\n \n impl fmt::Debug for Lifetime {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"lifetime({}: {})\", self.id, pprust::lifetime_to_string(self))\n+        write!(\n+            f,\n+            \"lifetime({}: {})\",\n+            self.id,\n+            pprust::lifetime_to_string(self)\n+        )\n     }\n }\n \n@@ -94,7 +99,10 @@ impl Path {\n     // convert a span and an identifier to the corresponding\n     // 1-segment path\n     pub fn from_ident(ident: Ident) -> Path {\n-        Path { segments: vec![PathSegment::from_ident(ident)], span: ident.span }\n+        Path {\n+            segments: vec![PathSegment::from_ident(ident)],\n+            span: ident.span,\n+        }\n     }\n \n     // Make a \"crate root\" segment for this path unless it already has it\n@@ -284,7 +292,7 @@ pub enum TraitBoundModifier {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum GenericBound {\n     Trait(PolyTraitRef, TraitBoundModifier),\n-    Outlives(Lifetime)\n+    Outlives(Lifetime),\n }\n \n impl GenericBound {\n@@ -304,7 +312,7 @@ pub enum GenericParamKind {\n     Lifetime,\n     Type {\n         default: Option<P<Ty>>,\n-    }\n+    },\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -328,7 +336,7 @@ pub struct Generics {\n \n impl Default for Generics {\n     /// Creates an instance of `Generics`.\n-    fn default() ->  Generics {\n+    fn default() -> Generics {\n         Generics {\n             params: Vec::new(),\n             where_clause: WhereClause {\n@@ -458,7 +466,7 @@ pub enum MetaItemKind {\n     /// Name value meta item.\n     ///\n     /// E.g. `feature = \"foo\"` as in `#[feature = \"foo\"]`\n-    NameValue(Lit)\n+    NameValue(Lit),\n }\n \n /// A Block (`{ .. }`).\n@@ -492,14 +500,17 @@ impl Pat {\n     pub(super) fn to_ty(&self) -> Option<P<Ty>> {\n         let node = match &self.node {\n             PatKind::Wild => TyKind::Infer,\n-            PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None) =>\n-                TyKind::Path(None, Path::from_ident(*ident)),\n+            PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None) => {\n+                TyKind::Path(None, Path::from_ident(*ident))\n+            }\n             PatKind::Path(qself, path) => TyKind::Path(qself.clone(), path.clone()),\n             PatKind::Mac(mac) => TyKind::Mac(mac.clone()),\n-            PatKind::Ref(pat, mutbl) =>\n-                pat.to_ty().map(|ty| TyKind::Rptr(None, MutTy { ty, mutbl: *mutbl }))?,\n-            PatKind::Slice(pats, None, _) if pats.len() == 1 =>\n-                pats[0].to_ty().map(TyKind::Slice)?,\n+            PatKind::Ref(pat, mutbl) => pat\n+                .to_ty()\n+                .map(|ty| TyKind::Rptr(None, MutTy { ty, mutbl: *mutbl }))?,\n+            PatKind::Slice(pats, None, _) if pats.len() == 1 => {\n+                pats[0].to_ty().map(TyKind::Slice)?\n+            }\n             PatKind::Tuple(pats, None) => {\n                 let mut tys = Vec::with_capacity(pats.len());\n                 // FIXME(#48994) - could just be collected into an Option<Vec>\n@@ -511,40 +522,39 @@ impl Pat {\n             _ => return None,\n         };\n \n-        Some(P(Ty { node, id: self.id, span: self.span }))\n+        Some(P(Ty {\n+            node,\n+            id: self.id,\n+            span: self.span,\n+        }))\n     }\n \n     pub fn walk<F>(&self, it: &mut F) -> bool\n-        where F: FnMut(&Pat) -> bool\n+    where\n+        F: FnMut(&Pat) -> bool,\n     {\n         if !it(self) {\n             return false;\n         }\n \n         match self.node {\n             PatKind::Ident(_, _, Some(ref p)) => p.walk(it),\n-            PatKind::Struct(_, ref fields, _) => {\n-                fields.iter().all(|field| field.node.pat.walk(it))\n-            }\n+            PatKind::Struct(_, ref fields, _) => fields.iter().all(|field| field.node.pat.walk(it)),\n             PatKind::TupleStruct(_, ref s, _) | PatKind::Tuple(ref s, _) => {\n                 s.iter().all(|p| p.walk(it))\n             }\n-            PatKind::Box(ref s) | PatKind::Ref(ref s, _) | PatKind::Paren(ref s) => {\n-                s.walk(it)\n-            }\n+            PatKind::Box(ref s) | PatKind::Ref(ref s, _) | PatKind::Paren(ref s) => s.walk(it),\n             PatKind::Slice(ref before, ref slice, ref after) => {\n-                before.iter().all(|p| p.walk(it)) &&\n-                slice.iter().all(|p| p.walk(it)) &&\n-                after.iter().all(|p| p.walk(it))\n-            }\n-            PatKind::Wild |\n-            PatKind::Lit(_) |\n-            PatKind::Range(..) |\n-            PatKind::Ident(..) |\n-            PatKind::Path(..) |\n-            PatKind::Mac(_) => {\n-                true\n+                before.iter().all(|p| p.walk(it))\n+                    && slice.iter().all(|p| p.walk(it))\n+                    && after.iter().all(|p| p.walk(it))\n             }\n+            PatKind::Wild\n+            | PatKind::Lit(_)\n+            | PatKind::Range(..)\n+            | PatKind::Ident(..)\n+            | PatKind::Path(..)\n+            | PatKind::Mac(_) => true,\n         }\n     }\n }\n@@ -623,13 +633,15 @@ pub enum PatKind {\n     /// `[a, b, ..i, y, z]` is represented as:\n     ///     `PatKind::Slice(box [a, b], Some(i), box [y, z])`\n     Slice(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n-    /// Parentheses in patters used for grouping, i.e. `(PAT)`.\n+    /// Parentheses in patterns used for grouping, i.e. `(PAT)`.\n     Paren(P<Pat>),\n     /// A macro pattern; pre-expansion\n     Mac(Mac),\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(\n+    Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug, Copy,\n+)]\n pub enum Mutability {\n     Mutable,\n     Immutable,\n@@ -702,25 +714,22 @@ impl BinOpKind {\n     pub fn lazy(&self) -> bool {\n         match *self {\n             BinOpKind::And | BinOpKind::Or => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n \n     pub fn is_shift(&self) -> bool {\n         match *self {\n             BinOpKind::Shl | BinOpKind::Shr => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n \n     pub fn is_comparison(&self) -> bool {\n         use self::BinOpKind::*;\n         match *self {\n-            Eq | Lt | Le | Ne | Gt | Ge =>\n-            true,\n-            And | Or | Add | Sub | Mul | Div | Rem |\n-            BitXor | BitAnd | BitOr | Shl | Shr =>\n-            false,\n+            Eq | Lt | Le | Ne | Gt | Ge => true,\n+            And | Or | Add | Sub | Mul | Div | Rem | BitXor | BitAnd | BitOr | Shl | Shr => false,\n         }\n     }\n \n@@ -772,9 +781,9 @@ impl Stmt {\n     pub fn add_trailing_semicolon(mut self) -> Self {\n         self.node = match self.node {\n             StmtKind::Expr(expr) => StmtKind::Semi(expr),\n-            StmtKind::Mac(mac) => StmtKind::Mac(mac.map(|(mac, _style, attrs)| {\n-                (mac, MacStmtStyle::Semicolon, attrs)\n-            })),\n+            StmtKind::Mac(mac) => {\n+                StmtKind::Mac(mac.map(|(mac, _style, attrs)| (mac, MacStmtStyle::Semicolon, attrs)))\n+            }\n             node => node,\n         };\n         self\n@@ -797,11 +806,15 @@ impl Stmt {\n \n impl fmt::Debug for Stmt {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"stmt({}: {})\", self.id.to_string(), pprust::stmt_to_string(self))\n+        write!(\n+            f,\n+            \"stmt({}: {})\",\n+            self.id.to_string(),\n+            pprust::stmt_to_string(self)\n+        )\n     }\n }\n \n-\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub enum StmtKind {\n     /// A local (let) binding.\n@@ -900,14 +913,13 @@ pub struct AnonConst {\n     pub value: P<Expr>,\n }\n \n-\n /// An expression\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Expr {\n     pub id: NodeId,\n     pub node: ExprKind,\n     pub span: Span,\n-    pub attrs: ThinVec<Attribute>\n+    pub attrs: ThinVec<Attribute>,\n }\n \n impl Expr {\n@@ -937,9 +949,10 @@ impl Expr {\n \n     fn to_bound(&self) -> Option<GenericBound> {\n         match &self.node {\n-            ExprKind::Path(None, path) =>\n-                Some(GenericBound::Trait(PolyTraitRef::new(Vec::new(), path.clone(), self.span),\n-                                         TraitBoundModifier::None)),\n+            ExprKind::Path(None, path) => Some(GenericBound::Trait(\n+                PolyTraitRef::new(Vec::new(), path.clone(), self.span),\n+                TraitBoundModifier::None,\n+            )),\n             _ => None,\n         }\n     }\n@@ -949,26 +962,35 @@ impl Expr {\n             ExprKind::Path(qself, path) => TyKind::Path(qself.clone(), path.clone()),\n             ExprKind::Mac(mac) => TyKind::Mac(mac.clone()),\n             ExprKind::Paren(expr) => expr.to_ty().map(TyKind::Paren)?,\n-            ExprKind::AddrOf(mutbl, expr) =>\n-                expr.to_ty().map(|ty| TyKind::Rptr(None, MutTy { ty, mutbl: *mutbl }))?,\n-            ExprKind::Repeat(expr, expr_len) =>\n-                expr.to_ty().map(|ty| TyKind::Array(ty, expr_len.clone()))?,\n-            ExprKind::Array(exprs) if exprs.len() == 1 =>\n-                exprs[0].to_ty().map(TyKind::Slice)?,\n+            ExprKind::AddrOf(mutbl, expr) => expr\n+                .to_ty()\n+                .map(|ty| TyKind::Rptr(None, MutTy { ty, mutbl: *mutbl }))?,\n+            ExprKind::Repeat(expr, expr_len) => {\n+                expr.to_ty().map(|ty| TyKind::Array(ty, expr_len.clone()))?\n+            }\n+            ExprKind::Array(exprs) if exprs.len() == 1 => exprs[0].to_ty().map(TyKind::Slice)?,\n             ExprKind::Tup(exprs) => {\n-                let tys = exprs.iter().map(|expr| expr.to_ty()).collect::<Option<Vec<_>>>()?;\n+                let tys = exprs\n+                    .iter()\n+                    .map(|expr| expr.to_ty())\n+                    .collect::<Option<Vec<_>>>()?;\n                 TyKind::Tup(tys)\n             }\n-            ExprKind::Binary(binop, lhs, rhs) if binop.node == BinOpKind::Add =>\n+            ExprKind::Binary(binop, lhs, rhs) if binop.node == BinOpKind::Add => {\n                 if let (Some(lhs), Some(rhs)) = (lhs.to_bound(), rhs.to_bound()) {\n                     TyKind::TraitObject(vec![lhs, rhs], TraitObjectSyntax::None)\n                 } else {\n                     return None;\n                 }\n+            }\n             _ => return None,\n         };\n \n-        Some(P(Ty { node, id: self.id, span: self.span }))\n+        Some(P(Ty {\n+            node,\n+            id: self.id,\n+            span: self.span,\n+        }))\n     }\n \n     pub fn precedence(&self) -> ExprPrecedence {\n@@ -1195,7 +1217,7 @@ pub struct QSelf {\n     /// a::b::Trait>::AssociatedItem`; in the case where `position ==\n     /// 0`, this is an empty span.\n     pub path_span: Span,\n-    pub position: usize\n+    pub position: usize,\n }\n \n /// A capture clause\n@@ -1259,7 +1281,7 @@ pub enum StrStyle {\n     /// A raw string, like `r##\"foo\"##`\n     ///\n     /// The value is the number of `#` symbols used.\n-    Raw(u16)\n+    Raw(u16),\n }\n \n /// A literal\n@@ -1307,9 +1329,7 @@ impl LitKind {\n     /// Returns true if this is a numeric literal.\n     pub fn is_numeric(&self) -> bool {\n         match *self {\n-            LitKind::Int(..) |\n-            LitKind::Float(..) |\n-            LitKind::FloatUnsuffixed(..) => true,\n+            LitKind::Int(..) | LitKind::Float(..) | LitKind::FloatUnsuffixed(..) => true,\n             _ => false,\n         }\n     }\n@@ -1319,17 +1339,17 @@ impl LitKind {\n     pub fn is_unsuffixed(&self) -> bool {\n         match *self {\n             // unsuffixed variants\n-            LitKind::Str(..) |\n-            LitKind::ByteStr(..) |\n-            LitKind::Byte(..) |\n-            LitKind::Char(..) |\n-            LitKind::Int(_, LitIntType::Unsuffixed) |\n-            LitKind::FloatUnsuffixed(..) |\n-            LitKind::Bool(..) => true,\n+            LitKind::Str(..)\n+            | LitKind::ByteStr(..)\n+            | LitKind::Byte(..)\n+            | LitKind::Char(..)\n+            | LitKind::Int(_, LitIntType::Unsuffixed)\n+            | LitKind::FloatUnsuffixed(..)\n+            | LitKind::Bool(..) => true,\n             // suffixed variants\n-            LitKind::Int(_, LitIntType::Signed(..)) |\n-            LitKind::Int(_, LitIntType::Unsigned(..)) |\n-            LitKind::Float(..) => false,\n+            LitKind::Int(_, LitIntType::Signed(..))\n+            | LitKind::Int(_, LitIntType::Unsigned(..))\n+            | LitKind::Float(..) => false,\n         }\n     }\n \n@@ -1532,7 +1552,7 @@ pub struct BareFnTy {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n     pub generic_params: Vec<GenericParam>,\n-    pub decl: P<FnDecl>\n+    pub decl: P<FnDecl>,\n }\n \n /// The different kinds of types recognized by the compiler\n@@ -1551,7 +1571,7 @@ pub enum TyKind {\n     /// The never type (`!`)\n     Never,\n     /// A tuple (`(A, B, C, D,...)`)\n-    Tup(Vec<P<Ty>> ),\n+    Tup(Vec<P<Ty>>),\n     /// A path (`module::module::...::Type`), optionally\n     /// \"qualified\", e.g. `<Vec<T> as SomeTrait>::SomeType`.\n     ///\n@@ -1584,11 +1604,19 @@ pub enum TyKind {\n \n impl TyKind {\n     pub fn is_implicit_self(&self) -> bool {\n-        if let TyKind::ImplicitSelf = *self { true } else { false }\n+        if let TyKind::ImplicitSelf = *self {\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n     pub fn is_unit(&self) -> bool {\n-        if let TyKind::Tup(ref tys) = *self { tys.is_empty() } else { false }\n+        if let TyKind::Tup(ref tys) = *self {\n+            tys.is_empty()\n+        } else {\n+            false\n+        }\n     }\n }\n \n@@ -1666,12 +1694,14 @@ impl Arg {\n             if ident.name == keywords::SelfValue.name() {\n                 return match self.ty.node {\n                     TyKind::ImplicitSelf => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n-                    TyKind::Rptr(lt, MutTy{ref ty, mutbl}) if ty.node.is_implicit_self() => {\n+                    TyKind::Rptr(lt, MutTy { ref ty, mutbl }) if ty.node.is_implicit_self() => {\n                         Some(respan(self.pat.span, SelfKind::Region(lt, mutbl)))\n                     }\n-                    _ => Some(respan(self.pat.span.to(self.ty.span),\n-                                     SelfKind::Explicit(self.ty.clone(), mutbl))),\n-                }\n+                    _ => Some(respan(\n+                        self.pat.span.to(self.ty.span),\n+                        SelfKind::Explicit(self.ty.clone(), mutbl),\n+                    )),\n+                };\n             }\n         }\n         None\n@@ -1704,11 +1734,20 @@ impl Arg {\n         match eself.node {\n             SelfKind::Explicit(ty, mutbl) => arg(mutbl, ty),\n             SelfKind::Value(mutbl) => arg(mutbl, infer_ty),\n-            SelfKind::Region(lt, mutbl) => arg(Mutability::Immutable, P(Ty {\n-                id: DUMMY_NODE_ID,\n-                node: TyKind::Rptr(lt, MutTy { ty: infer_ty, mutbl: mutbl }),\n-                span,\n-            })),\n+            SelfKind::Region(lt, mutbl) => arg(\n+                Mutability::Immutable,\n+                P(Ty {\n+                    id: DUMMY_NODE_ID,\n+                    node: TyKind::Rptr(\n+                        lt,\n+                        MutTy {\n+                            ty: infer_ty,\n+                            mutbl: mutbl,\n+                        },\n+                    ),\n+                    span,\n+                }),\n+            ),\n         }\n     }\n }\n@@ -1720,7 +1759,7 @@ impl Arg {\n pub struct FnDecl {\n     pub inputs: Vec<Arg>,\n     pub output: FunctionRetTy,\n-    pub variadic: bool\n+    pub variadic: bool,\n }\n \n impl FnDecl {\n@@ -1736,7 +1775,7 @@ impl FnDecl {\n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n pub enum IsAuto {\n     Yes,\n-    No\n+    No,\n }\n \n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n@@ -1765,7 +1804,10 @@ impl IsAsync {\n     /// In case this is an `Async` return the `NodeId` for the generated impl Trait item\n     pub fn opt_return_id(self) -> Option<NodeId> {\n         match self {\n-            IsAsync::Async { return_impl_trait_id, .. } => Some(return_impl_trait_id),\n+            IsAsync::Async {\n+                return_impl_trait_id,\n+                ..\n+            } => Some(return_impl_trait_id),\n             IsAsync::NotAsync => None,\n         }\n     }\n@@ -1785,10 +1827,13 @@ pub enum Defaultness {\n \n impl fmt::Display for Unsafety {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(match *self {\n-            Unsafety::Normal => \"normal\",\n-            Unsafety::Unsafe => \"unsafe\",\n-        }, f)\n+        fmt::Display::fmt(\n+            match *self {\n+                Unsafety::Normal => \"normal\",\n+                Unsafety::Unsafe => \"unsafe\",\n+            },\n+            f,\n+        )\n     }\n }\n \n@@ -1809,7 +1854,6 @@ impl fmt::Debug for ImplPolarity {\n     }\n }\n \n-\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum FunctionRetTy {\n     /// Return type is not specified.\n@@ -1904,8 +1948,13 @@ impl UseTree {\n     pub fn ident(&self) -> Ident {\n         match self.kind {\n             UseTreeKind::Simple(Some(rename), ..) => rename,\n-            UseTreeKind::Simple(None, ..) =>\n-                self.prefix.segments.last().expect(\"empty prefix in a simple import\").ident,\n+            UseTreeKind::Simple(None, ..) => {\n+                self.prefix\n+                    .segments\n+                    .last()\n+                    .expect(\"empty prefix in a simple import\")\n+                    .ident\n+            }\n             _ => panic!(\"`UseTree::ident` can only be used on a simple import\"),\n         }\n     }\n@@ -1920,7 +1969,9 @@ pub enum AttrStyle {\n     Inner,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, PartialOrd, Ord, Copy)]\n+#[derive(\n+    Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, PartialOrd, Ord, Copy,\n+)]\n pub struct AttrId(pub usize);\n \n impl Idx for AttrId {\n@@ -1971,7 +2022,10 @@ impl PolyTraitRef {\n     pub fn new(generic_params: Vec<GenericParam>, path: Path, span: Span) -> Self {\n         PolyTraitRef {\n             bound_generic_params: generic_params,\n-            trait_ref: TraitRef { path: path, ref_id: DUMMY_NODE_ID },\n+            trait_ref: TraitRef {\n+                path: path,\n+                ref_id: DUMMY_NODE_ID,\n+            },\n             span,\n         }\n     }\n@@ -1998,7 +2052,11 @@ pub enum VisibilityKind {\n \n impl VisibilityKind {\n     pub fn is_pub(&self) -> bool {\n-        if let VisibilityKind::Public = *self { true } else { false }\n+        if let VisibilityKind::Public = *self {\n+            true\n+        } else {\n+            false\n+        }\n     }\n }\n \n@@ -2051,17 +2109,29 @@ impl VariantData {\n     }\n     pub fn id(&self) -> NodeId {\n         match *self {\n-            VariantData::Struct(_, id) | VariantData::Tuple(_, id) | VariantData::Unit(id) => id\n+            VariantData::Struct(_, id) | VariantData::Tuple(_, id) | VariantData::Unit(id) => id,\n         }\n     }\n     pub fn is_struct(&self) -> bool {\n-        if let VariantData::Struct(..) = *self { true } else { false }\n+        if let VariantData::Struct(..) = *self {\n+            true\n+        } else {\n+            false\n+        }\n     }\n     pub fn is_tuple(&self) -> bool {\n-        if let VariantData::Tuple(..) = *self { true } else { false }\n+        if let VariantData::Tuple(..) = *self {\n+            true\n+        } else {\n+            false\n+        }\n     }\n     pub fn is_unit(&self) -> bool {\n-        if let VariantData::Unit(..) = *self { true } else { false }\n+        if let VariantData::Unit(..) = *self {\n+            true\n+        } else {\n+            false\n+        }\n     }\n }\n \n@@ -2173,13 +2243,15 @@ pub enum ItemKind {\n     /// An implementation.\n     ///\n     /// E.g. `impl<A> Foo<A> { .. }` or `impl<A> Trait for Foo<A> { .. }`\n-    Impl(Unsafety,\n-             ImplPolarity,\n-             Defaultness,\n-             Generics,\n-             Option<TraitRef>, // (optional) trait this impl implements\n-             P<Ty>, // self\n-             Vec<ImplItem>),\n+    Impl(\n+        Unsafety,\n+        ImplPolarity,\n+        Defaultness,\n+        Generics,\n+        Option<TraitRef>, // (optional) trait this impl implements\n+        P<Ty>,            // self\n+        Vec<ImplItem>,\n+    ),\n     /// A macro invocation.\n     ///\n     /// E.g. `macro_rules! foo { .. }` or `foo!(..)`\n@@ -2207,9 +2279,7 @@ impl ItemKind {\n             ItemKind::Union(..) => \"union\",\n             ItemKind::Trait(..) => \"trait\",\n             ItemKind::TraitAlias(..) => \"trait alias\",\n-            ItemKind::Mac(..) |\n-            ItemKind::MacroDef(..) |\n-            ItemKind::Impl(..) => \"item\"\n+            ItemKind::Mac(..) | ItemKind::MacroDef(..) | ItemKind::Impl(..) => \"item\",\n         }\n     }\n }\n@@ -2251,8 +2321,8 @@ impl ForeignItemKind {\n \n #[cfg(test)]\n mod tests {\n-    use serialize;\n     use super::*;\n+    use serialize;\n \n     // are ASTs encodable?\n     #[test]"}, {"sha": "bbadfa01221b9e39a77098f5184138cfebe24859", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a2b27c19dad8b90063b56eff7b6433ba3f390d96/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b27c19dad8b90063b56eff7b6433ba3f390d96/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=a2b27c19dad8b90063b56eff7b6433ba3f390d96", "patch": "@@ -415,9 +415,6 @@ declare_features! (\n     // Multiple patterns with `|` in `if let` and `while let`\n     (active, if_while_or_patterns, \"1.26.0\", Some(48215), None),\n \n-    // Parentheses in patterns\n-    (active, pattern_parentheses, \"1.26.0\", Some(51087), None),\n-\n     // Allows `#[repr(packed)]` attribute on structs\n     (active, repr_packed, \"1.26.0\", Some(33158), None),\n \n@@ -686,6 +683,8 @@ declare_features! (\n     (accepted, extern_absolute_paths, \"1.30.0\", Some(44660), None),\n     // Access to crate names passed via `--extern` through prelude\n     (accepted, extern_prelude, \"1.30.0\", Some(44660), None),\n+    // Parentheses in patterns\n+    (accepted, pattern_parentheses, \"1.31.0\", Some(51087), None),\n );\n \n // If you change this, please modify src/doc/unstable-book as well. You must\n@@ -1791,10 +1790,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, exclusive_range_pattern, pattern.span,\n                                    \"exclusive range pattern syntax is experimental\");\n             }\n-            PatKind::Paren(..) => {\n-                gate_feature_post!(&self, pattern_parentheses, pattern.span,\n-                                   \"parentheses in patterns are unstable\");\n-            }\n             _ => {}\n         }\n         visit::walk_pat(self, pattern)"}, {"sha": "8f54f2e2dc3f965754609866ab8486b388ba5a20", "filename": "src/test/run-pass-fulldeps/ast_stmt_expr_attr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2b27c19dad8b90063b56eff7b6433ba3f390d96/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b27c19dad8b90063b56eff7b6433ba3f390d96/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs?ref=a2b27c19dad8b90063b56eff7b6433ba3f390d96", "patch": "@@ -284,9 +284,7 @@ fn run() {\n     reject_stmt_parse(\"#[attr] #![attr] foo!{}\");\n \n     // FIXME: Allow attributes in pattern constexprs?\n-    // would require parens in patterns to allow disambiguation...\n-    // \u2014which is now available under the `pattern_parentheses` feature gate\n-    // (tracking issue #51087)\n+    // note: requires parens in patterns to allow disambiguation\n \n     reject_expr_parse(\"match 0 {\n         0..=#[attr] 10 => ()"}, {"sha": "29768018f0e447bb8de78c7faa4ac306f5d50e29", "filename": "src/test/ui/feature-gates/feature-gate-pattern_parentheses.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/beff387601fef141e7b6716a6cd50728d079a0c1/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-pattern_parentheses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beff387601fef141e7b6716a6cd50728d079a0c1/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-pattern_parentheses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-pattern_parentheses.rs?ref=beff387601fef141e7b6716a6cd50728d079a0c1", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    match 0 {\n-        (pat) => {} //~ ERROR parentheses in patterns are unstable\n-    }\n-}"}, {"sha": "4268d27ebec991a3d32e90f4950ac91e6b330cc2", "filename": "src/test/ui/feature-gates/feature-gate-pattern_parentheses.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/beff387601fef141e7b6716a6cd50728d079a0c1/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-pattern_parentheses.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/beff387601fef141e7b6716a6cd50728d079a0c1/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-pattern_parentheses.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-pattern_parentheses.stderr?ref=beff387601fef141e7b6716a6cd50728d079a0c1", "patch": "@@ -1,11 +0,0 @@\n-error[E0658]: parentheses in patterns are unstable (see issue #51087)\n-  --> $DIR/feature-gate-pattern_parentheses.rs:13:9\n-   |\n-LL |         (pat) => {} //~ ERROR parentheses in patterns are unstable\n-   |         ^^^^^\n-   |\n-   = help: add #![feature(pattern_parentheses)] to the crate attributes to enable\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "c32b52eac33d1c3e2af6642d53617dd4e9be2624", "filename": "src/test/ui/run-pass/binding/pat-tuple-7.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2b27c19dad8b90063b56eff7b6433ba3f390d96/src%2Ftest%2Fui%2Frun-pass%2Fbinding%2Fpat-tuple-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b27c19dad8b90063b56eff7b6433ba3f390d96/src%2Ftest%2Fui%2Frun-pass%2Fbinding%2Fpat-tuple-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frun-pass%2Fbinding%2Fpat-tuple-7.rs?ref=a2b27c19dad8b90063b56eff7b6433ba3f390d96", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // run-pass\n-#![feature(pattern_parentheses)]\n \n fn main() {\n     match 0 {"}, {"sha": "d492edb16171d0e405573bd0e0c62b347de83622", "filename": "src/test/ui/run-pass/binding/range-inclusive-pattern-precedence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2b27c19dad8b90063b56eff7b6433ba3f390d96/src%2Ftest%2Fui%2Frun-pass%2Fbinding%2Frange-inclusive-pattern-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b27c19dad8b90063b56eff7b6433ba3f390d96/src%2Ftest%2Fui%2Frun-pass%2Fbinding%2Frange-inclusive-pattern-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frun-pass%2Fbinding%2Frange-inclusive-pattern-precedence.rs?ref=a2b27c19dad8b90063b56eff7b6433ba3f390d96", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // run-pass\n-#![feature(box_patterns, pattern_parentheses)]\n+#![feature(box_patterns)]\n \n const VALUE: usize = 21;\n "}]}