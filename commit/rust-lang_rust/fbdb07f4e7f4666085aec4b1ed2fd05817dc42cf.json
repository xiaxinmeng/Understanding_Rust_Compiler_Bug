{"sha": "fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf", "node_id": "C_kwDOAAsO6NoAKGZiZGIwN2Y0ZTdmNDY2NjA4NWFlYzRiMWVkMmZkMDU4MTdkYzQyY2Y", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-08T12:44:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-08T12:44:14Z"}, "message": "Auto merge of #98758 - nnethercote:more-derive-output-improvements, r=Mark-Simulacrum\n\nMore derive output improvements\n\nThis PR includes:\n- Some test improvements.\n- Some cosmetic changes to derive output that make the code look more like what a human would write.\n- Some more fundamental improvements to `cmp` and `partial_cmp` generation.\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "30cf3d42b6fd9da4a7e83598c4b72ee6ab2b6734", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30cf3d42b6fd9da4a7e83598c4b72ee6ab2b6734"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf", "html_url": "https://github.com/rust-lang/rust/commit/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1dcff2d5077244f49687ea25070958f23bd9edc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dcff2d5077244f49687ea25070958f23bd9edc6", "html_url": "https://github.com/rust-lang/rust/commit/1dcff2d5077244f49687ea25070958f23bd9edc6"}, {"sha": "0da063c9916fc3ce1330ac14e28ea7bca002ac89", "url": "https://api.github.com/repos/rust-lang/rust/commits/0da063c9916fc3ce1330ac14e28ea7bca002ac89", "html_url": "https://github.com/rust-lang/rust/commit/0da063c9916fc3ce1330ac14e28ea7bca002ac89"}], "stats": {"total": 1223, "additions": 655, "deletions": 568}, "files": [{"sha": "f705d004422277325ab4c9d1739c93fabd4e4dcc", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf", "patch": "@@ -2036,6 +2036,14 @@ impl TyKind {\n     pub fn is_unit(&self) -> bool {\n         matches!(self, TyKind::Tup(tys) if tys.is_empty())\n     }\n+\n+    pub fn is_simple_path(&self) -> Option<Symbol> {\n+        if let TyKind::Path(None, Path { segments, .. }) = &self && segments.len() == 1 {\n+            Some(segments[0].ident.name)\n+        } else {\n+            None\n+        }\n+    }\n }\n \n /// Syntax used to declare a trait object."}, {"sha": "0a55d4e0ce0a638287fea46d604df06727104de5", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf", "patch": "@@ -2,8 +2,8 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n-use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, Expr, Generics, ItemKind, MetaItem, VariantData};\n+use rustc_ast::{self as ast, Generics, ItemKind, MetaItem, VariantData};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n@@ -98,22 +98,31 @@ fn cs_clone_simple(\n     trait_span: Span,\n     substr: &Substructure<'_>,\n     is_union: bool,\n-) -> P<Expr> {\n+) -> BlockOrExpr {\n     let mut stmts = Vec::new();\n+    let mut seen_type_names = FxHashSet::default();\n     let mut process_variant = |variant: &VariantData| {\n         for field in variant.fields() {\n-            // let _: AssertParamIsClone<FieldTy>;\n-            super::assert_ty_bounds(\n-                cx,\n-                &mut stmts,\n-                field.ty.clone(),\n-                field.span,\n-                &[sym::clone, sym::AssertParamIsClone],\n-            );\n+            // This basic redundancy checking only prevents duplication of\n+            // assertions like `AssertParamIsClone<Foo>` where the type is a\n+            // simple name. That's enough to get a lot of cases, though.\n+            if let Some(name) = field.ty.kind.is_simple_path() && !seen_type_names.insert(name) {\n+                // Already produced an assertion for this type.\n+            } else {\n+                // let _: AssertParamIsClone<FieldTy>;\n+                super::assert_ty_bounds(\n+                    cx,\n+                    &mut stmts,\n+                    field.ty.clone(),\n+                    field.span,\n+                    &[sym::clone, sym::AssertParamIsClone],\n+                );\n+            }\n         }\n     };\n \n     if is_union {\n+        // Just a single assertion for unions, that the union impls `Copy`.\n         // let _: AssertParamIsCopy<Self>;\n         let self_ty = cx.ty_path(cx.path_ident(trait_span, Ident::with_dummy_span(kw::SelfUpper)));\n         super::assert_ty_bounds(\n@@ -139,16 +148,15 @@ fn cs_clone_simple(\n             ),\n         }\n     }\n-    stmts.push(cx.stmt_expr(cx.expr_deref(trait_span, cx.expr_self(trait_span))));\n-    cx.expr_block(cx.block(trait_span, stmts))\n+    BlockOrExpr::new_mixed(stmts, cx.expr_deref(trait_span, cx.expr_self(trait_span)))\n }\n \n fn cs_clone(\n     name: &str,\n     cx: &mut ExtCtxt<'_>,\n     trait_span: Span,\n     substr: &Substructure<'_>,\n-) -> P<Expr> {\n+) -> BlockOrExpr {\n     let ctor_path;\n     let all_fields;\n     let fn_path = cx.std_path(&[sym::clone, sym::Clone, sym::clone]);\n@@ -177,7 +185,7 @@ fn cs_clone(\n         }\n     }\n \n-    match *vdata {\n+    let expr = match *vdata {\n         VariantData::Struct(..) => {\n             let fields = all_fields\n                 .iter()\n@@ -201,5 +209,6 @@ fn cs_clone(\n             cx.expr_call(trait_span, path, subcalls)\n         }\n         VariantData::Unit(..) => cx.expr_path(ctor_path),\n-    }\n+    };\n+    BlockOrExpr::new_expr(expr)\n }"}, {"sha": "c1a2ebcc14601e5d384de4a2ad54be2395f3c590", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf", "patch": "@@ -2,8 +2,8 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n-use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, Expr, MetaItem};\n+use rustc_ast::{self as ast, MetaItem};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -52,18 +52,26 @@ fn cs_total_eq_assert(\n     cx: &mut ExtCtxt<'_>,\n     trait_span: Span,\n     substr: &Substructure<'_>,\n-) -> P<Expr> {\n+) -> BlockOrExpr {\n     let mut stmts = Vec::new();\n+    let mut seen_type_names = FxHashSet::default();\n     let mut process_variant = |variant: &ast::VariantData| {\n         for field in variant.fields() {\n-            // let _: AssertParamIsEq<FieldTy>;\n-            super::assert_ty_bounds(\n-                cx,\n-                &mut stmts,\n-                field.ty.clone(),\n-                field.span,\n-                &[sym::cmp, sym::AssertParamIsEq],\n-            );\n+            // This basic redundancy checking only prevents duplication of\n+            // assertions like `AssertParamIsEq<Foo>` where the type is a\n+            // simple name. That's enough to get a lot of cases, though.\n+            if let Some(name) = field.ty.kind.is_simple_path() && !seen_type_names.insert(name) {\n+                // Already produced an assertion for this type.\n+            } else {\n+                // let _: AssertParamIsEq<FieldTy>;\n+                super::assert_ty_bounds(\n+                    cx,\n+                    &mut stmts,\n+                    field.ty.clone(),\n+                    field.span,\n+                    &[sym::cmp, sym::AssertParamIsEq],\n+                );\n+            }\n         }\n     };\n \n@@ -78,5 +86,5 @@ fn cs_total_eq_assert(\n         }\n         _ => cx.span_bug(trait_span, \"unexpected substructure in `derive(Eq)`\"),\n     }\n-    cx.expr_block(cx.block(trait_span, stmts))\n+    BlockOrExpr::new_stmts(stmts)\n }"}, {"sha": "bec59aac5eee1d13ba4f90eb3eea69423795bf5a", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf", "patch": "@@ -3,7 +3,7 @@ use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, Expr, MetaItem};\n+use rustc_ast::{self as ast, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -51,7 +51,7 @@ pub fn ordering_collapsed(\n     cx.expr_call_global(span, fn_cmp_path, vec![lft, rgt])\n }\n \n-pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n+pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n     let test_id = Ident::new(sym::cmp, span);\n     let equals_path = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n \n@@ -70,7 +70,7 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<\n     // cmp => cmp\n     // }\n     //\n-    cs_fold(\n+    let expr = cs_fold(\n         // foldr nests the if-elses correctly, leaving the first field\n         // as the outermost one, and the last as the innermost.\n         false,\n@@ -79,15 +79,12 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<\n             //     ::std::cmp::Ordering::Equal => old,\n             //     cmp => cmp\n             // }\n-\n             let new = {\n                 let [other_f] = other_fs else {\n                     cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\");\n                 };\n-\n                 let args =\n                     vec![cx.expr_addr_of(span, self_f), cx.expr_addr_of(span, other_f.clone())];\n-\n                 cx.expr_call_global(span, cmp_path.clone(), args)\n             };\n \n@@ -96,7 +93,21 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<\n \n             cx.expr_match(span, new, vec![eq_arm, neq_arm])\n         },\n-        cx.expr_path(equals_path.clone()),\n+        |cx, args| match args {\n+            Some((span, self_f, other_fs)) => {\n+                let new = {\n+                    let [other_f] = other_fs else {\n+                            cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\");\n+                        };\n+                    let args =\n+                        vec![cx.expr_addr_of(span, self_f), cx.expr_addr_of(span, other_f.clone())];\n+                    cx.expr_call_global(span, cmp_path.clone(), args)\n+                };\n+\n+                new\n+            }\n+            None => cx.expr_path(equals_path.clone()),\n+        },\n         Box::new(|cx, span, tag_tuple| {\n             if tag_tuple.len() != 2 {\n                 cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\")\n@@ -107,5 +118,6 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<\n         cx,\n         span,\n         substr,\n-    )\n+    );\n+    BlockOrExpr::new_expr(expr)\n }"}, {"sha": "b44c290d12f567990efef4176040cfa6e5e858d0", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf", "patch": "@@ -15,16 +15,14 @@ pub fn expand_deriving_partial_eq(\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n-    // structures are equal if all fields are equal, and non equal, if\n-    // any fields are not equal or if the enum variants are different\n     fn cs_op(\n         cx: &mut ExtCtxt<'_>,\n         span: Span,\n         substr: &Substructure<'_>,\n         op: BinOpKind,\n         combiner: BinOpKind,\n         base: bool,\n-    ) -> P<Expr> {\n+    ) -> BlockOrExpr {\n         let op = |cx: &mut ExtCtxt<'_>, span: Span, self_f: P<Expr>, other_fs: &[P<Expr>]| {\n             let [other_f] = other_fs else {\n                 cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\");\n@@ -33,7 +31,7 @@ pub fn expand_deriving_partial_eq(\n             cx.expr_binary(span, op, self_f, other_f.clone())\n         };\n \n-        cs_fold1(\n+        let expr = cs_fold(\n             true, // use foldl\n             |cx, span, subexpr, self_f, other_fs| {\n                 let eq = op(cx, span, self_f, other_fs);\n@@ -52,13 +50,14 @@ pub fn expand_deriving_partial_eq(\n             cx,\n             span,\n             substr,\n-        )\n+        );\n+        BlockOrExpr::new_expr(expr)\n     }\n \n-    fn cs_eq(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n+    fn cs_eq(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n         cs_op(cx, span, substr, BinOpKind::Eq, BinOpKind::And, true)\n     }\n-    fn cs_ne(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n+    fn cs_ne(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n         cs_op(cx, span, substr, BinOpKind::Ne, BinOpKind::Or, false)\n     }\n "}, {"sha": "5769f08f494824d7e8d8fa9be4361793a5c9ee82", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf", "patch": "@@ -48,11 +48,10 @@ pub fn expand_deriving_partial_ord(\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n+pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n     let test_id = Ident::new(sym::cmp, span);\n     let ordering = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n     let ordering_expr = cx.expr_path(ordering.clone());\n-    let equals_expr = cx.expr_some(span, ordering_expr);\n \n     let partial_cmp_path = cx.std_path(&[sym::cmp, sym::PartialOrd, sym::partial_cmp]);\n \n@@ -69,7 +68,7 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n     // cmp => cmp\n     // }\n     //\n-    cs_fold(\n+    let expr = cs_fold(\n         // foldr nests the if-elses correctly, leaving the first field\n         // as the outermost one, and the last as the innermost.\n         false,\n@@ -95,7 +94,21 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n \n             cx.expr_match(span, new, vec![eq_arm, neq_arm])\n         },\n-        equals_expr,\n+        |cx: &mut ExtCtxt<'_>, args: Option<(Span, P<Expr>, &[P<Expr>])>| match args {\n+            Some((span, self_f, other_fs)) => {\n+                let new = {\n+                    let [other_f] = other_fs else {\n+                            cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\");\n+                        };\n+                    let args =\n+                        vec![cx.expr_addr_of(span, self_f), cx.expr_addr_of(span, other_f.clone())];\n+                    cx.expr_call_global(span, partial_cmp_path.clone(), args)\n+                };\n+\n+                new\n+            }\n+            None => cx.expr_some(span, ordering_expr.clone()),\n+        },\n         Box::new(|cx, span, tag_tuple| {\n             if tag_tuple.len() != 2 {\n                 cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n@@ -110,5 +123,6 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n         cx,\n         span,\n         substr,\n-    )\n+    );\n+    BlockOrExpr::new_expr(expr)\n }"}, {"sha": "e04898287608b756523f714298de5b43b525d0cd", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf", "patch": "@@ -2,8 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n-use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, Expr, MetaItem};\n+use rustc_ast::{self as ast, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n@@ -42,7 +41,7 @@ pub fn expand_deriving_debug(\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n+fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n     let (ident, vdata, fields) = match substr.fields {\n         Struct(vdata, fields) => (substr.type_ident, *vdata, fields),\n         EnumMatching(_, _, v, fields) => (v.ident, &v.data, fields),\n@@ -74,7 +73,8 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     if fields.is_empty() {\n         // Special case for no fields.\n         let fn_path_write_str = cx.std_path(&[sym::fmt, sym::Formatter, sym::write_str]);\n-        cx.expr_call_global(span, fn_path_write_str, vec![fmt, name])\n+        let expr = cx.expr_call_global(span, fn_path_write_str, vec![fmt, name]);\n+        BlockOrExpr::new_expr(expr)\n     } else if fields.len() <= CUTOFF {\n         // Few enough fields that we can use a specific-length method.\n         let debug = if is_struct {\n@@ -100,7 +100,8 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n             let field = cx.expr_addr_of(field.span, field);\n             args.push(field);\n         }\n-        cx.expr_call_global(span, fn_path_debug, args)\n+        let expr = cx.expr_call_global(span, fn_path_debug, args);\n+        BlockOrExpr::new_expr(expr)\n     } else {\n         // Enough fields that we must use the any-length method.\n         let mut name_exprs = Vec::with_capacity(fields.len());\n@@ -176,8 +177,6 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n             stmts.push(names_let.unwrap());\n         }\n         stmts.push(values_let);\n-        stmts.push(cx.stmt_expr(expr));\n-\n-        cx.expr_block(cx.block(span, stmts))\n+        BlockOrExpr::new_mixed(stmts, expr)\n     }\n }"}, {"sha": "b9f2a75082224a5647b856ca092cc165ea205c30", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf", "patch": "@@ -62,7 +62,7 @@ fn decodable_substructure(\n     trait_span: Span,\n     substr: &Substructure<'_>,\n     krate: Symbol,\n-) -> P<Expr> {\n+) -> BlockOrExpr {\n     let decoder = substr.nonself_args[0].clone();\n     let recurse = vec![\n         Ident::new(krate, trait_span),\n@@ -74,7 +74,7 @@ fn decodable_substructure(\n     let blkarg = Ident::new(sym::_d, trait_span);\n     let blkdecoder = cx.expr_ident(trait_span, blkarg);\n \n-    match *substr.fields {\n+    let expr = match *substr.fields {\n         StaticStruct(_, ref summary) => {\n             let nfields = match *summary {\n                 Unnamed(ref fields, _) => fields.len(),\n@@ -173,7 +173,8 @@ fn decodable_substructure(\n             )\n         }\n         _ => cx.bug(\"expected StaticEnum or StaticStruct in derive(Decodable)\"),\n-    }\n+    };\n+    BlockOrExpr::new_expr(expr)\n }\n \n /// Creates a decoder for a single enum variant/struct:"}, {"sha": "90d5cdbc0a0783ac494e2b7941859875f1734f5b", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf", "patch": "@@ -1,11 +1,10 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n \n-use rustc_ast::ptr::P;\n+use rustc_ast as ast;\n use rustc_ast::walk_list;\n use rustc_ast::EnumDef;\n use rustc_ast::VariantData;\n-use rustc_ast::{Expr, MetaItem};\n use rustc_errors::Applicability;\n use rustc_expand::base::{Annotatable, DummyResult, ExtCtxt};\n use rustc_span::symbol::Ident;\n@@ -16,7 +15,7 @@ use smallvec::SmallVec;\n pub fn expand_deriving_default(\n     cx: &mut ExtCtxt<'_>,\n     span: Span,\n-    mitem: &MetaItem,\n+    mitem: &ast::MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n@@ -59,12 +58,12 @@ fn default_struct_substructure(\n     trait_span: Span,\n     substr: &Substructure<'_>,\n     summary: &StaticFields,\n-) -> P<Expr> {\n+) -> BlockOrExpr {\n     // Note that `kw::Default` is \"default\" and `sym::Default` is \"Default\"!\n     let default_ident = cx.std_path(&[kw::Default, sym::Default, kw::Default]);\n     let default_call = |span| cx.expr_call_global(span, default_ident.clone(), Vec::new());\n \n-    match summary {\n+    let expr = match summary {\n         Unnamed(ref fields, is_tuple) => {\n             if !is_tuple {\n                 cx.expr_ident(trait_span, substr.type_ident)\n@@ -80,31 +79,27 @@ fn default_struct_substructure(\n                 .collect();\n             cx.expr_struct_ident(trait_span, substr.type_ident, default_fields)\n         }\n-    }\n+    };\n+    BlockOrExpr::new_expr(expr)\n }\n \n fn default_enum_substructure(\n     cx: &mut ExtCtxt<'_>,\n     trait_span: Span,\n     enum_def: &EnumDef,\n-) -> P<Expr> {\n-    let Ok(default_variant) = extract_default_variant(cx, enum_def, trait_span) else {\n-        return DummyResult::raw_expr(trait_span, true);\n+) -> BlockOrExpr {\n+    let expr = if let Ok(default_variant) = extract_default_variant(cx, enum_def, trait_span)\n+        && let Ok(_) = validate_default_attribute(cx, default_variant)\n+    {\n+        // We now know there is exactly one unit variant with exactly one `#[default]` attribute.\n+        cx.expr_path(cx.path(\n+            default_variant.span,\n+            vec![Ident::new(kw::SelfUpper, default_variant.span), default_variant.ident],\n+        ))\n+    } else {\n+        DummyResult::raw_expr(trait_span, true)\n     };\n-\n-    // At this point, we know that there is exactly one variant with a `#[default]` attribute. The\n-    // attribute hasn't yet been validated.\n-\n-    if let Err(()) = validate_default_attribute(cx, default_variant) {\n-        return DummyResult::raw_expr(trait_span, true);\n-    }\n-\n-    // We now know there is exactly one unit variant with exactly one `#[default]` attribute.\n-\n-    cx.expr_path(cx.path(\n-        default_variant.span,\n-        vec![Ident::new(kw::SelfUpper, default_variant.span), default_variant.ident],\n-    ))\n+    BlockOrExpr::new_expr(expr)\n }\n \n fn extract_default_variant<'a>("}, {"sha": "0dfce114bfc5399af72a809b64cc3d80721cc0e3", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf", "patch": "@@ -89,8 +89,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::pathvec_std;\n \n-use rustc_ast::ptr::P;\n-use rustc_ast::{Expr, ExprKind, MetaItem, Mutability};\n+use rustc_ast::{ExprKind, MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n@@ -147,7 +146,7 @@ fn encodable_substructure(\n     trait_span: Span,\n     substr: &Substructure<'_>,\n     krate: Symbol,\n-) -> P<Expr> {\n+) -> BlockOrExpr {\n     let encoder = substr.nonself_args[0].clone();\n     // throw an underscore in front to suppress unused variable warnings\n     let blkarg = Ident::new(sym::_e, trait_span);\n@@ -208,7 +207,7 @@ fn encodable_substructure(\n             let fn_emit_struct_path =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Encoder, sym::emit_struct]);\n \n-            cx.expr_call_global(\n+            let expr = cx.expr_call_global(\n                 trait_span,\n                 fn_emit_struct_path,\n                 vec![\n@@ -217,7 +216,8 @@ fn encodable_substructure(\n                     cx.expr_usize(trait_span, fields.len()),\n                     blk,\n                 ],\n-            )\n+            );\n+            BlockOrExpr::new_expr(expr)\n         }\n \n         EnumMatching(idx, _, variant, ref fields) => {\n@@ -279,12 +279,12 @@ fn encodable_substructure(\n             let blk = cx.lambda1(trait_span, call, blkarg);\n             let fn_emit_enum_path: Vec<_> =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Encoder, sym::emit_enum]);\n-            let ret = cx.expr_call_global(\n+            let expr = cx.expr_call_global(\n                 trait_span,\n                 fn_emit_enum_path,\n                 vec![encoder, cx.expr_str(trait_span, substr.type_ident.name), blk],\n             );\n-            cx.expr_block(cx.block(trait_span, vec![me, cx.stmt_expr(ret)]))\n+            BlockOrExpr::new_mixed(vec![me], expr)\n         }\n \n         _ => cx.bug(\"expected Struct or EnumMatching in derive(Encodable)\"),"}, {"sha": "e618255b0c6fd4b0866d4b58a67bb14f1334f4d3", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 101, "deletions": 112, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf", "patch": "@@ -296,7 +296,7 @@ pub enum SubstructureFields<'a> {\n /// Combine the values of all the fields together. The last argument is\n /// all the fields of all the structures.\n pub type CombineSubstructureFunc<'a> =\n-    Box<dyn FnMut(&mut ExtCtxt<'_>, Span, &Substructure<'_>) -> P<Expr> + 'a>;\n+    Box<dyn FnMut(&mut ExtCtxt<'_>, Span, &Substructure<'_>) -> BlockOrExpr + 'a>;\n \n /// Deal with non-matching enum variants. The slice is the identifiers holding\n /// the variant index value for each of the `Self` arguments.\n@@ -314,6 +314,48 @@ struct TypeParameter {\n     ty: P<ast::Ty>,\n }\n \n+// The code snippets built up for derived code are sometimes used as blocks\n+// (e.g. in a function body) and sometimes used as expressions (e.g. in a match\n+// arm). This structure avoids committing to either form until necessary,\n+// avoiding the insertion of any unnecessary blocks.\n+//\n+// The statements come before the expression.\n+pub struct BlockOrExpr(Vec<ast::Stmt>, Option<P<Expr>>);\n+\n+impl BlockOrExpr {\n+    pub fn new_stmts(stmts: Vec<ast::Stmt>) -> BlockOrExpr {\n+        BlockOrExpr(stmts, None)\n+    }\n+\n+    pub fn new_expr(expr: P<Expr>) -> BlockOrExpr {\n+        BlockOrExpr(vec![], Some(expr))\n+    }\n+\n+    pub fn new_mixed(stmts: Vec<ast::Stmt>, expr: P<Expr>) -> BlockOrExpr {\n+        BlockOrExpr(stmts, Some(expr))\n+    }\n+\n+    // Converts it into a block.\n+    fn into_block(mut self, cx: &ExtCtxt<'_>, span: Span) -> P<ast::Block> {\n+        if let Some(expr) = self.1 {\n+            self.0.push(cx.stmt_expr(expr));\n+        }\n+        cx.block(span, self.0)\n+    }\n+\n+    // Converts it into an expression.\n+    fn into_expr(self, cx: &ExtCtxt<'_>, span: Span) -> P<Expr> {\n+        if self.0.is_empty() {\n+            match self.1 {\n+                None => cx.expr_block(cx.block(span, vec![])),\n+                Some(expr) => expr,\n+            }\n+        } else {\n+            cx.expr_block(self.into_block(cx, span))\n+        }\n+    }\n+}\n+\n /// This method helps to extract all the type parameters referenced from a\n /// type. For a type parameter `<T>`, it looks for either a `TyPath` that\n /// is not global and starts with `T`, or a `TyQPath`.\n@@ -827,7 +869,7 @@ impl<'a> MethodDef<'a> {\n         type_ident: Ident,\n         nonself_args: &[P<Expr>],\n         fields: &SubstructureFields<'_>,\n-    ) -> P<Expr> {\n+    ) -> BlockOrExpr {\n         let span = trait_.span;\n         let substructure = Substructure { type_ident, nonself_args, fields };\n         let mut f = self.combine_substructure.borrow_mut();\n@@ -902,7 +944,7 @@ impl<'a> MethodDef<'a> {\n         generics: &Generics,\n         explicit_self: Option<ast::ExplicitSelf>,\n         arg_types: Vec<(Ident, P<ast::Ty>)>,\n-        body: P<Expr>,\n+        body: BlockOrExpr,\n     ) -> P<ast::AssocItem> {\n         let span = trait_.span;\n         // Create the generics that aren't for `Self`.\n@@ -921,7 +963,7 @@ impl<'a> MethodDef<'a> {\n \n         let method_ident = Ident::new(self.name, span);\n         let fn_decl = cx.fn_decl(args, ast::FnRetTy::Ty(ret_type));\n-        let body_block = cx.block_expr(body);\n+        let body_block = body.into_block(cx, span);\n \n         let trait_lo_sp = span.shrink_to_lo();\n \n@@ -986,7 +1028,7 @@ impl<'a> MethodDef<'a> {\n         nonself_args: &[P<Expr>],\n         use_temporaries: bool,\n         is_packed: bool,\n-    ) -> P<Expr> {\n+    ) -> BlockOrExpr {\n         let mut raw_fields = Vec::new(); // Vec<[fields of self], [fields of next Self arg], [etc]>\n         let span = trait_.span;\n         let mut patterns = Vec::new();\n@@ -1047,16 +1089,14 @@ impl<'a> MethodDef<'a> {\n         );\n \n         if !is_packed {\n-            body.span = span;\n             body\n         } else {\n             // Do the let-destructuring.\n             let mut stmts: Vec<_> = iter::zip(self_args, patterns)\n                 .map(|(arg_expr, pat)| cx.stmt_let_pat(span, pat, arg_expr.clone()))\n                 .collect();\n-            stmts.push(cx.stmt_expr(body));\n-\n-            cx.expr_block(cx.block(span, stmts))\n+            stmts.extend(std::mem::take(&mut body.0));\n+            BlockOrExpr(stmts, body.1)\n         }\n     }\n \n@@ -1067,7 +1107,7 @@ impl<'a> MethodDef<'a> {\n         struct_def: &VariantData,\n         type_ident: Ident,\n         nonself_args: &[P<Expr>],\n-    ) -> P<Expr> {\n+    ) -> BlockOrExpr {\n         let summary = trait_.summarise_struct(cx, struct_def);\n \n         self.call_substructure_method(\n@@ -1130,7 +1170,7 @@ impl<'a> MethodDef<'a> {\n         type_ident: Ident,\n         mut self_args: Vec<P<Expr>>,\n         nonself_args: &[P<Expr>],\n-    ) -> P<Expr> {\n+    ) -> BlockOrExpr {\n         let span = trait_.span;\n         let variants = &enum_def.variants;\n \n@@ -1199,7 +1239,11 @@ impl<'a> MethodDef<'a> {\n                 }\n \n                 // Here is the pat = `(&VariantK, &VariantK, ...)`\n-                let single_pat = cx.pat_tuple(span, subpats);\n+                let single_pat = if subpats.len() == 1 {\n+                    subpats.pop().unwrap()\n+                } else {\n+                    cx.pat_tuple(span, subpats)\n+                };\n \n                 // For the BodyK, we need to delegate to our caller,\n                 // passing it an EnumMatching to indicate which case\n@@ -1253,13 +1297,9 @@ impl<'a> MethodDef<'a> {\n                 // Self arg, assuming all are instances of VariantK.\n                 // Build up code associated with such a case.\n                 let substructure = EnumMatching(index, variants.len(), variant, field_tuples);\n-                let arm_expr = self.call_substructure_method(\n-                    cx,\n-                    trait_,\n-                    type_ident,\n-                    nonself_args,\n-                    &substructure,\n-                );\n+                let arm_expr = self\n+                    .call_substructure_method(cx, trait_, type_ident, nonself_args, &substructure)\n+                    .into_expr(cx, span);\n \n                 cx.arm(span, single_pat, arm_expr)\n             })\n@@ -1271,13 +1311,16 @@ impl<'a> MethodDef<'a> {\n                 // The index and actual variant aren't meaningful in this case,\n                 // so just use whatever\n                 let substructure = EnumMatching(0, variants.len(), v, Vec::new());\n-                Some(self.call_substructure_method(\n-                    cx,\n-                    trait_,\n-                    type_ident,\n-                    nonself_args,\n-                    &substructure,\n-                ))\n+                Some(\n+                    self.call_substructure_method(\n+                        cx,\n+                        trait_,\n+                        type_ident,\n+                        nonself_args,\n+                        &substructure,\n+                    )\n+                    .into_expr(cx, span),\n+                )\n             }\n             _ if variants.len() > 1 && self_args.len() > 1 => {\n                 // Since we know that all the arguments will match if we reach\n@@ -1341,13 +1384,15 @@ impl<'a> MethodDef<'a> {\n                 }\n             }\n \n-            let arm_expr = self.call_substructure_method(\n-                cx,\n-                trait_,\n-                type_ident,\n-                nonself_args,\n-                &catch_all_substructure,\n-            );\n+            let arm_expr = self\n+                .call_substructure_method(\n+                    cx,\n+                    trait_,\n+                    type_ident,\n+                    nonself_args,\n+                    &catch_all_substructure,\n+                )\n+                .into_expr(cx, span);\n \n             // Final wrinkle: the self_args are expressions that deref\n             // down to desired places, but we cannot actually deref\n@@ -1371,8 +1416,7 @@ impl<'a> MethodDef<'a> {\n             //  }\n             let all_match = cx.expr_match(span, match_arg, match_arms);\n             let arm_expr = cx.expr_if(span, discriminant_test, all_match, Some(arm_expr));\n-            index_let_stmts.push(cx.stmt_expr(arm_expr));\n-            cx.expr_block(cx.block(span, index_let_stmts))\n+            BlockOrExpr(index_let_stmts, Some(arm_expr))\n         } else if variants.is_empty() {\n             // As an additional wrinkle, For a zero-variant enum A,\n             // currently the compiler\n@@ -1423,16 +1467,20 @@ impl<'a> MethodDef<'a> {\n             // derive Debug on such a type could here generate code\n             // that needs the feature gate enabled.)\n \n-            deriving::call_unreachable(cx, span)\n+            BlockOrExpr(vec![], Some(deriving::call_unreachable(cx, span)))\n         } else {\n             // Final wrinkle: the self_args are expressions that deref\n             // down to desired places, but we cannot actually deref\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n             self_args.map_in_place(|self_arg| cx.expr_addr_of(span, self_arg));\n-            let match_arg = cx.expr(span, ast::ExprKind::Tup(self_args));\n-            cx.expr_match(span, match_arg, match_arms)\n+            let match_arg = if self_args.len() == 1 {\n+                self_args.pop().unwrap()\n+            } else {\n+                cx.expr(span, ast::ExprKind::Tup(self_args))\n+            };\n+            BlockOrExpr(vec![], Some(cx.expr_match(span, match_arg, match_arms)))\n         }\n     }\n \n@@ -1443,7 +1491,7 @@ impl<'a> MethodDef<'a> {\n         enum_def: &EnumDef,\n         type_ident: Ident,\n         nonself_args: &[P<Expr>],\n-    ) -> P<Expr> {\n+    ) -> BlockOrExpr {\n         let summary = enum_def\n             .variants\n             .iter()\n@@ -1606,71 +1654,6 @@ impl<'a> TraitDef<'a> {\n     }\n }\n \n-// helpful premade recipes\n-\n-fn cs_fold_fields<'a, F>(\n-    use_foldl: bool,\n-    mut f: F,\n-    base: P<Expr>,\n-    cx: &mut ExtCtxt<'_>,\n-    all_fields: &[FieldInfo<'a>],\n-) -> P<Expr>\n-where\n-    F: FnMut(&mut ExtCtxt<'_>, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>,\n-{\n-    if use_foldl {\n-        all_fields\n-            .iter()\n-            .fold(base, |old, field| f(cx, field.span, old, field.self_.clone(), &field.other))\n-    } else {\n-        all_fields\n-            .iter()\n-            .rev()\n-            .fold(base, |old, field| f(cx, field.span, old, field.self_.clone(), &field.other))\n-    }\n-}\n-\n-fn cs_fold_enumnonmatch(\n-    mut enum_nonmatch_f: EnumNonMatchCollapsedFunc<'_>,\n-    cx: &mut ExtCtxt<'_>,\n-    trait_span: Span,\n-    substructure: &Substructure<'_>,\n-) -> P<Expr> {\n-    match *substructure.fields {\n-        EnumNonMatchingCollapsed(tuple) => enum_nonmatch_f(cx, trait_span, tuple),\n-        _ => cx.span_bug(trait_span, \"cs_fold_enumnonmatch expected an EnumNonMatchingCollapsed\"),\n-    }\n-}\n-\n-fn cs_fold_static(cx: &mut ExtCtxt<'_>, trait_span: Span) -> P<Expr> {\n-    cx.span_bug(trait_span, \"static function in `derive`\")\n-}\n-\n-/// Fold the fields. `use_foldl` controls whether this is done\n-/// left-to-right (`true`) or right-to-left (`false`).\n-pub fn cs_fold<F>(\n-    use_foldl: bool,\n-    f: F,\n-    base: P<Expr>,\n-    enum_nonmatch_f: EnumNonMatchCollapsedFunc<'_>,\n-    cx: &mut ExtCtxt<'_>,\n-    trait_span: Span,\n-    substructure: &Substructure<'_>,\n-) -> P<Expr>\n-where\n-    F: FnMut(&mut ExtCtxt<'_>, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>,\n-{\n-    match *substructure.fields {\n-        EnumMatching(.., ref all_fields) | Struct(_, ref all_fields) => {\n-            cs_fold_fields(use_foldl, f, base, cx, all_fields)\n-        }\n-        EnumNonMatchingCollapsed(..) => {\n-            cs_fold_enumnonmatch(enum_nonmatch_f, cx, trait_span, substructure)\n-        }\n-        StaticEnum(..) | StaticStruct(..) => cs_fold_static(cx, trait_span),\n-    }\n-}\n-\n /// Function to fold over fields, with three cases, to generate more efficient and concise code.\n /// When the `substructure` has grouped fields, there are two cases:\n /// Zero fields: call the base case function with `None` (like the usual base case of `cs_fold`).\n@@ -1679,11 +1662,11 @@ where\n /// fields.\n /// When the `substructure` is an `EnumNonMatchingCollapsed`, the result of `enum_nonmatch_f`\n /// is returned. Statics may not be folded over.\n-pub fn cs_fold1<F, B>(\n+pub fn cs_fold<F, B>(\n     use_foldl: bool,\n-    f: F,\n+    mut f: F,\n     mut b: B,\n-    enum_nonmatch_f: EnumNonMatchCollapsedFunc<'_>,\n+    mut enum_nonmatch_f: EnumNonMatchCollapsedFunc<'_>,\n     cx: &mut ExtCtxt<'_>,\n     trait_span: Span,\n     substructure: &Substructure<'_>,\n@@ -1708,12 +1691,18 @@ where\n                 (true, _) => (b(cx, None), &all_fields[..]),\n             };\n \n-            cs_fold_fields(use_foldl, f, base, cx, rest)\n-        }\n-        EnumNonMatchingCollapsed(..) => {\n-            cs_fold_enumnonmatch(enum_nonmatch_f, cx, trait_span, substructure)\n+            if use_foldl {\n+                rest.iter().fold(base, |old, field| {\n+                    f(cx, field.span, old, field.self_.clone(), &field.other)\n+                })\n+            } else {\n+                rest.iter().rev().fold(base, |old, field| {\n+                    f(cx, field.span, old, field.self_.clone(), &field.other)\n+                })\n+            }\n         }\n-        StaticEnum(..) | StaticStruct(..) => cs_fold_static(cx, trait_span),\n+        EnumNonMatchingCollapsed(tuple) => enum_nonmatch_f(cx, trait_span, tuple),\n+        StaticEnum(..) | StaticStruct(..) => cx.span_bug(trait_span, \"static function in `derive`\"),\n     }\n }\n "}, {"sha": "c3f7d09886b3a23681dc8e6f5e2f7bee1a5370d9", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf", "patch": "@@ -2,8 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{self, path_std, pathvec_std};\n \n-use rustc_ast::ptr::P;\n-use rustc_ast::{Expr, MetaItem, Mutability};\n+use rustc_ast::{MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -45,7 +44,11 @@ pub fn expand_deriving_hash(\n     hash_trait_def.expand(cx, mitem, item, push);\n }\n \n-fn hash_substructure(cx: &mut ExtCtxt<'_>, trait_span: Span, substr: &Substructure<'_>) -> P<Expr> {\n+fn hash_substructure(\n+    cx: &mut ExtCtxt<'_>,\n+    trait_span: Span,\n+    substr: &Substructure<'_>,\n+) -> BlockOrExpr {\n     let [state_expr] = substr.nonself_args else {\n         cx.span_bug(trait_span, \"incorrect number of arguments in `derive(Hash)`\");\n     };\n@@ -81,6 +84,5 @@ fn hash_substructure(cx: &mut ExtCtxt<'_>, trait_span: Span, substr: &Substructu\n     stmts.extend(\n         fields.iter().map(|FieldInfo { ref self_, span, .. }| call_hash(*span, self_.clone())),\n     );\n-\n-    cx.expr_block(cx.block(trait_span, stmts))\n+    BlockOrExpr::new_stmts(stmts)\n }"}, {"sha": "260d9de867087696af0675fb36d1dab22c2aa68c", "filename": "src/test/codegen/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/src%2Ftest%2Fcodegen%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/src%2Ftest%2Fcodegen%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fconsts.rs?ref=fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf", "patch": "@@ -10,7 +10,7 @@\n // CHECK: @STATIC = {{.*}}, align 4\n \n // This checks the constants from inline_enum_const\n-// CHECK: @alloc14 = {{.*}}, align 2\n+// CHECK: @alloc12 = {{.*}}, align 2\n \n // This checks the constants from {low,high}_align_const, they share the same\n // constant, but the alignment differs, so the higher one should be used"}, {"sha": "1a651b2074c59ee1292a03e2a74f51566b250a0d", "filename": "src/test/ui/deriving/deriving-all-codegen.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.rs?ref=fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf", "patch": "@@ -39,6 +39,16 @@ struct Big {\n #[repr(packed)]\n struct Packed(u32);\n \n+// An empty enum.\n+#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+enum Enum0 {}\n+\n+// A single-variant enum.\n+#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+enum Enum1 {\n+    Single { x: u32 }\n+}\n+\n // A C-like, fieldless enum.\n #[derive(Clone, Copy, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n enum Fieldless {\n@@ -66,3 +76,11 @@ enum Fielded {\n     Y(bool),\n     Z(Option<i32>),\n }\n+\n+// A union. Most builtin traits are not derivable for unions.\n+#[derive(Clone, Copy)]\n+pub union Union {\n+    pub b: bool,\n+    pub u: u32,\n+    pub i: i32,\n+}"}, {"sha": "9b10192d75a132b8bd550b9d26ec1c5547a39a6d", "filename": "src/test/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 394, "deletions": 361, "changes": 755, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=fbdb07f4e7f4666085aec4b1ed2fd05817dc42cf", "patch": "@@ -28,7 +28,7 @@ struct Empty;\n #[allow(unused_qualifications)]\n impl ::core::clone::Clone for Empty {\n     #[inline]\n-    fn clone(&self) -> Empty { { *self } }\n+    fn clone(&self) -> Empty { *self }\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n@@ -49,7 +49,7 @@ impl ::core::default::Default for Empty {\n #[automatically_derived]\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Empty {\n-    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () { {} }\n+    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}\n }\n impl ::core::marker::StructuralPartialEq for Empty {}\n #[automatically_derived]\n@@ -65,7 +65,7 @@ impl ::core::cmp::Eq for Empty {\n     #[inline]\n     #[doc(hidden)]\n     #[no_coverage]\n-    fn assert_receiver_is_total_eq(&self) -> () { {} }\n+    fn assert_receiver_is_total_eq(&self) -> () {}\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n@@ -95,11 +95,8 @@ struct Point {\n impl ::core::clone::Clone for Point {\n     #[inline]\n     fn clone(&self) -> Point {\n-        {\n-            let _: ::core::clone::AssertParamIsClone<u32>;\n-            let _: ::core::clone::AssertParamIsClone<u32>;\n-            *self\n-        }\n+        let _: ::core::clone::AssertParamIsClone<u32>;\n+        *self\n     }\n }\n #[automatically_derived]\n@@ -128,10 +125,8 @@ impl ::core::default::Default for Point {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Point {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        {\n-            ::core::hash::Hash::hash(&self.x, state);\n-            ::core::hash::Hash::hash(&self.y, state)\n-        }\n+        ::core::hash::Hash::hash(&self.x, state);\n+        ::core::hash::Hash::hash(&self.y, state)\n     }\n }\n impl ::core::marker::StructuralPartialEq for Point {}\n@@ -155,10 +150,7 @@ impl ::core::cmp::Eq for Point {\n     #[doc(hidden)]\n     #[no_coverage]\n     fn assert_receiver_is_total_eq(&self) -> () {\n-        {\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-        }\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n     }\n }\n #[automatically_derived]\n@@ -169,13 +161,7 @@ impl ::core::cmp::PartialOrd for Point {\n         -> ::core::option::Option<::core::cmp::Ordering> {\n         match ::core::cmp::PartialOrd::partial_cmp(&self.x, &other.x) {\n             ::core::option::Option::Some(::core::cmp::Ordering::Equal) =>\n-                match ::core::cmp::PartialOrd::partial_cmp(&self.y, &other.y)\n-                    {\n-                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                        =>\n-                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                    cmp => cmp,\n-                },\n+                ::core::cmp::PartialOrd::partial_cmp(&self.y, &other.y),\n             cmp => cmp,\n         }\n     }\n@@ -187,11 +173,7 @@ impl ::core::cmp::Ord for Point {\n     fn cmp(&self, other: &Point) -> ::core::cmp::Ordering {\n         match ::core::cmp::Ord::cmp(&self.x, &other.x) {\n             ::core::cmp::Ordering::Equal =>\n-                match ::core::cmp::Ord::cmp(&self.y, &other.y) {\n-                    ::core::cmp::Ordering::Equal =>\n-                        ::core::cmp::Ordering::Equal,\n-                    cmp => cmp,\n-                },\n+                ::core::cmp::Ord::cmp(&self.y, &other.y),\n             cmp => cmp,\n         }\n     }\n@@ -229,15 +211,13 @@ impl ::core::clone::Clone for Big {\n #[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Big {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        {\n-            let names: &'static _ =\n-                &[\"b1\", \"b2\", \"b3\", \"b4\", \"b5\", \"b6\", \"b7\", \"b8\"];\n-            let values: &[&dyn ::core::fmt::Debug] =\n-                &[&&self.b1, &&self.b2, &&self.b3, &&self.b4, &&self.b5,\n-                            &&self.b6, &&self.b7, &&self.b8];\n-            ::core::fmt::Formatter::debug_struct_fields_finish(f, \"Big\",\n-                names, values)\n-        }\n+        let names: &'static _ =\n+            &[\"b1\", \"b2\", \"b3\", \"b4\", \"b5\", \"b6\", \"b7\", \"b8\"];\n+        let values: &[&dyn ::core::fmt::Debug] =\n+            &[&&self.b1, &&self.b2, &&self.b3, &&self.b4, &&self.b5,\n+                        &&self.b6, &&self.b7, &&self.b8];\n+        ::core::fmt::Formatter::debug_struct_fields_finish(f, \"Big\", names,\n+            values)\n     }\n }\n #[automatically_derived]\n@@ -261,16 +241,14 @@ impl ::core::default::Default for Big {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Big {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        {\n-            ::core::hash::Hash::hash(&self.b1, state);\n-            ::core::hash::Hash::hash(&self.b2, state);\n-            ::core::hash::Hash::hash(&self.b3, state);\n-            ::core::hash::Hash::hash(&self.b4, state);\n-            ::core::hash::Hash::hash(&self.b5, state);\n-            ::core::hash::Hash::hash(&self.b6, state);\n-            ::core::hash::Hash::hash(&self.b7, state);\n-            ::core::hash::Hash::hash(&self.b8, state)\n-        }\n+        ::core::hash::Hash::hash(&self.b1, state);\n+        ::core::hash::Hash::hash(&self.b2, state);\n+        ::core::hash::Hash::hash(&self.b3, state);\n+        ::core::hash::Hash::hash(&self.b4, state);\n+        ::core::hash::Hash::hash(&self.b5, state);\n+        ::core::hash::Hash::hash(&self.b6, state);\n+        ::core::hash::Hash::hash(&self.b7, state);\n+        ::core::hash::Hash::hash(&self.b8, state)\n     }\n }\n impl ::core::marker::StructuralPartialEq for Big {}\n@@ -300,16 +278,7 @@ impl ::core::cmp::Eq for Big {\n     #[doc(hidden)]\n     #[no_coverage]\n     fn assert_receiver_is_total_eq(&self) -> () {\n-        {\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-        }\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n     }\n }\n #[automatically_derived]\n@@ -344,13 +313,7 @@ impl ::core::cmp::PartialOrd for Big {\n                                                                 &other.b7) {\n                                                             ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n                                                                 =>\n-                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.b8,\n-                                                                        &other.b8) {\n-                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                                                        =>\n-                                                                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                                                                    cmp => cmp,\n-                                                                },\n+                                                                ::core::cmp::PartialOrd::partial_cmp(&self.b8, &other.b8),\n                                                             cmp => cmp,\n                                                         },\n                                                     cmp => cmp,\n@@ -386,11 +349,7 @@ impl ::core::cmp::Ord for Big {\n                                                     ::core::cmp::Ordering::Equal =>\n                                                         match ::core::cmp::Ord::cmp(&self.b7, &other.b7) {\n                                                             ::core::cmp::Ordering::Equal =>\n-                                                                match ::core::cmp::Ord::cmp(&self.b8, &other.b8) {\n-                                                                    ::core::cmp::Ordering::Equal =>\n-                                                                        ::core::cmp::Ordering::Equal,\n-                                                                    cmp => cmp,\n-                                                                },\n+                                                                ::core::cmp::Ord::cmp(&self.b8, &other.b8),\n                                                             cmp => cmp,\n                                                         },\n                                                     cmp => cmp,\n@@ -416,7 +375,8 @@ struct Packed(u32);\n impl ::core::clone::Clone for Packed {\n     #[inline]\n     fn clone(&self) -> Packed {\n-        { let _: ::core::clone::AssertParamIsClone<u32>; *self }\n+        let _: ::core::clone::AssertParamIsClone<u32>;\n+        *self\n     }\n }\n #[automatically_derived]\n@@ -426,11 +386,9 @@ impl ::core::marker::Copy for Packed { }\n #[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Packed {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        {\n-            let Self(__self_0_0) = *self;\n-            ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"Packed\",\n-                &&__self_0_0)\n-        }\n+        let Self(__self_0_0) = *self;\n+        ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"Packed\",\n+            &&__self_0_0)\n     }\n }\n #[automatically_derived]\n@@ -443,10 +401,8 @@ impl ::core::default::Default for Packed {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Packed {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        {\n-            let Self(__self_0_0) = *self;\n-            { ::core::hash::Hash::hash(&__self_0_0, state) }\n-        }\n+        let Self(__self_0_0) = *self;\n+        ::core::hash::Hash::hash(&__self_0_0, state)\n     }\n }\n impl ::core::marker::StructuralPartialEq for Packed {}\n@@ -455,19 +411,15 @@ impl ::core::marker::StructuralPartialEq for Packed {}\n impl ::core::cmp::PartialEq for Packed {\n     #[inline]\n     fn eq(&self, other: &Packed) -> bool {\n-        {\n-            let Self(__self_0_0) = *self;\n-            let Self(__self_1_0) = *other;\n-            __self_0_0 == __self_1_0\n-        }\n+        let Self(__self_0_0) = *self;\n+        let Self(__self_1_0) = *other;\n+        __self_0_0 == __self_1_0\n     }\n     #[inline]\n     fn ne(&self, other: &Packed) -> bool {\n-        {\n-            let Self(__self_0_0) = *self;\n-            let Self(__self_1_0) = *other;\n-            __self_0_0 != __self_1_0\n-        }\n+        let Self(__self_0_0) = *self;\n+        let Self(__self_1_0) = *other;\n+        __self_0_0 != __self_1_0\n     }\n }\n impl ::core::marker::StructuralEq for Packed {}\n@@ -478,7 +430,7 @@ impl ::core::cmp::Eq for Packed {\n     #[doc(hidden)]\n     #[no_coverage]\n     fn assert_receiver_is_total_eq(&self) -> () {\n-        { let _: ::core::cmp::AssertParamIsEq<u32>; }\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n     }\n }\n #[automatically_derived]\n@@ -487,33 +439,177 @@ impl ::core::cmp::PartialOrd for Packed {\n     #[inline]\n     fn partial_cmp(&self, other: &Packed)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        {\n-            let Self(__self_0_0) = *self;\n-            let Self(__self_1_0) = *other;\n-            match ::core::cmp::PartialOrd::partial_cmp(&__self_0_0,\n-                    &__self_1_0) {\n-                ::core::option::Option::Some(::core::cmp::Ordering::Equal) =>\n-                    ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                cmp => cmp,\n-            }\n-        }\n+        let Self(__self_0_0) = *self;\n+        let Self(__self_1_0) = *other;\n+        ::core::cmp::PartialOrd::partial_cmp(&__self_0_0, &__self_1_0)\n     }\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Packed {\n     #[inline]\n     fn cmp(&self, other: &Packed) -> ::core::cmp::Ordering {\n-        {\n-            let Self(__self_0_0) = *self;\n-            let Self(__self_1_0) = *other;\n-            match ::core::cmp::Ord::cmp(&__self_0_0, &__self_1_0) {\n-                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,\n-                cmp => cmp,\n+        let Self(__self_0_0) = *self;\n+        let Self(__self_1_0) = *other;\n+        ::core::cmp::Ord::cmp(&__self_0_0, &__self_1_0)\n+    }\n+}\n+\n+// An empty enum.\n+enum Enum0 {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::clone::Clone for Enum0 {\n+    #[inline]\n+    fn clone(&self) -> Enum0 { *self }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::marker::Copy for Enum0 { }\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::fmt::Debug for Enum0 {\n+    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n+        unsafe { ::core::intrinsics::unreachable() }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::hash::Hash for Enum0 {\n+    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n+        unsafe { ::core::intrinsics::unreachable() }\n+    }\n+}\n+impl ::core::marker::StructuralPartialEq for Enum0 {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialEq for Enum0 {\n+    #[inline]\n+    fn eq(&self, other: &Enum0) -> bool {\n+        unsafe { ::core::intrinsics::unreachable() }\n+    }\n+}\n+impl ::core::marker::StructuralEq for Enum0 {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Eq for Enum0 {\n+    #[inline]\n+    #[doc(hidden)]\n+    #[no_coverage]\n+    fn assert_receiver_is_total_eq(&self) -> () {}\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialOrd for Enum0 {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Enum0)\n+        -> ::core::option::Option<::core::cmp::Ordering> {\n+        unsafe { ::core::intrinsics::unreachable() }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Ord for Enum0 {\n+    #[inline]\n+    fn cmp(&self, other: &Enum0) -> ::core::cmp::Ordering {\n+        unsafe { ::core::intrinsics::unreachable() }\n+    }\n+}\n+\n+// A single-variant enum.\n+enum Enum1 {\n+    Single {\n+        x: u32,\n+    },\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::clone::Clone for Enum1 {\n+    #[inline]\n+    fn clone(&self) -> Enum1 {\n+        match &*self {\n+            &Enum1::Single { x: ref __self_0 } =>\n+                Enum1::Single { x: ::core::clone::Clone::clone(&*__self_0) },\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::fmt::Debug for Enum1 {\n+    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n+        match &*self {\n+            &Enum1::Single { x: ref __self_0 } =>\n+                ::core::fmt::Formatter::debug_struct_field1_finish(f,\n+                    \"Single\", \"x\", &&*__self_0),\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::hash::Hash for Enum1 {\n+    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n+        match &*self {\n+            &Enum1::Single { x: ref __self_0 } => {\n+                ::core::hash::Hash::hash(&*__self_0, state)\n             }\n         }\n     }\n }\n+impl ::core::marker::StructuralPartialEq for Enum1 {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialEq for Enum1 {\n+    #[inline]\n+    fn eq(&self, other: &Enum1) -> bool {\n+        match (&*self, &*other) {\n+            (&Enum1::Single { x: ref __self_0 }, &Enum1::Single {\n+                x: ref __arg_1_0 }) => *__self_0 == *__arg_1_0,\n+        }\n+    }\n+    #[inline]\n+    fn ne(&self, other: &Enum1) -> bool {\n+        match (&*self, &*other) {\n+            (&Enum1::Single { x: ref __self_0 }, &Enum1::Single {\n+                x: ref __arg_1_0 }) => *__self_0 != *__arg_1_0,\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralEq for Enum1 {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Eq for Enum1 {\n+    #[inline]\n+    #[doc(hidden)]\n+    #[no_coverage]\n+    fn assert_receiver_is_total_eq(&self) -> () {\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialOrd for Enum1 {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Enum1)\n+        -> ::core::option::Option<::core::cmp::Ordering> {\n+        match (&*self, &*other) {\n+            (&Enum1::Single { x: ref __self_0 }, &Enum1::Single {\n+                x: ref __arg_1_0 }) =>\n+                ::core::cmp::PartialOrd::partial_cmp(&*__self_0, &*__arg_1_0),\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Ord for Enum1 {\n+    #[inline]\n+    fn cmp(&self, other: &Enum1) -> ::core::cmp::Ordering {\n+        match (&*self, &*other) {\n+            (&Enum1::Single { x: ref __self_0 }, &Enum1::Single {\n+                x: ref __arg_1_0 }) =>\n+                ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0),\n+        }\n+    }\n+}\n \n // A C-like, fieldless enum.\n enum Fieldless {\n@@ -527,7 +623,7 @@ enum Fieldless {\n #[allow(unused_qualifications)]\n impl ::core::clone::Clone for Fieldless {\n     #[inline]\n-    fn clone(&self) -> Fieldless { { *self } }\n+    fn clone(&self) -> Fieldless { *self }\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n@@ -536,10 +632,10 @@ impl ::core::marker::Copy for Fieldless { }\n #[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Fieldless {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        match (&*self,) {\n-            (&Fieldless::A,) => ::core::fmt::Formatter::write_str(f, \"A\"),\n-            (&Fieldless::B,) => ::core::fmt::Formatter::write_str(f, \"B\"),\n-            (&Fieldless::C,) => ::core::fmt::Formatter::write_str(f, \"C\"),\n+        match &*self {\n+            &Fieldless::A => ::core::fmt::Formatter::write_str(f, \"A\"),\n+            &Fieldless::B => ::core::fmt::Formatter::write_str(f, \"B\"),\n+            &Fieldless::C => ::core::fmt::Formatter::write_str(f, \"C\"),\n         }\n     }\n }\n@@ -553,7 +649,7 @@ impl ::core::default::Default for Fieldless {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Fieldless {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        match (&*self,) {\n+        match &*self {\n             _ => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state)\n@@ -567,13 +663,11 @@ impl ::core::marker::StructuralPartialEq for Fieldless {}\n impl ::core::cmp::PartialEq for Fieldless {\n     #[inline]\n     fn eq(&self, other: &Fieldless) -> bool {\n-        {\n-            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if __self_vi == __arg_1_vi {\n-                    match (&*self, &*other) { _ => true, }\n-                } else { false }\n-        }\n+        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        if __self_vi == __arg_1_vi {\n+                match (&*self, &*other) { _ => true, }\n+            } else { false }\n     }\n }\n impl ::core::marker::StructuralEq for Fieldless {}\n@@ -583,43 +677,36 @@ impl ::core::cmp::Eq for Fieldless {\n     #[inline]\n     #[doc(hidden)]\n     #[no_coverage]\n-    fn assert_receiver_is_total_eq(&self) -> () { {} }\n+    fn assert_receiver_is_total_eq(&self) -> () {}\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for Fieldless {\n     #[inline]\n     fn partial_cmp(&self, other: &Fieldless)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        {\n-            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if __self_vi == __arg_1_vi {\n-                    match (&*self, &*other) {\n-                        _ =>\n-                            ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                    }\n-                } else {\n-                   ::core::cmp::PartialOrd::partial_cmp(&__self_vi,\n-                       &__arg_1_vi)\n-               }\n-        }\n+        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        if __self_vi == __arg_1_vi {\n+                match (&*self, &*other) {\n+                    _ =>\n+                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                }\n+            } else {\n+               ::core::cmp::PartialOrd::partial_cmp(&__self_vi, &__arg_1_vi)\n+           }\n     }\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Fieldless {\n     #[inline]\n     fn cmp(&self, other: &Fieldless) -> ::core::cmp::Ordering {\n-        {\n-            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if __self_vi == __arg_1_vi {\n-                    match (&*self, &*other) {\n-                        _ => ::core::cmp::Ordering::Equal,\n-                    }\n-                } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }\n-        }\n+        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        if __self_vi == __arg_1_vi {\n+                match (&*self, &*other) { _ => ::core::cmp::Ordering::Equal, }\n+            } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }\n     }\n }\n \n@@ -640,12 +727,8 @@ enum Mixed {\n impl ::core::clone::Clone for Mixed {\n     #[inline]\n     fn clone(&self) -> Mixed {\n-        {\n-            let _: ::core::clone::AssertParamIsClone<u32>;\n-            let _: ::core::clone::AssertParamIsClone<u32>;\n-            let _: ::core::clone::AssertParamIsClone<u32>;\n-            *self\n-        }\n+        let _: ::core::clone::AssertParamIsClone<u32>;\n+        *self\n     }\n }\n #[automatically_derived]\n@@ -655,13 +738,13 @@ impl ::core::marker::Copy for Mixed { }\n #[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Mixed {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        match (&*self,) {\n-            (&Mixed::P,) => ::core::fmt::Formatter::write_str(f, \"P\"),\n-            (&Mixed::Q,) => ::core::fmt::Formatter::write_str(f, \"Q\"),\n-            (&Mixed::R(ref __self_0),) =>\n+        match &*self {\n+            &Mixed::P => ::core::fmt::Formatter::write_str(f, \"P\"),\n+            &Mixed::Q => ::core::fmt::Formatter::write_str(f, \"Q\"),\n+            &Mixed::R(ref __self_0) =>\n                 ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"R\",\n                     &&*__self_0),\n-            (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },) =>\n+            &Mixed::S { d1: ref __self_0, d2: ref __self_1 } =>\n                 ::core::fmt::Formatter::debug_struct_field2_finish(f, \"S\",\n                     \"d1\", &&*__self_0, \"d2\", &&*__self_1),\n         }\n@@ -677,13 +760,13 @@ impl ::core::default::Default for Mixed {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Mixed {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        match (&*self,) {\n-            (&Mixed::R(ref __self_0),) => {\n+        match &*self {\n+            &Mixed::R(ref __self_0) => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n                 ::core::hash::Hash::hash(&*__self_0, state)\n             }\n-            (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },) => {\n+            &Mixed::S { d1: ref __self_0, d2: ref __self_1 } => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n                 ::core::hash::Hash::hash(&*__self_0, state);\n@@ -702,37 +785,33 @@ impl ::core::marker::StructuralPartialEq for Mixed {}\n impl ::core::cmp::PartialEq for Mixed {\n     #[inline]\n     fn eq(&self, other: &Mixed) -> bool {\n-        {\n-            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if __self_vi == __arg_1_vi {\n-                    match (&*self, &*other) {\n-                        (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n-                            *__self_0 == *__arg_1_0,\n-                        (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n-                            &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n-                            *__self_0 == *__arg_1_0 && *__self_1 == *__arg_1_1,\n-                        _ => true,\n-                    }\n-                } else { false }\n-        }\n+        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        if __self_vi == __arg_1_vi {\n+                match (&*self, &*other) {\n+                    (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n+                        *__self_0 == *__arg_1_0,\n+                    (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n+                        &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n+                        *__self_0 == *__arg_1_0 && *__self_1 == *__arg_1_1,\n+                    _ => true,\n+                }\n+            } else { false }\n     }\n     #[inline]\n     fn ne(&self, other: &Mixed) -> bool {\n-        {\n-            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if __self_vi == __arg_1_vi {\n-                    match (&*self, &*other) {\n-                        (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n-                            *__self_0 != *__arg_1_0,\n-                        (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n-                            &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n-                            *__self_0 != *__arg_1_0 || *__self_1 != *__arg_1_1,\n-                        _ => false,\n-                    }\n-                } else { true }\n-        }\n+        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        if __self_vi == __arg_1_vi {\n+                match (&*self, &*other) {\n+                    (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n+                        *__self_0 != *__arg_1_0,\n+                    (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n+                        &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n+                        *__self_0 != *__arg_1_0 || *__self_1 != *__arg_1_1,\n+                    _ => false,\n+                }\n+            } else { true }\n     }\n }\n impl ::core::marker::StructuralEq for Mixed {}\n@@ -743,11 +822,7 @@ impl ::core::cmp::Eq for Mixed {\n     #[doc(hidden)]\n     #[no_coverage]\n     fn assert_receiver_is_total_eq(&self) -> () {\n-        {\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-        }\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n     }\n }\n #[automatically_derived]\n@@ -756,75 +831,52 @@ impl ::core::cmp::PartialOrd for Mixed {\n     #[inline]\n     fn partial_cmp(&self, other: &Mixed)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        {\n-            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if __self_vi == __arg_1_vi {\n-                    match (&*self, &*other) {\n-                        (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n-                            match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n-                                    &*__arg_1_0) {\n-                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                    =>\n-                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                                cmp => cmp,\n-                            },\n-                        (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n-                            &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n-                            match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n-                                    &*__arg_1_0) {\n-                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                    =>\n-                                    match ::core::cmp::PartialOrd::partial_cmp(&*__self_1,\n-                                            &*__arg_1_1) {\n-                                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                            =>\n-                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                                        cmp => cmp,\n-                                    },\n-                                cmp => cmp,\n-                            },\n-                        _ =>\n-                            ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                    }\n-                } else {\n-                   ::core::cmp::PartialOrd::partial_cmp(&__self_vi,\n-                       &__arg_1_vi)\n-               }\n-        }\n+        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        if __self_vi == __arg_1_vi {\n+                match (&*self, &*other) {\n+                    (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n+                        ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n+                            &*__arg_1_0),\n+                    (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n+                        &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n+                        match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n+                                &*__arg_1_0) {\n+                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                =>\n+                                ::core::cmp::PartialOrd::partial_cmp(&*__self_1,\n+                                    &*__arg_1_1),\n+                            cmp => cmp,\n+                        },\n+                    _ =>\n+                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                }\n+            } else {\n+               ::core::cmp::PartialOrd::partial_cmp(&__self_vi, &__arg_1_vi)\n+           }\n     }\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Mixed {\n     #[inline]\n     fn cmp(&self, other: &Mixed) -> ::core::cmp::Ordering {\n-        {\n-            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if __self_vi == __arg_1_vi {\n-                    match (&*self, &*other) {\n-                        (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n-                            match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n-                                ::core::cmp::Ordering::Equal =>\n-                                    ::core::cmp::Ordering::Equal,\n-                                cmp => cmp,\n-                            },\n-                        (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n-                            &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n-                            match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n-                                ::core::cmp::Ordering::Equal =>\n-                                    match ::core::cmp::Ord::cmp(&*__self_1, &*__arg_1_1) {\n-                                        ::core::cmp::Ordering::Equal =>\n-                                            ::core::cmp::Ordering::Equal,\n-                                        cmp => cmp,\n-                                    },\n-                                cmp => cmp,\n-                            },\n-                        _ => ::core::cmp::Ordering::Equal,\n-                    }\n-                } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }\n-        }\n+        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        if __self_vi == __arg_1_vi {\n+                match (&*self, &*other) {\n+                    (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n+                        ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0),\n+                    (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n+                        &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n+                        match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n+                            ::core::cmp::Ordering::Equal =>\n+                                ::core::cmp::Ord::cmp(&*__self_1, &*__arg_1_1),\n+                            cmp => cmp,\n+                        },\n+                    _ => ::core::cmp::Ordering::Equal,\n+                }\n+            } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }\n     }\n }\n \n@@ -836,12 +888,12 @@ enum Fielded { X(u32), Y(bool), Z(Option<i32>), }\n impl ::core::clone::Clone for Fielded {\n     #[inline]\n     fn clone(&self) -> Fielded {\n-        match (&*self,) {\n-            (&Fielded::X(ref __self_0),) =>\n+        match &*self {\n+            &Fielded::X(ref __self_0) =>\n                 Fielded::X(::core::clone::Clone::clone(&*__self_0)),\n-            (&Fielded::Y(ref __self_0),) =>\n+            &Fielded::Y(ref __self_0) =>\n                 Fielded::Y(::core::clone::Clone::clone(&*__self_0)),\n-            (&Fielded::Z(ref __self_0),) =>\n+            &Fielded::Z(ref __self_0) =>\n                 Fielded::Z(::core::clone::Clone::clone(&*__self_0)),\n         }\n     }\n@@ -850,14 +902,14 @@ impl ::core::clone::Clone for Fielded {\n #[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Fielded {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        match (&*self,) {\n-            (&Fielded::X(ref __self_0),) =>\n+        match &*self {\n+            &Fielded::X(ref __self_0) =>\n                 ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"X\",\n                     &&*__self_0),\n-            (&Fielded::Y(ref __self_0),) =>\n+            &Fielded::Y(ref __self_0) =>\n                 ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"Y\",\n                     &&*__self_0),\n-            (&Fielded::Z(ref __self_0),) =>\n+            &Fielded::Z(ref __self_0) =>\n                 ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"Z\",\n                     &&*__self_0),\n         }\n@@ -867,18 +919,18 @@ impl ::core::fmt::Debug for Fielded {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Fielded {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        match (&*self,) {\n-            (&Fielded::X(ref __self_0),) => {\n+        match &*self {\n+            &Fielded::X(ref __self_0) => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n                 ::core::hash::Hash::hash(&*__self_0, state)\n             }\n-            (&Fielded::Y(ref __self_0),) => {\n+            &Fielded::Y(ref __self_0) => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n                 ::core::hash::Hash::hash(&*__self_0, state)\n             }\n-            (&Fielded::Z(ref __self_0),) => {\n+            &Fielded::Z(ref __self_0) => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n                 ::core::hash::Hash::hash(&*__self_0, state)\n@@ -892,39 +944,35 @@ impl ::core::marker::StructuralPartialEq for Fielded {}\n impl ::core::cmp::PartialEq for Fielded {\n     #[inline]\n     fn eq(&self, other: &Fielded) -> bool {\n-        {\n-            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if __self_vi == __arg_1_vi {\n-                    match (&*self, &*other) {\n-                        (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n-                            *__self_0 == *__arg_1_0,\n-                        (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n-                            *__self_0 == *__arg_1_0,\n-                        (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n-                            *__self_0 == *__arg_1_0,\n-                        _ => unsafe { ::core::intrinsics::unreachable() }\n-                    }\n-                } else { false }\n-        }\n+        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        if __self_vi == __arg_1_vi {\n+                match (&*self, &*other) {\n+                    (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n+                        *__self_0 == *__arg_1_0,\n+                    (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n+                        *__self_0 == *__arg_1_0,\n+                    (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n+                        *__self_0 == *__arg_1_0,\n+                    _ => unsafe { ::core::intrinsics::unreachable() }\n+                }\n+            } else { false }\n     }\n     #[inline]\n     fn ne(&self, other: &Fielded) -> bool {\n-        {\n-            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if __self_vi == __arg_1_vi {\n-                    match (&*self, &*other) {\n-                        (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n-                            *__self_0 != *__arg_1_0,\n-                        (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n-                            *__self_0 != *__arg_1_0,\n-                        (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n-                            *__self_0 != *__arg_1_0,\n-                        _ => unsafe { ::core::intrinsics::unreachable() }\n-                    }\n-                } else { true }\n-        }\n+        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        if __self_vi == __arg_1_vi {\n+                match (&*self, &*other) {\n+                    (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n+                        *__self_0 != *__arg_1_0,\n+                    (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n+                        *__self_0 != *__arg_1_0,\n+                    (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n+                        *__self_0 != *__arg_1_0,\n+                    _ => unsafe { ::core::intrinsics::unreachable() }\n+                }\n+            } else { true }\n     }\n }\n impl ::core::marker::StructuralEq for Fielded {}\n@@ -935,11 +983,9 @@ impl ::core::cmp::Eq for Fielded {\n     #[doc(hidden)]\n     #[no_coverage]\n     fn assert_receiver_is_total_eq(&self) -> () {\n-        {\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-            let _: ::core::cmp::AssertParamIsEq<bool>;\n-            let _: ::core::cmp::AssertParamIsEq<Option<i32>>;\n-        }\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n+        let _: ::core::cmp::AssertParamIsEq<bool>;\n+        let _: ::core::cmp::AssertParamIsEq<Option<i32>>;\n     }\n }\n #[automatically_derived]\n@@ -948,75 +994,62 @@ impl ::core::cmp::PartialOrd for Fielded {\n     #[inline]\n     fn partial_cmp(&self, other: &Fielded)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        {\n-            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if __self_vi == __arg_1_vi {\n-                    match (&*self, &*other) {\n-                        (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n-                            match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n-                                    &*__arg_1_0) {\n-                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                    =>\n-                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                                cmp => cmp,\n-                            },\n-                        (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n-                            match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n-                                    &*__arg_1_0) {\n-                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                    =>\n-                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                                cmp => cmp,\n-                            },\n-                        (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n-                            match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n-                                    &*__arg_1_0) {\n-                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                    =>\n-                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                                cmp => cmp,\n-                            },\n-                        _ => unsafe { ::core::intrinsics::unreachable() }\n-                    }\n-                } else {\n-                   ::core::cmp::PartialOrd::partial_cmp(&__self_vi,\n-                       &__arg_1_vi)\n-               }\n-        }\n+        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        if __self_vi == __arg_1_vi {\n+                match (&*self, &*other) {\n+                    (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n+                        ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n+                            &*__arg_1_0),\n+                    (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n+                        ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n+                            &*__arg_1_0),\n+                    (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n+                        ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n+                            &*__arg_1_0),\n+                    _ => unsafe { ::core::intrinsics::unreachable() }\n+                }\n+            } else {\n+               ::core::cmp::PartialOrd::partial_cmp(&__self_vi, &__arg_1_vi)\n+           }\n     }\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Fielded {\n     #[inline]\n     fn cmp(&self, other: &Fielded) -> ::core::cmp::Ordering {\n-        {\n-            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if __self_vi == __arg_1_vi {\n-                    match (&*self, &*other) {\n-                        (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n-                            match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n-                                ::core::cmp::Ordering::Equal =>\n-                                    ::core::cmp::Ordering::Equal,\n-                                cmp => cmp,\n-                            },\n-                        (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n-                            match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n-                                ::core::cmp::Ordering::Equal =>\n-                                    ::core::cmp::Ordering::Equal,\n-                                cmp => cmp,\n-                            },\n-                        (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n-                            match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n-                                ::core::cmp::Ordering::Equal =>\n-                                    ::core::cmp::Ordering::Equal,\n-                                cmp => cmp,\n-                            },\n-                        _ => unsafe { ::core::intrinsics::unreachable() }\n-                    }\n-                } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }\n-        }\n+        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        if __self_vi == __arg_1_vi {\n+                match (&*self, &*other) {\n+                    (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n+                        ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0),\n+                    (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n+                        ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0),\n+                    (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n+                        ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0),\n+                    _ => unsafe { ::core::intrinsics::unreachable() }\n+                }\n+            } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }\n     }\n }\n+\n+// A union. Most builtin traits are not derivable for unions.\n+pub union Union {\n+    pub b: bool,\n+    pub u: u32,\n+    pub i: i32,\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::clone::Clone for Union {\n+    #[inline]\n+    fn clone(&self) -> Union {\n+        let _: ::core::clone::AssertParamIsCopy<Self>;\n+        *self\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::marker::Copy for Union { }"}]}