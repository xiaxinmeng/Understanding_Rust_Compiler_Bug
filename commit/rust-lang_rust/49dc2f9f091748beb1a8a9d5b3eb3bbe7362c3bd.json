{"sha": "49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5ZGMyZjlmMDkxNzQ4YmViMWE4YTlkNWIzZWIzYmJlNzM2MmMzYmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-04T09:16:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-04T09:16:19Z"}, "message": "Auto merge of #70272 - eddyb:type-of-impl-trait, r=nikomatsakis\n\ntypeck/type_of: let wfcheck handle generics in opaque types' substs.\n\nI was working on #70164, and `type_of`'s handling of opaque types seemed to be, by far, the trickiest use of `Ty::walk`, but I believe it wasn't doing anything (see https://github.com/rust-lang/rust/pull/57896#discussion_r396064431 - I suspect, based on glancing at the PR discussion, that an early attempt was kept in, despite becoming just an overcomplicated way to do exactly the same as the previous simple type equality check).\n\nI would've loved to remove `ResolvedOpaqueTy` (keep the `Ty` and lose the `Substs`), but it looks like the MIR borrowck part of the process needs that now, so it would've been added anyway since #57896, even if that PR hadn't happened.\n\n<hr/>\n\nIn the process, I've moved the remaining substitution validation to `wfcheck`, which was already handling lifetimes, and kept only `delay_span_bug`s in `type_of`, as an insurance policy.\n\nI've added tests for lifetime and const cases, they seem to be checked correctly now.\n(and more uniform than they were in https://github.com/rust-lang/rust/issues/63063#issuecomment-602162804)\n\nHowever, the quality of the errors is maybe a bit worse, and they don't trigger when there are other errors (not sure if this is due to compilation stop points or something more specific to one opaque type).\n\nr? @nikomatsakis cc @matthewjasper @oli-obk @Aaron1011", "tree": {"sha": "3c9f383370676a43b5e46b1e57785f62427b9889", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c9f383370676a43b5e46b1e57785f62427b9889"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "html_url": "https://github.com/rust-lang/rust/commit/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b521f57735663de9373679cf8c6502622036bf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b521f57735663de9373679cf8c6502622036bf1", "html_url": "https://github.com/rust-lang/rust/commit/1b521f57735663de9373679cf8c6502622036bf1"}, {"sha": "8ad149a0e0810cb2ef17b2b0aef18c9a2a9062b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ad149a0e0810cb2ef17b2b0aef18c9a2a9062b0", "html_url": "https://github.com/rust-lang/rust/commit/8ad149a0e0810cb2ef17b2b0aef18c9a2a9062b0"}], "stats": {"total": 587, "additions": 276, "deletions": 311}, "files": [{"sha": "9b182333907974f1986a917972ceac97af694667", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "patch": "@@ -1077,48 +1077,42 @@ impl<'tcx> Generics {\n         false\n     }\n \n+    pub fn param_at(&'tcx self, param_index: usize, tcx: TyCtxt<'tcx>) -> &'tcx GenericParamDef {\n+        if let Some(index) = param_index.checked_sub(self.parent_count) {\n+            &self.params[index]\n+        } else {\n+            tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n+                .param_at(param_index, tcx)\n+        }\n+    }\n+\n     pub fn region_param(\n         &'tcx self,\n         param: &EarlyBoundRegion,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx GenericParamDef {\n-        if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n-            let param = &self.params[index as usize];\n-            match param.kind {\n-                GenericParamDefKind::Lifetime => param,\n-                _ => bug!(\"expected lifetime parameter, but found another generic parameter\"),\n-            }\n-        } else {\n-            tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n-                .region_param(param, tcx)\n+        let param = self.param_at(param.index as usize, tcx);\n+        match param.kind {\n+            GenericParamDefKind::Lifetime => param,\n+            _ => bug!(\"expected lifetime parameter, but found another generic parameter\"),\n         }\n     }\n \n     /// Returns the `GenericParamDef` associated with this `ParamTy`.\n     pub fn type_param(&'tcx self, param: &ParamTy, tcx: TyCtxt<'tcx>) -> &'tcx GenericParamDef {\n-        if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n-            let param = &self.params[index as usize];\n-            match param.kind {\n-                GenericParamDefKind::Type { .. } => param,\n-                _ => bug!(\"expected type parameter, but found another generic parameter\"),\n-            }\n-        } else {\n-            tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n-                .type_param(param, tcx)\n+        let param = self.param_at(param.index as usize, tcx);\n+        match param.kind {\n+            GenericParamDefKind::Type { .. } => param,\n+            _ => bug!(\"expected type parameter, but found another generic parameter\"),\n         }\n     }\n \n     /// Returns the `ConstParameterDef` associated with this `ParamConst`.\n     pub fn const_param(&'tcx self, param: &ParamConst, tcx: TyCtxt<'tcx>) -> &GenericParamDef {\n-        if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n-            let param = &self.params[index as usize];\n-            match param.kind {\n-                GenericParamDefKind::Const => param,\n-                _ => bug!(\"expected const parameter, but found another generic parameter\"),\n-            }\n-        } else {\n-            tcx.generics_of(self.parent.expect(\"parent_count>0 but no parent?\"))\n-                .const_param(param, tcx)\n+        let param = self.param_at(param.index as usize, tcx);\n+        match param.kind {\n+            GenericParamDefKind::Const => param,\n+            _ => bug!(\"expected const parameter, but found another generic parameter\"),\n         }\n     }\n }"}, {"sha": "b0ff17ad56d7c5dd13cd46500cfffa50cb205e53", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 49, "deletions": 59, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "patch": "@@ -9,7 +9,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::itemlikevisit::ParItemLikeVisitor;\n use rustc_hir::lang_items;\n use rustc_hir::ItemKind;\n-use rustc_middle::ty::subst::{InternalSubsts, Subst};\n+use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n use rustc_middle::ty::{\n     self, AdtKind, GenericParamDefKind, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n@@ -864,87 +864,77 @@ fn check_opaque_types<'fcx, 'tcx>(\n                 trace!(\"check_opaque_types: opaque_ty, {:?}, {:?}\", def_id, substs);\n                 let generics = tcx.generics_of(def_id);\n                 // Only check named `impl Trait` types defined in this crate.\n+                // FIXME(eddyb) is  `generics.parent.is_none()` correct? It seems\n+                // potentially risky wrt associated types in `impl`s.\n                 if generics.parent.is_none() && def_id.is_local() {\n                     let opaque_hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n                     if may_define_opaque_type(tcx, fn_def_id, opaque_hir_id) {\n                         trace!(\"check_opaque_types: may define, generics={:#?}\", generics);\n-                        let mut seen: FxHashMap<_, Vec<_>> = FxHashMap::default();\n-                        for (subst, param) in substs.iter().zip(&generics.params) {\n-                            match subst.unpack() {\n-                                ty::subst::GenericArgKind::Type(ty) => match ty.kind {\n-                                    ty::Param(..) => {}\n-                                    // Prevent `fn foo() -> Foo<u32>` from being defining.\n-                                    _ => {\n-                                        tcx.sess\n-                                            .struct_span_err(\n-                                                span,\n-                                                \"non-defining opaque type use \\\n-                                                 in defining scope\",\n-                                            )\n-                                            .span_note(\n-                                                tcx.def_span(param.def_id),\n-                                                &format!(\n-                                                    \"used non-generic type {} for \\\n-                                                     generic parameter\",\n-                                                    ty,\n-                                                ),\n-                                            )\n-                                            .emit();\n-                                    }\n-                                },\n+                        let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n+                        for (i, &arg) in substs.iter().enumerate() {\n+                            let arg_is_param = match arg.unpack() {\n+                                GenericArgKind::Type(ty) => matches!(ty.kind, ty::Param(_)),\n \n-                                ty::subst::GenericArgKind::Lifetime(region) => {\n-                                    let param_span = tcx.def_span(param.def_id);\n+                                GenericArgKind::Lifetime(region) => {\n                                     if let ty::ReStatic = region {\n                                         tcx.sess\n                                             .struct_span_err(\n                                                 span,\n-                                                \"non-defining opaque type use \\\n-                                                 in defining scope\",\n+                                                \"non-defining opaque type use in defining scope\",\n                                             )\n                                             .span_label(\n-                                                param_span,\n+                                                tcx.def_span(generics.param_at(i, tcx).def_id),\n                                                 \"cannot use static lifetime; use a bound lifetime \\\n                                                  instead or remove the lifetime parameter from the \\\n                                                  opaque type\",\n                                             )\n                                             .emit();\n-                                    } else {\n-                                        seen.entry(region).or_default().push(param_span);\n+                                        continue;\n                                     }\n+\n+                                    true\n                                 }\n \n-                                ty::subst::GenericArgKind::Const(ct) => match ct.val {\n-                                    ty::ConstKind::Param(_) => {}\n-                                    _ => {\n-                                        tcx.sess\n-                                            .struct_span_err(\n-                                                span,\n-                                                \"non-defining opaque type use \\\n-                                                 in defining scope\",\n-                                            )\n-                                            .span_note(\n-                                                tcx.def_span(param.def_id),\n-                                                &format!(\n-                                                    \"used non-generic const {} for \\\n-                                                     generic parameter\",\n-                                                    ty,\n-                                                ),\n-                                            )\n-                                            .emit();\n-                                    }\n-                                },\n-                            } // match subst\n-                        } // for (subst, param)\n-                        for (_, spans) in seen {\n-                            if spans.len() > 1 {\n+                                GenericArgKind::Const(ct) => {\n+                                    matches!(ct.val, ty::ConstKind::Param(_))\n+                                }\n+                            };\n+\n+                            if arg_is_param {\n+                                seen_params.entry(arg).or_default().push(i);\n+                            } else {\n+                                // Prevent `fn foo() -> Foo<u32>` from being defining.\n+                                let opaque_param = generics.param_at(i, tcx);\n+                                tcx.sess\n+                                    .struct_span_err(\n+                                        span,\n+                                        \"non-defining opaque type use in defining scope\",\n+                                    )\n+                                    .span_note(\n+                                        tcx.def_span(opaque_param.def_id),\n+                                        &format!(\n+                                            \"used non-generic {} `{}` for generic parameter\",\n+                                            opaque_param.kind.descr(),\n+                                            arg,\n+                                        ),\n+                                    )\n+                                    .emit();\n+                            }\n+                        } // for (arg, param)\n+\n+                        for (_, indices) in seen_params {\n+                            if indices.len() > 1 {\n+                                let descr = generics.param_at(indices[0], tcx).kind.descr();\n+                                let spans: Vec<_> = indices\n+                                    .into_iter()\n+                                    .map(|i| tcx.def_span(generics.param_at(i, tcx).def_id))\n+                                    .collect();\n                                 tcx.sess\n                                     .struct_span_err(\n                                         span,\n-                                        \"non-defining opaque type use \\\n-                                         in defining scope\",\n+                                        \"non-defining opaque type use in defining scope\",\n                                     )\n-                                    .span_note(spans, \"lifetime used multiple times\")\n+                                    .span_note(spans, &format!(\"{} used multiple times\", descr))\n                                     .emit();\n                             }\n                         }"}, {"sha": "d45c82700689a169d5a257cdda96a1a3f45ac43e", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 39, "deletions": 101, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "patch": "@@ -1,4 +1,4 @@\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, Applicability, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -7,7 +7,7 @@ use rustc_hir::intravisit;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::Node;\n use rustc_middle::hir::map::Map;\n-use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n+use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable};\n use rustc_session::parse::feature_err;\n@@ -369,13 +369,8 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     struct ConstraintLocator<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n-        // (first found type span, actual type, mapping from the opaque type's generic\n-        // parameters to the concrete type's generic parameters)\n-        //\n-        // The mapping is an index for each use site of a generic parameter in the concrete type\n-        //\n-        // The indices index into the generic parameters on the opaque type.\n-        found: Option<(Span, Ty<'tcx>, Vec<usize>)>,\n+        // (first found type span, actual type)\n+        found: Option<(Span, Ty<'tcx>)>,\n     }\n \n     impl ConstraintLocator<'_> {\n@@ -407,83 +402,51 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n \n                 // FIXME(oli-obk): trace the actual span from inference to improve errors.\n                 let span = self.tcx.def_span(def_id);\n-                // used to quickly look up the position of a generic parameter\n-                let mut index_map: FxHashMap<ty::ParamTy, usize> = FxHashMap::default();\n-                // Skipping binder is ok, since we only use this to find generic parameters and\n-                // their positions.\n-                for (idx, subst) in substs.iter().enumerate() {\n-                    if let GenericArgKind::Type(ty) = subst.unpack() {\n-                        if let ty::Param(p) = ty.kind {\n-                            if index_map.insert(p, idx).is_some() {\n-                                // There was already an entry for `p`, meaning a generic parameter\n-                                // was used twice.\n-                                self.tcx.sess.span_err(\n-                                    span,\n-                                    &format!(\n-                                        \"defining opaque type use restricts opaque \\\n-                                         type by using the generic parameter `{}` twice\",\n-                                        p,\n-                                    ),\n-                                );\n-                                return;\n-                            }\n-                        } else {\n+\n+                // HACK(eddyb) this check shouldn't be needed, as `wfcheck`\n+                // performs the same checks, in theory, but I've kept it here\n+                // using `delay_span_bug`, just in case `wfcheck` slips up.\n+                let opaque_generics = self.tcx.generics_of(self.def_id);\n+                let mut used_params: FxHashSet<_> = FxHashSet::default();\n+                for (i, arg) in substs.iter().enumerate() {\n+                    let arg_is_param = match arg.unpack() {\n+                        GenericArgKind::Type(ty) => matches!(ty.kind, ty::Param(_)),\n+                        GenericArgKind::Lifetime(lt) => {\n+                            matches!(lt, ty::ReEarlyBound(_) | ty::ReFree(_))\n+                        }\n+                        GenericArgKind::Const(ct) => matches!(ct.val, ty::ConstKind::Param(_)),\n+                    };\n+\n+                    if arg_is_param {\n+                        if !used_params.insert(arg) {\n+                            // There was already an entry for `arg`, meaning a generic parameter\n+                            // was used twice.\n                             self.tcx.sess.delay_span_bug(\n                                 span,\n                                 &format!(\n-                                    \"non-defining opaque ty use in defining scope: {:?}, {:?}\",\n-                                    concrete_type, substs,\n+                                    \"defining opaque type use restricts opaque \\\n+                                     type by using the generic parameter `{}` twice\",\n+                                    arg,\n                                 ),\n                             );\n                         }\n-                    }\n-                }\n-                // Compute the index within the opaque type for each generic parameter used in\n-                // the concrete type.\n-                let indices = concrete_type\n-                    .subst(self.tcx, substs)\n-                    .walk()\n-                    .filter_map(|t| match &t.kind {\n-                        ty::Param(p) => Some(*index_map.get(p).unwrap()),\n-                        _ => None,\n-                    })\n-                    .collect();\n-                let is_param = |ty: Ty<'_>| match ty.kind {\n-                    ty::Param(_) => true,\n-                    _ => false,\n-                };\n-                let bad_substs: Vec<_> = substs\n-                    .iter()\n-                    .enumerate()\n-                    .filter_map(|(i, k)| {\n-                        if let GenericArgKind::Type(ty) = k.unpack() { Some((i, ty)) } else { None }\n-                    })\n-                    .filter(|(_, ty)| !is_param(ty))\n-                    .collect();\n-                if !bad_substs.is_empty() {\n-                    let identity_substs = InternalSubsts::identity_for_item(self.tcx, self.def_id);\n-                    for (i, bad_subst) in bad_substs {\n-                        self.tcx.sess.span_err(\n+                    } else {\n+                        let param = opaque_generics.param_at(i, self.tcx);\n+                        self.tcx.sess.delay_span_bug(\n                             span,\n                             &format!(\n                                 \"defining opaque type use does not fully define opaque type: \\\n-                            generic parameter `{}` is specified as concrete type `{}`\",\n-                                identity_substs.type_at(i),\n-                                bad_subst\n+                                 generic parameter `{}` is specified as concrete {} `{}`\",\n+                                param.name,\n+                                param.kind.descr(),\n+                                arg,\n                             ),\n                         );\n                     }\n-                } else if let Some((prev_span, prev_ty, ref prev_indices)) = self.found {\n-                    let mut ty = concrete_type.walk().fuse();\n-                    let mut p_ty = prev_ty.walk().fuse();\n-                    let iter_eq = (&mut ty).zip(&mut p_ty).all(|(t, p)| match (&t.kind, &p.kind) {\n-                        // Type parameters are equal to any other type parameter for the purpose of\n-                        // concrete type equality, as it is possible to obtain the same type just\n-                        // by passing matching parameters to a function.\n-                        (ty::Param(_), ty::Param(_)) => true,\n-                        _ => t == p,\n-                    });\n-                    if !iter_eq || ty.next().is_some() || p_ty.next().is_some() {\n+                }\n+\n+                if let Some((prev_span, prev_ty)) = self.found {\n+                    if *concrete_type != prev_ty {\n                         debug!(\"find_opaque_ty_constraints: span={:?}\", span);\n                         // Found different concrete types for the opaque type.\n                         let mut err = self.tcx.sess.struct_span_err(\n@@ -496,34 +459,9 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         );\n                         err.span_note(prev_span, \"previous use here\");\n                         err.emit();\n-                    } else if indices != *prev_indices {\n-                        // Found \"same\" concrete types, but the generic parameter order differs.\n-                        let mut err = self.tcx.sess.struct_span_err(\n-                            span,\n-                            \"concrete type's generic parameters differ from previous defining use\",\n-                        );\n-                        use std::fmt::Write;\n-                        let mut s = String::new();\n-                        write!(s, \"expected [\").unwrap();\n-                        let list = |s: &mut String, indices: &Vec<usize>| {\n-                            let mut indices = indices.iter().cloned();\n-                            if let Some(first) = indices.next() {\n-                                write!(s, \"`{}`\", substs[first]).unwrap();\n-                                for i in indices {\n-                                    write!(s, \", `{}`\", substs[i]).unwrap();\n-                                }\n-                            }\n-                        };\n-                        list(&mut s, prev_indices);\n-                        write!(s, \"], got [\").unwrap();\n-                        list(&mut s, &indices);\n-                        write!(s, \"]\").unwrap();\n-                        err.span_label(span, s);\n-                        err.span_note(prev_span, \"previous use here\");\n-                        err.emit();\n                     }\n                 } else {\n-                    self.found = Some((span, concrete_type, indices));\n+                    self.found = Some((span, concrete_type));\n                 }\n             } else {\n                 debug!(\n@@ -606,7 +544,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     }\n \n     match locator.found {\n-        Some((_, ty, _)) => ty,\n+        Some((_, ty)) => ty,\n         None => {\n             let span = tcx.def_span(def_id);\n             tcx.sess.span_err(span, \"could not find defining uses\");"}, {"sha": "0a4cc9b7fe8be4bf40046a9142bcf805d6537722", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs?ref=49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "patch": "@@ -8,13 +8,12 @@ trait TraitWithAssoc {\n }\n \n type Foo<V> = impl Trait<V>;\n-//~^ ERROR could not find defining uses\n-//~| ERROR the trait bound `T: TraitWithAssoc` is not satisfied\n+//~^ ERROR the trait bound `T: TraitWithAssoc` is not satisfied\n \n trait Trait<U> {}\n \n impl<W> Trait<W> for () {}\n \n-fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> { //~ ERROR does not fully define\n+fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n     ()\n }"}, {"sha": "b871f79aa1dc57e9c1decc7f252ad6d31d8cbab4", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.stderr", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr?ref=49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "patch": "@@ -9,20 +9,6 @@ help: consider further restricting this bound\n LL | fn foo_desugared<T: TraitWithAssoc + TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n    |                                    ^^^^^^^^^^^^^^^^\n \n-error: defining opaque type use does not fully define opaque type: generic parameter `V` is specified as concrete type `<T as TraitWithAssoc>::Assoc`\n-  --> $DIR/bound_reduction2.rs:18:1\n-   |\n-LL | / fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n-LL | |     ()\n-LL | | }\n-   | |_^\n-\n-error: could not find defining uses\n-  --> $DIR/bound_reduction2.rs:10:1\n-   |\n-LL | type Foo<V> = impl Trait<V>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "4503607a836385cfd2072e0a3877b8e64eed2cdb", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs?ref=49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "patch": "@@ -1,14 +1,26 @@\n-#![feature(type_alias_impl_trait)]\n+#![feature(type_alias_impl_trait, const_generics)]\n+#![allow(incomplete_features)]\n \n use std::fmt::Debug;\n \n fn main() {}\n \n // test that unused generic parameters are ok\n-type Two<T, U> = impl Debug;\n-//~^ could not find defining uses\n+type TwoTys<T, U> = impl Debug;\n+type TwoLifetimes<'a, 'b> = impl Debug;\n+type TwoConsts<const X: usize, const Y: usize> = impl Debug;\n \n-fn one<T: Debug>(t: T) -> Two<T, T> {\n-//~^ ERROR defining opaque type use restricts opaque type\n+fn one_ty<T: Debug>(t: T) -> TwoTys<T, T> {\n+//~^ ERROR non-defining opaque type use in defining scope\n+    t\n+}\n+\n+fn one_lifetime<'a>(t: &'a u32) -> TwoLifetimes<'a, 'a> {\n+//~^ ERROR non-defining opaque type use in defining scope\n+    t\n+}\n+\n+fn one_const<const N: usize>(t: *mut [u8; N]) -> TwoConsts<N, N> {\n+//~^ ERROR non-defining opaque type use in defining scope\n     t\n }"}, {"sha": "b4757e2763d0699d2503f5b0e3ca894fa222a616", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use.stderr", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr?ref=49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "patch": "@@ -1,17 +1,38 @@\n-error: defining opaque type use restricts opaque type by using the generic parameter `T` twice\n-  --> $DIR/generic_duplicate_param_use.rs:11:1\n-   |\n-LL | / fn one<T: Debug>(t: T) -> Two<T, T> {\n-LL | |\n-LL | |     t\n-LL | | }\n-   | |_^\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/generic_duplicate_param_use.rs:13:30\n+   |\n+LL | fn one_ty<T: Debug>(t: T) -> TwoTys<T, T> {\n+   |                              ^^^^^^^^^^^^\n+   |\n+note: type used multiple times\n+  --> $DIR/generic_duplicate_param_use.rs:9:13\n+   |\n+LL | type TwoTys<T, U> = impl Debug;\n+   |             ^  ^\n \n-error: could not find defining uses\n-  --> $DIR/generic_duplicate_param_use.rs:8:1\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/generic_duplicate_param_use.rs:18:36\n+   |\n+LL | fn one_lifetime<'a>(t: &'a u32) -> TwoLifetimes<'a, 'a> {\n+   |                                    ^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: lifetime used multiple times\n+  --> $DIR/generic_duplicate_param_use.rs:10:19\n+   |\n+LL | type TwoLifetimes<'a, 'b> = impl Debug;\n+   |                   ^^  ^^\n+\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/generic_duplicate_param_use.rs:23:50\n+   |\n+LL | fn one_const<const N: usize>(t: *mut [u8; N]) -> TwoConsts<N, N> {\n+   |                                                  ^^^^^^^^^^^^^^^\n+   |\n+note: constant used multiple times\n+  --> $DIR/generic_duplicate_param_use.rs:11:22\n    |\n-LL | type Two<T, U> = impl Debug;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | type TwoConsts<const X: usize, const Y: usize> = impl Debug;\n+   |                      ^               ^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "2b98d8fc63a1159fd7698160d4d2cfd18263a867", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.rs?ref=49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "patch": "@@ -8,10 +8,10 @@ fn main() {}\n type Two<T, U> = impl Debug;\n \n fn one<T: Debug>(t: T) -> Two<T, T> {\n-//~^ defining opaque type use restricts opaque type\n     t\n }\n \n fn two<T: Debug, U>(t: T, _: U) -> Two<T, U> {\n+//~^ ERROR concrete type differs from previous defining opaque type use\n     t\n }"}, {"sha": "8170c671f68cdaee02bf427b9d801ff8f2e90540", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use2.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.stderr?ref=49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "patch": "@@ -1,8 +1,16 @@\n-error: defining opaque type use restricts opaque type by using the generic parameter `T` twice\n+error: concrete type differs from previous defining opaque type use\n+  --> $DIR/generic_duplicate_param_use2.rs:14:1\n+   |\n+LL | / fn two<T: Debug, U>(t: T, _: U) -> Two<T, U> {\n+LL | |\n+LL | |     t\n+LL | | }\n+   | |_^ expected `U`, got `T`\n+   |\n+note: previous use here\n   --> $DIR/generic_duplicate_param_use2.rs:10:1\n    |\n LL | / fn one<T: Debug>(t: T) -> Two<T, T> {\n-LL | |\n LL | |     t\n LL | | }\n    | |_^"}, {"sha": "d9133fd11f7cdac57012607aa729d63ff31ebdad", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use3.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs?ref=49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "patch": "@@ -8,15 +8,14 @@ fn main() {}\n type Two<T, U> = impl Debug;\n \n fn one<T: Debug>(t: T) -> Two<T, T> {\n-//~^ defining opaque type use restricts opaque type\n     t\n }\n \n fn two<T: Debug, U>(t: T, _: U) -> Two<T, U> {\n+//~^ ERROR concrete type differs from previous defining opaque type use\n     t\n }\n \n fn three<T, U: Debug>(_: T, u: U) -> Two<T, U> {\n-//~^ concrete type's generic parameters differ from previous defining use\n     u\n }"}, {"sha": "86dd33684005b0bd7f70ab48cee828bd0dcbf661", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use3.stderr", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr?ref=49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "patch": "@@ -1,28 +1,19 @@\n-error: defining opaque type use restricts opaque type by using the generic parameter `T` twice\n-  --> $DIR/generic_duplicate_param_use3.rs:10:1\n+error: concrete type differs from previous defining opaque type use\n+  --> $DIR/generic_duplicate_param_use3.rs:14:1\n    |\n-LL | / fn one<T: Debug>(t: T) -> Two<T, T> {\n+LL | / fn two<T: Debug, U>(t: T, _: U) -> Two<T, U> {\n LL | |\n LL | |     t\n LL | | }\n-   | |_^\n-\n-error: concrete type's generic parameters differ from previous defining use\n-  --> $DIR/generic_duplicate_param_use3.rs:19:1\n-   |\n-LL | / fn three<T, U: Debug>(_: T, u: U) -> Two<T, U> {\n-LL | |\n-LL | |     u\n-LL | | }\n-   | |_^ expected [`T`], got [`U`]\n+   | |_^ expected `U`, got `T`\n    |\n note: previous use here\n-  --> $DIR/generic_duplicate_param_use3.rs:15:1\n+  --> $DIR/generic_duplicate_param_use3.rs:10:1\n    |\n-LL | / fn two<T: Debug, U>(t: T, _: U) -> Two<T, U> {\n+LL | / fn one<T: Debug>(t: T) -> Two<T, T> {\n LL | |     t\n LL | | }\n    | |_^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "40388c3b6c88aed1bdcb0939a819422a19fbc4ca", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.rs?ref=49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "patch": "@@ -8,7 +8,7 @@ fn main() {}\n type Two<T, U> = impl Debug;\n \n fn one<T: Debug>(t: T) -> Two<T, T> {\n-//~^ ERROR defining opaque type use restricts opaque type\n+//~^ ERROR non-defining opaque type use in defining scope\n     t\n }\n "}, {"sha": "fcf01f5164ae4aa770e52ada1ed7076194640d13", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use4.stderr", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.stderr?ref=49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "patch": "@@ -1,11 +1,14 @@\n-error: defining opaque type use restricts opaque type by using the generic parameter `T` twice\n-  --> $DIR/generic_duplicate_param_use4.rs:10:1\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/generic_duplicate_param_use4.rs:10:27\n    |\n-LL | / fn one<T: Debug>(t: T) -> Two<T, T> {\n-LL | |\n-LL | |     t\n-LL | | }\n-   | |_^\n+LL | fn one<T: Debug>(t: T) -> Two<T, T> {\n+   |                           ^^^^^^^^^\n+   |\n+note: type used multiple times\n+  --> $DIR/generic_duplicate_param_use4.rs:8:10\n+   |\n+LL | type Two<T, U> = impl Debug;\n+   |          ^  ^\n \n error: aborting due to previous error\n "}, {"sha": "b1782120f84cc10b3fa900bfda29c762a12fde9c", "filename": "src/test/ui/type-alias-impl-trait/generic_nondefining_use.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs?ref=49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "patch": "@@ -1,13 +1,27 @@\n-#![feature(type_alias_impl_trait)]\n+#![feature(type_alias_impl_trait, const_generics)]\n+#![allow(incomplete_features)]\n+\n+use std::fmt::Debug;\n \n fn main() {}\n \n-type Cmp<T> = impl 'static;\n-//~^ ERROR could not find defining uses\n-//~^^ ERROR: at least one trait must be specified\n+type OneTy<T> = impl Debug;\n+type OneLifetime<'a> = impl Debug;\n+type OneConst<const X: usize> = impl Debug;\n \n+// Not defining uses, because they doesn't define *all* possible generics.\n \n-// not a defining use, because it doesn't define *all* possible generics\n-fn cmp() -> Cmp<u32> { //~ ERROR defining opaque type use does not fully define\n+fn concrete_ty() -> OneTy<u32> {\n+//~^ ERROR non-defining opaque type use in defining scope\n     5u32\n }\n+\n+fn concrete_lifetime() -> OneLifetime<'static> {\n+//~^ ERROR non-defining opaque type use in defining scope\n+    6u32\n+}\n+\n+fn concrete_const() -> OneConst<{123}> {\n+//~^ ERROR non-defining opaque type use in defining scope\n+    7u32\n+}"}, {"sha": "b0ffc4a5ef61dc1a3025bbad04c348592f722b47", "filename": "src/test/ui/type-alias-impl-trait/generic_nondefining_use.stderr", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr?ref=49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "patch": "@@ -1,22 +1,35 @@\n-error: at least one trait must be specified\n-  --> $DIR/generic_nondefining_use.rs:5:15\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/generic_nondefining_use.rs:14:21\n    |\n-LL | type Cmp<T> = impl 'static;\n-   |               ^^^^^^^^^^^^\n+LL | fn concrete_ty() -> OneTy<u32> {\n+   |                     ^^^^^^^^^^\n+   |\n+note: used non-generic type `u32` for generic parameter\n+  --> $DIR/generic_nondefining_use.rs:8:12\n+   |\n+LL | type OneTy<T> = impl Debug;\n+   |            ^\n \n-error: defining opaque type use does not fully define opaque type: generic parameter `T` is specified as concrete type `u32`\n-  --> $DIR/generic_nondefining_use.rs:11:1\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/generic_nondefining_use.rs:19:27\n    |\n-LL | / fn cmp() -> Cmp<u32> {\n-LL | |     5u32\n-LL | | }\n-   | |_^\n+LL | type OneLifetime<'a> = impl Debug;\n+   |                  -- cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n+...\n+LL | fn concrete_lifetime() -> OneLifetime<'static> {\n+   |                           ^^^^^^^^^^^^^^^^^^^^\n \n-error: could not find defining uses\n-  --> $DIR/generic_nondefining_use.rs:5:1\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/generic_nondefining_use.rs:24:24\n+   |\n+LL | fn concrete_const() -> OneConst<{123}> {\n+   |                        ^^^^^^^^^^^^^^^\n+   |\n+note: used non-generic constant `123usize` for generic parameter\n+  --> $DIR/generic_nondefining_use.rs:10:21\n    |\n-LL | type Cmp<T> = impl 'static;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | type OneConst<const X: usize> = impl Debug;\n+   |                     ^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "4eb7f7836d8691cdac91a83858297fc0440dfe94", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs?ref=49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "patch": "@@ -6,7 +6,6 @@ trait IterBits {\n }\n \n type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n-//~^ ERROR could not find defining uses\n \n impl<T: Copy, E> IterBits for T\n where\n@@ -18,7 +17,8 @@ where\n {\n     type BitsIter = IterBitsIter<T, E, u8>;\n     fn iter_bits(self, n: u8) -> Self::BitsIter {\n-    //~^ ERROR defining opaque type use does not fully define opaque type\n+    //~^ ERROR non-defining opaque type use in defining scope\n+    //~| ERROR non-defining opaque type use in defining scope\n         (0u8..n)\n             .rev()\n             .map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())"}, {"sha": "55984609437b09652f285c88aba21f48e96e8403", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.stderr", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr?ref=49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "patch": "@@ -1,19 +1,26 @@\n-error: defining opaque type use does not fully define opaque type: generic parameter `I` is specified as concrete type `u8`\n-  --> $DIR/issue-60564.rs:20:5\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/issue-60564.rs:19:34\n    |\n-LL | /     fn iter_bits(self, n: u8) -> Self::BitsIter {\n-LL | |\n-LL | |         (0u8..n)\n-LL | |             .rev()\n-LL | |             .map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n-LL | |     }\n-   | |_____^\n+LL |     fn iter_bits(self, n: u8) -> Self::BitsIter {\n+   |                                  ^^^^^^^^^^^^^^\n+   |\n+note: used non-generic type `_` for generic parameter\n+  --> $DIR/issue-60564.rs:8:22\n+   |\n+LL | type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n+   |                      ^\n \n-error: could not find defining uses\n-  --> $DIR/issue-60564.rs:8:1\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/issue-60564.rs:19:34\n+   |\n+LL |     fn iter_bits(self, n: u8) -> Self::BitsIter {\n+   |                                  ^^^^^^^^^^^^^^\n+   |\n+note: used non-generic type `u8` for generic parameter\n+  --> $DIR/issue-60564.rs:8:25\n    |\n LL | type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                         ^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "3b6decbe9c65e5cf5e5d75123246fc66ebd33a01", "filename": "src/test/ui/type-alias-impl-trait/issue-68368-non-defining-use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.rs?ref=49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "patch": "@@ -4,9 +4,9 @@\n \n #![feature(type_alias_impl_trait)]\n trait Trait<T> {}\n-type Alias<'a, U> = impl Trait<U>; //~ ERROR could not find defining uses\n+type Alias<'a, U> = impl Trait<U>;\n fn f<'a>() -> Alias<'a, ()> {}\n-//~^ ERROR defining opaque type use does not fully define opaque type: generic parameter `U`\n+//~^ ERROR non-defining opaque type use in defining scope\n \n fn main() {}\n "}, {"sha": "c2fa54f50f881214050a05d210964a8c152bd080", "filename": "src/test/ui/type-alias-impl-trait/issue-68368-non-defining-use.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.stderr?ref=49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "patch": "@@ -1,14 +1,14 @@\n-error: defining opaque type use does not fully define opaque type: generic parameter `U` is specified as concrete type `()`\n-  --> $DIR/issue-68368-non-defining-use.rs:8:1\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/issue-68368-non-defining-use.rs:8:15\n    |\n LL | fn f<'a>() -> Alias<'a, ()> {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: could not find defining uses\n-  --> $DIR/issue-68368-non-defining-use.rs:7:1\n+   |               ^^^^^^^^^^^^^\n+   |\n+note: used non-generic type `()` for generic parameter\n+  --> $DIR/issue-68368-non-defining-use.rs:7:16\n    |\n LL | type Alias<'a, U> = impl Trait<U>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                ^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "02485b24e7b8a5fc3d0c04658a2dc880b71fd28e", "filename": "src/test/ui/type-alias-impl-trait/not_a_defining_use.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.rs?ref=49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "patch": "@@ -7,7 +7,6 @@ fn main() {}\n type Two<T, U> = impl Debug;\n \n fn two<T: Debug>(t: T) -> Two<T, u32> {\n-    //~^ ERROR defining opaque type use does not fully define opaque type\n     (t, 4i8)\n }\n "}, {"sha": "cce861b76c95e8b717b276b790c8b47c0d5dda8f", "filename": "src/test/ui/type-alias-impl-trait/not_a_defining_use.stderr", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.stderr?ref=49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "patch": "@@ -1,27 +1,18 @@\n-error: defining opaque type use does not fully define opaque type: generic parameter `U` is specified as concrete type `u32`\n-  --> $DIR/not_a_defining_use.rs:9:1\n-   |\n-LL | / fn two<T: Debug>(t: T) -> Two<T, u32> {\n-LL | |\n-LL | |     (t, 4i8)\n-LL | | }\n-   | |_^\n-\n error: concrete type differs from previous defining opaque type use\n-  --> $DIR/not_a_defining_use.rs:30:1\n+  --> $DIR/not_a_defining_use.rs:29:1\n    |\n LL | / fn four<T: Debug, U: Bar>(t: T) -> Two<T, U> {\n LL | |     (t, <U as Bar>::FOO)\n LL | | }\n    | |_^ expected `(T, i8)`, got `(T, <U as Bar>::Blub)`\n    |\n note: previous use here\n-  --> $DIR/not_a_defining_use.rs:14:1\n+  --> $DIR/not_a_defining_use.rs:9:1\n    |\n-LL | / fn three<T: Debug, U>(t: T) -> Two<T, U> {\n-LL | |     (t, 5i8)\n+LL | / fn two<T: Debug>(t: T) -> Two<T, u32> {\n+LL | |     (t, 4i8)\n LL | | }\n    | |_^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}]}