{"sha": "bdcb9d9b531c8dc6962d854edfeeeeb9477b40b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkY2I5ZDliNTMxYzhkYzY5NjJkODU0ZWRmZWVlZWI5NDc3YjQwYjI=", "commit": {"author": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-01-14T04:19:42Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-14T19:10:06Z"}, "message": "Make lookup non recursive and instead move the recursion just to\nfind_final_def. Use the fact that the recursion is in a simpler function to\ndetected import loops and exit.", "tree": {"sha": "80bf58b48a95ec566154c8726713dd4b3c4f1e29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80bf58b48a95ec566154c8726713dd4b3c4f1e29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdcb9d9b531c8dc6962d854edfeeeeb9477b40b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdcb9d9b531c8dc6962d854edfeeeeb9477b40b2", "html_url": "https://github.com/rust-lang/rust/commit/bdcb9d9b531c8dc6962d854edfeeeeb9477b40b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdcb9d9b531c8dc6962d854edfeeeeb9477b40b2/comments", "author": null, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3c3fc03537d9aca36b0ce5956ab8d5b760784b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3c3fc03537d9aca36b0ce5956ab8d5b760784b4", "html_url": "https://github.com/rust-lang/rust/commit/f3c3fc03537d9aca36b0ce5956ab8d5b760784b4"}], "stats": {"total": 150, "additions": 90, "deletions": 60}, "files": [{"sha": "6bb40a98d4ba86d8e98c8af5ca3cda7f602a6c03", "filename": "src/Makefile", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdcb9d9b531c8dc6962d854edfeeeeb9477b40b2/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bdcb9d9b531c8dc6962d854edfeeeeb9477b40b2/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=bdcb9d9b531c8dc6962d854edfeeeeb9477b40b2", "patch": "@@ -405,6 +405,7 @@ TEST_XFAILS_BOOT :=  $(TASK_XFAILS) \\\n                     test/compile-fail/import.rs \\\n                     test/compile-fail/import2.rs \\\n                     test/compile-fail/import3.rs \\\n+                    test/compile-fail/import4.rs \\\n                     test/compile-fail/bad-recv.rs \\\n                     test/compile-fail/bad-send.rs \\\n                     test/compile-fail/infinite-vec-type-recursion.rs \\\n@@ -485,6 +486,7 @@ TEST_XFAILS_RUSTC := $(filter-out \\\n                         import.rs \\\n                         import2.rs \\\n                         import3.rs \\\n+                        import4.rs \\\n                         while-type-error.rs \\\n                         ), \\\n                       $(wildcard test/*/*.rs test/*/*.rc))"}, {"sha": "a318c779547231d912472aa26c07517d34901422", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 88, "deletions": 60, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/bdcb9d9b531c8dc6962d854edfeeeeb9477b40b2/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdcb9d9b531c8dc6962d854edfeeeeb9477b40b2/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=bdcb9d9b531c8dc6962d854edfeeeeb9477b40b2", "patch": "@@ -25,17 +25,20 @@ tag scope {\n type env = rec(list[scope] scopes,\n                session.session sess);\n \n-type import_map = std.map.hashmap[ast.def_id,def_wrap];\n+type import_map = std.map.hashmap[ast.def_id,def];\n \n // A simple wrapper over defs that stores a bit more information about modules\n // and uses so that we can use the regular lookup_name when resolving imports.\n tag def_wrap {\n     def_wrap_use(@ast.view_item);\n+    def_wrap_import(@ast.view_item);\n     def_wrap_mod(@ast.item);\n     def_wrap_other(def);\n }\n \n-fn unwrap_def(option.t[def_wrap] d_) -> option.t[def] {\n+fn lookup_name(&env e, import_map index,\n+               ast.ident i) -> option.t[def] {\n+    auto d_ = lookup_name_wrapped(e, i);\n     alt (d_) {\n         case (none[def_wrap]) {\n             ret none[def];\n@@ -48,62 +51,93 @@ fn unwrap_def(option.t[def_wrap] d_) -> option.t[def] {\n                             ret some[def](ast.def_use(id));\n                         }\n                     }\n-                    fail;\n+                }\n+                case (def_wrap_import(?it)) {\n+                    alt (it.node) {\n+                        case (ast.view_item_import(_, ?id)) {\n+                            ret index.find(id);\n+                        }\n+                    }\n                 }\n                 case (def_wrap_mod(?i)) {\n                     alt (i.node) {\n                         case (ast.item_mod(_, _, ?id)) {\n                             ret some[def](ast.def_mod(id));\n                         }\n                     }\n-                    fail;\n                 }\n                 case (def_wrap_other(?d)) {\n                     ret some[def](d);\n                 }\n             }\n         }\n     }\n-    fail;\n }\n \n // Follow the path of an import and return what it ultimately points to.\n \n-fn find_final_def(&env e, &span sp, vec[ident] idents) -> option.t[def_wrap] {\n-    auto len = _vec.len[ident](idents);\n-    auto first = idents.(0);\n-    auto d_ = lookup_name(e, none[import_map], first);\n-    if (len == 1u) {\n-        ret d_;\n-    }\n-    alt (d_) {\n-        case (none[def_wrap]) {\n-            e.sess.span_err(sp, \"unresolved name: \" + first);\n-            ret d_;\n-        }\n-        case (some[def_wrap](?d)) {\n-            alt (d) {\n-                case (def_wrap_mod(?i)) {\n-                    auto new_idents = _vec.slice[ident](idents, 1u, len);\n-                    auto tmp_e = rec(scopes = nil[scope],\n-                                     sess = e.sess);\n-                    auto new_e = update_env_for_item(tmp_e, i);\n-                    ret find_final_def(new_e, sp, new_idents);\n-                }\n-                case (def_wrap_use(?c)) {\n-                    e.sess.span_err(sp, \"Crate access is not implemented\");\n-                }\n-                case (_) {\n-                    e.sess.span_err(sp, first + \" is not a module or crate\");\n+fn find_final_def(&env e, &span sp, vec[ident] idents) -> def_wrap {\n+    fn found_something(&env e, std.map.hashmap[ast.def_id, bool] pending,\n+                       &span sp, vec[ident] idents, def_wrap d) -> def_wrap {\n+        alt (d) {\n+            case (def_wrap_import(?imp)) {\n+                alt (imp.node) {\n+                    case (ast.view_item_import(?new_idents, ?d)) {\n+                        if (pending.contains_key(d)) {\n+                            e.sess.span_err(sp,\n+                                            \"recursive import\");\n+                            fail;\n+                        }\n+                        pending.insert(d, true);\n+                        auto x = inner(e, pending, sp, new_idents);\n+                        ret found_something(e, pending, sp, idents, x);\n+                    }\n                 }\n             }\n+            case (_) {\n+            }\n+        }\n+        auto len = _vec.len[ident](idents);\n+        if (len == 1u) {\n+            ret d;\n+        }\n+        alt (d) {\n+            case (def_wrap_mod(?i)) {\n+                auto new_idents = _vec.slice[ident](idents, 1u, len);\n+                auto tmp_e = rec(scopes = nil[scope],\n+                                 sess = e.sess);\n+                auto new_e = update_env_for_item(tmp_e, i);\n+                ret inner(new_e, pending, sp, new_idents);\n+            }\n+            case (def_wrap_use(?c)) {\n+                e.sess.span_err(sp, \"Crate access is not implemented\");\n+            }\n+            case (_) {\n+                auto first = idents.(0);\n+                e.sess.span_err(sp, first + \" is not a module or crate\");\n+            }\n+        }\n+        fail;\n+    }\n+    fn inner(&env e, std.map.hashmap[ast.def_id, bool] pending,\n+             &span sp, vec[ident] idents) -> def_wrap {\n+        auto first = idents.(0);\n+        auto d_ = lookup_name_wrapped(e, first);\n+        alt (d_) {\n+            case (none[def_wrap]) {\n+                e.sess.span_err(sp, \"unresolved name: \" + first);\n+                fail;\n+            }\n+            case (some[def_wrap](?d)) {\n+                ret found_something(e, pending, sp, idents, d);\n+            }\n         }\n     }\n-    fail;\n+    auto pending = new_def_hash[bool]();\n+    ret inner(e, pending, sp, idents);\n }\n \n-fn lookup_name(&env e, option.t[import_map] index,\n-               ast.ident i) -> option.t[def_wrap] {\n+fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[def_wrap] {\n \n     // log \"resolving name \" + i;\n \n@@ -147,33 +181,24 @@ fn lookup_name(&env e, option.t[import_map] index,\n         ret none[def_wrap];\n     }\n \n-    fn found_def_view(&env e, option.t[import_map] index,\n-                      @ast.view_item i) -> option.t[def_wrap] {\n+    fn found_def_view(&env e, @ast.view_item i) -> option.t[def_wrap] {\n         alt (i.node) {\n             case (ast.view_item_use(_, _, ?id)) {\n                 ret some[def_wrap](def_wrap_use(i));\n             }\n             case (ast.view_item_import(?idents,?d)) {\n-                alt (index) {\n-                    case (some[import_map](?idx)) {\n-                        ret idx.find(d);\n-                    }\n-                    case (none[import_map]) {\n-                        ret find_final_def(e, i.span, idents);\n-                    }\n-                }\n+                ret some[def_wrap](def_wrap_import(i));\n             }\n         }\n         fail;\n     }\n \n-    fn check_mod(&env e, option.t[import_map] index, ast.ident i,\n-                 ast._mod m) -> option.t[def_wrap] {\n+    fn check_mod(&env e, ast.ident i, ast._mod m) -> option.t[def_wrap] {\n         alt (m.index.find(i)) {\n             case (some[ast.mod_index_entry](?ent)) {\n                 alt (ent) {\n                     case (ast.mie_view_item(?view_item)) {\n-                        ret found_def_view(e, index, view_item);\n+                        ret found_def_view(e, view_item);\n                     }\n                     case (ast.mie_item(?item)) {\n                         ret found_def_item(item);\n@@ -199,12 +224,11 @@ fn lookup_name(&env e, option.t[import_map] index,\n     }\n \n \n-    fn in_scope(ast.ident i, env e, option.t[import_map] index,\n-                &scope s) -> option.t[def_wrap] {\n+    fn in_scope(ast.ident i, env e, &scope s) -> option.t[def_wrap] {\n         alt (s) {\n \n             case (scope_crate(?c)) {\n-                ret check_mod(e, index, i, c.node.module);\n+                ret check_mod(e, i, c.node.module);\n             }\n \n             case (scope_item(?it)) {\n@@ -238,7 +262,7 @@ fn lookup_name(&env e, option.t[import_map] index,\n                         }\n                     }\n                     case (ast.item_mod(_, ?m, _)) {\n-                        ret check_mod(e, index, i, m);\n+                        ret check_mod(e, i, m);\n                     }\n                     case (_) { /* fall through */ }\n                 }\n@@ -267,14 +291,14 @@ fn lookup_name(&env e, option.t[import_map] index,\n     }\n \n     ret std.list.find[scope,def_wrap](e.scopes,\n-                                      bind in_scope(i, e, index, _));\n+                                      bind in_scope(i, e, _));\n }\n \n fn fold_pat_tag(&env e, &span sp, import_map index, ident i,\n                 vec[@ast.pat] args, option.t[ast.variant_def] old_def,\n                 ann a) -> @ast.pat {\n     auto new_def;\n-    alt (unwrap_def(lookup_name(e, some(index), i))) {\n+    alt (lookup_name(e, index, i)) {\n         case (some[def](?d)) {\n             alt (d) {\n                 case (ast.def_variant(?did, ?vid)) {\n@@ -327,7 +351,7 @@ fn fold_expr_path(&env e, &span sp, import_map index,\n     check (n_idents != 0u);\n     auto id0 = p.node.idents.(0);\n \n-    auto d_ = unwrap_def(lookup_name(e, some(index), id0));\n+    auto d_ = lookup_name(e, index, id0);\n \n     alt (d_) {\n         case (some[def](_)) {\n@@ -362,11 +386,15 @@ fn fold_view_item_import(&env e, &span sp,\n     auto last_id = is.(len - 1u);\n     auto d = find_final_def(e, sp, is);\n     alt (d) {\n-        case (none[def_wrap]) {\n-            e.sess.span_err(sp, \"unresolved name: \" + last_id);\n+        case (def_wrap_mod(?m)) {\n+            alt (m.node) {\n+                case (ast.item_mod(_, _, ?id)) {\n+                    index.insert(id, ast.def_mod(id));\n+                }\n+            }\n         }\n-        case (some[def_wrap](?d2)) {\n-            index.insert(id, d2);\n+        case (def_wrap_other(?target_def)) {\n+            index.insert(id, target_def);\n         }\n     }\n \n@@ -387,7 +415,7 @@ fn fold_ty_path(&env e, &span sp, import_map index, ast.path p,\n         e.sess.unimpl(\"resolving path ty with ty params\");\n     }\n \n-    auto d_ = unwrap_def(lookup_name(e, some(index), p.node.idents.(0)));\n+    auto d_ = lookup_name(e, index, p.node.idents.(0));\n \n     alt (d_) {\n         case (some[def](?d)) {\n@@ -421,7 +449,7 @@ fn resolve_crate(session.session sess, @ast.crate crate) -> @ast.crate {\n \n     let fold.ast_fold[env] fld = fold.new_identity_fold[env]();\n \n-    auto import_index = new_def_hash[def_wrap]();\n+    auto import_index = new_def_hash[def]();\n     fld = @rec( fold_pat_tag = bind fold_pat_tag(_,_,import_index,_,_,_,_),\n                 fold_expr_path = bind fold_expr_path(_,_,import_index,_,_,_),\n                 fold_view_item_import"}]}