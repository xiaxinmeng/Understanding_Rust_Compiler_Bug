{"sha": "eeb8c8d59c1ca43999a6d7bd5f46a0a54971303f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlYjhjOGQ1OWMxY2E0Mzk5OWE2ZDdiZDVmNDZhMGE1NDk3MTMwM2Y=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-12-01T12:27:45Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-12-16T23:59:32Z"}, "message": "cleanup `deduce_expectations_from_obligations`", "tree": {"sha": "8aef899c35d5a077429e046882ba56f63db09bfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8aef899c35d5a077429e046882ba56f63db09bfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eeb8c8d59c1ca43999a6d7bd5f46a0a54971303f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eeb8c8d59c1ca43999a6d7bd5f46a0a54971303f", "html_url": "https://github.com/rust-lang/rust/commit/eeb8c8d59c1ca43999a6d7bd5f46a0a54971303f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eeb8c8d59c1ca43999a6d7bd5f46a0a54971303f/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4dc1c5d64d5439ba8b70f93490d7dc8ee512c7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4dc1c5d64d5439ba8b70f93490d7dc8ee512c7e", "html_url": "https://github.com/rust-lang/rust/commit/f4dc1c5d64d5439ba8b70f93490d7dc8ee512c7e"}], "stats": {"total": 41, "additions": 16, "deletions": 25}, "files": [{"sha": "f599a2b2ece07aebd033467cff132c03671cab2b", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/eeb8c8d59c1ca43999a6d7bd5f46a0a54971303f/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb8c8d59c1ca43999a6d7bd5f46a0a54971303f/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=eeb8c8d59c1ca43999a6d7bd5f46a0a54971303f", "patch": "@@ -219,14 +219,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         expected_vid: ty::TyVid,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n-        let fulfillment_cx = self.fulfillment_cx.borrow();\n-        // Here `expected_ty` is known to be a type inference variable.\n-\n-        let expected_vid = self.root_var(expected_vid);\n-        let expected_sig = fulfillment_cx\n-            .pending_obligations()\n-            .iter()\n-            .filter_map(|obligation| {\n+        let expected_sig = self.obligations_for_self_ty(expected_vid)\n+            .find_map(|(_, obligation)| {\n                 debug!(\n                     \"deduce_expectations_from_obligations: obligation.predicate={:?}\",\n                     obligation.predicate\n@@ -235,27 +229,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if let ty::Predicate::Projection(ref proj_predicate) = obligation.predicate {\n                     // Given a Projection predicate, we can potentially infer\n                     // the complete signature.\n-                    let trait_ref = proj_predicate.to_poly_trait_ref(self.tcx);\n-                    Some(()).filter(|()| {\n-                        self.self_type_matches_expected_vid(trait_ref, expected_vid)\n-                    }).and_then(|()| {\n-                        self.deduce_sig_from_projection(\n-                            Some(obligation.cause.span),\n-                            proj_predicate\n-                        )\n-                    })\n+                    self.deduce_sig_from_projection(\n+                        Some(obligation.cause.span),\n+                        proj_predicate\n+                    )\n                 } else {\n                     None\n                 }\n-            })\n-            .next();\n+            });\n \n         // Even if we can't infer the full signature, we may be able to\n         // infer the kind. This can occur if there is a trait-reference\n         // like `F : Fn<A>`. Note that due to subtyping we could encounter\n         // many viable options, so pick the most restrictive.\n         let expected_kind = self.obligations_for_self_ty(expected_vid)\n-            .filter_map(|tr| self.tcx.lang_items().fn_trait_kind(tr.def_id()))\n+            .filter_map(|(tr, _)| self.tcx.lang_items().fn_trait_kind(tr.def_id()))\n             .fold(None, |best, cur| {\n                 Some(best.map_or(cur, |best| cmp::min(best, cur)))\n             });"}, {"sha": "a8711d73af8ca0c1cec273908e03ac7c9f59be03", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/eeb8c8d59c1ca43999a6d7bd5f46a0a54971303f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb8c8d59c1ca43999a6d7bd5f46a0a54971303f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=eeb8c8d59c1ca43999a6d7bd5f46a0a54971303f", "patch": "@@ -2753,7 +2753,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn obligations_for_self_ty<'b>(&'b self, self_ty: ty::TyVid)\n-        -> impl Iterator<Item=ty::PolyTraitRef<'tcx>> + Captures<'gcx> + 'b\n+        -> impl Iterator<Item=(ty::PolyTraitRef<'tcx>, traits::PredicateObligation<'tcx>)>\n+           + Captures<'gcx> + 'b\n     {\n         let ty_var_root = self.root_var(self_ty);\n         debug!(\"obligations_for_self_ty: self_ty={:?} ty_var_root={:?} pending_obligations={:?}\",\n@@ -2765,8 +2766,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             .pending_obligations()\n             .into_iter()\n             .filter_map(move |obligation| match obligation.predicate {\n-                ty::Predicate::Projection(ref data) => Some(data.to_poly_trait_ref(self.tcx)),\n-                ty::Predicate::Trait(ref data) => Some(data.to_poly_trait_ref()),\n+                ty::Predicate::Projection(ref data) =>\n+                    Some((data.to_poly_trait_ref(self.tcx), obligation)),\n+                ty::Predicate::Trait(ref data) =>\n+                    Some((data.to_poly_trait_ref(), obligation)),\n                 ty::Predicate::Subtype(..) => None,\n                 ty::Predicate::RegionOutlives(..) => None,\n                 ty::Predicate::TypeOutlives(..) => None,\n@@ -2782,11 +2785,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // code is looking for a self type of a unresolved\n                 // inference variable.\n                 ty::Predicate::ClosureKind(..) => None,\n-            }).filter(move |tr| self.self_type_matches_expected_vid(*tr, ty_var_root))\n+            }).filter(move |(tr, _)| self.self_type_matches_expected_vid(*tr, ty_var_root))\n     }\n \n     fn type_var_is_sized(&self, self_ty: ty::TyVid) -> bool {\n-        self.obligations_for_self_ty(self_ty).any(|tr| {\n+        self.obligations_for_self_ty(self_ty).any(|(tr, _)| {\n             Some(tr.def_id()) == self.tcx.lang_items().sized_trait()\n         })\n     }"}]}