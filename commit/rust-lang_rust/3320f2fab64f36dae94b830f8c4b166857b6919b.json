{"sha": "3320f2fab64f36dae94b830f8c4b166857b6919b", "node_id": "C_kwDOAAsO6NoAKDMzMjBmMmZhYjY0ZjM2ZGFlOTRiODMwZjhjNGIxNjY4NTdiNjkxOWI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-05T04:48:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-05T04:48:50Z"}, "message": "Auto merge of #111231 - JohnTitor:rollup-a25ff8v, r=JohnTitor\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #110946 (avoid duplicating TLS state between test std and realstd)\n - #110954 (Reject borrows of projections in ConstProp.)\n - #111052 (Fix problems with backtraces in two ui tests.)\n - #111132 (cleanup nll generalizer)\n - #111173 (Still more encoder cleanups)\n - #111187 (bootstrap: add llvm-project/runtimes to the sources)\n - #111213 (Fixup \"since\" dates for `array_tuple_conv` feature)\n - #111223 (Use `free-args` consistently in bootstrap)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "ed35a767748983cfed5de4965d86393c393a9656", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed35a767748983cfed5de4965d86393c393a9656"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3320f2fab64f36dae94b830f8c4b166857b6919b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3320f2fab64f36dae94b830f8c4b166857b6919b", "html_url": "https://github.com/rust-lang/rust/commit/3320f2fab64f36dae94b830f8c4b166857b6919b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3320f2fab64f36dae94b830f8c4b166857b6919b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d", "html_url": "https://github.com/rust-lang/rust/commit/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d"}, {"sha": "650dc01a644c0429cd4853749f9077ce353b29e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/650dc01a644c0429cd4853749f9077ce353b29e6", "html_url": "https://github.com/rust-lang/rust/commit/650dc01a644c0429cd4853749f9077ce353b29e6"}], "stats": {"total": 554, "additions": 238, "deletions": 316}, "files": [{"sha": "315303b25fe4e0e0bf18e1c6a71335d6e4e6ab4f", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -498,11 +498,11 @@ impl<'cx, 'tcx> BorrowckInferCtxt<'cx, 'tcx> {\n         let next_region = self.infcx.next_region_var(origin);\n         let vid = next_region.as_var();\n \n-        if cfg!(debug_assertions) && !self.inside_canonicalization_ctxt() {\n+        if cfg!(debug_assertions) {\n             debug!(\"inserting vid {:?} with origin {:?} into var_to_origin\", vid, origin);\n             let ctxt = get_ctxt_fn();\n             let mut var_to_origin = self.reg_var_to_origin.borrow_mut();\n-            var_to_origin.insert(vid, ctxt);\n+            assert_eq!(var_to_origin.insert(vid, ctxt), None);\n         }\n \n         next_region\n@@ -520,11 +520,11 @@ impl<'cx, 'tcx> BorrowckInferCtxt<'cx, 'tcx> {\n         let next_region = self.infcx.next_nll_region_var(origin);\n         let vid = next_region.as_var();\n \n-        if cfg!(debug_assertions) && !self.inside_canonicalization_ctxt() {\n+        if cfg!(debug_assertions) {\n             debug!(\"inserting vid {:?} with origin {:?} into var_to_origin\", vid, origin);\n             let ctxt = get_ctxt_fn();\n             let mut var_to_origin = self.reg_var_to_origin.borrow_mut();\n-            var_to_origin.insert(vid, ctxt);\n+            assert_eq!(var_to_origin.insert(vid, ctxt), None);\n         }\n \n         next_region"}, {"sha": "7158c62b548afb00250172969d09bea8e5dcbbfe", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -131,9 +131,13 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n             ty::BoundRegionKind::BrEnv => BoundRegionInfo::Name(sym::env),\n         };\n \n-        if cfg!(debug_assertions) && !self.type_checker.infcx.inside_canonicalization_ctxt() {\n+        if cfg!(debug_assertions) {\n             let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n-            var_to_origin.insert(reg.as_var(), RegionCtxt::Placeholder(reg_info));\n+            let new = RegionCtxt::Placeholder(reg_info);\n+            let prev = var_to_origin.insert(reg.as_var(), new);\n+            if let Some(prev) = prev {\n+                assert_eq!(new, prev);\n+            }\n         }\n \n         reg\n@@ -146,9 +150,10 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n             universe,\n         );\n \n-        if cfg!(debug_assertions) && !self.type_checker.infcx.inside_canonicalization_ctxt() {\n+        if cfg!(debug_assertions) {\n             let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n-            var_to_origin.insert(reg.as_var(), RegionCtxt::Existential(None));\n+            let prev = var_to_origin.insert(reg.as_var(), RegionCtxt::Existential(None));\n+            assert_eq!(prev, None);\n         }\n \n         reg"}, {"sha": "0c8854e962abb85a8f55bb743156b8959dd11ba3", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -30,8 +30,6 @@ use super::*;\n use rustc_middle::ty::relate::{Relate, TypeRelation};\n use rustc_middle::ty::{Const, ImplSubject};\n \n-use std::cell::Cell;\n-\n /// Whether we should define opaque types or just treat them opaquely.\n ///\n /// Currently only used to prevent predicate matching from matching anything\n@@ -84,7 +82,6 @@ impl<'tcx> InferCtxt<'tcx> {\n             in_snapshot: self.in_snapshot.clone(),\n             universe: self.universe.clone(),\n             intercrate: self.intercrate,\n-            inside_canonicalization_ctxt: Cell::new(self.inside_canonicalization_ctxt()),\n         }\n     }\n }"}, {"sha": "427d05c8b4da7d14e300b7a10418ac88544d8192", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -561,8 +561,6 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n     where\n         V: TypeFoldable<TyCtxt<'tcx>>,\n     {\n-        let _inside_canonical_ctxt_guard = infcx.set_canonicalization_ctxt();\n-\n         let needs_canonical_flags = if canonicalize_region_mode.any() {\n             TypeFlags::HAS_INFER |\n             TypeFlags::HAS_FREE_REGIONS | // `HAS_RE_PLACEHOLDER` implies `HAS_FREE_REGIONS`"}, {"sha": "a89b9931599023f88ce753ec16dc9f52faaa962e", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -39,7 +39,6 @@ use rustc_span::Span;\n \n use std::cell::{Cell, RefCell};\n use std::fmt;\n-use std::ops::Drop;\n \n use self::combine::CombineFields;\n use self::error_reporting::TypeErrCtxt;\n@@ -342,11 +341,6 @@ pub struct InferCtxt<'tcx> {\n     /// there is no type that the user could *actually name* that\n     /// would satisfy it. This avoids crippling inference, basically.\n     pub intercrate: bool,\n-\n-    /// Flag that is set when we enter canonicalization. Used for debugging to ensure\n-    /// that we only collect region information for `BorrowckInferCtxt::reg_var_to_origin`\n-    /// inside non-canonicalization contexts.\n-    inside_canonicalization_ctxt: Cell<bool>,\n }\n \n /// See the `error_reporting` module for more details.\n@@ -638,7 +632,6 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             skip_leak_check: Cell::new(false),\n             universe: Cell::new(ty::UniverseIndex::ROOT),\n             intercrate,\n-            inside_canonicalization_ctxt: Cell::new(false),\n         }\n     }\n }\n@@ -1636,31 +1629,6 @@ impl<'tcx> InferCtxt<'tcx> {\n             }\n         }\n     }\n-\n-    pub fn inside_canonicalization_ctxt(&self) -> bool {\n-        self.inside_canonicalization_ctxt.get()\n-    }\n-\n-    pub fn set_canonicalization_ctxt(&self) -> CanonicalizationCtxtGuard<'_, 'tcx> {\n-        let prev_ctxt = self.inside_canonicalization_ctxt();\n-        self.inside_canonicalization_ctxt.set(true);\n-        CanonicalizationCtxtGuard { prev_ctxt, infcx: self }\n-    }\n-\n-    fn set_canonicalization_ctxt_to(&self, ctxt: bool) {\n-        self.inside_canonicalization_ctxt.set(ctxt);\n-    }\n-}\n-\n-pub struct CanonicalizationCtxtGuard<'cx, 'tcx> {\n-    prev_ctxt: bool,\n-    infcx: &'cx InferCtxt<'tcx>,\n-}\n-\n-impl<'cx, 'tcx> Drop for CanonicalizationCtxtGuard<'cx, 'tcx> {\n-    fn drop(&mut self) {\n-        self.infcx.set_canonicalization_ctxt_to(self.prev_ctxt)\n-    }\n }\n \n impl<'tcx> TypeErrCtxt<'_, 'tcx> {"}, {"sha": "88a0a81e276d27e4de74e32a48f864af3afdeddc", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 7, "deletions": 68, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -30,11 +30,10 @@ use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::FnMutDelegate;\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use rustc_middle::ty::visit::{TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor};\n+use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{self, InferConst, Ty, TyCtxt};\n use rustc_span::{Span, Symbol};\n use std::fmt::Debug;\n-use std::ops::ControlFlow;\n \n use super::combine::ObligationEmittingRelation;\n \n@@ -115,11 +114,6 @@ pub trait TypeRelatingDelegate<'tcx> {\n     fn forbid_inference_vars() -> bool;\n }\n \n-#[derive(Clone, Debug, Default)]\n-struct BoundRegionScope<'tcx> {\n-    map: FxHashMap<ty::BoundRegion, ty::Region<'tcx>>,\n-}\n-\n #[derive(Copy, Clone)]\n struct UniversallyQuantified(bool);\n \n@@ -230,10 +224,13 @@ where\n     ) -> RelateResult<'tcx, T> {\n         let universe = self.infcx.probe_ty_var(for_vid).unwrap_err();\n \n+        if value.has_escaping_bound_vars() {\n+            bug!(\"trying to instantiate {for_vid:?} with escaping bound vars: {value:?}\");\n+        }\n+\n         let mut generalizer = TypeGeneralizer {\n             infcx: self.infcx,\n             delegate: &mut self.delegate,\n-            first_free_index: ty::INNERMOST,\n             ambient_variance: self.ambient_variance,\n             for_vid_sub_root: self.infcx.inner.borrow_mut().type_variables().sub_root_var(for_vid),\n             universe,\n@@ -488,13 +485,7 @@ where\n         }\n \n         if a == b {\n-            // Subtle: if a or b has a bound variable that we are lazily\n-            // substituting, then even if a == b, it could be that the values we\n-            // will substitute for those bound variables are *not* the same, and\n-            // hence returning `Ok(a)` is incorrect.\n-            if !a.has_escaping_bound_vars() && !b.has_escaping_bound_vars() {\n-                return Ok(a);\n-            }\n+            return Ok(a);\n         }\n \n         match (a.kind(), b.kind()) {\n@@ -726,47 +717,6 @@ where\n     }\n }\n \n-/// When we encounter a binder like `for<..> fn(..)`, we actually have\n-/// to walk the `fn` value to find all the values bound by the `for`\n-/// (these are not explicitly present in the ty representation right\n-/// now). This visitor handles that: it descends the type, tracking\n-/// binder depth, and finds late-bound regions targeting the\n-/// `for<..`>. For each of those, it creates an entry in\n-/// `bound_region_scope`.\n-struct ScopeInstantiator<'me, 'tcx> {\n-    next_region: &'me mut dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n-    // The debruijn index of the scope we are instantiating.\n-    target_index: ty::DebruijnIndex,\n-    bound_region_scope: &'me mut BoundRegionScope<'tcx>,\n-}\n-\n-impl<'me, 'tcx> TypeVisitor<TyCtxt<'tcx>> for ScopeInstantiator<'me, 'tcx> {\n-    fn visit_binder<T: TypeVisitable<TyCtxt<'tcx>>>(\n-        &mut self,\n-        t: &ty::Binder<'tcx, T>,\n-    ) -> ControlFlow<Self::BreakTy> {\n-        self.target_index.shift_in(1);\n-        t.super_visit_with(self);\n-        self.target_index.shift_out(1);\n-\n-        ControlFlow::Continue(())\n-    }\n-\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        let ScopeInstantiator { bound_region_scope, next_region, .. } = self;\n-\n-        match *r {\n-            ty::ReLateBound(debruijn, br) if debruijn == self.target_index => {\n-                bound_region_scope.map.entry(br).or_insert_with(|| next_region(br));\n-            }\n-\n-            _ => {}\n-        }\n-\n-        ControlFlow::Continue(())\n-    }\n-}\n-\n /// The \"type generalizer\" is used when handling inference variables.\n ///\n /// The basic strategy for handling a constraint like `?A <: B` is to\n@@ -780,11 +730,6 @@ impl<'me, 'tcx> TypeVisitor<TyCtxt<'tcx>> for ScopeInstantiator<'me, 'tcx> {\n /// value of `A`. Finally, we relate `&'0 u32 <: &'x u32`, which\n /// establishes `'0: 'x` as a constraint.\n ///\n-/// As a side-effect of this generalization procedure, we also replace\n-/// all the bound regions that we have traversed with concrete values,\n-/// so that the resulting generalized type is independent from the\n-/// scopes.\n-///\n /// [blog post]: https://is.gd/0hKvIr\n struct TypeGeneralizer<'me, 'tcx, D>\n where\n@@ -798,8 +743,6 @@ where\n     /// some other type. What will be the variance at this point?\n     ambient_variance: ty::Variance,\n \n-    first_free_index: ty::DebruijnIndex,\n-\n     /// The vid of the type variable that is in the process of being\n     /// instantiated. If we find this within the value we are folding,\n     /// that means we would have created a cyclic value.\n@@ -939,7 +882,7 @@ where\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n         debug!(\"TypeGeneralizer::regions(a={:?})\", a);\n \n-        if let ty::ReLateBound(debruijn, _) = *a && debruijn < self.first_free_index {\n+        if let ty::ReLateBound(..) = *a {\n             return Ok(a);\n         }\n \n@@ -958,7 +901,6 @@ where\n         // FIXME(#54105) -- if the ambient variance is bivariant,\n         // though, we may however need to check well-formedness or\n         // risk a problem like #41677 again.\n-\n         let replacement_region_vid = self.delegate.generalize_existential(self.universe);\n \n         Ok(replacement_region_vid)\n@@ -1002,10 +944,7 @@ where\n         T: Relate<'tcx>,\n     {\n         debug!(\"TypeGeneralizer::binders(a={:?})\", a);\n-\n-        self.first_free_index.shift_in(1);\n         let result = self.relate(a.skip_binder(), a.skip_binder())?;\n-        self.first_free_index.shift_out(1);\n         Ok(a.rebind(result))\n     }\n }"}, {"sha": "82c66b9dfb9f69865d904c1fff98dc507fd1b8a2", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -108,11 +108,7 @@ impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n         emit_i64(i64);\n         emit_i32(i32);\n         emit_i16(i16);\n-        emit_i8(i8);\n \n-        emit_bool(bool);\n-        emit_char(char);\n-        emit_str(&str);\n         emit_raw_bytes(&[u8]);\n     }\n }"}, {"sha": "220118ae5ccb8d77cc3c8cd9df4b9fee3fdf7b6c", "filename": "compiler/rustc_middle/src/query/on_disk_cache.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fon_disk_cache.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -1026,11 +1026,7 @@ impl<'a, 'tcx> Encoder for CacheEncoder<'a, 'tcx> {\n         emit_i64(i64);\n         emit_i32(i32);\n         emit_i16(i16);\n-        emit_i8(i8);\n \n-        emit_bool(bool);\n-        emit_char(char);\n-        emit_str(&str);\n         emit_raw_bytes(&[u8]);\n     }\n }"}, {"sha": "7fc75674da53717961d9c6026240b1e0bb770690", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -506,23 +506,18 @@ macro_rules! implement_ty_decoder {\n \n             impl<$($typaram ),*> Decoder for $DecoderName<$($typaram),*> {\n                 $crate::__impl_decoder_methods! {\n+                    read_usize -> usize;\n                     read_u128 -> u128;\n                     read_u64 -> u64;\n                     read_u32 -> u32;\n                     read_u16 -> u16;\n                     read_u8 -> u8;\n-                    read_usize -> usize;\n \n+                    read_isize -> isize;\n                     read_i128 -> i128;\n                     read_i64 -> i64;\n                     read_i32 -> i32;\n                     read_i16 -> i16;\n-                    read_i8 -> i8;\n-                    read_isize -> isize;\n-\n-                    read_bool -> bool;\n-                    read_char -> char;\n-                    read_str -> &str;\n                 }\n \n                 #[inline]\n@@ -531,13 +526,13 @@ macro_rules! implement_ty_decoder {\n                 }\n \n                 #[inline]\n-                fn position(&self) -> usize {\n-                    self.opaque.position()\n+                fn peek_byte(&self) -> u8 {\n+                    self.opaque.peek_byte()\n                 }\n \n                 #[inline]\n-                fn peek_byte(&self) -> u8 {\n-                    self.opaque.peek_byte()\n+                fn position(&self) -> usize {\n+                    self.opaque.position()\n                 }\n             }\n         }"}, {"sha": "7f995c69a4879cbbf47780f9e0c4902ae7c6f11f", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -714,13 +714,22 @@ impl CanConstProp {\n     }\n }\n \n-impl Visitor<'_> for CanConstProp {\n+impl<'tcx> Visitor<'tcx> for CanConstProp {\n+    fn visit_place(&mut self, place: &Place<'tcx>, mut context: PlaceContext, loc: Location) {\n+        use rustc_middle::mir::visit::PlaceContext::*;\n+\n+        // Dereferencing just read the addess of `place.local`.\n+        if place.projection.first() == Some(&PlaceElem::Deref) {\n+            context = NonMutatingUse(NonMutatingUseContext::Copy);\n+        }\n+\n+        self.visit_local(place.local, context, loc);\n+        self.visit_projection(place.as_ref(), context, loc);\n+    }\n+\n     fn visit_local(&mut self, local: Local, context: PlaceContext, _: Location) {\n         use rustc_middle::mir::visit::PlaceContext::*;\n         match context {\n-            // Projections are fine, because `&mut foo.x` will be caught by\n-            // `MutatingUseContext::Borrow` elsewhere.\n-            MutatingUse(MutatingUseContext::Projection)\n             // These are just stores, where the storing is not propagatable, but there may be later\n             // mutations of the same local via `Store`\n             | MutatingUse(MutatingUseContext::Call)\n@@ -751,7 +760,6 @@ impl Visitor<'_> for CanConstProp {\n             NonMutatingUse(NonMutatingUseContext::Copy)\n             | NonMutatingUse(NonMutatingUseContext::Move)\n             | NonMutatingUse(NonMutatingUseContext::Inspect)\n-            | NonMutatingUse(NonMutatingUseContext::Projection)\n             | NonMutatingUse(NonMutatingUseContext::PlaceMention)\n             | NonUse(_) => {}\n \n@@ -771,6 +779,8 @@ impl Visitor<'_> for CanConstProp {\n                 trace!(\"local {:?} can't be propagated because it's used: {:?}\", local, context);\n                 self.can_const_prop[local] = ConstPropMode::NoPropagation;\n             }\n+            MutatingUse(MutatingUseContext::Projection)\n+            | NonMutatingUse(NonMutatingUseContext::Projection) => bug!(\"visit_place should not pass {context:?} for {local:?}\"),\n         }\n     }\n }"}, {"sha": "6b559cb5b2f643ceb4c9fa901d83198e9578a1c1", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 51, "deletions": 102, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -265,52 +265,41 @@ impl Drop for FileEncoder {\n     }\n }\n \n-macro_rules! file_encoder_write_leb128 {\n-    ($enc:expr, $value:expr, $int_ty:ty, $fun:ident) => {{\n-        const MAX_ENCODED_LEN: usize = $crate::leb128::max_leb128_len::<$int_ty>();\n+macro_rules! write_leb128 {\n+    ($this_fn:ident, $int_ty:ty, $write_leb_fn:ident) => {\n+        #[inline]\n+        fn $this_fn(&mut self, v: $int_ty) {\n+            const MAX_ENCODED_LEN: usize = $crate::leb128::max_leb128_len::<$int_ty>();\n \n-        // We ensure this during `FileEncoder` construction.\n-        debug_assert!($enc.capacity() >= MAX_ENCODED_LEN);\n+            // We ensure this during `FileEncoder` construction.\n+            debug_assert!(self.capacity() >= MAX_ENCODED_LEN);\n \n-        let mut buffered = $enc.buffered;\n+            let mut buffered = self.buffered;\n \n-        // This can't overflow. See assertion in `FileEncoder::with_capacity`.\n-        if std::intrinsics::unlikely(buffered + MAX_ENCODED_LEN > $enc.capacity()) {\n-            $enc.flush();\n-            buffered = 0;\n-        }\n+            // This can't overflow. See assertion in `FileEncoder::with_capacity`.\n+            if std::intrinsics::unlikely(buffered + MAX_ENCODED_LEN > self.capacity()) {\n+                self.flush();\n+                buffered = 0;\n+            }\n \n-        // SAFETY: The above check and flush ensures that there is enough\n-        // room to write the encoded value to the buffer.\n-        let buf = unsafe {\n-            &mut *($enc.buf.as_mut_ptr().add(buffered) as *mut [MaybeUninit<u8>; MAX_ENCODED_LEN])\n-        };\n+            // SAFETY: The above check and flush ensures that there is enough\n+            // room to write the encoded value to the buffer.\n+            let buf = unsafe {\n+                &mut *(self.buf.as_mut_ptr().add(buffered)\n+                    as *mut [MaybeUninit<u8>; MAX_ENCODED_LEN])\n+            };\n \n-        let encoded = leb128::$fun(buf, $value);\n-        $enc.buffered = buffered + encoded.len();\n-    }};\n+            let encoded = leb128::$write_leb_fn(buf, v);\n+            self.buffered = buffered + encoded.len();\n+        }\n+    };\n }\n \n impl Encoder for FileEncoder {\n-    #[inline]\n-    fn emit_usize(&mut self, v: usize) {\n-        file_encoder_write_leb128!(self, v, usize, write_usize_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_u128(&mut self, v: u128) {\n-        file_encoder_write_leb128!(self, v, u128, write_u128_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_u64(&mut self, v: u64) {\n-        file_encoder_write_leb128!(self, v, u64, write_u64_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_u32(&mut self, v: u32) {\n-        file_encoder_write_leb128!(self, v, u32, write_u32_leb128)\n-    }\n+    write_leb128!(emit_usize, usize, write_usize_leb128);\n+    write_leb128!(emit_u128, u128, write_u128_leb128);\n+    write_leb128!(emit_u64, u64, write_u64_leb128);\n+    write_leb128!(emit_u32, u32, write_u32_leb128);\n \n     #[inline]\n     fn emit_u16(&mut self, v: u16) {\n@@ -322,25 +311,10 @@ impl Encoder for FileEncoder {\n         self.write_one(v);\n     }\n \n-    #[inline]\n-    fn emit_isize(&mut self, v: isize) {\n-        file_encoder_write_leb128!(self, v, isize, write_isize_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_i128(&mut self, v: i128) {\n-        file_encoder_write_leb128!(self, v, i128, write_i128_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_i64(&mut self, v: i64) {\n-        file_encoder_write_leb128!(self, v, i64, write_i64_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_i32(&mut self, v: i32) {\n-        file_encoder_write_leb128!(self, v, i32, write_i32_leb128)\n-    }\n+    write_leb128!(emit_isize, isize, write_isize_leb128);\n+    write_leb128!(emit_i128, i128, write_i128_leb128);\n+    write_leb128!(emit_i64, i64, write_i64_leb128);\n+    write_leb128!(emit_i32, i32, write_i32_leb128);\n \n     #[inline]\n     fn emit_i16(&mut self, v: i16) {\n@@ -437,30 +411,19 @@ impl<'a> MemDecoder<'a> {\n }\n \n macro_rules! read_leb128 {\n-    ($dec:expr, $fun:ident) => {{ leb128::$fun($dec) }};\n+    ($this_fn:ident, $int_ty:ty, $read_leb_fn:ident) => {\n+        #[inline]\n+        fn $this_fn(&mut self) -> $int_ty {\n+            leb128::$read_leb_fn(self)\n+        }\n+    };\n }\n \n impl<'a> Decoder for MemDecoder<'a> {\n-    #[inline]\n-    fn position(&self) -> usize {\n-        // SAFETY: This type guarantees start <= current\n-        unsafe { self.current.sub_ptr(self.start) }\n-    }\n-\n-    #[inline]\n-    fn read_u128(&mut self) -> u128 {\n-        read_leb128!(self, read_u128_leb128)\n-    }\n-\n-    #[inline]\n-    fn read_u64(&mut self) -> u64 {\n-        read_leb128!(self, read_u64_leb128)\n-    }\n-\n-    #[inline]\n-    fn read_u32(&mut self) -> u32 {\n-        read_leb128!(self, read_u32_leb128)\n-    }\n+    read_leb128!(read_usize, usize, read_usize_leb128);\n+    read_leb128!(read_u128, u128, read_u128_leb128);\n+    read_leb128!(read_u64, u64, read_u64_leb128);\n+    read_leb128!(read_u32, u32, read_u32_leb128);\n \n     #[inline]\n     fn read_u16(&mut self) -> u16 {\n@@ -480,36 +443,16 @@ impl<'a> Decoder for MemDecoder<'a> {\n         }\n     }\n \n-    #[inline]\n-    fn read_usize(&mut self) -> usize {\n-        read_leb128!(self, read_usize_leb128)\n-    }\n-\n-    #[inline]\n-    fn read_i128(&mut self) -> i128 {\n-        read_leb128!(self, read_i128_leb128)\n-    }\n-\n-    #[inline]\n-    fn read_i64(&mut self) -> i64 {\n-        read_leb128!(self, read_i64_leb128)\n-    }\n-\n-    #[inline]\n-    fn read_i32(&mut self) -> i32 {\n-        read_leb128!(self, read_i32_leb128)\n-    }\n+    read_leb128!(read_isize, isize, read_isize_leb128);\n+    read_leb128!(read_i128, i128, read_i128_leb128);\n+    read_leb128!(read_i64, i64, read_i64_leb128);\n+    read_leb128!(read_i32, i32, read_i32_leb128);\n \n     #[inline]\n     fn read_i16(&mut self) -> i16 {\n         i16::from_le_bytes(self.read_array())\n     }\n \n-    #[inline]\n-    fn read_isize(&mut self) -> isize {\n-        read_leb128!(self, read_isize_leb128)\n-    }\n-\n     #[inline]\n     fn read_raw_bytes(&mut self, bytes: usize) -> &'a [u8] {\n         if bytes > self.remaining() {\n@@ -532,6 +475,12 @@ impl<'a> Decoder for MemDecoder<'a> {\n         // Since we just checked current == end, the current pointer must be inbounds.\n         unsafe { *self.current }\n     }\n+\n+    #[inline]\n+    fn position(&self) -> usize {\n+        // SAFETY: This type guarantees start <= current\n+        unsafe { self.current.sub_ptr(self.start) }\n+    }\n }\n \n // Specializations for contiguous byte sequences follow. The default implementations for slices"}, {"sha": "06166cabc187212eca09d6a8567bc9342d21560c", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -1,9 +1,5 @@\n //! Support code for encoding and decoding types.\n \n-/*\n-Core encoding and decoding interfaces.\n-*/\n-\n use std::alloc::Allocator;\n use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n@@ -35,13 +31,13 @@ const STR_SENTINEL: u8 = 0xC1;\n /// really makes sense to store floating-point values at all.\n /// (If you need it, revert <https://github.com/rust-lang/rust/pull/109984>.)\n pub trait Encoder {\n-    // Primitive types:\n     fn emit_usize(&mut self, v: usize);\n     fn emit_u128(&mut self, v: u128);\n     fn emit_u64(&mut self, v: u64);\n     fn emit_u32(&mut self, v: u32);\n     fn emit_u16(&mut self, v: u16);\n     fn emit_u8(&mut self, v: u8);\n+\n     fn emit_isize(&mut self, v: isize);\n     fn emit_i128(&mut self, v: i128);\n     fn emit_i64(&mut self, v: i64);\n@@ -93,13 +89,13 @@ pub trait Encoder {\n /// really makes sense to store floating-point values at all.\n /// (If you need it, revert <https://github.com/rust-lang/rust/pull/109984>.)\n pub trait Decoder {\n-    // Primitive types:\n     fn read_usize(&mut self) -> usize;\n     fn read_u128(&mut self) -> u128;\n     fn read_u64(&mut self) -> u64;\n     fn read_u32(&mut self) -> u32;\n     fn read_u16(&mut self) -> u16;\n     fn read_u8(&mut self) -> u8;\n+\n     fn read_isize(&mut self) -> isize;\n     fn read_i128(&mut self) -> i128;\n     fn read_i64(&mut self) -> i64;"}, {"sha": "2a8403c85a4eb015e10c40456e70f3d506d0f99d", "filename": "library/core/src/tuple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/library%2Fcore%2Fsrc%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/library%2Fcore%2Fsrc%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftuple.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -101,7 +101,7 @@ macro_rules! tuple_impls {\n             }\n         }\n \n-        #[stable(feature = \"array_tuple_conv\", since = \"1.63.0\")]\n+        #[stable(feature = \"array_tuple_conv\", since = \"CURRENT_RUSTC_VERSION\")]\n         impl<T> From<[T; ${count(T)}]> for ($(${ignore(T)} T,)+) {\n             #[inline]\n             #[allow(non_snake_case)]\n@@ -111,7 +111,7 @@ macro_rules! tuple_impls {\n             }\n         }\n \n-        #[stable(feature = \"array_tuple_conv\", since = \"1.63.0\")]\n+        #[stable(feature = \"array_tuple_conv\", since = \"CURRENT_RUSTC_VERSION\")]\n         impl<T> From<($(${ignore(T)} T,)+)> for [T; ${count(T)}] {\n             #[inline]\n             #[allow(non_snake_case)]"}, {"sha": "77f645883102c392796d1c925008beb22483f157", "filename": "library/std/src/sys/common/thread_local/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fmod.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -1,5 +1,10 @@\n #![unstable(feature = \"thread_local_internals\", reason = \"should not be necessary\", issue = \"none\")]\n \n+// There are three thread-local implementations: \"static\", \"fast\", \"OS\".\n+// The \"OS\" thread local key type is accessed via platform-specific API calls and is slow, while the\n+// \"fast\" key type is accessed via code generated via LLVM, where TLS keys are set up by the linker.\n+// \"static\" is for single-threaded platforms where a global static is sufficient.\n+\n cfg_if::cfg_if! {\n     if #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))] {\n         #[doc(hidden)]"}, {"sha": "5d48ce1e03bc359bd1f418a9d718918a292b5f04", "filename": "library/std/src/sys/common/thread_local/os_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fos_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fos_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fos_local.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -18,7 +18,7 @@ pub macro thread_local_inner {\n         ) -> $crate::option::Option<&'static $t> {\n             const INIT_EXPR: $t = $init;\n \n-                        // On platforms without `#[thread_local]` we fall back to the\n+            // On platforms without `#[thread_local]` we fall back to the\n             // same implementation as below for os thread locals.\n             #[inline]\n             const fn __init() -> $t { INIT_EXPR }"}, {"sha": "f712c872708ac97c2510cbb0d859c6c1222026a5", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -193,22 +193,22 @@ pub use scoped::{scope, Scope, ScopedJoinHandle};\n #[macro_use]\n mod local;\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::local::{AccessError, LocalKey};\n-\n-// Provide the type used by the thread_local! macro to access TLS keys. This\n-// needs to be kept in sync with the macro itself (in `local.rs`).\n-// There are three types: \"static\", \"fast\", \"OS\". The \"OS\" thread local key\n-// type is accessed via platform-specific API calls and is slow, while the \"fast\"\n-// key type is accessed via code generated via LLVM, where TLS keys are set up\n-// by the elf linker. \"static\" is for single-threaded platforms where a global\n-// static is sufficient.\n-\n-// Implementation details used by the thread_local!{} macro.\n-#[doc(hidden)]\n-#[unstable(feature = \"thread_local_internals\", issue = \"none\")]\n-pub mod local_impl {\n-    pub use crate::sys::common::thread_local::{thread_local_inner, Key};\n+cfg_if::cfg_if! {\n+    if #[cfg(test)] {\n+        // Avoid duplicating the global state assoicated with thread-locals between this crate and\n+        // realstd. Miri relies on this.\n+        pub use realstd::thread::{local_impl, AccessError, LocalKey};\n+    } else {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        pub use self::local::{AccessError, LocalKey};\n+\n+        // Implementation details used by the thread_local!{} macro.\n+        #[doc(hidden)]\n+        #[unstable(feature = \"thread_local_internals\", issue = \"none\")]\n+        pub mod local_impl {\n+            pub use crate::sys::common::thread_local::{thread_local_inner, Key};\n+        }\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "ac51dc51aeb0282ed36a87a14d0e555b7f22de7f", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -1442,6 +1442,28 @@ impl Config {\n         git\n     }\n \n+    pub(crate) fn test_args(&self) -> Vec<&str> {\n+        let mut test_args = match self.cmd {\n+            Subcommand::Test { ref test_args, .. } | Subcommand::Bench { ref test_args, .. } => {\n+                test_args.iter().flat_map(|s| s.split_whitespace()).collect()\n+            }\n+            _ => vec![],\n+        };\n+        test_args.extend(self.free_args.iter().map(|s| s.as_str()));\n+        test_args\n+    }\n+\n+    pub(crate) fn args(&self) -> Vec<&str> {\n+        let mut args = match self.cmd {\n+            Subcommand::Run { ref args, .. } => {\n+                args.iter().flat_map(|s| s.split_whitespace()).collect()\n+            }\n+            _ => vec![],\n+        };\n+        args.extend(self.free_args.iter().map(|s| s.as_str()));\n+        args\n+    }\n+\n     /// Bootstrap embeds a version number into the name of shared libraries it uploads in CI.\n     /// Return the version it would have used for the given commit.\n     pub(crate) fn artifact_version_part(&self, commit: &str) -> String {"}, {"sha": "9cead7adc8c3598640c1be35a3fc9c0a7500a4af", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -822,6 +822,8 @@ fn copy_src_dirs(\n             \"llvm-project\\\\compiler-rt\",\n             \"llvm-project/cmake\",\n             \"llvm-project\\\\cmake\",\n+            \"llvm-project/runtimes\",\n+            \"llvm-project\\\\runtimes\",\n         ];\n         if spath.contains(\"llvm-project\")\n             && !spath.ends_with(\"llvm-project\")"}, {"sha": "2a0ebee9a6b5b06ede0db2037c59b340e11c4dde", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -745,15 +745,6 @@ impl Subcommand {\n         }\n     }\n \n-    pub fn test_args(&self) -> Vec<&str> {\n-        match *self {\n-            Subcommand::Test { ref test_args, .. } | Subcommand::Bench { ref test_args, .. } => {\n-                test_args.iter().flat_map(|s| s.split_whitespace()).collect()\n-            }\n-            _ => vec![],\n-        }\n-    }\n-\n     pub fn rustc_args(&self) -> Vec<&str> {\n         match *self {\n             Subcommand::Test { ref rustc_args, .. } => {\n@@ -763,15 +754,6 @@ impl Subcommand {\n         }\n     }\n \n-    pub fn args(&self) -> Vec<&str> {\n-        match *self {\n-            Subcommand::Run { ref args, .. } => {\n-                args.iter().flat_map(|s| s.split_whitespace()).collect()\n-            }\n-            _ => vec![],\n-        }\n-    }\n-\n     pub fn fail_fast(&self) -> bool {\n         match *self {\n             Subcommand::Test { fail_fast, .. } => fail_fast,"}, {"sha": "cb15d9a6325b3d3a752978852404bf46876a8536", "filename": "src/bootstrap/run.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/src%2Fbootstrap%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/src%2Fbootstrap%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frun.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -105,7 +105,7 @@ impl Step for BumpStage0 {\n \n     fn run(self, builder: &Builder<'_>) -> Self::Output {\n         let mut cmd = builder.tool_cmd(Tool::BumpStage0);\n-        cmd.args(builder.config.cmd.args());\n+        cmd.args(builder.config.args());\n         builder.run(&mut cmd);\n     }\n }\n@@ -182,8 +182,7 @@ impl Step for Miri {\n         miri.add_rustc_lib_path(builder, compiler);\n         // Forward arguments.\n         miri.arg(\"--\").arg(\"--target\").arg(target.rustc_target_arg());\n-        miri.args(builder.config.cmd.args());\n-        miri.args(&builder.config.free_args);\n+        miri.args(builder.config.args());\n \n         // miri tests need to know about the stage sysroot\n         miri.env(\"MIRI_SYSROOT\", &miri_sysroot);"}, {"sha": "28813266a4d9e9f18793b7474e4041f37f7cbf2c", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -263,7 +263,7 @@ impl Step for Cargotest {\n             builder,\n             cmd.arg(&cargo)\n                 .arg(&out_dir)\n-                .args(builder.config.cmd.test_args())\n+                .args(builder.config.test_args())\n                 .env(\"RUSTC\", builder.rustc(compiler))\n                 .env(\"RUSTDOC\", builder.rustdoc(compiler)),\n         );\n@@ -634,7 +634,7 @@ impl Step for Miri {\n             .arg(builder.src.join(\"src/tools/miri/test-cargo-miri/Cargo.toml\"));\n         cargo.arg(\"--target\").arg(target.rustc_target_arg());\n         cargo.arg(\"--tests\"); // don't run doctests, they are too confused by the staging\n-        cargo.arg(\"--\").args(builder.config.cmd.test_args());\n+        cargo.arg(\"--\").args(builder.config.test_args());\n \n         // Tell `cargo miri` where to find things.\n         cargo.env(\"MIRI_SYSROOT\", &miri_sysroot);\n@@ -1060,7 +1060,7 @@ impl Step for RustdocGUI {\n                 }\n             }\n         }\n-        for test_arg in builder.config.cmd.test_args() {\n+        for test_arg in builder.config.test_args() {\n             command.arg(test_arg);\n         }\n         builder.run(&mut command);\n@@ -1555,8 +1555,7 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n             .filter_map(|p| util::is_valid_test_suite_arg(p, suite_path, builder))\n             .collect();\n \n-        test_args.append(&mut builder.config.cmd.test_args());\n-        test_args.extend(builder.config.free_args.iter().map(|s| s.as_str()));\n+        test_args.append(&mut builder.config.test_args());\n \n         // On Windows, replace forward slashes in test-args by backslashes\n         // so the correct filters are passed to libtest\n@@ -1962,7 +1961,7 @@ fn markdown_test(builder: &Builder<'_>, compiler: Compiler, markdown: &Path) ->\n     cmd.arg(markdown);\n     cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n \n-    let test_args = builder.config.cmd.test_args().join(\" \");\n+    let test_args = builder.config.test_args().join(\" \");\n     cmd.arg(\"--test-args\").arg(test_args);\n \n     if builder.config.verbose_tests {\n@@ -2099,7 +2098,7 @@ fn prepare_cargo_test(\n         cargo.arg(\"-p\").arg(krate);\n     }\n \n-    cargo.arg(\"--\").args(&builder.config.cmd.test_args()).args(libtest_args);\n+    cargo.arg(\"--\").args(&builder.config.test_args()).args(libtest_args);\n     if !builder.config.verbose_tests {\n         cargo.arg(\"--quiet\");\n     }"}, {"sha": "d50b12044ceb27d332433d28b2dc4c9d37dde23c", "filename": "tests/mir-opt/const_prop/address_of_pair.fn0.ConstProp.diff", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/tests%2Fmir-opt%2Fconst_prop%2Faddress_of_pair.fn0.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/tests%2Fmir-opt%2Fconst_prop%2Faddress_of_pair.fn0.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Faddress_of_pair.fn0.ConstProp.diff?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -0,0 +1,46 @@\n+- // MIR for `fn0` before ConstProp\n++ // MIR for `fn0` after ConstProp\n+  \n+  fn fn0() -> bool {\n+      let mut _0: bool;                    // return place in scope 0 at $DIR/address_of_pair.rs:+0:17: +0:21\n+      let mut _1: !;                       // in scope 0 at $DIR/address_of_pair.rs:+0:22: +9:2\n+      let mut _2: (i32, bool);             // in scope 0 at $DIR/address_of_pair.rs:+1:9: +1:17\n+      let _4: ();                          // in scope 0 at $DIR/address_of_pair.rs:+4:5: +6:6\n+      let mut _6: bool;                    // in scope 0 at $DIR/address_of_pair.rs:+7:16: +7:22\n+      scope 1 {\n+          debug pair => _2;                // in scope 1 at $DIR/address_of_pair.rs:+1:9: +1:17\n+          let _3: *mut bool;               // in scope 1 at $DIR/address_of_pair.rs:+2:9: +2:12\n+          scope 2 {\n+              debug ptr => _3;             // in scope 2 at $DIR/address_of_pair.rs:+2:9: +2:12\n+              let _5: bool;                // in scope 2 at $DIR/address_of_pair.rs:+7:9: +7:12\n+              scope 3 {\n+              }\n+              scope 4 {\n+                  debug ret => _5;         // in scope 4 at $DIR/address_of_pair.rs:+7:9: +7:12\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/address_of_pair.rs:+1:9: +1:17\n+          _2 = (const 1_i32, const false); // scope 0 at $DIR/address_of_pair.rs:+1:20: +1:30\n+          StorageLive(_3);                 // scope 1 at $DIR/address_of_pair.rs:+2:9: +2:12\n+          _3 = &raw mut (_2.1: bool);      // scope 1 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+          _2 = (const 1_i32, const false); // scope 2 at $DIR/address_of_pair.rs:+3:5: +3:22\n+          StorageLive(_4);                 // scope 2 at $DIR/address_of_pair.rs:+4:5: +6:6\n+          (*_3) = const true;              // scope 3 at $DIR/address_of_pair.rs:+5:9: +5:20\n+          _4 = const ();                   // scope 3 at $DIR/address_of_pair.rs:+4:5: +6:6\n+          StorageDead(_4);                 // scope 2 at $DIR/address_of_pair.rs:+6:5: +6:6\n+          StorageLive(_5);                 // scope 2 at $DIR/address_of_pair.rs:+7:9: +7:12\n+          StorageLive(_6);                 // scope 2 at $DIR/address_of_pair.rs:+7:16: +7:22\n+          _6 = (_2.1: bool);               // scope 2 at $DIR/address_of_pair.rs:+7:16: +7:22\n+          _5 = Not(move _6);               // scope 2 at $DIR/address_of_pair.rs:+7:15: +7:22\n+          StorageDead(_6);                 // scope 2 at $DIR/address_of_pair.rs:+7:21: +7:22\n+          _0 = _5;                         // scope 4 at $DIR/address_of_pair.rs:+8:12: +8:15\n+          StorageDead(_5);                 // scope 2 at $DIR/address_of_pair.rs:+9:1: +9:2\n+          StorageDead(_3);                 // scope 1 at $DIR/address_of_pair.rs:+9:1: +9:2\n+          StorageDead(_2);                 // scope 0 at $DIR/address_of_pair.rs:+9:1: +9:2\n+          return;                          // scope 0 at $DIR/address_of_pair.rs:+9:2: +9:2\n+      }\n+  }\n+  "}, {"sha": "43dc9bae625347336da5b3724d1d0be813b5e877", "filename": "tests/mir-opt/const_prop/address_of_pair.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/tests%2Fmir-opt%2Fconst_prop%2Faddress_of_pair.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/tests%2Fmir-opt%2Fconst_prop%2Faddress_of_pair.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Faddress_of_pair.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -0,0 +1,17 @@\n+// unit-test: ConstProp\n+\n+// EMIT_MIR address_of_pair.fn0.ConstProp.diff\n+pub fn fn0() -> bool {\n+    let mut pair = (1, false);\n+    let ptr = core::ptr::addr_of_mut!(pair.1);\n+    pair = (1, false);\n+    unsafe {\n+        *ptr = true;\n+    }\n+    let ret = !pair.1;\n+    return ret;\n+}\n+\n+pub fn main() {\n+    println!(\"{}\", fn0());\n+}"}, {"sha": "a5f52d08957c8fb2bcd507b8edea6d68b488c534", "filename": "tests/mir-opt/const_prop_miscompile.bar.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/tests%2Fmir-opt%2Fconst_prop_miscompile.bar.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/tests%2Fmir-opt%2Fconst_prop_miscompile.bar.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop_miscompile.bar.ConstProp.diff?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -19,8 +19,7 @@\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/const_prop_miscompile.rs:+1:9: +1:14\n--         _1 = (const 1_i32,);             // scope 0 at $DIR/const_prop_miscompile.rs:+1:17: +1:21\n-+         _1 = const (1_i32,);             // scope 0 at $DIR/const_prop_miscompile.rs:+1:17: +1:21\n+          _1 = (const 1_i32,);             // scope 0 at $DIR/const_prop_miscompile.rs:+1:17: +1:21\n           StorageLive(_2);                 // scope 1 at $DIR/const_prop_miscompile.rs:+2:5: +4:6\n           StorageLive(_3);                 // scope 2 at $DIR/const_prop_miscompile.rs:+3:10: +3:22\n           _3 = &raw mut (_1.0: i32);       // scope 2 at $DIR/const_prop_miscompile.rs:+3:10: +3:22"}, {"sha": "42ddc2a56208a82e57a2eb289186c65e4ee82012", "filename": "tests/mir-opt/const_prop_miscompile.foo.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/tests%2Fmir-opt%2Fconst_prop_miscompile.foo.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/tests%2Fmir-opt%2Fconst_prop_miscompile.foo.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop_miscompile.foo.ConstProp.diff?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -16,8 +16,7 @@\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/const_prop_miscompile.rs:+1:9: +1:14\n--         _1 = (const 1_i32,);             // scope 0 at $DIR/const_prop_miscompile.rs:+1:17: +1:21\n-+         _1 = const (1_i32,);             // scope 0 at $DIR/const_prop_miscompile.rs:+1:17: +1:21\n+          _1 = (const 1_i32,);             // scope 0 at $DIR/const_prop_miscompile.rs:+1:17: +1:21\n           StorageLive(_2);                 // scope 1 at $DIR/const_prop_miscompile.rs:+2:6: +2:14\n           _2 = &mut (_1.0: i32);           // scope 1 at $DIR/const_prop_miscompile.rs:+2:6: +2:14\n           (*_2) = const 5_i32;             // scope 1 at $DIR/const_prop_miscompile.rs:+2:5: +2:18"}, {"sha": "ec4fda322d04f1bf3e4874be3f2944e2b827053f", "filename": "tests/ui/impl-trait/issues/issue-86800.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-86800.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-86800.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-86800.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -1,14 +1,12 @@\n #![feature(type_alias_impl_trait)]\n \n // edition:2021\n-// unset-rustc-env:RUST_BACKTRACE\n // compile-flags:-Z treat-err-as-bug=1\n-// error-pattern:stack backtrace:\n+// error-pattern: aborting due to `-Z treat-err-as-bug=1`\n // failure-status:101\n-// normalize-stderr-test \"note: .*\" -> \"\"\n-// normalize-stderr-test \"thread 'rustc' .*\" -> \"\"\n-// normalize-stderr-test \" +[0-9]+:.*\\n\" -> \"\"\n-// normalize-stderr-test \" +at .*\\n\" -> \"\"\n+// normalize-stderr-test \".*note: .*\\n\\n\" -> \"\"\n+// normalize-stderr-test \"thread 'rustc' panicked.*\\n\" -> \"\"\n+// rustc-env:RUST_BACKTRACE=0\n \n use std::future::Future;\n "}, {"sha": "facab390d1524915c666a1adca8b6f8c262dfdae", "filename": "tests/ui/impl-trait/issues/issue-86800.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-86800.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-86800.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-86800.stderr?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -1,24 +1,12 @@\n error: unconstrained opaque type\n-  --> $DIR/issue-86800.rs:33:34\n+  --> $DIR/issue-86800.rs:31:34\n    |\n LL | type TransactionFuture<'__, O> = impl '__ + Future<Output = TransactionResult<O>>;\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = \n-\n-\n-stack backtrace:\n-\n error: the compiler unexpectedly panicked. this is a bug.\n \n-\n-\n-\n-\n-\n-\n query stack during panic:\n #0 [type_of] computing type of `TransactionFuture::{opaque#0}`\n #1 [check_mod_item_types] checking item types in top-level module\n-#2 [analysis] running analysis passes on this crate\n end of query stack"}, {"sha": "b40203c339d054df45c389ba7bae36e604d1148f", "filename": "tests/ui/panics/default-backtrace-ice.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/tests%2Fui%2Fpanics%2Fdefault-backtrace-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/tests%2Fui%2Fpanics%2Fdefault-backtrace-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanics%2Fdefault-backtrace-ice.rs?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -2,8 +2,20 @@\n // compile-flags:-Z treat-err-as-bug=1\n // error-pattern:stack backtrace:\n // failure-status:101\n+// ignore-msvc\n // normalize-stderr-test \"note: .*\" -> \"\"\n // normalize-stderr-test \"thread 'rustc' .*\" -> \"\"\n-// normalize-stderr-test \"  .*\\n\" -> \"\"\n+// normalize-stderr-test \" +\\d+:.*__rust_begin_short_backtrace.*\" -> \"(begin_short_backtrace)\"\n+// normalize-stderr-test \" +\\d+:.*__rust_end_short_backtrace.*\" -> \"(end_short_backtrace)\"\n+// normalize-stderr-test \" +\\d+:.*\\n\" -> \"\"\n+// normalize-stderr-test \" +at .*\\n\" -> \"\"\n+//\n+// This test makes sure that full backtraces are used for ICEs when\n+// RUST_BACKTRACE is not set. It does this by checking for the presence of\n+// `__rust_{begin,end}_short_backtrace` markers, which only appear in full\n+// backtraces. The rest of the backtrace is filtered out.\n+//\n+// Ignored on msvc becaue the `__rust_{begin,end}_short_backtrace` symbols\n+// aren't reliable.\n \n fn main() { missing_ident; }"}, {"sha": "ddbfc4e7f3a0cb82cc268353e0deb125db036786", "filename": "tests/ui/panics/default-backtrace-ice.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3320f2fab64f36dae94b830f8c4b166857b6919b/tests%2Fui%2Fpanics%2Fdefault-backtrace-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3320f2fab64f36dae94b830f8c4b166857b6919b/tests%2Fui%2Fpanics%2Fdefault-backtrace-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanics%2Fdefault-backtrace-ice.stderr?ref=3320f2fab64f36dae94b830f8c4b166857b6919b", "patch": "@@ -1,8 +1,13 @@\n error[E0425]: cannot find value `missing_ident` in this scope\n+  --> $DIR/default-backtrace-ice.rs:21:13\n+   |\n LL | fn main() { missing_ident; }\n+   |             ^^^^^^^^^^^^^ not found in this scope\n \n \n stack backtrace:\n+(end_short_backtrace)\n+(begin_short_backtrace)\n \n error: the compiler unexpectedly panicked. this is a bug.\n "}]}