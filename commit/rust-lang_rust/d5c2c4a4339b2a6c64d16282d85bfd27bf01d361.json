{"sha": "d5c2c4a4339b2a6c64d16282d85bfd27bf01d361", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1YzJjNGE0MzM5YjJhNmM2NGQxNjI4MmQ4NWJmZDI3YmYwMWQzNjE=", "commit": {"author": {"name": "Michael Hewson", "email": "michael@michaelhewson.ca", "date": "2018-09-20T07:12:00Z"}, "committer": {"name": "Michael Hewson", "email": "michael@michaelhewson.ca", "date": "2018-11-01T22:15:19Z"}, "message": "Implement the object-safety checks for arbitrary_self_types: part 1\n\nFor a trait method to be considered object-safe, the receiver type must\nsatisfy certain properties: first, we need to be able to get the vtable\nto so we can look up the method, and second, we need to convert the\nreceiver from the version where `Self=dyn Trait`, to the version where\n`Self=T`, `T` being some unknown, `Sized` type that implements `Trait`.\n\nTo check that the receiver satisfies those properties, we use the\nfollowing query:\n\nforall (U) {\nif (Self: Unsize<U>) {\nReceiver[Self => U]: CoerceSized<Receiver>\n}\n}\n\nwhere `Receiver` is the receiver type of the method (e.g. `Rc<Self>`),\nand `Receiver[Self => U]` is the receiver type where `Self = U`, e.g.\n`Rc<U>`.\n\nforall queries like this aren\u2019t implemented in the trait system yet, so\nfor now we are using a bit of a hack \u2014 see the code for explanation.", "tree": {"sha": "0b24b58a863e34c40b83c8bbb151e792addfd991", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b24b58a863e34c40b83c8bbb151e792addfd991"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5c2c4a4339b2a6c64d16282d85bfd27bf01d361", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5c2c4a4339b2a6c64d16282d85bfd27bf01d361", "html_url": "https://github.com/rust-lang/rust/commit/d5c2c4a4339b2a6c64d16282d85bfd27bf01d361", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5c2c4a4339b2a6c64d16282d85bfd27bf01d361/comments", "author": {"login": "mikeyhew", "id": 6751033, "node_id": "MDQ6VXNlcjY3NTEwMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6751033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikeyhew", "html_url": "https://github.com/mikeyhew", "followers_url": "https://api.github.com/users/mikeyhew/followers", "following_url": "https://api.github.com/users/mikeyhew/following{/other_user}", "gists_url": "https://api.github.com/users/mikeyhew/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikeyhew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikeyhew/subscriptions", "organizations_url": "https://api.github.com/users/mikeyhew/orgs", "repos_url": "https://api.github.com/users/mikeyhew/repos", "events_url": "https://api.github.com/users/mikeyhew/events{/privacy}", "received_events_url": "https://api.github.com/users/mikeyhew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mikeyhew", "id": 6751033, "node_id": "MDQ6VXNlcjY3NTEwMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6751033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikeyhew", "html_url": "https://github.com/mikeyhew", "followers_url": "https://api.github.com/users/mikeyhew/followers", "following_url": "https://api.github.com/users/mikeyhew/following{/other_user}", "gists_url": "https://api.github.com/users/mikeyhew/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikeyhew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikeyhew/subscriptions", "organizations_url": "https://api.github.com/users/mikeyhew/orgs", "repos_url": "https://api.github.com/users/mikeyhew/repos", "events_url": "https://api.github.com/users/mikeyhew/events{/privacy}", "received_events_url": "https://api.github.com/users/mikeyhew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be80a79a1ea247a71e5ffa408356b9b72cddb644", "url": "https://api.github.com/repos/rust-lang/rust/commits/be80a79a1ea247a71e5ffa408356b9b72cddb644", "html_url": "https://github.com/rust-lang/rust/commit/be80a79a1ea247a71e5ffa408356b9b72cddb644"}], "stats": {"total": 164, "additions": 144, "deletions": 20}, "files": [{"sha": "470a5c6bc9ebd4c6c9dc34dc8f109f9cc1a12de8", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 144, "deletions": 20, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/d5c2c4a4339b2a6c64d16282d85bfd27bf01d361/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5c2c4a4339b2a6c64d16282d85bfd27bf01d361/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=d5c2c4a4339b2a6c64d16282d85bfd27bf01d361", "patch": "@@ -13,19 +13,21 @@\n //! object if all of their methods meet certain criteria. In particular,\n //! they must:\n //!\n-//!   - have a suitable receiver from which we can extract a vtable;\n+//!   - have a suitable receiver from which we can extract a vtable and coerce to a \"thin\" version\n+//!     that doesn't contain the vtable;\n //!   - not reference the erased type `Self` except for in this receiver;\n //!   - not have generic type parameters\n \n use super::elaborate_predicates;\n \n use hir::def_id::DefId;\n use lint;\n-use traits;\n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n-use ty::util::ExplicitSelf;\n+use traits::{self, Obligation, ObligationCause};\n+use ty::{self, Ty, TyCtxt, TypeFoldable, Predicate, ToPredicate};\n+use ty::subst::{Subst, Substs};\n use std::borrow::Cow;\n-use syntax::ast;\n+use std::iter::{self};\n+use syntax::ast::{self, Name};\n use syntax_pos::Span;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n@@ -62,8 +64,8 @@ impl ObjectSafetyViolation {\n                 format!(\"method `{}` references the `Self` type in where clauses\", name).into(),\n             ObjectSafetyViolation::Method(name, MethodViolationCode::Generic) =>\n                 format!(\"method `{}` has generic type parameters\", name).into(),\n-            ObjectSafetyViolation::Method(name, MethodViolationCode::NonStandardSelfType) =>\n-                format!(\"method `{}` has a non-standard `self` type\", name).into(),\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::UncoercibleReceiver) =>\n+                format!(\"method `{}` has an uncoercible receiver type\", name).into(),\n             ObjectSafetyViolation::AssociatedConst(name) =>\n                 format!(\"the trait cannot contain associated consts like `{}`\", name).into(),\n         }\n@@ -85,8 +87,8 @@ pub enum MethodViolationCode {\n     /// e.g., `fn foo<A>()`\n     Generic,\n \n-    /// arbitrary `self` type, e.g. `self: Rc<Self>`\n-    NonStandardSelfType,\n+    /// the self argument can't be coerced from Self=dyn Trait to Self=T where T: Trait\n+    UncoercibleReceiver,\n }\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n@@ -113,6 +115,8 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn object_safety_violations(self, trait_def_id: DefId)\n                                     -> Vec<ObjectSafetyViolation>\n     {\n+        debug!(\"object_safety_violations: {:?}\", trait_def_id);\n+\n         traits::supertrait_def_ids(self, trait_def_id)\n             .flat_map(|def_id| self.object_safety_violations_for_trait(def_id))\n             .collect()\n@@ -277,23 +281,13 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n                                          method: &ty::AssociatedItem)\n                                          -> Option<MethodViolationCode>\n     {\n-        // The method's first parameter must be something that derefs (or\n-        // autorefs) to `&self`. For now, we only accept `self`, `&self`\n-        // and `Box<Self>`.\n+        // The method's first parameter must be named `self`\n         if !method.method_has_self_argument {\n             return Some(MethodViolationCode::StaticMethod);\n         }\n \n         let sig = self.fn_sig(method.def_id);\n \n-        let self_ty = self.mk_self_type();\n-        let self_arg_ty = sig.skip_binder().inputs()[0];\n-        if let ExplicitSelf::Other = ExplicitSelf::determine(self_arg_ty, |ty| ty == self_ty) {\n-            return Some(MethodViolationCode::NonStandardSelfType);\n-        }\n-\n-        // The `Self` type is erased, so it should not appear in list of\n-        // arguments or return type apart from the receiver.\n         for input_ty in &sig.skip_binder().inputs()[1..] {\n             if self.contains_illegal_self_type_reference(trait_def_id, input_ty) {\n                 return Some(MethodViolationCode::ReferencesSelf);\n@@ -320,9 +314,139 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             return Some(MethodViolationCode::WhereClauseReferencesSelf(span));\n         }\n \n+        let receiver_ty = self.liberate_late_bound_regions(\n+            method.def_id,\n+            &sig.map_bound(|sig| sig.inputs()[0]),\n+        );\n+\n+        // until `unsized_locals` is fully implemented, `self: Self` can't be coerced from\n+        // `Self=dyn Trait` to `Self=T`. However, this is already considered object-safe. We allow\n+        // it as a special case here.\n+        // FIXME(mikeyhew) get rid of this `if` statement once `receiver_is_coercible` allows\n+        // `Receiver: Unsize<Receiver[Self => dyn Trait]>`\n+        if receiver_ty != self.mk_self_type() {\n+            if !self.receiver_is_coercible(method, receiver_ty) {\n+                return Some(MethodViolationCode::UncoercibleReceiver);\n+            }\n+        }\n+\n         None\n     }\n \n+    /// checks the method's receiver (the `self` argument) can be coerced from\n+    /// a fat pointer, including the trait object vtable, to a thin pointer.\n+    /// e.g. from `Rc<dyn Trait>` to `Rc<T>`, where `T` is the erased type of the underlying object.\n+    /// More formally:\n+    /// - let `Receiver` be the type of the `self` argument, i.e `Self`, `&Self`, `Rc<Self>`\n+    /// - require the following bound:\n+    ///       forall(T: Trait) {\n+    ///           Receiver[Self => dyn Trait]: CoerceSized<Receiver[Self => T]>\n+    ///       }\n+    ///   where `Foo[X => Y]` means \"the same type as `Foo`, but with `X` replaced with `Y`\"\n+    ///   (substitution notation).\n+    ///\n+    /// some examples of receiver types and their required obligation\n+    /// - `&'a mut self` requires `&'a mut dyn Trait: CoerceSized<&'a mut T>`\n+    /// - `self: Rc<Self>` requires `Rc<dyn Trait>: CoerceSized<Rc<T>>`\n+    ///\n+    /// The only case where the receiver is not coercible, but is still a valid receiver\n+    /// type (just not object-safe), is when there is more than one level of pointer indirection.\n+    /// e.g. `self: &&Self`, `self: &Rc<Self>`, `self: Box<Box<Self>>`. In these cases, there\n+    /// is no way, or at least no inexpensive way, to coerce the receiver, because the object that\n+    /// needs to be coerced is behind a pointer.\n+    ///\n+    /// In practice, there are issues with the above bound: `where` clauses that apply to `Self`\n+    /// would have to apply to `T`, trait object types have a lot of parameters that need to\n+    /// be filled in (lifetime and type parameters, and the lifetime of the actual object), and\n+    /// I'm pretty sure using `dyn Trait` in the query causes another object-safety query for\n+    /// `Trait`, resulting in cyclic queries. So in the implementation, we use the following,\n+    /// more general bound:\n+    ///\n+    ///     forall (U: ?Sized) {\n+    ///         if (Self: Unsize<U>) {\n+    ///             Receiver[Self => U]: CoerceSized<Receiver>\n+    ///         }\n+    ///     }\n+    ///\n+    /// for `self: &'a mut Self`, this means `&'a mut U: CoerceSized<&'a mut Self>`\n+    /// for `self: Rc<Self>`, this means `Rc<U>: CoerceSized<Rc<Self>>`\n+    //\n+    // FIXME(mikeyhew) when unsized receivers are implemented as part of unsized rvalues, add this\n+    // fallback query: `Receiver: Unsize<Receiver[Self => U]>` to support receivers like\n+    // `self: Wrapper<Self>`.\n+    #[allow(dead_code)]\n+    fn receiver_is_coercible(\n+        self,\n+        method: &ty::AssociatedItem,\n+        receiver_ty: Ty<'tcx>,\n+    ) -> bool {\n+        debug!(\"receiver_is_coercible: method = {:?}, receiver_ty = {:?}\", method, receiver_ty);\n+\n+        let traits = (self.lang_items().unsize_trait(),\n+                      self.lang_items().coerce_sized_trait());\n+        let (unsize_did, coerce_sized_did) = if let (Some(u), Some(cu)) = traits {\n+            (u, cu)\n+        } else {\n+            debug!(\"receiver_is_coercible: Missing Unsize or CoerceSized traits\");\n+            return false;\n+        };\n+\n+        // use a bogus type parameter to mimick a forall(U) query using u32::MAX for now.\n+        // FIXME(mikeyhew) this is a total hack, and we should replace it when real forall queries\n+        // are implemented\n+        let target_self_ty: Ty<'tcx> = self.mk_ty_param(\n+            ::std::u32::MAX,\n+            Name::intern(\"RustaceansAreAwesome\").as_interned_str(),\n+        );\n+\n+        // create a modified param env, with `Self: Unsize<U>` added to the caller bounds\n+        let param_env = {\n+            let mut param_env = self.param_env(method.def_id);\n+\n+            let predicate = ty::TraitRef {\n+                def_id: unsize_did,\n+                substs: self.mk_substs_trait(self.mk_self_type(), &[target_self_ty.into()]),\n+            }.to_predicate();\n+\n+            let caller_bounds: Vec<Predicate<'tcx>> = param_env.caller_bounds.iter().cloned()\n+                .chain(iter::once(predicate))\n+                .collect();\n+\n+            param_env.caller_bounds = self.intern_predicates(&caller_bounds);\n+\n+            param_env\n+        };\n+\n+        let receiver_substs = Substs::for_item(self, method.def_id, |param, _| {\n+            if param.index == 0 {\n+                target_self_ty.into()\n+            } else {\n+                self.mk_param_from_def(param)\n+            }\n+        });\n+        // the type `Receiver[Self => U]` in the query\n+        let unsized_receiver_ty = receiver_ty.subst(self, receiver_substs);\n+\n+        // Receiver[Self => U]: CoerceSized<Receiver>\n+        let obligation = {\n+            let predicate = ty::TraitRef {\n+                def_id: coerce_sized_did,\n+                substs: self.mk_substs_trait(unsized_receiver_ty, &[receiver_ty.into()]),\n+            }.to_predicate();\n+\n+            Obligation::new(\n+                ObligationCause::dummy(),\n+                param_env,\n+                predicate,\n+            )\n+        };\n+\n+        self.infer_ctxt().enter(|ref infcx| {\n+            // the receiver is coercible iff the obligation holds\n+            infcx.predicate_must_hold(&obligation)\n+        })\n+    }\n+\n     fn contains_illegal_self_type_reference(self,\n                                             trait_def_id: DefId,\n                                             ty: Ty<'tcx>)"}]}