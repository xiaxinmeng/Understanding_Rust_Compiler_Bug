{"sha": "1b12d01903293453dd94aa170c82caf94415629f", "node_id": "C_kwDOAAsO6NoAKDFiMTJkMDE5MDMyOTM0NTNkZDk0YWExNzBjODJjYWY5NDQxNTYyOWY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-13T13:57:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-13T13:57:00Z"}, "message": "Auto merge of #90542 - the8472:privatize-the-means-of-rawvec-production, r=joshtriplett\n\nMake RawVec private to alloc\n\nRawVec was previously exposed for compiler-internal use (libarena specifically) in 1acbb0a9350560d951359cc359361b87992a6f2b\n\nSince it is unstable, doc-hidden and has no associated tracking issue it was never meant for public use. And since\nit is no longer used outside alloc itself it can be made private again.\n\nAlso remove some functions that are dead due to lack of internal users.", "tree": {"sha": "11b89d1d0814e1234e8f969f74cee286aea50e09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11b89d1d0814e1234e8f969f74cee286aea50e09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b12d01903293453dd94aa170c82caf94415629f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b12d01903293453dd94aa170c82caf94415629f", "html_url": "https://github.com/rust-lang/rust/commit/1b12d01903293453dd94aa170c82caf94415629f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b12d01903293453dd94aa170c82caf94415629f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e018ce194ab16125747220676dd8a20aecd5196", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e018ce194ab16125747220676dd8a20aecd5196", "html_url": "https://github.com/rust-lang/rust/commit/3e018ce194ab16125747220676dd8a20aecd5196"}, {"sha": "7afe6f52e4448d7523877f652e567542f02b974e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7afe6f52e4448d7523877f652e567542f02b974e", "html_url": "https://github.com/rust-lang/rust/commit/7afe6f52e4448d7523877f652e567542f02b974e"}], "stats": {"total": 64, "additions": 6, "deletions": 58}, "files": [{"sha": "1bb257acff76a905e10207f36b555d3a9262b179", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b12d01903293453dd94aa170c82caf94415629f/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b12d01903293453dd94aa170c82caf94415629f/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=1b12d01903293453dd94aa170c82caf94415629f", "patch": "@@ -174,6 +174,8 @@ extern crate test;\n #[macro_use]\n mod macros;\n \n+mod raw_vec;\n+\n // Heaps provided for low-level allocation strategies\n \n pub mod alloc;\n@@ -192,7 +194,6 @@ mod boxed {\n pub mod borrow;\n pub mod collections;\n pub mod fmt;\n-pub mod raw_vec;\n pub mod rc;\n pub mod slice;\n pub mod str;"}, {"sha": "4ab38c802a1599ef507e4bac8aa96d06056fe5d5", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 4, "deletions": 57, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1b12d01903293453dd94aa170c82caf94415629f/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b12d01903293453dd94aa170c82caf94415629f/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=1b12d01903293453dd94aa170c82caf94415629f", "patch": "@@ -1,5 +1,4 @@\n-#![unstable(feature = \"raw_vec_internals\", reason = \"implementation detail\", issue = \"none\")]\n-#![doc(hidden)]\n+#![unstable(feature = \"raw_vec_internals\", reason = \"unstable const warnings\", issue = \"none\")]\n \n use core::alloc::LayoutError;\n use core::cmp;\n@@ -50,7 +49,7 @@ enum AllocInit {\n /// `usize::MAX`. This means that you need to be careful when round-tripping this type with a\n /// `Box<[T]>`, since `capacity()` won't yield the length.\n #[allow(missing_debug_implementations)]\n-pub struct RawVec<T, A: Allocator = Global> {\n+pub(crate) struct RawVec<T, A: Allocator = Global> {\n     ptr: Unique<T>,\n     cap: usize,\n     alloc: A,\n@@ -87,33 +86,20 @@ impl<T> RawVec<T, Global> {\n     /// # Aborts\n     ///\n     /// Aborts on OOM.\n-    #[cfg(not(no_global_oom_handling))]\n+    #[cfg(not(any(no_global_oom_handling, test)))]\n     #[must_use]\n     #[inline]\n     pub fn with_capacity(capacity: usize) -> Self {\n         Self::with_capacity_in(capacity, Global)\n     }\n \n     /// Like `with_capacity`, but guarantees the buffer is zeroed.\n-    #[cfg(not(no_global_oom_handling))]\n+    #[cfg(not(any(no_global_oom_handling, test)))]\n     #[must_use]\n     #[inline]\n     pub fn with_capacity_zeroed(capacity: usize) -> Self {\n         Self::with_capacity_zeroed_in(capacity, Global)\n     }\n-\n-    /// Reconstitutes a `RawVec` from a pointer and capacity.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The `ptr` must be allocated (on the system heap), and with the given `capacity`.\n-    /// The `capacity` cannot exceed `isize::MAX` for sized types. (only a concern on 32-bit\n-    /// systems). ZST vectors may have a capacity up to `usize::MAX`.\n-    /// If the `ptr` and `capacity` come from a `RawVec`, then this is guaranteed.\n-    #[inline]\n-    pub unsafe fn from_raw_parts(ptr: *mut T, capacity: usize) -> Self {\n-        unsafe { Self::from_raw_parts_in(ptr, capacity, Global) }\n-    }\n }\n \n impl<T, A: Allocator> RawVec<T, A> {\n@@ -154,14 +140,6 @@ impl<T, A: Allocator> RawVec<T, A> {\n         Self::allocate_in(capacity, AllocInit::Zeroed, alloc)\n     }\n \n-    /// Converts a `Box<[T]>` into a `RawVec<T>`.\n-    pub fn from_box(slice: Box<[T], A>) -> Self {\n-        unsafe {\n-            let (slice, alloc) = Box::into_raw_with_allocator(slice);\n-            RawVec::from_raw_parts_in(slice.as_mut_ptr(), slice.len(), alloc)\n-        }\n-    }\n-\n     /// Converts the entire buffer into `Box<[MaybeUninit<T>]>` with the specified `len`.\n     ///\n     /// Note that this will correctly reconstitute any `cap` changes\n@@ -290,37 +268,6 @@ impl<T, A: Allocator> RawVec<T, A> {\n     /// # Aborts\n     ///\n     /// Aborts on OOM.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(raw_vec_internals)]\n-    /// # extern crate alloc;\n-    /// # use std::ptr;\n-    /// # use alloc::raw_vec::RawVec;\n-    /// struct MyVec<T> {\n-    ///     buf: RawVec<T>,\n-    ///     len: usize,\n-    /// }\n-    ///\n-    /// impl<T: Clone> MyVec<T> {\n-    ///     pub fn push_all(&mut self, elems: &[T]) {\n-    ///         self.buf.reserve(self.len, elems.len());\n-    ///         // reserve would have aborted or panicked if the len exceeded\n-    ///         // `isize::MAX` so this is safe to do unchecked now.\n-    ///         for x in elems {\n-    ///             unsafe {\n-    ///                 ptr::write(self.buf.ptr().add(self.len), x.clone());\n-    ///             }\n-    ///             self.len += 1;\n-    ///         }\n-    ///     }\n-    /// }\n-    /// # fn main() {\n-    /// #   let mut vector = MyVec { buf: RawVec::new(), len: 0 };\n-    /// #   vector.push_all(&[1, 3, 5, 7, 9]);\n-    /// # }\n-    /// ```\n     #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     pub fn reserve(&mut self, len: usize, additional: usize) {"}]}