{"sha": "e385bc5bcceaeca1c3e0a0b8c0ae38b9ff462a3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzODViYzViY2NlYWVjYTFjM2UwYTBiOGMwYWUzOGI5ZmY0NjJhM2E=", "commit": {"author": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2017-08-10T18:37:20Z"}, "committer": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2017-08-16T15:45:05Z"}, "message": "let `compose_and_run` take a `Command`", "tree": {"sha": "da92f34844025674c493049bc43d36902aadc463", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da92f34844025674c493049bc43d36902aadc463"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e385bc5bcceaeca1c3e0a0b8c0ae38b9ff462a3a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEJ9c9OhXB85uXPmbOeLE+KEl68t8FAlmUaIEACgkQeLE+KEl6\n8t9ncBAApuSfAO49Bz4hIoiOkwz4SnlViII0T57pxNN005E3dwHRupcLV/wnUg6Z\nd82Hkn1wVGxUyd5qINN54aNclqopKcff754cnthN6CX+S2BaQMOyjRc/bj6/KH2j\nc7qqGV+1JSOuJDtDOmC2zjyAcBZu1Fk2LEdiuGJ481kHfTxXx1dyQm/DpmCJA69/\niXZq4X6cRz+z7ThTVbLS1eWSIBBNIxwPoxo0kZNjfcY1VOL0EBjiIfXBOiGC0ZDP\nlNHFR/rAH4JtRQF/a3+ejFFaoqPJ6CBi+KVdoSLHH35iU4cJmm65a0WvwmmVKF6m\nDKLoA7+iuwZMX+sujMIpgaDV7s0RTqtymVwu6CD/Ay9vv0ZL7ORflYMSc83R/7yH\njyWhfBj7x/m5GtbROqbyHLZRwp0T0CEI5DE592xyNoEA8bWG+UO6dLnMiIzCEqOH\nQqCGWUTx4fjsCaNMn3KOtgljDzYNOkD1+gpUHNA85kNwr3w5d4IMb8OnA5HTlyjw\nAkke+1NJSZmF+6hTI+j3tveNcZ9YKqS+4gPajLp7uRWSejctQ4aDTW3pSZ4GPR/V\nv/3xo7utqe+cwz9ho2T3oNLtN/yDgUqiQShgx034KjBkeNFsyxn2G7qHzoQjVLxs\nNpRqUzFyVHWLf0y+7vC9oh2KDFMaOImpCPI2Vx0HFGHypOVfEwA=\n=6sJn\n-----END PGP SIGNATURE-----", "payload": "tree da92f34844025674c493049bc43d36902aadc463\nparent 6601ffca07f9a18a07351dcb54bb85a451aacb74\nauthor Andy Russell <arussell123@gmail.com> 1502390240 -0400\ncommitter Andy Russell <arussell123@gmail.com> 1502898305 -0400\n\nlet `compose_and_run` take a `Command`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e385bc5bcceaeca1c3e0a0b8c0ae38b9ff462a3a", "html_url": "https://github.com/rust-lang/rust/commit/e385bc5bcceaeca1c3e0a0b8c0ae38b9ff462a3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e385bc5bcceaeca1c3e0a0b8c0ae38b9ff462a3a/comments", "author": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "committer": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6601ffca07f9a18a07351dcb54bb85a451aacb74", "url": "https://api.github.com/repos/rust-lang/rust/commits/6601ffca07f9a18a07351dcb54bb85a451aacb74", "html_url": "https://github.com/rust-lang/rust/commit/6601ffca07f9a18a07351dcb54bb85a451aacb74"}], "stats": {"total": 123, "additions": 55, "deletions": 68}, "files": [{"sha": "a17036ead6381549cb60d9cf3dda9bdb85ea8f66", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 55, "deletions": 68, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/e385bc5bcceaeca1c3e0a0b8c0ae38b9ff462a3a/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e385bc5bcceaeca1c3e0a0b8c0ae38b9ff462a3a/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=e385bc5bcceaeca1c3e0a0b8c0ae38b9ff462a3a", "patch": "@@ -325,39 +325,26 @@ impl<'test> TestCx<'test> {\n         }\n     }\n \n-    fn print_source(&self,\n-                    src: String,\n-                    pretty_type: &str)\n-                    -> ProcRes {\n+    fn print_source(&self, src: String, pretty_type: &str) -> ProcRes {\n         let aux_dir = self.aux_output_dir_name();\n-        self.compose_and_run(self.make_pp_args(pretty_type.to_owned()),\n+\n+        let mut rustc = Command::new(&self.config.rustc_path);\n+        rustc.arg(\"-\")\n+            .arg(\"-Zunstable-options\")\n+            .args(&[\"--unpretty\", &pretty_type])\n+            .args(&[\"--target\", &self.config.target])\n+            .arg(\"-L\").arg(&aux_dir)\n+            .args(self.split_maybe_args(&self.config.target_rustcflags))\n+            .args(&self.props.compile_flags);\n+\n+        self.compose_and_run(rustc,\n                              self.props.exec_env.clone(),\n                              self.config.compile_lib_path.to_str().unwrap(),\n                              Some(aux_dir.to_str().unwrap()),\n                              Some(src),\n                              None)\n     }\n \n-    fn make_pp_args(&self,\n-                    pretty_type: String)\n-                    -> ProcArgs {\n-        let aux_dir = self.aux_output_dir_name();\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut args = vec![\"-\".to_owned(),\n-                            \"-Zunstable-options\".to_owned(),\n-                            \"--unpretty\".to_owned(),\n-                            pretty_type,\n-                            format!(\"--target={}\", self.config.target),\n-                            \"-L\".to_owned(),\n-                            aux_dir.to_str().unwrap().to_owned()];\n-        args.extend(self.split_maybe_args(&self.config.target_rustcflags));\n-        args.extend(self.props.compile_flags.iter().cloned());\n-        ProcArgs {\n-            prog: self.config.rustc_path.to_str().unwrap().to_owned(),\n-            args,\n-        }\n-    }\n-\n     fn compare_source(&self,\n                       expected: &str,\n                       actual: &str) {\n@@ -562,9 +549,9 @@ actual:\\n\\\n                     .output()\n                     .expect(&format!(\"failed to exec `{:?}`\", gdb_path));\n                 let cmdline = {\n-                    let cmdline = self.make_cmdline(\"\",\n-                                                    &format!(\"{}-gdb\", self.config.target),\n-                                                    &debugger_opts);\n+                    let mut gdb = Command::new(&format!(\"{}-gdb\", self.config.target));\n+                    gdb.args(&debugger_opts);\n+                    let cmdline = self.make_cmdline(&gdb, \"\");\n                     logv(self.config, format!(\"executing {}\", cmdline));\n                     cmdline\n                 };\n@@ -654,15 +641,13 @@ actual:\\n\\\n                          \"-nx\".to_owned(),\n                          format!(\"-command={}\", debugger_script.to_str().unwrap())];\n \n-                let proc_args = ProcArgs {\n-                    prog: self.config.gdb.as_ref().unwrap().to_owned(),\n-                    args: debugger_opts,\n-                };\n+                let mut gdb = Command::new(self.config.gdb.as_ref().unwrap());\n+                gdb.args(&debugger_opts);\n \n                 let environment = vec![(\"PYTHONPATH\".to_owned(), rust_pp_module_abs_path)];\n \n                 debugger_run_result =\n-                    self.compose_and_run(proc_args,\n+                    self.compose_and_run(gdb,\n                                          environment,\n                                          self.config.run_lib_path.to_str().unwrap(),\n                                          None,\n@@ -1205,23 +1190,22 @@ actual:\\n\\\n             // the process) and then report back the same result.\n             _ if self.config.remote_test_client.is_some() => {\n                 let aux_dir = self.aux_output_dir_name();\n-                let mut args = self.make_run_args();\n-                let mut program = args.prog.clone();\n+                let ProcArgs { mut prog, args } = self.make_run_args();\n                 if let Ok(entries) = aux_dir.read_dir() {\n                     for entry in entries {\n                         let entry = entry.unwrap();\n                         if !entry.path().is_file() {\n                             continue\n                         }\n-                        program.push_str(\":\");\n-                        program.push_str(entry.path().to_str().unwrap());\n+                        prog.push_str(\":\");\n+                        prog.push_str(entry.path().to_str().unwrap());\n                     }\n                 }\n-                args.args.insert(0, program);\n-                args.args.insert(0, \"run\".to_string());\n-                args.prog = self.config.remote_test_client.clone().unwrap()\n-                                .into_os_string().into_string().unwrap();\n-                self.compose_and_run(args,\n+                let mut test_client = Command::new(\n+                    self.config.remote_test_client.as_ref().unwrap());\n+                test_client.args(&[\"run\", &prog]);\n+                test_client.args(args);\n+                self.compose_and_run(test_client,\n                                      env,\n                                      self.config.run_lib_path.to_str().unwrap(),\n                                      Some(aux_dir.to_str().unwrap()),\n@@ -1234,7 +1218,10 @@ actual:\\n\\\n                     Some(self.output_base_name()\n                              .parent().unwrap()\n                              .to_str().unwrap().to_owned());\n-                self.compose_and_run(self.make_run_args(),\n+                let ProcArgs { prog, args } = self.make_run_args();\n+                let mut program = Command::new(&prog);\n+                program.args(args);\n+                self.compose_and_run(program,\n                                      env,\n                                      self.config.run_lib_path.to_str().unwrap(),\n                                      Some(aux_dir.to_str().unwrap()),\n@@ -1312,8 +1299,11 @@ actual:\\n\\\n                 testpaths: &aux_testpaths,\n                 revision: self.revision\n             };\n-            let aux_args = aux_cx.make_compile_args(crate_type, &aux_testpaths.file, aux_output);\n-            let auxres = aux_cx.compose_and_run(aux_args,\n+            let ProcArgs { prog, args } =\n+                aux_cx.make_compile_args(crate_type, &aux_testpaths.file, aux_output);\n+            let mut rustc = Command::new(prog);\n+            rustc.args(&args);\n+            let auxres = aux_cx.compose_and_run(rustc,\n                                                 Vec::new(),\n                                                 aux_cx.config.compile_lib_path.to_str().unwrap(),\n                                                 Some(aux_dir.to_str().unwrap()),\n@@ -1327,7 +1317,11 @@ actual:\\n\\\n             }\n         }\n \n-        self.compose_and_run(args,\n+        let ProcArgs { prog, args } = args;\n+        let mut rustc = Command::new(prog);\n+        rustc.args(args);\n+\n+        self.compose_and_run(rustc,\n                              self.props.rustc_env.clone(),\n                              self.config.compile_lib_path.to_str().unwrap(),\n                              Some(aux_dir.to_str().unwrap()),\n@@ -1336,37 +1330,33 @@ actual:\\n\\\n     }\n \n     fn compose_and_run(&self,\n-                       ProcArgs{ args, prog }: ProcArgs,\n+                       mut command: Command,\n                        procenv: Vec<(String, String)> ,\n                        lib_path: &str,\n                        aux_path: Option<&str>,\n                        input: Option<String>,\n                        working_dir: Option<String>) -> ProcRes {\n         let cmdline =\n         {\n-            let cmdline = self.make_cmdline(lib_path,\n-                                            &prog,\n-                                            &args);\n+            let cmdline = self.make_cmdline(&command, lib_path);\n             logv(self.config, format!(\"executing {}\", cmdline));\n             cmdline\n         };\n \n-        let mut process = Command::new(&prog);\n-        process\n-            .args(&args)\n+        command\n             .stdout(Stdio::piped())\n             .stderr(Stdio::piped())\n             .stdin(Stdio::piped());\n \n-        procsrv::add_target_env(&mut process, lib_path, aux_path);\n+        procsrv::add_target_env(&mut command, lib_path, aux_path);\n         for (key, val) in procenv {\n-            process.env(&key, &val);\n+            command.env(&key, &val);\n         }\n         if let Some(cwd) = working_dir {\n-            process.current_dir(cwd);\n+            command.current_dir(cwd);\n         }\n \n-        let mut child = process.spawn().expect(&format!(\"failed to exec `{}`\", prog));\n+        let mut child = command.spawn().expect(&format!(\"failed to exec `{:?}`\", &command));\n         if let Some(input) = input {\n             child.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n         }\n@@ -1568,20 +1558,20 @@ actual:\\n\\\n         }\n     }\n \n-    fn make_cmdline(&self, libpath: &str, prog: &str, args: &[String]) -> String {\n+    fn make_cmdline(&self, command: &Command, libpath: &str) -> String {\n         use util;\n \n         // Linux and mac don't require adjusting the library search path\n         if cfg!(unix) {\n-            format!(\"{} {}\", prog, args.join(\" \"))\n+            format!(\"{:?}\", command)\n         } else {\n             // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n             // for diagnostic purposes\n             fn lib_path_cmd_prefix(path: &str) -> String {\n                 format!(\"{}=\\\"{}\\\"\", util::lib_path_env_var(), util::make_new_path(path))\n             }\n \n-            format!(\"{} {} {}\", lib_path_cmd_prefix(libpath), prog, args.join(\" \"))\n+            format!(\"{} {:?}\", lib_path_cmd_prefix(libpath), command)\n         }\n     }\n \n@@ -1715,14 +1705,11 @@ actual:\\n\\\n \n     fn check_ir_with_filecheck(&self) -> ProcRes {\n         let irfile = self.output_base_name().with_extension(\"ll\");\n-        let prog = self.config.llvm_filecheck.as_ref().unwrap();\n-        let proc_args = ProcArgs {\n-            // FIXME (#9639): This needs to handle non-utf8 paths\n-            prog: prog.to_str().unwrap().to_owned(),\n-            args: vec![format!(\"-input-file={}\", irfile.to_str().unwrap()),\n-                       self.testpaths.file.to_str().unwrap().to_owned()]\n-        };\n-        self.compose_and_run(proc_args, Vec::new(), \"\", None, None, None)\n+        let mut filecheck = Command::new(self.config.llvm_filecheck.as_ref().unwrap());\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        filecheck.arg(&format!(\"-input-file={}\", irfile.to_str().unwrap()));\n+        filecheck.arg(&self.testpaths.file);\n+        self.compose_and_run(filecheck, Vec::new(), \"\", None, None, None)\n     }\n \n     fn run_codegen_test(&self) {"}]}