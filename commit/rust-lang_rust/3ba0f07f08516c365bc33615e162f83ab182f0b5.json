{"sha": "3ba0f07f08516c365bc33615e162f83ab182f0b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiYTBmMDdmMDg1MTZjMzY1YmMzMzYxNWUxNjJmODNhYjE4MmYwYjU=", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2017-07-03T14:16:45Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2017-07-03T19:51:36Z"}, "message": "Make sNaN removal code tolerate different sNaN encodings\n\nIEEE 754-1985 specifies the encoding of NaN floating point numbers,\nbut while it mentions that NaNs can be subdivided into signaling\nand quiet ones, it doesn't fix the encoding of signaling NaNs in binary\nformats. This led to different implementations (CPUs) having different\nencodings. IEEE 754-2008 finally specified the encoding of signaling NaNs\nbut some architectures are compatible with it, while others aren't.\nCertain MIPS and PA-RISC CPUs have different encodings for signaling\nNaNs.\n\nIn order to have the float <-> binary cast feature of the std library be\nportable to them, we don't mask any quiet NaNs like we did before (only\nbeing compliant to IEEE 754-2008 and nothing else), but instead we\nsimply pass a known good NaN instead.\n\nNote that in the code removed there was a bug; the 64 bit mask for quiet\nNaNs should have been `0x0008000000000000` instead of the specified\n`0x0001000000000000`.", "tree": {"sha": "56ab120cd778d2c73ec3e066adb0712be9d86052", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56ab120cd778d2c73ec3e066adb0712be9d86052"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ba0f07f08516c365bc33615e162f83ab182f0b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ba0f07f08516c365bc33615e162f83ab182f0b5", "html_url": "https://github.com/rust-lang/rust/commit/3ba0f07f08516c365bc33615e162f83ab182f0b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ba0f07f08516c365bc33615e162f83ab182f0b5/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d2db7b9e8082f0459e000985d77fc7ad0dabade", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d2db7b9e8082f0459e000985d77fc7ad0dabade", "html_url": "https://github.com/rust-lang/rust/commit/1d2db7b9e8082f0459e000985d77fc7ad0dabade"}], "stats": {"total": 37, "additions": 24, "deletions": 13}, "files": [{"sha": "a6eb17c8fa41bf6819bfe89af7c2bfca27659be1", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3ba0f07f08516c365bc33615e162f83ab182f0b5/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba0f07f08516c365bc33615e162f83ab182f0b5/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=3ba0f07f08516c365bc33615e162f83ab182f0b5", "patch": "@@ -1131,13 +1131,16 @@ impl f32 {\n     #[inline]\n     pub fn from_bits(mut v: u32) -> Self {\n         const EXP_MASK: u32   = 0x7F800000;\n-        const QNAN_MASK: u32  = 0x00400000;\n         const FRACT_MASK: u32 = 0x007FFFFF;\n         if v & EXP_MASK == EXP_MASK && v & FRACT_MASK != 0 {\n-            // If we have a NaN value, we\n-            // convert signaling NaN values to quiet NaN\n-            // by setting the the highest bit of the fraction\n-            v |= QNAN_MASK;\n+            // While IEEE 754-2008 specifies encodings for quiet NaNs\n+            // and signaling ones, certain MIPS and PA-RISC\n+            // CPUs treat signaling NaNs differently.\n+            // Therefore to be safe, we pass a known quiet NaN\n+            // if v is any kind of NaN.\n+            // The check above only assumes IEEE 754-1985 to be\n+            // valid.\n+            v = unsafe { ::mem::transmute(NAN) };\n         }\n         unsafe { ::mem::transmute(v) }\n     }\n@@ -1732,8 +1735,15 @@ mod tests {\n     }\n     #[test]\n     fn test_snan_masking() {\n+        // NOTE: this test assumes that our current platform\n+        // implements IEEE 754-2008 that specifies the difference\n+        // in encoding of quiet and signaling NaNs.\n+        // If you are porting Rust to a platform that does not\n+        // implement IEEE 754-2008 (but e.g. IEEE 754-1985, which\n+        // only says that \"Signaling NaNs shall be reserved operands\"\n+        // but doesn't specify the actual setup), feel free to\n+        // cfg out this test.\n         let snan: u32 = 0x7F801337;\n-        const PAYLOAD_MASK: u32 = 0x003FFFFF;\n         const QNAN_MASK: u32  = 0x00400000;\n         let nan_masked_fl = f32::from_bits(snan);\n         let nan_masked = nan_masked_fl.to_bits();\n@@ -1742,7 +1752,5 @@ mod tests {\n         // Ensure that we have a quiet NaN\n         assert_ne!(nan_masked & QNAN_MASK, 0);\n         assert!(nan_masked_fl.is_nan());\n-        // Ensure the payload wasn't touched during conversion\n-        assert_eq!(nan_masked & PAYLOAD_MASK, snan & PAYLOAD_MASK);\n     }\n }"}, {"sha": "4d8d8b4ebe6aa001d725972c3148a3c9cc62e193", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3ba0f07f08516c365bc33615e162f83ab182f0b5/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba0f07f08516c365bc33615e162f83ab182f0b5/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=3ba0f07f08516c365bc33615e162f83ab182f0b5", "patch": "@@ -1046,13 +1046,16 @@ impl f64 {\n     #[inline]\n     pub fn from_bits(mut v: u64) -> Self {\n         const EXP_MASK: u64   = 0x7FF0000000000000;\n-        const QNAN_MASK: u64  = 0x0001000000000000;\n         const FRACT_MASK: u64 = 0x000FFFFFFFFFFFFF;\n         if v & EXP_MASK == EXP_MASK && v & FRACT_MASK != 0 {\n-            // If we have a NaN value, we\n-            // convert signaling NaN values to quiet NaN\n-            // by setting the the highest bit of the fraction\n-            v |= QNAN_MASK;\n+            // While IEEE 754-2008 specifies encodings for quiet NaNs\n+            // and signaling ones, certain MIPS and PA-RISC\n+            // CPUs treat signaling NaNs differently.\n+            // Therefore to be safe, we pass a known quiet NaN\n+            // if v is any kind of NaN.\n+            // The check above only assumes IEEE 754-1985 to be\n+            // valid.\n+            v = unsafe { ::mem::transmute(NAN) };\n         }\n         unsafe { ::mem::transmute(v) }\n     }"}]}