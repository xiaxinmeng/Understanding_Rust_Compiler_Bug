{"sha": "3165ddeb408cb4caf42fb48954dce4a82e3b4200", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxNjVkZGViNDA4Y2I0Y2FmNDJmYjQ4OTU0ZGNlNGE4MmUzYjQyMDA=", "commit": {"author": {"name": "kud1ing", "email": "github@kudling.de", "date": "2013-09-26T08:33:02Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-09-26T13:15:42Z"}, "message": "bitv: backticks for code in documentation", "tree": {"sha": "571cb883a99352a4cf3203c32ad98b13e3bf90b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/571cb883a99352a4cf3203c32ad98b13e3bf90b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3165ddeb408cb4caf42fb48954dce4a82e3b4200", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3165ddeb408cb4caf42fb48954dce4a82e3b4200", "html_url": "https://github.com/rust-lang/rust/commit/3165ddeb408cb4caf42fb48954dce4a82e3b4200", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3165ddeb408cb4caf42fb48954dce4a82e3b4200/comments", "author": null, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c873216ab6c25edd0719ab05171c7e49483e01d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c873216ab6c25edd0719ab05171c7e49483e01d7", "html_url": "https://github.com/rust-lang/rust/commit/c873216ab6c25edd0719ab05171c7e49483e01d7"}], "stats": {"total": 48, "additions": 24, "deletions": 24}, "files": [{"sha": "323cf5b46b5452ffc6979b73753efa74cc5fc6cd", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3165ddeb408cb4caf42fb48954dce4a82e3b4200/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3165ddeb408cb4caf42fb48954dce4a82e3b4200/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=3165ddeb408cb4caf42fb48954dce4a82e3b4200", "patch": "@@ -116,7 +116,7 @@ struct BigBitv {\n }\n \n /**\n- * a mask that has a 1 for each defined bit in the nth element of a big_bitv,\n+ * A mask that has a 1 for each defined bit in the n'th element of a `BigBitv`,\n  * assuming n bits.\n  */\n #[inline]\n@@ -284,7 +284,7 @@ impl Bitv {\n      * Calculates the union of two bitvectors\n      *\n      * Sets `self` to the union of `self` and `v1`. Both bitvectors must be\n-     * the same length. Returns 'true' if `self` changed.\n+     * the same length. Returns `true` if `self` changed.\n     */\n     #[inline]\n     pub fn union(&mut self, v1: &Bitv) -> bool { self.do_op(Union, v1) }\n@@ -293,7 +293,7 @@ impl Bitv {\n      * Calculates the intersection of two bitvectors\n      *\n      * Sets `self` to the intersection of `self` and `v1`. Both bitvectors\n-     * must be the same length. Returns 'true' if `self` changed.\n+     * must be the same length. Returns `true` if `self` changed.\n     */\n     #[inline]\n     pub fn intersect(&mut self, v1: &Bitv) -> bool {\n@@ -395,7 +395,7 @@ impl Bitv {\n         self.do_op(Difference, v)\n     }\n \n-    /// Returns true if all bits are 1\n+    /// Returns `true` if all bits are 1\n     #[inline]\n     pub fn is_true(&self) -> bool {\n       match self.rep {\n@@ -417,7 +417,7 @@ impl Bitv {\n         self.iter().invert()\n     }\n \n-    /// Returns true if all bits are 0\n+    /// Returns `true` if all bits are 0\n     pub fn is_false(&self) -> bool {\n       match self.rep {\n         Small(ref b) => b.is_false(self.nbits),\n@@ -433,18 +433,18 @@ impl Bitv {\n     }\n \n     /**\n-     * Converts `self` to a vector of uint with the same length.\n+     * Converts `self` to a vector of `uint` with the same length.\n      *\n-     * Each uint in the resulting vector has either value 0u or 1u.\n+     * Each `uint` in the resulting vector has either value `0u` or `1u`.\n      */\n     pub fn to_vec(&self) -> ~[uint] {\n         vec::from_fn(self.nbits, |x| self.init_to_vec(x))\n     }\n \n     /**\n      * Organise the bits into bytes, such that the first bit in the\n-     * bitv becomes the high-order bit of the first byte. If the\n-     * size of the bitv is not a multiple of 8 then trailing bits\n+     * `Bitv` becomes the high-order bit of the first byte. If the\n+     * size of the `Bitv` is not a multiple of 8 then trailing bits\n      * will be filled-in with false/0\n      */\n     pub fn to_bytes(&self) -> ~[u8] {\n@@ -472,7 +472,7 @@ impl Bitv {\n     }\n \n     /**\n-     * Transform self into a [bool] by turning each bit into a bool\n+     * Transform `self` into a `[bool]` by turning each bit into a `bool`.\n      */\n     pub fn to_bools(&self) -> ~[bool] {\n         vec::from_fn(self.nbits, |i| self[i])\n@@ -498,7 +498,7 @@ impl Bitv {\n \n \n     /**\n-     * Compare a bitvector to a vector of bool.\n+     * Compare a bitvector to a vector of `bool`.\n      *\n      * Both the bitvector and vector must have the same length.\n      */\n@@ -519,9 +519,9 @@ impl Bitv {\n }\n \n /**\n- * Transform a byte-vector into a bitv. Each byte becomes 8 bits,\n+ * Transform a byte-vector into a `Bitv`. Each byte becomes 8 bits,\n  * with the most significant bits of each byte coming first. Each\n- * bit becomes true if equal to 1 or false if equal to 0.\n+ * bit becomes `true` if equal to 1 or `false` if equal to 0.\n  */\n pub fn from_utf8(bytes: &[u8]) -> Bitv {\n     from_fn(bytes.len() * 8, |i| {\n@@ -532,15 +532,15 @@ pub fn from_utf8(bytes: &[u8]) -> Bitv {\n }\n \n /**\n- * Transform a [bool] into a bitv by converting each bool into a bit.\n+ * Transform a `[bool]` into a `Bitv` by converting each `bool` into a bit.\n  */\n pub fn from_bools(bools: &[bool]) -> Bitv {\n     from_fn(bools.len(), |i| bools[i])\n }\n \n /**\n- * Create a bitv of the specified length where the value at each\n- * index is f(index).\n+ * Create a `Bitv` of the specified length where the value at each\n+ * index is `f(index)`.\n  */\n pub fn from_fn(len: uint, f: &fn(index: uint) -> bool) -> Bitv {\n     let mut bitv = Bitv::new(len, false);\n@@ -571,7 +571,7 @@ fn iterate_bits(base: uint, bits: uint, f: &fn(uint) -> bool) -> bool {\n     return true;\n }\n \n-/// An iterator for Bitv\n+/// An iterator for `Bitv`.\n pub struct BitvIterator<'self> {\n     priv bitv: &'self Bitv,\n     priv next_idx: uint,\n@@ -631,12 +631,12 @@ impl<'self> RandomAccessIterator<bool> for BitvIterator<'self> {\n ///\n /// It should also be noted that the amount of storage necessary for holding a\n /// set of objects is proportional to the maximum of the objects when viewed\n-/// as a uint.\n+/// as a `uint`.\n #[deriving(Clone)]\n pub struct BitvSet {\n     priv size: uint,\n \n-    // In theory this is a Bitv instead of always a BigBitv, but knowing that\n+    // In theory this is a `Bitv` instead of always a `BigBitv`, but knowing that\n     // there's an array of storage makes our lives a whole lot easier when\n     // performing union/intersection/etc operations\n     priv bitv: BigBitv\n@@ -861,7 +861,7 @@ impl MutableSet<uint> for BitvSet {\n }\n \n impl BitvSet {\n-    /// Visits each of the words that the two bit vectors (self and other)\n+    /// Visits each of the words that the two bit vectors (`self` and `other`)\n     /// both have in common. The three yielded arguments are (bit location,\n     /// w1, w2) where the bit location is the number of bits offset so far,\n     /// and w1/w2 are the words coming from the two vectors self, other.\n@@ -874,13 +874,13 @@ impl BitvSet {\n             .map(|((i, &w), o_store)| (i * uint::bits, w, o_store[i]))\n     }\n \n-    /// Visits each word in self or other that extends beyond the other. This\n+    /// Visits each word in `self` or `other` that extends beyond the other. This\n     /// will only iterate through one of the vectors, and it only iterates\n     /// over the portion that doesn't overlap with the other one.\n     ///\n-    /// The yielded arguments are a bool, the bit offset, and a word. The bool\n-    /// is true if the word comes from 'self', and false if it comes from\n-    /// 'other'.\n+    /// The yielded arguments are a `bool`, the bit offset, and a word. The `bool`\n+    /// is true if the word comes from `self`, and `false` if it comes from\n+    /// `other`.\n     fn outlier_iter<'a>(&'a self, other: &'a BitvSet)\n         -> Map<'static, ((uint, &'a uint), uint), (bool, uint, uint),\n                Zip<Enumerate<vec::VecIterator<'a, uint>>, Repeat<uint>>> {"}]}