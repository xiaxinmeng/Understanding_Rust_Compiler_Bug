{"sha": "c282810ab04a57f7d3f476e9628b6b82184b19b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyODI4MTBhYjA0YTU3ZjdkM2Y0NzZlOTYyOGI2YjgyMTg0YjE5YjI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-26T16:59:59Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-26T17:00:33Z"}, "message": "Enforce privacy declarations for class fields and methods", "tree": {"sha": "6380e576e5dc63e5c415513a811564a2b90c5a50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6380e576e5dc63e5c415513a811564a2b90c5a50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c282810ab04a57f7d3f476e9628b6b82184b19b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c282810ab04a57f7d3f476e9628b6b82184b19b2", "html_url": "https://github.com/rust-lang/rust/commit/c282810ab04a57f7d3f476e9628b6b82184b19b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c282810ab04a57f7d3f476e9628b6b82184b19b2/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a00538b3b3da226b751767ce282682d9de28fa75", "url": "https://api.github.com/repos/rust-lang/rust/commits/a00538b3b3da226b751767ce282682d9de28fa75", "html_url": "https://github.com/rust-lang/rust/commit/a00538b3b3da226b751767ce282682d9de28fa75"}], "stats": {"total": 243, "additions": 185, "deletions": 58}, "files": [{"sha": "bada0931953234df1e0af020e11f693783066c59", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=c282810ab04a57f7d3f476e9628b6b82184b19b2", "patch": "@@ -14,7 +14,6 @@ import std::map::hashmap;\n export get_symbol;\n export get_class_fields;\n export get_class_method;\n-// export get_class_method_ids;\n export get_field_type;\n export get_type_param_count;\n export lookup_defs;\n@@ -131,14 +130,6 @@ fn get_class_fields(tcx: ty::ctxt, def: ast::def_id) -> [ty::field_ty] {\n     decoder::get_class_fields(cdata, def.node)\n }\n \n-/*\n-fn get_class_method_ids(tcx: ty::ctxt, def: ast::def_id) -> [ty::field_ty] {\n-    let cstore = tcx.sess.cstore;\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::get_class_method_ids(cdata, def.node)\n-}\n-*/\n-\n fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.sess.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);"}, {"sha": "c4860ebade7d8ac022dd74beb28365c7e80e867f", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=c282810ab04a57f7d3f476e9628b6b82184b19b2", "patch": "@@ -17,7 +17,6 @@ import middle::trans::common::maps;\n import util::ppaux::ty_to_str;\n \n export get_class_fields;\n-// export get_class_method_ids;\n export get_symbol;\n export get_enum_variants;\n export get_type;\n@@ -427,38 +426,38 @@ fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n \n // Helper function that gets either fields or methods\n fn get_class_members(cdata: cmd, id: ast::node_id,\n-                     family: char) -> [ty::field_ty] {\n+                     p: fn(char) -> bool) -> [ty::field_ty] {\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = [];\n     ebml::tagged_docs(item, tag_item_field) {|an_item|\n-       if item_family(an_item) == family {\n+       let f = item_family(an_item);\n+       if p(f) {\n           let name = item_name(an_item);\n           let did = class_member_id(an_item, cdata);\n-          result += [{ident: name, id: did}];\n+          result += [{ident: name, id: did, privacy:\n+                  // This won't work for methods, argh\n+                  family_to_privacy(f)}];\n        }\n     }\n     result\n }\n \n-\n-/* Take a node ID for a class, return a vector of the class's\n-   field names/IDs */\n-fn get_class_fields(cdata: cmd, id: ast::node_id) -> [ty::field_ty] {\n-    get_class_members(cdata, id, 'g')\n+pure fn family_to_privacy(family: char) -> ast::privacy {\n+    alt family {\n+      'g' { ast::pub }\n+      _   { ast::priv }\n+    }\n }\n \n-/*\n-/* Take a node ID for a class, return a vector of the class's\n-   method names/IDs */\n-fn get_class_method_ids(cdata: cmd, id: ast::node_id) -> [ty::field_ty] {\n-    get_class_members(cdata, id, 'h')\n+/* 'g' for public field, 'j' for private field */\n+fn get_class_fields(cdata: cmd, id: ast::node_id) -> [ty::field_ty] {\n+    get_class_members(cdata, id, {|f| f == 'g' || f == 'j'})\n }\n-*/\n \n fn family_has_type_params(fam_ch: char) -> bool {\n     alt check fam_ch {\n-      'c' | 'T' | 'm' | 'n' | 'g' | 'h' { false }\n+      'c' | 'T' | 'm' | 'n' | 'g' | 'h' | 'j' { false }\n       'f' | 'u' | 'p' | 'F' | 'U' | 'P' | 'y' | 't' | 'v' | 'i' | 'I' | 'C'\n           | 'a'\n           { true }"}, {"sha": "37d7cb600782d95f1cf939c12f35461b02f73c56", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=c282810ab04a57f7d3f476e9628b6b82184b19b2", "patch": "@@ -353,6 +353,11 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n     ebml_w.end_tag();\n }\n \n+fn encode_privacy(ebml_w: ebml::writer, privacy: privacy) {\n+    encode_family(ebml_w, alt privacy {\n+                pub { 'g' } priv { 'j' }});\n+}\n+\n /* Returns an index of items in this class */\n fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                          id: node_id, path: ast_map::path,\n@@ -369,7 +374,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n           *index += [{val: id, pos: ebml_w.writer.tell()}];\n           ebml_w.start_tag(tag_items_data_item);\n           #debug(\"encode_info_for_class: doing %s %d\", nm, id);\n-          encode_family(ebml_w, 'g');\n+          encode_privacy(ebml_w, ci.node.privacy);\n           encode_name(ebml_w, nm);\n           encode_path(ebml_w, path, ast_map::path_name(nm));\n           encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n@@ -564,19 +569,25 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         let (fs,ms) = ast_util::split_class_items(items);\n         for f in fs {\n            ebml_w.start_tag(tag_item_field);\n-           encode_family(ebml_w, 'g');\n+           encode_privacy(ebml_w, f.privacy);\n            encode_name(ebml_w, f.ident);\n            encode_def_id(ebml_w, local_def(f.id));\n            ebml_w.end_tag();\n         }\n-        for m in ms {\n-           ebml_w.start_tag(tag_item_method);\n-           #debug(\"Writing %s %d\", m.ident, m.id);\n-           encode_family(ebml_w, purity_fn_family(m.decl.purity));\n-           encode_name(ebml_w, m.ident);\n-           encode_type(ecx, ebml_w, node_id_to_type(tcx, m.id));\n-           encode_def_id(ebml_w, local_def(m.id));\n-           ebml_w.end_tag();\n+        for mt in ms {\n+           alt mt.privacy {\n+              priv { /* do nothing */ }\n+              pub {\n+                let m = mt.meth;\n+                ebml_w.start_tag(tag_item_method);\n+                #debug(\"Writing %s %d\", m.ident, m.id);\n+                encode_family(ebml_w, purity_fn_family(m.decl.purity));\n+                encode_name(ebml_w, m.ident);\n+                encode_type(ecx, ebml_w, node_id_to_type(tcx, m.id));\n+                encode_def_id(ebml_w, local_def(m.id));\n+                ebml_w.end_tag();\n+              }\n+           }\n         }\n         /* Each class has its own index -- encode it */\n         let bkts = create_index(idx, hash_node_id);"}, {"sha": "35a73a0a530f06b9f3dd25966945e0293422d549", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c282810ab04a57f7d3f476e9628b6b82184b19b2", "patch": "@@ -4271,7 +4271,8 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n \n         // Translate methods\n         let (_, ms) = ast_util::split_class_items(items);\n-        impl::trans_impl(ccx, *path, item.ident, ms, tps);\n+        impl::trans_impl(ccx, *path, item.ident,\n+                         vec::map(ms, {|m| m.meth}), tps);\n       }\n       _ {/* fall through */ }\n     }"}, {"sha": "8fac6b536c001b36da4be97b48a6bace51e054f7", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=c282810ab04a57f7d3f476e9628b6b82184b19b2", "patch": "@@ -45,6 +45,7 @@ export lookup_class_fields;\n export lookup_class_method_by_name;\n export lookup_field_type;\n export lookup_item_type;\n+export lookup_public_fields;\n export method;\n export method_idx;\n export mk_class;\n@@ -160,10 +161,10 @@ type constr_table = hashmap<ast::node_id, [constr]>;\n \n type mt = {ty: t, mutbl: ast::mutability};\n \n-// Just use <field> for class fields?\n type field_ty = {\n   ident: ident,\n   id: def_id,\n+  privacy: ast::privacy\n };\n \n // Contains information needed to resolve types and (in the future) look up\n@@ -1996,14 +1997,26 @@ fn lookup_class_fields(cx: ctxt, did: ast::def_id) -> [field_ty] {\n     }\n }\n \n+fn lookup_public_fields(cx: ctxt, did: ast::def_id) -> [field_ty] {\n+    vec::filter(lookup_class_fields(cx, did), is_public)\n+}\n+\n+pure fn is_public(f: field_ty) -> bool {\n+  alt f.privacy {\n+       pub { true }\n+       priv { false }\n+  }\n+}\n+\n // Look up the list of method names and IDs for a given class\n // Fails if the id is not bound to a class.\n fn lookup_class_method_ids(cx: ctxt, did: ast::def_id)\n-    : is_local(did) -> [{name: ident, id: node_id}] {\n+    : is_local(did) -> [{name: ident, id: node_id, privacy: privacy}] {\n     alt cx.items.find(did.node) {\n        some(ast_map::node_item(@{node: item_class(_,items,_), _}, _)) {\n          let (_,ms) = split_class_items(items);\n-         vec::map(ms, {|m| {name: m.ident, id: m.id}})\n+         vec::map(ms, {|m| {name: m.meth.ident, id: m.meth.id,\n+                         privacy: m.privacy}})\n        }\n        _ {\n            cx.sess.bug(\"lookup_class_method_ids: id not bound to a class\");\n@@ -2012,19 +2025,19 @@ fn lookup_class_method_ids(cx: ctxt, did: ast::def_id)\n }\n \n /* Given a class def_id and a method name, return the method's\n- def_id. Needed so we can do static dispatch for methods */\n+ def_id. Needed so we can do static dispatch for methods\n+ Fails if the requested method is private */\n fn lookup_class_method_by_name(cx:ctxt, did: ast::def_id, name: ident,\n-                               sp: span) ->\n-    def_id {\n+                               sp: span) -> def_id {\n     if check is_local(did) {\n        let ms = lookup_class_method_ids(cx, did);\n        for m in ms {\n-         if m.name == name {\n+         if m.name == name && m.privacy == ast::pub {\n              ret ast_util::local_def(m.id);\n          }\n        }\n-       cx.sess.span_fatal(sp, #fmt(\"Class doesn't have a method named %s\",\n-                                  name));\n+       cx.sess.span_fatal(sp, #fmt(\"Class doesn't have a public method \\\n+           named %s\", name));\n     }\n     else {\n       csearch::get_class_method(cx.sess.cstore, did, name)\n@@ -2036,7 +2049,8 @@ fn class_field_tys(items: [@class_item]) -> [field_ty] {\n     for it in items {\n        alt it.node.decl {\n           instance_var(nm, _, _, id) {\n-              rslt += [{ident: nm, id: ast_util::local_def(id)}];\n+              rslt += [{ident: nm, id: ast_util::local_def(id),\n+                          privacy: it.node.privacy}];\n           }\n           class_method(_) {\n           }"}, {"sha": "20b705f07384bc6b89712acd26975e4d89caca1a", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=c282810ab04a57f7d3f476e9628b6b82184b19b2", "patch": "@@ -11,7 +11,7 @@ import pat_util::*;\n import middle::ty;\n import middle::ty::{node_id_to_type, arg, block_ty,\n                     expr_ty, field, node_type_table, mk_nil,\n-                    ty_param_bounds_and_ty, lookup_class_fields};\n+                    ty_param_bounds_and_ty, lookup_public_fields};\n import util::ppaux::ty_to_str;\n import std::smallintmap;\n import std::map::{hashmap, int_hash};\n@@ -934,7 +934,9 @@ mod collect {\n           }\n           ast_map::node_item(@{node: ast::item_class(_,its,_), _}, _) {\n               let (_,ms) = split_class_items(its);\n-              store_methods::<@ast::method>(tcx, id, ms, {|m|\n+              // Handling all methods here\n+              let ps = ast_util::ignore_privacy(ms);\n+              store_methods::<@ast::method>(tcx, id, ps, {|m|\n                           ty_of_method(tcx, m_collect, m)});\n           }\n         }\n@@ -1089,10 +1091,13 @@ mod collect {\n               for f in fields {\n                  convert_class_item(tcx, f);\n               }\n+              // The selfty is just the class type\n               let selfty = ty::mk_class(tcx, local_def(it.id),\n                                         mk_ty_params(tcx, tps).params);\n-              // The selfty is just the class type\n-              convert_methods(tcx, methods, @[], some(selfty));\n+              // Need to convert all methods so we can check internal\n+              // references to private methods\n+              convert_methods(tcx, ast_util::ignore_privacy(methods), @[],\n+                              some(selfty));\n           }\n           _ {\n             // This call populates the type cache with the converted type\n@@ -3095,7 +3100,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n               // (1) verify that the class id actually has a field called\n               // field\n               #debug(\"class named %s\", ty_to_str(tcx, base_t));\n-              let cls_items = lookup_class_fields(tcx, base_id);\n+              /*\n+                This is an external reference, so only consider public\n+                fields\n+               */\n+              let cls_items = lookup_public_fields(tcx, base_id);\n               #debug(\"cls_items: %?\", cls_items);\n               alt lookup_field_ty(tcx, base_id, cls_items, field) {\n                  some(field_ty) {\n@@ -3119,7 +3128,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n               none {\n                 let t_err = resolve_type_vars_if_possible(fcx, expr_t);\n                 let msg = #fmt[\"attempted access of field %s on type %s, but \\\n-                                no field or method with that name was found\",\n+                          no public field or method with that name was found\",\n                                field, ty_to_str(tcx, t_err)];\n                 tcx.sess.span_err(expr.span, msg);\n                 // NB: Adding a bogus type to allow typechecking to continue\n@@ -3613,9 +3622,8 @@ fn class_types(ccx: @crate_ctxt, members: [@ast::class_item]) -> class_map {\n \n fn check_class_member(ccx: @crate_ctxt, cm: ast::class_member) {\n     alt cm {\n-      ast::instance_var(_,t,_,_) { // ??? Not sure\n+      ast::instance_var(_,t,_,_) {\n       }\n-      // not right yet -- need a scope\n       ast::class_method(m) { check_method(ccx, m); }\n     }\n }"}, {"sha": "308b13be88223deaed12db62c50d79e99cf233ba", "filename": "src/rustc/syntax/ast_util.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Frustc%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Frustc%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fast_util.rs?ref=c282810ab04a57f7d3f476e9628b6b82184b19b2", "patch": "@@ -435,16 +435,29 @@ pure fn class_item_ident(ci: @class_item) -> ident {\n     }\n }\n \n-type ivar = {ident: ident, ty: @ty, cm: class_mutability, id: node_id};\n+type ivar = {ident: ident, ty: @ty, cm: class_mutability,\n+             id: node_id, privacy: privacy};\n \n-fn split_class_items(cs: [@class_item]) -> ([ivar], [@method]) {\n+type cmethod = {privacy: privacy, meth: @method};\n+\n+fn public_methods(cms: [cmethod]) -> [@method] {\n+    vec::filter_map(cms, {|cm| alt cm.privacy {\n+                    pub { some(cm.meth) }\n+                    _   { none }}})\n+}\n+\n+fn ignore_privacy(cms: [cmethod]) -> [@method] {\n+    vec::map(cms, {|cm| cm.meth})\n+}\n+\n+fn split_class_items(cs: [@class_item]) -> ([ivar], [cmethod]) {\n     let mut vs = [], ms = [];\n     for c in cs {\n       alt c.node.decl {\n         instance_var(i, t, cm, id) {\n-          vs += [{ident: i, ty: t, cm: cm, id: id}];\n+          vs += [{ident: i, ty: t, cm: cm, id: id, privacy: c.node.privacy}];\n         }\n-        class_method(m) { ms += [m]; }\n+        class_method(m) { ms += [{privacy: c.node.privacy, meth: m}]; }\n       }\n     }\n     (vs, ms)"}, {"sha": "8a213b0849722a7e03bb4779ad6e4d1b141dfca2", "filename": "src/test/compile-fail/assign-to-method.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs?ref=c282810ab04a57f7d3f476e9628b6b82184b19b2", "patch": "@@ -0,0 +1,16 @@\n+// error-pattern:assigning to immutable field\n+class cat {\n+  priv {\n+    let mutable meows : uint;\n+  }\n+\n+  let how_hungry : int;\n+\n+  fn speak() { meows += 1u; }\n+  new(in_x : uint, in_y : int) { meows = in_x; how_hungry = in_y; }\n+}\n+\n+fn main() {\n+  let nyan : cat = cat(52u, 99);\n+  nyan.speak = fn@() { log(error, \"meow\"); };\n+}"}, {"sha": "e7ba6339ea7e61fc40bea8b94672ff5dd5728c2f", "filename": "src/test/compile-fail/private-class-field.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Ftest%2Fcompile-fail%2Fprivate-class-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Ftest%2Fcompile-fail%2Fprivate-class-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-class-field.rs?ref=c282810ab04a57f7d3f476e9628b6b82184b19b2", "patch": "@@ -0,0 +1,24 @@\n+// error-pattern:no public field or method with that name\n+class cat {\n+  priv {\n+    let mutable meows : uint;\n+  }\n+\n+  let how_hungry : int;\n+\n+  new(in_x : uint, in_y : int) { meows = in_x; how_hungry = in_y; }\n+}\n+\n+fn main() {\n+  let nyan : cat = cat(52u, 99);\n+  assert (nyan.meows == 52u);\n+}\n+/*\n+  other tests:\n+  not ok to refer to a private method outside a class\n+  ok to refer to private method within a class\n+  can't assign to a non-mutable var\n+  can't assign to a method\n+\n+  all the same tests, cross-crate\n+ */\n\\ No newline at end of file"}, {"sha": "8b257c11cd95759d0c04091ad366d028ece54bd9", "filename": "src/test/compile-fail/private-method.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs?ref=c282810ab04a57f7d3f476e9628b6b82184b19b2", "patch": "@@ -0,0 +1,16 @@\n+// error-pattern:Class doesn't have a public method named nap\n+class cat {\n+  priv {\n+    let mutable meows : uint;\n+    fn nap() { uint::range(1u, 10000u) {|_i|}}\n+  }\n+\n+  let how_hungry : int;\n+\n+  new(in_x : uint, in_y : int) { meows = in_x; how_hungry = in_y; }\n+}\n+\n+fn main() {\n+  let nyan : cat = cat(52u, 99);\n+  nyan.nap();\n+}"}, {"sha": "6d11ce2c3dad2280a659f40b135b99b4016d864d", "filename": "src/test/run-pass/private-class-field.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Ftest%2Frun-pass%2Fprivate-class-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Ftest%2Frun-pass%2Fprivate-class-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprivate-class-field.rs?ref=c282810ab04a57f7d3f476e9628b6b82184b19b2", "patch": "@@ -0,0 +1,15 @@\n+class cat {\n+  priv {\n+    let mutable meows : uint;\n+  }\n+\n+  let how_hungry : int;\n+\n+  fn meow_count() -> uint { meows }\n+  new(in_x : uint, in_y : int) { meows = in_x; how_hungry = in_y; }\n+}\n+\n+fn main() {\n+  let nyan : cat = cat(52u, 99);\n+  assert (nyan.meow_count() == 52u);\n+}"}, {"sha": "6e95d3d314f9cac03365879d777321cdfb90b3d8", "filename": "src/test/run-pass/private-method.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Ftest%2Frun-pass%2Fprivate-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c282810ab04a57f7d3f476e9628b6b82184b19b2/src%2Ftest%2Frun-pass%2Fprivate-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprivate-method.rs?ref=c282810ab04a57f7d3f476e9628b6b82184b19b2", "patch": "@@ -0,0 +1,19 @@\n+class cat {\n+  priv {\n+    let mutable meows : uint;\n+    fn nap() { uint::range(1u, 10u) {|_i|}}\n+  }\n+\n+  let how_hungry : int;\n+\n+  fn play() {\n+    meows += 1u;\n+    nap();\n+  }\n+  new(in_x : uint, in_y : int) { meows = in_x; how_hungry = in_y; }\n+}\n+\n+fn main() {\n+  let nyan : cat = cat(52u, 99);\n+  nyan.play();\n+}"}]}