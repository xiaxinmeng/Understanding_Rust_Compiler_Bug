{"sha": "06f1a64bd6e417b73f1b812b860271e86bb42b47", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2ZjFhNjRiZDZlNDE3YjczZjFiODEyYjg2MDI3MWU4NmJiNDJiNDc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-19T22:45:39Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-20T22:21:09Z"}, "message": "core::rt: Convert users of local_sched to Local trait", "tree": {"sha": "e7d4c337d71cbf38ee1ee2fff78e1dc71bb5d018", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7d4c337d71cbf38ee1ee2fff78e1dc71bb5d018"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06f1a64bd6e417b73f1b812b860271e86bb42b47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06f1a64bd6e417b73f1b812b860271e86bb42b47", "html_url": "https://github.com/rust-lang/rust/commit/06f1a64bd6e417b73f1b812b860271e86bb42b47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06f1a64bd6e417b73f1b812b860271e86bb42b47/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18fab45aab8622b0bfbcd336d57652bfb2f4f4ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/18fab45aab8622b0bfbcd336d57652bfb2f4f4ac", "html_url": "https://github.com/rust-lang/rust/commit/18fab45aab8622b0bfbcd336d57652bfb2f4f4ac"}], "stats": {"total": 288, "additions": 143, "deletions": 145}, "files": [{"sha": "544d9817558c61e3d13eab03054b1374eecd57eb", "filename": "src/libcore/rt/comm.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/06f1a64bd6e417b73f1b812b860271e86bb42b47/src%2Flibcore%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f1a64bd6e417b73f1b812b860271e86bb42b47/src%2Flibcore%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fcomm.rs?ref=06f1a64bd6e417b73f1b812b860271e86bb42b47", "patch": "@@ -20,7 +20,8 @@ use cast;\n use util;\n use ops::Drop;\n use kinds::Owned;\n-use rt::sched::Coroutine;\n+use rt::sched::{Scheduler, Coroutine};\n+use rt::local::Local;\n use rt::local_sched;\n use unstable::intrinsics::{atomic_xchg, atomic_load};\n use util::Void;\n@@ -127,7 +128,7 @@ impl<T> ChanOne<T> {\n                 task_as_state => {\n                     // Port is blocked. Wake it up.\n                     let recvr: ~Coroutine = cast::transmute(task_as_state);\n-                    let sched = local_sched::take();\n+                    let sched = Local::take::<Scheduler>();\n                     sched.schedule_task(recvr);\n                 }\n             }\n@@ -157,7 +158,7 @@ impl<T> PortOne<T> {\n         // XXX: Optimize this to not require the two context switches when data is available\n \n         // Switch to the scheduler to put the ~Task into the Packet state.\n-        let sched = local_sched::take();\n+        let sched = Local::take::<Scheduler>();\n         do sched.deschedule_running_task_and_then |task| {\n             unsafe {\n                 // Atomically swap the task pointer into the Packet state, issuing\n@@ -173,7 +174,7 @@ impl<T> PortOne<T> {\n                     STATE_ONE => {\n                         // Channel is closed. Switch back and check the data.\n                         let task: ~Coroutine = cast::transmute(task_as_state);\n-                        let sched = local_sched::take();\n+                        let sched = Local::take::<Scheduler>();\n                         sched.resume_task_immediately(task);\n                     }\n                     _ => util::unreachable()\n@@ -239,7 +240,7 @@ impl<T> Drop for ChanOneHack<T> {\n                     // The port is blocked waiting for a message we will never send. Wake it.\n                     assert!((*this.packet()).payload.is_none());\n                     let recvr: ~Coroutine = cast::transmute(task_as_state);\n-                    let sched = local_sched::take();\n+                    let sched = Local::take::<Scheduler>();\n                     sched.schedule_task(recvr);\n                 }\n             }"}, {"sha": "c054ba68d1082d1b196e6681be02fbd539a03c30", "filename": "src/libcore/rt/local.rs", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/06f1a64bd6e417b73f1b812b860271e86bb42b47/src%2Flibcore%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f1a64bd6e417b73f1b812b860271e86bb42b47/src%2Flibcore%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal.rs?ref=06f1a64bd6e417b73f1b812b860271e86bb42b47", "patch": "@@ -12,17 +12,51 @@ use rt::sched::Scheduler;\n use rt::local_ptr;\n \n pub trait Local {\n-    fn put_local(value: ~Self);\n-    fn take_local() -> ~Self;\n-    fn exists_local() -> bool;\n-    fn borrow_local(f: &fn(&mut Self));\n-    unsafe fn unsafe_borrow_local() -> *mut Self;\n+    fn put(value: ~Self);\n+    fn take() -> ~Self;\n+    fn exists() -> bool;\n+    fn borrow(f: &fn(&mut Self));\n+    unsafe fn unsafe_borrow() -> *mut Self;\n }\n \n impl Local for Scheduler {\n-    fn put_local(value: ~Scheduler) { unsafe { local_ptr::put(value) }}\n-    fn take_local() -> ~Scheduler { unsafe { local_ptr::take() } }\n-    fn exists_local() -> bool { local_ptr::exists() }\n-    fn borrow_local(f: &fn(&mut Scheduler)) { unsafe { local_ptr::borrow(f) } }\n-    unsafe fn unsafe_borrow_local() -> *mut Scheduler { local_ptr::unsafe_borrow() }\n+    fn put(value: ~Scheduler) { unsafe { local_ptr::put(value) }}\n+    fn take() -> ~Scheduler { unsafe { local_ptr::take() } }\n+    fn exists() -> bool { local_ptr::exists() }\n+    fn borrow(f: &fn(&mut Scheduler)) { unsafe { local_ptr::borrow(f) } }\n+    unsafe fn unsafe_borrow() -> *mut Scheduler { local_ptr::unsafe_borrow() }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use rt::sched::Scheduler;\n+    use rt::uv::uvio::UvEventLoop;\n+    use super::*;\n+\n+    #[test]\n+    fn thread_local_scheduler_smoke_test() {\n+        let scheduler = ~UvEventLoop::new_scheduler();\n+        Local::put(scheduler);\n+        let _scheduler: ~Scheduler = Local::take();\n+    }\n+\n+    #[test]\n+    fn thread_local_scheduler_two_instances() {\n+        let scheduler = ~UvEventLoop::new_scheduler();\n+        Local::put(scheduler);\n+        let _scheduler: ~Scheduler = Local::take();\n+        let scheduler = ~UvEventLoop::new_scheduler();\n+        Local::put(scheduler);\n+        let _scheduler: ~Scheduler = Local::take();\n+    }\n+\n+    #[test]\n+    fn borrow_smoke_test() {\n+        let scheduler = ~UvEventLoop::new_scheduler();\n+        Local::put(scheduler);\n+        unsafe {\n+            let _scheduler: *mut Scheduler = Local::unsafe_borrow();\n+        }\n+        let _scheduler: ~Scheduler = Local::take();\n+    }\n }\n\\ No newline at end of file"}, {"sha": "48e3351c44f28b00e16d9e57912e94d64690bf53", "filename": "src/libcore/rt/local_sched.rs", "status": "modified", "additions": 1, "deletions": 49, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/06f1a64bd6e417b73f1b812b860271e86bb42b47/src%2Flibcore%2Frt%2Flocal_sched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f1a64bd6e417b73f1b812b860271e86bb42b47/src%2Flibcore%2Frt%2Flocal_sched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_sched.rs?ref=06f1a64bd6e417b73f1b812b860271e86bb42b47", "patch": "@@ -25,56 +25,8 @@ use rt::local::Local;\n \n #[cfg(test)] use rt::uv::uvio::UvEventLoop;\n \n-/// Give the Scheduler to thread-local storage\n-pub fn put(sched: ~Scheduler) { Local::put_local(sched) }\n-\n-/// Take ownership of the Scheduler from thread-local storage\n-pub fn take() -> ~Scheduler { Local::take_local() }\n-\n-/// Check whether there is a thread-local Scheduler attached to the running thread\n-pub fn exists() -> bool { Local::exists_local::<Scheduler>() }\n-\n-/// Borrow the thread-local scheduler from thread-local storage.\n-/// While the scheduler is borrowed it is not available in TLS.\n-pub fn borrow(f: &fn(&mut Scheduler)) { Local::borrow_local(f) }\n-\n-/// Borrow a mutable reference to the thread-local Scheduler\n-///\n-/// # Safety Note\n-///\n-/// Because this leaves the Scheduler in thread-local storage it is possible\n-/// For the Scheduler pointer to be aliased\n-pub unsafe fn unsafe_borrow() -> *mut Scheduler { Local::unsafe_borrow_local() }\n-\n pub unsafe fn unsafe_borrow_io() -> *mut IoFactoryObject {\n-    let sched = unsafe_borrow();\n+    let sched = Local::unsafe_borrow::<Scheduler>();\n     let io: *mut IoFactoryObject = (*sched).event_loop.io().unwrap();\n     return io;\n }\n-\n-#[test]\n-fn thread_local_scheduler_smoke_test() {\n-    let scheduler = ~UvEventLoop::new_scheduler();\n-    put(scheduler);\n-    let _scheduler = take();\n-}\n-\n-#[test]\n-fn thread_local_scheduler_two_instances() {\n-    let scheduler = ~UvEventLoop::new_scheduler();\n-    put(scheduler);\n-    let _scheduler = take();\n-    let scheduler = ~UvEventLoop::new_scheduler();\n-    put(scheduler);\n-    let _scheduler = take();\n-}\n-\n-#[test]\n-fn borrow_smoke_test() {\n-    let scheduler = ~UvEventLoop::new_scheduler();\n-    put(scheduler);\n-    unsafe {\n-        let _scheduler = unsafe_borrow();\n-    }\n-    let _scheduler = take();\n-}"}, {"sha": "c8532f6b94a3a84cf15bef09301c67b9799e5e10", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06f1a64bd6e417b73f1b812b860271e86bb42b47/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f1a64bd6e417b73f1b812b860271e86bb42b47/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=06f1a64bd6e417b73f1b812b860271e86bb42b47", "patch": "@@ -188,16 +188,17 @@ pub enum RuntimeContext {\n pub fn context() -> RuntimeContext {\n \n     use task::rt::rust_task;\n-    use self::sched::local_sched;\n+    use self::local::Local;\n+    use self::sched::{local_sched, Scheduler};\n \n     // XXX: Hitting TLS twice to check if the scheduler exists\n     // then to check for the task is not good for perf\n     if unsafe { rust_try_get_task().is_not_null() } {\n         return OldTaskContext;\n     } else {\n-        if local_sched::exists() {\n+        if Local::exists::<Scheduler>() {\n             let context = ::cell::empty_cell();\n-            do local_sched::borrow |sched| {\n+            do Local::borrow::<Scheduler> |sched| {\n                 if sched.in_task_context() {\n                     context.put_back(TaskContext);\n                 } else {\n@@ -219,21 +220,22 @@ pub fn context() -> RuntimeContext {\n #[test]\n fn test_context() {\n     use unstable::run_in_bare_thread;\n-    use self::sched::{local_sched, Coroutine};\n+    use self::sched::{local_sched, Scheduler, Coroutine};\n     use rt::uv::uvio::UvEventLoop;\n     use cell::Cell;\n+    use rt::local::Local;\n \n     assert_eq!(context(), OldTaskContext);\n     do run_in_bare_thread {\n         assert_eq!(context(), GlobalContext);\n         let mut sched = ~UvEventLoop::new_scheduler();\n         let task = ~do Coroutine::new(&mut sched.stack_pool) {\n             assert_eq!(context(), TaskContext);\n-            let sched = local_sched::take();\n+            let sched = Local::take::<Scheduler>();\n             do sched.deschedule_running_task_and_then() |task| {\n                 assert_eq!(context(), SchedulerContext);\n                 let task = Cell(task);\n-                do local_sched::borrow |sched| {\n+                do Local::borrow::<Scheduler> |sched| {\n                     sched.enqueue_task(task.take());\n                 }\n             }"}, {"sha": "0004ef29de02a7665405dcf32ac1e59f99879a80", "filename": "src/libcore/rt/sched.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/06f1a64bd6e417b73f1b812b860271e86bb42b47/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f1a64bd6e417b73f1b812b860271e86bb42b47/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=06f1a64bd6e417b73f1b812b860271e86bb42b47", "patch": "@@ -19,6 +19,7 @@ use super::rtio::{EventLoop, EventLoopObject};\n use super::context::Context;\n use super::task::Task;\n use rt::local_ptr;\n+use rt::local::Local;\n \n // A more convenient name for external callers, e.g. `local_sched::take()`\n pub mod local_sched;\n@@ -94,12 +95,12 @@ pub impl Scheduler {\n             };\n \n             // Give ownership of the scheduler (self) to the thread\n-            local_sched::put(self_sched);\n+            Local::put(self_sched);\n \n             (*event_loop).run();\n         }\n \n-        let sched = local_sched::take();\n+        let sched = Local::take::<Scheduler>();\n         assert!(sched.work_queue.is_empty());\n         return sched;\n     }\n@@ -114,7 +115,7 @@ pub impl Scheduler {\n         self.event_loop.callback(resume_task_from_queue);\n \n         fn resume_task_from_queue() {\n-            let scheduler = local_sched::take();\n+            let scheduler = Local::take::<Scheduler>();\n             scheduler.resume_task_from_queue();\n         }\n     }\n@@ -134,7 +135,7 @@ pub impl Scheduler {\n             }\n             None => {\n                 rtdebug!(\"no tasks in queue\");\n-                local_sched::put(this);\n+                Local::put(this);\n             }\n         }\n     }\n@@ -150,7 +151,7 @@ pub impl Scheduler {\n \n         do self.deschedule_running_task_and_then |dead_task| {\n             let dead_task = Cell(dead_task);\n-            do local_sched::borrow |sched| {\n+            do Local::borrow::<Scheduler> |sched| {\n                 dead_task.take().recycle(&mut sched.stack_pool);\n             }\n         }\n@@ -163,7 +164,7 @@ pub impl Scheduler {\n \n         do self.switch_running_tasks_and_then(task) |last_task| {\n             let last_task = Cell(last_task);\n-            do local_sched::borrow |sched| {\n+            do Local::borrow::<Scheduler> |sched| {\n                 sched.enqueue_task(last_task.take());\n             }\n         }\n@@ -174,7 +175,7 @@ pub impl Scheduler {\n \n         do self.switch_running_tasks_and_then(task) |last_task| {\n             let last_task = Cell(last_task);\n-            do local_sched::borrow |sched| {\n+            do Local::borrow::<Scheduler> |sched| {\n                 sched.enqueue_task(last_task.take());\n             }\n         }\n@@ -192,18 +193,18 @@ pub impl Scheduler {\n         this.current_task = Some(task);\n         this.enqueue_cleanup_job(DoNothing);\n \n-        local_sched::put(this);\n+        Local::put(this);\n \n         // Take pointers to both the task and scheduler's saved registers.\n         unsafe {\n-            let sched = local_sched::unsafe_borrow();\n+            let sched = Local::unsafe_borrow::<Scheduler>();\n             let (sched_context, _, next_task_context) = (*sched).get_contexts();\n             let next_task_context = next_task_context.unwrap();\n             // Context switch to the task, restoring it's registers\n             // and saving the scheduler's\n             Context::swap(sched_context, next_task_context);\n \n-            let sched = local_sched::unsafe_borrow();\n+            let sched = Local::unsafe_borrow::<Scheduler>();\n             // The running task should have passed ownership elsewhere\n             assert!((*sched).current_task.is_none());\n \n@@ -233,16 +234,16 @@ pub impl Scheduler {\n             this.enqueue_cleanup_job(GiveTask(blocked_task, f_opaque));\n         }\n \n-        local_sched::put(this);\n+        Local::put(this);\n \n         unsafe {\n-            let sched = local_sched::unsafe_borrow();\n+            let sched = Local::unsafe_borrow::<Scheduler>();\n             let (sched_context, last_task_context, _) = (*sched).get_contexts();\n             let last_task_context = last_task_context.unwrap();\n             Context::swap(last_task_context, sched_context);\n \n             // We could be executing in a different thread now\n-            let sched = local_sched::unsafe_borrow();\n+            let sched = Local::unsafe_borrow::<Scheduler>();\n             (*sched).run_cleanup_job();\n         }\n     }\n@@ -262,17 +263,17 @@ pub impl Scheduler {\n         this.enqueue_cleanup_job(GiveTask(old_running_task, f_opaque));\n         this.current_task = Some(next_task);\n \n-        local_sched::put(this);\n+        Local::put(this);\n \n         unsafe {\n-            let sched = local_sched::unsafe_borrow();\n+            let sched = Local::unsafe_borrow::<Scheduler>();\n             let (_, last_task_context, next_task_context) = (*sched).get_contexts();\n             let last_task_context = last_task_context.unwrap();\n             let next_task_context = next_task_context.unwrap();\n             Context::swap(last_task_context, next_task_context);\n \n             // We could be executing in a different thread now\n-            let sched = local_sched::unsafe_borrow();\n+            let sched = Local::unsafe_borrow::<Scheduler>();\n             (*sched).run_cleanup_job();\n         }\n     }\n@@ -377,16 +378,16 @@ pub impl Coroutine {\n             // context switch to the task. The previous context may\n             // have asked us to do some cleanup.\n             unsafe {\n-                let sched = local_sched::unsafe_borrow();\n+                let sched = Local::unsafe_borrow::<Scheduler>();\n                 (*sched).run_cleanup_job();\n \n-                let sched = local_sched::unsafe_borrow();\n+                let sched = Local::unsafe_borrow::<Scheduler>();\n                 let task = (*sched).current_task.get_mut_ref();\n                 // FIXME #6141: shouldn't neet to put `start()` in another closure\n                 task.task.run(||start());\n             }\n \n-            let sched = local_sched::take();\n+            let sched = Local::take::<Scheduler>();\n             sched.terminate_current_task();\n         };\n         return wrapper;\n@@ -409,6 +410,7 @@ mod test {\n     use rt::uv::uvio::UvEventLoop;\n     use unstable::run_in_bare_thread;\n     use task::spawn;\n+    use rt::local::Local;\n     use rt::test::*;\n     use super::*;\n \n@@ -456,14 +458,14 @@ mod test {\n             let mut sched = ~UvEventLoop::new_scheduler();\n             let task1 = ~do Coroutine::new(&mut sched.stack_pool) {\n                 unsafe { *count_ptr = *count_ptr + 1; }\n-                let mut sched = local_sched::take();\n+                let mut sched = Local::take::<Scheduler>();\n                 let task2 = ~do Coroutine::new(&mut sched.stack_pool) {\n                     unsafe { *count_ptr = *count_ptr + 1; }\n                 };\n                 // Context switch directly to the new task\n                 do sched.switch_running_tasks_and_then(task2) |task1| {\n                     let task1 = Cell(task1);\n-                    do local_sched::borrow |sched| {\n+                    do Local::borrow::<Scheduler> |sched| {\n                         sched.enqueue_task(task1.take());\n                     }\n                 }\n@@ -493,7 +495,7 @@ mod test {\n             assert_eq!(count, MAX);\n \n             fn run_task(count_ptr: *mut int) {\n-                do local_sched::borrow |sched| {\n+                do Local::borrow::<Scheduler> |sched| {\n                     let task = ~do Coroutine::new(&mut sched.stack_pool) {\n                         unsafe {\n                             *count_ptr = *count_ptr + 1;\n@@ -513,11 +515,11 @@ mod test {\n         do run_in_bare_thread {\n             let mut sched = ~UvEventLoop::new_scheduler();\n             let task = ~do Coroutine::new(&mut sched.stack_pool) {\n-                let sched = local_sched::take();\n+                let sched = Local::take::<Scheduler>();\n                 assert!(sched.in_task_context());\n                 do sched.deschedule_running_task_and_then() |task| {\n                     let task = Cell(task);\n-                    do local_sched::borrow |sched| {\n+                    do Local::borrow::<Scheduler> |sched| {\n                         assert!(!sched.in_task_context());\n                         sched.enqueue_task(task.take());\n                     }\n@@ -536,17 +538,17 @@ mod test {\n         // exit before emptying the work queue\n         do run_in_newsched_task {\n             do spawn {\n-                let sched = local_sched::take();\n+                let sched = Local::take::<Scheduler>();\n                 do sched.deschedule_running_task_and_then |task| {\n-                    let mut sched = local_sched::take();\n+                    let mut sched = Local::take::<Scheduler>();\n                     let task = Cell(task);\n                     do sched.event_loop.callback_ms(10) {\n                         rtdebug!(\"in callback\");\n-                        let mut sched = local_sched::take();\n+                        let mut sched = Local::take::<Scheduler>();\n                         sched.enqueue_task(task.take());\n-                        local_sched::put(sched);\n+                        Local::put(sched);\n                     }\n-                    local_sched::put(sched);\n+                    Local::put(sched);\n                 }\n             }\n         }"}, {"sha": "cfb5b965860349953fa736debd5d2bda0fe820ab", "filename": "src/libcore/rt/task.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/06f1a64bd6e417b73f1b812b860271e86bb42b47/src%2Flibcore%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f1a64bd6e417b73f1b812b860271e86bb42b47/src%2Flibcore%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftask.rs?ref=06f1a64bd6e417b73f1b812b860271e86bb42b47", "patch": "@@ -16,7 +16,8 @@\n use prelude::*;\n use libc::{c_void, uintptr_t};\n use cast::transmute;\n-use super::sched::local_sched;\n+use super::sched::{Scheduler, local_sched};\n+use rt::local::Local;\n use super::local_heap::LocalHeap;\n use rt::logging::StdErrLogger;\n \n@@ -152,7 +153,7 @@ impl Unwinder {\n /// Borrow a pointer to the installed local services.\n /// Fails (likely aborting the process) if local services are not available.\n pub fn borrow_local_task(f: &fn(&mut Task)) {\n-    do local_sched::borrow |sched| {\n+    do Local::borrow::<Scheduler> |sched| {\n         match sched.current_task {\n             Some(~ref mut task) => {\n                 f(&mut *task.task)\n@@ -165,7 +166,7 @@ pub fn borrow_local_task(f: &fn(&mut Task)) {\n }\n \n pub unsafe fn unsafe_borrow_local_task() -> *mut Task {\n-    match (*local_sched::unsafe_borrow()).current_task {\n+    match (*Local::unsafe_borrow::<Scheduler>()).current_task {\n         Some(~ref mut task) => {\n             let s: *mut Task = &mut *task.task;\n             return s;\n@@ -178,7 +179,7 @@ pub unsafe fn unsafe_borrow_local_task() -> *mut Task {\n }\n \n pub unsafe fn unsafe_try_borrow_local_task() -> Option<*mut Task> {\n-    if local_sched::exists() {\n+    if Local::exists::<Scheduler>() {\n         Some(unsafe_borrow_local_task())\n     } else {\n         None"}, {"sha": "c60ae2bfeffc8bb06500750dd2dc98a7fdbfd444", "filename": "src/libcore/rt/test.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/06f1a64bd6e417b73f1b812b860271e86bb42b47/src%2Flibcore%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f1a64bd6e417b73f1b812b860271e86bb42b47/src%2Flibcore%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftest.rs?ref=06f1a64bd6e417b73f1b812b860271e86bb42b47", "patch": "@@ -15,6 +15,7 @@ use result::{Result, Ok, Err};\n use super::io::net::ip::{IpAddr, Ipv4};\n use rt::task::Task;\n use rt::thread::Thread;\n+use rt::local::Local;\n \n /// Creates a new scheduler in a new thread and runs a task in it,\n /// then waits for the scheduler to exit. Failure of the task\n@@ -40,13 +41,13 @@ pub fn run_in_newsched_task(f: ~fn()) {\n pub fn spawntask(f: ~fn()) {\n     use super::sched::*;\n \n-    let mut sched = local_sched::take();\n+    let mut sched = Local::take::<Scheduler>();\n     let task = ~Coroutine::with_task(&mut sched.stack_pool,\n                                      ~Task::without_unwinding(),\n                                      f);\n     do sched.switch_running_tasks_and_then(task) |task| {\n         let task = Cell(task);\n-        let sched = local_sched::take();\n+        let sched = Local::take::<Scheduler>();\n         sched.schedule_new_task(task.take());\n     }\n }\n@@ -55,13 +56,13 @@ pub fn spawntask(f: ~fn()) {\n pub fn spawntask_immediately(f: ~fn()) {\n     use super::sched::*;\n \n-    let mut sched = local_sched::take();\n+    let mut sched = Local::take::<Scheduler>();\n     let task = ~Coroutine::with_task(&mut sched.stack_pool,\n                                      ~Task::without_unwinding(),\n                                      f);\n     do sched.switch_running_tasks_and_then(task) |task| {\n         let task = Cell(task);\n-        do local_sched::borrow |sched| {\n+        do Local::borrow::<Scheduler> |sched| {\n             sched.enqueue_task(task.take());\n         }\n     }\n@@ -71,13 +72,13 @@ pub fn spawntask_immediately(f: ~fn()) {\n pub fn spawntask_later(f: ~fn()) {\n     use super::sched::*;\n \n-    let mut sched = local_sched::take();\n+    let mut sched = Local::take::<Scheduler>();\n     let task = ~Coroutine::with_task(&mut sched.stack_pool,\n                                      ~Task::without_unwinding(),\n                                      f);\n \n     sched.enqueue_task(task);\n-    local_sched::put(sched);\n+    Local::put(sched);\n }\n \n /// Spawn a task and either run it immediately or run it later\n@@ -88,21 +89,21 @@ pub fn spawntask_random(f: ~fn()) {\n     let mut rng = rng();\n     let run_now: bool = Rand::rand(&mut rng);\n \n-    let mut sched = local_sched::take();\n+    let mut sched = Local::take::<Scheduler>();\n     let task = ~Coroutine::with_task(&mut sched.stack_pool,\n                                      ~Task::without_unwinding(),\n                                      f);\n \n     if run_now {\n         do sched.switch_running_tasks_and_then(task) |task| {\n             let task = Cell(task);\n-            do local_sched::borrow |sched| {\n+            do Local::borrow::<Scheduler> |sched| {\n                 sched.enqueue_task(task.take());\n             }\n         }\n     } else {\n         sched.enqueue_task(task);\n-        local_sched::put(sched);\n+        Local::put(sched);\n     }\n }\n \n@@ -120,21 +121,21 @@ pub fn spawntask_try(f: ~fn()) -> Result<(), ()> {\n \n     // Switch to the scheduler\n     let f = Cell(Cell(f));\n-    let sched = local_sched::take();\n+    let sched = Local::take::<Scheduler>();\n     do sched.deschedule_running_task_and_then() |old_task| {\n         let old_task = Cell(old_task);\n         let f = f.take();\n-        let mut sched = local_sched::take();\n+        let mut sched = Local::take::<Scheduler>();\n         let new_task = ~do Coroutine::new(&mut sched.stack_pool) {\n             do (|| {\n                 (f.take())()\n             }).finally {\n                 // Check for failure then resume the parent task\n                 unsafe { *failed_ptr = task::failing(); }\n-                let sched = local_sched::take();\n+                let sched = Local::take::<Scheduler>();\n                 do sched.switch_running_tasks_and_then(old_task.take()) |new_task| {\n                     let new_task = Cell(new_task);\n-                    do local_sched::borrow |sched| {\n+                    do Local::borrow::<Scheduler> |sched| {\n                         sched.enqueue_task(new_task.take());\n                     }\n                 }"}, {"sha": "2e6dc64986ebfeefa2037b691710ca7a7a3a36f0", "filename": "src/libcore/rt/tube.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/06f1a64bd6e417b73f1b812b860271e86bb42b47/src%2Flibcore%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f1a64bd6e417b73f1b812b860271e86bb42b47/src%2Flibcore%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftube.rs?ref=06f1a64bd6e417b73f1b812b860271e86bb42b47", "patch": "@@ -16,9 +16,10 @@\n use option::*;\n use clone::Clone;\n use super::rc::RC;\n-use rt::sched::Coroutine;\n+use rt::sched::{Scheduler, Coroutine};\n use rt::{context, TaskContext, SchedulerContext};\n use rt::local_sched;\n+use rt::local::Local;\n use vec::OwnedVector;\n use container::Container;\n \n@@ -53,7 +54,7 @@ impl<T> Tube<T> {\n                 // There's a waiting task. Wake it up\n                 rtdebug!(\"waking blocked tube\");\n                 let task = (*state).blocked_task.swap_unwrap();\n-                let sched = local_sched::take();\n+                let sched = Local::take::<Scheduler>();\n                 sched.resume_task_immediately(task);\n             }\n         }\n@@ -71,7 +72,7 @@ impl<T> Tube<T> {\n                 rtdebug!(\"blocking on tube recv\");\n                 assert!(self.p.refcount() > 1); // There better be somebody to wake us up\n                 assert!((*state).blocked_task.is_none());\n-                let sched = local_sched::take();\n+                let sched = Local::take::<Scheduler>();\n                 do sched.deschedule_running_task_and_then |task| {\n                     (*state).blocked_task = Some(task);\n                 }\n@@ -97,6 +98,8 @@ mod test {\n     use rt::local_sched;\n     use rt::test::*;\n     use rt::rtio::EventLoop;\n+    use rt::sched::Scheduler;\n+    use rt::local::Local;\n     use super::*;\n \n     #[test]\n@@ -105,11 +108,11 @@ mod test {\n             let mut tube: Tube<int> = Tube::new();\n             let tube_clone = tube.clone();\n             let tube_clone_cell = Cell(tube_clone);\n-            let sched = local_sched::take();\n+            let sched = Local::take::<Scheduler>();\n             do sched.deschedule_running_task_and_then |task| {\n                 let mut tube_clone = tube_clone_cell.take();\n                 tube_clone.send(1);\n-                let sched = local_sched::take();\n+                let sched = Local::take::<Scheduler>();\n                 sched.resume_task_immediately(task);\n             }\n \n@@ -123,10 +126,10 @@ mod test {\n             let mut tube: Tube<int> = Tube::new();\n             let tube_clone = tube.clone();\n             let tube_clone = Cell(Cell(Cell(tube_clone)));\n-            let sched = local_sched::take();\n+            let sched = Local::take::<Scheduler>();\n             do sched.deschedule_running_task_and_then |task| {\n                 let tube_clone = tube_clone.take();\n-                do local_sched::borrow |sched| {\n+                do Local::borrow::<Scheduler> |sched| {\n                     let tube_clone = tube_clone.take();\n                     do sched.event_loop.callback {\n                         let mut tube_clone = tube_clone.take();\n@@ -135,7 +138,7 @@ mod test {\n                         tube_clone.send(1);\n                     }\n                 }\n-                let sched = local_sched::take();\n+                let sched = Local::take::<Scheduler>();\n                 sched.resume_task_immediately(task);\n             }\n \n@@ -151,15 +154,15 @@ mod test {\n             let mut tube: Tube<int> = Tube::new();\n             let tube_clone = tube.clone();\n             let tube_clone = Cell(tube_clone);\n-            let sched = local_sched::take();\n+            let sched = Local::take::<Scheduler>();\n             do sched.deschedule_running_task_and_then |task| {\n                 callback_send(tube_clone.take(), 0);\n \n                 fn callback_send(tube: Tube<int>, i: int) {\n                     if i == 100 { return; }\n \n                     let tube = Cell(Cell(tube));\n-                    do local_sched::borrow |sched| {\n+                    do Local::borrow::<Scheduler> |sched| {\n                         let tube = tube.take();\n                         do sched.event_loop.callback {\n                             let mut tube = tube.take();\n@@ -171,7 +174,7 @@ mod test {\n                     }\n                 }\n \n-                let sched = local_sched::take();\n+                let sched = Local::take::<Scheduler>();\n                 sched.resume_task_immediately(task);\n             }\n "}, {"sha": "e83ab0dd808939933dd3e253afd203c59ace40a7", "filename": "src/libcore/rt/uv/uvio.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/06f1a64bd6e417b73f1b812b860271e86bb42b47/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f1a64bd6e417b73f1b812b860271e86bb42b47/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs?ref=06f1a64bd6e417b73f1b812b860271e86bb42b47", "patch": "@@ -22,6 +22,7 @@ use rt::rtio::*;\n use rt::sched::{Scheduler, local_sched};\n use rt::io::{standard_error, OtherIoError};\n use rt::tube::Tube;\n+use rt::local::Local;\n \n #[cfg(test)] use container::Container;\n #[cfg(test)] use uint;\n@@ -118,14 +119,14 @@ impl IoFactory for UvIoFactory {\n         let result_cell = empty_cell();\n         let result_cell_ptr: *Cell<Result<~RtioTcpStreamObject, IoError>> = &result_cell;\n \n-        let scheduler = local_sched::take();\n+        let scheduler = Local::take::<Scheduler>();\n         assert!(scheduler.in_task_context());\n \n         // Block this task and take ownership, switch to scheduler context\n         do scheduler.deschedule_running_task_and_then |task| {\n \n             rtdebug!(\"connect: entered scheduler context\");\n-            do local_sched::borrow |scheduler| {\n+            do Local::borrow::<Scheduler> |scheduler| {\n                 assert!(!scheduler.in_task_context());\n             }\n             let mut tcp_watcher = TcpWatcher::new(self.uv_loop());\n@@ -142,15 +143,15 @@ impl IoFactory for UvIoFactory {\n                     unsafe { (*result_cell_ptr).put_back(res); }\n \n                     // Context switch\n-                    let scheduler = local_sched::take();\n+                    let scheduler = Local::take::<Scheduler>();\n                     scheduler.resume_task_immediately(task_cell.take());\n                 } else {\n                     rtdebug!(\"status is some\");\n                     let task_cell = Cell(task_cell.take());\n                     do stream_watcher.close {\n                         let res = Err(uv_error_to_io_error(status.get()));\n                         unsafe { (*result_cell_ptr).put_back(res); }\n-                        let scheduler = local_sched::take();\n+                        let scheduler = Local::take::<Scheduler>();\n                         scheduler.resume_task_immediately(task_cell.take());\n                     }\n                 };\n@@ -166,11 +167,11 @@ impl IoFactory for UvIoFactory {\n         match watcher.bind(addr) {\n             Ok(_) => Ok(~UvTcpListener::new(watcher)),\n             Err(uverr) => {\n-                let scheduler = local_sched::take();\n+                let scheduler = Local::take::<Scheduler>();\n                 do scheduler.deschedule_running_task_and_then |task| {\n                     let task_cell = Cell(task);\n                     do watcher.as_stream().close {\n-                        let scheduler = local_sched::take();\n+                        let scheduler = Local::take::<Scheduler>();\n                         scheduler.resume_task_immediately(task_cell.take());\n                     }\n                 }\n@@ -202,11 +203,11 @@ impl UvTcpListener {\n impl Drop for UvTcpListener {\n     fn finalize(&self) {\n         let watcher = self.watcher();\n-        let scheduler = local_sched::take();\n+        let scheduler = Local::take::<Scheduler>();\n         do scheduler.deschedule_running_task_and_then |task| {\n             let task_cell = Cell(task);\n             do watcher.as_stream().close {\n-                let scheduler = local_sched::take();\n+                let scheduler = Local::take::<Scheduler>();\n                 scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n@@ -264,11 +265,11 @@ impl Drop for UvTcpStream {\n     fn finalize(&self) {\n         rtdebug!(\"closing tcp stream\");\n         let watcher = self.watcher();\n-        let scheduler = local_sched::take();\n+        let scheduler = Local::take::<Scheduler>();\n         do scheduler.deschedule_running_task_and_then |task| {\n             let task_cell = Cell(task);\n             do watcher.close {\n-                let scheduler = local_sched::take();\n+                let scheduler = Local::take::<Scheduler>();\n                 scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n@@ -280,13 +281,13 @@ impl RtioTcpStream for UvTcpStream {\n         let result_cell = empty_cell();\n         let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n \n-        let scheduler = local_sched::take();\n+        let scheduler = Local::take::<Scheduler>();\n         assert!(scheduler.in_task_context());\n         let watcher = self.watcher();\n         let buf_ptr: *&mut [u8] = &buf;\n         do scheduler.deschedule_running_task_and_then |task| {\n             rtdebug!(\"read: entered scheduler context\");\n-            do local_sched::borrow |scheduler| {\n+            do Local::borrow::<Scheduler> |scheduler| {\n                 assert!(!scheduler.in_task_context());\n             }\n             let mut watcher = watcher;\n@@ -314,7 +315,7 @@ impl RtioTcpStream for UvTcpStream {\n \n                 unsafe { (*result_cell_ptr).put_back(result); }\n \n-                let scheduler = local_sched::take();\n+                let scheduler = Local::take::<Scheduler>();\n                 scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n@@ -326,7 +327,7 @@ impl RtioTcpStream for UvTcpStream {\n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         let result_cell = empty_cell();\n         let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-        let scheduler = local_sched::take();\n+        let scheduler = Local::take::<Scheduler>();\n         assert!(scheduler.in_task_context());\n         let watcher = self.watcher();\n         let buf_ptr: *&[u8] = &buf;\n@@ -343,7 +344,7 @@ impl RtioTcpStream for UvTcpStream {\n \n                 unsafe { (*result_cell_ptr).put_back(result); }\n \n-                let scheduler = local_sched::take();\n+                let scheduler = Local::take::<Scheduler>();\n                 scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n@@ -420,13 +421,13 @@ fn test_read_and_block() {\n                 }\n                 reads += 1;\n \n-                let scheduler = local_sched::take();\n+                let scheduler = Local::take::<Scheduler>();\n                 // Yield to the other task in hopes that it\n                 // will trigger a read callback while we are\n                 // not ready for it\n                 do scheduler.deschedule_running_task_and_then |task| {\n                     let task = Cell(task);\n-                    do local_sched::borrow |scheduler| {\n+                    do Local::borrow::<Scheduler> |scheduler| {\n                         scheduler.enqueue_task(task.take());\n                     }\n                 }"}, {"sha": "81e5af5caab111a756fd06dd7b774b0cdb777512", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06f1a64bd6e417b73f1b812b860271e86bb42b47/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f1a64bd6e417b73f1b812b860271e86bb42b47/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=06f1a64bd6e417b73f1b812b860271e86bb42b47", "patch": "@@ -90,6 +90,7 @@ use task::unkillable;\n use uint;\n use util;\n use unstable::sync::{Exclusive, exclusive};\n+use rt::local::Local;\n \n #[cfg(test)] use task::default_task_opts;\n \n@@ -575,7 +576,7 @@ pub fn spawn_raw(opts: TaskOpts, f: ~fn()) {\n fn spawn_raw_newsched(_opts: TaskOpts, f: ~fn()) {\n     use rt::sched::*;\n \n-    let mut sched = local_sched::take();\n+    let mut sched = Local::take::<Scheduler>();\n     let task = ~Coroutine::new(&mut sched.stack_pool, f);\n     sched.schedule_new_task(task);\n }"}]}