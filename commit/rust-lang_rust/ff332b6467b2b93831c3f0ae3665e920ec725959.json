{"sha": "ff332b6467b2b93831c3f0ae3665e920ec725959", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmMzMyYjY0NjdiMmI5MzgzMWMzZjBhZTM2NjVlOTIwZWM3MjU5NTk=", "commit": {"author": {"name": "Barosl Lee", "email": "vcs@barosl.com", "date": "2015-05-08T15:12:29Z"}, "committer": {"name": "Barosl Lee", "email": "vcs@barosl.com", "date": "2015-05-08T17:24:18Z"}, "message": "Squeeze the last bits of `task`s in documentation in favor of `thread`\n\nAn automated script was run against the `.rs` and `.md` files,\nsubsituting every occurrence of `task` with `thread`. In the `.rs`\nfiles, only the texts in the comment blocks were affected.", "tree": {"sha": "4845dc94cb452d158eafa2cd136a1eeee6292448", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4845dc94cb452d158eafa2cd136a1eeee6292448"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff332b6467b2b93831c3f0ae3665e920ec725959", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff332b6467b2b93831c3f0ae3665e920ec725959", "html_url": "https://github.com/rust-lang/rust/commit/ff332b6467b2b93831c3f0ae3665e920ec725959", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff332b6467b2b93831c3f0ae3665e920ec725959/comments", "author": {"login": "barosl", "id": 573768, "node_id": "MDQ6VXNlcjU3Mzc2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/573768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/barosl", "html_url": "https://github.com/barosl", "followers_url": "https://api.github.com/users/barosl/followers", "following_url": "https://api.github.com/users/barosl/following{/other_user}", "gists_url": "https://api.github.com/users/barosl/gists{/gist_id}", "starred_url": "https://api.github.com/users/barosl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/barosl/subscriptions", "organizations_url": "https://api.github.com/users/barosl/orgs", "repos_url": "https://api.github.com/users/barosl/repos", "events_url": "https://api.github.com/users/barosl/events{/privacy}", "received_events_url": "https://api.github.com/users/barosl/received_events", "type": "User", "site_admin": false}, "committer": {"login": "barosl", "id": 573768, "node_id": "MDQ6VXNlcjU3Mzc2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/573768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/barosl", "html_url": "https://github.com/barosl", "followers_url": "https://api.github.com/users/barosl/followers", "following_url": "https://api.github.com/users/barosl/following{/other_user}", "gists_url": "https://api.github.com/users/barosl/gists{/gist_id}", "starred_url": "https://api.github.com/users/barosl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/barosl/subscriptions", "organizations_url": "https://api.github.com/users/barosl/orgs", "repos_url": "https://api.github.com/users/barosl/repos", "events_url": "https://api.github.com/users/barosl/events{/privacy}", "received_events_url": "https://api.github.com/users/barosl/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf76e637450a861e94ef583340b8f080379a159a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf76e637450a861e94ef583340b8f080379a159a", "html_url": "https://github.com/rust-lang/rust/commit/cf76e637450a861e94ef583340b8f080379a159a"}], "stats": {"total": 396, "additions": 198, "deletions": 198}, "files": [{"sha": "3ff7f3cc70adae0e3d01f7479c81cd1b9c58dd94", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -226,15 +226,15 @@ pub fn run_tests(config: &Config) {\n         }\n \n         // android debug-info test uses remote debugger\n-        // so, we test 1 task at once.\n+        // so, we test 1 thread at once.\n         // also trying to isolate problems with adb_run_wrapper.sh ilooping\n         env::set_var(\"RUST_TEST_THREADS\",\"1\");\n     }\n \n     match config.mode {\n         DebugInfoLldb => {\n             // Some older versions of LLDB seem to have problems with multiple\n-            // instances running in parallel, so only run one test task at a\n+            // instances running in parallel, so only run one test thread at a\n             // time.\n             env::set_var(\"RUST_TEST_THREADS\", \"1\");\n         }"}, {"sha": "fb157c65d957b2cd4ee727ec28dcd2b666a7e91f", "filename": "src/doc/complement-design-faq.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Fcomplement-design-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Fcomplement-design-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-design-faq.md?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -96,7 +96,7 @@ code should need to run is a stack.\n possibility is covered by the `match`, adding further variants to the `enum`\n in the future will prompt a compilation failure, rather than runtime panic.\n Second, it makes cost explicit. In general, the only safe way to have a\n-non-exhaustive match would be to panic the task if nothing is matched, though\n+non-exhaustive match would be to panic the thread if nothing is matched, though\n it could fall through if the type of the `match` expression is `()`. This sort\n of hidden cost and special casing is against the language's philosophy. It's\n easy to ignore certain cases by using the `_` wildcard:"}, {"sha": "e51e7d414a89161c63bb8b0046c216a477df3c3a", "filename": "src/doc/complement-lang-faq.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-lang-faq.md?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -62,15 +62,15 @@ Data values in the language can only be constructed through a fixed set of initi\n * There is no global inter-crate namespace; all name management occurs within a crate.\n  * Using another crate binds the root of _its_ namespace into the user's namespace.\n \n-## Why is panic unwinding non-recoverable within a task? Why not try to \"catch exceptions\"?\n+## Why is panic unwinding non-recoverable within a thread? Why not try to \"catch exceptions\"?\n \n-In short, because too few guarantees could be made about the dynamic environment of the catch block, as well as invariants holding in the unwound heap, to be able to safely resume; we believe that other methods of signalling and logging errors are more appropriate, with tasks playing the role of a \"hard\" isolation boundary between separate heaps.\n+In short, because too few guarantees could be made about the dynamic environment of the catch block, as well as invariants holding in the unwound heap, to be able to safely resume; we believe that other methods of signalling and logging errors are more appropriate, with threads playing the role of a \"hard\" isolation boundary between separate heaps.\n \n Rust provides, instead, three predictable and well-defined options for handling any combination of the three main categories of \"catch\" logic:\n \n * Failure _logging_ is done by the integrated logging subsystem.\n-* _Recovery_ after a panic is done by trapping a task panic from _outside_\n-  the task, where other tasks are known to be unaffected.\n+* _Recovery_ after a panic is done by trapping a thread panic from _outside_\n+  the thread, where other threads are known to be unaffected.\n * _Cleanup_ of resources is done by RAII-style objects with destructors.\n \n Cleanup through RAII-style destructors is more likely to work than in catch blocks anyways, since it will be better tested (part of the non-error control paths, so executed all the time).\n@@ -91,8 +91,8 @@ We don't know if there's an obvious, easy, efficient, stock-textbook way of supp\n \n There's a lot of debate on this topic; it's easy to find a proponent of default-sync or default-async communication, and there are good reasons for either. Our choice rests on the following arguments:\n \n-* Part of the point of isolating tasks is to decouple tasks from one another, such that assumptions in one task do not cause undue constraints (or bugs, if violated!) in another. Temporal coupling is as real as any other kind; async-by-default relaxes the default case to only _causal_ coupling.\n-* Default-async supports buffering and batching communication, reducing the frequency and severity of task-switching and inter-task / inter-domain synchronization.\n+* Part of the point of isolating threads is to decouple threads from one another, such that assumptions in one thread do not cause undue constraints (or bugs, if violated!) in another. Temporal coupling is as real as any other kind; async-by-default relaxes the default case to only _causal_ coupling.\n+* Default-async supports buffering and batching communication, reducing the frequency and severity of thread-switching and inter-thread / inter-domain synchronization.\n * Default-async with transmittable channels is the lowest-level building block on which more-complex synchronization topologies and strategies can be built; it is not clear to us that the majority of cases fit the 2-party full-synchronization pattern rather than some more complex multi-party or multi-stage scenario. We did not want to force all programs to pay for wiring the former assumption into all communications.\n \n ## Why are channels half-duplex (one-way)?"}, {"sha": "03f6978ec1c98f39ad3784a3ca3a3f8107117ea7", "filename": "src/doc/grammar.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -789,8 +789,8 @@ bound := path | lifetime\n \n ### Boxes\n \n-## Tasks\n+## Threads\n \n-### Communication between tasks\n+### Communication between threads\n \n-### Task lifecycle\n+### Thread lifecycle"}, {"sha": "ef230cb4b57cf59604cb5b256b5b368da4bc93d2", "filename": "src/doc/reference.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -3636,7 +3636,7 @@ that have since been removed):\n * ML Kit, Cyclone: region based memory management\n * Haskell (GHC): typeclasses, type families\n * Newsqueak, Alef, Limbo: channels, concurrency\n-* Erlang: message passing, task failure, ~~linked task failure~~,\n+* Erlang: message passing, thread failure, ~~linked thread failure~~,\n   ~~lightweight concurrency~~\n * Swift: optional bindings\n * Scheme: hygienic macros"}, {"sha": "9b8a00d73665b6f4fd0f983a1e56763fef80fa23", "filename": "src/doc/style/errors/handling.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Fstyle%2Ferrors%2Fhandling.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Fstyle%2Ferrors%2Fhandling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ferrors%2Fhandling.md?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -1,7 +1,7 @@\n % Handling errors\n \n-### Use task isolation to cope with failure. [FIXME]\n+### Use thread isolation to cope with failure. [FIXME]\n \n-> **[FIXME]** Explain how to isolate tasks and detect task failure for recovery.\n+> **[FIXME]** Explain how to isolate threads and detect thread failure for recovery.\n \n ### Consuming `Result` [FIXME]"}, {"sha": "24cd5957f8aac079c27a3e408305c63ca73f2f2b", "filename": "src/doc/style/errors/signaling.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Fstyle%2Ferrors%2Fsignaling.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Fstyle%2Ferrors%2Fsignaling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ferrors%2Fsignaling.md?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -11,13 +11,13 @@ Errors fall into one of three categories:\n The basic principle of the convention is that:\n \n * Catastrophic errors and programming errors (bugs) can and should only be\n-recovered at a *coarse grain*, i.e. a task boundary.\n+recovered at a *coarse grain*, i.e. a thread boundary.\n * Obstructions preventing an operation should be reported at a maximally *fine\n grain* -- to the immediate invoker of the operation.\n \n ## Catastrophic errors\n \n-An error is _catastrophic_ if there is no meaningful way for the current task to\n+An error is _catastrophic_ if there is no meaningful way for the current thread to\n continue after the error occurs.\n \n Catastrophic errors are _extremely_ rare, especially outside of `libstd`.\n@@ -28,7 +28,7 @@ Catastrophic errors are _extremely_ rare, especially outside of `libstd`.\n \n For errors like stack overflow, Rust currently aborts the process, but\n could in principle panic, which (in the best case) would allow\n-reporting and recovery from a supervisory task.\n+reporting and recovery from a supervisory thread.\n \n ## Contract violations\n \n@@ -44,7 +44,7 @@ existing borrows have been relinquished.\n \n A contract violation is always a bug, and for bugs we follow the Erlang\n philosophy of \"let it crash\": we assume that software *will* have bugs, and we\n-design coarse-grained task boundaries to report, and perhaps recover, from these\n+design coarse-grained thread boundaries to report, and perhaps recover, from these\n bugs.\n \n ### Contract design"}, {"sha": "e936c0b903758cc3c77422eab216779bbb7bc465", "filename": "src/doc/style/ownership/builders.md", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Fstyle%2Fownership%2Fbuilders.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Fstyle%2Fownership%2Fbuilders.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fownership%2Fbuilders.md?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -23,7 +23,7 @@ If `T` is such a data structure, consider introducing a `T` _builder_:\n 4. The builder should provide one or more \"_terminal_\" methods for actually building a `T`.\n \n The builder pattern is especially appropriate when building a `T` involves side\n-effects, such as spawning a task or launching a process.\n+effects, such as spawning a thread or launching a process.\n \n In Rust, there are two variants of the builder pattern, differing in the\n treatment of ownership, as described below.\n@@ -115,24 +115,24 @@ Sometimes builders must transfer ownership when constructing the final type\n `T`, meaning that the terminal methods must take `self` rather than `&self`:\n \n ```rust\n-// A simplified excerpt from std::task::TaskBuilder\n+// A simplified excerpt from std::thread::ThreadBuilder\n \n-impl TaskBuilder {\n-    /// Name the task-to-be. Currently the name is used for identification\n+impl ThreadBuilder {\n+    /// Name the thread-to-be. Currently the name is used for identification\n     /// only in failure messages.\n-    pub fn named(mut self, name: String) -> TaskBuilder {\n+    pub fn named(mut self, name: String) -> ThreadBuilder {\n         self.name = Some(name);\n         self\n     }\n \n-    /// Redirect task-local stdout.\n-    pub fn stdout(mut self, stdout: Box<Writer + Send>) -> TaskBuilder {\n+    /// Redirect thread-local stdout.\n+    pub fn stdout(mut self, stdout: Box<Writer + Send>) -> ThreadBuilder {\n         self.stdout = Some(stdout);\n         //   ^~~~~~ this is owned and cannot be cloned/re-used\n         self\n     }\n \n-    /// Creates and executes a new child task.\n+    /// Creates and executes a new child thread.\n     pub fn spawn(self, f: proc():Send) {\n         // consume self\n         ...\n@@ -141,7 +141,7 @@ impl TaskBuilder {\n ```\n \n Here, the `stdout` configuration involves passing ownership of a `Writer`,\n-which must be transferred to the task upon construction (in `spawn`).\n+which must be transferred to the thread upon construction (in `spawn`).\n \n When the terminal methods of the builder require ownership, there is a basic tradeoff:\n \n@@ -158,17 +158,17 @@ builder methods for a consuming builder should take and returned an owned\n \n ```rust\n // One-liners\n-TaskBuilder::new().named(\"my_task\").spawn(proc() { ... });\n+ThreadBuilder::new().named(\"my_thread\").spawn(proc() { ... });\n \n // Complex configuration\n-let mut task = TaskBuilder::new();\n-task = task.named(\"my_task_2\"); // must re-assign to retain ownership\n+let mut thread = ThreadBuilder::new();\n+thread = thread.named(\"my_thread_2\"); // must re-assign to retain ownership\n \n if reroute {\n-    task = task.stdout(mywriter);\n+    thread = thread.stdout(mywriter);\n }\n \n-task.spawn(proc() { ... });\n+thread.spawn(proc() { ... });\n ```\n \n One-liners work as before, because ownership is threaded through each of the"}, {"sha": "1cfcd78d20da8346f052351ae285714e6fcf0e9f", "filename": "src/doc/style/ownership/destructors.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Fstyle%2Fownership%2Fdestructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Fstyle%2Fownership%2Fdestructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fownership%2Fdestructors.md?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -8,7 +8,7 @@ go out of scope.\n \n ### Destructors should not fail. [FIXME: needs RFC]\n \n-Destructors are executed on task failure, and in that context a failing\n+Destructors are executed on thread failure, and in that context a failing\n destructor causes the program to abort.\n \n Instead of failing in a destructor, provide a separate method for checking for"}, {"sha": "b2d2d9ab6b4d68e1a776797112ea3988b38b435e", "filename": "src/doc/style/style/comments.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Fstyle%2Fstyle%2Fcomments.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Fstyle%2Fstyle%2Fcomments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fcomments.md?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -5,15 +5,15 @@\n Use line comments:\n \n ``` rust\n-// Wait for the main task to return, and set the process error code\n+// Wait for the main thread to return, and set the process error code\n // appropriately.\n ```\n \n Instead of:\n \n ``` rust\n /*\n- * Wait for the main task to return, and set the process error code\n+ * Wait for the main thread to return, and set the process error code\n  * appropriately.\n  */\n ```\n@@ -55,7 +55,7 @@ For example:\n /// Sets up a default runtime configuration, given compiler-supplied arguments.\n ///\n /// This function will block until the entire pool of M:N schedulers has\n-/// exited. This function also requires a local task to be available.\n+/// exited. This function also requires a local thread to be available.\n ///\n /// # Arguments\n ///\n@@ -64,7 +64,7 @@ For example:\n /// * `main` - The initial procedure to run inside of the M:N scheduling pool.\n ///            Once this procedure exits, the scheduling pool will begin to shut\n ///            down. The entire pool (and this function) will only return once\n-///            all child tasks have finished executing.\n+///            all child threads have finished executing.\n ///\n /// # Return value\n ///"}, {"sha": "dfed4f9f75a58906c78068566077aba180f30cd3", "filename": "src/doc/style/style/naming/containers.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fcontainers.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fcontainers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fcontainers.md?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -5,7 +5,7 @@ they enclose.  Accessor methods often have variants to access the data\n by value, by reference, and by mutable reference.\n \n In general, the `get` family of methods is used to access contained\n-data without any risk of task failure; they return `Option` as\n+data without any risk of thread failure; they return `Option` as\n appropriate. This name is chosen rather than names like `find` or\n `lookup` because it is appropriate for a wider range of container types.\n "}, {"sha": "2b6a6bad18212f53acb426d02d1844beeb8cdea3", "filename": "src/doc/trpl/academic-research.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Ftrpl%2Facademic-research.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Ftrpl%2Facademic-research.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Facademic-research.md?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -24,7 +24,7 @@ Recommended for inspiration and a better understanding of Rust's background.\n * [Thread scheduling for multiprogramming multiprocessors](http://www.eecis.udel.edu/%7Ecavazos/cisc879-spring2008/papers/arora98thread.pdf)\n * [The data locality of work stealing](http://www.aladdin.cs.cmu.edu/papers/pdfs/y2000/locality_spaa00.pdf)\n * [Dynamic circular work stealing deque](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.170.1097&rep=rep1&type=pdf) - The Chase/Lev deque\n-* [Work-first and help-first scheduling policies for async-finish task parallelism](http://www.cs.rice.edu/%7Eyguo/pubs/PID824943.pdf) - More general than fully-strict work stealing\n+* [Work-first and help-first scheduling policies for async-finish thread parallelism](http://www.cs.rice.edu/%7Eyguo/pubs/PID824943.pdf) - More general than fully-strict work stealing\n * [A Java fork/join calamity](http://www.coopsoft.com/ar/CalamityArticle.html) - critique of Java's fork/join library, particularly its application of work stealing to non-strict computation\n * [Scheduling techniques for concurrent systems](http://www.ece.rutgers.edu/%7Eparashar/Classes/ece572-papers/05/ps-ousterhout.pdf)\n * [Contention aware scheduling](http://www.blagodurov.net/files/a8-blagodurov.pdf)"}, {"sha": "d6590e956a8416a69e29ca9eefc3b77f0414432b", "filename": "src/doc/trpl/concurrency.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconcurrency.md?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -6,7 +6,7 @@ and more cores, yet many programmers aren't prepared to fully utilize them.\n \n Rust's memory safety features also apply to its concurrency story too. Even\n concurrent Rust programs must be memory safe, having no data races. Rust's type\n-system is up to the task, and gives you powerful ways to reason about\n+system is up to the thread, and gives you powerful ways to reason about\n concurrent code at compile time.\n \n Before we talk about the concurrency features that come with Rust, it's important"}, {"sha": "abb14a60205242720abd0fd1be6c2bb80dd1d6ea", "filename": "src/doc/trpl/iterators.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -42,7 +42,7 @@ loop is just a handy way to write this `loop`/`match`/`break` construct.\n `for` loops aren't the only thing that uses iterators, however. Writing your\n own iterator involves implementing the `Iterator` trait. While doing that is\n outside of the scope of this guide, Rust provides a number of useful iterators\n-to accomplish various tasks. Before we talk about those, we should talk about a\n+to accomplish various threads. Before we talk about those, we should talk about a\n Rust anti-pattern. And that's using ranges like this.\n \n Yes, we just talked about how ranges are cool. But ranges are also very"}, {"sha": "8c3c21a89023dc62322d1b0f8e21167225ba2a61", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -31,7 +31,7 @@\n //!\n //! # Examples\n //!\n-//! Sharing some immutable data between tasks:\n+//! Sharing some immutable data between threads:\n //!\n //! ```no_run\n //! use std::sync::Arc;\n@@ -48,7 +48,7 @@\n //! }\n //! ```\n //!\n-//! Sharing mutable data safely between tasks with a `Mutex`:\n+//! Sharing mutable data safely between threads with a `Mutex`:\n //!\n //! ```no_run\n //! use std::sync::{Arc, Mutex};\n@@ -89,9 +89,9 @@ use heap::deallocate;\n ///\n /// # Examples\n ///\n-/// In this example, a large vector of floats is shared between several tasks.\n+/// In this example, a large vector of floats is shared between several threads.\n /// With simple pipes, without `Arc`, a copy would have to be made for each\n-/// task.\n+/// thread.\n ///\n /// When you clone an `Arc<T>`, it will create another pointer to the data and\n /// increase the reference counter."}, {"sha": "473429b813c50bc6d093a61cb60338de324520d9", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -26,14 +26,14 @@\n //! There can only be one owner of a `Box`, and the owner can decide to mutate\n //! the contents, which live on the heap.\n //!\n-//! This type can be sent among tasks efficiently as the size of a `Box` value\n+//! This type can be sent among threads efficiently as the size of a `Box` value\n //! is the same as that of a pointer. Tree-like data structures are often built\n //! with boxes because each node often has only one owner, the parent.\n //!\n //! ## Reference counted pointers\n //!\n //! The [`Rc`](rc/index.html) type is a non-threadsafe reference-counted pointer\n-//! type intended for sharing memory within a task. An `Rc` pointer wraps a\n+//! type intended for sharing memory within a thread. An `Rc` pointer wraps a\n //! type, `T`, and only allows access to `&T`, a shared reference.\n //!\n //! This type is useful when inherited mutability (such as using `Box`) is too"}, {"sha": "ec693f366912dd53ca871e5c305002590fdafc72", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -52,20 +52,20 @@\n //!         spinlock_clone.store(0, Ordering::SeqCst);\n //!     });\n //!\n-//!     // Wait for the other task to release the lock\n+//!     // Wait for the other thread to release the lock\n //!     while spinlock.load(Ordering::SeqCst) != 0 {}\n //! }\n //! ```\n //!\n-//! Keep a global count of live tasks:\n+//! Keep a global count of live threads:\n //!\n //! ```\n //! use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n //!\n-//! static GLOBAL_TASK_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n+//! static GLOBAL_THREAD_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n //!\n-//! let old_task_count = GLOBAL_TASK_COUNT.fetch_add(1, Ordering::SeqCst);\n-//! println!(\"live tasks: {}\", old_task_count + 1);\n+//! let old_thread_count = GLOBAL_THREAD_COUNT.fetch_add(1, Ordering::SeqCst);\n+//! println!(\"live threads: {}\", old_thread_count + 1);\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "cd4a50d4025d1fb9c3c0de8f6b4518eb0d83b5da", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -24,7 +24,7 @@\n //! claim temporary, exclusive, mutable access to the inner value. Borrows for `RefCell<T>`s are\n //! tracked 'at runtime', unlike Rust's native reference types which are entirely tracked\n //! statically, at compile time. Because `RefCell<T>` borrows are dynamic it is possible to attempt\n-//! to borrow a value that is already mutably borrowed; when this happens it results in task panic.\n+//! to borrow a value that is already mutably borrowed; when this happens it results in thread panic.\n //!\n //! # When to choose interior mutability\n //!\n@@ -100,7 +100,7 @@\n //!         // Recursive call to return the just-cached value.\n //!         // Note that if we had not let the previous borrow\n //!         // of the cache fall out of scope then the subsequent\n-//!         // recursive borrow would cause a dynamic task panic.\n+//!         // recursive borrow would cause a dynamic thread panic.\n //!         // This is the major hazard of using `RefCell`.\n //!         self.minimum_spanning_tree()\n //!     }"}, {"sha": "54877c070cbe48f7368eb1f24aa68e1b246f0c04", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// Entry point of task panic, for details, see std::macros\n+/// Entry point of thread panic, for details, see std::macros\n #[macro_export]\n macro_rules! panic {\n     () => ("}, {"sha": "4280a88f724a29eb8d91ace42dd889def74750c3", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -228,7 +228,7 @@ thread_local! {\n     }\n }\n \n-/// A trait used to represent an interface to a task-local logger. Each task\n+/// A trait used to represent an interface to a thread-local logger. Each thread\n /// can have its own custom logger which can respond to logging messages\n /// however it likes.\n pub trait Logger {\n@@ -324,7 +324,7 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n #[inline(always)]\n pub fn log_level() -> u32 { unsafe { LOG_LEVEL } }\n \n-/// Replaces the task-local logger with the specified logger, returning the old\n+/// Replaces the thread-local logger with the specified logger, returning the old\n /// logger.\n pub fn set_logger(logger: Box<Logger + Send>) -> Option<Box<Logger + Send>> {\n     let mut l = Some(logger);"}, {"sha": "cb069acdfd2f0c6aa04afb12330a821477c0ea6c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -4630,7 +4630,7 @@ pub fn expr_ty_opt<'tcx>(cx: &ctxt<'tcx>, expr: &ast::Expr) -> Option<Ty<'tcx>>\n /// require serializing and deserializing the type and, although that's not\n /// hard to do, I just hate that code so much I didn't want to touch it\n /// unless it was to fix it properly, which seemed a distraction from the\n-/// task at hand! -nmatsakis\n+/// thread at hand! -nmatsakis\n pub fn expr_ty_adjusted<'tcx>(cx: &ctxt<'tcx>, expr: &ast::Expr) -> Ty<'tcx> {\n     adjust_ty(cx, expr.span, expr.id, expr_ty(cx, expr),\n               cx.adjustments.borrow().get(&expr.id),"}, {"sha": "4ea331f68987e96210c216cefca6680213d57e2d", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -131,7 +131,7 @@ impl<'a> PluginLoader<'a> {\n \n             // Intentionally leak the dynamic library. We can't ever unload it\n             // since the library can make things that will live arbitrarily long\n-            // (e.g. an @-box cycle or a task).\n+            // (e.g. an @-box cycle or a thread).\n             mem::forget(lib);\n \n             registrar"}, {"sha": "a10ff71a8f689d400f4b565109ac3649ab9fac01", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -86,8 +86,8 @@ struct Diagnostic {\n }\n \n // We use an Arc instead of just returning a list of diagnostics from the\n-// child task because we need to make sure that the messages are seen even\n-// if the child task panics (for example, when `fatal` is called).\n+// child thread because we need to make sure that the messages are seen even\n+// if the child thread panics (for example, when `fatal` is called).\n #[derive(Clone)]\n struct SharedEmitter {\n     buffer: Arc<Mutex<Vec<Diagnostic>>>,\n@@ -637,7 +637,7 @@ pub fn run_passes(sess: &Session,\n     metadata_config.set_flags(sess, trans);\n \n \n-    // Populate a buffer with a list of codegen tasks.  Items are processed in\n+    // Populate a buffer with a list of codegen threads.  Items are processed in\n     // LIFO order, just because it's a tiny bit simpler that way.  (The order\n     // doesn't actually matter.)\n     let mut work_items = Vec::with_capacity(1 + trans.modules.len());"}, {"sha": "03dda57e5689fab9d4112575892d0f4dd662a040", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -147,7 +147,7 @@ pub fn type_is_fat_ptr<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n }\n \n // Some things don't need cleanups during unwinding because the\n-// task can free them all at once later. Currently only things\n+// thread can free them all at once later. Currently only things\n // that only contain scalars and shared boxes can avoid unwind\n // cleanups.\n pub fn type_needs_unwind_cleanup<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {"}, {"sha": "66c5a4e0db2366a6c303b69b2d96ff4bdba323ef", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -477,7 +477,7 @@ impl LangString {\n \n /// By default this markdown renderer generates anchors for each header in the\n /// rendered document. The anchor name is the contents of the header separated\n-/// by hyphens, and a task-local map is used to disambiguate among duplicate\n+/// by hyphens, and a thread-local map is used to disambiguate among duplicate\n /// headers (numbers are appended).\n ///\n /// This method will reset the local table for these headers. This is typically"}, {"sha": "3d0b31d228d415177326c792ca0719cc5d7bf71e", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -17,10 +17,10 @@\n //!\n //! The rendering process is largely driven by the `Context` and `Cache`\n //! structures. The cache is pre-populated by crawling the crate in question,\n-//! and then it is shared among the various rendering tasks. The cache is meant\n+//! and then it is shared among the various rendering threads. The cache is meant\n //! to be a fairly large structure not implementing `Clone` (because it's shared\n-//! among tasks). The context, however, should be a lightweight structure. This\n-//! is cloned per-task and contains information about what is currently being\n+//! among threads). The context, however, should be a lightweight structure. This\n+//! is cloned per-thread and contains information about what is currently being\n //! rendered.\n //!\n //! In order to speed up rendering (mostly because of markdown rendering), the\n@@ -30,7 +30,7 @@\n //!\n //! In addition to rendering the crate itself, this module is also responsible\n //! for creating the corresponding search index and source file renderings.\n-//! These tasks are not parallelized (they haven't been a bottleneck yet), and\n+//! These threads are not parallelized (they haven't been a bottleneck yet), and\n //! both occur before the crate is rendered.\n pub use self::ExternalLocation::*;\n \n@@ -154,7 +154,7 @@ impl Impl {\n /// This structure purposefully does not implement `Clone` because it's intended\n /// to be a fairly large and expensive structure to clone. Instead this adheres\n /// to `Send` so it may be stored in a `Arc` instance and shared among the various\n-/// rendering tasks.\n+/// rendering threads.\n #[derive(Default)]\n pub struct Cache {\n     /// Mapping of typaram ids to the name of the type parameter. This is used\n@@ -688,7 +688,7 @@ fn write(dst: PathBuf, contents: &[u8]) -> io::Result<()> {\n     try!(File::create(&dst)).write_all(contents)\n }\n \n-/// Makes a directory on the filesystem, failing the task if an error occurs and\n+/// Makes a directory on the filesystem, failing the thread if an error occurs and\n /// skipping if the directory already exists.\n fn mkdir(path: &Path) -> io::Result<()> {\n     if !path.exists() {"}, {"sha": "f8c2626d09e317668b9558a75abfa8ed75bd9d47", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -180,9 +180,9 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n     // an explicit handle into rustc to collect output messages, but we also\n     // want to catch the error message that rustc prints when it fails.\n     //\n-    // We take our task-local stderr (likely set by the test runner) and replace\n+    // We take our thread-local stderr (likely set by the test runner) and replace\n     // it with a sink that is also passed to rustc itself. When this function\n-    // returns the output of the sink is copied onto the output of our own task.\n+    // returns the output of the sink is copied onto the output of our own thread.\n     //\n     // The basic idea is to not use a default_handler() for rustc, and then also\n     // not print things by default to the actual stderr."}, {"sha": "9b824f11b926822fe818ed70cadbbe63684e408d", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -205,7 +205,7 @@ fn test_resize_policy() {\n /// A hash map implementation which uses linear probing with Robin\n /// Hood bucket stealing.\n ///\n-/// The hashes are all keyed by the task-local random number generator\n+/// The hashes are all keyed by the thread-local random number generator\n /// on creation by default. This means that the ordering of the keys is\n /// randomized, but makes the tables more resistant to\n /// denial-of-service attacks (Hash DoS). This behaviour can be"}, {"sha": "1099bf108f1dbb7116798bb8c3c8969159ab39c3", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -271,7 +271,7 @@\n //! ```\n //!\n //! Iterators also provide a series of *adapter* methods for performing common\n-//! tasks to sequences. Among the adapters are functional favorites like `map`,\n+//! threads to sequences. Among the adapters are functional favorites like `map`,\n //! `fold`, `skip`, and `take`. Of particular interest to collections is the\n //! `rev` adapter, that reverses any iterator that supports this operation. Most\n //! collections provide reversible iterators as the way to iterate over them in"}, {"sha": "82999a47e563701a57235b842ff450147da00699", "filename": "src/libstd/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -457,8 +457,8 @@ static EXIT_STATUS: AtomicIsize = ATOMIC_ISIZE_INIT;\n \n /// Sets the process exit code\n ///\n-/// Sets the exit code returned by the process if all supervised tasks\n-/// terminate successfully (without panicking). If the current root task panics\n+/// Sets the exit code returned by the process if all supervised threads\n+/// terminate successfully (without panicking). If the current root thread panics\n /// and is supervised by the scheduler then any user-specified exit status is\n /// ignored and the process exits with the default panic status.\n ///"}, {"sha": "a14c472333c6eb0f93a263e456722f356088f9f2", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -355,13 +355,13 @@ impl<'a> Write for StderrLock<'a> {\n     }\n }\n \n-/// Resets the task-local stderr handle to the specified writer\n+/// Resets the thread-local stderr handle to the specified writer\n ///\n-/// This will replace the current task's stderr handle, returning the old\n+/// This will replace the current thread's stderr handle, returning the old\n /// handle. All future calls to `panic!` and friends will emit their output to\n /// this specified handle.\n ///\n-/// Note that this does not need to be called for all new tasks; the default\n+/// Note that this does not need to be called for all new threads; the default\n /// output handle is to the process's stderr stream.\n #[unstable(feature = \"set_stdio\",\n            reason = \"this function may disappear completely or be replaced \\\n@@ -378,13 +378,13 @@ pub fn set_panic(sink: Box<Write + Send>) -> Option<Box<Write + Send>> {\n     })\n }\n \n-/// Resets the task-local stdout handle to the specified writer\n+/// Resets the thread-local stdout handle to the specified writer\n ///\n-/// This will replace the current task's stdout handle, returning the old\n+/// This will replace the current thread's stdout handle, returning the old\n /// handle. All future calls to `print!` and friends will emit their output to\n /// this specified handle.\n ///\n-/// Note that this does not need to be called for all new tasks; the default\n+/// Note that this does not need to be called for all new threads; the default\n /// output handle is to the process's stdout stream.\n #[unstable(feature = \"set_stdio\",\n            reason = \"this function may disappear completely or be replaced \\"}, {"sha": "32193b4089d3079682130866499deb31d4ba2d4b", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -16,10 +16,10 @@\n \n #![unstable(feature = \"std_misc\")]\n \n-/// The entry point for panic of Rust tasks.\n+/// The entry point for panic of Rust threads.\n ///\n-/// This macro is used to inject panic into a Rust task, causing the task to\n-/// unwind and panic entirely. Each task's panic can be reaped as the\n+/// This macro is used to inject panic into a Rust thread, causing the thread to\n+/// unwind and panic entirely. Each thread's panic can be reaped as the\n /// `Box<Any>` type, and the single-argument form of the `panic!` macro will be\n /// the value which is transmitted.\n ///\n@@ -38,10 +38,10 @@\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow_internal_unstable]\n-/// The entry point for panic of Rust tasks.\n+/// The entry point for panic of Rust threads.\n ///\n-/// This macro is used to inject panic into a Rust task, causing the task to\n-/// unwind and panic entirely. Each task's panic can be reaped as the\n+/// This macro is used to inject panic into a Rust thread, causing the thread to\n+/// unwind and panic entirely. Each thread's panic can be reaped as the\n /// `Box<Any>` type, and the single-argument form of the `panic!` macro will be\n /// the value which is transmitted.\n ///\n@@ -143,17 +143,17 @@ macro_rules! try {\n /// use std::sync::mpsc;\n ///\n /// // two placeholder functions for now\n-/// fn long_running_task() {}\n+/// fn long_running_thread() {}\n /// fn calculate_the_answer() -> u32 { 42 }\n ///\n /// let (tx1, rx1) = mpsc::channel();\n /// let (tx2, rx2) = mpsc::channel();\n ///\n-/// thread::spawn(move|| { long_running_task(); tx1.send(()).unwrap(); });\n+/// thread::spawn(move|| { long_running_thread(); tx1.send(()).unwrap(); });\n /// thread::spawn(move|| { tx2.send(calculate_the_answer()).unwrap(); });\n ///\n /// select! {\n-///     _ = rx1.recv() => println!(\"the long running task finished first\"),\n+///     _ = rx1.recv() => println!(\"the long running thread finished first\"),\n ///     answer = rx2.recv() => {\n ///         println!(\"the answer was: {}\", answer.unwrap());\n ///     }"}, {"sha": "28063c1edb3f744755fd6c61cd9ce8b5fb5b5b62", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -444,7 +444,7 @@ mod tests {\n             let _t = thread::spawn(move|| {\n                 let acceptor = acceptor;\n                 for (i, stream) in acceptor.incoming().enumerate().take(MAX) {\n-                    // Start another task to handle the connection\n+                    // Start another thread to handle the connection\n                     let _t = thread::spawn(move|| {\n                         let mut stream = t!(stream);\n                         let mut buf = [0];\n@@ -478,7 +478,7 @@ mod tests {\n \n             let _t = thread::spawn(move|| {\n                 for stream in acceptor.incoming().take(MAX) {\n-                    // Start another task to handle the connection\n+                    // Start another thread to handle the connection\n                     let _t = thread::spawn(move|| {\n                         let mut stream = t!(stream);\n                         let mut buf = [0];\n@@ -738,7 +738,7 @@ mod tests {\n                 assert_eq!(t!(s2.read(&mut [0])), 0);\n                 tx.send(()).unwrap();\n             });\n-            // this should wake up the child task\n+            // this should wake up the child thread\n             t!(s.shutdown(Shutdown::Read));\n \n             // this test will never finish if the child doesn't wake up\n@@ -752,7 +752,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let accept = t!(TcpListener::bind(&addr));\n \n-            // Enqueue a task to write to a socket\n+            // Enqueue a thread to write to a socket\n             let (tx, rx) = channel();\n             let (txdone, rxdone) = channel();\n             let txdone2 = txdone.clone();"}, {"sha": "4a8cceb202f5d3dad7a115c8b06fb2007d1b3ddb", "filename": "src/libstd/prelude/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fmod.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -19,7 +19,7 @@\n //! ```\n //!\n //! This means that the contents of std can be accessed from any context\n-//! with the `std::` path prefix, as in `use std::vec`, `use std::task::spawn`,\n+//! with the `std::` path prefix, as in `use std::vec`, `use std::thread::spawn`,\n //! etc.\n //!\n //! Additionally, `std` contains a `prelude` module that reexports many of the"}, {"sha": "3c36f0f1d490c223dbd01c57d52654cf8501c916", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -374,7 +374,7 @@ mod tests {\n             txs.push(tx);\n \n             thread::spawn(move|| {\n-                // wait until all the tasks are ready to go.\n+                // wait until all the threads are ready to go.\n                 rx.recv().unwrap();\n \n                 // deschedule to attempt to interleave things as much\n@@ -394,7 +394,7 @@ mod tests {\n             });\n         }\n \n-        // start all the tasks\n+        // start all the threads\n         for tx in &txs {\n             tx.send(()).unwrap();\n         }"}, {"sha": "8e55ff0b76c50effcd41fe26aa83b7a9498facad", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -590,7 +590,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>,\n /// This is an unsafe and experimental API which allows for an arbitrary\n /// callback to be invoked when a thread panics. This callback is invoked on both\n /// the initial unwinding and a double unwinding if one occurs. Additionally,\n-/// the local `Task` will be in place for the duration of the callback, and\n+/// the local `Thread` will be in place for the duration of the callback, and\n /// the callback must ensure that it remains in place once the callback returns.\n ///\n /// Only a limited number of callbacks can be registered, and this function"}, {"sha": "8360620c3453b71fe806c04ec4904a370a59f65a", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -10,7 +10,7 @@\n \n use sync::{Mutex, Condvar};\n \n-/// A barrier enables multiple tasks to synchronize the beginning\n+/// A barrier enables multiple threads to synchronize the beginning\n /// of some computation.\n ///\n /// ```\n@@ -128,7 +128,7 @@ mod tests {\n             });\n         }\n \n-        // At this point, all spawned tasks should be blocked,\n+        // At this point, all spawned threads should be blocked,\n         // so we shouldn't get anything from the port\n         assert!(match rx.try_recv() {\n             Err(TryRecvError::Empty) => true,"}, {"sha": "77aeeca7968099b4d80e1633a695e5556a4bdc35", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -107,7 +107,7 @@\n //!\n //! let (tx, rx) = sync_channel::<i32>(0);\n //! thread::spawn(move|| {\n-//!     // This will wait for the parent task to start receiving\n+//!     // This will wait for the parent thread to start receiving\n //!     tx.send(53).unwrap();\n //! });\n //! rx.recv().unwrap();\n@@ -253,7 +253,7 @@\n // blocking. The implementation is essentially the entire blocking procedure\n // followed by an increment as soon as its woken up. The cancellation procedure\n // involves an increment and swapping out of to_wake to acquire ownership of the\n-// task to unblock.\n+// thread to unblock.\n //\n // Sadly this current implementation requires multiple allocations, so I have\n // seen the throughput of select() be much worse than it should be. I do not\n@@ -289,7 +289,7 @@ mod mpsc_queue;\n mod spsc_queue;\n \n /// The receiving-half of Rust's channel type. This half can only be owned by\n-/// one task\n+/// one thread\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Receiver<T> {\n     inner: UnsafeCell<Flavor<T>>,\n@@ -316,7 +316,7 @@ pub struct IntoIter<T> {\n }\n \n /// The sending-half of Rust's asynchronous channel type. This half can only be\n-/// owned by one task, but it can be cloned to send to other tasks.\n+/// owned by one thread, but it can be cloned to send to other threads.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Sender<T> {\n     inner: UnsafeCell<Flavor<T>>,\n@@ -327,7 +327,7 @@ pub struct Sender<T> {\n unsafe impl<T: Send> Send for Sender<T> { }\n \n /// The sending-half of Rust's synchronous channel type. This half can only be\n-/// owned by one task, but it can be cloned to send to other tasks.\n+/// owned by one thread, but it can be cloned to send to other threads.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SyncSender<T> {\n     inner: Arc<UnsafeCell<sync::Packet<T>>>,\n@@ -421,7 +421,7 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// Creates a new asynchronous channel, returning the sender/receiver halves.\n ///\n /// All data sent on the sender will become available on the receiver, and no\n-/// send will block the calling task (this channel has an \"infinite buffer\").\n+/// send will block the calling thread (this channel has an \"infinite buffer\").\n ///\n /// # Examples\n ///\n@@ -1596,15 +1596,15 @@ mod tests {\n             drop(rx);  // destroy a shared\n             tx2.send(()).unwrap();\n         });\n-        // make sure the other task has gone to sleep\n+        // make sure the other thread has gone to sleep\n         for _ in 0..5000 { thread::yield_now(); }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n         drop(tx);\n         t.send(()).unwrap();\n \n-        // wait for the child task to exit before we exit\n+        // wait for the child thread to exit before we exit\n         rx2.recv().unwrap();\n     }\n }\n@@ -2060,15 +2060,15 @@ mod sync_tests {\n             drop(rx);  // destroy a shared\n             tx2.send(()).unwrap();\n         });\n-        // make sure the other task has gone to sleep\n+        // make sure the other thread has gone to sleep\n         for _ in 0..5000 { thread::yield_now(); }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n         drop(tx);\n         t.send(()).unwrap();\n \n-        // wait for the child task to exit before we exit\n+        // wait for the child thread to exit before we exit\n         rx2.recv().unwrap();\n     }\n "}, {"sha": "2c0da938cbf8b71c59079fa37e1c22ee6c5a02c5", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -28,7 +28,7 @@\n //! A mostly lock-free multi-producer, single consumer queue.\n //!\n //! This module contains an implementation of a concurrent MPSC queue. This\n-//! queue can be used to share data between tasks, and is also used as the\n+//! queue can be used to share data between threads, and is also used as the\n //! building block of channels in rust.\n //!\n //! Note that the current implementation of this queue has a caveat of the `pop`"}, {"sha": "7e9c017617d8ac43c81da9e16c4617cc63c62dbb", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -23,7 +23,7 @@\n /// # Implementation\n ///\n /// Oneshots are implemented around one atomic usize variable. This variable\n-/// indicates both the state of the port/chan but also contains any tasks\n+/// indicates both the state of the port/chan but also contains any threads\n /// blocked on the port. All atomic operations happen on this one word.\n ///\n /// In order to upgrade a oneshot channel, an upgrade is considered a disconnect\n@@ -55,7 +55,7 @@ const DISCONNECTED: usize = 2;   // channel is disconnected OR upgraded\n // whoever changed the state.\n \n pub struct Packet<T> {\n-    // Internal state of the chan/port pair (stores the blocked task as well)\n+    // Internal state of the chan/port pair (stores the blocked thread as well)\n     state: AtomicUsize,\n     // One-shot data slot location\n     data: Option<T>,\n@@ -139,7 +139,7 @@ impl<T> Packet<T> {\n     }\n \n     pub fn recv(&mut self) -> Result<T, Failure<T>> {\n-        // Attempt to not block the task (it's a little expensive). If it looks\n+        // Attempt to not block the thread (it's a little expensive). If it looks\n         // like we're not empty, then immediately go through to `try_recv`.\n         if self.state.load(Ordering::SeqCst) == EMPTY {\n             let (wait_token, signal_token) = blocking::tokens();\n@@ -317,8 +317,8 @@ impl<T> Packet<T> {\n         }\n     }\n \n-    // Remove a previous selecting task from this port. This ensures that the\n-    // blocked task will no longer be visible to any other threads.\n+    // Remove a previous selecting thread from this port. This ensures that the\n+    // blocked thread will no longer be visible to any other threads.\n     //\n     // The return value indicates whether there's data on this port.\n     pub fn abort_selection(&mut self) -> Result<bool, Receiver<T>> {\n@@ -329,7 +329,7 @@ impl<T> Packet<T> {\n             s @ DATA |\n             s @ DISCONNECTED => s,\n \n-            // If we've got a blocked task, then use an atomic to gain ownership\n+            // If we've got a blocked thread, then use an atomic to gain ownership\n             // of it (may fail)\n             ptr => self.state.compare_and_swap(ptr, EMPTY, Ordering::SeqCst)\n         };\n@@ -338,7 +338,7 @@ impl<T> Packet<T> {\n         // about it.\n         match state {\n             EMPTY => unreachable!(),\n-            // our task used for select was stolen\n+            // our thread used for select was stolen\n             DATA => Ok(true),\n \n             // If the other end has hung up, then we have complete ownership"}, {"sha": "679cc550454fa77eba908a7c04b2c79b1095a801", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -229,7 +229,7 @@ impl Select {\n             // woken us up (although the wakeup is guaranteed to fail).\n             //\n             // This situation happens in the window of where a sender invokes\n-            // increment(), sees -1, and then decides to wake up the task. After\n+            // increment(), sees -1, and then decides to wake up the thread. After\n             // all this is done, the sending thread will set `selecting` to\n             // `false`. Until this is done, we cannot return. If we were to\n             // return, then a sender could wake up a receiver which has gone"}, {"sha": "41c79dd52c85a1a38d5e60c0be3da36c6398a757", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -91,8 +91,8 @@ impl<T> Packet<T> {\n     }\n \n     // This function is used at the creation of a shared packet to inherit a\n-    // previously blocked task. This is done to prevent spurious wakeups of\n-    // tasks in select().\n+    // previously blocked thread. This is done to prevent spurious wakeups of\n+    // threads in select().\n     //\n     // This can only be called at channel-creation time\n     pub fn inherit_blocker(&mut self,\n@@ -424,7 +424,7 @@ impl<T> Packet<T> {\n         }\n     }\n \n-    // Cancels a previous task waiting on this port, returning whether there's\n+    // Cancels a previous thread waiting on this port, returning whether there's\n     // data on the port.\n     //\n     // This is similar to the stream implementation (hence fewer comments), but"}, {"sha": "b72da91c0a075cffd1ed7a4421070ae980358699", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -30,7 +30,7 @@\n //! A single-producer single-consumer concurrent queue\n //!\n //! This module contains the implementation of an SPSC queue which can be used\n-//! concurrently between two tasks. This data structure is safe to use and\n+//! concurrently between two threads. This data structure is safe to use and\n //! enforces the semantics that there is one pusher and one popper.\n \n #![unstable(feature = \"std_misc\")]"}, {"sha": "404814b4cd4bb6dfc8075184fffdbeeaedb97f36", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -181,7 +181,7 @@ impl<T> Packet<T> {\n             data => return data,\n         }\n \n-        // Welp, our channel has no data. Deschedule the current task and\n+        // Welp, our channel has no data. Deschedule the current thread and\n         // initiate the blocking protocol.\n         let (wait_token, signal_token) = blocking::tokens();\n         if self.decrement(signal_token).is_ok() {\n@@ -385,7 +385,7 @@ impl<T> Packet<T> {\n         }\n     }\n \n-    // Removes a previous task from being blocked in this port\n+    // Removes a previous thread from being blocked in this port\n     pub fn abort_selection(&mut self,\n                            was_upgrade: bool) -> Result<bool, Receiver<T>> {\n         // If we're aborting selection after upgrading from a oneshot, then\n@@ -414,7 +414,7 @@ impl<T> Packet<T> {\n         let prev = self.bump(steals + 1);\n \n         // If we were previously disconnected, then we know for sure that there\n-        // is no task in to_wake, so just keep going\n+        // is no thread in to_wake, so just keep going\n         let has_data = if prev == DISCONNECTED {\n             assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n             true // there is data, that data is that we're disconnected\n@@ -428,7 +428,7 @@ impl<T> Packet<T> {\n             //\n             // If the previous count was positive then we're in a tougher\n             // situation. A possible race is that a sender just incremented\n-            // through -1 (meaning it's going to try to wake a task up), but it\n+            // through -1 (meaning it's going to try to wake a thread up), but it\n             // hasn't yet read the to_wake. In order to prevent a future recv()\n             // from waking up too early (this sender picking up the plastered\n             // over to_wake), we spin loop here waiting for to_wake to be 0."}, {"sha": "904eab1fd7efd18ac2f7a7a1c9105eb111746ad1", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -19,7 +19,7 @@\n /// which means that every successful send is paired with a successful recv.\n ///\n /// This flavor of channels defines a new `send_opt` method for channels which\n-/// is the method by which a message is sent but the task does not panic if it\n+/// is the method by which a message is sent but the thread does not panic if it\n /// cannot be delivered.\n ///\n /// Another major difference is that send() will *always* return back the data\n@@ -62,12 +62,12 @@ unsafe impl<T: Send> Sync for Packet<T> { }\n struct State<T> {\n     disconnected: bool, // Is the channel disconnected yet?\n     queue: Queue,       // queue of senders waiting to send data\n-    blocker: Blocker,   // currently blocked task on this channel\n+    blocker: Blocker,   // currently blocked thread on this channel\n     buf: Buffer<T>,     // storage for buffered messages\n     cap: usize,         // capacity of this channel\n \n     /// A curious flag used to indicate whether a sender failed or succeeded in\n-    /// blocking. This is used to transmit information back to the task that it\n+    /// blocking. This is used to transmit information back to the thread that it\n     /// must dequeue its message from the buffer because it was not received.\n     /// This is only relevant in the 0-buffer case. This obviously cannot be\n     /// safely constructed, but it's guaranteed to always have a valid pointer\n@@ -84,7 +84,7 @@ enum Blocker {\n     NoneBlocked\n }\n \n-/// Simple queue for threading tasks together. Nodes are stack-allocated, so\n+/// Simple queue for threading threads together. Nodes are stack-allocated, so\n /// this structure is not safe at all\n struct Queue {\n     head: *mut Node,\n@@ -130,7 +130,7 @@ fn wait<'a, 'b, T>(lock: &'a Mutex<State<T>>,\n \n /// Wakes up a thread, dropping the lock at the correct time\n fn wakeup<T>(token: SignalToken, guard: MutexGuard<State<T>>) {\n-    // We need to be careful to wake up the waiting task *outside* of the mutex\n+    // We need to be careful to wake up the waiting thread *outside* of the mutex\n     // in case it incurs a context switch.\n     drop(guard);\n     token.signal();\n@@ -298,7 +298,7 @@ impl<T> Packet<T> {\n         };\n         mem::drop(guard);\n \n-        // only outside of the lock do we wake up the pending tasks\n+        // only outside of the lock do we wake up the pending threads\n         pending_sender1.map(|t| t.signal());\n         pending_sender2.map(|t| t.signal());\n     }\n@@ -394,8 +394,8 @@ impl<T> Packet<T> {\n         }\n     }\n \n-    // Remove a previous selecting task from this port. This ensures that the\n-    // blocked task will no longer be visible to any other threads.\n+    // Remove a previous selecting thread from this port. This ensures that the\n+    // blocked thread will no longer be visible to any other threads.\n     //\n     // The return value indicates whether there's data on this port.\n     pub fn abort_selection(&self) -> bool {\n@@ -446,7 +446,7 @@ impl<T> Buffer<T> {\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n-// Queue, a simple queue to enqueue tasks with (stack-allocated nodes)\n+// Queue, a simple queue to enqueue threads with (stack-allocated nodes)\n ////////////////////////////////////////////////////////////////////////////////\n \n impl Queue {"}, {"sha": "febf5f1b183223938d706341be1b86abf1ec0bb9", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -30,7 +30,7 @@ use sys_common::poison::{self, TryLockError, TryLockResult, LockResult};\n ///\n /// The mutexes in this module implement a strategy called \"poisoning\" where a\n /// mutex is considered poisoned whenever a thread panics while holding the\n-/// lock. Once a mutex is poisoned, all other tasks are unable to access the\n+/// lock. Once a mutex is poisoned, all other threads are unable to access the\n /// data by default as it is likely tainted (some invariant is not being\n /// upheld).\n ///\n@@ -56,7 +56,7 @@ use sys_common::poison::{self, TryLockError, TryLockResult, LockResult};\n /// // Spawn a few threads to increment a shared variable (non-atomically), and\n /// // let the main thread know once all increments are done.\n /// //\n-/// // Here we're using an Arc to share memory among tasks, and the data inside\n+/// // Here we're using an Arc to share memory among threads, and the data inside\n /// // the Arc is protected with a mutex.\n /// let data = Arc::new(Mutex::new(0));\n ///\n@@ -69,7 +69,7 @@ use sys_common::poison::{self, TryLockError, TryLockResult, LockResult};\n ///         // which can access the shared state when the lock is held.\n ///         //\n ///         // We unwrap() the return value to assert that we are not expecting\n-///         // tasks to ever fail while holding the lock.\n+///         // threads to ever fail while holding the lock.\n ///         let mut data = data.lock().unwrap();\n ///         *data += 1;\n ///         if *data == N {\n@@ -195,10 +195,10 @@ impl<T> Mutex<T> {\n }\n \n impl<T: ?Sized> Mutex<T> {\n-    /// Acquires a mutex, blocking the current task until it is able to do so.\n+    /// Acquires a mutex, blocking the current thread until it is able to do so.\n     ///\n-    /// This function will block the local task until it is available to acquire\n-    /// the mutex. Upon returning, the task is the only task with the mutex\n+    /// This function will block the local thread until it is available to acquire\n+    /// the mutex. Upon returning, the thread is the only thread with the mutex\n     /// held. An RAII guard is returned to allow scoped unlock of the lock. When\n     /// the guard goes out of scope, the mutex will be unlocked.\n     ///"}, {"sha": "57baedaad9c8e85fef351e66874347d6414a28ad", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -55,13 +55,13 @@ impl Once {\n     /// will be executed if this is the first time `call_once` has been called,\n     /// and otherwise the routine will *not* be invoked.\n     ///\n-    /// This method will block the calling task if another initialization\n+    /// This method will block the calling thread if another initialization\n     /// routine is currently running.\n     ///\n     /// When this function returns, it is guaranteed that some initialization\n     /// has run and completed (it may not be the closure specified). It is also\n     /// guaranteed that any memory writes performed by the executed closure can\n-    /// be reliably observed by other tasks at this point (there is a\n+    /// be reliably observed by other threads at this point (there is a\n     /// happens-before relation between the closure and code executing after the\n     /// return).\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "625377df7d6dd71748146d87681fbc5c97c3756d", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -25,7 +25,7 @@ use sys_common::rwlock as sys;\n /// typically allows for read-only access (shared access).\n ///\n /// The type parameter `T` represents the data that this lock protects. It is\n-/// required that `T` satisfies `Send` to be shared across tasks and `Sync` to\n+/// required that `T` satisfies `Send` to be shared across threads and `Sync` to\n /// allow concurrent access through readers. The RAII guards returned from the\n /// locking methods implement `Deref` (and `DerefMut` for the `write` methods)\n /// to allow access to the contained of the lock."}, {"sha": "67679c11a9858b587d3e66f4539511e5161670e0", "filename": "src/libstd/sys/common/poison.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -55,7 +55,7 @@ pub struct Guard {\n \n /// A type of error which can be returned whenever a lock is acquired.\n ///\n-/// Both Mutexes and RwLocks are poisoned whenever a task fails while the lock\n+/// Both Mutexes and RwLocks are poisoned whenever a thread fails while the lock\n /// is held. The precise semantics for when a lock is poisoned is documented on\n /// each lock, but once a lock is poisoned then all future acquisitions will\n /// return this error.\n@@ -68,7 +68,7 @@ pub struct PoisonError<T> {\n /// `try_lock` method.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TryLockError<T> {\n-    /// The lock could not be acquired because another task failed while holding\n+    /// The lock could not be acquired because another thread failed while holding\n     /// the lock.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Poisoned(PoisonError<T>),"}, {"sha": "fadeebc8150017518a258cec3f653cb9924b6330", "filename": "src/libstd/sys/common/stack.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -11,13 +11,13 @@\n //! Rust stack-limit management\n //!\n //! Currently Rust uses a segmented-stack-like scheme in order to detect stack\n-//! overflow for rust tasks. In this scheme, the prologue of all functions are\n+//! overflow for rust threads. In this scheme, the prologue of all functions are\n //! preceded with a check to see whether the current stack limits are being\n //! exceeded.\n //!\n //! This module provides the functionality necessary in order to manage these\n //! stack limits (which are stored in platform-specific locations). The\n-//! functions here are used at the borders of the task lifetime in order to\n+//! functions here are used at the borders of the thread lifetime in order to\n //! manage these limits.\n //!\n //! This function is an unstable module because this scheme for stack overflow"}, {"sha": "135ae1bf9163bc155bd312de295eed1150ac826f", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -22,7 +22,7 @@\n ///   getting both accurate backtraces and accurate symbols across platforms.\n ///   This route was not chosen in favor of the next option, however.\n ///\n-/// * We're already using libgcc_s for exceptions in rust (triggering task\n+/// * We're already using libgcc_s for exceptions in rust (triggering thread\n ///   unwinding and running destructors on the stack), and it turns out that it\n ///   conveniently comes with a function that also gives us a backtrace. All of\n ///   these functions look like _Unwind_*, but it's not quite the full\n@@ -116,7 +116,7 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n \n     // while it doesn't requires lock for work as everything is\n     // local, it still displays much nicer backtraces when a\n-    // couple of tasks panic simultaneously\n+    // couple of threads panic simultaneously\n     static LOCK: StaticMutex = MUTEX_INIT;\n     let _g = LOCK.lock();\n "}, {"sha": "ea5af3f2830e8cd0ad58449457878707a6c1ec10", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -32,7 +32,7 @@ pub type Dtor = unsafe extern fn(*mut u8);\n // somewhere to run arbitrary code on thread termination. With this in place\n // we'll be able to run anything we like, including all TLS destructors!\n //\n-// To accomplish this feat, we perform a number of tasks, all contained\n+// To accomplish this feat, we perform a number of threads, all contained\n // within this module:\n //\n // * All TLS destructors are tracked by *us*, not the windows runtime. This"}, {"sha": "41bdf034705d3bce65f68bce31504ad36da1ca86", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -32,7 +32,7 @@ pub mod __impl {\n /// primary method is the `with` method.\n ///\n /// The `with` method yields a reference to the contained value which cannot be\n-/// sent across tasks or escape the given closure.\n+/// sent across threads or escape the given closure.\n ///\n /// # Initialization and Destruction\n ///"}, {"sha": "f480147b93ee704a9ae1b6ca66f066fa224f1242", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -873,8 +873,8 @@ mod tests {\n \n     #[test]\n     fn test_child_doesnt_ref_parent() {\n-        // If the child refcounts the parent task, this will stack overflow when\n-        // climbing the task tree to dereference each ancestor. (See #1789)\n+        // If the child refcounts the parent thread, this will stack overflow when\n+        // climbing the thread tree to dereference each ancestor. (See #1789)\n         // (well, it would if the constant were 8000+ - I lowered it to be more\n         // valgrind-friendly. try this at home, instead..!)\n         const GENERATIONS: u32 = 16;\n@@ -983,6 +983,6 @@ mod tests {\n         thread::sleep_ms(2);\n     }\n \n-    // NOTE: the corresponding test for stderr is in run-pass/task-stderr, due\n+    // NOTE: the corresponding test for stderr is in run-pass/thread-stderr, due\n     // to the test harness apparently interfering with stderr configuration.\n }"}, {"sha": "e36631210d4da5f02766653b1e3a3d8c69fced82", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -77,7 +77,7 @@\n //!\n //! The `cs_...` functions (\"combine substructure) are designed to\n //! make life easier by providing some pre-made recipes for common\n-//! tasks; mostly calling the function being derived on all the\n+//! threads; mostly calling the function being derived on all the\n //! arguments and then combining them back together in some way (or\n //! letting the user chose that). They are not meant to be the only\n //! way to handle the structures that this code creates."}, {"sha": "53ed4f351d35667f5c4d1eec07edb51f7b14d043", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -601,7 +601,7 @@ pub type IdentInterner = StrInterner;\n \n // if an interner exists in TLS, return it. Otherwise, prepare a\n // fresh one.\n-// FIXME(eddyb) #8726 This should probably use a task-local reference.\n+// FIXME(eddyb) #8726 This should probably use a thread-local reference.\n pub fn get_ident_interner() -> Rc<IdentInterner> {\n     thread_local!(static KEY: Rc<::parse::token::IdentInterner> = {\n         Rc::new(mk_fresh_ident_interner())\n@@ -615,14 +615,14 @@ pub fn reset_ident_interner() {\n     interner.reset(mk_fresh_ident_interner());\n }\n \n-/// Represents a string stored in the task-local interner. Because the\n-/// interner lives for the life of the task, this can be safely treated as an\n-/// immortal string, as long as it never crosses between tasks.\n+/// Represents a string stored in the thread-local interner. Because the\n+/// interner lives for the life of the thread, this can be safely treated as an\n+/// immortal string, as long as it never crosses between threads.\n ///\n /// FIXME(pcwalton): You must be careful about what you do in the destructors\n /// of objects stored in TLS, because they may run after the interner is\n /// destroyed. In particular, they must not access string contents. This can\n-/// be fixed in the future by just leaking all strings until task death\n+/// be fixed in the future by just leaking all strings until thread death\n /// somehow.\n #[derive(Clone, PartialEq, Hash, PartialOrd, Eq, Ord)]\n pub struct InternedString {\n@@ -697,22 +697,22 @@ impl Encodable for InternedString {\n     }\n }\n \n-/// Returns the string contents of a name, using the task-local interner.\n+/// Returns the string contents of a name, using the thread-local interner.\n #[inline]\n pub fn get_name(name: ast::Name) -> InternedString {\n     let interner = get_ident_interner();\n     InternedString::new_from_rc_str(interner.get(name))\n }\n \n-/// Returns the string contents of an identifier, using the task-local\n+/// Returns the string contents of an identifier, using the thread-local\n /// interner.\n #[inline]\n pub fn get_ident(ident: ast::Ident) -> InternedString {\n     get_name(ident.name)\n }\n \n /// Interns and returns the string contents of an identifier, using the\n-/// task-local interner.\n+/// thread-local interner.\n #[inline]\n pub fn intern_and_get_ident(s: &str) -> InternedString {\n     get_name(intern(s))"}, {"sha": "4d0b746c60c755de7d239348aef896747a067eb7", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -146,7 +146,7 @@ pub trait TDynBenchFn: Send {\n // A function that runs a test. If the function returns successfully,\n // the test succeeds; if the function panics then the test fails. We\n // may need to come up with a more clever definition of test in order\n-// to support isolation of tests into tasks.\n+// to support isolation of tests into threads.\n pub enum TestFn {\n     StaticTestFn(fn()),\n     StaticBenchFn(fn(&mut Bencher)),"}, {"sha": "07174de88a3d017b385c4bdcfbc0abf8e775ef34", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This test creates a bunch of tasks that simultaneously send to each\n+// This test creates a bunch of threads that simultaneously send to each\n // other in a ring. The messages should all be basically\n // independent.\n // This is like msgsend-ring-pipes but adapted to use Arcs.\n@@ -52,7 +52,7 @@ fn thread_ring(i: usize, count: usize, num_chan: pipe, num_port: pipe) {\n     let mut num_port = Some(num_port);\n     // Send/Receive lots of messages.\n     for j in 0..count {\n-        //println!(\"task %?, iter %?\", i, j);\n+        //println!(\"thread %?, iter %?\", i, j);\n         let num_chan2 = num_chan.take().unwrap();\n         let num_port2 = num_port.take().unwrap();\n         send(&num_chan2, i * j);"}, {"sha": "9be13101aa8a1d108d30de13c6c704eec1665d69", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -21,14 +21,14 @@ use std::sync::mpsc::channel;\n use std::env;\n use std::thread;\n \n-// This is a simple bench that creates M pairs of tasks. These\n-// tasks ping-pong back and forth over a pair of streams. This is a\n+// This is a simple bench that creates M pairs of threads. These\n+// threads ping-pong back and forth over a pair of streams. This is a\n // canonical message-passing benchmark as it heavily strains message\n // passing and almost nothing else.\n \n fn ping_pong_bench(n: usize, m: usize) {\n \n-    // Create pairs of tasks that pingpong back and forth.\n+    // Create pairs of threads that pingpong back and forth.\n     fn run_pair(n: usize) {\n         // Create a channel: A->B\n         let (atx, arx) = channel();"}, {"sha": "2c5c0ea27c7603b02d1e2020177014b80b9aebe2", "filename": "src/test/bench/rt-parfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Fbench%2Frt-parfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Fbench%2Frt-parfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-parfib.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -13,7 +13,7 @@ use std::env;\n use std::thread;\n \n // A simple implementation of parfib. One subtree is found in a new\n-// task and communicated over a oneshot pipe, the other is found\n+// thread and communicated over a oneshot pipe, the other is found\n // locally. There is no sequential-mode threshold.\n \n fn parfib(n: u64) -> u64 {"}, {"sha": "365a86464e2d377a6c82ef2072be1d37aed31558", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -11,7 +11,7 @@\n // ignore-android: FIXME(#10393) hangs without output\n // ignore-pretty very bad with line comments\n \n-// multi tasking k-nucleotide\n+// multi threading k-nucleotide\n \n use std::ascii::AsciiExt;\n use std::cmp::Ordering::{self, Less, Greater, Equal};"}, {"sha": "6e3db3d01960eabeb8642cb4230d439900030ea9", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test performance of a task \"spawn ladder\", in which children task have\n-// many ancestor taskgroups, but with only a few such groups alive at a time.\n-// Each child task has to enlist as a descendant in each of its ancestor\n+// Test performance of a thread \"spawn ladder\", in which children thread have\n+// many ancestor threadgroups, but with only a few such groups alive at a time.\n+// Each child thread has to enlist as a descendant in each of its ancestor\n // groups, but that shouldn't have to happen for already-dead groups.\n //\n // The filename is a song reference; google it in quotes.\n@@ -23,7 +23,7 @@ use std::thread;\n \n fn child_generation(gens_left: usize, tx: Sender<()>) {\n     // This used to be O(n^2) in the number of generations that ever existed.\n-    // With this code, only as many generations are alive at a time as tasks\n+    // With this code, only as many generations are alive at a time as threads\n     // alive at a time,\n     thread::spawn(move|| {\n         if gens_left & 1 == 1 {"}, {"sha": "252ac9bcac0d524db348ff6f0c59d8f674ebba94", "filename": "src/test/run-fail/issue-2061.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-fail%2Fissue-2061.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-fail%2Fissue-2061.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-2061.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-test\n-// error-pattern: task '<main>' has overflowed its stack\n+// error-pattern: thread '<main>' has overflowed its stack\n \n struct R {\n     b: isize,"}, {"sha": "f5da02018154649106bf661aae0f2be723b06607", "filename": "src/test/run-fail/rt-set-exit-status.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-fail%2Frt-set-exit-status.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-fail%2Frt-set-exit-status.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -17,7 +17,7 @@ use std::env;\n \n fn main() {\n     error!(\"whatever\");\n-    // 101 is the code the runtime uses on task panic and the value\n+    // 101 is the code the runtime uses on thread panic and the value\n     // compiletest expects run-fail tests to return.\n     env::set_exit_status(101);\n }"}, {"sha": "8ad9d4cf6e2c59f676b08bf23962a7d46844835a", "filename": "src/test/run-fail/task-spawn-barefn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:Ensure that the child task runs by panicking\n+// error-pattern:Ensure that the child thread runs by panicking\n \n use std::thread;\n \n fn main() {\n-    // the purpose of this test is to make sure that task::spawn()\n+    // the purpose of this test is to make sure that thread::spawn()\n     // works when provided with a bare function:\n     let r = thread::spawn(startfn).join();\n     if r.is_err() {"}, {"sha": "6e5a9b2f2ac023973a2dfbe33d9d858e5635d43b", "filename": "src/test/run-fail/too-much-recursion-unwinding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-fail%2Ftoo-much-recursion-unwinding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-fail%2Ftoo-much-recursion-unwinding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftoo-much-recursion-unwinding.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -11,7 +11,7 @@\n // ignore-test leaks\n // error-pattern:ran out of stack\n \n-// Test that the task panicks after hitting the recursion limit\n+// Test that the thread panicks after hitting the recursion limit\n // during unwinding\n \n fn recurse() {"}, {"sha": "252086ad014da6d65a485fc9d54e11a6e1632d39", "filename": "src/test/run-pass/extern-call-deep2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -40,7 +40,7 @@ fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n }\n \n pub fn main() {\n-    // Make sure we're on a task with small Rust stacks (main currently\n+    // Make sure we're on a thread with small Rust stacks (main currently\n     // has a large stack)\n     thread::spawn(move|| {\n         let result = count(1000);"}, {"sha": "9a39b1773e533e58f48bd3839755e04d92e79c8a", "filename": "src/test/run-pass/extern-call-scrub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -44,7 +44,7 @@ fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n }\n \n pub fn main() {\n-    // Make sure we're on a task with small Rust stacks (main currently\n+    // Make sure we're on a thread with small Rust stacks (main currently\n     // has a large stack)\n     thread::spawn(move|| {\n         let result = count(12);"}, {"sha": "11de5ac70f4feecccd15c82a1ceee8528443f330", "filename": "src/test/run-pass/foreign-dupe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// calling pin_task and that's having weird side-effects.\n+// calling pin_thread and that's having weird side-effects.\n \n // pretty-expanded FIXME #23616\n "}, {"sha": "4dae1131c6d918daf7403820b3015b2137d971a1", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -68,7 +68,7 @@ mod map_reduce {\n     pub fn map_reduce(inputs: Vec<String>) {\n         let (tx, rx) = channel();\n \n-        // This task becomes the master control task. It spawns others\n+        // This thread becomes the master control thread. It spawns others\n         // to do the rest.\n \n         let mut reducers: HashMap<String, isize>;"}, {"sha": "a3dfa361cecd6268cda9c0cbf5760bd4f7383acc", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -22,14 +22,14 @@ fn test00() {\n         start(i)\n     });\n \n-    // Sleep long enough for the task to finish.\n+    // Sleep long enough for the thread to finish.\n     let mut i = 0_usize;\n     while i < 10000 {\n         thread::yield_now();\n         i += 1;\n     }\n \n-    // Try joining tasks that have already finished.\n+    // Try joining threads that have already finished.\n     result.join();\n \n     println!(\"Joined task.\");"}, {"sha": "90f68deb303e847d34ca6f9bb4afe8ad7528c155", "filename": "src/test/run-pass/task-comm-14.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -16,7 +16,7 @@ use std::thread;\n pub fn main() {\n     let (tx, rx) = channel();\n \n-    // Spawn 10 tasks each sending us back one isize.\n+    // Spawn 10 threads each sending us back one isize.\n     let mut i = 10;\n     while (i > 0) {\n         println!(\"{}\", i);\n@@ -25,7 +25,7 @@ pub fn main() {\n         i = i - 1;\n     }\n \n-    // Spawned tasks are likely killed before they get a chance to send\n+    // Spawned threads are likely killed before they get a chance to send\n     // anything back, so we deadlock here.\n \n     i = 10;"}, {"sha": "2994b9c53849093260a53399ac49d83cc3909461", "filename": "src/test/run-pass/task-comm-15.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -24,7 +24,7 @@ fn start(tx: &Sender<isize>, i0: isize) {\n }\n \n pub fn main() {\n-    // Spawn a task that sends us back messages. The parent task\n+    // Spawn a thread that sends us back messages. The parent thread\n     // is likely to terminate before the child completes, so from\n     // the child's point of view the receiver may die. We should\n     // drop messages on the floor in this case, and not crash!"}, {"sha": "890107998ccb75f44b53aff4332bf59a3ed8468f", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -38,7 +38,7 @@ fn test00() {\n \n     let mut i: isize = 0;\n \n-    // Create and spawn tasks...\n+    // Create and spawn threads...\n     let mut results = Vec::new();\n     while i < number_of_tasks {\n         let tx = tx.clone();\n@@ -51,7 +51,7 @@ fn test00() {\n         i = i + 1;\n     }\n \n-    // Read from spawned tasks...\n+    // Read from spawned threads...\n     let mut sum = 0;\n     for _r in &results {\n         i = 0;\n@@ -62,12 +62,12 @@ fn test00() {\n         }\n     }\n \n-    // Join spawned tasks...\n+    // Join spawned threads...\n     for r in results { r.join(); }\n \n     println!(\"Completed: Final number is: \");\n     println!(\"{}\", sum);\n-    // assert (sum == (((number_of_tasks * (number_of_tasks - 1)) / 2) *\n+    // assert (sum == (((number_of_threads * (number_of_threads - 1)) / 2) *\n     //       number_of_messages));\n     assert_eq!(sum, 480);\n }"}, {"sha": "250ed58a8ef4c5040cd0d1389b68521695ff0193", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff332b6467b2b93831c3f0ae3665e920ec725959/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=ff332b6467b2b93831c3f0ae3665e920ec725959", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // Tests that a heterogeneous list of existential types can be put inside an Arc\n-// and shared between tasks as long as all types fulfill Send.\n+// and shared between threads as long as all types fulfill Send.\n \n // ignore-pretty\n "}]}