{"sha": "c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4MWI0M2Q4YWMwZGQ2OGE0OWM0YzY1NzcxYzNjNjVhNGNhNjFmOTM=", "commit": {"author": {"name": "Victor Ding", "email": "victording@google.com", "date": "2020-09-09T04:51:16Z"}, "committer": {"name": "Victor Ding", "email": "victording@google.com", "date": "2020-09-09T07:32:23Z"}, "message": "Add `-Z combine_cgu` flag\n\nIntroduce a compiler option to let rustc combines all regular CGUs into\na single one at the end of compilation.\n\nPart of Issue #64191", "tree": {"sha": "98bb7d0e06691d6023b59ceee23511d4670473cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98bb7d0e06691d6023b59ceee23511d4670473cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93", "html_url": "https://github.com/rust-lang/rust/commit/c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93/comments", "author": null, "committer": null, "parents": [{"sha": "e82584a77d019bd5ee4254b5870270b1493763a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/e82584a77d019bd5ee4254b5870270b1493763a6", "html_url": "https://github.com/rust-lang/rust/commit/e82584a77d019bd5ee4254b5870270b1493763a6"}], "stats": {"total": 105, "additions": 90, "deletions": 15}, "files": [{"sha": "4b2d5907a02f46739dffe316149641aa579d76a9", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93", "patch": "@@ -346,14 +346,14 @@ fn fat_lto(\n     Ok(LtoModuleCodegen::Fat { module: Some(module), _serialized_bitcode: serialized_bitcode })\n }\n \n-struct Linker<'a>(&'a mut llvm::Linker<'a>);\n+crate struct Linker<'a>(&'a mut llvm::Linker<'a>);\n \n impl Linker<'a> {\n-    fn new(llmod: &'a llvm::Module) -> Self {\n+    crate fn new(llmod: &'a llvm::Module) -> Self {\n         unsafe { Linker(llvm::LLVMRustLinkerNew(llmod)) }\n     }\n \n-    fn add(&mut self, bytecode: &[u8]) -> Result<(), ()> {\n+    crate fn add(&mut self, bytecode: &[u8]) -> Result<(), ()> {\n         unsafe {\n             if llvm::LLVMRustLinkerAdd(\n                 self.0,"}, {"sha": "937821e9d4fb20230a7393e5f7a9d2ad14045938", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93", "patch": "@@ -617,6 +617,31 @@ unsafe fn add_sanitizer_passes(config: &ModuleConfig, passes: &mut Vec<&'static\n     }\n }\n \n+pub(crate) fn link(\n+    cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    diag_handler: &Handler,\n+    mut modules: Vec<ModuleCodegen<ModuleLlvm>>,\n+) -> Result<ModuleCodegen<ModuleLlvm>, FatalError> {\n+    use super::lto::{Linker, ModuleBuffer};\n+    // Sort the modules by name to ensure to ensure deterministic behavior.\n+    modules.sort_by(|a, b| a.name.cmp(&b.name));\n+    let (first, elements) =\n+        modules.split_first().expect(\"Bug! modules must contain at least one module.\");\n+\n+    let mut linker = Linker::new(first.module_llvm.llmod());\n+    for module in elements {\n+        let _timer =\n+            cgcx.prof.generic_activity_with_arg(\"LLVM_link_module\", format!(\"{:?}\", module.name));\n+        let buffer = ModuleBuffer::new(module.module_llvm.llmod());\n+        linker.add(&buffer.data()).map_err(|()| {\n+            let msg = format!(\"failed to serialize module {:?}\", module.name);\n+            llvm_err(&diag_handler, &msg)\n+        })?;\n+    }\n+    drop(linker);\n+    Ok(modules.remove(0))\n+}\n+\n pub(crate) unsafe fn codegen(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n     diag_handler: &Handler,"}, {"sha": "2e2abe9fb30f8a5b311e3136642965e5a32c8808", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93", "patch": "@@ -130,6 +130,13 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n             llvm::LLVMRustPrintPassTimings();\n         }\n     }\n+    fn run_link(\n+        cgcx: &CodegenContext<Self>,\n+        diag_handler: &Handler,\n+        modules: Vec<ModuleCodegen<Self::Module>>,\n+    ) -> Result<ModuleCodegen<Self::Module>, FatalError> {\n+        back::write::link(cgcx, diag_handler, modules)\n+    }\n     fn run_fat_lto(\n         cgcx: &CodegenContext<Self>,\n         modules: Vec<FatLTOInput<Self>>,"}, {"sha": "0edf0fcd1a2642998b2bc59be8d47182f3bfa531", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 47, "deletions": 12, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93", "patch": "@@ -702,6 +702,7 @@ impl<B: WriteBackendMethods> WorkItem<B> {\n \n enum WorkItemResult<B: WriteBackendMethods> {\n     Compiled(CompiledModule),\n+    NeedsLink(ModuleCodegen<B::Module>),\n     NeedsFatLTO(FatLTOInput<B>),\n     NeedsThinLTO(String, B::ThinBuffer),\n }\n@@ -801,31 +802,28 @@ fn execute_optimize_work_item<B: ExtraBackendMethods>(\n         None\n     };\n \n-    Ok(match lto_type {\n-        ComputedLtoType::No => {\n-            let module = unsafe { B::codegen(cgcx, &diag_handler, module, module_config)? };\n-            WorkItemResult::Compiled(module)\n-        }\n+    match lto_type {\n+        ComputedLtoType::No => finish_intra_module_work(cgcx, module, module_config),\n         ComputedLtoType::Thin => {\n             let (name, thin_buffer) = B::prepare_thin(module);\n             if let Some(path) = bitcode {\n                 fs::write(&path, thin_buffer.data()).unwrap_or_else(|e| {\n                     panic!(\"Error writing pre-lto-bitcode file `{}`: {}\", path.display(), e);\n                 });\n             }\n-            WorkItemResult::NeedsThinLTO(name, thin_buffer)\n+            Ok(WorkItemResult::NeedsThinLTO(name, thin_buffer))\n         }\n         ComputedLtoType::Fat => match bitcode {\n             Some(path) => {\n                 let (name, buffer) = B::serialize_module(module);\n                 fs::write(&path, buffer.data()).unwrap_or_else(|e| {\n                     panic!(\"Error writing pre-lto-bitcode file `{}`: {}\", path.display(), e);\n                 });\n-                WorkItemResult::NeedsFatLTO(FatLTOInput::Serialized { name, buffer })\n+                Ok(WorkItemResult::NeedsFatLTO(FatLTOInput::Serialized { name, buffer }))\n             }\n-            None => WorkItemResult::NeedsFatLTO(FatLTOInput::InMemory(module)),\n+            None => Ok(WorkItemResult::NeedsFatLTO(FatLTOInput::InMemory(module))),\n         },\n-    })\n+    }\n }\n \n fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n@@ -870,13 +868,26 @@ fn execute_lto_work_item<B: ExtraBackendMethods>(\n     cgcx: &CodegenContext<B>,\n     mut module: lto::LtoModuleCodegen<B>,\n     module_config: &ModuleConfig,\n+) -> Result<WorkItemResult<B>, FatalError> {\n+    let module = unsafe { module.optimize(cgcx)? };\n+    finish_intra_module_work(cgcx, module, module_config)\n+}\n+\n+fn finish_intra_module_work<B: ExtraBackendMethods>(\n+    cgcx: &CodegenContext<B>,\n+    module: ModuleCodegen<B::Module>,\n+    module_config: &ModuleConfig,\n ) -> Result<WorkItemResult<B>, FatalError> {\n     let diag_handler = cgcx.create_diag_handler();\n \n-    unsafe {\n-        let module = module.optimize(cgcx)?;\n-        let module = B::codegen(cgcx, &diag_handler, module, module_config)?;\n+    if !cgcx.opts.debugging_opts.combine_cgu\n+        || module.kind == ModuleKind::Metadata\n+        || module.kind == ModuleKind::Allocator\n+    {\n+        let module = unsafe { B::codegen(cgcx, &diag_handler, module, module_config)? };\n         Ok(WorkItemResult::Compiled(module))\n+    } else {\n+        Ok(WorkItemResult::NeedsLink(module))\n     }\n }\n \n@@ -891,6 +902,10 @@ pub enum Message<B: WriteBackendMethods> {\n         thin_buffer: B::ThinBuffer,\n         worker_id: usize,\n     },\n+    NeedsLink {\n+        module: ModuleCodegen<B::Module>,\n+        worker_id: usize,\n+    },\n     Done {\n         result: Result<CompiledModule, Option<WorkerFatalError>>,\n         worker_id: usize,\n@@ -1178,6 +1193,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         let mut compiled_modules = vec![];\n         let mut compiled_metadata_module = None;\n         let mut compiled_allocator_module = None;\n+        let mut needs_link = Vec::new();\n         let mut needs_fat_lto = Vec::new();\n         let mut needs_thin_lto = Vec::new();\n         let mut lto_import_only_modules = Vec::new();\n@@ -1434,6 +1450,10 @@ fn start_executing_work<B: ExtraBackendMethods>(\n                         }\n                     }\n                 }\n+                Message::NeedsLink { module, worker_id } => {\n+                    free_worker(worker_id);\n+                    needs_link.push(module);\n+                }\n                 Message::NeedsFatLTO { result, worker_id } => {\n                     assert!(!started_lto);\n                     free_worker(worker_id);\n@@ -1462,6 +1482,18 @@ fn start_executing_work<B: ExtraBackendMethods>(\n             }\n         }\n \n+        let needs_link = mem::take(&mut needs_link);\n+        if !needs_link.is_empty() {\n+            assert!(compiled_modules.is_empty());\n+            let diag_handler = cgcx.create_diag_handler();\n+            let module = B::run_link(&cgcx, &diag_handler, needs_link).map_err(|_| ())?;\n+            let module = unsafe {\n+                B::codegen(&cgcx, &diag_handler, module, cgcx.config(ModuleKind::Regular))\n+                    .map_err(|_| ())?\n+            };\n+            compiled_modules.push(module);\n+        }\n+\n         // Drop to print timings\n         drop(llvm_start_time);\n \n@@ -1521,6 +1553,9 @@ fn spawn_work<B: ExtraBackendMethods>(cgcx: CodegenContext<B>, work: WorkItem<B>\n                     Some(Ok(WorkItemResult::Compiled(m))) => {\n                         Message::Done::<B> { result: Ok(m), worker_id }\n                     }\n+                    Some(Ok(WorkItemResult::NeedsLink(m))) => {\n+                        Message::NeedsLink::<B> { module: m, worker_id }\n+                    }\n                     Some(Ok(WorkItemResult::NeedsFatLTO(m))) => {\n                         Message::NeedsFatLTO::<B> { result: m, worker_id }\n                     }"}, {"sha": "264e7c2aa92c0c44551aa53a7f20166ba238016b", "filename": "compiler/rustc_codegen_ssa/src/traits/write.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs?ref=c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93", "patch": "@@ -13,6 +13,12 @@ pub trait WriteBackendMethods: 'static + Sized + Clone {\n     type ThinData: Send + Sync;\n     type ThinBuffer: ThinBufferMethods;\n \n+    /// Merge all modules into main_module and returning it\n+    fn run_link(\n+        cgcx: &CodegenContext<Self>,\n+        diag_handler: &Handler,\n+        modules: Vec<ModuleCodegen<Self::Module>>,\n+    ) -> Result<ModuleCodegen<Self::Module>, FatalError>;\n     /// Performs fat LTO by merging all modules into a single one and returning it\n     /// for further optimization.\n     fn run_fat_lto("}, {"sha": "848c7cb7d7552604fc1e6bc61bd7ed7499f0a9ba", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=c81b43d8ac0dd68a49c4c65771c3c65a4ca61f93", "patch": "@@ -850,6 +850,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"enable the experimental Chalk-based trait solving engine\"),\n     codegen_backend: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"the backend to use\"),\n+    combine_cgu: bool = (false, parse_bool, [TRACKED],\n+        \"combine CGUs into a single one\"),\n     crate_attr: Vec<String> = (Vec::new(), parse_string_push, [TRACKED],\n         \"inject the given attribute in the crate\"),\n     debug_macros: bool = (false, parse_bool, [TRACKED],"}]}