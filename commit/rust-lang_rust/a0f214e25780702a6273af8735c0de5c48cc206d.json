{"sha": "a0f214e25780702a6273af8735c0de5c48cc206d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwZjIxNGUyNTc4MDcwMmE2MjczYWY4NzM1YzBkZTVjNDhjYzIwNmQ=", "commit": {"author": {"name": "critiqjo", "email": "john.ch.fr@gmail.com", "date": "2015-09-17T15:00:17Z"}, "committer": {"name": "critiqjo", "email": "john.ch.fr@gmail.com", "date": "2015-09-19T15:41:17Z"}, "message": "trpl: Improve clarity in Concurrency", "tree": {"sha": "5aab538a3cc0667663cf6cec8b3ab465b924b604", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5aab538a3cc0667663cf6cec8b3ab465b924b604"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0f214e25780702a6273af8735c0de5c48cc206d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0f214e25780702a6273af8735c0de5c48cc206d", "html_url": "https://github.com/rust-lang/rust/commit/a0f214e25780702a6273af8735c0de5c48cc206d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0f214e25780702a6273af8735c0de5c48cc206d/comments", "author": {"login": "johncf", "id": 21051830, "node_id": "MDQ6VXNlcjIxMDUxODMw", "avatar_url": "https://avatars.githubusercontent.com/u/21051830?v=4", "gravatar_id": "", "url": "https://api.github.com/users/johncf", "html_url": "https://github.com/johncf", "followers_url": "https://api.github.com/users/johncf/followers", "following_url": "https://api.github.com/users/johncf/following{/other_user}", "gists_url": "https://api.github.com/users/johncf/gists{/gist_id}", "starred_url": "https://api.github.com/users/johncf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/johncf/subscriptions", "organizations_url": "https://api.github.com/users/johncf/orgs", "repos_url": "https://api.github.com/users/johncf/repos", "events_url": "https://api.github.com/users/johncf/events{/privacy}", "received_events_url": "https://api.github.com/users/johncf/received_events", "type": "User", "site_admin": false}, "committer": {"login": "johncf", "id": 21051830, "node_id": "MDQ6VXNlcjIxMDUxODMw", "avatar_url": "https://avatars.githubusercontent.com/u/21051830?v=4", "gravatar_id": "", "url": "https://api.github.com/users/johncf", "html_url": "https://github.com/johncf", "followers_url": "https://api.github.com/users/johncf/followers", "following_url": "https://api.github.com/users/johncf/following{/other_user}", "gists_url": "https://api.github.com/users/johncf/gists{/gist_id}", "starred_url": "https://api.github.com/users/johncf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/johncf/subscriptions", "organizations_url": "https://api.github.com/users/johncf/orgs", "repos_url": "https://api.github.com/users/johncf/repos", "events_url": "https://api.github.com/users/johncf/events{/privacy}", "received_events_url": "https://api.github.com/users/johncf/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89faafcd67a45b66aa4a8b6ae36e97b1cee80200", "url": "https://api.github.com/repos/rust-lang/rust/commits/89faafcd67a45b66aa4a8b6ae36e97b1cee80200", "html_url": "https://github.com/rust-lang/rust/commit/89faafcd67a45b66aa4a8b6ae36e97b1cee80200"}], "stats": {"total": 59, "additions": 28, "deletions": 31}, "files": [{"sha": "7028bade6deae557909b680cdbdf33cc707f4c1e", "filename": "src/doc/trpl/concurrency.md", "status": "modified", "additions": 28, "deletions": 31, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a0f214e25780702a6273af8735c0de5c48cc206d/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/a0f214e25780702a6273af8735c0de5c48cc206d/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconcurrency.md?ref=a0f214e25780702a6273af8735c0de5c48cc206d", "patch": "@@ -26,8 +26,8 @@ to help us make sense of code that can possibly be concurrent.\n ### `Send`\n \n The first trait we're going to talk about is\n-[`Send`](../std/marker/trait.Send.html). When a type `T` implements `Send`, it indicates\n-to the compiler that something of this type is able to have ownership transferred\n+[`Send`](../std/marker/trait.Send.html). When a type `T` implements `Send`, it\n+indicates that something of this type is able to have ownership transferred\n safely between threads.\n \n This is important to enforce certain restrictions. For example, if we have a\n@@ -42,13 +42,19 @@ us enforce that it can't leave the current thread.\n ### `Sync`\n \n The second of these traits is called [`Sync`](../std/marker/trait.Sync.html).\n-When a type `T` implements `Sync`, it indicates to the compiler that something\n+When a type `T` implements `Sync`, it indicates that something\n of this type has no possibility of introducing memory unsafety when used from\n-multiple threads concurrently.\n-\n-For example, sharing immutable data with an atomic reference count is\n-threadsafe. Rust provides a type like this, `Arc<T>`, and it implements `Sync`,\n-so it is safe to share between threads.\n+multiple threads concurrently through shared references. This implies that\n+types which don't have [interior mutability](mutability.html) are inherently\n+`Sync`, which includes simple primitive types (like `u8`) and aggregate types\n+containing them.\n+\n+For sharing references across threads, Rust provides a wrapper type called\n+`Arc<T>`. `Arc<T>` implements `Send` and `Sync` if and only if `T` implements\n+both `Send` and `Sync`. For example, an object of type `Arc<RefCell<U>>` cannot\n+be transferred across threads because\n+[`RefCell`](choosing-your-guarantees.html#refcell%3Ct%3E) does not implement\n+`Sync`, consequently `Arc<RefCell<U>>` would not implement `Send`.\n \n These two traits allow you to use the type system to make strong guarantees\n about the properties of your code under concurrency. Before we demonstrate\n@@ -70,7 +76,7 @@ fn main() {\n }\n ```\n \n-The `thread::spawn()` method accepts a closure, which is executed in a\n+The `thread::spawn()` method accepts a [closure](closures.html), which is executed in a\n new thread. It returns a handle to the thread, that can be used to\n wait for the child thread to finish and extract its result:\n \n@@ -215,29 +221,18 @@ fn main() {\n }\n ```\n \n+Note that the value of `i` is bound (copied) to the closure and not shared\n+among the threads.\n \n-If we'd tried to use `Mutex<T>` without wrapping it in an `Arc<T>` we would have\n-seen another error like:\n-\n-```text\n-error: the trait `core::marker::Send` is not implemented for the type `std::sync::mutex::MutexGuard<'_, collections::vec::Vec<u32>>` [E0277]\n- thread::spawn(move || {\n-                  ^~~~~~~~~~~~~\n-note: `std::sync::mutex::MutexGuard<'_, collections::vec::Vec<u32>>` cannot be sent between threads safely\n- thread::spawn(move || {\n-                  ^~~~~~~~~~~~~\n-```\n-\n-You see, [`Mutex`](../std/sync/struct.Mutex.html) has a\n-[`lock`](../std/sync/struct.Mutex.html#method.lock)\n-method which has this signature:\n+Also note that [`lock`](../std/sync/struct.Mutex.html#method.lock) method of\n+[`Mutex`](../std/sync/struct.Mutex.html) has this signature:\n \n ```ignore\n fn lock(&self) -> LockResult<MutexGuard<T>>\n ```\n \n-and because `Send` is not implemented for `MutexGuard<T>`, we couldn't have\n-transferred the guard across thread boundaries on it's own.\n+and because `Send` is not implemented for `MutexGuard<T>`, the guard cannot\n+cross thread boundaries, ensuring thread-locality of lock acquire and release.\n \n Let's examine the body of the thread more closely:\n \n@@ -317,22 +312,24 @@ use std::sync::mpsc;\n fn main() {\n     let (tx, rx) = mpsc::channel();\n \n-    for _ in 0..10 {\n+    for i in 0..10 {\n         let tx = tx.clone();\n \n         thread::spawn(move || {\n-            let answer = 42;\n+            let answer = i * i;\n \n             tx.send(answer);\n         });\n     }\n \n-   rx.recv().ok().expect(\"Could not receive answer\");\n+    for _ in 0..10 {\n+        println!(\"{}\", rx.recv().unwrap());\n+    }\n }\n ```\n \n-A `u32` is `Send` because we can make a copy. So we create a thread, ask it to calculate\n-the answer, and then it `send()`s us the answer over the channel.\n+Here we create 10 threads, asking each to calculate the square of a number (`i`\n+at the time of `spawn()`), and then `send()` back the answer over the channel.\n \n \n ## Panics"}]}