{"sha": "0bcacb391b28460f5a50fd627f01f670dfcfc7cc", "node_id": "C_kwDOAAsO6NoAKDBiY2FjYjM5MWIyODQ2MGY1YTUwZmQ2MjdmMDFmNjcwZGZjZmM3Y2M", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-21T06:20:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-21T06:20:18Z"}, "message": "Auto merge of #91359 - dtolnay:args, r=Mark-Simulacrum\n\nEmit simpler code from format_args\n\nI made this PR so that `cargo expand` dumps a less overwhelming amount of formatting-related code.\n\n<br>\n\n`println!(\"rust\")` **Before:**\n\n```rust\n{\n    ::std::io::_print(::core::fmt::Arguments::new_v1(&[\"rust\\n\"],\n                                                     &match () {\n                                                          _args => [],\n                                                      }));\n};\n```\n\n**After:**\n\n```rust\n{ ::std::io::_print(::core::fmt::Arguments::new_v1(&[\"rust\\n\"], &[])); };\n```\n\n`println!(\"{}\", x)` **Before:**\n\n```rust\n{\n    ::std::io::_print(::core::fmt::Arguments::new_v1(\n        &[\"\", \"\\n\"],\n        &match (&x,) {\n            _args => [::core::fmt::ArgumentV1::new(\n                _args.0,\n                ::core::fmt::Display::fmt,\n            )],\n        },\n    ));\n};\n```\n\n**After:**\n\n```rust\n{\n    ::std::io::_print(::core::fmt::Arguments::new_v1(\n        &[\"\", \"\\n\"],\n        &[::core::fmt::ArgumentV1::new(&x, ::core::fmt::Display::fmt)],\n    ));\n};\n```", "tree": {"sha": "efe7eacd74114713b277589bdda6716bd4e59e25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efe7eacd74114713b277589bdda6716bd4e59e25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bcacb391b28460f5a50fd627f01f670dfcfc7cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bcacb391b28460f5a50fd627f01f670dfcfc7cc", "html_url": "https://github.com/rust-lang/rust/commit/0bcacb391b28460f5a50fd627f01f670dfcfc7cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "html_url": "https://github.com/rust-lang/rust/commit/523be2e05da322daaecf1ecc8f2c0d625f5f46e3"}, {"sha": "7ee21e3de115e086061e5fdc5729c4e41969def9", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ee21e3de115e086061e5fdc5729c4e41969def9", "html_url": "https://github.com/rust-lang/rust/commit/7ee21e3de115e086061e5fdc5729c4e41969def9"}], "stats": {"total": 214, "additions": 123, "deletions": 91}, "files": [{"sha": "438168f4fcc5cd9504f5b497419b9d452ec821ac", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=0bcacb391b28460f5a50fd627f01f670dfcfc7cc", "patch": "@@ -39,6 +39,7 @@ use rustc_span::{Span, DUMMY_SP};\n use std::cmp::Ordering;\n use std::convert::TryFrom;\n use std::fmt;\n+use std::mem;\n \n #[cfg(test)]\n mod tests;\n@@ -1276,6 +1277,19 @@ impl Expr {\n             ExprKind::Err => ExprPrecedence::Err,\n         }\n     }\n+\n+    pub fn take(&mut self) -> Self {\n+        mem::replace(\n+            self,\n+            Expr {\n+                id: DUMMY_NODE_ID,\n+                kind: ExprKind::Err,\n+                span: DUMMY_SP,\n+                attrs: ThinVec::new(),\n+                tokens: None,\n+            },\n+        )\n+    }\n }\n \n /// Limit types of a range (inclusive or exclusive)"}, {"sha": "d1393528d1ce8ae94f64db383957351becffdbcc", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 75, "deletions": 59, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=0bcacb391b28460f5a50fd627f01f670dfcfc7cc", "patch": "@@ -11,6 +11,7 @@ use rustc_expand::base::{self, *};\n use rustc_parse_format as parse;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{MultiSpan, Span};\n+use smallvec::SmallVec;\n \n use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n@@ -744,78 +745,95 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// Actually builds the expression which the format_args! block will be\n     /// expanded to.\n     fn into_expr(self) -> P<ast::Expr> {\n-        let mut args = Vec::with_capacity(\n+        let mut original_args = self.args;\n+        let mut fmt_args = Vec::with_capacity(\n             self.arg_unique_types.iter().map(|v| v.len()).sum::<usize>() + self.count_args.len(),\n         );\n-        let mut heads = Vec::with_capacity(self.args.len());\n \n         // First, build up the static array which will become our precompiled\n         // format \"string\"\n         let pieces = self.ecx.expr_vec_slice(self.fmtsp, self.str_pieces);\n \n-        // Before consuming the expressions, we have to remember spans for\n-        // count arguments as they are now generated separate from other\n-        // arguments, hence have no access to the `P<ast::Expr>`'s.\n-        let spans_pos: Vec<_> = self.args.iter().map(|e| e.span).collect();\n-\n-        // Right now there is a bug such that for the expression:\n-        //      foo(bar(&1))\n-        // the lifetime of `1` doesn't outlast the call to `bar`, so it's not\n-        // valid for the call to `foo`. To work around this all arguments to the\n-        // format! string are shoved into locals. Furthermore, we shove the address\n-        // of each variable because we don't want to move out of the arguments\n-        // passed to this function.\n-        for (i, e) in self.args.into_iter().enumerate() {\n-            for arg_ty in self.arg_unique_types[i].iter() {\n-                args.push(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty, i));\n-            }\n-            // use the arg span for `&arg` so that borrowck errors\n-            // point to the specific expression passed to the macro\n-            // (the span is otherwise unavailable in MIR)\n-            heads.push(self.ecx.expr_addr_of(e.span.with_ctxt(self.macsp.ctxt()), e));\n-        }\n-        for index in self.count_args {\n-            let span = spans_pos[index];\n-            args.push(Context::format_arg(self.ecx, self.macsp, span, &Count, index));\n+        // We need to construct a &[ArgumentV1] to pass into the fmt::Arguments\n+        // constructor. In general the expressions in this slice might be\n+        // permuted from their order in original_args (such as in the case of\n+        // \"{1} {0}\"), or may have multiple entries referring to the same\n+        // element of original_args (\"{0} {0}\").\n+        //\n+        // The following vector has one item per element of our output slice,\n+        // identifying the index of which element of original_args it's passing,\n+        // and that argument's type.\n+        let mut fmt_arg_index_and_ty = SmallVec::<[(usize, &ArgumentType); 8]>::new();\n+        for (i, unique_types) in self.arg_unique_types.iter().enumerate() {\n+            fmt_arg_index_and_ty.extend(unique_types.iter().map(|ty| (i, ty)));\n         }\n+        fmt_arg_index_and_ty.extend(self.count_args.iter().map(|&i| (i, &Count)));\n \n-        let args_array = self.ecx.expr_vec(self.macsp, args);\n-\n-        // Constructs an AST equivalent to:\n-        //\n-        //      match (&arg0, &arg1) {\n-        //          (tmp0, tmp1) => args_array\n-        //      }\n+        // Figure out whether there are permuted or repeated elements. If not,\n+        // we can generate simpler code.\n         //\n-        // It was:\n+        // The sequence has no indices out of order or repeated if: for every\n+        // adjacent pair of elements, the first one's index is less than the\n+        // second one's index.\n+        let nicely_ordered =\n+            fmt_arg_index_and_ty.array_windows().all(|[(i, _i_ty), (j, _j_ty)]| i < j);\n+\n+        // We want to emit:\n         //\n-        //      let tmp0 = &arg0;\n-        //      let tmp1 = &arg1;\n-        //      args_array\n+        //     [ArgumentV1::new(&$arg0, \u2026), ArgumentV1::new(&$arg1, \u2026), \u2026]\n         //\n-        // Because of #11585 the new temporary lifetime rule, the enclosing\n-        // statements for these temporaries become the let's themselves.\n-        // If one or more of them are RefCell's, RefCell borrow() will also\n-        // end there; they don't last long enough for args_array to use them.\n-        // The match expression solves the scope problem.\n+        // However, it's only legal to do so if $arg0, $arg1, \u2026 were written in\n+        // exactly that order by the programmer. When arguments are permuted, we\n+        // want them evaluated in the order written by the programmer, not in\n+        // the order provided to fmt::Arguments. When arguments are repeated, we\n+        // want the expression evaluated only once.\n         //\n-        // Note, it may also very well be transformed to:\n+        // Thus in the not nicely ordered case we emit the following instead:\n         //\n-        //      match arg0 {\n-        //          ref tmp0 => {\n-        //              match arg1 => {\n-        //                  ref tmp1 => args_array } } }\n+        //     match (&$arg0, &$arg1, \u2026) {\n+        //         _args => [ArgumentV1::new(_args.$i, \u2026), ArgumentV1::new(_args.$j, \u2026), \u2026]\n+        //     }\n         //\n-        // But the nested match expression is proved to perform not as well\n-        // as series of let's; the first approach does.\n-        let args_match = {\n-            let pat = self.ecx.pat_ident(self.macsp, Ident::new(sym::_args, self.macsp));\n-            let arm = self.ecx.arm(self.macsp, pat, args_array);\n-            let head = self.ecx.expr(self.macsp, ast::ExprKind::Tup(heads));\n-            self.ecx.expr_match(self.macsp, head, vec![arm])\n-        };\n+        // for the sequence of indices $i, $j, \u2026 governed by fmt_arg_index_and_ty.\n+        for (arg_index, arg_ty) in fmt_arg_index_and_ty {\n+            let e = &mut original_args[arg_index];\n+            let span = e.span;\n+            let arg = if nicely_ordered {\n+                let expansion_span = e.span.with_ctxt(self.macsp.ctxt());\n+                // The indices are strictly ordered so e has not been taken yet.\n+                self.ecx.expr_addr_of(expansion_span, P(e.take()))\n+            } else {\n+                let def_site = self.ecx.with_def_site_ctxt(span);\n+                let args_tuple = self.ecx.expr_ident(def_site, Ident::new(sym::_args, def_site));\n+                let member = Ident::new(sym::integer(arg_index), def_site);\n+                self.ecx.expr(def_site, ast::ExprKind::Field(args_tuple, member))\n+            };\n+            fmt_args.push(Context::format_arg(self.ecx, self.macsp, span, arg_ty, arg));\n+        }\n \n-        let args_slice = self.ecx.expr_addr_of(self.macsp, args_match);\n+        let args_array = self.ecx.expr_vec(self.macsp, fmt_args);\n+        let args_slice = self.ecx.expr_addr_of(\n+            self.macsp,\n+            if nicely_ordered {\n+                args_array\n+            } else {\n+                // In the !nicely_ordered case, none of the exprs were moved\n+                // away in the previous loop.\n+                //\n+                // This uses the arg span for `&arg` so that borrowck errors\n+                // point to the specific expression passed to the macro (the\n+                // span is otherwise unavailable in the MIR used by borrowck).\n+                let heads = original_args\n+                    .into_iter()\n+                    .map(|e| self.ecx.expr_addr_of(e.span.with_ctxt(self.macsp.ctxt()), e))\n+                    .collect();\n+\n+                let pat = self.ecx.pat_ident(self.macsp, Ident::new(sym::_args, self.macsp));\n+                let arm = self.ecx.arm(self.macsp, pat, args_array);\n+                let head = self.ecx.expr(self.macsp, ast::ExprKind::Tup(heads));\n+                self.ecx.expr_match(self.macsp, head, vec![arm])\n+            },\n+        );\n \n         // Now create the fmt::Arguments struct with all our locals we created.\n         let (fn_name, fn_args) = if self.all_pieces_simple {\n@@ -848,11 +866,9 @@ impl<'a, 'b> Context<'a, 'b> {\n         macsp: Span,\n         mut sp: Span,\n         ty: &ArgumentType,\n-        arg_index: usize,\n+        arg: P<ast::Expr>,\n     ) -> P<ast::Expr> {\n         sp = ecx.with_def_site_ctxt(sp);\n-        let arg = ecx.expr_ident(sp, Ident::new(sym::_args, sp));\n-        let arg = ecx.expr(sp, ast::ExprKind::Field(arg, Ident::new(sym::integer(arg_index), sp)));\n         let trait_ = match *ty {\n             Placeholder(trait_) if trait_ == \"<invalid>\" => return DummyResult::raw_expr(sp, true),\n             Placeholder(trait_) => trait_,"}, {"sha": "6c16c285492410906a97c4f26d7fffceb9fca3bc", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=0bcacb391b28460f5a50fd627f01f670dfcfc7cc", "patch": "@@ -2,10 +2,12 @@\n //! injecting code into the crate before it is lowered to HIR.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(array_windows)]\n #![feature(box_patterns)]\n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n+#![feature(is_sorted)]\n #![feature(nll)]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_quote)]"}, {"sha": "3af37955f238079de77ae656b08b2694d33ba5ba", "filename": "src/test/pretty/dollar-crate.pp", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/src%2Ftest%2Fpretty%2Fdollar-crate.pp", "raw_url": "https://github.com/rust-lang/rust/raw/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/src%2Ftest%2Fpretty%2Fdollar-crate.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdollar-crate.pp?ref=0bcacb391b28460f5a50fd627f01f670dfcfc7cc", "patch": "@@ -9,10 +9,5 @@\n // pp-exact:dollar-crate.pp\n \n fn main() {\n-    {\n-        ::std::io::_print(::core::fmt::Arguments::new_v1(&[\"rust\\n\"],\n-                                                         &match () {\n-                                                              _args => [],\n-                                                          }));\n-    };\n+    { ::std::io::_print(::core::fmt::Arguments::new_v1(&[\"rust\\n\"], &[])); };\n }"}, {"sha": "93967e720c1b0b5de1c582c06eabd013313bdc75", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=0bcacb391b28460f5a50fd627f01f670dfcfc7cc", "patch": "@@ -41,16 +41,7 @@\n                                                                                                                                                               [&str; 1])\n                                                                                                                                                             as\n                                                                                                                                                             &[&str; 1]),\n-                                                                                                                                                        (&(match (()\n-                                                                                                                                                                     as\n-                                                                                                                                                                     ())\n-                                                                                                                                                               {\n-                                                                                                                                                               _args\n-                                                                                                                                                               =>\n-                                                                                                                                                               ([]\n-                                                                                                                                                                   as\n-                                                                                                                                                                   [ArgumentV1; 0]),\n-                                                                                                                                                           }\n+                                                                                                                                                        (&([]\n                                                                                                                                                               as\n                                                                                                                                                               [ArgumentV1; 0])\n                                                                                                                                                             as"}, {"sha": "7eb393bb4481f0d6aae1e37a3ab7eee30dba2556", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.closure.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure.txt", "raw_url": "https://github.com/rust-lang/rust/raw/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure.txt?ref=0bcacb391b28460f5a50fd627f01f670dfcfc7cc", "patch": "@@ -29,8 +29,8 @@\n    29|      1|    some_string = Some(String::from(\"the string content\"));\n    30|      1|    let\n    31|      1|        a\n-   32|      1|    =\n-   33|      1|        ||\n+   32|       |    =\n+   33|       |        ||\n    34|      0|    {\n    35|      0|        let mut countdown = 0;\n    36|      0|        if is_false {\n@@ -173,7 +173,7 @@\n   169|       |    ;\n   170|       |\n   171|      1|    let short_used_not_covered_closure_line_break_no_block_embedded_branch =\n-  172|      1|        | _unused_arg: u8 |\n+  172|       |        | _unused_arg: u8 |\n   173|      0|            println!(\n   174|      0|                \"not called: {}\",\n   175|      0|                if is_true { \"check\" } else { \"me\" }"}, {"sha": "268e382327e1dd703cf40dee277f6d9c2d8d4f2b", "filename": "src/test/ui/attributes/key-value-expansion.stderr", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/src%2Ftest%2Fui%2Fattributes%2Fkey-value-expansion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/src%2Ftest%2Fui%2Fattributes%2Fkey-value-expansion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fkey-value-expansion.stderr?ref=0bcacb391b28460f5a50fd627f01f670dfcfc7cc", "patch": "@@ -18,11 +18,8 @@ LL | bug!();\n error: unexpected token: `{\n            let res =\n                ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&[\"\"],\n-                                                                   &match (&\"u8\",) {\n-                                                                        _args =>\n-                                                                        [::core::fmt::ArgumentV1::new(_args.0,\n-                                                                                                      ::core::fmt::Display::fmt)],\n-                                                                    }));\n+                                                                   &[::core::fmt::ArgumentV1::new(&\"u8\",\n+                                                                                                  ::core::fmt::Display::fmt)]));\n            res\n        }.as_str()`\n   --> $DIR/key-value-expansion.rs:48:23"}, {"sha": "bdc71b8dcaa20c0983464dce669cab7cda0f299a", "filename": "src/test/ui/closures/print/closure-print-generic-trim-off-verbose-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/src%2Ftest%2Fui%2Fclosures%2Fprint%2Fclosure-print-generic-trim-off-verbose-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/src%2Ftest%2Fui%2Fclosures%2Fprint%2Fclosure-print-generic-trim-off-verbose-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fprint%2Fclosure-print-generic-trim-off-verbose-2.stderr?ref=0bcacb391b28460f5a50fd627f01f670dfcfc7cc", "patch": "@@ -9,7 +9,7 @@ LL |         let c1 : () = c;\n    |                  expected due to this\n    |\n    = note: expected unit type `()`\n-                found closure `[mod1::f<T>::{closure#0} closure_substs=(unavailable) substs=[T, _#22t, extern \"rust-call\" fn(()), _#23t]]`\n+                found closure `[mod1::f<T>::{closure#0} closure_substs=(unavailable) substs=[T, _#19t, extern \"rust-call\" fn(()), _#20t]]`\n help: use parentheses to call this closure\n    |\n LL |         let c1 : () = c();"}, {"sha": "453f18891d319ae18a9c6f854344664c0826e314", "filename": "src/test/ui/closures/print/closure-print-generic-verbose-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/src%2Ftest%2Fui%2Fclosures%2Fprint%2Fclosure-print-generic-verbose-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/src%2Ftest%2Fui%2Fclosures%2Fprint%2Fclosure-print-generic-verbose-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fprint%2Fclosure-print-generic-verbose-2.stderr?ref=0bcacb391b28460f5a50fd627f01f670dfcfc7cc", "patch": "@@ -9,7 +9,7 @@ LL |         let c1 : () = c;\n    |                  expected due to this\n    |\n    = note: expected unit type `()`\n-                found closure `[f<T>::{closure#0} closure_substs=(unavailable) substs=[T, _#22t, extern \"rust-call\" fn(()), _#23t]]`\n+                found closure `[f<T>::{closure#0} closure_substs=(unavailable) substs=[T, _#19t, extern \"rust-call\" fn(()), _#20t]]`\n help: use parentheses to call this closure\n    |\n LL |         let c1 : () = c();"}, {"sha": "95617e4ecc8b82473b1ad844f346eb4c951b8dba", "filename": "src/test/ui/issues/issue-69455.stderr", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/src%2Ftest%2Fui%2Fissues%2Fissue-69455.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/src%2Ftest%2Fui%2Fissues%2Fissue-69455.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69455.stderr?ref=0bcacb391b28460f5a50fd627f01f670dfcfc7cc", "patch": "@@ -1,8 +1,16 @@\n-error[E0284]: type annotations needed: cannot satisfy `<u64 as Test<_>>::Output == _`\n-  --> $DIR/issue-69455.rs:29:26\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-69455.rs:29:5\n    |\n+LL |     type Output;\n+   |     ------------ `<Self as Test<Rhs>>::Output` defined here\n+...\n LL |     println!(\"{}\", 23u64.test(xs.iter().sum()));\n-   |                          ^^^^ cannot satisfy `<u64 as Test<_>>::Output == _`\n+   |     ^^^^^^^^^^^^^^^---------------------------^\n+   |     |              |\n+   |     |              this method call resolves to `<Self as Test<Rhs>>::Output`\n+   |     cannot infer type for type parameter `T` declared on the associated function `new`\n+   |\n+   = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0283]: type annotations needed\n   --> $DIR/issue-69455.rs:29:26\n@@ -25,5 +33,5 @@ LL |     println!(\"{}\", 23u64.test(xs.iter().sum::<S>()));\n \n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0283, E0284.\n-For more information about an error, try `rustc --explain E0283`.\n+Some errors have detailed explanations: E0282, E0283.\n+For more information about an error, try `rustc --explain E0282`."}, {"sha": "80189ca1f0aeeedc70fb70c0ffe4b75d509f12c3", "filename": "src/tools/clippy/tests/ui/to_string_in_display.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fto_string_in_display.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bcacb391b28460f5a50fd627f01f670dfcfc7cc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fto_string_in_display.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fto_string_in_display.stderr?ref=0bcacb391b28460f5a50fd627f01f670dfcfc7cc", "patch": "@@ -6,5 +6,14 @@ LL |         write!(f, \"{}\", self.to_string())\n    |\n    = note: `-D clippy::to-string-in-display` implied by `-D warnings`\n \n-error: aborting due to previous error\n+error: unnecessary use of `to_string`\n+  --> $DIR/to_string_in_display.rs:55:50\n+   |\n+LL |             Self::E(string) => write!(f, \"E {}\", string.to_string()),\n+   |                                                  ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::unnecessary-to-owned` implied by `-D warnings`\n+   = note: this error originates in the macro `$crate::format_args` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 2 previous errors\n "}]}