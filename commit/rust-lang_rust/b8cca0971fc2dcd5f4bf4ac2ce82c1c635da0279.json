{"sha": "b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4Y2NhMDk3MWZjMmRjZDVmNGJmNGFjMmNlODJjMWM2MzVkYTAyNzk=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-10-19T21:54:10Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-10-19T21:54:10Z"}, "message": "Teach trans to allocate, initialize and load from local variables.", "tree": {"sha": "9744ef42235ff93c1534461210c80b0f9ecb35b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9744ef42235ff93c1534461210c80b0f9ecb35b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279", "html_url": "https://github.com/rust-lang/rust/commit/b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10d628dbd06ec71956c7849c24822dde8710c2bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/10d628dbd06ec71956c7849c24822dde8710c2bd", "html_url": "https://github.com/rust-lang/rust/commit/10d628dbd06ec71956c7849c24822dde8710c2bd"}], "stats": {"total": 192, "additions": 174, "deletions": 18}, "files": [{"sha": "2135a97dac9983c228bb3a4cc3de01a8b872dc84", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279", "patch": "@@ -78,7 +78,7 @@ type local = rec(option[@ty] ty,\n \n type decl = spanned[decl_];\n tag decl_ {\n-    decl_local(local);\n+    decl_local(@local);\n     decl_item(@item);\n }\n "}, {"sha": "68603e4a04e0b065e9365ea90999b6f1c84ea85a", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279", "patch": "@@ -629,7 +629,7 @@ io fn parse_let(parser p) -> @ast.decl {\n                               init = init,\n                               id = p.next_def_id());\n \n-    ret @spanned(lo, hi, ast.decl_local(local));\n+    ret @spanned(lo, hi, ast.decl_local(@local));\n }\n \n io fn parse_auto(parser p) -> @ast.decl {\n@@ -648,7 +648,7 @@ io fn parse_auto(parser p) -> @ast.decl {\n                               init = init,\n                               id = p.next_def_id());\n \n-    ret @spanned(lo, hi, ast.decl_local(local));\n+    ret @spanned(lo, hi, ast.decl_local(@local));\n }\n \n io fn parse_stmt(parser p) -> @ast.stmt {"}, {"sha": "4dd10871a8c2cfca8723eb8d5ce701cb8e62840c", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279", "patch": "@@ -103,7 +103,7 @@ type ast_fold[ENV] =\n \n      // Decl folds.\n      (fn(&ENV e, &span sp,\n-         &ast.local local) -> @decl)              fold_decl_local,\n+         @ast.local local) -> @decl)              fold_decl_local,\n \n      (fn(&ENV e, &span sp,\n          @item item) -> @decl)                    fold_decl_item,\n@@ -238,7 +238,7 @@ fn fold_decl[ENV](&ENV env, ast_fold[ENV] fld, @decl d) -> @decl {\n                     init_ = some[@ast.expr](fold_expr(env, fld, e));\n                 }\n             }\n-            let ast.local local_ = rec(ty=ty_, init=init_ with local);\n+            let @ast.local local_ = @rec(ty=ty_, init=init_ with *local);\n             ret fld.fold_decl_local(env_, d.span, local_);\n         }\n \n@@ -356,7 +356,7 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n \n         case (ast.expr_name(?n, ?r, ?t)) {\n             auto n_ = fold_name(env_, fld, n);\n-            ret fld.fold_expr_name(env_, e.span, n, r, t);\n+            ret fld.fold_expr_name(env_, e.span, n_, r, t);\n         }\n     }\n \n@@ -375,7 +375,7 @@ fn fold_stmt[ENV](&ENV env, ast_fold[ENV] fld, &@stmt s) -> @stmt {\n     alt (s.node) {\n         case (ast.stmt_decl(?d)) {\n             auto dd = fold_decl(env_, fld, d);\n-            ret fld.fold_stmt_decl(env_, s.span, d);\n+            ret fld.fold_stmt_decl(env_, s.span, dd);\n         }\n \n         case (ast.stmt_ret(?oe)) {\n@@ -390,12 +390,12 @@ fn fold_stmt[ENV](&ENV env, ast_fold[ENV] fld, &@stmt s) -> @stmt {\n \n         case (ast.stmt_log(?e)) {\n             auto ee = fold_expr(env_, fld, e);\n-            ret fld.fold_stmt_log(env_, s.span, e);\n+            ret fld.fold_stmt_log(env_, s.span, ee);\n         }\n \n         case (ast.stmt_expr(?e)) {\n             auto ee = fold_expr(env_, fld, e);\n-            ret fld.fold_stmt_expr(env_, s.span, e);\n+            ret fld.fold_stmt_expr(env_, s.span, ee);\n         }\n     }\n     ret s;\n@@ -621,7 +621,7 @@ fn identity_fold_expr_name[ENV](&ENV env, &span sp,\n // Decl identities.\n \n fn identity_fold_decl_local[ENV](&ENV e, &span sp,\n-                                 &ast.local local) -> @decl {\n+                                 @ast.local local) -> @decl {\n     ret @respan(sp, ast.decl_local(local));\n }\n "}, {"sha": "7951ec85a03b130425b4be3c1d4d68478a9531fa", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279", "patch": "@@ -18,7 +18,8 @@ tag scope {\n     scope_block(ast.block);\n }\n \n-type env = list[scope];\n+type env = rec(list[scope] scopes,\n+               session.session sess);\n \n fn lookup_name(&env e, ast.ident i) -> option[def] {\n \n@@ -97,7 +98,7 @@ fn lookup_name(&env e, ast.ident i) -> option[def] {\n         ret none[def];\n     }\n \n-    ret std.list.find[scope,def](e, bind in_scope(i, _));\n+    ret std.list.find[scope,def](e.scopes, bind in_scope(i, _));\n }\n \n fn fold_expr_name(&env e, &span sp, &ast.name n,\n@@ -110,33 +111,39 @@ fn fold_expr_name(&env e, &span sp, &ast.name n,\n             log \"resolved name \" + n.node.ident;\n         }\n         case (none[def]) {\n-            log \"unresolved name \" + n.node.ident;\n+            e.sess.err(\"unresolved name: \" + n.node.ident);\n         }\n     }\n \n     ret @fold.respan[ast.expr_](sp, ast.expr_name(n, d_, t));\n }\n \n fn update_env_for_crate(&env e, @ast.crate c) -> env {\n-    ret cons[scope](scope_crate(c), @e);\n+    ret rec(scopes = cons[scope](scope_crate(c), @e.scopes) with e);\n }\n \n fn update_env_for_item(&env e, @ast.item i) -> env {\n-    ret cons[scope](scope_item(i), @e);\n+    ret rec(scopes = cons[scope](scope_item(i), @e.scopes) with e);\n }\n \n fn update_env_for_block(&env e, &ast.block b) -> env {\n-    ret cons[scope](scope_block(b), @e);\n+    ret rec(scopes = cons[scope](scope_block(b), @e.scopes) with e);\n }\n \n fn resolve_crate(session.session sess, @ast.crate crate) -> @ast.crate {\n+\n     let fold.ast_fold[env] fld = fold.new_identity_fold[env]();\n+\n     fld = @rec( fold_expr_name = bind fold_expr_name(_,_,_,_,_),\n                 update_env_for_crate = bind update_env_for_crate(_,_),\n                 update_env_for_item = bind update_env_for_item(_,_),\n                 update_env_for_block = bind update_env_for_block(_,_)\n                 with *fld );\n-    ret fold.fold_crate[env](nil[scope], fld, crate);\n+\n+    auto e = rec(scopes = nil[scope],\n+                 sess = sess);\n+\n+    ret fold.fold_crate[env](e, fld, crate);\n }\n \n // Local Variables:"}, {"sha": "c0f718fbecba03f1be2e6a15afe8ce127868f3fe", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 131, "deletions": 1, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279", "patch": "@@ -12,7 +12,9 @@ import driver.session;\n import back.x86;\n import back.abi;\n \n+import util.common;\n import util.common.istr;\n+import util.common.new_def_hash;\n import util.common.new_str_hash;\n \n import lib.llvm.llvm;\n@@ -49,6 +51,7 @@ state type trans_ctxt = rec(session.session sess,\n state type fn_ctxt = rec(ValueRef llfn,\n                          ValueRef lloutptr,\n                          ValueRef lltaskptr,\n+                         hashmap[ast.def_id, ValueRef] lllocals,\n                          @trans_ctxt tcx);\n \n type terminator = fn(@fn_ctxt cx, builder build);\n@@ -126,11 +129,23 @@ fn T_i64() -> TypeRef {\n     ret llvm.LLVMInt64Type();\n }\n \n+fn T_f32() -> TypeRef {\n+    ret llvm.LLVMFloatType();\n+}\n+\n+fn T_f64() -> TypeRef {\n+    ret llvm.LLVMDoubleType();\n+}\n+\n fn T_int() -> TypeRef {\n     // FIXME: switch on target type.\n     ret T_i32();\n }\n \n+fn T_char() -> TypeRef {\n+    ret T_i32();\n+}\n+\n fn T_fn(vec[TypeRef] inputs, TypeRef output) -> TypeRef {\n     ret llvm.LLVMFunctionType(output,\n                               _vec.buf[TypeRef](inputs),\n@@ -180,6 +195,10 @@ fn T_str(uint n) -> TypeRef {\n     ret T_vec(T_i8(), n);\n }\n \n+fn T_box(TypeRef t) -> TypeRef {\n+    ret T_struct(vec(T_int(), t));\n+}\n+\n fn T_crate() -> TypeRef {\n     ret T_struct(vec(T_int(),      // ptrdiff_t image_base_off\n                      T_int(),      // uintptr_t self_addr\n@@ -206,6 +225,49 @@ fn T_taskptr() -> TypeRef {\n     ret T_ptr(T_task());\n }\n \n+fn type_of(@trans_ctxt cx, @ast.ty t) -> TypeRef {\n+    alt (t.node) {\n+        case (ast.ty_nil) { ret T_nil(); }\n+        case (ast.ty_bool) { ret T_i1(); }\n+        case (ast.ty_int) { ret T_int(); }\n+        case (ast.ty_uint) { ret T_int(); }\n+        case (ast.ty_machine(?tm)) {\n+            alt (tm) {\n+                case (common.ty_i8) { ret T_i8(); }\n+                case (common.ty_u8) { ret T_i8(); }\n+                case (common.ty_i16) { ret T_i16(); }\n+                case (common.ty_u16) { ret T_i16(); }\n+                case (common.ty_i32) { ret T_i32(); }\n+                case (common.ty_u32) { ret T_i32(); }\n+                case (common.ty_i64) { ret T_i64(); }\n+                case (common.ty_u64) { ret T_i64(); }\n+                case (common.ty_f32) { ret T_f32(); }\n+                case (common.ty_f64) { ret T_f64(); }\n+            }\n+        }\n+        case (ast.ty_char) { ret T_char(); }\n+        case (ast.ty_str) { ret T_str(0u); }\n+        case (ast.ty_box(?t)) {\n+            ret T_ptr(T_box(type_of(cx, t)));\n+        }\n+        case (ast.ty_vec(?t)) {\n+            ret T_ptr(T_vec(type_of(cx, t), 0u));\n+        }\n+        case (ast.ty_tup(?elts)) {\n+            let vec[TypeRef] tys = vec();\n+            for (tup(bool, @ast.ty) elt in elts) {\n+                tys += type_of(cx, elt._1);\n+            }\n+            ret T_struct(tys);\n+        }\n+        case (ast.ty_path(?pth,  ?def)) {\n+            // FIXME: implement.\n+            cx.sess.unimpl(\"ty_path in trans.type_of\");\n+        }\n+    }\n+    fail;\n+}\n+\n // LLVM constant constructors.\n \n fn C_null(TypeRef t) -> ValueRef {\n@@ -356,7 +418,7 @@ fn trans_lit(@block_ctxt cx, &ast.lit lit) -> result {\n             ret res(cx, C_int(u as int));\n         }\n         case (ast.lit_char(?c)) {\n-            ret res(cx, C_integral(c as int, T_i32()));\n+            ret res(cx, C_integral(c as int, T_char()));\n         }\n         case (ast.lit_bool(?b)) {\n             ret res(cx, C_bool(b));\n@@ -572,6 +634,25 @@ fn trans_expr(@block_ctxt cx, &ast.expr e) -> result {\n \n             ret res(next_cx, sub.val);\n         }\n+\n+        case (ast.expr_name(?n, ?dopt, _)) {\n+            alt (dopt) {\n+                case (some[ast.def](?def)) {\n+                    alt (def) {\n+                        case (ast.def_local(?did)) {\n+                            auto llptr = cx.fcx.lllocals.get(did);\n+                            ret res(cx, cx.build.Load(llptr));\n+                        }\n+                        case (_) {\n+                            cx.fcx.tcx.sess.unimpl(\"def variant in trans\");\n+                        }\n+                    }\n+                }\n+                case (none[ast.def]) {\n+                    cx.fcx.tcx.sess.err(\"unresolved expr_name in trans\");\n+                }\n+            }\n+        }\n     }\n     cx.fcx.tcx.sess.unimpl(\"expr variant in trans_expr\");\n     fail;\n@@ -616,6 +697,20 @@ fn trans_stmt(@block_ctxt cx, &ast.stmt s) -> result {\n             sub.bcx = trans_expr(cx, *e).bcx;\n         }\n \n+        case (ast.stmt_decl(?d)) {\n+            alt (d.node) {\n+                case (ast.decl_local(?local)) {\n+                    alt (local.init) {\n+                        case (some[@ast.expr](?e)) {\n+                            log \"storing init of local \" + local.ident;\n+                            auto llptr = cx.fcx.lllocals.get(local.id);\n+                            sub = trans_expr(cx, *e);\n+                            sub.val = sub.bcx.build.Store(sub.val, llptr);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n         case (_) {\n             cx.fcx.tcx.sess.unimpl(\"stmt variant\");\n         }\n@@ -685,9 +780,41 @@ fn trans_block_cleanups(@block_ctxt cx) -> @block_ctxt {\n     ret bcx;\n }\n \n+iter block_locals(&ast.block b) -> @ast.local {\n+    // FIXME: putting from inside an iter block doesn't work, so we can't\n+    // use the index here.\n+    for (@ast.stmt s in b.node.stmts) {\n+        alt (s.node) {\n+            case (ast.stmt_decl(?d)) {\n+                alt (d.node) {\n+                    case (ast.decl_local(?local)) {\n+                        put local;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n     auto bcx = cx;\n \n+    for each (@ast.local local in block_locals(b)) {\n+        log \"declaring local \" + local.ident;\n+        auto ty = T_nil();\n+        alt (local.ty) {\n+            case (some[@ast.ty](?t)) {\n+                ty = type_of(cx.fcx.tcx, t);\n+            }\n+            case (none[@ast.ty]) {\n+                cx.fcx.tcx.sess.err(\"missing type for local \" + local.ident);\n+            }\n+        }\n+        auto val = bcx.build.Alloca(ty);\n+        log \"built alloca: \" + val_str(val);\n+        cx.fcx.lllocals.insert(local.id, val);\n+    }\n+\n     for (@ast.stmt s in b.node.stmts) {\n         bcx = trans_stmt(bcx, *s).bcx;\n     }\n@@ -709,9 +836,11 @@ fn new_fn_ctxt(@trans_ctxt cx,\n     cx.fns.insert(cx.path, llfn);\n     let ValueRef lloutptr = llvm.LLVMGetParam(llfn, 0u);\n     let ValueRef lltaskptr = llvm.LLVMGetParam(llfn, 1u);\n+    let hashmap[ast.def_id, ValueRef] lllocals = new_def_hash[ValueRef]();\n     ret @rec(llfn=llfn,\n              lloutptr=lloutptr,\n              lltaskptr=lltaskptr,\n+             lllocals=lllocals,\n              tcx=cx);\n }\n \n@@ -758,6 +887,7 @@ fn trans_exit_task_glue(@trans_ctxt cx) {\n     auto fcx = @rec(llfn=llfn,\n                     lloutptr=lloutptr,\n                     lltaskptr=lltaskptr,\n+                    lllocals=new_def_hash[ValueRef](),\n                     tcx=cx);\n \n     auto bcx = new_top_block_ctxt(fcx);"}, {"sha": "20bff22dda5c6cd61e564b9a641240dff1485aef", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=b8cca0971fc2dcd5f4bf4ac2ce82c1c635da0279", "patch": "@@ -1,5 +1,6 @@\n import std._uint;\n import std._int;\n+import front.ast;\n \n type pos = rec(uint line, uint col);\n type span = rec(str filename, pos lo, pos hi);\n@@ -43,6 +44,24 @@ fn new_str_hash[V]() -> std.map.hashmap[str,V] {\n     ret std.map.mk_hashmap[str,V](hasher, eqer);\n }\n \n+fn new_def_hash[V]() -> std.map.hashmap[ast.def_id,V] {\n+\n+    fn hash(&ast.def_id d) -> uint {\n+        let uint u = d._0 as uint;\n+        u <<= 16u;\n+        u |= d._1 as uint;\n+        ret u;\n+    }\n+\n+    fn eq(&ast.def_id a, &ast.def_id b) -> bool {\n+        ret a._0 == b._0 && a._1 == b._1;\n+    }\n+\n+    let std.map.hashfn[ast.def_id] hasher = hash;\n+    let std.map.eqfn[ast.def_id] eqer = eq;\n+    ret std.map.mk_hashmap[ast.def_id,V](hasher, eqer);\n+}\n+\n fn istr(int i) -> str {\n     ret _int.to_str(i, 10u);\n }"}]}