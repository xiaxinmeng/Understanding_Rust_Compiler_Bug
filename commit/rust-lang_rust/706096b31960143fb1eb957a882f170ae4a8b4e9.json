{"sha": "706096b31960143fb1eb957a882f170ae4a8b4e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwNjA5NmIzMTk2MDE0M2ZiMWViOTU3YTg4MmYxNzBhZTRhOGI0ZTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-24T01:27:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-24T01:27:48Z"}, "message": "auto merge of #6038 : alexcrichton/rust/more-unsafe, r=pcwalton\n\nBecause unsafe functions are never warned about, then all `unsafe` blocks in unsafe functions should definitely be warned about (no need to be redundant). This fixes this case, adds tests, cleans up remaining cases, and then fixes a few other import warnings being spit out.", "tree": {"sha": "b4e4afd8a3c0c6efa7965cb5dd6d0b8342c16d87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4e4afd8a3c0c6efa7965cb5dd6d0b8342c16d87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/706096b31960143fb1eb957a882f170ae4a8b4e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/706096b31960143fb1eb957a882f170ae4a8b4e9", "html_url": "https://github.com/rust-lang/rust/commit/706096b31960143fb1eb957a882f170ae4a8b4e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/706096b31960143fb1eb957a882f170ae4a8b4e9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8708e0c099400f363a5b95806847bd12d780000a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8708e0c099400f363a5b95806847bd12d780000a", "html_url": "https://github.com/rust-lang/rust/commit/8708e0c099400f363a5b95806847bd12d780000a"}, {"sha": "0c2ab662b71377efd2da7dced4f56e75cb68f540", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c2ab662b71377efd2da7dced4f56e75cb68f540", "html_url": "https://github.com/rust-lang/rust/commit/0c2ab662b71377efd2da7dced4f56e75cb68f540"}], "stats": {"total": 304, "additions": 160, "deletions": 144}, "files": [{"sha": "a6bae3c76631c245e8f9e5184fcbff2153ac8aa3", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 50, "deletions": 52, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=706096b31960143fb1eb957a882f170ae4a8b4e9", "patch": "@@ -231,66 +231,64 @@ unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n     // the stack.\n     let mut reached_sentinel = ptr::is_null(sentinel);\n     for stackwalk::walk_stack |frame| {\n-        unsafe {\n-            let pc = last_ret;\n-            let Segment {segment: next_segment, boundary: boundary} =\n-                find_segment_for_frame(frame.fp, segment);\n-            segment = next_segment;\n-            // Each stack segment is bounded by a morestack frame. The\n-            // morestack frame includes two return addresses, one for\n-            // morestack itself, at the normal offset from the frame\n-            // pointer, and then a second return address for the\n-            // function prologue (which called morestack after\n-            // determining that it had hit the end of the stack).\n-            // Since morestack itself takes two parameters, the offset\n-            // for this second return address is 3 greater than the\n-            // return address for morestack.\n-            let ret_offset = if boundary { 4 } else { 1 };\n-            last_ret = *ptr::offset(frame.fp, ret_offset) as *Word;\n-\n-            if ptr::is_null(pc) {\n-                loop;\n-            }\n+        let pc = last_ret;\n+        let Segment {segment: next_segment, boundary: boundary} =\n+            find_segment_for_frame(frame.fp, segment);\n+        segment = next_segment;\n+        // Each stack segment is bounded by a morestack frame. The\n+        // morestack frame includes two return addresses, one for\n+        // morestack itself, at the normal offset from the frame\n+        // pointer, and then a second return address for the\n+        // function prologue (which called morestack after\n+        // determining that it had hit the end of the stack).\n+        // Since morestack itself takes two parameters, the offset\n+        // for this second return address is 3 greater than the\n+        // return address for morestack.\n+        let ret_offset = if boundary { 4 } else { 1 };\n+        last_ret = *ptr::offset(frame.fp, ret_offset) as *Word;\n+\n+        if ptr::is_null(pc) {\n+            loop;\n+        }\n \n-            let mut delay_reached_sentinel = reached_sentinel;\n-            let sp = is_safe_point(pc);\n-            match sp {\n-              Some(sp_info) => {\n-                for walk_safe_point(frame.fp, sp_info) |root, tydesc| {\n-                    // Skip roots until we see the sentinel.\n-                    if !reached_sentinel {\n-                        if root == sentinel {\n-                            delay_reached_sentinel = true;\n-                        }\n-                        loop;\n+        let mut delay_reached_sentinel = reached_sentinel;\n+        let sp = is_safe_point(pc);\n+        match sp {\n+          Some(sp_info) => {\n+            for walk_safe_point(frame.fp, sp_info) |root, tydesc| {\n+                // Skip roots until we see the sentinel.\n+                if !reached_sentinel {\n+                    if root == sentinel {\n+                        delay_reached_sentinel = true;\n                     }\n+                    loop;\n+                }\n \n-                    // Skip null pointers, which can occur when a\n-                    // unique pointer has already been freed.\n-                    if ptr::is_null(*root) {\n-                        loop;\n-                    }\n+                // Skip null pointers, which can occur when a\n+                // unique pointer has already been freed.\n+                if ptr::is_null(*root) {\n+                    loop;\n+                }\n \n-                    if ptr::is_null(tydesc) {\n-                        // Root is a generic box.\n-                        let refcount = **root;\n-                        if mem | task_local_heap != 0 && refcount != -1 {\n-                            if !visitor(root, tydesc) { return; }\n-                        } else if mem | exchange_heap != 0 && refcount == -1 {\n-                            if !visitor(root, tydesc) { return; }\n-                        }\n-                    } else {\n-                        // Root is a non-immediate.\n-                        if mem | stack != 0 {\n-                            if !visitor(root, tydesc) { return; }\n-                        }\n+                if ptr::is_null(tydesc) {\n+                    // Root is a generic box.\n+                    let refcount = **root;\n+                    if mem | task_local_heap != 0 && refcount != -1 {\n+                        if !visitor(root, tydesc) { return; }\n+                    } else if mem | exchange_heap != 0 && refcount == -1 {\n+                        if !visitor(root, tydesc) { return; }\n+                    }\n+                } else {\n+                    // Root is a non-immediate.\n+                    if mem | stack != 0 {\n+                        if !visitor(root, tydesc) { return; }\n                     }\n                 }\n-              }\n-              None => ()\n             }\n-            reached_sentinel = delay_reached_sentinel;\n+          }\n+          None => ()\n         }\n+        reached_sentinel = delay_reached_sentinel;\n     }\n }\n "}, {"sha": "2ec3afca61269f8efbcf7de9bf323a5ff3611582", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=706096b31960143fb1eb957a882f170ae4a8b4e9", "patch": "@@ -156,9 +156,7 @@ pub impl PacketHeader {\n     unsafe fn unblock(&self) {\n         let old_task = swap_task(&mut self.blocked_task, ptr::null());\n         if !old_task.is_null() {\n-            unsafe {\n-                rustrt::rust_task_deref(old_task)\n-            }\n+            rustrt::rust_task_deref(old_task)\n         }\n         match swap_state_acq(&mut self.state, Empty) {\n           Empty | Blocked => (),"}, {"sha": "2d1e06163beb8b6e0bad785f590dcbf830aa2c59", "filename": "src/libcore/rt/sched/local_sched.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibcore%2Frt%2Fsched%2Flocal_sched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibcore%2Frt%2Fsched%2Flocal_sched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Flocal_sched.rs?ref=706096b31960143fb1eb957a882f170ae4a8b4e9", "patch": "@@ -80,10 +80,8 @@ pub unsafe fn unsafe_borrow() -> &mut Scheduler {\n }\n \n pub unsafe fn unsafe_borrow_io() -> &mut IoFactoryObject {\n-    unsafe {\n-        let sched = unsafe_borrow();\n-        return sched.event_loop.io().unwrap();\n-    }\n+    let sched = unsafe_borrow();\n+    return sched.event_loop.io().unwrap();\n }\n \n fn tls_key() -> tls::Key {"}, {"sha": "abdd8d6619a8a51abbae43c5116739e99ed6e74b", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=706096b31960143fb1eb957a882f170ae4a8b4e9", "patch": "@@ -11,14 +11,15 @@\n use option::*;\n use result::*;\n \n-use super::io::net::ip::{IpAddr, Ipv4}; // n.b. Ipv4 is used only in tests\n+use super::io::net::ip::IpAddr;\n use super::uv::*;\n use super::rtio::*;\n use ops::Drop;\n use cell::{Cell, empty_cell};\n use cast::transmute;\n use super::sched::{Scheduler, local_sched};\n \n+#[cfg(test)] use super::io::net::ip::Ipv4;\n #[cfg(test)] use super::sched::Task;\n #[cfg(test)] use unstable::run_in_bare_thread;\n #[cfg(test)] use uint;"}, {"sha": "b7eff217ff8c6c40bb54b644661d13f720b5cb6b", "filename": "src/libcore/rt/uvll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibcore%2Frt%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibcore%2Frt%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvll.rs?ref=706096b31960143fb1eb957a882f170ae4a8b4e9", "patch": "@@ -98,7 +98,7 @@ pub enum uv_req_type {\n \n pub unsafe fn malloc_handle(handle: uv_handle_type) -> *c_void {\n     assert!(handle != UV_UNKNOWN_HANDLE && handle != UV_HANDLE_TYPE_MAX);\n-    let size = unsafe { rust_uv_handle_size(handle as uint) };\n+    let size = rust_uv_handle_size(handle as uint);\n     let p = malloc(size);\n     assert!(p.is_not_null());\n     return p;\n@@ -110,7 +110,7 @@ pub unsafe fn free_handle(v: *c_void) {\n \n pub unsafe fn malloc_req(req: uv_req_type) -> *c_void {\n     assert!(req != UV_UNKNOWN_REQ && req != UV_REQ_TYPE_MAX);\n-    let size = unsafe { rust_uv_req_size(req as uint) };\n+    let size = rust_uv_req_size(req as uint);\n     let p = malloc(size);\n     assert!(p.is_not_null());\n     return p;"}, {"sha": "f6c0176eafc6366d39616ec8edd0bfa08152f6c0", "filename": "src/libcore/str/ascii.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibcore%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibcore%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fascii.rs?ref=706096b31960143fb1eb957a882f170ae4a8b4e9", "patch": "@@ -196,6 +196,7 @@ impl ToStrConsume for ~[Ascii] {\n     }\n }\n \n+#[cfg(test)]\n mod tests {\n     use super::*;\n "}, {"sha": "4a69de26f6b134a03f30d2d50d95904ddbf2fc7f", "filename": "src/libcore/unstable.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=706096b31960143fb1eb957a882f170ae4a8b4e9", "patch": "@@ -262,18 +262,16 @@ pub impl<T:Owned> Exclusive<T> {\n     // the exclusive. Supporting that is a work in progress.\n     #[inline(always)]\n     unsafe fn with<U>(&self, f: &fn(x: &mut T) -> U) -> U {\n-        unsafe {\n-            let rec = get_shared_mutable_state(&self.x);\n-            do (*rec).lock.lock {\n-                if (*rec).failed {\n-                    fail!(\n-                        ~\"Poisoned exclusive - another task failed inside!\");\n-                }\n-                (*rec).failed = true;\n-                let result = f(&mut (*rec).data);\n-                (*rec).failed = false;\n-                result\n+        let rec = get_shared_mutable_state(&self.x);\n+        do (*rec).lock.lock {\n+            if (*rec).failed {\n+                fail!(\n+                    ~\"Poisoned exclusive - another task failed inside!\");\n             }\n+            (*rec).failed = true;\n+            let result = f(&mut (*rec).data);\n+            (*rec).failed = false;\n+            result\n         }\n     }\n "}, {"sha": "7a30bb92111b16aeede078c56d78c77859d6bf8c", "filename": "src/libcore/unstable/weak_task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibcore%2Funstable%2Fweak_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibcore%2Funstable%2Fweak_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fweak_task.rs?ref=706096b31960143fb1eb957a882f170ae4a8b4e9", "patch": "@@ -43,11 +43,11 @@ pub unsafe fn weaken_task(f: &fn(Port<ShutdownMsg>)) {\n     let task = get_task_id();\n     // Expect the weak task service to be alive\n     assert!(service.try_send(RegisterWeakTask(task, shutdown_chan)));\n-    unsafe { rust_dec_kernel_live_count(); }\n+    rust_dec_kernel_live_count();\n     do (|| {\n         f(shutdown_port.take())\n     }).finally || {\n-        unsafe { rust_inc_kernel_live_count(); }\n+        rust_inc_kernel_live_count();\n         // Service my have already exited\n         service.send(UnregisterWeakTask(task));\n     }"}, {"sha": "8befa4c82031add754f4be86f43e67e39df57062", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=706096b31960143fb1eb957a882f170ae4a8b4e9", "patch": "@@ -26,7 +26,7 @@ use core::char;\n use core::hash::Streaming;\n use core::hash;\n use core::io::WriterUtil;\n-use core::libc::{c_int, c_uint, c_char};\n+use core::libc::{c_int, c_uint};\n use core::os::consts::{macos, freebsd, linux, android, win32};\n use core::os;\n use core::ptr;"}, {"sha": "8fed8e78094c2c8d63223a0a3d67dd223f562c41", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=706096b31960143fb1eb957a882f170ae4a8b4e9", "patch": "@@ -20,6 +20,7 @@\n use core::prelude::*;\n \n use middle::moves;\n+use middle::typeck::check::PurityState;\n use middle::borrowck::{Loan, bckerr, BorrowckCtxt, inherent_mutability};\n use middle::borrowck::{ReqMaps, root_map_key, save_and_restore_managed};\n use middle::borrowck::{MoveError, MoveOk, MoveFromIllegalCmt};\n@@ -41,11 +42,6 @@ use syntax::codemap::span;\n use syntax::print::pprust;\n use syntax::visit;\n \n-struct PurityState {\n-    def: ast::node_id,\n-    purity: ast::purity\n-}\n-\n struct CheckLoanCtxt {\n     bccx: @BorrowckCtxt,\n     req_maps: ReqMaps,\n@@ -85,8 +81,7 @@ pub fn check_loans(bccx: @BorrowckCtxt,\n         bccx: bccx,\n         req_maps: req_maps,\n         reported: HashSet::new(),\n-        declared_purity: @mut PurityState { purity: ast::impure_fn,\n-                                            def: 0 },\n+        declared_purity: @mut PurityState::function(ast::impure_fn, 0),\n         fn_args: @mut @~[]\n     };\n     let vt = visit::mk_vt(@visit::Visitor {visit_expr: check_loans_in_expr,\n@@ -658,9 +653,7 @@ fn check_loans_in_fn(fk: &visit::fn_kind,\n     debug!(\"purity on entry=%?\", copy self.declared_purity);\n     do save_and_restore_managed(self.declared_purity) {\n         do save_and_restore_managed(self.fn_args) {\n-            self.declared_purity = @mut PurityState {\n-                purity: declared_purity, def: src\n-            };\n+            self.declared_purity = @mut PurityState::function(declared_purity, src);\n \n             match *fk {\n                 visit::fk_anon(*) |\n@@ -810,17 +803,7 @@ fn check_loans_in_block(blk: &ast::blk,\n     do save_and_restore_managed(self.declared_purity) {\n         self.check_for_conflicting_loans(blk.node.id);\n \n-        match blk.node.rules {\n-          ast::default_blk => {\n-          }\n-          ast::unsafe_blk => {\n-            *self.declared_purity = PurityState {\n-                purity: ast::unsafe_fn,\n-                def: blk.node.id,\n-            };\n-          }\n-        }\n-\n+        *self.declared_purity = self.declared_purity.recurse(blk);\n         visit::visit_block(blk, self, vt);\n     }\n }"}, {"sha": "da87568b3d0c0f3a89f52272ba3273298f616ad1", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=706096b31960143fb1eb957a882f170ae4a8b4e9", "patch": "@@ -70,7 +70,7 @@ use core::hash;\n use core::hashmap::{HashMap, HashSet};\n use core::int;\n use core::io;\n-use core::libc::{c_uint, c_ulonglong};\n+use core::libc::c_uint;\n use core::uint;\n use std::time;\n use syntax::ast::ident;\n@@ -2628,13 +2628,11 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n             let class_ty = ty::lookup_item_type(tcx, parent_id).ty;\n             // This code shouldn't be reached if the class is generic\n             assert!(!ty::type_has_params(class_ty));\n-            let lldty = unsafe {\n-                T_fn(~[\n+            let lldty = T_fn(~[\n                     T_ptr(T_i8()),\n                     T_ptr(type_of(ccx, class_ty))\n                 ],\n-                T_nil())\n-            };\n+                T_nil());\n             let s = get_dtor_symbol(ccx, /*bad*/copy *pt, dt.node.id, None);\n \n             /* Make the declaration for the dtor */"}, {"sha": "47c9c3bdb6be4d70bdcac1df6d9ffd6276abfd49", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=706096b31960143fb1eb957a882f170ae4a8b4e9", "patch": "@@ -514,7 +514,7 @@ pub struct substs {\n }\n \n mod primitives {\n-    use super::{sty, t_box_};\n+    use super::t_box_;\n \n     use syntax::ast;\n "}, {"sha": "536de78c752f99dedf945e46df9891b00caa2bed", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=706096b31960143fb1eb957a882f170ae4a8b4e9", "patch": "@@ -115,6 +115,7 @@ use core::result::{Result, Ok, Err};\n use core::result;\n use core::str;\n use core::vec;\n+use core::util::replace;\n use std::list::Nil;\n use syntax::abi::AbiSet;\n use syntax::ast::{provided, required};\n@@ -179,9 +180,36 @@ pub enum FnKind {\n     Vanilla\n }\n \n-struct PurityState {\n+pub struct PurityState {\n+    def: ast::node_id,\n     purity: ast::purity,\n-    from: ast::node_id,\n+    priv from_fn: bool\n+}\n+\n+pub impl PurityState {\n+    pub fn function(purity: ast::purity, def: ast::node_id) -> PurityState {\n+        PurityState { def: def, purity: purity, from_fn: true }\n+    }\n+\n+    pub fn recurse(&mut self, blk: &ast::blk) -> PurityState {\n+        match self.purity {\n+            // If this unsafe, then if the outer function was already marked as\n+            // unsafe we shouldn't attribute the unsafe'ness to the block. This\n+            // way the block can be warned about instead of ignoring this\n+            // extraneous block (functions are never warned about).\n+            ast::unsafe_fn if self.from_fn => *self,\n+\n+            purity => {\n+                let (purity, def) = match blk.node.rules {\n+                    ast::unsafe_blk => (ast::unsafe_fn, blk.node.id),\n+                    ast::default_blk => (purity, self.def),\n+                };\n+                PurityState{ def: def,\n+                             purity: purity,\n+                             from_fn: false }\n+            }\n+        }\n+    }\n }\n \n pub struct FnCtxt {\n@@ -243,7 +271,7 @@ pub fn blank_fn_ctxt(ccx: @mut CrateCtxt,\n     @mut FnCtxt {\n         ret_ty: rty,\n         indirect_ret_ty: None,\n-        ps: PurityState { purity: ast::pure_fn, from: 0 },\n+        ps: PurityState::function(ast::pure_fn, 0),\n         region_lb: region_bnd,\n         in_scope_regions: @Nil,\n         fn_kind: Vanilla,\n@@ -348,7 +376,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         @mut FnCtxt {\n             ret_ty: ret_ty,\n             indirect_ret_ty: indirect_ret_ty,\n-            ps: PurityState { purity: purity, from: id },\n+            ps: PurityState::function(purity, id),\n             region_lb: body.node.id,\n             in_scope_regions: isr,\n             fn_kind: fn_kind,\n@@ -876,8 +904,8 @@ pub impl FnCtxt {\n         match self.ps.purity {\n           ast::unsafe_fn => {\n             // ok, but flag that we used the source of unsafeness\n-            debug!(\"flagging %? as a used unsafe source\", self.ps.from);\n-            self.tcx().used_unsafe.insert(self.ps.from);\n+            debug!(\"flagging %? as a used unsafe source\", self.ps);\n+            self.tcx().used_unsafe.insert(self.ps.def);\n           }\n           _ => {\n             self.ccx.tcx.sess.span_err(\n@@ -1689,7 +1717,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_ty(expr.id, fty);\n \n         let (inherited_purity, id) =\n-            ty::determine_inherited_purity((fcx.ps.purity, fcx.ps.from),\n+            ty::determine_inherited_purity((fcx.ps.purity, fcx.ps.def),\n                                            (purity, expr.id),\n                                            sigil);\n \n@@ -2929,16 +2957,11 @@ pub fn check_block(fcx0: @mut FnCtxt, blk: &ast::blk)  {\n     check_block_with_expected(fcx0, blk, None)\n }\n \n-pub fn check_block_with_expected(fcx0: @mut FnCtxt,\n+pub fn check_block_with_expected(fcx: @mut FnCtxt,\n                                  blk: &ast::blk,\n                                  expected: Option<ty::t>) {\n-    let fcx = match blk.node.rules {\n-        ast::unsafe_blk => @mut FnCtxt {\n-            ps: PurityState { purity: ast::unsafe_fn, from: blk.node.id },\n-            .. copy *fcx0\n-        },\n-        ast::default_blk => fcx0\n-    };\n+    let prev = replace(&mut fcx.ps, fcx.ps.recurse(blk));\n+\n     do fcx.with_region_lb(blk.node.id) {\n         let mut warned = false;\n         let mut last_was_bot = false;\n@@ -2990,6 +3013,8 @@ pub fn check_block_with_expected(fcx0: @mut FnCtxt,\n           }\n         };\n     }\n+\n+    fcx.ps = prev;\n }\n \n pub fn check_const(ccx: @mut CrateCtxt,"}, {"sha": "33aa6171de4b70f774a9236222a47ecb9807b204", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=706096b31960143fb1eb957a882f170ae4a8b4e9", "patch": "@@ -177,15 +177,13 @@ pub impl<T:Owned> MutexARC<T> {\n      */\n     #[inline(always)]\n     unsafe fn access<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n-        unsafe {\n-            let state = get_shared_mutable_state(&self.x);\n-            // Borrowck would complain about this if the function were\n-            // not already unsafe. See borrow_rwlock, far below.\n-            do (&(*state).lock).lock {\n-                check_poison(true, (*state).failed);\n-                let _z = PoisonOnFail(&mut (*state).failed);\n-                blk(&mut (*state).data)\n-            }\n+        let state = get_shared_mutable_state(&self.x);\n+        // Borrowck would complain about this if the function were\n+        // not already unsafe. See borrow_rwlock, far below.\n+        do (&(*state).lock).lock {\n+            check_poison(true, (*state).failed);\n+            let _z = PoisonOnFail(&mut (*state).failed);\n+            blk(&mut (*state).data)\n         }\n     }\n \n@@ -195,16 +193,14 @@ pub impl<T:Owned> MutexARC<T> {\n         &self,\n         blk: &fn(x: &'x mut T, c: &'c Condvar) -> U) -> U\n     {\n-        unsafe {\n-            let state = get_shared_mutable_state(&self.x);\n-            do (&(*state).lock).lock_cond |cond| {\n-                check_poison(true, (*state).failed);\n-                let _z = PoisonOnFail(&mut (*state).failed);\n-                blk(&mut (*state).data,\n-                    &Condvar {is_mutex: true,\n-                              failed: &mut (*state).failed,\n-                              cond: cond })\n-            }\n+        let state = get_shared_mutable_state(&self.x);\n+        do (&(*state).lock).lock_cond |cond| {\n+            check_poison(true, (*state).failed);\n+            let _z = PoisonOnFail(&mut (*state).failed);\n+            blk(&mut (*state).data,\n+                &Condvar {is_mutex: true,\n+                          failed: &mut (*state).failed,\n+                          cond: cond })\n         }\n     }\n }"}, {"sha": "9552badb57f67c1ce1e4d52230ccfafbad4794d6", "filename": "src/test/compile-fail/unused-unsafe.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Ftest%2Fcompile-fail%2Funused-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/706096b31960143fb1eb957a882f170ae4a8b4e9/src%2Ftest%2Fcompile-fail%2Funused-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-unsafe.rs?ref=706096b31960143fb1eb957a882f170ae4a8b4e9", "patch": "@@ -12,30 +12,50 @@\n \n #[deny(unused_unsafe)];\n \n-use core::libc;\n+extern mod foo {\n+    fn bar();\n+}\n \n fn callback<T>(_f: &fn() -> T) -> T { fail!() }\n+unsafe fn unsf() {}\n \n fn bad1() { unsafe {} }                  //~ ERROR: unnecessary `unsafe` block\n fn bad2() { unsafe { bad1() } }          //~ ERROR: unnecessary `unsafe` block\n-unsafe fn bad4() { unsafe {} }           //~ ERROR: unnecessary `unsafe` block\n-fn bad5() { unsafe { do callback {} } }  //~ ERROR: unnecessary `unsafe` block\n+unsafe fn bad3() { unsafe {} }           //~ ERROR: unnecessary `unsafe` block\n+fn bad4() { unsafe { do callback {} } }  //~ ERROR: unnecessary `unsafe` block\n+unsafe fn bad5() { unsafe { unsf() } }   //~ ERROR: unnecessary `unsafe` block\n+fn bad6() {\n+    unsafe {                             //~ ERROR: unnecessary `unsafe` block\n+        unsafe {                         // don't put the warning here\n+            unsf()\n+        }\n+    }\n+}\n+unsafe fn bad7() {\n+    unsafe {                             //~ ERROR: unnecessary `unsafe` block\n+        unsafe {                         //~ ERROR: unnecessary `unsafe` block\n+            unsf()\n+        }\n+    }\n+}\n \n-unsafe fn good0() { libc::exit(1) }\n-fn good1() { unsafe { libc::exit(1) } }\n+unsafe fn good0() { unsf() }\n+fn good1() { unsafe { unsf() } }\n fn good2() {\n     /* bug uncovered when implementing warning about unused unsafe blocks. Be\n        sure that when purity is inherited that the source of the unsafe-ness\n        is tracked correctly */\n     unsafe {\n-        unsafe fn what() -> ~[~str] { libc::exit(2) }\n+        unsafe fn what() -> ~[~str] { fail!() }\n \n         do callback {\n             what();\n         }\n     }\n }\n+unsafe fn good3() { foo::bar() }\n+fn good4() { unsafe { foo::bar() } }\n \n #[allow(unused_unsafe)] fn allowed() { unsafe {} }\n \n-fn main() { }\n+fn main() {}"}]}