{"sha": "0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmMGNkZjZhY2RiNWE5Yjk2ODcyOGQ5NjE5MjljYTU5ZmY5M2NmYTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-10T22:46:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-10T22:46:29Z"}, "message": "Auto merge of #69030 - Dylan-DPC:rollup-t9uk7vc, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #68897 (clean up E0275 explanation)\n - #68908 (Add long error code explanation message for E0637 )\n - #68932 (self-profile: Support arguments for generic_activities.)\n - #68986 (Make ASCII ctype functions unstably const )\n - #69007 (Clean up E0283 explanation)\n - #69014 (change an instance of span_bug() to struct_span_err() to avoid ICE)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "49bcf3b1fde98c8ed06da56145fafc574f47e60e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49bcf3b1fde98c8ed06da56145fafc574f47e60e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "html_url": "https://github.com/rust-lang/rust/commit/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6ec0d125eba4074122b187032474b4174fb9d31", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6ec0d125eba4074122b187032474b4174fb9d31", "html_url": "https://github.com/rust-lang/rust/commit/e6ec0d125eba4074122b187032474b4174fb9d31"}, {"sha": "119bc976db5549f17258a55bb9684eae0fa98b65", "url": "https://api.github.com/repos/rust-lang/rust/commits/119bc976db5549f17258a55bb9684eae0fa98b65", "html_url": "https://github.com/rust-lang/rust/commit/119bc976db5549f17258a55bb9684eae0fa98b65"}], "stats": {"total": 504, "additions": 354, "deletions": 150}, "files": [{"sha": "2b52c48cb9077578cb2204b922c1b66c6ebfb4a9", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -1072,8 +1072,9 @@ impl char {\n     /// assert!(!esc.is_ascii_alphabetic());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_alphabetic(&self) -> bool {\n+    pub const fn is_ascii_alphabetic(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_alphabetic()\n     }\n \n@@ -1104,8 +1105,9 @@ impl char {\n     /// assert!(!esc.is_ascii_uppercase());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_uppercase(&self) -> bool {\n+    pub const fn is_ascii_uppercase(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_uppercase()\n     }\n \n@@ -1136,8 +1138,9 @@ impl char {\n     /// assert!(!esc.is_ascii_lowercase());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_lowercase(&self) -> bool {\n+    pub const fn is_ascii_lowercase(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_lowercase()\n     }\n \n@@ -1171,8 +1174,9 @@ impl char {\n     /// assert!(!esc.is_ascii_alphanumeric());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_alphanumeric(&self) -> bool {\n+    pub const fn is_ascii_alphanumeric(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_alphanumeric()\n     }\n \n@@ -1203,8 +1207,9 @@ impl char {\n     /// assert!(!esc.is_ascii_digit());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_digit(&self) -> bool {\n+    pub const fn is_ascii_digit(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_digit()\n     }\n \n@@ -1238,8 +1243,9 @@ impl char {\n     /// assert!(!esc.is_ascii_hexdigit());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_hexdigit(&self) -> bool {\n+    pub const fn is_ascii_hexdigit(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_hexdigit()\n     }\n \n@@ -1274,8 +1280,9 @@ impl char {\n     /// assert!(!esc.is_ascii_punctuation());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_punctuation(&self) -> bool {\n+    pub const fn is_ascii_punctuation(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_punctuation()\n     }\n \n@@ -1306,8 +1313,9 @@ impl char {\n     /// assert!(!esc.is_ascii_graphic());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_graphic(&self) -> bool {\n+    pub const fn is_ascii_graphic(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_graphic()\n     }\n \n@@ -1355,8 +1363,9 @@ impl char {\n     /// assert!(!esc.is_ascii_whitespace());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_whitespace(&self) -> bool {\n+    pub const fn is_ascii_whitespace(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_whitespace()\n     }\n \n@@ -1389,8 +1398,9 @@ impl char {\n     /// assert!(esc.is_ascii_control());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_control(&self) -> bool {\n+    pub const fn is_ascii_control(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_control()\n     }\n }"}, {"sha": "176c36664a9b14404e7b09016861a6d40b5c29e0", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -70,6 +70,7 @@\n #![feature(bound_cloned)]\n #![feature(cfg_target_has_atomic)]\n #![feature(concat_idents)]\n+#![feature(const_ascii_ctype_on_intrinsics)]\n #![feature(const_alloc_layout)]\n #![feature(const_if_match)]\n #![feature(const_checked_int_methods)]"}, {"sha": "471ab966622495ca55e395999330e813f7aa38f8", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -4449,8 +4449,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_alphabetic());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_alphabetic(&self) -> bool {\n+    pub const fn is_ascii_alphabetic(&self) -> bool {\n         matches!(*self, b'A'..=b'Z' | b'a'..=b'z')\n     }\n \n@@ -4481,8 +4482,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_uppercase());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_uppercase(&self) -> bool {\n+    pub const fn is_ascii_uppercase(&self) -> bool {\n         matches!(*self, b'A'..=b'Z')\n     }\n \n@@ -4513,8 +4515,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_lowercase());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_lowercase(&self) -> bool {\n+    pub const fn is_ascii_lowercase(&self) -> bool {\n         matches!(*self, b'a'..=b'z')\n     }\n \n@@ -4548,8 +4551,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_alphanumeric());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_alphanumeric(&self) -> bool {\n+    pub const fn is_ascii_alphanumeric(&self) -> bool {\n         matches!(*self, b'0'..=b'9' | b'A'..=b'Z' | b'a'..=b'z')\n     }\n \n@@ -4580,8 +4584,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_digit());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_digit(&self) -> bool {\n+    pub const fn is_ascii_digit(&self) -> bool {\n         matches!(*self, b'0'..=b'9')\n     }\n \n@@ -4615,8 +4620,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_hexdigit());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_hexdigit(&self) -> bool {\n+    pub const fn is_ascii_hexdigit(&self) -> bool {\n         matches!(*self, b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f')\n     }\n \n@@ -4651,8 +4657,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_punctuation());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_punctuation(&self) -> bool {\n+    pub const fn is_ascii_punctuation(&self) -> bool {\n         matches!(*self, b'!'..=b'/' | b':'..=b'@' | b'['..=b'`' | b'{'..=b'~')\n     }\n \n@@ -4683,8 +4690,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_graphic());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_graphic(&self) -> bool {\n+    pub const fn is_ascii_graphic(&self) -> bool {\n         matches!(*self, b'!'..=b'~')\n     }\n \n@@ -4732,8 +4740,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_whitespace());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_whitespace(&self) -> bool {\n+    pub const fn is_ascii_whitespace(&self) -> bool {\n         matches!(*self, b'\\t' | b'\\n' | b'\\x0C' | b'\\r' | b' ')\n     }\n \n@@ -4766,8 +4775,9 @@ impl u8 {\n     /// assert!(esc.is_ascii_control());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_control(&self) -> bool {\n+    pub const fn is_ascii_control(&self) -> bool {\n         matches!(*self, b'\\0'..=b'\\x1F' | b'\\x7F')\n     }\n }"}, {"sha": "01f684dc65c30998b1959e262ae98e10fd3412bb", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -1053,8 +1053,10 @@ where\n     Q: super::config::QueryDescription<'tcx, Value: Encodable>,\n     E: 'a + TyEncoder,\n {\n-    let desc = &format!(\"encode_query_results_for_{}\", ::std::any::type_name::<Q>());\n-    let _timer = tcx.sess.prof.extra_verbose_generic_activity(desc);\n+    let _timer = tcx\n+        .sess\n+        .prof\n+        .extra_verbose_generic_activity(\"encode_query_results_for\", ::std::any::type_name::<Q>());\n \n     let shards = Q::query_cache(tcx).lock_shards();\n     assert!(shards.iter().all(|shard| shard.active.is_empty()));"}, {"sha": "76a6ffbb1c5b2049cf6620166288b53bb51d38fb", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -110,23 +110,21 @@ fn prepare_lto(\n                 symbol_white_list.extend(exported_symbols[&cnum].iter().filter_map(symbol_filter));\n             }\n \n-            let _timer = cgcx.prof.generic_activity(\"LLVM_lto_load_upstream_bitcode\");\n             let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n             let bytecodes = archive\n                 .iter()\n                 .filter_map(|child| child.ok().and_then(|c| c.name().map(|name| (name, c))))\n                 .filter(|&(name, _)| name.ends_with(RLIB_BYTECODE_EXTENSION));\n             for (name, data) in bytecodes {\n+                let _timer =\n+                    cgcx.prof.generic_activity_with_arg(\"LLVM_lto_load_upstream_bitcode\", name);\n                 info!(\"adding bytecode {}\", name);\n                 let bc_encoded = data.data();\n \n-                let (bc, id) = cgcx\n-                    .prof\n-                    .extra_verbose_generic_activity(&format!(\"decode {}\", name))\n-                    .run(|| match DecodedBytecode::new(bc_encoded) {\n-                        Ok(b) => Ok((b.bytecode(), b.identifier().to_string())),\n-                        Err(e) => Err(diag_handler.fatal(&e)),\n-                    })?;\n+                let (bc, id) = match DecodedBytecode::new(bc_encoded) {\n+                    Ok(b) => Ok((b.bytecode(), b.identifier().to_string())),\n+                    Err(e) => Err(diag_handler.fatal(&e)),\n+                }?;\n                 let bc = SerializedModule::FromRlib(bc);\n                 upstream_modules.push((bc, CString::new(id).unwrap()));\n             }\n@@ -281,14 +279,14 @@ fn fat_lto(\n         // save and persist everything with the original module.\n         let mut linker = Linker::new(llmod);\n         for (bc_decoded, name) in serialized_modules {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_fat_lto_link_module\");\n+            let _timer = cgcx\n+                .prof\n+                .generic_activity_with_arg(\"LLVM_fat_lto_link_module\", format!(\"{:?}\", name));\n             info!(\"linking {:?}\", name);\n-            cgcx.prof.extra_verbose_generic_activity(&format!(\"ll link {:?}\", name)).run(|| {\n-                let data = bc_decoded.data();\n-                linker.add(&data).map_err(|()| {\n-                    let msg = format!(\"failed to load bc of {:?}\", name);\n-                    write::llvm_err(&diag_handler, &msg)\n-                })\n+            let data = bc_decoded.data();\n+            linker.add(&data).map_err(|()| {\n+                let msg = format!(\"failed to load bc of {:?}\", name);\n+                write::llvm_err(&diag_handler, &msg)\n             })?;\n             serialized_bitcode.push(bc_decoded);\n         }\n@@ -577,6 +575,8 @@ pub(crate) fn run_pass_manager(\n     config: &ModuleConfig,\n     thin: bool,\n ) {\n+    let _timer = cgcx.prof.extra_verbose_generic_activity(\"LLVM_lto_optimize\", &module.name[..]);\n+\n     // Now we have one massive module inside of llmod. Time to run the\n     // LTO-specific optimization passes that LLVM provides.\n     //\n@@ -634,9 +634,7 @@ pub(crate) fn run_pass_manager(\n             llvm::LLVMRustAddPass(pm, pass.unwrap());\n         }\n \n-        cgcx.prof\n-            .extra_verbose_generic_activity(\"LTO_passes\")\n-            .run(|| llvm::LLVMRunPassManager(pm, module.module_llvm.llmod()));\n+        llvm::LLVMRunPassManager(pm, module.module_llvm.llmod());\n \n         llvm::LLVMDisposePassManager(pm);\n     }\n@@ -760,7 +758,9 @@ pub unsafe fn optimize_thin_module(\n         // Like with \"fat\" LTO, get some better optimizations if landing pads\n         // are disabled by removing all landing pads.\n         if cgcx.no_landing_pads {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_remove_landing_pads\");\n+            let _timer = cgcx\n+                .prof\n+                .generic_activity_with_arg(\"LLVM_thin_lto_remove_landing_pads\", thin_module.name());\n             llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n             save_temp_bitcode(&cgcx, &module, \"thin-lto-after-nounwind\");\n         }\n@@ -774,7 +774,8 @@ pub unsafe fn optimize_thin_module(\n         // You can find some more comments about these functions in the LLVM\n         // bindings we've got (currently `PassWrapper.cpp`)\n         {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_rename\");\n+            let _timer =\n+                cgcx.prof.generic_activity_with_arg(\"LLVM_thin_lto_rename\", thin_module.name());\n             if !llvm::LLVMRustPrepareThinLTORename(thin_module.shared.data.0, llmod) {\n                 let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg));\n@@ -783,7 +784,9 @@ pub unsafe fn optimize_thin_module(\n         }\n \n         {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_resolve_weak\");\n+            let _timer = cgcx\n+                .prof\n+                .generic_activity_with_arg(\"LLVM_thin_lto_resolve_weak\", thin_module.name());\n             if !llvm::LLVMRustPrepareThinLTOResolveWeak(thin_module.shared.data.0, llmod) {\n                 let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg));\n@@ -792,7 +795,9 @@ pub unsafe fn optimize_thin_module(\n         }\n \n         {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_internalize\");\n+            let _timer = cgcx\n+                .prof\n+                .generic_activity_with_arg(\"LLVM_thin_lto_internalize\", thin_module.name());\n             if !llvm::LLVMRustPrepareThinLTOInternalize(thin_module.shared.data.0, llmod) {\n                 let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg));\n@@ -801,7 +806,8 @@ pub unsafe fn optimize_thin_module(\n         }\n \n         {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_import\");\n+            let _timer =\n+                cgcx.prof.generic_activity_with_arg(\"LLVM_thin_lto_import\", thin_module.name());\n             if !llvm::LLVMRustPrepareThinLTOImport(thin_module.shared.data.0, llmod) {\n                 let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg));\n@@ -839,7 +845,9 @@ pub unsafe fn optimize_thin_module(\n         // so it appears). Hopefully we can remove this once upstream bugs are\n         // fixed in LLVM.\n         {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_patch_debuginfo\");\n+            let _timer = cgcx\n+                .prof\n+                .generic_activity_with_arg(\"LLVM_thin_lto_patch_debuginfo\", thin_module.name());\n             llvm::LLVMRustThinLTOPatchDICompileUnit(llmod, cu1);\n             save_temp_bitcode(cgcx, &module, \"thin-lto-after-patch\");\n         }\n@@ -850,7 +858,6 @@ pub unsafe fn optimize_thin_module(\n         // populate a thin-specific pass manager, which presumably LLVM treats a\n         // little differently.\n         {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_optimize\");\n             info!(\"running thin lto passes over {}\", module.name);\n             let config = cgcx.config(module.kind);\n             run_pass_manager(cgcx, &module, config, true);"}, {"sha": "7dd57da90c3d60f40372332e88757c520ced5733", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -310,7 +310,7 @@ pub(crate) unsafe fn optimize(\n     module: &ModuleCodegen<ModuleLlvm>,\n     config: &ModuleConfig,\n ) -> Result<(), FatalError> {\n-    let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize\");\n+    let _timer = cgcx.prof.generic_activity_with_arg(\"LLVM_module_optimize\", &module.name[..]);\n \n     let llmod = module.module_llvm.llmod();\n     let llcx = &*module.module_llvm.llcx;\n@@ -424,23 +424,17 @@ pub(crate) unsafe fn optimize(\n \n         // Finally, run the actual optimization passes\n         {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize_function_passes\");\n-            let desc = &format!(\"llvm function passes [{}]\", module_name.unwrap());\n-            let _timer = if config.time_module {\n-                Some(cgcx.prof.extra_verbose_generic_activity(desc))\n-            } else {\n-                None\n-            };\n+            let _timer = cgcx.prof.extra_verbose_generic_activity(\n+                \"LLVM_module_optimize_function_passes\",\n+                &module.name[..],\n+            );\n             llvm::LLVMRustRunFunctionPassManager(fpm, llmod);\n         }\n         {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize_module_passes\");\n-            let desc = &format!(\"llvm module passes [{}]\", module_name.unwrap());\n-            let _timer = if config.time_module {\n-                Some(cgcx.prof.extra_verbose_generic_activity(desc))\n-            } else {\n-                None\n-            };\n+            let _timer = cgcx.prof.extra_verbose_generic_activity(\n+                \"LLVM_module_optimize_module_passes\",\n+                &module.name[..],\n+            );\n             llvm::LLVMRunPassManager(mpm, llmod);\n         }\n \n@@ -480,7 +474,7 @@ pub(crate) unsafe fn codegen(\n     module: ModuleCodegen<ModuleLlvm>,\n     config: &ModuleConfig,\n ) -> Result<CompiledModule, FatalError> {\n-    let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen\");\n+    let _timer = cgcx.prof.generic_activity_with_arg(\"LLVM_module_codegen\", &module.name[..]);\n     {\n         let llmod = module.module_llvm.llmod();\n         let llcx = &*module.module_llvm.llcx;\n@@ -533,26 +527,36 @@ pub(crate) unsafe fn codegen(\n         let obj_out = cgcx.output_filenames.temp_path(OutputType::Object, module_name);\n \n         if write_bc || config.emit_bc_compressed || config.embed_bitcode {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_make_bitcode\");\n+            let _timer = cgcx\n+                .prof\n+                .generic_activity_with_arg(\"LLVM_module_codegen_make_bitcode\", &module.name[..]);\n             let thin = ThinBuffer::new(llmod);\n             let data = thin.data();\n \n             if write_bc {\n-                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_bitcode\");\n+                let _timer = cgcx.prof.generic_activity_with_arg(\n+                    \"LLVM_module_codegen_emit_bitcode\",\n+                    &module.name[..],\n+                );\n                 if let Err(e) = fs::write(&bc_out, data) {\n                     let msg = format!(\"failed to write bytecode to {}: {}\", bc_out.display(), e);\n                     diag_handler.err(&msg);\n                 }\n             }\n \n             if config.embed_bitcode {\n-                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_embed_bitcode\");\n+                let _timer = cgcx.prof.generic_activity_with_arg(\n+                    \"LLVM_module_codegen_embed_bitcode\",\n+                    &module.name[..],\n+                );\n                 embed_bitcode(cgcx, llcx, llmod, Some(data));\n             }\n \n             if config.emit_bc_compressed {\n-                let _timer =\n-                    cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_compressed_bitcode\");\n+                let _timer = cgcx.prof.generic_activity_with_arg(\n+                    \"LLVM_module_codegen_emit_compressed_bitcode\",\n+                    &module.name[..],\n+                );\n                 let dst = bc_out.with_extension(RLIB_BYTECODE_EXTENSION);\n                 let data = bytecode::encode(&module.name, data);\n                 if let Err(e) = fs::write(&dst, data) {\n@@ -565,15 +569,10 @@ pub(crate) unsafe fn codegen(\n         }\n \n         {\n-            let desc = &format!(\"codegen passes [{}]\", module_name.unwrap());\n-            let _timer = if config.time_module {\n-                Some(cgcx.prof.extra_verbose_generic_activity(desc))\n-            } else {\n-                None\n-            };\n-\n             if config.emit_ir {\n-                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_ir\");\n+                let _timer = cgcx\n+                    .prof\n+                    .generic_activity_with_arg(\"LLVM_module_codegen_emit_ir\", &module.name[..]);\n                 let out = cgcx.output_filenames.temp_path(OutputType::LlvmAssembly, module_name);\n                 let out_c = path_to_c_string(&out);\n \n@@ -618,7 +617,9 @@ pub(crate) unsafe fn codegen(\n             }\n \n             if config.emit_asm || asm_to_obj {\n-                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_asm\");\n+                let _timer = cgcx\n+                    .prof\n+                    .generic_activity_with_arg(\"LLVM_module_codegen_emit_asm\", &module.name[..]);\n                 let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n \n                 // We can't use the same module for asm and binary output, because that triggers\n@@ -638,7 +639,9 @@ pub(crate) unsafe fn codegen(\n             }\n \n             if write_obj {\n-                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_obj\");\n+                let _timer = cgcx\n+                    .prof\n+                    .generic_activity_with_arg(\"LLVM_module_codegen_emit_obj\", &module.name[..]);\n                 with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                     write_output_file(\n                         diag_handler,\n@@ -650,7 +653,9 @@ pub(crate) unsafe fn codegen(\n                     )\n                 })?;\n             } else if asm_to_obj {\n-                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_asm_to_obj\");\n+                let _timer = cgcx\n+                    .prof\n+                    .generic_activity_with_arg(\"LLVM_module_codegen_asm_to_obj\", &module.name[..]);\n                 let assembly = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n                 run_assembler(cgcx, diag_handler, &assembly, &obj_out);\n "}, {"sha": "d3b8f7ea33fab46971bbb567c9e0a0fa293675b0", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -1648,7 +1648,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n         let name = cratepath.file_name().unwrap().to_str().unwrap();\n         let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n \n-        sess.prof.extra_verbose_generic_activity(&format!(\"altering {}.rlib\", name)).run(|| {\n+        sess.prof.generic_activity_with_arg(\"link_altering_rlib\", name).run(|| {\n             let mut archive = <B as ArchiveBuilder>::new(sess, &dst, Some(cratepath));\n             archive.update_symbols();\n "}, {"sha": "9905b3a56c0fa1b7c936c858d1d044052b343e86", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -21,6 +21,7 @@ use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::SelfProfilerRef;\n+use rustc_data_structures::profiling::TimingGuard;\n use rustc_data_structures::profiling::VerboseTimingGuard;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n@@ -691,11 +692,17 @@ impl<B: WriteBackendMethods> WorkItem<B> {\n         }\n     }\n \n-    fn profiling_event_id(&self) -> &'static str {\n+    fn start_profiling<'a>(&self, cgcx: &'a CodegenContext<B>) -> TimingGuard<'a> {\n         match *self {\n-            WorkItem::Optimize(_) => \"codegen_module_optimize\",\n-            WorkItem::CopyPostLtoArtifacts(_) => \"codegen_copy_artifacts_from_incr_cache\",\n-            WorkItem::LTO(_) => \"codegen_module_perform_lto\",\n+            WorkItem::Optimize(ref m) => {\n+                cgcx.prof.generic_activity_with_arg(\"codegen_module_optimize\", &m.name[..])\n+            }\n+            WorkItem::CopyPostLtoArtifacts(ref m) => cgcx\n+                .prof\n+                .generic_activity_with_arg(\"codegen_copy_artifacts_from_incr_cache\", &m.name[..]),\n+            WorkItem::LTO(ref m) => {\n+                cgcx.prof.generic_activity_with_arg(\"codegen_module_perform_lto\", m.name())\n+            }\n         }\n     }\n }\n@@ -1520,7 +1527,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         llvm_start_time: &mut Option<VerboseTimingGuard<'a>>,\n     ) {\n         if config.time_module && llvm_start_time.is_none() {\n-            *llvm_start_time = Some(prof.extra_verbose_generic_activity(\"LLVM_passes\"));\n+            *llvm_start_time = Some(prof.extra_verbose_generic_activity(\"LLVM_passes\", \"crate\"));\n         }\n     }\n }\n@@ -1575,7 +1582,7 @@ fn spawn_work<B: ExtraBackendMethods>(cgcx: CodegenContext<B>, work: WorkItem<B>\n         // as a diagnostic was already sent off to the main thread - just\n         // surface that there was an error in this worker.\n         bomb.result = {\n-            let _prof_timer = cgcx.prof.generic_activity(work.profiling_event_id());\n+            let _prof_timer = work.start_profiling(&cgcx);\n             Some(execute_work_item(&cgcx, work))\n         };\n     });"}, {"sha": "debda9f0a0a24f409701eedb3e7d945f124803cc", "filename": "src/librustc_data_structures/profiling.rs", "status": "modified", "additions": 73, "deletions": 34, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_data_structures%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_data_structures%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fprofiling.rs?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -83,6 +83,9 @@\n \n use crate::fx::FxHashMap;\n \n+use std::borrow::Borrow;\n+use std::collections::hash_map::Entry;\n+use std::convert::Into;\n use std::error::Error;\n use std::fs;\n use std::path::Path;\n@@ -123,11 +126,14 @@ bitflags::bitflags! {\n         const INCR_CACHE_LOADS   = 1 << 4;\n \n         const QUERY_KEYS         = 1 << 5;\n+        const FUNCTION_ARGS      = 1 << 6;\n \n         const DEFAULT = Self::GENERIC_ACTIVITIES.bits |\n                         Self::QUERY_PROVIDERS.bits |\n                         Self::QUERY_BLOCKED.bits |\n                         Self::INCR_CACHE_LOADS.bits;\n+\n+        const ARGS = Self::QUERY_KEYS.bits | Self::FUNCTION_ARGS.bits;\n     }\n }\n \n@@ -142,6 +148,8 @@ const EVENT_FILTERS_BY_NAME: &[(&str, EventFilter)] = &[\n     (\"query-blocked\", EventFilter::QUERY_BLOCKED),\n     (\"incr-cache-load\", EventFilter::INCR_CACHE_LOADS),\n     (\"query-keys\", EventFilter::QUERY_KEYS),\n+    (\"function-args\", EventFilter::FUNCTION_ARGS),\n+    (\"args\", EventFilter::ARGS),\n ];\n \n /// Something that uniquely identifies a query invocation.\n@@ -216,43 +224,68 @@ impl SelfProfilerRef {\n     /// VerboseTimingGuard returned from this call is dropped. In addition to recording\n     /// a measureme event, \"verbose\" generic activities also print a timing entry to\n     /// stdout if the compiler is invoked with -Ztime or -Ztime-passes.\n-    #[inline(always)]\n     pub fn verbose_generic_activity<'a>(\n         &'a self,\n-        event_id: &'static str,\n+        event_label: &'static str,\n     ) -> VerboseTimingGuard<'a> {\n-        VerboseTimingGuard::start(\n-            event_id,\n-            self.print_verbose_generic_activities,\n-            self.generic_activity(event_id),\n-        )\n+        let message =\n+            if self.print_verbose_generic_activities { Some(event_label.to_owned()) } else { None };\n+\n+        VerboseTimingGuard::start(message, self.generic_activity(event_label))\n     }\n \n     /// Start profiling a extra verbose generic activity. Profiling continues until the\n     /// VerboseTimingGuard returned from this call is dropped. In addition to recording\n     /// a measureme event, \"extra verbose\" generic activities also print a timing entry to\n     /// stdout if the compiler is invoked with -Ztime-passes.\n-    #[inline(always)]\n-    pub fn extra_verbose_generic_activity<'a>(\n+    pub fn extra_verbose_generic_activity<'a, A>(\n         &'a self,\n-        event_id: &'a str,\n-    ) -> VerboseTimingGuard<'a> {\n-        // FIXME: This does not yet emit a measureme event\n-        // because callers encode arguments into `event_id`.\n-        VerboseTimingGuard::start(\n-            event_id,\n-            self.print_extra_verbose_generic_activities,\n-            TimingGuard::none(),\n-        )\n+        event_label: &'static str,\n+        event_arg: A,\n+    ) -> VerboseTimingGuard<'a>\n+    where\n+        A: Borrow<str> + Into<String>,\n+    {\n+        let message = if self.print_extra_verbose_generic_activities {\n+            Some(format!(\"{}({})\", event_label, event_arg.borrow()))\n+        } else {\n+            None\n+        };\n+\n+        VerboseTimingGuard::start(message, self.generic_activity_with_arg(event_label, event_arg))\n+    }\n+\n+    /// Start profiling a generic activity. Profiling continues until the\n+    /// TimingGuard returned from this call is dropped.\n+    #[inline(always)]\n+    pub fn generic_activity(&self, event_label: &'static str) -> TimingGuard<'_> {\n+        self.exec(EventFilter::GENERIC_ACTIVITIES, |profiler| {\n+            let event_label = profiler.get_or_alloc_cached_string(event_label);\n+            let event_id = EventId::from_label(event_label);\n+            TimingGuard::start(profiler, profiler.generic_activity_event_kind, event_id)\n+        })\n     }\n \n     /// Start profiling a generic activity. Profiling continues until the\n     /// TimingGuard returned from this call is dropped.\n     #[inline(always)]\n-    pub fn generic_activity(&self, event_id: &'static str) -> TimingGuard<'_> {\n+    pub fn generic_activity_with_arg<A>(\n+        &self,\n+        event_label: &'static str,\n+        event_arg: A,\n+    ) -> TimingGuard<'_>\n+    where\n+        A: Borrow<str> + Into<String>,\n+    {\n         self.exec(EventFilter::GENERIC_ACTIVITIES, |profiler| {\n-            let event_id = profiler.get_or_alloc_cached_string(event_id);\n-            let event_id = EventId::from_label(event_id);\n+            let builder = EventIdBuilder::new(&profiler.profiler);\n+            let event_label = profiler.get_or_alloc_cached_string(event_label);\n+            let event_id = if profiler.event_filter_mask.contains(EventFilter::FUNCTION_ARGS) {\n+                let event_arg = profiler.get_or_alloc_cached_string(event_arg);\n+                builder.from_label_and_arg(event_label, event_arg)\n+            } else {\n+                builder.from_label(event_label)\n+            };\n             TimingGuard::start(profiler, profiler.generic_activity_event_kind, event_id)\n         })\n     }\n@@ -337,7 +370,7 @@ pub struct SelfProfiler {\n     profiler: Profiler,\n     event_filter_mask: EventFilter,\n \n-    string_cache: RwLock<FxHashMap<&'static str, StringId>>,\n+    string_cache: RwLock<FxHashMap<String, StringId>>,\n \n     query_event_kind: StringId,\n     generic_activity_event_kind: StringId,\n@@ -419,21 +452,30 @@ impl SelfProfiler {\n     /// Gets a `StringId` for the given string. This method makes sure that\n     /// any strings going through it will only be allocated once in the\n     /// profiling data.\n-    pub fn get_or_alloc_cached_string(&self, s: &'static str) -> StringId {\n+    pub fn get_or_alloc_cached_string<A>(&self, s: A) -> StringId\n+    where\n+        A: Borrow<str> + Into<String>,\n+    {\n         // Only acquire a read-lock first since we assume that the string is\n         // already present in the common case.\n         {\n             let string_cache = self.string_cache.read();\n \n-            if let Some(&id) = string_cache.get(s) {\n+            if let Some(&id) = string_cache.get(s.borrow()) {\n                 return id;\n             }\n         }\n \n         let mut string_cache = self.string_cache.write();\n         // Check if the string has already been added in the small time window\n         // between dropping the read lock and acquiring the write lock.\n-        *string_cache.entry(s).or_insert_with(|| self.profiler.alloc_string(s))\n+        match string_cache.entry(s.into()) {\n+            Entry::Occupied(e) => *e.get(),\n+            Entry::Vacant(e) => {\n+                let string_id = self.profiler.alloc_string(&e.key()[..]);\n+                *e.insert(string_id)\n+            }\n+        }\n     }\n \n     pub fn map_query_invocation_id_to_string(&self, from: QueryInvocationId, to: StringId) {\n@@ -498,18 +540,13 @@ impl<'a> TimingGuard<'a> {\n \n #[must_use]\n pub struct VerboseTimingGuard<'a> {\n-    event_id: &'a str,\n-    start: Option<Instant>,\n+    start_and_message: Option<(Instant, String)>,\n     _guard: TimingGuard<'a>,\n }\n \n impl<'a> VerboseTimingGuard<'a> {\n-    pub fn start(event_id: &'a str, verbose: bool, _guard: TimingGuard<'a>) -> Self {\n-        VerboseTimingGuard {\n-            event_id,\n-            _guard,\n-            start: if unlikely!(verbose) { Some(Instant::now()) } else { None },\n-        }\n+    pub fn start(message: Option<String>, _guard: TimingGuard<'a>) -> Self {\n+        VerboseTimingGuard { _guard, start_and_message: message.map(|msg| (Instant::now(), msg)) }\n     }\n \n     #[inline(always)]\n@@ -521,7 +558,9 @@ impl<'a> VerboseTimingGuard<'a> {\n \n impl Drop for VerboseTimingGuard<'_> {\n     fn drop(&mut self) {\n-        self.start.map(|start| print_time_passes_entry(true, self.event_id, start.elapsed()));\n+        if let Some((start, ref message)) = self.start_and_message {\n+            print_time_passes_entry(true, &message[..], start.elapsed());\n+        }\n     }\n }\n "}, {"sha": "ba43b29538d50dcd85b5f42ed14ed637251adb9d", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -353,6 +353,7 @@ E0631: include_str!(\"./error_codes/E0631.md\"),\n E0633: include_str!(\"./error_codes/E0633.md\"),\n E0635: include_str!(\"./error_codes/E0635.md\"),\n E0636: include_str!(\"./error_codes/E0636.md\"),\n+E0637: include_str!(\"./error_codes/E0637.md\"),\n E0638: include_str!(\"./error_codes/E0638.md\"),\n E0639: include_str!(\"./error_codes/E0639.md\"),\n E0641: include_str!(\"./error_codes/E0641.md\"),\n@@ -584,7 +585,6 @@ E0746: include_str!(\"./error_codes/E0746.md\"),\n     E0632, // cannot provide explicit generic arguments when `impl Trait` is\n            // used in argument position\n     E0634, // type has conflicting packed representaton hints\n-    E0637, // \"'_\" is not a valid lifetime bound\n     E0640, // infer outlives requirements\n //  E0645, // trait aliases not finished\n     E0657, // `impl Trait` can only capture lifetimes bound at the fn level"}, {"sha": "2d12fcea4cafca3366336948577b66227abc9c6a", "filename": "src/librustc_error_codes/error_codes/E0275.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_error_codes%2Ferror_codes%2FE0275.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_error_codes%2Ferror_codes%2FE0275.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0275.md?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -1,8 +1,6 @@\n-This error occurs when there was a recursive trait requirement that overflowed\n-before it could be evaluated. Often this means that there is unbounded\n-recursion in resolving some type bounds.\n+An evaluation of a trait requirement overflowed.\n \n-For example, in the following code:\n+Erroneous code example:\n \n ```compile_fail,E0275\n trait Foo {}\n@@ -12,6 +10,10 @@ struct Bar<T>(T);\n impl<T> Foo for T where Bar<T>: Foo {}\n ```\n \n+This error occurs when there was a recursive trait requirement that overflowed\n+before it could be evaluated. This often means that there is an unbounded\n+recursion in resolving some type bounds.\n+\n To determine if a `T` is `Foo`, we need to check if `Bar<T>` is `Foo`. However,\n to do this check, we need to determine that `Bar<Bar<T>>` is `Foo`. To\n determine this, we check if `Bar<Bar<Bar<T>>>` is `Foo`, and so on. This is"}, {"sha": "6885f9a486d3d673b68c83320b590e72d7305fc8", "filename": "src/librustc_error_codes/error_codes/E0283.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_error_codes%2Ferror_codes%2FE0283.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_error_codes%2Ferror_codes%2FE0283.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0283.md?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -1,7 +1,6 @@\n-This error occurs when the compiler doesn't have enough information\n-to unambiguously choose an implementation.\n+An implementation cannot be chosen unambiguously because of lack of information.\n \n-For example:\n+Erroneous code example:\n \n ```compile_fail,E0283\n trait Generator {\n@@ -27,7 +26,9 @@ fn main() {\n }\n ```\n \n-To resolve this error use the concrete type:\n+This error can be solved by adding type annotations that provide the missing\n+information to the compiler. In this case, the solution is to use a concrete\n+type:\n \n ```\n trait Generator {"}, {"sha": "e114d3d0f94aec5ee38a3258779d7a38dc409bdd", "filename": "src/librustc_error_codes/error_codes/E0637.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_error_codes%2Ferror_codes%2FE0637.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_error_codes%2Ferror_codes%2FE0637.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0637.md?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -0,0 +1,32 @@\n+An underscore `_` character has been used as the identifier for a lifetime.\n+\n+Erroneous example:\n+```compile_fail,E0106,E0637\n+fn longest<'_>(str1: &'_ str, str2: &'_ str) -> &'_ str {\n+         //^^ `'_` is a reserved lifetime name\n+    if str1.len() > str2.len() {\n+        str1\n+    } else {\n+        str2\n+    }\n+}\n+```\n+`'_`, cannot be used as a lifetime identifier because it is a reserved for the\n+anonymous lifetime. To fix this, use a lowercase letter such as 'a, or a series\n+of lowercase letters such as `'foo`.  For more information, see [the\n+book][bk-no].  For more information on using the anonymous lifetime in rust\n+nightly, see [the nightly book][bk-al].\n+\n+Corrected example:\n+```\n+fn longest<'a>(str1: &'a str, str2: &'a str) -> &'a str {\n+    if str1.len() > str2.len() {\n+        str1\n+    } else {\n+        str2\n+    }\n+}\n+```\n+\n+[bk-no]: https://doc.rust-lang.org/book/appendix-02-operators.html#non-operator-symbols\n+[bk-al]: https://doc.rust-lang.org/nightly/edition-guide/rust-2018/ownership-and-lifetimes/the-anonymous-lifetime.html"}, {"sha": "27781eb41d28d4a2a5bef8f804b6fc72082faeff", "filename": "src/librustc_lint/early.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_lint%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_lint%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fearly.rs?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -342,10 +342,8 @@ pub fn check_ast_crate<T: EarlyLintPass>(\n         }\n     } else {\n         for pass in &mut passes {\n-            buffered = sess\n-                .prof\n-                .extra_verbose_generic_activity(&format!(\"running lint: {}\", pass.name()))\n-                .run(|| {\n+            buffered =\n+                sess.prof.extra_verbose_generic_activity(\"run_lint\", pass.name()).run(|| {\n                     early_lint_crate(\n                         sess,\n                         lint_store,"}, {"sha": "b3d5cdf15c933773e04c27fafbbaa32cc6e0539d", "filename": "src/librustc_lint/late.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_lint%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_lint%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flate.rs?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -441,27 +441,20 @@ fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, b\n         late_lint_pass_crate(tcx, builtin_lints);\n     } else {\n         for pass in &mut passes {\n-            tcx.sess\n-                .prof\n-                .extra_verbose_generic_activity(&format!(\"running late lint: {}\", pass.name()))\n-                .run(|| {\n-                    late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n-                });\n+            tcx.sess.prof.extra_verbose_generic_activity(\"run_late_lint\", pass.name()).run(|| {\n+                late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n+            });\n         }\n \n         let mut passes: Vec<_> =\n             unerased_lint_store(tcx).late_module_passes.iter().map(|pass| (pass)()).collect();\n \n         for pass in &mut passes {\n-            tcx.sess\n-                .prof\n-                .extra_verbose_generic_activity(&format!(\n-                    \"running late module lint: {}\",\n-                    pass.name()\n-                ))\n-                .run(|| {\n+            tcx.sess.prof.extra_verbose_generic_activity(\"run_late_module_lint\", pass.name()).run(\n+                || {\n                     late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n-                });\n+                },\n+            );\n         }\n     }\n }"}, {"sha": "a573a1ee69976bf0aa38f0ba2d5eb59cda888474", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -214,7 +214,10 @@ impl<'a> Parser<'a> {\n                     let path = match bounds.remove(0) {\n                         GenericBound::Trait(pt, ..) => pt.trait_ref.path,\n                         GenericBound::Outlives(..) => {\n-                            self.span_bug(ty.span, \"unexpected lifetime bound\")\n+                            return Err(self.struct_span_err(\n+                                ty.span,\n+                                \"expected trait bound, not lifetime bound\",\n+                            ));\n                         }\n                     };\n                     self.parse_remaining_bounds(Vec::new(), path, lo, true)"}, {"sha": "6841d1fdf360b9df002c910f4c72da6d8fa535c8", "filename": "src/test/ui/const-generics/const-param-elided-lifetime.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-elided-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-elided-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-elided-lifetime.stderr?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -38,3 +38,4 @@ LL | #![feature(const_generics)]\n \n error: aborting due to 5 previous errors\n \n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "25b270ee49cae05fd1c2e9ea0e8f0b7f137e8d59", "filename": "src/test/ui/consts/ascii_ctype.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Fconsts%2Fascii_ctype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Fconsts%2Fascii_ctype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fascii_ctype.rs?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -0,0 +1,55 @@\n+// run-pass\n+\n+#![feature(const_ascii_ctype_on_intrinsics)]\n+\n+macro_rules! suite {\n+    ( $( $fn:ident => [$a:ident, $A:ident, $nine:ident, $dot:ident, $space:ident]; )* ) => {\n+        $(\n+            mod $fn {\n+                const CHAR_A_LOWER: bool = 'a'.$fn();\n+                const CHAR_A_UPPER: bool = 'A'.$fn();\n+                const CHAR_NINE: bool = '9'.$fn();\n+                const CHAR_DOT: bool = '.'.$fn();\n+                const CHAR_SPACE: bool = ' '.$fn();\n+\n+                const U8_A_LOWER: bool = b'a'.$fn();\n+                const U8_A_UPPER: bool = b'A'.$fn();\n+                const U8_NINE: bool = b'9'.$fn();\n+                const U8_DOT: bool = b'.'.$fn();\n+                const U8_SPACE: bool = b' '.$fn();\n+\n+                pub fn run() {\n+                    assert_eq!(CHAR_A_LOWER, $a);\n+                    assert_eq!(CHAR_A_UPPER, $A);\n+                    assert_eq!(CHAR_NINE, $nine);\n+                    assert_eq!(CHAR_DOT, $dot);\n+                    assert_eq!(CHAR_SPACE, $space);\n+\n+                    assert_eq!(U8_A_LOWER, $a);\n+                    assert_eq!(U8_A_UPPER, $A);\n+                    assert_eq!(U8_NINE, $nine);\n+                    assert_eq!(U8_DOT, $dot);\n+                    assert_eq!(U8_SPACE, $space);\n+                }\n+            }\n+        )*\n+\n+        fn main() {\n+            $( $fn::run(); )*\n+        }\n+    }\n+}\n+\n+suite! {\n+    //                        'a'    'A'    '9'    '.'    ' '\n+    is_ascii_alphabetic   => [true,  true,  false, false, false];\n+    is_ascii_uppercase    => [false, true,  false, false, false];\n+    is_ascii_lowercase    => [true,  false, false, false, false];\n+    is_ascii_alphanumeric => [true,  true,  true,  false, false];\n+    is_ascii_digit        => [false, false, true,  false, false];\n+    is_ascii_hexdigit     => [true,  true,  true,  false, false];\n+    is_ascii_punctuation  => [false, false, false, true,  false];\n+    is_ascii_graphic      => [true,  true,  true,  true,  false];\n+    is_ascii_whitespace   => [false, false, false, false, true];\n+    is_ascii_control      => [false, false, false, false, false];\n+}"}, {"sha": "d19ebfd15a52cd341a22a7107c3544ece3a295ea", "filename": "src/test/ui/error-codes/E0637.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Ferror-codes%2FE0637.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Ferror-codes%2FE0637.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0637.stderr?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -18,3 +18,4 @@ LL | impl<'a: '_> Bar<'a> {\n \n error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "9f410c0dbbbd21059d2ff9af3dc3ab1d02fdbf15", "filename": "src/test/ui/generics/issue-65285-incorrect-explicit-lifetime-name-needed.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.stderr?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -18,4 +18,5 @@ LL | fn bar<'b, L: X<&'b Nested<i32>>>(){}\n \n error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0106`.\n+Some errors have detailed explanations: E0106, E0637.\n+For more information about an error, try `rustc --explain E0106`."}, {"sha": "a7c5a5e13008aab8f32a4ef0fce4aef0b0af3b60", "filename": "src/test/ui/parser/issue-68890.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Fparser%2Fissue-68890.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Fparser%2Fissue-68890.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-68890.rs?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -0,0 +1,4 @@\n+enum e{A((?'a a+?+l))}\n+//~^ ERROR `?` may only modify trait bounds, not lifetime bounds\n+//~| ERROR expected one of `)`, `+`, or `,`\n+//~| ERROR expected trait bound, not lifetime bound"}, {"sha": "9bb8761b67b5fad3807d0afba91197a1d67da339", "filename": "src/test/ui/parser/issue-68890.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Fparser%2Fissue-68890.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Fparser%2Fissue-68890.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-68890.stderr?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -0,0 +1,20 @@\n+error: `?` may only modify trait bounds, not lifetime bounds\n+  --> $DIR/issue-68890.rs:1:11\n+   |\n+LL | enum e{A((?'a a+?+l))}\n+   |           ^\n+\n+error: expected one of `)`, `+`, or `,`, found `a`\n+  --> $DIR/issue-68890.rs:1:15\n+   |\n+LL | enum e{A((?'a a+?+l))}\n+   |               ^ expected one of `)`, `+`, or `,`\n+\n+error: expected trait bound, not lifetime bound\n+  --> $DIR/issue-68890.rs:1:11\n+   |\n+LL | enum e{A((?'a a+?+l))}\n+   |           ^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "fcd7eddb57605197fd7fd9a115847d17d7499ef9", "filename": "src/test/ui/underscore-lifetime/in-binder.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-binder.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-binder.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-binder.stderr?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -36,3 +36,4 @@ LL | fn foo<'_>() {\n \n error: aborting due to 6 previous errors\n \n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "ada4551baefffe09483ebfecde240937bd28b761", "filename": "src/test/ui/underscore-lifetime/underscore-lifetime-binders.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.stderr?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -38,4 +38,5 @@ LL | fn foo2<'a>(_: &'a u8, y: &'a u8) -> &'a u8 { y }\n \n error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0106`.\n+Some errors have detailed explanations: E0106, E0637.\n+For more information about an error, try `rustc --explain E0106`."}, {"sha": "4b38a26f957f96c915b6ef4be937c16f66a00a2d", "filename": "src/test/ui/underscore-lifetime/underscore-outlives-bounds.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-outlives-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-outlives-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-outlives-bounds.stderr?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -6,3 +6,4 @@ LL | impl<'b: '_> Foo<'b> for i32 {}\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "fe726cb49c73737a3c244d520e5ceba3dbbf7c67", "filename": "src/test/ui/underscore-lifetime/where-clause-inherent-impl-ampersand.rust2015.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-ampersand.rust2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-ampersand.rust2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-ampersand.rust2015.stderr?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -6,3 +6,4 @@ LL |     T: WithType<&u32>\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "fe726cb49c73737a3c244d520e5ceba3dbbf7c67", "filename": "src/test/ui/underscore-lifetime/where-clause-inherent-impl-ampersand.rust2018.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-ampersand.rust2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-ampersand.rust2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-ampersand.rust2018.stderr?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -6,3 +6,4 @@ LL |     T: WithType<&u32>\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "95939fd6b7e0374880dc80125675d197447865c8", "filename": "src/test/ui/underscore-lifetime/where-clause-inherent-impl-underscore.rust2015.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-underscore.rust2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-underscore.rust2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-underscore.rust2015.stderr?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -6,3 +6,4 @@ LL |     T: WithRegion<'_>\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "95939fd6b7e0374880dc80125675d197447865c8", "filename": "src/test/ui/underscore-lifetime/where-clause-inherent-impl-underscore.rust2018.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-underscore.rust2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-underscore.rust2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-underscore.rust2018.stderr?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -6,3 +6,4 @@ LL |     T: WithRegion<'_>\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "fbd14de21078b1440a47035103bbf782f88edc9d", "filename": "src/test/ui/underscore-lifetime/where-clause-trait-impl-region.rust2015.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-region.rust2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-region.rust2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-region.rust2015.stderr?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -6,3 +6,4 @@ LL |     T: WithType<&u32>\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "fbd14de21078b1440a47035103bbf782f88edc9d", "filename": "src/test/ui/underscore-lifetime/where-clause-trait-impl-region.rust2018.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-region.rust2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-region.rust2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-region.rust2018.stderr?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -6,3 +6,4 @@ LL |     T: WithType<&u32>\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "92caff0dcde9977d669106c969a4bab8540e72df", "filename": "src/test/ui/underscore-lifetime/where-clause-trait-impl-underscore.rust2015.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-underscore.rust2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-underscore.rust2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-underscore.rust2015.stderr?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -6,3 +6,4 @@ LL |     T: WithRegion<'_>\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "92caff0dcde9977d669106c969a4bab8540e72df", "filename": "src/test/ui/underscore-lifetime/where-clause-trait-impl-underscore.rust2018.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-underscore.rust2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-underscore.rust2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-underscore.rust2018.stderr?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -6,3 +6,4 @@ LL |     T: WithRegion<'_>\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "1a3ea4af7e12e78788747dbc085c2b602f75c5e2", "filename": "src/test/ui/underscore-lifetime/where-clauses.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clauses.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f0cdf6acdb5a9b968728d961929ca59ff93cfa4/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clauses.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clauses.stderr?ref=0f0cdf6acdb5a9b968728d961929ca59ff93cfa4", "patch": "@@ -12,3 +12,4 @@ LL | impl<T: '_> Foo<'static> for Vec<T> {}\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0637`."}]}