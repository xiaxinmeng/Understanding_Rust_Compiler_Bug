{"sha": "032462e06f7ef393bac06a76a62fe9ad3f4290b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzMjQ2MmUwNmY3ZWYzOTNiYWMwNmE3NmE2MmZlOWFkM2Y0MjkwYjc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-04-04T23:58:32Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-04-06T22:28:47Z"}, "message": "linker: Combine argument building into a single function", "tree": {"sha": "312133a1cc32aa4878f42cce8fef5743a636bf4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/312133a1cc32aa4878f42cce8fef5743a636bf4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/032462e06f7ef393bac06a76a62fe9ad3f4290b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/032462e06f7ef393bac06a76a62fe9ad3f4290b7", "html_url": "https://github.com/rust-lang/rust/commit/032462e06f7ef393bac06a76a62fe9ad3f4290b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/032462e06f7ef393bac06a76a62fe9ad3f4290b7/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce25dabc66d4b7905dba3bf63ad766d9d6f421ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce25dabc66d4b7905dba3bf63ad766d9d6f421ab", "html_url": "https://github.com/rust-lang/rust/commit/ce25dabc66d4b7905dba3bf63ad766d9d6f421ab"}], "stats": {"total": 233, "additions": 118, "deletions": 115}, "files": [{"sha": "0c418b7e3d708833edff91ec41cfa7700d7efcbd", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 107, "deletions": 98, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/032462e06f7ef393bac06a76a62fe9ad3f4290b7/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032462e06f7ef393bac06a76a62fe9ad3f4290b7/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=032462e06f7ef393bac06a76a62fe9ad3f4290b7", "patch": "@@ -154,7 +154,7 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n // The third parameter is for env vars, used on windows to set up the\n // path for MSVC to find its DLLs, and gcc to find its bundled\n // toolchain\n-pub fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> (PathBuf, Command) {\n+pub fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> Command {\n     let msvc_tool = windows_registry::find_tool(&sess.opts.target_triple.triple(), \"link.exe\");\n \n     // If our linker looks like a batch script on Windows then to execute this\n@@ -232,7 +232,7 @@ pub fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> (PathB\n     }\n     cmd.env(\"PATH\", env::join_paths(new_path).unwrap());\n \n-    (linker.to_path_buf(), cmd)\n+    cmd\n }\n \n pub fn each_linked_rlib(\n@@ -487,95 +487,18 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n     target_cpu: &str,\n ) {\n     info!(\"preparing {:?} to {:?}\", crate_type, out_filename);\n-    let (linker, flavor) = linker_and_flavor(sess);\n-\n-    let any_dynamic_crate = crate_type == config::CrateType::Dylib\n-        || codegen_results.crate_info.dependency_formats.iter().any(|(ty, list)| {\n-            *ty == crate_type && list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n-        });\n-\n-    // The invocations of cc share some flags across platforms\n-    let (pname, mut cmd) = get_linker(sess, &linker, flavor);\n-\n-    if let Some(args) = sess.target.target.options.pre_link_args.get(&flavor) {\n-        cmd.args(args);\n-    }\n-    if let Some(args) = sess.target.target.options.pre_link_args_crt.get(&flavor) {\n-        if sess.crt_static(Some(crate_type)) {\n-            cmd.args(args);\n-        }\n-    }\n-    cmd.args(&sess.opts.debugging_opts.pre_link_args);\n-\n-    if sess.target.target.options.is_like_fuchsia {\n-        let prefix = match sess.opts.debugging_opts.sanitizer {\n-            Some(Sanitizer::Address) => \"asan/\",\n-            _ => \"\",\n-        };\n-        cmd.arg(format!(\"--dynamic-linker={}ld.so.1\", prefix));\n-    }\n-\n-    let pre_link_objects = if crate_type == config::CrateType::Executable {\n-        &sess.target.target.options.pre_link_objects_exe\n-    } else {\n-        &sess.target.target.options.pre_link_objects_dll\n-    };\n-    for obj in pre_link_objects {\n-        cmd.arg(get_file_path(sess, obj));\n-    }\n-\n-    if crate_type == config::CrateType::Executable && sess.crt_static(Some(crate_type)) {\n-        for obj in &sess.target.target.options.pre_link_objects_exe_crt {\n-            cmd.arg(get_file_path(sess, obj));\n-        }\n-    }\n-\n-    if sess.target.target.options.is_like_emscripten {\n-        cmd.arg(\"-s\");\n-        cmd.arg(if sess.panic_strategy() == PanicStrategy::Abort {\n-            \"DISABLE_EXCEPTION_CATCHING=1\"\n-        } else {\n-            \"DISABLE_EXCEPTION_CATCHING=0\"\n-        });\n-    }\n+    let (linker_path, flavor) = linker_and_flavor(sess);\n+    let mut cmd = linker_with_args::<B>(\n+        &linker_path,\n+        flavor,\n+        sess,\n+        crate_type,\n+        tmpdir,\n+        out_filename,\n+        codegen_results,\n+        target_cpu,\n+    );\n \n-    {\n-        let mut linker = codegen_results.linker_info.to_linker(cmd, &sess, flavor, target_cpu);\n-        link_sanitizer_runtime(sess, crate_type, &mut *linker);\n-        link_args::<B>(\n-            &mut *linker,\n-            flavor,\n-            sess,\n-            crate_type,\n-            tmpdir,\n-            out_filename,\n-            codegen_results,\n-        );\n-        cmd = linker.finalize();\n-    }\n-    if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n-        cmd.args(args);\n-    }\n-    if any_dynamic_crate {\n-        if let Some(args) = sess.target.target.options.late_link_args_dynamic.get(&flavor) {\n-            cmd.args(args);\n-        }\n-    } else {\n-        if let Some(args) = sess.target.target.options.late_link_args_static.get(&flavor) {\n-            cmd.args(args);\n-        }\n-    }\n-    for obj in &sess.target.target.options.post_link_objects {\n-        cmd.arg(get_file_path(sess, obj));\n-    }\n-    if sess.crt_static(Some(crate_type)) {\n-        for obj in &sess.target.target.options.post_link_objects_crt {\n-            cmd.arg(get_file_path(sess, obj));\n-        }\n-    }\n-    if let Some(args) = sess.target.target.options.post_link_args.get(&flavor) {\n-        cmd.args(args);\n-    }\n     for &(ref k, ref v) in &sess.target.target.options.link_env {\n         cmd.env(k, v);\n     }\n@@ -597,7 +520,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n     let mut i = 0;\n     loop {\n         i += 1;\n-        prog = sess.time(\"run_linker\", || exec_linker(sess, &mut cmd, out_filename, tmpdir));\n+        prog = sess.time(\"run_linker\", || exec_linker(sess, &cmd, out_filename, tmpdir));\n         let output = match prog {\n             Ok(ref output) => output,\n             Err(_) => break,\n@@ -698,7 +621,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n                 output.extend_from_slice(&prog.stdout);\n                 sess.struct_err(&format!(\n                     \"linking with `{}` failed: {}\",\n-                    pname.display(),\n+                    linker_path.display(),\n                     prog.status\n                 ))\n                 .note(&format!(\"{:?}\", &cmd))\n@@ -714,9 +637,12 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n \n             let mut linker_error = {\n                 if linker_not_found {\n-                    sess.struct_err(&format!(\"linker `{}` not found\", pname.display()))\n+                    sess.struct_err(&format!(\"linker `{}` not found\", linker_path.display()))\n                 } else {\n-                    sess.struct_err(&format!(\"could not exec the linker `{}`\", pname.display()))\n+                    sess.struct_err(&format!(\n+                        \"could not exec the linker `{}`\",\n+                        linker_path.display()\n+                    ))\n                 }\n             };\n \n@@ -1087,7 +1013,7 @@ pub fn get_file_path(sess: &Session, name: &str) -> PathBuf {\n \n pub fn exec_linker(\n     sess: &Session,\n-    cmd: &mut Command,\n+    cmd: &Command,\n     out_filename: &Path,\n     tmpdir: &Path,\n ) -> io::Result<Output> {\n@@ -1233,15 +1159,66 @@ pub fn exec_linker(\n     }\n }\n \n-fn link_args<'a, B: ArchiveBuilder<'a>>(\n-    cmd: &mut dyn Linker,\n+fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n+    path: &Path,\n     flavor: LinkerFlavor,\n     sess: &'a Session,\n     crate_type: config::CrateType,\n     tmpdir: &Path,\n     out_filename: &Path,\n     codegen_results: &CodegenResults,\n-) {\n+    target_cpu: &str,\n+) -> Command {\n+    let base_cmd = get_linker(sess, path, flavor);\n+    // FIXME: Move `/LIBPATH` addition for uwp targets from the linker construction\n+    // to the linker args construction.\n+    assert!(base_cmd.get_args().is_empty() || sess.target.target.target_vendor == \"uwp\");\n+    let cmd = &mut *codegen_results.linker_info.to_linker(base_cmd, &sess, flavor, target_cpu);\n+\n+    if let Some(args) = sess.target.target.options.pre_link_args.get(&flavor) {\n+        cmd.args(args);\n+    }\n+    if let Some(args) = sess.target.target.options.pre_link_args_crt.get(&flavor) {\n+        if sess.crt_static(Some(crate_type)) {\n+            cmd.args(args);\n+        }\n+    }\n+    cmd.args(&sess.opts.debugging_opts.pre_link_args);\n+\n+    if sess.target.target.options.is_like_fuchsia {\n+        let prefix = match sess.opts.debugging_opts.sanitizer {\n+            Some(Sanitizer::Address) => \"asan/\",\n+            _ => \"\",\n+        };\n+        cmd.arg(format!(\"--dynamic-linker={}ld.so.1\", prefix));\n+    }\n+\n+    let pre_link_objects = if crate_type == config::CrateType::Executable {\n+        &sess.target.target.options.pre_link_objects_exe\n+    } else {\n+        &sess.target.target.options.pre_link_objects_dll\n+    };\n+    for obj in pre_link_objects {\n+        cmd.arg(get_file_path(sess, obj));\n+    }\n+\n+    if crate_type == config::CrateType::Executable && sess.crt_static(Some(crate_type)) {\n+        for obj in &sess.target.target.options.pre_link_objects_exe_crt {\n+            cmd.arg(get_file_path(sess, obj));\n+        }\n+    }\n+\n+    if sess.target.target.options.is_like_emscripten {\n+        cmd.arg(\"-s\");\n+        cmd.arg(if sess.panic_strategy() == PanicStrategy::Abort {\n+            \"DISABLE_EXCEPTION_CATCHING=1\"\n+        } else {\n+            \"DISABLE_EXCEPTION_CATCHING=0\"\n+        });\n+    }\n+\n+    link_sanitizer_runtime(sess, crate_type, cmd);\n+\n     // Linker plugins should be specified early in the list of arguments\n     cmd.linker_plugin_lto();\n \n@@ -1440,6 +1417,38 @@ fn link_args<'a, B: ArchiveBuilder<'a>>(\n     // Finally add all the linker arguments provided on the command line along\n     // with any #[link_args] attributes found inside the crate\n     cmd.args(user_link_args);\n+\n+    cmd.finalize();\n+\n+    if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n+        cmd.args(args);\n+    }\n+    let any_dynamic_crate = crate_type == config::CrateType::Dylib\n+        || codegen_results.crate_info.dependency_formats.iter().any(|(ty, list)| {\n+            *ty == crate_type && list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n+        });\n+    if any_dynamic_crate {\n+        if let Some(args) = sess.target.target.options.late_link_args_dynamic.get(&flavor) {\n+            cmd.args(args);\n+        }\n+    } else {\n+        if let Some(args) = sess.target.target.options.late_link_args_static.get(&flavor) {\n+            cmd.args(args);\n+        }\n+    }\n+    for obj in &sess.target.target.options.post_link_objects {\n+        cmd.arg(get_file_path(sess, obj));\n+    }\n+    if sess.crt_static(Some(crate_type)) {\n+        for obj in &sess.target.target.options.post_link_objects_crt {\n+            cmd.arg(get_file_path(sess, obj));\n+        }\n+    }\n+    if let Some(args) = sess.target.target.options.post_link_args.get(&flavor) {\n+        cmd.args(args);\n+    }\n+\n+    cmd.take_cmd()\n }\n \n // # Native library linking"}, {"sha": "0baa37ae9f1ab76eafb6e8fa1fdb185b8bf75c28", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/032462e06f7ef393bac06a76a62fe9ad3f4290b7/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032462e06f7ef393bac06a76a62fe9ad3f4290b7/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=032462e06f7ef393bac06a76a62fe9ad3f4290b7", "patch": "@@ -6,6 +6,7 @@ use std::ffi::{OsStr, OsString};\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufWriter};\n+use std::mem;\n use std::path::{Path, PathBuf};\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -117,8 +118,7 @@ pub trait Linker {\n     fn group_start(&mut self);\n     fn group_end(&mut self);\n     fn linker_plugin_lto(&mut self);\n-    // Should have been finalize(self), but we don't support self-by-value on trait objects (yet?).\n-    fn finalize(&mut self) -> Command;\n+    fn finalize(&mut self);\n }\n \n impl dyn Linker + '_ {\n@@ -129,6 +129,10 @@ impl dyn Linker + '_ {\n     pub fn args(&mut self, args: impl IntoIterator<Item: AsRef<OsStr>>) {\n         self.cmd().args(args);\n     }\n+\n+    pub fn take_cmd(&mut self) -> Command {\n+        mem::replace(self.cmd(), Command::new(\"\"))\n+    }\n }\n \n pub struct GccLinker<'a> {\n@@ -515,10 +519,8 @@ impl<'a> Linker for GccLinker<'a> {\n         self.linker_arg(&subsystem);\n     }\n \n-    fn finalize(&mut self) -> Command {\n+    fn finalize(&mut self) {\n         self.hint_dynamic(); // Reset to default before returning the composed command line.\n-\n-        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n     }\n \n     fn group_start(&mut self) {\n@@ -768,9 +770,7 @@ impl<'a> Linker for MsvcLinker<'a> {\n         }\n     }\n \n-    fn finalize(&mut self) -> Command {\n-        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n-    }\n+    fn finalize(&mut self) {}\n \n     // MSVC doesn't need group indicators\n     fn group_start(&mut self) {}\n@@ -937,9 +937,7 @@ impl<'a> Linker for EmLinker<'a> {\n         // noop\n     }\n \n-    fn finalize(&mut self) -> Command {\n-        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n-    }\n+    fn finalize(&mut self) {}\n \n     // Appears not necessary on Emscripten\n     fn group_start(&mut self) {}\n@@ -1107,9 +1105,7 @@ impl<'a> Linker for WasmLd<'a> {\n \n     fn no_position_independent_executable(&mut self) {}\n \n-    fn finalize(&mut self) -> Command {\n-        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n-    }\n+    fn finalize(&mut self) {}\n \n     // Not needed for now with LLD\n     fn group_start(&mut self) {}\n@@ -1209,14 +1205,12 @@ impl<'a> Linker for PtxLinker<'a> {\n         self.cmd.arg(\"-o\").arg(path);\n     }\n \n-    fn finalize(&mut self) -> Command {\n+    fn finalize(&mut self) {\n         // Provide the linker with fallback to internal `target-cpu`.\n         self.cmd.arg(\"--fallback-arch\").arg(match self.sess.opts.cg.target_cpu {\n             Some(ref s) => s,\n             None => &self.sess.target.target.options.cpu,\n         });\n-\n-        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n     }\n \n     fn link_dylib(&mut self, _lib: Symbol) {"}]}