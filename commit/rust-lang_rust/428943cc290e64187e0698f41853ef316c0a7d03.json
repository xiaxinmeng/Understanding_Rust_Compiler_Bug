{"sha": "428943cc290e64187e0698f41853ef316c0a7d03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyODk0M2NjMjkwZTY0MTg3ZTA2OThmNDE4NTNlZjMxNmMwYTdkMDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-02T16:26:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-02T16:26:10Z"}, "message": "Auto merge of #59636 - Centril:rollup, r=Centril\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #59166 (resolve: collect trait aliases along with traits)\n - #59341 (Fix custom relative libdir)\n - #59446 (Fix stack overflow when generating debuginfo for 'recursive' type)\n - #59529 (Added documentation on the remainder (Rem) operator for floating points.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "16bf85f0b8cecaefe14b06f33a4251ad90dd11d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16bf85f0b8cecaefe14b06f33a4251ad90dd11d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/428943cc290e64187e0698f41853ef316c0a7d03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/428943cc290e64187e0698f41853ef316c0a7d03", "html_url": "https://github.com/rust-lang/rust/commit/428943cc290e64187e0698f41853ef316c0a7d03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/428943cc290e64187e0698f41853ef316c0a7d03/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e008e4fde837313d4a72da603ef492a721afc998", "url": "https://api.github.com/repos/rust-lang/rust/commits/e008e4fde837313d4a72da603ef492a721afc998", "html_url": "https://github.com/rust-lang/rust/commit/e008e4fde837313d4a72da603ef492a721afc998"}, {"sha": "21e2e98b8ce445141eb91b5d93ecfc416b5e279a", "url": "https://api.github.com/repos/rust-lang/rust/commits/21e2e98b8ce445141eb91b5d93ecfc416b5e279a", "html_url": "https://github.com/rust-lang/rust/commit/21e2e98b8ce445141eb91b5d93ecfc416b5e279a"}], "stats": {"total": 442, "additions": 377, "deletions": 65}, "files": [{"sha": "522466314d66045306e65b71763a6f4ea1e88669", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/428943cc290e64187e0698f41853ef316c0a7d03/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428943cc290e64187e0698f41853ef316c0a7d03/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=428943cc290e64187e0698f41853ef316c0a7d03", "patch": "@@ -634,7 +634,28 @@ impl<'a> Builder<'a> {\n         if compiler.is_snapshot(self) {\n             self.rustc_snapshot_libdir()\n         } else {\n-            self.sysroot(compiler).join(libdir(&compiler.host))\n+            match self.config.libdir_relative() {\n+                Some(relative_libdir) if compiler.stage >= 1\n+                    => self.sysroot(compiler).join(relative_libdir),\n+                _ => self.sysroot(compiler).join(libdir(&compiler.host))\n+            }\n+        }\n+    }\n+\n+    /// Returns the compiler's relative libdir where it stores the dynamic libraries that\n+    /// it itself links against.\n+    ///\n+    /// For example this returns `lib` on Unix and `bin` on\n+    /// Windows.\n+    pub fn libdir_relative(&self, compiler: Compiler) -> &Path {\n+        if compiler.is_snapshot(self) {\n+            libdir(&self.config.build).as_ref()\n+        } else {\n+            match self.config.libdir_relative() {\n+                Some(relative_libdir) if compiler.stage >= 1\n+                    => relative_libdir,\n+                _ => libdir(&compiler.host).as_ref()\n+            }\n         }\n     }\n "}, {"sha": "08316b71ea85b36b2e807102dfc96a8b92e8e9aa", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/428943cc290e64187e0698f41853ef316c0a7d03/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428943cc290e64187e0698f41853ef316c0a7d03/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=428943cc290e64187e0698f41853ef316c0a7d03", "patch": "@@ -20,7 +20,7 @@ use filetime::FileTime;\n use serde_json;\n \n use crate::dist;\n-use crate::util::{exe, libdir, is_dylib};\n+use crate::util::{exe, is_dylib};\n use crate::{Compiler, Mode, GitRepo};\n use crate::native;\n \n@@ -1005,13 +1005,13 @@ impl Step for Assemble {\n \n         // Link in all dylibs to the libdir\n         let sysroot = builder.sysroot(target_compiler);\n-        let sysroot_libdir = sysroot.join(libdir(&*host));\n-        t!(fs::create_dir_all(&sysroot_libdir));\n+        let rustc_libdir = builder.rustc_libdir(target_compiler);\n+        t!(fs::create_dir_all(&rustc_libdir));\n         let src_libdir = builder.sysroot_libdir(build_compiler, host);\n         for f in builder.read_dir(&src_libdir) {\n             let filename = f.file_name().into_string().unwrap();\n             if is_dylib(&filename) {\n-                builder.copy(&f.path(), &sysroot_libdir.join(&filename));\n+                builder.copy(&f.path(), &rustc_libdir.join(&filename));\n             }\n         }\n "}, {"sha": "a4d924d64ee78487156f20b6d79328b01b3cac2c", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/428943cc290e64187e0698f41853ef316c0a7d03/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428943cc290e64187e0698f41853ef316c0a7d03/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=428943cc290e64187e0698f41853ef316c0a7d03", "patch": "@@ -18,7 +18,7 @@ use build_helper::output;\n \n use crate::{Compiler, Mode, LLVM_TOOLS};\n use crate::channel;\n-use crate::util::{libdir, is_dylib, exe};\n+use crate::util::{is_dylib, exe};\n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::compile;\n use crate::tool::{self, Tool};\n@@ -473,21 +473,23 @@ impl Step for Rustc {\n         fn prepare_image(builder: &Builder<'_>, compiler: Compiler, image: &Path) {\n             let host = compiler.host;\n             let src = builder.sysroot(compiler);\n-            let libdir = libdir(&host);\n+            let libdir = builder.rustc_libdir(compiler);\n \n             // Copy rustc/rustdoc binaries\n             t!(fs::create_dir_all(image.join(\"bin\")));\n             builder.cp_r(&src.join(\"bin\"), &image.join(\"bin\"));\n \n             builder.install(&builder.rustdoc(compiler), &image.join(\"bin\"), 0o755);\n \n+            let libdir_relative = builder.libdir_relative(compiler);\n+\n             // Copy runtime DLLs needed by the compiler\n-            if libdir != \"bin\" {\n-                for entry in builder.read_dir(&src.join(libdir)) {\n+            if libdir_relative.to_str() != Some(\"bin\") {\n+                for entry in builder.read_dir(&libdir) {\n                     let name = entry.file_name();\n                     if let Some(s) = name.to_str() {\n                         if is_dylib(s) {\n-                            builder.install(&entry.path(), &image.join(libdir), 0o644);\n+                            builder.install(&entry.path(), &image.join(&libdir_relative), 0o644);\n                         }\n                     }\n                 }\n@@ -516,7 +518,8 @@ impl Step for Rustc {\n                     .join(\"bin\")\n                     .join(&exe);\n                 // for the rationale about this rename check `compile::copy_lld_to_sysroot`\n-                let dst = image.join(\"lib/rustlib\")\n+                let dst = image.join(libdir_relative)\n+                    .join(\"rustlib\")\n                     .join(&*host)\n                     .join(\"bin\")\n                     .join(&exe);"}, {"sha": "47ac04baf6d6d73563a854aab14b278eda6d5a73", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/428943cc290e64187e0698f41853ef316c0a7d03/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428943cc290e64187e0698f41853ef316c0a7d03/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=428943cc290e64187e0698f41853ef316c0a7d03", "patch": "@@ -1275,6 +1275,7 @@ impl Build {\n     fn install(&self, src: &Path, dstdir: &Path, perms: u32) {\n         if self.config.dry_run { return; }\n         let dst = dstdir.join(src.file_name().unwrap());\n+        self.verbose_than(1, &format!(\"Install {:?} to {:?}\", src, dst));\n         t!(fs::create_dir_all(dstdir));\n         drop(fs::remove_file(&dst));\n         {"}, {"sha": "0688a606591e433c8be4ab4898c07c18e0a1f334", "filename": "src/libcore/ops/arith.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/428943cc290e64187e0698f41853ef316c0a7d03/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428943cc290e64187e0698f41853ef316c0a7d03/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=428943cc290e64187e0698f41853ef316c0a7d03", "patch": "@@ -537,6 +537,21 @@ rem_impl_integer! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n macro_rules! rem_impl_float {\n     ($($t:ty)*) => ($(\n+\n+        /// The remainder from the division of two floats.\n+        ///\n+        /// The remainder has the same sign as the dividend and is computed as:\n+        /// `x - (x / y).trunc() * y`.\n+        ///\n+        /// # Examples\n+        /// ```\n+        /// let x: f32 = 50.50;\n+        /// let y: f32 = 8.125;\n+        /// let remainder = x - (x / y).trunc() * y;\n+        ///\n+        /// // The answer to both operations is 1.75\n+        /// assert_eq!(x % y, remainder);\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Rem for $t {\n             type Output = $t;"}, {"sha": "94d520ec78c71a54f48822c7bbfbda17a155a338", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 62, "deletions": 4, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/428943cc290e64187e0698f41853ef316c0a7d03/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428943cc290e64187e0698f41853ef316c0a7d03/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=428943cc290e64187e0698f41853ef316c0a7d03", "patch": "@@ -117,6 +117,32 @@ impl TypeMap<'ll, 'tcx> {\n         }\n     }\n \n+    // Removes a Ty to metadata mapping\n+    // This is useful when computing the metadata for a potentially\n+    // recursive type (e.g. a function ptr of the form:\n+    //\n+    // fn foo() -> impl Copy { foo }\n+    //\n+    // This kind of type cannot be properly represented\n+    // via LLVM debuginfo. As a workaround,\n+    // we register a temporary Ty to metadata mapping\n+    // for the function before we compute its actual metadata.\n+    // If the metadata computation ends up recursing back to the\n+    // original function, it will use the temporary mapping\n+    // for the inner self-reference, preventing us from\n+    // recursing forever.\n+    //\n+    // This function is used to remove the temporary metadata\n+    // mapping after we've computed the actual metadata\n+    fn remove_type(\n+        &mut self,\n+        type_: Ty<'tcx>,\n+    ) {\n+        if self.type_to_metadata.remove(type_).is_none() {\n+            bug!(\"Type metadata Ty '{}' is not in the TypeMap!\", type_);\n+        }\n+    }\n+\n     // Adds a UniqueTypeId to metadata mapping to the TypeMap. The method will\n     // fail if the mapping already exists.\n     fn register_unique_id_with_metadata(\n@@ -608,17 +634,49 @@ pub fn type_metadata(\n             }\n         }\n         ty::FnDef(..) | ty::FnPtr(_) => {\n-            let fn_metadata = subroutine_type_metadata(cx,\n-                                                       unique_type_id,\n-                                                       t.fn_sig(cx.tcx),\n-                                                       usage_site_span).metadata;\n+\n             if let Some(metadata) = debug_context(cx).type_map\n                .borrow()\n                .find_metadata_for_unique_id(unique_type_id)\n             {\n                 return metadata;\n             }\n \n+            // It's possible to create a self-referential\n+            // type in Rust by using 'impl trait':\n+            //\n+            // fn foo() -> impl Copy { foo }\n+            //\n+            // See TypeMap::remove_type for more detals\n+            // about the workaround\n+\n+            let temp_type = {\n+                unsafe {\n+                    // The choice of type here is pretty arbitrary -\n+                    // anything reading the debuginfo for a recursive\n+                    // type is going to see *somthing* weird - the only\n+                    // question is what exactly it will see\n+                    let (size, align) = cx.size_and_align_of(t);\n+                    llvm::LLVMRustDIBuilderCreateBasicType(\n+                        DIB(cx),\n+                        SmallCStr::new(\"<recur_type>\").as_ptr(),\n+                        size.bits(),\n+                        align.bits() as u32,\n+                        DW_ATE_unsigned)\n+                }\n+            };\n+\n+            let type_map = &debug_context(cx).type_map;\n+            type_map.borrow_mut().register_type_with_metadata(t, temp_type);\n+\n+            let fn_metadata = subroutine_type_metadata(cx,\n+                                                       unique_type_id,\n+                                                       t.fn_sig(cx.tcx),\n+                                                       usage_site_span).metadata;\n+\n+            type_map.borrow_mut().remove_type(t);\n+\n+\n             // This is actually a function pointer, so wrap it in pointer DI\n             MetadataCreationResult::new(pointer_type_metadata(cx, t, fn_metadata), false)\n "}, {"sha": "eff7cd1bc8a485f5b77dc0d1c89190f55c86b41f", "filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs", "status": "modified", "additions": 49, "deletions": 13, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/428943cc290e64187e0698f41853ef316c0a7d03/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428943cc290e64187e0698f41853ef316c0a7d03/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs?ref=428943cc290e64187e0698f41853ef316c0a7d03", "patch": "@@ -5,6 +5,7 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty};\n use rustc_codegen_ssa::traits::*;\n+use rustc_data_structures::fx::FxHashSet;\n \n use rustc::hir;\n \n@@ -17,7 +18,8 @@ pub fn compute_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                              qualified: bool)\n                                              -> String {\n     let mut result = String::with_capacity(64);\n-    push_debuginfo_type_name(cx, t, qualified, &mut result);\n+    let mut visited = FxHashSet::default();\n+    push_debuginfo_type_name(cx, t, qualified, &mut result, &mut visited);\n     result\n }\n \n@@ -26,7 +28,9 @@ pub fn compute_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                           t: Ty<'tcx>,\n                                           qualified: bool,\n-                                          output: &mut String) {\n+                                          output: &mut String,\n+                                          visited: &mut FxHashSet<Ty<'tcx>>) {\n+\n     // When targeting MSVC, emit C++ style type names for compatibility with\n     // .natvis visualizers (and perhaps other existing native debuggers?)\n     let cpp_like_names = cx.sess().target.target.options.is_like_msvc;\n@@ -42,12 +46,12 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         ty::Foreign(def_id) => push_item_name(cx, def_id, qualified, output),\n         ty::Adt(def, substs) => {\n             push_item_name(cx, def.did, qualified, output);\n-            push_type_params(cx, substs, output);\n+            push_type_params(cx, substs, output, visited);\n         },\n         ty::Tuple(component_types) => {\n             output.push('(');\n             for &component_type in component_types {\n-                push_debuginfo_type_name(cx, component_type, true, output);\n+                push_debuginfo_type_name(cx, component_type, true, output, visited);\n                 output.push_str(\", \");\n             }\n             if !component_types.is_empty() {\n@@ -65,7 +69,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 hir::MutMutable => output.push_str(\"mut \"),\n             }\n \n-            push_debuginfo_type_name(cx, inner_type, true, output);\n+            push_debuginfo_type_name(cx, inner_type, true, output, visited);\n \n             if cpp_like_names {\n                 output.push('*');\n@@ -79,15 +83,15 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 output.push_str(\"mut \");\n             }\n \n-            push_debuginfo_type_name(cx, inner_type, true, output);\n+            push_debuginfo_type_name(cx, inner_type, true, output, visited);\n \n             if cpp_like_names {\n                 output.push('*');\n             }\n         },\n         ty::Array(inner_type, len) => {\n             output.push('[');\n-            push_debuginfo_type_name(cx, inner_type, true, output);\n+            push_debuginfo_type_name(cx, inner_type, true, output, visited);\n             output.push_str(&format!(\"; {}\", len.unwrap_usize(cx.tcx)));\n             output.push(']');\n         },\n@@ -98,7 +102,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 output.push('[');\n             }\n \n-            push_debuginfo_type_name(cx, inner_type, true, output);\n+            push_debuginfo_type_name(cx, inner_type, true, output, visited);\n \n             if cpp_like_names {\n                 output.push('>');\n@@ -113,12 +117,31 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                     &principal,\n                 );\n                 push_item_name(cx, principal.def_id, false, output);\n-                push_type_params(cx, principal.substs, output);\n+                push_type_params(cx, principal.substs, output, visited);\n             } else {\n                 output.push_str(\"dyn '_\");\n             }\n         },\n         ty::FnDef(..) | ty::FnPtr(_) => {\n+            // We've encountered a weird 'recursive type'\n+            // Currently, the only way to generate such a type\n+            // is by using 'impl trait':\n+            //\n+            // fn foo() -> impl Copy { foo }\n+            //\n+            // There's not really a sensible name we can generate,\n+            // since we don't include 'impl trait' types (e.g. ty::Opaque)\n+            // in the output\n+            //\n+            // Since we need to generate *something*, we just\n+            // use a dummy string that should make it clear\n+            // that something unusual is going on\n+            if !visited.insert(t) {\n+                output.push_str(\"<recursive_type>\");\n+                return;\n+            }\n+\n+\n             let sig = t.fn_sig(cx.tcx);\n             if sig.unsafety() == hir::Unsafety::Unsafe {\n                 output.push_str(\"unsafe \");\n@@ -136,7 +159,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n             if !sig.inputs().is_empty() {\n                 for &parameter_type in sig.inputs() {\n-                    push_debuginfo_type_name(cx, parameter_type, true, output);\n+                    push_debuginfo_type_name(cx, parameter_type, true, output, visited);\n                     output.push_str(\", \");\n                 }\n                 output.pop();\n@@ -155,8 +178,20 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n             if !sig.output().is_unit() {\n                 output.push_str(\" -> \");\n-                push_debuginfo_type_name(cx, sig.output(), true, output);\n+                push_debuginfo_type_name(cx, sig.output(), true, output, visited);\n             }\n+\n+\n+            // We only keep the type in 'visited'\n+            // for the duration of the body of this method.\n+            // It's fine for a particular function type\n+            // to show up multiple times in one overall type\n+            // (e.g. MyType<fn() -> u8, fn() -> u8>\n+            //\n+            // We only care about avoiding recursing\n+            // directly back to the type we're currently\n+            // processing\n+            visited.remove(t);\n         },\n         ty::Closure(..) => {\n             output.push_str(\"closure\");\n@@ -200,15 +235,16 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     // common denominator - otherwise we would run into conflicts.\n     fn push_type_params<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                   substs: SubstsRef<'tcx>,\n-                                  output: &mut String) {\n+                                  output: &mut String,\n+                                  visited: &mut FxHashSet<Ty<'tcx>>) {\n         if substs.types().next().is_none() {\n             return;\n         }\n \n         output.push('<');\n \n         for type_parameter in substs.types() {\n-            push_debuginfo_type_name(cx, type_parameter, true, output);\n+            push_debuginfo_type_name(cx, type_parameter, true, output, visited);\n             output.push_str(\", \");\n         }\n "}, {"sha": "1934f800af7575a8e9886fb809d0753408acd62d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 41, "deletions": 18, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/428943cc290e64187e0698f41853ef316c0a7d03/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428943cc290e64187e0698f41853ef316c0a7d03/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=428943cc290e64187e0698f41853ef316c0a7d03", "patch": "@@ -1352,7 +1352,7 @@ impl<'a> NameBinding<'a> {\n         }\n     }\n \n-    // We sometimes need to treat variants as `pub` for backwards compatibility\n+    // We sometimes need to treat variants as `pub` for backwards compatibility.\n     fn pseudo_vis(&self) -> ty::Visibility {\n         if self.is_variant() && self.def().def_id().is_local() {\n             ty::Visibility::Public\n@@ -2714,7 +2714,7 @@ impl<'a> Resolver<'a> {\n     {\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n-        // plain insert (no renaming, types are not currently hygienic....)\n+        // Plain insert (no renaming, since types are not currently hygienic)\n         self_type_rib.bindings.insert(keywords::SelfUpper.ident(), self_def);\n         self.ribs[TypeNS].push(self_type_rib);\n         f(self);\n@@ -4438,26 +4438,47 @@ impl<'a> Resolver<'a> {\n             let mut collected_traits = Vec::new();\n             module.for_each_child(|name, ns, binding| {\n                 if ns != TypeNS { return }\n-                if let Def::Trait(_) = binding.def() {\n-                    collected_traits.push((name, binding));\n+                match binding.def() {\n+                    Def::Trait(_) |\n+                    Def::TraitAlias(_) => collected_traits.push((name, binding)),\n+                    _ => (),\n                 }\n             });\n             *traits = Some(collected_traits.into_boxed_slice());\n         }\n \n         for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n-            let module = binding.module().unwrap();\n-            let mut ident = ident;\n-            if ident.span.glob_adjust(module.expansion, binding.span.ctxt().modern()).is_none() {\n-                continue\n-            }\n-            if self.resolve_ident_in_module_unadjusted(\n-                ModuleOrUniformRoot::Module(module),\n-                ident,\n-                ns,\n-                false,\n-                module.span,\n-            ).is_ok() {\n+            // Traits have pseudo-modules that can be used to search for the given ident.\n+            if let Some(module) = binding.module() {\n+                let mut ident = ident;\n+                if ident.span.glob_adjust(\n+                    module.expansion,\n+                    binding.span.ctxt().modern(),\n+                ).is_none() {\n+                    continue\n+                }\n+                if self.resolve_ident_in_module_unadjusted(\n+                    ModuleOrUniformRoot::Module(module),\n+                    ident,\n+                    ns,\n+                    false,\n+                    module.span,\n+                ).is_ok() {\n+                    let import_id = match binding.kind {\n+                        NameBindingKind::Import { directive, .. } => {\n+                            self.maybe_unused_trait_imports.insert(directive.id);\n+                            self.add_to_glob_map(&directive, trait_name);\n+                            Some(directive.id)\n+                        }\n+                        _ => None,\n+                    };\n+                    let trait_def_id = module.def_id().unwrap();\n+                    found_traits.push(TraitCandidate { def_id: trait_def_id, import_id });\n+                }\n+            } else if let Def::TraitAlias(_) = binding.def() {\n+                // For now, just treat all trait aliases as possible candidates, since we don't\n+                // know if the ident is somewhere in the transitive bounds.\n+\n                 let import_id = match binding.kind {\n                     NameBindingKind::Import { directive, .. } => {\n                         self.maybe_unused_trait_imports.insert(directive.id);\n@@ -4466,8 +4487,10 @@ impl<'a> Resolver<'a> {\n                     }\n                     _ => None,\n                 };\n-                let trait_def_id = module.def_id().unwrap();\n-                found_traits.push(TraitCandidate { def_id: trait_def_id, import_id: import_id });\n+                let trait_def_id = binding.def().def_id();\n+                found_traits.push(TraitCandidate { def_id: trait_def_id, import_id });\n+            } else {\n+                bug!(\"candidate is not trait or trait alias?\")\n             }\n         }\n     }"}, {"sha": "97b630ba5f298c8e1632b40a4289f3057baa590b", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/428943cc290e64187e0698f41853ef316c0a7d03/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428943cc290e64187e0698f41853ef316c0a7d03/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=428943cc290e64187e0698f41853ef316c0a7d03", "patch": "@@ -1334,7 +1334,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n         self.populate_module_if_necessary(module);\n \n-        if let Some(Def::Trait(_)) = module.def() {\n+        if module.is_trait() {\n             self.session.span_err(directive.span, \"items in traits are not importable.\");\n             return;\n         } else if module.def_id() == directive.parent_scope.module.def_id()  {"}, {"sha": "42156213f21df8713a14fa1687d33de69a8a63cc", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/428943cc290e64187e0698f41853ef316c0a7d03/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428943cc290e64187e0698f41853ef316c0a7d03/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=428943cc290e64187e0698f41853ef316c0a7d03", "patch": "@@ -896,20 +896,36 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         let trait_substs = self.fresh_item_substs(trait_def_id);\n         let trait_ref = ty::TraitRef::new(trait_def_id, trait_substs);\n \n-        for item in self.impl_or_trait_item(trait_def_id) {\n-            // Check whether `trait_def_id` defines a method with suitable name:\n-            if !self.has_applicable_self(&item) {\n-                debug!(\"method has inapplicable self\");\n-                self.record_static_candidate(TraitSource(trait_def_id));\n-                continue;\n-            }\n+        if self.tcx.is_trait_alias(trait_def_id) {\n+            // For trait aliases, assume all super-traits are relevant.\n+            let bounds = iter::once(trait_ref.to_poly_trait_ref());\n+            self.elaborate_bounds(bounds, |this, new_trait_ref, item| {\n+                let new_trait_ref = this.erase_late_bound_regions(&new_trait_ref);\n+\n+                let (xform_self_ty, xform_ret_ty) =\n+                    this.xform_self_ty(&item, new_trait_ref.self_ty(), new_trait_ref.substs);\n+                this.push_candidate(Candidate {\n+                    xform_self_ty, xform_ret_ty, item, import_id,\n+                    kind: TraitCandidate(new_trait_ref),\n+                }, true);\n+            });\n+        } else {\n+            debug_assert!(self.tcx.is_trait(trait_def_id));\n+            for item in self.impl_or_trait_item(trait_def_id) {\n+                // Check whether `trait_def_id` defines a method with suitable name.\n+                if !self.has_applicable_self(&item) {\n+                    debug!(\"method has inapplicable self\");\n+                    self.record_static_candidate(TraitSource(trait_def_id));\n+                    continue;\n+                }\n \n-            let (xform_self_ty, xform_ret_ty) =\n-                self.xform_self_ty(&item, trait_ref.self_ty(), trait_substs);\n-            self.push_candidate(Candidate {\n-                xform_self_ty, xform_ret_ty, item, import_id,\n-                kind: TraitCandidate(trait_ref),\n-            }, false);\n+                let (xform_self_ty, xform_ret_ty) =\n+                    self.xform_self_ty(&item, trait_ref.self_ty(), trait_substs);\n+                self.push_candidate(Candidate {\n+                    xform_self_ty, xform_ret_ty, item, import_id,\n+                    kind: TraitCandidate(trait_ref),\n+                }, false);\n+            }\n         }\n         Ok(())\n     }\n@@ -930,7 +946,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             .filter(|&name| set.insert(name))\n             .collect();\n \n-        // sort them by the name so we have a stable result\n+        // Sort them by the name so we have a stable result.\n         names.sort_by_cached_key(|n| n.as_str());\n         names\n     }\n@@ -945,6 +961,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             return r;\n         }\n \n+        debug!(\"pick: actual search failed, assemble diagnotics\");\n+\n         let static_candidates = mem::replace(&mut self.static_candidates, vec![]);\n         let private_candidate = self.private_candidate.take();\n         let unsatisfied_predicates = mem::replace(&mut self.unsatisfied_predicates, vec![]);"}, {"sha": "5f5c7cfec9578c4b1889b883f013bcca44f0dfa9", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/428943cc290e64187e0698f41853ef316c0a7d03/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428943cc290e64187e0698f41853ef316c0a7d03/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=428943cc290e64187e0698f41853ef316c0a7d03", "patch": "@@ -757,9 +757,13 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n \n     impl<'v, 'a, 'tcx> itemlikevisit::ItemLikeVisitor<'v> for Visitor<'a, 'tcx> {\n         fn visit_item(&mut self, i: &'v hir::Item) {\n-            if let hir::ItemKind::Trait(..) = i.node {\n-                let def_id = self.map.local_def_id_from_hir_id(i.hir_id);\n-                self.traits.push(def_id);\n+            match i.node {\n+                hir::ItemKind::Trait(..) |\n+                hir::ItemKind::TraitAlias(..) => {\n+                    let def_id = self.map.local_def_id_from_hir_id(i.hir_id);\n+                    self.traits.push(def_id);\n+                }\n+                _ => ()\n             }\n         }\n \n@@ -781,7 +785,8 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n                            external_mods: &mut FxHashSet<DefId>,\n                            def: Def) {\n         match def {\n-            Def::Trait(def_id) => {\n+            Def::Trait(def_id) |\n+            Def::TraitAlias(def_id) => {\n                 traits.push(def_id);\n             }\n             Def::Mod(def_id) => {"}, {"sha": "f9113d50197c19950fead49653da4d78b495b374", "filename": "src/test/codegen/fn-impl-trait-self.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/428943cc290e64187e0698f41853ef316c0a7d03/src%2Ftest%2Fcodegen%2Ffn-impl-trait-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428943cc290e64187e0698f41853ef316c0a7d03/src%2Ftest%2Fcodegen%2Ffn-impl-trait-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffn-impl-trait-self.rs?ref=428943cc290e64187e0698f41853ef316c0a7d03", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -g\n+//\n+// CHECK-LABEL: @main\n+// CHECK: {{.*}}DIDerivedType(tag: DW_TAG_pointer_type, name: \"fn() -> <recursive_type>\",{{.*}}\n+//\n+// CHECK: {{.*}}DISubroutineType{{.*}}\n+// CHECK: {{.*}}DIBasicType(name: \"<recur_type>\", encoding: DW_ATE_unsigned)\n+\n+pub fn foo() -> impl Copy {\n+    foo\n+}\n+\n+fn main() {\n+    let my_res = foo();\n+}"}, {"sha": "8ab845366b7b4b873687dbc9e7aa6c4b82cd4237", "filename": "src/test/run-pass/issues/issue-58463.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/428943cc290e64187e0698f41853ef316c0a7d03/src%2Ftest%2Frun-pass%2Fissues%2Fissue-58463.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428943cc290e64187e0698f41853ef316c0a7d03/src%2Ftest%2Frun-pass%2Fissues%2Fissue-58463.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-58463.rs?ref=428943cc290e64187e0698f41853ef316c0a7d03", "patch": "@@ -0,0 +1,8 @@\n+// run-pass\n+// compile-flags:-C debuginfo=2\n+fn foo() -> impl Copy {\n+    foo\n+}\n+fn main() {\n+    foo();\n+}"}, {"sha": "9e412215512c90bc4e978bea8116d88a8637a9ee", "filename": "src/test/run-pass/traits/auxiliary/trait_alias.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/428943cc290e64187e0698f41853ef316c0a7d03/src%2Ftest%2Frun-pass%2Ftraits%2Fauxiliary%2Ftrait_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428943cc290e64187e0698f41853ef316c0a7d03/src%2Ftest%2Frun-pass%2Ftraits%2Fauxiliary%2Ftrait_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Fauxiliary%2Ftrait_alias.rs?ref=428943cc290e64187e0698f41853ef316c0a7d03", "patch": "@@ -0,0 +1,13 @@\n+#![feature(trait_alias)]\n+\n+pub trait Hello {\n+    fn hello(&self);\n+}\n+\n+pub struct Hi;\n+\n+impl Hello for Hi {\n+    fn hello(&self) {}\n+}\n+\n+pub trait Greet = Hello;"}, {"sha": "975542ab49b591edc531efb3b5047a901eaafeae", "filename": "src/test/run-pass/traits/trait-alias-import-cross-crate.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/428943cc290e64187e0698f41853ef316c0a7d03/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-import-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428943cc290e64187e0698f41853ef316c0a7d03/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-import-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-import-cross-crate.rs?ref=428943cc290e64187e0698f41853ef316c0a7d03", "patch": "@@ -0,0 +1,14 @@\n+// run-pass\n+// aux-build:trait_alias.rs\n+\n+#![feature(trait_alias)]\n+\n+extern crate trait_alias;\n+\n+// Import only the alias, not the real trait.\n+use trait_alias::{Greet, Hi};\n+\n+fn main() {\n+    let hi = Hi;\n+    hi.hello(); // From `Hello`, via `Greet` alias.\n+}"}, {"sha": "7d63320b9aad433a225b5b139030e1b5be67ebc4", "filename": "src/test/run-pass/traits/trait-alias-import.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/428943cc290e64187e0698f41853ef316c0a7d03/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428943cc290e64187e0698f41853ef316c0a7d03/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-import.rs?ref=428943cc290e64187e0698f41853ef316c0a7d03", "patch": "@@ -0,0 +1,38 @@\n+#![feature(trait_alias)]\n+\n+mod inner {\n+    pub trait Foo {\n+        fn foo(&self);\n+    }\n+\n+    pub struct Qux;\n+\n+    impl Foo for Qux {\n+        fn foo(&self) {}\n+    }\n+\n+    pub trait Bar = Foo;\n+}\n+\n+mod two {\n+    pub trait A {\n+        fn foo();\n+    }\n+\n+    impl A for u8 {\n+        fn foo() {}\n+    }\n+}\n+\n+// Import only the alias, not the `Foo` trait.\n+use inner::{Bar, Qux};\n+\n+// Declaring an alias also brings in aliased methods.\n+trait Two = two::A;\n+\n+fn main() {\n+    let q = Qux;\n+    q.foo(); // From Bar.\n+\n+    u8::foo(); // From A.\n+}"}, {"sha": "28409e0c662775a88d86f42b31ff0d573f98b08d", "filename": "src/test/ui/traits/trait-alias-ambiguous.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/428943cc290e64187e0698f41853ef316c0a7d03/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428943cc290e64187e0698f41853ef316c0a7d03/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.rs?ref=428943cc290e64187e0698f41853ef316c0a7d03", "patch": "@@ -0,0 +1,24 @@\n+#![feature(trait_alias)]\n+\n+mod inner {\n+    pub trait A { fn foo(&self); }\n+    pub trait B { fn foo(&self); }\n+\n+    impl A for u8 {\n+        fn foo(&self) {}\n+    }\n+    impl B for u8 {\n+        fn foo(&self) {}\n+    }\n+\n+    pub trait C = A + B;\n+}\n+\n+use inner::C;\n+\n+fn main() {\n+    let t = 1u8;\n+    t.foo(); //~ ERROR E0034\n+\n+    inner::A::foo(&t); // ok\n+}"}, {"sha": "b7443269b882d63509ef4a8063b540fa0144ed23", "filename": "src/test/ui/traits/trait-alias-ambiguous.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/428943cc290e64187e0698f41853ef316c0a7d03/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/428943cc290e64187e0698f41853ef316c0a7d03/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.stderr?ref=428943cc290e64187e0698f41853ef316c0a7d03", "patch": "@@ -0,0 +1,20 @@\n+error[E0034]: multiple applicable items in scope\n+  --> $DIR/trait-alias-ambiguous.rs:21:7\n+   |\n+LL |     t.foo();\n+   |       ^^^ multiple `foo` found\n+   |\n+note: candidate #1 is defined in an impl of the trait `inner::A` for the type `u8`\n+  --> $DIR/trait-alias-ambiguous.rs:8:9\n+   |\n+LL |         fn foo(&self) {}\n+   |         ^^^^^^^^^^^^^\n+note: candidate #2 is defined in an impl of the trait `inner::B` for the type `u8`\n+  --> $DIR/trait-alias-ambiguous.rs:11:9\n+   |\n+LL |         fn foo(&self) {}\n+   |         ^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0034`."}]}