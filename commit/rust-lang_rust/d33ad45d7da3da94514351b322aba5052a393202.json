{"sha": "d33ad45d7da3da94514351b322aba5052a393202", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzM2FkNDVkN2RhM2RhOTQ1MTQzNTFiMzIyYWJhNTA1MmEzOTMyMDI=", "commit": {"author": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2019-11-11T22:42:12Z"}, "committer": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2019-11-26T22:07:17Z"}, "message": "trigger string_lit_as_bytes when literal has escapes", "tree": {"sha": "4e59e03fac116094ed5790158538cf5508e339e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e59e03fac116094ed5790158538cf5508e339e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d33ad45d7da3da94514351b322aba5052a393202", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQFKBAABCAA0FiEELriChyEaiMu0yCg7viIhAz7bw3QFAl3dohUWHGFydXNzZWxs\nMTIzQGdtYWlsLmNvbQAKCRC+IiEDPtvDdGtVCACd79BPKTBw3NuQIG3iL1LhFTMC\nDcsf9xO+g5W8lZXszoJI99l52NgxwYQMPAMI8KF7G47hvTawJ4uhbhCbXvC6AOzq\nrJysIFsjpdweDgT2s6HCu2uln+uXJBNVWYEeQV8Jghnf3XvMONegVECPQn9R/Hp1\nSmXzE/sLjue95h8GVj944bsTtkLjAxBi27zvlTjdq8wLswl9If+TJ8CUQgpVYZhA\nhHimzfvtwz4q/58PBkHivO+D42SAmJ/dt0f76BJQPVByAtidoOEH3HpRZEKiw2HI\n7LOLvxC+bIAdF2Y20T0843MndmAMxxDVhhQeF/Nvll+MlTL4/9SOkcOkUNkf\n=uzdT\n-----END PGP SIGNATURE-----", "payload": "tree 4e59e03fac116094ed5790158538cf5508e339e6\nparent cc35165f52c16b884d06e1efc76c8f2bf73f1cbd\nauthor Andy Russell <arussell123@gmail.com> 1573512132 -0500\ncommitter Andy Russell <arussell123@gmail.com> 1574806037 -0500\n\ntrigger string_lit_as_bytes when literal has escapes\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d33ad45d7da3da94514351b322aba5052a393202", "html_url": "https://github.com/rust-lang/rust/commit/d33ad45d7da3da94514351b322aba5052a393202", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d33ad45d7da3da94514351b322aba5052a393202/comments", "author": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "committer": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc35165f52c16b884d06e1efc76c8f2bf73f1cbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc35165f52c16b884d06e1efc76c8f2bf73f1cbd", "html_url": "https://github.com/rust-lang/rust/commit/cc35165f52c16b884d06e1efc76c8f2bf73f1cbd"}], "stats": {"total": 99, "additions": 52, "deletions": 47}, "files": [{"sha": "00e2441becf8129f8b6e283fb7e23eea8e74daa2", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 41, "deletions": 46, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/d33ad45d7da3da94514351b322aba5052a393202/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d33ad45d7da3da94514351b322aba5052a393202/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=d33ad45d7da3da94514351b322aba5052a393202", "patch": "@@ -4,6 +4,8 @@ use rustc::{declare_lint_pass, declare_tool_lint};\n use rustc_errors::Applicability;\n use syntax::source_map::Spanned;\n \n+use if_chain::if_chain;\n+\n use crate::utils::SpanlessEq;\n use crate::utils::{get_parent_expr, is_allowed, match_type, paths, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n \n@@ -146,53 +148,46 @@ declare_lint_pass!(StringLitAsBytes => [STRING_LIT_AS_BYTES]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         use crate::utils::{snippet, snippet_with_applicability};\n-        use syntax::ast::{LitKind, StrStyle};\n+        use syntax::ast::LitKind;\n \n-        if let ExprKind::MethodCall(ref path, _, ref args) = e.kind {\n-            if path.ident.name == sym!(as_bytes) {\n-                if let ExprKind::Lit(ref lit) = args[0].kind {\n-                    if let LitKind::Str(ref lit_content, style) = lit.node {\n-                        let callsite = snippet(cx, args[0].span.source_callsite(), r#\"\"foo\"\"#);\n-                        let expanded = if let StrStyle::Raw(n) = style {\n-                            let term = \"#\".repeat(usize::from(n));\n-                            format!(\"r{0}\\\"{1}\\\"{0}\", term, lit_content.as_str())\n-                        } else {\n-                            format!(\"\\\"{}\\\"\", lit_content.as_str())\n-                        };\n-                        let mut applicability = Applicability::MachineApplicable;\n-                        if callsite.starts_with(\"include_str!\") {\n-                            span_lint_and_sugg(\n-                                cx,\n-                                STRING_LIT_AS_BYTES,\n-                                e.span,\n-                                \"calling `as_bytes()` on `include_str!(..)`\",\n-                                \"consider using `include_bytes!(..)` instead\",\n-                                snippet_with_applicability(cx, args[0].span, r#\"\"foo\"\"#, &mut applicability).replacen(\n-                                    \"include_str\",\n-                                    \"include_bytes\",\n-                                    1,\n-                                ),\n-                                applicability,\n-                            );\n-                        } else if callsite == expanded\n-                            && lit_content.as_str().chars().all(|c| c.is_ascii())\n-                            && lit_content.as_str().len() <= MAX_LENGTH_BYTE_STRING_LIT\n-                            && !args[0].span.from_expansion()\n-                        {\n-                            span_lint_and_sugg(\n-                                cx,\n-                                STRING_LIT_AS_BYTES,\n-                                e.span,\n-                                \"calling `as_bytes()` on a string literal\",\n-                                \"consider using a byte string literal instead\",\n-                                format!(\n-                                    \"b{}\",\n-                                    snippet_with_applicability(cx, args[0].span, r#\"\"foo\"\"#, &mut applicability)\n-                                ),\n-                                applicability,\n-                            );\n-                        }\n-                    }\n+        if_chain! {\n+            if let ExprKind::MethodCall(path, _, args) = &e.kind;\n+            if path.ident.name == sym!(as_bytes);\n+            if let ExprKind::Lit(lit) = &args[0].kind;\n+            if let LitKind::Str(lit_content, _) = &lit.node;\n+            then {\n+                let callsite = snippet(cx, args[0].span.source_callsite(), r#\"\"foo\"\"#);\n+                let mut applicability = Applicability::MachineApplicable;\n+                if callsite.starts_with(\"include_str!\") {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        STRING_LIT_AS_BYTES,\n+                        e.span,\n+                        \"calling `as_bytes()` on `include_str!(..)`\",\n+                        \"consider using `include_bytes!(..)` instead\",\n+                        snippet_with_applicability(cx, args[0].span, r#\"\"foo\"\"#, &mut applicability).replacen(\n+                            \"include_str\",\n+                            \"include_bytes\",\n+                            1,\n+                        ),\n+                        applicability,\n+                    );\n+                } else if lit_content.as_str().is_ascii()\n+                    && lit_content.as_str().len() <= MAX_LENGTH_BYTE_STRING_LIT\n+                    && !args[0].span.from_expansion()\n+                {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        STRING_LIT_AS_BYTES,\n+                        e.span,\n+                        \"calling `as_bytes()` on a string literal\",\n+                        \"consider using a byte string literal instead\",\n+                        format!(\n+                            \"b{}\",\n+                            snippet_with_applicability(cx, args[0].span, r#\"\"foo\"\"#, &mut applicability)\n+                        ),\n+                        applicability,\n+                    );\n                 }\n             }\n         }"}, {"sha": "7ad272ade5f9c6bb6fbde13e3182a28b47cff0a3", "filename": "tests/ui/string_lit_as_bytes.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d33ad45d7da3da94514351b322aba5052a393202/tests%2Fui%2Fstring_lit_as_bytes.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d33ad45d7da3da94514351b322aba5052a393202/tests%2Fui%2Fstring_lit_as_bytes.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstring_lit_as_bytes.fixed?ref=d33ad45d7da3da94514351b322aba5052a393202", "patch": "@@ -15,6 +15,8 @@ fn str_lit_as_bytes() {\n     let strify = stringify!(foobar).as_bytes();\n \n     let includestr = include_bytes!(\"entry_unfixable.rs\");\n+\n+    let _ = b\"string with newline\\t\\n\";\n }\n \n fn main() {}"}, {"sha": "1bf4538b7c94f25069289340e53ae4d8819b9142", "filename": "tests/ui/string_lit_as_bytes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d33ad45d7da3da94514351b322aba5052a393202/tests%2Fui%2Fstring_lit_as_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d33ad45d7da3da94514351b322aba5052a393202/tests%2Fui%2Fstring_lit_as_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstring_lit_as_bytes.rs?ref=d33ad45d7da3da94514351b322aba5052a393202", "patch": "@@ -15,6 +15,8 @@ fn str_lit_as_bytes() {\n     let strify = stringify!(foobar).as_bytes();\n \n     let includestr = include_str!(\"entry_unfixable.rs\").as_bytes();\n+\n+    let _ = \"string with newline\\t\\n\".as_bytes();\n }\n \n fn main() {}"}, {"sha": "ff6e3346dfc756e6112e9a8d1f6128236b0261e1", "filename": "tests/ui/string_lit_as_bytes.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d33ad45d7da3da94514351b322aba5052a393202/tests%2Fui%2Fstring_lit_as_bytes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d33ad45d7da3da94514351b322aba5052a393202/tests%2Fui%2Fstring_lit_as_bytes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstring_lit_as_bytes.stderr?ref=d33ad45d7da3da94514351b322aba5052a393202", "patch": "@@ -18,5 +18,11 @@ error: calling `as_bytes()` on `include_str!(..)`\n LL |     let includestr = include_str!(\"entry_unfixable.rs\").as_bytes();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `include_bytes!(..)` instead: `include_bytes!(\"entry_unfixable.rs\")`\n \n-error: aborting due to 3 previous errors\n+error: calling `as_bytes()` on a string literal\n+  --> $DIR/string_lit_as_bytes.rs:19:13\n+   |\n+LL |     let _ = \"string with newline/t/n\".as_bytes();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using a byte string literal instead: `b\"string with newline/t/n\"`\n+\n+error: aborting due to 4 previous errors\n "}]}