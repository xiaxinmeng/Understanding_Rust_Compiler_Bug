{"sha": "746a0051c3d61ef89ed8b8a118509fd407a69344", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0NmEwMDUxYzNkNjFlZjg5ZWQ4YjhhMTE4NTA5ZmQ0MDdhNjkzNDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-14T15:56:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-14T15:56:07Z"}, "message": "Auto merge of #7640 - kneasle:mut-key-false-positive, r=camsteffen\n\nImprove accuracy of `mut_key`\n\nFixes #6745.\n\nWhilst writing the tests for this, I noticed what I believe is a false negative (the code in `@xFrednet's` [comment](https://github.com/rust-lang/rust-clippy/issues/6745#issuecomment-909658267) doesn't trigger the lint).  Currently the tests contain a case for this (which is blatantly ignored), but I'm not at all sure how to implement this (since the lint currently behaves completely differently for ADTs).  I'm not sure what should be done - on the one hand the extra test cases are misleading, but on the other hand they don't cause much harm and would save effort for anyone fixing that false negative.\n\n---\n\nchangelog: Improve accuracy of `clippy::mutable_key_type`.", "tree": {"sha": "1b3679fd4d4a20b56266b21e458277d388060220", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b3679fd4d4a20b56266b21e458277d388060220"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/746a0051c3d61ef89ed8b8a118509fd407a69344", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/746a0051c3d61ef89ed8b8a118509fd407a69344", "html_url": "https://github.com/rust-lang/rust/commit/746a0051c3d61ef89ed8b8a118509fd407a69344", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/746a0051c3d61ef89ed8b8a118509fd407a69344/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7680c9ba6ce472d10e4845fe354f186c00d28a74", "url": "https://api.github.com/repos/rust-lang/rust/commits/7680c9ba6ce472d10e4845fe354f186c00d28a74", "html_url": "https://github.com/rust-lang/rust/commit/7680c9ba6ce472d10e4845fe354f186c00d28a74"}, {"sha": "b2ffb28da582d160f0689e6540a212d6d2bfabc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2ffb28da582d160f0689e6540a212d6d2bfabc5", "html_url": "https://github.com/rust-lang/rust/commit/b2ffb28da582d160f0689e6540a212d6d2bfabc5"}], "stats": {"total": 203, "additions": 176, "deletions": 27}, "files": [{"sha": "cb17e4dbfd0da8cdcf3930b9b32b4e88e5174a78", "filename": "clippy_lints/src/mut_key.rs", "status": "modified", "additions": 61, "deletions": 20, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/746a0051c3d61ef89ed8b8a118509fd407a69344/clippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/746a0051c3d61ef89ed8b8a118509fd407a69344/clippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_key.rs?ref=746a0051c3d61ef89ed8b8a118509fd407a69344", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::trait_ref_of_method;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::TypeFoldable;\n-use rustc_middle::ty::{Adt, Array, RawPtr, Ref, Slice, Tuple, Ty, TypeAndMut};\n+use rustc_middle::ty::{Adt, Array, Ref, Slice, Tuple, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::sym;\n@@ -19,10 +19,29 @@ declare_clippy_lint! {\n     /// so having types with interior mutability is a bad idea.\n     ///\n     /// ### Known problems\n-    /// It's correct to use a struct, that contains interior mutability\n-    /// as a key, when its `Hash` implementation doesn't access any of the interior mutable types.\n-    /// However, this lint is unable to recognize this, so it causes a false positive in theses cases.\n-    /// The `bytes` crate is a great example of this.\n+    ///\n+    /// #### False Positives\n+    /// It's correct to use a struct that contains interior mutability as a key, when its\n+    /// implementation of `Hash` or `Ord` doesn't access any of the interior mutable types.\n+    /// However, this lint is unable to recognize this, so it will often cause false positives in\n+    /// theses cases.  The `bytes` crate is a great example of this.\n+    ///\n+    /// #### False Negatives\n+    /// For custom `struct`s/`enum`s, this lint is unable to check for interior mutability behind\n+    /// indirection.  For example, `struct BadKey<'a>(&'a Cell<usize>)` will be seen as immutable\n+    /// and cause a false negative if its implementation of `Hash`/`Ord` accesses the `Cell`.\n+    ///\n+    /// This lint does check a few cases for indirection.  Firstly, using some standard library\n+    /// types (`Option`, `Result`, `Box`, `Rc`, `Arc`, `Vec`, `VecDeque`, `BTreeMap` and\n+    /// `BTreeSet`) directly as keys (e.g. in `HashMap<Box<Cell<usize>>, ()>`) **will** trigger the\n+    /// lint, because the impls of `Hash`/`Ord` for these types directly call `Hash`/`Ord` on their\n+    /// contained type.\n+    ///\n+    /// Secondly, the implementations of `Hash` and `Ord` for raw pointers (`*const T` or `*mut T`)\n+    /// apply only to the **address** of the contained value.  Therefore, interior mutability\n+    /// behind raw pointers (e.g. in `HashSet<*mut Cell<usize>>`) can't impact the value of `Hash`\n+    /// or `Ord`, and therefore will not trigger this link.  For more info, see issue\n+    /// [#6745](https://github.com/rust-lang/rust-clippy/issues/6745).\n     ///\n     /// ### Example\n     /// ```rust\n@@ -103,30 +122,52 @@ fn check_sig<'tcx>(cx: &LateContext<'tcx>, item_hir_id: hir::HirId, decl: &hir::\n fn check_ty<'tcx>(cx: &LateContext<'tcx>, span: Span, ty: Ty<'tcx>) {\n     let ty = ty.peel_refs();\n     if let Adt(def, substs) = ty.kind() {\n-        if [sym::hashmap_type, sym::BTreeMap, sym::hashset_type, sym::BTreeMap]\n+        let is_keyed_type = [sym::hashmap_type, sym::BTreeMap, sym::hashset_type, sym::BTreeSet]\n             .iter()\n-            .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def.did))\n-            && is_mutable_type(cx, substs.type_at(0), span)\n-        {\n+            .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def.did));\n+        if is_keyed_type && is_interior_mutable_type(cx, substs.type_at(0), span) {\n             span_lint(cx, MUTABLE_KEY_TYPE, span, \"mutable key type\");\n         }\n     }\n }\n \n-fn is_mutable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span) -> bool {\n+/// Determines if a type contains interior mutability which would affect its implementation of\n+/// [`Hash`] or [`Ord`].\n+fn is_interior_mutable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span) -> bool {\n     match *ty.kind() {\n-        RawPtr(TypeAndMut { ty: inner_ty, mutbl }) | Ref(_, inner_ty, mutbl) => {\n-            mutbl == hir::Mutability::Mut || is_mutable_type(cx, inner_ty, span)\n-        },\n-        Slice(inner_ty) => is_mutable_type(cx, inner_ty, span),\n+        Ref(_, inner_ty, mutbl) => mutbl == hir::Mutability::Mut || is_interior_mutable_type(cx, inner_ty, span),\n+        Slice(inner_ty) => is_interior_mutable_type(cx, inner_ty, span),\n         Array(inner_ty, size) => {\n-            size.try_eval_usize(cx.tcx, cx.param_env).map_or(true, |u| u != 0) && is_mutable_type(cx, inner_ty, span)\n+            size.try_eval_usize(cx.tcx, cx.param_env).map_or(true, |u| u != 0)\n+                && is_interior_mutable_type(cx, inner_ty, span)\n         },\n-        Tuple(..) => ty.tuple_fields().any(|ty| is_mutable_type(cx, ty, span)),\n-        Adt(..) => {\n-            !ty.has_escaping_bound_vars()\n-                && cx.tcx.layout_of(cx.param_env.and(ty)).is_ok()\n-                && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n+        Tuple(..) => ty.tuple_fields().any(|ty| is_interior_mutable_type(cx, ty, span)),\n+        Adt(def, substs) => {\n+            // Special case for collections in `std` who's impl of `Hash` or `Ord` delegates to\n+            // that of their type parameters.  Note: we don't include `HashSet` and `HashMap`\n+            // because they have no impl for `Hash` or `Ord`.\n+            let is_std_collection = [\n+                sym::option_type,\n+                sym::result_type,\n+                sym::LinkedList,\n+                sym::vec_type,\n+                sym::vecdeque_type,\n+                sym::BTreeMap,\n+                sym::BTreeSet,\n+                sym::Rc,\n+                sym::Arc,\n+            ]\n+            .iter()\n+            .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def.did));\n+            let is_box = Some(def.did) == cx.tcx.lang_items().owned_box();\n+            if is_std_collection || is_box {\n+                // The type is mutable if any of its type parameters are\n+                substs.types().any(|ty| is_interior_mutable_type(cx, ty, span))\n+            } else {\n+                !ty.has_escaping_bound_vars()\n+                    && cx.tcx.layout_of(cx.param_env.and(ty)).is_ok()\n+                    && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n+            }\n         },\n         _ => false,\n     }"}, {"sha": "1c0ba664580a40d253923a2ec937db47efac8049", "filename": "tests/ui/mut_key.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/746a0051c3d61ef89ed8b8a118509fd407a69344/tests%2Fui%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/746a0051c3d61ef89ed8b8a118509fd407a69344/tests%2Fui%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_key.rs?ref=746a0051c3d61ef89ed8b8a118509fd407a69344", "patch": "@@ -1,6 +1,9 @@\n-use std::collections::{HashMap, HashSet};\n+use std::cell::Cell;\n+use std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};\n use std::hash::{Hash, Hasher};\n+use std::rc::Rc;\n use std::sync::atomic::{AtomicUsize, Ordering::Relaxed};\n+use std::sync::Arc;\n \n struct Key(AtomicUsize);\n \n@@ -31,11 +34,19 @@ fn should_not_take_this_arg(m: &mut HashMap<Key, usize>, _n: usize) -> HashSet<K\n \n fn this_is_ok(_m: &mut HashMap<usize, Key>) {}\n \n+// Raw pointers are hashed by the address they point to, so it doesn't matter if they point to a\n+// type with interior mutability.  See:\n+// - clippy issue: https://github.com/rust-lang/rust-clippy/issues/6745\n+// - std lib: https://github.com/rust-lang/rust/blob/1.54.0/library/core/src/hash/mod.rs#L717-L736\n+// So these are OK:\n+fn raw_ptr_is_ok(_m: &mut HashMap<*const Key, ()>) {}\n+fn raw_mut_ptr_is_ok(_m: &mut HashMap<*mut Key, ()>) {}\n+\n #[allow(unused)]\n trait Trait {\n     type AssociatedType;\n \n-    fn trait_fn(&self, set: std::collections::HashSet<Self::AssociatedType>);\n+    fn trait_fn(&self, set: HashSet<Self::AssociatedType>);\n }\n \n fn generics_are_ok_too<K>(_m: &mut HashSet<K>) {\n@@ -52,4 +63,23 @@ fn main() {\n     tuples::<Key>(&mut HashMap::new());\n     tuples::<()>(&mut HashMap::new());\n     tuples_bad::<()>(&mut HashMap::new());\n+\n+    raw_ptr_is_ok(&mut HashMap::new());\n+    raw_mut_ptr_is_ok(&mut HashMap::new());\n+\n+    let _map = HashMap::<Cell<usize>, usize>::new();\n+    let _map = HashMap::<&mut Cell<usize>, usize>::new();\n+    let _map = HashMap::<&mut usize, usize>::new();\n+    // Collection types from `std` who's impl of `Hash` or `Ord` delegate their type parameters\n+    let _map = HashMap::<Vec<Cell<usize>>, usize>::new();\n+    let _map = HashMap::<BTreeMap<Cell<usize>, ()>, usize>::new();\n+    let _map = HashMap::<BTreeMap<(), Cell<usize>>, usize>::new();\n+    let _map = HashMap::<BTreeSet<Cell<usize>>, usize>::new();\n+    let _map = HashMap::<Option<Cell<usize>>, usize>::new();\n+    let _map = HashMap::<Option<Vec<Cell<usize>>>, usize>::new();\n+    let _map = HashMap::<Result<&mut usize, ()>, usize>::new();\n+    // Smart pointers from `std` who's impl of `Hash` or `Ord` delegate their type parameters\n+    let _map = HashMap::<Box<Cell<usize>>, usize>::new();\n+    let _map = HashMap::<Rc<Cell<usize>>, usize>::new();\n+    let _map = HashMap::<Arc<Cell<usize>>, usize>::new();\n }"}, {"sha": "25dd029b16eeea1e13b5e773613ddf27e106bd4e", "filename": "tests/ui/mut_key.stderr", "status": "modified", "additions": 83, "deletions": 5, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/746a0051c3d61ef89ed8b8a118509fd407a69344/tests%2Fui%2Fmut_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/746a0051c3d61ef89ed8b8a118509fd407a69344/tests%2Fui%2Fmut_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_key.stderr?ref=746a0051c3d61ef89ed8b8a118509fd407a69344", "patch": "@@ -1,28 +1,106 @@\n error: mutable key type\n-  --> $DIR/mut_key.rs:27:32\n+  --> $DIR/mut_key.rs:30:32\n    |\n LL | fn should_not_take_this_arg(m: &mut HashMap<Key, usize>, _n: usize) -> HashSet<Key> {\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::mutable-key-type` implied by `-D warnings`\n \n error: mutable key type\n-  --> $DIR/mut_key.rs:27:72\n+  --> $DIR/mut_key.rs:30:72\n    |\n LL | fn should_not_take_this_arg(m: &mut HashMap<Key, usize>, _n: usize) -> HashSet<Key> {\n    |                                                                        ^^^^^^^^^^^^\n \n error: mutable key type\n-  --> $DIR/mut_key.rs:28:5\n+  --> $DIR/mut_key.rs:31:5\n    |\n LL |     let _other: HashMap<Key, bool> = HashMap::new();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: mutable key type\n-  --> $DIR/mut_key.rs:47:22\n+  --> $DIR/mut_key.rs:58:22\n    |\n LL | fn tuples_bad<U>(_m: &mut HashMap<(Key, U), bool>) {}\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 4 previous errors\n+error: mutable key type\n+  --> $DIR/mut_key.rs:70:5\n+   |\n+LL |     let _map = HashMap::<Cell<usize>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:71:5\n+   |\n+LL |     let _map = HashMap::<&mut Cell<usize>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:72:5\n+   |\n+LL |     let _map = HashMap::<&mut usize, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:74:5\n+   |\n+LL |     let _map = HashMap::<Vec<Cell<usize>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:75:5\n+   |\n+LL |     let _map = HashMap::<BTreeMap<Cell<usize>, ()>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:76:5\n+   |\n+LL |     let _map = HashMap::<BTreeMap<(), Cell<usize>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:77:5\n+   |\n+LL |     let _map = HashMap::<BTreeSet<Cell<usize>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:78:5\n+   |\n+LL |     let _map = HashMap::<Option<Cell<usize>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:79:5\n+   |\n+LL |     let _map = HashMap::<Option<Vec<Cell<usize>>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:80:5\n+   |\n+LL |     let _map = HashMap::<Result<&mut usize, ()>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:82:5\n+   |\n+LL |     let _map = HashMap::<Box<Cell<usize>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:83:5\n+   |\n+LL |     let _map = HashMap::<Rc<Cell<usize>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:84:5\n+   |\n+LL |     let _map = HashMap::<Arc<Cell<usize>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 17 previous errors\n "}]}