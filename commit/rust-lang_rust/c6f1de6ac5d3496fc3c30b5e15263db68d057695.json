{"sha": "c6f1de6ac5d3496fc3c30b5e15263db68d057695", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2ZjFkZTZhYzVkMzQ5NmZjM2MzMGI1ZTE1MjYzZGI2OGQwNTc2OTU=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-06T19:05:57Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-06T19:25:39Z"}, "message": "Use FamousDefs for shorten_iterator hint", "tree": {"sha": "34671d8f6785c5505edace7853372f192d26f810", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34671d8f6785c5505edace7853372f192d26f810"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6f1de6ac5d3496fc3c30b5e15263db68d057695", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6f1de6ac5d3496fc3c30b5e15263db68d057695", "html_url": "https://github.com/rust-lang/rust/commit/c6f1de6ac5d3496fc3c30b5e15263db68d057695", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6f1de6ac5d3496fc3c30b5e15263db68d057695/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aaa3905fdd18a7981d40ac371099ae9044e833a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/aaa3905fdd18a7981d40ac371099ae9044e833a8", "html_url": "https://github.com/rust-lang/rust/commit/aaa3905fdd18a7981d40ac371099ae9044e833a8"}], "stats": {"total": 154, "additions": 85, "deletions": 69}, "files": [{"sha": "0335969fd91b8d15e82d367bf9616640639089f3", "filename": "crates/assists/src/utils.rs", "status": "modified", "additions": 49, "deletions": 12, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c6f1de6ac5d3496fc3c30b5e15263db68d057695/crates%2Fassists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6f1de6ac5d3496fc3c30b5e15263db68d057695/crates%2Fassists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils.rs?ref=c6f1de6ac5d3496fc3c30b5e15263db68d057695", "patch": "@@ -274,24 +274,54 @@ impl TryEnum {\n /// somewhat similar to the known paths infra inside hir, but it different; We\n /// want to make sure that IDE specific paths don't become interesting inside\n /// the compiler itself as well.\n-pub(crate) struct FamousDefs<'a, 'b>(pub(crate) &'a Semantics<'b, RootDatabase>, pub(crate) Crate);\n+pub struct FamousDefs<'a, 'b>(pub &'a Semantics<'b, RootDatabase>, pub Crate);\n \n #[allow(non_snake_case)]\n impl FamousDefs<'_, '_> {\n-    #[cfg(test)]\n-    pub(crate) const FIXTURE: &'static str = r#\"//- /libcore.rs crate:core\n+    pub const FIXTURE: &'static str = r#\"//- /libcore.rs crate:core\n pub mod convert {\n     pub trait From<T> {\n         fn from(T) -> Self;\n     }\n }\n \n+pub mod iter {\n+    pub use self::traits::iterator::Iterator;\n+    mod traits { mod iterator {\n+        use crate::option::Option;\n+        pub trait Iterator {\n+            type Item;\n+            fn next(&mut self) -> Option<Self::Item>;\n+        }\n+    } }\n+\n+    pub use self::sources::*;\n+    mod sources {\n+        use super::Iterator;\n+        pub struct Repeat<A> {\n+            element: A,\n+        }\n+\n+        pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n+            Repeat { element: elt }\n+        }\n+\n+        impl<A: Clone> Iterator for Repeat<A> {\n+            type Item = A;\n+\n+            fn next(&mut self) -> Option<A> {\n+                Some(self.element.clone())\n+            }\n+        }\n+    }\n+}\n+\n pub mod option {\n     pub enum Option<T> { None, Some(T)}\n }\n \n pub mod prelude {\n-    pub use crate::{convert::From, option::Option::{self, *}};\n+    pub use crate::{convert::From, iter::Iterator, option::Option::{self, *}};\n }\n #[prelude_import]\n pub use prelude::*;\n@@ -305,6 +335,10 @@ pub use prelude::*;\n         self.find_enum(\"core:option:Option\")\n     }\n \n+    pub fn core_iter_Iterator(&self) -> Option<Trait> {\n+        self.find_trait(\"core:iter:traits:iterator:Iterator\")\n+    }\n+\n     fn find_trait(&self, path: &str) -> Option<Trait> {\n         match self.find_def(path)? {\n             hir::ScopeDef::ModuleDef(hir::ModuleDef::Trait(it)) => Some(it),\n@@ -324,26 +358,29 @@ pub use prelude::*;\n         let mut path = path.split(':');\n         let trait_ = path.next_back()?;\n         let std_crate = path.next()?;\n-        let std_crate = self\n+        let std_crate = if self\n             .1\n-            .dependencies(db)\n-            .into_iter()\n-            .find(|dep| &dep.name.to_string() == std_crate)?\n-            .krate;\n-\n+            .declaration_name(db)\n+            .map(|name| name.to_string() == std_crate)\n+            .unwrap_or(false)\n+        {\n+            self.1\n+        } else {\n+            self.1.dependencies(db).into_iter().find(|dep| dep.name.to_string() == std_crate)?.krate\n+        };\n         let mut module = std_crate.root_module(db);\n         for segment in path {\n             module = module.children(db).find_map(|child| {\n                 let name = child.name(db)?;\n-                if &name.to_string() == segment {\n+                if name.to_string() == segment {\n                     Some(child)\n                 } else {\n                     None\n                 }\n             })?;\n         }\n         let def =\n-            module.scope(db, None).into_iter().find(|(name, _def)| &name.to_string() == trait_)?.1;\n+            module.scope(db, None).into_iter().find(|(name, _def)| name.to_string() == trait_)?.1;\n         Some(def)\n     }\n }"}, {"sha": "27bd1e37f4bea918d7a6410a13b8b366d1f6e48b", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 36, "deletions": 57, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/c6f1de6ac5d3496fc3c30b5e15263db68d057695/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6f1de6ac5d3496fc3c30b5e15263db68d057695/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=c6f1de6ac5d3496fc3c30b5e15263db68d057695", "patch": "@@ -1,4 +1,5 @@\n-use hir::{known, Adt, AssocItem, Callable, HirDisplay, ModuleDef, Semantics, Type};\n+use assists::utils::FamousDefs;\n+use hir::{known, Adt, AssocItem, Callable, HirDisplay, Semantics, Type};\n use ide_db::RootDatabase;\n use stdx::to_lower_snake_case;\n use syntax::{\n@@ -194,7 +195,7 @@ fn get_bind_pat_hints(\n     }\n \n     let db = sema.db;\n-    if let Some(hint) = hint_iterator(db, config, &ty, pat.clone()) {\n+    if let Some(hint) = hint_iterator(sema, config, &ty, pat.clone()) {\n         acc.push(hint);\n     } else {\n         acc.push(InlayHint {\n@@ -209,45 +210,44 @@ fn get_bind_pat_hints(\n \n /// Checks if the type is an Iterator from std::iter and replaces its hint with an `impl Iterator<Item = Ty>`.\n fn hint_iterator(\n-    db: &RootDatabase,\n+    sema: &Semantics<RootDatabase>,\n     config: &InlayHintsConfig,\n     ty: &Type,\n     pat: ast::IdentPat,\n ) -> Option<InlayHint> {\n+    let db = sema.db;\n     let strukt = ty.as_adt()?;\n     let krate = strukt.krate(db)?;\n-    let module = strukt.module(db);\n     if krate.declaration_name(db).as_deref() != Some(\"core\") {\n         return None;\n     }\n-    let module = module\n+    // assert this type comes from `core::iter`\n+    strukt\n+        .module(db)\n         .path_to_root(db)\n         .into_iter()\n         .rev()\n         .find(|module| module.name(db) == Some(known::iter))?;\n-    let iter_trait = module.scope(db, None).into_iter().find_map(|(name, def)| match def {\n-        hir::ScopeDef::ModuleDef(ModuleDef::Trait(r#trait)) if name == known::Iterator => {\n-            Some(r#trait)\n-        }\n-        _ => None,\n-    })?;\n+    let iter_trait = FamousDefs(sema, krate).core_iter_Iterator()?;\n     if ty.impls_trait(db, iter_trait, &[]) {\n         let assoc_type_item = iter_trait.items(db).into_iter().find_map(|item| match item {\n             AssocItem::TypeAlias(alias) if alias.name(db) == known::Item => Some(alias),\n             _ => None,\n         })?;\n         if let Some(ty) = ty.normalize_trait_assoc_type(db, iter_trait, &[], assoc_type_item) {\n+            const LABEL_START: &str = \"impl Iterator<Item = \";\n+            const LABEL_END: &str = \">\";\n+\n+            let ty_display = ty.display_truncated(\n+                db,\n+                config\n+                    .max_length\n+                    .map(|len| len.saturating_sub(LABEL_START.len() + LABEL_END.len())),\n+            );\n             return Some(InlayHint {\n                 range: pat.syntax().text_range(),\n                 kind: InlayKind::TypeHint,\n-                label: format!(\n-                    \"impl Iterator<Item = {}>\",\n-                    ty.display_truncated(\n-                        db,\n-                        config.max_length.map(|len| len - 22 /*len of the template string above*/)\n-                    )\n-                )\n-                .into(),\n+                label: format!(\"{}{}{}\", LABEL_START, ty_display, LABEL_END).into(),\n             });\n         }\n     }\n@@ -401,6 +401,7 @@ fn get_callable(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<Call\n \n #[cfg(test)]\n mod tests {\n+    use assists::utils::FamousDefs;\n     use expect_test::{expect, Expect};\n     use test_utils::extract_annotations;\n \n@@ -1124,15 +1125,26 @@ fn main() {\n                 chaining_hints: true,\n                 max_length: None,\n             },\n-            r#\"\n+            &format!(\n+                \"{}\\n{}\\n\",\n+                r#\"\n //- /main.rs crate:main deps:std\n use std::{Option::{self, Some, None}, iter};\n \n+struct MyIter;\n+\n+impl iter::Iterator for MyIter {\n+    type Item = ();\n+    fn next(&mut self) -> Option<Self::Item> {\n+        None\n+    }\n+}\n+\n fn main() {\n+    let _x = MyIter;\n+      //^^ MyIter\n     let _x = iter::repeat(0);\n       //^^ impl Iterator<Item = i32>\n-    let _y = iter::Chain(iter::repeat(0), iter::repeat(0));\n-      //^^ impl Iterator<Item = i32>\n     fn generic<T: Clone>(t: T) {\n         let _x = iter::repeat(t);\n           //^^ impl Iterator<Item = T>\n@@ -1141,42 +1153,9 @@ fn main() {\n \n //- /std.rs crate:std deps:core\n use core::*;\n-\n-//- /core.rs crate:core\n-pub enum Option<T> {\n-    Some(T),\n-    None\n-}\n-\n-pub mod iter {\n-    pub use self::traits::iterator::Iterator;\n-    pub mod traits { pub mod iterator {\n-        pub trait Iterator {\n-            type Item;\n-        }\n-    } }\n-\n-    pub use self::sources::*;\n-    pub mod sources {\n-        use super::Iterator;\n-        pub struct Repeat<T: Clone>(pub T);\n-\n-        pub fn repeat<T: Clone>(t: T) -> Repeat<T> {\n-            Repeat(f)\n-        }\n-\n-        impl<T: Clone> Iterator for Repeat<T> {\n-            type Item = T;\n-        }\n-\n-        pub struct Chain<A, B>(pub A, pub B);\n-\n-        impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item = T>, B: Iterator<Item = T> {\n-            type Item = T;\n-        }\n-    }\n-}\n \"#,\n+                FamousDefs::FIXTURE\n+            ),\n         );\n     }\n }"}]}