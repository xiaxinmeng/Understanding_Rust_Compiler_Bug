{"sha": "b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0MmVhN2Y5ZWYwNmJlOWE2MjNhOGEwMDdhZTNhZWNiYjdkOTYxYTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-02T05:06:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-02T05:06:37Z"}, "message": "auto merge of #6174 : sanxiyn/rust/static-string, r=brson", "tree": {"sha": "05b704784e114cfe7a488705c87085c73cdaa384", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05b704784e114cfe7a488705c87085c73cdaa384"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3", "html_url": "https://github.com/rust-lang/rust/commit/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efcabc41e4ab4dbabd3f6d0954b5a1184ad75e8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/efcabc41e4ab4dbabd3f6d0954b5a1184ad75e8b", "html_url": "https://github.com/rust-lang/rust/commit/efcabc41e4ab4dbabd3f6d0954b5a1184ad75e8b"}, {"sha": "4294aed01ba4836cf0d40d5422e5a404b467dcca", "url": "https://api.github.com/repos/rust-lang/rust/commits/4294aed01ba4836cf0d40d5422e5a404b467dcca", "html_url": "https://github.com/rust-lang/rust/commit/4294aed01ba4836cf0d40d5422e5a404b467dcca"}], "stats": {"total": 292, "additions": 146, "deletions": 146}, "files": [{"sha": "237b03bc20fb377aa44e837a58c39f2af42c4b64", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3", "patch": "@@ -175,16 +175,16 @@ pub struct Session_ {\n pub type Session = @Session_;\n \n pub impl Session_ {\n-    fn span_fatal(@self, sp: span, msg: ~str) -> ! {\n+    fn span_fatal(@self, sp: span, msg: &str) -> ! {\n         self.span_diagnostic.span_fatal(sp, msg)\n     }\n-    fn fatal(@self, msg: ~str) -> ! {\n+    fn fatal(@self, msg: &str) -> ! {\n         self.span_diagnostic.handler().fatal(msg)\n     }\n-    fn span_err(@self, sp: span, msg: ~str) {\n+    fn span_err(@self, sp: span, msg: &str) {\n         self.span_diagnostic.span_err(sp, msg)\n     }\n-    fn err(@self, msg: ~str) {\n+    fn err(@self, msg: &str) {\n         self.span_diagnostic.handler().err(msg)\n     }\n     fn has_errors(@self) -> bool {\n@@ -193,31 +193,31 @@ pub impl Session_ {\n     fn abort_if_errors(@self) {\n         self.span_diagnostic.handler().abort_if_errors()\n     }\n-    fn span_warn(@self, sp: span, msg: ~str) {\n+    fn span_warn(@self, sp: span, msg: &str) {\n         self.span_diagnostic.span_warn(sp, msg)\n     }\n-    fn warn(@self, msg: ~str) {\n+    fn warn(@self, msg: &str) {\n         self.span_diagnostic.handler().warn(msg)\n     }\n-    fn span_note(@self, sp: span, msg: ~str) {\n+    fn span_note(@self, sp: span, msg: &str) {\n         self.span_diagnostic.span_note(sp, msg)\n     }\n-    fn note(@self, msg: ~str) {\n+    fn note(@self, msg: &str) {\n         self.span_diagnostic.handler().note(msg)\n     }\n-    fn span_bug(@self, sp: span, msg: ~str) -> ! {\n+    fn span_bug(@self, sp: span, msg: &str) -> ! {\n         self.span_diagnostic.span_bug(sp, msg)\n     }\n-    fn bug(@self, msg: ~str) -> ! {\n+    fn bug(@self, msg: &str) -> ! {\n         self.span_diagnostic.handler().bug(msg)\n     }\n-    fn span_unimpl(@self, sp: span, msg: ~str) -> ! {\n+    fn span_unimpl(@self, sp: span, msg: &str) -> ! {\n         self.span_diagnostic.span_unimpl(sp, msg)\n     }\n-    fn unimpl(@self, msg: ~str) -> ! {\n+    fn unimpl(@self, msg: &str) -> ! {\n         self.span_diagnostic.handler().unimpl(msg)\n     }\n-    fn span_lint_level(@self, level: lint::level, sp: span, msg: ~str) {\n+    fn span_lint_level(@self, level: lint::level, sp: span, msg: &str) {\n         match level {\n           lint::allow => { },\n           lint::warn => self.span_warn(sp, msg),\n@@ -230,7 +230,7 @@ pub impl Session_ {\n                  expr_id: ast::node_id,\n                  item_id: ast::node_id,\n                  span: span,\n-                 msg: ~str) {\n+                 msg: &str) {\n         let level = lint::get_lint_settings_level(\n             self.lint_settings, lint_mode, expr_id, item_id);\n         self.span_lint_level(level, span, msg);"}, {"sha": "4e21fcb5bd97dce13d846235d3cefd9a5f3bc59a", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3", "patch": "@@ -92,13 +92,13 @@ pub fn check_expr(sess: Session,\n           expr_unary(deref, _) => { }\n           expr_unary(box(_), _) | expr_unary(uniq(_), _) => {\n             sess.span_err(e.span,\n-                          ~\"disallowed operator in constant expression\");\n+                          \"disallowed operator in constant expression\");\n             return;\n           }\n           expr_lit(@codemap::spanned {node: lit_str(_), _}) => { }\n           expr_binary(_, _, _) | expr_unary(_, _) => {\n             if method_map.contains_key(&e.id) {\n-                sess.span_err(e.span, ~\"user-defined operators are not \\\n+                sess.span_err(e.span, \"user-defined operators are not \\\n                                        allowed in constant expressions\");\n             }\n           }\n@@ -118,8 +118,8 @@ pub fn check_expr(sess: Session,\n             // a path in trans::callee that only works in block contexts.\n             if pth.types.len() != 0 {\n                 sess.span_err(\n-                    e.span, ~\"paths in constants may only refer to \\\n-                              items without type parameters\");\n+                    e.span, \"paths in constants may only refer to \\\n+                             items without type parameters\");\n             }\n             match def_map.find(&e.id) {\n               Some(&def_const(_)) |\n@@ -131,11 +131,11 @@ pub fn check_expr(sess: Session,\n                 debug!(\"(checking const) found bad def: %?\", def);\n                 sess.span_err(\n                     e.span,\n-                    fmt!(\"paths in constants may only refer to \\\n-                          constants or functions\"));\n+                    \"paths in constants may only refer to \\\n+                     constants or functions\");\n               }\n               None => {\n-                sess.span_bug(e.span, ~\"unbound path in const?!\");\n+                sess.span_bug(e.span, \"unbound path in const?!\");\n               }\n             }\n           }\n@@ -146,8 +146,8 @@ pub fn check_expr(sess: Session,\n                 _ => {\n                     sess.span_err(\n                         e.span,\n-                        ~\"function calls in constants are limited to \\\n-                          struct and enum constructors\");\n+                        \"function calls in constants are limited to \\\n+                         struct and enum constructors\");\n                 }\n             }\n           }\n@@ -163,12 +163,12 @@ pub fn check_expr(sess: Session,\n           expr_addr_of(*) => {\n                 sess.span_err(\n                     e.span,\n-                    ~\"borrowed pointers in constants may only refer to \\\n-                      immutable values\");\n+                    \"borrowed pointers in constants may only refer to \\\n+                     immutable values\");\n           }\n           _ => {\n             sess.span_err(e.span,\n-                          ~\"constant contains unimplemented expression type\");\n+                          \"constant contains unimplemented expression type\");\n             return;\n           }\n         }\n@@ -178,14 +178,14 @@ pub fn check_expr(sess: Session,\n         if t != ty_char {\n             if (v as u64) > ast_util::int_ty_max(\n                 if t == ty_i { sess.targ_cfg.int_type } else { t }) {\n-                sess.span_err(e.span, ~\"literal out of range for its type\");\n+                sess.span_err(e.span, \"literal out of range for its type\");\n             }\n         }\n       }\n       expr_lit(@codemap::spanned {node: lit_uint(v, t), _}) => {\n         if v > ast_util::uint_ty_max(\n             if t == ty_u { sess.targ_cfg.uint_type } else { t }) {\n-            sess.span_err(e.span, ~\"literal out of range for its type\");\n+            sess.span_err(e.span, \"literal out of range for its type\");\n         }\n       }\n       _ => ()\n@@ -224,7 +224,7 @@ pub fn check_item_recursion(sess: Session,\n \n     fn visit_item(it: @item, env: env, v: visit::vt<env>) {\n         if env.idstack.contains(&(it.id)) {\n-            env.sess.span_fatal(env.root_it.span, ~\"recursive constant\");\n+            env.sess.span_fatal(env.root_it.span, \"recursive constant\");\n         }\n         env.idstack.push(it.id);\n         visit::visit_item(it, env, v);"}, {"sha": "e3b816fceb8bb49540b66e6e89288fd172c62ec3", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3", "patch": "@@ -54,17 +54,17 @@ pub fn check_crate(tcx: ty::ctxt, crate: @crate) {\n               }\n               expr_break(_) => {\n                 if !cx.in_loop {\n-                    tcx.sess.span_err(e.span, ~\"`break` outside of loop\");\n+                    tcx.sess.span_err(e.span, \"`break` outside of loop\");\n                 }\n               }\n               expr_again(_) => {\n                 if !cx.in_loop {\n-                    tcx.sess.span_err(e.span, ~\"`again` outside of loop\");\n+                    tcx.sess.span_err(e.span, \"`again` outside of loop\");\n                 }\n               }\n               expr_ret(oe) => {\n                 if !cx.can_ret {\n-                    tcx.sess.span_err(e.span, ~\"`return` in block function\");\n+                    tcx.sess.span_err(e.span, \"`return` in block function\");\n                 }\n                 visit::visit_expr_opt(oe, cx, v);\n               }"}, {"sha": "479271cf458dd6fe4e06d4d1def28ca03e193514", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3", "patch": "@@ -94,7 +94,7 @@ pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, s: (), v: visit::vt<()>) {\n        }\n        let arms = vec::concat(arms.filter_mapped(unguarded_pat));\n        if arms.is_empty() {\n-           cx.tcx.sess.span_err(ex.span, ~\"non-exhaustive patterns\");\n+           cx.tcx.sess.span_err(ex.span, \"non-exhaustive patterns\");\n        } else {\n            check_exhaustive(cx, ex.span, arms);\n        }\n@@ -111,7 +111,7 @@ pub fn check_arms(cx: @MatchCheckCtxt, arms: &[arm]) {\n             let v = ~[*pat];\n             match is_useful(cx, &seen, v) {\n               not_useful => {\n-                cx.tcx.sess.span_err(pat.span, ~\"unreachable pattern\");\n+                cx.tcx.sess.span_err(pat.span, \"unreachable pattern\");\n               }\n               _ => ()\n             }\n@@ -685,7 +685,7 @@ pub fn check_local(cx: @MatchCheckCtxt,\n     visit::visit_local(loc, s, v);\n     if is_refutable(cx, loc.node.pat) {\n         cx.tcx.sess.span_err(loc.node.pat.span,\n-                          ~\"refutable pattern in local binding\");\n+                             \"refutable pattern in local binding\");\n     }\n \n     // Check legality of move bindings.\n@@ -708,7 +708,7 @@ pub fn check_fn(cx: @MatchCheckCtxt,\n     for decl.inputs.each |input| {\n         if is_refutable(cx, input.pat) {\n             cx.tcx.sess.span_err(input.pat.span,\n-                              ~\"refutable pattern in function argument\");\n+                                 \"refutable pattern in function argument\");\n         }\n     }\n }\n@@ -780,24 +780,24 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n         if sub.is_some() {\n             tcx.sess.span_err(\n                 p.span,\n-                ~\"cannot bind by-move with sub-bindings\");\n+                \"cannot bind by-move with sub-bindings\");\n         } else if has_guard {\n             tcx.sess.span_err(\n                 p.span,\n-                ~\"cannot bind by-move into a pattern guard\");\n+                \"cannot bind by-move into a pattern guard\");\n         } else if by_ref_span.is_some() {\n             tcx.sess.span_err(\n                 p.span,\n-                ~\"cannot bind by-move and by-ref \\\n-                  in the same pattern\");\n+                \"cannot bind by-move and by-ref \\\n+                 in the same pattern\");\n             tcx.sess.span_note(\n                 by_ref_span.get(),\n-                ~\"by-ref binding occurs here\");\n+                \"by-ref binding occurs here\");\n         } else if is_lvalue {\n             tcx.sess.span_err(\n                 p.span,\n-                ~\"cannot bind by-move when \\\n-                  matching an lvalue\");\n+                \"cannot bind by-move when \\\n+                 matching an lvalue\");\n         }\n     };\n \n@@ -837,9 +837,9 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n                         {\n                             cx.tcx.sess.span_err(\n                                 pat.span,\n-                                ~\"by-move pattern \\\n-                                  bindings may not occur \\\n-                                  behind @ or & bindings\");\n+                                \"by-move pattern \\\n+                                 bindings may not occur \\\n+                                 behind @ or & bindings\");\n                         }\n \n                         match sub {"}, {"sha": "6cdc96f7809a9ef29f1315bd0631eb3ef6a7bb3a", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3", "patch": "@@ -97,21 +97,21 @@ fn check_struct_safe_for_destructor(cx: Context,\n         });\n         if !ty::type_is_owned(cx.tcx, struct_ty) {\n             cx.tcx.sess.span_err(span,\n-                                 ~\"cannot implement a destructor on a struct \\\n-                                   that is not Owned\");\n+                                 \"cannot implement a destructor on a struct \\\n+                                  that is not Owned\");\n             cx.tcx.sess.span_note(span,\n-                                  ~\"use \\\"#[unsafe_destructor]\\\" on the \\\n-                                    implementation to force the compiler to \\\n-                                    allow this\");\n+                                  \"use \\\"#[unsafe_destructor]\\\" on the \\\n+                                   implementation to force the compiler to \\\n+                                   allow this\");\n         }\n     } else {\n         cx.tcx.sess.span_err(span,\n-                             ~\"cannot implement a destructor on a struct \\\n-                               with type parameters\");\n+                             \"cannot implement a destructor on a struct \\\n+                              with type parameters\");\n         cx.tcx.sess.span_note(span,\n-                              ~\"use \\\"#[unsafe_destructor]\\\" on the \\\n-                                implementation to force the compiler to \\\n-                                allow this\");\n+                              \"use \\\"#[unsafe_destructor]\\\" on the \\\n+                               implementation to force the compiler to \\\n+                               allow this\");\n     }\n }\n \n@@ -143,10 +143,10 @@ fn check_item(item: @item, cx: Context, visitor: visit::vt<Context>) {\n                                 }\n                                 _ => {\n                                     cx.tcx.sess.span_bug(self_type.span,\n-                                                         ~\"the self type for \\\n-                                                           the Drop trait \\\n-                                                           impl is not a \\\n-                                                           path\");\n+                                                         \"the self type for \\\n+                                                          the Drop trait \\\n+                                                          impl is not a \\\n+                                                          path\");\n                                 }\n                             }\n                         }\n@@ -193,7 +193,7 @@ fn with_appropriate_checker(cx: Context, id: node_id, b: &fn(check_fn)) {\n     fn check_for_bare(cx: Context, fv: @freevar_entry) {\n         cx.tcx.sess.span_err(\n             fv.span,\n-            ~\"attempted dynamic environment capture\");\n+            \"attempted dynamic environment capture\");\n     }\n \n     let fty = ty::node_id_to_type(cx.tcx, id);\n@@ -409,7 +409,7 @@ fn check_imm_free_var(cx: Context, def: def, sp: span) {\n             if is_mutbl {\n                 cx.tcx.sess.span_err(\n                     sp,\n-                    ~\"mutable variables cannot be implicitly captured\");\n+                    \"mutable variables cannot be implicitly captured\");\n             }\n         }\n         def_arg(*) => { /* ok */ }\n@@ -451,12 +451,12 @@ pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n     if !ty::type_is_durable(tcx, ty) {\n         match ty::get(ty).sty {\n           ty::ty_param(*) => {\n-            tcx.sess.span_err(sp, ~\"value may contain borrowed \\\n-                                    pointers; use `'static` bound\");\n+            tcx.sess.span_err(sp, \"value may contain borrowed \\\n+                                   pointers; use `'static` bound\");\n           }\n           _ => {\n-            tcx.sess.span_err(sp, ~\"value may contain borrowed \\\n-                                    pointers\");\n+            tcx.sess.span_err(sp, \"value may contain borrowed \\\n+                                   pointers\");\n           }\n         }\n         false\n@@ -581,7 +581,7 @@ pub fn check_kind_bounds_of_cast(cx: Context, source: @expr, target: @expr) {\n             if !ty::type_is_owned(cx.tcx, source_ty) {\n                 cx.tcx.sess.span_err(\n                     target.span,\n-                    ~\"uniquely-owned trait objects must be sendable\");\n+                    \"uniquely-owned trait objects must be sendable\");\n             }\n         }\n         _ => {} // Nothing to do."}, {"sha": "265d6b0c7677cdf3c68e44d101ec1aa351b08e0f", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3", "patch": "@@ -338,14 +338,14 @@ pub impl Context {\n                           _ => {\n                             self.sess.span_err(\n                                 meta.span,\n-                                ~\"malformed lint attribute\");\n+                                \"malformed lint attribute\");\n                           }\n                         }\n                     }\n                   }\n                   _  => {\n                     self.sess.span_err(meta.span,\n-                                       ~\"malformed lint attribute\");\n+                                       \"malformed lint attribute\");\n                   }\n                 }\n             }\n@@ -485,8 +485,8 @@ fn check_item_while_true(cx: ty::ctxt, it: @ast::item) {\n                                 cx.sess.span_lint(\n                                     while_true, e.id, it.id,\n                                     e.span,\n-                                    ~\"denote infinite loops \\\n-                                      with loop { ... }\");\n+                                    \"denote infinite loops \\\n+                                     with loop { ... }\");\n                             }\n                             _ => ()\n                         }\n@@ -603,7 +603,7 @@ fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n                     && !check_limits(cx, *binop, l, r) {\n                     cx.sess.span_lint(\n                         type_limits, e.id, it.id, e.span,\n-                        ~\"comparison is useless due to type limits\");\n+                        \"comparison is useless due to type limits\");\n                 }\n             }\n             _ => ()\n@@ -630,7 +630,7 @@ fn check_item_default_methods(cx: ty::ctxt, item: @ast::item) {\n                             item.id,\n                             item.id,\n                             item.span,\n-                            ~\"default methods are experimental\");\n+                            \"default methods are experimental\");\n                     }\n                 }\n             }\n@@ -649,7 +649,7 @@ fn check_item_deprecated_mutable_fields(cx: ty::ctxt, item: @ast::item) {\n                                           item.id,\n                                           item.id,\n                                           field.span,\n-                                          ~\"mutable fields are deprecated\");\n+                                          \"mutable fields are deprecated\");\n                     }\n                     ast::named_field(*) | ast::unnamed_field => {}\n                 }\n@@ -672,14 +672,14 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n                     cx.sess.span_lint(\n                         ctypes, id, fn_id,\n                         ty.span,\n-                        ~\"found rust type `int` in foreign module, while \\\n+                        \"found rust type `int` in foreign module, while \\\n                          libc::c_int or libc::c_long should be used\");\n                   }\n                   ast::def_prim_ty(ast::ty_uint(ast::ty_u)) => {\n                     cx.sess.span_lint(\n                         ctypes, id, fn_id,\n                         ty.span,\n-                        ~\"found rust type `uint` in foreign module, while \\\n+                        \"found rust type `uint` in foreign module, while \\\n                          libc::c_uint or libc::c_ulong should be used\");\n                   }\n                   _ => ()\n@@ -795,7 +795,7 @@ fn check_item_path_statement(cx: ty::ctxt, it: @ast::item) {\n                         cx.sess.span_lint(\n                             path_statement, id, it.id,\n                             s.span,\n-                            ~\"path statement with no effect\");\n+                            \"path statement with no effect\");\n                     }\n                     _ => ()\n                 }\n@@ -835,8 +835,8 @@ fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n         if !is_camel_case(cx, ident) {\n             cx.sess.span_lint(\n                 non_camel_case_types, expr_id, item_id, span,\n-                ~\"type, variant, or trait should have \\\n-                  a camel case identifier\");\n+                \"type, variant, or trait should have \\\n+                 a camel case identifier\");\n         }\n     }\n \n@@ -863,7 +863,7 @@ fn check_item_unused_unsafe(cx: ty::ctxt, it: @ast::item) {\n                 if !cx.used_unsafe.contains(&blk.node.id) {\n                     cx.sess.span_lint(unused_unsafe, blk.node.id, it.id,\n                                       blk.span,\n-                                      ~\"unnecessary `unsafe` block\");\n+                                      \"unnecessary `unsafe` block\");\n                 }\n             }\n             _ => ()\n@@ -888,9 +888,9 @@ fn check_item_unused_mut(tcx: ty::ctxt, it: @ast::item) {\n         }\n         if !used {\n             let msg = if bindings == 1 {\n-                ~\"variable does not need to be mutable\"\n+                \"variable does not need to be mutable\"\n             } else {\n-                ~\"variables do not need to be mutable\"\n+                \"variables do not need to be mutable\"\n             };\n             tcx.sess.span_lint(unused_mut, p.id, it.id, p.span, msg);\n         }"}, {"sha": "40d62cac3572d98b942fd1a37b8b2a12cd8f5377", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3", "patch": "@@ -359,7 +359,7 @@ pub impl IrMaps {\n         match self.capture_info_map.find(&expr.id) {\n           Some(&caps) => caps,\n           None => {\n-            self.tcx.sess.span_bug(expr.span, ~\"no registered caps\");\n+            self.tcx.sess.span_bug(expr.span, \"no registered caps\");\n           }\n         }\n     }\n@@ -687,7 +687,7 @@ pub impl Liveness {\n           }\n           None => {\n             self.tcx.sess.span_bug(\n-                span, ~\"Not present in def map\")\n+                span, \"Not present in def map\")\n           }\n         }\n     }\n@@ -804,15 +804,15 @@ pub impl Liveness {\n                       // to find with one\n                 match self.tcx.def_map.find(&id) {\n                     Some(&def_label(loop_id)) => loop_id,\n-                    _ => self.tcx.sess.span_bug(sp, ~\"Label on break/loop \\\n-                                                    doesn't refer to a loop\")\n+                    _ => self.tcx.sess.span_bug(sp, \"Label on break/loop \\\n+                                                     doesn't refer to a loop\")\n                 },\n             None => {\n                 // Vanilla 'break' or 'loop', so use the enclosing\n                 // loop scope\n                 let loop_scope = &mut *self.loop_scope;\n                 if loop_scope.len() == 0 {\n-                    self.tcx.sess.span_bug(sp, ~\"break outside loop\");\n+                    self.tcx.sess.span_bug(sp, \"break outside loop\");\n                 }\n                 else {\n                     // FIXME(#5275): this shouldn't have to be a method...\n@@ -994,7 +994,7 @@ pub impl Liveness {\n           }\n \n           stmt_mac(*) => {\n-            self.tcx.sess.span_bug(stmt.span, ~\"unexpanded macro\");\n+            self.tcx.sess.span_bug(stmt.span, \"unexpanded macro\");\n           }\n         }\n     }\n@@ -1164,7 +1164,7 @@ pub impl Liveness {\n               match self.break_ln.find(&sc) {\n                   Some(&b) => b,\n                   None => self.tcx.sess.span_bug(expr.span,\n-                                ~\"Break to unknown label\")\n+                                                 \"Break to unknown label\")\n               }\n           }\n \n@@ -1178,7 +1178,7 @@ pub impl Liveness {\n               match self.cont_ln.find(&sc) {\n                   Some(&b) => b,\n                   None => self.tcx.sess.span_bug(expr.span,\n-                                ~\"Loop to unknown label\")\n+                                                 \"Loop to unknown label\")\n               }\n           }\n \n@@ -1304,7 +1304,7 @@ pub impl Liveness {\n           }\n \n           expr_mac(*) => {\n-            self.tcx.sess.span_bug(expr.span, ~\"unexpanded macro\");\n+            self.tcx.sess.span_bug(expr.span, \"unexpanded macro\");\n           }\n         }\n     }\n@@ -1618,10 +1618,10 @@ pub impl Liveness {\n             } else if ty::type_is_bot(t_ret) {\n                 // for bot return types, not ok.  Function should fail.\n                 self.tcx.sess.span_err(\n-                    sp, ~\"some control paths may return\");\n+                    sp, \"some control paths may return\");\n             } else {\n                 self.tcx.sess.span_err(\n-                    sp, ~\"not all control paths return a value\");\n+                    sp, \"not all control paths return a value\");\n             }\n         }\n     }\n@@ -1712,10 +1712,10 @@ pub impl Liveness {\n               None => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    ~\"re-assignment of immutable variable\");\n+                    \"re-assignment of immutable variable\");\n                 self.tcx.sess.span_note(\n                     orig_span,\n-                    ~\"prior assignment occurs here\");\n+                    \"prior assignment occurs here\");\n               }\n             }\n           }"}, {"sha": "866bd5377b9bac060004495e24376fd75c74eef0", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3", "patch": "@@ -928,7 +928,7 @@ pub impl mem_categorization_ctxt {\n                 _ => {\n                     self.tcx.sess.span_bug(\n                         pat.span,\n-                        ~\"enum pattern didn't resolve to enum or struct\");\n+                        \"enum pattern didn't resolve to enum or struct\");\n                 }\n             }\n           }"}, {"sha": "ecee2ea1a2fb264191d755511a9c292c0a381110", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3", "patch": "@@ -424,7 +424,7 @@ pub impl VisitContext {\n                     MoveInWhole => {\n                         self.tcx.sess.span_bug(\n                             expr.span,\n-                            fmt!(\"Component mode can never be MoveInWhole\"));\n+                            \"Component mode can never be MoveInWhole\");\n                     }\n                 }\n             }\n@@ -647,7 +647,7 @@ pub impl VisitContext {\n             expr_mac(*) => {\n                 self.tcx.sess.span_bug(\n                     expr.span,\n-                    ~\"macro expression remains after expansion\");\n+                    \"macro expression remains after expansion\");\n             }\n         }\n     }"}, {"sha": "be98195621902b8980899223e66630847e71e6b9", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3", "patch": "@@ -99,8 +99,8 @@ pub fn check_crate(tcx: ty::ctxt,\n                                          parental_privacy == Public)\n                                          == Private {\n             tcx.sess.span_err(span,\n-                ~\"can only dereference enums \\\n-                  with a single, public variant\");\n+                \"can only dereference enums \\\n+                 with a single, public variant\");\n         }\n     };\n \n@@ -121,8 +121,8 @@ pub fn check_crate(tcx: ty::ctxt,\n                                             tcx.sess.parse_sess.interner)));\n             }\n             None => {\n-                tcx.sess.span_bug(span, ~\"method not found in \\\n-                                          AST map?!\");\n+                tcx.sess.span_bug(span, \"method not found in \\\n+                                         AST map?!\");\n             }\n         }\n     };\n@@ -140,8 +140,8 @@ pub fn check_crate(tcx: ty::ctxt,\n                 // Look up the enclosing impl.\n                 if container_id.crate != local_crate {\n                     tcx.sess.span_bug(span,\n-                                      ~\"local method isn't in local \\\n-                                        impl?!\");\n+                                      \"local method isn't in local \\\n+                                       impl?!\");\n                 }\n \n                 match tcx.items.find(&container_id.node) {\n@@ -155,10 +155,10 @@ pub fn check_crate(tcx: ty::ctxt,\n                         }\n                     }\n                     Some(_) => {\n-                        tcx.sess.span_bug(span, ~\"impl wasn't an item?!\");\n+                        tcx.sess.span_bug(span, \"impl wasn't an item?!\");\n                     }\n                     None => {\n-                        tcx.sess.span_bug(span, ~\"impl wasn't in AST map?!\");\n+                        tcx.sess.span_bug(span, \"impl wasn't in AST map?!\");\n                     }\n                 }\n             }\n@@ -185,8 +185,8 @@ pub fn check_crate(tcx: ty::ctxt,\n                                             tcx.sess.parse_sess.interner)));\n             }\n             None => {\n-                tcx.sess.span_bug(span, ~\"method not found in \\\n-                                          AST map?!\");\n+                tcx.sess.span_bug(span, \"method not found in \\\n+                                         AST map?!\");\n             }\n         }\n     };\n@@ -219,7 +219,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                                                    .interner)));\n                 }\n                 None => {\n-                    tcx.sess.span_bug(span, ~\"item not found in AST map?!\");\n+                    tcx.sess.span_bug(span, \"item not found in AST map?!\");\n                 }\n             }\n         };\n@@ -333,10 +333,10 @@ pub fn check_crate(tcx: ty::ctxt,\n                             match item.node {\n                                 item_trait(_, _, ref methods) => {\n                                     if method_num >= (*methods).len() {\n-                                        tcx.sess.span_bug(span, ~\"method \\\n-                                                                  number \\\n-                                                                  out of \\\n-                                                                  range?!\");\n+                                        tcx.sess.span_bug(span, \"method \\\n+                                                                 number \\\n+                                                                 out of \\\n+                                                                 range?!\");\n                                     }\n                                     match (*methods)[method_num] {\n                                         provided(method)\n@@ -363,20 +363,20 @@ pub fn check_crate(tcx: ty::ctxt,\n                                     }\n                                 }\n                                 _ => {\n-                                    tcx.sess.span_bug(span, ~\"trait wasn't \\\n-                                                              actually a \\\n-                                                              trait?!\");\n+                                    tcx.sess.span_bug(span, \"trait wasn't \\\n+                                                             actually a \\\n+                                                             trait?!\");\n                                 }\n                             }\n                         }\n                         Some(_) => {\n-                            tcx.sess.span_bug(span, ~\"trait wasn't an \\\n-                                                      item?!\");\n+                            tcx.sess.span_bug(span, \"trait wasn't an \\\n+                                                     item?!\");\n                         }\n                         None => {\n-                            tcx.sess.span_bug(span, ~\"trait item wasn't \\\n-                                                      found in the AST \\\n-                                                      map?!\");\n+                            tcx.sess.span_bug(span, \"trait item wasn't \\\n+                                                     found in the AST \\\n+                                                     map?!\");\n                         }\n                     }\n                 } else {\n@@ -465,8 +465,8 @@ pub fn check_crate(tcx: ty::ctxt,\n                             match method_map.find(&expr.id) {\n                                 None => {\n                                     tcx.sess.span_bug(expr.span,\n-                                                      ~\"method call not in \\\n-                                                        method map\");\n+                                                      \"method call not in \\\n+                                                       method map\");\n                                 }\n                                 Some(ref entry) => {\n                                     debug!(\"(privacy checking) checking \\\n@@ -512,18 +512,18 @@ pub fn check_crate(tcx: ty::ctxt,\n                                     }\n                                     _ => {\n                                         tcx.sess.span_bug(expr.span,\n-                                                          ~\"resolve didn't \\\n-                                                            map enum struct \\\n-                                                            constructor to a \\\n-                                                            variant def\");\n+                                                          \"resolve didn't \\\n+                                                           map enum struct \\\n+                                                           constructor to a \\\n+                                                           variant def\");\n                                     }\n                                 }\n                             }\n                         }\n                         _ => {\n-                            tcx.sess.span_bug(expr.span, ~\"struct expr \\\n-                                                           didn't have \\\n-                                                           struct type?!\");\n+                            tcx.sess.span_bug(expr.span, \"struct expr \\\n+                                                          didn't have \\\n+                                                          struct type?!\");\n                         }\n                     }\n                 }\n@@ -579,18 +579,18 @@ pub fn check_crate(tcx: ty::ctxt,\n                                     }\n                                     _ => {\n                                         tcx.sess.span_bug(pattern.span,\n-                                                          ~\"resolve didn't \\\n-                                                            map enum struct \\\n-                                                            pattern to a \\\n-                                                            variant def\");\n+                                                          \"resolve didn't \\\n+                                                           map enum struct \\\n+                                                           pattern to a \\\n+                                                           variant def\");\n                                     }\n                                 }\n                             }\n                         }\n                         _ => {\n                             tcx.sess.span_bug(pattern.span,\n-                                              ~\"struct pattern didn't have \\\n-                                                struct type?!\");\n+                                              \"struct pattern didn't have \\\n+                                               struct type?!\");\n                         }\n                     }\n                 }"}, {"sha": "4faa2150003f02d4c5fd0c4941c92b15ac7024ea", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3", "patch": "@@ -320,7 +320,7 @@ pub impl RegionMaps {\n pub fn parent_id(cx: ctxt, span: span) -> ast::node_id {\n     match cx.parent {\n       None => {\n-        cx.sess.span_bug(span, ~\"crate should not be parent here\");\n+        cx.sess.span_bug(span, \"crate should not be parent here\");\n       }\n       Some(parent_id) => {\n         parent_id"}, {"sha": "3c8f100d1c9337645ca5aad1920f1a7d4fa8c608", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=b42ea7f9ef06be9a623a8a007ae3aecbb7d961a3", "patch": "@@ -3261,7 +3261,7 @@ pub fn expr_kind(tcx: ctxt,\n         ast::expr_mac(*) => {\n             tcx.sess.span_bug(\n                 expr.span,\n-                ~\"macro expression remains after expansion\");\n+                \"macro expression remains after expansion\");\n         }\n     }\n }\n@@ -4242,27 +4242,27 @@ pub fn eval_repeat_count(tcx: ctxt, count_expr: @ast::expr) -> uint {\n         const_eval::const_uint(count) => return count as uint,\n         const_eval::const_float(count) => {\n             tcx.sess.span_err(count_expr.span,\n-                              ~\"expected signed or unsigned integer for \\\n-                                repeat count but found float\");\n+                              \"expected signed or unsigned integer for \\\n+                               repeat count but found float\");\n             return count as uint;\n         }\n         const_eval::const_str(_) => {\n             tcx.sess.span_err(count_expr.span,\n-                              ~\"expected signed or unsigned integer for \\\n-                                repeat count but found string\");\n+                              \"expected signed or unsigned integer for \\\n+                               repeat count but found string\");\n             return 0;\n         }\n         const_eval::const_bool(_) => {\n             tcx.sess.span_err(count_expr.span,\n-                              ~\"expected signed or unsigned integer for \\\n-                                repeat count but found boolean\");\n+                              \"expected signed or unsigned integer for \\\n+                               repeat count but found boolean\");\n             return 0;\n         }\n       },\n       Err(*) => {\n         tcx.sess.span_err(count_expr.span,\n-                          ~\"expected constant integer for repeat count \\\n-                            but found variable\");\n+                          \"expected constant integer for repeat count \\\n+                           but found variable\");\n         return 0;\n       }\n     }"}]}