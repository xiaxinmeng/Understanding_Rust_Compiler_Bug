{"sha": "78778fc6aa87d6f9735b73b4136fb26043d84158", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4Nzc4ZmM2YWE4N2Q2Zjk3MzViNzNiNDEzNmZiMjYwNDNkODQxNTg=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2021-08-25T15:15:09Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2021-08-29T21:44:12Z"}, "message": "rustc_target: remove `LayoutOf` bound from `TyAbiInterface`.", "tree": {"sha": "76184dd2c8449278afa2474d3d39311ab57f0c04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76184dd2c8449278afa2474d3d39311ab57f0c04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78778fc6aa87d6f9735b73b4136fb26043d84158", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78778fc6aa87d6f9735b73b4136fb26043d84158", "html_url": "https://github.com/rust-lang/rust/commit/78778fc6aa87d6f9735b73b4136fb26043d84158", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78778fc6aa87d6f9735b73b4136fb26043d84158/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e6d126b7d69281072f16dcc3cfff140e8947c58", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e6d126b7d69281072f16dcc3cfff140e8947c58", "html_url": "https://github.com/rust-lang/rust/commit/8e6d126b7d69281072f16dcc3cfff140e8947c58"}], "stats": {"total": 166, "additions": 81, "deletions": 85}, "files": [{"sha": "5e5902abe662f9063d4b96cb7d005bf4179e3e87", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=78778fc6aa87d6f9735b73b4136fb26043d84158", "patch": "@@ -2090,7 +2090,7 @@ impl LayoutOf<'tcx> for LayoutCx<'tcx, ty::query::TyCtxtAt<'tcx>> {\n \n impl<'tcx, C> TyAbiInterface<'tcx, C> for Ty<'tcx>\n where\n-    C: LayoutOf<'tcx, Ty = Ty<'tcx>> + HasTyCtxt<'tcx> + HasParamEnv<'tcx>,\n+    C: HasTyCtxt<'tcx> + HasParamEnv<'tcx>,\n {\n     fn ty_and_layout_for_variant(\n         this: TyAndLayout<'tcx>,\n@@ -2109,8 +2109,11 @@ where\n             }\n \n             Variants::Single { index } => {\n+                let tcx = cx.tcx();\n+                let param_env = cx.param_env();\n+\n                 // Deny calling for_variant more than once for non-Single enums.\n-                if let Ok(original_layout) = cx.layout_of(this.ty).to_result() {\n+                if let Ok(original_layout) = tcx.layout_of(param_env.and(this.ty)) {\n                     assert_eq!(original_layout.variants, Variants::Single { index });\n                 }\n \n@@ -2120,7 +2123,6 @@ where\n                     ty::Adt(def, _) => def.variants[variant_index].fields.len(),\n                     _ => bug!(),\n                 };\n-                let tcx = cx.tcx();\n                 tcx.intern_layout(Layout {\n                     variants: Variants::Single { index: variant_index },\n                     fields: match NonZeroUsize::new(fields) {\n@@ -2300,32 +2302,32 @@ where\n         cx: &C,\n         offset: Size,\n     ) -> Option<PointeeInfo> {\n+        let tcx = cx.tcx();\n+        let param_env = cx.param_env();\n+\n         let addr_space_of_ty = |ty: Ty<'tcx>| {\n             if ty.is_fn() { cx.data_layout().instruction_address_space } else { AddressSpace::DATA }\n         };\n \n         let pointee_info = match *this.ty.kind() {\n             ty::RawPtr(mt) if offset.bytes() == 0 => {\n-                cx.layout_of(mt.ty).to_result().ok().map(|layout| PointeeInfo {\n+                tcx.layout_of(param_env.and(mt.ty)).ok().map(|layout| PointeeInfo {\n                     size: layout.size,\n                     align: layout.align.abi,\n                     safe: None,\n                     address_space: addr_space_of_ty(mt.ty),\n                 })\n             }\n             ty::FnPtr(fn_sig) if offset.bytes() == 0 => {\n-                cx.layout_of(cx.tcx().mk_fn_ptr(fn_sig)).to_result().ok().map(|layout| {\n-                    PointeeInfo {\n-                        size: layout.size,\n-                        align: layout.align.abi,\n-                        safe: None,\n-                        address_space: cx.data_layout().instruction_address_space,\n-                    }\n+                tcx.layout_of(param_env.and(tcx.mk_fn_ptr(fn_sig))).ok().map(|layout| PointeeInfo {\n+                    size: layout.size,\n+                    align: layout.align.abi,\n+                    safe: None,\n+                    address_space: cx.data_layout().instruction_address_space,\n                 })\n             }\n             ty::Ref(_, ty, mt) if offset.bytes() == 0 => {\n                 let address_space = addr_space_of_ty(ty);\n-                let tcx = cx.tcx();\n                 let kind = if tcx.sess.opts.optimize == OptLevel::No {\n                     // Use conservative pointer kind if not optimizing. This saves us the\n                     // Freeze/Unpin queries, and can save time in the codegen backend (noalias\n@@ -2354,7 +2356,7 @@ where\n                     }\n                 };\n \n-                cx.layout_of(ty).to_result().ok().map(|layout| PointeeInfo {\n+                tcx.layout_of(param_env.and(ty)).ok().map(|layout| PointeeInfo {\n                     size: layout.size,\n                     align: layout.align.abi,\n                     safe: Some(kind),\n@@ -3023,16 +3025,15 @@ where\n     }\n }\n \n-fn make_thin_self_ptr<'tcx, C>(cx: &C, mut layout: TyAndLayout<'tcx>) -> TyAndLayout<'tcx>\n-where\n-    C: LayoutOf<'tcx, Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n-        + HasTyCtxt<'tcx>\n-        + HasParamEnv<'tcx>,\n-{\n+fn make_thin_self_ptr<'tcx>(\n+    cx: &(impl HasTyCtxt<'tcx> + HasParamEnv<'tcx>),\n+    layout: TyAndLayout<'tcx>,\n+) -> TyAndLayout<'tcx> {\n+    let tcx = cx.tcx();\n     let fat_pointer_ty = if layout.is_unsized() {\n         // unsized `self` is passed as a pointer to `self`\n         // FIXME (mikeyhew) change this to use &own if it is ever added to the language\n-        cx.tcx().mk_mut_ptr(layout.ty)\n+        tcx.mk_mut_ptr(layout.ty)\n     } else {\n         match layout.abi {\n             Abi::ScalarPair(..) => (),\n@@ -3066,8 +3067,13 @@ where\n     // we now have a type like `*mut RcBox<dyn Trait>`\n     // change its layout to that of `*mut ()`, a thin pointer, but keep the same type\n     // this is understood as a special case elsewhere in the compiler\n-    let unit_pointer_ty = cx.tcx().mk_mut_ptr(cx.tcx().mk_unit());\n-    layout = cx.layout_of(unit_pointer_ty);\n-    layout.ty = fat_pointer_ty;\n-    layout\n+    let unit_ptr_ty = tcx.mk_mut_ptr(tcx.mk_unit());\n+\n+    TyAndLayout {\n+        ty: fat_pointer_ty,\n+\n+        // NOTE(eddyb) using an empty `ParamEnv`, and `unwrap`-ing the `Result`\n+        // should always work because the type is always `*mut ()`.\n+        ..tcx.layout_of(ty::ParamEnv::reveal_all().and(unit_ptr_ty)).unwrap()\n+    }\n }"}, {"sha": "4613a459c51d6d281dcf09d14b39d9fa3a16c2e3", "filename": "compiler/rustc_target/src/abi/call/aarch64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Faarch64.rs?ref=78778fc6aa87d6f9735b73b4136fb26043d84158", "patch": "@@ -1,10 +1,10 @@\n use crate::abi::call::{ArgAbi, FnAbi, Reg, RegKind, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, TyAbiInterface, TyAndLayout};\n+use crate::abi::{HasDataLayout, TyAbiInterface};\n \n fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>) -> Option<Uniform>\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         let size = arg.layout.size;\n@@ -27,7 +27,7 @@ where\n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n@@ -49,7 +49,7 @@ where\n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(32);\n@@ -71,7 +71,7 @@ where\n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {\n         classify_ret(cx, &mut fn_abi.ret);"}, {"sha": "9be97476ce8f09efc49d83d6aa76684c1abf72c3", "filename": "compiler/rustc_target/src/abi/call/amdgpu.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Famdgpu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Famdgpu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Famdgpu.rs?ref=78778fc6aa87d6f9735b73b4136fb26043d84158", "patch": "@@ -1,26 +1,26 @@\n use crate::abi::call::{ArgAbi, FnAbi};\n-use crate::abi::{HasDataLayout, LayoutOf, TyAbiInterface, TyAndLayout};\n+use crate::abi::{HasDataLayout, TyAbiInterface};\n \n fn classify_ret<'a, Ty, C>(_cx: &C, ret: &mut ArgAbi<'a, Ty>)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     ret.extend_integer_width_to(32);\n }\n \n fn classify_arg<'a, Ty, C>(_cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     arg.extend_integer_width_to(32);\n }\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {\n         classify_ret(cx, &mut fn_abi.ret);"}, {"sha": "e66c2132b8677b824f740007517cb8389ac4eab1", "filename": "compiler/rustc_target/src/abi/call/arm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Farm.rs?ref=78778fc6aa87d6f9735b73b4136fb26043d84158", "patch": "@@ -1,11 +1,11 @@\n use crate::abi::call::{ArgAbi, Conv, FnAbi, Reg, RegKind, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, TyAbiInterface, TyAndLayout};\n+use crate::abi::{HasDataLayout, TyAbiInterface};\n use crate::spec::HasTargetSpec;\n \n fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>) -> Option<Uniform>\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         let size = arg.layout.size;\n@@ -28,7 +28,7 @@ where\n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>, vfp: bool)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n@@ -54,7 +54,7 @@ where\n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, vfp: bool)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(32);\n@@ -76,7 +76,7 @@ where\n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n+    C: HasDataLayout + HasTargetSpec,\n {\n     // If this is a target with a hard-float ABI, and the function is not explicitly\n     // `extern \"aapcs\"`, then we must use the VFP registers for homogeneous aggregates."}, {"sha": "28ca93c46921e1cd7f69e770f89e99a7c722b40b", "filename": "compiler/rustc_target/src/abi/call/mips64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs?ref=78778fc6aa87d6f9735b73b4136fb26043d84158", "patch": "@@ -1,5 +1,5 @@\n use crate::abi::call::{ArgAbi, ArgExtension, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n-use crate::abi::{self, HasDataLayout, LayoutOf, Size, TyAbiInterface, TyAndLayout};\n+use crate::abi::{self, HasDataLayout, Size, TyAbiInterface};\n \n fn extend_integer_width_mips<Ty>(arg: &mut ArgAbi<'_, Ty>, bits: u64) {\n     // Always sign extend u32 values on 64-bit mips\n@@ -20,7 +20,7 @@ fn extend_integer_width_mips<Ty>(arg: &mut ArgAbi<'_, Ty>, bits: u64) {\n fn float_reg<'a, Ty, C>(cx: &C, ret: &ArgAbi<'a, Ty>, i: usize) -> Option<Reg>\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     match ret.layout.field(cx, i).abi {\n         abi::Abi::Scalar(ref scalar) => match scalar.value {\n@@ -35,7 +35,7 @@ where\n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n         extend_integer_width_mips(ret, 64);\n@@ -75,7 +75,7 @@ where\n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     if !arg.layout.is_aggregate() {\n         extend_integer_width_mips(arg, 64);\n@@ -145,7 +145,7 @@ where\n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {\n         classify_ret(cx, &mut fn_abi.ret);"}, {"sha": "6d3c7318091076fbcbb0b2f7b5fab6c70ef5cfc7", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=78778fc6aa87d6f9735b73b4136fb26043d84158", "patch": "@@ -1,5 +1,5 @@\n use crate::abi::{self, Abi, Align, FieldsShape, Size};\n-use crate::abi::{HasDataLayout, LayoutOf, TyAbiInterface, TyAndLayout};\n+use crate::abi::{HasDataLayout, TyAbiInterface, TyAndLayout};\n use crate::spec::{self, HasTargetSpec};\n \n mod aarch64;\n@@ -317,7 +317,6 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n     pub fn homogeneous_aggregate<C>(&self, cx: &C) -> Result<HomogeneousAggregate, Heterogeneous>\n     where\n         Ty: TyAbiInterface<'a, C> + Copy,\n-        C: LayoutOf<'a, Ty = Ty, TyAndLayout = Self>,\n     {\n         match self.abi {\n             Abi::Uninhabited => Err(Heterogeneous),\n@@ -604,7 +603,7 @@ impl<'a, Ty> FnAbi<'a, Ty> {\n     pub fn adjust_for_cabi<C>(&mut self, cx: &C, abi: spec::abi::Abi) -> Result<(), String>\n     where\n         Ty: TyAbiInterface<'a, C> + Copy,\n-        C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n+        C: HasDataLayout + HasTargetSpec,\n     {\n         if abi == spec::abi::Abi::X86Interrupt {\n             if let Some(arg) = self.args.first_mut() {"}, {"sha": "c22ef9c8f2a7f54d19448901a0ad939055939f76", "filename": "compiler/rustc_target/src/abi/call/powerpc64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fpowerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fpowerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fpowerpc64.rs?ref=78778fc6aa87d6f9735b73b4136fb26043d84158", "patch": "@@ -3,7 +3,7 @@\n // need to be fixed when PowerPC vector support is added.\n \n use crate::abi::call::{ArgAbi, FnAbi, Reg, RegKind, Uniform};\n-use crate::abi::{Endian, HasDataLayout, LayoutOf, TyAbiInterface, TyAndLayout};\n+use crate::abi::{Endian, HasDataLayout, TyAbiInterface};\n use crate::spec::HasTargetSpec;\n \n #[derive(Debug, Clone, Copy, PartialEq)]\n@@ -20,7 +20,7 @@ fn is_homogeneous_aggregate<'a, Ty, C>(\n ) -> Option<Uniform>\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         // ELFv1 only passes one-member aggregates transparently.\n@@ -44,7 +44,7 @@ where\n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>, abi: ABI)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n@@ -87,7 +87,7 @@ where\n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, abi: ABI)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(64);\n@@ -117,7 +117,7 @@ where\n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n+    C: HasDataLayout + HasTargetSpec,\n {\n     let abi = if cx.target_spec().env == \"musl\" {\n         ELFv2"}, {"sha": "8c2ef8c7a017dfe130e2ac1799faee0241fdaff3", "filename": "compiler/rustc_target/src/abi/call/riscv.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs?ref=78778fc6aa87d6f9735b73b4136fb26043d84158", "patch": "@@ -5,9 +5,7 @@\n // https://github.com/llvm/llvm-project/blob/8e780252a7284be45cf1ba224cabd884847e8e92/clang/lib/CodeGen/TargetInfo.cpp#L9311-L9773\n \n use crate::abi::call::{ArgAbi, ArgExtension, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n-use crate::abi::{\n-    self, Abi, FieldsShape, HasDataLayout, LayoutOf, Size, TyAbiInterface, TyAndLayout,\n-};\n+use crate::abi::{self, Abi, FieldsShape, HasDataLayout, Size, TyAbiInterface, TyAndLayout};\n use crate::spec::HasTargetSpec;\n \n #[derive(Copy, Clone)]\n@@ -44,7 +42,6 @@ fn should_use_fp_conv_helper<'a, Ty, C>(\n ) -> Result<(), CannotUseFpConv>\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>>,\n {\n     match arg_layout.abi {\n         Abi::Scalar(ref scalar) => match scalar.value {\n@@ -131,7 +128,6 @@ fn should_use_fp_conv<'a, Ty, C>(\n ) -> Option<FloatConv>\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>>,\n {\n     let mut field1_kind = RegPassKind::Unknown;\n     let mut field2_kind = RegPassKind::Unknown;\n@@ -150,7 +146,6 @@ where\n fn classify_ret<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, xlen: u64, flen: u64) -> bool\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>>,\n {\n     if let Some(conv) = should_use_fp_conv(cx, &arg.layout, xlen, flen) {\n         match conv {\n@@ -213,7 +208,6 @@ fn classify_arg<'a, Ty, C>(\n     avail_fprs: &mut u64,\n ) where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>>,\n {\n     if !is_vararg {\n         match should_use_fp_conv(cx, &arg.layout, xlen, flen) {\n@@ -321,7 +315,7 @@ fn extend_integer_width<'a, Ty>(arg: &mut ArgAbi<'a, Ty>, xlen: u64) {\n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n+    C: HasDataLayout + HasTargetSpec,\n {\n     let flen = match &cx.target_spec().llvm_abiname[..] {\n         \"ilp32f\" | \"lp64f\" => 32,"}, {"sha": "594108925de8093e4ac90159ab035c714aff2c9b", "filename": "compiler/rustc_target/src/abi/call/s390x.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fs390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fs390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fs390x.rs?ref=78778fc6aa87d6f9735b73b4136fb26043d84158", "patch": "@@ -2,7 +2,7 @@\n // for a pre-z13 machine or using -mno-vx.\n \n use crate::abi::call::{ArgAbi, FnAbi, Reg};\n-use crate::abi::{self, HasDataLayout, LayoutOf, TyAbiInterface, TyAndLayout};\n+use crate::abi::{self, HasDataLayout, TyAbiInterface, TyAndLayout};\n \n fn classify_ret<Ty>(ret: &mut ArgAbi<'_, Ty>) {\n     if !ret.layout.is_aggregate() && ret.layout.size.bits() <= 64 {\n@@ -15,7 +15,7 @@ fn classify_ret<Ty>(ret: &mut ArgAbi<'_, Ty>) {\n fn is_single_fp_element<'a, Ty, C>(cx: &C, layout: TyAndLayout<'a, Ty>) -> bool\n where\n     Ty: TyAbiInterface<'a, C>,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     match layout.abi {\n         abi::Abi::Scalar(ref scalar) => scalar.value.is_float(),\n@@ -33,7 +33,7 @@ where\n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     if !arg.layout.is_aggregate() && arg.layout.size.bits() <= 64 {\n         arg.extend_integer_width_to(64);\n@@ -60,7 +60,7 @@ where\n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {\n         classify_ret(&mut fn_abi.ret);"}, {"sha": "5d74c94e2c6f67c32c91632f1642115822425061", "filename": "compiler/rustc_target/src/abi/call/sparc64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs?ref=78778fc6aa87d6f9735b73b4136fb26043d84158", "patch": "@@ -1,12 +1,12 @@\n // FIXME: This needs an audit for correctness and completeness.\n \n use crate::abi::call::{ArgAbi, FnAbi, Reg, RegKind, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, TyAbiInterface, TyAndLayout};\n+use crate::abi::{HasDataLayout, TyAbiInterface};\n \n fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>) -> Option<Uniform>\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         // Ensure we have at most eight uniquely addressable members.\n@@ -27,7 +27,7 @@ where\n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n@@ -53,7 +53,7 @@ where\n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(64);\n@@ -77,7 +77,7 @@ where\n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {\n         classify_ret(cx, &mut fn_abi.ret);"}, {"sha": "3237cde10654ac4a1a70120843f95fb74165c8ed", "filename": "compiler/rustc_target/src/abi/call/wasm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fwasm.rs?ref=78778fc6aa87d6f9735b73b4136fb26043d84158", "patch": "@@ -1,10 +1,10 @@\n use crate::abi::call::{ArgAbi, FnAbi, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, TyAbiInterface, TyAndLayout};\n+use crate::abi::{HasDataLayout, TyAbiInterface};\n \n fn unwrap_trivial_aggregate<'a, Ty, C>(cx: &C, val: &mut ArgAbi<'a, Ty>) -> bool\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     if val.layout.is_aggregate() {\n         if let Some(unit) = val.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()) {\n@@ -21,7 +21,7 @@ where\n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     ret.extend_integer_width_to(32);\n     if ret.layout.is_aggregate() && !unwrap_trivial_aggregate(cx, ret) {\n@@ -32,7 +32,7 @@ where\n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     arg.extend_integer_width_to(32);\n     if arg.layout.is_aggregate() && !unwrap_trivial_aggregate(cx, arg) {\n@@ -44,7 +44,7 @@ where\n pub fn compute_c_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {\n         classify_ret(cx, &mut fn_abi.ret);"}, {"sha": "3fc197b5d7537f494c7e830c776c19526b3324d5", "filename": "compiler/rustc_target/src/abi/call/x86.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs?ref=78778fc6aa87d6f9735b73b4136fb26043d84158", "patch": "@@ -1,5 +1,5 @@\n use crate::abi::call::{ArgAttribute, FnAbi, PassMode, Reg, RegKind};\n-use crate::abi::{self, HasDataLayout, LayoutOf, TyAbiInterface, TyAndLayout};\n+use crate::abi::{self, HasDataLayout, TyAbiInterface, TyAndLayout};\n use crate::spec::HasTargetSpec;\n \n #[derive(PartialEq)]\n@@ -11,7 +11,7 @@ pub enum Flavor {\n fn is_single_fp_element<'a, Ty, C>(cx: &C, layout: TyAndLayout<'a, Ty>) -> bool\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     match layout.abi {\n         abi::Abi::Scalar(ref scalar) => scalar.value.is_float(),\n@@ -29,7 +29,7 @@ where\n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>, flavor: Flavor)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n+    C: HasDataLayout + HasTargetSpec,\n {\n     if !fn_abi.ret.is_ignore() {\n         if fn_abi.ret.layout.is_aggregate() {"}, {"sha": "08f0aaba59af4891333db4179448682a8f314464", "filename": "compiler/rustc_target/src/abi/call/x86_64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs?ref=78778fc6aa87d6f9735b73b4136fb26043d84158", "patch": "@@ -2,7 +2,7 @@\n // https://github.com/jckarter/clay/blob/master/compiler/src/externals.cpp\n \n use crate::abi::call::{ArgAbi, CastTarget, FnAbi, Reg, RegKind};\n-use crate::abi::{self, Abi, HasDataLayout, LayoutOf, Size, TyAbiInterface, TyAndLayout};\n+use crate::abi::{self, Abi, HasDataLayout, Size, TyAbiInterface, TyAndLayout};\n \n /// Classification of \"eightbyte\" components.\n // N.B., the order of the variants is from general to specific,\n@@ -27,7 +27,7 @@ fn classify_arg<'a, Ty, C>(\n ) -> Result<[Option<Class>; MAX_EIGHTBYTES], Memory>\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     fn classify<'a, Ty, C>(\n         cx: &C,\n@@ -37,7 +37,7 @@ where\n     ) -> Result<(), Memory>\n     where\n         Ty: TyAbiInterface<'a, C> + Copy,\n-        C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+        C: HasDataLayout,\n     {\n         if !off.is_aligned(layout.align.abi) {\n             if !layout.is_zst() {\n@@ -173,7 +173,7 @@ const MAX_SSE_REGS: usize = 8; // XMM0-7\n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n-    C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     let mut int_regs = MAX_INT_REGS;\n     let mut sse_regs = MAX_SSE_REGS;"}, {"sha": "820399943f0afc91f62b36e38e0c5781bc549352", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78778fc6aa87d6f9735b73b4136fb26043d84158/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=78778fc6aa87d6f9735b73b4136fb26043d84158", "patch": "@@ -1238,7 +1238,7 @@ pub struct PointeeInfo {\n \n /// Trait that needs to be implemented by the higher-level type representation\n /// (e.g. `rustc_middle::ty::Ty`), to provide `rustc_target::abi` functionality.\n-pub trait TyAbiInterface<'a, C: LayoutOf<'a, Ty = Self>>: Sized {\n+pub trait TyAbiInterface<'a, C>: Sized {\n     fn ty_and_layout_for_variant(\n         this: TyAndLayout<'a, Self>,\n         cx: &C,\n@@ -1256,23 +1256,20 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n     pub fn for_variant<C>(self, cx: &C, variant_index: VariantIdx) -> Self\n     where\n         Ty: TyAbiInterface<'a, C>,\n-        C: LayoutOf<'a, Ty = Ty>,\n     {\n         Ty::ty_and_layout_for_variant(self, cx, variant_index)\n     }\n \n     pub fn field<C>(self, cx: &C, i: usize) -> Self\n     where\n         Ty: TyAbiInterface<'a, C>,\n-        C: LayoutOf<'a, Ty = Ty>,\n     {\n         Ty::ty_and_layout_field(self, cx, i)\n     }\n \n     pub fn pointee_info_at<C>(self, cx: &C, offset: Size) -> Option<PointeeInfo>\n     where\n         Ty: TyAbiInterface<'a, C>,\n-        C: LayoutOf<'a, Ty = Ty>,\n     {\n         Ty::ty_and_layout_pointee_info_at(self, cx, offset)\n     }\n@@ -1306,7 +1303,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n     where\n         Self: Copy,\n         Ty: TyAbiInterface<'a, C>,\n-        C: LayoutOf<'a, Ty = Ty> + HasDataLayout,\n+        C: HasDataLayout,\n     {\n         let scalar_allows_raw_init = move |s: &Scalar| -> bool {\n             if zero {"}]}