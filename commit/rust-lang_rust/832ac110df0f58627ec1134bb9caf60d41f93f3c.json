{"sha": "832ac110df0f58627ec1134bb9caf60d41f93f3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzMmFjMTEwZGYwZjU4NjI3ZWMxMTM0YmI5Y2FmNjBkNDFmOTNmM2M=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-09-15T15:10:10Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-12-14T16:18:51Z"}, "message": "remove the typeck::autoderef::Autoderef fcx field\n\nThis allows using it in an fcx-independent context", "tree": {"sha": "db0d665986af0974762e88dd95dcd29797b9d53b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db0d665986af0974762e88dd95dcd29797b9d53b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/832ac110df0f58627ec1134bb9caf60d41f93f3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/832ac110df0f58627ec1134bb9caf60d41f93f3c", "html_url": "https://github.com/rust-lang/rust/commit/832ac110df0f58627ec1134bb9caf60d41f93f3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/832ac110df0f58627ec1134bb9caf60d41f93f3c/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07201249f09ddf4ade1f02d8208b624b5d927212", "url": "https://api.github.com/repos/rust-lang/rust/commits/07201249f09ddf4ade1f02d8208b624b5d927212", "html_url": "https://github.com/rust-lang/rust/commit/07201249f09ddf4ade1f02d8208b624b5d927212"}], "stats": {"total": 85, "additions": 43, "deletions": 42}, "files": [{"sha": "c13ed1bd9d0e7bc5028d50a1c39c8110951db580", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/832ac110df0f58627ec1134bb9caf60d41f93f3c/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/832ac110df0f58627ec1134bb9caf60d41f93f3c/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=832ac110df0f58627ec1134bb9caf60d41f93f3c", "patch": "@@ -8,20 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use astconv::AstConv;\n-\n use super::{FnCtxt, PlaceOp, Needs};\n use super::method::MethodCallee;\n \n-use rustc::infer::InferOk;\n+use rustc::infer::{InferCtxt, InferOk};\n use rustc::session::DiagnosticMessageId;\n use rustc::traits::{self, TraitEngine};\n use rustc::ty::{self, Ty, TraitRef};\n use rustc::ty::{ToPredicate, TypeFoldable};\n use rustc::ty::adjustment::{Adjustment, Adjust, OverloadedDeref};\n \n use syntax_pos::Span;\n-use syntax::ast::Ident;\n+use syntax::ast::{NodeId, Ident};\n \n use std::iter;\n \n@@ -32,7 +30,9 @@ enum AutoderefKind {\n }\n \n pub struct Autoderef<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    body_id: NodeId,\n+    param_env: ty::ParamEnv<'tcx>,\n     steps: Vec<(Ty<'tcx>, AutoderefKind)>,\n     cur_ty: Ty<'tcx>,\n     obligations: Vec<traits::PredicateObligation<'tcx>>,\n@@ -45,7 +45,7 @@ impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n     type Item = (Ty<'tcx>, usize);\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        let tcx = self.fcx.tcx;\n+        let tcx = self.infcx.tcx;\n \n         debug!(\"autoderef: steps={:?}, cur_ty={:?}\",\n                self.steps,\n@@ -110,35 +110,35 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n     fn overloaded_deref_ty(&mut self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n         debug!(\"overloaded_deref_ty({:?})\", ty);\n \n-        let tcx = self.fcx.tcx();\n+        let tcx = self.infcx.tcx;\n \n         // <cur_ty as Deref>\n         let trait_ref = TraitRef {\n             def_id: tcx.lang_items().deref_trait()?,\n             substs: tcx.mk_substs_trait(self.cur_ty, &[]),\n         };\n \n-        let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n+        let cause = traits::ObligationCause::misc(self.span, self.body_id);\n \n         let obligation = traits::Obligation::new(cause.clone(),\n-                                                 self.fcx.param_env,\n+                                                 self.param_env,\n                                                  trait_ref.to_predicate());\n-        if !self.fcx.predicate_may_hold(&obligation) {\n+        if !self.infcx.predicate_may_hold(&obligation) {\n             debug!(\"overloaded_deref_ty: cannot match obligation\");\n             return None;\n         }\n \n         let mut fulfillcx = traits::FulfillmentContext::new_in_snapshot();\n         let normalized_ty = fulfillcx.normalize_projection_type(\n-            &self.fcx,\n-            self.fcx.param_env,\n+            &self.infcx,\n+            self.param_env,\n             ty::ProjectionTy::from_ref_and_name(\n                 tcx,\n                 trait_ref,\n                 Ident::from_str(\"Target\"),\n             ),\n             cause);\n-        if let Err(e) = fulfillcx.select_where_possible(&self.fcx) {\n+        if let Err(e) = fulfillcx.select_where_possible(&self.infcx) {\n             // This shouldn't happen, except for evaluate/fulfill mismatches,\n             // but that's not a reason for an ICE (`predicate_may_hold` is conservative\n             // by design).\n@@ -151,39 +151,39 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n                ty, normalized_ty, obligations);\n         self.obligations.extend(obligations);\n \n-        Some(self.fcx.resolve_type_vars_if_possible(&normalized_ty))\n+        Some(self.infcx.resolve_type_vars_if_possible(&normalized_ty))\n     }\n \n     /// Returns the final type, generating an error if it is an\n     /// unresolved inference variable.\n-    pub fn unambiguous_final_ty(&self) -> Ty<'tcx> {\n-        self.fcx.structurally_resolved_type(self.span, self.cur_ty)\n+    pub fn unambiguous_final_ty(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+        fcx.structurally_resolved_type(self.span, self.cur_ty)\n     }\n \n     /// Returns the final type we ended up with, which may well be an\n     /// inference variable (we will resolve it first, if possible).\n     pub fn maybe_ambiguous_final_ty(&self) -> Ty<'tcx> {\n-        self.fcx.resolve_type_vars_if_possible(&self.cur_ty)\n+        self.infcx.resolve_type_vars_if_possible(&self.cur_ty)\n     }\n \n     pub fn step_count(&self) -> usize {\n         self.steps.len()\n     }\n \n     /// Returns the adjustment steps.\n-    pub fn adjust_steps(&self, needs: Needs)\n+    pub fn adjust_steps(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>, needs: Needs)\n                         -> Vec<Adjustment<'tcx>> {\n-        self.fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(needs))\n+        fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(fcx, needs))\n     }\n \n-    pub fn adjust_steps_as_infer_ok(&self, needs: Needs)\n+    pub fn adjust_steps_as_infer_ok(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>, needs: Needs)\n                                     -> InferOk<'tcx, Vec<Adjustment<'tcx>>> {\n         let mut obligations = vec![];\n         let targets = self.steps.iter().skip(1).map(|&(ty, _)| ty)\n             .chain(iter::once(self.cur_ty));\n         let steps: Vec<_> = self.steps.iter().map(|&(source, kind)| {\n             if let AutoderefKind::Overloaded = kind {\n-                self.fcx.try_overloaded_deref(self.span, source, needs)\n+                fcx.try_overloaded_deref(self.span, source, needs)\n                     .and_then(|InferOk { value: method, obligations: o }| {\n                         obligations.extend(o);\n                         if let ty::Ref(region, _, mutbl) = method.sig.output().sty {\n@@ -220,8 +220,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         self\n     }\n \n-    pub fn finalize(self) {\n-        let fcx = self.fcx;\n+    pub fn finalize(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) {\n         fcx.register_predicates(self.into_obligations());\n     }\n \n@@ -233,7 +232,9 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn autoderef(&'a self, span: Span, base_ty: Ty<'tcx>) -> Autoderef<'a, 'gcx, 'tcx> {\n         Autoderef {\n-            fcx: self,\n+            infcx: &self.infcx,\n+            body_id: self.body_id,\n+            param_env: self.param_env,\n             steps: vec![],\n             cur_ty: self.resolve_type_vars_if_possible(&base_ty),\n             obligations: vec![],"}, {"sha": "a139310b2076c0bdb468ba786900ef15ba38319c", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/832ac110df0f58627ec1134bb9caf60d41f93f3c/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/832ac110df0f58627ec1134bb9caf60d41f93f3c/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=832ac110df0f58627ec1134bb9caf60d41f93f3c", "patch": "@@ -57,7 +57,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         while result.is_none() && autoderef.next().is_some() {\n             result = self.try_overloaded_call_step(call_expr, callee_expr, &autoderef);\n         }\n-        autoderef.finalize();\n+        autoderef.finalize(self);\n \n         let output = match result {\n             None => {\n@@ -89,15 +89,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 callee_expr: &'gcx hir::Expr,\n                                 autoderef: &Autoderef<'a, 'gcx, 'tcx>)\n                                 -> Option<CallStep<'tcx>> {\n-        let adjusted_ty = autoderef.unambiguous_final_ty();\n+        let adjusted_ty = autoderef.unambiguous_final_ty(self);\n         debug!(\"try_overloaded_call_step(call_expr={:?}, adjusted_ty={:?})\",\n                call_expr,\n                adjusted_ty);\n \n         // If the callee is a bare function or a closure, then we're all set.\n         match adjusted_ty.sty {\n             ty::FnDef(..) | ty::FnPtr(_) => {\n-                let adjustments = autoderef.adjust_steps(Needs::None);\n+                let adjustments = autoderef.adjust_steps(self, Needs::None);\n                 self.apply_adjustments(callee_expr, adjustments);\n                 return Some(CallStep::Builtin(adjusted_ty));\n             }\n@@ -115,7 +115,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         infer::FnCall,\n                         &closure_ty\n                     ).0;\n-                    let adjustments = autoderef.adjust_steps(Needs::None);\n+                    let adjustments = autoderef.adjust_steps(self, Needs::None);\n                     self.record_deferred_call_resolution(def_id, DeferredCallResolution {\n                         call_expr,\n                         callee_expr,\n@@ -145,7 +145,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         self.try_overloaded_call_traits(call_expr, adjusted_ty).map(|(autoref, method)| {\n-            let mut adjustments = autoderef.adjust_steps(Needs::None);\n+            let mut adjustments = autoderef.adjust_steps(self, Needs::None);\n             adjustments.extend(autoref);\n             self.apply_adjustments(callee_expr, adjustments);\n             CallStep::Overloaded(method)"}, {"sha": "d616d88905bbf298a9abff93de591c5fc5931887", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/832ac110df0f58627ec1134bb9caf60d41f93f3c/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/832ac110df0f58627ec1134bb9caf60d41f93f3c/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=832ac110df0f58627ec1134bb9caf60d41f93f3c", "patch": "@@ -419,7 +419,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         let needs = Needs::maybe_mut_place(mt_b.mutbl);\n         let InferOk { value: mut adjustments, obligations: o }\n-            = autoderef.adjust_steps_as_infer_ok(needs);\n+            = autoderef.adjust_steps_as_infer_ok(self, needs);\n         obligations.extend(o);\n         obligations.extend(autoderef.into_obligations());\n "}, {"sha": "3902dddd0d4761d1007d57b6fae75e44a4fcaec6", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/832ac110df0f58627ec1134bb9caf60d41f93f3c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/832ac110df0f58627ec1134bb9caf60d41f93f3c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=832ac110df0f58627ec1134bb9caf60d41f93f3c", "patch": "@@ -161,9 +161,9 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         let (_, n) = autoderef.nth(pick.autoderefs).unwrap();\n         assert_eq!(n, pick.autoderefs);\n \n-        let mut adjustments = autoderef.adjust_steps(Needs::None);\n+        let mut adjustments = autoderef.adjust_steps(self, Needs::None);\n \n-        let mut target = autoderef.unambiguous_final_ty();\n+        let mut target = autoderef.unambiguous_final_ty(self);\n \n         if let Some(mutbl) = pick.autoref {\n             let region = self.next_region_var(infer::Autoref(self.span));\n@@ -202,7 +202,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             assert!(pick.unsize.is_none());\n         }\n \n-        autoderef.finalize();\n+        autoderef.finalize(self);\n \n         // Write out the final adjustments.\n         self.apply_adjustments(self.self_expr, adjustments);"}, {"sha": "d4c010b45dfdeccdb937fbba58bee9b35213c33b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/832ac110df0f58627ec1134bb9caf60d41f93f3c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/832ac110df0f58627ec1134bb9caf60d41f93f3c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=832ac110df0f58627ec1134bb9caf60d41f93f3c", "patch": "@@ -2554,7 +2554,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         while result.is_none() && autoderef.next().is_some() {\n             result = self.try_index_step(expr, base_expr, &autoderef, needs, idx_ty);\n         }\n-        autoderef.finalize();\n+        autoderef.finalize(self);\n         result\n     }\n \n@@ -2571,7 +2571,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       index_ty: Ty<'tcx>)\n                       -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)>\n     {\n-        let adjusted_ty = autoderef.unambiguous_final_ty();\n+        let adjusted_ty = autoderef.unambiguous_final_ty(self);\n         debug!(\"try_index_step(expr={:?}, base_expr={:?}, adjusted_ty={:?}, \\\n                                index_ty={:?})\",\n                expr,\n@@ -2601,7 +2601,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 debug!(\"try_index_step: success, using overloaded indexing\");\n                 let method = self.register_infer_ok_obligations(ok);\n \n-                let mut adjustments = autoderef.adjust_steps(needs);\n+                let mut adjustments = autoderef.adjust_steps(self, needs);\n                 if let ty::Ref(region, _, r_mutbl) = method.sig.inputs()[0].sty {\n                     let mutbl = match r_mutbl {\n                         hir::MutImmutable => AutoBorrowMutability::Immutable,\n@@ -3295,9 +3295,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // of error recovery.\n                         self.write_field_index(expr.id, index);\n                         if field.vis.is_accessible_from(def_scope, self.tcx) {\n-                            let adjustments = autoderef.adjust_steps(needs);\n+                            let adjustments = autoderef.adjust_steps(self, needs);\n                             self.apply_adjustments(base, adjustments);\n-                            autoderef.finalize();\n+                            autoderef.finalize(self);\n \n                             self.tcx.check_stability(field.did, Some(expr.id), expr.span);\n                             return field_ty;\n@@ -3310,9 +3310,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if let Ok(index) = fstr.parse::<usize>() {\n                         if fstr == index.to_string() {\n                             if let Some(field_ty) = tys.get(index) {\n-                                let adjustments = autoderef.adjust_steps(needs);\n+                                let adjustments = autoderef.adjust_steps(self, needs);\n                                 self.apply_adjustments(base, adjustments);\n-                                autoderef.finalize();\n+                                autoderef.finalize(self);\n \n                                 self.write_field_index(expr.id, index);\n                                 return field_ty;\n@@ -3323,7 +3323,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 _ => {}\n             }\n         }\n-        autoderef.unambiguous_final_ty();\n+        autoderef.unambiguous_final_ty(self);\n \n         if let Some((did, field_ty)) = private_candidate {\n             let struct_path = self.tcx().item_path_str(did);"}, {"sha": "e24548cfb239fd6cdcd0e5b1b1fc2ab24a442958", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/832ac110df0f58627ec1134bb9caf60d41f93f3c/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/832ac110df0f58627ec1134bb9caf60d41f93f3c/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=832ac110df0f58627ec1134bb9caf60d41f93f3c", "patch": "@@ -766,7 +766,7 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                 potential_self_ty, self_ty);\n \n             if fcx.infcx.can_eq(fcx.param_env, self_ty, potential_self_ty).is_ok() {\n-                autoderef.finalize();\n+                autoderef.finalize(fcx);\n                 if let Some(mut err) = fcx.demand_eqtype_with_origin(\n                     &cause, self_ty, potential_self_ty) {\n                     err.emit();"}]}