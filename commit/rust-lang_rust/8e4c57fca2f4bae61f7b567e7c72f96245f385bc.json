{"sha": "8e4c57fca2f4bae61f7b567e7c72f96245f385bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNGM1N2ZjYTJmNGJhZTYxZjdiNTY3ZTdjNzJmOTYyNDVmMzg1YmM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-01-09T20:16:32Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-01-25T15:03:47Z"}, "message": "distinguish \"no data\" from \"heterogeneous\" for ABI purposes\n\nAlso, add a testing infrastructure and tests that lets us dump layout.", "tree": {"sha": "afbf7a76111a3a425c837171709eda9359c65e41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afbf7a76111a3a425c837171709eda9359c65e41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e4c57fca2f4bae61f7b567e7c72f96245f385bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e4c57fca2f4bae61f7b567e7c72f96245f385bc", "html_url": "https://github.com/rust-lang/rust/commit/8e4c57fca2f4bae61f7b567e7c72f96245f385bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "html_url": "https://github.com/rust-lang/rust/commit/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1"}], "stats": {"total": 512, "additions": 492, "deletions": 20}, "files": [{"sha": "55f9d8a1109ce75f50332b1ee1e0978685aee486", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=8e4c57fca2f4bae61f7b567e7c72f96245f385bc", "patch": "@@ -22,7 +22,7 @@ use rustc_incremental;\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::{self, CStore};\n use rustc_mir as mir;\n-use rustc_passes::{self, ast_validation, hir_stats, loops, rvalue_promotion};\n+use rustc_passes::{self, ast_validation, hir_stats, loops, rvalue_promotion, layout_test};\n use rustc_plugin as plugin;\n use rustc_plugin::registry::Registry;\n use rustc_privacy;\n@@ -1287,6 +1287,9 @@ where\n                     mir::transform::check_unsafety::check_unsafety(tcx, def_id)\n                 }\n             });\n+\n+            time(sess, \"layout testing\", || layout_test::test_layout(tcx));\n+\n             // Avoid overwhelming user with errors if type checking failed.\n             // I'm not sure how helpful this is, to be honest, but it avoids\n             // a"}, {"sha": "d21707c578b2ac536e1813357216e990faeb9ebb", "filename": "src/librustc_passes/layout_test.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=8e4c57fca2f4bae61f7b567e7c72f96245f385bc", "patch": "@@ -0,0 +1,132 @@\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::hir::ItemKind;\n+use rustc::ty::layout::HasDataLayout;\n+use rustc::ty::layout::HasTyCtxt;\n+use rustc::ty::layout::LayoutOf;\n+use rustc::ty::layout::TargetDataLayout;\n+use rustc::ty::layout::TyLayout;\n+use rustc::ty::ParamEnv;\n+use rustc::ty::Ty;\n+use rustc::ty::TyCtxt;\n+use syntax::ast::Attribute;\n+\n+pub fn test_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    if tcx.features().rustc_attrs {\n+        // if the `rustc_attrs` feature is not enabled, don't bother testing layout\n+        tcx.hir()\n+            .krate()\n+            .visit_all_item_likes(&mut VarianceTest { tcx });\n+    }\n+}\n+\n+struct VarianceTest<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+}\n+\n+impl<'a, 'tcx> ItemLikeVisitor<'tcx> for VarianceTest<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        let item_def_id = self.tcx.hir().local_def_id(item.id);\n+\n+        if let ItemKind::Ty(..) = item.node {\n+            for attr in self.tcx.get_attrs(item_def_id).iter() {\n+                if attr.check_name(\"rustc_layout\") {\n+                    self.dump_layout_of(item_def_id, item, attr);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem) {}\n+    fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) {}\n+}\n+\n+impl<'a, 'tcx> VarianceTest<'a, 'tcx> {\n+    fn dump_layout_of(&self, item_def_id: DefId, item: &hir::Item, attr: &Attribute) {\n+        let tcx = self.tcx;\n+        let param_env = self.tcx.param_env(item_def_id);\n+        let ty = self.tcx.type_of(item_def_id);\n+        match self.tcx.layout_of(param_env.and(ty)) {\n+            Ok(ty_layout) => {\n+                // Check out the `#[rustc_layout(..)]` attribute to tell what to dump.\n+                // The `..` are the names of fields to dump.\n+                let meta_items = attr.meta_item_list().unwrap_or_default();\n+                for meta_item in meta_items {\n+                    let name = meta_item.word().map(|mi| mi.name().as_str());\n+                    let name = name.as_ref().map(|s| &s[..]).unwrap_or(\"\");\n+\n+                    match name {\n+                        \"abi\" => {\n+                            self.tcx\n+                                .sess\n+                                .span_err(item.span, &format!(\"abi: {:?}\", ty_layout.abi));\n+                        }\n+\n+                        \"align\" => {\n+                            self.tcx\n+                                .sess\n+                                .span_err(item.span, &format!(\"align: {:?}\", ty_layout.align));\n+                        }\n+\n+                        \"size\" => {\n+                            self.tcx\n+                                .sess\n+                                .span_err(item.span, &format!(\"size: {:?}\", ty_layout.size));\n+                        }\n+\n+                        \"homogeneous_aggregate\" => {\n+                            self.tcx.sess.span_err(\n+                                item.span,\n+                                &format!(\n+                                    \"homogeneous_aggregate: {:?}\",\n+                                    ty_layout\n+                                        .homogeneous_aggregate(&UnwrapLayoutCx { tcx, param_env }),\n+                                ),\n+                            );\n+                        }\n+\n+                        _ => {\n+                            self.tcx.sess.span_err(\n+                                meta_item.span,\n+                                &format!(\"unrecognized field name `{}`\", name),\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+\n+            Err(layout_error) => {\n+                self.tcx\n+                    .sess\n+                    .span_err(item.span, &format!(\"layout error: {:?}\", layout_error));\n+            }\n+        }\n+    }\n+}\n+\n+struct UnwrapLayoutCx<'me, 'tcx> {\n+    tcx: TyCtxt<'me, 'tcx, 'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+}\n+\n+impl<'me, 'tcx> LayoutOf for UnwrapLayoutCx<'me, 'tcx> {\n+    type Ty = Ty<'tcx>;\n+    type TyLayout = TyLayout<'tcx>;\n+\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n+        self.tcx.layout_of(self.param_env.and(ty)).unwrap()\n+    }\n+}\n+\n+impl<'me, 'tcx> HasTyCtxt<'tcx> for UnwrapLayoutCx<'me, 'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n+}\n+\n+impl<'me, 'tcx> HasDataLayout for UnwrapLayoutCx<'me, 'tcx> {\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        self.tcx.data_layout()\n+    }\n+}"}, {"sha": "a181bc7e9b480dc8bbf56bc664dd8cb333b11fab", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=8e4c57fca2f4bae61f7b567e7c72f96245f385bc", "patch": "@@ -32,6 +32,7 @@ mod diagnostics;\n pub mod ast_validation;\n pub mod rvalue_promotion;\n pub mod hir_stats;\n+pub mod layout_test;\n pub mod loops;\n \n __build_diagnostic_array! { librustc_passes, DIAGNOSTICS }"}, {"sha": "9f9bba14b963e8428ffc225606fdf2fc40a470eb", "filename": "src/librustc_target/abi/call/aarch64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs?ref=8e4c57fca2f4bae61f7b567e7c72f96245f385bc", "patch": "@@ -6,7 +6,7 @@ fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n-    arg.layout.homogeneous_aggregate(cx).and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).unit().and_then(|unit| {\n         let size = arg.layout.size;\n \n         // Ensure we have at most four uniquely addressable members."}, {"sha": "228dd36216158976b1926b894f7aca7d1ca95da9", "filename": "src/librustc_target/abi/call/arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs?ref=8e4c57fca2f4bae61f7b567e7c72f96245f385bc", "patch": "@@ -7,7 +7,7 @@ fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n-    arg.layout.homogeneous_aggregate(cx).and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).unit().and_then(|unit| {\n         let size = arg.layout.size;\n \n         // Ensure we have at most four uniquely addressable members."}, {"sha": "85444500c5e11752e13d4653fb0b7ed8fa0d74a7", "filename": "src/librustc_target/abi/call/asmjs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Flibrustc_target%2Fabi%2Fcall%2Fasmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Flibrustc_target%2Fabi%2Fcall%2Fasmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fasmjs.rs?ref=8e4c57fca2f4bae61f7b567e7c72f96245f385bc", "patch": "@@ -11,7 +11,7 @@ fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'a, Ty>)\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n     if ret.layout.is_aggregate() {\n-        if let Some(unit) = ret.layout.homogeneous_aggregate(cx) {\n+        if let Some(unit) = ret.layout.homogeneous_aggregate(cx).unit() {\n             let size = ret.layout.size;\n             if unit.size == size {\n                 ret.cast_to(Uniform {"}, {"sha": "0d50439c67ec08495698a6b6b5807c8d7f8c6fa3", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 66, "deletions": 13, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=8e4c57fca2f4bae61f7b567e7c72f96245f385bc", "patch": "@@ -228,6 +228,33 @@ impl CastTarget {\n     }\n }\n \n+/// Return value from the `homogeneous_aggregate` test function.\n+#[derive(Copy, Clone, Debug)]\n+pub enum HomogeneousAggregate {\n+    /// Yes, all the \"leaf fields\" of this struct are passed in the\n+    /// same way (specified in the `Reg` value).\n+    Homogeneous(Reg),\n+\n+    /// There are distinct leaf fields passed in different ways,\n+    /// or this is uninhabited.\n+    Heterogeneous,\n+\n+    /// There are no leaf fields at all.\n+    NoData,\n+}\n+\n+impl HomogeneousAggregate {\n+    /// If this is a homogeneous aggregate, returns the homogeneous\n+    /// unit, else `None`.\n+    pub fn unit(self) -> Option<Reg> {\n+        if let HomogeneousAggregate::Homogeneous(r) = self {\n+            Some(r)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n impl<'a, Ty> TyLayout<'a, Ty> {\n     fn is_aggregate(&self) -> bool {\n         match self.abi {\n@@ -239,11 +266,21 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n         }\n     }\n \n-    fn homogeneous_aggregate<C>(&self, cx: &C) -> Option<Reg>\n+    /// True if this layout is an aggregate containing fields of only\n+    /// a single type (e.g., `(u32, u32)`). Such aggregates are often\n+    /// special-cased in ABIs.\n+    ///\n+    /// Note: We generally ignore fields of zero-sized type when computing\n+    /// this value (cc #56877).\n+    ///\n+    /// This is public so that it can be used in unit tests, but\n+    /// should generally only be relevant to the ABI details of\n+    /// specific targets.\n+    pub fn homogeneous_aggregate<C>(&self, cx: &C) -> HomogeneousAggregate\n         where Ty: TyLayoutMethods<'a, C> + Copy, C: LayoutOf<Ty = Ty, TyLayout = Self>\n     {\n         match self.abi {\n-            Abi::Uninhabited => None,\n+            Abi::Uninhabited => HomogeneousAggregate::Heterogeneous,\n \n             // The primitive for this algorithm.\n             Abi::Scalar(ref scalar) => {\n@@ -252,14 +289,15 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n                     abi::Pointer => RegKind::Integer,\n                     abi::Float(_) => RegKind::Float,\n                 };\n-                Some(Reg {\n+                HomogeneousAggregate::Homogeneous(Reg {\n                     kind,\n                     size: self.size\n                 })\n             }\n \n             Abi::Vector { .. } => {\n-                Some(Reg {\n+                assert!(!self.is_zst());\n+                HomogeneousAggregate::Homogeneous(Reg {\n                     kind: RegKind::Vector,\n                     size: self.size\n                 })\n@@ -275,7 +313,7 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n                         if count > 0 {\n                             return self.field(cx, 0).homogeneous_aggregate(cx);\n                         } else {\n-                            return None;\n+                            return HomogeneousAggregate::NoData;\n                         }\n                     }\n                     FieldPlacement::Union(_) => true,\n@@ -284,21 +322,27 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n \n                 for i in 0..self.fields.count() {\n                     if !is_union && total != self.fields.offset(i) {\n-                        return None;\n+                        return HomogeneousAggregate::Heterogeneous;\n                     }\n \n                     let field = self.field(cx, i);\n+\n                     match (result, field.homogeneous_aggregate(cx)) {\n-                        // The field itself must be a homogeneous aggregate.\n-                        (_, None) => return None,\n+                        (_, HomogeneousAggregate::NoData) => {\n+                            // Ignore fields that have no data\n+                        }\n+                        (_, HomogeneousAggregate::Heterogeneous) => {\n+                            // The field itself must be a homogeneous aggregate.\n+                            return HomogeneousAggregate::Heterogeneous;\n+                        }\n                         // If this is the first field, record the unit.\n-                        (None, Some(unit)) => {\n+                        (None, HomogeneousAggregate::Homogeneous(unit)) => {\n                             result = Some(unit);\n                         }\n                         // For all following fields, the unit must be the same.\n-                        (Some(prev_unit), Some(unit)) => {\n+                        (Some(prev_unit), HomogeneousAggregate::Homogeneous(unit)) => {\n                             if prev_unit != unit {\n-                                return None;\n+                                return HomogeneousAggregate::Heterogeneous;\n                             }\n                         }\n                     }\n@@ -314,9 +358,18 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n \n                 // There needs to be no padding.\n                 if total != self.size {\n-                    None\n+                    HomogeneousAggregate::Heterogeneous\n                 } else {\n-                    result\n+                    match result {\n+                        Some(reg) => {\n+                            assert_ne!(total, Size::ZERO);\n+                            HomogeneousAggregate::Homogeneous(reg)\n+                        }\n+                        None => {\n+                            assert_eq!(total, Size::ZERO);\n+                            HomogeneousAggregate::NoData\n+                        }\n+                    }\n                 }\n             }\n         }"}, {"sha": "305a2d4225056352f776f2df481e76efe8fe8dfc", "filename": "src/librustc_target/abi/call/powerpc64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs?ref=8e4c57fca2f4bae61f7b567e7c72f96245f385bc", "patch": "@@ -18,7 +18,7 @@ fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>, abi: A\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n-    arg.layout.homogeneous_aggregate(cx).and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).unit().and_then(|unit| {\n         // ELFv1 only passes one-member aggregates transparently.\n         // ELFv2 passes up to eight uniquely addressable members.\n         if (abi == ELFv1 && arg.layout.size > unit.size)"}, {"sha": "150b48a8d02550d06aa0f7ea5377dd9ee8fa4a4d", "filename": "src/librustc_target/abi/call/sparc64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs?ref=8e4c57fca2f4bae61f7b567e7c72f96245f385bc", "patch": "@@ -8,7 +8,7 @@ fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n-    arg.layout.homogeneous_aggregate(cx).and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).unit().and_then(|unit| {\n         // Ensure we have at most eight uniquely addressable members.\n         if arg.layout.size > unit.size.checked_mul(8, cx).unwrap() {\n             return None;"}, {"sha": "648a4b5bb9d79cb1ceb96000145f9d3ab3363c0d", "filename": "src/librustc_target/abi/call/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs?ref=8e4c57fca2f4bae61f7b567e7c72f96245f385bc", "patch": "@@ -99,7 +99,7 @@ pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>, flavor: Fla\n             };\n \n             // At this point we know this must be a primitive of sorts.\n-            let unit = arg.layout.homogeneous_aggregate(cx).unwrap();\n+            let unit = arg.layout.homogeneous_aggregate(cx).unit().unwrap();\n             assert_eq!(unit.size, arg.layout.size);\n             if unit.kind == RegKind::Float {\n                 continue;"}, {"sha": "85e80f7bdaf19f0c882c79183a1190d601e4257e", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=8e4c57fca2f4bae61f7b567e7c72f96245f385bc", "patch": "@@ -938,6 +938,13 @@ pub const BUILTIN_ATTRIBUTES: &[(&str, AttributeType, AttributeTemplate, Attribu\n                                       is just used for rustc unit tests \\\n                                       and will never be stable\",\n                                      cfg_fn!(rustc_attrs))),\n+    (\"rustc_layout\", Normal, template!(List: \"field1, field2, ...\"),\n+     Gated(Stability::Unstable,\n+           \"rustc_attrs\",\n+           \"the `#[rustc_layout]` attribute \\\n+            is just used for rustc unit tests \\\n+            and will never be stable\",\n+           cfg_fn!(rustc_attrs))),\n     (\"rustc_regions\", Normal, template!(Word), Gated(Stability::Unstable,\n                                     \"rustc_attrs\",\n                                     \"the `#[rustc_regions]` attribute \\"}, {"sha": "622709e7de58472f962767fd2923055425c9e8fb", "filename": "src/test/ui/layout/homogeneous-aggr-zero-sized-c-struct.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.rs?ref=8e4c57fca2f4bae61f7b567e7c72f96245f385bc", "patch": "@@ -0,0 +1,36 @@\n+#![feature(rustc_attrs)]\n+\n+// Show that `homogeneous_aggregate` code ignores zero-length C\n+// arrays.  This matches the recent C standard, though not the\n+// behavior of all older compilers, which somtimes consider `T[0]` to\n+// be a \"flexible array member\" (see discussion on #56877 for\n+// details).\n+\n+#[repr(C)]\n+pub struct Foo {\n+    x: u32\n+}\n+\n+#[repr(C)]\n+pub struct Middle {\n+    pub a: f32,\n+    pub foo: [Foo; 0],\n+    pub b: f32,\n+}\n+\n+#[rustc_layout(homogeneous_aggregate)]\n+pub type TestMiddle = Middle;\n+//~^ ERROR homogeneous_aggregate: Homogeneous\n+\n+#[repr(C)]\n+pub struct Final {\n+    pub a: f32,\n+    pub b: f32,\n+    pub foo: [Foo; 0],\n+}\n+\n+#[rustc_layout(homogeneous_aggregate)]\n+pub type TestFinal = Final;\n+//~^ ERROR homogeneous_aggregate: Homogeneous\n+\n+fn main() { }"}, {"sha": "0d442606351875787fdaed1f50d6b0239272f3c5", "filename": "src/test/ui/layout/homogeneous-aggr-zero-sized-c-struct.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.stderr?ref=8e4c57fca2f4bae61f7b567e7c72f96245f385bc", "patch": "@@ -0,0 +1,14 @@\n+error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+  --> $DIR/homogeneous-aggr-zero-sized-c-struct.rs:22:1\n+   |\n+LL | pub type TestMiddle = Middle;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+  --> $DIR/homogeneous-aggr-zero-sized-c-struct.rs:33:1\n+   |\n+LL | pub type TestFinal = Final;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "4b429412aebfc2a9e63c25f38e05a6f12efd156d", "filename": "src/test/ui/layout/homogeneous-aggr-zero-sized-repr-rust.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.rs?ref=8e4c57fca2f4bae61f7b567e7c72f96245f385bc", "patch": "@@ -0,0 +1,73 @@\n+#![feature(rustc_attrs)]\n+\n+// Regression test for #56877. We want to ensure that the presence of\n+// `PhantomData` does not prevent `Bar` from being considered a\n+// homogeneous aggregate.\n+\n+#[repr(C)]\n+pub struct BaseCase {\n+    pub a: f32,\n+    pub b: f32,\n+}\n+\n+#[repr(C)]\n+pub struct WithPhantomData {\n+    pub a: f32,\n+    pub b: f32,\n+    pub _unit: std::marker::PhantomData<()>,\n+}\n+\n+pub struct EmptyRustStruct {\n+}\n+\n+#[repr(C)]\n+pub struct WithEmptyRustStruct {\n+    pub a: f32,\n+    pub b: f32,\n+    pub _unit: EmptyRustStruct,\n+}\n+\n+pub struct TransitivelyEmptyRustStruct {\n+    field: EmptyRustStruct,\n+    array: [u32; 0],\n+}\n+\n+#[repr(C)]\n+pub struct WithTransitivelyEmptyRustStruct {\n+    pub a: f32,\n+    pub b: f32,\n+    pub _unit: TransitivelyEmptyRustStruct,\n+}\n+\n+pub enum EmptyRustEnum {\n+    Dummy,\n+}\n+\n+#[repr(C)]\n+pub struct WithEmptyRustEnum {\n+    pub a: f32,\n+    pub b: f32,\n+    pub _unit: EmptyRustEnum,\n+}\n+\n+#[rustc_layout(homogeneous_aggregate)]\n+pub type Test1 = BaseCase;\n+//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+\n+#[rustc_layout(homogeneous_aggregate)]\n+pub type Test2 = WithPhantomData;\n+//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+\n+#[rustc_layout(homogeneous_aggregate)]\n+pub type Test3 = WithEmptyRustStruct;\n+//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+\n+#[rustc_layout(homogeneous_aggregate)]\n+pub type Test4 = WithTransitivelyEmptyRustStruct;\n+//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+\n+#[rustc_layout(homogeneous_aggregate)]\n+pub type Test5 = WithEmptyRustEnum;\n+//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+\n+fn main() { }"}, {"sha": "be04ba3e7f6cb7a3685cee5c956ea35969a6db84", "filename": "src/test/ui/layout/homogeneous-aggr-zero-sized-repr-rust.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.stderr?ref=8e4c57fca2f4bae61f7b567e7c72f96245f385bc", "patch": "@@ -0,0 +1,32 @@\n+error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+  --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:54:1\n+   |\n+LL | pub type Test1 = BaseCase;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+  --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:58:1\n+   |\n+LL | pub type Test2 = WithPhantomData;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+  --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:62:1\n+   |\n+LL | pub type Test3 = WithEmptyRustStruct;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+  --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:66:1\n+   |\n+LL | pub type Test4 = WithTransitivelyEmptyRustStruct;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+  --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:70:1\n+   |\n+LL | pub type Test5 = WithEmptyRustEnum;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "68b218249eb9a84a799dce33cb97ad3d91336bc7", "filename": "src/test/ui/layout/zero-sized-array-union.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.rs?ref=8e4c57fca2f4bae61f7b567e7c72f96245f385bc", "patch": "@@ -0,0 +1,95 @@\n+#![feature(rustc_attrs)]\n+\n+// Various tests around the behavior of zero-sized arrays and\n+// unions. This matches the behavior of modern C compilers, though\n+// older compilers (and sometimes clang) treat `T[0]` as a \"flexible\n+// array member\". See more\n+// details in #56877.\n+\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+struct Empty { }\n+\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+struct Empty2 {\n+    e: Empty\n+}\n+\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+struct Empty3 {\n+    z: [f32; 0],\n+}\n+\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+struct Empty4 {\n+    e: Empty3\n+}\n+\n+#[repr(C)]\n+union U1 {\n+    s: Empty\n+}\n+\n+#[repr(C)]\n+union U2 {\n+    s: Empty2\n+}\n+\n+#[repr(C)]\n+union U3 {\n+    s: Empty3\n+}\n+\n+#[repr(C)]\n+union U4 {\n+    s: Empty4\n+}\n+\n+#[repr(C)]\n+struct Baz1 {\n+    x: f32,\n+    y: f32,\n+    u: U1,\n+}\n+\n+#[rustc_layout(homogeneous_aggregate)]\n+type TestBaz1 = Baz1;\n+//~^ ERROR homogeneous_aggregate: Homogeneous\n+\n+#[repr(C)]\n+struct Baz2 {\n+    x: f32,\n+    y: f32,\n+    u: U2,\n+}\n+\n+#[rustc_layout(homogeneous_aggregate)]\n+type TestBaz2 = Baz2;\n+//~^ ERROR homogeneous_aggregate: Homogeneous\n+\n+#[repr(C)]\n+struct Baz3 {\n+    x: f32,\n+    y: f32,\n+    u: U3,\n+}\n+\n+#[rustc_layout(homogeneous_aggregate)]\n+type TestBaz3 = Baz3;\n+//~^ ERROR homogeneous_aggregate: Homogeneous\n+\n+#[repr(C)]\n+struct Baz4 {\n+    x: f32,\n+    y: f32,\n+    u: U4,\n+}\n+\n+#[rustc_layout(homogeneous_aggregate)]\n+type TestBaz4 = Baz4;\n+//~^ ERROR homogeneous_aggregate: Homogeneous\n+\n+fn main() { }"}, {"sha": "1bb31aaf7b7b90cbd2790933971e20111895f64b", "filename": "src/test/ui/layout/zero-sized-array-union.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8e4c57fca2f4bae61f7b567e7c72f96245f385bc/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.stderr?ref=8e4c57fca2f4bae61f7b567e7c72f96245f385bc", "patch": "@@ -0,0 +1,26 @@\n+error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+  --> $DIR/zero-sized-array-union.rs:59:1\n+   |\n+LL | type TestBaz1 = Baz1;\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+  --> $DIR/zero-sized-array-union.rs:70:1\n+   |\n+LL | type TestBaz2 = Baz2;\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+  --> $DIR/zero-sized-array-union.rs:81:1\n+   |\n+LL | type TestBaz3 = Baz3;\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+  --> $DIR/zero-sized-array-union.rs:92:1\n+   |\n+LL | type TestBaz4 = Baz4;\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}]}