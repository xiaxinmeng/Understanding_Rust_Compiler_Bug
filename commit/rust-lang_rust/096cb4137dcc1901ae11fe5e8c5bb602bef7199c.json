{"sha": "096cb4137dcc1901ae11fe5e8c5bb602bef7199c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5NmNiNDEzN2RjYzE5MDFhZTExZmU1ZThjNWJiNjAyYmVmNzE5OWM=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-07-09T13:51:56Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-07-10T11:13:57Z"}, "message": "Remove writer function from PrintState", "tree": {"sha": "6faac7bc6635d7d316c6f5254fbf34069af41412", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6faac7bc6635d7d316c6f5254fbf34069af41412"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/096cb4137dcc1901ae11fe5e8c5bb602bef7199c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/096cb4137dcc1901ae11fe5e8c5bb602bef7199c", "html_url": "https://github.com/rust-lang/rust/commit/096cb4137dcc1901ae11fe5e8c5bb602bef7199c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/096cb4137dcc1901ae11fe5e8c5bb602bef7199c/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73c1752b8e9a6edb38cfadec25e430320300730b", "url": "https://api.github.com/repos/rust-lang/rust/commits/73c1752b8e9a6edb38cfadec25e430320300730b", "html_url": "https://github.com/rust-lang/rust/commit/73c1752b8e9a6edb38cfadec25e430320300730b"}], "stats": {"total": 75, "additions": 33, "deletions": 42}, "files": [{"sha": "5a14b30e699bedd99a5dad56036958e57b93326f", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/096cb4137dcc1901ae11fe5e8c5bb602bef7199c/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096cb4137dcc1901ae11fe5e8c5bb602bef7199c/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=096cb4137dcc1901ae11fe5e8c5bb602bef7199c", "patch": "@@ -87,10 +87,6 @@ impl std::ops::DerefMut for State<'_> {\n }\n \n impl<'a> PrintState<'a> for State<'a> {\n-    fn writer(&mut self) -> &mut pp::Printer {\n-        &mut self.s\n-    }\n-\n     fn comments(&mut self) -> &mut Option<Comments<'a>> {\n         &mut self.comments\n     }\n@@ -1182,7 +1178,7 @@ impl<'a> State<'a> {\n \n     fn print_literal(&mut self, lit: &hir::Lit) {\n         self.maybe_print_comment(lit.span.lo());\n-        self.writer().word(lit.node.to_lit_token().to_string())\n+        self.word(lit.node.to_lit_token().to_string())\n     }\n \n     pub fn print_expr(&mut self, expr: &hir::Expr) {"}, {"sha": "8da8d3dc540bf6d32539d77d4e7421d3472e3ba7", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 32, "deletions": 37, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/096cb4137dcc1901ae11fe5e8c5bb602bef7199c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096cb4137dcc1901ae11fe5e8c5bb602bef7199c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=096cb4137dcc1901ae11fe5e8c5bb602bef7199c", "patch": "@@ -446,7 +446,6 @@ impl std::ops::DerefMut for State<'_> {\n }\n \n pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefMut {\n-    fn writer(&mut self) -> &mut pp::Printer;\n     fn comments(&mut self) -> &mut Option<Comments<'a>>;\n \n     fn commasep<T, F>(&mut self, b: Breaks, elts: &[T], mut op: F)\n@@ -476,51 +475,51 @@ pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefM\n         match cmnt.style {\n             comments::Mixed => {\n                 assert_eq!(cmnt.lines.len(), 1);\n-                self.writer().zerobreak();\n-                self.writer().word(cmnt.lines[0].clone());\n-                self.writer().zerobreak()\n+                self.zerobreak();\n+                self.word(cmnt.lines[0].clone());\n+                self.zerobreak()\n             }\n             comments::Isolated => {\n                 self.hardbreak_if_not_bol();\n                 for line in &cmnt.lines {\n                     // Don't print empty lines because they will end up as trailing\n                     // whitespace\n                     if !line.is_empty() {\n-                        self.writer().word(line.clone());\n+                        self.word(line.clone());\n                     }\n-                    self.writer().hardbreak();\n+                    self.hardbreak();\n                 }\n             }\n             comments::Trailing => {\n-                if !self.writer().is_beginning_of_line() {\n-                    self.writer().word(\" \");\n+                if !self.is_beginning_of_line() {\n+                    self.word(\" \");\n                 }\n                 if cmnt.lines.len() == 1 {\n-                    self.writer().word(cmnt.lines[0].clone());\n-                    self.writer().hardbreak()\n+                    self.word(cmnt.lines[0].clone());\n+                    self.hardbreak()\n                 } else {\n                     self.ibox(0);\n                     for line in &cmnt.lines {\n                         if !line.is_empty() {\n-                            self.writer().word(line.clone());\n+                            self.word(line.clone());\n                         }\n-                        self.writer().hardbreak();\n+                        self.hardbreak();\n                     }\n                     self.end();\n                 }\n             }\n             comments::BlankLine => {\n                 // We need to do at least one, possibly two hardbreaks.\n-                let twice = match self.writer().last_token() {\n+                let twice = match self.last_token() {\n                     pp::Token::String(s) => \";\" == s,\n                     pp::Token::Begin(_) => true,\n                     pp::Token::End => true,\n                     _ => false\n                 };\n                 if twice {\n-                    self.writer().hardbreak();\n+                    self.hardbreak();\n                 }\n-                self.writer().hardbreak();\n+                self.hardbreak();\n             }\n         }\n         if let Some(cm) = self.comments() {\n@@ -534,7 +533,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefM\n \n     fn print_literal(&mut self, lit: &ast::Lit) {\n         self.maybe_print_comment(lit.span.lo());\n-        self.writer().word(lit.token.to_string())\n+        self.word(lit.token.to_string())\n     }\n \n     fn print_string(&mut self, st: &str,\n@@ -549,7 +548,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefM\n                          string=st))\n             }\n         };\n-        self.writer().word(st)\n+        self.word(st)\n     }\n \n     fn print_inner_attributes(&mut self,\n@@ -601,10 +600,10 @@ pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefM\n     fn print_attribute_path(&mut self, path: &ast::Path) {\n         for (i, segment) in path.segments.iter().enumerate() {\n             if i > 0 {\n-                self.writer().word(\"::\");\n+                self.word(\"::\");\n             }\n             if segment.ident.name != kw::PathRoot {\n-                self.writer().word(ident_to_string(segment.ident, segment.ident.is_raw_guess()));\n+                self.word(ident_to_string(segment.ident, segment.ident.is_raw_guess()));\n             }\n         }\n     }\n@@ -620,21 +619,21 @@ pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefM\n         }\n         self.maybe_print_comment(attr.span.lo());\n         if attr.is_sugared_doc {\n-            self.writer().word(attr.value_str().unwrap().as_str().to_string());\n-            self.writer().hardbreak()\n+            self.word(attr.value_str().unwrap().as_str().to_string());\n+            self.hardbreak()\n         } else {\n             match attr.style {\n-                ast::AttrStyle::Inner => self.writer().word(\"#![\"),\n-                ast::AttrStyle::Outer => self.writer().word(\"#[\"),\n+                ast::AttrStyle::Inner => self.word(\"#![\"),\n+                ast::AttrStyle::Outer => self.word(\"#[\"),\n             }\n             if let Some(mi) = attr.meta() {\n                 self.print_meta_item(&mi);\n             } else {\n                 self.print_attribute_path(&attr.path);\n-                self.writer().space();\n+                self.space();\n                 self.print_tts(attr.tokens.clone());\n             }\n-            self.writer().word(\"]\");\n+            self.word(\"]\");\n         }\n     }\n \n@@ -655,7 +654,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefM\n             ast::MetaItemKind::Word => self.print_attribute_path(&item.path),\n             ast::MetaItemKind::NameValue(ref value) => {\n                 self.print_attribute_path(&item.path);\n-                self.writer().space();\n+                self.space();\n                 self.word_space(\"=\");\n                 self.print_literal(value);\n             }\n@@ -681,20 +680,20 @@ pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefM\n     fn print_tt(&mut self, tt: tokenstream::TokenTree, convert_dollar_crate: bool) {\n         match tt {\n             TokenTree::Token(ref token) => {\n-                self.writer().word(token_to_string_ext(&token, convert_dollar_crate));\n+                self.word(token_to_string_ext(&token, convert_dollar_crate));\n                 match token.kind {\n                     token::DocComment(..) => {\n-                        self.writer().hardbreak()\n+                        self.hardbreak()\n                     }\n                     _ => {}\n                 }\n             }\n             TokenTree::Delimited(_, delim, tts) => {\n-                self.writer().word(token_kind_to_string(&token::OpenDelim(delim)));\n-                self.writer().space();\n+                self.word(token_kind_to_string(&token::OpenDelim(delim)));\n+                self.space();\n                 self.print_tts(tts);\n-                self.writer().space();\n-                self.writer().word(token_kind_to_string(&token::CloseDelim(delim)))\n+                self.space();\n+                self.word(token_kind_to_string(&token::CloseDelim(delim)))\n             },\n         }\n     }\n@@ -707,7 +706,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefM\n         self.ibox(0);\n         for (i, tt) in tts.into_trees().enumerate() {\n             if i != 0 {\n-                self.writer().space();\n+                self.space();\n             }\n             self.print_tt(tt, convert_dollar_crate);\n         }\n@@ -716,10 +715,6 @@ pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefM\n }\n \n impl<'a> PrintState<'a> for State<'a> {\n-    fn writer(&mut self) -> &mut pp::Printer {\n-        &mut self.s\n-    }\n-\n     fn comments(&mut self) -> &mut Option<Comments<'a>> {\n         &mut self.comments\n     }"}]}