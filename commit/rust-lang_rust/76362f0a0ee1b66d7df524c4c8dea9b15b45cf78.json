{"sha": "76362f0a0ee1b66d7df524c4c8dea9b15b45cf78", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2MzYyZjBhMGVlMWI2NmQ3ZGY1MjRjNGM4ZGVhOWIxNWI0NWNmNzg=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-22T22:46:40Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-30T15:37:44Z"}, "message": "custom message for refutable patterns in for loops", "tree": {"sha": "db45562431cfa6109a45a0e13f98b70252e2bb42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db45562431cfa6109a45a0e13f98b70252e2bb42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76362f0a0ee1b66d7df524c4c8dea9b15b45cf78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76362f0a0ee1b66d7df524c4c8dea9b15b45cf78", "html_url": "https://github.com/rust-lang/rust/commit/76362f0a0ee1b66d7df524c4c8dea9b15b45cf78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76362f0a0ee1b66d7df524c4c8dea9b15b45cf78/comments", "author": null, "committer": null, "parents": [{"sha": "5e1820f34611e311759518440fd4129c5f0c322a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e1820f34611e311759518440fd4129c5f0c322a", "html_url": "https://github.com/rust-lang/rust/commit/5e1820f34611e311759518440fd4129c5f0c322a"}], "stats": {"total": 47, "additions": 38, "deletions": 9}, "files": [{"sha": "e594d462ff385d77a10792ff1e7ef4e26c2907ed", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76362f0a0ee1b66d7df524c4c8dea9b15b45cf78/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76362f0a0ee1b66d7df524c4c8dea9b15b45cf78/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=76362f0a0ee1b66d7df524c4c8dea9b15b45cf78", "patch": "@@ -1163,6 +1163,7 @@ impl LintPass for UnusedParens {\n                 ast::MatchSource::Normal => (head, \"`match` head expression\", true),\n                 ast::MatchSource::IfLetDesugar { .. } => (head, \"`if let` head expression\", true),\n                 ast::MatchSource::WhileLetDesugar => (head, \"`while let` head expression\", true),\n+                ast::MatchSource::ForLoopDesugar => (head, \"`for` head expression\", true),\n             },\n             ast::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n             ast::ExprAssign(_, ref value) => (value, \"assigned value\", false),"}, {"sha": "86ab26ea40d940bdbd18fb9499026399da6a54e4", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/76362f0a0ee1b66d7df524c4c8dea9b15b45cf78/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76362f0a0ee1b66d7df524c4c8dea9b15b45cf78/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=76362f0a0ee1b66d7df524c4c8dea9b15b45cf78", "patch": "@@ -221,7 +221,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                 .flat_map(|arm| arm.0.iter())\n                 .map(|pat| vec![&**pat])\n                 .collect();\n-            check_exhaustive(cx, ex.span, &matrix);\n+            check_exhaustive(cx, ex.span, &matrix, source);\n         },\n         ast::ExprForLoop(ref pat, _, _, _) => {\n             let mut static_inliner = StaticInliner::new(cx.tcx);\n@@ -327,6 +327,14 @@ fn check_arms(cx: &MatchCheckCtxt,\n                             span_err!(cx.tcx.sess, span, E0165, \"irrefutable while-let pattern\");\n                         },\n \n+                        ast::MatchSource::ForLoopDesugar => {\n+                            // this is a bug, because on `match iter.next()` we cover\n+                            // `Some(<head>)` and `None`. It's impossible to have an unreachable\n+                            // pattern\n+                            // (see libsyntax/ext/expand.rs for the full expansion of a for loop)\n+                            cx.tcx.sess.span_bug(pat.span, \"unreachable for-loop pattern\")\n+                        },\n+\n                         ast::MatchSource::Normal => {\n                             span_err!(cx.tcx.sess, pat.span, E0001, \"unreachable pattern\")\n                         },\n@@ -351,18 +359,37 @@ fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n     }\n }\n \n-fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n+fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: ast::MatchSource) {\n     match is_useful(cx, matrix, &[DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             let witness = match &pats[] {\n                 [ref witness] => &**witness,\n                 [] => DUMMY_WILD_PAT,\n                 _ => unreachable!()\n             };\n-            span_err!(cx.tcx.sess, sp, E0004,\n-                \"non-exhaustive patterns: `{}` not covered\",\n-                pat_to_string(witness)\n-            );\n+            match source {\n+                ast::MatchSource::ForLoopDesugar => {\n+                    // `witness` has the form `Some(<head>)`, peel off the `Some`\n+                    let witness = match witness.node {\n+                        ast::PatEnum(_, Some(ref pats)) => match &pats[] {\n+                            [ref pat] => &**pat,\n+                            _ => unreachable!(),\n+                        },\n+                        _ => unreachable!(),\n+                    };\n+\n+                    span_err!(cx.tcx.sess, sp, E0297,\n+                        \"refutable pattern in `for` loop binding: \\\n+                                `{}` not covered\",\n+                                pat_to_string(witness));\n+                },\n+                _ => {\n+                    span_err!(cx.tcx.sess, sp, E0004,\n+                        \"non-exhaustive patterns: `{}` not covered\",\n+                        pat_to_string(witness)\n+                    );\n+                },\n+            }\n         }\n         NotUseful => {\n             // This is good, wildcard pattern isn't reachable"}, {"sha": "dd9a52aa705555f71351458029f25bc00a915edb", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76362f0a0ee1b66d7df524c4c8dea9b15b45cf78/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76362f0a0ee1b66d7df524c4c8dea9b15b45cf78/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=76362f0a0ee1b66d7df524c4c8dea9b15b45cf78", "patch": "@@ -100,6 +100,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n               ast::ExprMethodCall(..) => \"method call\",\n               ast::ExprMatch(_, _, ast::MatchSource::IfLetDesugar { .. }) => \"if let\",\n               ast::ExprMatch(_, _, ast::MatchSource::WhileLetDesugar) =>  \"while let\",\n+              ast::ExprMatch(_, _, ast::MatchSource::ForLoopDesugar) =>  \"for\",\n               ast::ExprMatch(..) => \"match\",\n               _ => \"expression\",\n           },"}, {"sha": "d7283db25a5f2eedc23e4347b721e79716b599ce", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76362f0a0ee1b66d7df524c4c8dea9b15b45cf78/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76362f0a0ee1b66d7df524c4c8dea9b15b45cf78/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=76362f0a0ee1b66d7df524c4c8dea9b15b45cf78", "patch": "@@ -788,6 +788,7 @@ pub enum MatchSource {\n     Normal,\n     IfLetDesugar { contains_else_clause: bool },\n     WhileLetDesugar,\n+    ForLoopDesugar,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]"}, {"sha": "5736400313e95f92dd40f5c6e5cd682f500836a6", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76362f0a0ee1b66d7df524c4c8dea9b15b45cf78/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76362f0a0ee1b66d7df524c4c8dea9b15b45cf78/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=76362f0a0ee1b66d7df524c4c8dea9b15b45cf78", "patch": "@@ -288,8 +288,8 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n                     fld.cx.expr_call(span, fld.cx.expr_path(next_path), vec![ref_mut_iter]);\n                 let arms = vec![pat_arm, break_arm];\n \n-                // FIXME(japaric) This should use `ForLoopDesugar` as MatchSource\n-                fld.cx.expr_match(pat_span, next_expr, arms)\n+                fld.cx.expr(pat_span,\n+                            ast::ExprMatch(next_expr, arms, ast::MatchSource::ForLoopDesugar))\n             };\n \n             // `[opt_ident]: loop { ... }`"}, {"sha": "fa55e7215c0b260698751fee63b6eec7ef743f97", "filename": "src/test/compile-fail/for-loop-refutable-pattern-error-message.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76362f0a0ee1b66d7df524c4c8dea9b15b45cf78/src%2Ftest%2Fcompile-fail%2Ffor-loop-refutable-pattern-error-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76362f0a0ee1b66d7df524c4c8dea9b15b45cf78/src%2Ftest%2Fcompile-fail%2Ffor-loop-refutable-pattern-error-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-refutable-pattern-error-message.rs?ref=76362f0a0ee1b66d7df524c4c8dea9b15b45cf78", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n fn main() {\n     for\n         &1is //~ ERROR refutable pattern in `for` loop binding"}]}