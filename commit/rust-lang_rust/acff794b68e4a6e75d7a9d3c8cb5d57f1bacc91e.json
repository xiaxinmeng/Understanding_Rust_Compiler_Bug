{"sha": "acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjZmY3OTRiNjhlNGE2ZTc1ZDdhOWQzYzhjYjVkNTdmMWJhY2M5MWU=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-08-01T08:12:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-08-01T08:12:36Z"}, "message": "Rollup merge of #52732 - SimonSapin:spring, r=Mark-Simulacrum\n\nRemove unstable and deprecated APIs", "tree": {"sha": "9b39fce4c5269e48bbc0b02b97b18f3f05e5ed65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b39fce4c5269e48bbc0b02b97b18f3f05e5ed65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbYWt0CRBK7hj4Ov3rIwAAdHIIAG0Z6ovfJ4ALLlEHZuX5mHWC\nt8VRHTcpiswRc2znVBUT9RWSAuQ5brnh+X/Caix2PSKTPtAadxxvU3sPAf6hqgJ2\neWF6d2fiewm7Dz5HEKMArxCVzLRO22J60fQ9kFolsy/CRGHaieZlfeGmrgfhkQhU\ntegm1Cuh7vSrUEJYp5wEkp2gR7DeHCmgBUCR32gwbu0n1ypM9thkUqiGqBaNb1fx\n9WEP2SB2Ccy0e38di9HyXgOOEanTsMIdfUzDP1x5+uFpkU83mpEfyWsf/dWyROpd\nHG36Ox7HT4LgLiaJENPfqVDshgS6k7YQKbqs27FxXBu6sf/zAuoxe9DpYgaeaTU=\n=HHkc\n-----END PGP SIGNATURE-----\n", "payload": "tree 9b39fce4c5269e48bbc0b02b97b18f3f05e5ed65\nparent 03df573c57b331df37fc3304c4d96293b069b522\nparent 4ca77f702f813332defe15a0aa73707628bf592e\nauthor Pietro Albini <pietro@pietroalbini.org> 1533111156 +0200\ncommitter GitHub <noreply@github.com> 1533111156 +0200\n\nRollup merge of #52732 - SimonSapin:spring, r=Mark-Simulacrum\n\nRemove unstable and deprecated APIs\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e", "html_url": "https://github.com/rust-lang/rust/commit/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03df573c57b331df37fc3304c4d96293b069b522", "url": "https://api.github.com/repos/rust-lang/rust/commits/03df573c57b331df37fc3304c4d96293b069b522", "html_url": "https://github.com/rust-lang/rust/commit/03df573c57b331df37fc3304c4d96293b069b522"}, {"sha": "4ca77f702f813332defe15a0aa73707628bf592e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ca77f702f813332defe15a0aa73707628bf592e", "html_url": "https://github.com/rust-lang/rust/commit/4ca77f702f813332defe15a0aa73707628bf592e"}], "stats": {"total": 851, "additions": 1, "deletions": 850}, "files": [{"sha": "b2e41589893cc4a55827e0fe3d67dce390defa7c", "filename": "src/Cargo.lock", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e", "patch": "@@ -2612,18 +2612,9 @@ dependencies = [\n  \"rustc_lsan 0.0.0\",\n  \"rustc_msan 0.0.0\",\n  \"rustc_tsan 0.0.0\",\n- \"std_unicode 0.0.0\",\n  \"unwind 0.0.0\",\n ]\n \n-[[package]]\n-name = \"std_unicode\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"compiler_builtins 0.0.0\",\n- \"core 0.0.0\",\n-]\n-\n [[package]]\n name = \"string_cache\"\n version = \"0.7.3\""}, {"sha": "8c4f2df60fe6ff1ca0f7576bb91365613987504a", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e", "patch": "@@ -157,7 +157,6 @@ pub fn std_cargo(builder: &Builder,\n         cargo.arg(\"--features\").arg(\"c mem\")\n             .args(&[\"-p\", \"alloc\"])\n             .args(&[\"-p\", \"compiler_builtins\"])\n-            .args(&[\"-p\", \"std_unicode\"])\n             .arg(\"--manifest-path\")\n             .arg(builder.src.join(\"src/rustc/compiler_builtins_shim/Cargo.toml\"));\n     } else {"}, {"sha": "188e64cd668ddc6bb2bdc68c34051254656d1a7a", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e", "patch": "@@ -856,7 +856,6 @@ impl Step for Src {\n             \"src/librustc_msan\",\n             \"src/librustc_tsan\",\n             \"src/libstd\",\n-            \"src/libstd_unicode\",\n             \"src/libunwind\",\n             \"src/rustc/compiler_builtins_shim\",\n             \"src/rustc/libc_shim\","}, {"sha": "ed9b5b1773fae0de01342200b363505902394a12", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e", "patch": "@@ -489,7 +489,7 @@ impl Step for Std {\n         // Keep a whitelist so we do not build internal stdlib crates, these will be\n         // build by the rustc step later if enabled.\n         cargo.arg(\"--no-deps\");\n-        for krate in &[\"alloc\", \"core\", \"std\", \"std_unicode\"] {\n+        for krate in &[\"alloc\", \"core\", \"std\"] {\n             cargo.arg(\"-p\").arg(krate);\n             // Create all crate output directories first to make sure rustdoc uses\n             // relative links."}, {"sha": "cc52f048b891b578f258dd47bf2f4b03de2d5f93", "filename": "src/libcore/char/decode.rs", "status": "modified", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Flibcore%2Fchar%2Fdecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Flibcore%2Fchar%2Fdecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fdecode.rs?ref=acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e", "patch": "@@ -11,135 +11,8 @@\n //! UTF-8 and UTF-16 decoding iterators\n \n use fmt;\n-use iter::FusedIterator;\n use super::from_u32_unchecked;\n \n-/// An iterator over an iterator of bytes of the characters the bytes represent\n-/// as UTF-8\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-#[rustc_deprecated(since = \"1.27.0\", reason = \"Use str::from_utf8 instead:\n-    https://doc.rust-lang.org/nightly/std/str/struct.Utf8Error.html#examples\")]\n-#[derive(Clone, Debug)]\n-#[allow(deprecated)]\n-pub struct DecodeUtf8<I: Iterator<Item = u8>>(::iter::Peekable<I>);\n-\n-/// Decodes an `Iterator` of bytes as UTF-8.\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-#[rustc_deprecated(since = \"1.27.0\", reason = \"Use str::from_utf8 instead:\n-    https://doc.rust-lang.org/nightly/std/str/struct.Utf8Error.html#examples\")]\n-#[allow(deprecated)]\n-#[inline]\n-pub fn decode_utf8<I: IntoIterator<Item = u8>>(i: I) -> DecodeUtf8<I::IntoIter> {\n-    DecodeUtf8(i.into_iter().peekable())\n-}\n-\n-/// `<DecodeUtf8 as Iterator>::next` returns this for an invalid input sequence.\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-#[rustc_deprecated(since = \"1.27.0\", reason = \"Use str::from_utf8 instead:\n-    https://doc.rust-lang.org/nightly/std/str/struct.Utf8Error.html#examples\")]\n-#[derive(PartialEq, Eq, Debug)]\n-#[allow(deprecated)]\n-pub struct InvalidSequence(());\n-\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-#[allow(deprecated)]\n-impl<I: Iterator<Item = u8>> Iterator for DecodeUtf8<I> {\n-    type Item = Result<char, InvalidSequence>;\n-    #[inline]\n-\n-    fn next(&mut self) -> Option<Result<char, InvalidSequence>> {\n-        self.0.next().map(|first_byte| {\n-            // Emit InvalidSequence according to\n-            // Unicode \u00a75.22 Best Practice for U+FFFD Substitution\n-            // http://www.unicode.org/versions/Unicode9.0.0/ch05.pdf#G40630\n-\n-            // Roughly: consume at least one byte,\n-            // then validate one byte at a time and stop before the first unexpected byte\n-            // (which might be the valid start of the next byte sequence).\n-\n-            let mut code_point;\n-            macro_rules! first_byte {\n-                ($mask: expr) => {\n-                    code_point = u32::from(first_byte & $mask)\n-                }\n-            }\n-            macro_rules! continuation_byte {\n-                () => { continuation_byte!(0x80..=0xBF) };\n-                ($range: pat) => {\n-                    match self.0.peek() {\n-                        Some(&byte @ $range) => {\n-                            code_point = (code_point << 6) | u32::from(byte & 0b0011_1111);\n-                            self.0.next();\n-                        }\n-                        _ => return Err(InvalidSequence(()))\n-                    }\n-                }\n-            }\n-\n-            match first_byte {\n-                0x00..=0x7F => {\n-                    first_byte!(0b1111_1111);\n-                }\n-                0xC2..=0xDF => {\n-                    first_byte!(0b0001_1111);\n-                    continuation_byte!();\n-                }\n-                0xE0 => {\n-                    first_byte!(0b0000_1111);\n-                    continuation_byte!(0xA0..=0xBF);  // 0x80..=0x9F here are overlong\n-                    continuation_byte!();\n-                }\n-                0xE1..=0xEC | 0xEE..=0xEF => {\n-                    first_byte!(0b0000_1111);\n-                    continuation_byte!();\n-                    continuation_byte!();\n-                }\n-                0xED => {\n-                    first_byte!(0b0000_1111);\n-                    continuation_byte!(0x80..=0x9F);  // 0xA0..0xBF here are surrogates\n-                    continuation_byte!();\n-                }\n-                0xF0 => {\n-                    first_byte!(0b0000_0111);\n-                    continuation_byte!(0x90..=0xBF);  // 0x80..0x8F here are overlong\n-                    continuation_byte!();\n-                    continuation_byte!();\n-                }\n-                0xF1..=0xF3 => {\n-                    first_byte!(0b0000_0111);\n-                    continuation_byte!();\n-                    continuation_byte!();\n-                    continuation_byte!();\n-                }\n-                0xF4 => {\n-                    first_byte!(0b0000_0111);\n-                    continuation_byte!(0x80..=0x8F);  // 0x90..0xBF here are beyond char::MAX\n-                    continuation_byte!();\n-                    continuation_byte!();\n-                }\n-                _ => return Err(InvalidSequence(()))  // Illegal first byte, overlong, or beyond MAX\n-            }\n-            unsafe {\n-                Ok(from_u32_unchecked(code_point))\n-            }\n-        })\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (lower, upper) = self.0.size_hint();\n-\n-        // A code point is at most 4 bytes long.\n-        let min_code_points = lower / 4;\n-\n-        (min_code_points, upper)\n-    }\n-}\n-\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-#[allow(deprecated)]\n-impl<I: FusedIterator<Item = u8>> FusedIterator for DecodeUtf8<I> {}\n-\n /// An iterator that decodes UTF-16 encoded code points from an iterator of `u16`s.\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n #[derive(Clone, Debug)]"}, {"sha": "5be673db3200d8b3696749443520c48bafeb964b", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e", "patch": "@@ -50,11 +50,6 @@ pub use self::decode::{decode_utf16, DecodeUtf16, DecodeUtf16Error};\n pub use unicode::tables::UNICODE_VERSION;\n #[unstable(feature = \"unicode_version\", issue = \"49726\")]\n pub use unicode::version::UnicodeVersion;\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-#[rustc_deprecated(since = \"1.27.0\", reason = \"Use str::from_utf8 instead:\n-    https://doc.rust-lang.org/nightly/std/str/struct.Utf8Error.html#examples\")]\n-#[allow(deprecated)]\n-pub use self::decode::{decode_utf8, DecodeUtf8, InvalidSequence};\n \n use fmt::{self, Write};\n use iter::FusedIterator;"}, {"sha": "479c10c4ffbae40ecd0a169687381da1fb5e28dd", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e", "patch": "@@ -680,46 +680,6 @@ impl<T: ?Sized> *const T {\n         }\n     }\n \n-    /// Calculates the distance between two pointers. The returned value is in\n-    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n-    ///\n-    /// If the address different between the two pointers ia not a multiple of\n-    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n-    /// zero.\n-    ///\n-    /// This function returns `None` if `T` is a zero-sized type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// #![feature(offset_to)]\n-    /// #![allow(deprecated)]\n-    ///\n-    /// fn main() {\n-    ///     let a = [0; 5];\n-    ///     let ptr1: *const i32 = &a[1];\n-    ///     let ptr2: *const i32 = &a[3];\n-    ///     assert_eq!(ptr1.offset_to(ptr2), Some(2));\n-    ///     assert_eq!(ptr2.offset_to(ptr1), Some(-2));\n-    ///     assert_eq!(unsafe { ptr1.offset(2) }, ptr2);\n-    ///     assert_eq!(unsafe { ptr2.offset(-2) }, ptr1);\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"offset_to\", issue = \"41079\")]\n-    #[rustc_deprecated(since = \"1.27.0\", reason = \"Replaced by `wrapping_offset_from`, with the \\\n-        opposite argument order.  If you're writing unsafe code, consider `offset_from`.\")]\n-    #[inline]\n-    pub fn offset_to(self, other: *const T) -> Option<isize> where T: Sized {\n-        let size = mem::size_of::<T>();\n-        if size == 0 {\n-            None\n-        } else {\n-            Some(other.wrapping_offset_from(self))\n-        }\n-    }\n-\n     /// Calculates the distance between two pointers. The returned value is in\n     /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n     ///\n@@ -1464,46 +1424,6 @@ impl<T: ?Sized> *mut T {\n         }\n     }\n \n-    /// Calculates the distance between two pointers. The returned value is in\n-    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n-    ///\n-    /// If the address different between the two pointers ia not a multiple of\n-    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n-    /// zero.\n-    ///\n-    /// This function returns `None` if `T` is a zero-sized type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// #![feature(offset_to)]\n-    /// #![allow(deprecated)]\n-    ///\n-    /// fn main() {\n-    ///     let mut a = [0; 5];\n-    ///     let ptr1: *mut i32 = &mut a[1];\n-    ///     let ptr2: *mut i32 = &mut a[3];\n-    ///     assert_eq!(ptr1.offset_to(ptr2), Some(2));\n-    ///     assert_eq!(ptr2.offset_to(ptr1), Some(-2));\n-    ///     assert_eq!(unsafe { ptr1.offset(2) }, ptr2);\n-    ///     assert_eq!(unsafe { ptr2.offset(-2) }, ptr1);\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"offset_to\", issue = \"41079\")]\n-    #[rustc_deprecated(since = \"1.27.0\", reason = \"Replaced by `wrapping_offset_from`, with the \\\n-        opposite argument order.  If you're writing unsafe code, consider `offset_from`.\")]\n-    #[inline]\n-    pub fn offset_to(self, other: *const T) -> Option<isize> where T: Sized {\n-        let size = mem::size_of::<T>();\n-        if size == 0 {\n-            None\n-        } else {\n-            Some(other.wrapping_offset_from(self))\n-        }\n-    }\n-\n     /// Calculates the distance between two pointers. The returned value is in\n     /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n     ///"}, {"sha": "46c54056e2cc9e67b8f4882e294c1ef110d1dcaf", "filename": "src/libcore/tests/char.rs", "status": "modified", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Flibcore%2Ftests%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Flibcore%2Ftests%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fchar.rs?ref=acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e", "patch": "@@ -363,54 +363,3 @@ fn eu_iterator_specializations() {\n     check('\\u{12340}');\n     check('\\u{10FFFF}');\n }\n-\n-#[test]\n-#[allow(deprecated)]\n-fn test_decode_utf8() {\n-    macro_rules! assert_decode_utf8 {\n-        ($input_bytes: expr, $expected_str: expr) => {\n-            let input_bytes: &[u8] = &$input_bytes;\n-            let s = char::decode_utf8(input_bytes.iter().cloned())\n-                .map(|r_b| r_b.unwrap_or('\\u{FFFD}'))\n-                .collect::<String>();\n-            assert_eq!(s, $expected_str,\n-                       \"input bytes: {:?}, expected str: {:?}, result: {:?}\",\n-                       input_bytes, $expected_str, s);\n-            assert_eq!(String::from_utf8_lossy(&$input_bytes), $expected_str);\n-        }\n-    }\n-\n-    assert_decode_utf8!([], \"\");\n-    assert_decode_utf8!([0x41], \"A\");\n-    assert_decode_utf8!([0xC1, 0x81], \"\ufffd\ufffd\");\n-    assert_decode_utf8!([0xE2, 0x99, 0xA5], \"\u2665\");\n-    assert_decode_utf8!([0xE2, 0x99, 0xA5, 0x41], \"\u2665A\");\n-    assert_decode_utf8!([0xE2, 0x99], \"\ufffd\");\n-    assert_decode_utf8!([0xE2, 0x99, 0x41], \"\ufffdA\");\n-    assert_decode_utf8!([0xC0], \"\ufffd\");\n-    assert_decode_utf8!([0xC0, 0x41], \"\ufffdA\");\n-    assert_decode_utf8!([0x80], \"\ufffd\");\n-    assert_decode_utf8!([0x80, 0x41], \"\ufffdA\");\n-    assert_decode_utf8!([0xFE], \"\ufffd\");\n-    assert_decode_utf8!([0xFE, 0x41], \"\ufffdA\");\n-    assert_decode_utf8!([0xFF], \"\ufffd\");\n-    assert_decode_utf8!([0xFF, 0x41], \"\ufffdA\");\n-    assert_decode_utf8!([0xC0, 0x80], \"\ufffd\ufffd\");\n-\n-    // Surrogates\n-    assert_decode_utf8!([0xED, 0x9F, 0xBF], \"\\u{D7FF}\");\n-    assert_decode_utf8!([0xED, 0xA0, 0x80], \"\ufffd\ufffd\ufffd\");\n-    assert_decode_utf8!([0xED, 0xBF, 0x80], \"\ufffd\ufffd\ufffd\");\n-    assert_decode_utf8!([0xEE, 0x80, 0x80], \"\\u{E000}\");\n-\n-    // char::MAX\n-    assert_decode_utf8!([0xF4, 0x8F, 0xBF, 0xBF], \"\\u{10FFFF}\");\n-    assert_decode_utf8!([0xF4, 0x8F, 0xBF, 0x41], \"\ufffdA\");\n-    assert_decode_utf8!([0xF4, 0x90, 0x80, 0x80], \"\ufffd\ufffd\ufffd\ufffd\");\n-\n-    // 5 and 6 bytes sequence\n-    // Part of the original design of UTF-8,\n-    // but invalid now that UTF-8 is artificially restricted to match the range of UTF-16.\n-    assert_decode_utf8!([0xF8, 0x80, 0x80, 0x80, 0x80], \"\ufffd\ufffd\ufffd\ufffd\ufffd\");\n-    assert_decode_utf8!([0xFC, 0x80, 0x80, 0x80, 0x80, 0x80], \"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\");\n-}"}, {"sha": "5348c9a0f349842e057985b7fdfce779d3714082", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e", "patch": "@@ -22,7 +22,6 @@ core = { path = \"../libcore\" }\n libc = { path = \"../rustc/libc_shim\" }\n compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }\n profiler_builtins = { path = \"../libprofiler_builtins\", optional = true }\n-std_unicode = { path = \"../libstd_unicode\" }\n unwind = { path = \"../libunwind\" }\n \n [dev-dependencies]"}, {"sha": "0c8e95aa4262409b48a57f4834528781d36fb48f", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 0, "deletions": 310, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e", "patch": "@@ -154,180 +154,6 @@ pub trait AsciiExt {\n     /// [`to_ascii_lowercase`]: #tymethod.to_ascii_lowercase\n     #[stable(feature = \"ascii\", since = \"1.9.0\")]\n     fn make_ascii_lowercase(&mut self);\n-\n-    /// Checks if the value is an ASCII alphabetic character:\n-    /// U+0041 'A' ... U+005A 'Z' or U+0061 'a' ... U+007A 'z'.\n-    /// For strings, true if all characters in the string are\n-    /// ASCII alphabetic.\n-    ///\n-    /// # Note\n-    ///\n-    /// This method will be deprecated in favor of the identically-named\n-    /// inherent methods on `u8` and `char`.\n-    /// For `[u8]` use `.iter().all(u8::is_ascii_alphabetic)`.\n-    /// For `str` use `.bytes().all(u8::is_ascii_alphabetic)`.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n-    fn is_ascii_alphabetic(&self) -> bool { unimplemented!(); }\n-\n-    /// Checks if the value is an ASCII uppercase character:\n-    /// U+0041 'A' ... U+005A 'Z'.\n-    /// For strings, true if all characters in the string are\n-    /// ASCII uppercase.\n-    ///\n-    /// # Note\n-    ///\n-    /// This method will be deprecated in favor of the identically-named\n-    /// inherent methods on `u8` and `char`.\n-    /// For `[u8]` use `.iter().all(u8::is_ascii_uppercase)`.\n-    /// For `str` use `.bytes().all(u8::is_ascii_uppercase)`.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n-    fn is_ascii_uppercase(&self) -> bool { unimplemented!(); }\n-\n-    /// Checks if the value is an ASCII lowercase character:\n-    /// U+0061 'a' ... U+007A 'z'.\n-    /// For strings, true if all characters in the string are\n-    /// ASCII lowercase.\n-    ///\n-    /// # Note\n-    ///\n-    /// This method will be deprecated in favor of the identically-named\n-    /// inherent methods on `u8` and `char`.\n-    /// For `[u8]` use `.iter().all(u8::is_ascii_lowercase)`.\n-    /// For `str` use `.bytes().all(u8::is_ascii_lowercase)`.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n-    fn is_ascii_lowercase(&self) -> bool { unimplemented!(); }\n-\n-    /// Checks if the value is an ASCII alphanumeric character:\n-    /// U+0041 'A' ... U+005A 'Z', U+0061 'a' ... U+007A 'z', or\n-    /// U+0030 '0' ... U+0039 '9'.\n-    /// For strings, true if all characters in the string are\n-    /// ASCII alphanumeric.\n-    ///\n-    /// # Note\n-    ///\n-    /// This method will be deprecated in favor of the identically-named\n-    /// inherent methods on `u8` and `char`.\n-    /// For `[u8]` use `.iter().all(u8::is_ascii_alphanumeric)`.\n-    /// For `str` use `.bytes().all(u8::is_ascii_alphanumeric)`.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n-    fn is_ascii_alphanumeric(&self) -> bool { unimplemented!(); }\n-\n-    /// Checks if the value is an ASCII decimal digit:\n-    /// U+0030 '0' ... U+0039 '9'.\n-    /// For strings, true if all characters in the string are\n-    /// ASCII digits.\n-    ///\n-    /// # Note\n-    ///\n-    /// This method will be deprecated in favor of the identically-named\n-    /// inherent methods on `u8` and `char`.\n-    /// For `[u8]` use `.iter().all(u8::is_ascii_digit)`.\n-    /// For `str` use `.bytes().all(u8::is_ascii_digit)`.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n-    fn is_ascii_digit(&self) -> bool { unimplemented!(); }\n-\n-    /// Checks if the value is an ASCII hexadecimal digit:\n-    /// U+0030 '0' ... U+0039 '9', U+0041 'A' ... U+0046 'F', or\n-    /// U+0061 'a' ... U+0066 'f'.\n-    /// For strings, true if all characters in the string are\n-    /// ASCII hex digits.\n-    ///\n-    /// # Note\n-    ///\n-    /// This method will be deprecated in favor of the identically-named\n-    /// inherent methods on `u8` and `char`.\n-    /// For `[u8]` use `.iter().all(u8::is_ascii_hexdigit)`.\n-    /// For `str` use `.bytes().all(u8::is_ascii_hexdigit)`.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n-    fn is_ascii_hexdigit(&self) -> bool { unimplemented!(); }\n-\n-    /// Checks if the value is an ASCII punctuation character:\n-    ///\n-    /// U+0021 ... U+002F `! \" # $ % & ' ( ) * + , - . /`\n-    /// U+003A ... U+0040 `: ; < = > ? @`\n-    /// U+005B ... U+0060 ``[ \\\\ ] ^ _ ` ``\n-    /// U+007B ... U+007E `{ | } ~`\n-    ///\n-    /// For strings, true if all characters in the string are\n-    /// ASCII punctuation.\n-    ///\n-    /// # Note\n-    ///\n-    /// This method will be deprecated in favor of the identically-named\n-    /// inherent methods on `u8` and `char`.\n-    /// For `[u8]` use `.iter().all(u8::is_ascii_punctuation)`.\n-    /// For `str` use `.bytes().all(u8::is_ascii_punctuation)`.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n-    fn is_ascii_punctuation(&self) -> bool { unimplemented!(); }\n-\n-    /// Checks if the value is an ASCII graphic character:\n-    /// U+0021 '!' ... U+007E '~'.\n-    /// For strings, true if all characters in the string are\n-    /// ASCII graphic characters.\n-    ///\n-    /// # Note\n-    ///\n-    /// This method will be deprecated in favor of the identically-named\n-    /// inherent methods on `u8` and `char`.\n-    /// For `[u8]` use `.iter().all(u8::is_ascii_graphic)`.\n-    /// For `str` use `.bytes().all(u8::is_ascii_graphic)`.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n-    fn is_ascii_graphic(&self) -> bool { unimplemented!(); }\n-\n-    /// Checks if the value is an ASCII whitespace character:\n-    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n-    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n-    /// For strings, true if all characters in the string are\n-    /// ASCII whitespace.\n-    ///\n-    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n-    /// whitespace][infra-aw].  There are several other definitions in\n-    /// wide use.  For instance, [the POSIX locale][pct] includes\n-    /// U+000B VERTICAL TAB as well as all the above characters,\n-    /// but\u2014from the very same specification\u2014[the default rule for\n-    /// \"field splitting\" in the Bourne shell][bfs] considers *only*\n-    /// SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n-    ///\n-    /// If you are writing a program that will process an existing\n-    /// file format, check what that format's definition of whitespace is\n-    /// before using this function.\n-    ///\n-    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n-    /// [pct]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n-    /// [bfs]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n-    ///\n-    /// # Note\n-    ///\n-    /// This method will be deprecated in favor of the identically-named\n-    /// inherent methods on `u8` and `char`.\n-    /// For `[u8]` use `.iter().all(u8::is_ascii_whitespace)`.\n-    /// For `str` use `.bytes().all(u8::is_ascii_whitespace)`.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n-    fn is_ascii_whitespace(&self) -> bool { unimplemented!(); }\n-\n-    /// Checks if the value is an ASCII control character:\n-    /// U+0000 NUL ... U+001F UNIT SEPARATOR, or U+007F DELETE.\n-    /// Note that most ASCII whitespace characters are control\n-    /// characters, but SPACE is not.\n-    ///\n-    /// # Note\n-    ///\n-    /// This method will be deprecated in favor of the identically-named\n-    /// inherent methods on `u8` and `char`.\n-    /// For `[u8]` use `.iter().all(u8::is_ascii_control)`.\n-    /// For `str` use `.bytes().all(u8::is_ascii_control)`.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n-    fn is_ascii_control(&self) -> bool { unimplemented!(); }\n }\n \n macro_rules! delegating_ascii_methods {\n@@ -352,47 +178,12 @@ macro_rules! delegating_ascii_methods {\n     }\n }\n \n-macro_rules! delegating_ascii_ctype_methods {\n-    () => {\n-        #[inline]\n-        fn is_ascii_alphabetic(&self) -> bool { self.is_ascii_alphabetic() }\n-\n-        #[inline]\n-        fn is_ascii_uppercase(&self) -> bool { self.is_ascii_uppercase() }\n-\n-        #[inline]\n-        fn is_ascii_lowercase(&self) -> bool { self.is_ascii_lowercase() }\n-\n-        #[inline]\n-        fn is_ascii_alphanumeric(&self) -> bool { self.is_ascii_alphanumeric() }\n-\n-        #[inline]\n-        fn is_ascii_digit(&self) -> bool { self.is_ascii_digit() }\n-\n-        #[inline]\n-        fn is_ascii_hexdigit(&self) -> bool { self.is_ascii_hexdigit() }\n-\n-        #[inline]\n-        fn is_ascii_punctuation(&self) -> bool { self.is_ascii_punctuation() }\n-\n-        #[inline]\n-        fn is_ascii_graphic(&self) -> bool { self.is_ascii_graphic() }\n-\n-        #[inline]\n-        fn is_ascii_whitespace(&self) -> bool { self.is_ascii_whitespace() }\n-\n-        #[inline]\n-        fn is_ascii_control(&self) -> bool { self.is_ascii_control() }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated)]\n impl AsciiExt for u8 {\n     type Owned = u8;\n \n     delegating_ascii_methods!();\n-    delegating_ascii_ctype_methods!();\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -401,7 +192,6 @@ impl AsciiExt for char {\n     type Owned = char;\n \n     delegating_ascii_methods!();\n-    delegating_ascii_ctype_methods!();\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -410,56 +200,6 @@ impl AsciiExt for [u8] {\n     type Owned = Vec<u8>;\n \n     delegating_ascii_methods!();\n-\n-    #[inline]\n-    fn is_ascii_alphabetic(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_alphabetic())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_uppercase(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_uppercase())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_lowercase(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_lowercase())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_alphanumeric(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_alphanumeric())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_digit(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_digit())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_hexdigit(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_hexdigit())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_punctuation(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_punctuation())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_graphic(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_graphic())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_whitespace(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_whitespace())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_control(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_control())\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -468,54 +208,4 @@ impl AsciiExt for str {\n     type Owned = String;\n \n     delegating_ascii_methods!();\n-\n-    #[inline]\n-    fn is_ascii_alphabetic(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_alphabetic())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_uppercase(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_uppercase())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_lowercase(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_lowercase())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_alphanumeric(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_alphanumeric())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_digit(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_digit())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_hexdigit(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_hexdigit())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_punctuation(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_punctuation())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_graphic(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_graphic())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_whitespace(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_whitespace())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_control(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_control())\n-    }\n }"}, {"sha": "03c97de6ec1e9b8418c9da79ded78dca8777d2d0", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e", "patch": "@@ -154,33 +154,6 @@ impl<R: Read> BufReader<R> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut R { &mut self.inner }\n \n-    /// Returns `true` if there are no bytes in the internal buffer.\n-    ///\n-    /// # Examples\n-    //\n-    /// ```no_run\n-    /// # #![feature(bufreader_is_empty)]\n-    /// use std::io::BufReader;\n-    /// use std::io::BufRead;\n-    /// use std::fs::File;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let f1 = File::open(\"log.txt\")?;\n-    ///     let mut reader = BufReader::new(f1);\n-    ///     assert!(reader.is_empty());\n-    ///\n-    ///     if reader.fill_buf()?.len() > 0 {\n-    ///         assert!(!reader.is_empty());\n-    ///     }\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"bufreader_is_empty\", issue = \"45323\", reason = \"recently added\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use .buffer().is_empty() instead\")]\n-    pub fn is_empty(&self) -> bool {\n-        self.buffer().is_empty()\n-    }\n-\n     /// Returns a reference to the internally buffered data.\n     ///\n     /// Unlike `fill_buf`, this will not attempt to fill the buffer if it is empty.\n@@ -1265,25 +1238,6 @@ mod tests {\n         assert_eq!(reader.read(&mut buf).unwrap(), 0);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn read_char_buffered() {\n-        let buf = [195, 159];\n-        let reader = BufReader::with_capacity(1, &buf[..]);\n-        assert_eq!(reader.chars().next().unwrap().unwrap(), '\u00df');\n-    }\n-\n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_chars() {\n-        let buf = [195, 159, b'a'];\n-        let reader = BufReader::with_capacity(1, &buf[..]);\n-        let mut it = reader.chars();\n-        assert_eq!(it.next().unwrap().unwrap(), '\u00df');\n-        assert_eq!(it.next().unwrap().unwrap(), 'a');\n-        assert!(it.next().is_none());\n-    }\n-\n     #[test]\n     #[should_panic]\n     fn dont_panic_in_drop_on_panicked_flush() {"}, {"sha": "14f20151dca861c9ef6e3518392fdac9b4e49ce1", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e", "patch": "@@ -550,26 +550,6 @@ mod tests {\n         assert_eq!(reader.read(&mut buf).unwrap(), 0);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_read_char() {\n-        let b = &b\"Vi\\xE1\\xBB\\x87t\"[..];\n-        let mut c = Cursor::new(b).chars();\n-        assert_eq!(c.next().unwrap().unwrap(), 'V');\n-        assert_eq!(c.next().unwrap().unwrap(), 'i');\n-        assert_eq!(c.next().unwrap().unwrap(), '\u1ec7');\n-        assert_eq!(c.next().unwrap().unwrap(), 't');\n-        assert!(c.next().is_none());\n-    }\n-\n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_read_bad_char() {\n-        let b = &b\"\\x80\"[..];\n-        let mut c = Cursor::new(b).chars();\n-        assert!(c.next().unwrap().is_err());\n-    }\n-\n     #[test]\n     fn seek_past_end() {\n         let buf = [0xff];"}, {"sha": "5e89ad45f81d24031ec06999eb8b2acfd101e84f", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 0, "deletions": 148, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=acff794b68e4a6e75d7a9d3c8cb5d57f1bacc91e", "patch": "@@ -270,10 +270,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use cmp;\n-use core::str as core_str;\n-use error as std_error;\n use fmt;\n-use result;\n use str;\n use memchr;\n use ptr;\n@@ -800,53 +797,6 @@ pub trait Read {\n         Bytes { inner: self }\n     }\n \n-    /// Transforms this `Read` instance to an [`Iterator`] over [`char`]s.\n-    ///\n-    /// This adaptor will attempt to interpret this reader as a UTF-8 encoded\n-    /// sequence of characters. The returned iterator will return [`None`] once\n-    /// EOF is reached for this reader. Otherwise each element yielded will be a\n-    /// [`Result`]`<`[`char`]`, E>` where `E` may contain information about what I/O error\n-    /// occurred or where decoding failed.\n-    ///\n-    /// Currently this adaptor will discard intermediate data read, and should\n-    /// be avoided if this is not desired.\n-    ///\n-    /// # Examples\n-    ///\n-    /// [`File`]s implement `Read`:\n-    ///\n-    /// [`File`]: ../fs/struct.File.html\n-    /// [`Iterator`]: ../../std/iter/trait.Iterator.html\n-    /// [`Result`]: ../../std/result/enum.Result.html\n-    /// [`char`]: ../../std/primitive.char.html\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n-    /// ```no_run\n-    /// #![feature(io)]\n-    /// use std::io;\n-    /// use std::io::prelude::*;\n-    /// use std::fs::File;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let mut f = File::open(\"foo.txt\")?;\n-    ///\n-    ///     for c in f.chars() {\n-    ///         println!(\"{}\", c.unwrap());\n-    ///     }\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"io\", reason = \"the semantics of a partial read/write \\\n-                                         of where errors happen is currently \\\n-                                         unclear and may change\",\n-               issue = \"27802\")]\n-    #[rustc_deprecated(since = \"1.27.0\", reason = \"Use str::from_utf8 instead:\n-        https://doc.rust-lang.org/nightly/std/str/struct.Utf8Error.html#examples\")]\n-    #[allow(deprecated)]\n-    fn chars(self) -> Chars<Self> where Self: Sized {\n-        Chars { inner: self }\n-    }\n-\n     /// Creates an adaptor which will chain this stream with another.\n     ///\n     /// The returned `Read` instance will first read all bytes from this object\n@@ -2005,104 +1955,6 @@ impl<R: Read> Iterator for Bytes<R> {\n     }\n }\n \n-/// An iterator over the `char`s of a reader.\n-///\n-/// This struct is generally created by calling [`chars`][chars] on a reader.\n-/// Please see the documentation of `chars()` for more details.\n-///\n-/// [chars]: trait.Read.html#method.chars\n-#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\",\n-           issue = \"27802\")]\n-#[rustc_deprecated(since = \"1.27.0\", reason = \"Use str::from_utf8 instead:\n-    https://doc.rust-lang.org/nightly/std/str/struct.Utf8Error.html#examples\")]\n-#[derive(Debug)]\n-#[allow(deprecated)]\n-pub struct Chars<R> {\n-    inner: R,\n-}\n-\n-/// An enumeration of possible errors that can be generated from the `Chars`\n-/// adapter.\n-#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\",\n-           issue = \"27802\")]\n-#[rustc_deprecated(since = \"1.27.0\", reason = \"Use str::from_utf8 instead:\n-    https://doc.rust-lang.org/nightly/std/str/struct.Utf8Error.html#examples\")]\n-#[derive(Debug)]\n-#[allow(deprecated)]\n-pub enum CharsError {\n-    /// Variant representing that the underlying stream was read successfully\n-    /// but it did not contain valid utf8 data.\n-    NotUtf8,\n-\n-    /// Variant representing that an I/O error occurred.\n-    Other(Error),\n-}\n-\n-#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\",\n-           issue = \"27802\")]\n-#[allow(deprecated)]\n-impl<R: Read> Iterator for Chars<R> {\n-    type Item = result::Result<char, CharsError>;\n-\n-    fn next(&mut self) -> Option<result::Result<char, CharsError>> {\n-        let first_byte = match read_one_byte(&mut self.inner)? {\n-            Ok(b) => b,\n-            Err(e) => return Some(Err(CharsError::Other(e))),\n-        };\n-        let width = core_str::utf8_char_width(first_byte);\n-        if width == 1 { return Some(Ok(first_byte as char)) }\n-        if width == 0 { return Some(Err(CharsError::NotUtf8)) }\n-        let mut buf = [first_byte, 0, 0, 0];\n-        {\n-            let mut start = 1;\n-            while start < width {\n-                match self.inner.read(&mut buf[start..width]) {\n-                    Ok(0) => return Some(Err(CharsError::NotUtf8)),\n-                    Ok(n) => start += n,\n-                    Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n-                    Err(e) => return Some(Err(CharsError::Other(e))),\n-                }\n-            }\n-        }\n-        Some(match str::from_utf8(&buf[..width]).ok() {\n-            Some(s) => Ok(s.chars().next().unwrap()),\n-            None => Err(CharsError::NotUtf8),\n-        })\n-    }\n-}\n-\n-#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\",\n-           issue = \"27802\")]\n-#[allow(deprecated)]\n-impl std_error::Error for CharsError {\n-    fn description(&self) -> &str {\n-        match *self {\n-            CharsError::NotUtf8 => \"invalid utf8 encoding\",\n-            CharsError::Other(ref e) => std_error::Error::description(e),\n-        }\n-    }\n-    fn cause(&self) -> Option<&dyn std_error::Error> {\n-        match *self {\n-            CharsError::NotUtf8 => None,\n-            CharsError::Other(ref e) => e.cause(),\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\",\n-           issue = \"27802\")]\n-#[allow(deprecated)]\n-impl fmt::Display for CharsError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            CharsError::NotUtf8 => {\n-                \"byte stream did not contain valid utf8\".fmt(f)\n-            }\n-            CharsError::Other(ref e) => e.fmt(f),\n-        }\n-    }\n-}\n-\n /// An iterator over the contents of an instance of `BufRead` split on a\n /// particular byte.\n ///"}, {"sha": "b1c55c2e4b6ced7aa3520322031f1e36cba8b4f3", "filename": "src/libstd_unicode/Cargo.toml", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/03df573c57b331df37fc3304c4d96293b069b522/src%2Flibstd_unicode%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/03df573c57b331df37fc3304c4d96293b069b522/src%2Flibstd_unicode%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2FCargo.toml?ref=03df573c57b331df37fc3304c4d96293b069b522", "patch": "@@ -1,14 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"std_unicode\"\n-version = \"0.0.0\"\n-\n-[lib]\n-name = \"std_unicode\"\n-path = \"lib.rs\"\n-test = false\n-bench = false\n-\n-[dependencies]\n-core = { path = \"../libcore\" }\n-compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }"}, {"sha": "c0d47f1fcb42bbc680d352a1ae86b7f23d34f14d", "filename": "src/libstd_unicode/lib.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/03df573c57b331df37fc3304c4d96293b069b522/src%2Flibstd_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03df573c57b331df37fc3304c4d96293b069b522/src%2Flibstd_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Flib.rs?ref=03df573c57b331df37fc3304c4d96293b069b522", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! # The Unicode Library\n-//!\n-//! Unicode-intensive functions for `char` and `str` types.\n-//!\n-//! This crate provides a collection of Unicode-related functionality,\n-//! including decompositions, conversions, etc., and provides traits\n-//! implementing these functions for the `char` and `str` types.\n-//!\n-//! The functionality included here is only that which is necessary to\n-//! provide for basic string-related manipulations. This crate does not\n-//! (yet) aim to provide a full set of Unicode tables.\n-\n-#![unstable(feature = \"unicode\", issue = \"27783\")]\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"https://play.rust-lang.org/\",\n-       issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n-       test(no_crate_inject, attr(allow(unused_variables), deny(warnings))))]\n-#![no_std]\n-\n-#![feature(unicode_internals)]\n-#![feature(staged_api)]\n-#![rustc_deprecated(since = \"1.27.0\", reason = \"moved into libcore\")]\n-\n-pub use core::unicode::*;"}]}