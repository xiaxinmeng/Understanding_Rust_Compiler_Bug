{"sha": "8fcfd9e11db56d40739fe7816540e3f98d6283b5", "node_id": "C_kwDOAAsO6NoAKDhmY2ZkOWUxMWRiNTZkNDA3MzlmZTc4MTY1NDBlM2Y5OGQ2MjgzYjU", "commit": {"author": {"name": "Neven Villani", "email": "vanille@crans.org", "date": "2023-03-16T13:40:17Z"}, "committer": {"name": "Neven Villani", "email": "vanille@crans.org", "date": "2023-03-16T13:52:46Z"}, "message": "TB: encoding of the underlying state machine\n\n+ properties about the transitions", "tree": {"sha": "121ca482b38df48061355872766718fec8a17b3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/121ca482b38df48061355872766718fec8a17b3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fcfd9e11db56d40739fe7816540e3f98d6283b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fcfd9e11db56d40739fe7816540e3f98d6283b5", "html_url": "https://github.com/rust-lang/rust/commit/8fcfd9e11db56d40739fe7816540e3f98d6283b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fcfd9e11db56d40739fe7816540e3f98d6283b5/comments", "author": {"login": "Vanille-N", "id": 58042063, "node_id": "MDQ6VXNlcjU4MDQyMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/58042063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vanille-N", "html_url": "https://github.com/Vanille-N", "followers_url": "https://api.github.com/users/Vanille-N/followers", "following_url": "https://api.github.com/users/Vanille-N/following{/other_user}", "gists_url": "https://api.github.com/users/Vanille-N/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vanille-N/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vanille-N/subscriptions", "organizations_url": "https://api.github.com/users/Vanille-N/orgs", "repos_url": "https://api.github.com/users/Vanille-N/repos", "events_url": "https://api.github.com/users/Vanille-N/events{/privacy}", "received_events_url": "https://api.github.com/users/Vanille-N/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Vanille-N", "id": 58042063, "node_id": "MDQ6VXNlcjU4MDQyMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/58042063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vanille-N", "html_url": "https://github.com/Vanille-N", "followers_url": "https://api.github.com/users/Vanille-N/followers", "following_url": "https://api.github.com/users/Vanille-N/following{/other_user}", "gists_url": "https://api.github.com/users/Vanille-N/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vanille-N/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vanille-N/subscriptions", "organizations_url": "https://api.github.com/users/Vanille-N/orgs", "repos_url": "https://api.github.com/users/Vanille-N/repos", "events_url": "https://api.github.com/users/Vanille-N/events{/privacy}", "received_events_url": "https://api.github.com/users/Vanille-N/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ad2fece144996fb3591dc3250b9fc6b49288a91", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ad2fece144996fb3591dc3250b9fc6b49288a91", "html_url": "https://github.com/rust-lang/rust/commit/3ad2fece144996fb3591dc3250b9fc6b49288a91"}], "stats": {"total": 214, "additions": 214, "deletions": 0}, "files": [{"sha": "dc7f934a70589621cde3397bc8942f8cde43ad03", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/perms.rs", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/8fcfd9e11db56d40739fe7816540e3f98d6283b5/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fperms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fcfd9e11db56d40739fe7816540e3f98d6283b5/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fperms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fperms.rs?ref=8fcfd9e11db56d40739fe7816540e3f98d6283b5", "patch": "@@ -0,0 +1,214 @@\n+use std::cmp::{Ordering, PartialOrd};\n+use std::fmt;\n+\n+/// The activation states of a pointer\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+enum PermissionPriv {\n+    /// represents: a local reference that has not yet been written to;\n+    /// allows: child reads, foreign reads, foreign writes if type is freeze;\n+    /// rejects: child writes (Active), foreign writes (Disabled, except if type is not freeze).\n+    /// special case: behaves differently when protected to adhere more closely to noalias\n+    Reserved { ty_is_freeze: bool },\n+    /// represents: a unique pointer;\n+    /// allows: child reads, child writes;\n+    /// rejects: foreign reads (Frozen), foreign writes (Disabled).\n+    Active,\n+    /// represents: a shared pointer;\n+    /// allows: all read accesses;\n+    /// rejects child writes (UB), foreign writes (Disabled).\n+    Frozen,\n+    /// represents: a dead pointer;\n+    /// allows: all foreign accesses;\n+    /// rejects: all child accesses (UB).\n+    Disabled,\n+}\n+use PermissionPriv::*;\n+\n+impl PartialOrd for PermissionPriv {\n+    /// PermissionPriv is ordered as follows:\n+    /// - Reserved(_) < Active < Frozen < Disabled;\n+    /// - different kinds of `Reserved` (with or without interior mutability)\n+    /// are incomparable to each other.\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        use Ordering::*;\n+        Some(match (self, other) {\n+            (a, b) if a == b => Equal,\n+            (Disabled, _) => Greater,\n+            (_, Disabled) => Less,\n+            (Frozen, _) => Greater,\n+            (_, Frozen) => Less,\n+            (Active, _) => Greater,\n+            (_, Active) => Less,\n+            (Reserved { .. }, Reserved { .. }) => return None,\n+        })\n+    }\n+}\n+\n+/// This module controls how each permission individually reacts to an access.\n+/// Although these functions take `protected` as an argument, this is NOT because\n+/// we check protector violations here, but because some permissions behave differently\n+/// when protected.\n+mod transition {\n+    use super::*;\n+    /// A child node was read-accessed: UB on Disabled, noop on the rest.\n+    fn child_read(state: PermissionPriv, _protected: bool) -> Option<PermissionPriv> {\n+        Some(match state {\n+            Disabled => return None,\n+            // The inner data `ty_is_freeze` of `Reserved` is always irrelevant for Read\n+            // accesses, since the data is not being mutated. Hence the `{ .. }`\n+            readable @ (Reserved { .. } | Active | Frozen) => readable,\n+        })\n+    }\n+\n+    /// A non-child node was read-accessed: noop on non-protected Reserved, advance to Frozen otherwise.\n+    fn foreign_read(state: PermissionPriv, protected: bool) -> Option<PermissionPriv> {\n+        use Option::*;\n+        Some(match state {\n+            // The inner data `ty_is_freeze` of `Reserved` is always irrelevant for Read\n+            // accesses, since the data is not being mutated. Hence the `{ .. }`\n+            res @ Reserved { .. } if !protected => res,\n+            Reserved { .. } => Frozen, // protected reserved\n+            Active => Frozen,\n+            non_writeable @ (Frozen | Disabled) => non_writeable,\n+        })\n+    }\n+\n+    /// A child node was write-accessed: `Reserved` must become `Active` to obtain\n+    /// write permissions, `Frozen` and `Disabled` cannot obtain such permissions and produce UB.\n+    fn child_write(state: PermissionPriv, _protected: bool) -> Option<PermissionPriv> {\n+        Some(match state {\n+            // A write always activates the 2-phase borrow, even with interior\n+            // mutability\n+            Reserved { .. } | Active => Active,\n+            Frozen | Disabled => return None,\n+        })\n+    }\n+\n+    /// A non-child node was write-accessed: this makes everything `Disabled` except for\n+    /// non-protected interior mutable `Reserved` which stay the same.\n+    fn foreign_write(state: PermissionPriv, protected: bool) -> Option<PermissionPriv> {\n+        Some(match state {\n+            cell @ Reserved { ty_is_freeze: false } if !protected => cell,\n+            _ => Disabled,\n+        })\n+    }\n+}\n+\n+impl PermissionPriv {\n+    /// Determines whether a transition that occured is compatible with the presence\n+    /// of a Protector. This is not included in the `transition` functions because\n+    /// it would distract from the few places where the transition is modified\n+    /// because of a protector, but not forbidden.\n+    fn protector_allows_transition(self, new: Self) -> bool {\n+        match (self, new) {\n+            _ if self == new => true,\n+            // It is always a protector violation to not be readable anymore\n+            (_, Disabled) => false,\n+            // In the case of a `Reserved` under a protector, both transitions\n+            // `Reserved => Active` and `Reserved => Frozen` can legitimately occur.\n+            // The first is standard (Child Write), the second is for Foreign Writes\n+            // on protected Reserved where we must ensure that the pointer is not\n+            // written to in the future.\n+            (Reserved { .. }, Active) | (Reserved { .. }, Frozen) => true,\n+            // This pointer should have stayed writeable for the whole function\n+            (Active, Frozen) => false,\n+            _ => unreachable!(\"Transition from {self:?} to {new:?} should never be possible\"),\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod propagation_optimization_checks {\n+    pub use super::*;\n+\n+    mod util {\n+        pub use super::*;\n+        impl PermissionPriv {\n+            /// Enumerate all states\n+            pub fn all() -> impl Iterator<Item = PermissionPriv> {\n+                vec![\n+                    Active,\n+                    Reserved { ty_is_freeze: true },\n+                    Reserved { ty_is_freeze: false },\n+                    Frozen,\n+                    Disabled,\n+                ]\n+                .into_iter()\n+            }\n+        }\n+\n+        impl AccessKind {\n+            /// Enumerate all AccessKind.\n+            pub fn all() -> impl Iterator<Item = AccessKind> {\n+                use AccessKind::*;\n+                [Read, Write].into_iter()\n+            }\n+        }\n+\n+        impl AccessRelatedness {\n+            /// Enumerate all relative positions\n+            pub fn all() -> impl Iterator<Item = AccessRelatedness> {\n+                use AccessRelatedness::*;\n+                [This, StrictChildAccess, AncestorAccess, DistantAccess].into_iter()\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    // For any kind of access, if we do it twice the second should be a no-op.\n+    // Even if the protector has disappeared.\n+    fn all_transitions_idempotent() {\n+        use transition::*;\n+        for old in PermissionPriv::all() {\n+            for (old_protected, new_protected) in [(true, true), (true, false), (false, false)] {\n+                for access in AccessKind::all() {\n+                    for rel_pos in AccessRelatedness::all() {\n+                        if let Some(new) = perform_access(access, rel_pos, old, old_protected) {\n+                            assert_eq!(\n+                                new,\n+                                perform_access(access, rel_pos, new, new_protected).unwrap()\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn foreign_read_is_noop_after_write() {\n+        use transition::*;\n+        let old_access = AccessKind::Write;\n+        let new_access = AccessKind::Read;\n+        for old in PermissionPriv::all() {\n+            for (old_protected, new_protected) in [(true, true), (true, false), (false, false)] {\n+                for rel_pos in AccessRelatedness::all().filter(|rel| rel.is_foreign()) {\n+                    if let Some(new) = perform_access(old_access, rel_pos, old, old_protected) {\n+                        assert_eq!(\n+                            new,\n+                            perform_access(new_access, rel_pos, new, new_protected).unwrap()\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    // Check that all transitions are consistent with the order on PermissionPriv,\n+    // i.e. Reserved -> Active -> Frozen -> Disabled\n+    fn access_transitions_progress_increasing() {\n+        use transition::*;\n+        for old in PermissionPriv::all() {\n+            for protected in [true, false] {\n+                for access in AccessKind::all() {\n+                    for rel_pos in AccessRelatedness::all() {\n+                        if let Some(new) = perform_access(access, rel_pos, old, protected) {\n+                            assert!(old <= new);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}]}