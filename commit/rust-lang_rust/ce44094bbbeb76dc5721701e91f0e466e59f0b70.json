{"sha": "ce44094bbbeb76dc5721701e91f0e466e59f0b70", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlNDQwOTRiYmJlYjc2ZGM1NzIxNzAxZTkxZjBlNDY2ZTU5ZjBiNzA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-11-16T22:29:19Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-11-25T11:41:26Z"}, "message": "Add [mut_]shift_ref/[mut_]pop_ref functions, which return a pointer to the first/last item in the slice and modify the slice to exclude the returned item. Useful when writing iterators over mutable references.", "tree": {"sha": "477648f04c2d069ffacb3be3749d88a0adafa3f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/477648f04c2d069ffacb3be3749d88a0adafa3f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce44094bbbeb76dc5721701e91f0e466e59f0b70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce44094bbbeb76dc5721701e91f0e466e59f0b70", "html_url": "https://github.com/rust-lang/rust/commit/ce44094bbbeb76dc5721701e91f0e466e59f0b70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce44094bbbeb76dc5721701e91f0e466e59f0b70/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40439516ecf10c760a9df2cd562f6b695d4d4a6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/40439516ecf10c760a9df2cd562f6b695d4d4a6b", "html_url": "https://github.com/rust-lang/rust/commit/40439516ecf10c760a9df2cd562f6b695d4d4a6b"}], "stats": {"total": 194, "additions": 194, "deletions": 0}, "files": [{"sha": "b11907aeaec19e665f959d02f32ca1b52a712759", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/ce44094bbbeb76dc5721701e91f0e466e59f0b70/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce44094bbbeb76dc5721701e91f0e466e59f0b70/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=ce44094bbbeb76dc5721701e91f0e466e59f0b70", "patch": "@@ -975,6 +975,40 @@ pub trait ImmutableVector<'self, T> {\n      * foreign interop.\n      */\n     fn as_imm_buf<U>(&self, f: |*T, uint| -> U) -> U;\n+\n+    /**\n+     * Returns a mutable reference to the first element in this slice\n+     * and adjusts the slice in place so that it no longer contains\n+     * that element. O(1).\n+     *\n+     * Equivalent to:\n+     *\n+     * ```\n+     *     let head = &self[0];\n+     *     *self = self.slice_from(1);\n+     *     head\n+     * ```\n+     *\n+     * Fails if slice is empty.\n+     */\n+    fn shift_ref(&mut self) -> &'self T;\n+\n+    /**\n+     * Returns a mutable reference to the last element in this slice\n+     * and adjusts the slice in place so that it no longer contains\n+     * that element. O(1).\n+     *\n+     * Equivalent to:\n+     *\n+     * ```\n+     *     let tail = &self[self.len() - 1];\n+     *     *self = self.slice_to(self.len() - 1);\n+     *     tail\n+     * ```\n+     *\n+     * Fails if slice is empty.\n+     */\n+    fn pop_ref(&mut self) -> &'self T;\n }\n \n impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n@@ -1141,6 +1175,20 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         let s = self.repr();\n         f(s.data, s.len)\n     }\n+\n+    fn shift_ref(&mut self) -> &'self T {\n+        unsafe {\n+            let s: &mut Slice<T> = cast::transmute(self);\n+            &*raw::shift_ptr(s)\n+        }\n+    }\n+\n+    fn pop_ref(&mut self) -> &'self T {\n+        unsafe {\n+            let s: &mut Slice<T> = cast::transmute(self);\n+            &*raw::pop_ptr(s)\n+        }\n+    }\n }\n \n /// Extension methods for vectors contain `Eq` elements.\n@@ -1859,23 +1907,61 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n pub trait MutableVector<'self, T> {\n     /// Return a slice that points into another slice.\n     fn mut_slice(self, start: uint, end: uint) -> &'self mut [T];\n+\n     /**\n      * Returns a slice of self from `start` to the end of the vec.\n      *\n      * Fails when `start` points outside the bounds of self.\n      */\n     fn mut_slice_from(self, start: uint) -> &'self mut [T];\n+\n     /**\n      * Returns a slice of self from the start of the vec to `end`.\n      *\n      * Fails when `end` points outside the bounds of self.\n      */\n     fn mut_slice_to(self, end: uint) -> &'self mut [T];\n+\n     /// Returns an iterator that allows modifying each value\n     fn mut_iter(self) -> VecMutIterator<'self, T>;\n+\n     /// Returns a reversed iterator that allows modifying each value\n     fn mut_rev_iter(self) -> MutRevIterator<'self, T>;\n \n+    /**\n+     * Returns a mutable reference to the first element in this slice\n+     * and adjusts the slice in place so that it no longer contains\n+     * that element. O(1).\n+     *\n+     * Equivalent to:\n+     *\n+     * ```\n+     *     let head = &mut self[0];\n+     *     *self = self.mut_slice_from(1);\n+     *     head\n+     * ```\n+     *\n+     * Fails if slice is empty.\n+     */\n+    fn mut_shift_ref(&mut self) -> &'self mut T;\n+\n+    /**\n+     * Returns a mutable reference to the last element in this slice\n+     * and adjusts the slice in place so that it no longer contains\n+     * that element. O(1).\n+     *\n+     * Equivalent to:\n+     *\n+     * ```\n+     *     let tail = &mut self[self.len() - 1];\n+     *     *self = self.mut_slice_to(self.len() - 1);\n+     *     tail\n+     * ```\n+     *\n+     * Fails if slice is empty.\n+     */\n+    fn mut_pop_ref(&mut self) -> &'self mut T;\n+\n     /**\n      * Swaps two elements in a vector\n      *\n@@ -1978,6 +2064,20 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n         self.mut_iter().invert()\n     }\n \n+    fn mut_shift_ref(&mut self) -> &'self mut T {\n+        unsafe {\n+            let s: &mut Slice<T> = cast::transmute(self);\n+            cast::transmute_mut(&*raw::shift_ptr(s))\n+        }\n+    }\n+\n+    fn mut_pop_ref(&mut self) -> &'self mut T {\n+        unsafe {\n+            let s: &mut Slice<T> = cast::transmute(self);\n+            cast::transmute_mut(&*raw::pop_ptr(s))\n+        }\n+    }\n+\n     fn swap(self, a: uint, b: uint) {\n         unsafe {\n             // Can't take two mutable loans from one vector, so instead just cast\n@@ -2189,6 +2289,31 @@ pub mod raw {\n             }\n         }\n     }\n+\n+    /**\n+     * Returns a pointer to first element in slice and adjusts\n+     * slice so it no longer contains that element. Fails if\n+     * slice is empty. O(1).\n+     */\n+    pub unsafe fn shift_ptr<T>(slice: &mut Slice<T>) -> *T {\n+        if slice.len == 0 { fail!(\"shift on empty slice\"); }\n+        let head: *T = slice.data;\n+        slice.data = ptr::offset(slice.data, 1);\n+        slice.len -= 1;\n+        head\n+    }\n+\n+    /**\n+     * Returns a pointer to last element in slice and adjusts\n+     * slice so it no longer contains that element. Fails if\n+     * slice is empty. O(1).\n+     */\n+    pub unsafe fn pop_ptr<T>(slice: &mut Slice<T>) -> *T {\n+        if slice.len == 0 { fail!(\"pop on empty slice\"); }\n+        let tail: *T = ptr::offset(slice.data, (slice.len - 1) as int);\n+        slice.len -= 1;\n+        tail\n+    }\n }\n \n /// Operations on `[u8]`\n@@ -3822,6 +3947,75 @@ mod tests {\n         assert!(!empty.ends_with(bytes!(\"foo\")));\n         assert!(bytes!(\"foobar\").ends_with(empty));\n     }\n+\n+    #[test]\n+    fn test_shift_ref() {\n+        let mut x: &[int] = [1, 2, 3, 4, 5];\n+        let h = x.shift_ref();\n+        assert_eq!(*h, 1);\n+        assert_eq!(x.len(), 4);\n+        assert_eq!(x[0], 2);\n+        assert_eq!(x[3], 5);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_shift_ref_empty() {\n+        let mut x: &[int] = [];\n+        x.shift_ref();\n+    }\n+\n+    #[test]\n+    fn test_pop_ref() {\n+        let mut x: &[int] = [1, 2, 3, 4, 5];\n+        let h = x.pop_ref();\n+        assert_eq!(*h, 5);\n+        assert_eq!(x.len(), 4);\n+        assert_eq!(x[0], 1);\n+        assert_eq!(x[3], 4);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_pop_ref_empty() {\n+        let mut x: &[int] = [];\n+        x.pop_ref();\n+    }\n+\n+\n+    #[test]\n+    fn test_mut_shift_ref() {\n+        let mut x: &mut [int] = [1, 2, 3, 4, 5];\n+        let h = x.mut_shift_ref();\n+        assert_eq!(*h, 1);\n+        assert_eq!(x.len(), 4);\n+        assert_eq!(x[0], 2);\n+        assert_eq!(x[3], 5);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_mut_shift_ref_empty() {\n+        let mut x: &mut [int] = [];\n+        x.mut_shift_ref();\n+    }\n+\n+    #[test]\n+    fn test_mut_pop_ref() {\n+        let mut x: &mut [int] = [1, 2, 3, 4, 5];\n+        let h = x.mut_pop_ref();\n+        assert_eq!(*h, 5);\n+        assert_eq!(x.len(), 4);\n+        assert_eq!(x[0], 1);\n+        assert_eq!(x[3], 4);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_mut_pop_ref_empty() {\n+        let mut x: &mut [int] = [];\n+        x.mut_pop_ref();\n+    }\n }\n \n #[cfg(test)]"}]}