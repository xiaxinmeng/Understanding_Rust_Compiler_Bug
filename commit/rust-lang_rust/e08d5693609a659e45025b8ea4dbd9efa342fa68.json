{"sha": "e08d5693609a659e45025b8ea4dbd9efa342fa68", "node_id": "C_kwDOAAsO6NoAKGUwOGQ1NjkzNjA5YTY1OWU0NTAyNWI4ZWE0ZGJkOWVmYTM0MmZhNjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-19T12:15:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-19T12:15:10Z"}, "message": "Auto merge of #94148 - matthiaskrgr:rollup-jgea68f, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #92902 (Improve the documentation of drain members)\n - #93658 (Stabilize `#[cfg(panic = \"...\")]`)\n - #93954 (rustdoc-json: buffer output)\n - #93979 (Add debug assertions to validate NUL terminator in c strings)\n - #93990 (pre #89862 cleanup)\n - #94006 (Use a `Field` in `ConstraintCategory::ClosureUpvar`)\n - #94086 (Fix ScalarInt to char conversion)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "582c4ebf10591a5a758a3552b3e4cd7996e73974", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/582c4ebf10591a5a758a3552b3e4cd7996e73974"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e08d5693609a659e45025b8ea4dbd9efa342fa68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e08d5693609a659e45025b8ea4dbd9efa342fa68", "html_url": "https://github.com/rust-lang/rust/commit/e08d5693609a659e45025b8ea4dbd9efa342fa68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e08d5693609a659e45025b8ea4dbd9efa342fa68/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb4ee81ef555126e49b3e9f16ca6f12a3264a451", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb4ee81ef555126e49b3e9f16ca6f12a3264a451", "html_url": "https://github.com/rust-lang/rust/commit/cb4ee81ef555126e49b3e9f16ca6f12a3264a451"}, {"sha": "5a083dbbe6cbb5e7bcab3b21942d162b4628e76f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a083dbbe6cbb5e7bcab3b21942d162b4628e76f", "html_url": "https://github.com/rust-lang/rust/commit/5a083dbbe6cbb5e7bcab3b21942d162b4628e76f"}], "stats": {"total": 470, "additions": 256, "deletions": 214}, "files": [{"sha": "e6a323d676e14c0c349b8cbec1d0afcb0e8b296d", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -5,6 +5,7 @@ use rustc_infer::infer::{\n     error_reporting::nice_region_error::NiceRegionError,\n     error_reporting::unexpected_hidden_region_diagnostic, NllRegionVariableOrigin,\n };\n+use rustc_middle::hir::place::PlaceBase;\n use rustc_middle::mir::{ConstraintCategory, ReturnConstraint};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n use rustc_middle::ty::{self, RegionVid, Ty};\n@@ -421,17 +422,26 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n         diag.span_label(*span, message);\n \n-        // FIXME(project-rfc-2229#48): This should store a captured_place not a hir id\n-        if let ReturnConstraint::ClosureUpvar(upvar) = kind {\n+        if let ReturnConstraint::ClosureUpvar(upvar_field) = kind {\n             let def_id = match self.regioncx.universal_regions().defining_ty {\n                 DefiningTy::Closure(def_id, _) => def_id,\n                 ty => bug!(\"unexpected DefiningTy {:?}\", ty),\n             };\n \n-            let upvar_def_span = self.infcx.tcx.hir().span(upvar);\n-            let upvar_span = self.infcx.tcx.upvars_mentioned(def_id).unwrap()[&upvar].span;\n-            diag.span_label(upvar_def_span, \"variable defined here\");\n-            diag.span_label(upvar_span, \"variable captured here\");\n+            let captured_place = &self.upvars[upvar_field.index()].place;\n+            let defined_hir = match captured_place.place.base {\n+                PlaceBase::Local(hirid) => Some(hirid),\n+                PlaceBase::Upvar(upvar) => Some(upvar.var_path.hir_id),\n+                _ => None,\n+            };\n+\n+            if defined_hir.is_some() {\n+                let upvars_map = self.infcx.tcx.upvars_mentioned(def_id).unwrap();\n+                let upvar_def_span = self.infcx.tcx.hir().span(defined_hir.unwrap());\n+                let upvar_span = upvars_map.get(&defined_hir.unwrap()).unwrap().span;\n+                diag.span_label(upvar_def_span, \"variable defined here\");\n+                diag.span_label(upvar_span, \"variable captured here\");\n+            }\n         }\n \n         if let Some(fr_span) = self.give_region_a_name(*outlived_fr).unwrap().span() {"}, {"sha": "a58240900969e5ee8b04291bbbb9173d7a9a849b", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -2530,9 +2530,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             body,\n         );\n         let category = if let Some(field) = field {\n-            let var_hir_id = self.borrowck_context.upvars[field.index()].place.get_root_variable();\n-            // FIXME(project-rfc-2229#8): Use Place for better diagnostics\n-            ConstraintCategory::ClosureUpvar(var_hir_id)\n+            ConstraintCategory::ClosureUpvar(field)\n         } else {\n             ConstraintCategory::Boring\n         };"}, {"sha": "d43f926d0a56a458fc3dbd97fe27ef867736ba31", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -70,6 +70,8 @@ declare_features! (\n     (accepted, cfg_attr_multi, \"1.33.0\", Some(54881), None),\n     /// Allows the use of `#[cfg(doctest)]`, set when rustdoc is collecting doctests.\n     (accepted, cfg_doctest, \"1.40.0\", Some(62210), None),\n+    /// Enables `#[cfg(panic = \"...\")]` config key.\n+    (accepted, cfg_panic, \"1.60.0\", Some(77443), None),\n     /// Allows `cfg(target_feature = \"...\")`.\n     (accepted, cfg_target_feature, \"1.27.0\", Some(29717), None),\n     /// Allows `cfg(target_vendor = \"...\")`."}, {"sha": "5545abc6024af2f8140488b18989da4e9cfa8c4d", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -306,8 +306,6 @@ declare_features! (\n     (active, c_variadic, \"1.34.0\", Some(44930), None),\n     /// Allows capturing disjoint fields in a closure/generator (RFC 2229).\n     (incomplete, capture_disjoint_fields, \"1.49.0\", Some(53488), None),\n-    /// Enables `#[cfg(panic = \"...\")]` config key.\n-    (active, cfg_panic, \"1.49.0\", Some(77443), None),\n     /// Allows the use of `#[cfg(sanitize = \"option\")]`; set when -Zsanitizer is used.\n     (active, cfg_sanitize, \"1.41.0\", Some(39699), None),\n     /// Allows `cfg(target_abi = \"...\")`."}, {"sha": "1fb1a38a927d549db9b4f93e1cbee58ebfbf54f3", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -34,7 +34,6 @@ const GATED_CFGS: &[GatedCfg] = &[\n     (sym::target_has_atomic_load_store, sym::cfg_target_has_atomic, cfg_fn!(cfg_target_has_atomic)),\n     (sym::sanitize, sym::cfg_sanitize, cfg_fn!(cfg_sanitize)),\n     (sym::version, sym::cfg_version, cfg_fn!(cfg_version)),\n-    (sym::panic, sym::cfg_panic, cfg_fn!(cfg_panic)),\n ];\n \n /// Find a gated cfg determined by the `pred`icate which is given the cfg's name."}, {"sha": "205ad04455483229fc3e3116930bb92fa12574de", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -497,16 +497,32 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n             let mut s = String::new();\n             let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n-            let mut inner = self.inner.borrow_mut();\n-            let ty_vars = inner.type_variables();\n-            let getter = move |ty_vid| {\n-                let var_origin = ty_vars.var_origin(ty_vid);\n-                if let TypeVariableOriginKind::TypeParameterDefinition(name, _) = var_origin.kind {\n+            let ty_getter = move |ty_vid| {\n+                if let TypeVariableOriginKind::TypeParameterDefinition(name, _) =\n+                    self.inner.borrow_mut().type_variables().var_origin(ty_vid).kind\n+                {\n+                    Some(name.to_string())\n+                } else {\n+                    None\n+                }\n+            };\n+            printer.ty_infer_name_resolver = Some(Box::new(ty_getter));\n+            let const_getter = move |ct_vid| {\n+                if let ConstVariableOriginKind::ConstParameterDefinition(name, _) = self\n+                    .inner\n+                    .borrow_mut()\n+                    .const_unification_table()\n+                    .probe_value(ct_vid)\n+                    .origin\n+                    .kind\n+                {\n                     return Some(name.to_string());\n+                } else {\n+                    None\n                 }\n-                None\n             };\n-            printer.name_resolver = Some(Box::new(&getter));\n+            printer.const_infer_name_resolver = Some(Box::new(const_getter));\n+\n             let _ = if let ty::FnDef(..) = ty.kind() {\n                 // We don't want the regular output for `fn`s because it includes its path in\n                 // invalid pseudo-syntax, we want the `fn`-pointer output instead."}, {"sha": "fbd5a2d08a5dcd8bee27eedfcf231928863af097", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -341,7 +341,7 @@ pub enum ConstraintCategory {\n     /// like `Foo { field: my_val }`)\n     Usage,\n     OpaqueType,\n-    ClosureUpvar(hir::HirId),\n+    ClosureUpvar(Field),\n \n     /// A constraint from a user-written predicate\n     /// with the provided span, written on the item\n@@ -363,7 +363,7 @@ pub enum ConstraintCategory {\n #[derive(TyEncodable, TyDecodable, HashStable)]\n pub enum ReturnConstraint {\n     Normal,\n-    ClosureUpvar(hir::HirId),\n+    ClosureUpvar(Field),\n }\n \n /// The subject of a `ClosureOutlivesRequirement` -- that is, the thing"}, {"sha": "ca1db2fd55141515bf483ba712392d67f3d45297", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -294,12 +294,22 @@ impl From<char> for ScalarInt {\n     }\n }\n \n+/// Error returned when a conversion from ScalarInt to char fails.\n+#[derive(Debug)]\n+pub struct CharTryFromScalarInt;\n+\n impl TryFrom<ScalarInt> for char {\n-    type Error = Size;\n+    type Error = CharTryFromScalarInt;\n+\n     #[inline]\n-    fn try_from(int: ScalarInt) -> Result<Self, Size> {\n-        int.to_bits(Size::from_bytes(std::mem::size_of::<char>()))\n-            .map(|u| char::from_u32(u.try_into().unwrap()).unwrap())\n+    fn try_from(int: ScalarInt) -> Result<Self, Self::Error> {\n+        let Ok(bits) = int.to_bits(Size::from_bytes(std::mem::size_of::<char>())) else  {\n+            return Err(CharTryFromScalarInt);\n+        };\n+        match char::from_u32(bits.try_into().unwrap()) {\n+            Some(c) => Ok(c),\n+            None => Err(CharTryFromScalarInt),\n+        }\n     }\n }\n "}, {"sha": "bf7370c9e0ee5c2fe1f111b10029a289beab6959", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -606,7 +606,7 @@ pub trait PrettyPrinter<'tcx>:\n             ty::Infer(infer_ty) => {\n                 let verbose = self.tcx().sess.verbose();\n                 if let ty::TyVar(ty_vid) = infer_ty {\n-                    if let Some(name) = self.infer_ty_name(ty_vid) {\n+                    if let Some(name) = self.ty_infer_name(ty_vid) {\n                         p!(write(\"{}\", name))\n                     } else {\n                         if verbose {\n@@ -1015,7 +1015,11 @@ pub trait PrettyPrinter<'tcx>:\n         }\n     }\n \n-    fn infer_ty_name(&self, _: ty::TyVid) -> Option<String> {\n+    fn ty_infer_name(&self, _: ty::TyVid) -> Option<String> {\n+        None\n+    }\n+\n+    fn const_infer_name(&self, _: ty::ConstVid<'tcx>) -> Option<String> {\n         None\n     }\n \n@@ -1203,7 +1207,14 @@ pub trait PrettyPrinter<'tcx>:\n                     }\n                 }\n             }\n-            ty::ConstKind::Infer(..) => print_underscore!(),\n+            ty::ConstKind::Infer(infer_ct) => {\n+                match infer_ct {\n+                    ty::InferConst::Var(ct_vid)\n+                        if let Some(name) = self.const_infer_name(ct_vid) =>\n+                            p!(write(\"{}\", name)),\n+                    _ => print_underscore!(),\n+                }\n+            }\n             ty::ConstKind::Param(ParamConst { name, .. }) => p!(write(\"{}\", name)),\n             ty::ConstKind::Value(value) => {\n                 return self.pretty_print_const_value(value, ct.ty(), print_ty);\n@@ -1559,7 +1570,8 @@ pub struct FmtPrinterData<'a, 'tcx, F> {\n \n     pub region_highlight_mode: RegionHighlightMode<'tcx>,\n \n-    pub name_resolver: Option<Box<&'a dyn Fn(ty::TyVid) -> Option<String>>>,\n+    pub ty_infer_name_resolver: Option<Box<dyn Fn(ty::TyVid) -> Option<String> + 'a>>,\n+    pub const_infer_name_resolver: Option<Box<dyn Fn(ty::ConstVid<'tcx>) -> Option<String> + 'a>>,\n }\n \n impl<'a, 'tcx, F> Deref for FmtPrinter<'a, 'tcx, F> {\n@@ -1588,7 +1600,8 @@ impl<'a, 'tcx, F> FmtPrinter<'a, 'tcx, F> {\n             binder_depth: 0,\n             printed_type_count: 0,\n             region_highlight_mode: RegionHighlightMode::new(tcx),\n-            name_resolver: None,\n+            ty_infer_name_resolver: None,\n+            const_infer_name_resolver: None,\n         }))\n     }\n }\n@@ -1843,8 +1856,12 @@ impl<'tcx, F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n }\n \n impl<'tcx, F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n-    fn infer_ty_name(&self, id: ty::TyVid) -> Option<String> {\n-        self.0.name_resolver.as_ref().and_then(|func| func(id))\n+    fn ty_infer_name(&self, id: ty::TyVid) -> Option<String> {\n+        self.0.ty_infer_name_resolver.as_ref().and_then(|func| func(id))\n+    }\n+\n+    fn const_infer_name(&self, id: ty::ConstVid<'tcx>) -> Option<String> {\n+        self.0.const_infer_name_resolver.as_ref().and_then(|func| func(id))\n     }\n \n     fn print_value_path("}, {"sha": "92d9cb2fc1b2b131c250dee59e04a48228d69914", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -17,7 +17,7 @@ use rustc_data_structures::intern::Interned;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n-use rustc_hir::def::DefKind;\n+use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n use rustc_query_system::ich::NodeIdHashingMode;\n@@ -146,6 +146,37 @@ impl<'tcx> TyCtxt<'tcx> {\n         hasher.finish()\n     }\n \n+    pub fn res_generics_def_id(self, res: Res) -> Option<DefId> {\n+        match res {\n+            Res::Def(DefKind::Ctor(CtorOf::Variant, _), def_id) => {\n+                Some(self.parent(def_id).and_then(|def_id| self.parent(def_id)).unwrap())\n+            }\n+            Res::Def(DefKind::Variant | DefKind::Ctor(CtorOf::Struct, _), def_id) => {\n+                Some(self.parent(def_id).unwrap())\n+            }\n+            // Other `DefKind`s don't have generics and would ICE when calling\n+            // `generics_of`.\n+            Res::Def(\n+                DefKind::Struct\n+                | DefKind::Union\n+                | DefKind::Enum\n+                | DefKind::Trait\n+                | DefKind::OpaqueTy\n+                | DefKind::TyAlias\n+                | DefKind::ForeignTy\n+                | DefKind::TraitAlias\n+                | DefKind::AssocTy\n+                | DefKind::Fn\n+                | DefKind::AssocFn\n+                | DefKind::AssocConst\n+                | DefKind::Impl,\n+                def_id,\n+            ) => Some(def_id),\n+            Res::Err => None,\n+            _ => None,\n+        }\n+    }\n+\n     pub fn has_error_field(self, ty: Ty<'tcx>) -> bool {\n         if let ty::Adt(def, substs) = *ty.kind() {\n             for field in def.all_fields() {"}, {"sha": "39da7c82c4eec42179a854c1840e128e6b98f59a", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 5, "deletions": 35, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -1,15 +1,14 @@\n use rustc_errors::{Applicability, ErrorReported, StashKey};\n use rustc_hir as hir;\n-use rustc_hir::def::CtorOf;\n-use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def::Res;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{HirId, Node};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IntTypeExt;\n-use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable, TypeFolder};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeFolder};\n use rustc_span::symbol::Ident;\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -198,38 +197,9 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n             // Try to use the segment resolution if it is valid, otherwise we\n             // default to the path resolution.\n             let res = segment.res.filter(|&r| r != Res::Err).unwrap_or(path.res);\n-            let generics = match res {\n-                Res::Def(DefKind::Ctor(CtorOf::Variant, _), def_id) => tcx\n-                    .generics_of(tcx.parent(def_id).and_then(|def_id| tcx.parent(def_id)).unwrap()),\n-                Res::Def(DefKind::Variant | DefKind::Ctor(CtorOf::Struct, _), def_id) => {\n-                    tcx.generics_of(tcx.parent(def_id).unwrap())\n-                }\n-                // Other `DefKind`s don't have generics and would ICE when calling\n-                // `generics_of`.\n-                Res::Def(\n-                    DefKind::Struct\n-                    | DefKind::Union\n-                    | DefKind::Enum\n-                    | DefKind::Trait\n-                    | DefKind::OpaqueTy\n-                    | DefKind::TyAlias\n-                    | DefKind::ForeignTy\n-                    | DefKind::TraitAlias\n-                    | DefKind::AssocTy\n-                    | DefKind::Fn\n-                    | DefKind::AssocFn\n-                    | DefKind::AssocConst\n-                    | DefKind::Impl,\n-                    def_id,\n-                ) => tcx.generics_of(def_id),\n-                Res::Err => {\n-                    tcx.sess.delay_span_bug(tcx.def_span(def_id), \"anon const with Res::Err\");\n-                    return None;\n-                }\n-                _ => {\n-                    // If the user tries to specify generics on a type that does not take them,\n-                    // e.g. `usize<T>`, we may hit this branch, in which case we treat it as if\n-                    // no arguments have been passed. An error should already have been emitted.\n+            let generics = match tcx.res_generics_def_id(res) {\n+                Some(def_id) => tcx.generics_of(def_id),\n+                None => {\n                     tcx.sess.delay_span_bug(\n                         tcx.def_span(def_id),\n                         &format!(\"unexpected anon const res {:?} in path: {:?}\", res, path),"}, {"sha": "e18cd8cd46427ac7c70d9b9500e86751a9c4cace", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -746,9 +746,12 @@ impl<T: Ord> BinaryHeap<T> {\n         self.rebuild_tail(start);\n     }\n \n-    /// Returns an iterator which retrieves elements in heap order.\n-    /// The retrieved elements are removed from the original heap.\n-    /// The remaining elements will be removed on drop in heap order.\n+    /// Clears the binary heap, returning an iterator over the removed elements\n+    /// in heap order. If the iterator is dropped before being fully consumed,\n+    /// it drops the remaining elements in heap order.\n+    ///\n+    /// The returned iterator keeps a mutable borrow on the heap to optimize\n+    /// its implementation.\n     ///\n     /// Note:\n     /// * `.drain_sorted()` is *O*(*n* \\* log(*n*)); much slower than `.drain()`.\n@@ -1158,9 +1161,12 @@ impl<T> BinaryHeap<T> {\n         self.len() == 0\n     }\n \n-    /// Clears the binary heap, returning an iterator over the removed elements.\n+    /// Clears the binary heap, returning an iterator over the removed elements\n+    /// in arbitrary order. If the iterator is dropped before being fully\n+    /// consumed, it drops the remaining elements in arbitrary order.\n     ///\n-    /// The elements are removed in arbitrary order.\n+    /// The returned iterator keeps a mutable borrow on the heap to optimize\n+    /// its implementation.\n     ///\n     /// # Examples\n     ///"}, {"sha": "7139a0fb94d76752372e8af27767274028bf30f4", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -1215,21 +1215,25 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         unsafe { IterMut::new(ring, tail, head, PhantomData) }\n     }\n \n-    /// Creates a draining iterator that removes the specified range in the\n-    /// deque and yields the removed items.\n+    /// Removes the specified range from the deque in bulk, returning all\n+    /// removed elements as an iterator. If the iterator is dropped before\n+    /// being fully consumed, it drops the remaining removed elements.\n     ///\n-    /// Note 1: The element range is removed even if the iterator is not\n-    /// consumed until the end.\n+    /// The returned iterator keeps a mutable borrow on the queue to optimize\n+    /// its implementation.\n     ///\n-    /// Note 2: It is unspecified how many elements are removed from the deque,\n-    /// if the `Drain` value is not dropped, but the borrow it holds expires\n-    /// (e.g., due to `mem::forget`).\n     ///\n     /// # Panics\n     ///\n     /// Panics if the starting point is greater than the end point or if\n     /// the end point is greater than the length of the deque.\n     ///\n+    /// # Leaking\n+    ///\n+    /// If the returned iterator goes out of scope without being dropped (due to\n+    /// [`mem::forget`], for example), the deque may have lost and leaked\n+    /// elements arbitrarily, including elements outside the range.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1240,7 +1244,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// assert_eq!(drained, [3]);\n     /// assert_eq!(deque, [1, 2]);\n     ///\n-    /// // A full range clears all contents\n+    /// // A full range clears all contents, like `clear()` does\n     /// deque.drain(..);\n     /// assert!(deque.is_empty());\n     /// ```"}, {"sha": "716bb4983a651f2cb581862d21ad92f4e62e69c6", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -1628,17 +1628,24 @@ impl String {\n         self.vec.clear()\n     }\n \n-    /// Creates a draining iterator that removes the specified range in the `String`\n-    /// and yields the removed `chars`.\n+    /// Removes the specified range from the string in bulk, returning all\n+    /// removed characters as an iterator.\n     ///\n-    /// Note: The element range is removed even if the iterator is not\n-    /// consumed until the end.\n+    /// The returned iterator keeps a mutable borrow on the string to optimize\n+    /// its implementation.\n     ///\n     /// # Panics\n     ///\n     /// Panics if the starting point or end point do not lie on a [`char`]\n     /// boundary, or if they're out of bounds.\n     ///\n+    /// # Leaking\n+    ///\n+    /// If the returned iterator goes out of scope without being dropped (due to\n+    /// [`core::mem::forget`], for example), the string may still contain a copy\n+    /// of any drained characters, or may have lost characters arbitrarily,\n+    /// including characters outside the range.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1652,7 +1659,7 @@ impl String {\n     /// assert_eq!(t, \"\u03b1 is alpha, \");\n     /// assert_eq!(s, \"\u03b2 is beta\");\n     ///\n-    /// // A full range clears the string\n+    /// // A full range clears the string, like `clear()` does\n     /// s.drain(..);\n     /// assert_eq!(s, \"\");\n     /// ```"}, {"sha": "c29aa0fec5b87faf7e74488a1352d5e83c9b2bf7", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -1799,19 +1799,24 @@ impl<T, A: Allocator> Vec<T, A> {\n         self.len += count;\n     }\n \n-    /// Creates a draining iterator that removes the specified range in the vector\n-    /// and yields the removed items.\n+    /// Removes the specified range from the vector in bulk, returning all\n+    /// removed elements as an iterator. If the iterator is dropped before\n+    /// being fully consumed, it drops the remaining removed elements.\n     ///\n-    /// When the iterator **is** dropped, all elements in the range are removed\n-    /// from the vector, even if the iterator was not fully consumed. If the\n-    /// iterator **is not** dropped (with [`mem::forget`] for example), it is\n-    /// unspecified how many elements are removed.\n+    /// The returned iterator keeps a mutable borrow on the vector to optimize\n+    /// its implementation.\n     ///\n     /// # Panics\n     ///\n     /// Panics if the starting point is greater than the end point or if\n     /// the end point is greater than the length of the vector.\n     ///\n+    /// # Leaking\n+    ///\n+    /// If the returned iterator goes out of scope without being dropped (due to\n+    /// [`mem::forget`], for example), the vector may have lost and leaked\n+    /// elements arbitrarily, including elements outside the range.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1820,7 +1825,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// assert_eq!(v, &[1]);\n     /// assert_eq!(u, &[2, 3]);\n     ///\n-    /// // A full range clears the vector\n+    /// // A full range clears the vector, like `clear()` does\n     /// v.drain(..);\n     /// assert_eq!(v, &[]);\n     /// ```"}, {"sha": "06c7be054a0381b0eaa9574efba3277999d4fe46", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -6,7 +6,7 @@\n #![feature(bool_to_option)]\n #![feature(box_syntax)]\n #![feature(cell_update)]\n-#![feature(cfg_panic)]\n+#![cfg_attr(bootstrap, feature(cfg_panic))]\n #![cfg_attr(bootstrap, feature(cfg_target_has_atomic))]\n #![feature(const_assume)]\n #![feature(const_black_box)]"}, {"sha": "53b43455b5a61804b25acf527ba6d4c3e22fc4cb", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -547,6 +547,10 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n     /// allocated memory for reuse.\n     ///\n+    /// If the returned iterator is dropped before being fully consumed, it\n+    /// drops the remaining key-value pairs. The returned iterator keeps a\n+    /// mutable borrow on the vector to optimize its implementation.\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "200667ae390697c390bc9f466c5933035eb4baff", "filename": "library/std/src/collections/hash/set.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -227,7 +227,12 @@ impl<T, S> HashSet<T, S> {\n         self.base.is_empty()\n     }\n \n-    /// Clears the set, returning all elements in an iterator.\n+    /// Clears the set, returning all elements as an iterator. Keeps the\n+    /// allocated memory for reuse.\n+    ///\n+    /// If the returned iterator is dropped before being fully consumed, it\n+    /// drops the remaining elements. The returned iterator keeps a mutable\n+    /// borrow on the vector to optimize its implementation.\n     ///\n     /// # Examples\n     ///"}, {"sha": "1678367290e5103d1b85f2a5a3edc3a7f6a7904e", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -382,7 +382,7 @@ impl CString {\n                 let bytes: Vec<u8> = self.into();\n                 match memchr::memchr(0, &bytes) {\n                     Some(i) => Err(NulError(i, bytes)),\n-                    None => Ok(unsafe { CString::from_vec_unchecked(bytes) }),\n+                    None => Ok(unsafe { CString::_from_vec_unchecked(bytes) }),\n                 }\n             }\n         }\n@@ -405,7 +405,7 @@ impl CString {\n             // This allows better optimizations if lto enabled.\n             match memchr::memchr(0, bytes) {\n                 Some(i) => Err(NulError(i, buffer)),\n-                None => Ok(unsafe { CString::from_vec_unchecked(buffer) }),\n+                None => Ok(unsafe { CString::_from_vec_unchecked(buffer) }),\n             }\n         }\n \n@@ -451,10 +451,15 @@ impl CString {\n     /// ```\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub unsafe fn from_vec_unchecked(mut v: Vec<u8>) -> CString {\n+    pub unsafe fn from_vec_unchecked(v: Vec<u8>) -> Self {\n+        debug_assert!(memchr::memchr(0, &v).is_none());\n+        unsafe { Self::_from_vec_unchecked(v) }\n+    }\n+\n+    unsafe fn _from_vec_unchecked(mut v: Vec<u8>) -> Self {\n         v.reserve_exact(1);\n         v.push(0);\n-        CString { inner: v.into_boxed_slice() }\n+        Self { inner: v.into_boxed_slice() }\n     }\n \n     /// Retakes ownership of a `CString` that was transferred to C via\n@@ -578,7 +583,7 @@ impl CString {\n     pub fn into_string(self) -> Result<String, IntoStringError> {\n         String::from_utf8(self.into_bytes()).map_err(|e| IntoStringError {\n             error: e.utf8_error(),\n-            inner: unsafe { CString::from_vec_unchecked(e.into_bytes()) },\n+            inner: unsafe { Self::_from_vec_unchecked(e.into_bytes()) },\n         })\n     }\n \n@@ -735,6 +740,11 @@ impl CString {\n     #[must_use]\n     #[stable(feature = \"cstring_from_vec_with_nul\", since = \"1.58.0\")]\n     pub unsafe fn from_vec_with_nul_unchecked(v: Vec<u8>) -> Self {\n+        debug_assert!(memchr::memchr(0, &v).unwrap() + 1 == v.len());\n+        unsafe { Self::_from_vec_with_nul_unchecked(v) }\n+    }\n+\n+    unsafe fn _from_vec_with_nul_unchecked(v: Vec<u8>) -> Self {\n         Self { inner: v.into_boxed_slice() }\n     }\n \n@@ -778,7 +788,7 @@ impl CString {\n             Some(nul_pos) if nul_pos + 1 == v.len() => {\n                 // SAFETY: We know there is only one nul byte, at the end\n                 // of the vec.\n-                Ok(unsafe { Self::from_vec_with_nul_unchecked(v) })\n+                Ok(unsafe { Self::_from_vec_with_nul_unchecked(v) })\n             }\n             Some(nul_pos) => Err(FromVecWithNulError {\n                 error_kind: FromBytesWithNulErrorKind::InteriorNul(nul_pos),\n@@ -811,7 +821,7 @@ impl ops::Deref for CString {\n \n     #[inline]\n     fn deref(&self) -> &CStr {\n-        unsafe { CStr::from_bytes_with_nul_unchecked(self.as_bytes_with_nul()) }\n+        unsafe { CStr::_from_bytes_with_nul_unchecked(self.as_bytes_with_nul()) }\n     }\n }\n \n@@ -928,7 +938,7 @@ impl From<Vec<NonZeroU8>> for CString {\n             };\n             // SAFETY: `v` cannot contain null bytes, given the type-level\n             // invariant of `NonZeroU8`.\n-            CString::from_vec_unchecked(v)\n+            Self::_from_vec_unchecked(v)\n         }\n     }\n }\n@@ -1225,7 +1235,7 @@ impl CStr {\n         unsafe {\n             let len = sys::strlen(ptr);\n             let ptr = ptr as *const u8;\n-            CStr::from_bytes_with_nul_unchecked(slice::from_raw_parts(ptr, len as usize + 1))\n+            Self::_from_bytes_with_nul_unchecked(slice::from_raw_parts(ptr, len as usize + 1))\n         }\n     }\n \n@@ -1268,7 +1278,7 @@ impl CStr {\n             Some(nul_pos) if nul_pos + 1 == bytes.len() => {\n                 // SAFETY: We know there is only one nul byte, at the end\n                 // of the byte slice.\n-                Ok(unsafe { Self::from_bytes_with_nul_unchecked(bytes) })\n+                Ok(unsafe { Self::_from_bytes_with_nul_unchecked(bytes) })\n             }\n             Some(nul_pos) => Err(FromBytesWithNulError::interior_nul(nul_pos)),\n             None => Err(FromBytesWithNulError::not_nul_terminated()),\n@@ -1297,12 +1307,19 @@ impl CStr {\n     #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n     #[rustc_const_stable(feature = \"const_cstr_unchecked\", since = \"1.59.0\")]\n     pub const unsafe fn from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr {\n+        // We're in a const fn, so this is the best we can do\n+        debug_assert!(!bytes.is_empty() && bytes[bytes.len() - 1] == 0);\n+        unsafe { Self::_from_bytes_with_nul_unchecked(bytes) }\n+    }\n+\n+    #[inline]\n+    const unsafe fn _from_bytes_with_nul_unchecked(bytes: &[u8]) -> &Self {\n         // SAFETY: Casting to CStr is safe because its internal representation\n         // is a [u8] too (safe only inside std).\n         // Dereferencing the obtained pointer is safe because it comes from a\n         // reference. Making a reference is then safe because its lifetime\n         // is bound by the lifetime of the given `bytes`.\n-        unsafe { &*(bytes as *const [u8] as *const CStr) }\n+        unsafe { &*(bytes as *const [u8] as *const Self) }\n     }\n \n     /// Returns the inner pointer to this C string.\n@@ -1566,7 +1583,7 @@ impl ops::Index<ops::RangeFrom<usize>> for CStr {\n         // byte, since otherwise we could get an empty string that doesn't end\n         // in a null.\n         if index.start < bytes.len() {\n-            unsafe { CStr::from_bytes_with_nul_unchecked(&bytes[index.start..]) }\n+            unsafe { CStr::_from_bytes_with_nul_unchecked(&bytes[index.start..]) }\n         } else {\n             panic!(\n                 \"index out of bounds: the len is {} but the index is {}\","}, {"sha": "00ba5460821ff356601febf2f8d13452725e0bb7", "filename": "library/std/src/ffi/c_str/tests.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/library%2Fstd%2Fsrc%2Fffi%2Fc_str%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/library%2Fstd%2Fsrc%2Fffi%2Fc_str%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str%2Ftests.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -32,14 +32,6 @@ fn build_with_zero2() {\n     assert!(CString::new(vec![0]).is_err());\n }\n \n-#[test]\n-fn build_with_zero3() {\n-    unsafe {\n-        let s = CString::from_vec_unchecked(vec![0]);\n-        assert_eq!(s.as_bytes(), b\"\\0\");\n-    }\n-}\n-\n #[test]\n fn formatted() {\n     let s = CString::new(&b\"abc\\x01\\x02\\n\\xE2\\x80\\xA6\\xFF\"[..]).unwrap();"}, {"sha": "f5b73128ad6c28a80a259f75f85879ca881f0b25", "filename": "src/doc/unstable-book/src/language-features/cfg-panic.md", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cb4ee81ef555126e49b3e9f16ca6f12a3264a451/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-panic.md", "raw_url": "https://github.com/rust-lang/rust/raw/cb4ee81ef555126e49b3e9f16ca6f12a3264a451/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-panic.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-panic.md?ref=cb4ee81ef555126e49b3e9f16ca6f12a3264a451", "patch": "@@ -1,38 +0,0 @@\n-# `cfg_panic`\n-\n-The tracking issue for this feature is: [#77443]\n-\n-[#77443]: https://github.com/rust-lang/rust/issues/77443\n-\n-------------------------\n-\n-The `cfg_panic` feature makes it possible to execute different code\n-depending on the panic strategy.\n-\n-Possible values at the moment are `\"unwind\"` or `\"abort\"`, although\n-it is possible that new panic strategies may be added to Rust in the\n-future.\n-\n-## Examples\n-\n-```rust\n-#![feature(cfg_panic)]\n-\n-#[cfg(panic = \"unwind\")]\n-fn a() {\n-    // ...\n-}\n-\n-#[cfg(not(panic = \"unwind\"))]\n-fn a() {\n-    // ...\n-}\n-\n-fn b() {\n-    if cfg!(panic = \"abort\") {\n-        // ...\n-    } else {\n-        // ...\n-    }\n-}\n-```"}, {"sha": "52980e07b8ca39b41d67bbee2a9ff5496e192c64", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -8,6 +8,7 @@ mod conversions;\n \n use std::cell::RefCell;\n use std::fs::{create_dir_all, File};\n+use std::io::{BufWriter, Write};\n use std::path::PathBuf;\n use std::rc::Rc;\n \n@@ -213,7 +214,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n         let mut index = (*self.index).clone().into_inner();\n         index.extend(self.get_trait_items());\n         // This needs to be the default HashMap for compatibility with the public interface for\n-        // rustdoc-json\n+        // rustdoc-json-types\n         #[allow(rustc::default_hash_types)]\n         let output = types::Crate {\n             root: types::Id(String::from(\"0:0\")),\n@@ -263,8 +264,10 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n         let mut p = out_dir;\n         p.push(output.index.get(&output.root).unwrap().name.clone().unwrap());\n         p.set_extension(\"json\");\n-        let file = try_err!(File::create(&p), p);\n-        serde_json::ser::to_writer(&file, &output).unwrap();\n+        let mut file = BufWriter::new(try_err!(File::create(&p), p));\n+        serde_json::ser::to_writer(&mut file, &output).unwrap();\n+        try_err!(file.flush(), p);\n+\n         Ok(())\n     }\n "}, {"sha": "1b53318806f4d64cc07a40cf2166643d395d094f", "filename": "src/test/mir-opt/const_prop/invalid_constant.main.ConstProp.diff", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/src%2Ftest%2Fmir-opt%2Fconst_prop%2Finvalid_constant.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/src%2Ftest%2Fmir-opt%2Fconst_prop%2Finvalid_constant.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Finvalid_constant.main.ConstProp.diff?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -5,39 +5,53 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/invalid_constant.rs:15:11: 15:11\n       let _1: std::option::Option<()>;     // in scope 0 at $DIR/invalid_constant.rs:16:5: 16:12\n       let mut _2: std::option::Option<std::option::Option<()>>; // in scope 0 at $DIR/invalid_constant.rs:16:7: 16:11\n-      scope 1 (inlined f) {                // at $DIR/invalid_constant.rs:16:5: 16:12\n-          debug x => _2;                   // in scope 1 at $DIR/invalid_constant.rs:16:5: 16:12\n-          let mut _3: isize;               // in scope 1 at $DIR/invalid_constant.rs:16:5: 16:12\n-          let _4: std::option::Option<()>; // in scope 1 at $DIR/invalid_constant.rs:16:5: 16:12\n-          scope 2 {\n-              debug y => _4;               // in scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n+      let _3: main::Union;                 // in scope 0 at $DIR/invalid_constant.rs:22:9: 22:22\n+      scope 1 {\n+          debug _invalid_char => _3;       // in scope 1 at $DIR/invalid_constant.rs:22:9: 22:22\n+      }\n+      scope 2 (inlined f) {                // at $DIR/invalid_constant.rs:16:5: 16:12\n+          debug x => _2;                   // in scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n+          let mut _4: isize;               // in scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n+          let _5: std::option::Option<()>; // in scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n+          scope 3 {\n+              debug y => _5;               // in scope 3 at $DIR/invalid_constant.rs:16:5: 16:12\n           }\n       }\n   \n       bb0: {\n           discriminant(_2) = 0;            // scope 0 at $DIR/invalid_constant.rs:16:7: 16:11\n--         _3 = discriminant(_2);           // scope 1 at $DIR/invalid_constant.rs:16:5: 16:12\n--         switchInt(move _3) -> [0_isize: bb3, otherwise: bb2]; // scope 1 at $DIR/invalid_constant.rs:16:5: 16:12\n-+         _3 = const 0_isize;              // scope 1 at $DIR/invalid_constant.rs:16:5: 16:12\n-+         switchInt(const 0_isize) -> [0_isize: bb3, otherwise: bb2]; // scope 1 at $DIR/invalid_constant.rs:16:5: 16:12\n+-         _4 = discriminant(_2);           // scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n+-         switchInt(move _4) -> [0_isize: bb3, otherwise: bb2]; // scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n++         _4 = const 0_isize;              // scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n++         switchInt(const 0_isize) -> [0_isize: bb3, otherwise: bb2]; // scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n       }\n   \n       bb1: {\n-          nop;                             // scope 0 at $DIR/invalid_constant.rs:15:11: 17:2\n-          return;                          // scope 0 at $DIR/invalid_constant.rs:17:2: 17:2\n+-         _3 = const { Union { int: 0x110001 } }; // scope 0 at $DIR/invalid_constant.rs:22:25: 22:58\n++         _3 = const main::Union { int: 1114113_u32, chr: {transmute(0x00110001): char} }; // scope 0 at $DIR/invalid_constant.rs:22:25: 22:58\n+                                           // ty::Const\n+                                           // + ty: main::Union\n+-                                          // + val: Unevaluated(main::{constant#0}, [main::Union], None)\n++                                          // + val: Value(Scalar(0x00110001))\n+                                           // mir::Constant\n+                                           // + span: $DIR/invalid_constant.rs:22:25: 22:58\n+-                                          // + literal: Const { ty: main::Union, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:8 ~ invalid_constant[726d]::main::{constant#0}), const_param_did: None }, substs: [main::Union], promoted: None }) }\n++                                          // + literal: Const { ty: main::Union, val: Value(Scalar(0x00110001)) }\n+          nop;                             // scope 0 at $DIR/invalid_constant.rs:15:11: 23:2\n+          return;                          // scope 0 at $DIR/invalid_constant.rs:23:2: 23:2\n       }\n   \n       bb2: {\n--         _4 = ((_2 as Some).0: std::option::Option<()>); // scope 1 at $DIR/invalid_constant.rs:16:5: 16:12\n--         _1 = _4;                         // scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n-+         _4 = const Scalar(0x02): Option::<()>; // scope 1 at $DIR/invalid_constant.rs:16:5: 16:12\n+-         _5 = ((_2 as Some).0: std::option::Option<()>); // scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n+-         _1 = _5;                         // scope 3 at $DIR/invalid_constant.rs:16:5: 16:12\n++         _5 = const Scalar(0x02): Option::<()>; // scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n +                                          // ty::Const\n +                                          // + ty: std::option::Option<()>\n +                                          // + val: Value(Scalar(0x02))\n +                                          // mir::Constant\n +                                          // + span: $DIR/invalid_constant.rs:16:5: 16:12\n +                                          // + literal: Const { ty: std::option::Option<()>, val: Value(Scalar(0x02)) }\n-+         _1 = const Scalar(0x02): Option::<()>; // scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n++         _1 = const Scalar(0x02): Option::<()>; // scope 3 at $DIR/invalid_constant.rs:16:5: 16:12\n +                                          // ty::Const\n +                                          // + ty: std::option::Option<()>\n +                                          // + val: Value(Scalar(0x02))\n@@ -48,7 +62,7 @@\n       }\n   \n       bb3: {\n-          discriminant(_1) = 0;            // scope 1 at $DIR/invalid_constant.rs:16:5: 16:12\n+          discriminant(_1) = 0;            // scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n           goto -> bb1;                     // scope 0 at $DIR/invalid_constant.rs:9:17: 9:21\n       }\n   }"}, {"sha": "4aca90900199e755efc35408cc9b8859d2d35d69", "filename": "src/test/mir-opt/const_prop/invalid_constant.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/src%2Ftest%2Fmir-opt%2Fconst_prop%2Finvalid_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/src%2Ftest%2Fmir-opt%2Fconst_prop%2Finvalid_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Finvalid_constant.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -2,7 +2,7 @@\n // by constant propagation. Regression test for issue #93688.\n //\n // compile-flags: -Copt-level=0 -Zinline-mir\n-\n+#![feature(inline_const)]\n #[inline(always)]\n pub fn f(x: Option<Option<()>>) -> Option<()> {\n     match x {\n@@ -14,4 +14,10 @@ pub fn f(x: Option<Option<()>>) -> Option<()> {\n // EMIT_MIR invalid_constant.main.ConstProp.diff\n fn main() {\n     f(None);\n+\n+    union Union {\n+        int: u32,\n+        chr: char,\n+    }\n+    let _invalid_char = const { Union { int: 0x110001 } };\n }"}, {"sha": "3853b598a7a799aaede4c32e01e06b2b33978653", "filename": "src/test/ui/cfg/cfg-panic-abort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/src%2Ftest%2Fui%2Fcfg%2Fcfg-panic-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/src%2Ftest%2Fui%2Fcfg%2Fcfg-panic-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcfg%2Fcfg-panic-abort.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -1,7 +1,7 @@\n // build-pass\n // compile-flags: -C panic=abort\n // no-prefer-dynamic\n-#![feature(cfg_panic)]\n+\n \n #[cfg(panic = \"unwind\")]\n pub fn bad() -> i32 { }"}, {"sha": "fb3e5059c8199b68c7db516ede49671ba8dfbbc1", "filename": "src/test/ui/cfg/cfg-panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/src%2Ftest%2Fui%2Fcfg%2Fcfg-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/src%2Ftest%2Fui%2Fcfg%2Fcfg-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcfg%2Fcfg-panic.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -4,7 +4,7 @@\n // ignore-emscripten no panic_unwind implementation\n // ignore-wasm32     no panic_unwind implementation\n // ignore-wasm64     no panic_unwind implementation\n-#![feature(cfg_panic)]\n+\n \n #[cfg(panic = \"abort\")]\n pub fn bad() -> i32 { }"}, {"sha": "9c59e672d8e4cbc523b4d3744bebd4b5e565c4cc", "filename": "src/test/ui/const-generics/defaults/doesnt_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdoesnt_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdoesnt_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdoesnt_infer.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -9,5 +9,5 @@ impl<const N: u32> Foo<N> {\n fn main() {\n     let foo = Foo::<1>::foo();\n     let foo = Foo::foo();\n-    //~^ error: type annotations needed for `Foo<{_: u32}>`\n+    //~^ error: type annotations needed for `Foo<N>`\n }"}, {"sha": "cccf433e32864ae0c58c21ec0b8519d91bc3161f", "filename": "src/test/ui/const-generics/defaults/doesnt_infer.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdoesnt_infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdoesnt_infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdoesnt_infer.stderr?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -1,4 +1,4 @@\n-error[E0282]: type annotations needed for `Foo<{_: u32}>`\n+error[E0282]: type annotations needed for `Foo<N>`\n   --> $DIR/doesnt_infer.rs:11:15\n    |\n LL |     let foo = Foo::foo();"}, {"sha": "b45e2cbc7372b3bfc3446714d9af3be41e609b2f", "filename": "src/test/ui/const-generics/generic_arg_infer/issue-91614.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fissue-91614.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fissue-91614.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fissue-91614.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -4,5 +4,5 @@ use std::simd::Mask;\n \n fn main() {\n     let y = Mask::<_, _>::splat(false);\n-    //~^ error: type annotations needed for `Mask<_, {_: usize}>`\n+    //~^ ERROR: type annotations needed for\n }"}, {"sha": "347cd2364b2667cff9bb7103c23376cf4ef90006", "filename": "src/test/ui/const-generics/generic_arg_infer/issue-91614.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fissue-91614.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fissue-91614.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fissue-91614.stderr?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -1,4 +1,4 @@\n-error[E0283]: type annotations needed for `Mask<_, {_: usize}>`\n+error[E0283]: type annotations needed for `Mask<_, LANES>`\n   --> $DIR/issue-91614.rs:6:13\n    |\n LL |     let y = Mask::<_, _>::splat(false);"}, {"sha": "1508374d9426622b852b97403aa99d7aeaac458f", "filename": "src/test/ui/feature-gates/feature-gate-cfg-panic.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cb4ee81ef555126e49b3e9f16ca6f12a3264a451/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb4ee81ef555126e49b3e9f16ca6f12a3264a451/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-panic.rs?ref=cb4ee81ef555126e49b3e9f16ca6f12a3264a451", "patch": "@@ -1,11 +0,0 @@\n-#[cfg(panic = \"unwind\")]\n-//~^ ERROR `cfg(panic)` is experimental and subject to change\n-fn foo() -> bool { true }\n-#[cfg(not(panic = \"unwind\"))]\n-//~^ ERROR `cfg(panic)` is experimental and subject to change\n-fn foo() -> bool { false }\n-\n-\n-fn main() {\n-    assert!(foo());\n-}"}, {"sha": "ea5cd54fa90f0e3716f67758198408711edbb572", "filename": "src/test/ui/feature-gates/feature-gate-cfg-panic.stderr", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cb4ee81ef555126e49b3e9f16ca6f12a3264a451/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb4ee81ef555126e49b3e9f16ca6f12a3264a451/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-panic.stderr?ref=cb4ee81ef555126e49b3e9f16ca6f12a3264a451", "patch": "@@ -1,21 +0,0 @@\n-error[E0658]: `cfg(panic)` is experimental and subject to change\n-  --> $DIR/feature-gate-cfg-panic.rs:1:7\n-   |\n-LL | #[cfg(panic = \"unwind\")]\n-   |       ^^^^^^^^^^^^^^^^\n-   |\n-   = note: see issue #77443 <https://github.com/rust-lang/rust/issues/77443> for more information\n-   = help: add `#![feature(cfg_panic)]` to the crate attributes to enable\n-\n-error[E0658]: `cfg(panic)` is experimental and subject to change\n-  --> $DIR/feature-gate-cfg-panic.rs:4:11\n-   |\n-LL | #[cfg(not(panic = \"unwind\"))]\n-   |           ^^^^^^^^^^^^^^^^\n-   |\n-   = note: see issue #77443 <https://github.com/rust-lang/rust/issues/77443> for more information\n-   = help: add `#![feature(cfg_panic)]` to the crate attributes to enable\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "560352b5cb958411c9db7ff5b69cfbf6a4aa2ba2", "filename": "src/test/ui/fmt/format-args-capture.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/src%2Ftest%2Fui%2Ffmt%2Fformat-args-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/src%2Ftest%2Fui%2Ffmt%2Fformat-args-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fformat-args-capture.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -1,5 +1,4 @@\n // run-pass\n-#![feature(cfg_panic)]\n \n fn main() {\n     named_argument_takes_precedence_to_captured();"}, {"sha": "2b12a62d0eb258143c7602f0e8ebaf177ad39d9f", "filename": "src/test/ui/issues/issue-68696-catch-during-unwind.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e08d5693609a659e45025b8ea4dbd9efa342fa68/src%2Ftest%2Fui%2Fissues%2Fissue-68696-catch-during-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08d5693609a659e45025b8ea4dbd9efa342fa68/src%2Ftest%2Fui%2Fissues%2Fissue-68696-catch-during-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-68696-catch-during-unwind.rs?ref=e08d5693609a659e45025b8ea4dbd9efa342fa68", "patch": "@@ -4,7 +4,6 @@\n // entering the catch_unwind.\n //\n // run-pass\n-#![feature(cfg_panic)]\n \n use std::panic::catch_unwind;\n "}]}