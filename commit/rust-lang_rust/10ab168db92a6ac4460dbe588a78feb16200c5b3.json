{"sha": "10ab168db92a6ac4460dbe588a78feb16200c5b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwYWIxNjhkYjkyYTZhYzQ0NjBkYmU1ODhhNzhmZWIxNjIwMGM1YjM=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-09-27T08:46:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-27T08:46:57Z"}, "message": "Merge pull request #60 from oli-obk/dst\n\nsome more cleanups getting rid of intermediate allocations and bad fat ptr assumptions", "tree": {"sha": "9f9e03533f307dd024cf2a61d3701905aaea1442", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f9e03533f307dd024cf2a61d3701905aaea1442"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10ab168db92a6ac4460dbe588a78feb16200c5b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10ab168db92a6ac4460dbe588a78feb16200c5b3", "html_url": "https://github.com/rust-lang/rust/commit/10ab168db92a6ac4460dbe588a78feb16200c5b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10ab168db92a6ac4460dbe588a78feb16200c5b3/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e3659eabbdb8159c00b741bcb67c0209d1d5710", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e3659eabbdb8159c00b741bcb67c0209d1d5710", "html_url": "https://github.com/rust-lang/rust/commit/1e3659eabbdb8159c00b741bcb67c0209d1d5710"}, {"sha": "7e29392ac4114029a589b42cc117266a99da61e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e29392ac4114029a589b42cc117266a99da61e3", "html_url": "https://github.com/rust-lang/rust/commit/7e29392ac4114029a589b42cc117266a99da61e3"}], "stats": {"total": 634, "additions": 431, "deletions": 203}, "files": [{"sha": "f53d22699ca079d92d464e671ad0552873dbdecf", "filename": "src/interpreter/cast.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10ab168db92a6ac4460dbe588a78feb16200c5b3/src%2Finterpreter%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ab168db92a6ac4460dbe588a78feb16200c5b3/src%2Finterpreter%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fcast.rs?ref=10ab168db92a6ac4460dbe588a78feb16200c5b3", "patch": "@@ -8,7 +8,7 @@ use primval::PrimVal;\n use memory::Pointer;\n \n use rustc::ty::Ty;\n-use syntax::ast;\n+use syntax::ast::{self, IntTy, UintTy};\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn cast_primval(&self, val: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n@@ -37,6 +37,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             ty::TyRef(..) |\n             ty::TyRawPtr(_) => Ok(Ptr(ptr)),\n             ty::TyFnPtr(_) => Ok(FnPtr(ptr)),\n+            ty::TyInt(IntTy::I8) => Ok(I8(ptr.to_int()? as i8)),\n+            ty::TyInt(IntTy::I16) => Ok(I16(ptr.to_int()? as i16)),\n+            ty::TyInt(IntTy::I32) => Ok(I32(ptr.to_int()? as i32)),\n+            ty::TyInt(IntTy::I64) => Ok(I64(ptr.to_int()? as i64)),\n+            ty::TyUint(UintTy::U8) => Ok(U8(ptr.to_int()? as u8)),\n+            ty::TyUint(UintTy::U16) => Ok(U16(ptr.to_int()? as u16)),\n+            ty::TyUint(UintTy::U32) => Ok(U32(ptr.to_int()? as u32)),\n+            ty::TyUint(UintTy::U64) => Ok(U64(ptr.to_int()? as u64)),\n             _ => Err(EvalError::Unimplemented(format!(\"ptr to {:?} cast\", ty))),\n         }\n     }"}, {"sha": "c9b51a6213a2df6a96dc44e5df639e0a496d111b", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 135, "deletions": 138, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/10ab168db92a6ac4460dbe588a78feb16200c5b3/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ab168db92a6ac4460dbe588a78feb16200c5b3/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=10ab168db92a6ac4460dbe588a78feb16200c5b3", "patch": "@@ -17,13 +17,15 @@ use syntax::codemap::{self, DUMMY_SP};\n use error::{EvalError, EvalResult};\n use memory::{Memory, Pointer, AllocId};\n use primval::{self, PrimVal};\n+use self::value::Value;\n \n use std::collections::HashMap;\n \n mod step;\n mod terminator;\n mod cast;\n mod vtable;\n+mod value;\n \n pub struct EvalContext<'a, 'tcx: 'a> {\n     /// The results of the type checker, from rustc.\n@@ -99,21 +101,6 @@ pub struct Frame<'a, 'tcx: 'a> {\n     pub stmt: usize,\n }\n \n-/// A `Value` represents a single self-contained Rust value.\n-///\n-/// A `Value` can either refer to a block of memory inside an allocation (`ByRef`) or to a primitve\n-/// value held directly, outside of any allocation (`ByVal`).\n-///\n-/// For optimization of a few very common cases, there is also a representation for a pair of\n-/// primitive values (`ByValPair`). It allows Miri to avoid making allocations for checked binary\n-/// operations and fat pointers. This idea was taken from rustc's trans.\n-#[derive(Clone, Copy, Debug)]\n-enum Value {\n-    ByRef(Pointer),\n-    ByVal(PrimVal),\n-    ByValPair(PrimVal, PrimVal),\n-}\n-\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n struct Lvalue {\n     ptr: Pointer,\n@@ -217,45 +204,45 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n+    fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n+        // FIXME: cache these allocs\n+        let ptr = self.memory.allocate(s.len(), 1)?;\n+        self.memory.write_bytes(ptr, s.as_bytes())?;\n+        self.memory.freeze(ptr.alloc_id)?;\n+        Ok(Value::ByValPair(PrimVal::Ptr(ptr), self.target_usize_primval(s.len() as u64)))\n+    }\n+\n     fn const_to_value(&mut self, const_val: &ConstVal) -> EvalResult<'tcx, Value> {\n         use rustc::middle::const_val::ConstVal::*;\n         use rustc_const_math::{ConstInt, ConstIsize, ConstUsize, ConstFloat};\n \n         let primval = match *const_val {\n-            Integral(ConstInt::I8(i)) => Value::ByVal(PrimVal::I8(i)),\n-            Integral(ConstInt::U8(i)) => Value::ByVal(PrimVal::U8(i)),\n+            Integral(ConstInt::I8(i)) => PrimVal::I8(i),\n+            Integral(ConstInt::U8(i)) => PrimVal::U8(i),\n             Integral(ConstInt::Isize(ConstIsize::Is16(i))) |\n-            Integral(ConstInt::I16(i)) => Value::ByVal(PrimVal::I16(i)),\n+            Integral(ConstInt::I16(i)) => PrimVal::I16(i),\n             Integral(ConstInt::Usize(ConstUsize::Us16(i))) |\n-            Integral(ConstInt::U16(i)) => Value::ByVal(PrimVal::U16(i)),\n+            Integral(ConstInt::U16(i)) => PrimVal::U16(i),\n             Integral(ConstInt::Isize(ConstIsize::Is32(i))) |\n-            Integral(ConstInt::I32(i)) => Value::ByVal(PrimVal::I32(i)),\n+            Integral(ConstInt::I32(i)) => PrimVal::I32(i),\n             Integral(ConstInt::Usize(ConstUsize::Us32(i))) |\n-            Integral(ConstInt::U32(i)) => Value::ByVal(PrimVal::U32(i)),\n+            Integral(ConstInt::U32(i)) => PrimVal::U32(i),\n             Integral(ConstInt::Isize(ConstIsize::Is64(i))) |\n-            Integral(ConstInt::I64(i)) => Value::ByVal(PrimVal::I64(i)),\n+            Integral(ConstInt::I64(i)) => PrimVal::I64(i),\n             Integral(ConstInt::Usize(ConstUsize::Us64(i))) |\n-            Integral(ConstInt::U64(i)) => Value::ByVal(PrimVal::U64(i)),\n-            Float(ConstFloat::F32(f)) => Value::ByVal(PrimVal::F32(f)),\n-            Float(ConstFloat::F64(f)) => Value::ByVal(PrimVal::F64(f)),\n-            Bool(b) => Value::ByVal(PrimVal::Bool(b)),\n-            Char(c) => Value::ByVal(PrimVal::Char(c)),\n-\n-            Str(ref s) => {\n-                let ptr = self.memory.allocate(s.len(), 1)?;\n-                self.memory.write_bytes(ptr, s.as_bytes())?;\n-                self.memory.freeze(ptr.alloc_id)?;\n-                Value::ByValPair(\n-                    PrimVal::Ptr(ptr),\n-                    self.target_usize_primval(s.len() as u64)\n-                )\n-            }\n+            Integral(ConstInt::U64(i)) => PrimVal::U64(i),\n+            Float(ConstFloat::F32(f)) => PrimVal::F32(f),\n+            Float(ConstFloat::F64(f)) => PrimVal::F64(f),\n+            Bool(b) => PrimVal::Bool(b),\n+            Char(c) => PrimVal::Char(c),\n+\n+            Str(ref s) => return self.str_to_value(s),\n \n             ByteStr(ref bs) => {\n                 let ptr = self.memory.allocate(bs.len(), 1)?;\n                 self.memory.write_bytes(ptr, bs)?;\n                 self.memory.freeze(ptr.alloc_id)?;\n-                Value::ByVal(PrimVal::Ptr(ptr))\n+                PrimVal::Ptr(ptr)\n             }\n \n             Struct(_)    => unimplemented!(),\n@@ -271,7 +258,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 bug!(\"uninferred constants only exist before typeck\"),\n         };\n \n-        Ok(primval)\n+        Ok(Value::ByVal(primval))\n     }\n \n     fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n@@ -578,30 +565,25 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Len(ref lvalue) => {\n                 let src = self.eval_lvalue(lvalue)?;\n                 let ty = self.lvalue_ty(lvalue);\n-                let len = match ty.sty {\n-                    ty::TyArray(_, n) => n as u64,\n-                    ty::TySlice(_) => if let LvalueExtra::Length(n) = src.extra {\n-                        n\n+                match ty.sty {\n+                    ty::TyArray(_, n) => self.memory.write_usize(dest, n as u64)?,\n+                    ty::TySlice(_) => if let LvalueExtra::Length(len) = src.extra {\n+                        self.memory.write_usize(dest, len)?;\n                     } else {\n                         bug!(\"Rvalue::Len of a slice given non-slice pointer: {:?}\", src);\n                     },\n                     _ => bug!(\"Rvalue::Len expected array or slice, got {:?}\", ty),\n-                };\n-                self.memory.write_usize(dest, len)?;\n+                }\n             }\n \n             Ref(_, _, ref lvalue) => {\n-                let lv = self.eval_lvalue(lvalue)?;\n-                let (ptr, extra) = self.get_fat_ptr(dest);\n-                self.memory.write_ptr(ptr, lv.ptr)?;\n-                match lv.extra {\n+                let lvalue = self.eval_lvalue(lvalue)?;\n+                self.memory.write_ptr(dest, lvalue.ptr)?;\n+                let extra_ptr = dest.offset(self.memory.pointer_size() as isize);\n+                match lvalue.extra {\n                     LvalueExtra::None => {},\n-                    LvalueExtra::Length(len) => {\n-                        self.memory.write_usize(extra, len)?;\n-                    }\n-                    LvalueExtra::Vtable(ptr) => {\n-                        self.memory.write_ptr(extra, ptr)?;\n-                    },\n+                    LvalueExtra::Length(len) => self.memory.write_usize(extra_ptr, len)?,\n+                    LvalueExtra::Vtable(ptr) => self.memory.write_ptr(extra_ptr, ptr)?,\n                     LvalueExtra::DowncastVariant(..) =>\n                         bug!(\"attempted to take a reference to an enum downcast lvalue\"),\n                 }\n@@ -618,13 +600,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 use rustc::mir::repr::CastKind::*;\n                 match kind {\n                     Unsize => {\n-                        let src = self.eval_operand_to_ptr(operand)?;\n+                        let src = self.eval_operand(operand)?;\n                         let src_ty = self.operand_ty(operand);\n                         let dest_ty = self.monomorphize(dest_ty, self.substs());\n                         // FIXME: cases where dest_ty is not a fat pointer. e.g. Arc<Struct> -> Arc<Trait>\n                         assert!(self.type_is_fat_ptr(dest_ty));\n-                        let (ptr, extra) = self.get_fat_ptr(dest);\n-                        self.move_(src, ptr, src_ty)?;\n                         let src_pointee_ty = pointee_type(src_ty).unwrap();\n                         let dest_pointee_ty = pointee_type(dest_ty).unwrap();\n \n@@ -633,47 +613,60 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                         match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n                             (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n-                                self.memory.write_usize(extra, length as u64)?;\n+                                let ptr = src.read_ptr(&self.memory)?;\n+                                self.memory.write_ptr(dest, ptr)?;\n+                                let ptr_size = self.memory.pointer_size() as isize;\n+                                let dest_extra = dest.offset(ptr_size);\n+                                self.memory.write_usize(dest_extra, length as u64)?;\n                             }\n                             (&ty::TyTrait(_), &ty::TyTrait(_)) => {\n                                 // For now, upcasts are limited to changes in marker\n                                 // traits, and hence never actually require an actual\n                                 // change to the vtable.\n-                                let (_, src_extra) = self.get_fat_ptr(src);\n-                                let src_extra = self.memory.read_ptr(src_extra)?;\n-                                self.memory.write_ptr(extra, src_extra)?;\n+                                self.write_value(src, dest, dest_ty)?;\n                             },\n                             (_, &ty::TyTrait(ref data)) => {\n                                 let trait_ref = data.principal.with_self_ty(self.tcx, src_pointee_ty);\n                                 let trait_ref = self.tcx.erase_regions(&trait_ref);\n                                 let vtable = self.get_vtable(trait_ref)?;\n-                                self.memory.write_ptr(extra, vtable)?;\n+                                let ptr = src.read_ptr(&self.memory)?;\n+\n+                                self.memory.write_ptr(dest, ptr)?;\n+                                let ptr_size = self.memory.pointer_size() as isize;\n+                                let dest_extra = dest.offset(ptr_size);\n+                                self.memory.write_ptr(dest_extra, vtable)?;\n                             },\n \n                             _ => bug!(\"invalid unsizing {:?} -> {:?}\", src_ty, dest_ty),\n                         }\n                     }\n \n                     Misc => {\n-                        let src = self.eval_operand_to_ptr(operand)?;\n+                        let src = self.eval_operand(operand)?;\n                         let src_ty = self.operand_ty(operand);\n+                        // FIXME: dest_ty should already be monomorphized\n+                        let dest_ty = self.monomorphize(dest_ty, self.substs());\n                         if self.type_is_fat_ptr(src_ty) {\n-                            let (data_ptr, _meta_ptr) = self.get_fat_ptr(src);\n+                            trace!(\"misc cast: {:?}\", src);\n                             let ptr_size = self.memory.pointer_size();\n-                            let dest_ty = self.monomorphize(dest_ty, self.substs());\n-                            if self.type_is_fat_ptr(dest_ty) {\n-                                // FIXME: add assertion that the extra part of the src_ty and\n-                                // dest_ty is of the same type\n-                                self.memory.copy(data_ptr, dest, ptr_size * 2, ptr_size)?;\n-                            } else { // cast to thin-ptr\n-                                // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n-                                // pointer-cast of that pointer to desired pointer type.\n-                                self.memory.copy(data_ptr, dest, ptr_size, ptr_size)?;\n+                            match (src, self.type_is_fat_ptr(dest_ty)) {\n+                                (Value::ByValPair(data, meta), true) => {\n+                                    self.memory.write_primval(dest, data)?;\n+                                    self.memory.write_primval(dest.offset(ptr_size as isize), meta)?;\n+                                },\n+                                (Value::ByValPair(data, _), false) => {\n+                                    self.memory.write_primval(dest, data)?;\n+                                },\n+                                (Value::ByRef(ptr), true) => {\n+                                    self.memory.copy(ptr, dest, ptr_size * 2, ptr_size)?;\n+                                },\n+                                (Value::ByRef(ptr), false) => {\n+                                    self.memory.copy(ptr, dest, ptr_size, ptr_size)?;\n+                                },\n+                                (Value::ByVal(_), _) => bug!(\"expected fat ptr\"),\n                             }\n                         } else {\n-                            // FIXME: dest_ty should already be monomorphized\n-                            let dest_ty = self.monomorphize(dest_ty, self.substs());\n-                            let src_val = self.read_primval(src, src_ty)?;\n+                            let src_val = self.value_to_primval(src, src_ty)?;\n                             let dest_val = self.cast_primval(src_val, dest_ty)?;\n                             self.memory.write_primval(dest, dest_val)?;\n                         }\n@@ -689,8 +682,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     UnsafeFnPointer => match dest_ty.sty {\n                         ty::TyFnPtr(unsafe_fn_ty) => {\n-                            let src = self.eval_operand_to_ptr(operand)?;\n-                            let ptr = self.memory.read_ptr(src)?;\n+                            let src = self.eval_operand(operand)?;\n+                            let ptr = src.read_ptr(&self.memory)?;\n                             let (def_id, substs, _) = self.memory.get_fn(ptr.alloc_id)?;\n                             let fn_ptr = self.memory.create_fn_ptr(def_id, substs, unsafe_fn_ty);\n                             self.memory.write_ptr(dest, fn_ptr)?;\n@@ -779,14 +772,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    // FIXME(solson): This method unnecessarily allocates and should not be necessary. We can\n-    // remove it as soon as PrimVal can represent fat pointers.\n-    fn eval_operand_to_ptr(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Pointer> {\n-        let value = self.eval_operand(op)?;\n-        let ty = self.operand_ty(op);\n-        self.value_to_ptr(value, ty)\n-    }\n-\n     fn eval_operand_to_primval(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         let value = self.eval_operand(op)?;\n         let ty = self.operand_ty(op);\n@@ -863,6 +848,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 use rustc::mir::repr::ProjectionElem::*;\n                 match proj.elem {\n                     Field(field, field_ty) => {\n+                        let field_ty = self.monomorphize(field_ty, self.substs());\n                         use rustc::ty::layout::Layout::*;\n                         let variant = match *base_layout {\n                             Univariant { ref variant, .. } => variant,\n@@ -883,15 +869,21 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                         let offset = variant.field_offset(field.index()).bytes();\n                         let ptr = base.ptr.offset(offset as isize);\n-                        match (&field_ty.sty, base.extra) {\n-                            (&ty::TyStr, extra @ LvalueExtra::Length(_)) |\n-                            (&ty::TySlice(_), extra @ LvalueExtra::Length(_)) |\n-                            (&ty::TyTrait(_), extra @ LvalueExtra::Vtable(_)) => return Ok(Lvalue {\n+                        trace!(\"{:?}\", base);\n+                        trace!(\"{:?}\", field_ty);\n+                        if self.type_is_sized(field_ty) {\n+                            ptr\n+                        } else {\n+                            match base.extra {\n+                                LvalueExtra::None => bug!(\"expected fat pointer\"),\n+                                LvalueExtra::DowncastVariant(..) => bug!(\"Rust doesn't support unsized fields in enum variants\"),\n+                                LvalueExtra::Vtable(_) |\n+                                LvalueExtra::Length(_) => {},\n+                            }\n+                            return Ok(Lvalue {\n                                 ptr: ptr,\n-                                extra: extra,\n-                            }),\n-                            (&ty::TyTrait(_), _) => bug!(\"trait field without vtable\"),\n-                            _ => ptr,\n+                                extra: base.extra,\n+                            });\n                         }\n                     },\n \n@@ -912,21 +904,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     },\n \n                     Deref => {\n-                        let pointee_ty = pointee_type(base_ty).expect(\"Deref of non-pointer\");\n-                        let pointee_ty = self.tcx.struct_tail(pointee_ty);\n-                        let ptr = self.memory.read_ptr(base.ptr)?;\n-                        let extra = match pointee_ty.sty {\n-                            ty::TySlice(_) | ty::TyStr => {\n-                                let (_, extra) = self.get_fat_ptr(base.ptr);\n-                                let len = self.memory.read_usize(extra)?;\n-                                LvalueExtra::Length(len)\n-                            }\n-                            ty::TyTrait(_) => {\n-                                let (_, extra) = self.get_fat_ptr(base.ptr);\n-                                let vtable = self.memory.read_ptr(extra)?;\n-                                LvalueExtra::Vtable(vtable)\n-                            },\n-                            _ => LvalueExtra::None,\n+                        use primval::PrimVal::*;\n+                        use interpreter::value::Value::*;\n+                        let (ptr, extra) = match self.read_value(base.ptr, base_ty)? {\n+                            ByValPair(Ptr(ptr), Ptr(vptr)) => (ptr, LvalueExtra::Vtable(vptr)),\n+                            ByValPair(Ptr(ptr), n) => (ptr, LvalueExtra::Length(n.expect_uint(\"slice length\"))),\n+                            ByVal(Ptr(ptr)) => (ptr, LvalueExtra::None),\n+                            _ => bug!(\"can't deref non pointer types\"),\n                         };\n                         return Ok(Lvalue { ptr: ptr, extra: extra });\n                     }\n@@ -937,8 +921,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             ty::TySlice(elem_ty) => self.type_size(elem_ty),\n                             _ => bug!(\"indexing expected an array or slice, got {:?}\", base_ty),\n                         };\n-                        let n_ptr = self.eval_operand_to_ptr(operand)?;\n-                        let n = self.memory.read_usize(n_ptr)?;\n+                        let n_ptr = self.eval_operand(operand)?;\n+                        let usize = self.tcx.types.usize;\n+                        let n = self.value_to_primval(n_ptr, usize)?.expect_uint(\"Projection::Index expected usize\");\n                         base.ptr.offset(n as isize * elem_size as isize)\n                     }\n \n@@ -951,12 +936,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(Lvalue { ptr: ptr, extra: LvalueExtra::None })\n     }\n \n-    fn get_fat_ptr(&self, ptr: Pointer) -> (Pointer, Pointer) {\n-        assert_eq!(layout::FAT_PTR_ADDR, 0);\n-        assert_eq!(layout::FAT_PTR_EXTRA, 1);\n-        (ptr, ptr.offset(self.memory.pointer_size() as isize))\n-    }\n-\n     fn lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n         self.monomorphize(lvalue.ty(&self.mir(), self.tcx).to_ty(self.tcx), self.substs())\n     }\n@@ -974,7 +953,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     // FIXME(solson): This method unnecessarily allocates and should not be necessary. We can\n     // remove it as soon as PrimVal can represent fat pointers.\n-    fn value_to_ptr(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Pointer> {\n+    fn value_to_ptr_dont_use(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Pointer> {\n         match value {\n             Value::ByRef(ptr) => Ok(ptr),\n \n@@ -986,27 +965,29 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 Ok(ptr)\n             }\n \n-            Value::ByValPair(primval1, primval2) => {\n+            Value::ByValPair(a, b) => {\n                 let size = self.type_size(ty);\n                 let align = self.type_align(ty);\n                 let ptr = self.memory.allocate(size, align)?;\n-\n-                // FIXME(solson): Major dangerous assumptions here. Ideally obliterate this\n-                // function.\n-                self.memory.write_primval(ptr, primval1)?;\n-                self.memory.write_primval(ptr.offset((size / 2) as isize), primval2)?;\n+                let ptr_size = self.memory.pointer_size() as isize;\n+                self.memory.write_primval(ptr, a)?;\n+                self.memory.write_primval(ptr.offset(ptr_size), b)?;\n                 Ok(ptr)\n             }\n         }\n     }\n \n     fn value_to_primval(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         match value {\n-            Value::ByRef(ptr) => self.read_primval(ptr, ty),\n+            Value::ByRef(ptr) => match self.read_value(ptr, ty)? {\n+                Value::ByRef(_) => bug!(\"read_value can't result in `ByRef`\"),\n+                Value::ByVal(primval) => Ok(primval),\n+                Value::ByValPair(..) => bug!(\"value_to_primval can't work with fat pointers\"),\n+            },\n \n             // TODO(solson): Sanity-check the primval type against the input type.\n             Value::ByVal(primval) => Ok(primval),\n-            Value::ByValPair(..) => bug!(\"can't turn a ByValPair into a single PrimVal\"),\n+            Value::ByValPair(..) => bug!(\"value_to_primval can't work with fat pointers\"),\n         }\n     }\n \n@@ -1019,18 +1000,24 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match value {\n             Value::ByRef(ptr) => self.move_(ptr, dest, dest_ty),\n             Value::ByVal(primval) => self.memory.write_primval(dest, primval),\n-            Value::ByValPair(primval1, primval2) => {\n-                let size = self.type_size(dest_ty);\n-\n-                // FIXME(solson): Major dangerous assumptions here.\n-                self.memory.write_primval(dest, primval1)?;\n-                self.memory.write_primval(dest.offset((size / 2) as isize), primval2)?;\n-                Ok(())\n+            Value::ByValPair(a, b) => {\n+                self.memory.write_primval(dest, a)?;\n+                let layout = self.type_layout(dest_ty);\n+                let offset = match *layout {\n+                    Layout::Univariant { .. } => {\n+                        bug!(\"I don't think this can ever happen until we have custom fat pointers\");\n+                        //variant.field_offset(1).bytes() as isize\n+                    },\n+                    Layout::FatPointer { .. } => self.memory.pointer_size() as isize,\n+                    _ => bug!(\"tried to write value pair of non-fat pointer type: {:?}\", layout),\n+                };\n+                let extra_dest = dest.offset(offset);\n+                self.memory.write_primval(extra_dest, b)\n             }\n         }\n     }\n \n-    pub fn read_primval(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+    fn read_value(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         use syntax::ast::{IntTy, UintTy, FloatTy};\n         let val = match &ty.sty {\n             &ty::TyBool => PrimVal::Bool(self.memory.read_bool(ptr)?),\n@@ -1061,12 +1048,22 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 PrimVal::FnPtr(self.memory.create_fn_ptr(def_id, substs, fn_ty))\n             },\n             &ty::TyFnPtr(_) => self.memory.read_ptr(ptr).map(PrimVal::FnPtr)?,\n+            &ty::TyBox(ty) |\n             &ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n             &ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n+                let p = self.memory.read_ptr(ptr)?;\n                 if self.type_is_sized(ty) {\n-                    PrimVal::Ptr(self.memory.read_ptr(ptr)?)\n+                    PrimVal::Ptr(p)\n                 } else {\n-                    bug!(\"primitive read of fat pointer type: {:?}\", ty);\n+                    // FIXME: extract the offset to the tail field for `Box<(i64, i32, [u8])>`\n+                    let extra = ptr.offset(self.memory.pointer_size() as isize);\n+                    let extra = match self.tcx.struct_tail(ty).sty {\n+                        ty::TyTrait(..) => PrimVal::Ptr(self.memory.read_ptr(extra)?),\n+                        ty::TySlice(..) |\n+                        ty::TyStr => self.target_usize_primval(self.memory.read_usize(extra)?),\n+                        _ => bug!(\"unsized primval ptr read from {:?}\", ty),\n+                    };\n+                    return Ok(Value::ByValPair(PrimVal::Ptr(p), extra));\n                 }\n             }\n \n@@ -1091,7 +1088,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             _ => bug!(\"primitive read of non-primitive type: {:?}\", ty),\n         };\n-        Ok(val)\n+        Ok(Value::ByVal(val))\n     }\n \n     fn frame(&self) -> &Frame<'a, 'tcx> {"}, {"sha": "c025852bc5e458584c073164d6d2c5236b19b536", "filename": "src/interpreter/terminator/intrinsics.rs", "status": "modified", "additions": 59, "deletions": 45, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/10ab168db92a6ac4460dbe588a78feb16200c5b3/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ab168db92a6ac4460dbe588a78feb16200c5b3/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fintrinsics.rs?ref=10ab168db92a6ac4460dbe588a78feb16200c5b3", "patch": "@@ -2,12 +2,13 @@ use rustc::hir::def_id::DefId;\n use rustc::mir::repr as mir;\n use rustc::ty::layout::Layout;\n use rustc::ty::subst::Substs;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n \n use error::{EvalError, EvalResult};\n use memory::Pointer;\n use interpreter::EvalContext;\n-use primval;\n+use primval::{self, PrimVal};\n+use interpreter::value::Value;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn call_intrinsic(\n@@ -16,29 +17,35 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         substs: &'tcx Substs<'tcx>,\n         args: &[mir::Operand<'tcx>],\n         dest: Pointer,\n+        dest_ty: Ty<'tcx>,\n         dest_layout: &'tcx Layout,\n     ) -> EvalResult<'tcx, ()> {\n-        // TODO(solson): We can probably remove this _to_ptr easily.\n-        let args_res: EvalResult<Vec<Pointer>> = args.iter()\n-            .map(|arg| self.eval_operand_to_ptr(arg))\n+        let args_ptrs: EvalResult<Vec<Value>> = args.iter()\n+            .map(|arg| self.eval_operand(arg))\n             .collect();\n-        let args_ptrs = args_res?;\n+        let args_ptrs = args_ptrs?;\n         let pointer_size = self.memory.pointer_size();\n+        let i32 = self.tcx.types.i32;\n+        let isize = self.tcx.types.isize;\n+        let usize = self.tcx.types.usize;\n+        let f32 = self.tcx.types.f32;\n+        let f64 = self.tcx.types.f64;\n \n         match &self.tcx.item_name(def_id).as_str()[..] {\n             \"add_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Add, &args[0], &args[1], dest, dest_layout)?,\n             \"sub_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Sub, &args[0], &args[1], dest, dest_layout)?,\n             \"mul_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Mul, &args[0], &args[1], dest, dest_layout)?,\n \n             \"arith_offset\" => {\n-                let ptr = self.memory.read_ptr(args_ptrs[0])?;\n-                let offset = self.memory.read_int(args_ptrs[1], pointer_size)?;\n+                let ptr = args_ptrs[0].read_ptr(&self.memory)?;\n+                let offset = self.value_to_primval(args_ptrs[1], isize)?.expect_int(\"arith_offset second arg not isize\");\n                 let new_ptr = ptr.offset(offset as isize);\n                 self.memory.write_ptr(dest, new_ptr)?;\n             }\n \n             \"assume\" => {\n-                if !self.memory.read_bool(args_ptrs[0])? {\n+                let bool = self.tcx.types.bool;\n+                if !self.value_to_primval(args_ptrs[0], bool)?.expect_bool(\"assume arg not bool\") {\n                     return Err(EvalError::AssumptionNotHeld);\n                 }\n             }\n@@ -51,47 +58,59 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let elem_ty = substs.type_at(0);\n                 let elem_size = self.type_size(elem_ty);\n                 let elem_align = self.type_align(elem_ty);\n-                let src = self.memory.read_ptr(args_ptrs[0])?;\n-                let dest = self.memory.read_ptr(args_ptrs[1])?;\n-                let count = self.memory.read_isize(args_ptrs[2])?;\n+                let src = args_ptrs[0].read_ptr(&self.memory)?;\n+                let dest = args_ptrs[1].read_ptr(&self.memory)?;\n+                let count = self.value_to_primval(args_ptrs[2], usize)?.expect_uint(\"arith_offset second arg not isize\");\n                 self.memory.copy(src, dest, count as usize * elem_size, elem_align)?;\n             }\n \n             \"ctpop\" => {\n                 let elem_ty = substs.type_at(0);\n                 let elem_size = self.type_size(elem_ty);\n-                let num = self.memory.read_uint(args_ptrs[0], elem_size)?.count_ones();\n+                let num = self.value_to_primval(args_ptrs[2], elem_ty)?.expect_int(\"ctpop second arg not integral\");\n+                let num = num.count_ones();\n                 self.memory.write_uint(dest, num.into(), elem_size)?;\n             }\n \n             \"ctlz\" => {\n                 let elem_ty = substs.type_at(0);\n                 let elem_size = self.type_size(elem_ty);\n-                let num = self.memory.read_uint(args_ptrs[0], elem_size)?.leading_zeros();\n+                let num = self.value_to_primval(args_ptrs[2], elem_ty)?;\n+                let num = match num {\n+                    PrimVal::I8(i) => i.leading_zeros(),\n+                    PrimVal::U8(i) => i.leading_zeros(),\n+                    PrimVal::I16(i) => i.leading_zeros(),\n+                    PrimVal::U16(i) => i.leading_zeros(),\n+                    PrimVal::I32(i) => i.leading_zeros(),\n+                    PrimVal::U32(i) => i.leading_zeros(),\n+                    PrimVal::I64(i) => i.leading_zeros(),\n+                    PrimVal::U64(i) => i.leading_zeros(),\n+                    _ => bug!(\"ctlz called with non-integer type\"),\n+                };\n                 self.memory.write_uint(dest, num.into(), elem_size)?;\n             }\n \n             \"discriminant_value\" => {\n                 let ty = substs.type_at(0);\n-                let adt_ptr = self.memory.read_ptr(args_ptrs[0])?;\n+                let adt_ptr = args_ptrs[0].read_ptr(&self.memory)?;\n                 let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n                 self.memory.write_uint(dest, discr_val, 8)?;\n             }\n \n             \"fabsf32\" => {\n-                let f = self.memory.read_f32(args_ptrs[0])?;\n+                let f = self.value_to_primval(args_ptrs[2], f32)?.expect_f32(\"fabsf32 read non f32\");\n                 self.memory.write_f32(dest, f.abs())?;\n             }\n \n             \"fabsf64\" => {\n-                let f = self.memory.read_f64(args_ptrs[0])?;\n+                let f = self.value_to_primval(args_ptrs[2], f64)?.expect_f64(\"fabsf64 read non f64\");\n                 self.memory.write_f64(dest, f.abs())?;\n             }\n \n             \"fadd_fast\" => {\n                 let ty = substs.type_at(0);\n-                let a = self.read_primval(args_ptrs[0], ty)?;\n-                let b = self.read_primval(args_ptrs[0], ty)?;\n+                let a = self.value_to_primval(args_ptrs[0], ty)?;\n+                let b = self.value_to_primval(args_ptrs[0], ty)?;\n                 let result = primval::binary_op(mir::BinOp::Add, a, b)?;\n                 self.memory.write_primval(dest, result.0)?;\n             }\n@@ -117,8 +136,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"move_val_init\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = self.memory.read_ptr(args_ptrs[0])?;\n-                self.move_(args_ptrs[1], ptr, ty)?;\n+                let ptr = args_ptrs[0].read_ptr(&self.memory)?;\n+                self.write_value(args_ptrs[1], ptr, ty)?;\n             }\n \n             \"needs_drop\" => {\n@@ -129,10 +148,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"offset\" => {\n                 let pointee_ty = substs.type_at(0);\n                 let pointee_size = self.type_size(pointee_ty) as isize;\n-                let ptr_arg = args_ptrs[0];\n-                let offset = self.memory.read_isize(args_ptrs[1])?;\n+                let offset = self.value_to_primval(args_ptrs[1], isize)?.expect_int(\"offset second arg not isize\");\n \n-                let ptr = self.memory.read_ptr(ptr_arg)?;\n+                let ptr = args_ptrs[0].read_ptr(&self.memory)?;\n                 let result_ptr = ptr.offset(offset as isize * pointee_size);\n                 self.memory.write_ptr(dest, result_ptr)?;\n             }\n@@ -150,24 +168,24 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"powif32\" => {\n-                let f = self.memory.read_f32(args_ptrs[0])?;\n-                let i = self.memory.read_int(args_ptrs[1], 4)?;\n+                let f = self.value_to_primval(args_ptrs[0], f32)?.expect_f32(\"powif32 first arg not f32\");\n+                let i = self.value_to_primval(args_ptrs[1], i32)?.expect_int(\"powif32 second arg not i32\");\n                 self.memory.write_f32(dest, f.powi(i as i32))?;\n             }\n \n             \"powif64\" => {\n-                let f = self.memory.read_f32(args_ptrs[0])?;\n-                let i = self.memory.read_int(args_ptrs[1], 4)?;\n-                self.memory.write_f32(dest, f.powi(i as i32))?;\n+                let f = self.value_to_primval(args_ptrs[0], f64)?.expect_f64(\"powif64 first arg not f64\");\n+                let i = self.value_to_primval(args_ptrs[1], i32)?.expect_int(\"powif64 second arg not i32\");\n+                self.memory.write_f64(dest, f.powi(i as i32))?;\n             }\n \n             \"sqrtf32\" => {\n-                let f = self.memory.read_f32(args_ptrs[0])?;\n+                let f = self.value_to_primval(args_ptrs[0], f32)?.expect_f32(\"sqrtf32 first arg not f32\");\n                 self.memory.write_f32(dest, f.sqrt())?;\n             }\n \n             \"sqrtf64\" => {\n-                let f = self.memory.read_f64(args_ptrs[0])?;\n+                let f = self.value_to_primval(args_ptrs[0], f64)?.expect_f64(\"sqrtf64 first arg not f64\");\n                 self.memory.write_f64(dest, f.sqrt())?;\n             }\n \n@@ -182,14 +200,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let (size, _) = self.size_and_align_of_dst(ty, args_ptrs[0])?;\n                 self.memory.write_uint(dest, size, pointer_size)?;\n             }\n-            // FIXME: wait for eval_operand_to_ptr to be gone\n-            /*\n             \"type_name\" => {\n                 let ty = substs.type_at(0);\n                 let ty_name = ty.to_string();\n                 let s = self.str_to_value(&ty_name)?;\n-                self.memory.write_ptr(dest, s)?;\n-            }*/\n+                self.write_value(s, dest, dest_ty)?;\n+            }\n             \"type_id\" => {\n                 let ty = substs.type_at(0);\n                 let n = self.tcx.type_id_hash(ty);\n@@ -198,7 +214,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"transmute\" => {\n                 let ty = substs.type_at(0);\n-                self.move_(args_ptrs[0], dest, ty)?;\n+                self.write_value(args_ptrs[0], dest, ty)?;\n             }\n \n             \"try\" => unimplemented!(),\n@@ -207,14 +223,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"volatile_load\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = self.memory.read_ptr(args_ptrs[0])?;\n+                let ptr = args_ptrs[0].read_ptr(&self.memory)?;\n                 self.move_(ptr, dest, ty)?;\n             }\n \n             \"volatile_store\" => {\n                 let ty = substs.type_at(0);\n-                let dest = self.memory.read_ptr(args_ptrs[0])?;\n-                self.move_(args_ptrs[1], dest, ty)?;\n+                let dest = args_ptrs[0].read_ptr(&self.memory)?;\n+                self.write_value(args_ptrs[1], dest, ty)?;\n             }\n \n             name => return Err(EvalError::Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),\n@@ -229,7 +245,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn size_and_align_of_dst(\n         &self,\n         ty: ty::Ty<'tcx>,\n-        value: Pointer,\n+        value: Value,\n     ) -> EvalResult<'tcx, (u64, u64)> {\n         let pointer_size = self.memory.pointer_size();\n         if self.type_is_sized(ty) {\n@@ -306,8 +322,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                 }\n                 ty::TyTrait(..) => {\n-                    let (_, vtable) = self.get_fat_ptr(value);\n-                    let vtable = self.memory.read_ptr(vtable)?;\n+                    let vtable = value.expect_vtable(&self.memory)?;\n                     // the second entry in the vtable is the dynamic size of the object.\n                     let size = self.memory.read_usize(vtable.offset(pointer_size as isize))?;\n                     let align = self.memory.read_usize(vtable.offset(pointer_size as isize * 2))?;\n@@ -317,10 +332,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 ty::TySlice(_) | ty::TyStr => {\n                     let elem_ty = ty.sequence_element_type(self.tcx);\n                     let elem_size = self.type_size(elem_ty) as u64;\n-                    let (_, len_ptr) = self.get_fat_ptr(value);\n-                    let n = self.memory.read_usize(len_ptr)?;\n+                    let len = value.expect_slice_len(&self.memory)?;\n                     let align = self.type_align(elem_ty);\n-                    Ok((n * elem_size, align as u64))\n+                    Ok((len * elem_size, align as u64))\n                 }\n \n                 _ => bug!(\"size_of_val::<{:?}>\", ty),"}, {"sha": "6e2f138119369cf19a5bc59eab6925bf1c3468c9", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/10ab168db92a6ac4460dbe588a78feb16200c5b3/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ab168db92a6ac4460dbe588a78feb16200c5b3/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=10ab168db92a6ac4460dbe588a78feb16200c5b3", "patch": "@@ -14,7 +14,8 @@ use syntax::{ast, attr};\n use error::{EvalError, EvalResult};\n use memory::Pointer;\n use primval::PrimVal;\n-use super::{EvalContext, IntegerExt, StackPopCleanup, Value};\n+use super::{EvalContext, IntegerExt, StackPopCleanup};\n+use super::value::Value;\n \n mod intrinsics;\n \n@@ -164,7 +165,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ty = fn_ty.sig.0.output;\n                 let layout = self.type_layout(ty);\n                 let (ret, target) = destination.unwrap();\n-                self.call_intrinsic(def_id, substs, arg_operands, ret, layout)?;\n+                self.call_intrinsic(def_id, substs, arg_operands, ret, ty, layout)?;\n                 self.goto_block(target);\n                 Ok(())\n             }\n@@ -265,9 +266,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             None => name.as_str(),\n         };\n \n-        // TODO(solson): We can probably remove this _to_ptr easily.\n-        let args_res: EvalResult<Vec<Pointer>> = args.iter()\n-            .map(|arg| self.eval_operand_to_ptr(arg))\n+        let args_res: EvalResult<Vec<Value>> = args.iter()\n+            .map(|arg| self.eval_operand(arg))\n             .collect();\n         let args = args_res?;\n \n@@ -276,26 +276,28 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             return Ok(());\n         }\n \n+        let usize = self.tcx.types.usize;\n+\n         match &link_name[..] {\n             \"__rust_allocate\" => {\n-                let size = self.memory.read_usize(args[0])?;\n-                let align = self.memory.read_usize(args[1])?;\n+                let size = self.value_to_primval(args[0], usize)?.expect_uint(\"__rust_allocate first arg not usize\");\n+                let align = self.value_to_primval(args[1], usize)?.expect_uint(\"__rust_allocate second arg not usize\");\n                 let ptr = self.memory.allocate(size as usize, align as usize)?;\n                 self.memory.write_ptr(dest, ptr)?;\n             }\n \n             \"__rust_reallocate\" => {\n-                let ptr = self.memory.read_ptr(args[0])?;\n-                let size = self.memory.read_usize(args[2])?;\n-                let align = self.memory.read_usize(args[3])?;\n+                let ptr = args[0].read_ptr(&self.memory)?;\n+                let size = self.value_to_primval(args[2], usize)?.expect_uint(\"__rust_reallocate third arg not usize\");\n+                let align = self.value_to_primval(args[3], usize)?.expect_uint(\"__rust_reallocate fourth arg not usize\");\n                 let new_ptr = self.memory.reallocate(ptr, size as usize, align as usize)?;\n                 self.memory.write_ptr(dest, new_ptr)?;\n             }\n \n             \"memcmp\" => {\n-                let left = self.memory.read_ptr(args[0])?;\n-                let right = self.memory.read_ptr(args[1])?;\n-                let n = self.memory.read_usize(args[2])? as usize;\n+                let left = args[0].read_ptr(&self.memory)?;\n+                let right = args[1].read_ptr(&self.memory)?;\n+                let n = self.value_to_primval(args[2], usize)?.expect_uint(\"__rust_reallocate first arg not usize\") as usize;\n \n                 let result = {\n                     let left_bytes = self.memory.read_bytes(left, n)?;\n@@ -419,7 +421,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         // intermediate function call.\n                         // FIXME: this is a memory leak, should probably add the pointer to the\n                         // current stack.\n-                        let first = self.value_to_ptr(args[0].0, args[0].1)?;\n+                        let first = self.value_to_ptr_dont_use(args[0].0, args[0].1)?;\n                         args[0].0 = Value::ByVal(PrimVal::Ptr(first));\n                         args[0].1 = self.tcx.mk_mut_ptr(args[0].1);\n                     }\n@@ -442,11 +444,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             traits::VtableObject(ref data) => {\n                 let idx = self.tcx.get_vtable_index_of_object_method(data, def_id);\n                 if let Some(&mut(ref mut first_arg, ref mut first_ty)) = args.get_mut(0) {\n-                    // FIXME(solson): Remove this allocating hack.\n-                    let ptr = self.value_to_ptr(*first_arg, *first_ty)?;\n-                    *first_arg = Value::ByRef(ptr);\n-                    let (_, vtable) = self.get_fat_ptr(ptr);\n-                    let vtable = self.memory.read_ptr(vtable)?;\n+                    let vtable = first_arg.expect_vtable(&self.memory)?;\n                     let idx = idx + 3;\n                     let offset = idx * self.memory.pointer_size();\n                     let fn_ptr = self.memory.read_ptr(vtable.offset(offset as isize))?;"}, {"sha": "87a0e15cf75e7ef5d1d0cbe0da5022d0c29109be", "filename": "src/interpreter/value.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/10ab168db92a6ac4460dbe588a78feb16200c5b3/src%2Finterpreter%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ab168db92a6ac4460dbe588a78feb16200c5b3/src%2Finterpreter%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fvalue.rs?ref=10ab168db92a6ac4460dbe588a78feb16200c5b3", "patch": "@@ -0,0 +1,53 @@\n+use memory::{Memory, Pointer};\n+use error::EvalResult;\n+use primval::PrimVal;\n+\n+/// A `Value` represents a single self-contained Rust value.\n+///\n+/// A `Value` can either refer to a block of memory inside an allocation (`ByRef`) or to a primitve\n+/// value held directly, outside of any allocation (`ByVal`).\n+///\n+/// For optimization of a few very common cases, there is also a representation for a pair of\n+/// primitive values (`ByValPair`). It allows Miri to avoid making allocations for checked binary\n+/// operations and fat pointers. This idea was taken from rustc's trans.\n+#[derive(Clone, Copy, Debug)]\n+pub(super) enum Value {\n+    ByRef(Pointer),\n+    ByVal(PrimVal),\n+    ByValPair(PrimVal, PrimVal),\n+}\n+\n+impl Value {\n+\n+    pub(super) fn read_ptr<'a, 'tcx: 'a>(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n+        use self::Value::*;\n+        match *self {\n+            ByRef(ptr) => mem.read_ptr(ptr),\n+            ByVal(PrimVal::Ptr(ptr)) |\n+            ByVal(PrimVal::FnPtr(ptr)) => Ok(ptr),\n+            ByValPair(..) => unimplemented!(),\n+            ByVal(_other) => unimplemented!(),\n+        }\n+    }\n+\n+    pub(super) fn expect_vtable<'a, 'tcx: 'a>(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n+        use self::Value::*;\n+        match *self {\n+            ByRef(ptr) => mem.read_ptr(ptr.offset(mem.pointer_size() as isize)),\n+            ByValPair(_, PrimVal::Ptr(vtable)) => Ok(vtable),\n+            _ => unimplemented!(),\n+        }\n+    }\n+\n+    pub(super) fn expect_slice_len<'a, 'tcx: 'a>(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, u64> {\n+        use self::Value::*;\n+        match *self {\n+            ByRef(ptr) => mem.read_usize(ptr.offset(mem.pointer_size() as isize)),\n+            ByValPair(_, PrimVal::U8(len)) => Ok(len as u64),\n+            ByValPair(_, PrimVal::U16(len)) => Ok(len as u64),\n+            ByValPair(_, PrimVal::U32(len)) => Ok(len as u64),\n+            ByValPair(_, PrimVal::U64(len)) => Ok(len),\n+            _ => unimplemented!(),\n+        }\n+    }\n+}"}, {"sha": "eeae014c6da1c8fb7926edaf95c3a33971b3c03f", "filename": "src/memory.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/10ab168db92a6ac4460dbe588a78feb16200c5b3/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ab168db92a6ac4460dbe588a78feb16200c5b3/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=10ab168db92a6ac4460dbe588a78feb16200c5b3", "patch": "@@ -55,6 +55,13 @@ impl Pointer {\n     pub fn points_to_zst(&self) -> bool {\n         self.alloc_id == ZST_ALLOC_ID\n     }\n+    pub fn to_int<'tcx>(&self) -> EvalResult<'tcx, usize> {\n+        if self.points_to_zst() {\n+            Ok(self.offset)\n+        } else {\n+            Err(EvalError::ReadPointerAsBytes)\n+        }\n+    }\n     pub fn from_int(i: usize) -> Self {\n         Pointer {\n             alloc_id: ZST_ALLOC_ID,"}, {"sha": "70934c2a549ac47b0fefcaa9e1ff134613c69e88", "filename": "src/primval.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/10ab168db92a6ac4460dbe588a78feb16200c5b3/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ab168db92a6ac4460dbe588a78feb16200c5b3/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=10ab168db92a6ac4460dbe588a78feb16200c5b3", "patch": "@@ -32,7 +32,10 @@ macro_rules! declare_expect_fn {\n \n impl PrimVal {\n     declare_expect_fn!(expect_bool, Bool, bool);\n+    declare_expect_fn!(expect_f32, F32, f32);\n+    declare_expect_fn!(expect_f64, F64, f64);\n     declare_expect_fn!(expect_fn_ptr, FnPtr, Pointer);\n+    declare_expect_fn!(expect_ptr, Ptr, Pointer);\n \n     pub fn expect_uint(self, error_msg: &str) -> u64 {\n         use self::PrimVal::*;\n@@ -41,6 +44,19 @@ impl PrimVal {\n             U16(u) => u as u64,\n             U32(u) => u as u64,\n             U64(u) => u,\n+            Ptr(ptr) => ptr.to_int().expect(\"non abstract ptr\") as u64,\n+            _ => bug!(\"{}\", error_msg),\n+        }\n+    }\n+\n+    pub fn expect_int(self, error_msg: &str) -> i64 {\n+        use self::PrimVal::*;\n+        match self {\n+            I8(i)  => i as i64,\n+            I16(i) => i as i64,\n+            I32(i) => i as i64,\n+            I64(i) => i,\n+            Ptr(ptr) => ptr.to_int().expect(\"non abstract ptr\") as i64,\n             _ => bug!(\"{}\", error_msg),\n         }\n     }"}, {"sha": "6870161e7682a6cca42899055bf743060ac7f5dd", "filename": "tests/compiletest.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10ab168db92a6ac4460dbe588a78feb16200c5b3/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ab168db92a6ac4460dbe588a78feb16200c5b3/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=10ab168db92a6ac4460dbe588a78feb16200c5b3", "patch": "@@ -105,6 +105,7 @@ fn compile_test() {\n                         writeln!(stderr.lock(), \"FAILED with exit code {:?}\", output.status.code()).unwrap();\n                         writeln!(stderr.lock(), \"stdout: \\n {}\", std::str::from_utf8(&output.stdout).unwrap()).unwrap();\n                         writeln!(stderr.lock(), \"stderr: \\n {}\", output_err).unwrap();\n+                        panic!(\"failed to run test\");\n                     }\n                 }\n                 Err(e) => {"}, {"sha": "932b571eccdbb8551646ada388f6b9c5e1739ca7", "filename": "tests/run-pass/dst-struct.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/10ab168db92a6ac4460dbe588a78feb16200c5b3/tests%2Frun-pass%2Fdst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ab168db92a6ac4460dbe588a78feb16200c5b3/tests%2Frun-pass%2Fdst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdst-struct.rs?ref=10ab168db92a6ac4460dbe588a78feb16200c5b3", "patch": "@@ -0,0 +1,134 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+#![allow(unused_features)]\n+#![feature(box_syntax)]\n+\n+struct Fat<T: ?Sized> {\n+    f1: isize,\n+    f2: &'static str,\n+    ptr: T\n+}\n+\n+// x is a fat pointer\n+fn foo(x: &Fat<[isize]>) {\n+    let y = &x.ptr;\n+    assert_eq!(x.ptr.len(), 3);\n+    assert_eq!(y[0], 1);\n+    assert_eq!(x.ptr[1], 2);\n+    assert_eq!(x.f1, 5);\n+    assert_eq!(x.f2, \"some str\");\n+}\n+\n+fn foo2<T:ToBar>(x: &Fat<[T]>) {\n+    let y = &x.ptr;\n+    let bar = Bar;\n+    assert_eq!(x.ptr.len(), 3);\n+    assert_eq!(y[0].to_bar(), bar);\n+    assert_eq!(x.ptr[1].to_bar(), bar);\n+    assert_eq!(x.f1, 5);\n+    assert_eq!(x.f2, \"some str\");\n+}\n+\n+fn foo3(x: &Fat<Fat<[isize]>>) {\n+    let y = &x.ptr.ptr;\n+    assert_eq!(x.f1, 5);\n+    assert_eq!(x.f2, \"some str\");\n+    assert_eq!(x.ptr.f1, 8);\n+    assert_eq!(x.ptr.f2, \"deep str\");\n+    assert_eq!(x.ptr.ptr.len(), 3);\n+    assert_eq!(y[0], 1);\n+    assert_eq!(x.ptr.ptr[1], 2);\n+}\n+\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+struct Bar;\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+}\n+\n+impl ToBar for Bar {\n+    fn to_bar(&self) -> Bar {\n+        *self\n+    }\n+}\n+\n+pub fn main() {\n+    // With a vec of ints.\n+    let f1 = Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    foo(&f1);\n+    let f2 = &f1;\n+    foo(f2);\n+    let f3: &Fat<[isize]> = f2;\n+    foo(f3);\n+    let f4: &Fat<[isize]> = &f1;\n+    foo(f4);\n+    let f5: &Fat<[isize]> = &Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    foo(f5);\n+\n+    // With a vec of Bars.\n+    let bar = Bar;\n+    let f1 = Fat { f1: 5, f2: \"some str\", ptr: [bar, bar, bar] };\n+    foo2(&f1);\n+    let f2 = &f1;\n+    foo2(f2);\n+    let f3: &Fat<[Bar]> = f2;\n+    foo2(f3);\n+    let f4: &Fat<[Bar]> = &f1;\n+    foo2(f4);\n+    let f5: &Fat<[Bar]> = &Fat { f1: 5, f2: \"some str\", ptr: [bar, bar, bar] };\n+    foo2(f5);\n+\n+    // Assignment.\n+    let f5: &mut Fat<[isize]> = &mut Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    f5.ptr[1] = 34;\n+    assert_eq!(f5.ptr[0], 1);\n+    assert_eq!(f5.ptr[1], 34);\n+    assert_eq!(f5.ptr[2], 3);\n+\n+    // Zero size vec.\n+    let f5: &Fat<[isize]> = &Fat { f1: 5, f2: \"some str\", ptr: [] };\n+    assert!(f5.ptr.is_empty());\n+    let f5: &Fat<[Bar]> = &Fat { f1: 5, f2: \"some str\", ptr: [] };\n+    assert!(f5.ptr.is_empty());\n+\n+    // Deeply nested.\n+    let f1 = Fat { f1: 5, f2: \"some str\", ptr: Fat { f1: 8, f2: \"deep str\", ptr: [1, 2, 3]} };\n+    foo3(&f1);\n+    let f2 = &f1;\n+    foo3(f2);\n+    let f3: &Fat<Fat<[isize]>> = f2;\n+    foo3(f3);\n+    let f4: &Fat<Fat<[isize]>> = &f1;\n+    foo3(f4);\n+    let f5: &Fat<Fat<[isize]>> =\n+        &Fat { f1: 5, f2: \"some str\", ptr: Fat { f1: 8, f2: \"deep str\", ptr: [1, 2, 3]} };\n+    foo3(f5);\n+\n+    // Box.\n+    let f1 = Box::new([1, 2, 3]);\n+    assert_eq!((*f1)[1], 2);\n+    let f2: Box<[isize]> = f1;\n+    assert_eq!((*f2)[1], 2);\n+\n+    // Nested Box.\n+    let f1 : Box<Fat<[isize; 3]>> = box Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    foo(&*f1);\n+    let f2 : Box<Fat<[isize]>> = f1;\n+    foo(&*f2);\n+\n+    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n+    let f3 : Box<Fat<[isize]>> =\n+        Box::<Fat<[_; 3]>>::new(Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] });\n+    foo(&*f3);\n+}"}]}