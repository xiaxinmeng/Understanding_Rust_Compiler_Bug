{"sha": "57f399bd638c211005e8565609e928db33ebf864", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3ZjM5OWJkNjM4YzIxMTAwNWU4NTY1NjA5ZTkyOGRiMzNlYmY4NjQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-05-31T22:31:13Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-05-31T22:32:29Z"}, "message": "Implement 2 kinds of char / str escaping. Use in rustc. Close #2306.", "tree": {"sha": "05d9289af9058f1509f976c1c73e722ab87cec1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05d9289af9058f1509f976c1c73e722ab87cec1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57f399bd638c211005e8565609e928db33ebf864", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57f399bd638c211005e8565609e928db33ebf864", "html_url": "https://github.com/rust-lang/rust/commit/57f399bd638c211005e8565609e928db33ebf864", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57f399bd638c211005e8565609e928db33ebf864/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2ce2741a773b94d3a8f7293cb598322bc61f89d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2ce2741a773b94d3a8f7293cb598322bc61f89d", "html_url": "https://github.com/rust-lang/rust/commit/c2ce2741a773b94d3a8f7293cb598322bc61f89d"}], "stats": {"total": 169, "additions": 136, "deletions": 33}, "files": [{"sha": "fdc44e02696f55bef5ab73e8e86d851a7c68bf56", "filename": "src/libcore/char.rs", "status": "modified", "additions": 76, "deletions": 1, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/57f399bd638c211005e8565609e928db33ebf864/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f399bd638c211005e8565609e928db33ebf864/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=57f399bd638c211005e8565609e928db33ebf864", "patch": "@@ -38,7 +38,8 @@ export is_alphabetic,\n        is_lowercase, is_uppercase,\n        is_whitespace, is_alphanumeric,\n        is_ascii, is_digit,\n-       to_digit, cmp;\n+       to_digit, cmp,\n+       escape_default, escape_unicode;\n \n import is_alphabetic = unicode::derived_property::Alphabetic;\n import is_XID_start = unicode::derived_property::XID_Start;\n@@ -122,6 +123,53 @@ pure fn to_digit(c: char, radix: uint) -> option<uint> {\n     else { none }\n }\n \n+#[doc = \"\n+Return the hexadecimal unicode escape of a char.\n+\n+The rules are as follows:\n+\n+  - chars in [0,0xff] get 2-digit escapes: `\\\\xNN`\n+  - chars in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`\n+  - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n+\"]\n+fn escape_unicode(c: char) -> str {\n+    let s = u32::to_str(c as u32, 16u);\n+    let (c, pad) = (if c <= '\\xff' { ('x', 2u) }\n+                    else if c <= '\\uffff' { ('u', 4u) }\n+                    else { ('U', 8u) });\n+    assert str::len(s) <= pad;\n+    let mut out = \"\\\\\";\n+    out += str::from_char(c);\n+    for uint::range(str::len(s), pad) {|_i| out += \"0\"; }\n+    out += s;\n+    ret out;\n+}\n+\n+#[doc = \"\n+Return a 'default' ASCII and C++11-like char-literal escape of a char.\n+\n+The default is chosen with a bias toward producing literals that are\n+legal in a variety of languages, including C++11 and similar C-family\n+languages. The exact rules are:\n+\n+  - Tab, CR and LF are escaped as '\\t', '\\r' and '\\n' respectively.\n+  - Single-quote, double-quote and backslash chars are backslash-escaped.\n+  - Any other chars in the range [0x20,0x7e] are not escaped.\n+  - Any other chars are given hex unicode escapes; see `escape_unicode`.\n+\"]\n+fn escape_default(c: char) -> str {\n+    alt c {\n+      '\\t' { \"\\\\t\" }\n+      '\\r' { \"\\\\r\" }\n+      '\\n' { \"\\\\n\" }\n+      '\\\\' { \"\\\\\\\\\" }\n+      '\\'' { \"\\\\'\" }\n+      '\"' { \"\\\\\\\"\" }\n+      '\\x20' to '\\x7e' { str::from_char(c) }\n+      _ { escape_unicode(c) }\n+    }\n+}\n+\n #[doc = \"\n Compare two chars\n \n@@ -198,3 +246,30 @@ fn test_is_digit() {\n    assert ! is_digit('Q');\n }\n \n+#[test]\n+fn test_escape_default() {\n+    assert escape_default('\\n') == \"\\\\n\";\n+    assert escape_default('\\r') == \"\\\\r\";\n+    assert escape_default('\\'') == \"\\\\'\";\n+    assert escape_default('\"') == \"\\\\\\\"\";\n+    assert escape_default(' ') == \" \";\n+    assert escape_default('a') == \"a\";\n+    assert escape_default('~') == \"~\";\n+    assert escape_default('\\x00') == \"\\\\x00\";\n+    assert escape_default('\\x1f') == \"\\\\x1f\";\n+    assert escape_default('\\x7f') == \"\\\\x7f\";\n+    assert escape_default('\\xff') == \"\\\\xff\";\n+    assert escape_default('\\u011b') == \"\\\\u011b\";\n+    assert escape_default('\\U0001d4b6') == \"\\\\U0001d4b6\";\n+}\n+\n+\n+#[test]\n+fn test_escape_unicode() {\n+    assert escape_unicode('\\x00') == \"\\\\x00\";\n+    assert escape_unicode('\\n') == \"\\\\x0a\";\n+    assert escape_unicode(' ') == \"\\\\x20\";\n+    assert escape_unicode('a') == \"\\\\x61\";\n+    assert escape_unicode('\\u011b') == \"\\\\u011b\";\n+    assert escape_unicode('\\U0001d4b6') == \"\\\\U0001d4b6\";\n+}"}, {"sha": "27bc1586273dac4bc78eb6feb23e9e55625c1257", "filename": "src/libcore/str.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/57f399bd638c211005e8565609e928db33ebf864/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f399bd638c211005e8565609e928db33ebf864/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=57f399bd638c211005e8565609e928db33ebf864", "patch": "@@ -97,6 +97,8 @@ export\n    reserve,\n    reserve_at_least,\n    capacity,\n+   escape_default,\n+   escape_unicode,\n \n    unsafe,\n    extensions;\n@@ -1625,6 +1627,22 @@ fn capacity(&&s: str) -> uint unsafe {\n     }\n }\n \n+#[doc = \"Escape each char in `s` with char::escape_default.\"]\n+fn escape_default(s: str) -> str {\n+    let mut out: str = \"\";\n+    reserve_at_least(out, str::len(s));\n+    chars_iter(s) {|c| out += char::escape_default(c); }\n+    ret out;\n+}\n+\n+#[doc = \"Escape each char in `s` with char::escape_unicode.\"]\n+fn escape_unicode(s: str) -> str {\n+    let mut out: str = \"\";\n+    reserve_at_least(out, str::len(s));\n+    chars_iter(s) {|c| out += char::escape_unicode(c); }\n+    ret out;\n+}\n+\n #[doc = \"Unsafe operations\"]\n mod unsafe {\n    export\n@@ -1866,6 +1884,12 @@ impl extensions for str {\n     #[doc = \"Returns a string with trailing whitespace removed\"]\n     #[inline]\n     fn trim_right() -> str { trim_right(self) }\n+    #[doc = \"Escape each char in `s` with char::escape_default.\"]\n+    #[inline]\n+    fn escape_default() -> str { escape_default(self) }\n+    #[doc = \"Escape each char in `s` with char::escape_unicode.\"]\n+    #[inline]\n+    fn escape_unicode() -> str { escape_unicode(self) }\n }\n \n #[cfg(test)]\n@@ -2748,4 +2772,32 @@ mod tests {\n             assert *ptr::offset(buf,5u) == 0u8;\n         }\n     }\n+\n+    #[test]\n+    fn test_escape_unicode() {\n+        assert escape_unicode(\"abc\") == \"\\\\x61\\\\x62\\\\x63\";\n+        assert escape_unicode(\"a c\") == \"\\\\x61\\\\x20\\\\x63\";\n+        assert escape_unicode(\"\\r\\n\\t\") == \"\\\\x0d\\\\x0a\\\\x09\";\n+        assert escape_unicode(\"'\\\"\\\\\") == \"\\\\x27\\\\x22\\\\x5c\";\n+        assert escape_unicode(\"\\x00\\x01\\xfe\\xff\") == \"\\\\x00\\\\x01\\\\xfe\\\\xff\";\n+        assert escape_unicode(\"\\u0100\\uffff\") == \"\\\\u0100\\\\uffff\";\n+        assert escape_unicode(\"\\U00010000\\U0010ffff\") ==\n+            \"\\\\U00010000\\\\U0010ffff\";\n+        assert escape_unicode(\"ab\\ufb00\") == \"\\\\x61\\\\x62\\\\ufb00\";\n+        assert escape_unicode(\"\\U0001d4ea\\r\") == \"\\\\U0001d4ea\\\\x0d\";\n+    }\n+\n+    #[test]\n+    fn test_escape_default() {\n+        assert escape_default(\"abc\") == \"abc\";\n+        assert escape_default(\"a c\") == \"a c\";\n+        assert escape_default(\"\\r\\n\\t\") == \"\\\\r\\\\n\\\\t\";\n+        assert escape_default(\"'\\\"\\\\\") == \"\\\\'\\\\\\\"\\\\\\\\\";\n+        assert escape_default(\"\\u0100\\uffff\") == \"\\\\u0100\\\\uffff\";\n+        assert escape_default(\"\\U00010000\\U0010ffff\") ==\n+            \"\\\\U00010000\\\\U0010ffff\";\n+        assert escape_default(\"ab\\ufb00\") == \"ab\\\\ufb00\";\n+        assert escape_default(\"\\U0001d4ea\\r\") == \"\\\\U0001d4ea\\\\r\";\n+    }\n+\n }"}, {"sha": "bef5f6d1fd889127d8c5abb24844914cf93ca409", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57f399bd638c211005e8565609e928db33ebf864/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f399bd638c211005e8565609e928db33ebf864/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=57f399bd638c211005e8565609e928db33ebf864", "patch": "@@ -434,6 +434,7 @@ fn next_token_inner(rdr: reader) -> token::token {\n               't' { c2 = '\\t'; }\n               '\\\\' { c2 = '\\\\'; }\n               '\\'' { c2 = '\\''; }\n+              '\"' { c2 = '\"'; }\n               'x' { c2 = scan_numeric_escape(rdr, 2u); }\n               'u' { c2 = scan_numeric_escape(rdr, 4u); }\n               'U' { c2 = scan_numeric_escape(rdr, 8u); }"}, {"sha": "044509a5144f615989c7929c9a43112f75e692f2", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/57f399bd638c211005e8565609e928db33ebf864/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f399bd638c211005e8565609e928db33ebf864/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=57f399bd638c211005e8565609e928db33ebf864", "patch": "@@ -122,11 +122,7 @@ fn to_str(in: interner<str>, t: token) -> str {\n \n       /* Literals */\n       LIT_INT(c, ast::ty_char) {\n-        // FIXME: escape.\n-        let mut tmp = \"'\";\n-        str::push_char(tmp, c as char);\n-        str::push_char(tmp, '\\'');\n-        ret tmp;\n+        ret \"'\" + char::escape_default(c as char) + \"'\";\n       }\n       LIT_INT(i, t) {\n         ret int::to_str(i as int, 10u) + ast_util::int_ty_to_str(t);\n@@ -138,10 +134,11 @@ fn to_str(in: interner<str>, t: token) -> str {\n         ret interner::get::<str>(in, s) +\n             ast_util::float_ty_to_str(t);\n       }\n-      LIT_STR(s) { // FIXME: escape.\n-        ret \"\\\"\" + interner::get::<str>(in, s) + \"\\\"\";\n+      LIT_STR(s) {\n+        ret \"\\\"\"\n+            + str::escape_default(interner::get::<str>(in, s))\n+            + \"\\\"\";\n       }\n-\n       /* Name components */\n       IDENT(s, _) {\n         ret interner::get::<str>(in, s);"}, {"sha": "dd935533b7fc72aea5eff2e15a709d6d5fc2aac3", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/57f399bd638c211005e8565609e928db33ebf864/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f399bd638c211005e8565609e928db33ebf864/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=57f399bd638c211005e8565609e928db33ebf864", "patch": "@@ -1609,7 +1609,7 @@ fn print_literal(s: ps, &&lit: @ast::lit) {\n     alt lit.node {\n       ast::lit_str(st) { print_string(s, st); }\n       ast::lit_int(ch, ast::ty_char) {\n-        word(s.s, \"'\" + escape_str(str::from_char(ch as char), '\\'') + \"'\");\n+        word(s.s, \"'\" + char::escape_default(ch as char) + \"'\");\n       }\n       ast::lit_int(i, t) {\n         if i < 0_i64 {\n@@ -1714,32 +1714,10 @@ fn print_comment(s: ps, cmnt: comments::cmnt) {\n \n fn print_string(s: ps, st: str) {\n     word(s.s, \"\\\"\");\n-    word(s.s, escape_str(st, '\"'));\n+    word(s.s, str::escape_default(st));\n     word(s.s, \"\\\"\");\n }\n \n-fn escape_str(st: str, to_escape: char) -> str {\n-    let mut out: str = \"\";\n-    let len = str::len(st);\n-    let mut i = 0u;\n-    while i < len {\n-        alt st[i] as char {\n-          '\\n' { out += \"\\\\n\"; }\n-          '\\t' { out += \"\\\\t\"; }\n-          '\\r' { out += \"\\\\r\"; }\n-          '\\\\' { out += \"\\\\\\\\\"; }\n-          cur {\n-            if cur == to_escape { out += \"\\\\\"; }\n-            // FIXME some (or all?) non-ascii things should be escaped\n-            // (See #2306)\n-            str::push_char(out, cur);\n-          }\n-        }\n-        i += 1u;\n-    }\n-    ret out;\n-}\n-\n fn to_str<T>(t: T, f: fn@(ps, T)) -> str {\n     let buffer = io::mem_buffer();\n     let s = rust_printer(io::mem_buffer_writer(buffer));"}]}