{"sha": "382d3b043e7eef39f5948bb07dc8df9159dd597c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MmQzYjA0M2U3ZWVmMzlmNTk0OGJiMDdkYzhkZjkxNTlkZDU5N2M=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2016-10-28T10:16:44Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2016-11-21T21:18:31Z"}, "message": "Change HirVec<P<T>> to HirVec<T> in Expr.\n\nThis changes structures like this:\n```\n[ ExprArray | 8 | P ]\n                  |\n                  v\n                  [ P | P | P | P | P | P | P | P ]\n                    |\n                    v\n                    [ ExprTup | 2 | P ]\n                                    |\n                                    v\n                                    [ P | P ]\n                                      |\n                                      v\n                                      [ Expr ]\n```\nto this:\n```\n[ ExprArray | 8 | P ]\n                  |\n                  v\n                  [ [ ExprTup | 2 | P ] | ... ]\n                                    |\n                                    v\n                                    [ Expr | Expr ]\n```", "tree": {"sha": "c7905322ff9c72555f02507b52a19cf06dca6359", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7905322ff9c72555f02507b52a19cf06dca6359"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/382d3b043e7eef39f5948bb07dc8df9159dd597c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/382d3b043e7eef39f5948bb07dc8df9159dd597c", "html_url": "https://github.com/rust-lang/rust/commit/382d3b043e7eef39f5948bb07dc8df9159dd597c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/382d3b043e7eef39f5948bb07dc8df9159dd597c/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80a95e34fe32ca86982607a85e9c5714eb6262d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/80a95e34fe32ca86982607a85e9c5714eb6262d9", "html_url": "https://github.com/rust-lang/rust/commit/80a95e34fe32ca86982607a85e9c5714eb6262d9"}], "stats": {"total": 366, "additions": 183, "deletions": 183}, "files": [{"sha": "be996ea1957234edf5cf9004cee8ae1c0f6fc04a", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/382d3b043e7eef39f5948bb07dc8df9159dd597c/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382d3b043e7eef39f5948bb07dc8df9159dd597c/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=382d3b043e7eef39f5948bb07dc8df9159dd597c", "patch": "@@ -299,15 +299,15 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprArray(ref elems) => {\n-                self.straightline(expr, pred, elems.iter().map(|e| &**e))\n+                self.straightline(expr, pred, elems.iter().map(|e| &*e))\n             }\n \n             hir::ExprCall(ref func, ref args) => {\n-                self.call(expr, pred, &func, args.iter().map(|e| &**e))\n+                self.call(expr, pred, &func, args.iter().map(|e| &*e))\n             }\n \n             hir::ExprMethodCall(.., ref args) => {\n-                self.call(expr, pred, &args[0], args[1..].iter().map(|e| &**e))\n+                self.call(expr, pred, &args[0], args[1..].iter().map(|e| &*e))\n             }\n \n             hir::ExprIndex(ref l, ref r) |\n@@ -320,7 +320,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprTup(ref exprs) => {\n-                self.straightline(expr, pred, exprs.iter().map(|e| &**e))\n+                self.straightline(expr, pred, exprs.iter().map(|e| &*e))\n             }\n \n             hir::ExprStruct(_, ref fields, ref base) => {\n@@ -353,8 +353,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprInlineAsm(_, ref outputs, ref inputs) => {\n-                let post_outputs = self.exprs(outputs.iter().map(|e| &**e), pred);\n-                let post_inputs = self.exprs(inputs.iter().map(|e| &**e), post_outputs);\n+                let post_outputs = self.exprs(outputs.iter().map(|e| &*e), pred);\n+                let post_inputs = self.exprs(inputs.iter().map(|e| &*e), post_outputs);\n                 self.add_ast_node(expr.id, &[post_inputs])\n             }\n "}, {"sha": "7b04259d1c3beb178af9609768d064f05955def0", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 140, "deletions": 138, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/382d3b043e7eef39f5948bb07dc8df9159dd597c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382d3b043e7eef39f5948bb07dc8df9159dd597c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=382d3b043e7eef39f5948bb07dc8df9159dd597c", "patch": "@@ -210,8 +210,8 @@ impl<'a> LoweringContext<'a> {\n         hir::Arm {\n             attrs: self.lower_attrs(&arm.attrs),\n             pats: arm.pats.iter().map(|x| self.lower_pat(x)).collect(),\n-            guard: arm.guard.as_ref().map(|ref x| self.lower_expr(x)),\n-            body: self.lower_expr(&arm.body),\n+            guard: arm.guard.as_ref().map(|ref x| P(self.lower_expr(x))),\n+            body: P(self.lower_expr(&arm.body)),\n         }\n     }\n \n@@ -262,10 +262,10 @@ impl<'a> LoweringContext<'a> {\n                     hir::TyObjectSum(self.lower_ty(ty), self.lower_bounds(bounds))\n                 }\n                 TyKind::Array(ref ty, ref e) => {\n-                    hir::TyArray(self.lower_ty(ty), self.lower_expr(e))\n+                    hir::TyArray(self.lower_ty(ty), P(self.lower_expr(e)))\n                 }\n                 TyKind::Typeof(ref expr) => {\n-                    hir::TyTypeof(self.lower_expr(expr))\n+                    hir::TyTypeof(P(self.lower_expr(expr)))\n                 }\n                 TyKind::PolyTraitRef(ref bounds) => {\n                     hir::TyPolyTraitRef(self.lower_bounds(bounds))\n@@ -292,7 +292,7 @@ impl<'a> LoweringContext<'a> {\n                 name: v.node.name.name,\n                 attrs: self.lower_attrs(&v.node.attrs),\n                 data: self.lower_variant_data(&v.node.data),\n-                disr_expr: v.node.disr_expr.as_ref().map(|e| self.lower_expr(e)),\n+                disr_expr: v.node.disr_expr.as_ref().map(|e| P(self.lower_expr(e))),\n             },\n             span: v.span,\n         }\n@@ -350,7 +350,7 @@ impl<'a> LoweringContext<'a> {\n             id: l.id,\n             ty: l.ty.as_ref().map(|t| self.lower_ty(t)),\n             pat: self.lower_pat(&l.pat),\n-            init: l.init.as_ref().map(|e| self.lower_expr(e)),\n+            init: l.init.as_ref().map(|e| P(self.lower_expr(e))),\n             span: l.span,\n             attrs: l.attrs.clone(),\n         })\n@@ -550,7 +550,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_field(&mut self, f: &Field) -> hir::Field {\n         hir::Field {\n             name: respan(f.ident.span, f.ident.node.name),\n-            expr: self.lower_expr(&f.expr),\n+            expr: P(self.lower_expr(&f.expr)),\n             span: f.span,\n             is_shorthand: f.is_shorthand,\n         }\n@@ -599,10 +599,10 @@ impl<'a> LoweringContext<'a> {\n             ItemKind::Static(ref t, m, ref e) => {\n                 hir::ItemStatic(self.lower_ty(t),\n                                 self.lower_mutability(m),\n-                                self.lower_expr(e))\n+                                P(self.lower_expr(e)))\n             }\n             ItemKind::Const(ref t, ref e) => {\n-                hir::ItemConst(self.lower_ty(t), self.lower_expr(e))\n+                hir::ItemConst(self.lower_ty(t), P(self.lower_expr(e)))\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n                 let body = self.lower_block(body);\n@@ -611,7 +611,7 @@ impl<'a> LoweringContext<'a> {\n                             self.lower_constness(constness),\n                             abi,\n                             self.lower_generics(generics),\n-                            self.expr_block(body, ThinVec::new()))\n+                            P(self.expr_block(body, ThinVec::new())))\n             }\n             ItemKind::Mod(ref m) => hir::ItemMod(self.lower_mod(m)),\n             ItemKind::ForeignMod(ref nm) => hir::ItemForeignMod(self.lower_foreign_mod(nm)),\n@@ -672,13 +672,13 @@ impl<'a> LoweringContext<'a> {\n                 node: match i.node {\n                     TraitItemKind::Const(ref ty, ref default) => {\n                         hir::ConstTraitItem(this.lower_ty(ty),\n-                                            default.as_ref().map(|x| this.lower_expr(x)))\n+                                            default.as_ref().map(|x| P(this.lower_expr(x))))\n                     }\n                     TraitItemKind::Method(ref sig, ref body) => {\n                         hir::MethodTraitItem(this.lower_method_sig(sig),\n                                              body.as_ref().map(|x| {\n                             let body = this.lower_block(x);\n-                            this.expr_block(body, ThinVec::new())\n+                            P(this.expr_block(body, ThinVec::new()))\n                         }))\n                     }\n                     TraitItemKind::Type(ref bounds, ref default) => {\n@@ -702,12 +702,12 @@ impl<'a> LoweringContext<'a> {\n                 defaultness: this.lower_defaultness(i.defaultness, true /* [1] */),\n                 node: match i.node {\n                     ImplItemKind::Const(ref ty, ref expr) => {\n-                        hir::ImplItemKind::Const(this.lower_ty(ty), this.lower_expr(expr))\n+                        hir::ImplItemKind::Const(this.lower_ty(ty), P(this.lower_expr(expr)))\n                     }\n                     ImplItemKind::Method(ref sig, ref body) => {\n                         let body = this.lower_block(body);\n                         hir::ImplItemKind::Method(this.lower_method_sig(sig),\n-                                                  this.expr_block(body, ThinVec::new()))\n+                                                  P(this.expr_block(body, ThinVec::new())))\n                     }\n                     ImplItemKind::Type(ref ty) => hir::ImplItemKind::Type(this.lower_ty(ty)),\n                     ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n@@ -885,7 +885,7 @@ impl<'a> LoweringContext<'a> {\n                         }\n                     })\n                 }\n-                PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n+                PatKind::Lit(ref e) => hir::PatKind::Lit(P(self.lower_expr(e))),\n                 PatKind::TupleStruct(ref path, ref pats, ddpos) => {\n                     hir::PatKind::TupleStruct(self.lower_path(path),\n                                         pats.iter().map(|x| self.lower_pat(x)).collect(), ddpos)\n@@ -920,7 +920,7 @@ impl<'a> LoweringContext<'a> {\n                     hir::PatKind::Ref(self.lower_pat(inner), self.lower_mutability(mutbl))\n                 }\n                 PatKind::Range(ref e1, ref e2) => {\n-                    hir::PatKind::Range(self.lower_expr(e1), self.lower_expr(e2))\n+                    hir::PatKind::Range(P(self.lower_expr(e1)), P(self.lower_expr(e2)))\n                 }\n                 PatKind::Slice(ref before, ref slice, ref after) => {\n                     hir::PatKind::Slice(before.iter().map(|x| self.lower_pat(x)).collect(),\n@@ -933,8 +933,8 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn lower_expr(&mut self, e: &Expr) -> P<hir::Expr> {\n-        P(hir::Expr {\n+    fn lower_expr(&mut self, e: &Expr) -> hir::Expr {\n+        hir::Expr {\n             id: e.id,\n             node: match e.node {\n                 // Issue #22181:\n@@ -954,7 +954,7 @@ impl<'a> LoweringContext<'a> {\n                 //\n                 // But for now there are type-inference issues doing that.\n                 ExprKind::Box(ref e) => {\n-                    hir::ExprBox(self.lower_expr(e))\n+                    hir::ExprBox(P(self.lower_expr(e)))\n                 }\n \n                 // Desugar ExprBox: `in (PLACE) EXPR`\n@@ -968,8 +968,8 @@ impl<'a> LoweringContext<'a> {\n                     //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n                     //     InPlace::finalize(place)\n                     // })\n-                    let placer_expr = self.lower_expr(placer);\n-                    let value_expr = self.lower_expr(value_expr);\n+                    let placer_expr = P(self.lower_expr(placer));\n+                    let value_expr = P(self.lower_expr(value_expr));\n \n                     let placer_ident = self.str_to_ident(\"placer\");\n                     let place_ident = self.str_to_ident(\"place\");\n@@ -983,7 +983,7 @@ impl<'a> LoweringContext<'a> {\n                     let make_call = |this: &mut LoweringContext, p, args| {\n                         let path = this.std_path(e.span, p);\n                         let path = this.expr_path(path, ThinVec::new());\n-                        this.expr_call(e.span, path, args)\n+                        P(this.expr_call(e.span, path, args))\n                     };\n \n                     let mk_stmt_let = |this: &mut LoweringContext, bind, expr| {\n@@ -996,11 +996,11 @@ impl<'a> LoweringContext<'a> {\n \n                     // let placer = <placer_expr> ;\n                     let (s1, placer_binding) = {\n-                        let placer_expr = self.signal_block_expr(hir_vec![],\n-                                                                 placer_expr,\n-                                                                 e.span,\n-                                                                 hir::PopUnstableBlock,\n-                                                                 ThinVec::new());\n+                        let placer_expr = P(self.signal_block_expr(hir_vec![],\n+                                                                   placer_expr,\n+                                                                   e.span,\n+                                                                   hir::PopUnstableBlock,\n+                                                                   ThinVec::new()));\n                         mk_stmt_let(self, placer_ident, placer_expr)\n                     };\n \n@@ -1013,19 +1013,19 @@ impl<'a> LoweringContext<'a> {\n \n                     // let p_ptr = Place::pointer(&mut place);\n                     let (s3, p_ptr_binding) = {\n-                        let agent = self.expr_ident(e.span, place_ident, place_binding);\n+                        let agent = P(self.expr_ident(e.span, place_ident, place_binding));\n                         let args = hir_vec![self.expr_mut_addr_of(e.span, agent)];\n                         let call = make_call(self, &place_pointer, args);\n                         mk_stmt_let(self, p_ptr_ident, call)\n                     };\n \n                     // pop_unsafe!(EXPR));\n                     let pop_unsafe_expr = {\n-                        let value_expr = self.signal_block_expr(hir_vec![],\n-                                                                value_expr,\n-                                                                e.span,\n-                                                                hir::PopUnstableBlock,\n-                                                                ThinVec::new());\n+                        let value_expr = P(self.signal_block_expr(hir_vec![],\n+                                                                  value_expr,\n+                                                                  e.span,\n+                                                                  hir::PopUnstableBlock,\n+                                                                  ThinVec::new()));\n                         self.signal_block_expr(hir_vec![],\n                                                value_expr,\n                                                e.span,\n@@ -1047,11 +1047,11 @@ impl<'a> LoweringContext<'a> {\n \n                         let place = self.expr_ident(e.span, place_ident, place_binding);\n                         let call = make_call(self, &inplace_finalize, hir_vec![place]);\n-                        self.signal_block_expr(hir_vec![call_move_val_init],\n-                                               call,\n-                                               e.span,\n-                                               hir::PushUnsafeBlock(hir::CompilerGenerated),\n-                                               ThinVec::new())\n+                        P(self.signal_block_expr(hir_vec![call_move_val_init],\n+                                                 call,\n+                                                 e.span,\n+                                                 hir::PushUnsafeBlock(hir::CompilerGenerated),\n+                                                 ThinVec::new()))\n                     };\n \n                     return self.signal_block_expr(hir_vec![s1, s2, s3],\n@@ -1065,15 +1065,15 @@ impl<'a> LoweringContext<'a> {\n                     hir::ExprArray(exprs.iter().map(|x| self.lower_expr(x)).collect())\n                 }\n                 ExprKind::Repeat(ref expr, ref count) => {\n-                    let expr = self.lower_expr(expr);\n-                    let count = self.lower_expr(count);\n+                    let expr = P(self.lower_expr(expr));\n+                    let count = P(self.lower_expr(count));\n                     hir::ExprRepeat(expr, count)\n                 }\n                 ExprKind::Tup(ref elts) => {\n                     hir::ExprTup(elts.iter().map(|x| self.lower_expr(x)).collect())\n                 }\n                 ExprKind::Call(ref f, ref args) => {\n-                    let f = self.lower_expr(f);\n+                    let f = P(self.lower_expr(f));\n                     hir::ExprCall(f, args.iter().map(|x| self.lower_expr(x)).collect())\n                 }\n                 ExprKind::MethodCall(i, ref tps, ref args) => {\n@@ -1083,27 +1083,27 @@ impl<'a> LoweringContext<'a> {\n                 }\n                 ExprKind::Binary(binop, ref lhs, ref rhs) => {\n                     let binop = self.lower_binop(binop);\n-                    let lhs = self.lower_expr(lhs);\n-                    let rhs = self.lower_expr(rhs);\n+                    let lhs = P(self.lower_expr(lhs));\n+                    let rhs = P(self.lower_expr(rhs));\n                     hir::ExprBinary(binop, lhs, rhs)\n                 }\n                 ExprKind::Unary(op, ref ohs) => {\n                     let op = self.lower_unop(op);\n-                    let ohs = self.lower_expr(ohs);\n+                    let ohs = P(self.lower_expr(ohs));\n                     hir::ExprUnary(op, ohs)\n                 }\n                 ExprKind::Lit(ref l) => hir::ExprLit(P((**l).clone())),\n                 ExprKind::Cast(ref expr, ref ty) => {\n-                    let expr = self.lower_expr(expr);\n+                    let expr = P(self.lower_expr(expr));\n                     hir::ExprCast(expr, self.lower_ty(ty))\n                 }\n                 ExprKind::Type(ref expr, ref ty) => {\n-                    let expr = self.lower_expr(expr);\n+                    let expr = P(self.lower_expr(expr));\n                     hir::ExprType(expr, self.lower_ty(ty))\n                 }\n                 ExprKind::AddrOf(m, ref ohs) => {\n                     let m = self.lower_mutability(m);\n-                    let ohs = self.lower_expr(ohs);\n+                    let ohs = P(self.lower_expr(ohs));\n                     hir::ExprAddrOf(m, ohs)\n                 }\n                 // More complicated than you might expect because the else branch\n@@ -1114,7 +1114,7 @@ impl<'a> LoweringContext<'a> {\n                             ExprKind::IfLet(..) => {\n                                 // wrap the if-let expr in a block\n                                 let span = els.span;\n-                                let els = self.lower_expr(els);\n+                                let els = P(self.lower_expr(els));\n                                 let id = self.next_id();\n                                 let blk = P(hir::Block {\n                                     stmts: hir_vec![],\n@@ -1123,57 +1123,57 @@ impl<'a> LoweringContext<'a> {\n                                     rules: hir::DefaultBlock,\n                                     span: span,\n                                 });\n-                                self.expr_block(blk, ThinVec::new())\n+                                P(self.expr_block(blk, ThinVec::new()))\n                             }\n-                            _ => self.lower_expr(els),\n+                            _ => P(self.lower_expr(els)),\n                         }\n                     });\n \n-                    hir::ExprIf(self.lower_expr(cond), self.lower_block(blk), else_opt)\n+                    hir::ExprIf(P(self.lower_expr(cond)), self.lower_block(blk), else_opt)\n                 }\n                 ExprKind::While(ref cond, ref body, opt_ident) => {\n-                    hir::ExprWhile(self.lower_expr(cond), self.lower_block(body),\n+                    hir::ExprWhile(P(self.lower_expr(cond)), self.lower_block(body),\n                                    self.lower_opt_sp_ident(opt_ident))\n                 }\n                 ExprKind::Loop(ref body, opt_ident) => {\n                     hir::ExprLoop(self.lower_block(body), self.lower_opt_sp_ident(opt_ident))\n                 }\n                 ExprKind::Match(ref expr, ref arms) => {\n-                    hir::ExprMatch(self.lower_expr(expr),\n+                    hir::ExprMatch(P(self.lower_expr(expr)),\n                                    arms.iter().map(|x| self.lower_arm(x)).collect(),\n                                    hir::MatchSource::Normal)\n                 }\n                 ExprKind::Closure(capture_clause, ref decl, ref body, fn_decl_span) => {\n                     self.with_parent_def(e.id, |this| {\n                         hir::ExprClosure(this.lower_capture_clause(capture_clause),\n                                          this.lower_fn_decl(decl),\n-                                         this.lower_expr(body),\n+                                         P(this.lower_expr(body)),\n                                          fn_decl_span)\n                     })\n                 }\n                 ExprKind::Block(ref blk) => hir::ExprBlock(self.lower_block(blk)),\n                 ExprKind::Assign(ref el, ref er) => {\n-                    hir::ExprAssign(self.lower_expr(el), self.lower_expr(er))\n+                    hir::ExprAssign(P(self.lower_expr(el)), P(self.lower_expr(er)))\n                 }\n                 ExprKind::AssignOp(op, ref el, ref er) => {\n                     hir::ExprAssignOp(self.lower_binop(op),\n-                                      self.lower_expr(el),\n-                                      self.lower_expr(er))\n+                                      P(self.lower_expr(el)),\n+                                      P(self.lower_expr(er)))\n                 }\n                 ExprKind::Field(ref el, ident) => {\n-                    hir::ExprField(self.lower_expr(el), respan(ident.span, ident.node.name))\n+                    hir::ExprField(P(self.lower_expr(el)), respan(ident.span, ident.node.name))\n                 }\n                 ExprKind::TupField(ref el, ident) => {\n-                    hir::ExprTupField(self.lower_expr(el), ident)\n+                    hir::ExprTupField(P(self.lower_expr(el)), ident)\n                 }\n                 ExprKind::Index(ref el, ref er) => {\n-                    hir::ExprIndex(self.lower_expr(el), self.lower_expr(er))\n+                    hir::ExprIndex(P(self.lower_expr(el)), P(self.lower_expr(er)))\n                 }\n                 ExprKind::Range(ref e1, ref e2, lims) => {\n                     fn make_struct(this: &mut LoweringContext,\n                                    ast_expr: &Expr,\n                                    path: &[&str],\n-                                   fields: &[(&str, &P<Expr>)]) -> P<hir::Expr> {\n+                                   fields: &[(&str, &P<Expr>)]) -> hir::Expr {\n                         let struct_path = this.std_path(ast_expr.span,\n                                                         &iter::once(&\"ops\").chain(path)\n                                                                            .map(|s| *s)\n@@ -1183,12 +1183,12 @@ impl<'a> LoweringContext<'a> {\n                             this.expr_path(struct_path, ast_expr.attrs.clone())\n                         } else {\n                             let fields = fields.into_iter().map(|&(s, e)| {\n-                                let expr = this.lower_expr(&e);\n-                                let signal_block = this.signal_block_expr(hir_vec![],\n-                                                                          expr,\n-                                                                          e.span,\n-                                                                          hir::PopUnstableBlock,\n-                                                                          ThinVec::new());\n+                                let expr = P(this.lower_expr(&e));\n+                                let signal_block = P(this.signal_block_expr(hir_vec![],\n+                                                                            expr,\n+                                                                            e.span,\n+                                                                            hir::PopUnstableBlock,\n+                                                                            ThinVec::new()));\n                                 this.field(Symbol::intern(s), signal_block, ast_expr.span)\n                             }).collect();\n                             let attrs = ast_expr.attrs.clone();\n@@ -1244,7 +1244,7 @@ impl<'a> LoweringContext<'a> {\n                 }\n                 ExprKind::Break(opt_ident) => hir::ExprBreak(self.lower_opt_sp_ident(opt_ident)),\n                 ExprKind::Continue(opt_ident) => hir::ExprAgain(self.lower_opt_sp_ident(opt_ident)),\n-                ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| self.lower_expr(x))),\n+                ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| P(self.lower_expr(x)))),\n                 ExprKind::InlineAsm(ref asm) => {\n                     let hir_asm = hir::InlineAsm {\n                         inputs: asm.inputs.iter().map(|&(ref c, _)| c.clone()).collect(),\n@@ -1272,20 +1272,19 @@ impl<'a> LoweringContext<'a> {\n                 ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n                     hir::ExprStruct(P(self.lower_path(path)),\n                                     fields.iter().map(|x| self.lower_field(x)).collect(),\n-                                    maybe_expr.as_ref().map(|x| self.lower_expr(x)))\n+                                    maybe_expr.as_ref().map(|x| P(self.lower_expr(x))))\n                 }\n                 ExprKind::Paren(ref ex) => {\n-                    return self.lower_expr(ex).map(|mut ex| {\n-                        // include parens in span, but only if it is a super-span.\n-                        if e.span.contains(ex.span) {\n-                            ex.span = e.span;\n-                        }\n-                        // merge attributes into the inner expression.\n-                        let mut attrs = e.attrs.clone();\n-                        attrs.extend::<Vec<_>>(ex.attrs.into());\n-                        ex.attrs = attrs;\n-                        ex\n-                    });\n+                    let mut ex = self.lower_expr(ex);\n+                    // include parens in span, but only if it is a super-span.\n+                    if e.span.contains(ex.span) {\n+                        ex.span = e.span;\n+                    }\n+                    // merge attributes into the inner expression.\n+                    let mut attrs = e.attrs.clone();\n+                    attrs.extend::<Vec<_>>(ex.attrs.into());\n+                    ex.attrs = attrs;\n+                    return ex;\n                 }\n \n                 // Desugar ExprIfLet\n@@ -1302,13 +1301,13 @@ impl<'a> LoweringContext<'a> {\n                     // `<pat> => <body>`\n                     let pat_arm = {\n                         let body = self.lower_block(body);\n-                        let body_expr = self.expr_block(body, ThinVec::new());\n+                        let body_expr = P(self.expr_block(body, ThinVec::new()));\n                         let pat = self.lower_pat(pat);\n                         self.arm(hir_vec![pat], body_expr)\n                     };\n \n                     // `[_ if <else_opt_if_cond> => <else_opt_if_body>,]`\n-                    let mut else_opt = else_opt.as_ref().map(|e| self.lower_expr(e));\n+                    let mut else_opt = else_opt.as_ref().map(|e| P(self.lower_expr(e)));\n                     let else_if_arms = {\n                         let mut arms = vec![];\n                         loop {\n@@ -1322,7 +1321,7 @@ impl<'a> LoweringContext<'a> {\n                                                 attrs: hir_vec![],\n                                                 pats: hir_vec![pat_under],\n                                                 guard: Some(cond),\n-                                                body: self.expr_block(then, ThinVec::new()),\n+                                                body: P(self.expr_block(then, ThinVec::new())),\n                                             });\n                                             else_opt.map(|else_opt| (else_opt, true))\n                                         }\n@@ -1362,7 +1361,7 @@ impl<'a> LoweringContext<'a> {\n                     arms.extend(else_if_arms);\n                     arms.push(else_arm);\n \n-                    let sub_expr = self.lower_expr(sub_expr);\n+                    let sub_expr = P(self.lower_expr(sub_expr));\n                     // add attributes to the outer returned expr node\n                     return self.expr(e.span,\n                                      hir::ExprMatch(sub_expr,\n@@ -1388,7 +1387,7 @@ impl<'a> LoweringContext<'a> {\n                     // `<pat> => <body>`\n                     let pat_arm = {\n                         let body = self.lower_block(body);\n-                        let body_expr = self.expr_block(body, ThinVec::new());\n+                        let body_expr = P(self.expr_block(body, ThinVec::new()));\n                         let pat = self.lower_pat(pat);\n                         self.arm(hir_vec![pat], body_expr)\n                     };\n@@ -1402,19 +1401,19 @@ impl<'a> LoweringContext<'a> {\n \n                     // `match <sub_expr> { ... }`\n                     let arms = hir_vec![pat_arm, break_arm];\n-                    let sub_expr = self.lower_expr(sub_expr);\n+                    let sub_expr = P(self.lower_expr(sub_expr));\n                     let match_expr = self.expr(e.span,\n                                                hir::ExprMatch(sub_expr,\n                                                               arms,\n                                                               hir::MatchSource::WhileLetDesugar),\n                                                ThinVec::new());\n \n                     // `[opt_ident]: loop { ... }`\n-                    let loop_block = self.block_expr(match_expr);\n+                    let loop_block = P(self.block_expr(P(match_expr)));\n                     let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident));\n                     // add attributes to the outer returned expr node\n                     let attrs = e.attrs.clone();\n-                    return P(hir::Expr { id: e.id, node: loop_expr, span: e.span, attrs: attrs });\n+                    return hir::Expr { id: e.id, node: loop_expr, span: e.span, attrs: attrs };\n                 }\n \n                 // Desugar ExprForLoop\n@@ -1471,19 +1470,21 @@ impl<'a> LoweringContext<'a> {\n                     // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n                     let match_expr = {\n                         let next_path = self.std_path(e.span, &[\"iter\", \"Iterator\", \"next\"]);\n-                        let iter = self.expr_ident(e.span, iter, iter_pat.id);\n+                        let iter = P(self.expr_ident(e.span, iter, iter_pat.id));\n                         let ref_mut_iter = self.expr_mut_addr_of(e.span, iter);\n                         let next_path = self.expr_path(next_path, ThinVec::new());\n-                        let next_expr = self.expr_call(e.span, next_path, hir_vec![ref_mut_iter]);\n+                        let next_expr = P(self.expr_call(e.span, next_path,\n+                                          hir_vec![ref_mut_iter]));\n                         let arms = hir_vec![pat_arm, break_arm];\n \n-                        self.expr(e.span,\n-                                  hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar),\n-                                  ThinVec::new())\n+                        P(self.expr(e.span,\n+                                    hir::ExprMatch(next_expr, arms,\n+                                                   hir::MatchSource::ForLoopDesugar),\n+                                    ThinVec::new()))\n                     };\n \n                     // `[opt_ident]: loop { ... }`\n-                    let loop_block = self.block_expr(match_expr);\n+                    let loop_block = P(self.block_expr(match_expr));\n                     let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident));\n                     let loop_expr = P(hir::Expr {\n                         id: e.id,\n@@ -1501,22 +1502,22 @@ impl<'a> LoweringContext<'a> {\n                                                            &[\"iter\", \"IntoIterator\", \"into_iter\"]);\n \n                         let into_iter = self.expr_path(into_iter_path, ThinVec::new());\n-                        self.expr_call(e.span, into_iter, hir_vec![head])\n+                        P(self.expr_call(e.span, into_iter, hir_vec![head]))\n                     };\n \n-                    let match_expr = self.expr_match(e.span,\n-                                                     into_iter_expr,\n-                                                     hir_vec![iter_arm],\n-                                                     hir::MatchSource::ForLoopDesugar);\n+                    let match_expr = P(self.expr_match(e.span,\n+                                                       into_iter_expr,\n+                                                       hir_vec![iter_arm],\n+                                                       hir::MatchSource::ForLoopDesugar));\n \n                     // `{ let _result = ...; _result }`\n                     // underscore prevents an unused_variables lint if the head diverges\n                     let result_ident = self.str_to_ident(\"_result\");\n                     let (let_stmt, let_stmt_binding) =\n                         self.stmt_let(e.span, false, result_ident, match_expr);\n \n-                    let result = self.expr_ident(e.span, result_ident, let_stmt_binding);\n-                    let block = self.block_all(e.span, hir_vec![let_stmt], Some(result));\n+                    let result = P(self.expr_ident(e.span, result_ident, let_stmt_binding));\n+                    let block = P(self.block_all(e.span, hir_vec![let_stmt], Some(result)));\n                     // add the attributes to the outer returned expr node\n                     return self.expr_block(block, e.attrs.clone());\n                 }\n@@ -1536,7 +1537,7 @@ impl<'a> LoweringContext<'a> {\n                     // { Carrier::translate( { <expr> } ) }\n                     let discr = {\n                         // expand <expr>\n-                        let sub_expr = self.lower_expr(sub_expr);\n+                        let sub_expr = P(self.lower_expr(sub_expr));\n                         let sub_expr = self.signal_block_expr(hir_vec![],\n                                                               sub_expr,\n                                                               e.span,\n@@ -1545,20 +1546,20 @@ impl<'a> LoweringContext<'a> {\n \n                         let path = self.std_path(e.span, &[\"ops\", \"Carrier\", \"translate\"]);\n                         let path = self.expr_path(path, ThinVec::new());\n-                        let call = self.expr_call(e.span, path, hir_vec![sub_expr]);\n+                        let call = P(self.expr_call(e.span, path, hir_vec![sub_expr]));\n \n-                        self.signal_block_expr(hir_vec![],\n-                                               call,\n-                                               e.span,\n-                                               hir::PushUnstableBlock,\n-                                               ThinVec::new())\n+                        P(self.signal_block_expr(hir_vec![],\n+                                                 call,\n+                                                 e.span,\n+                                                 hir::PushUnstableBlock,\n+                                                 ThinVec::new()))\n                     };\n \n                     // Ok(val) => val\n                     let ok_arm = {\n                         let val_ident = self.str_to_ident(\"val\");\n                         let val_pat = self.pat_ident(e.span, val_ident);\n-                        let val_expr = self.expr_ident(e.span, val_ident, val_pat.id);\n+                        let val_expr = P(self.expr_ident(e.span, val_ident, val_pat.id));\n                         let ok_pat = self.pat_ok(e.span, val_pat);\n \n                         self.arm(hir_vec![ok_pat], val_expr)\n@@ -1578,15 +1579,16 @@ impl<'a> LoweringContext<'a> {\n                         let from_err_expr = {\n                             let path = self.std_path(e.span, &[\"ops\", \"Carrier\", \"from_error\"]);\n                             let from_err = self.expr_path(path, ThinVec::new());\n-                            self.expr_call(e.span, from_err, hir_vec![from_expr])\n+                            P(self.expr_call(e.span, from_err, hir_vec![from_expr]))\n                         };\n \n-                        let ret_expr = self.expr(e.span,\n-                                                 hir::Expr_::ExprRet(Some(from_err_expr)),\n-                                                                     ThinVec::new());\n+                        let ret_expr = P(self.expr(e.span,\n+                                                   hir::Expr_::ExprRet(Some(from_err_expr)),\n+                                                                       ThinVec::new()));\n                         let ret_stmt = self.stmt_expr(ret_expr);\n-                        let block = self.signal_block_stmt(ret_stmt, e.span,\n-                                                           hir::PushUnstableBlock, ThinVec::new());\n+                        let block = P(self.signal_block_stmt(ret_stmt, e.span,\n+                                                             hir::PushUnstableBlock,\n+                                                             ThinVec::new()));\n \n                         let err_pat = self.pat_err(e.span, err_local);\n                         self.arm(hir_vec![err_pat], block)\n@@ -1600,7 +1602,7 @@ impl<'a> LoweringContext<'a> {\n             },\n             span: e.span,\n             attrs: e.attrs.clone(),\n-        })\n+        }\n     }\n \n     fn lower_stmt(&mut self, s: &Stmt) -> hir::Stmt {\n@@ -1621,13 +1623,13 @@ impl<'a> LoweringContext<'a> {\n             },\n             StmtKind::Expr(ref e) => {\n                 Spanned {\n-                    node: hir::StmtExpr(self.lower_expr(e), s.id),\n+                    node: hir::StmtExpr(P(self.lower_expr(e)), s.id),\n                     span: s.span,\n                 }\n             }\n             StmtKind::Semi(ref e) => {\n                 Spanned {\n-                    node: hir::StmtSemi(self.lower_expr(e), s.id),\n+                    node: hir::StmtSemi(P(self.lower_expr(e)), s.id),\n                     span: s.span,\n                 }\n             }\n@@ -1721,15 +1723,15 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expr_break(&mut self, span: Span, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n-        self.expr(span, hir::ExprBreak(None), attrs)\n+        P(self.expr(span, hir::ExprBreak(None), attrs))\n     }\n \n-    fn expr_call(&mut self, span: Span, e: P<hir::Expr>, args: hir::HirVec<P<hir::Expr>>)\n-                 -> P<hir::Expr> {\n+    fn expr_call(&mut self, span: Span, e: P<hir::Expr>, args: hir::HirVec<hir::Expr>)\n+                 -> hir::Expr {\n         self.expr(span, hir::ExprCall(e, args), ThinVec::new())\n     }\n \n-    fn expr_ident(&mut self, span: Span, id: Name, binding: NodeId) -> P<hir::Expr> {\n+    fn expr_ident(&mut self, span: Span, id: Name, binding: NodeId) -> hir::Expr {\n         let expr_path = hir::ExprPath(None, self.path_ident(span, id));\n         let expr = self.expr(span, expr_path, ThinVec::new());\n \n@@ -1742,13 +1744,13 @@ impl<'a> LoweringContext<'a> {\n         expr\n     }\n \n-    fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>) -> P<hir::Expr> {\n+    fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>) -> hir::Expr {\n         self.expr(span, hir::ExprAddrOf(hir::MutMutable, e), ThinVec::new())\n     }\n \n     fn expr_path(&mut self, path: hir::Path, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         let def = self.resolver.resolve_generated_global_path(&path, true);\n-        let expr = self.expr(path.span, hir::ExprPath(None, path), attrs);\n+        let expr = P(self.expr(path.span, hir::ExprPath(None, path), attrs));\n         self.resolver.record_resolution(expr.id, def);\n         expr\n     }\n@@ -1758,16 +1760,16 @@ impl<'a> LoweringContext<'a> {\n                   arg: P<hir::Expr>,\n                   arms: hir::HirVec<hir::Arm>,\n                   source: hir::MatchSource)\n-                  -> P<hir::Expr> {\n+                  -> hir::Expr {\n         self.expr(span, hir::ExprMatch(arg, arms, source), ThinVec::new())\n     }\n \n-    fn expr_block(&mut self, b: P<hir::Block>, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n+    fn expr_block(&mut self, b: P<hir::Block>, attrs: ThinVec<Attribute>) -> hir::Expr {\n         self.expr(b.span, hir::ExprBlock(b), attrs)\n     }\n \n-    fn expr_tuple(&mut self, sp: Span, exprs: hir::HirVec<P<hir::Expr>>) -> P<hir::Expr> {\n-        self.expr(sp, hir::ExprTup(exprs), ThinVec::new())\n+    fn expr_tuple(&mut self, sp: Span, exprs: hir::HirVec<hir::Expr>) -> P<hir::Expr> {\n+        P(self.expr(sp, hir::ExprTup(exprs), ThinVec::new()))\n     }\n \n     fn expr_struct(&mut self,\n@@ -1777,18 +1779,18 @@ impl<'a> LoweringContext<'a> {\n                    e: Option<P<hir::Expr>>,\n                    attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         let def = self.resolver.resolve_generated_global_path(&path, false);\n-        let expr = self.expr(sp, hir::ExprStruct(P(path), fields, e), attrs);\n+        let expr = P(self.expr(sp, hir::ExprStruct(P(path), fields, e), attrs));\n         self.resolver.record_resolution(expr.id, def);\n         expr\n     }\n \n-    fn expr(&mut self, span: Span, node: hir::Expr_, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n-        P(hir::Expr {\n+    fn expr(&mut self, span: Span, node: hir::Expr_, attrs: ThinVec<Attribute>) -> hir::Expr {\n+        hir::Expr {\n             id: self.next_id(),\n             node: node,\n             span: span,\n             attrs: attrs,\n-        })\n+        }\n     }\n \n     fn stmt_let(&mut self, sp: Span, mutbl: bool, ident: Name, ex: P<hir::Expr>)\n@@ -1820,19 +1822,19 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn block_expr(&mut self, expr: P<hir::Expr>) -> P<hir::Block> {\n+    fn block_expr(&mut self, expr: P<hir::Expr>) -> hir::Block {\n         self.block_all(expr.span, hir::HirVec::new(), Some(expr))\n     }\n \n     fn block_all(&mut self, span: Span, stmts: hir::HirVec<hir::Stmt>, expr: Option<P<hir::Expr>>)\n-                 -> P<hir::Block> {\n-        P(hir::Block {\n+                 -> hir::Block {\n+        hir::Block {\n             stmts: stmts,\n             expr: expr,\n             id: self.next_id(),\n             rules: hir::DefaultBlock,\n             span: span,\n-        })\n+        }\n     }\n \n     fn pat_ok(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n@@ -1972,7 +1974,7 @@ impl<'a> LoweringContext<'a> {\n                          span: Span,\n                          rule: hir::BlockCheckMode,\n                          attrs: ThinVec<Attribute>)\n-                         -> P<hir::Expr> {\n+                         -> hir::Expr {\n         let id = self.next_id();\n         let block = P(hir::Block {\n             rules: rule,\n@@ -1989,7 +1991,7 @@ impl<'a> LoweringContext<'a> {\n                          span: Span,\n                          rule: hir::BlockCheckMode,\n                          attrs: ThinVec<Attribute>)\n-                         -> P<hir::Expr> {\n+                         -> hir::Expr {\n         let id = self.next_id();\n         let block = P(hir::Block {\n             rules: rule,"}, {"sha": "28ea14437247acada6bafd2ddc9a1848794937ec", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/382d3b043e7eef39f5948bb07dc8df9159dd597c/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382d3b043e7eef39f5948bb07dc8df9159dd597c/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=382d3b043e7eef39f5948bb07dc8df9159dd597c", "patch": "@@ -867,12 +867,12 @@ pub enum Expr_ {\n     /// A `box x` expression.\n     ExprBox(P<Expr>),\n     /// An array (`[a, b, c, d]`)\n-    ExprArray(HirVec<P<Expr>>),\n+    ExprArray(HirVec<Expr>),\n     /// A function call\n     ///\n     /// The first field resolves to the function itself (usually an `ExprPath`),\n     /// and the second field is the list of arguments\n-    ExprCall(P<Expr>, HirVec<P<Expr>>),\n+    ExprCall(P<Expr>, HirVec<Expr>),\n     /// A method call (`x.foo::<Bar, Baz>(a, b, c, d)`)\n     ///\n     /// The `Spanned<Name>` is the identifier for the method name.\n@@ -885,9 +885,9 @@ pub enum Expr_ {\n     ///\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n     /// `ExprMethodCall(foo, [Bar, Baz], [x, a, b, c, d])`.\n-    ExprMethodCall(Spanned<Name>, HirVec<P<Ty>>, HirVec<P<Expr>>),\n+    ExprMethodCall(Spanned<Name>, HirVec<P<Ty>>, HirVec<Expr>),\n     /// A tuple (`(a, b, c ,d)`)\n-    ExprTup(HirVec<P<Expr>>),\n+    ExprTup(HirVec<Expr>),\n     /// A binary operation (For example: `a + b`, `a * b`)\n     ExprBinary(BinOp, P<Expr>, P<Expr>),\n     /// A unary operation (For example: `!x`, `*x`)\n@@ -951,7 +951,7 @@ pub enum Expr_ {\n     ExprRet(Option<P<Expr>>),\n \n     /// Inline assembly (from `asm!`), with its outputs and inputs.\n-    ExprInlineAsm(P<InlineAsm>, HirVec<P<Expr>>, HirVec<P<Expr>>),\n+    ExprInlineAsm(P<InlineAsm>, HirVec<Expr>, HirVec<Expr>),\n \n     /// A struct or struct-like variant literal expression.\n     ///"}, {"sha": "9eb79e38d6f7754566a28552b9f6c7ac6a968123", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/382d3b043e7eef39f5948bb07dc8df9159dd597c/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382d3b043e7eef39f5948bb07dc8df9159dd597c/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=382d3b043e7eef39f5948bb07dc8df9159dd597c", "patch": "@@ -452,7 +452,7 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    pub fn commasep_exprs(&mut self, b: Breaks, exprs: &[P<hir::Expr>]) -> io::Result<()> {\n+    pub fn commasep_exprs(&mut self, b: Breaks, exprs: &[hir::Expr]) -> io::Result<()> {\n         self.commasep_cmnt(b, exprs, |s, e| s.print_expr(&e), |e| e.span)\n     }\n \n@@ -1200,7 +1200,7 @@ impl<'a> State<'a> {\n     }\n \n \n-    fn print_call_post(&mut self, args: &[P<hir::Expr>]) -> io::Result<()> {\n+    fn print_call_post(&mut self, args: &[hir::Expr]) -> io::Result<()> {\n         self.popen()?;\n         self.commasep_exprs(Inconsistent, args)?;\n         self.pclose()\n@@ -1218,10 +1218,10 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    fn print_expr_vec(&mut self, exprs: &[P<hir::Expr>]) -> io::Result<()> {\n+    fn print_expr_vec(&mut self, exprs: &[hir::Expr]) -> io::Result<()> {\n         self.ibox(indent_unit)?;\n         word(&mut self.s, \"[\")?;\n-        self.commasep_exprs(Inconsistent, &exprs[..])?;\n+        self.commasep_exprs(Inconsistent, exprs)?;\n         word(&mut self.s, \"]\")?;\n         self.end()\n     }\n@@ -1274,24 +1274,24 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    fn print_expr_tup(&mut self, exprs: &[P<hir::Expr>]) -> io::Result<()> {\n+    fn print_expr_tup(&mut self, exprs: &[hir::Expr]) -> io::Result<()> {\n         self.popen()?;\n-        self.commasep_exprs(Inconsistent, &exprs[..])?;\n+        self.commasep_exprs(Inconsistent, exprs)?;\n         if exprs.len() == 1 {\n             word(&mut self.s, \",\")?;\n         }\n         self.pclose()\n     }\n \n-    fn print_expr_call(&mut self, func: &hir::Expr, args: &[P<hir::Expr>]) -> io::Result<()> {\n+    fn print_expr_call(&mut self, func: &hir::Expr, args: &[hir::Expr]) -> io::Result<()> {\n         self.print_expr_maybe_paren(func)?;\n         self.print_call_post(args)\n     }\n \n     fn print_expr_method_call(&mut self,\n                               name: Spanned<ast::Name>,\n                               tys: &[P<hir::Ty>],\n-                              args: &[P<hir::Expr>])\n+                              args: &[hir::Expr])\n                               -> io::Result<()> {\n         let base_args = &args[1..];\n         self.print_expr(&args[0])?;\n@@ -1340,7 +1340,7 @@ impl<'a> State<'a> {\n                 self.print_expr(expr)?;\n             }\n             hir::ExprArray(ref exprs) => {\n-                self.print_expr_vec(&exprs[..])?;\n+                self.print_expr_vec(exprs)?;\n             }\n             hir::ExprRepeat(ref element, ref count) => {\n                 self.print_expr_repeat(&element, &count)?;\n@@ -1349,13 +1349,13 @@ impl<'a> State<'a> {\n                 self.print_expr_struct(path, &fields[..], wth)?;\n             }\n             hir::ExprTup(ref exprs) => {\n-                self.print_expr_tup(&exprs[..])?;\n+                self.print_expr_tup(exprs)?;\n             }\n             hir::ExprCall(ref func, ref args) => {\n-                self.print_expr_call(&func, &args[..])?;\n+                self.print_expr_call(&func, args)?;\n             }\n             hir::ExprMethodCall(name, ref tys, ref args) => {\n-                self.print_expr_method_call(name, &tys[..], &args[..])?;\n+                self.print_expr_method_call(name, &tys[..], args)?;\n             }\n             hir::ExprBinary(op, ref lhs, ref rhs) => {\n                 self.print_expr_binary(op, &lhs, &rhs)?;"}, {"sha": "aafb38853b37322dce3d0c2a2f27f5469f204979", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/382d3b043e7eef39f5948bb07dc8df9159dd597c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382d3b043e7eef39f5948bb07dc8df9159dd597c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=382d3b043e7eef39f5948bb07dc8df9159dd597c", "patch": "@@ -327,7 +327,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n \n-    fn consume_exprs(&mut self, exprs: &[P<hir::Expr>]) {\n+    fn consume_exprs(&mut self, exprs: &[hir::Expr]) {\n         for expr in exprs {\n             self.consume_expr(&expr);\n         }"}, {"sha": "582c64b6e6836db7fdf7637c89aacce2c634b04b", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/382d3b043e7eef39f5948bb07dc8df9159dd597c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382d3b043e7eef39f5948bb07dc8df9159dd597c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=382d3b043e7eef39f5948bb07dc8df9159dd597c", "patch": "@@ -123,7 +123,6 @@ use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n use syntax::ast::{self, NodeId};\n-use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n@@ -902,7 +901,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.define_bindings_in_pat(&local.pat, succ)\n     }\n \n-    fn propagate_through_exprs(&mut self, exprs: &[P<Expr>], succ: LiveNode)\n+    fn propagate_through_exprs(&mut self, exprs: &[Expr], succ: LiveNode)\n                                -> LiveNode {\n         exprs.iter().rev().fold(succ, |succ, expr| {\n             self.propagate_through_expr(&expr, succ)\n@@ -1087,7 +1086,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           // Uninteresting cases: just propagate in rev exec order\n \n           hir::ExprArray(ref exprs) => {\n-            self.propagate_through_exprs(&exprs[..], succ)\n+            self.propagate_through_exprs(exprs, succ)\n           }\n \n           hir::ExprRepeat(ref element, ref count) => {\n@@ -1111,7 +1110,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             } else {\n                 succ\n             };\n-            let succ = self.propagate_through_exprs(&args[..], succ);\n+            let succ = self.propagate_through_exprs(args, succ);\n             self.propagate_through_expr(&f, succ)\n           }\n \n@@ -1124,11 +1123,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             } else {\n                 succ\n             };\n-            self.propagate_through_exprs(&args[..], succ)\n+            self.propagate_through_exprs(args, succ)\n           }\n \n           hir::ExprTup(ref exprs) => {\n-            self.propagate_through_exprs(&exprs[..], succ)\n+            self.propagate_through_exprs(exprs, succ)\n           }\n \n           hir::ExprBinary(op, ref l, ref r) if op.node.is_lazy() => {"}, {"sha": "b594fe9853a43ac35a2b5bf8ca247300fd18fdde", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/382d3b043e7eef39f5948bb07dc8df9159dd597c/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382d3b043e7eef39f5948bb07dc8df9159dd597c/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=382d3b043e7eef39f5948bb07dc8df9159dd597c", "patch": "@@ -297,7 +297,7 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 _ => bug!()\n             };\n             let pats = args.iter()\n-                           .map(|expr| const_expr_to_pat(tcx, &**expr, pat_id, span))\n+                           .map(|expr| const_expr_to_pat(tcx, &*expr, pat_id, span))\n                            .collect::<Result<_, _>>()?;\n             PatKind::TupleStruct(path, pats, None)\n         }"}, {"sha": "3ffbbd1be80160acae8a304f4972be13661faba2", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/382d3b043e7eef39f5948bb07dc8df9159dd597c/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382d3b043e7eef39f5948bb07dc8df9159dd597c/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=382d3b043e7eef39f5948bb07dc8df9159dd597c", "patch": "@@ -17,7 +17,6 @@ use hir::print;\n use rustc::{infer, traits};\n use rustc::ty::{self, LvaluePreference, Ty};\n use syntax::symbol::Symbol;\n-use syntax::ptr::P;\n use syntax_pos::Span;\n \n use rustc::hir;\n@@ -46,7 +45,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_call(&self,\n                       call_expr: &'gcx hir::Expr,\n                       callee_expr: &'gcx hir::Expr,\n-                      arg_exprs: &'gcx [P<hir::Expr>],\n+                      arg_exprs: &'gcx [hir::Expr],\n                       expected: Expectation<'tcx>)\n                       -> Ty<'tcx> {\n         let original_callee_ty = self.check_expr(callee_expr);\n@@ -189,7 +188,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn confirm_builtin_call(&self,\n                             call_expr: &hir::Expr,\n                             callee_ty: Ty<'tcx>,\n-                            arg_exprs: &'gcx [P<hir::Expr>],\n+                            arg_exprs: &'gcx [hir::Expr],\n                             expected: Expectation<'tcx>)\n                             -> Ty<'tcx> {\n         let error_fn_sig;\n@@ -272,7 +271,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn confirm_deferred_closure_call(&self,\n                                      call_expr: &hir::Expr,\n-                                     arg_exprs: &'gcx [P<hir::Expr>],\n+                                     arg_exprs: &'gcx [hir::Expr],\n                                      expected: Expectation<'tcx>,\n                                      fn_sig: ty::FnSig<'tcx>)\n                                      -> Ty<'tcx> {\n@@ -299,7 +298,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn confirm_overloaded_call(&self,\n                                call_expr: &hir::Expr,\n                                callee_expr: &'gcx hir::Expr,\n-                               arg_exprs: &'gcx [P<hir::Expr>],\n+                               arg_exprs: &'gcx [hir::Expr],\n                                expected: Expectation<'tcx>,\n                                method_callee: ty::MethodCallee<'tcx>)\n                                -> Ty<'tcx> {"}, {"sha": "bb6b2a3116ba39507755bd73a6d37b07d82d788c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/382d3b043e7eef39f5948bb07dc8df9159dd597c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382d3b043e7eef39f5948bb07dc8df9159dd597c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=382d3b043e7eef39f5948bb07dc8df9159dd597c", "patch": "@@ -2409,7 +2409,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                    sp: Span,\n                                    method_fn_ty: Ty<'tcx>,\n                                    callee_expr: &'gcx hir::Expr,\n-                                   args_no_rcvr: &'gcx [P<hir::Expr>],\n+                                   args_no_rcvr: &'gcx [hir::Expr],\n                                    tuple_arguments: TupleArgumentsFlag,\n                                    expected: Expectation<'tcx>)\n                                    -> Ty<'tcx> {\n@@ -2448,7 +2448,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             sp: Span,\n                             fn_inputs: &[Ty<'tcx>],\n                             expected_arg_tys: &[Ty<'tcx>],\n-                            args: &'gcx [P<hir::Expr>],\n+                            args: &'gcx [hir::Expr],\n                             variadic: bool,\n                             tuple_arguments: TupleArgumentsFlag) {\n         let tcx = self.tcx;\n@@ -2822,7 +2822,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_method_call(&self,\n                          expr: &'gcx hir::Expr,\n                          method_name: Spanned<ast::Name>,\n-                         args: &'gcx [P<hir::Expr>],\n+                         args: &'gcx [hir::Expr],\n                          tps: &[P<hir::Ty>],\n                          expected: Expectation<'tcx>,\n                          lvalue_pref: LvaluePreference) -> Ty<'tcx> {\n@@ -3670,10 +3670,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.check_block_with_expected(&b, expected)\n           }\n           hir::ExprCall(ref callee, ref args) => {\n-              self.check_call(expr, &callee, &args[..], expected)\n+              self.check_call(expr, &callee, args, expected)\n           }\n           hir::ExprMethodCall(name, ref tps, ref args) => {\n-              self.check_method_call(expr, name, &args[..], &tps[..], expected, lvalue_pref)\n+              self.check_method_call(expr, name, args, &tps[..], expected, lvalue_pref)\n           }\n           hir::ExprCast(ref e, ref t) => {\n             if let hir::TyArray(_, ref count_expr) = t.node {\n@@ -3728,7 +3728,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let result = if i == 0 {\n                     self.try_coerce(e, e_ty, coerce_to)\n                 } else {\n-                    let prev_elems = || args[..i].iter().map(|e| &**e);\n+                    let prev_elems = || args[..i].iter().map(|e| &*e);\n                     self.try_find_coercion_lub(&cause, prev_elems, unified, e, e_ty)\n                 };\n "}, {"sha": "0cd481baef11b636db521ab7cc7f25b512ab34ad", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/382d3b043e7eef39f5948bb07dc8df9159dd597c/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382d3b043e7eef39f5948bb07dc8df9159dd597c/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=382d3b043e7eef39f5948bb07dc8df9159dd597c", "patch": "@@ -613,19 +613,19 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n             hir::ExprCall(ref callee, ref args) => {\n                 if has_method_map {\n                     self.constrain_call(expr, Some(&callee),\n-                                        args.iter().map(|e| &**e), false);\n+                                        args.iter().map(|e| &*e), false);\n                 } else {\n                     self.constrain_callee(callee.id, expr, &callee);\n                     self.constrain_call(expr, None,\n-                                        args.iter().map(|e| &**e), false);\n+                                        args.iter().map(|e| &*e), false);\n                 }\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n             hir::ExprMethodCall(.., ref args) => {\n                 self.constrain_call(expr, Some(&args[0]),\n-                                    args[1..].iter().map(|e| &**e), false);\n+                                    args[1..].iter().map(|e| &*e), false);\n \n                 intravisit::walk_expr(self, expr);\n             }"}]}