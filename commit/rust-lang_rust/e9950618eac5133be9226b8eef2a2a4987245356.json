{"sha": "e9950618eac5133be9226b8eef2a2a4987245356", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5OTUwNjE4ZWFjNTEzM2JlOTIyNmI4ZWVmMmEyYTQ5ODcyNDUzNTY=", "commit": {"author": {"name": "Felix Rath", "email": "felixr@archlinux.info", "date": "2016-08-06T13:07:16Z"}, "committer": {"name": "Felix Rath", "email": "felixr@archlinux.info", "date": "2016-08-07T11:40:04Z"}, "message": "save an Instant for the timeout instead of a Duration\n\nrequires less bookkeeping. also move some functionality into functions,\nto keep the loop cleaner.", "tree": {"sha": "0496e4387171e4300caf376e68482052d336df5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0496e4387171e4300caf376e68482052d336df5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9950618eac5133be9226b8eef2a2a4987245356", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9950618eac5133be9226b8eef2a2a4987245356", "html_url": "https://github.com/rust-lang/rust/commit/e9950618eac5133be9226b8eef2a2a4987245356", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9950618eac5133be9226b8eef2a2a4987245356/comments", "author": null, "committer": null, "parents": [{"sha": "9006913bf5c1ecfebbffd5c3417bd26c3d6c4aeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/9006913bf5c1ecfebbffd5c3417bd26c3d6c4aeb", "html_url": "https://github.com/rust-lang/rust/commit/9006913bf5c1ecfebbffd5c3417bd26c3d6c4aeb"}], "stats": {"total": 59, "additions": 35, "deletions": 24}, "files": [{"sha": "64515b900d5b188e5b364319ecdd2d40ebd2ce90", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 35, "deletions": 24, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e9950618eac5133be9226b8eef2a2a4987245356/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9950618eac5133be9226b8eef2a2a4987245356/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=e9950618eac5133be9226b8eef2a2a4987245356", "patch": "@@ -596,7 +596,9 @@ impl<T: Write> ConsoleTestState<T> {\n     }\n \n     pub fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n-        self.write_plain(&format!(\"test {} has been running for over {} seconds\\n\", desc.name, TEST_WARN_TIMEOUT_S))\n+        self.write_plain(&format!(\"test {} has been running for over {} seconds\\n\",\n+                                  desc.name,\n+                                  TEST_WARN_TIMEOUT_S))\n     }\n \n     pub fn write_log(&mut self, test: &TestDesc, result: &TestResult) -> io::Result<()> {\n@@ -879,7 +881,28 @@ fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F) ->\n \n     let (tx, rx) = channel::<MonitorMsg>();\n \n-    let mut running_tests: HashMap<TestDesc, Duration> = HashMap::new();\n+    let mut running_tests: HashMap<TestDesc, Instant> = HashMap::new();\n+\n+    fn get_timed_out_tests(running_tests: &mut HashMap<TestDesc, Instant>) -> Vec<TestDesc> {\n+        let now = Instant::now();\n+        let timed_out = running_tests.iter()\n+            .filter_map(|(desc, timeout)| if &now >= timeout { Some(desc.clone())} else { None })\n+            .collect();\n+        for test in &timed_out {\n+            running_tests.remove(test);\n+        }\n+        timed_out\n+    };\n+\n+    fn calc_timeout(running_tests: &HashMap<TestDesc, Instant>) -> Option<Duration> {\n+        running_tests.values().min().map(|next_timeout| {\n+            let now = Instant::now();\n+            if *next_timeout >= now {\n+                *next_timeout - now\n+            } else {\n+                Duration::new(0, 0)\n+            }})\n+    };\n \n     while pending > 0 || !remaining.is_empty() {\n         while pending < concurrency && !remaining.is_empty() {\n@@ -890,38 +913,26 @@ fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F) ->\n                 // that hang forever.\n                 callback(TeWait(test.desc.clone(), test.testfn.padding()))?;\n             }\n-            running_tests.insert(test.desc.clone(), Duration::from_secs(TEST_WARN_TIMEOUT_S));\n+            let timeout = Instant::now() + Duration::from_secs(TEST_WARN_TIMEOUT_S);\n+            running_tests.insert(test.desc.clone(), timeout);\n             run_test(opts, !opts.run_tests, test, tx.clone());\n             pending += 1;\n         }\n \n         let mut res;\n-        if let Some(min_timeout) = running_tests.values().min().cloned() {\n-            loop {\n-                let before = Instant::now();\n-                res = rx.recv_timeout(min_timeout);\n-                let elapsed = Instant::now() - before;\n-\n-                let mut to_remove = Vec::new();\n-                for (desc, time_left) in &mut running_tests {\n-                    if *time_left >= elapsed {\n-                        *time_left -= elapsed;\n-                    } else {\n-                        to_remove.push(desc.clone());\n-                        callback(TeTimeout(desc.clone()))?;\n-                    }\n-                }\n-\n-                for rem in to_remove {\n-                    running_tests.remove(&rem);\n+        loop {\n+            if let Some(timeout) = calc_timeout(&running_tests) {\n+                res = rx.recv_timeout(timeout);\n+                for test in get_timed_out_tests(&mut running_tests) {\n+                    callback(TeTimeout(test))?;\n                 }\n-\n                 if res != Err(RecvTimeoutError::Timeout) {\n                     break;\n                 }\n+            } else {\n+                res = rx.recv().map_err(|_| RecvTimeoutError::Disconnected);\n+                break;\n             }\n-        } else {\n-            res = rx.recv().map_err(|_| RecvTimeoutError::Disconnected);\n         }\n \n         let (desc, result, stdout) = res.unwrap();"}]}