{"sha": "ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlNzUwYTdkYmNkMmRjNjhkYjZkZTg5OTU2YjFkZTNlY2Y5ZjJkMGE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-10T07:49:59Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-13T18:30:45Z"}, "message": "Box AST idents", "tree": {"sha": "55c2ee5be0986c2489879022d4788d6c3ac2c964", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55c2ee5be0986c2489879022d4788d6c3ac2c964"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "html_url": "https://github.com/rust-lang/rust/commit/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdd20000665a35e14b4ec2c54f893fc80fe451ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdd20000665a35e14b4ec2c54f893fc80fe451ef", "html_url": "https://github.com/rust-lang/rust/commit/bdd20000665a35e14b4ec2c54f893fc80fe451ef"}], "stats": {"total": 1232, "additions": 629, "deletions": 603}, "files": [{"sha": "0174af3f500d8137c96330a0c18d6d9560fc6122", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -224,10 +224,10 @@ fn load_link(mis: [@ast::meta_item]) -> (option<str>,\n     for mis.each {|a|\n         alt a.node {\n             ast::meta_name_value(v, {node: ast::lit_str(s), span: _}) {\n-                alt v {\n-                    \"name\" { name = some(s); }\n-                    \"vers\" { vers = some(s); }\n-                    \"uuid\" { uuid = some(s); }\n+                alt *v {\n+                    \"name\" { name = some(*s); }\n+                    \"vers\" { vers = some(*s); }\n+                    \"uuid\" { uuid = some(*s); }\n                     _ { }\n                 }\n             }\n@@ -259,15 +259,15 @@ fn load_crate(filename: str) -> option<crate> {\n     for c.node.attrs.each {|a|\n         alt a.node.value.node {\n             ast::meta_name_value(v, {node: ast::lit_str(s), span: _}) {\n-                alt v {\n-                    \"desc\" { desc = some(v); }\n-                    \"sigs\" { sigs = some(v); }\n-                    \"crate_type\" { crate_type = some(v); }\n+                alt *v {\n+                    \"desc\" { desc = some(*v); }\n+                    \"sigs\" { sigs = some(*v); }\n+                    \"crate_type\" { crate_type = some(*v); }\n                     _ { }\n                 }\n             }\n             ast::meta_list(v, mis) {\n-                if v == \"link\" {\n+                if *v == \"link\" {\n                     let (n, v, u) = load_link(mis);\n                     name = n;\n                     vers = v;\n@@ -290,7 +290,7 @@ fn load_crate(filename: str) -> option<crate> {\n             ast::view_item_use(ident, metas, id) {\n                 let name_items = attr::find_meta_items_by_name(metas, \"name\");\n                 let m = if name_items.is_empty() {\n-                    metas + [attr::mk_name_value_item_str(\"name\", ident)]\n+                    metas + [attr::mk_name_value_item_str(@\"name\", *ident)]\n                 } else {\n                     metas\n                 };\n@@ -303,9 +303,9 @@ fn load_crate(filename: str) -> option<crate> {\n                         some(value) {\n                             let name = attr::get_meta_item_name(item);\n \n-                            alt name {\n-                                \"vers\" { attr_vers = value; }\n-                                \"from\" { attr_from = value; }\n+                            alt *name {\n+                                \"vers\" { attr_vers = *value; }\n+                                \"from\" { attr_from = *value; }\n                                 _ {}\n                             }\n                         }\n@@ -317,11 +317,11 @@ fn load_crate(filename: str) -> option<crate> {\n                     attr_from\n                 } else {\n                     if !str::is_empty(attr_vers) {\n-                        attr_name + \"@\" + attr_vers\n-                    } else { attr_name }\n+                        *attr_name + \"@\" + attr_vers\n+                    } else { *attr_name }\n                 };\n \n-                alt attr_name {\n+                alt *attr_name {\n                     \"std\" | \"core\" { }\n                     _ { e.deps += [query]; }\n                 }"}, {"sha": "efef3233685a593b2f53bd4aab43ce81cec23dcf", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -45,7 +45,7 @@ fn common_exprs() -> [ast::expr] {\n      dse(ast::expr_cont),\n      dse(ast::expr_fail(option::none)),\n      dse(ast::expr_fail(option::some(\n-         @dse(ast::expr_lit(@dsl(ast::lit_str(\"boo\"))))))),\n+         @dse(ast::expr_lit(@dsl(ast::lit_str(@\"boo\"))))))),\n      dse(ast::expr_ret(option::none)),\n      dse(ast::expr_lit(@dsl(ast::lit_nil))),\n      dse(ast::expr_lit(@dsl(ast::lit_bool(false)))),"}, {"sha": "bfa1fb4a7b6ddfa4d63401654e55ae9bd82e98f2", "filename": "src/libstd/map.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -2,6 +2,7 @@\n \n import chained::hashmap;\n export hashmap, hashfn, eqfn, set, map, chained, hashmap, str_hash;\n+export box_str_hash;\n export bytes_hash, int_hash, uint_hash, set_add;\n export hash_from_vec, hash_from_strs, hash_from_bytes;\n export hash_from_ints, hash_from_uints;\n@@ -292,6 +293,11 @@ fn str_hash<V: copy>() -> hashmap<str, V> {\n     ret hashmap(str::hash, str::eq);\n }\n \n+#[doc = \"Construct a hashmap for boxed string keys\"]\n+fn box_str_hash<V: copy>() -> hashmap<@str, V> {\n+    ret hashmap({|x: @str|str::hash(*x)}, {|x,y|str::eq(*x,*y)});\n+}\n+\n #[doc = \"Construct a hashmap for byte string keys\"]\n fn bytes_hash<V: copy>() -> hashmap<[u8], V> {\n     ret hashmap(vec::u8::hash, vec::u8::eq);"}, {"sha": "5381a9f345d232892953bafeb9df8cf6212242ab", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -30,7 +30,7 @@ fn deserialize_span<D>(_d: D) -> span {\n type spanned<T> = {node: T, span: span};\n \n #[auto_serialize]\n-type ident = str;\n+type ident = @str;\n \n // Functions may or may not have names.\n #[auto_serialize]\n@@ -399,11 +399,11 @@ type lit = spanned<lit_>;\n \n #[auto_serialize]\n enum lit_ {\n-    lit_str(str),\n+    lit_str(@str),\n     lit_int(i64, int_ty),\n     lit_uint(u64, uint_ty),\n     lit_int_unsuffixed(i64, int_ty),\n-    lit_float(str, float_ty),\n+    lit_float(@str, float_ty),\n     lit_nil,\n     lit_bool(bool),\n }"}, {"sha": "98a3a8e7bccabbd47bbda5a8b8f8ea2688d2bd54", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -6,24 +6,24 @@ import ast_util::path_to_ident;\n import ast_util::inlined_item_methods;\n import diagnostic::span_handler;\n \n-enum path_elt { path_mod(str), path_name(str) }\n+enum path_elt { path_mod(ident), path_name(ident) }\n type path = [path_elt];\n \n fn path_to_str_with_sep(p: path, sep: str) -> str {\n     let strs = vec::map(p) {|e|\n         alt e {\n-          path_mod(s) { /* FIXME: bad */ copy s }\n-          path_name(s) { /* FIXME: bad */ copy s }\n+          path_mod(s) { /* FIXME: bad */ copy *s }\n+          path_name(s) { /* FIXME: bad */ copy *s }\n         }\n     };\n     str::connect(strs, sep)\n }\n \n fn path_ident_to_str(p: path, i: ident) -> str {\n     if vec::is_empty(p) {\n-        /* FIXME: bad */ copy i\n+        /* FIXME: bad */ copy *i\n     } else {\n-        #fmt[\"%s::%s\", path_to_str(p), i]\n+        #fmt[\"%s::%s\", path_to_str(p), *i]\n     }\n }\n \n@@ -59,7 +59,7 @@ type ctx = {map: map, mut path: path,\n             mut local_id: uint, diag: span_handler};\n type vt = visit::vt<ctx>;\n \n-fn extend(cx: ctx, +elt: str) -> @path {\n+fn extend(cx: ctx, +elt: ident) -> @path {\n     @(cx.path + [path_name(elt)])\n }\n \n@@ -192,7 +192,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n       item_impl(_, _, _, _, ms) {\n         let impl_did = ast_util::local_def(i.id);\n         for ms.each {|m|\n-            map_method(impl_did, extend(cx, /* FIXME: bad */ copy i.ident), m,\n+            map_method(impl_did, extend(cx, i.ident), m,\n                        cx);\n         }\n       }\n@@ -208,7 +208,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n         for vs.each {|v|\n             cx.map.insert(v.node.id, node_variant(\n                 /* FIXME: bad */ copy v, i,\n-                extend(cx, /* FIXME: bad */ copy i.ident)));\n+                extend(cx, i.ident)));\n         }\n       }\n       item_native_mod(nm) {\n@@ -229,17 +229,17 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n           vec::iter(ifces) {|p| cx.map.insert(p.id,\n                                   node_item(i, item_path)); };\n           let d_id = ast_util::local_def(i.id);\n-          let p = extend(cx, /* FIXME: bad */ copy i.ident);\n+          let p = extend(cx, i.ident);\n            // only need to handle methods\n           vec::iter(ms) {|m| map_method(d_id, p, m, cx); }\n       }\n       _ { }\n     }\n     alt i.node {\n       item_mod(_) | item_native_mod(_) {\n-        cx.path += [path_mod(/* FIXME: bad */ copy i.ident)];\n+        cx.path += [path_mod(i.ident)];\n       }\n-      _ { cx.path += [path_name(/* FIXME: bad */ copy i.ident)]; }\n+      _ { cx.path += [path_name(i.ident)]; }\n     }\n     visit::visit_item(i, cx, v);\n     vec::pop(cx.path);\n@@ -281,11 +281,11 @@ fn node_id_to_str(map: map, id: node_id) -> str {\n       }\n       some(node_method(m, impl_did, path)) {\n         #fmt[\"method %s in %s (id=%?)\",\n-             m.ident, path_to_str(*path), id]\n+             *m.ident, path_to_str(*path), id]\n       }\n       some(node_variant(variant, def_id, path)) {\n         #fmt[\"variant %s in %s (id=%?)\",\n-             variant.node.name, path_to_str(*path), id]\n+             *variant.node.name, path_to_str(*path), id]\n       }\n       some(node_expr(expr)) {\n         #fmt[\"expr %s (id=%?)\","}, {"sha": "d4efdb4bb0d01a5797909b49e6bd3803aec6d02e", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -23,7 +23,10 @@ pure fn dummy_sp() -> span { ret mk_sp(0u, 0u); }\n \n pure fn path_name(p: @path) -> str { path_name_i(p.idents) }\n \n-pure fn path_name_i(idents: [ident]) -> str { str::connect(idents, \"::\") }\n+pure fn path_name_i(idents: [ident]) -> str {\n+    // FIXME: Bad copies\n+    str::connect(idents.map({|i|*i}), \"::\")\n+}\n \n pure fn path_to_ident(p: @path) -> ident { vec::last(p.idents) }\n \n@@ -380,7 +383,7 @@ fn dtor_dec() -> fn_decl {\n     let nil_t = @{id: 0, node: ty_nil, span: dummy_sp()};\n     // dtor has one argument, of type ()\n     {inputs: [{mode: ast::expl(ast::by_ref),\n-               ty: nil_t, ident: \"_\", id: 0}],\n+               ty: nil_t, ident: @\"_\", id: 0}],\n      output: nil_t, purity: impure_fn, cf: return_val, constraints: []}\n }\n "}, {"sha": "9138fed69c8b03aa06ba9e5bdc0487a186352fba", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -47,7 +47,7 @@ export require_unique_names;\n /* Constructors */\n \n fn mk_name_value_item_str(+name: ast::ident, +value: str) -> @ast::meta_item {\n-    let value_lit = dummy_spanned(ast::lit_str(value));\n+    let value_lit = dummy_spanned(ast::lit_str(@value));\n     ret mk_name_value_item(name, value_lit);\n }\n \n@@ -100,12 +100,12 @@ fn get_meta_item_name(meta: @ast::meta_item) -> ast::ident {\n Gets the string value if the meta_item is a meta_name_value variant\n containing a string, otherwise none\n \"]\n-fn get_meta_item_value_str(meta: @ast::meta_item) -> option<str> {\n+fn get_meta_item_value_str(meta: @ast::meta_item) -> option<@str> {\n     alt meta.node {\n       ast::meta_name_value(_, v) {\n         alt v.node {\n             ast::lit_str(s) {\n-                option::some(/* FIXME bad */ copy s)\n+                option::some(s)\n             }\n             _ {\n                 option::none\n@@ -130,11 +130,11 @@ a tuple containing the name and string value, otherwise `none`\n \"]\n fn get_name_value_str_pair(\n     item: @ast::meta_item\n-) -> option<(str, str)> {\n+) -> option<(ast::ident, @str)> {\n     alt attr::get_meta_item_value_str(item) {\n       some(value) {\n         let name = attr::get_meta_item_name(item);\n-        some((name, /* FIXME bad */ copy value))\n+        some((name, value))\n       }\n       none { none }\n     }\n@@ -146,11 +146,11 @@ fn get_name_value_str_pair(\n #[doc = \"\n Search a list of attributes and return only those with a specific name\n \"]\n-fn find_attrs_by_name(attrs: [ast::attribute], +name: ast::ident) ->\n+fn find_attrs_by_name(attrs: [ast::attribute], +name: str) ->\n    [ast::attribute] {\n     let filter = (\n         fn@(a: ast::attribute) -> option<ast::attribute> {\n-            if get_attr_name(a) == name {\n+            if *get_attr_name(a) == name {\n                 option::some(a)\n             } else { option::none }\n         }\n@@ -161,10 +161,10 @@ fn find_attrs_by_name(attrs: [ast::attribute], +name: ast::ident) ->\n #[doc = \"\n Searcha list of meta items and return only those with a specific name\n \"]\n-fn find_meta_items_by_name(metas: [@ast::meta_item], +name: ast::ident) ->\n+fn find_meta_items_by_name(metas: [@ast::meta_item], +name: str) ->\n    [@ast::meta_item] {\n     let filter = fn@(&&m: @ast::meta_item) -> option<@ast::meta_item> {\n-        if get_meta_item_name(m) == name {\n+        if *get_meta_item_name(m) == name {\n             option::some(m)\n         } else { option::none }\n     };\n@@ -209,17 +209,17 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n         }\n }\n \n-fn contains_name(metas: [@ast::meta_item], +name: ast::ident) -> bool {\n+fn contains_name(metas: [@ast::meta_item], +name: str) -> bool {\n     let matches = find_meta_items_by_name(metas, name);\n     ret vec::len(matches) > 0u;\n }\n \n-fn attrs_contains_name(attrs: [ast::attribute], +name: ast::ident) -> bool {\n+fn attrs_contains_name(attrs: [ast::attribute], +name: str) -> bool {\n     vec::is_not_empty(find_attrs_by_name(attrs, name))\n }\n \n-fn first_attr_value_str_by_name(attrs: [ast::attribute], +name: ast::ident)\n-    -> option<str> {\n+fn first_attr_value_str_by_name(attrs: [ast::attribute], +name: str)\n+    -> option<@str> {\n     let mattrs = find_attrs_by_name(attrs, name);\n     if vec::len(mattrs) > 0u {\n         ret get_meta_item_value_str(attr_meta(mattrs[0]));\n@@ -238,11 +238,11 @@ fn last_meta_item_by_name(\n fn last_meta_item_value_str_by_name(\n     items: [@ast::meta_item],\n     +name: str\n-) -> option<str> {\n+) -> option<@str> {\n     alt last_meta_item_by_name(items, name) {\n       some(item) {\n         alt attr::get_meta_item_value_str(item) {\n-          some(value) { some(/* FIXME bad */ copy value) }\n+          some(value) { some(value) }\n           none { none }\n         }\n       }\n@@ -285,7 +285,7 @@ fn sort_meta_items(+items: [@ast::meta_item]) -> [@ast::meta_item] {\n     ret vec::from_mut(v);\n }\n \n-fn remove_meta_items_by_name(items: [@ast::meta_item], name: str) ->\n+fn remove_meta_items_by_name(items: [@ast::meta_item], name: ast::ident) ->\n    [@ast::meta_item] {\n \n     ret vec::filter_map(items, {\n@@ -326,17 +326,17 @@ fn native_abi(attrs: [ast::attribute]) -> either<str, ast::native_abi> {\n       option::none {\n         either::right(ast::native_abi_cdecl)\n       }\n-      option::some(\"rust-intrinsic\") {\n+      option::some(@\"rust-intrinsic\") {\n         either::right(ast::native_abi_rust_intrinsic)\n       }\n-      option::some(\"cdecl\") {\n+      option::some(@\"cdecl\") {\n         either::right(ast::native_abi_cdecl)\n       }\n-      option::some(\"stdcall\") {\n+      option::some(@\"stdcall\") {\n         either::right(ast::native_abi_stdcall)\n       }\n       option::some(t) {\n-        either::left(\"unsupported abi: \" + t)\n+        either::left(\"unsupported abi: \" + *t)\n       }\n     };\n }\n@@ -352,8 +352,8 @@ fn find_inline_attr(attrs: [ast::attribute]) -> inline_attr {\n     // TODO---validate the usage of #[inline] and #[inline(always)]\n     vec::foldl(ia_none, attrs) {|ia,attr|\n         alt attr.node.value.node {\n-          ast::meta_word(\"inline\") { ia_hint }\n-          ast::meta_list(\"inline\", items) {\n+          ast::meta_word(@\"inline\") { ia_hint }\n+          ast::meta_list(@\"inline\", items) {\n             if !vec::is_empty(find_meta_items_by_name(items, \"always\")) {\n                 ia_always\n             } else {\n@@ -373,11 +373,11 @@ fn require_unique_names(diagnostic: span_handler,\n         let name = get_meta_item_name(meta);\n \n         // FIXME: How do I silence the warnings? --pcw\n-        if map.contains_key(name) {\n+        if map.contains_key(*name) {\n             diagnostic.span_fatal(meta.span,\n-                                  #fmt[\"duplicate meta item `%s`\", name]);\n+                                  #fmt[\"duplicate meta item `%s`\", *name]);\n         }\n-        map.insert(name, ());\n+        map.insert(*name, ());\n     }\n }\n "}, {"sha": "888ff7d4ef2942166c0cd5c46fac17825fe5cd4c", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 39, "deletions": 36, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -92,7 +92,7 @@ fn expand(cx: ext_ctxt,\n           _mitem: ast::meta_item,\n           in_items: [@ast::item]) -> [@ast::item] {\n     fn not_auto_serialize(a: ast::attribute) -> bool {\n-        attr::get_attr_name(a) != \"auto_serialize\"\n+        attr::get_attr_name(a) != @\"auto_serialize\"\n     }\n \n     fn filter_attrs(item: @ast::item) -> @ast::item {\n@@ -126,18 +126,19 @@ impl helpers for ext_ctxt {\n                    helper_name: str) -> @ast::path {\n         let head = vec::init(base_path.idents);\n         let tail = vec::last(base_path.idents);\n-        self.path(base_path.span, head + [helper_name + \"_\" + tail])\n+        self.path(base_path.span, head + [@(helper_name + \"_\" + *tail)])\n     }\n \n-    fn path(span: span, strs: [str]) -> @ast::path {\n+    fn path(span: span, strs: [ast::ident]) -> @ast::path {\n         @{span: span, global: false, idents: strs, rp: none, types: []}\n     }\n \n-    fn path_tps(span: span, strs: [str], tps: [@ast::ty]) -> @ast::path {\n+    fn path_tps(span: span, strs: [ast::ident],\n+                tps: [@ast::ty]) -> @ast::path {\n         @{span: span, global: false, idents: strs, rp: none, types: tps}\n     }\n \n-    fn ty_path(span: span, strs: [str], tps: [@ast::ty]) -> @ast::ty {\n+    fn ty_path(span: span, strs: [ast::ident], tps: [@ast::ty]) -> @ast::ty {\n         @{id: self.next_id(),\n           node: ast::ty_path(self.path_tps(span, strs, tps), self.next_id()),\n           span: span}\n@@ -149,7 +150,7 @@ impl helpers for ext_ctxt {\n         let args = vec::map(input_tys) {|ty|\n             {mode: ast::expl(ast::by_ref),\n              ty: ty,\n-             ident: \"\",\n+             ident: @\"\",\n              id: self.next_id()}\n         };\n \n@@ -170,7 +171,7 @@ impl helpers for ext_ctxt {\n         @{id: self.next_id(), node: node, span: span}\n     }\n \n-    fn var_ref(span: span, name: str) -> @ast::expr {\n+    fn var_ref(span: span, name: ast::ident) -> @ast::expr {\n         self.expr(span, ast::expr_path(self.path(span, [name])))\n     }\n \n@@ -192,7 +193,7 @@ impl helpers for ext_ctxt {\n          span: expr.span}\n     }\n \n-    fn binder_pat(span: span, nm: str) -> @ast::pat {\n+    fn binder_pat(span: span, nm: ast::ident) -> @ast::pat {\n         let path = @{span: span, global: false, idents: [nm],\n                      rp: none, types: []};\n         @{id: self.next_id(),\n@@ -212,7 +213,7 @@ impl helpers for ext_ctxt {\n                 ast::expr_alt(v, arms, ast::alt_exhaustive)))\n     }\n \n-    fn lit_str(span: span, s: str) -> @ast::expr {\n+    fn lit_str(span: span, s: @str) -> @ast::expr {\n         self.expr(\n             span,\n             ast::expr_lit(\n@@ -310,7 +311,7 @@ fn ser_variant(cx: ext_ctxt,\n                bodyfn: fn(-@ast::expr, ast::blk) -> @ast::expr,\n                argfn: fn(-@ast::expr, uint, ast::blk) -> @ast::expr)\n     -> ast::arm {\n-    let vnames = vec::from_fn(vec::len(tys)) {|i| #fmt[\"__v%u\", i]};\n+    let vnames = vec::from_fn(vec::len(tys)) {|i| @#fmt[\"__v%u\", i]};\n     let pats = vec::from_fn(vec::len(tys)) {|i|\n         cx.binder_pat(tys[i].span, vnames[i])\n     };\n@@ -428,7 +429,7 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n             vec::is_empty(path.types) {\n             let ident = path.idents[0];\n \n-            alt tps.find(ident) {\n+            alt tps.find(*ident) {\n               some(f) { f(v) }\n               none { ser_path(cx, tps, path, s, v) }\n             }\n@@ -474,7 +475,7 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n     }\n }\n \n-fn mk_ser_fn(cx: ext_ctxt, span: span, name: str, tps: [ast::ty_param],\n+fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident, tps: [ast::ty_param],\n              f: fn(ext_ctxt, ser_tps_map,\n                    -@ast::expr, -@ast::expr) -> [@ast::stmt])\n     -> @ast::item {\n@@ -489,42 +490,42 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: str, tps: [ast::ty_param],\n              ty: cx.ty_fn(span,\n                           [cx.ty_path(span, [tp.ident], [])],\n                           cx.ty_nil(span)),\n-             ident: \"__s\" + tp.ident,\n+             ident: @(\"__s\" + *tp.ident),\n              id: cx.next_id()}});\n \n     #debug[\"tp_inputs = %?\", tp_inputs];\n \n \n     let ser_inputs: [ast::arg] =\n         [{mode: ast::expl(ast::by_ref),\n-          ty: cx.ty_path(span, [\"__S\"], []),\n-          ident: \"__s\",\n+          ty: cx.ty_path(span, [@\"__S\"], []),\n+          ident: @\"__s\",\n           id: cx.next_id()},\n          {mode: ast::expl(ast::by_ref),\n           ty: v_ty,\n-          ident: \"__v\",\n+          ident: @\"__v\",\n           id: cx.next_id()}]\n         + tp_inputs;\n \n     let tps_map = map::str_hash();\n     vec::iter2(tps, tp_inputs) {|tp, arg|\n         let arg_ident = arg.ident;\n         tps_map.insert(\n-            tp.ident,\n+            *tp.ident,\n             fn@(v: @ast::expr) -> [@ast::stmt] {\n                 let f = cx.var_ref(span, arg_ident);\n-                #debug[\"serializing type arg %s\", arg_ident];\n+                #debug[\"serializing type arg %s\", *arg_ident];\n                 [#ast(stmt){$(f)($(v));}]\n             });\n     }\n \n     let ser_bnds = @[\n         ast::bound_iface(cx.ty_path(span,\n-                                    [\"std\", \"serialization\", \"serializer\"],\n+                                    [@\"std\", @\"serialization\", @\"serializer\"],\n                                     []))];\n \n     let ser_tps: [ast::ty_param] =\n-        [{ident: \"__S\",\n+        [{ident: @\"__S\",\n           id: cx.next_id(),\n           bounds: ser_bnds}] +\n         vec::map(tps) {|tp| cx.clone_ty_param(tp) };\n@@ -536,7 +537,7 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: str, tps: [ast::ty_param],\n     let ser_blk = cx.blk(span,\n                          f(cx, tps_map, #ast{ __s }, #ast{ __v }));\n \n-    @{ident: \"serialize_\" + name,\n+    @{ident: @(\"serialize_\" + *name),\n       attrs: [],\n       id: cx.next_id(),\n       node: ast::item_fn({inputs: ser_inputs,\n@@ -651,7 +652,7 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n             vec::is_empty(path.types) {\n             let ident = path.idents[0];\n \n-            alt tps.find(ident) {\n+            alt tps.find(*ident) {\n               some(f) { f() }\n               none { deser_path(cx, tps, path, d) }\n             }\n@@ -683,7 +684,8 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n     }\n }\n \n-fn mk_deser_fn(cx: ext_ctxt, span: span, name: str, tps: [ast::ty_param],\n+fn mk_deser_fn(cx: ext_ctxt, span: span,\n+               name: ast::ident, tps: [ast::ty_param],\n                f: fn(ext_ctxt, deser_tps_map, -@ast::expr) -> @ast::expr)\n     -> @ast::item {\n     let ext_cx = cx; // required for #ast\n@@ -697,36 +699,37 @@ fn mk_deser_fn(cx: ext_ctxt, span: span, name: str, tps: [ast::ty_param],\n              ty: cx.ty_fn(span,\n                           [],\n                           cx.ty_path(span, [tp.ident], [])),\n-             ident: \"__d\" + tp.ident,\n+             ident: @(\"__d\" + *tp.ident),\n              id: cx.next_id()}});\n \n     #debug[\"tp_inputs = %?\", tp_inputs];\n \n     let deser_inputs: [ast::arg] =\n         [{mode: ast::expl(ast::by_ref),\n-          ty: cx.ty_path(span, [\"__D\"], []),\n-          ident: \"__d\",\n+          ty: cx.ty_path(span, [@\"__D\"], []),\n+          ident: @\"__d\",\n           id: cx.next_id()}]\n         + tp_inputs;\n \n     let tps_map = map::str_hash();\n     vec::iter2(tps, tp_inputs) {|tp, arg|\n         let arg_ident = arg.ident;\n         tps_map.insert(\n-            tp.ident,\n+            *tp.ident,\n             fn@() -> @ast::expr {\n                 let f = cx.var_ref(span, arg_ident);\n                 #ast{ $(f)() }\n             });\n     }\n \n     let deser_bnds = @[\n-        ast::bound_iface(cx.ty_path(span,\n-                                    [\"std\", \"serialization\", \"deserializer\"],\n-                                    []))];\n+        ast::bound_iface(cx.ty_path(\n+            span,\n+            [@\"std\", @\"serialization\", @\"deserializer\"],\n+            []))];\n \n     let deser_tps: [ast::ty_param] =\n-        [{ident: \"__D\",\n+        [{ident: @\"__D\",\n           id: cx.next_id(),\n           bounds: deser_bnds}] + vec::map(tps) {|tp|\n         let cloned = cx.clone_ty_param(tp);\n@@ -735,7 +738,7 @@ fn mk_deser_fn(cx: ext_ctxt, span: span, name: str, tps: [ast::ty_param],\n \n     let deser_blk = cx.expr_blk(f(cx, tps_map, #ast(expr){__d}));\n \n-    @{ident: \"deserialize_\" + name,\n+    @{ident: @(\"deserialize_\" + *name),\n       attrs: [],\n       id: cx.next_id(),\n       node: ast::item_fn({inputs: deser_inputs,\n@@ -749,7 +752,7 @@ fn mk_deser_fn(cx: ext_ctxt, span: span, name: str, tps: [ast::ty_param],\n       span: span}\n }\n \n-fn ty_fns(cx: ext_ctxt, name: str, ty: @ast::ty, tps: [ast::ty_param])\n+fn ty_fns(cx: ext_ctxt, name: ast::ident, ty: @ast::ty, tps: [ast::ty_param])\n     -> [@ast::item] {\n \n     let span = ty.span;\n@@ -759,7 +762,7 @@ fn ty_fns(cx: ext_ctxt, name: str, ty: @ast::ty, tps: [ast::ty_param])\n     ]\n }\n \n-fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: str,\n+fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: ast::ident,\n             e_span: span, variants: [ast::variant],\n             -s: @ast::expr, -v: @ast::expr) -> [@ast::stmt] {\n     let ext_cx = cx;\n@@ -808,7 +811,7 @@ fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: str,\n     [#ast(stmt){ $(s).emit_enum($(e_name), $(lam)) }]\n }\n \n-fn deser_enum(cx: ext_ctxt, tps: deser_tps_map, e_name: str,\n+fn deser_enum(cx: ext_ctxt, tps: deser_tps_map, e_name: ast::ident,\n               e_span: span, variants: [ast::variant],\n               -d: @ast::expr) -> @ast::expr {\n     let ext_cx = cx;\n@@ -852,7 +855,7 @@ fn deser_enum(cx: ext_ctxt, tps: deser_tps_map, e_name: str,\n     #ast{ $(d).read_enum($(e_name), $(read_lambda)) }\n }\n \n-fn enum_fns(cx: ext_ctxt, e_name: str, e_span: span,\n+fn enum_fns(cx: ext_ctxt, e_name: ast::ident, e_span: span,\n                variants: [ast::variant], tps: [ast::ty_param])\n     -> [@ast::item] {\n     ["}, {"sha": "e39f97452490a60b4e150ff1b0e5564bb5e621f0", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -9,7 +9,7 @@ type syntax_expander_ =\n type syntax_expander = {\n     expander: syntax_expander_,\n     span: option<span>};\n-type macro_def = {ident: str, ext: syntax_extension};\n+type macro_def = {ident: ast::ident, ext: syntax_extension};\n type macro_definer =\n     fn@(ext_ctxt, span, ast::mac_arg, ast::mac_body) -> macro_def;\n type item_decorator =\n@@ -150,7 +150,7 @@ fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, error: str) -> str {\n     alt expr.node {\n       ast::expr_lit(l) {\n         alt l.node {\n-          ast::lit_str(s) { ret s; }\n+          ast::lit_str(s) { ret *s; }\n           _ { cx.span_fatal(l.span, error); }\n         }\n       }"}, {"sha": "69f7f2b69cda2f6e629b9ba746870c7a6c07e824", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -6,7 +6,7 @@ fn mk_lit(cx: ext_ctxt, sp: span, lit: ast::lit_) -> @ast::expr {\n     ret @{id: cx.next_id(), node: ast::expr_lit(sp_lit), span: sp};\n }\n fn mk_str(cx: ext_ctxt, sp: span, s: str) -> @ast::expr {\n-    let lit = ast::lit_str(s);\n+    let lit = ast::lit_str(@s);\n     ret mk_lit(cx, sp, lit);\n }\n fn mk_int(cx: ext_ctxt, sp: span, i: int) -> @ast::expr {"}, {"sha": "faf8e1a08683f49801564ca6e66334581aa6af06", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -3,13 +3,13 @@ import base::*;\n fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n                      _body: ast::mac_body) -> @ast::expr {\n     let args = get_mac_args_no_max(cx,sp,arg,1u,\"concat_idents\");\n-    let mut res: ast::ident = \"\";\n+    let mut res = \"\";\n     for args.each {|e|\n-        res += expr_to_ident(cx, e, \"expected an ident\");\n+        res += *expr_to_ident(cx, e, \"expected an ident\");\n     }\n \n     ret @{id: cx.next_id(),\n-          node: ast::expr_path(@{span: sp, global: false, idents: [res],\n+          node: ast::expr_path(@{span: sp, global: false, idents: [@res],\n                                  rp: none, types: []}),\n           span: sp};\n }"}, {"sha": "ebb56fa3b5856d9db82201e0a5e01f5778205efe", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -21,8 +21,8 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n     }\n }\n \n-fn make_new_str(cx: ext_ctxt, sp: codemap::span, s: str) -> @ast::expr {\n-    ret make_new_lit(cx, sp, ast::lit_str(s));\n+fn make_new_str(cx: ext_ctxt, sp: codemap::span, +s: str) -> @ast::expr {\n+    ret make_new_lit(cx, sp, ast::lit_str(@s));\n }\n //\n // Local Variables:"}, {"sha": "8bc1f7a3433df97c3706b03473fcf8ad96dc6c39", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -21,21 +21,21 @@ fn expand_expr(exts: hashmap<str, syntax_extension>, cx: ext_ctxt,\n               mac_invoc(pth, args, body) {\n                 assert (vec::len(pth.idents) > 0u);\n                 let extname = pth.idents[0];\n-                alt exts.find(extname) {\n+                alt exts.find(*extname) {\n                   none {\n                     cx.span_fatal(pth.span,\n-                                  #fmt[\"macro undefined: '%s'\", extname])\n+                                  #fmt[\"macro undefined: '%s'\", *extname])\n                   }\n                   some(item_decorator(_)) {\n                     cx.span_fatal(\n                         pth.span,\n-                        #fmt[\"%s can only be used as a decorator\", extname]);\n+                        #fmt[\"%s can only be used as a decorator\", *extname]);\n                   }\n                   some(normal({expander: exp, span: exp_sp})) {\n                     let expanded = exp(cx, pth.span, args, body);\n \n                     cx.bt_push(expanded_from({call_site: s,\n-                                callie: {name: extname, span: exp_sp}}));\n+                                callie: {name: *extname, span: exp_sp}}));\n                     //keep going, outside-in\n                     let fully_expanded = fld.fold_expr(expanded).node;\n                     cx.bt_pop();\n@@ -44,7 +44,7 @@ fn expand_expr(exts: hashmap<str, syntax_extension>, cx: ext_ctxt,\n                   }\n                   some(macro_defining(ext)) {\n                     let named_extension = ext(cx, pth.span, args, body);\n-                    exts.insert(named_extension.ident, named_extension.ext);\n+                    exts.insert(*named_extension.ident, named_extension.ext);\n                     (ast::expr_rec([], none), s)\n                   }\n                 }\n@@ -74,7 +74,7 @@ fn expand_mod_items(exts: hashmap<str, syntax_extension>, cx: ext_ctxt,\n               ast::meta_name_value(n, _) { n }\n               ast::meta_list(n, _) { n }\n             };\n-            alt exts.find(mname) {\n+            alt exts.find(*mname) {\n               none | some(normal(_)) | some(macro_defining(_)) {\n                 items\n               }"}, {"sha": "4725f5a1977f3eaa15721cb5a17d41983b9e1936", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -36,9 +36,10 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n    -> @ast::expr {\n     fn make_path_vec(_cx: ext_ctxt, ident: ast::ident) -> [ast::ident] {\n-        ret [\"extfmt\", \"rt\", ident];\n+        ret [@\"extfmt\", @\"rt\", ident];\n     }\n-    fn make_rt_path_expr(cx: ext_ctxt, sp: span, ident: str) -> @ast::expr {\n+    fn make_rt_path_expr(cx: ext_ctxt, sp: span,\n+                         ident: ast::ident) -> @ast::expr {\n         let path = make_path_vec(cx, ident);\n         ret mk_path(cx, sp, path);\n     }\n@@ -57,18 +58,18 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n                   flag_sign_always { fstr = \"flag_sign_always\"; }\n                   flag_alternate { fstr = \"flag_alternate\"; }\n                 }\n-                flagexprs += [make_rt_path_expr(cx, sp, fstr)];\n+                flagexprs += [make_rt_path_expr(cx, sp, @fstr)];\n             }\n             ret mk_vec_e(cx, sp, flagexprs);\n         }\n         fn make_count(cx: ext_ctxt, sp: span, cnt: count) -> @ast::expr {\n             alt cnt {\n               count_implied {\n-                ret make_rt_path_expr(cx, sp, \"count_implied\");\n+                ret make_rt_path_expr(cx, sp, @\"count_implied\");\n               }\n               count_is(c) {\n                 let count_lit = mk_int(cx, sp, c);\n-                let count_is_path = make_path_vec(cx, \"count_is\");\n+                let count_is_path = make_path_vec(cx, @\"count_is\");\n                 let count_is_args = [count_lit];\n                 ret mk_call(cx, sp, count_is_path, count_is_args);\n               }\n@@ -88,16 +89,16 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n               ty_octal { rt_type = \"ty_octal\"; }\n               _ { rt_type = \"ty_default\"; }\n             }\n-            ret make_rt_path_expr(cx, sp, rt_type);\n+            ret make_rt_path_expr(cx, sp, @rt_type);\n         }\n         fn make_conv_rec(cx: ext_ctxt, sp: span, flags_expr: @ast::expr,\n                          width_expr: @ast::expr, precision_expr: @ast::expr,\n                          ty_expr: @ast::expr) -> @ast::expr {\n             ret mk_rec_e(cx, sp,\n-                         [{ident: \"flags\", ex: flags_expr},\n-                          {ident: \"width\", ex: width_expr},\n-                          {ident: \"precision\", ex: precision_expr},\n-                          {ident: \"ty\", ex: ty_expr}]);\n+                         [{ident: @\"flags\", ex: flags_expr},\n+                          {ident: @\"width\", ex: width_expr},\n+                          {ident: @\"precision\", ex: precision_expr},\n+                          {ident: @\"ty\", ex: ty_expr}]);\n         }\n         let rt_conv_flags = make_flags(cx, sp, cnv.flags);\n         let rt_conv_width = make_count(cx, sp, cnv.width);\n@@ -109,7 +110,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n     fn make_conv_call(cx: ext_ctxt, sp: span, conv_type: str, cnv: conv,\n                       arg: @ast::expr) -> @ast::expr {\n         let fname = \"conv_\" + conv_type;\n-        let path = make_path_vec(cx, fname);\n+        let path = make_path_vec(cx, @fname);\n         let cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n         let args = [cnv_expr, arg];\n         ret mk_call(cx, arg.span, path, args);"}, {"sha": "316ac7603fb0f814ca23ac03c5a004af77ff514b", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -35,7 +35,7 @@ impl of qq_helper for @ast::crate {\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_crate(*self, cx, v);}\n     fn extract_mac() -> option<ast::mac_> {fail}\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp, [\"syntax\", \"ext\", \"qquote\", \"parse_crate\"])\n+        mk_path(cx, sp, [@\"syntax\", @\"ext\", @\"qquote\", @\"parse_crate\"])\n     }\n     fn get_fold_fn() -> str {\"fold_crate\"}\n }\n@@ -49,7 +49,7 @@ impl of qq_helper for @ast::expr {\n         }\n     }\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp, [\"syntax\", \"ext\", \"qquote\", \"parse_expr\"])\n+        mk_path(cx, sp, [@\"syntax\", @\"ext\", @\"qquote\", @\"parse_expr\"])\n     }\n     fn get_fold_fn() -> str {\"fold_expr\"}\n }\n@@ -63,7 +63,7 @@ impl of qq_helper for @ast::ty {\n         }\n     }\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp, [\"syntax\", \"ext\", \"qquote\", \"parse_ty\"])\n+        mk_path(cx, sp, [@\"syntax\", @\"ext\", @\"qquote\", @\"parse_ty\"])\n     }\n     fn get_fold_fn() -> str {\"fold_ty\"}\n }\n@@ -72,7 +72,7 @@ impl of qq_helper for @ast::item {\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_item(self, cx, v);}\n     fn extract_mac() -> option<ast::mac_> {fail}\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp, [\"syntax\", \"ext\", \"qquote\", \"parse_item\"])\n+        mk_path(cx, sp, [@\"syntax\", @\"ext\", @\"qquote\", @\"parse_item\"])\n     }\n     fn get_fold_fn() -> str {\"fold_item\"}\n }\n@@ -81,7 +81,7 @@ impl of qq_helper for @ast::stmt {\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_stmt(self, cx, v);}\n     fn extract_mac() -> option<ast::mac_> {fail}\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp, [\"syntax\", \"ext\", \"qquote\", \"parse_stmt\"])\n+        mk_path(cx, sp, [@\"syntax\", @\"ext\", @\"qquote\", @\"parse_stmt\"])\n     }\n     fn get_fold_fn() -> str {\"fold_stmt\"}\n }\n@@ -90,7 +90,7 @@ impl of qq_helper for @ast::pat {\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_pat(self, cx, v);}\n     fn extract_mac() -> option<ast::mac_> {fail}\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp, [\"syntax\", \"ext\", \"qquote\", \"parse_pat\"])\n+        mk_path(cx, sp, [@\"syntax\", @\"ext\", @\"qquote\", @\"parse_pat\"])\n     }\n     fn get_fold_fn() -> str {\"fold_pat\"}\n }\n@@ -146,7 +146,7 @@ fn expand_ast(ecx: ext_ctxt, _sp: span,\n         }\n         alt (args[0].node) {\n           ast::expr_path(@{idents: id, _}) if vec::len(id) == 1u\n-              {what = id[0]}\n+              {what = *id[0]}\n           _ {ecx.span_fatal(args[0].span, \"expected an identifier\");}\n         }\n     }\n@@ -230,20 +230,21 @@ fn finish<T: qq_helper>\n     let cx = ecx;\n \n     let cfg_call = {||\n-        mk_call_(cx, sp, mk_access(cx, sp, [\"ext_cx\"], \"cfg\"), [])\n+        mk_call_(cx, sp, mk_access(cx, sp, [@\"ext_cx\"], @\"cfg\"), [])\n     };\n \n     let parse_sess_call = {||\n-        mk_call_(cx, sp, mk_access(cx, sp, [\"ext_cx\"], \"parse_sess\"), [])\n+        mk_call_(cx, sp, mk_access(cx, sp, [@\"ext_cx\"], @\"parse_sess\"), [])\n     };\n \n     let pcall = mk_call(cx,sp,\n-                       [\"syntax\", \"parse\", \"parser\",\n-                        \"parse_from_source_str\"],\n+                       [@\"syntax\", @\"parse\", @\"parser\",\n+                        @\"parse_from_source_str\"],\n                        [node.mk_parse_fn(cx,sp),\n                         mk_str(cx,sp, fname),\n                         mk_call(cx,sp,\n-                                [\"syntax\",\"ext\",\"qquote\", \"mk_file_substr\"],\n+                                [@\"syntax\",@\"ext\",\n+                                 @\"qquote\", @\"mk_file_substr\"],\n                                 [mk_str(cx,sp, loc.file.name),\n                                  mk_uint(cx,sp, loc.line),\n                                  mk_uint(cx,sp, loc.col)]),\n@@ -255,15 +256,16 @@ fn finish<T: qq_helper>\n     let mut rcall = pcall;\n     if (g_len > 0u) {\n         rcall = mk_call(cx,sp,\n-                        [\"syntax\", \"ext\", \"qquote\", \"replace\"],\n+                        [@\"syntax\", @\"ext\", @\"qquote\", @\"replace\"],\n                         [pcall,\n                          mk_vec_e(cx,sp, qcx.gather.map_to_vec {|g|\n                              mk_call(cx,sp,\n-                                     [\"syntax\", \"ext\", \"qquote\", g.constr],\n+                                     [@\"syntax\", @\"ext\",\n+                                      @\"qquote\", @g.constr],\n                                      [g.e])}),\n                          mk_path(cx,sp,\n-                                 [\"syntax\", \"ext\", \"qquote\",\n-                                  node.get_fold_fn()])]);\n+                                 [@\"syntax\", @\"ext\", @\"qquote\",\n+                                  @node.get_fold_fn()])]);\n     }\n     ret rcall;\n }"}, {"sha": "e2d16299b22e95ff99d54d49f30888eaa6402813", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -1,5 +1,5 @@\n import codemap::span;\n-import std::map::{hashmap, str_hash};\n+import std::map::{hashmap, str_hash, box_str_hash};\n import dvec::{dvec, extensions};\n \n import base::*;\n@@ -146,7 +146,7 @@ fn acumm_bindings(_cx: ext_ctxt, _b_dest: bindings, _b_src: bindings) { }\n \n fn pattern_to_selectors(cx: ext_ctxt, e: @expr) -> binders {\n     let res: binders =\n-        {real_binders: str_hash::<selector>(),\n+        {real_binders: box_str_hash::<selector>(),\n          literal_ast_matchers: dvec()};\n     //this oughta return binders instead, but macro args are a sequence of\n     //expressions, rather than a single expression\n@@ -162,7 +162,7 @@ bindings. Most of the work is done in p_t_s, which generates the\n selectors. */\n \n fn use_selectors_to_bind(b: binders, e: @expr) -> option<bindings> {\n-    let res = str_hash::<arb_depth<matchable>>();\n+    let res = box_str_hash::<arb_depth<matchable>>();\n     //need to do this first, to check vec lengths.\n     for b.literal_ast_matchers.each {|sel|\n         alt sel(match_expr(e)) { none { ret none; } _ { } }\n@@ -240,7 +240,7 @@ fn follow_for_trans(cx: ext_ctxt, mmaybe: option<arb_depth<matchable>>,\n \n /* helper for transcribe_exprs: what vars from `b` occur in `e`? */\n fn free_vars(b: bindings, e: @expr, it: fn(ident)) {\n-    let idents: hashmap<ident, ()> = str_hash::<()>();\n+    let idents: hashmap<ident, ()> = box_str_hash::<()>();\n     fn mark_ident(&&i: ident, _fld: ast_fold, b: bindings,\n                   idents: hashmap<ident, ()>) -> ident {\n         if b.contains_key(i) { idents.insert(i, ()); }\n@@ -282,8 +282,8 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n                         let len = vec::len(*ms);\n                         if old_len != len {\n                             let msg =\n-                                #fmt[\"'%s' occurs %u times, but \", fv, len] +\n-                                    #fmt[\"'%s' occurs %u times\", old_name,\n+                                #fmt[\"'%s' occurs %u times, but \", *fv, len] +\n+                                    #fmt[\"'%s' occurs %u times\", *old_name,\n                                          old_len];\n                             cx.span_fatal(repeat_me.span, msg);\n                         }\n@@ -672,7 +672,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                      _body: ast::mac_body) -> base::macro_def {\n     let args = get_mac_args_no_max(cx, sp, arg, 0u, \"macro\");\n \n-    let mut macro_name: option<str> = none;\n+    let mut macro_name: option<@str> = none;\n     let mut clauses: [@clause] = [];\n     for args.each {|arg|\n         alt arg.node {"}, {"sha": "23c6a3714c37e78ff7d4e1f99a471b424a010912", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -36,19 +36,20 @@ fn expand_file(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n     get_mac_args(cx, sp, arg, 0u, option::some(0u), \"file\");\n     let { file: @{ name: filename, _ }, _ } =\n         codemap::lookup_char_pos(cx.codemap(), sp.lo);\n-    ret make_new_lit(cx, sp, ast::lit_str(filename));\n+    ret make_new_lit(cx, sp, ast::lit_str(@filename));\n }\n \n fn expand_stringify(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                     _body: ast::mac_body) -> @ast::expr {\n     let args = get_mac_args(cx, sp, arg, 1u, option::some(1u), \"stringify\");\n-    ret make_new_lit(cx, sp, ast::lit_str(pprust::expr_to_str(args[0])));\n+    ret make_new_lit(cx, sp, ast::lit_str(@pprust::expr_to_str(args[0])));\n }\n \n fn expand_mod(cx: ext_ctxt, sp: span, arg: ast::mac_arg, _body: ast::mac_body)\n     -> @ast::expr {\n     get_mac_args(cx, sp, arg, 0u, option::some(0u), \"file\");\n-    ret make_new_lit(cx, sp, ast::lit_str(str::connect(cx.mod_path(), \"::\")));\n+    ret make_new_lit(cx, sp, ast::lit_str(\n+        @str::connect(cx.mod_path().map({|x|*x}), \"::\")));\n }\n \n fn expand_include(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n@@ -75,7 +76,7 @@ fn expand_include_str(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n       }\n     }\n \n-    ret make_new_lit(cx, sp, ast::lit_str(result::unwrap(res)));\n+    ret make_new_lit(cx, sp, ast::lit_str(@result::unwrap(res)));\n }\n \n fn expand_include_bin(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,"}, {"sha": "c8e62a2245dfb86421ad0440741741243e2d786d", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -81,7 +81,7 @@ impl parser_common for parser {\n     fn token_is_keyword(word: str, ++tok: token::token) -> bool {\n         self.require_keyword(word);\n         alt tok {\n-          token::IDENT(sid, false) { str::eq(word, self.get_str(sid)) }\n+          token::IDENT(sid, false) { str::eq(word, *self.get_str(sid)) }\n           _ { false }\n         }\n     }\n@@ -97,7 +97,7 @@ impl parser_common for parser {\n         // workaround LLVM bug #13042\n         alt @self.token {\n           @token::IDENT(sid, false) {\n-            if str::eq(word, self.get_str(sid)) {\n+            if str::eq(word, *self.get_str(sid)) {\n                 self.bump();\n                 ret true;\n             } else { ret false; }\n@@ -128,7 +128,7 @@ impl parser_common for parser {\n         }\n     }\n \n-    fn check_restricted_keywords_(w: ast::ident) {\n+    fn check_restricted_keywords_(w: str) {\n         if self.is_restricted_keyword(w) {\n             self.fatal(\"found `\" + w + \"` in restricted position\");\n         }"}, {"sha": "4b5632124d858b560597776be5d5f55f96ac61da", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -75,7 +75,7 @@ fn parse_companion_mod(cx: ctx, prefix: str, suffix: option<str>)\n     }\n }\n \n-fn cdir_path_opt(id: str, attrs: [ast::attribute]) -> str {\n+fn cdir_path_opt(id: ast::ident, attrs: [ast::attribute]) -> @str {\n     alt ::attr::first_attr_value_str_by_name(attrs, \"path\") {\n       some(d) {\n         ret d;\n@@ -89,11 +89,11 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n                         &items: [@ast::item]) {\n     alt cdir.node {\n       ast::cdir_src_mod(id, attrs) {\n-        let file_path = cdir_path_opt(id + \".rs\", attrs);\n+        let file_path = cdir_path_opt(@(*id + \".rs\"), attrs);\n         let full_path =\n-            if path::path_is_absolute(file_path) {\n-                file_path\n-            } else { prefix + path::path_sep() + file_path };\n+            if path::path_is_absolute(*file_path) {\n+                *file_path\n+            } else { prefix + path::path_sep() + *file_path };\n         let p0 =\n             new_parser_from_file(cx.sess, cx.cfg, full_path, SOURCE_FILE);\n         let inner_attrs = p0.parse_inner_attrs_and_next();\n@@ -112,9 +112,9 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n       ast::cdir_dir_mod(id, cdirs, attrs) {\n         let path = cdir_path_opt(id, attrs);\n         let full_path =\n-            if path::path_is_absolute(path) {\n-                path\n-            } else { prefix + path::path_sep() + path };\n+            if path::path_is_absolute(*path) {\n+                *path\n+            } else { prefix + path::path_sep() + *path };\n         let (m0, a0) = eval_crate_directives_to_mod(\n             cx, cdirs, full_path, none);\n         let i ="}, {"sha": "975e90318770a9559cd2b23631b2f31fe54dd1d1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -151,8 +151,8 @@ class parser {\n     fn warn(m: str) {\n         self.sess.span_diagnostic.span_warn(copy self.span, m)\n     }\n-    fn get_str(i: token::str_num) -> str {\n-        *interner::get(*self.reader.interner, i)\n+    fn get_str(i: token::str_num) -> @str {\n+        interner::get(*self.reader.interner, i)\n     }\n     fn get_id() -> node_id { next_node_id(self.sess) }\n \n@@ -178,7 +178,7 @@ class parser {\n                 let name = self.parse_value_ident();\n                 p.bump();\n                 name\n-            } else { \"\" };\n+            } else { @\"\" };\n \n             {mode: mode, ty: p.parse_ty(false), ident: name,\n              id: p.get_id()}\n@@ -229,7 +229,7 @@ class parser {\n     fn ident_index(args: [arg], i: ident) -> uint {\n         let mut j = 0u;\n         for args.each {|a| if a.ident == i { ret j; } j += 1u; }\n-        self.fatal(\"unbound variable `\" + i + \"` in constraint arg\");\n+        self.fatal(\"unbound variable `\" + *i + \"` in constraint arg\");\n     }\n \n     fn parse_type_constr_arg() -> @ty_constr_arg {\n@@ -315,7 +315,7 @@ class parser {\n         }\n     }\n \n-    fn region_from_name(s: option<str>) -> @region {\n+    fn region_from_name(s: option<@str>) -> @region {\n         let r = alt s {\n           some (string) { re_named(string) }\n           none { re_anon }\n@@ -1858,13 +1858,13 @@ class parser {\n \n     fn parse_method_name() -> ident {\n         alt copy self.token {\n-          token::BINOP(op) { self.bump(); token::binop_to_str(op) }\n-          token::NOT { self.bump(); \"!\" }\n-          token::LBRACKET { self.bump(); self.expect(token::RBRACKET); \"[]\" }\n+          token::BINOP(op) { self.bump(); @token::binop_to_str(op) }\n+          token::NOT { self.bump(); @\"!\" }\n+          token::LBRACKET { self.bump(); self.expect(token::RBRACKET); @\"[]\" }\n           _ {\n             let id = self.parse_value_ident();\n-            if id == \"unary\" && self.eat(token::BINOP(token::MINUS)) {\n-                \"unary-\"\n+            if id == @\"unary\" && self.eat(token::BINOP(token::MINUS)) {\n+                @\"unary-\"\n             }\n             else { id }\n           }\n@@ -1969,7 +1969,7 @@ class parser {\n         // Hack.  But then, this whole function is in service of a hack.\n         let a_r = alt rp {\n           rp_none { none }\n-          rp_self { some(self.region_from_name(some(\"self\"))) }\n+          rp_self { some(self.region_from_name(some(@\"self\"))) }\n         };\n \n         @{span: s, global: false, idents: [i],\n@@ -2243,7 +2243,7 @@ class parser {\n         let mut variants: [variant] = [];\n         // Newtype syntax\n         if self.token == token::EQ {\n-            self.check_restricted_keywords_(id);\n+            self.check_restricted_keywords_(*id);\n             self.bump();\n             let ty = self.parse_ty(false);\n             self.expect(token::SEMI);\n@@ -2381,7 +2381,7 @@ class parser {\n         let lo = self.span.lo;\n         let first_ident = self.parse_ident();\n         let mut path = [first_ident];\n-        #debug(\"parsed view_path: %s\", first_ident);\n+        #debug(\"parsed view_path: %s\", *first_ident);\n         alt self.token {\n           token::EQ {\n             // x = foo::bar\n@@ -2504,7 +2504,7 @@ class parser {\n                       config: self.cfg});\n     }\n \n-    fn parse_str() -> str {\n+    fn parse_str() -> @str {\n         alt copy self.token {\n           token::LIT_STR(s) { self.bump(); self.get_str(s) }\n           _ {"}, {"sha": "a63e3139b5bbeb7c8273fb3217658666761b4732", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -342,7 +342,7 @@ fn print_region(s: ps, region: @ast::region) {\n       ast::re_anon { word_space(s, \"&\"); }\n       ast::re_named(name) {\n         word(s.s, \"&\");\n-        word_space(s, name);\n+        word_space(s, *name);\n       }\n     }\n }\n@@ -382,7 +382,7 @@ fn print_type_ex(s: ps, &&ty: @ast::ty, print_colons: bool) {\n         fn print_field(s: ps, f: ast::ty_field) {\n             cbox(s, indent_unit);\n             print_mutability(s, f.node.mt.mutbl);\n-            word(s.s, f.node.ident);\n+            word(s.s, *f.node.ident);\n             word_space(s, \":\");\n             print_type(s, f.node.mt.ty);\n             end(s);\n@@ -443,7 +443,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n     alt item.node {\n       ast::item_const(ty, expr) {\n         head(s, \"const\");\n-        word_space(s, item.ident + \":\");\n+        word_space(s, *item.ident + \":\");\n         print_type(s, ty);\n         space(s.s);\n         end(s); // end the head-ibox\n@@ -461,15 +461,15 @@ fn print_item(s: ps, &&item: @ast::item) {\n       }\n       ast::item_mod(_mod) {\n         head(s, \"mod\");\n-        word_nbsp(s, item.ident);\n+        word_nbsp(s, *item.ident);\n         bopen(s);\n         print_mod(s, _mod, item.attrs);\n         bclose(s, item.span);\n       }\n       ast::item_native_mod(nmod) {\n         head(s, \"native\");\n         word_nbsp(s, \"mod\");\n-        word_nbsp(s, item.ident);\n+        word_nbsp(s, *item.ident);\n         bopen(s);\n         print_native_mod(s, nmod, item.attrs);\n         bclose(s, item.span);\n@@ -478,7 +478,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n         ibox(s, indent_unit);\n         ibox(s, 0u);\n         word_nbsp(s, \"type\");\n-        word(s.s, item.ident);\n+        word(s.s, *item.ident);\n         print_region_param(s, rp);\n         print_type_params(s, params);\n         end(s); // end the inner ibox\n@@ -492,13 +492,13 @@ fn print_item(s: ps, &&item: @ast::item) {\n       ast::item_enum(variants, params, rp) {\n         let newtype =\n             vec::len(variants) == 1u &&\n-                str::eq(item.ident, variants[0].node.name) &&\n+                str::eq(*item.ident, *variants[0].node.name) &&\n                 vec::len(variants[0].node.args) == 1u;\n         if newtype {\n             ibox(s, indent_unit);\n             word_space(s, \"enum\");\n         } else { head(s, \"enum\"); }\n-        word(s.s, item.ident);\n+        word(s.s, *item.ident);\n         print_region_param(s, rp);\n         print_type_params(s, params);\n         space(s.s);\n@@ -524,7 +524,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n       }\n       ast::item_class(tps, ifaces, items, ctor, m_dtor, rp) {\n           head(s, \"class\");\n-          word_nbsp(s, item.ident);\n+          word_nbsp(s, *item.ident);\n           print_region_param(s, rp);\n           print_type_params(s, tps);\n           word_space(s, \"implements\");\n@@ -570,7 +570,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n                       ast::class_mutable { word_nbsp(s, \"mut\"); }\n                       _ {}\n                     }\n-                    word(s.s, nm);\n+                    word(s.s, *nm);\n                     word_nbsp(s, \":\");\n                     print_type(s, t);\n                     word(s.s, \";\");\n@@ -588,7 +588,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n        }\n       ast::item_impl(tps, rp, ifce, ty, methods) {\n         head(s, \"impl\");\n-        word(s.s, item.ident);\n+        word(s.s, *item.ident);\n         print_region_param(s, rp);\n         print_type_params(s, tps);\n         space(s.s);\n@@ -608,7 +608,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n       }\n       ast::item_iface(tps, rp, methods) {\n         head(s, \"iface\");\n-        word(s.s, item.ident);\n+        word(s.s, *item.ident);\n         print_region_param(s, rp);\n         print_type_params(s, tps);\n         word(s.s, \" \");\n@@ -627,18 +627,18 @@ fn print_item(s: ps, &&item: @ast::item) {\n fn print_res(s: ps, decl: ast::fn_decl, name: ast::ident,\n              typarams: [ast::ty_param], rp: ast::region_param) {\n     head(s, \"resource\");\n-    word(s.s, name);\n+    word(s.s, *name);\n     print_region_param(s, rp);\n     print_type_params(s, typarams);\n     popen(s);\n-    word_space(s, decl.inputs[0].ident + \":\");\n+    word_space(s, *decl.inputs[0].ident + \":\");\n     print_type(s, decl.inputs[0].ty);\n     pclose(s);\n     space(s.s);\n }\n \n fn print_variant(s: ps, v: ast::variant) {\n-    word(s.s, v.node.name);\n+    word(s.s, *v.node.name);\n     if vec::len(v.node.args) > 0u {\n         popen(s);\n         fn print_variant_arg(s: ps, arg: ast::variant_arg) {\n@@ -892,7 +892,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         fn print_field(s: ps, field: ast::field) {\n             ibox(s, indent_unit);\n             if field.node.mutbl == ast::m_mutbl { word_nbsp(s, \"mut\"); }\n-            word(s.s, field.node.ident);\n+            word(s.s, *field.node.ident);\n             word_space(s, \":\");\n             print_expr(s, field.node.expr);\n             end(s);\n@@ -1089,7 +1089,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n             print_expr_parens_if_not_bot(s, expr);\n         }\n         word(s.s, \".\");\n-        word(s.s, id);\n+        word(s.s, *id);\n         if vec::len(tys) > 0u {\n             word(s.s, \"::<\");\n             commasep(s, inconsistent, tys, print_type);\n@@ -1222,7 +1222,7 @@ fn print_decl(s: ps, decl: @ast::decl) {\n     }\n }\n \n-fn print_ident(s: ps, ident: ast::ident) { word(s.s, ident); }\n+fn print_ident(s: ps, ident: ast::ident) { word(s.s, *ident); }\n \n fn print_for_decl(s: ps, loc: @ast::local, coll: @ast::expr) {\n     print_local_decl(s, loc);\n@@ -1237,7 +1237,7 @@ fn print_path(s: ps, &&path: @ast::path, colons_before_params: bool) {\n     let mut first = true;\n     for path.idents.each {|id|\n         if first { first = false; } else { word(s.s, \"::\"); }\n-        word(s.s, id);\n+        word(s.s, *id);\n     }\n     if path.rp.is_some() || !path.types.is_empty() {\n         if colons_before_params { word(s.s, \"::\"); }\n@@ -1290,7 +1290,7 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n         word(s.s, \"{\");\n         fn print_field(s: ps, f: ast::field_pat) {\n             cbox(s, indent_unit);\n-            word(s.s, f.ident);\n+            word(s.s, *f.ident);\n             word_space(s, \":\");\n             print_pat(s, f.pat);\n             end(s);\n@@ -1327,7 +1327,7 @@ fn print_fn(s: ps, decl: ast::fn_decl, name: ast::ident,\n       ast::impure_fn { head(s, \"fn\") }\n       _ { head(s, purity_to_str(decl.purity) + \" fn\") }\n     }\n-    word(s.s, name);\n+    word(s.s, *name);\n     print_type_params(s, typarams);\n     print_fn_args_and_ret(s, decl, []);\n }\n@@ -1341,7 +1341,7 @@ fn print_fn_args(s: ps, decl: ast::fn_decl,\n             if first { first = false; } else { word_space(s, \",\"); }\n             if cap_item.is_move { word_nbsp(s, \"move\") }\n             else { word_nbsp(s, \"copy\") }\n-            word(s.s, cap_item.name);\n+            word(s.s, *cap_item.name);\n         }\n     }\n }\n@@ -1418,7 +1418,7 @@ fn print_type_params(s: ps, &&params: [ast::ty_param]) {\n     if vec::len(params) > 0u {\n         word(s.s, \"<\");\n         fn printParam(s: ps, param: ast::ty_param) {\n-            word(s.s, param.ident);\n+            word(s.s, *param.ident);\n             print_bounds(s, param.bounds);\n         }\n         commasep(s, inconsistent, params, printParam);\n@@ -1429,14 +1429,14 @@ fn print_type_params(s: ps, &&params: [ast::ty_param]) {\n fn print_meta_item(s: ps, &&item: @ast::meta_item) {\n     ibox(s, indent_unit);\n     alt item.node {\n-      ast::meta_word(name) { word(s.s, name); }\n+      ast::meta_word(name) { word(s.s, *name); }\n       ast::meta_name_value(name, value) {\n-        word_space(s, name);\n+        word_space(s, *name);\n         word_space(s, \"=\");\n         print_literal(s, @value);\n       }\n       ast::meta_list(name, items) {\n-        word(s.s, name);\n+        word(s.s, *name);\n         popen(s);\n         commasep(s, consistent, items, print_meta_item);\n         pclose(s);\n@@ -1449,7 +1449,7 @@ fn print_view_path(s: ps, &&vp: @ast::view_path) {\n     alt vp.node {\n       ast::view_path_simple(ident, path, _) {\n         if path.idents[vec::len(path.idents)-1u] != ident {\n-            word_space(s, ident);\n+            word_space(s, *ident);\n             word_space(s, \"=\");\n         }\n         print_path(s, path, false);\n@@ -1464,7 +1464,7 @@ fn print_view_path(s: ps, &&vp: @ast::view_path) {\n         print_path(s, path, false);\n         word(s.s, \"::{\");\n         commasep(s, inconsistent, idents) {|s, w|\n-            word(s.s, w.node.name)\n+            word(s.s, *w.node.name)\n         }\n         word(s.s, \"}\");\n       }\n@@ -1481,7 +1481,7 @@ fn print_view_item(s: ps, item: @ast::view_item) {\n     alt item.node {\n       ast::view_item_use(id, mta, _) {\n         head(s, \"use\");\n-        word(s.s, id);\n+        word(s.s, *id);\n         if vec::len(mta) > 0u {\n             popen(s);\n             commasep(s, consistent, mta, print_meta_item);\n@@ -1529,11 +1529,11 @@ fn print_arg(s: ps, input: ast::arg) {\n     print_arg_mode(s, input.mode);\n     alt input.ty.node {\n       ast::ty_infer {\n-        word(s.s, input.ident);\n+        word(s.s, *input.ident);\n       }\n       _ {\n-        if str::len(input.ident) > 0u {\n-            word_space(s, input.ident + \":\");\n+        if str::len(*input.ident) > 0u {\n+            word_space(s, *input.ident + \":\");\n         }\n         print_type(s, input.ty);\n       }\n@@ -1546,7 +1546,7 @@ fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n                tps: option<[ast::ty_param]>) {\n     ibox(s, indent_unit);\n     word(s.s, opt_proto_to_str(opt_proto));\n-    alt id { some(id) { word(s.s, \" \"); word(s.s, id); } _ { } }\n+    alt id { some(id) { word(s.s, \" \"); word(s.s, *id); } _ { } }\n     alt tps { some(tps) { print_type_params(s, tps); } _ { } }\n     zerobreak(s.s);\n     popen(s);\n@@ -1608,7 +1608,7 @@ fn print_literal(s: ps, &&lit: @ast::lit) {\n       _ {}\n     }\n     alt lit.node {\n-      ast::lit_str(st) { print_string(s, st); }\n+      ast::lit_str(st) { print_string(s, *st); }\n       ast::lit_int(ch, ast::ty_char) {\n         word(s.s, \"'\" + char::escape_default(ch as char) + \"'\");\n       }\n@@ -1640,7 +1640,7 @@ fn print_literal(s: ps, &&lit: @ast::lit) {\n         }\n       }\n       ast::lit_float(f, t) {\n-        word(s.s, f + ast_util::float_ty_to_str(t));\n+        word(s.s, *f + ast_util::float_ty_to_str(t));\n       }\n       ast::lit_nil { word(s.s, \"()\"); }\n       ast::lit_bool(val) {\n@@ -1804,7 +1804,7 @@ fn constrs_str<T>(constrs: [T], elt: fn(T) -> str) -> str {\n }\n \n fn fn_arg_idx_to_str(decl: ast::fn_decl, &&idx: uint) -> str {\n-    decl.inputs[idx].ident\n+    *decl.inputs[idx].ident\n }\n \n fn opt_proto_to_str(opt_p: option<ast::proto>) -> str {"}, {"sha": "8b70848b248b450f34c0115cf1fb33cd81f23f1d", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -29,8 +29,8 @@ fn name_of_fn(fk: fn_kind) -> ident {\n     alt fk {\n       fk_item_fn(name, _) | fk_method(name, _, _) | fk_res(name, _, _)\n           | fk_ctor(name, _, _, _) { /* FIXME: bad */ copy name }\n-      fk_anon(*) | fk_fn_block(*) { \"anon\" }\n-      fk_dtor(*)                  { \"drop\" }\n+      fk_anon(*) | fk_fn_block(*) { @\"anon\" }\n+      fk_dtor(*)                  { @\"drop\" }\n     }\n }\n "}, {"sha": "4eccfa80247a7340d0517c5db3c873945c850ef2", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -291,24 +291,24 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n                    sha: sha1) -> link_meta {\n \n     type provided_metas =\n-        {name: option<str>,\n-         vers: option<str>,\n+        {name: option<@str>,\n+         vers: option<@str>,\n          cmh_items: [@ast::meta_item]};\n \n     fn provided_link_metas(sess: session, c: ast::crate) ->\n        provided_metas {\n-        let mut name: option<str> = none;\n-        let mut vers: option<str> = none;\n+        let mut name: option<@str> = none;\n+        let mut vers: option<@str> = none;\n         let mut cmh_items: [@ast::meta_item] = [];\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess.diagnostic(), linkage_metas);\n         for linkage_metas.each {|meta|\n-            if attr::get_meta_item_name(meta) == \"name\" {\n+            if *attr::get_meta_item_name(meta) == \"name\" {\n                 alt attr::get_meta_item_value_str(meta) {\n                   some(v) { name = some(v); }\n                   none { cmh_items += [meta]; }\n                 }\n-            } else if attr::get_meta_item_name(meta) == \"vers\" {\n+            } else if *attr::get_meta_item_name(meta) == \"vers\" {\n                 alt attr::get_meta_item_value_str(meta) {\n                   some(v) { vers = some(v); }\n                   none { cmh_items += [meta]; }\n@@ -321,7 +321,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n     // This calculates CMH as defined above\n     fn crate_meta_extras_hash(sha: sha1, _crate: ast::crate,\n                               metas: provided_metas,\n-                              dep_hashes: [str]) -> str {\n+                              dep_hashes: [@str]) -> str {\n         fn len_and_str(s: str) -> str {\n             ret #fmt[\"%u_%s\", str::len(s), s];\n         }\n@@ -337,10 +337,10 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n             let m = m_;\n             alt m.node {\n               ast::meta_name_value(key, value) {\n-                sha.input_str(len_and_str(key));\n+                sha.input_str(len_and_str(*key));\n                 sha.input_str(len_and_str_lit(value));\n               }\n-              ast::meta_word(name) { sha.input_str(len_and_str(name)); }\n+              ast::meta_word(name) { sha.input_str(len_and_str(*name)); }\n               ast::meta_list(_, _) {\n                 // FIXME (#607): Implement this\n                 fail \"unimplemented meta_item variant\";\n@@ -349,7 +349,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n         }\n \n         for dep_hashes.each {|dh|\n-            sha.input_str(len_and_str(dh));\n+            sha.input_str(len_and_str(*dh));\n         }\n \n         ret truncated_sha1_result(sha);\n@@ -362,7 +362,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n     }\n \n     fn crate_meta_name(sess: session, _crate: ast::crate,\n-                       output: str, metas: provided_metas) -> str {\n+                       output: str, metas: provided_metas) -> @str {\n         ret alt metas.name {\n               some(v) { v }\n               none {\n@@ -378,19 +378,19 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n                         str::connect(os, \".\")\n                     };\n                 warn_missing(sess, \"name\", name);\n-                name\n+                @name\n               }\n             };\n     }\n \n     fn crate_meta_vers(sess: session, _crate: ast::crate,\n-                       metas: provided_metas) -> str {\n+                       metas: provided_metas) -> @str {\n         ret alt metas.vers {\n               some(v) { v }\n               none {\n                 let vers = \"0.0\";\n                 warn_missing(sess, \"vers\", vers);\n-                vers\n+                @vers\n               }\n             };\n     }\n@@ -417,7 +417,7 @@ fn symbol_hash(tcx: ty::ctxt, sha: sha1, t: ty::t,\n     // to be independent of one another in the crate.\n \n     sha.reset();\n-    sha.input_str(link_meta.name);\n+    sha.input_str(*link_meta.name);\n     sha.input_str(\"-\");\n     sha.input_str(link_meta.extras_hash);\n     sha.input_str(\"-\");\n@@ -482,41 +482,42 @@ fn mangle(ss: path) -> str {\n \n     for ss.each {|s|\n         alt s { path_name(s) | path_mod(s) {\n-          let sani = sanitize(s);\n+          let sani = sanitize(*s);\n           n += #fmt[\"%u%s\", str::len(sani), sani];\n         } }\n     }\n     n += \"E\"; // End name-sequence.\n     n\n }\n \n-fn exported_name(path: path, hash: str, vers: str) -> str {\n+fn exported_name(path: path, hash: @str, vers: @str) -> str {\n     ret mangle(path + [path_name(hash)] + [path_name(vers)]);\n }\n \n fn mangle_exported_name(ccx: @crate_ctxt, path: path, t: ty::t) -> str {\n     let hash = get_symbol_hash(ccx, t);\n-    ret exported_name(path, hash, ccx.link_meta.vers);\n+    ret exported_name(path, @hash, ccx.link_meta.vers);\n }\n \n-fn mangle_internal_name_by_type_only(ccx: @crate_ctxt, t: ty::t, name: str) ->\n+fn mangle_internal_name_by_type_only(ccx: @crate_ctxt,\n+                                     t: ty::t, name: @str) ->\n    str {\n-    let s = util::ppaux::ty_to_short_str(ccx.tcx, t);\n+    let s = @util::ppaux::ty_to_short_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);\n-    ret mangle([path_name(name), path_name(s), path_name(hash)]);\n+    ret mangle([path_name(name), path_name(s), path_name(@hash)]);\n }\n \n fn mangle_internal_name_by_path_and_seq(ccx: @crate_ctxt, path: path,\n-                                        flav: str) -> str {\n-    ret mangle(path + [path_name(ccx.names(flav))]);\n+                                        flav: @str) -> str {\n+    ret mangle(path + [path_name(@ccx.names(*flav))]);\n }\n \n fn mangle_internal_name_by_path(_ccx: @crate_ctxt, path: path) -> str {\n     ret mangle(path);\n }\n \n-fn mangle_internal_name_by_seq(ccx: @crate_ctxt, flav: str) -> str {\n-    ret ccx.names(flav);\n+fn mangle_internal_name_by_seq(ccx: @crate_ctxt, flav: @str) -> str {\n+    ret ccx.names(*flav);\n }\n \n // If the user wants an exe generated we need to invoke\n@@ -552,8 +553,8 @@ fn link_binary(sess: session,\n     let output = if sess.building_library {\n         let long_libname =\n             os::dll_filename(#fmt(\"%s-%s-%s\",\n-                                  lm.name, lm.extras_hash, lm.vers));\n-        #debug(\"link_meta.name:  %s\", lm.name);\n+                                  *lm.name, lm.extras_hash, *lm.vers));\n+        #debug(\"link_meta.name:  %s\", *lm.name);\n         #debug(\"long_libname: %s\", long_libname);\n         #debug(\"out_filename: %s\", out_filename);\n         #debug(\"dirname(out_filename): %s\", path::dirname(out_filename));"}, {"sha": "550e2290bfae806a4a94cc79164b6fcce3cffe63", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -49,14 +49,14 @@ fn default_configuration(sess: session, argv0: str, input: input) ->\n     };\n \n     ret [ // Target bindings.\n-         attr::mk_word_item(os::family()),\n-         mk(\"target_os\", os::sysname()),\n-         mk(\"target_family\", os::family()),\n-         mk(\"target_arch\", arch),\n-         mk(\"target_libc\", libc),\n+         attr::mk_word_item(@os::family()),\n+         mk(@\"target_os\", os::sysname()),\n+         mk(@\"target_family\", os::family()),\n+         mk(@\"target_arch\", arch),\n+         mk(@\"target_libc\", libc),\n          // Build bindings.\n-         mk(\"build_compiler\", argv0),\n-         mk(\"build_input\", source_name(input))];\n+         mk(@\"build_compiler\", argv0),\n+         mk(@\"build_input\", source_name(input))];\n }\n \n fn build_configuration(sess: session, argv0: str, input: input) ->\n@@ -70,7 +70,7 @@ fn build_configuration(sess: session, argv0: str, input: input) ->\n         {\n             if sess.opts.test && !attr::contains_name(user_cfg, \"test\")\n                {\n-                [attr::mk_word_item(\"test\")]\n+                [attr::mk_word_item(@\"test\")]\n             } else { [] }\n         };\n     ret user_cfg + gen_cfg + default_cfg;\n@@ -82,7 +82,7 @@ fn parse_cfgspecs(cfgspecs: [str]) -> ast::crate_cfg {\n     // meta_item here. At the moment we just support the meta_word variant.\n     // #2399\n     let mut words = [];\n-    for cfgspecs.each {|s| words += [attr::mk_word_item(s)]; }\n+    for cfgspecs.each {|s| words += [attr::mk_word_item(@s)]; }\n     ret words;\n }\n "}, {"sha": "ef37c2bea51be304dc454ea0014b6cf32bd674b1", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -199,7 +199,7 @@ fn building_library(req_crate_type: crate_type, crate: @ast::crate,\n             alt syntax::attr::first_attr_value_str_by_name(\n                 crate.node.attrs,\n                 \"crate_type\") {\n-              option::some(\"lib\") { true }\n+              option::some(@\"lib\") { true }\n               _ { false }\n             }\n         }\n@@ -227,9 +227,9 @@ mod test {\n             style: ast::attr_outer,\n             value: ast_util::respan(ast_util::dummy_sp(),\n                 ast::meta_name_value(\n-                    \"crate_type\",\n+                    @\"crate_type\",\n                     ast_util::respan(ast_util::dummy_sp(),\n-                                     ast::lit_str(t))))\n+                                     ast::lit_str(@t))))\n         })\n     }\n "}, {"sha": "bc7048f8f0976764a4194bad0b36c6ff83c9b16b", "filename": "src/rustc/front/core_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fcore_inject.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -30,11 +30,11 @@ fn inject_libcore_ref(sess: session,\n     let n1 = sess.next_node_id();\n     let n2 = sess.next_node_id();\n \n-    let vi1 = @{node: ast::view_item_use(\"core\", [], n1),\n+    let vi1 = @{node: ast::view_item_use(@\"core\", [], n1),\n                 attrs: [],\n                 vis: ast::public,\n                 span: dummy_sp()};\n-    let vp = spanned(ast::view_path_glob(ident_to_path(dummy_sp(), \"core\"),\n+    let vp = spanned(ast::view_path_glob(ident_to_path(dummy_sp(), @\"core\"),\n                                          n2));\n     let vi2 = @{node: ast::view_item_import([vp]),\n                 attrs: [],"}, {"sha": "44b9356896beb684b7b82dc2eea17aa596cfcdab", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -70,7 +70,7 @@ fn fold_mod(_cx: test_ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n     fn nomain(&&item: @ast::item) -> option<@ast::item> {\n         alt item.node {\n           ast::item_fn(_, _, _) {\n-            if item.ident == \"main\" {\n+            if *item.ident == \"main\" {\n                 option::none\n             } else { option::some(item) }\n           }\n@@ -190,9 +190,9 @@ fn mk_test_module(cx: test_ctxt) -> @ast::item {\n     let item_ = ast::item_mod(testmod);\n     // This attribute tells resolve to let us call unexported functions\n     let resolve_unexported_attr =\n-        attr::mk_attr(attr::mk_word_item(\"!resolve_unexported\"));\n+        attr::mk_attr(attr::mk_word_item(@\"!resolve_unexported\"));\n     let item: ast::item =\n-        {ident: \"__test\",\n+        {ident: @\"__test\",\n          attrs: [resolve_unexported_attr],\n          id: cx.sess.next_node_id(),\n          node: item_,\n@@ -231,7 +231,7 @@ fn mk_tests(cx: test_ctxt) -> @ast::item {\n \n     let item_ = ast::item_fn(decl, [], body);\n     let item: ast::item =\n-        {ident: \"tests\",\n+        {ident: @\"tests\",\n          attrs: [],\n          id: cx.sess.next_node_id(),\n          node: item_,\n@@ -246,16 +246,16 @@ fn mk_path(cx: test_ctxt, path: [ast::ident]) -> [ast::ident] {\n     let is_std = {\n         let items = attr::find_linkage_metas(cx.crate.node.attrs);\n         alt attr::last_meta_item_value_str_by_name(items, \"name\") {\n-          some(\"std\") { true }\n+          some(@\"std\") { true }\n           _ { false }\n         }\n     };\n-    (if is_std { [] } else { [\"std\"] }) + path\n+    (if is_std { [] } else { [@\"std\"] }) + path\n }\n \n // The ast::ty of [std::test::test_desc]\n fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::ty {\n-    let test_desc_ty_path = path_node(mk_path(cx, [\"test\", \"test_desc\"]));\n+    let test_desc_ty_path = path_node(mk_path(cx, [@\"test\", @\"test_desc\"]));\n \n     let test_desc_ty: ast::ty =\n         {id: cx.sess.next_node_id(),\n@@ -288,14 +288,14 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n     #debug(\"encoding %s\", ast_util::path_name_i(path));\n \n     let name_lit: ast::lit =\n-        nospan(ast::lit_str(ast_util::path_name_i(path)));\n+        nospan(ast::lit_str(@ast_util::path_name_i(path)));\n     let name_expr: ast::expr =\n         {id: cx.sess.next_node_id(),\n          node: ast::expr_lit(@name_lit),\n          span: span};\n \n     let name_field: ast::field =\n-        nospan({mutbl: ast::m_imm, ident: \"name\", expr: @name_expr});\n+        nospan({mutbl: ast::m_imm, ident: @\"name\", expr: @name_expr});\n \n     let fn_path = path_node(path);\n \n@@ -307,7 +307,7 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n     let fn_wrapper_expr = mk_test_wrapper(cx, fn_expr, span);\n \n     let fn_field: ast::field =\n-        nospan({mutbl: ast::m_imm, ident: \"fn\", expr: fn_wrapper_expr});\n+        nospan({mutbl: ast::m_imm, ident: @\"fn\", expr: fn_wrapper_expr});\n \n     let ignore_lit: ast::lit = nospan(ast::lit_bool(test.ignore));\n \n@@ -317,7 +317,7 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n          span: span};\n \n     let ignore_field: ast::field =\n-        nospan({mutbl: ast::m_imm, ident: \"ignore\", expr: @ignore_expr});\n+        nospan({mutbl: ast::m_imm, ident: @\"ignore\", expr: @ignore_expr});\n \n     let fail_lit: ast::lit = nospan(ast::lit_bool(test.should_fail));\n \n@@ -327,7 +327,7 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n          span: span};\n \n     let fail_field: ast::field =\n-        nospan({mutbl: ast::m_imm, ident: \"should_fail\", expr: @fail_expr});\n+        nospan({mutbl: ast::m_imm, ident: @\"should_fail\", expr: @fail_expr});\n \n     let desc_rec_: ast::expr_ =\n         ast::expr_rec([name_field, fn_field, ignore_field, fail_field],\n@@ -379,7 +379,7 @@ fn mk_test_wrapper(cx: test_ctxt,\n }\n \n fn mk_main(cx: test_ctxt) -> @ast::item {\n-    let str_pt = path_node([\"str\"]);\n+    let str_pt = path_node([@\"str\"]);\n     let str_ty = @{id: cx.sess.next_node_id(),\n                    node: ast::ty_path(str_pt, cx.sess.next_node_id()),\n                    span: dummy_sp()};\n@@ -391,7 +391,7 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n     let args_arg: ast::arg =\n         {mode: ast::expl(ast::by_val),\n          ty: @args_ty,\n-         ident: \"args\",\n+         ident: @\"args\",\n          id: cx.sess.next_node_id()};\n \n     let ret_ty = {id: cx.sess.next_node_id(),\n@@ -414,7 +414,7 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n \n     let item_ = ast::item_fn(decl, [], body);\n     let item: ast::item =\n-        {ident: \"main\",\n+        {ident: @\"main\",\n          attrs: [],\n          id: cx.sess.next_node_id(),\n          node: item_,\n@@ -426,15 +426,15 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n fn mk_test_main_call(cx: test_ctxt) -> @ast::expr {\n \n     // Get the args passed to main so we can pass the to test_main\n-    let args_path = path_node([\"args\"]);\n+    let args_path = path_node([@\"args\"]);\n \n     let args_path_expr_: ast::expr_ = ast::expr_path(args_path);\n \n     let args_path_expr: ast::expr =\n         {id: cx.sess.next_node_id(), node: args_path_expr_, span: dummy_sp()};\n \n     // Call __test::test to generate the vector of test_descs\n-    let test_path = path_node([\"tests\"]);\n+    let test_path = path_node([@\"tests\"]);\n \n     let test_path_expr_: ast::expr_ = ast::expr_path(test_path);\n \n@@ -447,7 +447,7 @@ fn mk_test_main_call(cx: test_ctxt) -> @ast::expr {\n         {id: cx.sess.next_node_id(), node: test_call_expr_, span: dummy_sp()};\n \n     // Call std::test::test_main\n-    let test_main_path = path_node(mk_path(cx, [\"test\", \"test_main\"]));\n+    let test_main_path = path_node(mk_path(cx, [@\"test\", @\"test_main\"]));\n \n     let test_main_path_expr_: ast::expr_ = ast::expr_path(test_main_path);\n "}, {"sha": "9aa7748c5a4c0250ab41c4a766d778ef942b18a8", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -132,5 +132,5 @@ fn hash_path(&&s: str) -> uint {\n     ret h;\n }\n \n-type link_meta = {name: str, vers: str, extras_hash: str};\n+type link_meta = {name: @str, vers: @str, extras_hash: str};\n "}, {"sha": "fbb6a18edcde24b2311eff3d6c1c6992f603cfea", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -42,7 +42,7 @@ fn read_crates(diag: span_handler, crate: ast::crate,\n type cache_entry = {\n     cnum: int,\n     span: span,\n-    hash: str,\n+    hash: @str,\n     metas: @[@ast::meta_item]\n };\n \n@@ -53,7 +53,7 @@ fn dump_crates(crate_cache: dvec<cache_entry>) {\n         #debug(\"span: %?\", entry.span);\n         #debug(\"hash: %?\", entry.hash);\n         let attrs = [\n-            attr::mk_attr(attr::mk_list_item(\"link\", *entry.metas))\n+            attr::mk_attr(attr::mk_list_item(@\"link\", *entry.metas))\n         ];\n         for attr::find_linkage_attrs(attrs).each {|attr|\n             #debug(\"meta: %s\", pprust::attr_to_str(attr));\n@@ -81,11 +81,11 @@ fn warn_if_multiple_versions(diag: span_handler,\n \n         if matches.len() != 1u {\n             diag.handler().warn(\n-                #fmt(\"using multiple versions of crate `%s`\", name));\n+                #fmt(\"using multiple versions of crate `%s`\", *name));\n             for matches.each {|match|\n                 diag.span_note(match.span, \"used here\");\n                 let attrs = [\n-                    attr::mk_attr(attr::mk_list_item(\"link\", *match.metas))\n+                    attr::mk_attr(attr::mk_list_item(@\"link\", *match.metas))\n                 ];\n                 loader::note_linkage_attrs(diag, attrs);\n             }\n@@ -129,7 +129,7 @@ fn visit_item(e: env, i: @ast::item) {\n         let native_name =\n             alt attr::first_attr_value_str_by_name(i.attrs, \"link_name\") {\n               some(nn) {\n-                if nn == \"\" {\n+                if *nn == \"\" {\n                     e.diag.span_fatal(\n                         i.span,\n                         \"empty #[link_name] not allowed; use #[nolink].\");\n@@ -140,17 +140,17 @@ fn visit_item(e: env, i: @ast::item) {\n             };\n         let mut already_added = false;\n         if vec::len(attr::find_attrs_by_name(i.attrs, \"nolink\")) == 0u {\n-            already_added = !cstore::add_used_library(cstore, native_name);\n+            already_added = !cstore::add_used_library(cstore, *native_name);\n         }\n         let link_args = attr::find_attrs_by_name(i.attrs, \"link_args\");\n         if vec::len(link_args) > 0u && already_added {\n-            e.diag.span_fatal(i.span, \"library '\" + native_name +\n+            e.diag.span_fatal(i.span, \"library '\" + *native_name +\n                               \"' already added: can't specify link_args.\");\n         }\n         for link_args.each {|a|\n             alt attr::get_meta_item_value_str(attr::attr_meta(a)) {\n               some(linkarg) {\n-                cstore::add_used_link_args(cstore, linkarg);\n+                cstore::add_used_link_args(cstore, *linkarg);\n               }\n               none {/* fallthrough */ }\n             }\n@@ -160,27 +160,27 @@ fn visit_item(e: env, i: @ast::item) {\n     }\n }\n \n-fn metas_with(ident: ast::ident, key: str,\n+fn metas_with(ident: ast::ident, key: ast::ident,\n                     metas: [@ast::meta_item]) -> [@ast::meta_item] {\n-    let name_items = attr::find_meta_items_by_name(metas, key);\n+    let name_items = attr::find_meta_items_by_name(metas, *key);\n     if name_items.is_empty() {\n-        metas + [attr::mk_name_value_item_str(key, ident)]\n+        metas + [attr::mk_name_value_item_str(key, *ident)]\n     } else {\n         metas\n     }\n }\n \n fn metas_with_ident(ident: ast::ident,\n                     metas: [@ast::meta_item]) -> [@ast::meta_item] {\n-    metas_with(ident, \"name\", metas)\n+    metas_with(ident, @\"name\", metas)\n }\n \n fn existing_match(e: env, metas: [@ast::meta_item], hash: str) ->\n     option<int> {\n \n     for e.crate_cache.each {|c|\n         if loader::metadata_matches(*c.metas, metas)\n-            && (hash.is_empty() || c.hash == hash) {\n+            && (hash.is_empty() || *c.hash == hash) {\n             ret some(c.cnum);\n         }\n     }\n@@ -226,7 +226,7 @@ fn resolve_crate(e: env, ident: ast::ident, metas: [@ast::meta_item],\n               option::some(v) { v }\n               option::none { ident }\n             };\n-        let cmeta = @{name: cname, data: cdata,\n+        let cmeta = @{name: *cname, data: cdata,\n                       cnum_map: cnum_map, cnum: cnum};\n \n         let cstore = e.cstore;\n@@ -249,10 +249,10 @@ fn resolve_crate_deps(e: env, cdata: @[u8]) -> cstore::cnum_map {\n     for decoder::get_crate_deps(cdata).each {|dep|\n         let extrn_cnum = dep.cnum;\n         let cname = dep.name;\n-        let cmetas = metas_with(dep.vers, \"vers\", []);\n+        let cmetas = metas_with(dep.vers, @\"vers\", []);\n         #debug(\"resolving dep crate %s ver: %s hash: %s\",\n-               dep.name, dep.vers, dep.hash);\n-        alt existing_match(e, metas_with_ident(cname, cmetas), dep.hash) {\n+               *dep.name, *dep.vers, *dep.hash);\n+        alt existing_match(e, metas_with_ident(cname, cmetas), *dep.hash) {\n           some(local_cnum) {\n             #debug(\"already have it\");\n             // We've already seen this crate\n@@ -265,7 +265,7 @@ fn resolve_crate_deps(e: env, cdata: @[u8]) -> cstore::cnum_map {\n             // #2404\n             let fake_span = ast_util::dummy_sp();\n             let local_cnum =\n-                resolve_crate(e, cname, cmetas, dep.hash, fake_span);\n+                resolve_crate(e, cname, cmetas, *dep.hash, fake_span);\n             cnum_map.insert(extrn_cnum, local_cnum);\n           }\n         }"}, {"sha": "f65f6110388fa8afbd264b11614db88d9fae6966", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -64,7 +64,7 @@ fn resolve_path(cstore: cstore::cstore, cnum: ast::crate_num,\n     [(ast::crate_num, @[u8], ast::def_id)] {\n     let cm = cstore::get_crate_data(cstore, cnum);\n     #debug(\"resolve_path %s in crates[%d]:%s\",\n-           str::connect(path, \"::\"), cnum, cm.name);\n+           ast_util::path_name_i(path), cnum, cm.name);\n     let mut result = [];\n     for decoder::resolve_path(path, cm.data).each {|def|\n         if def.crate == ast::local_crate {\n@@ -88,7 +88,7 @@ fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n-    [ast_map::path_mod(cdata.name)] + path\n+    [ast_map::path_mod(@cdata.name)] + path\n }\n \n enum found_ast {\n@@ -170,7 +170,8 @@ fn get_impl_iface(tcx: ty::ctxt, def: ast::def_id) -> option<ty::t> {\n     decoder::get_impl_iface(cdata, def.node, tcx)\n }\n \n-fn get_impl_method(cstore: cstore::cstore, def: ast::def_id, mname: str)\n+fn get_impl_method(cstore: cstore::cstore,\n+                   def: ast::def_id, mname: ast::ident)\n     -> ast::def_id {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_impl_method(cdata, def.node, mname)\n@@ -180,7 +181,8 @@ fn get_impl_method(cstore: cstore::cstore, def: ast::def_id, mname: str)\n    for their methods (so that get_iface_methods can be reused to get\n    class methods), classes require a slightly different version of\n    get_impl_method. Sigh. */\n-fn get_class_method(cstore: cstore::cstore, def: ast::def_id, mname: str)\n+fn get_class_method(cstore: cstore::cstore,\n+                    def: ast::def_id, mname: ast::ident)\n     -> ast::def_id {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_class_method(cdata, def.node, mname)"}, {"sha": "ebfa8df3b109dff7016de29778d23be4d1160729", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -37,7 +37,7 @@ type cnum_map = map::hashmap<ast::crate_num, ast::crate_num>;\n // Multiple items may have the same def_id in crate metadata. They may be\n // renamed imports or reexports. This map keeps the \"real\" module path\n // and def_id.\n-type mod_path_map = map::hashmap<ast::def_id, str>;\n+type mod_path_map = map::hashmap<ast::def_id, @str>;\n \n type crate_metadata = @{name: str,\n                         data: @[u8],\n@@ -83,12 +83,12 @@ fn get_crate_data(cstore: cstore, cnum: ast::crate_num) -> crate_metadata {\n     ret p(cstore).metas.get(cnum);\n }\n \n-fn get_crate_hash(cstore: cstore, cnum: ast::crate_num) -> str {\n+fn get_crate_hash(cstore: cstore, cnum: ast::crate_num) -> @str {\n     let cdata = get_crate_data(cstore, cnum);\n     ret decoder::get_crate_hash(cdata.data);\n }\n \n-fn get_crate_vers(cstore: cstore, cnum: ast::crate_num) -> str {\n+fn get_crate_vers(cstore: cstore, cnum: ast::crate_num) -> @str {\n     let cdata = get_crate_data(cstore, cnum);\n     ret decoder::get_crate_vers(cdata.data);\n }\n@@ -99,7 +99,7 @@ fn set_crate_data(cstore: cstore, cnum: ast::crate_num,\n     vec::iter(decoder::get_crate_module_paths(data.data)) {|dp|\n         let (did, path) = dp;\n         let d = {crate: cnum, node: did.node};\n-        p(cstore).mod_path_map.insert(d, path);\n+        p(cstore).mod_path_map.insert(d, @path);\n     }\n }\n \n@@ -153,32 +153,32 @@ fn find_use_stmt_cnum(cstore: cstore,\n \n // returns hashes of crates directly used by this crate. Hashes are\n // sorted by crate name.\n-fn get_dep_hashes(cstore: cstore) -> [str] {\n-    type crate_hash = {name: str, hash: str};\n+fn get_dep_hashes(cstore: cstore) -> [@str] {\n+    type crate_hash = {name: @str, hash: @str};\n     let mut result = [];\n \n     for p(cstore).use_crate_map.each_value {|cnum|\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n-        #debug(\"Add hash[%s]: %s\", cdata.name, hash);\n-        result += [{name: cdata.name, hash: hash}];\n+        #debug(\"Add hash[%s]: %s\", cdata.name, *hash);\n+        result += [{name: @cdata.name, hash: hash}];\n     };\n     fn lteq(a: crate_hash, b: crate_hash) -> bool {\n-        ret a.name <= b.name;\n+        ret *a.name <= *b.name;\n     }\n     let sorted = std::sort::merge_sort(lteq, result);\n     #debug(\"sorted:\");\n     for sorted.each {|x|\n-        #debug(\"  hash[%s]: %s\", x.name, x.hash);\n+        #debug(\"  hash[%s]: %s\", *x.name, *x.hash);\n     }\n-    fn mapper(ch: crate_hash) -> str { ret ch.hash; }\n+    fn mapper(ch: crate_hash) -> @str { ret ch.hash; }\n     ret vec::map(sorted, mapper);\n }\n \n-fn get_path(cstore: cstore, d: ast::def_id) -> [str] {\n+fn get_path(cstore: cstore, d: ast::def_id) -> [ast::ident] {\n     // let f = bind str::split_str(_, \"::\");\n     option::map_default(p(cstore).mod_path_map.find(d), [],\n-                  {|ds| str::split_str(ds, \"::\")})\n+                        {|ds| str::split_str(*ds, \"::\").map({|x|@x})})\n }\n // Local Variables:\n // mode: rust"}, {"sha": "9ae0fa9842f953011be0d4a6d3f57a86da73413f", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -210,7 +210,7 @@ fn resolve_path(path: [ast::ident], data: @[u8]) -> [ast::def_id] {\n     fn eq_item(data: [u8], s: str) -> bool {\n         ret str::eq(str::from_bytes(data), s);\n     }\n-    let s = str::connect(path, \"::\");\n+    let s = ast_util::path_name_i(path);\n     let md = ebml::doc(data);\n     let paths = ebml::get_doc(md, tag_paths);\n     let eqer = bind eq_item(_, s);\n@@ -235,10 +235,10 @@ fn item_path(item_doc: ebml::doc) -> ast_map::path {\n     ebml::docs(path_doc) {|tag, elt_doc|\n         if tag == tag_path_elt_mod {\n             let str = ebml::doc_as_str(elt_doc);\n-            result += [ast_map::path_mod(str)];\n+            result += [ast_map::path_mod(@str)];\n         } else if tag == tag_path_elt_name {\n             let str = ebml::doc_as_str(elt_doc);\n-            result += [ast_map::path_name(str)];\n+            result += [ast_map::path_name(@str)];\n         } else {\n             // ignore tag_path_len element\n         }\n@@ -249,7 +249,7 @@ fn item_path(item_doc: ebml::doc) -> ast_map::path {\n \n fn item_name(item: ebml::doc) -> ast::ident {\n     let name = ebml::get_doc(item, tag_paths_data_name);\n-    str::from_bytes(ebml::doc_data(name))\n+    @str::from_bytes(ebml::doc_data(name))\n }\n \n fn lookup_item_name(data: @[u8], id: ast::node_id) -> ast::ident {\n@@ -302,7 +302,8 @@ fn get_impl_iface(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     item_impl_iface(lookup_item(id, cdata.data), tcx, cdata)\n }\n \n-fn get_impl_method(cdata: cmd, id: ast::node_id, name: str) -> ast::def_id {\n+fn get_impl_method(cdata: cmd, id: ast::node_id,\n+                   name: ast::ident) -> ast::def_id {\n     let items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n     let mut found = none;\n     ebml::tagged_docs(find_item(id, items), tag_item_impl_method) {|mid|\n@@ -314,13 +315,14 @@ fn get_impl_method(cdata: cmd, id: ast::node_id, name: str) -> ast::def_id {\n     option::get(found)\n }\n \n-fn get_class_method(cdata: cmd, id: ast::node_id, name: str) -> ast::def_id {\n+fn get_class_method(cdata: cmd, id: ast::node_id,\n+                    name: ast::ident) -> ast::def_id {\n     let items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n     let mut found = none;\n     let cls_items = alt maybe_find_item(id, items) {\n             some(it) { it }\n             none { fail (#fmt(\"get_class_method: class id not found \\\n-             when looking up method %s\", name)) }};\n+             when looking up method %s\", *name)) }};\n     ebml::tagged_docs(cls_items, tag_item_iface_method) {|mid|\n         let m_did = class_member_id(mid, cdata);\n         if item_name(mid) == name {\n@@ -329,7 +331,7 @@ fn get_class_method(cdata: cmd, id: ast::node_id, name: str) -> ast::def_id {\n     }\n     alt found {\n       some(found) { found }\n-      none { fail (#fmt(\"get_class_method: no method named %s\", name)) }\n+      none { fail (#fmt(\"get_class_method: no method named %s\", *name)) }\n     }\n }\n \n@@ -574,7 +576,7 @@ fn get_meta_items(md: ebml::doc) -> [@ast::meta_item] {\n     ebml::tagged_docs(md, tag_meta_item_word) {|meta_item_doc|\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::from_bytes(ebml::doc_data(nd));\n-        items += [attr::mk_word_item(n)];\n+        items += [attr::mk_word_item(@n)];\n     };\n     ebml::tagged_docs(md, tag_meta_item_name_value) {|meta_item_doc|\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n@@ -583,13 +585,13 @@ fn get_meta_items(md: ebml::doc) -> [@ast::meta_item] {\n         let v = str::from_bytes(ebml::doc_data(vd));\n         // FIXME (#623): Should be able to decode meta_name_value variants,\n         // but currently the encoder just drops them\n-        items += [attr::mk_name_value_item_str(n, v)];\n+        items += [attr::mk_name_value_item_str(@n, v)];\n     };\n     ebml::tagged_docs(md, tag_meta_item_list) {|meta_item_doc|\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::from_bytes(ebml::doc_data(nd));\n         let subitems = get_meta_items(meta_item_doc);\n-        items += [attr::mk_list_item(n, subitems)];\n+        items += [attr::mk_list_item(@n, subitems)];\n     };\n     ret items;\n }\n@@ -620,8 +622,8 @@ fn list_meta_items(meta_items: ebml::doc, out: io::writer) {\n     }\n }\n \n-fn list_crate_attributes(md: ebml::doc, hash: str, out: io::writer) {\n-    out.write_str(#fmt(\"=Crate Attributes (%s)=\\n\", hash));\n+fn list_crate_attributes(md: ebml::doc, hash: @str, out: io::writer) {\n+    out.write_str(#fmt(\"=Crate Attributes (%s)=\\n\", *hash));\n \n     for get_attributes(md).each {|attr|\n         out.write_str(#fmt[\"%s\\n\", pprust::attribute_to_str(attr)]);\n@@ -635,7 +637,7 @@ fn get_crate_attributes(data: @[u8]) -> [ast::attribute] {\n }\n \n type crate_dep = {cnum: ast::crate_num, name: ast::ident,\n-                  vers: str, hash: str};\n+                  vers: @str, hash: @str};\n \n fn get_crate_deps(data: @[u8]) -> [crate_dep] {\n     let mut deps: [crate_dep] = [];\n@@ -647,9 +649,9 @@ fn get_crate_deps(data: @[u8]) -> [crate_dep] {\n     }\n     ebml::tagged_docs(depsdoc, tag_crate_dep) {|depdoc|\n         deps += [{cnum: crate_num,\n-                  name: docstr(depdoc, tag_crate_dep_name),\n-                  vers: docstr(depdoc, tag_crate_dep_vers),\n-                  hash: docstr(depdoc, tag_crate_dep_hash)}];\n+                  name: @docstr(depdoc, tag_crate_dep_name),\n+                  vers: @docstr(depdoc, tag_crate_dep_vers),\n+                  hash: @docstr(depdoc, tag_crate_dep_hash)}];\n         crate_num += 1;\n     };\n     ret deps;\n@@ -660,24 +662,24 @@ fn list_crate_deps(data: @[u8], out: io::writer) {\n \n     for get_crate_deps(data).each {|dep|\n         out.write_str(#fmt[\"%d %s-%s-%s\\n\",\n-                           dep.cnum, dep.name, dep.hash, dep.vers]);\n+                           dep.cnum, *dep.name, *dep.hash, *dep.vers]);\n     }\n \n     out.write_str(\"\\n\");\n }\n \n-fn get_crate_hash(data: @[u8]) -> str {\n+fn get_crate_hash(data: @[u8]) -> @str {\n     let cratedoc = ebml::doc(data);\n     let hashdoc = ebml::get_doc(cratedoc, tag_crate_hash);\n-    ret str::from_bytes(ebml::doc_data(hashdoc));\n+    ret @str::from_bytes(ebml::doc_data(hashdoc));\n }\n \n-fn get_crate_vers(data: @[u8]) -> str {\n+fn get_crate_vers(data: @[u8]) -> @str {\n     let attrs = decoder::get_crate_attributes(data);\n     ret alt attr::last_meta_item_value_str_by_name(\n         attr::find_linkage_metas(attrs), \"vers\") {\n       some(ver) { ver }\n-      none { \"0.0\" }\n+      none { @\"0.0\" }\n     };\n }\n "}, {"sha": "e10554c79edf03f16353fdadfd1c38ef74155851", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -71,8 +71,8 @@ fn reachable(ecx: @encode_ctxt, id: node_id) -> bool {\n }\n \n // Path table encoding\n-fn encode_name(ebml_w: ebml::writer, name: str) {\n-    ebml_w.wr_tagged_str(tag_paths_data_name, name);\n+fn encode_name(ebml_w: ebml::writer, name: ident) {\n+    ebml_w.wr_tagged_str(tag_paths_data_name, *name);\n }\n \n fn encode_def_id(ebml_w: ebml::writer, id: def_id) {\n@@ -92,7 +92,7 @@ fn encode_region_param(ebml_w: ebml::writer, rp: region_param) {\n     }\n }\n \n-fn encode_named_def_id(ebml_w: ebml::writer, name: str, id: def_id) {\n+fn encode_named_def_id(ebml_w: ebml::writer, name: ident, id: def_id) {\n     ebml_w.wr_tag(tag_paths_data_item) {||\n         encode_name(ebml_w, name);\n         encode_def_id(ebml_w, id);\n@@ -109,7 +109,7 @@ fn encode_mutability(ebml_w: ebml::writer, mt: class_mutability) {\n type entry<T> = {val: T, pos: uint};\n \n fn encode_enum_variant_paths(ebml_w: ebml::writer, variants: [variant],\n-                            path: [str], &index: [entry<str>]) {\n+                            path: [ident], &index: [entry<str>]) {\n     for variants.each {|variant|\n         add_to_index(ebml_w, path, index, variant.node.name);\n         ebml_w.wr_tag(tag_paths_data_item) {||\n@@ -119,23 +119,23 @@ fn encode_enum_variant_paths(ebml_w: ebml::writer, variants: [variant],\n     }\n }\n \n-fn add_to_index(ebml_w: ebml::writer, path: [str], &index: [entry<str>],\n-                name: str) {\n+fn add_to_index(ebml_w: ebml::writer, path: [ident], &index: [entry<str>],\n+                name: ident) {\n     let full_path = path + [name];\n     index +=\n-        [{val: str::connect(full_path, \"::\"), pos: ebml_w.writer.tell()}];\n+        [{val: ast_util::path_name_i(full_path), pos: ebml_w.writer.tell()}];\n }\n \n fn encode_native_module_item_paths(ebml_w: ebml::writer, nmod: native_mod,\n-                                   path: [str], &index: [entry<str>]) {\n+                                   path: [ident], &index: [entry<str>]) {\n     for nmod.items.each {|nitem|\n         add_to_index(ebml_w, path, index, nitem.ident);\n         encode_named_def_id(ebml_w, nitem.ident, local_def(nitem.id));\n     }\n }\n \n fn encode_class_item_paths(ebml_w: ebml::writer,\n-     items: [@class_member], path: [str], &index: [entry<str>]) {\n+     items: [@class_member], path: [ident], &index: [entry<str>]) {\n     for items.each {|it|\n      alt ast_util::class_member_visibility(it) {\n           private { cont; }\n@@ -152,7 +152,8 @@ fn encode_class_item_paths(ebml_w: ebml::writer,\n }\n \n fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n-                            module: _mod, path: [str], &index: [entry<str>]) {\n+                            module: _mod, path: [ident],\n+                            &index: [entry<str>]) {\n     for module.items.each {|it|\n         if !reachable(ecx, it.id) ||\n            !ast_util::is_exported(it.ident, module) { cont; }\n@@ -235,7 +236,7 @@ fn encode_iface_ref(ebml_w: ebml::writer, ecx: @encode_ctxt, t: @iface_ref) {\n fn encode_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt, crate: @crate)\n     -> [entry<str>] {\n     let mut index: [entry<str>] = [];\n-    let mut path: [str] = [];\n+    let mut path: [ident] = [];\n     ebml_w.start_tag(tag_paths);\n     encode_module_item_paths(ebml_w, ecx, crate.node.module, path, index);\n     encode_reexport_paths(ebml_w, ecx, index);\n@@ -249,7 +250,7 @@ fn encode_reexport_paths(ebml_w: ebml::writer,\n         let (path, def_id) = reexport;\n         index += [{val: path, pos: ebml_w.writer.tell()}];\n         ebml_w.start_tag(tag_paths_data_item);\n-        encode_name(ebml_w, path);\n+        encode_name(ebml_w, @path);\n         encode_def_id(ebml_w, def_id);\n         ebml_w.end_tag();\n     }\n@@ -374,7 +375,7 @@ fn encode_path(ebml_w: ebml::writer,\n           ast_map::path_name(name) { (tag_path_elt_name, name) }\n         };\n \n-        ebml_w.wr_tagged_str(tag, name);\n+        ebml_w.wr_tagged_str(tag, *name);\n     }\n \n     ebml_w.wr_tag(tag_path) {||\n@@ -439,7 +440,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         instance_var(nm, _, mt, id, vis) {\n           *index += [{val: id, pos: ebml_w.writer.tell()}];\n           ebml_w.start_tag(tag_items_data_item);\n-          #debug(\"encode_info_for_class: doing %s %d\", nm, id);\n+          #debug(\"encode_info_for_class: doing %s %d\", *nm, id);\n           encode_visibility(ebml_w, vis);\n           encode_name(ebml_w, nm);\n           encode_path(ebml_w, path, ast_map::path_name(nm));\n@@ -456,7 +457,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                    but it works for now -- tjc */\n                 *global_index += [{val: m.id, pos: ebml_w.writer.tell()}];\n                 let impl_path = path + [ast_map::path_name(m.ident)];\n-                #debug(\"encode_info_for_class: doing %s %d\", m.ident, m.id);\n+                #debug(\"encode_info_for_class: doing %s %d\", *m.ident, m.id);\n                 encode_info_for_method(ecx, ebml_w, impl_path,\n                                        should_inline(m.attrs), id, m,\n                                        class_tps + m.tps);\n@@ -479,7 +480,7 @@ fn encode_info_for_fn(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         encode_family(ebml_w, purity_fn_family(decl.purity));\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         let its_ty = node_id_to_type(ecx.tcx, id);\n-        #debug(\"fn name = %s ty = %s its node id = %d\", ident,\n+        #debug(\"fn name = %s ty = %s its node id = %d\", *ident,\n                util::ppaux::ty_to_str(ecx.tcx, its_ty), id);\n         encode_type(ecx, ebml_w, its_ty);\n         encode_path(ebml_w, path, ast_map::path_name(ident));\n@@ -498,7 +499,7 @@ fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                           impl_path: ast_map::path, should_inline: bool,\n                           parent_id: node_id,\n                           m: @method, all_tps: [ty_param]) {\n-    #debug(\"encode_info_for_method: %d %s %u\", m.id, m.ident, all_tps.len());\n+    #debug(\"encode_info_for_method: %d %s %u\", m.id, *m.ident, all_tps.len());\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(m.id));\n     encode_family(ebml_w, purity_fn_family(m.decl.purity));\n@@ -627,8 +628,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         /* Encode the dtor */\n         option::iter(m_dtor) {|dtor|\n           *index += [{val: dtor.node.id, pos: ebml_w.writer.tell()}];\n-          encode_info_for_fn(ecx, ebml_w, dtor.node.id, item.ident\n-                             + \"_dtor\", path, if tps.len() > 0u {\n+          encode_info_for_fn(ecx, ebml_w, dtor.node.id, @(*item.ident\n+                             + \"_dtor\"), path, if tps.len() > 0u {\n                                some(ii_dtor(dtor, item.ident, tps,\n                                             local_def(item.id))) }\n                              else { none }, tps, ast_util::dtor_dec());\n@@ -805,7 +806,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     ebml_w.start_tag(tag_items_data);\n     *index += [{val: crate_node_id, pos: ebml_w.writer.tell()}];\n     encode_info_for_mod(ecx, ebml_w, crate.node.module,\n-                        crate_node_id, [], \"\");\n+                        crate_node_id, [], @\"\");\n     visit::visit_crate(*crate, (), visit::mk_vt(@{\n         visit_expr: {|_e, _cx, _v|},\n         visit_item: {|i, cx, v, copy ebml_w|\n@@ -816,7 +817,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                 /* encode ctor, then encode items */\n                 alt i.node {\n                    item_class(tps, _, _, ctor, m_dtor, _) {\n-                   #debug(\"encoding info for ctor %s %d\", i.ident,\n+                   #debug(\"encoding info for ctor %s %d\", *i.ident,\n                           ctor.node.id);\n                    *index += [{val: ctor.node.id, pos: ebml_w.writer.tell()}];\n                    encode_info_for_fn(ecx, ebml_w, ctor.node.id, i.ident,\n@@ -898,7 +899,7 @@ fn encode_meta_item(ebml_w: ebml::writer, mi: meta_item) {\n       meta_word(name) {\n         ebml_w.start_tag(tag_meta_item_word);\n         ebml_w.start_tag(tag_meta_item_name);\n-        ebml_w.writer.write(str::bytes(name));\n+        ebml_w.writer.write(str::bytes(*name));\n         ebml_w.end_tag();\n         ebml_w.end_tag();\n       }\n@@ -907,10 +908,10 @@ fn encode_meta_item(ebml_w: ebml::writer, mi: meta_item) {\n           lit_str(value) {\n             ebml_w.start_tag(tag_meta_item_name_value);\n             ebml_w.start_tag(tag_meta_item_name);\n-            ebml_w.writer.write(str::bytes(name));\n+            ebml_w.writer.write(str::bytes(*name));\n             ebml_w.end_tag();\n             ebml_w.start_tag(tag_meta_item_value);\n-            ebml_w.writer.write(str::bytes(value));\n+            ebml_w.writer.write(str::bytes(*value));\n             ebml_w.end_tag();\n             ebml_w.end_tag();\n           }\n@@ -920,7 +921,7 @@ fn encode_meta_item(ebml_w: ebml::writer, mi: meta_item) {\n       meta_list(name, items) {\n         ebml_w.start_tag(tag_meta_item_list);\n         ebml_w.start_tag(tag_meta_item_name);\n-        ebml_w.writer.write(str::bytes(name));\n+        ebml_w.writer.write(str::bytes(*name));\n         ebml_w.end_tag();\n         for items.each {|inner_item|\n             encode_meta_item(ebml_w, *inner_item);\n@@ -949,22 +950,22 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> [attribute] {\n     fn synthesize_link_attr(ecx: @encode_ctxt, items: [@meta_item]) ->\n        attribute {\n \n-        assert (ecx.link_meta.name != \"\");\n-        assert (ecx.link_meta.vers != \"\");\n+        assert (*ecx.link_meta.name != \"\");\n+        assert (*ecx.link_meta.vers != \"\");\n \n         let name_item =\n-            attr::mk_name_value_item_str(\"name\", ecx.link_meta.name);\n+            attr::mk_name_value_item_str(@\"name\", *ecx.link_meta.name);\n         let vers_item =\n-            attr::mk_name_value_item_str(\"vers\", ecx.link_meta.vers);\n+            attr::mk_name_value_item_str(@\"vers\", *ecx.link_meta.vers);\n \n         let other_items =\n             {\n-                let tmp = attr::remove_meta_items_by_name(items, \"name\");\n-                attr::remove_meta_items_by_name(tmp, \"vers\")\n+                let tmp = attr::remove_meta_items_by_name(items, @\"name\");\n+                attr::remove_meta_items_by_name(tmp, @\"vers\")\n             };\n \n         let meta_items = [name_item, vers_item] + other_items;\n-        let link_item = attr::mk_list_item(\"link\", meta_items);\n+        let link_item = attr::mk_list_item(@\"link\", meta_items);\n \n         ret attr::mk_attr(link_item);\n     }\n@@ -973,7 +974,7 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> [attribute] {\n     let mut found_link_attr = false;\n     for crate.node.attrs.each {|attr|\n         attrs +=\n-            if attr::get_attr_name(attr) != \"link\" {\n+            if *attr::get_attr_name(attr) != \"link\" {\n                 [attr]\n             } else {\n                 alt attr.node.value.node {\n@@ -1000,9 +1001,9 @@ fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n         // Pull the cnums and name,vers,hash out of cstore\n         let mut deps: [mut numdep] = [mut];\n         cstore::iter_crate_data(cstore) {|key, val|\n-            let dep = {cnum: key, name: val.name,\n+            let dep = {cnum: key, name: @val.name,\n                        vers: decoder::get_crate_vers(val.data),\n-                       hash:  decoder::get_crate_hash(val.data)};\n+                       hash: decoder::get_crate_hash(val.data)};\n             deps += [mut dep];\n         };\n \n@@ -1036,13 +1037,13 @@ fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n fn encode_crate_dep(ebml_w: ebml::writer, dep: decoder::crate_dep) {\n     ebml_w.start_tag(tag_crate_dep);\n     ebml_w.start_tag(tag_crate_dep_name);\n-    ebml_w.writer.write(str::bytes(dep.name));\n+    ebml_w.writer.write(str::bytes(*dep.name));\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_crate_dep_vers);\n-    ebml_w.writer.write(str::bytes(dep.vers));\n+    ebml_w.writer.write(str::bytes(*dep.vers));\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_crate_dep_hash);\n-    ebml_w.writer.write(str::bytes(dep.hash));\n+    ebml_w.writer.write(str::bytes(*dep.hash));\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }"}, {"sha": "2cbf529ecf045b3b54f76a5946f972c968a077e4", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -44,7 +44,7 @@ fn load_library_crate(cx: ctxt) -> {ident: str, data: @[u8]} {\n       some(t) { ret t; }\n       none {\n         cx.diag.span_fatal(\n-            cx.span, #fmt[\"can't find crate for '%s'\", cx.ident]);\n+            cx.span, #fmt[\"can't find crate for '%s'\", *cx.ident]);\n       }\n     }\n }\n@@ -69,7 +69,7 @@ fn find_library_crate_aux(cx: ctxt,\n                           filesearch: filesearch::filesearch) ->\n    option<{ident: str, data: @[u8]}> {\n     let crate_name = crate_name_from_metas(cx.metas);\n-    let prefix: str = nn.prefix + crate_name + \"-\";\n+    let prefix: str = nn.prefix + *crate_name + \"-\";\n     let suffix: str = nn.suffix;\n \n     let mut matches = [];\n@@ -107,7 +107,7 @@ fn find_library_crate_aux(cx: ctxt,\n         some(matches[0])\n     } else {\n         cx.diag.span_err(\n-            cx.span, #fmt(\"multiple matching crates for `%s`\", crate_name));\n+            cx.span, #fmt(\"multiple matching crates for `%s`\", *crate_name));\n         cx.diag.handler().note(\"candidates:\");\n         for matches.each {|match|\n             cx.diag.handler().note(#fmt(\"path: %s\", match.ident));\n@@ -119,7 +119,7 @@ fn find_library_crate_aux(cx: ctxt,\n     }\n }\n \n-fn crate_name_from_metas(metas: [@ast::meta_item]) -> str {\n+fn crate_name_from_metas(metas: [@ast::meta_item]) -> @str {\n     let name_items = attr::find_meta_items_by_name(metas, \"name\");\n     alt vec::last_opt(name_items) {\n       some(i) {\n@@ -146,7 +146,7 @@ fn crate_matches(crate_data: @[u8], metas: [@ast::meta_item], hash: str) ->\n     let linkage_metas = attr::find_linkage_metas(attrs);\n     if hash.is_not_empty() {\n         let chash = decoder::get_crate_hash(crate_data);\n-        if chash != hash { ret false; }\n+        if *chash != hash { ret false; }\n     }\n     metadata_matches(linkage_metas, metas)\n }"}, {"sha": "c6e70c6db07b124a88021ad5d9572318d86da697", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -46,7 +46,7 @@ fn parse_ident_(st: @pstate, is_last: fn@(char) -> bool) ->\n     while !is_last(peek(st)) {\n         rslt += str::from_byte(next_byte(st));\n     }\n-    ret rslt;\n+    ret @rslt;\n }\n \n \n@@ -210,7 +210,7 @@ fn parse_bound_region(st: @pstate) -> ty::bound_region {\n     alt check next(st) {\n       's' { ty::br_self }\n       'a' { ty::br_anon }\n-      '[' { ty::br_named(parse_str(st, ']')) }\n+      '[' { ty::br_named(@parse_str(st, ']')) }\n     }\n }\n \n@@ -322,7 +322,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         assert (next(st) == '[');\n         let mut fields: [ty::field] = [];\n         while peek(st) != ']' {\n-            let name = parse_str(st, '=');\n+            let name = @parse_str(st, '=');\n             fields += [{ident: name, mt: parse_mt(st, conv)}];\n         }\n         st.pos = st.pos + 1u;"}, {"sha": "a158b0b01fdfa28b80d37e70a8516ffb0be4b0c8", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -157,7 +157,7 @@ fn enc_bound_region(w: io::writer, br: ty::bound_region) {\n       ty::br_anon { w.write_char('a') }\n       ty::br_named(s) {\n         w.write_char('[');\n-        w.write_str(s);\n+        w.write_str(*s);\n         w.write_char(']')\n       }\n     }\n@@ -256,7 +256,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n       ty::ty_rec(fields) {\n         w.write_str(\"R[\"/&);\n         for fields.each {|field|\n-            w.write_str(field.ident);\n+            w.write_str(*field.ident);\n             w.write_char('=');\n             enc_mt(w, cx, field.mt);\n         }"}, {"sha": "ca84dafb535f8e22afe5902d0a190e6e2641d09d", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -83,7 +83,7 @@ fn encode_inlined_item(ecx: @e::encode_ctxt,\n                        ii: ast::inlined_item,\n                        maps: maps) {\n     #debug[\"> Encoding inlined item: %s::%s (%u)\",\n-           ast_map::path_to_str(path), ii.ident(),\n+           ast_map::path_to_str(path), *ii.ident(),\n            ebml_w.writer.tell()];\n \n     let id_range = compute_id_range(ii);\n@@ -94,7 +94,7 @@ fn encode_inlined_item(ecx: @e::encode_ctxt,\n     }\n \n     #debug[\"< Encoded inlined fn: %s::%s (%u)\",\n-           ast_map::path_to_str(path), ii.ident(),\n+           ast_map::path_to_str(path), *ii.ident(),\n            ebml_w.writer.tell()];\n }\n \n@@ -117,10 +117,10 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n         let ii = renumber_ast(xcx, raw_ii);\n         ast_map::map_decoded_item(tcx.sess.diagnostic(),\n                                   dcx.tcx.items, path, ii);\n-        #debug[\"Fn named: %s\", ii.ident()];\n+        #debug[\"Fn named: %s\", *ii.ident()];\n         decode_side_tables(xcx, ast_doc);\n         #debug[\"< Decoded inlined fn: %s::%s\",\n-               ast_map::path_to_str(path), ii.ident()];\n+               ast_map::path_to_str(path), *ii.ident()];\n         alt ii {\n           ast::ii_item(i) {\n             #debug(\">>> DECODED ITEM >>>\\n%s\\n<<< DECODED ITEM <<<\","}, {"sha": "f9a985da25daff9b1a8a82aa010e0da10eafff4c", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -241,7 +241,7 @@ enum comp_kind {\n     comp_tuple,                  // elt in a tuple\n     comp_res,                    // data for a resource\n     comp_variant(ast::def_id),   // internals to a variant of given enum\n-    comp_field(str,              // name of field\n+    comp_field(ast::ident,       // name of field\n                ast::mutability), // declared mutability of field\n     comp_index(ty::t,            // type of vec/str/etc being deref'd\n                ast::mutability)  // mutability of vec content\n@@ -409,7 +409,7 @@ impl to_str_methods for borrowck_ctxt {\n \n     fn comp_to_repr(comp: comp_kind) -> str {\n         alt comp {\n-          comp_field(fld, _) { fld }\n+          comp_field(fld, _) { *fld }\n           comp_index(*) { \"[]\" }\n           comp_tuple { \"()\" }\n           comp_res { \"<res>\" }"}, {"sha": "4a6f8c15147cb7701292250cdd5dd858e1fb22ea", "filename": "src/rustc/middle/borrowck/categorization.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -295,14 +295,15 @@ impl public_methods for borrowck_ctxt {\n         ret @{cat:cat_discr(cmt, alt_id) with *cmt};\n     }\n \n-    fn cat_field<N:ast_node>(node: N, base_cmt: cmt, f_name: str) -> cmt {\n+    fn cat_field<N:ast_node>(node: N, base_cmt: cmt,\n+                             f_name: ast::ident) -> cmt {\n         let f_mutbl = alt field_mutbl(self.tcx, base_cmt.ty, f_name) {\n           some(f_mutbl) { f_mutbl }\n           none {\n             self.tcx.sess.span_bug(\n                 node.span(),\n                 #fmt[\"Cannot find field `%s` in type `%s`\",\n-                     f_name, ty_to_str(self.tcx, base_cmt.ty)]);\n+                     *f_name, ty_to_str(self.tcx, base_cmt.ty)]);\n           }\n         };\n         let m = alt f_mutbl {\n@@ -427,7 +428,7 @@ impl private_methods for borrowck_ctxt {\n \n fn field_mutbl(tcx: ty::ctxt,\n                base_ty: ty::t,\n-               f_name: str) -> option<ast::mutability> {\n+               f_name: ast::ident) -> option<ast::mutability> {\n     // Need to refactor so that records/class fields can be treated uniformly.\n     alt ty::get(base_ty).struct {\n       ty::ty_rec(fields) {"}, {"sha": "fe7aeb8e5f0594d401d9957e62273a6767b7cd6a", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -44,15 +44,15 @@ fn check_capture_clause(tcx: ty::ctxt,\n             tcx.sess.span_warn(\n                 cap_item.span,\n                 #fmt(\"captured variable '%s' not used in closure\",\n-                     cap_item.name));\n+                     *cap_item.name));\n         }\n \n         let cap_def_id = ast_util::def_id_of_def(cap_def).node;\n         if !seen_defs.insert(cap_def_id, ()) {\n             tcx.sess.span_err(\n                 cap_item.span,\n                 #fmt(\"variable '%s' captured more than once\",\n-                     cap_item.name));\n+                     *cap_item.name));\n         }\n     }\n }\n@@ -68,7 +68,7 @@ fn compute_capture_vars(tcx: ty::ctxt,\n \n     for (*cap_clause).each { |cap_item|\n         #debug(\"Doing capture var: %s (%?)\",\n-               cap_item.name, cap_item.id);\n+               *cap_item.name, cap_item.id);\n \n         let cap_def = tcx.def_map.get(cap_item.id);\n         let cap_def_id = ast_util::def_id_of_def(cap_def).node;"}, {"sha": "ee95a8571ff7a770e890ef7846527f85725dbd26", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -67,8 +67,8 @@ fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: [@pat]) {\n         alt ty::get(ty).struct {\n           ty::ty_bool {\n             alt check ctor {\n-              val(const_int(1i64)) { some(\"true\") }\n-              val(const_int(0i64)) { some(\"false\") }\n+              val(const_int(1i64)) { some(@\"true\") }\n+              val(const_int(0i64)) { some(@\"false\") }\n             }\n           }\n           ty::ty_enum(id, _) {\n@@ -83,7 +83,7 @@ fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: [@pat]) {\n       }\n     };\n     let msg = \"non-exhaustive patterns\" + alt ext {\n-      some(s) { \": \" + s + \" not covered\" }\n+      some(s) { \": \" + *s + \" not covered\" }\n       none { \"\" }\n     };\n     tcx.sess.span_err(sp, msg);"}, {"sha": "a72e7fb02085845cbc815151d84c7ee76b4a3ecc", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -108,11 +108,11 @@ fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n \n fn lit_to_const(lit: @lit) -> const_val {\n     alt lit.node {\n-      lit_str(s) { const_str(s) }\n+      lit_str(s) { const_str(*s) }\n       lit_int(n, _) { const_int(n) }\n       lit_uint(n, _) { const_uint(n) }\n       lit_int_unsuffixed(n, _) { const_int(n) }\n-      lit_float(n, _) { const_float(option::get(float::from_str(n)) as f64) }\n+      lit_float(n, _) { const_float(option::get(float::from_str(*n)) as f64) }\n       lit_nil { const_int(0i64) }\n       lit_bool(b) { const_int(b as i64) }\n     }"}, {"sha": "a11ea4c9a629d3b412c2d45828677b9a4835b518", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -210,7 +210,7 @@ impl methods for ctxt {\n                 for metas.each {|meta|\n                     alt meta.node {\n                       ast::meta_word(lintname) {\n-                        alt lookup_lint(self.dict, lintname) {\n+                        alt lookup_lint(self.dict, *lintname) {\n                           (name, none) {\n                             self.span_lint(\n                                 self.get_level(unrecognized_warning),\n@@ -444,7 +444,7 @@ fn check_item_old_vecs(cx: ty::ctxt, it: @ast::item) {\n \n               ast::ty_path(@{span: _, global: _, idents: ids,\n                              rp: none, types: _}, _)\n-              if ids == [\"str\"] && (! uses_vstore.contains_key(t.id)) {\n+              if ids == [@\"str\"] && (! uses_vstore.contains_key(t.id)) {\n                 cx.sess.span_lint(\n                     old_vecs, it.id, t.id,\n                     t.span, \"deprecated str type\");"}, {"sha": "38571680ec6bba259379df3a7772c98a8e41a48c", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -45,7 +45,7 @@ of `f`.\n */\n \n import dvec::{dvec, extensions};\n-import std::map::{hashmap, int_hash, str_hash};\n+import std::map::{hashmap, int_hash, str_hash, box_str_hash};\n import syntax::{visit, ast_util};\n import syntax::print::pprust::{expr_to_str};\n import visit::vt;\n@@ -134,9 +134,9 @@ enum relevant_def { rdef_var(node_id), rdef_self }\n type capture_info = {ln: live_node, is_move: bool, rv: relevant_def};\n \n enum var_kind {\n-    vk_arg(node_id, str, rmode),\n-    vk_local(node_id, str),\n-    vk_field(str),\n+    vk_arg(node_id, ident, rmode),\n+    vk_local(node_id, ident),\n+    vk_field(ident),\n     vk_self,\n     vk_implicit_ret\n }\n@@ -158,7 +158,7 @@ class ir_maps {\n     let mut num_vars: uint;\n     let live_node_map: hashmap<node_id, live_node>;\n     let variable_map: hashmap<node_id, variable>;\n-    let field_map: hashmap<str, variable>;\n+    let field_map: hashmap<ident, variable>;\n     let capture_map: hashmap<node_id, @[capture_info]>;\n     let mut var_kinds: [var_kind];\n     let mut lnks: [live_node_kind];\n@@ -174,7 +174,7 @@ class ir_maps {\n         self.live_node_map = int_hash();\n         self.variable_map = int_hash();\n         self.capture_map = int_hash();\n-        self.field_map = str_hash();\n+        self.field_map = box_str_hash();\n         self.var_kinds = [];\n         self.lnks = [];\n     }\n@@ -227,12 +227,12 @@ class ir_maps {\n         }\n     }\n \n-    fn variable_name(var: variable) -> str {\n+    fn variable_name(var: variable) -> ident {\n         alt self.var_kinds[*var] {\n           vk_local(_, name) | vk_arg(_, name, _) {name}\n-          vk_field(name) {\"self.\" + name}\n-          vk_self {\"self\"}\n-          vk_implicit_ret {\"<implicit-ret>\"}\n+          vk_field(name) {@(\"self.\" + *name)}\n+          vk_self {@\"self\"}\n+          vk_implicit_ret {@\"<implicit-ret>\"}\n         }\n     }\n \n@@ -1208,7 +1208,8 @@ class liveness {\n         }\n     }\n \n-    fn as_self_field(expr: @expr, fld: str) -> option<(live_node,variable)> {\n+    fn as_self_field(expr: @expr,\n+                     fld: ident) -> option<(live_node,variable)> {\n         // If we checking a constructor, then we treat self.f as a\n         // variable.  we use the live_node id that will be assigned to\n         // the reference to self but the variable id for `f`.\n@@ -1429,7 +1430,7 @@ impl check_methods for @liveness {\n               none { /* ok */ }\n               some(lnk_exit) {\n                 self.tcx.sess.span_err(\n-                    sp, #fmt[\"field `self.%s` is never initialized\", nm]);\n+                    sp, #fmt[\"field `self.%s` is never initialized\", *nm]);\n               }\n               some(lnk) {\n                 self.report_illegal_read(\n@@ -1605,13 +1606,13 @@ impl check_methods for @liveness {\n                 self.tcx.sess.span_err(\n                     move_span,\n                     #fmt[\"illegal move from argument `%s`, which is not \\\n-                          copy or move mode\", name]);\n+                          copy or move mode\", *name]);\n                 ret;\n               }\n               vk_field(name) {\n                 self.tcx.sess.span_err(\n                     move_span,\n-                    #fmt[\"illegal move from field `%s`\", name]);\n+                    #fmt[\"illegal move from field `%s`\", *name]);\n                 ret;\n               }\n               vk_local(*) | vk_self | vk_implicit_ret {\n@@ -1643,12 +1644,12 @@ impl check_methods for @liveness {\n           lnk_freevar(span) {\n             self.tcx.sess.span_err(\n                 span,\n-                #fmt[\"capture of %s: `%s`\", msg, name]);\n+                #fmt[\"capture of %s: `%s`\", msg, *name]);\n           }\n           lnk_expr(span) {\n             self.tcx.sess.span_err(\n                 span,\n-                #fmt[\"use of %s: `%s`\", msg, name]);\n+                #fmt[\"use of %s: `%s`\", msg, *name]);\n           }\n           lnk_exit |\n           lnk_vdef(_) {\n@@ -1659,9 +1660,9 @@ impl check_methods for @liveness {\n         }\n     }\n \n-    fn should_warn(var: variable) -> option<str> {\n+    fn should_warn(var: variable) -> option<ident> {\n         let name = (*self.ir).variable_name(var);\n-        if name[0] == ('_' as u8) {none} else {some(name)}\n+        if (*name)[0] == ('_' as u8) {none} else {some(name)}\n     }\n \n     fn warn_about_unused_args(sp: span, decl: fn_decl, entry_ln: live_node) {\n@@ -1712,10 +1713,10 @@ impl check_methods for @liveness {\n                 if is_assigned {\n                     self.tcx.sess.span_warn(\n                         sp, #fmt[\"variable `%s` is assigned to, \\\n-                                  but never used\", name]);\n+                                  but never used\", *name]);\n                 } else {\n                     self.tcx.sess.span_warn(\n-                        sp, #fmt[\"unused variable: `%s`\", name]);\n+                        sp, #fmt[\"unused variable: `%s`\", *name]);\n                 }\n             }\n             ret true;\n@@ -1728,7 +1729,7 @@ impl check_methods for @liveness {\n             for self.should_warn(var).each { |name|\n                 self.tcx.sess.span_warn(\n                     sp,\n-                    #fmt[\"value assigned to `%s` is never read\", name]);\n+                    #fmt[\"value assigned to `%s` is never read\", *name]);\n             }\n         }\n     }"}, {"sha": "706a6fb2264e740d2669136928f3233de8ab9ee8", "filename": "src/rustc/middle/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpat_util.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -9,12 +9,12 @@ import std::map::hashmap;\n export pat_binding_ids, pat_bindings, pat_id_map;\n export pat_is_variant;\n \n-type pat_id_map = std::map::hashmap<str, node_id>;\n+type pat_id_map = std::map::hashmap<ident, node_id>;\n \n // This is used because same-named variables in alternative patterns need to\n // use the node_id of their namesake in the first pattern.\n fn pat_id_map(dm: resolve::def_map, pat: @pat) -> pat_id_map {\n-    let map = std::map::str_hash();\n+    let map = std::map::box_str_hash();\n     pat_bindings(dm, pat) {|p_id, _s, n|\n       map.insert(path_to_ident(n), p_id);\n     };"}, {"sha": "fb9ae118a4aadde499431c3288f710bd99c4a890", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 49, "deletions": 48, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -9,7 +9,7 @@ import syntax::attr;\n import metadata::{csearch, cstore};\n import driver::session::session;\n import util::common::is_main_name;\n-import std::map::{int_hash, str_hash, hashmap};\n+import std::map::{int_hash, str_hash, box_str_hash, hashmap};\n import vec::each;\n import syntax::codemap::span;\n import syntax::visit;\n@@ -68,16 +68,16 @@ enum glob_import_state {\n                   option<def>), /* module */\n }\n \n-type ext_hash = hashmap<{did: def_id, ident: str, ns: namespace}, def>;\n+type ext_hash = hashmap<{did: def_id, ident: ast::ident, ns: namespace}, def>;\n \n fn new_ext_hash() -> ext_hash {\n-    type key = {did: def_id, ident: str, ns: namespace};\n+    type key = {did: def_id, ident: ast::ident, ns: namespace};\n     fn hash(v: key) -> uint {\n-        str::hash(v.ident) + ast_util::hash_def(v.did) + v.ns as uint\n+        str::hash(*v.ident) + ast_util::hash_def(v.did) + v.ns as uint\n     }\n     fn eq(v1: key, v2: key) -> bool {\n         ret ast_util::def_eq(v1.did, v2.did) &&\n-            str::eq(v1.ident, v2.ident) && v1.ns == v2.ns;\n+            str::eq(*v1.ident, *v2.ident) && v1.ns == v2.ns;\n     }\n     std::map::hashmap(hash, {|a, b| a == b})\n }\n@@ -102,7 +102,7 @@ type indexed_mod = {\n     index: mod_index,\n     glob_imports: dvec<glob_imp_def>,\n     mut globbed_exports: [ident],\n-    glob_imported_names: hashmap<str, glob_import_state>,\n+    glob_imported_names: hashmap<ident, glob_import_state>,\n     path: str\n };\n \n@@ -132,7 +132,7 @@ type env =\n      ext_cache: ext_hash,\n      used_imports: {mut track: bool,\n                     mut data: [node_id]},\n-     reported: dvec<{ident: str, sc: scope}>,\n+     reported: dvec<{ident: ast::ident, sc: scope}>,\n      mut ignored_imports: [node_id],\n      mut current_tp: option<uint>,\n      mut resolve_unexported: bool,\n@@ -256,7 +256,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n         let mut path = n + \"::\";\n         list::iter(sc) {|s|\n             alt s {\n-              scope_item(i) { path = i.ident + \"::\" + path; }\n+              scope_item(i) { path = *i.ident + \"::\" + path; }\n               _ {}\n             }\n         }\n@@ -272,17 +272,17 @@ fn map_crate(e: @env, c: @ast::crate) {\n                                index: index_mod(md),\n                                glob_imports: dvec(),\n                                mut globbed_exports: [],\n-                               glob_imported_names: str_hash(),\n-                               path: path_from_scope(sc, i.ident)});\n+                               glob_imported_names: box_str_hash(),\n+                               path: path_from_scope(sc, *i.ident)});\n           }\n           ast::item_native_mod(nmd) {\n             e.mod_map.insert(i.id,\n                              @{m: none::<ast::_mod>,\n                                index: index_nmod(nmd),\n                                glob_imports: dvec(),\n                                mut globbed_exports: [],\n-                               glob_imported_names: str_hash(),\n-                               path: path_from_scope(sc, i.ident)});\n+                               glob_imported_names: box_str_hash(),\n+                               path: path_from_scope(sc, *i.ident)});\n           }\n           _ { }\n         }\n@@ -340,7 +340,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n                        index: index_mod(c.node.module),\n                        glob_imports: dvec(),\n                        mut globbed_exports: [],\n-                       glob_imported_names: str_hash(),\n+                       glob_imported_names: box_str_hash(),\n                        path: \"\"});\n \n     // Next, assemble the links for globbed imports and exports.\n@@ -377,10 +377,10 @@ fn check_unused_imports(e: @env, level: lint::level) {\n               if !vec::contains(e.used_imports.data, k) {\n                   alt level {\n                     lint::warn {\n-                      e.sess.span_warn(sp, \"unused import \" + name);\n+                      e.sess.span_warn(sp, \"unused import \" + *name);\n                     }\n                     lint::error {\n-                      e.sess.span_err(sp, \"unused import \" + name);\n+                      e.sess.span_err(sp, \"unused import \" + *name);\n                     }\n                     lint::ignore {\n                     }\n@@ -518,7 +518,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n                 }\n                 some(fnd@ast::def_const(_)) {\n                     e.sess.span_err(p.span, \"pattern variable conflicts \\\n-                       with constant '\" + path_to_ident(p) + \"'\");\n+                       with constant '\" + *path_to_ident(p) + \"'\");\n                 }\n                 // Binds a var -- nothing needs to be done\n                 _ {}\n@@ -701,7 +701,7 @@ fn visit_local_with_scope(e: @env, loc: @local, &&sc: scopes, v:vt<scopes>) {\n                 e.sess.span_err(loc.span,\n                                 #fmt(\"declaration of `%s` shadows an \\\n                                       enum that's in scope\",\n-                                     path_to_ident(path)));\n+                                     *path_to_ident(path)));\n               }\n               _ {}\n             }\n@@ -734,7 +734,7 @@ fn follow_import(e: env, &&sc: scopes, path: [ident], sp: span) ->\n        alt dcur {\n           some(ast::def_mod(_)) | some(ast::def_native_mod(_)) { ret dcur; }\n           _ {\n-            e.sess.span_err(sp, str::connect(path, \"::\") +\n+            e.sess.span_err(sp, str::connect(path.map({|x|*x}), \"::\") +\n                             \" does not name a module.\");\n             ret none;\n           }\n@@ -860,7 +860,7 @@ fn resolve_import(e: env, n_id: node_id, name: ast::ident,\n     // import\n     alt e.imports.find(n_id) {\n       some(resolving(sp)) {\n-        e.imports.insert(n_id, resolved(none, none, none, @[], \"\", sp));\n+        e.imports.insert(n_id, resolved(none, none, none, @[], @\"\", sp));\n       }\n       _ { }\n     }\n@@ -897,7 +897,7 @@ fn unresolved_err(e: env, cx: ctxt, sp: span, name: ident, kind: str) {\n         alt find_fn_or_mod_scope(sc) {\n           some(err_scope) {\n             for e.reported.each {|rs|\n-                if str::eq(rs.ident, name) && err_scope == rs.sc { ret; }\n+                if str::eq(*rs.ident, *name) && err_scope == rs.sc { ret; }\n             }\n             e.reported.push({ident: name, sc: err_scope});\n           }\n@@ -907,10 +907,10 @@ fn unresolved_err(e: env, cx: ctxt, sp: span, name: ident, kind: str) {\n       in_mod(def) {\n         let did = def_id_of_def(def);\n         if did.crate == ast::local_crate {\n-            path = e.mod_map.get(did.node).path + path;\n+            path = @(e.mod_map.get(did.node).path + *path);\n         } else if did.node != ast::crate_node_id {\n             let paths = e.ext_map.get(did);\n-            path = str::connect(paths + [path], \"::\");\n+            path = @str::connect((paths + [path]).map({|x|*x}), \"::\");\n         }\n       }\n     }\n@@ -922,7 +922,7 @@ fn unresolved_fatal(e: env, sp: span, id: ident, kind: str) -> ! {\n }\n \n fn mk_unresolved_msg(id: ident, kind: str) -> str {\n-    ret #fmt[\"unresolved %s: %s\", kind, id];\n+    ret #fmt[\"unresolved %s: %s\", kind, *id];\n }\n \n // Lookup helpers\n@@ -1010,7 +1010,7 @@ fn lookup_in_scope(e: env, &&sc: scopes, sp: span, name: ident, ns: namespace,\n         alt s {\n           scope_toplevel {\n             if ns == ns_type {\n-                ret some(ast::def_prim_ty(alt name {\n+                ret some(ast::def_prim_ty(alt *name {\n                   \"bool\" { ast::ty_bool }\n                   \"int\" { ast::ty_int(ast::ty_i) }\n                   \"uint\" { ast::ty_uint(ast::ty_u) }\n@@ -1045,7 +1045,7 @@ fn lookup_in_scope(e: env, &&sc: scopes, sp: span, name: ident, ns: namespace,\n               }\n               ast::item_iface(tps, _, _) {\n                 if ns == ns_type {\n-                    if name == \"self\" {\n+                    if *name == \"self\" {\n                         ret some(def_self(it.id));\n                     }\n                     ret lookup_in_ty_params(e, name, tps);\n@@ -1070,7 +1070,7 @@ fn lookup_in_scope(e: env, &&sc: scopes, sp: span, name: ident, ns: namespace,\n             }\n           }\n           scope_method(id, tps) {\n-            if (name == \"self\" && ns == ns_val) {\n+            if (*name == \"self\" && ns == ns_val) {\n                 ret some(ast::def_self(id));\n             } else if ns == ns_type {\n                 ret lookup_in_ty_params(e, name, tps);\n@@ -1135,7 +1135,7 @@ fn lookup_in_scope(e: env, &&sc: scopes, sp: span, name: ident, ns: namespace,\n                     let mut i = vec::len(closing);\n                     while i > 0u {\n                         i -= 1u;\n-                        #debug[\"name=%s df=%?\", name, df];\n+                        #debug[\"name=%s df=%?\", *name, df];\n                         assert def_is_local(df) || def_is_self(df);\n                         let df_id = def_id_of_def(df).node;\n                         df = ast::def_upvar(df_id, @df, closing[i]);\n@@ -1164,7 +1164,7 @@ fn lookup_in_ty_params(e: env, name: ident, ty_params: [ast::ty_param])\n     -> option<def> {\n     let mut n = 0u;\n     for ty_params.each {|tp|\n-        if str::eq(tp.ident, name) && alt e.current_tp {\n+        if str::eq(*tp.ident, *name) && alt e.current_tp {\n             some(cur) { n < cur } none { true }\n         } { ret some(ast::def_ty_param(local_def(tp.id), n)); }\n         n += 1u;\n@@ -1176,7 +1176,7 @@ fn lookup_in_pat(e: env, name: ident, pat: @ast::pat) -> option<node_id> {\n     let mut found = none;\n \n     pat_util::pat_bindings(e.def_map, pat) {|p_id, _sp, n|\n-        if str::eq(path_to_ident(n), name)\n+        if str::eq(*path_to_ident(n), *name)\n                     { found = some(p_id); }\n     };\n     ret found;\n@@ -1188,7 +1188,7 @@ fn lookup_in_fn(e: env, name: ident, decl: ast::fn_decl,\n     alt ns {\n       ns_val {\n         for decl.inputs.each {|a|\n-            if str::eq(a.ident, name) {\n+            if str::eq(*a.ident, *name) {\n                 ret some(ast::def_arg(a.id, a.mode));\n             }\n         }\n@@ -1231,14 +1231,14 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n                 alt it.node {\n                   ast::item_enum(variants, _, _) {\n                     if ns == ns_type {\n-                        if str::eq(it.ident, name) {\n+                        if str::eq(*it.ident, *name) {\n                             ret some(ast::def_ty(local_def(it.id)));\n                         }\n                     } else {\n                         alt ns {\n                            ns_val {\n                                for variants.each {|v|\n-                                  if str::eq(v.node.name, name) {\n+                                  if str::eq(*v.node.name, *name) {\n                                      let i = v.node.id;\n                                      ret some(ast::def_variant\n                                         (local_def(it.id), local_def(i)));\n@@ -1250,7 +1250,7 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n                     }\n                   }\n                   _ {\n-                    if str::eq(it.ident, name) {\n+                    if str::eq(*it.ident, *name) {\n                         let found = found_def_item(it, ns);\n                         if !is_none(found) {\n                             ret found;\n@@ -1521,9 +1521,9 @@ fn lookup_in_globs(e: env, globs: [glob_imp_def], sp: span, id: ident,\n     } else {\n         for matches.each {|match|\n             let sp = match.path.span;\n-            e.sess.span_note(sp, #fmt[\"'%s' is imported here\", id]);\n+            e.sess.span_note(sp, #fmt[\"'%s' is imported here\", *id]);\n         }\n-        e.sess.span_fatal(sp, \"'\" + id + \"' is glob-imported from\" +\n+        e.sess.span_fatal(sp, \"'\" + *id + \"' is glob-imported from\" +\n                           \" multiple different modules.\");\n     }\n }\n@@ -1627,7 +1627,7 @@ fn index_view_items(view_items: [@ast::view_item],\n }\n \n fn index_mod(md: ast::_mod) -> mod_index {\n-    let index = str_hash::<@list<mod_index_entry>>();\n+    let index = box_str_hash::<@list<mod_index_entry>>();\n \n     index_view_items(md.view_items, index);\n \n@@ -1667,7 +1667,7 @@ fn index_mod(md: ast::_mod) -> mod_index {\n \n \n fn index_nmod(md: ast::native_mod) -> mod_index {\n-    let index = str_hash::<@list<mod_index_entry>>();\n+    let index = box_str_hash::<@list<mod_index_entry>>();\n \n     index_view_items(md.view_items, index);\n \n@@ -1727,7 +1727,7 @@ fn check_mod_name(e: env, name: ident, entries: @list<mod_index_entry>) {\n     let mut saw_value = false;\n     let mut entries = entries;\n     fn dup(e: env, sp: span, word: str, name: ident) {\n-        e.sess.span_fatal(sp, \"duplicate definition of \" + word + name);\n+        e.sess.span_fatal(sp, \"duplicate definition of \" + word + *name);\n     }\n     loop {\n         alt *entries {\n@@ -1817,11 +1817,11 @@ fn check_arm(e: @env, a: ast::arm, &&x: (), v: vt<()>) {\n                             \"inconsistent number of bindings\");\n         } else {\n             for ch.seen.each {|name|\n-                if is_none(vec::find(seen0, bind str::eq(name, _))) {\n+                if is_none(vec::find(seen0, {|x|str::eq(*name, *x)})) {\n                     // Fight the alias checker\n                     let name_ = name;\n                     e.sess.span_err(a.pats[i].span,\n-                                    \"binding \" + name_ +\n+                                    \"binding \" + *name_ +\n                                         \" does not occur in first pattern\");\n                 }\n             }\n@@ -1915,8 +1915,9 @@ fn checker(e: env, kind: str) -> checker {\n \n fn check_name(ch: checker, sp: span, name: ident) {\n     for ch.seen.each {|s|\n-        if str::eq(s, name) {\n-            ch.sess.span_fatal(sp, \"duplicate \" + ch.kind + \" name: \" + name);\n+        if str::eq(*s, *name) {\n+            ch.sess.span_fatal(\n+                sp, \"duplicate \" + ch.kind + \" name: \" + *name);\n         }\n     }\n }\n@@ -2000,7 +2001,7 @@ fn check_exports(e: @env) {\n         e.exp_map.insert(export_id, found + [{reexp: reexp, id: target_id}]);\n     }\n \n-    fn check_export(e: @env, ident: str, _mod: @indexed_mod,\n+    fn check_export(e: @env, ident: ident, _mod: @indexed_mod,\n                     export_id: node_id, vi: @view_item) {\n         let mut found_something = false;\n         if _mod.index.contains_key(ident) {\n@@ -2036,15 +2037,15 @@ fn check_exports(e: @env) {\n            lookup_glob_any(e, _mod, vi.span, ident, export_id);\n         if !found_something {\n             e.sess.span_warn(vi.span,\n-                             #fmt(\"exported item %s is not defined\", ident));\n+                             #fmt(\"exported item %s is not defined\", *ident));\n         }\n     }\n \n     fn check_enum_ok(e: @env, sp:span, id: ident, _mod: @indexed_mod)\n         -> node_id {\n         alt _mod.index.find(id) {\n           none {\n-            e.sess.span_fatal(sp, #fmt(\"undefined id %s in an export\", id));\n+            e.sess.span_fatal(sp, #fmt(\"undefined id %s in an export\", *id));\n           }\n           some(ms) {\n             let maybe_id = list_search(ms) {|m|\n@@ -2056,7 +2057,7 @@ fn check_exports(e: @env) {\n             alt maybe_id {\n               some(an_id) { an_id }\n               _ { e.sess.span_fatal(sp, #fmt(\"%s does not refer \\\n-                                              to an enumeration\", id)); }\n+                                              to an enumeration\", *id)); }\n             }\n           }\n         }\n@@ -2079,7 +2080,7 @@ fn check_exports(e: @env) {\n                             e.sess.span_err(\n                                 span, #fmt(\"variant %s doesn't belong to \\\n                                             enum %s\",\n-                                           variant_id.node.name, id));\n+                                           *variant_id.node.name, *id));\n                         }\n                       }\n                       _ {}\n@@ -2090,7 +2091,7 @@ fn check_exports(e: @env) {\n             }\n             if !found {\n                 e.sess.span_err(span, #fmt(\"%s is not a variant\",\n-                                           variant_id.node.name));\n+                                           *variant_id.node.name));\n             }\n         }\n     }"}, {"sha": "183f78ad2ac95aec434e85c468c382077641a83a", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -78,9 +78,9 @@ fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> opt {\n }\n \n type bind_map = [{ident: ast::ident, val: ValueRef}];\n-fn assoc(key: str, list: bind_map) -> option<ValueRef> {\n+fn assoc(key: ast::ident, list: bind_map) -> option<ValueRef> {\n     for vec::each(list) {|elt|\n-        if str::eq(elt.ident, key) { ret some(elt.val); }\n+        if str::eq(*elt.ident, *key) { ret some(elt.val); }\n     }\n     ret none;\n }\n@@ -194,7 +194,7 @@ fn enter_rec(dm: def_map, m: match, col: uint, fields: [ast::ident],\n             for vec::each(fields) {|fname|\n                 let mut pat = dummy;\n                 for vec::each(fpats) {|fpat|\n-                    if str::eq(fpat.ident, fname) { pat = fpat.pat; break; }\n+                    if str::eq(*fpat.ident, *fname) { pat = fpat.pat; break; }\n                 }\n                 pats += [pat];\n             }\n@@ -287,12 +287,12 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n }\n \n fn collect_record_fields(m: match, col: uint) -> [ast::ident] {\n-    let mut fields = [];\n+    let mut fields: [ast::ident] = [];\n     for vec::each(m) {|br|\n         alt br.pats[col].node {\n           ast::pat_rec(fs, _) {\n             for vec::each(fs) {|f|\n-                if !vec::any(fields, bind str::eq(f.ident, _)) {\n+                if !vec::any(fields, {|x| str::eq(*f.ident, *x)}) {\n                     fields += [f.ident];\n                 }\n             }"}, {"sha": "62128c4cf54f81c3aa997fe1331a2dc145b32d57", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -513,8 +513,8 @@ fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n     let mut name;\n     //XXX this triggers duplicate LLVM symbols\n     if false /*ccx.sess.opts.debuginfo*/ {\n-        name = mangle_internal_name_by_type_only(ccx, t, \"tydesc\");\n-    } else { name = mangle_internal_name_by_seq(ccx, \"tydesc\"); }\n+        name = mangle_internal_name_by_type_only(ccx, t, @\"tydesc\");\n+    } else { name = mangle_internal_name_by_seq(ccx, @\"tydesc\"); }\n     note_unique_llvm_symbol(ccx, name);\n     let gvar = str::as_c_str(name, {|buf|\n         llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type, buf)\n@@ -541,9 +541,9 @@ fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n     let mut fn_nm;\n     //XXX this triggers duplicate LLVM symbols\n     if false /*ccx.sess.opts.debuginfo*/ {\n-        fn_nm = mangle_internal_name_by_type_only(ccx, t, \"glue_\" + name);\n+        fn_nm = mangle_internal_name_by_type_only(ccx, t, @(\"glue_\" + name));\n     } else {\n-        fn_nm = mangle_internal_name_by_seq(ccx, \"glue_\" + name);\n+        fn_nm = mangle_internal_name_by_seq(ccx, @(\"glue_\" + name));\n     }\n     note_unique_llvm_symbol(ccx, fn_nm);\n     let llfn = decl_cdecl_fn(ccx.llmod, fn_nm, llfnty);\n@@ -697,8 +697,8 @@ fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(\"make_visit_glue\");\n     let mut bcx = bcx;\n-    assert bcx.ccx().tcx.intrinsic_ifaces.contains_key(\"ty_visitor\");\n-    let (iid, ty) = bcx.ccx().tcx.intrinsic_ifaces.get(\"ty_visitor\");\n+    assert bcx.ccx().tcx.intrinsic_ifaces.contains_key(@\"ty_visitor\");\n+    let (iid, ty) = bcx.ccx().tcx.intrinsic_ifaces.get(@\"ty_visitor\");\n     let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), ty)));\n     bcx = reflect::emit_calls_to_iface_visit_ty(bcx, t, v, iid);\n     build_return(bcx);\n@@ -1495,7 +1495,7 @@ fn trans_crate_lit(cx: @crate_ctxt, lit: ast::lit) -> ValueRef {\n         // to actually generate from this?\n         C_integral(T_int_ty(cx, t), i as u64, True)\n       }\n-      ast::lit_float(fs, t) { C_floating(fs, T_float_ty(cx, t)) }\n+      ast::lit_float(fs, t) { C_floating(*fs, T_float_ty(cx, t)) }\n       ast::lit_bool(b) { C_bool(b) }\n       ast::lit_nil { C_nil() }\n       ast::lit_str(s) {\n@@ -2158,7 +2158,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n       ast_map::node_ctor(nm, _, ct, pt) { (pt, nm, alt ct {\n                   ast_map::res_ctor(_, _, sp) { sp }\n                   ast_map::class_ctor(ct_, _) { ct_.span }}) }\n-      ast_map::node_dtor(_, dtor, _, pt) {(pt, \"drop\", dtor.span)}\n+      ast_map::node_dtor(_, dtor, _, pt) {(pt, @\"drop\", dtor.span)}\n       ast_map::node_expr(*) { ccx.tcx.sess.bug(\"Can't monomorphize an expr\") }\n       ast_map::node_export(*) {\n           ccx.tcx.sess.bug(\"Can't monomorphize an export\")\n@@ -2184,7 +2184,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n     }\n     ccx.monomorphizing.insert(fn_id, depth + 1u);\n \n-    let pt = *pt + [path_name(ccx.names(name))];\n+    let pt = *pt + [path_name(@ccx.names(*name))];\n     let s = mangle_exported_name(ccx, pt, mono_ty);\n \n     let mk_lldecl = {||\n@@ -3382,7 +3382,7 @@ fn trans_rec(bcx: block, fields: [ast::field],\n     let mut temp_cleanups = [];\n     for fields.each {|fld|\n         let ix = option::get(vec::position(ty_fields, {|ft|\n-            str::eq(fld.node.ident, ft.ident)\n+            str::eq(*fld.node.ident, *ft.ident)\n         }));\n         let dst = GEPi(bcx, addr, [0u, ix]);\n         bcx = trans_expr_save_in(bcx, fld.node.expr, dst);\n@@ -3395,7 +3395,7 @@ fn trans_rec(bcx: block, fields: [ast::field],\n         bcx = cx;\n         // Copy over inherited fields\n         for ty_fields.eachi {|i, tf|\n-            if !vec::any(fields, {|f| str::eq(f.node.ident, tf.ident)}) {\n+            if !vec::any(fields, {|f| str::eq(*f.node.ident, *tf.ident)}) {\n                 let dst = GEPi(bcx, addr, [0u, i]);\n                 let base = GEPi(bcx, base_val, [0u, i]);\n                 let val = load_if_immediate(bcx, base, tf.mt.ty);\n@@ -3841,7 +3841,7 @@ fn trans_log(log_ex: @ast::expr, lvl: @ast::expr,\n         ccx.module_data.get(modname)\n     } else {\n         let s = link::mangle_internal_name_by_path_and_seq(\n-            ccx, modpath, \"loglevel\");\n+            ccx, modpath, @\"loglevel\");\n         let global = str::as_c_str(s, {|buf|\n             llvm::LLVMAddGlobal(ccx.llmod, T_i32(), buf)\n         });\n@@ -4320,7 +4320,7 @@ fn alloc_local(cx: block, local: @ast::local) -> block {\n     let val = alloc_ty(cx, t);\n     if cx.sess().opts.debuginfo {\n         option::iter(simple_name) {|name|\n-            str::as_c_str(name, {|buf|\n+            str::as_c_str(*name, {|buf|\n                 llvm::LLVMSetValueName(val, buf)\n             });\n         }\n@@ -4604,7 +4604,7 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n     let fn_args = vec::map(variant.node.args, {|varg|\n         {mode: ast::expl(ast::by_copy),\n          ty: varg.ty,\n-         ident: \"arg\",\n+         ident: @\"arg\",\n          id: varg.id}\n     });\n     let fcx = new_fn_ctxt_w_id(ccx, [], llfndecl, variant.node.id,\n@@ -5122,7 +5122,7 @@ fn get_dtor_symbol(ccx: @crate_ctxt, path: path, id: ast::node_id) -> str {\n      some(s) { s }\n      none    {\n          let s = mangle_exported_name(ccx, path +\n-           [path_name(ccx.names(\"dtor\"))], ty::node_id_to_type(ccx.tcx, id));\n+           [path_name(@ccx.names(\"dtor\"))], ty::node_id_to_type(ccx.tcx, id));\n          ccx.item_symbols.insert(id, s);\n          s\n      }\n@@ -5164,15 +5164,15 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n                 // def_ids otherwise -- one to identify the type, and one to\n                 // find the dtor symbol.\n                 let t = ty::node_id_to_type(ccx.tcx, dtor_id);\n-                register_fn_full(ccx, i.span, my_path + [path_name(\"dtor\")],\n+                register_fn_full(ccx, i.span, my_path + [path_name(@\"dtor\")],\n                                  i.id, t)\n               }\n             }\n           }\n           ast_map::node_method(m, impl_id, pth) {\n             exprt = true;\n             let mty = ty::node_id_to_type(ccx.tcx, id);\n-            let pth = *pth + [path_name(ccx.names(\"meth\")),\n+            let pth = *pth + [path_name(@ccx.names(\"meth\")),\n                               path_name(m.ident)];\n             let llfn = register_fn_full(ccx, m.span, pth, id, mty);\n             set_inline_hint_if_appr(m.attrs, llfn);\n@@ -5248,7 +5248,7 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n         let path = item_path(ccx, it);\n         for vec::each(variants) {|variant|\n             let p = path + [path_name(variant.node.name),\n-                            path_name(\"discrim\")];\n+                            path_name(@\"discrim\")];\n             let s = mangle_exported_name(ccx, p, ty::mk_int(ccx.tcx));\n             let disr_val = vi[i].disr_val;\n             note_unique_llvm_symbol(ccx, s);\n@@ -5376,7 +5376,7 @@ fn decl_crate_map(sess: session::session, mapmeta: link_meta,\n     let cstore = sess.cstore;\n     while cstore::have_crate_data(cstore, n_subcrates) { n_subcrates += 1; }\n     let mapname = if sess.building_library {\n-        mapmeta.name + \"_\" + mapmeta.vers + \"_\" + mapmeta.extras_hash\n+        *mapmeta.name + \"_\" + *mapmeta.vers + \"_\" + mapmeta.extras_hash\n     } else { \"toplevel\" };\n     let sym_name = \"_rust_crate_map_\" + mapname;\n     let arrtype = T_array(int_type, n_subcrates as uint);\n@@ -5395,8 +5395,8 @@ fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n     while cstore::have_crate_data(cstore, i) {\n         let cdata = cstore::get_crate_data(cstore, i);\n         let nm = \"_rust_crate_map_\" + cdata.name +\n-            \"_\" + cstore::get_crate_vers(cstore, i) +\n-            \"_\" + cstore::get_crate_hash(cstore, i);\n+            \"_\" + *cstore::get_crate_vers(cstore, i) +\n+            \"_\" + *cstore::get_crate_hash(cstore, i);\n         let cr = str::as_c_str(nm, {|buf|\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n         });\n@@ -5506,7 +5506,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n     // crashes if the module identifer is same as other symbols\n     // such as a function name in the module.\n     // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n-    let llmod_id = link_meta.name + \".rc\";\n+    let llmod_id = *link_meta.name + \".rc\";\n \n     let llmod = str::as_c_str(llmod_id, {|buf|\n         llvm::LLVMModuleCreateWithNameInContext"}, {"sha": "8d97653d1828923646b5f76bb89818f8fbe7eaf5", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -390,7 +390,7 @@ fn trans_expr_fn(bcx: block,\n     let ccx = bcx.ccx(), bcx = bcx;\n     let fty = node_id_type(bcx, id);\n     let llfnty = type_of_fn_from_ty(ccx, fty);\n-    let sub_path = bcx.fcx.path + [path_name(\"anon\")];\n+    let sub_path = bcx.fcx.path + [path_name(@\"anon\")];\n     let s = mangle_internal_name_by_path(ccx, sub_path);\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n \n@@ -676,7 +676,7 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n     // construct and return that thunk.\n \n     // Give the thunk a name, type, and value.\n-    let s = mangle_internal_name_by_path_and_seq(ccx, path, \"thunk\");\n+    let s = mangle_internal_name_by_path_and_seq(ccx, path, @\"thunk\");\n     let llthunk_ty = get_pair_fn_ty(type_of(ccx, incoming_fty));\n     let llthunk = decl_internal_cdecl_fn(ccx.llmod, s, llthunk_ty);\n "}, {"sha": "6474fa716b4bcb990faa1dbd3ea0df29d23097c0", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -933,7 +933,7 @@ fn path_str(p: path) -> str {\n         alt e { ast_map::path_name(s) | ast_map::path_mod(s) {\n           if first { first = false; }\n           else { r += \"::\"; }\n-          r += s;\n+          r += *s;\n         } }\n     }\n     r\n@@ -966,7 +966,7 @@ fn field_idx_strict(cx: ty::ctxt, sp: span, ident: ast::ident,\n     -> uint {\n     alt ty::field_idx(ident, fields) {\n        none { cx.sess.span_bug(sp, #fmt(\"base expr doesn't appear to \\\n-                 have a field named %s\", ident)); }\n+                 have a field named %s\", *ident)); }\n        some(i) { i }\n     }\n }"}, {"sha": "f80dd130e0e59d1d16f9fb3b01c3ae55cae2940c", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -421,7 +421,7 @@ fn create_record(cx: @crate_ctxt, t: ty::t, fields: [ast::ty_field],\n         let field_t = ty::get_field(t, field.node.ident).mt.ty;\n         let ty_md = create_ty(cx, field_t, field.node.mt.ty);\n         let (size, align) = size_and_align_of(cx, field_t);\n-        add_member(scx, field.node.ident,\n+        add_member(scx, *field.node.ident,\n                    line_from_span(cx.sess.codemap, field.span) as int,\n                    size as int, align as int, ty_md.node);\n     }\n@@ -661,7 +661,7 @@ fn create_local_var(bcx: block, local: @ast::local)\n         none { create_function(bcx.fcx).node }\n         some(_) { create_block(bcx).node }\n     };\n-    let mdnode = create_var(tg, context, name, filemd.node,\n+    let mdnode = create_var(tg, context, *name, filemd.node,\n                             loc.line as int, tymd.node);\n     let mdval = @{node: mdnode, data: {id: local.node.id}};\n     update_cache(cache, AutoVariableTag, local_var_metadata(mdval));\n@@ -703,7 +703,7 @@ fn create_arg(bcx: block, arg: ast::arg, sp: span)\n     let tymd = create_ty(cx, ty, arg.ty);\n     let filemd = create_file(cx, loc.file.name);\n     let context = create_function(bcx.fcx);\n-    let mdnode = create_var(tg, context.node, arg.ident, filemd.node,\n+    let mdnode = create_var(tg, context.node, *arg.ident, filemd.node,\n                             loc.line as int, tymd.node);\n     let mdval = @{node: mdnode, data: {id: arg.id}};\n     update_cache(cache, tg, argument_metadata(mdval));\n@@ -769,10 +769,10 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n       ast_map::node_expr(expr) {\n         alt expr.node {\n           ast::expr_fn(_, decl, _, _) {\n-            (dbg_cx.names(\"fn\"), decl.output, expr.id)\n+            (@dbg_cx.names(\"fn\"), decl.output, expr.id)\n           }\n           ast::expr_fn_block(decl, _, _) {\n-            (dbg_cx.names(\"fn\"), decl.output, expr.id)\n+            (@dbg_cx.names(\"fn\"), decl.output, expr.id)\n           }\n           _ { fcx.ccx.sess.span_bug(expr.span, \"create_function: \\\n                   expected an expr_fn or fn_block here\"); }\n@@ -810,8 +810,8 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     let fn_metadata = [lltag(SubprogramTag),\n                        llunused(),\n                        file_node,\n-                       llstr(ident),\n-                       llstr(ident), //XXX fully-qualified C++ name\n+                       llstr(*ident),\n+                       llstr(*ident), //XXX fully-qualified C++ name\n                        llstr(\"\"), //XXX MIPS name?????\n                        file_node,\n                        lli32(loc.line as int),"}, {"sha": "ed15741e57b2a49c72ba8291b9b5fed32c800240", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -421,8 +421,8 @@ fn decl_x86_64_fn(tys: x86_64_tys,\n \n fn link_name(i: @ast::native_item) -> str {\n     alt attr::first_attr_value_str_by_name(i.attrs, \"link_name\") {\n-      none { ret i.ident; }\n-      option::some(ln) { ret ln; }\n+      none { ret *i.ident; }\n+      option::some(ln) { ret *ln; }\n     }\n }\n \n@@ -805,7 +805,7 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::native_item,\n     let fcx = new_fn_ctxt_w_id(ccx, path, decl, item.id,\n                                some(substs), some(item.span));\n     let mut bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n-    alt check item.ident {\n+    alt check *item.ident {\n       \"size_of\" {\n         let tp_ty = substs.tys[0];\n         let lltp_ty = type_of::type_of(ccx, tp_ty);\n@@ -913,7 +913,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n         let _icx = ccx.insn_ctxt(\"native::crust::build_rust_fn\");\n         let t = ty::node_id_to_type(ccx.tcx, id);\n         let ps = link::mangle_internal_name_by_path(\n-            ccx, path + [ast_map::path_name(\"__rust_abi\")]);\n+            ccx, path + [ast_map::path_name(@\"__rust_abi\")]);\n         let llty = type_of_fn_from_ty(ccx, t);\n         let llfndecl = decl_internal_cdecl_fn(ccx.llmod, ps, llty);\n         trans_fn(ccx, path, decl, body, llfndecl, no_self, none, id);\n@@ -950,7 +950,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n         }\n \n         let shim_name = link::mangle_internal_name_by_path(\n-            ccx, path + [ast_map::path_name(\"__rust_stack_shim\")]);\n+            ccx, path + [ast_map::path_name(@\"__rust_stack_shim\")]);\n         ret build_shim_fn_(ccx, shim_name, llrustfn, tys,\n                            lib::llvm::CCallConv,\n                            build_args, build_ret);"}, {"sha": "0eaeb6513682ffc4b588a0df08318b9b131d04ce", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -41,7 +41,7 @@ impl methods for reflector {\n \n     fn visit(ty_name: str, args: [ValueRef]) {\n         let tcx = self.bcx.tcx();\n-        let mth_idx = option::get(ty::method_idx(\"visit_\" + ty_name,\n+        let mth_idx = option::get(ty::method_idx(@(\"visit_\" + ty_name),\n                                                  *self.visitor_methods));\n         let mth_ty = ty::mk_fn(tcx, self.visitor_methods[mth_idx].fty);\n         let v = self.visitor_val;\n@@ -142,7 +142,7 @@ impl methods for reflector {\n             for fields.eachi {|i, field|\n                 self.bracketed_mt(\"rec_field\", field.mt,\n                                   [self.c_uint(i),\n-                                   self.c_slice(field.ident)]);\n+                                   self.c_slice(*field.ident)]);\n             }\n             self.visit(\"leave_rec\", [self.c_uint(vec::len(fields))]);\n           }\n@@ -209,7 +209,7 @@ impl methods for reflector {\n             for fields.eachi {|i, field|\n                 self.bracketed_mt(\"class_field\", field.mt,\n                                   [self.c_uint(i),\n-                                   self.c_slice(field.ident)]);\n+                                   self.c_slice(*field.ident)]);\n             }\n             self.visit(\"leave_class\", [self.c_uint(vec::len(fields))]);\n           }\n@@ -228,7 +228,7 @@ impl methods for reflector {\n                 let extra = [self.c_uint(i),\n                              self.c_int(v.disr_val),\n                              self.c_uint(vec::len(v.args)),\n-                             self.c_slice(v.name)];\n+                             self.c_slice(*v.name)];\n                 self.visit(\"enter_enum_variant\", extra);\n                 for v.args.eachi {|j, a|\n                     self.bracketed_t(\"enum_variant_field\", a,"}, {"sha": "cfd779460eb34b8a7bb35909a433236a7858828a", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -421,7 +421,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n             let variant_shape = shape_of_variant(ccx, v);\n             add_substr(data, variant_shape);\n \n-            let zname = str::bytes(v.name) + [0u8];\n+            let zname = str::bytes(*v.name) + [0u8];\n             add_substr(data, zname);\n         }\n         enum_variants += [variants];"}, {"sha": "1861f690f9eacbecc045a470cb546784d779829f", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -233,7 +233,7 @@ fn get_base_and_len(cx: block, v: ValueRef, e_ty: ty::t)\n     }\n }\n \n-fn trans_estr(bcx: block, s: str, vstore: ast::vstore,\n+fn trans_estr(bcx: block, s: @str, vstore: ast::vstore,\n               dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(\"tvec::trans_estr\");\n     let ccx = bcx.ccx();\n@@ -242,27 +242,27 @@ fn trans_estr(bcx: block, s: str, vstore: ast::vstore,\n       ast::vstore_fixed(_)\n       {\n         // \"hello\"/_  =>  \"hello\"/5  =>  [i8 x 6] in llvm\n-        #debug(\"trans_estr: fixed: %s\", s);\n-        C_postr(s)\n+        #debug(\"trans_estr: fixed: %s\", *s);\n+        C_postr(*s)\n       }\n \n       ast::vstore_slice(_) {\n         // \"hello\"  =>  (*i8, 6u) in llvm\n-        #debug(\"trans_estr: slice '%s'\", s);\n-        C_estr_slice(ccx, s)\n+        #debug(\"trans_estr: slice '%s'\", *s);\n+        C_estr_slice(ccx, *s)\n       }\n \n       ast::vstore_uniq {\n-        let cs = PointerCast(bcx, C_cstr(ccx, s), T_ptr(T_i8()));\n-        let len = C_uint(ccx, str::len(s));\n+        let cs = PointerCast(bcx, C_cstr(ccx, *s), T_ptr(T_i8()));\n+        let len = C_uint(ccx, str::len(*s));\n         let c = Call(bcx, ccx.upcalls.str_new_uniq, [cs, len]);\n         PointerCast(bcx, c,\n                     T_unique_ptr(T_unique(ccx, T_vec(ccx, T_i8()))))\n       }\n \n       ast::vstore_box {\n-        let cs = PointerCast(bcx, C_cstr(ccx, s), T_ptr(T_i8()));\n-        let len = C_uint(ccx, str::len(s));\n+        let cs = PointerCast(bcx, C_cstr(ccx, *s), T_ptr(T_i8()));\n+        let len = C_uint(ccx, str::len(*s));\n         Call(bcx, ccx.upcalls.str_new_shared, [cs, len])\n       }\n     };"}, {"sha": "315e3be2afd4fa394e41144c60aa0015c9062a71", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -76,7 +76,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n       }\n       ast_map::node_native_item(i@@{node: native_item_fn(_, _), _}, abi, _) {\n         if abi == native_abi_rust_intrinsic {\n-            let flags = alt check i.ident {\n+            let flags = alt check *i.ident {\n               \"visit_ty\" { 3u }\n               \"size_of\" |  \"pref_align_of\" | \"min_align_of\" |\n               \"init\" |  \"reinterpret_cast\" { use_repr }"}, {"sha": "acc11572fe2c2413083f081987dd4b103094fdb0", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -41,7 +41,7 @@ fn comma_str(args: [@constr_arg_use]) -> str {\n         if comma { rslt += \", \"; } else { comma = true; }\n         alt a.node {\n           carg_base { rslt += \"*\"; }\n-          carg_ident(i) { rslt += i.ident; }\n+          carg_ident(i) { rslt += *i.ident; }\n           carg_lit(l) { rslt += lit_to_str(l); }\n         }\n     }\n@@ -143,11 +143,11 @@ fn log_states_err(pp: pre_and_post_state) {\n     log_cond_err(p2);\n }\n \n-fn print_ident(i: ident) { log(debug, \" \" + i + \" \"); }\n+fn print_ident(i: ident) { log(debug, \" \" + *i + \" \"); }\n \n fn print_idents(&idents: [ident]) {\n     if vec::len::<ident>(idents) == 0u { ret; }\n-    log(debug, \"an ident: \" + vec::pop::<ident>(idents));\n+    log(debug, \"an ident: \" + *vec::pop::<ident>(idents));\n     print_idents(idents);\n }\n \n@@ -500,7 +500,7 @@ fn constraints(fcx: fn_ctxt) -> [norm_constraint] {\n fn match_args(fcx: fn_ctxt, occs: @dvec<pred_args>,\n               occ: [@constr_arg_use]) -> uint {\n     #debug(\"match_args: looking at %s\",\n-           constr_args_to_str(fn@(i: inst) -> str { ret i.ident; }, occ));\n+           constr_args_to_str(fn@(i: inst) -> str { ret *i.ident; }, occ));\n     for (*occs).each {|pd|\n         log(debug,\n                  \"match_args: candidate \" + pred_args_to_str(pd));\n@@ -581,7 +581,7 @@ fn expr_to_constr(tcx: ty::ctxt, e: @expr) -> sp_constr {\n \n fn pred_args_to_str(p: pred_args) -> str {\n     \"<\" + uint::str(p.node.bit_num) + \", \" +\n-        constr_args_to_str(fn@(i: inst) -> str { ret i.ident; }, p.node.args)\n+        constr_args_to_str(fn@(i: inst) -> str { ret *i.ident; }, p.node.args)\n         + \">\"\n }\n \n@@ -695,7 +695,7 @@ fn insts_to_str(stuff: [constr_arg_general_<inst>]) -> str {\n         rslt +=\n             \" \" +\n                 alt i {\n-                  carg_ident(p) { p.ident }\n+                  carg_ident(p) { *p.ident }\n                   carg_base { \"*\" }\n                   carg_lit(_) { \"[lit]\" }\n                 } + \" \";"}, {"sha": "a6ce1642bab6194930c9a3b0ffccaaea308375d2", "filename": "src/rustc/middle/tstate/collect_locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -138,7 +138,7 @@ fn mk_fn_info(ccx: crate_ctxt,\n          used_vars: v,\n          ignore: ignore};\n     ccx.fm.insert(id, rslt);\n-    #debug(\"%s has %u constraints\", name, num_constraints(rslt));\n+    #debug(\"%s has %u constraints\", *name, num_constraints(rslt));\n }\n \n "}, {"sha": "2b39288152b175be6b84e3d2e63895d297f5d8bb", "filename": "src/rustc/middle/tstate/states.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -516,7 +516,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n fn find_pre_post_state_stmt(fcx: fn_ctxt, pres: prestate, s: @stmt) -> bool {\n     let stmt_ann = stmt_to_ann(fcx.ccx, *s);\n \n-    #debug[\"[ %s ]\", fcx.name];\n+    #debug[\"[ %s ]\", *fcx.name];\n     #debug[\"*At beginning: stmt = %s\", stmt_to_str(*s)];\n     #debug[\"*prestate = %s\", tritv::to_str(stmt_ann.states.prestate)];\n     #debug[\"*poststate = %s\", tritv::to_str(stmt_ann.states.prestate)];"}, {"sha": "02e683f4cbc731b3cdccc4276a244cfbc3fe963a", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -237,7 +237,7 @@ type ctxt =\n       node_type_substs: hashmap<node_id, [t]>,\n \n       items: ast_map::map,\n-      intrinsic_ifaces: hashmap<str, (ast::def_id, t)>,\n+      intrinsic_ifaces: hashmap<ast::ident, (ast::def_id, t)>,\n       freevars: freevars::freevar_map,\n       tcache: type_cache,\n       rcache: creader_cache,\n@@ -322,7 +322,7 @@ enum region {\n enum bound_region {\n     br_self,      // The self region for classes, impls\n     br_anon,      // The anonymous region parameter for a given function.\n-    br_named(str) // A named region parameter.\n+    br_named(ast::ident) // A named region parameter.\n }\n \n type opt_region = option<region>;\n@@ -414,7 +414,7 @@ enum type_err {\n     terr_constr_mismatch(@type_constr, @type_constr),\n     terr_regions_differ(region, region),\n     terr_vstores_differ(terr_vstore_kind, vstore, vstore),\n-    terr_in_field(@type_err, str),\n+    terr_in_field(@type_err, ast::ident),\n     terr_sorts(t, t),\n     terr_self_substs\n }\n@@ -516,7 +516,7 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n       node_types: @smallintmap::mk(),\n       node_type_substs: map::int_hash(),\n       items: amap,\n-      intrinsic_ifaces: map::str_hash(),\n+      intrinsic_ifaces: map::box_str_hash(),\n       freevars: freevars,\n       tcache: ast_util::new_def_hash(),\n       rcache: mk_rcache(),\n@@ -1992,7 +1992,7 @@ fn hash_bound_region(br: bound_region) -> uint {\n     alt br { // no idea if this is any good\n       ty::br_self { 0u }\n       ty::br_anon { 1u }\n-      ty::br_named(str) { str::hash(str) }\n+      ty::br_named(str) { str::hash(*str) }\n     }\n }\n \n@@ -2298,7 +2298,7 @@ fn field_idx(id: ast::ident, fields: [field]) -> option<uint> {\n }\n \n fn get_field(rec_ty: t, id: ast::ident) -> field {\n-    alt check vec::find(get_fields(rec_ty), {|f| str::eq(f.ident, id) }) {\n+    alt check vec::find(get_fields(rec_ty), {|f| str::eq(*f.ident, *id) }) {\n       some(f) { f }\n     }\n }\n@@ -2490,8 +2490,8 @@ fn type_err_to_str(cx: ctxt, err: type_err) -> str {\n       }\n       terr_record_mutability { ret \"record elements differ in mutability\"; }\n       terr_record_fields(e_fld, a_fld) {\n-        ret \"expected a record with field `\" + e_fld +\n-                \"` but found one with field `\" + a_fld + \"`\";\n+        ret \"expected a record with field `\" + *e_fld +\n+                \"` but found one with field `\" + *a_fld + \"`\";\n       }\n       terr_arg_count { ret \"incorrect number of function parameters\"; }\n       terr_mode_mismatch(e_mode, a_mode) {\n@@ -2521,7 +2521,7 @@ fn type_err_to_str(cx: ctxt, err: type_err) -> str {\n                  vstore_to_str(cx, a_vs));\n       }\n       terr_in_field(err, fname) {\n-        ret #fmt(\"in field `%s`, %s\", fname, type_err_to_str(cx, *err));\n+        ret #fmt(\"in field `%s`, %s\", *fname, type_err_to_str(cx, *err));\n       }\n       terr_sorts(exp, act) {\n         ret #fmt(\"%s vs %s\", ty_sort_str(cx, exp), ty_sort_str(cx, act));\n@@ -2592,7 +2592,7 @@ fn ty_to_def_id(ty: t) -> option<ast::def_id> {\n }\n \n // Enum information\n-type variant_info = @{args: [t], ctor_ty: t, name: str,\n+type variant_info = @{args: [t], ctor_ty: t, name: ast::ident,\n                       id: ast::def_id, disr_val: int};\n \n fn substd_enum_variants(cx: ctxt,\n@@ -2667,7 +2667,7 @@ fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n               *path + [ast_map::path_name(nm)]\n           }\n           ast_map::node_dtor(_, _, _, path) {\n-              *path + [ast_map::path_name(\"dtor\")]\n+              *path + [ast_map::path_name(@\"dtor\")]\n           }\n \n \n@@ -2861,7 +2861,7 @@ fn lookup_class_method_by_name(cx:ctxt, did: ast::def_id, name: ident,\n          }\n        }\n        cx.sess.span_fatal(sp, #fmt(\"Class doesn't have a method \\\n-           named %s\", name));\n+           named %s\", *name));\n     }\n     else {\n       csearch::get_class_method(cx.sess.cstore, did, name)"}, {"sha": "079228ada78f1688d39387f372117efafe5931ca", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -260,7 +260,7 @@ fn check_fn(ccx: @crate_ctxt,\n         vec::iter2(arg_tys, decl.inputs) {|arg_ty, input|\n             assign(input.id, some(arg_ty));\n             #debug[\"Argument %s is assigned to %s\",\n-                   input.ident, fcx.locals.get(input.id).to_str()];\n+                   *input.ident, fcx.locals.get(input.id).to_str()];\n         }\n \n         // Add explicitly-declared locals.\n@@ -284,7 +284,7 @@ fn check_fn(ccx: @crate_ctxt,\n               if !pat_util::pat_is_variant(fcx.ccx.tcx.def_map, p) {\n                 assign(p.id, none);\n                 #debug[\"Pattern binding %s is assigned to %s\",\n-                       path.idents[0],\n+                       *path.idents[0],\n                        fcx.locals.get(p.id).to_str()];\n               }\n               _ {}\n@@ -443,13 +443,13 @@ impl of region_scope for @fn_ctxt {\n     fn anon_region() -> result<ty::region, str> {\n         result::ok(self.infcx.next_region_var())\n     }\n-    fn named_region(id: str) -> result<ty::region, str> {\n+    fn named_region(id: ast::ident) -> result<ty::region, str> {\n         empty_rscope.named_region(id).chain_err { |_e|\n             alt self.in_scope_regions.find(ty::br_named(id)) {\n               some(r) { result::ok(r) }\n-              none if id == \"blk\" { self.block_region() }\n+              none if *id == \"blk\" { self.block_region() }\n               none {\n-                result::err(#fmt[\"named region `%s` not in scope here\", id])\n+                result::err(#fmt[\"named region `%s` not in scope here\", *id])\n               }\n             }\n         }\n@@ -937,7 +937,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                                    self_expr: self_ex,\n                                    borrow_scope: op_ex.id,\n                                    node_id: callee_id,\n-                                   m_name: opname,\n+                                   m_name: @opname,\n                                    self_ty: self_t,\n                                    supplied_tps: [],\n                                    include_private: false});\n@@ -1113,7 +1113,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       ast::expr_vstore(ev, vst) {\n         let typ = alt ev.node {\n           ast::expr_lit(@{node: ast::lit_str(s), span:_}) {\n-            let tt = ast_expr_vstore_to_vstore(fcx, ev, str::len(s), vst);\n+            let tt = ast_expr_vstore_to_vstore(fcx, ev, str::len(*s), vst);\n             ty::mk_estr(tcx, tt)\n           }\n           ast::expr_vec(args, mutbl) {\n@@ -1553,15 +1553,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             for fields_t.each {|f|\n                 let mut found = false;\n                 for base_fields.each {|bf|\n-                    if str::eq(f.node.ident, bf.ident) {\n+                    if str::eq(*f.node.ident, *bf.ident) {\n                         demand::suptype(fcx, f.span, bf.mt.ty, f.node.mt.ty);\n                         found = true;\n                     }\n                 }\n                 if !found {\n                     tcx.sess.span_fatal(f.span,\n                                         \"unknown field in record update: \" +\n-                                            f.node.ident);\n+                                            *f.node.ident);\n                 }\n             }\n           }\n@@ -1645,7 +1645,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 let t_err = fcx.infcx.resolve_type_vars_if_possible(expr_t);\n                 let msg = #fmt[\"attempted access of field %s on type %s, but \\\n                           no public field or method with that name was found\",\n-                               field, ty_to_str(tcx, t_err)];\n+                               *field, ty_to_str(tcx, t_err)];\n                 tcx.sess.span_err(expr.span, msg);\n                 // NB: Adding a bogus type to allow typechecking to continue\n                 fcx.write_ty(id, fcx.infcx.next_ty_var());\n@@ -1690,7 +1690,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                                    self_expr: p,\n                                    borrow_scope: expr.id,\n                                    node_id: alloc_id,\n-                                   m_name: \"alloc\",\n+                                   m_name: @\"alloc\",\n                                    self_ty: p_ty,\n                                    supplied_tps: [],\n                                    include_private: false});\n@@ -2310,7 +2310,7 @@ fn check_bounds_are_used(ccx: @crate_ctxt,\n     for tps_used.eachi { |i, b|\n         if !b {\n             ccx.tcx.sess.span_err(\n-                span, #fmt[\"Type parameter %s is unused.\", tps[i].ident]);\n+                span, #fmt[\"Type parameter %s is unused.\", *tps[i].ident]);\n         }\n     }\n }\n@@ -2323,7 +2323,7 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::native_item) {\n         {mode: ast::expl(m), ty: ty}\n     }\n     let tcx = ccx.tcx;\n-    let (n_tps, inputs, output) = alt it.ident {\n+    let (n_tps, inputs, output) = alt *it.ident {\n       \"size_of\" |\n       \"pref_align_of\" | \"min_align_of\" { (1u, [], ty::mk_uint(ccx.tcx)) }\n       \"get_tydesc\" { (1u, [], ty::mk_nil_ptr(tcx)) }\n@@ -2337,8 +2337,8 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::native_item) {\n       \"needs_drop\" { (1u, [], ty::mk_bool(tcx)) }\n \n       \"visit_ty\" {\n-        assert ccx.tcx.intrinsic_ifaces.contains_key(\"ty_visitor\");\n-        let (_, visitor_iface) = ccx.tcx.intrinsic_ifaces.get(\"ty_visitor\");\n+        assert ccx.tcx.intrinsic_ifaces.contains_key(@\"ty_visitor\");\n+        let (_, visitor_iface) = ccx.tcx.intrinsic_ifaces.get(@\"ty_visitor\");\n         (1u, [arg(ast::by_ref, visitor_iface)], ty::mk_nil(tcx))\n       }\n       \"frame_address\" {"}, {"sha": "d274423c815a54376948b414aa661213cf3604ed", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -191,8 +191,8 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n                       fields\",\n                                 ex_f_count, f_count]);\n         }\n-        fn matches(name: str, f: ty::field) -> bool {\n-            ret str::eq(name, f.ident);\n+        fn matches(name: ast::ident, f: ty::field) -> bool {\n+            ret str::eq(*name, *f.ident);\n         }\n         for fields.each {|f|\n             alt vec::find(ex_fields, bind matches(f.ident, _)) {\n@@ -203,7 +203,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n                 tcx.sess.span_fatal(pat.span,\n                                     #fmt[\"mismatched types: did not \\\n                                           expect a record with a field `%s`\",\n-                                         f.ident]);\n+                                         *f.ident]);\n               }\n             }\n         }"}, {"sha": "22d51093fa301caa53c3f4d5382d1c3815e68ca0", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -19,7 +19,7 @@ impl methods for lookup {\n     // Entrypoint:\n     fn method() -> option<method_origin> {\n         #debug[\"method lookup(m_name=%s, self_ty=%s)\",\n-               self.m_name, self.fcx.infcx.ty_to_str(self.self_ty)];\n+               *self.m_name, self.fcx.infcx.ty_to_str(self.self_ty)];\n \n         // First, see whether this is an interface-bounded parameter\n         let pass1 = alt ty::get(self.self_ty).struct {"}, {"sha": "a837f1b267c4e51b6254f818c521e5bf7367563f", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -65,7 +65,7 @@ fn visit_pat(p: @ast::pat, &&rcx: rcx, v: rvt) {\n     alt p.node {\n       ast::pat_ident(path, _)\n       if !pat_util::pat_is_variant(fcx.ccx.tcx.def_map, p) {\n-        #debug[\"visit_pat binding=%s\", path.idents[0]];\n+        #debug[\"visit_pat binding=%s\", *path.idents[0]];\n         visit_node(p.id, p.span, rcx);\n       }\n       _ {}"}, {"sha": "afc79b52428be25883944394e3fefd9b326f02e7", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -29,7 +29,7 @@ fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n     // there ought to be a better approach. Attributes?\n \n     for crate.node.module.items.each {|crate_item|\n-        if crate_item.ident == \"intrinsic\" {\n+        if *crate_item.ident == \"intrinsic\" {\n             alt crate_item.node {\n               ast::item_mod(m) {\n                 for m.items.each {|intrinsic_item|\n@@ -170,15 +170,15 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n                        self_ty: ty::t) {\n \n     if impl_m.tps != if_m.tps {\n-        tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n+        tcx.sess.span_err(sp, \"method `\" + *if_m.ident +\n                           \"` has an incompatible set of type parameters\");\n         ret;\n     }\n \n     if vec::len(impl_m.fty.inputs) != vec::len(if_m.fty.inputs) {\n         tcx.sess.span_err(sp,#fmt[\"method `%s` has %u parameters \\\n                                    but the iface has %u\",\n-                                  if_m.ident,\n+                                  *if_m.ident,\n                                   vec::len(impl_m.fty.inputs),\n                                   vec::len(if_m.fty.inputs)]);\n         ret;\n@@ -211,7 +211,7 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n     };\n     require_same_types(\n         tcx, sp, impl_fty, if_fty,\n-        {|| \"method `\" + if_m.ident + \"` has an incompatible type\"});\n+        {|| \"method `\" + *if_m.ident + \"` has an incompatible type\"});\n     ret;\n \n     // Replaces bound references to the self region with `with_r`.\n@@ -242,7 +242,7 @@ fn check_methods_against_iface(ccx: @crate_ctxt,\n                 ccx.tcx.sess.span_err(\n                     span, #fmt[\"method `%s`'s purity \\\n                                 not match the iface method's \\\n-                                purity\", m.ident]);\n+                                purity\", *m.ident]);\n             }\n             compare_impl_method(\n                 ccx.tcx, span, m, vec::len(tps),\n@@ -251,7 +251,7 @@ fn check_methods_against_iface(ccx: @crate_ctxt,\n           none {\n             tcx.sess.span_err(\n                 a_ifacety.path.span,\n-                #fmt[\"missing method `%s`\", if_m.ident]);\n+                #fmt[\"missing method `%s`\", *if_m.ident]);\n           }\n         } // alt\n     } // |if_m|\n@@ -511,7 +511,7 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n                    rp: ast::rp_none, // functions do not have a self\n                    ty: ty::mk_fn(ccx.tcx, tofd)};\n         #debug[\"type of %s (id %d) is %s\",\n-               it.ident, it.id, ty_to_str(tcx, tpt.ty)];\n+               *it.ident, it.id, ty_to_str(tcx, tpt.ty)];\n         ccx.tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }"}, {"sha": "2420250aa1ad6910fbc36f5abcf12f128ed0e562", "filename": "src/rustc/middle/typeck/rscope.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -2,16 +2,16 @@ import result::result;\n \n iface region_scope {\n     fn anon_region() -> result<ty::region, str>;\n-    fn named_region(id: str) -> result<ty::region, str>;\n+    fn named_region(id: ast::ident) -> result<ty::region, str>;\n }\n \n enum empty_rscope { empty_rscope }\n impl of region_scope for empty_rscope {\n     fn anon_region() -> result<ty::region, str> {\n         result::err(\"region types are not allowed here\")\n     }\n-    fn named_region(id: str) -> result<ty::region, str> {\n-        if id == \"static\" { result::ok(ty::re_static) }\n+    fn named_region(id: ast::ident) -> result<ty::region, str> {\n+        if *id == \"static\" { result::ok(ty::re_static) }\n         else { result::err(\"only the static region is allowed here\") }\n     }\n }\n@@ -27,9 +27,9 @@ impl of region_scope for type_rscope {\n           }\n         }\n     }\n-    fn named_region(id: str) -> result<ty::region, str> {\n+    fn named_region(id: ast::ident) -> result<ty::region, str> {\n         empty_rscope.named_region(id).chain_err { |_e|\n-            if id == \"self\" { self.anon_region() }\n+            if *id == \"self\" { self.anon_region() }\n             else {\n                 result::err(\"named regions other than `self` are not \\\n                              allowed as part of a type declaration\")\n@@ -47,7 +47,7 @@ impl of region_scope for @anon_rscope {\n     fn anon_region() -> result<ty::region, str> {\n         result::ok(self.anon)\n     }\n-    fn named_region(id: str) -> result<ty::region, str> {\n+    fn named_region(id: ast::ident) -> result<ty::region, str> {\n         self.base.named_region(id)\n     }\n }\n@@ -61,7 +61,7 @@ impl of region_scope for @binding_rscope {\n     fn anon_region() -> result<ty::region, str> {\n         result::ok(ty::re_bound(ty::br_anon))\n     }\n-    fn named_region(id: str) -> result<ty::region, str> {\n+    fn named_region(id: ast::ident) -> result<ty::region, str> {\n         self.base.named_region(id).chain_err {|_e|\n             result::ok(ty::re_bound(ty::br_named(id)))\n         }"}, {"sha": "e382e3835baea70495dbf3df11f57af43cc29b0a", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -72,7 +72,7 @@ fn local_rhs_span(l: @ast::local, def: span) -> span {\n fn is_main_name(path: syntax::ast_map::path) -> bool {\n     // FIXME: path should be a constrained type, so we know\n     // the call to last doesn't fail\n-    vec::last(path) == syntax::ast_map::path_name(\"main\")\n+    vec::last(path) == syntax::ast_map::path_name(@\"main\")\n }\n \n //"}, {"sha": "431eb8b0aea6a0472fa8d039121cfc8d61eee701", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -21,7 +21,7 @@ import driver::session::session;\n fn bound_region_to_str(cx: ctxt, br: bound_region) -> str {\n     alt br {\n       br_anon                        { \"&\" }\n-      br_named(str)                  { #fmt[\"&%s\", str] }\n+      br_named(str)                  { #fmt[\"&%s\", *str] }\n       br_self if cx.sess.ppregions() { \"&<self>\" }\n       br_self                        { \"&self\" }\n     }\n@@ -130,7 +130,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n           _ {purity_to_str(purity) + \" \"}\n         };\n         s += proto_to_str(proto);\n-        alt ident { some(i) { s += \" \"; s += i; } _ { } }\n+        alt ident { some(i) { s += \" \"; s += *i; } _ { } }\n         s += \"(\";\n         let mut strs = [];\n         for inputs.each {|a| strs += [fn_input_to_str(cx, a)]; }\n@@ -152,7 +152,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n             m.fty.output, m.fty.ret_style, m.fty.constraints) + \";\";\n     }\n     fn field_to_str(cx: ctxt, f: field) -> str {\n-        ret f.ident + \": \" + mt_to_str(cx, f.mt);\n+        ret *f.ident + \": \" + mt_to_str(cx, f.mt);\n     }\n \n     // if there is an id, print that instead of the structural type:"}, {"sha": "ca0878626a43781df0dddb127a7b9eb25c7f140b", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -67,7 +67,8 @@ fn parse_crate(attrs: [ast::attribute]) -> crate_attrs {\n     let link_metas = attr::find_linkage_metas(attrs);\n \n     {\n-        name: attr::last_meta_item_value_str_by_name(link_metas, \"name\")\n+        name: attr::last_meta_item_value_str_by_name(\n+            link_metas, \"name\").map({|x|*x})\n     }\n }\n \n@@ -98,7 +99,7 @@ fn should_not_extract_crate_name_if_no_name_value_in_link_attribute() {\n fn parse_desc(attrs: [ast::attribute]) -> option<str> {\n     alt doc_meta(attrs) {\n       some(meta) {\n-        attr::get_meta_item_value_str(meta)\n+        attr::get_meta_item_value_str(meta).map({|x|*x})\n       }\n       none { none }\n     }"}, {"sha": "983576e581687b1aee9ca99d3b60f82ffab62331", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -151,7 +151,7 @@ fn fold_enum(\n                   }, _) {\n                     let ast_variant = option::get(\n                         vec::find(ast_variants) {|v|\n-                            v.node.name == variant.name\n+                            *v.node.name == variant.name\n                         });\n \n                     attr_parser::parse_desc(ast_variant.node.attrs)\n@@ -207,14 +207,14 @@ fn merge_method_attrs(\n             node: ast::item_iface(_, _, methods), _\n           }, _) {\n             par::seqmap(methods) {|method|\n-                (method.ident, attr_parser::parse_desc(method.attrs))\n+                (*method.ident, attr_parser::parse_desc(method.attrs))\n             }\n           }\n           ast_map::node_item(@{\n             node: ast::item_impl(_, _, _, _, methods), _\n           }, _) {\n             par::seqmap(methods) {|method|\n-                (method.ident, attr_parser::parse_desc(method.attrs))\n+                (*method.ident, attr_parser::parse_desc(method.attrs))\n             }\n           }\n           _ { fail \"unexpected item\" }"}, {"sha": "35e9fd5ea31b2b1377ea311bd2add49a8cc06059", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -33,14 +33,14 @@ fn top_moddoc_from_crate(\n     crate: @ast::crate,\n     default_name: str\n ) -> doc::moddoc {\n-    moddoc_from_mod(mk_itemdoc(ast::crate_node_id, default_name),\n+    moddoc_from_mod(mk_itemdoc(ast::crate_node_id, @default_name),\n                     crate.node.module)\n }\n \n fn mk_itemdoc(id: ast::node_id, name: ast::ident) -> doc::itemdoc {\n     {\n         id: id,\n-        name: name,\n+        name: *name,\n         path: [],\n         brief: none,\n         desc: none,\n@@ -169,7 +169,7 @@ fn variantdocs_from_variants(\n \n fn variantdoc_from_variant(variant: ast::variant) -> doc::variantdoc {\n     {\n-        name: variant.node.name,\n+        name: *variant.node.name,\n         desc: none,\n         sig: none\n     }\n@@ -210,7 +210,7 @@ fn ifacedoc_from_iface(\n         item: itemdoc,\n         methods: par::seqmap(methods) {|method|\n             {\n-                name: method.ident,\n+                name: *method.ident,\n                 brief: none,\n                 desc: none,\n                 sections: [],\n@@ -242,7 +242,7 @@ fn impldoc_from_impl(\n         self_ty: none,\n         methods: par::seqmap(methods) {|method|\n             {\n-                name: method.ident,\n+                name: *method.ident,\n                 brief: none,\n                 desc: none,\n                 sections: [],"}, {"sha": "0c4614adf1dac14335756b471a4380a5b0acc9ab", "filename": "src/rustdoc/prune_unexported_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustdoc%2Fprune_unexported_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustdoc%2Fprune_unexported_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_unexported_pass.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -114,7 +114,7 @@ fn is_exported_from_mod(\n           ast_map::node_item(item, _) {\n             alt item.node {\n               ast::item_mod(m) {\n-                ast_util::is_exported(item_name, m)\n+                ast_util::is_exported(@item_name, m)\n               }\n               _ {\n                 fail \"is_exported_from_mod: not a mod\";\n@@ -131,7 +131,7 @@ fn is_exported_from_crate(\n     item_name: str\n ) -> bool {\n     astsrv::exec(srv) {|ctxt|\n-        ast_util::is_exported(item_name, ctxt.ast.node.module)\n+        ast_util::is_exported(@item_name, ctxt.ast.node.module)\n     }\n }\n "}, {"sha": "f9448bff082af503d80a5d874fbf7fe6c52a3d4a", "filename": "src/rustdoc/reexport_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -187,7 +187,7 @@ fn build_reexport_path_map(srv: astsrv::srv, -def_map: def_map) -> path_map {\n                 if !def.reexp { cont; }\n                 alt def_map.find(def.id) {\n                   some(itemtag) {\n-                    reexportdocs += [(name, itemtag)];\n+                    reexportdocs += [(*name, itemtag)];\n                   }\n                   _ {}\n                 }\n@@ -231,17 +231,17 @@ fn find_reexport_impl_docs(\n           some(ast_map::node_item(item, path)) {\n             let path = ast_map::path_to_str(*path);\n             if str::is_empty(path) {\n-                item.ident\n+                *item.ident\n             } else {\n-                path + \"::\" + item.ident\n+                path + \"::\" + *item.ident\n             }\n           }\n           _ {\n             assert mod_id == ast::crate_node_id;\n             \"\"\n           }\n         };\n-        let ident = i.ident;\n+        let ident = *i.ident;\n         let doc = alt check def_map.find(i.did) {\n           some(doc) { doc }\n         };"}, {"sha": "85740205ffa5bfc409ff1e85a97edea1875510b6", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=ce750a7dbcd2dc68db6de89956b1de3ecf9f2d0a", "patch": "@@ -116,7 +116,7 @@ fn fold_enum(\n                   }, _) {\n                     let ast_variant = option::get(\n                         vec::find(ast_variants) {|v|\n-                            v.node.name == variant.name\n+                            *v.node.name == variant.name\n                         });\n \n                     pprust::variant_to_str(ast_variant)\n@@ -151,7 +151,7 @@ fn fold_res(\n               ast_map::node_item(@{\n                 node: ast::item_res(decl, tys, _, _, _, rp), _\n               }, _) {\n-                pprust::res_to_str(decl, doc.name(), tys, rp)\n+                pprust::res_to_str(decl, @doc.name(), tys, rp)\n               }\n             }\n         })\n@@ -200,7 +200,7 @@ fn get_method_sig(\n             node: ast::item_iface(_, _, methods), _\n           }, _) {\n             alt check vec::find(methods) {|method|\n-                method.ident == method_name\n+                *method.ident == method_name\n             } {\n                 some(method) {\n                     some(pprust::fun_to_str(\n@@ -215,7 +215,7 @@ fn get_method_sig(\n             node: ast::item_impl(_, _, _, _, methods), _\n           }, _) {\n             alt check vec::find(methods) {|method|\n-                method.ident == method_name\n+                *method.ident == method_name\n             } {\n                 some(method) {\n                     some(pprust::fun_to_str(\n@@ -307,7 +307,7 @@ fn fold_type(\n               }, _) {\n                 some(#fmt(\n                     \"type %s%s = %s\",\n-                    ident,\n+                    *ident,\n                     pprust::typarams_to_str(params),\n                     pprust::ty_to_str(ty)\n                 ))"}]}