{"sha": "39484ac3b0b80c1c98c4d46a9f88336c02f24da6", "node_id": "C_kwDOAAsO6NoAKDM5NDg0YWMzYjBiODBjMWM5OGM0ZDQ2YTlmODgzMzZjMDJmMjRkYTY", "commit": {"author": {"name": "Josh Triplett", "email": "josh@joshtriplett.org", "date": "2022-09-24T16:20:23Z"}, "committer": {"name": "Josh Triplett", "email": "josh@joshtriplett.org", "date": "2022-09-24T18:49:58Z"}, "message": "Move style guide to rust-lang/rust\n\nPer [RFC 3309](https://rust-lang.github.io/rfcs/3309-style-team.html).", "tree": {"sha": "39349533f0aeda296bfccf98d2d583d76111d851", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39349533f0aeda296bfccf98d2d583d76111d851"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39484ac3b0b80c1c98c4d46a9f88336c02f24da6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39484ac3b0b80c1c98c4d46a9f88336c02f24da6", "html_url": "https://github.com/rust-lang/rust/commit/39484ac3b0b80c1c98c4d46a9f88336c02f24da6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/comments", "author": {"login": "joshtriplett", "id": 162737, "node_id": "MDQ6VXNlcjE2MjczNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162737?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joshtriplett", "html_url": "https://github.com/joshtriplett", "followers_url": "https://api.github.com/users/joshtriplett/followers", "following_url": "https://api.github.com/users/joshtriplett/following{/other_user}", "gists_url": "https://api.github.com/users/joshtriplett/gists{/gist_id}", "starred_url": "https://api.github.com/users/joshtriplett/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joshtriplett/subscriptions", "organizations_url": "https://api.github.com/users/joshtriplett/orgs", "repos_url": "https://api.github.com/users/joshtriplett/repos", "events_url": "https://api.github.com/users/joshtriplett/events{/privacy}", "received_events_url": "https://api.github.com/users/joshtriplett/received_events", "type": "User", "site_admin": false}, "committer": {"login": "joshtriplett", "id": 162737, "node_id": "MDQ6VXNlcjE2MjczNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162737?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joshtriplett", "html_url": "https://github.com/joshtriplett", "followers_url": "https://api.github.com/users/joshtriplett/followers", "following_url": "https://api.github.com/users/joshtriplett/following{/other_user}", "gists_url": "https://api.github.com/users/joshtriplett/gists{/gist_id}", "starred_url": "https://api.github.com/users/joshtriplett/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joshtriplett/subscriptions", "organizations_url": "https://api.github.com/users/joshtriplett/orgs", "repos_url": "https://api.github.com/users/joshtriplett/repos", "events_url": "https://api.github.com/users/joshtriplett/events{/privacy}", "received_events_url": "https://api.github.com/users/joshtriplett/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb5a01617589b5e3ece5a36435fc285bfd13c9a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb5a01617589b5e3ece5a36435fc285bfd13c9a4", "html_url": "https://github.com/rust-lang/rust/commit/bb5a01617589b5e3ece5a36435fc285bfd13c9a4"}], "stats": {"total": 2003, "additions": 2003, "deletions": 0}, "files": [{"sha": "4d1a1e084d529839be35c1b4b2643e3e01b6c9fa", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=39484ac3b0b80c1c98c4d46a9f88336c02f24da6", "patch": "@@ -704,6 +704,7 @@ impl<'a> Builder<'a> {\n                 doc::Miri,\n                 doc::EmbeddedBook,\n                 doc::EditionGuide,\n+                doc::StyleGuide,\n             ),\n             Kind::Dist => describe!(\n                 dist::Docs,"}, {"sha": "7bdd226cb692ea3695c11387f9ddc2bcf33d31d7", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=39484ac3b0b80c1c98c4d46a9f88336c02f24da6", "patch": "@@ -82,6 +82,7 @@ book!(\n     Reference, \"src/doc/reference\", \"reference\", submodule;\n     RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\", submodule;\n     RustdocBook, \"src/doc/rustdoc\", \"rustdoc\";\n+    StyleGuide, \"src/doc/style-guide\", \"style-guide\";\n );\n \n fn open(builder: &Builder<'_>, path: impl AsRef<Path>) {"}, {"sha": "bf08960f338a3e3cee51b3f11e75864bdbff7ede", "filename": "src/doc/index.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=39484ac3b0b80c1c98c4d46a9f88336c02f24da6", "patch": "@@ -113,6 +113,12 @@ resources useful.\n [The Reference](reference/index.html) is not a formal spec, but is more detailed and\n comprehensive than the book.\n \n+## The Style Guide\n+\n+[The Rust Style Guide](style-guide/index.html) describes the standard formatting of Rust\n+code. Most developers use rustfmt to format their code, and rustfmt's default\n+formatting matches this style guide.\n+\n ## The Rustonomicon\n \n [The Rustonomicon](nomicon/index.html) is your guidebook to the dark arts of unsafe"}, {"sha": "056aec8cdd4f631c1e4c174891c2b1f9f8aaa812", "filename": "src/doc/style-guide/book.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fdoc%2Fstyle-guide%2Fbook.toml", "raw_url": "https://github.com/rust-lang/rust/raw/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fdoc%2Fstyle-guide%2Fbook.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fbook.toml?ref=39484ac3b0b80c1c98c4d46a9f88336c02f24da6", "patch": "@@ -0,0 +1,8 @@\n+[book]\n+title = \"The Rust Style Guide\"\n+author = \"The Rust Style Team\"\n+multilingual = false\n+src = \"src\"\n+\n+[output.html]\n+git-repository-url = \"https://github.com/rust-lang/rust/tree/HEAD/src/doc/style-guide/\""}, {"sha": "adb73a7eef6e00345cea87f43b2ca474e75390f8", "filename": "src/doc/style-guide/src/README.md", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fdoc%2Fstyle-guide%2Fsrc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fdoc%2Fstyle-guide%2Fsrc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fsrc%2FREADME.md?ref=39484ac3b0b80c1c98c4d46a9f88336c02f24da6", "patch": "@@ -0,0 +1,190 @@\n+# Rust Style Guide\n+\n+## Motivation - why use a formatting tool?\n+\n+Formatting code is a mostly mechanical task which takes both time and mental\n+effort. By using an automatic formatting tool, a programmer is relieved of\n+this task and can concentrate on more important things.\n+\n+Furthermore, by sticking to an established style guide (such as this one),\n+programmers don't need to formulate ad hoc style rules, nor do they need to\n+debate with other programmers what style rules should be used, saving time,\n+communication overhead, and mental energy.\n+\n+Humans comprehend information through pattern matching. By ensuring that all\n+Rust code has similar formatting, less mental effort is required to comprehend a\n+new project, lowering the barrier to entry for new developers.\n+\n+Thus, there are productivity benefits to using a formatting tool (such as\n+rustfmt), and even larger benefits by using a community-consistent formatting,\n+typically by using a formatting tool's default settings.\n+\n+\n+## Formatting conventions\n+\n+### Indentation and line width\n+\n+* Use spaces, not tabs.\n+* Each level of indentation must be four spaces (that is, all indentation\n+  outside of string literals and comments must be a multiple of four).\n+* The maximum width for a line is 100 characters.\n+* A tool should be configurable for all three of these variables.\n+\n+\n+### Blank lines\n+\n+Separate items and statements by either zero or one blank lines (i.e., one or\n+two newlines). E.g,\n+\n+```rust\n+fn foo() {\n+    let x = ...;\n+\n+    let y = ...;\n+    let z = ...;\n+}\n+\n+fn bar() {}\n+fn baz() {}\n+```\n+\n+Formatting tools should make the bounds on blank lines configurable: there\n+should be separate minimum and maximum numbers of newlines between both\n+statements and (top-level) items (i.e., four options). As described above, the\n+defaults for both statements and items should be minimum: 1, maximum: 2.\n+\n+\n+### [Module-level items](items.md)\n+### [Statements](statements.md)\n+### [Expressions](expressions.md)\n+### [Types](types.md)\n+\n+\n+### Comments\n+\n+The following guidelines for comments are recommendations only, a mechanical\n+formatter might skip formatting of comments.\n+\n+Prefer line comments (`//`) to block comments (`/* ... */`).\n+\n+When using line comments there should be a single space after the opening sigil.\n+\n+When using single-line block comments there should be a single space after the\n+opening sigil and before the closing sigil. Multi-line block comments should\n+have a newline after the opening sigil and before the closing sigil.\n+\n+Prefer to put a comment on its own line. Where a comment follows code, there\n+should be a single space before it. Where a block comment is inline, there\n+should be surrounding whitespace as if it were an identifier or keyword. There\n+should be no trailing whitespace after a comment or at the end of any line in a\n+multi-line comment. Examples:\n+\n+```rust\n+// A comment on an item.\n+struct Foo { ... }\n+\n+fn foo() {} // A comment after an item.\n+\n+pub fn foo(/* a comment before an argument */ x: T) {...}\n+```\n+\n+Comments should usually be complete sentences. Start with a capital letter, end\n+with a period (`.`). An inline block comment may be treated as a note without\n+punctuation.\n+\n+Source lines which are entirely a comment should be limited to 80 characters\n+in length (including comment sigils, but excluding indentation) or the maximum\n+width of the line (including comment sigils and indentation), whichever is\n+smaller:\n+\n+```rust\n+// This comment goes up to the ................................. 80 char margin.\n+\n+{\n+    // This comment is .............................................. 80 chars wide.\n+}\n+\n+{\n+    {\n+        {\n+            {\n+                {\n+                    {\n+                        // This comment is limited by the ......................... 100 char margin.\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+```\n+\n+#### Doc comments\n+\n+Prefer line comments (`///`) to block comments (`/** ... */`).\n+\n+Prefer outer doc comments (`///` or `/** ... */`), only use inner doc comments\n+(`//!` and `/*! ... */`) to write module-level or crate-level documentation.\n+\n+Doc comments should come before attributes.\n+\n+### Attributes\n+\n+Put each attribute on its own line, indented to the level of the item.\n+In the case of inner attributes (`#!`), indent it to the level of the inside of\n+the item. Prefer outer attributes, where possible.\n+\n+For attributes with argument lists, format like functions.\n+\n+```rust\n+#[repr(C)]\n+#[foo(foo, bar)]\n+struct CRepr {\n+    #![repr(C)]\n+    x: f32,\n+    y: f32,\n+}\n+```\n+\n+For attributes with an equal sign, there should be a single space before and\n+after the `=`, e.g., `#[foo = 42]`.\n+\n+There must only be a single `derive` attribute. Note for tool authors: if\n+combining multiple `derive` attributes into a single attribute, the ordering of\n+the derived names should be preserved. E.g., `#[derive(bar)] #[derive(foo)]\n+struct Baz;` should be formatted to `#[derive(bar, foo)] struct Baz;`.\n+\n+### *small* items\n+\n+In many places in this guide we specify that a formatter may format an item\n+differently if it is *small*, for example struct literals:\n+\n+```rust\n+// Normal formatting\n+Foo {\n+    f1: an_expression,\n+    f2: another_expression(),\n+}\n+\n+// *small* formatting\n+Foo { f1, f2 }\n+```\n+\n+We leave it to individual tools to decide on exactly what *small* means. In\n+particular, tools are free to use different definitions in different\n+circumstances.\n+\n+Some suitable heuristics are the size of the item (in characters) or the\n+complexity of an item (for example, that all components must be simple names,\n+not more complex sub-expressions). For more discussion on suitable heuristics,\n+see [this issue](https://github.com/rust-lang-nursery/fmt-rfcs/issues/47).\n+\n+Tools should give the user an option to ignore such heuristics and always use\n+the normal formatting.\n+\n+\n+## [Non-formatting conventions](advice.md)\n+\n+## [Cargo.toml conventions](cargo.md)\n+\n+## [Principles used for deciding these guidelines](principles.md)"}, {"sha": "004692fa6a22bad19ca1f9b4f36b1eff1dcbb38e", "filename": "src/doc/style-guide/src/SUMMARY.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fdoc%2Fstyle-guide%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fdoc%2Fstyle-guide%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fsrc%2FSUMMARY.md?ref=39484ac3b0b80c1c98c4d46a9f88336c02f24da6", "patch": "@@ -0,0 +1,11 @@\n+# Summary\n+\n+[Introduction](README.md)\n+\n+- [Module-level items](items.md)\n+- [Statements](statements.md)\n+- [Expressions](expressions.md)\n+- [Types](types.md)\n+- [Non-formatting conventions](advice.md)\n+- [`Cargo.toml` conventions](cargo.md)\n+- [Principles used for deciding these guidelines](principles.md)"}, {"sha": "ab4b92b0a24783fc211b25a601276d4b0943b975", "filename": "src/doc/style-guide/src/advice.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fadvice.md", "raw_url": "https://github.com/rust-lang/rust/raw/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fadvice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fadvice.md?ref=39484ac3b0b80c1c98c4d46a9f88336c02f24da6", "patch": "@@ -0,0 +1,34 @@\n+# Other style advice\n+\n+## Expressions\n+\n+Prefer to use Rust's expression oriented nature where possible;\n+\n+```rust\n+// use\n+let x = if y { 1 } else { 0 };\n+// not\n+let x;\n+if y {\n+    x = 1;\n+} else {\n+    x = 0;\n+}\n+```\n+\n+## Names\n+\n+ * Types shall be `UpperCamelCase`,\n+ * Enum variants shall be `UpperCamelCase`,\n+ * Struct fields shall be `snake_case`,\n+ * Function and method names shall be `snake_case`,\n+ * Local variables shall be `snake_case`,\n+ * Macro names shall be `snake_case`,\n+ * Constants (`const`s and immutable `static`s) shall be `SCREAMING_SNAKE_CASE`.\n+ * When a name is forbidden because it is a reserved word (e.g., `crate`), use a\n+   trailing underscore to make the name legal (e.g., `crate_`), or use raw\n+   identifiers if possible.\n+\n+### Modules\n+\n+Avoid `#[path]` annotations where possible."}, {"sha": "f4993ba06a88871ffb9afebb6ea9d3e62602c480", "filename": "src/doc/style-guide/src/cargo.md", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fcargo.md", "raw_url": "https://github.com/rust-lang/rust/raw/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fcargo.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fcargo.md?ref=39484ac3b0b80c1c98c4d46a9f88336c02f24da6", "patch": "@@ -0,0 +1,78 @@\n+# Cargo.toml conventions\n+\n+## Formatting conventions\n+\n+Use the same line width and indentation as Rust code.\n+\n+Put a blank line between the last key-value pair in a section and the header of\n+the next section. Do not place a blank line between section headers and the\n+key-value pairs in that section, or between key-value pairs in a section.\n+\n+Sort key names alphabetically within each section, with the exception of the\n+`[package]` section. Put the `[package]` section at the top of the file; put\n+the `name` and `version` keys in that order at the top of that section,\n+followed by the remaining keys other than `description` in alphabetical order,\n+followed by the `description` at the end of that section.\n+\n+Don't use quotes around any standard key names; use bare keys. Only use quoted\n+keys for non-standard keys whose names require them, and avoid introducing such\n+key names when possible.  See the [TOML\n+specification](https://github.com/toml-lang/toml/blob/master/versions/en/toml-v0.4.0.md#table)\n+for details.\n+\n+Put a single space both before and after the `=` between a key and value. Do\n+not indent any key names; start all key names at the start of a line.\n+\n+Use multi-line strings (rather than newline escape sequences) for any string\n+values that include multiple lines, such as the crate description.\n+\n+For array values, such as a list of authors, put the entire list on the same\n+line as the key, if it fits. Otherwise, use block indentation: put a newline\n+after the opening square bracket, indent each item by one indentation level,\n+put a comma after each item (including the last), and put the closing square\n+bracket at the start of a line by itself after the last item.\n+\n+```rust\n+authors = [\n+    \"A Uthor <a.uthor@example.org>\",\n+    \"Another Author <author@example.net>\",\n+]\n+```\n+\n+For table values, such as a crate dependency with a path, write the entire\n+table using curly braces and commas on the same line as the key if it fits. If\n+the entire table does not fit on the same line as the key, separate it out into\n+a separate section with key-value pairs:\n+\n+```toml\n+[dependencies]\n+crate1 = { path = \"crate1\", version = \"1.2.3\" }\n+\n+[dependencies.extremely_long_crate_name_goes_here]\n+path = \"extremely_long_path_name_goes_right_here\"\n+version = \"4.5.6\"\n+```\n+\n+## Metadata conventions\n+\n+The authors list should consist of strings that each contain an author name\n+followed by an email address in angle brackets: `Full Name <email@address>`.\n+It should not contain bare email addresses, or names without email addresses.\n+(The authors list may also include a mailing list address without an associated\n+name.)\n+\n+The license field must contain a valid [SPDX\n+expression](https://spdx.org/spdx-specification-21-web-version#h.jxpfx0ykyb60),\n+using valid [SPDX license names](https://spdx.org/licenses/). (As an exception,\n+by widespread convention, the license field may use `/` in place of ` OR `; for\n+example, `MIT/Apache-2.0`.)\n+\n+The homepage field, if present, must consist of a single URL, including the\n+scheme (e.g. `https://example.org/`, not just `example.org`.)\n+\n+Within the description field, wrap text at 80 columns. Don't start the\n+description field with the name of the crate (e.g. \"cratename is a ...\"); just\n+describe the crate itself. If providing a multi-sentence description, the first\n+sentence should go on a line by itself and summarize the crate, like the\n+subject of an email or commit message; subsequent sentences can then describe\n+the crate in more detail."}, {"sha": "d4352ef1c301e6e5bbf8eaf7a5dec5608ed90dd6", "filename": "src/doc/style-guide/src/expressions.md", "status": "added", "additions": 850, "deletions": 0, "changes": 850, "blob_url": "https://github.com/rust-lang/rust/blob/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fexpressions.md", "raw_url": "https://github.com/rust-lang/rust/raw/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fexpressions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fexpressions.md?ref=39484ac3b0b80c1c98c4d46a9f88336c02f24da6", "patch": "@@ -0,0 +1,850 @@\n+## Expressions\n+\n+### Blocks\n+\n+A block expression should have a newline after the initial `{` and before the\n+terminal `}`. Any qualifier before the block (e.g., `unsafe`) should always be\n+on the same line as the opening brace, and separated with a single space. The\n+contents of the block should be block indented:\n+\n+```rust\n+fn block_as_stmt() {\n+    a_call();\n+\n+    {\n+        a_call_inside_a_block();\n+\n+        // a comment in a block\n+        the_value\n+    }\n+}\n+\n+fn block_as_expr() {\n+    let foo = {\n+        a_call_inside_a_block();\n+\n+        // a comment in a block\n+        the_value\n+    };\n+}\n+\n+fn unsafe_block_as_stmt() {\n+    a_call();\n+\n+    unsafe {\n+        a_call_inside_a_block();\n+\n+        // a comment in a block\n+        the_value\n+    }\n+}\n+```\n+\n+If a block has an attribute, it should be on its own line:\n+\n+```rust\n+fn block_as_stmt() {\n+    #[an_attribute]\n+    {\n+        #![an_inner_attribute]\n+\n+        // a comment in a block\n+        the_value\n+    }\n+}\n+```\n+\n+Avoid writing comments on the same line as the braces.\n+\n+An empty block should be written as `{}`.\n+\n+A block may be written on a single line if:\n+\n+* it is either used in expression position (not statement position) or is an\n+  unsafe block in statement position\n+* contains a single-line expression and no statements\n+* contains no comments\n+\n+A single line block should have spaces after the opening brace and before the\n+closing brace.\n+\n+Examples:\n+\n+```rust\n+fn main() {\n+    // Single line\n+    let _ = { a_call() };\n+    let _ = unsafe { a_call() };\n+\n+    // Not allowed on one line\n+    // Statement position.\n+    {\n+        a_call()\n+    }\n+\n+    // Contains a statement\n+    let _ = {\n+        a_call();\n+    };\n+    unsafe {\n+        a_call();\n+    }\n+\n+    // Contains a comment\n+    let _ = {\n+        // A comment\n+    };\n+    let _ = {\n+        // A comment\n+        a_call()\n+    };\n+\n+    // Multiple lines\n+    let _ = {\n+        a_call();\n+        another_call()\n+    };\n+    let _ = {\n+        a_call(\n+            an_argument,\n+            another_arg,\n+        )\n+    };\n+}\n+```\n+\n+\n+### Closures\n+\n+Don't put any extra spaces before the first `|` (unless the closure is prefixed\n+by `move`); put a space between the second `|` and the expression of the\n+closure. Between the `|`s, you should use function definition syntax, however,\n+elide types where possible.\n+\n+Use closures without the enclosing `{}`, if possible. Add the `{}` when you have\n+a return type, when there are statements, there are comments in the body, or the\n+body expression spans multiple lines and is a control-flow expression. If using\n+braces, follow the rules above for blocks. Examples:\n+\n+```rust\n+|arg1, arg2| expr\n+\n+move |arg1: i32, arg2: i32| -> i32 {\n+    expr1;\n+    expr2\n+}\n+\n+|| Foo {\n+    field1,\n+    field2: 0,\n+}\n+\n+|| {\n+    if true {\n+        blah\n+    } else {\n+        boo\n+    }\n+}\n+\n+|x| unsafe {\n+    expr\n+}\n+```\n+\n+\n+### Struct literals\n+\n+If a struct literal is *small* it may be formatted on a single line. If not,\n+each field should be on it's own, block-indented line. There should be a\n+trailing comma in the multi-line form only. There should be a space after the\n+colon only.\n+\n+There should be a space before the opening brace. In the single-line form there\n+should be spaces after the opening brace and before the closing brace.\n+\n+```rust\n+Foo { field1, field2: 0 }\n+let f = Foo {\n+    field1,\n+    field2: an_expr,\n+};\n+```\n+\n+Functional record update syntax is treated like a field, but it must never have\n+a trailing comma. There should be no space after `..`.\n+\n+let f = Foo {\n+    field1,\n+    ..an_expr\n+};\n+\n+\n+### Tuple literals\n+\n+Use a single-line form where possible. There should not be spaces around the\n+parentheses. Where a single-line form is not possible, each element of the tuple\n+should be on its own block-indented line and there should be a trailing comma.\n+\n+```rust\n+(a, b, c)\n+\n+let x = (\n+    a_long_expr,\n+    another_very_long_expr,\n+);\n+```\n+\n+\n+### Tuple struct literals\n+\n+There should be no space between the identifier and the opening parenthesis.\n+Otherwise, follow the rules for tuple literals, e.g., `Foo(a, b)`.\n+\n+\n+### Enum literals\n+\n+Follow the formatting rules for the various struct literals. Prefer using the\n+name of the enum as a qualifying name, unless the enum is in the prelude. E.g.,\n+\n+```rust\n+Foo::Bar(a, b)\n+Foo::Baz {\n+    field1,\n+    field2: 1001,\n+}\n+Ok(an_expr)\n+```\n+\n+\n+### Array literals\n+\n+For simple array literals, avoid line breaking, no spaces around square\n+brackets, contents of the array should be separated by commas and spaces. If\n+using the repeating initialiser, there should be a space after the semicolon\n+only. Apply the same rules if using the `vec!` or similar macros (always use\n+square brackets here). Examples:\n+\n+```rust\n+fn main() {\n+    [1, 2, 3];\n+    vec![a, b, c, d];\n+    let a = [42; 10];\n+}\n+```\n+\n+If a line must be broken, prefer breaking only after the `;`, if possible.\n+Otherwise, follow the rules below for function calls. In any case, the contents\n+of the initialiser should be block indented and there should be line breaks\n+after the opening bracket and before the closing bracket:\n+\n+```rust\n+fn main() {\n+    [\n+        a_long_expression();\n+        1234567890\n+    ]\n+    let x = [\n+        an_expression,\n+        another_expression,\n+        a_third_expression,\n+    ];\n+}\n+```\n+\n+\n+### Array accesses, indexing, and slicing.\n+\n+No spaces around the square brackets, avoid breaking lines if possible, never\n+break a line between the target expression and the opening bracket. If the\n+indexing expression covers multiple lines, then it should be block indented and\n+there should be newlines after the opening brackets and before the closing\n+bracket. However, this should be avoided where possible.\n+\n+Examples:\n+\n+```rust\n+fn main() {\n+    foo[42];\n+    &foo[..10];\n+    bar[0..100];\n+    foo[4 + 5 / bar];\n+    a_long_target[\n+        a_long_indexing_expression\n+    ];\n+}\n+```\n+\n+### Unary operations\n+\n+Do not include a space between a unary op and its operand (i.e., `!x`, not\n+`! x`). However, there must be a space after `&mut`. Avoid line-breaking\n+between a unary operator and its operand.\n+\n+### Binary operations\n+\n+Do include spaces around binary ops (i.e., `x + 1`, not `x+1`) (including `=`\n+and other assignment operators such as `+=` or `*=`).\n+\n+For comparison operators, because for `T op U`, `&T op &U` is also implemented:\n+if you have `t: &T`, and `u: U`, prefer `*t op u` to `t op &u`. In general,\n+within expressions, prefer dereferencing to taking references.\n+\n+Use parentheses liberally, do not necessarily elide them due to precedence.\n+Tools should not automatically insert or remove parentheses. Do not use spaces\n+to indicate precedence.\n+\n+If line-breaking, put the operator on a new line and block indent. Put each \n+sub-expression on its own line. E.g.,\n+\n+```rust\n+foo_bar\n+    + bar\n+    + baz\n+    + qux\n+    + whatever\n+```\n+\n+Prefer line-breaking at an assignment operator (either `=` or `+=`, etc.) rather\n+than at other binary operators.\n+\n+### Control flow\n+\n+Do not include extraneous parentheses for `if` and `while` expressions.\n+\n+```rust\n+if true {\n+}\n+```\n+\n+is better than\n+\n+```rust\n+if (true) {\n+}\n+```\n+\n+Do include extraneous parentheses if it makes an arithmetic or logic expression\n+easier to understand (`(x * 15) + (y * 20)` is fine)\n+\n+### Function calls\n+\n+Do not put a space between the function name, and the opening parenthesis.\n+\n+Do not put a space between an argument, and the comma which follows.\n+\n+Do put a space between an argument, and the comma which precedes it.\n+\n+Prefer not to break a line in the callee expression.\n+\n+#### Single-line calls\n+\n+Do not put a space between the function name and open paren, between the open\n+paren and the first argument, or between the last argument and the close paren.\n+\n+Do not put a comma after the last argument.\n+\n+```rust\n+foo(x, y, z)\n+```\n+\n+#### Multi-line calls\n+\n+If the function call is not *small*, it would otherwise over-run the max width,\n+or any argument or the callee is multi-line, then the call should be formatted\n+across multiple lines. In this case, each argument should be on it's own block-\n+indented line, there should be a newline after the opening parenthesis and\n+before the closing parenthesis, and there should be a trailing comma. E.g.,\n+\n+```rust\n+a_function_call(\n+    arg1,\n+    a_nested_call(a, b),\n+)\n+```\n+\n+\n+### Method calls\n+\n+Follow the function rules for calling.\n+\n+Do not put any spaces around the `.`.\n+\n+```rust\n+x.foo().bar().baz(x, y, z);\n+```\n+\n+\n+### Macro uses\n+\n+Macros which can be parsed like other constructs should be formatted like those\n+constructs. For example, a macro use `foo!(a, b, c)` can be parsed like a\n+function call (ignoring the `!`), therefore it should be formatted following the\n+rules for function calls.\n+\n+#### Special case macros\n+\n+Macros which take a format string and where all other arguments are *small* may\n+be formatted with arguments before and after the format string on a single line\n+and the format string on its own line, rather than putting each argument on its\n+own line. For example,\n+\n+```rust\n+println!(\n+    \"Hello {} and {}\",\n+    name1, name2,\n+);\n+\n+assert_eq!(\n+    x, y,\n+    \"x and y were not equal, see {}\",\n+    reason,\n+);\n+```\n+\n+\n+### Casts (`as`)\n+\n+Put spaces before and after `as`:\n+\n+```rust\n+let cstr = \"Hi\\0\" as *const str as *const [u8] as *const std::os::raw::c_char;\n+```\n+\n+\n+### Chains of fields and method calls\n+\n+A chain is a sequence of field accesses and/or method calls. A chain may also\n+include the try operator ('?'). E.g., `a.b.c().d` or `foo?.bar().baz?`.\n+\n+Prefer formatting on one line if possible, and the chain is *small*. If\n+formatting on multiple lines, each field access or method call in the chain\n+should be on its own line with the line-break before the `.` and after any `?`.\n+Each line should be block-indented. E.g.,\n+\n+```rust\n+let foo = bar\n+    .baz?\n+    .qux();\n+```\n+\n+If the length of the last line of the first element plus its indentation is\n+less than or equal to the indentation of the second line (and there is space),\n+then combine the first and second lines, e.g.,\n+\n+```rust\n+x.baz?\n+    .qux()\n+\n+let foo = x\n+    .baz?\n+    .qux();\n+\n+foo(\n+    expr1,\n+    expr2,\n+).baz?\n+    .qux();\n+```\n+\n+#### Multi-line elements\n+\n+If any element in a chain is formatted across multiple lines, then that element\n+and any later elements must be on their own line. Earlier elements may be kept\n+on a single line. E.g.,\n+\n+```rust\n+a.b.c()?.d\n+    .foo(\n+        an_expr,\n+        another_expr,\n+    )\n+    .bar\n+    .baz\n+```\n+\n+Note there is block indent due to the chain and the function call in the above\n+example.\n+\n+Prefer formatting the whole chain in multi-line style and each element on one\n+line, rather than putting some elements on multiple lines and some on a single\n+line, e.g.,\n+\n+```rust\n+// Better\n+self.pre_comment\n+    .as_ref()\n+    .map_or(false, |comment| comment.starts_with(\"//\"))\n+\n+// Worse\n+self.pre_comment.as_ref().map_or(\n+    false,\n+    |comment| comment.starts_with(\"//\"),\n+)\n+```\n+\n+### Control flow expressions\n+\n+This section covers `if`, `if let`, `loop`, `while`, `while let`, and `for`\n+expressions.\n+\n+The keyword, any initial clauses, and the opening brace of the block should be\n+on a single line. The usual rules for [block formatting](#Blocks) should be\n+applied to the block.\n+\n+If there is an `else` component, then the closing brace, `else`, any following\n+clause, and the opening brace should all be on the same line. There should be a\n+single space before and after the `else` keyword. For example:\n+\n+```rust\n+if ... {\n+    ...\n+} else {\n+    ...\n+}\n+\n+if let ... {\n+    ...\n+} else if ... {\n+    ...\n+} else {\n+    ...\n+}\n+```\n+\n+If the control line needs to be broken, then prefer to break before the `=` in\n+`* let` expressions and before `in` in a `for` expression; the following line\n+should be block indented. If the control line is broken for any reason, then the\n+opening brace should be on its own line and not indented. Examples:\n+\n+```rust\n+while let Some(foo)\n+    = a_long_expression\n+{\n+    ...\n+}\n+\n+for foo\n+    in a_long_expression\n+{\n+    ...\n+}\n+\n+if a_long_expression\n+    && another_long_expression\n+    || a_third_long_expression\n+{\n+    ...\n+}\n+```\n+\n+Where the initial clause is multi-lined and ends with one or more closing\n+parentheses, square brackets, or braces, and there is nothing else on that line,\n+and that line is not indented beyond the indent on the first line of the control\n+flow expression, then the opening brace of the block should be put on the same\n+line with a preceding space. For example:\n+\n+```rust\n+if !self.config.file_lines().intersects(\n+    &self.codemap.lookup_line_range(\n+        stmt.span,\n+    ),\n+) {  // Opening brace on same line as initial clause.\n+    ...\n+}\n+```\n+\n+\n+#### Single line `if else`\n+\n+Formatters may place an `if else` or `if let else` on a single line if it occurs\n+in expression context (i.e., is not a standalone statement), it contains a\n+single `else` clause, and is *small*. For example:\n+\n+```rust\n+let y = if x { 0 } else { 1 };\n+\n+// Examples that must be multi-line.\n+let y = if something_very_long {\n+    not_small\n+} else {\n+    also_not_small\n+};\n+\n+if x {\n+    0\n+} else {\n+    1\n+}\n+```\n+\n+\n+### Match\n+\n+Prefer not to line-break inside the discriminant expression. There must always\n+be a line break after the opening brace and before the closing brace. The match\n+arms must be block indented once:\n+\n+```rust\n+match foo {\n+    // arms\n+}\n+\n+let x = match foo.bar.baz() {\n+    // arms\n+};\n+```\n+\n+Use a trailing comma for a match arm if and only if not using a block. \n+\n+Never start a match arm pattern with `|`, e.g.,\n+\n+```rust\n+match foo {\n+    // Don't do this.\n+    | foo => bar,\n+    // Or this.\n+    | a_very_long_pattern\n+    | another_pattern\n+    | yet_another_pattern\n+    | a_forth_pattern => {\n+        ...\n+    }\n+}\n+```\n+\n+Prefer\n+\n+\n+```rust\n+match foo {\n+    foo => bar,\n+    a_very_long_pattern\n+    | another_pattern\n+    | yet_another_pattern\n+    | a_forth_pattern => {\n+        ...\n+    }\n+}\n+```\n+\n+Avoid splitting the left-hand side (before the `=>`) of a match arm where\n+possible. If the right-hand side of the match arm is kept on the same line,\n+never use a block (unless the block is empty).\n+\n+If the right-hand side consists of multiple statements or has line comments or\n+the start of the line cannot be fit on the same line as the left-hand side, use\n+a block.\n+\n+The body of a block arm should be block indented once.\n+\n+Examples:\n+\n+```rust\n+match foo {\n+    foo => bar,\n+    a_very_long_patten | another_pattern if an_expression() => {\n+        no_room_for_this_expression()\n+    }\n+    foo => {\n+        // A comment.\n+        an_expression()\n+    }\n+    foo => {\n+        let a = statement();\n+        an_expression()\n+    }\n+    bar => {}\n+    // Trailing comma on last item.\n+    foo => bar,\n+}\n+```\n+\n+If the body is a single expression with no line comments and not a control flow\n+expression, then it may be started on the same line as the right-hand side. If\n+not, then it must be in a block. Example,\n+\n+```rust\n+match foo {\n+    // A combinable expression.\n+    foo => a_function_call(another_call(\n+        argument1,\n+        argument2,\n+    )),\n+    // A non-combinable expression\n+    bar => {\n+        a_function_call(\n+            another_call(\n+                argument1,\n+                argument2,\n+            ),\n+            another_argument,\n+        )\n+    }\n+}\n+```\n+\n+#### Line-breaking\n+\n+Where it is possible to use a block form on the right-hand side and avoid\n+breaking the left-hand side, do that. E.g.\n+\n+```rust\n+    // Assuming the following line does done fit in the max width\n+    a_very_long_pattern | another_pattern => ALongStructName {\n+        ...\n+    },\n+    // Prefer this\n+    a_very_long_pattern | another_pattern => {\n+        ALongStructName {\n+            ...\n+        }\n+    }\n+    // To splitting the pattern.\n+```\n+\n+Never break after `=>` without using the block form of the body.\n+\n+If the left-hand side must be split and there is an `if` clause, break before\n+the `if` and block indent. In this case, always use a block body and start the\n+body on a new line:\n+\n+```rust\n+    a_very_long_pattern | another_pattern\n+        if expr =>\n+    {\n+        ...\n+    }\n+```\n+\n+If required to break the pattern, put each clause of the pattern on its own\n+line with no additional indent, breaking before the `|`. If there is an `if`\n+clause, then you must use the above form:\n+\n+```rust\n+    a_very_long_pattern\n+    | another_pattern\n+    | yet_another_pattern\n+    | a_forth_pattern => {\n+        ...\n+    }\n+    a_very_long_pattern\n+    | another_pattern\n+    | yet_another_pattern\n+    | a_forth_pattern\n+        if expr =>\n+    {\n+        ...\n+    }\n+```\n+\n+If the pattern is multi-line, and the last line is less wide than the indent, do\n+not put the `if` clause on a newline. E.g.,\n+\n+```rust\n+    Token::Dimension {\n+         value,\n+         ref unit,\n+         ..\n+    } if num_context.is_ok(context.parsing_mode, value) => {\n+        ...\n+    }\n+```\n+\n+If every clause in a pattern is *small*, but does not fit on one line, then the\n+pattern may be formatted across multiple lines with as many clauses per line as\n+possible. Again break before a `|`:\n+\n+```rust\n+    foo | bar | baz\n+    | qux => {\n+        ...\n+    }\n+```\n+\n+We define a pattern clause to be *small* if it matches the following grammar:\n+\n+```\n+[small, ntp]:\n+    - single token\n+    - `&[single-line, ntp]`\n+\n+[small]:\n+    - `[small, ntp]`\n+    - unary tuple constructor `([small, ntp])`\n+    - `&[small]`\n+```\n+\n+E.g., `&&Some(foo)` matches, `Foo(4, Bar)` does not.\n+\n+\n+### Combinable expressions\n+\n+Where a function call has a single argument, and that argument is formatted\n+across multiple-lines, the outer call may be formatted as if it were a single-\n+line call. The same combining behaviour may be applied to any similar\n+expressions which have multi-line, block-indented lists of sub-expressions\n+delimited by parentheses (e.g., macros or tuple struct literals). E.g.,\n+\n+```rust\n+foo(bar(\n+    an_expr,\n+    another_expr,\n+))\n+\n+let x = foo(Bar {\n+    field: whatever,\n+});\n+\n+foo(|param| {\n+    action();\n+    foo(param)\n+})\n+```\n+\n+Such behaviour should extend recursively, however, tools may choose to limit the\n+depth of nesting.\n+\n+Only where the multi-line sub-expression is a closure with an explicit block,\n+this combining behaviour may be used where there are other arguments, as long as\n+all the arguments and the first line of the closure fit on the first line, the\n+closure is the last argument, and there is only one closure argument:\n+\n+```rust\n+foo(first_arg, x, |param| {\n+    action();\n+    foo(param)\n+})\n+```\n+\n+\n+### Ranges\n+\n+Do not put spaces in ranges, e.g., `0..10`, `x..=y`, `..x.len()`, `foo..`.\n+\n+When writing a range with both upper and lower bounds, if the line must be\n+broken, break before the range operator and block indent the second line:\n+\n+```rust\n+a_long_expression\n+    ..another_long_expression\n+```\n+\n+For the sake of indicating precedence, we recommend that if either bound is a\n+compound expression, then use parentheses around it, e.g., `..(x + 1)`,\n+`(x.f)..(x.f.len())`, or `0..(x - 10)`.\n+\n+\n+### Hexadecimal literals\n+\n+Hexadecimal literals may use upper- or lower-case letters, but they must not be\n+mixed within the same literal. Projects should use the same case for all\n+literals, but we do not make a recommendation for either lower- or upper-case.\n+Tools should have an option to convert mixed case literals to upper-case, and\n+may have an option to convert all literals to either lower- or upper-case.\n+\n+\n+## Patterns\n+\n+Patterns should be formatted like their corresponding expressions. See the\n+section on `match` for additional formatting for patterns in match arms."}, {"sha": "324071eb39a5a0ea6ec2d37b4cf6a7b497ebba42", "filename": "src/doc/style-guide/src/items.md", "status": "added", "additions": 565, "deletions": 0, "changes": 565, "blob_url": "https://github.com/rust-lang/rust/blob/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fitems.md", "raw_url": "https://github.com/rust-lang/rust/raw/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fitems.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fitems.md?ref=39484ac3b0b80c1c98c4d46a9f88336c02f24da6", "patch": "@@ -0,0 +1,565 @@\n+## Items\n+\n+`extern crate` statements must be first in a file. They must be ordered\n+alphabetically.\n+\n+`use` statements, and module *declarations* (`mod foo;`, not `mod { ... }`)\n+must come before other items. We recommend that imports come before module\n+declarations; if imports and modules are separated, then they should be ordered\n+alphabetically. When sorting, `self` and `super` must come before any other\n+names. Module declarations should not be moved if they are annotated with\n+`#[macro_use]`, since that may be semantics changing.\n+\n+Tools should make the above ordering optional.\n+\n+\n+### Function definitions\n+\n+In Rust, one finds functions by searching for `fn [function-name]`; It's\n+important that you style your code so that it's very searchable in this way.\n+\n+The proper ordering and spacing is:\n+\n+```rust\n+[pub] [unsafe] [extern [\"ABI\"]] fn foo(arg1: i32, arg2: i32) -> i32 {\n+    ...\n+}\n+```\n+\n+Avoid comments within the signature itself.\n+\n+If the function signature does not fit on one line, then break after the opening\n+parenthesis and before the closing parenthesis and put each argument on its own\n+block-indented line. For example,\n+\n+```rust\n+fn foo(\n+    arg1: i32,\n+    arg2: i32,\n+) -> i32 {\n+    ...\n+}\n+```\n+\n+Note the trailing comma on the last argument.\n+\n+\n+### Tuples and tuple structs\n+\n+Write the type list as you would a parameter list to a function.\n+\n+Build a tuple or tuple struct as you would call a function.\n+\n+#### Single-line\n+\n+```rust\n+struct Bar(Type1, Type2);\n+\n+let x = Bar(11, 22);\n+let y = (11, 22, 33);\n+```\n+\n+### Enums\n+\n+In the declaration, put each variant on its own line, block indented.\n+\n+Format each variant accordingly as either a struct, tuple struct, or identifier,\n+which doesn't require special formatting (but without the `struct` keyword.\n+\n+```rust\n+enum FooBar {\n+    First(u32),\n+    Second,\n+    Error {\n+        err: Box<Error>,\n+        line: u32,\n+    },\n+}\n+```\n+\n+If a struct variant is [*small*](#small-items), it may be formatted on\n+one line. In this case, do not use a trailing comma for the field list, but do\n+put spaces around each brace:\n+\n+```rust\n+enum FooBar {\n+    Error { err: Box<Error>, line: u32 },\n+}\n+```\n+\n+In an enum with multiple struct variants, if any struct variant is written on\n+multiple lines, then the multi-line formatting should be used for all struct\n+variants. However, such a situation might be an indication that you should\n+factor out the fields of the variant into their own struct.\n+\n+\n+### Structs and Unions\n+\n+Struct names follow on the same line as the `struct` keyword, with the opening\n+brace on the same line when it fits within the right margin. All struct fields\n+are indented once and end with a trailing comma. The closing brace is not\n+indented and appears on its own line.\n+\n+```rust\n+struct Foo {\n+    a: A,\n+    b: B,\n+}\n+```\n+\n+If and only if the type of a field does not fit within the right margin, it is\n+pulled down to its own line and indented again.\n+\n+```rust\n+struct Foo {\n+    a: A,\n+    long_name: \n+        LongType,\n+}\n+```\n+\n+Prefer using a unit struct (e.g., `struct Foo;`) to an empty struct (e.g.,\n+`struct Foo();` or `struct Foo {}`, these only exist to simplify code\n+generation), but if you must use an empty struct, keep it on one line with no\n+space between the braces: `struct Foo;` or `struct Foo {}`.\n+\n+The same guidelines are used for untagged union declarations.\n+\n+```rust\n+union Foo {\n+    a: A,\n+    b: B,\n+    long_name: \n+        LongType,\n+}\n+```\n+\n+\n+### Tuple structs\n+\n+Put the whole struct on one line if possible. Types in the parentheses should be\n+separated by a comma and space with no trailing comma. No spaces around the\n+parentheses or semi-colon:\n+\n+```rust\n+pub struct Foo(String, u8);\n+```\n+\n+Prefer unit structs to empty tuple structs (these only exist to simplify code\n+generation), e.g., `struct Foo;` rather than `struct Foo();`.\n+\n+For more than a few fields, prefer a proper struct with named fields. Given\n+this, a tuple struct should always fit on one line. If it does not, block format\n+the fields with a field on each line and a trailing comma:\n+\n+```rust\n+pub struct Foo(\n+    String,\n+    u8,\n+);\n+```\n+\n+\n+### Traits\n+\n+Trait items should be block-indented. If there are no items, the trait may be\n+formatted on a single line. Otherwise there should be line-breaks after the\n+opening brace and before the closing brace:\n+\n+```rust\n+trait Foo {}\n+\n+pub trait Bar {\n+    ...\n+}\n+```\n+\n+If the trait has bounds, there should be a space after the colon but not before\n+and before and after each `+`, e.g.,\n+\n+```rust\n+trait Foo: Debug + Bar {}\n+```\n+\n+Prefer not to line-break in the bounds if possible (consider using a `where`\n+clause). Prefer to break between bounds than to break any individual bound. If\n+you must break the bounds, put each bound (including the first) on its own\n+block-indented line, break before the `+` and put the opening brace on its own\n+line:\n+\n+```rust\n+pub trait IndexRanges:\n+    Index<Range<usize>, Output=Self>\n+    + Index<RangeTo<usize>, Output=Self>\n+    + Index<RangeFrom<usize>, Output=Self>\n+    + Index<RangeFull, Output=Self>\n+{\n+    ...\n+}\n+```\n+\n+\n+### Impls\n+\n+Impl items should be block indented. If there are no items, the impl may be\n+formatted on a single line. Otherwise there should be line-breaks after the\n+opening brace and before the closing brace:\n+\n+```rust\n+impl Foo {}\n+\n+impl Bar for Foo {\n+    ...\n+}\n+```\n+\n+Avoid line-breaking in the signature if possible. If a line break is required in\n+a non-inherent impl, break immediately before `for`, block indent the concrete type\n+and put the opening brace on its own line:\n+\n+```rust\n+impl Bar\n+    for Foo\n+{\n+    ...\n+}\n+```\n+\n+\n+### Extern crate\n+\n+`extern crate foo;`\n+\n+Use spaces around keywords, no spaces around the semi-colon.\n+\n+\n+### Modules\n+\n+```rust\n+mod foo {\n+}\n+```\n+\n+```rust\n+mod foo;\n+```\n+\n+Use spaces around keywords and before the opening brace, no spaces around the\n+semi-colon.\n+\n+### macro\\_rules!\n+\n+Use `{}` for the full definition of the macro.\n+\n+```rust\n+macro_rules! foo {\n+}\n+```\n+\n+\n+### Generics\n+\n+Prefer to put a generics clause on one line. Break other parts of an item\n+declaration rather than line-breaking a generics clause. If a generics clause is\n+large enough to require line-breaking, you should prefer to use a `where` clause\n+instead.\n+\n+Do not put spaces before or after `<` nor before `>`. Only put a space after `>`\n+if it is followed by a word or opening brace, not an opening parenthesis. There\n+should be a space after each comma and no trailing comma.\n+\n+```rust\n+fn foo<T: Display, U: Debug>(x: Vec<T>, y: Vec<U>) ...\n+\n+impl<T: Display, U: Debug> SomeType<T, U> { ...\n+```\n+\n+If the generics clause must be formatted across multiple lines, each parameter\n+should have its own block-indented line, there should be newlines after the\n+opening bracket and before the closing bracket, and the should be a trailing\n+comma.\n+\n+```rust\n+fn foo<\n+    T: Display,\n+    U: Debug,\n+>(x: Vec<T>, y: Vec<U>) ...\n+```\n+\n+If an associated type is bound in a generic type, then there should be spaces on\n+either side of the `=`:\n+\n+```rust\n+<T: Example<Item = u32>>\n+```\n+\n+Prefer to use single-letter names for generic parameters.\n+\n+\n+### `where` clauses\n+\n+These rules apply for `where` clauses on any item.\n+\n+A `where` clause may immediately follow a closing bracket of any kind.\n+Otherwise, it must start a new line, with no indent. Each component of a `where`\n+clause must be on its own line and be block indented. There should be a trailing\n+comma, unless the clause is terminated with a semicolon. If the `where` clause\n+is followed by a block (or assignment), the block should be started on a new\n+line. Examples:\n+\n+```rust\n+fn function<T, U>(args)\n+where\n+    T: Bound,\n+    U: AnotherBound,\n+{\n+    body\n+}\n+\n+fn foo<T>(\n+    args\n+) -> ReturnType\n+where\n+    T: Bound,\n+{\n+    body\n+}\n+\n+fn foo<T, U>(\n+    args,\n+) where\n+    T: Bound,\n+    U: AnotherBound,\n+{\n+    body\n+}\n+\n+fn foo<T, U>(\n+    args\n+) -> ReturnType\n+where\n+    T: Bound,\n+    U: AnotherBound;  // Note, no trailing comma.\n+\n+// Note that where clauses on `type` aliases are not enforced and should not\n+// be used.\n+type Foo<T>\n+where\n+    T: Bound\n+= Bar<T>;\n+```\n+\n+If a `where` clause is very short, we recommend using an inline bound on the\n+type parameter.\n+\n+\n+If a component of a `where` clause is long, it may be broken before `+` and\n+further block indented. Each bound should go on its own line. E.g.,\n+\n+```rust\n+impl<T: ?Sized, Idx> IndexRanges<Idx> for T\n+where\n+    T: Index<Range<Idx>, Output = Self::Output>\n+        + Index<RangeTo<Idx>, Output = Self::Output>\n+        + Index<RangeFrom<Idx>, Output = Self::Output>\n+        + Index<RangeInclusive<Idx>, Output = Self::Output>\n+        + Index<RangeToInclusive<Idx>, Output = Self::Output> + Index<RangeFull>\n+```\n+\n+#### Option - `where_single_line`\n+\n+`where_single_line` is `false` by default. If `true`, then a where clause with\n+exactly one component may be formatted on a single line if the rest of the\n+item's signature is also kept on one line. In this case, there is no need for a\n+trailing comma and if followed by a block, no need for a newline before the\n+block. E.g.,\n+\n+```rust\n+// May be single-lined.\n+fn foo<T>(args) -> ReturnType\n+where T: Bound {\n+    body\n+}\n+\n+// Must be multi-lined.\n+fn foo<T>(\n+    args\n+) -> ReturnType\n+where\n+    T: Bound,\n+{\n+    body\n+}\n+```\n+\n+\n+### Type aliases\n+\n+Type aliases should generally be kept on one line. If necessary to break the\n+line, do so after the `=`; the right-hand-side should be block indented:\n+\n+```rust\n+pub type Foo = Bar<T>;\n+\n+// If multi-line is required\n+type VeryLongType<T, U: SomeBound> =\n+    AnEvenLongerType<T, U, Foo<T>>;\n+```\n+\n+Where possible avoid `where` clauses and keep type constraints inline. Where\n+that is not possible split the line before and after the `where` clause (and\n+split the `where` clause as normal), e.g.,\n+\n+```rust\n+type VeryLongType<T, U>\n+where\n+    T: U::AnAssociatedType,\n+    U: SomeBound,\n+= AnEvenLongerType<T, U, Foo<T>>;\n+```\n+\n+\n+### Associated types\n+\n+Associated types should follow the guidelines above for type aliases. Where an\n+associated type has a bound, there should be a space after the colon but not\n+before:\n+\n+```rust\n+pub type Foo: Bar;\n+```\n+\n+\n+### extern items\n+\n+When writing extern items (such as `extern \"C\" fn`), always be explicit about\n+the ABI. For example, write `extern \"C\" fn foo ...`, not `extern fn foo ...`, or\n+`extern \"C\" { ... }`.\n+\n+\n+### Imports (`use` statements)\n+\n+If an import can be formatted on one line, do so. There should be no spaces\n+around braces.\n+\n+```rust\n+use a::b::c;\n+use a::b::d::*;\n+use a::b::{foo, bar, baz};\n+```\n+\n+\n+#### Large list imports\n+\n+Prefer to use multiple imports rather than a multi-line import. However, tools\n+should not split imports by default (they may offer this as an option).\n+\n+If an import does require multiple lines (either because a list of single names\n+does not fit within the max width, or because of the rules for nested imports\n+below), then break after the opening brace and before the closing brace, use a\n+trailing comma, and block indent the names.\n+\n+\n+```rust\n+// Prefer\n+foo::{long, list, of, imports};\n+foo::{more, imports};\n+\n+// If necessary\n+foo::{\n+    long, list, of, imports, more,\n+    imports,  // Note trailing comma\n+};\n+```\n+\n+\n+#### Ordering of imports\n+\n+A *group* of imports is a set of imports on the same or sequential lines. One or\n+more blank lines or other items (e.g., a function) separate groups of imports.\n+\n+Within a group of imports, imports must be sorted ascii-betically. Groups of\n+imports must not be merged or re-ordered.\n+\n+\n+E.g., input:\n+\n+```rust\n+use d;\n+use c;\n+\n+use b;\n+use a;\n+```\n+\n+output:\n+\n+```rust\n+use c;\n+use d;\n+\n+use a;\n+use b;\n+```\n+\n+Because of `macro_use`, attributes must also start a new group and prevent\n+re-ordering.\n+\n+Note that tools which only have access to syntax (such as Rustfmt) cannot tell\n+which imports are from an external crate or the std lib, etc.\n+\n+\n+#### Ordering list import\n+\n+Names in a list import must be sorted ascii-betically, but with `self` and\n+`super` first, and groups and glob imports last. This applies recursively. For\n+example, `a::*` comes before `b::a` but `a::b` comes before `a::*`. E.g.,\n+`use foo::bar::{a, b::c, b::d, b::d::{x, y, z}, b::{self, r, s}};`.\n+\n+\n+#### Normalisation\n+\n+Tools must make the following normalisations:\n+\n+* `use a::self;` -> `use a;`\n+* `use a::{};` -> (nothing)\n+* `use a::{b};` -> `use a::b;`\n+\n+And must apply these recursively.\n+\n+Tools must not otherwise merge or un-merge import lists or adjust glob imports\n+(without an explicit option).\n+\n+\n+#### Nested imports\n+\n+If there are any nested imports in a list import, then use the multi-line form,\n+even if the import fits on one line. Each nested import must be on its own line,\n+but non-nested imports must be grouped on as few lines as possible.\n+\n+For example,\n+\n+```rust\n+use a::b::{\n+    x, y, z,\n+    u::{...},\n+    w::{...},\n+};\n+```\n+\n+\n+#### Merging/un-merging imports\n+\n+An example:\n+\n+```rust\n+// Un-merged\n+use a::b;\n+use a::c::d;\n+\n+// Merged\n+use a::{b, c::d};\n+```\n+\n+Tools must not merge or un-merge imports by default. They may offer merging or\n+un-merging as an option."}, {"sha": "b02b3c0471f2865eb39c7cc7887eaedac4c09ab0", "filename": "src/doc/style-guide/src/principles.md", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fprinciples.md", "raw_url": "https://github.com/rust-lang/rust/raw/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fprinciples.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fprinciples.md?ref=39484ac3b0b80c1c98c4d46a9f88336c02f24da6", "patch": "@@ -0,0 +1,51 @@\n+# Guiding principles and rationale\n+\n+When deciding on style guidelines, the style team tried to be guided by the\n+following principles (in rough priority order):\n+\n+* readability\n+    - scan-ability\n+    - avoiding misleading formatting\n+    - accessibility - readable and editable by users using the the widest\n+      variety of hardware, including non-visual accessibility interfaces\n+    - readability of code when quoted in rustc error messages\n+\n+* aesthetics\n+    - sense of 'beauty'\n+    - consistent with other languages/tools\n+\n+* specifics\n+    - compatibility with version control practices - preserving diffs,\n+      merge-friendliness, etc.\n+    - preventing right-ward drift\n+    - minimising vertical space\n+\n+* application\n+    - ease of manual application\n+    - ease of implementation (in Rustfmt, and in other tools/editors/code generators)\n+    - internal consistency\n+    - simplicity of formatting rules\n+\n+\n+## Overarching guidelines\n+\n+Prefer block indent over visual indent. E.g.,\n+\n+```rust\n+// Block indent\n+a_function_call(\n+    foo,\n+    bar,\n+);\n+\n+// Visual indent\n+a_function_call(foo,\n+                bar);\n+```\n+\n+This makes for smaller diffs (e.g., if `a_function_call` is renamed in the above\n+example) and less rightward drift.\n+\n+Lists should have a trailing comma when followed by a newline, see the block\n+indent example above. This choice makes moving code (e.g., by copy and paste)\n+easier and makes smaller diffs."}, {"sha": "9c3eba12d2ecbc43d024d617d78065594e774c11", "filename": "src/doc/style-guide/src/statements.md", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fstatements.md", "raw_url": "https://github.com/rust-lang/rust/raw/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fstatements.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fstatements.md?ref=39484ac3b0b80c1c98c4d46a9f88336c02f24da6", "patch": "@@ -0,0 +1,150 @@\n+### Let statements\n+\n+There should be spaces after the `:` and on both sides of the `=` (if they are\n+present). No space before the semi-colon.\n+\n+```rust\n+// A comment.\n+let pattern: Type = expr;\n+\n+let pattern;\n+let pattern: Type;\n+let pattern = expr;\n+```\n+\n+If possible the declaration should be formatted on a single line. If this is not\n+possible, then try splitting after the `=`, if the declaration can fit on two\n+lines. The expression should be block indented.\n+\n+```rust\n+let pattern: Type =\n+    expr;\n+```\n+\n+If the first line does not fit on a single line, then split after the colon,\n+using block indentation. If the type covers multiple lines, even after line-\n+breaking after the `:`, then the first line may be placed on the same line as\n+the `:`, subject to the [combining rules](https://github.com/rust-lang-nursery/fmt-rfcs/issues/61) (WIP).\n+\n+\n+```rust\n+let pattern:\n+    Type =\n+    expr;\n+```\n+\n+e.g,\n+\n+```rust\n+let Foo {\n+    f: abcd,\n+    g: qwer,\n+}: Foo<Bar> =\n+    Foo { f, g };\n+\n+let (abcd,\n+    defg):\n+    Baz =\n+{ ... }\n+```\n+\n+If the expression covers multiple lines, if the first line of the expression\n+fits in the remaining space, it stays on the same line as the `=`, the rest of the\n+expression is not indented. If the first line does not fit, then it should start\n+on the next lines, and should be block indented. If the expression is a block\n+and the type or pattern cover multiple lines, then the opening brace should be\n+on a new line and not indented (this provides separation for the interior of the\n+block from the type), otherwise the opening brace follows the `=`.\n+\n+Examples:\n+\n+```rust\n+let foo = Foo {\n+    f: abcd,\n+    g: qwer,\n+};\n+\n+let foo =\n+    ALongName {\n+        f: abcd,\n+        g: qwer,\n+    };\n+\n+let foo: Type = {\n+    an_expression();\n+    ...\n+};\n+\n+let foo:\n+    ALongType =\n+{\n+    an_expression();\n+    ...    \n+};\n+\n+let Foo {\n+    f: abcd,\n+    g: qwer,\n+}: Foo<Bar> = Foo {\n+    f: blimblimblim, \n+    g: blamblamblam,\n+};\n+\n+let Foo {\n+    f: abcd,\n+    g: qwer,\n+}: Foo<Bar> = foo(\n+    blimblimblim,\n+    blamblamblam,\n+);\n+```\n+\n+\n+### Macros in statement position\n+\n+A macro use in statement position should use parentheses or square brackets as\n+delimiters and should be terminated with a semi-colon. There should be no spaces\n+between the name, `!`, the delimiters, or the `;`.\n+\n+```rust\n+// A comment.\n+a_macro!(...);\n+```\n+\n+\n+### Expressions in statement position\n+\n+There should be no space between the expression and the semi-colon.\n+\n+```\n+<expr>;\n+```\n+\n+All expressions in statement position should be terminated with a semi-colon,\n+unless they end with a block or are used as the value for a block.\n+\n+E.g.,\n+\n+```rust\n+{\n+    an_expression();\n+    expr_as_value()\n+}\n+\n+return foo();\n+\n+loop {\n+    break;\n+}\n+```\n+\n+Use a semi-colon where an expression has void type, even if it could be\n+propagated. E.g.,\n+\n+```rust\n+fn foo() { ... }\n+\n+fn bar() {\n+    foo();\n+}\n+```"}, {"sha": "25861ddabb8d0e0b2e4a0deed53026ecd95a4846", "filename": "src/doc/style-guide/src/types.md", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fdoc%2Fstyle-guide%2Fsrc%2Ftypes.md", "raw_url": "https://github.com/rust-lang/rust/raw/39484ac3b0b80c1c98c4d46a9f88336c02f24da6/src%2Fdoc%2Fstyle-guide%2Fsrc%2Ftypes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fsrc%2Ftypes.md?ref=39484ac3b0b80c1c98c4d46a9f88336c02f24da6", "patch": "@@ -0,0 +1,58 @@\n+## Types and Bounds\n+\n+### Single line formatting\n+\n+* `[T]` no spaces\n+* `[T; expr]`, e.g., `[u32; 42]`, `[Vec<Foo>; 10 * 2 + foo()]` (space after colon, no spaces around square brackets)\n+* `*const T`, `*mut T` (no space after `*`, space before type)\n+* `&'a T`, `&T`, `&'a mut T`, `&mut T` (no space after `&`, single spaces separating other words)\n+* `unsafe extern \"C\" fn<'a, 'b, 'c>(T, U, V) -> W` or `fn()` (single spaces around keyowrds and sigils, and after commas, no trailing commas, no spaces around brackets)\n+* `!` should be treated like any other type name, `Name`\n+* `(A, B, C, D)` (spaces after commas, no spaces around parens, no trailing comma unless it is a one-tuple)\n+* `<Baz<T> as SomeTrait>::Foo::Bar` or `Foo::Bar` or `::Foo::Bar` (no spaces around `::` or angle brackets, single spaces around `as`)\n+* `Foo::Bar<T, U, V>` (spaces after commas, no trailing comma, no spaces around angle brackets)\n+* `T + T + T` (single spaces between types, and `+`).\n+* `impl T + T + T` (single spaces between keyword, types, and `+`).\n+\n+Parentheses used in types should not be surrounded by whitespace, e.g., `(Foo)`\n+\n+\n+### Line breaks\n+\n+Avoid breaking lines in types where possible. Prefer breaking at outermost scope, e.g., prefer\n+\n+```rust\n+Foo<\n+    Bar,\n+    Baz<Type1, Type2>,\n+>\n+```\n+\n+to\n+\n+```rust\n+Foo<Bar, Baz<\n+    Type1,\n+    Type2,\n+>>\n+```\n+\n+`[T; expr]` may be broken after the `;` if necessary.\n+\n+Function types may be broken following the rules for function declarations.\n+\n+Generic types may be broken following the rules for generics.\n+\n+Types with `+` may be broken after any `+` using block indent and breaking before the `+`. When breaking such a type, all `+`s should be line broken, e.g.,\n+\n+```rust\n+impl Clone\n+    + Copy\n+    + Debug\n+\n+Box<\n+    Clone\n+    + Copy\n+    + Debug\n+>\n+```"}]}