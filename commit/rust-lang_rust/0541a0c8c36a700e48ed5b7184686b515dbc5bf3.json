{"sha": "0541a0c8c36a700e48ed5b7184686b515dbc5bf3", "node_id": "C_kwDOAAsO6NoAKDA1NDFhMGM4YzM2YTcwMGU0OGVkNWI3MTg0Njg2YjUxNWRiYzViZjM", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-02-07T16:07:49Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-02-18T17:13:23Z"}, "message": "Allow reexports of items with same name but different types to both appear", "tree": {"sha": "f71cb4c850f81688ddec47c1e67fb1c8439a2e35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f71cb4c850f81688ddec47c1e67fb1c8439a2e35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0541a0c8c36a700e48ed5b7184686b515dbc5bf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0541a0c8c36a700e48ed5b7184686b515dbc5bf3", "html_url": "https://github.com/rust-lang/rust/commit/0541a0c8c36a700e48ed5b7184686b515dbc5bf3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0541a0c8c36a700e48ed5b7184686b515dbc5bf3/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a7cc6c32f1a690f86827e4724bcda85e506ef35", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a7cc6c32f1a690f86827e4724bcda85e506ef35", "html_url": "https://github.com/rust-lang/rust/commit/9a7cc6c32f1a690f86827e4724bcda85e506ef35"}], "stats": {"total": 117, "additions": 60, "deletions": 57}, "files": [{"sha": "22db2390d080fe98083c28b5e18bbff536365f0a", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 54, "deletions": 48, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/0541a0c8c36a700e48ed5b7184686b515dbc5bf3/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0541a0c8c36a700e48ed5b7184686b515dbc5bf3/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=0541a0c8c36a700e48ed5b7184686b515dbc5bf3", "patch": "@@ -38,7 +38,7 @@ impl JsonRenderer<'_> {\n                     Some(UrlFragment::UserWritten(_)) | None => *page_id,\n                 };\n \n-                (link.clone(), from_item_id(id.into(), self.tcx))\n+                (link.clone(), id_from_item_inner(id.into(), self.tcx, None))\n             })\n             .collect();\n         let docs = item.attrs.collapsed_doc_value();\n@@ -50,7 +50,8 @@ impl JsonRenderer<'_> {\n             .collect();\n         let span = item.span(self.tcx);\n         let visibility = item.visibility(self.tcx);\n-        let clean::Item { name, attrs: _, kind: _, item_id, cfg: _, .. } = item;\n+        let clean::Item { name, item_id, .. } = item;\n+        let id = id_from_item(&item, self.tcx);\n         let inner = match *item.kind {\n             clean::KeywordItem => return None,\n             clean::StrippedItem(ref inner) => {\n@@ -69,7 +70,7 @@ impl JsonRenderer<'_> {\n             _ => from_clean_item(item, self.tcx),\n         };\n         Some(Item {\n-            id: from_item_id_with_name(item_id, self.tcx, name),\n+            id,\n             crate_id: item_id.krate().as_u32(),\n             name: name.map(|sym| sym.to_string()),\n             span: span.and_then(|span| self.convert_span(span)),\n@@ -107,7 +108,7 @@ impl JsonRenderer<'_> {\n             Some(ty::Visibility::Public) => Visibility::Public,\n             Some(ty::Visibility::Restricted(did)) if did.is_crate_root() => Visibility::Crate,\n             Some(ty::Visibility::Restricted(did)) => Visibility::Restricted {\n-                parent: from_item_id(did.into(), self.tcx),\n+                parent: id_from_item_inner(did.into(), self.tcx, None),\n                 path: self.tcx.def_path(did).to_string_no_crate_verbose(),\n             },\n         }\n@@ -207,51 +208,58 @@ impl FromWithTcx<clean::TypeBindingKind> for TypeBindingKind {\n /// It generates an ID as follows:\n ///\n /// `CRATE_ID:ITEM_ID[:NAME_ID]` (if there is no name, NAME_ID is not generated).\n-pub(crate) fn from_item_id(item_id: ItemId, tcx: TyCtxt<'_>) -> Id {\n-    from_item_id_with_name(item_id, tcx, None)\n-}\n-\n-// FIXME: this function (and appending the name at the end of the ID) should be removed when\n-// reexports are not inlined anymore for json format. It should be done in #93518.\n-pub(crate) fn from_item_id_with_name(item_id: ItemId, tcx: TyCtxt<'_>, name: Option<Symbol>) -> Id {\n-    struct DisplayDefId<'a>(DefId, TyCtxt<'a>, Option<Symbol>);\n+pub(crate) fn id_from_item_inner(item_id: ItemId, tcx: TyCtxt<'_>, extra: Option<&Id>) -> Id {\n+    struct DisplayDefId<'a, 'b>(DefId, TyCtxt<'a>, Option<&'b Id>);\n \n-    impl<'a> fmt::Display for DisplayDefId<'a> {\n+    impl<'a, 'b> fmt::Display for DisplayDefId<'a, 'b> {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            let DisplayDefId(def_id, tcx, name) = self;\n-            let name = match name {\n-                Some(name) => format!(\":{}\", name.as_u32()),\n-                None => {\n-                    // We need this workaround because primitive types' DefId actually refers to\n-                    // their parent module, which isn't present in the output JSON items. So\n-                    // instead, we directly get the primitive symbol and convert it to u32 to\n-                    // generate the ID.\n-                    if matches!(tcx.def_kind(def_id), DefKind::Mod) &&\n-                        let Some(prim) = tcx.get_attrs(*def_id, sym::doc)\n-                            .flat_map(|attr| attr.meta_item_list().unwrap_or_default())\n-                            .filter(|attr| attr.has_name(sym::primitive))\n-                            .find_map(|attr| attr.value_str()) {\n-                        format!(\":{}\", prim.as_u32())\n-                    } else {\n-                        tcx\n-                        .opt_item_name(*def_id)\n-                        .map(|n| format!(\":{}\", n.as_u32()))\n-                        .unwrap_or_default()\n-                    }\n-                }\n+            let DisplayDefId(def_id, tcx, extra) = self;\n+            // We need this workaround because primitive types' DefId actually refers to\n+            // their parent module, which isn't present in the output JSON items. So\n+            // instead, we directly get the primitive symbol and convert it to u32 to\n+            // generate the ID.\n+            let s;\n+            let extra = if let Some(e) = extra {\n+                s = format!(\"-{}\", e.0);\n+                &s\n+            } else {\n+                \"\"\n+            };\n+            let name = if matches!(tcx.def_kind(def_id), DefKind::Mod) &&\n+                let Some(prim) = tcx.get_attrs(*def_id, sym::doc)\n+                    .flat_map(|attr| attr.meta_item_list().unwrap_or_default())\n+                    .filter(|attr| attr.has_name(sym::primitive))\n+                    .find_map(|attr| attr.value_str()) {\n+                format!(\":{}\", prim.as_u32())\n+            } else {\n+                tcx\n+                  .opt_item_name(*def_id)\n+                  .map(|n| format!(\":{}\", n.as_u32()))\n+                  .unwrap_or_default()\n             };\n-            write!(f, \"{}:{}{}\", self.0.krate.as_u32(), u32::from(self.0.index), name)\n+            write!(f, \"{}:{}{name}{extra}\", self.0.krate.as_u32(), u32::from(self.0.index))\n         }\n     }\n \n     match item_id {\n-        ItemId::DefId(did) => Id(format!(\"{}\", DisplayDefId(did, tcx, name))),\n+        ItemId::DefId(did) => Id(format!(\"{}\", DisplayDefId(did, tcx, extra))),\n         ItemId::Blanket { for_, impl_id } => {\n-            Id(format!(\"b:{}-{}\", DisplayDefId(impl_id, tcx, None), DisplayDefId(for_, tcx, name)))\n+            Id(format!(\"b:{}-{}\", DisplayDefId(impl_id, tcx, None), DisplayDefId(for_, tcx, extra)))\n         }\n         ItemId::Auto { for_, trait_ } => {\n-            Id(format!(\"a:{}-{}\", DisplayDefId(trait_, tcx, None), DisplayDefId(for_, tcx, name)))\n+            Id(format!(\"a:{}-{}\", DisplayDefId(trait_, tcx, None), DisplayDefId(for_, tcx, extra)))\n+        }\n+    }\n+}\n+\n+pub(crate) fn id_from_item(item: &clean::Item, tcx: TyCtxt<'_>) -> Id {\n+    match *item.kind {\n+        clean::ItemKind::ImportItem(ref import) => {\n+            let extra =\n+                import.source.did.map(ItemId::from).map(|i| id_from_item_inner(i, tcx, None));\n+            id_from_item_inner(item.item_id, tcx, extra.as_ref())\n         }\n+        _ => id_from_item_inner(item.item_id, tcx, None),\n     }\n }\n \n@@ -525,7 +533,7 @@ impl FromWithTcx<clean::Path> for Path {\n     fn from_tcx(path: clean::Path, tcx: TyCtxt<'_>) -> Path {\n         Path {\n             name: path.whole_name(),\n-            id: from_item_id(path.def_id().into(), tcx),\n+            id: id_from_item_inner(path.def_id().into(), tcx, None),\n             args: path.segments.last().map(|args| Box::new(args.clone().args.into_tcx(tcx))),\n         }\n     }\n@@ -702,7 +710,7 @@ impl FromWithTcx<clean::Import> for Import {\n         Import {\n             source: import.source.path.whole_name(),\n             name,\n-            id: import.source.did.map(ItemId::from).map(|i| from_item_id(i, tcx)),\n+            id: import.source.did.map(ItemId::from).map(|i| id_from_item_inner(i, tcx, None)),\n             glob,\n         }\n     }\n@@ -791,7 +799,7 @@ fn ids(items: impl IntoIterator<Item = clean::Item>, tcx: TyCtxt<'_>) -> Vec<Id>\n     items\n         .into_iter()\n         .filter(|x| !x.is_stripped() && !x.is_keyword())\n-        .map(|i| from_item_id_with_name(i.item_id, tcx, i.name))\n+        .map(|i| id_from_item(&i, tcx))\n         .collect()\n }\n \n@@ -801,12 +809,10 @@ fn ids_keeping_stripped(\n ) -> Vec<Option<Id>> {\n     items\n         .into_iter()\n-        .map(|i| {\n-            if !i.is_stripped() && !i.is_keyword() {\n-                Some(from_item_id_with_name(i.item_id, tcx, i.name))\n-            } else {\n-                None\n-            }\n-        })\n+        .map(\n+            |i| {\n+                if !i.is_stripped() && !i.is_keyword() { Some(id_from_item(&i, tcx)) } else { None }\n+            },\n+        )\n         .collect()\n }"}, {"sha": "10900efd488e0dd21aeb7e7b26866d83b1953b51", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0541a0c8c36a700e48ed5b7184686b515dbc5bf3/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0541a0c8c36a700e48ed5b7184686b515dbc5bf3/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=0541a0c8c36a700e48ed5b7184686b515dbc5bf3", "patch": "@@ -28,7 +28,7 @@ use crate::docfs::PathError;\n use crate::error::Error;\n use crate::formats::cache::Cache;\n use crate::formats::FormatRenderer;\n-use crate::json::conversions::{from_item_id, from_item_id_with_name, IntoWithTcx};\n+use crate::json::conversions::{id_from_item, id_from_item_inner, IntoWithTcx};\n use crate::{clean, try_err};\n \n #[derive(Clone)]\n@@ -58,7 +58,7 @@ impl<'tcx> JsonRenderer<'tcx> {\n                     .map(|i| {\n                         let item = &i.impl_item;\n                         self.item(item.clone()).unwrap();\n-                        from_item_id_with_name(item.item_id, self.tcx, item.name)\n+                        id_from_item(&item, self.tcx)\n                     })\n                     .collect()\n             })\n@@ -89,7 +89,7 @@ impl<'tcx> JsonRenderer<'tcx> {\n \n                         if item.item_id.is_local() || is_primitive_impl {\n                             self.item(item.clone()).unwrap();\n-                            Some(from_item_id_with_name(item.item_id, self.tcx, item.name))\n+                            Some(id_from_item(&item, self.tcx))\n                         } else {\n                             None\n                         }\n@@ -150,7 +150,6 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n         // Flatten items that recursively store other items\n         item.kind.inner_items().for_each(|i| self.item(i.clone()).unwrap());\n \n-        let name = item.name;\n         let item_id = item.item_id;\n         if let Some(mut new_item) = self.convert_item(item) {\n             let can_be_ignored = match new_item.inner {\n@@ -193,10 +192,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                 | types::ItemEnum::Macro(_)\n                 | types::ItemEnum::ProcMacro(_) => false,\n             };\n-            let removed = self\n-                .index\n-                .borrow_mut()\n-                .insert(from_item_id_with_name(item_id, self.tcx, name), new_item.clone());\n+            let removed = self.index.borrow_mut().insert(new_item.id.clone(), new_item.clone());\n \n             // FIXME(adotinthevoid): Currently, the index is duplicated. This is a sanity check\n             // to make sure the items are unique. The main place this happens is when an item, is\n@@ -207,6 +203,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                 if !can_be_ignored {\n                     assert_eq!(old_item, new_item);\n                 }\n+                trace!(\"replaced {:?}\\nwith {:?}\", old_item, new_item);\n             }\n         }\n \n@@ -246,7 +243,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                 .chain(&self.cache.external_paths)\n                 .map(|(&k, &(ref path, kind))| {\n                     (\n-                        from_item_id(k.into(), self.tcx),\n+                        id_from_item_inner(k.into(), self.tcx, None),\n                         types::ItemSummary {\n                             crate_id: k.krate.as_u32(),\n                             path: path.iter().map(|s| s.to_string()).collect(),"}]}