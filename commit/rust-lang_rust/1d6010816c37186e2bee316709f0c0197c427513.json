{"sha": "1d6010816c37186e2bee316709f0c0197c427513", "node_id": "C_kwDOAAsO6NoAKDFkNjAxMDgxNmMzNzE4NmUyYmVlMzE2NzA5ZjBjMDE5N2M0Mjc1MTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-20T10:58:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-20T10:58:56Z"}, "message": "Auto merge of #97674 - nnethercote:oblig-forest-tweaks, r=nikomatsakis\n\nObligation forest tweaks\n\nA few minor improvements to the code.\n\nr? `@nikomatsakis`", "tree": {"sha": "1d2f1317d9bbd3c05f5ff77b0963e028c1c8ab64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d2f1317d9bbd3c05f5ff77b0963e028c1c8ab64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d6010816c37186e2bee316709f0c0197c427513", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d6010816c37186e2bee316709f0c0197c427513", "html_url": "https://github.com/rust-lang/rust/commit/1d6010816c37186e2bee316709f0c0197c427513", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d6010816c37186e2bee316709f0c0197c427513/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4104596251818f4f588051c7a8172ca9f5a195bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/4104596251818f4f588051c7a8172ca9f5a195bf", "html_url": "https://github.com/rust-lang/rust/commit/4104596251818f4f588051c7a8172ca9f5a195bf"}, {"sha": "32741d5d1645a41acd16addc9612b1253e101458", "url": "https://api.github.com/repos/rust-lang/rust/commits/32741d5d1645a41acd16addc9612b1253e101458", "html_url": "https://github.com/rust-lang/rust/commit/32741d5d1645a41acd16addc9612b1253e101458"}], "stats": {"total": 268, "additions": 115, "deletions": 153}, "files": [{"sha": "07a96dd7dbbf1dfb9a0750912bef073d415971d6", "filename": "compiler/rustc_data_structures/src/obligation_forest/mod.rs", "status": "modified", "additions": 72, "deletions": 83, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/1d6010816c37186e2bee316709f0c0197c427513/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6010816c37186e2bee316709f0c0197c427513/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs?ref=1d6010816c37186e2bee316709f0c0197c427513", "patch": "@@ -42,7 +42,7 @@\n //!   now considered to be in error.\n //!\n //! When the call to `process_obligations` completes, you get back an `Outcome`,\n-//! which includes three bits of information:\n+//! which includes two bits of information:\n //!\n //! - `completed`: a list of obligations where processing was fully\n //!   completed without error (meaning that all transitive subobligations\n@@ -53,13 +53,10 @@\n //!   all the obligations in `C` have been found completed.\n //! - `errors`: a list of errors that occurred and associated backtraces\n //!   at the time of error, which can be used to give context to the user.\n-//! - `stalled`: if true, then none of the existing obligations were\n-//!   *shallowly successful* (that is, no callback returned `Changed(_)`).\n-//!   This implies that all obligations were either errors or returned an\n-//!   ambiguous result, which means that any further calls to\n-//!   `process_obligations` would simply yield back further ambiguous\n-//!   results. This is used by the `FulfillmentContext` to decide when it\n-//!   has reached a steady state.\n+//!\n+//! Upon completion, none of the existing obligations were *shallowly\n+//! successful* (that is, no callback returned `Changed(_)`). This implies that\n+//! all obligations were either errors or returned an ambiguous result.\n //!\n //! ### Implementation details\n //!\n@@ -99,6 +96,8 @@ pub trait ObligationProcessor {\n     type Obligation: ForestObligation;\n     type Error: Debug;\n \n+    fn needs_process_obligation(&self, obligation: &Self::Obligation) -> bool;\n+\n     fn process_obligation(\n         &mut self,\n         obligation: &mut Self::Obligation,\n@@ -146,7 +145,7 @@ pub struct ObligationForest<O: ForestObligation> {\n \n     /// A cache of the nodes in `nodes`, indexed by predicate. Unfortunately,\n     /// its contents are not guaranteed to match those of `nodes`. See the\n-    /// comments in [`Self::process_obligation` for details.\n+    /// comments in `Self::process_obligation` for details.\n     active_cache: FxHashMap<O::CacheKey, usize>,\n \n     /// A vector reused in [Self::compress()] and [Self::find_cycles_from_node()],\n@@ -260,8 +259,6 @@ pub trait OutcomeTrait {\n     type Obligation;\n \n     fn new() -> Self;\n-    fn mark_not_stalled(&mut self);\n-    fn is_stalled(&self) -> bool;\n     fn record_completed(&mut self, outcome: &Self::Obligation);\n     fn record_error(&mut self, error: Self::Error);\n }\n@@ -270,30 +267,14 @@ pub trait OutcomeTrait {\n pub struct Outcome<O, E> {\n     /// Backtrace of obligations that were found to be in error.\n     pub errors: Vec<Error<O, E>>,\n-\n-    /// If true, then we saw no successful obligations, which means\n-    /// there is no point in further iteration. This is based on the\n-    /// assumption that when trait matching returns `Error` or\n-    /// `Unchanged`, those results do not affect environmental\n-    /// inference state. (Note that if we invoke `process_obligations`\n-    /// with no pending obligations, stalled will be true.)\n-    pub stalled: bool,\n }\n \n impl<O, E> OutcomeTrait for Outcome<O, E> {\n     type Error = Error<O, E>;\n     type Obligation = O;\n \n     fn new() -> Self {\n-        Self { stalled: true, errors: vec![] }\n-    }\n-\n-    fn mark_not_stalled(&mut self) {\n-        self.stalled = false;\n-    }\n-\n-    fn is_stalled(&self) -> bool {\n-        self.stalled\n+        Self { errors: vec![] }\n     }\n \n     fn record_completed(&mut self, _outcome: &Self::Obligation) {\n@@ -415,10 +396,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             .insert(node.obligation.as_cache_key());\n     }\n \n-    /// Performs a pass through the obligation list. This must\n-    /// be called in a loop until `outcome.stalled` is false.\n-    ///\n-    /// This _cannot_ be unrolled (presently, at least).\n+    /// Performs a fixpoint computation over the obligation list.\n     #[inline(never)]\n     pub fn process_obligations<P, OUT>(&mut self, processor: &mut P) -> OUT\n     where\n@@ -427,55 +405,69 @@ impl<O: ForestObligation> ObligationForest<O> {\n     {\n         let mut outcome = OUT::new();\n \n-        // Note that the loop body can append new nodes, and those new nodes\n-        // will then be processed by subsequent iterations of the loop.\n-        //\n-        // We can't use an iterator for the loop because `self.nodes` is\n-        // appended to and the borrow checker would complain. We also can't use\n-        // `for index in 0..self.nodes.len() { ... }` because the range would\n-        // be computed with the initial length, and we would miss the appended\n-        // nodes. Therefore we use a `while` loop.\n-        let mut index = 0;\n-        while let Some(node) = self.nodes.get_mut(index) {\n-            // `processor.process_obligation` can modify the predicate within\n-            // `node.obligation`, and that predicate is the key used for\n-            // `self.active_cache`. This means that `self.active_cache` can get\n-            // out of sync with `nodes`. It's not very common, but it does\n-            // happen, and code in `compress` has to allow for it.\n-            if node.state.get() != NodeState::Pending {\n-                index += 1;\n-                continue;\n-            }\n-\n-            match processor.process_obligation(&mut node.obligation) {\n-                ProcessResult::Unchanged => {\n-                    // No change in state.\n+        // Fixpoint computation: we repeat until the inner loop stalls.\n+        loop {\n+            let mut has_changed = false;\n+\n+            // Note that the loop body can append new nodes, and those new nodes\n+            // will then be processed by subsequent iterations of the loop.\n+            //\n+            // We can't use an iterator for the loop because `self.nodes` is\n+            // appended to and the borrow checker would complain. We also can't use\n+            // `for index in 0..self.nodes.len() { ... }` because the range would\n+            // be computed with the initial length, and we would miss the appended\n+            // nodes. Therefore we use a `while` loop.\n+            let mut index = 0;\n+            while let Some(node) = self.nodes.get_mut(index) {\n+                if node.state.get() != NodeState::Pending\n+                    || !processor.needs_process_obligation(&node.obligation)\n+                {\n+                    index += 1;\n+                    continue;\n                 }\n-                ProcessResult::Changed(children) => {\n-                    // We are not (yet) stalled.\n-                    outcome.mark_not_stalled();\n-                    node.state.set(NodeState::Success);\n-\n-                    for child in children {\n-                        let st = self.register_obligation_at(child, Some(index));\n-                        if let Err(()) = st {\n-                            // Error already reported - propagate it\n-                            // to our node.\n-                            self.error_at(index);\n+\n+                // `processor.process_obligation` can modify the predicate within\n+                // `node.obligation`, and that predicate is the key used for\n+                // `self.active_cache`. This means that `self.active_cache` can get\n+                // out of sync with `nodes`. It's not very common, but it does\n+                // happen, and code in `compress` has to allow for it.\n+\n+                match processor.process_obligation(&mut node.obligation) {\n+                    ProcessResult::Unchanged => {\n+                        // No change in state.\n+                    }\n+                    ProcessResult::Changed(children) => {\n+                        // We are not (yet) stalled.\n+                        has_changed = true;\n+                        node.state.set(NodeState::Success);\n+\n+                        for child in children {\n+                            let st = self.register_obligation_at(child, Some(index));\n+                            if let Err(()) = st {\n+                                // Error already reported - propagate it\n+                                // to our node.\n+                                self.error_at(index);\n+                            }\n                         }\n                     }\n+                    ProcessResult::Error(err) => {\n+                        has_changed = true;\n+                        outcome.record_error(Error { error: err, backtrace: self.error_at(index) });\n+                    }\n                 }\n-                ProcessResult::Error(err) => {\n-                    outcome.mark_not_stalled();\n-                    outcome.record_error(Error { error: err, backtrace: self.error_at(index) });\n-                }\n+                index += 1;\n+            }\n+\n+            // If unchanged, then we saw no successful obligations, which means\n+            // there is no point in further iteration. This is based on the\n+            // assumption that when trait matching returns `Error` or\n+            // `Unchanged`, those results do not affect environmental inference\n+            // state. (Note that this will occur if we invoke\n+            // `process_obligations` with no pending obligations.)\n+            if !has_changed {\n+                break;\n             }\n-            index += 1;\n-        }\n \n-        // There's no need to perform marking, cycle processing and compression when nothing\n-        // changed.\n-        if !outcome.is_stalled() {\n             self.mark_successes();\n             self.process_cycles(processor);\n             self.compress(|obl| outcome.record_completed(obl));\n@@ -634,17 +626,14 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     }\n                 }\n                 NodeState::Done => {\n-                    // This lookup can fail because the contents of\n+                    // The removal lookup might fail because the contents of\n                     // `self.active_cache` are not guaranteed to match those of\n                     // `self.nodes`. See the comment in `process_obligation`\n                     // for more details.\n-                    if let Some((predicate, _)) =\n-                        self.active_cache.remove_entry(&node.obligation.as_cache_key())\n-                    {\n-                        self.done_cache.insert(predicate);\n-                    } else {\n-                        self.done_cache.insert(node.obligation.as_cache_key().clone());\n-                    }\n+                    let cache_key = node.obligation.as_cache_key();\n+                    self.active_cache.remove(&cache_key);\n+                    self.done_cache.insert(cache_key);\n+\n                     // Extract the success stories.\n                     outcome_cb(&node.obligation);\n                     node_rewrites[index] = orig_nodes_len;"}, {"sha": "e2991aae1742c89f076553fff6a79bf6d6e6bc4a", "filename": "compiler/rustc_data_structures/src/obligation_forest/tests.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1d6010816c37186e2bee316709f0c0197c427513/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6010816c37186e2bee316709f0c0197c427513/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Ftests.rs?ref=1d6010816c37186e2bee316709f0c0197c427513", "patch": "@@ -20,7 +20,6 @@ struct ClosureObligationProcessor<OF, BF, O, E> {\n struct TestOutcome<O, E> {\n     pub completed: Vec<O>,\n     pub errors: Vec<Error<O, E>>,\n-    pub stalled: bool,\n }\n \n impl<O, E> OutcomeTrait for TestOutcome<O, E>\n@@ -31,15 +30,7 @@ where\n     type Obligation = O;\n \n     fn new() -> Self {\n-        Self { errors: vec![], stalled: false, completed: vec![] }\n-    }\n-\n-    fn mark_not_stalled(&mut self) {\n-        self.stalled = false;\n-    }\n-\n-    fn is_stalled(&self) -> bool {\n-        self.stalled\n+        Self { errors: vec![], completed: vec![] }\n     }\n \n     fn record_completed(&mut self, outcome: &Self::Obligation) {\n@@ -74,6 +65,10 @@ where\n     type Obligation = O;\n     type Error = E;\n \n+    fn needs_process_obligation(&self, _obligation: &Self::Obligation) -> bool {\n+        true\n+    }\n+\n     fn process_obligation(\n         &mut self,\n         obligation: &mut Self::Obligation,"}, {"sha": "d61166437d75edcfe7db9683e1e8b7e6ea152d46", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 38, "deletions": 60, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/1d6010816c37186e2bee316709f0c0197c427513/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6010816c37186e2bee316709f0c0197c427513/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=1d6010816c37186e2bee316709f0c0197c427513", "patch": "@@ -133,27 +133,16 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n \n         let mut errors = Vec::new();\n \n-        loop {\n-            debug!(\"select: starting another iteration\");\n+        // Process pending obligations.\n+        let outcome: Outcome<_, _> = self.predicates.process_obligations(&mut FulfillProcessor {\n+            selcx,\n+            register_region_obligations: self.register_region_obligations,\n+        });\n \n-            // Process pending obligations.\n-            let outcome: Outcome<_, _> =\n-                self.predicates.process_obligations(&mut FulfillProcessor {\n-                    selcx,\n-                    register_region_obligations: self.register_region_obligations,\n-                });\n-            debug!(\"select: outcome={:#?}\", outcome);\n+        // FIXME: if we kept the original cache key, we could mark projection\n+        // obligations as complete for the projection cache here.\n \n-            // FIXME: if we kept the original cache key, we could mark projection\n-            // obligations as complete for the projection cache here.\n-\n-            errors.extend(outcome.errors.into_iter().map(to_fulfillment_error));\n-\n-            // If nothing new was added, no need to keep looping.\n-            if outcome.stalled {\n-                break;\n-            }\n-        }\n+        errors.extend(outcome.errors.into_iter().map(to_fulfillment_error));\n \n         debug!(\n             \"select({} predicates remaining, {} errors) done\",\n@@ -264,22 +253,16 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n     type Obligation = PendingPredicateObligation<'tcx>;\n     type Error = FulfillmentErrorCode<'tcx>;\n \n-    /// Processes a predicate obligation and returns either:\n-    /// - `Changed(v)` if the predicate is true, presuming that `v` are also true\n-    /// - `Unchanged` if we don't have enough info to be sure\n-    /// - `Error(e)` if the predicate does not hold\n+    /// Identifies whether a predicate obligation needs processing.\n     ///\n     /// This is always inlined, despite its size, because it has a single\n     /// callsite and it is called *very* frequently.\n     #[inline(always)]\n-    fn process_obligation(\n-        &mut self,\n-        pending_obligation: &mut Self::Obligation,\n-    ) -> ProcessResult<Self::Obligation, Self::Error> {\n+    fn needs_process_obligation(&self, pending_obligation: &Self::Obligation) -> bool {\n         // If we were stalled on some unresolved variables, first check whether\n         // any of them have been resolved; if not, don't bother doing more work\n         // yet.\n-        let change = match pending_obligation.stalled_on.len() {\n+        match pending_obligation.stalled_on.len() {\n             // Match arms are in order of frequency, which matters because this\n             // code is so hot. 1 and 0 dominate; 2+ is fairly rare.\n             1 => {\n@@ -302,42 +285,18 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                     false\n                 })()\n             }\n-        };\n-\n-        if !change {\n-            debug!(\n-                \"process_predicate: pending obligation {:?} still stalled on {:?}\",\n-                self.selcx.infcx().resolve_vars_if_possible(pending_obligation.obligation.clone()),\n-                pending_obligation.stalled_on\n-            );\n-            return ProcessResult::Unchanged;\n-        }\n-\n-        self.process_changed_obligations(pending_obligation)\n-    }\n-\n-    fn process_backedge<'c, I>(\n-        &mut self,\n-        cycle: I,\n-        _marker: PhantomData<&'c PendingPredicateObligation<'tcx>>,\n-    ) where\n-        I: Clone + Iterator<Item = &'c PendingPredicateObligation<'tcx>>,\n-    {\n-        if self.selcx.coinductive_match(cycle.clone().map(|s| s.obligation.predicate)) {\n-            debug!(\"process_child_obligations: coinductive match\");\n-        } else {\n-            let cycle: Vec<_> = cycle.map(|c| c.obligation.clone()).collect();\n-            self.selcx.infcx().report_overflow_error_cycle(&cycle);\n         }\n     }\n-}\n \n-impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n-    // The code calling this method is extremely hot and only rarely\n-    // actually uses this, so move this part of the code\n-    // out of that loop.\n+    /// Processes a predicate obligation and returns either:\n+    /// - `Changed(v)` if the predicate is true, presuming that `v` are also true\n+    /// - `Unchanged` if we don't have enough info to be sure\n+    /// - `Error(e)` if the predicate does not hold\n+    ///\n+    /// This is called much less often than `needs_process_obligation`, so we\n+    /// never inline it.\n     #[inline(never)]\n-    fn process_changed_obligations(\n+    fn process_obligation(\n         &mut self,\n         pending_obligation: &mut PendingPredicateObligation<'tcx>,\n     ) -> ProcessResult<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>> {\n@@ -352,6 +311,8 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 self.selcx.infcx().resolve_vars_if_possible(obligation.predicate);\n         }\n \n+        let obligation = &pending_obligation.obligation;\n+\n         debug!(?obligation, ?obligation.cause, \"process_obligation\");\n \n         let infcx = self.selcx.infcx();\n@@ -668,6 +629,23 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n         }\n     }\n \n+    fn process_backedge<'c, I>(\n+        &mut self,\n+        cycle: I,\n+        _marker: PhantomData<&'c PendingPredicateObligation<'tcx>>,\n+    ) where\n+        I: Clone + Iterator<Item = &'c PendingPredicateObligation<'tcx>>,\n+    {\n+        if self.selcx.coinductive_match(cycle.clone().map(|s| s.obligation.predicate)) {\n+            debug!(\"process_child_obligations: coinductive match\");\n+        } else {\n+            let cycle: Vec<_> = cycle.map(|c| c.obligation.clone()).collect();\n+            self.selcx.infcx().report_overflow_error_cycle(&cycle);\n+        }\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n     #[instrument(level = \"debug\", skip(self, obligation, stalled_on))]\n     fn process_trait_obligation(\n         &mut self,"}]}