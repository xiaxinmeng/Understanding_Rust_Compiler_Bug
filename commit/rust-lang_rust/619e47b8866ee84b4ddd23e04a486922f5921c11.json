{"sha": "619e47b8866ee84b4ddd23e04a486922f5921c11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxOWU0N2I4ODY2ZWU4NGI0ZGRkMjNlMDRhNDg2OTIyZjU5MjFjMTE=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-02-23T15:10:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-23T15:10:28Z"}, "message": "Rollup merge of #82311 - aDotInTheVoid:jsondocck-improvements, r=jyn514\n\nJsondocck improvements\n\nAdds 2 new commands, ```@is``` and ```@set`.``\n\n```@is``` works like ```@has`,`` except instead of checking if any value matches, it checks that there is exactly one value, and it matches. This allows more precise testing.\n\n```@set``` gets a value, and saves it to be used later. This makes it possible to check that an item appears in the correct module.\n\nOnce this lands, the rest of the test suite can be upgraded to use these.\n\ncc ``@CraftSpider``\n\n ``@rustbot`` modify labels: +T-rustdoc +A-rustdoc-json +A-testsuite", "tree": {"sha": "e71cacfd624b901c4e60bb0ec937e62d3a5dd33b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e71cacfd624b901c4e60bb0ec937e62d3a5dd33b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/619e47b8866ee84b4ddd23e04a486922f5921c11", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgNRrkCRBK7hj4Ov3rIwAAdHIIAC+7FFyWdm/s0Abq0yUPgxL6\n821KsJb7yrbF3PuitM4GTAbvtHUaSU576EsRPjW65UkHk+WuUezfDIsG/waIRXnF\nWunWzZ+/R9qX0a3hXYLn/GsMWw/rhLqqqyvE9mynsIhShic/0XG5UxXsNQjisWdS\nYq+XfThmIqUPDSZiDAXY9JY0McbYcxf/Hq5A83p1avhV4FvDbXy9gf0AhG9GsPaf\ncxQXA1YNFa+u8KHoBsv9/Ai4xUHpe6fIszczMSw8r3SwWXPcMWQJQeyPd2E/6CCR\nXDVDS4eb79+g7p4Ou0dtANkxfVKOcY3vJSqFwVt+vuArNj8RdE3cP8JizwwI9Sw=\n=BScN\n-----END PGP SIGNATURE-----\n", "payload": "tree e71cacfd624b901c4e60bb0ec937e62d3a5dd33b\nparent 269f39922bd8ac6abd8dee9ca8211fbb354b554b\nparent 4c949a455df81924b37dc41f2edf1071ea329fb5\nauthor Dylan DPC <dylan.dpc@gmail.com> 1614093028 +0100\ncommitter GitHub <noreply@github.com> 1614093028 +0100\n\nRollup merge of #82311 - aDotInTheVoid:jsondocck-improvements, r=jyn514\n\nJsondocck improvements\n\nAdds 2 new commands, ```@is``` and ```@set`.``\n\n```@is``` works like ```@has`,`` except instead of checking if any value matches, it checks that there is exactly one value, and it matches. This allows more precise testing.\n\n```@set``` gets a value, and saves it to be used later. This makes it possible to check that an item appears in the correct module.\n\nOnce this lands, the rest of the test suite can be upgraded to use these.\n\ncc ``@CraftSpider``\n\n ``@rustbot`` modify labels: +T-rustdoc +A-rustdoc-json +A-testsuite\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/619e47b8866ee84b4ddd23e04a486922f5921c11", "html_url": "https://github.com/rust-lang/rust/commit/619e47b8866ee84b4ddd23e04a486922f5921c11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/619e47b8866ee84b4ddd23e04a486922f5921c11/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "269f39922bd8ac6abd8dee9ca8211fbb354b554b", "url": "https://api.github.com/repos/rust-lang/rust/commits/269f39922bd8ac6abd8dee9ca8211fbb354b554b", "html_url": "https://github.com/rust-lang/rust/commit/269f39922bd8ac6abd8dee9ca8211fbb354b554b"}, {"sha": "4c949a455df81924b37dc41f2edf1071ea329fb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c949a455df81924b37dc41f2edf1071ea329fb5", "html_url": "https://github.com/rust-lang/rust/commit/4c949a455df81924b37dc41f2edf1071ea329fb5"}], "stats": {"total": 97, "additions": 70, "deletions": 27}, "files": [{"sha": "a3d4935f49614a1474fcc22d539dddff9c1cb7b9", "filename": "src/test/rustdoc-json/nested.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/619e47b8866ee84b4ddd23e04a486922f5921c11/src%2Ftest%2Frustdoc-json%2Fnested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/619e47b8866ee84b4ddd23e04a486922f5921c11/src%2Ftest%2Frustdoc-json%2Fnested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fnested.rs?ref=619e47b8866ee84b4ddd23e04a486922f5921c11", "patch": "@@ -1,24 +1,28 @@\n // edition:2018\n \n-// @has nested.json \"$.index[*][?(@.name=='nested')].kind\" \\\"module\\\"\n-// @has - \"$.index[*][?(@.name=='nested')].inner.is_crate\" true\n+// @is nested.json \"$.index[*][?(@.name=='nested')].kind\" \\\"module\\\"\n+// @is - \"$.index[*][?(@.name=='nested')].inner.is_crate\" true\n // @count - \"$.index[*][?(@.name=='nested')].inner.items[*]\" 1\n \n-// @has nested.json \"$.index[*][?(@.name=='l1')].kind\" \\\"module\\\"\n-// @has - \"$.index[*][?(@.name=='l1')].inner.is_crate\" false\n+// @is nested.json \"$.index[*][?(@.name=='l1')].kind\" \\\"module\\\"\n+// @is - \"$.index[*][?(@.name=='l1')].inner.is_crate\" false\n // @count - \"$.index[*][?(@.name=='l1')].inner.items[*]\" 2\n pub mod l1 {\n \n-    // @has nested.json \"$.index[*][?(@.name=='l3')].kind\" \\\"module\\\"\n-    // @has - \"$.index[*][?(@.name=='l3')].inner.is_crate\" false\n+    // @is nested.json \"$.index[*][?(@.name=='l3')].kind\" \\\"module\\\"\n+    // @is - \"$.index[*][?(@.name=='l3')].inner.is_crate\" false\n     // @count - \"$.index[*][?(@.name=='l3')].inner.items[*]\" 1\n+    // @set l3_id = - \"$.index[*][?(@.name=='l3')].id\"\n+    // @has - \"$.index[*][?(@.name=='l1')].inner.items[*]\" $l3_id\n     pub mod l3 {\n \n-        // @has nested.json \"$.index[*][?(@.name=='L4')].kind\" \\\"struct\\\"\n-        // @has - \"$.index[*][?(@.name=='L4')].inner.struct_type\" \\\"unit\\\"\n+        // @is nested.json \"$.index[*][?(@.name=='L4')].kind\" \\\"struct\\\"\n+        // @is - \"$.index[*][?(@.name=='L4')].inner.struct_type\" \\\"unit\\\"\n+        // @set l4_id = - \"$.index[*][?(@.name=='L4')].id\"\n+        // @has - \"$.index[*][?(@.name=='l3')].inner.items[*]\" $l4_id\n         pub struct L4;\n     }\n-    // @has nested.json \"$.index[*][?(@.inner.span=='l3::L4')].kind\" \\\"import\\\"\n-    // @has - \"$.index[*][?(@.inner.span=='l3::L4')].inner.glob\" false\n+    // @is nested.json \"$.index[*][?(@.inner.span=='l3::L4')].kind\" \\\"import\\\"\n+    // @is - \"$.index[*][?(@.inner.span=='l3::L4')].inner.glob\" false\n     pub use l3::L4;\n }"}, {"sha": "8a6a911321c345a57c8fd0384359190d18791773", "filename": "src/tools/jsondocck/src/cache.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/619e47b8866ee84b4ddd23e04a486922f5921c11/src%2Ftools%2Fjsondocck%2Fsrc%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/619e47b8866ee84b4ddd23e04a486922f5921c11/src%2Ftools%2Fjsondocck%2Fsrc%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondocck%2Fsrc%2Fcache.rs?ref=619e47b8866ee84b4ddd23e04a486922f5921c11", "patch": "@@ -9,6 +9,7 @@ pub struct Cache {\n     root: PathBuf,\n     files: HashMap<PathBuf, String>,\n     values: HashMap<PathBuf, Value>,\n+    pub variables: HashMap<String, Value>,\n     last_path: Option<PathBuf>,\n }\n \n@@ -19,6 +20,7 @@ impl Cache {\n             root: Path::new(doc_dir).to_owned(),\n             files: HashMap::new(),\n             values: HashMap::new(),\n+            variables: HashMap::new(),\n             last_path: None,\n         }\n     }"}, {"sha": "5020a4917a00a12514aa077d3e11d189443d3c18", "filename": "src/tools/jsondocck/src/main.rs", "status": "modified", "additions": 54, "deletions": 17, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/619e47b8866ee84b4ddd23e04a486922f5921c11/src%2Ftools%2Fjsondocck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/619e47b8866ee84b4ddd23e04a486922f5921c11/src%2Ftools%2Fjsondocck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondocck%2Fsrc%2Fmain.rs?ref=619e47b8866ee84b4ddd23e04a486922f5921c11", "patch": "@@ -2,6 +2,7 @@ use jsonpath_lib::select;\n use lazy_static::lazy_static;\n use regex::{Regex, RegexBuilder};\n use serde_json::Value;\n+use std::borrow::Cow;\n use std::{env, fmt, fs};\n \n mod cache;\n@@ -48,13 +49,16 @@ pub struct Command {\n pub enum CommandKind {\n     Has,\n     Count,\n+    Is,\n+    Set,\n }\n \n impl CommandKind {\n     fn validate(&self, args: &[String], command_num: usize, lineno: usize) -> bool {\n         let count = match self {\n             CommandKind::Has => (1..=3).contains(&args.len()),\n-            CommandKind::Count => 3 == args.len(),\n+            CommandKind::Count | CommandKind::Is => 3 == args.len(),\n+            CommandKind::Set => 4 == args.len(),\n         };\n \n         if !count {\n@@ -83,6 +87,8 @@ impl fmt::Display for CommandKind {\n         let text = match self {\n             CommandKind::Has => \"has\",\n             CommandKind::Count => \"count\",\n+            CommandKind::Is => \"is\",\n+            CommandKind::Set => \"set\",\n         };\n         write!(f, \"{}\", text)\n     }\n@@ -127,6 +133,8 @@ fn get_commands(template: &str) -> Result<Vec<Command>, ()> {\n         let cmd = match cmd {\n             \"has\" => CommandKind::Has,\n             \"count\" => CommandKind::Count,\n+            \"is\" => CommandKind::Is,\n+            \"set\" => CommandKind::Set,\n             _ => {\n                 print_err(&format!(\"Unrecognized command name `@{}`\", cmd), lineno);\n                 errors = true;\n@@ -180,6 +188,7 @@ fn get_commands(template: &str) -> Result<Vec<Command>, ()> {\n /// Performs the actual work of ensuring a command passes. Generally assumes the command\n /// is syntactically valid.\n fn check_command(command: Command, cache: &mut Cache) -> Result<(), CkError> {\n+    // FIXME: Be more granular about why, (e.g. syntax error, count not equal)\n     let result = match command.kind {\n         CommandKind::Has => {\n             match command.args.len() {\n@@ -188,23 +197,15 @@ fn check_command(command: Command, cache: &mut Cache) -> Result<(), CkError> {\n                 // @has <path> <jsonpath> = check path exists\n                 2 => {\n                     let val = cache.get_value(&command.args[0])?;\n-\n-                    match select(&val, &command.args[1]) {\n-                        Ok(results) => !results.is_empty(),\n-                        Err(_) => false,\n-                    }\n+                    let results = select(&val, &command.args[1]).unwrap();\n+                    !results.is_empty()\n                 }\n                 // @has <path> <jsonpath> <value> = check *any* item matched by path equals value\n                 3 => {\n                     let val = cache.get_value(&command.args[0])?;\n-                    match select(&val, &command.args[1]) {\n-                        Ok(results) => {\n-                            let pat: Value = serde_json::from_str(&command.args[2]).unwrap();\n-\n-                            !results.is_empty() && results.into_iter().any(|val| *val == pat)\n-                        }\n-                        Err(_) => false,\n-                    }\n+                    let results = select(&val, &command.args[1]).unwrap();\n+                    let pat = string_to_value(&command.args[2], cache);\n+                    results.contains(&pat.as_ref())\n                 }\n                 _ => unreachable!(),\n             }\n@@ -215,9 +216,37 @@ fn check_command(command: Command, cache: &mut Cache) -> Result<(), CkError> {\n             let expected: usize = command.args[2].parse().unwrap();\n \n             let val = cache.get_value(&command.args[0])?;\n-            match select(&val, &command.args[1]) {\n-                Ok(results) => results.len() == expected,\n-                Err(_) => false,\n+            let results = select(&val, &command.args[1]).unwrap();\n+            results.len() == expected\n+        }\n+        CommandKind::Is => {\n+            // @has <path> <jsonpath> <value> = check *exactly one* item matched by path, and it equals value\n+            assert_eq!(command.args.len(), 3);\n+            let val = cache.get_value(&command.args[0])?;\n+            let results = select(&val, &command.args[1]).unwrap();\n+            let pat = string_to_value(&command.args[2], cache);\n+            results.len() == 1 && results[0] == pat.as_ref()\n+        }\n+        CommandKind::Set => {\n+            // @set <name> = <path> <jsonpath>\n+            assert_eq!(command.args.len(), 4);\n+            assert_eq!(command.args[1], \"=\", \"Expected an `=`\");\n+            let val = cache.get_value(&command.args[2])?;\n+            let results = select(&val, &command.args[3]).unwrap();\n+            assert_eq!(results.len(), 1);\n+            match results.len() {\n+                0 => false,\n+                1 => {\n+                    let r = cache.variables.insert(command.args[0].clone(), results[0].clone());\n+                    assert!(r.is_none(), \"Name collision: {} is duplicated\", command.args[0]);\n+                    true\n+                }\n+                _ => {\n+                    panic!(\n+                        \"Got multiple results in `@set` for `{}`: {:?}\",\n+                        &command.args[3], results\n+                    );\n+                }\n             }\n         }\n     };\n@@ -247,3 +276,11 @@ fn check_command(command: Command, cache: &mut Cache) -> Result<(), CkError> {\n         Ok(())\n     }\n }\n+\n+fn string_to_value<'a>(s: &str, cache: &'a Cache) -> Cow<'a, Value> {\n+    if s.starts_with(\"$\") {\n+        Cow::Borrowed(&cache.variables[&s[1..]])\n+    } else {\n+        Cow::Owned(serde_json::from_str(s).unwrap())\n+    }\n+}"}]}