{"sha": "595e192274b581e3a3a938c84eb128fa8c20c60d", "node_id": "C_kwDOAAsO6NoAKDU5NWUxOTIyNzRiNTgxZTNhM2E5MzhjODRlYjEyOGZhOGMyMGM2MGQ", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-09-29T13:40:04Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-09-29T14:03:07Z"}, "message": "unsafe keyword: trait examples and unsafe_op_in_unsafe_fn update", "tree": {"sha": "8c863c2bf2135f20e123f60f749132e065990142", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c863c2bf2135f20e123f60f749132e065990142"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/595e192274b581e3a3a938c84eb128fa8c20c60d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/595e192274b581e3a3a938c84eb128fa8c20c60d", "html_url": "https://github.com/rust-lang/rust/commit/595e192274b581e3a3a938c84eb128fa8c20c60d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/595e192274b581e3a3a938c84eb128fa8c20c60d/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a497b7181cad4ae66dbd6cc31042b69b6bd0df7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a497b7181cad4ae66dbd6cc31042b69b6bd0df7", "html_url": "https://github.com/rust-lang/rust/commit/8a497b7181cad4ae66dbd6cc31042b69b6bd0df7"}], "stats": {"total": 152, "additions": 120, "deletions": 32}, "files": [{"sha": "6121054bd746a5c32f96b78350e1e22ffe6c8b63", "filename": "library/std/src/keyword_docs.rs", "status": "modified", "additions": 120, "deletions": 32, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/595e192274b581e3a3a938c84eb128fa8c20c60d/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/595e192274b581e3a3a938c84eb128fa8c20c60d/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fkeyword_docs.rs?ref=595e192274b581e3a3a938c84eb128fa8c20c60d", "patch": "@@ -1867,11 +1867,15 @@ mod type_keyword {}\n /// Code or interfaces whose [memory safety] cannot be verified by the type\n /// system.\n ///\n-/// The `unsafe` keyword has two uses: to declare the existence of contracts the\n-/// compiler can't check (`unsafe fn` and `unsafe trait`), and to declare that a\n-/// programmer has checked that these contracts have been upheld (`unsafe {}`\n-/// and `unsafe impl`, but also `unsafe fn` -- see below). They are not mutually\n-/// exclusive, as can be seen in `unsafe fn`.\n+/// The `unsafe` keyword has two uses:\n+/// - to declare the existence of contracts the compiler can't check (`unsafe fn` and `unsafe\n+/// trait`),\n+/// - and to declare that a programmer has checked that these contracts have been upheld (`unsafe\n+/// {}` and `unsafe impl`, but also `unsafe fn` -- see below).\n+///\n+/// They are not mutually exclusive, as can be seen in `unsafe fn`: the body of an `unsafe fn` is,\n+/// by default, treated like an unsafe block. The `unsafe_op_in_unsafe_fn` lint can be enabled to\n+/// change that.\n ///\n /// # Unsafe abilities\n ///\n@@ -1914,12 +1918,12 @@ mod type_keyword {}\n /// - `unsafe impl`: the contract necessary to implement the trait has been\n /// checked by the programmer and is guaranteed to be respected.\n ///\n-/// `unsafe fn` also acts like an `unsafe {}` block\n+/// By default, `unsafe fn` also acts like an `unsafe {}` block\n /// around the code inside the function. This means it is not just a signal to\n /// the caller, but also promises that the preconditions for the operations\n-/// inside the function are upheld. Mixing these two meanings can be confusing\n-/// and [proposal]s exist to use `unsafe {}` blocks inside such functions when\n-/// making `unsafe` operations.\n+/// inside the function are upheld. Mixing these two meanings can be confusing, so the\n+/// `unsafe_op_in_unsafe_fn` lint can be enabled to warn against that and require explicit unsafe\n+/// blocks even inside `unsafe fn`.\n ///\n /// See the [Rustnomicon] and the [Reference] for more information.\n ///\n@@ -1987,13 +1991,15 @@ mod type_keyword {}\n ///\n /// ```rust\n /// # #![allow(dead_code)]\n+/// #![deny(unsafe_op_in_unsafe_fn)]\n /// /// Dereference the given pointer.\n /// ///\n /// /// # Safety\n /// ///\n /// /// `ptr` must be aligned and must not be dangling.\n /// unsafe fn deref_unchecked(ptr: *const i32) -> i32 {\n-///     *ptr\n+///     // SAFETY: the caller is required to ensure that `ptr` is aligned and dereferenceable.\n+///     unsafe { *ptr }\n /// }\n ///\n /// let a = 3;\n@@ -2003,35 +2009,118 @@ mod type_keyword {}\n /// unsafe { assert_eq!(*b, deref_unchecked(b)); };\n /// ```\n ///\n-/// Traits marked as `unsafe` must be [`impl`]emented using `unsafe impl`. This\n-/// makes a guarantee to other `unsafe` code that the implementation satisfies\n-/// the trait's safety contract. The [Send] and [Sync] traits are examples of\n-/// this behaviour in the standard library.\n+/// ## `unsafe` and traits\n+///\n+/// The interactions of `unsafe` and traits can be surprising, so let us contrast the\n+/// two combinations of safe `fn` in `unsafe trait` and `unsafe fn` in safe trait using two\n+/// examples:\n ///\n /// ```rust\n-/// /// Implementors of this trait must guarantee an element is always\n-/// /// accessible with index 3.\n-/// unsafe trait ThreeIndexable<T> {\n-///     /// Returns a reference to the element with index 3 in `&self`.\n-///     fn three(&self) -> &T;\n+/// /// # Safety\n+/// ///\n+/// /// `make_even` must return an even number.\n+/// unsafe trait MakeEven {\n+///   fn make_even(&self) -> i32;\n /// }\n ///\n-/// // The implementation of `ThreeIndexable` for `[T; 4]` is `unsafe`\n-/// // because the implementor must abide by a contract the compiler cannot\n-/// // check but as a programmer we know there will always be a valid element\n-/// // at index 3 to access.\n-/// unsafe impl<T> ThreeIndexable<T> for [T; 4] {\n-///     fn three(&self) -> &T {\n-///         // SAFETY: implementing the trait means there always is an element\n-///         // with index 3 accessible.\n-///         unsafe { self.get_unchecked(3) }\n-///     }\n+/// // SAFETY: Our `make_even` always returns something even.\n+/// unsafe impl MakeEven for i32 {\n+///   fn make_even(&self) -> i32 {\n+///     self << 1\n+///   }\n+/// }\n+///\n+/// fn use_make_even(x: impl MakeEven) {\n+///   if x.make_even() % 2 == 1 {\n+///     // SAFETY: this can never happen, because all `MakeEven` implementations\n+///     // ensure that `make_even` returns something even.\n+///     unsafe { std::hint::unreachable_unchecked() };\n+///   }\n+/// }\n+/// ```\n+///\n+/// Note how the safety contract of the trait is upheld by the implementation, and is itself used to\n+/// uphold the safety contract of the unsafe function `unreachable_unchecked` called by\n+/// `use_make_even`. `make_even` itself is a safe function because its *callers* do not have to\n+/// worry about any contract, only the *implementation* of `MakeEven` is required to uphold a\n+/// certain contract. `use_make_even` is safe because it can use the promise made by `MakeEven`\n+/// implementations to uphold the safety contract of the `unsafe fn unreachable_unchecked` it calls.\n+///\n+/// It is also possible to have `unsafe fn` in a regular safe `trait`:\n+///\n+/// ```rust\n+/// # #![feature(never_type)]\n+/// #![deny(unsafe_op_in_unsafe_fn)]\n+///\n+/// trait Indexable {\n+///   const LEN: usize;\n+///\n+///   /// # Safety\n+///   ///\n+///   /// The caller must ensure that `idx < LEN`.\n+///   unsafe fn idx_unchecked(&self, idx: usize) -> i32;\n+/// }\n+///\n+/// // The implementation for `i32` doesn't need to do any contract reasoning.\n+/// impl Indexable for i32 {\n+///   const LEN: usize = 1;\n+///\n+///   unsafe fn idx_unchecked(&self, idx: usize) -> i32 {\n+///     debug_assert_eq!(idx, 0);\n+///     *self\n+///   }\n+/// }\n+///\n+/// // The implementation for arrays exploits the function contract to\n+/// // make use of `get_unchecked` on slices and avoid a run-time check.\n+/// impl Indexable for [i32; 42] {\n+///   const LEN: usize = 42;\n+///\n+///   unsafe fn idx_unchecked(&self, idx: usize) -> i32 {\n+///     // SAFETY: As per this trait's documentation, the caller ensures\n+///     // that `idx < 42`.\n+///     unsafe { *self.get_unchecked(idx) }\n+///   }\n+/// }\n+///\n+/// // The implementation for the never type declares a length of 0,\n+/// // which means `idx_unchecked` can never be called.\n+/// impl Indexable for ! {\n+///   const LEN: usize = 0;\n+///\n+///   unsafe fn idx_unchecked(&self, idx: usize) -> i32 {\n+///     // SAFETY: As per this trait's documentation, the caller ensures\n+///     // that `idx < 0`, which is impossible, so this is dead code.\n+///     unsafe { std::hint::unreachable_unchecked() }\n+///   }\n /// }\n ///\n-/// let a = [1, 2, 4, 8];\n-/// assert_eq!(a.three(), &8);\n+/// fn use_indexable<I: Indexable>(x: I, idx: usize) -> i32 {\n+///   if idx < I::LEN {\n+///     // SAFETY: We have checked that `idx < I::LEN`.\n+///     unsafe { x.idx_unchecked(idx) }\n+///   } else {\n+///     panic!(\"index out-of-bounds\")\n+///   }\n+/// }\n /// ```\n ///\n+/// This time, `use_indexable` is safe because it uses a run-time check to discharge the safety\n+/// contract of `idx_unchecked`. Implementing `Indexable` is safe because when writing\n+/// `idx_unchecked`, we don't have to worry: our *callers* need to discharge a proof obligation\n+/// (like `use_indexable` does), but the *implementation* of `get_unchecked` has no proof obligation\n+/// to contend with. Of course, the implementation of `Indexable` may choose to call other unsafe\n+/// operations, and then it needs an `unsafe` *block* to indicate it discharged the proof\n+/// obligations of its callees. (We enabled `unsafe_op_in_unsafe_fn`, so the body of `idx_unchecked`\n+/// is not implicitly an unsafe block.) For that purpose it can make use of the contract that all\n+/// its callers must uphold -- the fact that `idx < LEN`.\n+///\n+/// Formally speaking, an `unsafe fn` in a trait is a function with extra\n+/// *preconditions* (such as `idx < LEN`), whereas an `unsafe trait` can declare\n+/// that some of its functions have extra *postconditions* (such as returning an\n+/// even integer). If a trait needs a function with both extra precondition and\n+/// extra postcondition, then it needs an `unsafe fn` in an `unsafe trait`.\n+///\n /// [`extern`]: keyword.extern.html\n /// [`trait`]: keyword.trait.html\n /// [`static`]: keyword.static.html\n@@ -2043,7 +2132,6 @@ mod type_keyword {}\n /// [nomicon-soundness]: ../nomicon/safe-unsafe-meaning.html\n /// [soundness]: https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#soundness-of-code--of-a-library\n /// [Reference]: ../reference/unsafety.html\n-/// [proposal]: https://github.com/rust-lang/rfcs/pull/2585\n /// [discussion on Rust Internals]: https://internals.rust-lang.org/t/what-does-unsafe-mean/6696\n mod unsafe_keyword {}\n "}]}