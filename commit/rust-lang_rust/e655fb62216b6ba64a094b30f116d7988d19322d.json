{"sha": "e655fb62216b6ba64a094b30f116d7988d19322d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2NTVmYjYyMjE2YjZiYTY0YTA5NGIzMGYxMTZkNzk4OGQxOTMyMmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-16T22:42:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-16T22:42:56Z"}, "message": "Auto merge of #82936 - oli-obk:valtree, r=RalfJung,lcnr,matthewjasper\n\nImplement (but don't use) valtree and refactor in preparation of use\n\nThis PR does not cause any functional change. It refactors various things that are needed to make valtrees possible. This refactoring got big enough that I decided I'd want it reviewed as a PR instead of trying to make one huge PR with all the changes.\n\ncc `@rust-lang/wg-const-eval` on the following commits:\n\n* 2027184 implement valtree\n* eeecea9 fallible Scalar -> ScalarInt\n* 042f663 ScalarInt convenience methods\n\ncc `@eddyb` on ef04a6d\n\ncc `@rust-lang/wg-mir-opt` for cf1700c (`mir::Constant` can now represent either a `ConstValue` or a `ty::Const`, and it is totally possible to have two different representations for the same value)", "tree": {"sha": "80952f15ec0698641e3e9b8e8290f28ffa2d4c21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80952f15ec0698641e3e9b8e8290f28ffa2d4c21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e655fb62216b6ba64a094b30f116d7988d19322d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e655fb62216b6ba64a094b30f116d7988d19322d", "html_url": "https://github.com/rust-lang/rust/commit/e655fb62216b6ba64a094b30f116d7988d19322d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e655fb62216b6ba64a094b30f116d7988d19322d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5d8117c338a788bd24abec733fd143dfceb25a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5d8117c338a788bd24abec733fd143dfceb25a0", "html_url": "https://github.com/rust-lang/rust/commit/f5d8117c338a788bd24abec733fd143dfceb25a0"}, {"sha": "c4d564c7808334bf08bcbad700f4a4a93a99be14", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4d564c7808334bf08bcbad700f4a4a93a99be14", "html_url": "https://github.com/rust-lang/rust/commit/c4d564c7808334bf08bcbad700f4a4a93a99be14"}], "stats": {"total": 1086, "additions": 769, "deletions": 317}, "files": [{"sha": "9d93370b7d0c9d4dd88cf8ee8ce46cc0a1c2ee78", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::interpret::{\n     read_target_uint, AllocId, Allocation, ConstValue, ErrorHandled, GlobalAlloc, Pointer, Scalar,\n };\n-use rustc_middle::ty::{Const, ConstKind};\n+use rustc_middle::ty::ConstKind;\n \n use cranelift_codegen::ir::GlobalValueData;\n use cranelift_module::*;\n@@ -39,7 +39,10 @@ impl ConstantCx {\n pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, '_>) -> bool {\n     let mut all_constants_ok = true;\n     for constant in &fx.mir.required_consts {\n-        let const_ = fx.monomorphize(constant.literal);\n+        let const_ = match fx.monomorphize(constant.literal) {\n+            ConstantKind::Ty(ct) => ct,\n+            ConstantKind::Val(..) => continue,\n+        };\n         match const_.val {\n             ConstKind::Value(_) => {}\n             ConstKind::Unevaluated(def, ref substs, promoted) => {\n@@ -113,19 +116,17 @@ pub(crate) fn codegen_constant<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     constant: &Constant<'tcx>,\n ) -> CValue<'tcx> {\n-    let const_ = fx.monomorphize(constant.literal);\n+    let const_ = match fx.monomorphize(constant.literal) {\n+        ConstantKind::Ty(ct) => ct,\n+        ConstantKind::Val(val, ty) => return codegen_const_value(fx, val, ty),\n+    };\n     let const_val = match const_.val {\n         ConstKind::Value(const_val) => const_val,\n         ConstKind::Unevaluated(def, ref substs, promoted) if fx.tcx.is_static(def.did) => {\n             assert!(substs.is_empty());\n             assert!(promoted.is_none());\n \n-            return codegen_static_ref(\n-                fx,\n-                def.did,\n-                fx.layout_of(fx.monomorphize(&constant.literal.ty)),\n-            )\n-            .to_cvalue(fx);\n+            return codegen_static_ref(fx, def.did, fx.layout_of(const_.ty)).to_cvalue(fx);\n         }\n         ConstKind::Unevaluated(def, ref substs, promoted) => {\n             match fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None) {\n@@ -422,11 +423,14 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n pub(crate) fn mir_operand_get_const_val<'tcx>(\n     fx: &FunctionCx<'_, '_, 'tcx>,\n     operand: &Operand<'tcx>,\n-) -> Option<&'tcx Const<'tcx>> {\n+) -> Option<ConstValue<'tcx>> {\n     match operand {\n         Operand::Copy(_) | Operand::Move(_) => None,\n-        Operand::Constant(const_) => {\n-            Some(fx.monomorphize(const_.literal).eval(fx.tcx, ParamEnv::reveal_all()))\n-        }\n+        Operand::Constant(const_) => match const_.literal {\n+            ConstantKind::Ty(const_) => {\n+                fx.monomorphize(const_).eval(fx.tcx, ParamEnv::reveal_all()).val.try_to_value()\n+            }\n+            ConstantKind::Val(val, _) => Some(val),\n+        },\n     }\n }"}, {"sha": "83c91f789cd25eb219e10431cc1bf44905e32d2c", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -53,7 +53,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n         };\n         llvm.x86.sse2.cmp.ps | llvm.x86.sse2.cmp.pd, (c x, c y, o kind) {\n             let kind_const = crate::constant::mir_operand_get_const_val(fx, kind).expect(\"llvm.x86.sse2.cmp.* kind not const\");\n-            let flt_cc = match kind_const.val.try_to_bits(Size::from_bytes(1)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", kind_const)) {\n+            let flt_cc = match kind_const.try_to_bits(Size::from_bytes(1)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", kind_const)) {\n                 0 => FloatCC::Equal,\n                 1 => FloatCC::LessThan,\n                 2 => FloatCC::LessThanOrEqual,\n@@ -84,7 +84,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n         llvm.x86.sse2.psrli.d, (c a, o imm8) {\n             let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8).expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n             simd_for_each_lane(fx, a, ret, |fx, _lane_layout, res_lane_layout, lane| {\n-                let res_lane = match imm8.val.try_to_bits(Size::from_bytes(4)).unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8)) {\n+                let res_lane = match imm8.try_to_bits(Size::from_bytes(4)).unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8)) {\n                     imm8 if imm8 < 32 => fx.bcx.ins().ushr_imm(lane, i64::from(imm8 as u8)),\n                     _ => fx.bcx.ins().iconst(types::I32, 0),\n                 };\n@@ -94,7 +94,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n         llvm.x86.sse2.pslli.d, (c a, o imm8) {\n             let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8).expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n             simd_for_each_lane(fx, a, ret, |fx, _lane_layout, res_lane_layout, lane| {\n-                let res_lane = match imm8.val.try_to_bits(Size::from_bytes(4)).unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8)) {\n+                let res_lane = match imm8.try_to_bits(Size::from_bytes(4)).unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8)) {\n                     imm8 if imm8 < 32 => fx.bcx.ins().ishl_imm(lane, i64::from(imm8 as u8)),\n                     _ => fx.bcx.ins().iconst(types::I32, 0),\n                 };"}, {"sha": "d17136080fea3212375348c3a902798dff676861", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -85,8 +85,8 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 use rustc_middle::mir::interpret::*;\n                 let idx_const = crate::constant::mir_operand_get_const_val(fx, idx).expect(\"simd_shuffle* idx not const\");\n \n-                let idx_bytes = match idx_const.val {\n-                    ty::ConstKind::Value(ConstValue::ByRef { alloc, offset }) => {\n+                let idx_bytes = match idx_const {\n+                    ConstValue::ByRef { alloc, offset } => {\n                         let ptr = Pointer::new(AllocId(0 /* dummy */), offset);\n                         let size = Size::from_bytes(4 * u64::from(ret_lane_count) /* size_of([u32; ret_lane_count]) */);\n                         alloc.get_bytes(fx, ptr, size).unwrap()\n@@ -130,7 +130,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 );\n             };\n \n-            let idx = idx_const.val.try_to_bits(Size::from_bytes(4 /* u32*/)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", idx_const));\n+            let idx = idx_const.try_to_bits(Size::from_bytes(4 /* u32*/)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", idx_const));\n             let (lane_count, _lane_ty) = base.layout().ty.simd_size_and_type(fx.tcx);\n             if idx >= lane_count.into() {\n                 fx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_insert] idx {} >= lane_count {}\", idx, lane_count));\n@@ -159,7 +159,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 return;\n             };\n \n-            let idx = idx_const.val.try_to_bits(Size::from_bytes(4 /* u32*/)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", idx_const));\n+            let idx = idx_const.try_to_bits(Size::from_bytes(4 /* u32*/)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", idx_const));\n             let (lane_count, _lane_ty) = v.layout().ty.simd_size_and_type(fx.tcx);\n             if idx >= lane_count.into() {\n                 fx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_extract] idx {} >= lane_count {}\", idx, lane_count));"}, {"sha": "38e928145a8160c30753046aad966bf9d839a6c4", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -231,7 +231,7 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n     fn visit_terminator(&mut self, terminator: &mir::Terminator<'tcx>, location: Location) {\n         let check = match terminator.kind {\n             mir::TerminatorKind::Call { func: mir::Operand::Constant(ref c), ref args, .. } => {\n-                match *c.literal.ty.kind() {\n+                match *c.ty().kind() {\n                     ty::FnDef(did, _) => Some((did, args)),\n                     _ => None,\n                 }"}, {"sha": "04225ddd36ffb1bed8b274083845edda2455718f", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -635,12 +635,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         if i == 2 && intrinsic.as_str().starts_with(\"simd_shuffle\") {\n                             if let mir::Operand::Constant(constant) = arg {\n                                 let c = self.eval_mir_constant(constant);\n-                                let (llval, ty) = self.simd_shuffle_indices(\n-                                    &bx,\n-                                    constant.span,\n-                                    constant.literal.ty,\n-                                    c,\n-                                );\n+                                let (llval, ty) =\n+                                    self.simd_shuffle_indices(&bx, constant.span, constant.ty(), c);\n                                 return OperandRef {\n                                     val: Immediate(llval),\n                                     layout: bx.layout_of(ty),\n@@ -830,7 +826,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         let const_value = self\n                             .eval_mir_constant(constant)\n                             .unwrap_or_else(|_| span_bug!(span, \"asm const cannot be resolved\"));\n-                        let ty = constant.literal.ty;\n+                        let ty = constant.ty();\n                         let size = bx.layout_of(ty).size;\n                         let scalar = match const_value {\n                             ConstValue::Scalar(s) => s,\n@@ -864,7 +860,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n                 mir::InlineAsmOperand::SymFn { ref value } => {\n                     let literal = self.monomorphize(value.literal);\n-                    if let ty::FnDef(def_id, substs) = *literal.ty.kind() {\n+                    if let ty::FnDef(def_id, substs) = *literal.ty().kind() {\n                         let instance = ty::Instance::resolve_for_fn_ptr(\n                             bx.tcx(),\n                             ty::ParamEnv::reveal_all(),"}, {"sha": "aa41acc357841e0e58d78dc3df37a7236752cec0", "filename": "compiler/rustc_codegen_ssa/src/mir/constant.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -16,15 +16,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         constant: &mir::Constant<'tcx>,\n     ) -> Result<OperandRef<'tcx, Bx::Value>, ErrorHandled> {\n         let val = self.eval_mir_constant(constant)?;\n-        let ty = self.monomorphize(constant.literal.ty);\n+        let ty = self.monomorphize(constant.ty());\n         Ok(OperandRef::from_const(bx, val, ty))\n     }\n \n     pub fn eval_mir_constant(\n         &self,\n         constant: &mir::Constant<'tcx>,\n     ) -> Result<ConstValue<'tcx>, ErrorHandled> {\n-        match self.monomorphize(constant.literal).val {\n+        let ct = self.monomorphize(constant.literal);\n+        let ct = match ct {\n+            mir::ConstantKind::Ty(ct) => ct,\n+            mir::ConstantKind::Val(val, _) => return Ok(val),\n+        };\n+        match ct.val {\n             ty::ConstKind::Unevaluated(def, substs, promoted) => self\n                 .cx\n                 .tcx()"}, {"sha": "a3f20abc82dc53f4d097672248779479cc3b6651", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -372,7 +372,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         (var_ty, var_kind)\n                     }\n                     mir::VarDebugInfoContents::Const(c) => {\n-                        let ty = self.monomorphize(c.literal.ty);\n+                        let ty = self.monomorphize(c.ty());\n                         (ty, VariableKind::LocalVariable)\n                     }\n                 };"}, {"sha": "5172dfd041aea501f5842bdd9487332626b55235", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -1,4 +1,4 @@\n-use std::convert::TryFrom;\n+use std::convert::{TryFrom, TryInto};\n use std::fmt;\n \n use rustc_apfloat::{\n@@ -8,12 +8,12 @@ use rustc_apfloat::{\n use rustc_macros::HashStable;\n use rustc_target::abi::{HasDataLayout, Size, TargetDataLayout};\n \n-use crate::ty::{ParamEnv, ScalarInt, Ty, TyCtxt};\n+use crate::ty::{Lift, ParamEnv, ScalarInt, Ty, TyCtxt};\n \n use super::{AllocId, Allocation, InterpResult, Pointer, PointerArithmetic};\n \n /// Represents the result of const evaluation via the `eval_to_allocation` query.\n-#[derive(Clone, HashStable, TyEncodable, TyDecodable, Debug)]\n+#[derive(Copy, Clone, HashStable, TyEncodable, TyDecodable, Debug, Hash, Eq, PartialEq)]\n pub struct ConstAlloc<'tcx> {\n     // the value lives here, at offset 0, and that allocation definitely is a `AllocKind::Memory`\n     // (so you can use `AllocMap::unwrap_memory`).\n@@ -47,6 +47,27 @@ pub enum ConstValue<'tcx> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(ConstValue<'_>, 32);\n \n+impl From<Scalar> for ConstValue<'tcx> {\n+    fn from(s: Scalar) -> Self {\n+        Self::Scalar(s)\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ConstValue<'a> {\n+    type Lifted = ConstValue<'tcx>;\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ConstValue<'tcx>> {\n+        Some(match self {\n+            ConstValue::Scalar(s) => ConstValue::Scalar(s),\n+            ConstValue::Slice { data, start, end } => {\n+                ConstValue::Slice { data: tcx.lift(data)?, start, end }\n+            }\n+            ConstValue::ByRef { alloc, offset } => {\n+                ConstValue::ByRef { alloc: tcx.lift(alloc)?, offset }\n+            }\n+        })\n+    }\n+}\n+\n impl<'tcx> ConstValue<'tcx> {\n     #[inline]\n     pub fn try_to_scalar(&self) -> Option<Scalar> {\n@@ -56,20 +77,20 @@ impl<'tcx> ConstValue<'tcx> {\n         }\n     }\n \n+    pub fn try_to_scalar_int(&self) -> Option<ScalarInt> {\n+        Some(self.try_to_scalar()?.assert_int())\n+    }\n+\n     pub fn try_to_bits(&self, size: Size) -> Option<u128> {\n-        self.try_to_scalar()?.to_bits(size).ok()\n+        self.try_to_scalar_int()?.to_bits(size).ok()\n     }\n \n     pub fn try_to_bool(&self) -> Option<bool> {\n-        match self.try_to_bits(Size::from_bytes(1))? {\n-            0 => Some(false),\n-            1 => Some(true),\n-            _ => None,\n-        }\n+        self.try_to_scalar_int()?.try_into().ok()\n     }\n \n     pub fn try_to_machine_usize(&self, tcx: TyCtxt<'tcx>) -> Option<u64> {\n-        Some(self.try_to_bits(tcx.data_layout.pointer_size)? as u64)\n+        self.try_to_scalar_int()?.try_to_machine_usize(tcx).ok()\n     }\n \n     pub fn try_to_bits_for_ty(\n@@ -503,6 +524,13 @@ impl<Tag> From<Pointer<Tag>> for Scalar<Tag> {\n     }\n }\n \n+impl<Tag> From<ScalarInt> for Scalar<Tag> {\n+    #[inline(always)]\n+    fn from(ptr: ScalarInt) -> Self {\n+        Scalar::Int(ptr)\n+    }\n+}\n+\n #[derive(Clone, Copy, Eq, PartialEq, TyEncodable, TyDecodable, HashStable, Hash)]\n pub enum ScalarMaybeUninit<Tag = ()> {\n     Scalar(Scalar<Tag>),"}, {"sha": "90fda9ec91cea789b597f79575365586e9a95be5", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 126, "deletions": 8, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -11,12 +11,12 @@ use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::subst::{Subst, SubstsRef};\n use crate::ty::{self, List, Ty, TyCtxt};\n-use crate::ty::{AdtDef, InstanceDef, Region, UserTypeAnnotationIndex};\n+use crate::ty::{AdtDef, InstanceDef, Region, ScalarInt, UserTypeAnnotationIndex};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, Namespace};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_hir::{self, GeneratorKind};\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{Size, VariantIdx};\n \n use polonius_engine::Atom;\n pub use rustc_ast::Mutability;\n@@ -30,6 +30,7 @@ use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::asm::InlineAsmRegOrRegClass;\n use std::borrow::Cow;\n+use std::convert::TryInto;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n use std::ops::{ControlFlow, Index, IndexMut};\n use std::slice;\n@@ -2032,7 +2033,7 @@ impl<'tcx> Operand<'tcx> {\n         Operand::Constant(box Constant {\n             span,\n             user_ty: None,\n-            literal: ty::Const::zero_sized(tcx, ty),\n+            literal: ConstantKind::Ty(ty::Const::zero_sized(tcx, ty)),\n         })\n     }\n \n@@ -2063,7 +2064,7 @@ impl<'tcx> Operand<'tcx> {\n         Operand::Constant(box Constant {\n             span,\n             user_ty: None,\n-            literal: ty::Const::from_scalar(tcx, val, ty),\n+            literal: ConstantKind::Val(val.into(), ty),\n         })\n     }\n \n@@ -2405,12 +2406,21 @@ pub struct Constant<'tcx> {\n     /// Needed for NLL to impose user-given type constraints.\n     pub user_ty: Option<UserTypeAnnotationIndex>,\n \n-    pub literal: &'tcx ty::Const<'tcx>,\n+    pub literal: ConstantKind<'tcx>,\n+}\n+\n+#[derive(Clone, Copy, PartialEq, PartialOrd, TyEncodable, TyDecodable, Hash, HashStable, Debug)]\n+pub enum ConstantKind<'tcx> {\n+    /// This constant came from the type system\n+    Ty(&'tcx ty::Const<'tcx>),\n+    /// This constant cannot go back into the type system, as it represents\n+    /// something the type system cannot handle (e.g. pointers).\n+    Val(interpret::ConstValue<'tcx>, Ty<'tcx>),\n }\n \n impl Constant<'tcx> {\n     pub fn check_static_ptr(&self, tcx: TyCtxt<'_>) -> Option<DefId> {\n-        match self.literal.val.try_to_scalar() {\n+        match self.literal.const_for_ty()?.val.try_to_scalar() {\n             Some(Scalar::Ptr(ptr)) => match tcx.global_alloc(ptr.alloc_id) {\n                 GlobalAlloc::Static(def_id) => {\n                     assert!(!tcx.is_thread_local_static(def_id));\n@@ -2421,6 +2431,94 @@ impl Constant<'tcx> {\n             _ => None,\n         }\n     }\n+    pub fn ty(&self) -> Ty<'tcx> {\n+        self.literal.ty()\n+    }\n+}\n+\n+impl From<&'tcx ty::Const<'tcx>> for ConstantKind<'tcx> {\n+    fn from(ct: &'tcx ty::Const<'tcx>) -> Self {\n+        Self::Ty(ct)\n+    }\n+}\n+\n+impl ConstantKind<'tcx> {\n+    /// Returns `None` if the constant is not trivially safe for use in the type system.\n+    pub fn const_for_ty(&self) -> Option<&'tcx ty::Const<'tcx>> {\n+        match self {\n+            ConstantKind::Ty(c) => Some(c),\n+            ConstantKind::Val(..) => None,\n+        }\n+    }\n+\n+    pub fn ty(&self) -> Ty<'tcx> {\n+        match self {\n+            ConstantKind::Ty(c) => c.ty,\n+            ConstantKind::Val(_, ty) => ty,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn try_to_value(self) -> Option<interpret::ConstValue<'tcx>> {\n+        match self {\n+            ConstantKind::Ty(c) => c.val.try_to_value(),\n+            ConstantKind::Val(val, _) => Some(val),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn try_to_scalar(self) -> Option<Scalar> {\n+        self.try_to_value()?.try_to_scalar()\n+    }\n+\n+    #[inline]\n+    pub fn try_to_scalar_int(self) -> Option<ScalarInt> {\n+        Some(self.try_to_value()?.try_to_scalar()?.assert_int())\n+    }\n+\n+    #[inline]\n+    pub fn try_to_bits(self, size: Size) -> Option<u128> {\n+        self.try_to_scalar_int()?.to_bits(size).ok()\n+    }\n+\n+    #[inline]\n+    pub fn try_to_bool(self) -> Option<bool> {\n+        self.try_to_scalar_int()?.try_into().ok()\n+    }\n+\n+    #[inline]\n+    pub fn try_eval_bits(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> Option<u128> {\n+        match self {\n+            Self::Ty(ct) => ct.try_eval_bits(tcx, param_env, ty),\n+            Self::Val(val, t) => {\n+                assert_eq!(*t, ty);\n+                let size =\n+                    tcx.layout_of(param_env.with_reveal_all_normalized(tcx).and(ty)).ok()?.size;\n+                val.try_to_bits(size)\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn try_eval_bool(&self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> Option<bool> {\n+        match self {\n+            Self::Ty(ct) => ct.try_eval_bool(tcx, param_env),\n+            Self::Val(val, _) => val.try_to_bool(),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn try_eval_usize(&self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> Option<u64> {\n+        match self {\n+            Self::Ty(ct) => ct.try_eval_usize(tcx, param_env),\n+            Self::Val(val, _) => val.try_to_machine_usize(tcx),\n+        }\n+    }\n }\n \n /// A collection of projections into user types.\n@@ -2606,11 +2704,14 @@ impl<'tcx> Debug for Constant<'tcx> {\n \n impl<'tcx> Display for Constant<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n-        match self.literal.ty.kind() {\n+        match self.ty().kind() {\n             ty::FnDef(..) => {}\n             _ => write!(fmt, \"const \")?,\n         }\n-        pretty_print_const(self.literal, fmt, true)\n+        match self.literal {\n+            ConstantKind::Ty(c) => pretty_print_const(c, fmt, true),\n+            ConstantKind::Val(val, ty) => pretty_print_const_value(val, ty, fmt, true),\n+        }\n     }\n }\n \n@@ -2629,6 +2730,23 @@ fn pretty_print_const(\n     })\n }\n \n+fn pretty_print_const_value(\n+    val: interpret::ConstValue<'tcx>,\n+    ty: Ty<'tcx>,\n+    fmt: &mut Formatter<'_>,\n+    print_types: bool,\n+) -> fmt::Result {\n+    use crate::ty::print::PrettyPrinter;\n+    ty::tls::with(|tcx| {\n+        let val = tcx.lift(val).unwrap();\n+        let ty = tcx.lift(ty).unwrap();\n+        let mut cx = FmtPrinter::new(tcx, fmt, Namespace::ValueNS);\n+        cx.print_alloc_ids = true;\n+        cx.pretty_print_const_value(val, ty, print_types)?;\n+        Ok(())\n+    })\n+}\n+\n impl<'tcx> graph::DirectedGraph for Body<'tcx> {\n     type Node = BasicBlock;\n }"}, {"sha": "6e8191459769829af787e8ba4324832168c314da", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -227,7 +227,7 @@ impl<'tcx> Operand<'tcx> {\n     {\n         match self {\n             &Operand::Copy(ref l) | &Operand::Move(ref l) => l.ty(local_decls, tcx).ty,\n-            &Operand::Constant(ref c) => c.literal.ty,\n+            &Operand::Constant(ref c) => c.literal.ty(),\n         }\n     }\n }"}, {"sha": "cb59927727010fd43094fb6d9aa7e8d1ce66fc6e", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -342,6 +342,23 @@ impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n         }\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        self.literal.visit_with(visitor)\n+        self.literal.visit_with(visitor)?;\n+        self.user_ty.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ConstantKind<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        match self {\n+            ConstantKind::Ty(c) => ConstantKind::Ty(c.fold_with(folder)),\n+            ConstantKind::Val(v, t) => ConstantKind::Val(v, t.fold_with(folder)),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n+        match *self {\n+            ConstantKind::Ty(c) => c.visit_with(visitor),\n+            ConstantKind::Val(_, t) => t.visit_with(visitor),\n+        }\n     }\n }"}, {"sha": "be248ccabda01e40aecbdb4efc6bcac05956b795", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -871,7 +871,10 @@ macro_rules! make_mir_visitor {\n \n                 self.visit_span(span);\n                 drop(user_ty); // no visit method for this\n-                self.visit_const(literal, location);\n+                match literal {\n+                    ConstantKind::Ty(ct) => self.visit_const(ct, location),\n+                    ConstantKind::Val(_, t) => self.visit_ty(t, TyContext::Location(location)),\n+                }\n             }\n \n             fn super_span(&mut self, _span: & $($mutability)? Span) {"}, {"sha": "872cf1ed1944fd8c14c700fcf153b79d219916ae", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -785,6 +785,14 @@ rustc_queries! {\n         cache_on_disk_if { true }\n     }\n \n+    /// Convert an evaluated constant to a type level constant or\n+    /// return `None` if that is not possible.\n+    query const_to_valtree(\n+        key: ty::ParamEnvAnd<'tcx, ConstAlloc<'tcx>>\n+    ) -> Option<ty::ValTree<'tcx>> {\n+        desc { \"destructure constant\" }\n+    }\n+\n     /// Destructure a constant ADT or array into its variant index and its\n     /// field values.\n     query destructure_const("}, {"sha": "f796534c2e1188d62f86a41a32ac5a60d521bdc0", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -333,6 +333,16 @@ impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::Const<'tcx> {\n     }\n }\n \n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [ty::ValTree<'tcx>] {\n+    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n+        Ok(decoder.tcx().arena.alloc_from_iter(\n+            (0..decoder.read_usize()?)\n+                .map(|_| Decodable::decode(decoder))\n+                .collect::<Result<Vec<_>, _>>()?,\n+        ))\n+    }\n+}\n+\n impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for Allocation {\n     fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n         Ok(decoder.tcx().intern_const_alloc(Decodable::decode(decoder)?))"}, {"sha": "622f8e8ff6cce0781b7b54e880f0acf1f46fc6c5", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -10,9 +10,11 @@ use rustc_macros::HashStable;\n \n mod int;\n mod kind;\n+mod valtree;\n \n pub use int::*;\n pub use kind::*;\n+pub use valtree::*;\n \n /// Typed constant value.\n #[derive(Copy, Clone, Debug, Hash, TyEncodable, TyDecodable, Eq, PartialEq, Ord, PartialOrd)]"}, {"sha": "8ed8ea6a0bc55b2dcbc4f73b0f8ed7e7e9d54975", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -5,6 +5,8 @@ use rustc_target::abi::{Size, TargetDataLayout};\n use std::convert::{TryFrom, TryInto};\n use std::fmt;\n \n+use crate::ty::TyCtxt;\n+\n #[derive(Copy, Clone)]\n /// A type for representing any integer. Only used for printing.\n pub struct ConstInt {\n@@ -239,6 +241,11 @@ impl ScalarInt {\n             Err(self.size())\n         }\n     }\n+\n+    #[inline]\n+    pub fn try_to_machine_usize(&self, tcx: TyCtxt<'tcx>) -> Result<u64, Size> {\n+        Ok(self.to_bits(tcx.data_layout.pointer_size)? as u64)\n+    }\n }\n \n macro_rules! from {\n@@ -277,6 +284,18 @@ macro_rules! try_from {\n from!(u8, u16, u32, u64, u128, bool);\n try_from!(u8, u16, u32, u64, u128);\n \n+impl TryFrom<ScalarInt> for bool {\n+    type Error = Size;\n+    #[inline]\n+    fn try_from(int: ScalarInt) -> Result<Self, Size> {\n+        int.to_bits(Size::from_bytes(1)).and_then(|u| match u {\n+            0 => Ok(false),\n+            1 => Ok(true),\n+            _ => Err(Size::from_bytes(1)),\n+        })\n+    }\n+}\n+\n impl From<char> for ScalarInt {\n     #[inline]\n     fn from(c: char) -> Self {"}, {"sha": "43e22ce8f8731b632fdf903ca2610377ad0e3fb4", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -1,3 +1,5 @@\n+use std::convert::TryInto;\n+\n use crate::mir::interpret::ConstValue;\n use crate::mir::interpret::Scalar;\n use crate::mir::Promoted;\n@@ -9,6 +11,8 @@ use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n use rustc_target::abi::Size;\n \n+use super::ScalarInt;\n+\n /// Represents a constant in Rust.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable)]\n@@ -51,14 +55,19 @@ impl<'tcx> ConstKind<'tcx> {\n         self.try_to_value()?.try_to_scalar()\n     }\n \n+    #[inline]\n+    pub fn try_to_scalar_int(self) -> Option<ScalarInt> {\n+        Some(self.try_to_value()?.try_to_scalar()?.assert_int())\n+    }\n+\n     #[inline]\n     pub fn try_to_bits(self, size: Size) -> Option<u128> {\n-        self.try_to_value()?.try_to_bits(size)\n+        self.try_to_scalar_int()?.to_bits(size).ok()\n     }\n \n     #[inline]\n     pub fn try_to_bool(self) -> Option<bool> {\n-        self.try_to_value()?.try_to_bool()\n+        self.try_to_scalar_int()?.try_into().ok()\n     }\n \n     #[inline]"}, {"sha": "f1b78c876328dbd47834d80ba711ab00aba9dbc7", "filename": "compiler/rustc_middle/src/ty/consts/valtree.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -0,0 +1,34 @@\n+use super::ScalarInt;\n+use rustc_macros::HashStable;\n+\n+#[derive(Copy, Clone, Debug, Hash, TyEncodable, TyDecodable, Eq, PartialEq, Ord, PartialOrd)]\n+#[derive(HashStable)]\n+/// This datastructure is used to represent the value of constants used in the type system.\n+///\n+/// We explicitly choose a different datastructure from the way values are processed within\n+/// CTFE, as in the type system equal values (according to their `PartialEq`) must also have\n+/// equal representation (`==` on the rustc data structure, e.g. `ValTree`) and vice versa.\n+/// Since CTFE uses `AllocId` to represent pointers, it often happens that two different\n+/// `AllocId`s point to equal values. So we may end up with different representations for\n+/// two constants whose value is `&42`. Furthermore any kind of struct that has padding will\n+/// have arbitrary values within that padding, even if the values of the struct are the same.\n+///\n+/// `ValTree` does not have this problem with representation, as it only contains integers or\n+/// lists of (nested) `ValTree`.\n+pub enum ValTree<'tcx> {\n+    /// ZSTs, integers, `bool`, `char` are represented as scalars.\n+    /// See the `ScalarInt` documentation for how `ScalarInt` guarantees that equal values\n+    /// of these types have the same representation.\n+    Leaf(ScalarInt),\n+    /// The fields of any kind of aggregate. Structs, tuples and arrays are represented by\n+    /// listing their fields' values in order.\n+    /// Enums are represented by storing their discriminant as a field, followed by all\n+    /// the fields of the variant.\n+    Branch(&'tcx [ValTree<'tcx>]),\n+}\n+\n+impl ValTree<'tcx> {\n+    pub fn zst() -> Self {\n+        Self::Branch(&[])\n+    }\n+}"}, {"sha": "9c0048d96da243e4364c4c25564126578570b7d8", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -95,6 +95,8 @@ pub struct CtxtInterners<'tcx> {\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n     place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n     const_: InternedSet<'tcx, Const<'tcx>>,\n+    /// Const allocations.\n+    allocation: InternedSet<'tcx, Allocation>,\n }\n \n impl<'tcx> CtxtInterners<'tcx> {\n@@ -112,6 +114,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n             projs: Default::default(),\n             place_elems: Default::default(),\n             const_: Default::default(),\n+            allocation: Default::default(),\n         }\n     }\n \n@@ -1041,9 +1044,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// `#[rustc_const_stable]` and `#[rustc_const_unstable]` attributes\n     const_stability_interner: ShardedHashMap<&'tcx attr::ConstStability, ()>,\n \n-    /// Stores the value of constants (and deduplicates the actual memory)\n-    allocation_interner: ShardedHashMap<&'tcx Allocation, ()>,\n-\n     /// Stores memory for globals (statics/consts).\n     pub(crate) alloc_map: Lock<interpret::AllocMap<'tcx>>,\n \n@@ -1086,7 +1086,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn intern_const_alloc(self, alloc: Allocation) -> &'tcx Allocation {\n-        self.allocation_interner.intern(alloc, |alloc| self.arena.alloc(alloc))\n+        self.interners\n+            .allocation\n+            .intern(alloc, |alloc| Interned(self.interners.arena.alloc(alloc)))\n+            .0\n     }\n \n     /// Allocates a read-only byte or string literal for `mir::interpret`.\n@@ -1205,7 +1208,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             layout_interner: Default::default(),\n             stability_interner: Default::default(),\n             const_stability_interner: Default::default(),\n-            allocation_interner: Default::default(),\n             alloc_map: Lock::new(interpret::AllocMap::new()),\n             output_filenames: Arc::new(output_filenames.clone()),\n         }\n@@ -1641,6 +1643,7 @@ macro_rules! nop_list_lift {\n nop_lift! {type_; Ty<'a> => Ty<'tcx>}\n nop_lift! {region; Region<'a> => Region<'tcx>}\n nop_lift! {const_; &'a Const<'a> => &'tcx Const<'tcx>}\n+nop_lift! {allocation; &'a Allocation => &'tcx Allocation}\n nop_lift! {predicate; &'a PredicateInner<'a> => &'tcx PredicateInner<'tcx>}\n \n nop_list_lift! {type_list; Ty<'a> => Ty<'tcx>}\n@@ -1931,7 +1934,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     \"Const Stability interner: #{}\",\n                     self.0.const_stability_interner.len()\n                 )?;\n-                writeln!(fmt, \"Allocation interner: #{}\", self.0.allocation_interner.len())?;\n+                writeln!(fmt, \"Allocation interner: #{}\", self.0.interners.allocation.len())?;\n                 writeln!(fmt, \"Layout interner: #{}\", self.0.layout_interner.len())?;\n \n                 Ok(())\n@@ -2032,6 +2035,26 @@ impl<'tcx> Borrow<Const<'tcx>> for Interned<'tcx, Const<'tcx>> {\n     }\n }\n \n+impl<'tcx> Borrow<Allocation> for Interned<'tcx, Allocation> {\n+    fn borrow<'a>(&'a self) -> &'a Allocation {\n+        &self.0\n+    }\n+}\n+\n+impl<'tcx> PartialEq for Interned<'tcx, Allocation> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.0 == other.0\n+    }\n+}\n+\n+impl<'tcx> Eq for Interned<'tcx, Allocation> {}\n+\n+impl<'tcx> Hash for Interned<'tcx, Allocation> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        self.0.hash(s)\n+    }\n+}\n+\n macro_rules! direct_interners {\n     ($($name:ident: $method:ident($ty:ty),)+) => {\n         $(impl<'tcx> PartialEq for Interned<'tcx, $ty> {"}, {"sha": "5bbf7b35d3d74cb646bc0546b5f172ac0cfe3eea", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -55,7 +55,7 @@ pub use rustc_type_ir::*;\n \n pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n-pub use self::consts::{Const, ConstInt, ConstKind, InferConst, ScalarInt};\n+pub use self::consts::{Const, ConstInt, ConstKind, InferConst, ScalarInt, ValTree};\n pub use self::context::{\n     tls, CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n     CtxtInterners, DelaySpanBugEmitted, FreeRegionInfo, GeneratorInteriorTypeCause, GlobalCtxt,"}, {"sha": "7946d170064c98b2061680dd05cc184d991b01c2", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 67, "deletions": 46, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -956,32 +956,40 @@ pub trait PrettyPrinter<'tcx>:\n     }\n \n     fn pretty_print_const_scalar(\n-        mut self,\n+        self,\n         scalar: Scalar,\n         ty: Ty<'tcx>,\n         print_ty: bool,\n+    ) -> Result<Self::Const, Self::Error> {\n+        match scalar {\n+            Scalar::Ptr(ptr) => self.pretty_print_const_scalar_ptr(ptr, ty, print_ty),\n+            Scalar::Int(int) => self.pretty_print_const_scalar_int(int, ty, print_ty),\n+        }\n+    }\n+\n+    fn pretty_print_const_scalar_ptr(\n+        mut self,\n+        ptr: Pointer,\n+        ty: Ty<'tcx>,\n+        print_ty: bool,\n     ) -> Result<Self::Const, Self::Error> {\n         define_scoped_cx!(self);\n \n-        match (scalar, &ty.kind()) {\n+        match ty.kind() {\n             // Byte strings (&[u8; N])\n-            (\n-                Scalar::Ptr(ptr),\n-                ty::Ref(\n-                    _,\n-                    ty::TyS {\n-                        kind:\n-                            ty::Array(\n-                                ty::TyS { kind: ty::Uint(ty::UintTy::U8), .. },\n-                                ty::Const {\n-                                    val: ty::ConstKind::Value(ConstValue::Scalar(int)),\n-                                    ..\n-                                },\n-                            ),\n-                        ..\n-                    },\n-                    _,\n-                ),\n+            ty::Ref(\n+                _,\n+                ty::TyS {\n+                    kind:\n+                        ty::Array(\n+                            ty::TyS { kind: ty::Uint(ty::UintTy::U8), .. },\n+                            ty::Const {\n+                                val: ty::ConstKind::Value(ConstValue::Scalar(int)), ..\n+                            },\n+                        ),\n+                    ..\n+                },\n+                _,\n             ) => match self.tcx().get_global_alloc(ptr.alloc_id) {\n                 Some(GlobalAlloc::Memory(alloc)) => {\n                     let bytes = int.assert_bits(self.tcx().data_layout.pointer_size);\n@@ -997,28 +1005,59 @@ pub trait PrettyPrinter<'tcx>:\n                 Some(GlobalAlloc::Function(_)) => p!(\"<function>\"),\n                 None => p!(\"<dangling pointer>\"),\n             },\n+            ty::FnPtr(_) => {\n+                // FIXME: We should probably have a helper method to share code with the \"Byte strings\"\n+                // printing above (which also has to handle pointers to all sorts of things).\n+                match self.tcx().get_global_alloc(ptr.alloc_id) {\n+                    Some(GlobalAlloc::Function(instance)) => {\n+                        self = self.typed_value(\n+                            |this| this.print_value_path(instance.def_id(), instance.substs),\n+                            |this| this.print_type(ty),\n+                            \" as \",\n+                        )?;\n+                    }\n+                    _ => self = self.pretty_print_const_pointer(ptr, ty, print_ty)?,\n+                }\n+            }\n+            // Any pointer values not covered by a branch above\n+            _ => {\n+                self = self.pretty_print_const_pointer(ptr, ty, print_ty)?;\n+            }\n+        }\n+        Ok(self)\n+    }\n+\n+    fn pretty_print_const_scalar_int(\n+        mut self,\n+        int: ScalarInt,\n+        ty: Ty<'tcx>,\n+        print_ty: bool,\n+    ) -> Result<Self::Const, Self::Error> {\n+        define_scoped_cx!(self);\n+\n+        match ty.kind() {\n             // Bool\n-            (Scalar::Int(int), ty::Bool) if int == ScalarInt::FALSE => p!(\"false\"),\n-            (Scalar::Int(int), ty::Bool) if int == ScalarInt::TRUE => p!(\"true\"),\n+            ty::Bool if int == ScalarInt::FALSE => p!(\"false\"),\n+            ty::Bool if int == ScalarInt::TRUE => p!(\"true\"),\n             // Float\n-            (Scalar::Int(int), ty::Float(ty::FloatTy::F32)) => {\n+            ty::Float(ty::FloatTy::F32) => {\n                 p!(write(\"{}f32\", Single::try_from(int).unwrap()))\n             }\n-            (Scalar::Int(int), ty::Float(ty::FloatTy::F64)) => {\n+            ty::Float(ty::FloatTy::F64) => {\n                 p!(write(\"{}f64\", Double::try_from(int).unwrap()))\n             }\n             // Int\n-            (Scalar::Int(int), ty::Uint(_) | ty::Int(_)) => {\n+            ty::Uint(_) | ty::Int(_) => {\n                 let int =\n                     ConstInt::new(int, matches!(ty.kind(), ty::Int(_)), ty.is_ptr_sized_integral());\n                 if print_ty { p!(write(\"{:#?}\", int)) } else { p!(write(\"{:?}\", int)) }\n             }\n             // Char\n-            (Scalar::Int(int), ty::Char) if char::try_from(int).is_ok() => {\n+            ty::Char if char::try_from(int).is_ok() => {\n                 p!(write(\"{:?}\", char::try_from(int).unwrap()))\n             }\n             // Raw pointers\n-            (Scalar::Int(int), ty::RawPtr(_) | ty::FnPtr(_)) => {\n+            ty::RawPtr(_) | ty::FnPtr(_) => {\n                 let data = int.assert_bits(self.tcx().data_layout.pointer_size);\n                 self = self.typed_value(\n                     |mut this| {\n@@ -1029,26 +1068,12 @@ pub trait PrettyPrinter<'tcx>:\n                     \" as \",\n                 )?;\n             }\n-            (Scalar::Ptr(ptr), ty::FnPtr(_)) => {\n-                // FIXME: We should probably have a helper method to share code with the \"Byte strings\"\n-                // printing above (which also has to handle pointers to all sorts of things).\n-                match self.tcx().get_global_alloc(ptr.alloc_id) {\n-                    Some(GlobalAlloc::Function(instance)) => {\n-                        self = self.typed_value(\n-                            |this| this.print_value_path(instance.def_id(), instance.substs),\n-                            |this| this.print_type(ty),\n-                            \" as \",\n-                        )?;\n-                    }\n-                    _ => self = self.pretty_print_const_pointer(ptr, ty, print_ty)?,\n-                }\n-            }\n             // For function type zsts just printing the path is enough\n-            (Scalar::Int(int), ty::FnDef(d, s)) if int == ScalarInt::ZST => {\n+            ty::FnDef(d, s) if int == ScalarInt::ZST => {\n                 p!(print_value_path(*d, s))\n             }\n             // Nontrivial types with scalar bit representation\n-            (Scalar::Int(int), _) => {\n+            _ => {\n                 let print = |mut this: Self| {\n                     if int.size() == Size::ZERO {\n                         write!(this, \"transmute(())\")?;\n@@ -1063,10 +1088,6 @@ pub trait PrettyPrinter<'tcx>:\n                     print(self)?\n                 };\n             }\n-            // Any pointer values not covered by a branch above\n-            (Scalar::Ptr(p), _) => {\n-                self = self.pretty_print_const_pointer(p, ty, print_ty)?;\n-            }\n         }\n         Ok(self)\n     }"}, {"sha": "48e777f7158fd5cfbc790d12a3049b782ecf9537", "filename": "compiler/rustc_middle/src/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -14,8 +14,8 @@ use crate::middle::resolve_lifetime::{ObjectLifetimeDefault, Region, ResolveLife\n use crate::middle::stability::{self, DeprecationEntry};\n use crate::mir;\n use crate::mir::interpret::GlobalId;\n+use crate::mir::interpret::{ConstAlloc, LitToConstError, LitToConstInput};\n use crate::mir::interpret::{ConstValue, EvalToAllocationRawResult, EvalToConstValueResult};\n-use crate::mir::interpret::{LitToConstError, LitToConstInput};\n use crate::mir::mono::CodegenUnit;\n use crate::traits::query::{\n     CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,"}, {"sha": "436ca4c0578cb7c4a83768be19ed8d82f4e5a748", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 74, "deletions": 85, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -4,13 +4,12 @@\n //! types or regions but can be other things. Examples of type relations are\n //! subtyping, type equality, etc.\n \n-use crate::mir::interpret::{get_slice_bytes, ConstValue};\n+use crate::mir::interpret::{get_slice_bytes, ConstValue, GlobalAlloc, Scalar};\n use crate::ty::error::{ExpectedFound, TypeError};\n use crate::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_hir as ast;\n use rustc_hir::def_id::DefId;\n-use rustc_span::DUMMY_SP;\n use rustc_target::spec::abi;\n use std::iter;\n \n@@ -498,104 +497,41 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n     debug!(\"{}.super_relate_consts(a = {:?}, b = {:?})\", relation.tag(), a, b);\n     let tcx = relation.tcx();\n \n-    let eagerly_eval = |x: &'tcx ty::Const<'tcx>| x.eval(tcx, relation.param_env()).val;\n+    // FIXME(oli-obk): once const generics can have generic types, this assertion\n+    // will likely get triggered. Move to `normalize_erasing_regions` at that point.\n+    assert_eq!(\n+        tcx.erase_regions(a.ty),\n+        tcx.erase_regions(b.ty),\n+        \"cannot relate constants of different types\"\n+    );\n \n-    // FIXME(eddyb) doesn't look like everything below checks that `a.ty == b.ty`.\n-    // We could probably always assert it early, as const generic parameters\n-    // are not allowed to depend on other generic parameters, i.e. are concrete.\n-    // (although there could be normalization differences)\n+    let eagerly_eval = |x: &'tcx ty::Const<'tcx>| x.eval(tcx, relation.param_env());\n+    let a = eagerly_eval(a);\n+    let b = eagerly_eval(b);\n \n     // Currently, the values that can be unified are primitive types,\n     // and those that derive both `PartialEq` and `Eq`, corresponding\n     // to structural-match types.\n-    let new_const_val = match (eagerly_eval(a), eagerly_eval(b)) {\n+    let is_match = match (a.val, b.val) {\n         (ty::ConstKind::Infer(_), _) | (_, ty::ConstKind::Infer(_)) => {\n             // The caller should handle these cases!\n             bug!(\"var types encountered in super_relate_consts: {:?} {:?}\", a, b)\n         }\n \n-        (ty::ConstKind::Error(d), _) | (_, ty::ConstKind::Error(d)) => Ok(ty::ConstKind::Error(d)),\n+        (ty::ConstKind::Error(_), _) => return Ok(a),\n+        (_, ty::ConstKind::Error(_)) => return Ok(b),\n \n-        (ty::ConstKind::Param(a_p), ty::ConstKind::Param(b_p)) if a_p.index == b_p.index => {\n-            return Ok(a);\n-        }\n-        (ty::ConstKind::Placeholder(p1), ty::ConstKind::Placeholder(p2)) if p1 == p2 => {\n-            return Ok(a);\n-        }\n+        (ty::ConstKind::Param(a_p), ty::ConstKind::Param(b_p)) => a_p.index == b_p.index,\n+        (ty::ConstKind::Placeholder(p1), ty::ConstKind::Placeholder(p2)) => p1 == p2,\n         (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => {\n-            let new_val = match (a_val, b_val) {\n-                (ConstValue::Scalar(a_val), ConstValue::Scalar(b_val)) if a.ty == b.ty => {\n-                    if a_val == b_val {\n-                        Ok(ConstValue::Scalar(a_val))\n-                    } else if let ty::FnPtr(_) = a.ty.kind() {\n-                        let a_instance = tcx.global_alloc(a_val.assert_ptr().alloc_id).unwrap_fn();\n-                        let b_instance = tcx.global_alloc(b_val.assert_ptr().alloc_id).unwrap_fn();\n-                        if a_instance == b_instance {\n-                            Ok(ConstValue::Scalar(a_val))\n-                        } else {\n-                            Err(TypeError::ConstMismatch(expected_found(relation, a, b)))\n-                        }\n-                    } else {\n-                        Err(TypeError::ConstMismatch(expected_found(relation, a, b)))\n-                    }\n-                }\n-\n-                (ConstValue::Slice { .. }, ConstValue::Slice { .. }) => {\n-                    let a_bytes = get_slice_bytes(&tcx, a_val);\n-                    let b_bytes = get_slice_bytes(&tcx, b_val);\n-                    if a_bytes == b_bytes {\n-                        Ok(a_val)\n-                    } else {\n-                        Err(TypeError::ConstMismatch(expected_found(relation, a, b)))\n-                    }\n-                }\n-\n-                (ConstValue::ByRef { .. }, ConstValue::ByRef { .. }) => {\n-                    match a.ty.kind() {\n-                        ty::Array(..) | ty::Adt(..) | ty::Tuple(..) => {\n-                            let a_destructured = tcx.destructure_const(relation.param_env().and(a));\n-                            let b_destructured = tcx.destructure_const(relation.param_env().and(b));\n-\n-                            // Both the variant and each field have to be equal.\n-                            if a_destructured.variant == b_destructured.variant {\n-                                for (a_field, b_field) in\n-                                    a_destructured.fields.iter().zip(b_destructured.fields.iter())\n-                                {\n-                                    relation.consts(a_field, b_field)?;\n-                                }\n-\n-                                Ok(a_val)\n-                            } else {\n-                                Err(TypeError::ConstMismatch(expected_found(relation, a, b)))\n-                            }\n-                        }\n-                        // FIXME(const_generics): There are probably some `TyKind`s\n-                        // which should be handled here.\n-                        _ => {\n-                            tcx.sess.delay_span_bug(\n-                                DUMMY_SP,\n-                                &format!(\"unexpected consts: a: {:?}, b: {:?}\", a, b),\n-                            );\n-                            Err(TypeError::ConstMismatch(expected_found(relation, a, b)))\n-                        }\n-                    }\n-                }\n-\n-                _ => Err(TypeError::ConstMismatch(expected_found(relation, a, b))),\n-            };\n-\n-            new_val.map(ty::ConstKind::Value)\n+            check_const_value_eq(relation, a_val, b_val, a, b)?\n         }\n \n         (\n             ty::ConstKind::Unevaluated(a_def, a_substs, None),\n             ty::ConstKind::Unevaluated(b_def, b_substs, None),\n         ) if tcx.features().const_evaluatable_checked && !relation.visit_ct_substs() => {\n-            if tcx.try_unify_abstract_consts(((a_def, a_substs), (b_def, b_substs))) {\n-                Ok(a.val)\n-            } else {\n-                Err(TypeError::ConstMismatch(expected_found(relation, a, b)))\n-            }\n+            tcx.try_unify_abstract_consts(((a_def, a_substs), (b_def, b_substs)))\n         }\n \n         // While this is slightly incorrect, it shouldn't matter for `min_const_generics`\n@@ -607,11 +543,64 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n         ) if a_def == b_def && a_promoted == b_promoted => {\n             let substs =\n                 relation.relate_with_variance(ty::Variance::Invariant, a_substs, b_substs)?;\n-            Ok(ty::ConstKind::Unevaluated(a_def, substs, a_promoted))\n+            return Ok(tcx.mk_const(ty::Const {\n+                val: ty::ConstKind::Unevaluated(a_def, substs, a_promoted),\n+                ty: a.ty,\n+            }));\n         }\n-        _ => Err(TypeError::ConstMismatch(expected_found(relation, a, b))),\n+        _ => false,\n     };\n-    new_const_val.map(|val| tcx.mk_const(ty::Const { val, ty: a.ty }))\n+    if is_match { Ok(a) } else { Err(TypeError::ConstMismatch(expected_found(relation, a, b))) }\n+}\n+\n+fn check_const_value_eq<R: TypeRelation<'tcx>>(\n+    relation: &mut R,\n+    a_val: ConstValue<'tcx>,\n+    b_val: ConstValue<'tcx>,\n+    // FIXME(oli-obk): these arguments should go away with valtrees\n+    a: &'tcx ty::Const<'tcx>,\n+    b: &'tcx ty::Const<'tcx>,\n+    // FIXME(oli-obk): this should just be `bool` with valtrees\n+) -> RelateResult<'tcx, bool> {\n+    let tcx = relation.tcx();\n+    Ok(match (a_val, b_val) {\n+        (ConstValue::Scalar(Scalar::Int(a_val)), ConstValue::Scalar(Scalar::Int(b_val))) => {\n+            a_val == b_val\n+        }\n+        (ConstValue::Scalar(Scalar::Ptr(a_val)), ConstValue::Scalar(Scalar::Ptr(b_val))) => {\n+            a_val == b_val\n+                || match (tcx.global_alloc(a_val.alloc_id), tcx.global_alloc(b_val.alloc_id)) {\n+                    (GlobalAlloc::Function(a_instance), GlobalAlloc::Function(b_instance)) => {\n+                        a_instance == b_instance\n+                    }\n+                    _ => false,\n+                }\n+        }\n+\n+        (ConstValue::Slice { .. }, ConstValue::Slice { .. }) => {\n+            get_slice_bytes(&tcx, a_val) == get_slice_bytes(&tcx, b_val)\n+        }\n+\n+        (ConstValue::ByRef { .. }, ConstValue::ByRef { .. }) => {\n+            let a_destructured = tcx.destructure_const(relation.param_env().and(a));\n+            let b_destructured = tcx.destructure_const(relation.param_env().and(b));\n+\n+            // Both the variant and each field have to be equal.\n+            if a_destructured.variant == b_destructured.variant {\n+                for (a_field, b_field) in\n+                    a_destructured.fields.iter().zip(b_destructured.fields.iter())\n+                {\n+                    relation.consts(a_field, b_field)?;\n+                }\n+\n+                true\n+            } else {\n+                false\n+            }\n+        }\n+\n+        _ => false,\n+    })\n }\n \n impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>> {"}, {"sha": "bc15b3972c9fce14e6122d077ad2a8458c6eb2e0", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -81,12 +81,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let terminator = self.body[location.block].terminator();\n         debug!(\"add_moved_or_invoked_closure_note: terminator={:?}\", terminator);\n         if let TerminatorKind::Call {\n-            func: Operand::Constant(box Constant { literal: ty::Const { ty: const_ty, .. }, .. }),\n+            func: Operand::Constant(box Constant { literal, .. }),\n             args,\n             ..\n         } = &terminator.kind\n         {\n-            if let ty::FnDef(id, _) = *const_ty.kind() {\n+            if let ty::FnDef(id, _) = *literal.ty().kind() {\n                 debug!(\"add_moved_or_invoked_closure_note: id={:?}\", id);\n                 if self.infcx.tcx.parent(id) == self.infcx.tcx.lang_items().fn_once_trait() {\n                     let closure = match args.first() {"}, {"sha": "cce1549cb29c2fd47765cb9ecc595b47a7447c71", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -282,7 +282,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n \n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         self.super_constant(constant, location);\n-        let ty = self.sanitize_type(constant, constant.literal.ty);\n+        let ty = self.sanitize_type(constant, constant.literal.ty());\n \n         self.cx.infcx.tcx.for_each_free_region(&ty, |live_region| {\n             let live_region_vid =\n@@ -296,7 +296,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n \n         if let Some(annotation_index) = constant.user_ty {\n             if let Err(terr) = self.cx.relate_type_and_user_type(\n-                constant.literal.ty,\n+                constant.literal.ty(),\n                 ty::Variance::Invariant,\n                 &UserTypeProjection { base: annotation_index, projs: vec![] },\n                 location.to_locations(),\n@@ -308,13 +308,22 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                     constant,\n                     \"bad constant user type {:?} vs {:?}: {:?}\",\n                     annotation,\n-                    constant.literal.ty,\n+                    constant.literal.ty(),\n                     terr,\n                 );\n             }\n         } else {\n             let tcx = self.tcx();\n-            if let ty::ConstKind::Unevaluated(def, substs, promoted) = constant.literal.val {\n+            let maybe_uneval = match constant.literal {\n+                ConstantKind::Ty(ct) => match ct.val {\n+                    ty::ConstKind::Unevaluated(def, substs, promoted) => {\n+                        Some((def, substs, promoted))\n+                    }\n+                    _ => None,\n+                },\n+                _ => None,\n+            };\n+            if let Some((def, substs, promoted)) = maybe_uneval {\n                 if let Some(promoted) = promoted {\n                     let check_err = |verifier: &mut TypeVerifier<'a, 'b, 'tcx>,\n                                      promoted: &Body<'tcx>,\n@@ -349,7 +358,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                         location.to_locations(),\n                         ConstraintCategory::Boring,\n                         self.cx.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n-                            constant.literal.ty,\n+                            constant.literal.ty(),\n                             def.did,\n                             UserSubsts { substs, user_self_ty: None },\n                         )),\n@@ -367,7 +376,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                 let unnormalized_ty = tcx.type_of(static_def_id);\n                 let locations = location.to_locations();\n                 let normalized_ty = self.cx.normalize(unnormalized_ty, locations);\n-                let literal_ty = constant.literal.ty.builtin_deref(true).unwrap().ty;\n+                let literal_ty = constant.literal.ty().builtin_deref(true).unwrap().ty;\n \n                 if let Err(terr) = self.cx.eq_types(\n                     normalized_ty,\n@@ -379,7 +388,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            if let ty::FnDef(def_id, substs) = *constant.literal.ty.kind() {\n+            if let ty::FnDef(def_id, substs) = *constant.literal.ty().kind() {\n                 let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n                 self.cx.normalize_and_prove_instantiated_predicates(\n                     instantiated_predicates,"}, {"sha": "77531ae2c5f05307341682b9dca7df96b512e206", "filename": "compiler/rustc_mir/src/const_eval/mod.rs", "status": "modified", "additions": 99, "deletions": 2, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -3,12 +3,15 @@\n use std::convert::TryFrom;\n \n use rustc_hir::Mutability;\n-use rustc_middle::mir;\n use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::{\n+    mir::{self, interpret::ConstAlloc},\n+    ty::ScalarInt,\n+};\n use rustc_span::{source_map::DUMMY_SP, symbol::Symbol};\n \n use crate::interpret::{\n-    intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, MemPlaceMeta, Scalar,\n+    intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, MPlaceTy, MemPlaceMeta, Scalar,\n };\n \n mod error;\n@@ -35,6 +38,100 @@ pub(crate) fn const_caller_location(\n     ConstValue::Scalar(loc_place.ptr)\n }\n \n+/// Convert an evaluated constant to a type level constant\n+pub(crate) fn const_to_valtree<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    raw: ConstAlloc<'tcx>,\n+) -> Option<ty::ValTree<'tcx>> {\n+    let ecx = mk_eval_cx(\n+        tcx, DUMMY_SP, param_env,\n+        // It is absolutely crucial for soundness that\n+        // we do not read from static items or other mutable memory.\n+        false,\n+    );\n+    let place = ecx.raw_const_to_mplace(raw).unwrap();\n+    const_to_valtree_inner(&ecx, &place)\n+}\n+\n+fn const_to_valtree_inner<'tcx>(\n+    ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n+    place: &MPlaceTy<'tcx>,\n+) -> Option<ty::ValTree<'tcx>> {\n+    let branches = |n, variant| {\n+        let place = match variant {\n+            Some(variant) => ecx.mplace_downcast(&place, variant).unwrap(),\n+            None => *place,\n+        };\n+        let variant =\n+            variant.map(|variant| Some(ty::ValTree::Leaf(ScalarInt::from(variant.as_u32()))));\n+        let fields = (0..n).map(|i| {\n+            let field = ecx.mplace_field(&place, i).unwrap();\n+            const_to_valtree_inner(ecx, &field)\n+        });\n+        // For enums, we preped their variant index before the variant's fields so we can figure out\n+        // the variant again when just seeing a valtree.\n+        let branches = variant.into_iter().chain(fields);\n+        Some(ty::ValTree::Branch(\n+            ecx.tcx.arena.alloc_from_iter(branches.collect::<Option<Vec<_>>>()?),\n+        ))\n+    };\n+    match place.layout.ty.kind() {\n+        ty::FnDef(..) => Some(ty::ValTree::zst()),\n+        ty::Bool | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Char => {\n+            let val = ecx.read_immediate(&place.into()).unwrap();\n+            let val = val.to_scalar().unwrap();\n+            Some(ty::ValTree::Leaf(val.assert_int()))\n+        }\n+\n+        // Raw pointers are not allowed in type level constants, as we cannot properly test them for\n+        // equality at compile-time (see `ptr_guaranteed_eq`/`_ne`).\n+        // Technically we could allow function pointers (represented as `ty::Instance`), but this is not guaranteed to\n+        // agree with runtime equality tests.\n+        ty::FnPtr(_) | ty::RawPtr(_) => None,\n+        ty::Ref(..) => unimplemented!(\"need to use deref_const\"),\n+\n+        // Trait objects are not allowed in type level constants, as we have no concept for\n+        // resolving their backing type, even if we can do that at const eval time. We may\n+        // hypothetically be able to allow `dyn StructuralEq` trait objects in the future,\n+        // but it is unclear if this is useful.\n+        ty::Dynamic(..) => None,\n+\n+        ty::Slice(_) | ty::Str => {\n+            unimplemented!(\"need to find the backing data of the slice/str and recurse on that\")\n+        }\n+        ty::Tuple(substs) => branches(substs.len(), None),\n+        ty::Array(_, len) => branches(usize::try_from(len.eval_usize(ecx.tcx.tcx, ecx.param_env)).unwrap(), None),\n+\n+        ty::Adt(def, _) => {\n+            if def.variants.is_empty() {\n+                bug!(\"uninhabited types should have errored and never gotten converted to valtree\")\n+            }\n+\n+            let variant = ecx.read_discriminant(&place.into()).unwrap().1;\n+\n+            branches(def.variants[variant].fields.len(), Some(variant))\n+        }\n+\n+        ty::Never\n+        | ty::Error(_)\n+        | ty::Foreign(..)\n+        | ty::Infer(ty::FreshIntTy(_))\n+        | ty::Infer(ty::FreshFloatTy(_))\n+        | ty::Projection(..)\n+        | ty::Param(_)\n+        | ty::Bound(..)\n+        | ty::Placeholder(..)\n+        // FIXME(oli-obk): we could look behind opaque types\n+        | ty::Opaque(..)\n+        | ty::Infer(_)\n+        // FIXME(oli-obk): we can probably encode closures just like structs\n+        | ty::Closure(..)\n+        | ty::Generator(..)\n+        | ty::GeneratorWitness(..) => None,\n+    }\n+}\n+\n /// This function uses `unwrap` copiously, because an already validated constant\n /// must have valid fields and can thus never fail outside of compiler bugs. However, it is\n /// invoked from the pretty printer, where it can receive enums with no variants and e.g."}, {"sha": "149a9f81ea0d9a9bf8b353a6cec7f02a0111403d", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -689,7 +689,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             let span = const_.span;\n             let const_ =\n                 self.subst_from_current_frame_and_normalize_erasing_regions(const_.literal);\n-            self.const_to_op(const_, None).map_err(|err| {\n+            self.mir_const_to_op(&const_, None).map_err(|err| {\n                 // If there was an error, set the span of the current frame to this constant.\n                 // Avoiding doing this when evaluation succeeds.\n                 self.frame_mut().loc = Err(span);"}, {"sha": "28933493a21c41bcfd271b194bbeda51bb6069fc", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -532,7 +532,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // * During ConstProp, with `TooGeneric` or since the `requried_consts` were not all\n                 //   checked yet.\n                 // * During CTFE, since promoteds in `const`/`static` initializer bodies can fail.\n-                self.const_to_op(val, layout)?\n+\n+                self.mir_const_to_op(&val, layout)?\n             }\n         };\n         trace!(\"{:?}: {:?}\", mir_op, *op);\n@@ -556,28 +557,45 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         val: &ty::Const<'tcx>,\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        let tag_scalar = |scalar| -> InterpResult<'tcx, _> {\n-            Ok(match scalar {\n-                Scalar::Ptr(ptr) => Scalar::Ptr(self.global_base_pointer(ptr)?),\n-                Scalar::Int(int) => Scalar::Int(int),\n-            })\n-        };\n-        // Early-return cases.\n-        let val_val = match val.val {\n+        match val.val {\n             ty::ConstKind::Param(_) | ty::ConstKind::Bound(..) => throw_inval!(TooGeneric),\n             ty::ConstKind::Error(_) => throw_inval!(AlreadyReported(ErrorReported)),\n             ty::ConstKind::Unevaluated(def, substs, promoted) => {\n                 let instance = self.resolve(def, substs)?;\n-                return Ok(self.eval_to_allocation(GlobalId { instance, promoted })?.into());\n+                Ok(self.eval_to_allocation(GlobalId { instance, promoted })?.into())\n             }\n             ty::ConstKind::Infer(..) | ty::ConstKind::Placeholder(..) => {\n                 span_bug!(self.cur_span(), \"const_to_op: Unexpected ConstKind {:?}\", val)\n             }\n-            ty::ConstKind::Value(val_val) => val_val,\n-        };\n+            ty::ConstKind::Value(val_val) => self.const_val_to_op(val_val, val.ty, layout),\n+        }\n+    }\n+\n+    crate fn mir_const_to_op(\n+        &self,\n+        val: &mir::ConstantKind<'tcx>,\n+        layout: Option<TyAndLayout<'tcx>>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        match val {\n+            mir::ConstantKind::Ty(ct) => self.const_to_op(ct, layout),\n+            mir::ConstantKind::Val(val, ty) => self.const_val_to_op(*val, ty, None),\n+        }\n+    }\n+\n+    crate fn const_val_to_op(\n+        &self,\n+        val_val: ConstValue<'tcx>,\n+        ty: Ty<'tcx>,\n+        layout: Option<TyAndLayout<'tcx>>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         // Other cases need layout.\n-        let layout =\n-            from_known_layout(self.tcx, self.param_env, layout, || self.layout_of(val.ty))?;\n+        let tag_scalar = |scalar| -> InterpResult<'tcx, _> {\n+            Ok(match scalar {\n+                Scalar::Ptr(ptr) => Scalar::Ptr(self.global_base_pointer(ptr)?),\n+                Scalar::Int(int) => Scalar::Int(int),\n+            })\n+        };\n+        let layout = from_known_layout(self.tcx, self.param_env, layout, || self.layout_of(ty))?;\n         let op = match val_val {\n             ConstValue::ByRef { alloc, offset } => {\n                 let id = self.tcx.create_memory_alloc(alloc);"}, {"sha": "699b531f501885aa91ce5580b1c4f4fe43cf79cc", "filename": "compiler/rustc_mir/src/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -531,7 +531,7 @@ where\n         base.offset(from_offset, meta, layout, self)\n     }\n \n-    pub(super) fn mplace_downcast(\n+    pub(crate) fn mplace_downcast(\n         &self,\n         base: &MPlaceTy<'tcx, M::PointerTag>,\n         variant: VariantIdx,"}, {"sha": "194bc74c0fb1a8b28269074a87f750564c997534", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -63,6 +63,10 @@ pub fn provide(providers: &mut Providers) {\n         let (param_env, value) = param_env_and_value.into_parts();\n         const_eval::destructure_const(tcx, param_env, value)\n     };\n+    providers.const_to_valtree = |tcx, param_env_and_value| {\n+        let (param_env, raw) = param_env_and_value.into_parts();\n+        const_eval::const_to_valtree(tcx, param_env, raw)\n+    };\n     providers.deref_const = |tcx, param_env_and_value| {\n         let (param_env, value) = param_env_and_value.into_parts();\n         const_eval::deref_const(tcx, param_env, value)"}, {"sha": "911224d8c1f445be9440f326bc5833feb1455d1f", "filename": "compiler/rustc_mir/src/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -684,7 +684,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 for op in operands {\n                     match *op {\n                         mir::InlineAsmOperand::SymFn { ref value } => {\n-                            let fn_ty = self.monomorphize(value.literal.ty);\n+                            let fn_ty = self.monomorphize(value.literal.ty());\n                             visit_fn_use(self.tcx, fn_ty, false, source, &mut self.output);\n                         }\n                         mir::InlineAsmOperand::SymStatic { def_id } => {"}, {"sha": "796d024771d7f4bc0de6d7eb52f0bae03c800ac6", "filename": "compiler/rustc_mir/src/shim.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fshim.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -421,7 +421,7 @@ impl CloneShimBuilder<'tcx> {\n         let func = Operand::Constant(box Constant {\n             span: self.span,\n             user_ty: None,\n-            literal: ty::Const::zero_sized(tcx, func_ty),\n+            literal: ty::Const::zero_sized(tcx, func_ty).into(),\n         });\n \n         let ref_loc = self.make_place(\n@@ -478,7 +478,7 @@ impl CloneShimBuilder<'tcx> {\n         box Constant {\n             span: self.span,\n             user_ty: None,\n-            literal: ty::Const::from_usize(self.tcx, value),\n+            literal: ty::Const::from_usize(self.tcx, value).into(),\n         }\n     }\n \n@@ -509,7 +509,7 @@ impl CloneShimBuilder<'tcx> {\n                 Rvalue::Use(Operand::Constant(box Constant {\n                     span: self.span,\n                     user_ty: None,\n-                    literal: len,\n+                    literal: len.into(),\n                 })),\n             ))),\n         ];\n@@ -768,7 +768,7 @@ fn build_call_shim<'tcx>(\n                 Operand::Constant(box Constant {\n                     span,\n                     user_ty: None,\n-                    literal: ty::Const::zero_sized(tcx, ty),\n+                    literal: ty::Const::zero_sized(tcx, ty).into(),\n                 }),\n                 rcvr.into_iter().collect::<Vec<_>>(),\n             )"}, {"sha": "748f65cba2260b21f6de9ba07c6891aaee10138f", "filename": "compiler/rustc_mir/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -246,25 +246,27 @@ where\n     };\n \n     // Check the qualifs of the value of `const` items.\n-    if let ty::ConstKind::Unevaluated(def, _, promoted) = constant.literal.val {\n-        assert!(promoted.is_none());\n-        // Don't peek inside trait associated constants.\n-        if cx.tcx.trait_of_item(def.did).is_none() {\n-            let qualifs = if let Some((did, param_did)) = def.as_const_arg() {\n-                cx.tcx.at(constant.span).mir_const_qualif_const_arg((did, param_did))\n-            } else {\n-                cx.tcx.at(constant.span).mir_const_qualif(def.did)\n-            };\n-\n-            if !Q::in_qualifs(&qualifs) {\n-                return false;\n-            }\n+    if let Some(ct) = constant.literal.const_for_ty() {\n+        if let ty::ConstKind::Unevaluated(def, _, promoted) = ct.val {\n+            assert!(promoted.is_none());\n+            // Don't peek inside trait associated constants.\n+            if cx.tcx.trait_of_item(def.did).is_none() {\n+                let qualifs = if let Some((did, param_did)) = def.as_const_arg() {\n+                    cx.tcx.at(constant.span).mir_const_qualif_const_arg((did, param_did))\n+                } else {\n+                    cx.tcx.at(constant.span).mir_const_qualif(def.did)\n+                };\n+\n+                if !Q::in_qualifs(&qualifs) {\n+                    return false;\n+                }\n \n-            // Just in case the type is more specific than\n-            // the definition, e.g., impl associated const\n-            // with type parameters, take it into account.\n+                // Just in case the type is more specific than\n+                // the definition, e.g., impl associated const\n+                // with type parameters, take it into account.\n+            }\n         }\n     }\n     // Otherwise use the qualifs of the type.\n-    Q::in_any_value_of_ty(cx, constant.literal.ty)\n+    Q::in_any_value_of_ty(cx, constant.literal.ty())\n }"}, {"sha": "cc8669d9705468ce65cba883b911a330a9f6df35", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -13,9 +13,9 @@ use rustc_middle::mir::visit::{\n     MutVisitor, MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor,\n };\n use rustc_middle::mir::{\n-    AssertKind, BasicBlock, BinOp, Body, ClearCrossCrate, Constant, Local, LocalDecl, LocalKind,\n-    Location, Operand, Place, Rvalue, SourceInfo, SourceScope, SourceScopeData, Statement,\n-    StatementKind, Terminator, TerminatorKind, UnOp, RETURN_PLACE,\n+    AssertKind, BasicBlock, BinOp, Body, ClearCrossCrate, Constant, ConstantKind, Local, LocalDecl,\n+    LocalKind, Location, Operand, Place, Rvalue, SourceInfo, SourceScope, SourceScopeData,\n+    Statement, StatementKind, Terminator, TerminatorKind, UnOp, RETURN_PLACE,\n };\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutError, TyAndLayout};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n@@ -482,18 +482,21 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             return None;\n         }\n \n-        match self.ecx.const_to_op(c.literal, None) {\n+        match self.ecx.mir_const_to_op(&c.literal, None) {\n             Ok(op) => Some(op),\n             Err(error) => {\n                 let tcx = self.ecx.tcx.at(c.span);\n                 let err = ConstEvalErr::new(&self.ecx, error, Some(c.span));\n                 if let Some(lint_root) = self.lint_root(source_info) {\n-                    let lint_only = match c.literal.val {\n-                        // Promoteds must lint and not error as the user didn't ask for them\n-                        ConstKind::Unevaluated(_, _, Some(_)) => true,\n-                        // Out of backwards compatibility we cannot report hard errors in unused\n-                        // generic functions using associated constants of the generic parameters.\n-                        _ => c.literal.needs_subst(),\n+                    let lint_only = match c.literal {\n+                        ConstantKind::Ty(ct) => match ct.val {\n+                            // Promoteds must lint and not error as the user didn't ask for them\n+                            ConstKind::Unevaluated(_, _, Some(_)) => true,\n+                            // Out of backwards compatibility we cannot report hard errors in unused\n+                            // generic functions using associated constants of the generic parameters.\n+                            _ => c.literal.needs_subst(),\n+                        },\n+                        ConstantKind::Val(_, ty) => ty.needs_subst(),\n                     };\n                     if lint_only {\n                         // Out of backwards compatibility we cannot report hard errors in unused\n@@ -803,7 +806,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         Operand::Constant(Box::new(Constant {\n             span,\n             user_ty: None,\n-            literal: ty::Const::from_scalar(self.tcx, scalar, ty),\n+            literal: ty::Const::from_scalar(self.tcx, scalar, ty).into(),\n         }))\n     }\n \n@@ -814,9 +817,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         source_info: SourceInfo,\n     ) {\n         if let Rvalue::Use(Operand::Constant(c)) = rval {\n-            if !matches!(c.literal.val, ConstKind::Unevaluated(..)) {\n-                trace!(\"skipping replace of Rvalue::Use({:?} because it is already a const\", c);\n-                return;\n+            match c.literal {\n+                ConstantKind::Ty(c) if matches!(c.val, ConstKind::Unevaluated(..)) => {}\n+                _ => {\n+                    trace!(\"skipping replace of Rvalue::Use({:?} because it is already a const\", c);\n+                    return;\n+                }\n             }\n         }\n \n@@ -883,13 +889,17 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                                 *rval = Rvalue::Use(Operand::Constant(Box::new(Constant {\n                                     span: source_info.span,\n                                     user_ty: None,\n-                                    literal: self.ecx.tcx.mk_const(ty::Const {\n-                                        ty,\n-                                        val: ty::ConstKind::Value(ConstValue::ByRef {\n-                                            alloc,\n-                                            offset: Size::ZERO,\n-                                        }),\n-                                    }),\n+                                    literal: self\n+                                        .ecx\n+                                        .tcx\n+                                        .mk_const(ty::Const {\n+                                            ty,\n+                                            val: ty::ConstKind::Value(ConstValue::ByRef {\n+                                                alloc,\n+                                                offset: Size::ZERO,\n+                                            }),\n+                                        })\n+                                        .into(),\n                                 })));\n                             }\n                         }"}, {"sha": "c0fcfb620ff769f774de6d555c91786d7b548404", "filename": "compiler/rustc_mir/src/transform/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Felaborate_drops.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -471,7 +471,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         Rvalue::Use(Operand::Constant(Box::new(Constant {\n             span,\n             user_ty: None,\n-            literal: ty::Const::from_bool(self.tcx, val),\n+            literal: ty::Const::from_bool(self.tcx, val).into(),\n         })))\n     }\n "}, {"sha": "c85e9b9b932d4ad7c13b64b5380f46231f0900c9", "filename": "compiler/rustc_mir/src/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -989,7 +989,7 @@ fn insert_panic_block<'tcx>(\n         cond: Operand::Constant(box Constant {\n             span: body.span,\n             user_ty: None,\n-            literal: ty::Const::from_bool(tcx, false),\n+            literal: ty::Const::from_bool(tcx, false).into(),\n         }),\n         expected: true,\n         msg: message,"}, {"sha": "dd06daecd5dc2cfae9cd10c38f2b1fa85950a850", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -416,7 +416,7 @@ impl Inliner<'tcx> {\n \n                 TerminatorKind::Call { func: Operand::Constant(ref f), cleanup, .. } => {\n                     if let ty::FnDef(def_id, substs) =\n-                        *callsite.callee.subst_mir(self.tcx, &f.literal.ty).kind()\n+                        *callsite.callee.subst_mir(self.tcx, &f.literal.ty()).kind()\n                     {\n                         let substs = self.tcx.normalize_erasing_regions(self.param_env, substs);\n                         if let Ok(Some(instance)) =\n@@ -637,8 +637,11 @@ impl Inliner<'tcx> {\n                 // `required_consts`, here we may not only have `ConstKind::Unevaluated`\n                 // because we are calling `subst_and_normalize_erasing_regions`.\n                 caller_body.required_consts.extend(\n-                    callee_body.required_consts.iter().copied().filter(|&constant| {\n-                        matches!(constant.literal.val, ConstKind::Unevaluated(_, _, _))\n+                    callee_body.required_consts.iter().copied().filter(|&ct| {\n+                        match ct.literal.const_for_ty() {\n+                            Some(ct) => matches!(ct.val, ConstKind::Unevaluated(_, _, _)),\n+                            None => true,\n+                        }\n                     }),\n                 );\n             }"}, {"sha": "7aaf0224164c690a73868830376bb211da4cba04", "filename": "compiler/rustc_mir/src/transform/instcombine.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -79,7 +79,7 @@ impl<'tcx, 'a> InstCombineContext<'tcx, 'a> {\n \n     fn try_eval_bool(&self, a: &Operand<'_>) -> Option<bool> {\n         let a = a.constant()?;\n-        if a.literal.ty.is_bool() { a.literal.val.try_to_bool() } else { None }\n+        if a.literal.ty().is_bool() { a.literal.try_to_bool() } else { None }\n     }\n \n     /// Transform \"&(*a)\" ==> \"a\".\n@@ -110,12 +110,13 @@ impl<'tcx, 'a> InstCombineContext<'tcx, 'a> {\n     fn combine_len(&self, source_info: &SourceInfo, rvalue: &mut Rvalue<'tcx>) {\n         if let Rvalue::Len(ref place) = *rvalue {\n             let place_ty = place.ty(self.local_decls, self.tcx).ty;\n-            if let ty::Array(_, len) = place_ty.kind() {\n+            if let ty::Array(_, len) = *place_ty.kind() {\n                 if !self.should_combine(source_info, rvalue) {\n                     return;\n                 }\n \n-                let constant = Constant { span: source_info.span, literal: len, user_ty: None };\n+                let constant =\n+                    Constant { span: source_info.span, literal: len.into(), user_ty: None };\n                 *rvalue = Rvalue::Use(Operand::Constant(box constant));\n             }\n         }"}, {"sha": "e6ee474285ec1a862ade146a615813a46e45c4ab", "filename": "compiler/rustc_mir/src/transform/lower_intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Flower_intrinsics.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -33,7 +33,7 @@ impl<'tcx> MirPass<'tcx> for LowerIntrinsics {\n                                     Rvalue::Use(Operand::Constant(box Constant {\n                                         span: terminator.source_info.span,\n                                         user_ty: None,\n-                                        literal: ty::Const::zero_sized(tcx, tcx.types.unit),\n+                                        literal: ty::Const::zero_sized(tcx, tcx.types.unit).into(),\n                                     })),\n                                 )),\n                             });"}, {"sha": "d04a7011ab0647ad96a2f38c220b04639a0f47e0", "filename": "compiler/rustc_mir/src/transform/match_branches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -93,8 +93,8 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n                         StatementKind::Assign(box (lhs_f, Rvalue::Use(Operand::Constant(f_c)))),\n                         StatementKind::Assign(box (lhs_s, Rvalue::Use(Operand::Constant(s_c)))),\n                     ) if lhs_f == lhs_s\n-                        && f_c.literal.ty.is_bool()\n-                        && s_c.literal.ty.is_bool()\n+                        && f_c.literal.ty().is_bool()\n+                        && s_c.literal.ty().is_bool()\n                         && f_c.literal.try_eval_bool(tcx, param_env).is_some()\n                         && s_c.literal.try_eval_bool(tcx, param_env).is_some() => {}\n "}, {"sha": "7db790cf32b63bd3aea0a3d941f4415c4a91a3ed", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -921,7 +921,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         let unit = Rvalue::Use(Operand::Constant(box Constant {\n                             span: statement.source_info.span,\n                             user_ty: None,\n-                            literal: ty::Const::zero_sized(self.tcx, self.tcx.types.unit),\n+                            literal: ty::Const::zero_sized(self.tcx, self.tcx.types.unit).into(),\n                         }));\n                         mem::replace(rhs, unit)\n                     },\n@@ -998,20 +998,22 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 Operand::Constant(Box::new(Constant {\n                     span,\n                     user_ty: None,\n-                    literal: tcx.mk_const(ty::Const {\n-                        ty,\n-                        val: ty::ConstKind::Unevaluated(\n-                            def,\n-                            InternalSubsts::for_item(tcx, def.did, |param, _| {\n-                                if let ty::GenericParamDefKind::Lifetime = param.kind {\n-                                    tcx.lifetimes.re_erased.into()\n-                                } else {\n-                                    tcx.mk_param_from_def(param)\n-                                }\n-                            }),\n-                            Some(promoted_id),\n-                        ),\n-                    }),\n+                    literal: tcx\n+                        .mk_const(ty::Const {\n+                            ty,\n+                            val: ty::ConstKind::Unevaluated(\n+                                def,\n+                                InternalSubsts::for_item(tcx, def.did, |param, _| {\n+                                    if let ty::GenericParamDefKind::Lifetime = param.kind {\n+                                        tcx.lifetimes.re_erased.into()\n+                                    } else {\n+                                        tcx.mk_param_from_def(param)\n+                                    }\n+                                }),\n+                                Some(promoted_id),\n+                            ),\n+                        })\n+                        .into(),\n                 }))\n             };\n             let (blocks, local_decls) = self.source.basic_blocks_and_local_decls_mut();\n@@ -1250,8 +1252,8 @@ crate fn is_const_fn_in_array_repeat_expression<'tcx>(\n         if let Some(Terminator { kind: TerminatorKind::Call { func, destination, .. }, .. }) =\n             &block.terminator\n         {\n-            if let Operand::Constant(box Constant { literal: ty::Const { ty, .. }, .. }) = func {\n-                if let ty::FnDef(def_id, _) = *ty.kind() {\n+            if let Operand::Constant(box Constant { literal, .. }) = func {\n+                if let ty::FnDef(def_id, _) = *literal.ty().kind() {\n                     if let Some((destination_place, _)) = destination {\n                         if destination_place == place {\n                             if is_const_fn(ccx.tcx, def_id) {"}, {"sha": "2b518bd3a4813ca69680f590bbf75abd53ea7f81", "filename": "compiler/rustc_mir/src/transform/required_consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frequired_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frequired_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frequired_consts.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -14,10 +14,10 @@ impl<'a, 'tcx> RequiredConstsVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for RequiredConstsVisitor<'a, 'tcx> {\n     fn visit_constant(&mut self, constant: &Constant<'tcx>, _: Location) {\n-        let const_kind = constant.literal.val;\n-\n-        if let ConstKind::Unevaluated(_, _, _) = const_kind {\n-            self.required_consts.push(*constant);\n+        if let Some(ct) = constant.literal.const_for_ty() {\n+            if let ConstKind::Unevaluated(_, _, _) = ct.val {\n+                self.required_consts.push(*constant);\n+            }\n         }\n     }\n }"}, {"sha": "a6b8f20f6d4498f13eb26e271f29a196d4b9ea84", "filename": "compiler/rustc_mir/src/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -205,7 +205,7 @@ impl PeekCall {\n         if let mir::TerminatorKind::Call { func: Operand::Constant(func), args, .. } =\n             &terminator.kind\n         {\n-            if let ty::FnDef(def_id, substs) = *func.literal.ty.kind() {\n+            if let ty::FnDef(def_id, substs) = *func.literal.ty().kind() {\n                 let sig = tcx.fn_sig(def_id);\n                 let name = tcx.item_name(def_id);\n                 if sig.abi() != Abi::RustIntrinsic || name != sym::rustc_peek {"}, {"sha": "9f473f3bae534df547064fbcb224edd2653250c3", "filename": "compiler/rustc_mir/src/transform/simplify_comparison_integral.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -205,12 +205,12 @@ fn find_branch_value_info<'tcx>(\n     match (left, right) {\n         (Constant(branch_value), Copy(to_switch_on) | Move(to_switch_on))\n         | (Copy(to_switch_on) | Move(to_switch_on), Constant(branch_value)) => {\n-            let branch_value_ty = branch_value.literal.ty;\n+            let branch_value_ty = branch_value.literal.ty();\n             // we only want to apply this optimization if we are matching on integrals (and chars), as it is not possible to switch on floats\n             if !branch_value_ty.is_integral() && !branch_value_ty.is_char() {\n                 return None;\n             };\n-            let branch_value_scalar = branch_value.literal.val.try_to_scalar()?;\n+            let branch_value_scalar = branch_value.literal.try_to_scalar()?;\n             Some((branch_value_scalar, branch_value_ty, *to_switch_on))\n         }\n         _ => None,"}, {"sha": "e9190d7ebef8b6238271fbe8d8f1ef1d84b32d39", "filename": "compiler/rustc_mir/src/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Felaborate_drops.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -1035,7 +1035,7 @@ where\n         Operand::Constant(box Constant {\n             span: self.source_info.span,\n             user_ty: None,\n-            literal: ty::Const::from_usize(self.tcx(), val.into()),\n+            literal: ty::Const::from_usize(self.tcx(), val.into()).into(),\n         })\n     }\n "}, {"sha": "ddda98d16162312d55c0f83f13bb65bc24bcf916", "filename": "compiler/rustc_mir/src/util/find_self_call.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Futil%2Ffind_self_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Futil%2Ffind_self_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Ffind_self_call.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -17,8 +17,8 @@ pub fn find_self_call<'tcx>(\n         &body[block].terminator\n     {\n         debug!(\"find_self_call: func={:?}\", func);\n-        if let Operand::Constant(box Constant { literal: ty::Const { ty, .. }, .. }) = func {\n-            if let ty::FnDef(def_id, substs) = *ty.kind() {\n+        if let Operand::Constant(box Constant { literal, .. }) = func {\n+            if let ty::FnDef(def_id, substs) = *literal.ty().kind() {\n                 if let Some(ty::AssocItem { fn_has_self_parameter: true, .. }) =\n                     tcx.opt_associated_item(def_id)\n                 {"}, {"sha": "1bf010ffca7529683933ce3c7337d884e830083b", "filename": "compiler/rustc_mir/src/util/pretty.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -439,7 +439,7 @@ impl Visitor<'tcx> for ExtraComments<'tcx> {\n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         self.super_constant(constant, location);\n         let Constant { span, user_ty, literal } = constant;\n-        match literal.ty.kind() {\n+        match literal.ty().kind() {\n             ty::Int(_) | ty::Uint(_) | ty::Bool | ty::Char => {}\n             // Unit type\n             ty::Tuple(tys) if tys.is_empty() => {}\n@@ -449,7 +449,12 @@ impl Visitor<'tcx> for ExtraComments<'tcx> {\n                 if let Some(user_ty) = user_ty {\n                     self.push(&format!(\"+ user_ty: {:?}\", user_ty));\n                 }\n-                self.push(&format!(\"+ literal: {:?}\", literal));\n+                match literal {\n+                    ConstantKind::Ty(literal) => self.push(&format!(\"+ literal: {:?}\", literal)),\n+                    ConstantKind::Val(val, ty) => {\n+                        self.push(&format!(\"+ literal: {:?}, {}\", val, ty))\n+                    }\n+                }\n             }\n         }\n     }"}, {"sha": "e562e52f8410fe59f366f26a4bc81732cc2662ba", "filename": "compiler/rustc_mir_build/src/build/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcfg.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -68,7 +68,7 @@ impl<'tcx> CFG<'tcx> {\n             Rvalue::Use(Operand::Constant(box Constant {\n                 span: source_info.span,\n                 user_ty: None,\n-                literal: ty::Const::zero_sized(tcx, tcx.types.unit),\n+                literal: ty::Const::zero_sized(tcx, tcx.types.unit).into(),\n             })),\n         );\n     }"}, {"sha": "57f56e2d09227c515679211d424c4e68615907a1", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -11,7 +11,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn as_constant(&mut self, expr: &Expr<'_, 'tcx>) -> Constant<'tcx> {\n         let this = self;\n         let Expr { ty, temp_lifetime: _, span, ref kind } = *expr;\n-        match kind {\n+        match *kind {\n             ExprKind::Scope { region_scope: _, lint_level: _, value } => this.as_constant(value),\n             ExprKind::Literal { literal, user_ty, const_id: _ } => {\n                 let user_ty = user_ty.map(|user_ty| {\n@@ -22,11 +22,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     })\n                 });\n                 assert_eq!(literal.ty, ty);\n-                Constant { span, user_ty, literal }\n+                Constant { span, user_ty, literal: literal.into() }\n+            }\n+            ExprKind::StaticRef { literal, .. } => {\n+                Constant { span, user_ty: None, literal: literal.into() }\n             }\n-            ExprKind::StaticRef { literal, .. } => Constant { span, user_ty: None, literal },\n             ExprKind::ConstBlock { value } => {\n-                Constant { span: span, user_ty: None, literal: value }\n+                Constant { span: span, user_ty: None, literal: value.into() }\n             }\n             _ => span_bug!(span, \"expression is not a valid constant {:?}\", kind),\n         }"}, {"sha": "7f24a41b00bbeaf95852d728ab2078110bef71ff", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -255,7 +255,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block.and(Rvalue::Use(Operand::Constant(box Constant {\n                     span: expr_span,\n                     user_ty: None,\n-                    literal: ty::Const::zero_sized(this.tcx, this.tcx.types.unit),\n+                    literal: ty::Const::zero_sized(this.tcx, this.tcx.types.unit).into(),\n                 })))\n             }\n             ExprKind::Yield { .. }"}, {"sha": "fc92e8019c26e1c81270b40434979f420b1fbbf3", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -146,7 +146,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     Constant {\n                         span: expr_span,\n                         user_ty: None,\n-                        literal: ty::Const::from_bool(this.tcx, true),\n+                        literal: ty::Const::from_bool(this.tcx, true).into(),\n                     },\n                 );\n \n@@ -157,7 +157,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     Constant {\n                         span: expr_span,\n                         user_ty: None,\n-                        literal: ty::Const::from_bool(this.tcx, false),\n+                        literal: ty::Const::from_bool(this.tcx, false).into(),\n                     },\n                 );\n "}, {"sha": "b082169cd63c17d4444bce358e482f2c431161dc", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -438,7 +438,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     // Need to experiment.\n                     user_ty: None,\n \n-                    literal: method,\n+                    literal: method.into(),\n                 }),\n                 args: vec![val, expect],\n                 destination: Some((eq_result, eq_block)),"}, {"sha": "a1126d1c3d529a93270d9116274160f1960ccba4", "filename": "compiler/rustc_mir_build/src/build/misc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -30,6 +30,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         span: Span,\n         literal: &'tcx ty::Const<'tcx>,\n     ) -> Operand<'tcx> {\n+        let literal = literal.into();\n         let constant = box Constant { span, user_ty: None, literal };\n         Operand::Constant(constant)\n     }\n@@ -57,7 +58,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             Constant {\n                 span: source_info.span,\n                 user_ty: None,\n-                literal: ty::Const::from_usize(self.tcx, value),\n+                literal: ty::Const::from_usize(self.tcx, value).into(),\n             },\n         );\n         temp"}, {"sha": "c0433604f8c6801176a9dba6aacaa3051d344806", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -68,11 +68,11 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                 // FIXME(#31407) this is only necessary because float parsing is buggy\n                 self.tcx.sess.span_err(sp, \"could not evaluate float literal (see issue #31407)\");\n                 // create a dummy value and continue compiling\n-                Const::from_bits(self.tcx, 0, self.param_env.and(ty))\n+                self.tcx.const_error(ty)\n             }\n             Err(LitToConstError::Reported) => {\n                 // create a dummy value and continue compiling\n-                Const::from_bits(self.tcx, 0, self.param_env.and(ty))\n+                self.tcx.const_error(ty)\n             }\n             Err(LitToConstError::TypeError) => bug!(\"const_eval_literal: had type error\"),\n         }"}, {"sha": "e467f41986332a5472836dd82bb8b2f23be8b770", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -228,6 +228,15 @@ impl<'tcx> Key for (&'tcx ty::Const<'tcx>, mir::Field) {\n     }\n }\n \n+impl<'tcx> Key for mir::interpret::ConstAlloc<'tcx> {\n+    fn query_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n impl<'tcx> Key for ty::PolyTraitRef<'tcx> {\n     fn query_crate(&self) -> CrateNum {\n         self.def_id().krate"}, {"sha": "670527fb3f08f1a7dfc0563bd18e757b5f3c7b8e", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e655fb62216b6ba64a094b30f116d7988d19322d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=e655fb62216b6ba64a094b30f116d7988d19322d", "patch": "@@ -377,7 +377,10 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 let local = self.place_to_local(span, p)?;\n                 Ok(self.locals[local])\n             }\n-            mir::Operand::Constant(ct) => Ok(self.add_node(Node::Leaf(ct.literal), span)),\n+            mir::Operand::Constant(ct) => match ct.literal {\n+                mir::ConstantKind::Ty(ct) => Ok(self.add_node(Node::Leaf(ct), span)),\n+                mir::ConstantKind::Val(..) => self.error(Some(span), \"unsupported constant\")?,\n+            },\n         }\n     }\n "}]}