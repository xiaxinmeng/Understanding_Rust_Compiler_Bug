{"sha": "6a8b3ae22fbf514d6dc920abebe478e95c38e3ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhOGIzYWUyMmZiZjUxNGQ2ZGM5MjBhYmViZTQ3OGU5NWMzOGUzYWQ=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-06T12:02:28Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-08T02:53:21Z"}, "message": "Implement `#[deriving(Show)]`.", "tree": {"sha": "3a058241d354b208d78d2f0227a4148f02769509", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a058241d354b208d78d2f0227a4148f02769509"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a8b3ae22fbf514d6dc920abebe478e95c38e3ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a8b3ae22fbf514d6dc920abebe478e95c38e3ad", "html_url": "https://github.com/rust-lang/rust/commit/6a8b3ae22fbf514d6dc920abebe478e95c38e3ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a8b3ae22fbf514d6dc920abebe478e95c38e3ad/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d63910f90afcb601a765bba6bd4bb8d52ebef81", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d63910f90afcb601a765bba6bd4bb8d52ebef81", "html_url": "https://github.com/rust-lang/rust/commit/5d63910f90afcb601a765bba6bd4bb8d52ebef81"}], "stats": {"total": 182, "additions": 182, "deletions": 0}, "files": [{"sha": "01e31fc5724d20b1200353c200a1c8ff322f5f66", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a8b3ae22fbf514d6dc920abebe478e95c38e3ad/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8b3ae22fbf514d6dc920abebe478e95c38e3ad/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=6a8b3ae22fbf514d6dc920abebe478e95c38e3ad", "patch": "@@ -28,6 +28,7 @@ pub mod encodable;\n pub mod decodable;\n pub mod rand;\n pub mod to_str;\n+pub mod show;\n pub mod zero;\n pub mod default;\n pub mod primitive;\n@@ -83,6 +84,7 @@ pub fn expand_meta_deriving(cx: &mut ExtCtxt,\n                             \"Rand\" => expand!(rand::expand_deriving_rand),\n \n                             \"ToStr\" => expand!(to_str::expand_deriving_to_str),\n+                            \"Show\" => expand!(show::expand_deriving_show),\n \n                             \"Zero\" => expand!(zero::expand_deriving_zero),\n                             \"Default\" => expand!(default::expand_deriving_default),"}, {"sha": "67cfd151f6293e07d293137873dfb334d507a1d7", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/6a8b3ae22fbf514d6dc920abebe478e95c38e3ad/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8b3ae22fbf514d6dc920abebe478e95c38e3ad/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=6a8b3ae22fbf514d6dc920abebe478e95c38e3ad", "patch": "@@ -0,0 +1,138 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ast;\n+use ast::{MetaItem, Item, Expr};\n+use codemap::Span;\n+use ext::format;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n+use ext::deriving::generic::*;\n+\n+use parse::token;\n+\n+use std::hashmap::HashMap;\n+\n+pub fn expand_deriving_show(cx: &mut ExtCtxt,\n+                            span: Span,\n+                            mitem: @MetaItem,\n+                            in_items: ~[@Item])\n+    -> ~[@Item] {\n+    // &mut ::std::fmt::Formatter\n+    let fmtr = Ptr(~Literal(Path::new(~[\"std\", \"fmt\", \"Formatter\"])),\n+                   Borrowed(None, ast::MutMutable));\n+\n+    let trait_def = TraitDef {\n+        cx: cx, span: span,\n+\n+        path: Path::new(~[\"std\", \"fmt\", \"Show\"]),\n+        additional_bounds: ~[],\n+        generics: LifetimeBounds::empty(),\n+        methods: ~[\n+            MethodDef {\n+                name: \"fmt\",\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: borrowed_explicit_self(),\n+                args: ~[fmtr],\n+                ret_ty: Literal(Path::new(~[\"std\", \"fmt\", \"Result\"])),\n+                inline: false,\n+                const_nonmatching: false,\n+                combine_substructure: show_substructure\n+            }\n+        ]\n+    };\n+    trait_def.expand(mitem, in_items)\n+}\n+\n+// we construct a format string and then defer to std::fmt, since that\n+// knows what's up with formatting at so on.\n+fn show_substructure(cx: &mut ExtCtxt, span: Span,\n+                     substr: &Substructure) -> @Expr {\n+    // build `<name>`, `<name>({}, {}, ...)` or `<name> { <field>: {},\n+    // <field>: {}, ... }` based on the \"shape\".\n+    //\n+    // Easy start: they all start with the name.\n+    let name = match *substr.fields {\n+        Struct(_) => substr.type_ident,\n+        EnumMatching(_, v, _) => v.node.name,\n+\n+        EnumNonMatching(..) | StaticStruct(..) | StaticEnum(..) => {\n+            cx.span_bug(span, \"nonsensical .fields in `#[deriving(Show)]`\")\n+        }\n+    };\n+\n+    let mut format_string = token::get_ident(name.name).get().to_owned();\n+    // the internal fields we're actually formatting\n+    let mut exprs = ~[];\n+\n+    // Getting harder... making the format string:\n+    match *substr.fields {\n+        // unit struct/nullary variant: no work necessary!\n+        Struct([]) | EnumMatching(_, _, []) => {}\n+\n+        Struct(ref fields) | EnumMatching(_, _, ref fields) => {\n+            if fields[0].name.is_none() {\n+                // tuple struct/\"normal\" variant\n+\n+                format_string.push_str(\"(\");\n+\n+                for (i, field) in fields.iter().enumerate() {\n+                    if i != 0 { format_string.push_str(\", \"); }\n+\n+                    format_string.push_str(\"{}\");\n+\n+                    exprs.push(field.self_);\n+                }\n+\n+                format_string.push_str(\")\");\n+            } else {\n+                // normal struct/struct variant\n+\n+                format_string.push_str(\" \\\\{\");\n+\n+                for (i, field) in fields.iter().enumerate() {\n+                    if i != 0 { format_string.push_str(\",\"); }\n+\n+                    let name = token::get_ident(field.name.unwrap().name);\n+                    format_string.push_str(\" \");\n+                    format_string.push_str(name.get());\n+                    format_string.push_str(\": {}\");\n+\n+                    exprs.push(field.self_);\n+                }\n+\n+                format_string.push_str(\" \\\\}\");\n+            }\n+        }\n+        _ => unreachable!()\n+    }\n+\n+    // AST construction!\n+    // we're basically calling\n+    //\n+    // format_arg!(|__args| ::std::fmt::write(fmt.buf, __args), \"<format_string>\", exprs...)\n+    //\n+    // but doing it directly via ext::format.\n+    let formatter = substr.nonself_args[0];\n+    let buf = cx.expr_field_access(span, formatter, cx.ident_of(\"buf\"));\n+\n+    let std_write = ~[cx.ident_of(\"std\"), cx.ident_of(\"fmt\"), cx.ident_of(\"write\")];\n+    let args = cx.ident_of(\"__args\");\n+    let write_call = cx.expr_call_global(span, std_write, ~[buf, cx.expr_ident(span, args)]);\n+    let format_closure = cx.lambda_expr(span, ~[args], write_call);\n+\n+    let s = token::intern_and_get_ident(format_string);\n+    let format_string = cx.expr_str(span, s);\n+\n+    // phew, not our responsibility any more!\n+    format::expand_preparsed_format_args(cx, span,\n+                                         format_closure,\n+                                         format_string, exprs, HashMap::new())\n+}"}, {"sha": "40965615506c79d0d9d3a1326eef0b58fd0aa240", "filename": "src/test/run-pass/deriving-show.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6a8b3ae22fbf514d6dc920abebe478e95c38e3ad/src%2Ftest%2Frun-pass%2Fderiving-show.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8b3ae22fbf514d6dc920abebe478e95c38e3ad/src%2Ftest%2Frun-pass%2Fderiving-show.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-show.rs?ref=6a8b3ae22fbf514d6dc920abebe478e95c38e3ad", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(struct_variant, macro_rules)];\n+\n+#[deriving(Show)]\n+struct Unit;\n+\n+#[deriving(Show)]\n+struct Tuple(int, uint);\n+\n+#[deriving(Show)]\n+struct Struct { x: int, y: uint }\n+\n+#[deriving(Show)]\n+enum Enum {\n+    Nullary,\n+    Variant(int, uint),\n+    StructVariant { x: int, y : uint }\n+}\n+\n+macro_rules! t {\n+    ($x:expr, $expected:expr) => {\n+        assert_eq!(format!(\"{}\", $x), $expected.to_owned())\n+    }\n+}\n+\n+pub fn main() {\n+    t!(Unit, \"Unit\");\n+    t!(Tuple(1, 2), \"Tuple(1, 2)\");\n+    t!(Struct { x: 1, y: 2 }, \"Struct { x: 1, y: 2 }\");\n+    t!(Nullary, \"Nullary\");\n+    t!(Variant(1, 2), \"Variant(1, 2)\");\n+    t!(StructVariant { x: 1, y: 2 }, \"StructVariant { x: 1, y: 2 }\");\n+}"}]}