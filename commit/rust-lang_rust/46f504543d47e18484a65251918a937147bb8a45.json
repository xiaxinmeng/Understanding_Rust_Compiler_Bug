{"sha": "46f504543d47e18484a65251918a937147bb8a45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2ZjUwNDU0M2Q0N2UxODQ4NGE2NTI1MTkxOGE5MzcxNDdiYjhhNDU=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-10-26T10:24:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-10-26T10:24:59Z"}, "message": "Rollup merge of #55258 - Aaron1011:fix/rustdoc-blanket, r=GuillaumeGomez\n\nFix Rustdoc ICE when checking blanket impls\n\nFixes #55001, #54744\n\nPreviously, SelectionContext would unconditionally cache the selection\nresult for an obligation. This worked fine for most users of\nSelectionContext, but it caused an issue when used by Rustdoc's blanket\nimpl finder.\n\nThe issue occured when SelectionContext chose a ParamCandidate which\ncontained inference variables. Since inference variables can change\nbetween calls to select(), it's not safe to cache the selection result -\nthe chosen candidate might not be applicable for future results, leading\nto an ICE when we try to run confirmation.\n\nThis commit prevents SelectionContext from caching any ParamCandidate\nthat contains inference variables. This should always be completely\nsafe, as trait selection should never depend on a particular result\nbeing cached.\n\nI've also added some extra debug!() statements, which I found helpful in\ntracking down this bug.", "tree": {"sha": "98a73c2cd1ecea9180a658ec02b08993c3889e41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98a73c2cd1ecea9180a658ec02b08993c3889e41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46f504543d47e18484a65251918a937147bb8a45", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb0ut8CRBK7hj4Ov3rIwAAdHIIAHjzCAjUIbwHrrTJRHXIIfQx\nKs0DjIfuPj3w9YZZzoyWJALnXHuqmzw/cOTWGb1cn2alN8wYRxrKgC3GyxwyrauV\nwi/Dodunf1/G0uVw8mv+xiFgcksLm6MTZq5mM958c1bJMxx2RJYXI2CDNhKXTiVu\nAzdjZLfa/m1uhH3IdgERypt2gn0s/4/YbV0T8i1gOqIDqYXW2OhxzFBpJT3ab5Fx\nxfmj7CjsR33JVZQRU7122zYiY4wJiQRXi9+oZypG9MxLmW8X/09yh79ConNg5Edi\nHJEOjgaZmrIQt0p0mQT/rzxKmDB2kNIAHbm3f85k1R2GvklHPqGJjSDDZd88ljo=\n=HNQk\n-----END PGP SIGNATURE-----\n", "payload": "tree 98a73c2cd1ecea9180a658ec02b08993c3889e41\nparent d83376c70511b2fc12506bb22c3bb02353e028d1\nparent 4f2624cac90ee9145175d6e4b9c59b9ab7875a9c\nauthor kennytm <kennytm@gmail.com> 1540549499 +0800\ncommitter GitHub <noreply@github.com> 1540549499 +0800\n\nRollup merge of #55258 - Aaron1011:fix/rustdoc-blanket, r=GuillaumeGomez\n\nFix Rustdoc ICE when checking blanket impls\n\nFixes #55001, #54744\n\nPreviously, SelectionContext would unconditionally cache the selection\nresult for an obligation. This worked fine for most users of\nSelectionContext, but it caused an issue when used by Rustdoc's blanket\nimpl finder.\n\nThe issue occured when SelectionContext chose a ParamCandidate which\ncontained inference variables. Since inference variables can change\nbetween calls to select(), it's not safe to cache the selection result -\nthe chosen candidate might not be applicable for future results, leading\nto an ICE when we try to run confirmation.\n\nThis commit prevents SelectionContext from caching any ParamCandidate\nthat contains inference variables. This should always be completely\nsafe, as trait selection should never depend on a particular result\nbeing cached.\n\nI've also added some extra debug!() statements, which I found helpful in\ntracking down this bug.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46f504543d47e18484a65251918a937147bb8a45", "html_url": "https://github.com/rust-lang/rust/commit/46f504543d47e18484a65251918a937147bb8a45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46f504543d47e18484a65251918a937147bb8a45/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d83376c70511b2fc12506bb22c3bb02353e028d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d83376c70511b2fc12506bb22c3bb02353e028d1", "html_url": "https://github.com/rust-lang/rust/commit/d83376c70511b2fc12506bb22c3bb02353e028d1"}, {"sha": "4f2624cac90ee9145175d6e4b9c59b9ab7875a9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f2624cac90ee9145175d6e4b9c59b9ab7875a9c", "html_url": "https://github.com/rust-lang/rust/commit/4f2624cac90ee9145175d6e4b9c59b9ab7875a9c"}], "stats": {"total": 90, "additions": 87, "deletions": 3}, "files": [{"sha": "0ee03bc4c6e00902d0026a78e23b8be1c63a0a5d", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46f504543d47e18484a65251918a937147bb8a45/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f504543d47e18484a65251918a937147bb8a45/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=46f504543d47e18484a65251918a937147bb8a45", "patch": "@@ -251,6 +251,7 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n                   dir: RelationDir)\n                   -> RelateResult<'tcx, Generalization<'tcx>>\n     {\n+        debug!(\"generalize(ty={:?}, for_vid={:?}, dir={:?}\", ty, for_vid, dir);\n         // Determine the ambient variance within which `ty` appears.\n         // The surrounding equation is:\n         //\n@@ -273,8 +274,15 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n             root_ty: ty,\n         };\n \n-        let ty = generalize.relate(&ty, &ty)?;\n+        let ty = match generalize.relate(&ty, &ty) {\n+            Ok(ty) => ty,\n+            Err(e) => {\n+                debug!(\"generalize: failure {:?}\", e);\n+                return Err(e);\n+            }\n+        };\n         let needs_wf = generalize.needs_wf;\n+        debug!(\"generalize: success {{ {:?}, {:?} }}\", ty, needs_wf);\n         Ok(Generalization { ty, needs_wf })\n     }\n }"}, {"sha": "c7b5ddb83410f6c969a0c088aad262c6d7d6ad3e", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46f504543d47e18484a65251918a937147bb8a45/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f504543d47e18484a65251918a937147bb8a45/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=46f504543d47e18484a65251918a937147bb8a45", "patch": "@@ -74,6 +74,9 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         let infcx = self.fields.infcx;\n         let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n         let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n+\n+        debug!(\"{}.tys: replacements ({:?}, {:?})\", self.tag(), a, b);\n+\n         match (&a.sty, &b.sty) {\n             (&ty::Infer(TyVar(a_id)), &ty::Infer(TyVar(b_id))) => {\n                 infcx.type_variables.borrow_mut().equate(a_id, b_id);"}, {"sha": "2ea16823cc65dadd3ef12f06860045dc75d73c9a", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/46f504543d47e18484a65251918a937147bb8a45/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f504543d47e18484a65251918a937147bb8a45/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=46f504543d47e18484a65251918a937147bb8a45", "patch": "@@ -1522,6 +1522,33 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             .map(|v| v.get(tcx))\n     }\n \n+    /// Determines whether can we safely cache the result\n+    /// of selecting an obligation. This is almost always 'true',\n+    /// except when dealing with certain ParamCandidates.\n+    ///\n+    /// Ordinarily, a ParamCandidate will contain no inference variables,\n+    /// since it was usually produced directly from a DefId. However,\n+    /// certain cases (currently only librustdoc's blanket impl finder),\n+    /// a ParamEnv may be explicitly constructed with inference types.\n+    /// When this is the case, we do *not* want to cache the resulting selection\n+    /// candidate. This is due to the fact that it might not always be possible\n+    /// to equate the obligation's trait ref and the candidate's trait ref,\n+    /// if more constraints end up getting added to an inference variable.\n+    ///\n+    /// Because of this, we always want to re-run the full selection\n+    /// process for our obligation the next time we see it, since\n+    /// we might end up picking a different SelectionCandidate (or none at all)\n+    fn can_cache_candidate(&self,\n+        result: &SelectionResult<'tcx, SelectionCandidate<'tcx>>\n+     ) -> bool {\n+        match result {\n+            Ok(Some(SelectionCandidate::ParamCandidate(trait_ref))) => {\n+                !trait_ref.skip_binder().input_types().any(|t| t.walk().any(|t_| t_.is_ty_infer()))\n+            },\n+            _ => true\n+        }\n+    }\n+\n     fn insert_candidate_cache(\n         &mut self,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -1531,6 +1558,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     ) {\n         let tcx = self.tcx();\n         let trait_ref = cache_fresh_trait_pred.skip_binder().trait_ref;\n+\n+        if !self.can_cache_candidate(&candidate) {\n+            debug!(\"insert_candidate_cache(trait_ref={:?}, candidate={:?} -\\\n+                    candidate is not cacheable\", trait_ref, candidate);\n+            return;\n+\n+        }\n+\n         if self.can_use_global_caches(param_env) {\n             if let Err(Overflow) = candidate {\n                 // Don't cache overflow globally; we only produce this"}, {"sha": "57c7e2afd625e02c99cdfa530338327599c7f4e3", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/46f504543d47e18484a65251918a937147bb8a45/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f504543d47e18484a65251918a937147bb8a45/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=46f504543d47e18484a65251918a937147bb8a45", "patch": "@@ -50,6 +50,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> BlanketImplFinder <'a, 'tcx, 'rcx, 'cstore> {\n         name: Option<String>,\n     ) -> Vec<Item>\n     where F: Fn(DefId) -> Def {\n+        debug!(\"get_blanket_impls(def_id={:?}, ...)\", def_id);\n         let mut impls = Vec::new();\n         if self.cx\n             .tcx\n@@ -78,6 +79,8 @@ impl<'a, 'tcx, 'rcx, 'cstore> BlanketImplFinder <'a, 'tcx, 'rcx, 'cstore> {\n             }\n             self.cx.tcx.for_each_relevant_impl(trait_def_id, ty, |impl_def_id| {\n                 self.cx.tcx.infer_ctxt().enter(|infcx| {\n+                    debug!(\"get_blanet_impls: Considering impl for trait '{:?}' {:?}\",\n+                           trait_def_id, impl_def_id);\n                     let t_generics = infcx.tcx.generics_of(impl_def_id);\n                     let trait_ref = infcx.tcx.impl_trait_ref(impl_def_id)\n                                              .expect(\"Cannot get impl trait\");\n@@ -104,8 +107,8 @@ impl<'a, 'tcx, 'rcx, 'cstore> BlanketImplFinder <'a, 'tcx, 'rcx, 'cstore> {\n                         drop(obligations);\n \n                         debug!(\n-                            \"invoking predicate_may_hold: {:?}\",\n-                            trait_ref,\n+                            \"invoking predicate_may_hold: param_env={:?}, trait_ref={:?}, ty={:?}\",\n+                             param_env, trait_ref, ty\n                         );\n                         let may_apply = match infcx.evaluate_obligation(\n                             &traits::Obligation::new(\n@@ -117,6 +120,10 @@ impl<'a, 'tcx, 'rcx, 'cstore> BlanketImplFinder <'a, 'tcx, 'rcx, 'cstore> {\n                             Ok(eval_result) => eval_result.may_apply(),\n                             Err(traits::OverflowError) => true, // overflow doesn't mean yes *or* no\n                         };\n+                        debug!(\"get_blanket_impls: found applicable impl: {}\\\n+                               for trait_ref={:?}, ty={:?}\",\n+                               may_apply, trait_ref, ty);\n+\n                         if !may_apply {\n                             return\n                         }"}, {"sha": "f6c7f9a3d082c674d09b20d0b1ea54c824565981", "filename": "src/test/rustdoc/issue-55001.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/46f504543d47e18484a65251918a937147bb8a45/src%2Ftest%2Frustdoc%2Fissue-55001.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f504543d47e18484a65251918a937147bb8a45/src%2Ftest%2Frustdoc%2Fissue-55001.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-55001.rs?ref=46f504543d47e18484a65251918a937147bb8a45", "patch": "@@ -0,0 +1,31 @@\n+// Regression test for issue #55001. Previously, we would incorrectly\n+// cache certain trait selection results when checking for blanket impls,\n+// resulting in an ICE when we tried to confirm the cached ParamCandidate\n+// against an obligation.\n+\n+pub struct DefaultAllocator;\n+pub struct Standard;\n+pub struct Inner;\n+\n+pub trait Rand {}\n+\n+pub trait Distribution<T> {}\n+pub trait Allocator<N> {}\n+\n+impl<T> Rand for T where Standard: Distribution<T> {}\n+\n+impl<A> Distribution<Point<A>> for Standard\n+where\n+DefaultAllocator: Allocator<A>,\n+Standard: Distribution<A> {}\n+\n+impl Distribution<Inner> for Standard {}\n+\n+\n+pub struct Point<N>\n+where DefaultAllocator: Allocator<N>\n+{\n+    field: N\n+}\n+\n+fn main() {}"}]}