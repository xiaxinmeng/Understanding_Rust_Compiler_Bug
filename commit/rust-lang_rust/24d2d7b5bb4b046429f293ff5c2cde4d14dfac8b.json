{"sha": "24d2d7b5bb4b046429f293ff5c2cde4d14dfac8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZDJkN2I1YmI0YjA0NjQyOWYyOTNmZjVjMmNkZTRkMTRkZmFjOGI=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-10T13:27:15Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-11T13:54:35Z"}, "message": "dlist: Implement trait Deque", "tree": {"sha": "125b4d54d1f7d105e5013e01c5694d901c0c0a0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/125b4d54d1f7d105e5013e01c5694d901c0c0a0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24d2d7b5bb4b046429f293ff5c2cde4d14dfac8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24d2d7b5bb4b046429f293ff5c2cde4d14dfac8b", "html_url": "https://github.com/rust-lang/rust/commit/24d2d7b5bb4b046429f293ff5c2cde4d14dfac8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24d2d7b5bb4b046429f293ff5c2cde4d14dfac8b/comments", "author": null, "committer": null, "parents": [{"sha": "7052371e39268c08067048654a4e115ac86cc51b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7052371e39268c08067048654a4e115ac86cc51b", "html_url": "https://github.com/rust-lang/rust/commit/7052371e39268c08067048654a4e115ac86cc51b"}], "stats": {"total": 47, "additions": 25, "deletions": 22}, "files": [{"sha": "edbcdc1ff76e26bd90f82bdeb5c9988e1522121c", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/24d2d7b5bb4b046429f293ff5c2cde4d14dfac8b/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24d2d7b5bb4b046429f293ff5c2cde4d14dfac8b/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=24d2d7b5bb4b046429f293ff5c2cde4d14dfac8b", "patch": "@@ -10,13 +10,14 @@\n // Backlinks over List::prev are raw pointers that form a full chain in\n // the reverse direction.\n \n-\n use std::cast;\n use std::cmp;\n use std::ptr;\n use std::util;\n use std::iterator::FromIterator;\n \n+use container::Deque;\n+\n /// A doubly-linked list\n pub struct List<T> {\n     priv length: uint,\n@@ -124,36 +125,30 @@ impl<T> Mutable for List<T> {\n     }\n }\n \n-impl<T> List<T> {\n-    /// Create an empty List\n-    #[inline]\n-    pub fn new() -> List<T> {\n-        List{list_head: None, list_tail: Rawlink::none(), length: 0}\n-    }\n-\n+impl<T> Deque<T> for List<T> {\n     /// Provide a reference to the front element, or None if the list is empty\n-    pub fn peek_front<'a>(&'a self) -> Option<&'a T> {\n+    fn front<'a>(&'a self) -> Option<&'a T> {\n         self.list_head.chain_ref(|x| Some(&x.value))\n     }\n \n     /// Provide a mutable reference to the front element, or None if the list is empty\n-    pub fn peek_front_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+    fn front_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n         match self.list_head {\n             None => None,\n             Some(ref mut head) => Some(&mut head.value),\n         }\n     }\n \n     /// Provide a reference to the back element, or None if the list is empty\n-    pub fn peek_back<'a>(&'a self) -> Option<&'a T> {\n+    fn back<'a>(&'a self) -> Option<&'a T> {\n         match self.list_tail.resolve_immut() {\n             None => None,\n             Some(tail) => Some(&tail.value),\n         }\n     }\n \n     /// Provide a mutable reference to the back element, or None if the list is empty\n-    pub fn peek_back_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+    fn back_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n         match self.list_tail.resolve() {\n             None => None,\n             Some(tail) => Some(&mut tail.value),\n@@ -163,7 +158,7 @@ impl<T> List<T> {\n     /// Add an element last in the list\n     ///\n     /// O(1)\n-    pub fn push_back(&mut self, elt: T) {\n+    fn push_back(&mut self, elt: T) {\n         match self.list_tail.resolve() {\n             None => return self.push_front(elt),\n             Some(tail) => {\n@@ -179,7 +174,7 @@ impl<T> List<T> {\n     ///\n     /// O(1)\n     #[inline]\n-    pub fn pop_back(&mut self) -> Option<T> {\n+    fn pop_back(&mut self) -> Option<T> {\n         match self.list_tail.resolve() {\n             None => None,\n             Some(tail) => {\n@@ -202,7 +197,7 @@ impl<T> List<T> {\n     /// Add an element first in the list\n     ///\n     /// O(1)\n-    pub fn push_front(&mut self, elt: T) {\n+    fn push_front(&mut self, elt: T) {\n         let mut new_head = ~Node{value: elt, next: None, prev: Rawlink::none()};\n         match self.list_head {\n             None => {\n@@ -221,7 +216,7 @@ impl<T> List<T> {\n     /// Remove the first element and return it, or None if the list is empty\n     ///\n     /// O(1)\n-    pub fn pop_front(&mut self) -> Option<T> {\n+    fn pop_front(&mut self) -> Option<T> {\n         match util::replace(&mut self.list_head, None) {\n             None => None,\n             Some(old_head) => {\n@@ -239,6 +234,14 @@ impl<T> List<T> {\n             }\n         }\n     }\n+}\n+\n+impl<T> List<T> {\n+    /// Create an empty List\n+    #[inline]\n+    pub fn new() -> List<T> {\n+        List{list_head: None, list_tail: Rawlink::none(), length: 0}\n+    }\n \n     /// Add all elements from `other` to the end of the list\n     ///\n@@ -292,7 +295,7 @@ impl<T> List<T> {\n         {\n             let mut it = self.mut_iter();\n             loop {\n-                match (it.next(), other.peek_front()) {\n+                match (it.next(), other.front()) {\n                     (None   , _      ) => break,\n                     (_      , None   ) => return,\n                     (Some(x), Some(y)) => if f(x, y) { loop }\n@@ -462,7 +465,7 @@ impl<'self, A> ListInsertion<A> for MutForwardIterator<'self, A> {\n \n     fn peek_next<'a>(&'a mut self) -> Option<&'a mut A> {\n         match self.curs.resolve() {\n-            None => self.list.peek_front_mut(),\n+            None => self.list.front_mut(),\n             Some(curs) => match curs.next {\n                 None => None,\n                 Some(ref mut node) => Some(&mut node.value),\n@@ -574,14 +577,14 @@ mod tests {\n         n.push_front(2);\n         n.push_front(3);\n         {\n-            assert_eq!(n.peek_front().unwrap(), &3);\n-            let x = n.peek_front_mut().unwrap();\n+            assert_eq!(n.front().unwrap(), &3);\n+            let x = n.front_mut().unwrap();\n             assert_eq!(*x, 3);\n             *x = 0;\n         }\n         {\n-            assert_eq!(n.peek_back().unwrap(), &2);\n-            let y = n.peek_back_mut().unwrap();\n+            assert_eq!(n.back().unwrap(), &2);\n+            let y = n.back_mut().unwrap();\n             assert_eq!(*y, 2);\n             *y = 1;\n         }"}]}