{"sha": "ffcdbad263fc2522696b3376627aca503fe0fe8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmY2RiYWQyNjNmYzI1MjI2OTZiMzM3NjYyN2FjYTUwM2ZlMGZlOGY=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-01-08T17:09:43Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-01-08T17:30:27Z"}, "message": "review comments", "tree": {"sha": "4cde17ee054669ae06d828104c15fe39ea0622c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cde17ee054669ae06d828104c15fe39ea0622c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffcdbad263fc2522696b3376627aca503fe0fe8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffcdbad263fc2522696b3376627aca503fe0fe8f", "html_url": "https://github.com/rust-lang/rust/commit/ffcdbad263fc2522696b3376627aca503fe0fe8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffcdbad263fc2522696b3376627aca503fe0fe8f/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b522ba02374169372a80d867894818c92e8c534a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b522ba02374169372a80d867894818c92e8c534a", "html_url": "https://github.com/rust-lang/rust/commit/b522ba02374169372a80d867894818c92e8c534a"}], "stats": {"total": 66, "additions": 40, "deletions": 26}, "files": [{"sha": "b6d6ca0dcef728469104b8ef699114152710780c", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 40, "deletions": 26, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ffcdbad263fc2522696b3376627aca503fe0fe8f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffcdbad263fc2522696b3376627aca503fe0fe8f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=ffcdbad263fc2522696b3376627aca503fe0fe8f", "patch": "@@ -1303,15 +1303,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             _ => {}\n         }\n \n+        /// This is a bare signal of what kind of type we're dealing with. `ty::TyKind` tracks\n+        /// extra information about each type, but we only care about the category.\n         #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-        enum TyKind {\n+        enum TyCategory {\n             Closure,\n             Opaque,\n             Generator,\n             Foreign,\n         }\n \n-        impl TyKind {\n+        impl TyCategory {\n             fn descr(&self) -> &'static str {\n                 match self {\n                     Self::Closure => \"closure\",\n@@ -1334,8 +1336,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         struct OpaqueTypesVisitor<'tcx> {\n             types: FxHashMap<TyKind, FxHashSet<Span>>,\n-            expected: FxHashMap<TyKind, FxHashSet<Span>>,\n-            found: FxHashMap<TyKind, FxHashSet<Span>>,\n+            expected: FxHashMap<TyCategory, FxHashSet<Span>>,\n+            found: FxHashMap<TyCategory, FxHashSet<Span>>,\n             ignore_span: Span,\n             tcx: TyCtxt<'tcx>,\n         }\n@@ -1354,6 +1356,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     ignore_span,\n                     tcx,\n                 };\n+                // The visitor puts all the relevant encountered types in `self.types`, but in\n+                // here we want to visit two separate types with no relation to each other, so we\n+                // move the results from `types` to `expected` or `found` as appropriate.\n                 expected.visit_with(&mut types_visitor);\n                 std::mem::swap(&mut types_visitor.expected, &mut types_visitor.types);\n                 found.visit_with(&mut types_visitor);\n@@ -1362,28 +1367,37 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n \n             fn report(&self, err: &mut DiagnosticBuilder<'_>) {\n-                for (target, types) in &[(\"expected\", &self.expected), (\"found\", &self.found)] {\n-                    for (key, values) in types.iter() {\n-                        let count = values.len();\n-                        for sp in values {\n-                            err.span_label(\n-                                *sp,\n-                                format!(\n-                                    \"{}{}{} {}{}\",\n-                                    if sp.is_desugaring(DesugaringKind::Async) {\n-                                        \"the `Output` of this `async fn`'s \"\n-                                    } else if count == 1 {\n-                                        \"the \"\n-                                    } else {\n-                                        \"\"\n-                                    },\n-                                    if count > 1 { \"one of the \" } else { \"\" },\n-                                    target,\n-                                    key.descr(),\n-                                    pluralize!(count),\n-                                ),\n-                            );\n-                        }\n+                self.add_labels_for_types(err, \"expected\", &self.expected);\n+                self.add_labels_for_types(err, \"found\", &self.found);\n+            }\n+\n+            fn add_labels_for_types(\n+                &self,\n+                err: &mut DiagnosticBuilder<'_>,\n+                target: &str,\n+                types: &FxHashMap<TyKind, FxHashSet<Span>>,\n+            ) {\n+                for (key, values) in types.iter() {\n+                    let count = values.len();\n+                    let kind = key.descr();\n+                    for sp in values {\n+                        err.span_label(\n+                            *sp,\n+                            format!(\n+                                \"{}{}{} {}{}\",\n+                                if sp.is_desugaring(DesugaringKind::Async) {\n+                                    \"the `Output` of this `async fn`'s \"\n+                                } else if count == 1 {\n+                                    \"the \"\n+                                } else {\n+                                    \"\"\n+                                },\n+                                if count > 1 { \"one of the \" } else { \"\" },\n+                                target,\n+                                key,\n+                                pluralize!(count),\n+                            ),\n+                        );\n                     }\n                 }\n             }"}]}