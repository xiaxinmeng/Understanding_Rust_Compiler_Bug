{"sha": "defcceb8796ea98d429297e2cf8c414064aa0234", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZmNjZWI4Nzk2ZWE5OGQ0MjkyOTdlMmNmOGM0MTQwNjRhYTAyMzQ=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-21T04:47:15Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-21T04:47:15Z"}, "message": "Pull out some functionality into separate files", "tree": {"sha": "f0a96598501f8875e3c52f5f6dd146234477dbb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0a96598501f8875e3c52f5f6dd146234477dbb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/defcceb8796ea98d429297e2cf8c414064aa0234", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/defcceb8796ea98d429297e2cf8c414064aa0234", "html_url": "https://github.com/rust-lang/rust/commit/defcceb8796ea98d429297e2cf8c414064aa0234", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/defcceb8796ea98d429297e2cf8c414064aa0234/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "986de65b979bde3968c9c438c4cc9c1f98ba9e2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/986de65b979bde3968c9c438c4cc9c1f98ba9e2a", "html_url": "https://github.com/rust-lang/rust/commit/986de65b979bde3968c9c438c4cc9c1f98ba9e2a"}], "stats": {"total": 893, "additions": 471, "deletions": 422}, "files": [{"sha": "f1a9c3954705368a1391b867ecd0850b4d60ff56", "filename": "src/functions.rs", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/defcceb8796ea98d429297e2cf8c414064aa0234/src%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcceb8796ea98d429297e2cf8c414064aa0234/src%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffunctions.rs?ref=defcceb8796ea98d429297e2cf8c414064aa0234", "patch": "@@ -0,0 +1,234 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use {FmtVisitor, ReturnIndent, make_indent, MAX_WIDTH, BraceStyle,\n+     IDEAL_WIDTH, LEEWAY, FN_BRACE_STYLE, FN_RETURN_INDENT};\n+use lists::{write_list, ListFormatting, SeparatorTactic, ListTactic};\n+use syntax::{ast, abi};\n+use syntax::print::pprust;\n+use syntax::parse::token;\n+\n+impl<'a> FmtVisitor<'a> {\n+    pub fn rewrite_fn(&mut self,\n+                      indent: usize,\n+                      ident: ast::Ident,\n+                      fd: &ast::FnDecl,\n+                      explicit_self: Option<&ast::ExplicitSelf>,\n+                      generics: &ast::Generics,\n+                      unsafety: &ast::Unsafety,\n+                      abi: &abi::Abi,\n+                      vis: ast::Visibility)\n+        -> String\n+    {\n+        // FIXME we'll lose any comments in between parts of the function decl, but anyone\n+        // who comments there probably deserves what they get.\n+\n+        let where_clause = &generics.where_clause;\n+        let newline_brace = match FN_BRACE_STYLE {\n+            BraceStyle::AlwaysNextLine => true,\n+            BraceStyle::SameLineWhere if where_clause.predicates.len() > 0 => true,\n+            _ => false,\n+        };\n+\n+        let mut result = String::with_capacity(1024);\n+        // Vis unsafety abi.\n+        if vis == ast::Visibility::Public {\n+            result.push_str(\"pub \");\n+        }\n+        if let &ast::Unsafety::Unsafe = unsafety {\n+            result.push_str(\"unsafe \");\n+        }\n+        if *abi != abi::Rust {\n+            result.push_str(\"extern \");\n+            result.push_str(&abi.to_string());\n+            result.push(' ');\n+        }\n+\n+        // fn foo\n+        result.push_str(\"fn \");\n+        result.push_str(&token::get_ident(ident));\n+\n+        // Generics.\n+        // FIXME convert bounds to where clauses where they get too big or if\n+        // there is a where clause at all.\n+        let lifetimes: &[_] = &generics.lifetimes;\n+        let tys: &[_] = &generics.ty_params;\n+        if lifetimes.len() + tys.len() > 0 {\n+            let budget = MAX_WIDTH - indent - result.len() - 2;\n+            // TODO might need to insert a newline if the generics are really long\n+            result.push('<');\n+\n+            let lt_strs = lifetimes.iter().map(|l| self.rewrite_lifetime_def(l));\n+            let ty_strs = tys.iter().map(|ty| self.rewrite_ty_param(ty));\n+            let generics_strs: Vec<_> = lt_strs.chain(ty_strs).map(|s| (s, String::new())).collect();\n+            let fmt = ListFormatting {\n+                tactic: ListTactic::HorizontalVertical,\n+                separator: \",\",\n+                trailing_separator: SeparatorTactic::Never,\n+                indent: indent + result.len() + 1,\n+                h_width: budget,\n+                v_width: budget,\n+            };\n+            result.push_str(&write_list(&generics_strs, &fmt));\n+\n+            result.push('>');\n+        }\n+\n+        let ret_str = match fd.output {\n+            ast::FunctionRetTy::DefaultReturn(_) => String::new(),\n+            ast::FunctionRetTy::NoReturn(_) => \"-> !\".to_string(),\n+            ast::FunctionRetTy::Return(ref ty) => \"-> \".to_string() + &pprust::ty_to_string(ty),\n+        };\n+\n+        // Args.\n+        let args = &fd.inputs;\n+\n+        let mut budgets = None;\n+\n+        // Try keeping everything on the same line\n+        if !result.contains(\"\\n\") {\n+            // 3 = `() `, space is before ret_string\n+            let mut used_space = indent + result.len() + 3 + ret_str.len();\n+            if newline_brace {\n+                used_space += 2;\n+            }\n+            let one_line_budget = if used_space > MAX_WIDTH {\n+                0\n+            } else {\n+                MAX_WIDTH - used_space\n+            };\n+\n+            let used_space = indent + result.len() + 2;\n+            let max_space = IDEAL_WIDTH + LEEWAY;\n+            if used_space < max_space {\n+                budgets = Some((one_line_budget,\n+                                // 2 = `()`\n+                                max_space - used_space,\n+                                indent + result.len() + 1));\n+            }\n+        }\n+\n+        // Didn't work. we must force vertical layout and put args on a newline.\n+        if let None = budgets {\n+            result.push('\\n');\n+            result.push_str(&make_indent(indent + 4));\n+            // 6 = new indent + `()`\n+            let used_space = indent + 6;\n+            let max_space = IDEAL_WIDTH + LEEWAY;\n+            if used_space > max_space {\n+                // Whoops! bankrupt.\n+                // TODO take evasive action, perhaps kill the indent or something.\n+            } else {\n+                // 5 = new indent + `(`\n+                budgets = Some((0, max_space - used_space, indent + 5));\n+            }\n+        }\n+\n+        let (one_line_budget, multi_line_budget, arg_indent) = budgets.unwrap();\n+        result.push('(');\n+\n+        let fmt = ListFormatting {\n+            tactic: ListTactic::HorizontalVertical,\n+            separator: \",\",\n+            trailing_separator: SeparatorTactic::Never,\n+            indent: arg_indent,\n+            h_width: one_line_budget,\n+            v_width: multi_line_budget,\n+        };\n+        // TODO dead spans\n+        let mut arg_strs: Vec<_> = args.iter().map(|a| (self.rewrite_fn_input(a), String::new())).collect();\n+        // Account for sugary self.\n+        if let Some(explicit_self) = explicit_self {\n+            match explicit_self.node {\n+                ast::ExplicitSelf_::SelfRegion(ref lt, ref m, _) => {\n+                    let lt_str = match lt {\n+                        &Some(ref l) => format!(\"{} \", pprust::lifetime_to_string(l)),\n+                        &None => String::new(),\n+                    };\n+                    let mut_str = match m {\n+                        &ast::Mutability::MutMutable => \"mut \".to_string(),\n+                        &ast::Mutability::MutImmutable => String::new(),\n+                    };\n+                    arg_strs[0].0 = format!(\"&{}{}self\", lt_str, mut_str);\n+                }\n+                ast::ExplicitSelf_::SelfExplicit(ref ty, _) => {\n+                    arg_strs[0].0 = format!(\"self: {}\", pprust::ty_to_string(ty));\n+                }\n+                ast::ExplicitSelf_::SelfValue(_) => {\n+                    arg_strs[0].0 = \"self\".to_string();\n+                }\n+                _ => {}\n+            }\n+        }\n+        result.push_str(&write_list(&arg_strs, &fmt));\n+\n+        result.push(')');\n+\n+        // Where clause.\n+        if where_clause.predicates.len() > 0 {\n+            result.push('\\n');\n+            result.push_str(&make_indent(indent + 4));\n+            result.push_str(\"where \");\n+\n+            let budget = IDEAL_WIDTH + LEEWAY - indent - 10;\n+            let fmt = ListFormatting {\n+                tactic: ListTactic::Vertical,\n+                separator: \",\",\n+                trailing_separator: SeparatorTactic::Always,\n+                indent: indent + 10,\n+                h_width: budget,\n+                v_width: budget,\n+            };\n+            let where_strs: Vec<_> = where_clause.predicates.iter().map(|p| (self.rewrite_pred(p), String::new())).collect();\n+            result.push_str(&write_list(&where_strs, &fmt));\n+        }\n+\n+        // Return type.\n+        if ret_str.len() > 0 {\n+            // If we've already gone multi-line, or the return type would push\n+            // over the max width, then put the return type on a new line.\n+            if result.contains(\"\\n\") ||\n+               result.len() + indent + ret_str.len() > MAX_WIDTH {\n+                let indent = match FN_RETURN_INDENT {\n+                    ReturnIndent::WithWhereClause => indent + 4,\n+                    // TODO we might want to check that using the arg indent doesn't\n+                    // blow our budget, and if it does, then fallback to the where\n+                    // clause indent.\n+                    ReturnIndent::WithArgs => arg_indent,\n+                };\n+\n+                result.push('\\n');\n+                result.push_str(&make_indent(indent));\n+            } else {\n+                result.push(' ');\n+            }\n+            result.push_str(&ret_str);\n+        }\n+\n+        // Prepare for the function body by possibly adding a newline and indent.\n+        // FIXME we'll miss anything between the end of the signature and the start\n+        // of the body, but we need more spans from the compiler to solve this.\n+        if newline_brace {\n+            result.push('\\n');\n+            result.push_str(&make_indent(self.block_indent));\n+        } else {\n+            result.push(' ');\n+        }\n+\n+        result\n+    }\n+\n+    // TODO we farm this out, but this could spill over the column limit, so we ought to handle it properly\n+    fn rewrite_fn_input(&self, arg: &ast::Arg) -> String {\n+        format!(\"{}: {}\",\n+                pprust::pat_to_string(&arg.pat),\n+                pprust::ty_to_string(&arg.ty))\n+    }\n+}"}, {"sha": "5800f76b95aeba8e34059f7f7b246301272d4240", "filename": "src/lists.rs", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/defcceb8796ea98d429297e2cf8c414064aa0234/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcceb8796ea98d429297e2cf8c414064aa0234/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=defcceb8796ea98d429297e2cf8c414064aa0234", "patch": "@@ -0,0 +1,136 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use make_indent;\n+\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+pub enum ListTactic {\n+    // One item per row.\n+    Vertical,\n+    // All items on one row.\n+    Horizontal,\n+    // Try Horizontal layout, if that fails then vertical\n+    HorizontalVertical,\n+    // Pack as many items as possible per row over (possibly) many rows.\n+    Mixed,\n+}\n+\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+pub enum SeparatorTactic {\n+    Always,\n+    Never,\n+    Vertical,\n+}\n+\n+pub struct ListFormatting<'a> {\n+    pub tactic: ListTactic,\n+    pub separator: &'a str,\n+    pub trailing_separator: SeparatorTactic,\n+    pub indent: usize,\n+    // Available width if we layout horizontally.\n+    pub h_width: usize,\n+    // Available width if we layout vertically\n+    pub v_width: usize,\n+}\n+\n+// Format a list of strings into a string.\n+pub fn write_list<'b>(items:&[(String, String)], formatting: &ListFormatting<'b>) -> String {\n+    if items.len() == 0 {\n+        return String::new();\n+    }\n+\n+    let mut tactic = formatting.tactic;\n+\n+    let h_width = formatting.h_width;\n+    let v_width = formatting.v_width;\n+    let sep_len = formatting.separator.len();\n+\n+    // Conservatively overestimates because of the changing separator tactic.\n+    let sep_count = if formatting.trailing_separator != SeparatorTactic::Never {\n+        items.len()\n+    } else {\n+        items.len() - 1\n+    };\n+\n+    // TODO count dead space too.\n+    let total_width = items.iter().map(|&(ref s, _)| s.len()).fold(0, |a, l| a + l);\n+\n+    // Check if we need to fallback from horizontal listing, if possible.\n+    if tactic == ListTactic::HorizontalVertical { \n+        if (total_width + (sep_len + 1) * sep_count) > h_width {\n+            tactic = ListTactic::Vertical;\n+        } else {\n+            tactic = ListTactic::Horizontal;\n+        }\n+    }\n+\n+    // Now that we know how we will layout, we can decide for sure if there\n+    // will be a trailing separator.\n+    let trailing_separator = match formatting.trailing_separator {\n+        SeparatorTactic::Always => true,\n+        SeparatorTactic::Vertical => tactic == ListTactic::Vertical,\n+        SeparatorTactic::Never => false,\n+    };\n+\n+    // Create a buffer for the result.\n+    // TODO could use a StringBuffer or rope for this\n+    let alloc_width = if tactic == ListTactic::Horizontal {\n+        total_width + (sep_len + 1) * sep_count\n+    } else {\n+        total_width + items.len() * (formatting.indent + 1)\n+    };\n+    let mut result = String::with_capacity(alloc_width);\n+\n+    let mut line_len = 0;\n+    let indent_str = &make_indent(formatting.indent);\n+    for (i, &(ref item, _)) in items.iter().enumerate() {\n+        let first = i == 0;\n+        let separate = i != items.len() - 1 || trailing_separator;\n+\n+        match tactic {\n+            ListTactic::Horizontal if !first => {\n+                result.push(' ');\n+            }\n+            ListTactic::Vertical if !first => {\n+                result.push('\\n');\n+                result.push_str(indent_str);\n+            }\n+            ListTactic::Mixed => {\n+                let mut item_width = item.len();\n+                if separate {\n+                    item_width += sep_len;\n+                }\n+\n+                if line_len > 0 && line_len + item_width > v_width {\n+                    result.push('\\n');\n+                    result.push_str(indent_str);\n+                    line_len = 0;\n+                }\n+\n+                if line_len > 0 {\n+                    result.push(' ');\n+                    line_len += 1;\n+                }\n+\n+                line_len += item_width;\n+            }\n+            _ => {}\n+        }\n+\n+        result.push_str(item);\n+        \n+        if separate {\n+            result.push_str(formatting.separator);\n+        }\n+        // TODO dead spans\n+    }\n+\n+    result\n+}"}, {"sha": "bea83a4f90fad34a1b55179f39a5e9aa132ac678", "filename": "src/missed_spans.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/defcceb8796ea98d429297e2cf8c414064aa0234/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcceb8796ea98d429297e2cf8c414064aa0234/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=defcceb8796ea98d429297e2cf8c414064aa0234", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use {FmtVisitor, make_indent};\n+use syntax::codemap::{self, Span, BytePos};\n+\n+impl<'a> FmtVisitor<'a> {\n+    // TODO these format_missing methods are ugly. Refactor and add unit tests\n+    // for the central whitespace stripping loop.\n+    pub fn format_missing(&mut self, end: BytePos) {\n+        self.format_missing_inner(end, |this, last_snippet, span, _| {\n+            this.changes.push_str_span(span, last_snippet)\n+        })\n+    }\n+\n+    pub fn format_missing_with_indent(&mut self, end: BytePos) {\n+        self.format_missing_inner(end, |this, last_snippet, span, snippet| {\n+            if last_snippet == snippet {\n+                // No new lines\n+                this.changes.push_str_span(span, last_snippet);\n+                this.changes.push_str_span(span, \"\\n\");\n+            } else {\n+                this.changes.push_str_span(span, last_snippet.trim_right());\n+            }\n+            let indent = make_indent(this.block_indent);\n+            this.changes.push_str_span(span, &indent);\n+        })\n+    }\n+\n+    fn format_missing_inner<F: Fn(&mut FmtVisitor, &str, Span, &str)>(&mut self,\n+                                                                      end: BytePos,\n+                                                                      process_last_snippet: F)\n+    {\n+        let start = self.last_pos;\n+        debug!(\"format_missing_inner: {:?} to {:?}\",\n+               self.codemap.lookup_char_pos(start),\n+               self.codemap.lookup_char_pos(end));\n+\n+        if start == end {\n+            return;\n+        }\n+\n+        assert!(start < end,\n+                \"Request to format inverted span: {:?} to {:?}\",\n+                self.codemap.lookup_char_pos(start),\n+                self.codemap.lookup_char_pos(end));\n+\n+\n+        self.last_pos = end;\n+        let spans = self.changes.filespans_for_span(start, end);\n+        for (i, &(start, end)) in spans.iter().enumerate() {\n+            let span = codemap::mk_sp(BytePos(start), BytePos(end));\n+            let snippet = self.snippet(span);\n+\n+            // Trim whitespace from the right hand side of each line.\n+            // Annoyingly, the library functions for splitting by lines etc. are not\n+            // quite right, so we must do it ourselves.\n+            let mut line_start = 0;\n+            let mut last_wspace = None;\n+            for (i, c) in snippet.char_indices() {\n+                if c == '\\n' {\n+                    if let Some(lw) = last_wspace {\n+                        self.changes.push_str_span(span, &snippet[line_start..lw]);\n+                        self.changes.push_str_span(span, \"\\n\");\n+                    } else {\n+                        self.changes.push_str_span(span, &snippet[line_start..i+1]);\n+                    }\n+\n+                    line_start = i + 1;\n+                    last_wspace = None;\n+                } else {\n+                    if c.is_whitespace() {\n+                        if last_wspace.is_none() {\n+                            last_wspace = Some(i);\n+                        }\n+                    } else {\n+                        last_wspace = None;\n+                    }\n+                }\n+            }\n+            if i == spans.len() - 1 {\n+                process_last_snippet(self, &snippet[line_start..], span, &snippet);\n+            } else {\n+                self.changes.push_str_span(span, &snippet[line_start..]);\n+            }\n+        }\n+    }\n+}"}, {"sha": "750b3159a932148911f0b85b9d5cce028e17edca", "filename": "src/mod.rs", "status": "modified", "additions": 6, "deletions": 422, "changes": 428, "blob_url": "https://github.com/rust-lang/rust/blob/defcceb8796ea98d429297e2cf8c414064aa0234/src%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcceb8796ea98d429297e2cf8c414064aa0234/src%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmod.rs?ref=defcceb8796ea98d429297e2cf8c414064aa0234", "patch": "@@ -41,8 +41,8 @@ use rustc::session::Session;\n use rustc::session::config::{self, Input};\n use rustc_driver::{driver, CompilerCalls, Compilation};\n \n-use syntax::{ast, ptr, abi};\n-use syntax::codemap::{self, CodeMap, Span, Pos, BytePos};\n+use syntax::{ast, ptr};\n+use syntax::codemap::{CodeMap, Span, Pos, BytePos};\n use syntax::diagnostics;\n use syntax::parse::token;\n use syntax::print::pprust;\n@@ -51,8 +51,12 @@ use syntax::visit;\n use std::path::PathBuf;\n \n use changes::ChangeSet;\n+use lists::{write_list, ListFormatting, SeparatorTactic, ListTactic};\n \n mod changes;\n+mod functions;\n+mod missed_spans;\n+mod lists;\n \n const IDEAL_WIDTH: usize = 80;\n const LEEWAY: usize = 5;\n@@ -286,130 +290,6 @@ fn make_indent(width: usize) -> String {\n     indent\n }\n \n-#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n-enum ListTactic {\n-    // One item per row.\n-    Vertical,\n-    // All items on one row.\n-    Horizontal,\n-    // Try Horizontal layout, if that fails then vertical\n-    HorizontalVertical,\n-    // Pack as many items as possible per row over (possibly) many rows.\n-    Mixed,\n-}\n-\n-#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n-enum SeparatorTactic {\n-    Always,\n-    Never,\n-    Vertical,\n-}\n-\n-struct ListFormatting<'a> {\n-    tactic: ListTactic,\n-    separator: &'a str,\n-    trailing_separator: SeparatorTactic,\n-    indent: usize,\n-    // Available width if we layout horizontally.\n-    h_width: usize,\n-    // Available width if we layout vertically\n-    v_width: usize,\n-}\n-\n-// Format a list of strings into a string.\n-fn write_list<'b>(items:&[(String, String)], formatting: &ListFormatting<'b>) -> String {\n-    if items.len() == 0 {\n-        return String::new();\n-    }\n-\n-    let mut tactic = formatting.tactic;\n-\n-    let h_width = formatting.h_width;\n-    let v_width = formatting.v_width;\n-    let sep_len = formatting.separator.len();\n-\n-    // Conservatively overestimates because of the changing separator tactic.\n-    let sep_count = if formatting.trailing_separator != SeparatorTactic::Never {\n-        items.len()\n-    } else {\n-        items.len() - 1\n-    };\n-\n-    // TODO count dead space too.\n-    let total_width = items.iter().map(|&(ref s, _)| s.len()).fold(0, |a, l| a + l);\n-\n-    // Check if we need to fallback from horizontal listing, if possible.\n-    if tactic == ListTactic::HorizontalVertical { \n-        if (total_width + (sep_len + 1) * sep_count) > h_width {\n-            tactic = ListTactic::Vertical;\n-        } else {\n-            tactic = ListTactic::Horizontal;\n-        }\n-    }\n-\n-    // Now that we know how we will layout, we can decide for sure if there\n-    // will be a trailing separator.\n-    let trailing_separator = match formatting.trailing_separator {\n-        SeparatorTactic::Always => true,\n-        SeparatorTactic::Vertical => tactic == ListTactic::Vertical,\n-        SeparatorTactic::Never => false,\n-    };\n-\n-    // Create a buffer for the result.\n-    // TODO could use a StringBuffer or rope for this\n-    let alloc_width = if tactic == ListTactic::Horizontal {\n-        total_width + (sep_len + 1) * sep_count\n-    } else {\n-        total_width + items.len() * (formatting.indent + 1)\n-    };\n-    let mut result = String::with_capacity(alloc_width);\n-\n-    let mut line_len = 0;\n-    let indent_str = &make_indent(formatting.indent);\n-    for (i, &(ref item, _)) in items.iter().enumerate() {\n-        let first = i == 0;\n-        let separate = i != items.len() - 1 || trailing_separator;\n-\n-        match tactic {\n-            ListTactic::Horizontal if !first => {\n-                result.push(' ');\n-            }\n-            ListTactic::Vertical if !first => {\n-                result.push('\\n');\n-                result.push_str(indent_str);\n-            }\n-            ListTactic::Mixed => {\n-                let mut item_width = item.len();\n-                if separate {\n-                    item_width += sep_len;\n-                }\n-\n-                if line_len > 0 && line_len + item_width > v_width {\n-                    result.push('\\n');\n-                    result.push_str(indent_str);\n-                    line_len = 0;\n-                }\n-\n-                if line_len > 0 {\n-                    result.push(' ');\n-                    line_len += 1;\n-                }\n-\n-                line_len += item_width;\n-            }\n-            _ => {}\n-        }\n-\n-        result.push_str(item);\n-        \n-        if separate {\n-            result.push_str(formatting.separator);\n-        }\n-        // TODO dead spans\n-    }\n-\n-    result\n-}\n \n impl<'a> FmtVisitor<'a> {\n     fn from_codemap<'b>(codemap: &'b CodeMap) -> FmtVisitor<'b> {\n@@ -421,87 +301,6 @@ impl<'a> FmtVisitor<'a> {\n         }\n     }\n \n-    // TODO these format_missing methods are ugly. Refactor and add unit tests\n-    // for the central whitespace stripping loop.\n-    fn format_missing(&mut self, end: BytePos) {\n-        self.format_missing_inner(end, |this, last_snippet, span, _| {\n-            this.changes.push_str_span(span, last_snippet)\n-        })\n-    }\n-\n-    fn format_missing_with_indent(&mut self, end: BytePos) {\n-        self.format_missing_inner(end, |this, last_snippet, span, snippet| {\n-            if last_snippet == snippet {\n-                // No new lines\n-                this.changes.push_str_span(span, last_snippet);\n-                this.changes.push_str_span(span, \"\\n\");\n-            } else {\n-                this.changes.push_str_span(span, last_snippet.trim_right());\n-            }\n-            let indent = make_indent(this.block_indent);\n-            this.changes.push_str_span(span, &indent);\n-        })\n-    }\n-\n-    fn format_missing_inner<F: Fn(&mut FmtVisitor, &str, Span, &str)>(&mut self,\n-                                                                      end: BytePos,\n-                                                                      process_last_snippet: F)\n-    {\n-        let start = self.last_pos;\n-        debug!(\"format_missing_inner: {:?} to {:?}\",\n-               self.codemap.lookup_char_pos(start),\n-               self.codemap.lookup_char_pos(end));\n-\n-        if start == end {\n-            return;\n-        }\n-\n-        assert!(start < end,\n-                \"Request to format inverted span: {:?} to {:?}\",\n-                self.codemap.lookup_char_pos(start),\n-                self.codemap.lookup_char_pos(end));\n-\n-\n-        self.last_pos = end;\n-        let spans = self.changes.filespans_for_span(start, end);\n-        for (i, &(start, end)) in spans.iter().enumerate() {\n-            let span = codemap::mk_sp(BytePos(start), BytePos(end));\n-            let snippet = self.snippet(span);\n-\n-            // Trim whitespace from the right hand side of each line.\n-            // Annoyingly, the library functions for splitting by lines etc. are not\n-            // quite right, so we must do it ourselves.\n-            let mut line_start = 0;\n-            let mut last_wspace = None;\n-            for (i, c) in snippet.char_indices() {\n-                if c == '\\n' {\n-                    if let Some(lw) = last_wspace {\n-                        self.changes.push_str_span(span, &snippet[line_start..lw]);\n-                        self.changes.push_str_span(span, \"\\n\");\n-                    } else {\n-                        self.changes.push_str_span(span, &snippet[line_start..i+1]);\n-                    }\n-\n-                    line_start = i + 1;\n-                    last_wspace = None;\n-                } else {\n-                    if c.is_whitespace() {\n-                        if last_wspace.is_none() {\n-                            last_wspace = Some(i);\n-                        }\n-                    } else {\n-                        last_wspace = None;\n-                    }\n-                }\n-            }\n-            if i == spans.len() - 1 {\n-                process_last_snippet(self, &snippet[line_start..], span, &snippet);\n-            } else {\n-                self.changes.push_str_span(span, &snippet[line_start..]);\n-            }\n-        }\n-    }\n-\n     fn snippet(&self, span: Span) -> String {\n         match self.codemap.span_to_snippet(span) {\n             Ok(s) => s,\n@@ -629,221 +428,6 @@ impl<'a> FmtVisitor<'a> {\n         format!(\"use {}::{{{}}};\", path_str, write_list(&items, &fmt))\n     }\n \n-    fn rewrite_fn(&mut self,\n-                  indent: usize,\n-                  ident: ast::Ident,\n-                  fd: &ast::FnDecl,\n-                  explicit_self: Option<&ast::ExplicitSelf>,\n-                  generics: &ast::Generics,\n-                  unsafety: &ast::Unsafety,\n-                  abi: &abi::Abi,\n-                  vis: ast::Visibility)\n-        -> String\n-    {\n-        // FIXME we'll lose any comments in between parts of the function decl, but anyone\n-        // who comments there probably deserves what they get.\n-\n-        let where_clause = &generics.where_clause;\n-        let newline_brace = match FN_BRACE_STYLE {\n-            BraceStyle::AlwaysNextLine => true,\n-            BraceStyle::SameLineWhere if where_clause.predicates.len() > 0 => true,\n-            _ => false,\n-        };\n-\n-        let mut result = String::with_capacity(1024);\n-        // Vis unsafety abi.\n-        if vis == ast::Visibility::Public {\n-            result.push_str(\"pub \");\n-        }\n-        if let &ast::Unsafety::Unsafe = unsafety {\n-            result.push_str(\"unsafe \");\n-        }\n-        if *abi != abi::Rust {\n-            result.push_str(\"extern \");\n-            result.push_str(&abi.to_string());\n-            result.push(' ');\n-        }\n-\n-        // fn foo\n-        result.push_str(\"fn \");\n-        result.push_str(&token::get_ident(ident));\n-\n-        // Generics.\n-        // FIXME convert bounds to where clauses where they get too big or if\n-        // there is a where clause at all.\n-        let lifetimes: &[_] = &generics.lifetimes;\n-        let tys: &[_] = &generics.ty_params;\n-        if lifetimes.len() + tys.len() > 0 {\n-            let budget = MAX_WIDTH - indent - result.len() - 2;\n-            // TODO might need to insert a newline if the generics are really long\n-            result.push('<');\n-\n-            let lt_strs = lifetimes.iter().map(|l| self.rewrite_lifetime_def(l));\n-            let ty_strs = tys.iter().map(|ty| self.rewrite_ty_param(ty));\n-            let generics_strs: Vec<_> = lt_strs.chain(ty_strs).map(|s| (s, String::new())).collect();\n-            let fmt = ListFormatting {\n-                tactic: ListTactic::HorizontalVertical,\n-                separator: \",\",\n-                trailing_separator: SeparatorTactic::Never,\n-                indent: indent + result.len() + 1,\n-                h_width: budget,\n-                v_width: budget,\n-            };\n-            result.push_str(&write_list(&generics_strs, &fmt));\n-\n-            result.push('>');\n-        }\n-\n-        let ret_str = match fd.output {\n-            ast::FunctionRetTy::DefaultReturn(_) => String::new(),\n-            ast::FunctionRetTy::NoReturn(_) => \"-> !\".to_string(),\n-            ast::FunctionRetTy::Return(ref ty) => \"-> \".to_string() + &pprust::ty_to_string(ty),\n-        };\n-\n-        // Args.\n-        let args = &fd.inputs;\n-\n-        let mut budgets = None;\n-\n-        // Try keeping everything on the same line\n-        if !result.contains(\"\\n\") {\n-            // 3 = `() `, space is before ret_string\n-            let mut used_space = indent + result.len() + 3 + ret_str.len();\n-            if newline_brace {\n-                used_space += 2;\n-            }\n-            let one_line_budget = if used_space > MAX_WIDTH {\n-                0\n-            } else {\n-                MAX_WIDTH - used_space\n-            };\n-\n-            let used_space = indent + result.len() + 2;\n-            let max_space = IDEAL_WIDTH + LEEWAY;\n-            if used_space < max_space {\n-                budgets = Some((one_line_budget,\n-                                // 2 = `()`\n-                                max_space - used_space,\n-                                indent + result.len() + 1));\n-            }\n-        }\n-\n-        // Didn't work. we must force vertical layout and put args on a newline.\n-        if let None = budgets {\n-            result.push('\\n');\n-            result.push_str(&make_indent(indent + 4));\n-            // 6 = new indent + `()`\n-            let used_space = indent + 6;\n-            let max_space = IDEAL_WIDTH + LEEWAY;\n-            if used_space > max_space {\n-                // Whoops! bankrupt.\n-                // TODO take evasive action, perhaps kill the indent or something.\n-            } else {\n-                // 5 = new indent + `(`\n-                budgets = Some((0, max_space - used_space, indent + 5));\n-            }\n-        }\n-\n-        let (one_line_budget, multi_line_budget, arg_indent) = budgets.unwrap();\n-        result.push('(');\n-\n-        let fmt = ListFormatting {\n-            tactic: ListTactic::HorizontalVertical,\n-            separator: \",\",\n-            trailing_separator: SeparatorTactic::Never,\n-            indent: arg_indent,\n-            h_width: one_line_budget,\n-            v_width: multi_line_budget,\n-        };\n-        // TODO dead spans\n-        let mut arg_strs: Vec<_> = args.iter().map(|a| (self.rewrite_fn_input(a), String::new())).collect();\n-        // Account for sugary self.\n-        if let Some(explicit_self) = explicit_self {\n-            match explicit_self.node {\n-                ast::ExplicitSelf_::SelfRegion(ref lt, ref m, _) => {\n-                    let lt_str = match lt {\n-                        &Some(ref l) => format!(\"{} \", pprust::lifetime_to_string(l)),\n-                        &None => String::new(),\n-                    };\n-                    let mut_str = match m {\n-                        &ast::Mutability::MutMutable => \"mut \".to_string(),\n-                        &ast::Mutability::MutImmutable => String::new(),\n-                    };\n-                    arg_strs[0].0 = format!(\"&{}{}self\", lt_str, mut_str);\n-                }\n-                ast::ExplicitSelf_::SelfExplicit(ref ty, _) => {\n-                    arg_strs[0].0 = format!(\"self: {}\", pprust::ty_to_string(ty));\n-                }\n-                ast::ExplicitSelf_::SelfValue(_) => {\n-                    arg_strs[0].0 = \"self\".to_string();\n-                }\n-                _ => {}\n-            }\n-        }\n-        result.push_str(&write_list(&arg_strs, &fmt));\n-\n-        result.push(')');\n-\n-        // Where clause.\n-        if where_clause.predicates.len() > 0 {\n-            result.push('\\n');\n-            result.push_str(&make_indent(indent + 4));\n-            result.push_str(\"where \");\n-\n-            let budget = IDEAL_WIDTH + LEEWAY - indent - 10;\n-            let fmt = ListFormatting {\n-                tactic: ListTactic::Vertical,\n-                separator: \",\",\n-                trailing_separator: SeparatorTactic::Always,\n-                indent: indent + 10,\n-                h_width: budget,\n-                v_width: budget,\n-            };\n-            let where_strs: Vec<_> = where_clause.predicates.iter().map(|p| (self.rewrite_pred(p), String::new())).collect();\n-            result.push_str(&write_list(&where_strs, &fmt));\n-        }\n-\n-        // Return type.\n-        if ret_str.len() > 0 {\n-            // If we've already gone multi-line, or the return type would push\n-            // over the max width, then put the return type on a new line.\n-            if result.contains(\"\\n\") ||\n-               result.len() + indent + ret_str.len() > MAX_WIDTH {\n-                let indent = match FN_RETURN_INDENT {\n-                    ReturnIndent::WithWhereClause => indent + 4,\n-                    // TODO we might want to check that using the arg indent doesn't\n-                    // blow our budget, and if it does, then fallback to the where\n-                    // clause indent.\n-                    ReturnIndent::WithArgs => arg_indent,\n-                };\n-\n-                result.push('\\n');\n-                result.push_str(&make_indent(indent));\n-            } else {\n-                result.push(' ');\n-            }\n-            result.push_str(&ret_str);\n-        }\n-\n-        // Prepare for the function body by possibly adding a newline and indent.\n-        // FIXME we'll miss anything between the end of the signature and the start\n-        // of the body, but we need more spans from the compiler to solve this.\n-        if newline_brace {\n-            result.push('\\n');\n-            result.push_str(&make_indent(self.block_indent));\n-        } else {\n-            result.push(' ');\n-        }\n-\n-        result\n-    }\n-\n-    // TODO we farm this out, but this could spill over the column limit, so we ought to handle it properly\n-    fn rewrite_fn_input(&self, arg: &ast::Arg) -> String {\n-        format!(\"{}: {}\",\n-                pprust::pat_to_string(&arg.pat),\n-                pprust::ty_to_string(&arg.ty))\n-    }\n \n     fn rewrite_pred(&self, predicate: &ast::WherePredicate) -> String\n     {"}]}