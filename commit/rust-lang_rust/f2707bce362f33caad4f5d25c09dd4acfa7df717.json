{"sha": "f2707bce362f33caad4f5d25c09dd4acfa7df717", "node_id": "C_kwDOAAsO6NoAKGYyNzA3YmNlMzYyZjMzY2FhZDRmNWQyNWMwOWRkNGFjZmE3ZGY3MTc", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-11-20T15:40:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-20T15:40:56Z"}, "message": "Merge #10819\n\n10819: internal: Replace some `Vec` occurences with `Box`  r=Veykril a=Veykril\n\nShaves off ~15mb from self analysis\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "23ca6ffb3e183e2849c13c7744e3106ad85f2a51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23ca6ffb3e183e2849c13c7744e3106ad85f2a51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2707bce362f33caad4f5d25c09dd4acfa7df717", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhmRcICRBK7hj4Ov3rIwAA5gAIAD9W0usWOpOIAjiRv+FxnCqB\n6+/uvpSCjbH4Wlac2IquCYr6eewdAjA/CU1CbbHnX5OvZWXHvnBVBcGiMn6X+r5M\nIb2mxF/uGFTyddHDdEosXbpt/c/fkE/sW+BwKHYBOIMfKIYhFdWL+nHplQSISIPn\ny5lNwQgmnai88DdQemSuIOzXAgr0TA9DVExe2RAE/5CEGa5nTGEcBqQ9uC1XuLKz\npDUJtPNCHMEimZiIUFJRcGX9AcS7Wp4S9aFKS5N/YfOmM35537Y7aEIlxiJFtbM5\nlGPbr7VTJpjZw5PO3CeM7ukm1Y9q6t+0A6SddO4ZQraU/6bmTCnIwR/NS8HZMkI=\n=BHaw\n-----END PGP SIGNATURE-----\n", "payload": "tree 23ca6ffb3e183e2849c13c7744e3106ad85f2a51\nparent 5f5c84d9212936ce2b82ba9fcb0283a7cdf9aa6f\nparent 91def936bc0ecabd574eb312e376afa801f12dca\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1637422856 +0000\ncommitter GitHub <noreply@github.com> 1637422856 +0000\n\nMerge #10819\n\n10819: internal: Replace some `Vec` occurences with `Box`  r=Veykril a=Veykril\n\nShaves off ~15mb from self analysis\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2707bce362f33caad4f5d25c09dd4acfa7df717", "html_url": "https://github.com/rust-lang/rust/commit/f2707bce362f33caad4f5d25c09dd4acfa7df717", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2707bce362f33caad4f5d25c09dd4acfa7df717/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f5c84d9212936ce2b82ba9fcb0283a7cdf9aa6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f5c84d9212936ce2b82ba9fcb0283a7cdf9aa6f", "html_url": "https://github.com/rust-lang/rust/commit/5f5c84d9212936ce2b82ba9fcb0283a7cdf9aa6f"}, {"sha": "91def936bc0ecabd574eb312e376afa801f12dca", "url": "https://api.github.com/repos/rust-lang/rust/commits/91def936bc0ecabd574eb312e376afa801f12dca", "html_url": "https://github.com/rust-lang/rust/commit/91def936bc0ecabd574eb312e376afa801f12dca"}], "stats": {"total": 178, "additions": 78, "deletions": 100}, "files": [{"sha": "e322a953844aeb709ad320b24e1d9a3096c57790", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f2707bce362f33caad4f5d25c09dd4acfa7df717/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2707bce362f33caad4f5d25c09dd4acfa7df717/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=f2707bce362f33caad4f5d25c09dd4acfa7df717", "patch": "@@ -130,11 +130,7 @@ impl ExprCollector<'_> {\n                 self.body.params.push(param_pat);\n             }\n \n-            for param in param_list.params() {\n-                let pat = match param.pat() {\n-                    None => continue,\n-                    Some(pat) => pat,\n-                };\n+            for pat in param_list.params().filter_map(|param| param.pat()) {\n                 let param_pat = self.collect_pat(pat);\n                 self.body.params.push(param_pat);\n             }\n@@ -160,7 +156,7 @@ impl ExprCollector<'_> {\n         self.make_expr(expr, Err(SyntheticSyntax))\n     }\n     fn unit(&mut self) -> ExprId {\n-        self.alloc_expr_desugared(Expr::Tuple { exprs: Vec::new() })\n+        self.alloc_expr_desugared(Expr::Tuple { exprs: Box::default() })\n     }\n     fn missing_expr(&mut self) -> ExprId {\n         self.alloc_expr_desugared(Expr::Missing)\n@@ -235,7 +231,8 @@ impl ExprCollector<'_> {\n                                     expr: else_branch.unwrap_or_else(|| self.unit()),\n                                     guard: None,\n                                 },\n-                            ];\n+                            ]\n+                            .into();\n                             return Some(\n                                 self.alloc_expr(Expr::Match { expr: match_expr, arms }, syntax_ptr),\n                             );\n@@ -300,7 +297,8 @@ impl ExprCollector<'_> {\n                             let arms = vec![\n                                 MatchArm { pat, expr: body, guard: None },\n                                 MatchArm { pat: placeholder_pat, expr: break_, guard: None },\n-                            ];\n+                            ]\n+                            .into();\n                             let match_expr =\n                                 self.alloc_expr_desugared(Expr::Match { expr: match_expr, arms });\n                             return Some(\n@@ -324,7 +322,7 @@ impl ExprCollector<'_> {\n                 let args = if let Some(arg_list) = e.arg_list() {\n                     arg_list.args().filter_map(|e| self.maybe_collect_expr(e)).collect()\n                 } else {\n-                    Vec::new()\n+                    Box::default()\n                 };\n                 self.alloc_expr(Expr::Call { callee, args }, syntax_ptr)\n             }\n@@ -333,7 +331,7 @@ impl ExprCollector<'_> {\n                 let args = if let Some(arg_list) = e.arg_list() {\n                     arg_list.args().filter_map(|e| self.maybe_collect_expr(e)).collect()\n                 } else {\n-                    Vec::new()\n+                    Box::default()\n                 };\n                 let method_name = e.name_ref().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n                 let generic_args = e\n@@ -367,7 +365,7 @@ impl ExprCollector<'_> {\n                         })\n                         .collect()\n                 } else {\n-                    Vec::new()\n+                    Box::default()\n                 };\n                 self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)\n             }\n@@ -429,7 +427,7 @@ impl ExprCollector<'_> {\n                     let spread = nfl.spread().map(|s| self.collect_expr(s));\n                     Expr::RecordLit { path, fields, spread }\n                 } else {\n-                    Expr::RecordLit { path, fields: Vec::new(), spread: None }\n+                    Expr::RecordLit { path, fields: Box::default(), spread: None }\n                 };\n \n                 self.alloc_expr(record_lit, syntax_ptr)\n@@ -496,7 +494,10 @@ impl ExprCollector<'_> {\n                     .and_then(|r| r.ty())\n                     .map(|it| Interned::new(TypeRef::from_ast(&self.ctx(), it)));\n                 let body = self.collect_expr_opt(e.body());\n-                self.alloc_expr(Expr::Lambda { args, arg_types, ret_type, body }, syntax_ptr)\n+                self.alloc_expr(\n+                    Expr::Lambda { args: args.into(), arg_types: arg_types.into(), ret_type, body },\n+                    syntax_ptr,\n+                )\n             }\n             ast::Expr::BinExpr(e) => {\n                 let lhs = self.collect_expr_opt(e.lhs());\n@@ -718,7 +719,7 @@ impl ExprCollector<'_> {\n             self.statements_in_scope.pop();\n         }\n         let tail = tail;\n-        let statements = std::mem::replace(&mut self.statements_in_scope, prev_statements);\n+        let statements = std::mem::replace(&mut self.statements_in_scope, prev_statements).into();\n         let syntax_node_ptr = AstPtr::new(&block.into());\n         let expr_id = self.alloc_expr(\n             Expr::Block { id: block_id, statements, tail, label: None },\n@@ -812,7 +813,7 @@ impl ExprCollector<'_> {\n             ast::Pat::RecordPat(p) => {\n                 let path =\n                     p.path().and_then(|path| self.expander.parse_path(self.db, path)).map(Box::new);\n-                let args: Vec<_> = p\n+                let args = p\n                     .record_pat_field_list()\n                     .expect(\"every struct should have a field list\")\n                     .fields()\n@@ -902,7 +903,7 @@ impl ExprCollector<'_> {\n         }\n     }\n \n-    fn collect_tuple_pat(&mut self, args: AstChildren<ast::Pat>) -> (Vec<PatId>, Option<usize>) {\n+    fn collect_tuple_pat(&mut self, args: AstChildren<ast::Pat>) -> (Box<[PatId]>, Option<usize>) {\n         // Find the location of the `..`, if there is one. Note that we do not\n         // consider the possibility of there being multiple `..` here.\n         let ellipsis = args.clone().position(|p| matches!(p, ast::Pat::RestPat(_)));\n@@ -961,7 +962,7 @@ impl From<ast::LiteralKind> for Literal {\n                 Literal::Float(Default::default(), ty)\n             }\n             LiteralKind::ByteString(bs) => {\n-                let text = bs.value().map(Vec::from).unwrap_or_else(Default::default);\n+                let text = bs.value().map(Box::from).unwrap_or_else(Default::default);\n                 Literal::ByteString(text)\n             }\n             LiteralKind::String(_) => Literal::String(Default::default()),"}, {"sha": "2658eece8e85e60fa93a8d95dbd4cd9bcb7a3bb4", "filename": "crates/hir_def/src/body/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2707bce362f33caad4f5d25c09dd4acfa7df717/crates%2Fhir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2707bce362f33caad4f5d25c09dd4acfa7df717/crates%2Fhir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Fscope.rs?ref=f2707bce362f33caad4f5d25c09dd4acfa7df717", "patch": "@@ -204,7 +204,7 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n         }\n         Expr::Match { expr, arms } => {\n             compute_expr_scopes(*expr, body, scopes, scope);\n-            for arm in arms {\n+            for arm in arms.iter() {\n                 let mut scope = scopes.new_scope(scope);\n                 scopes.add_bindings(body, scope, arm.pat);\n                 match arm.guard {"}, {"sha": "6534f970ee6b860f245fa89f6073f921ab07adf4", "filename": "crates/hir_def/src/expr.rs", "status": "modified", "additions": 37, "deletions": 51, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/f2707bce362f33caad4f5d25c09dd4acfa7df717/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2707bce362f33caad4f5d25c09dd4acfa7df717/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fexpr.rs?ref=f2707bce362f33caad4f5d25c09dd4acfa7df717", "patch": "@@ -40,8 +40,8 @@ pub type LabelId = Idx<Label>;\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Literal {\n-    String(String),\n-    ByteString(Vec<u8>),\n+    String(Box<str>),\n+    ByteString(Box<[u8]>),\n     Char(char),\n     Bool(bool),\n     Int(i128, Option<BuiltinInt>),\n@@ -61,7 +61,7 @@ pub enum Expr {\n     },\n     Block {\n         id: BlockId,\n-        statements: Vec<Statement>,\n+        statements: Box<[Statement]>,\n         tail: Option<ExprId>,\n         label: Option<LabelId>,\n     },\n@@ -82,17 +82,17 @@ pub enum Expr {\n     },\n     Call {\n         callee: ExprId,\n-        args: Vec<ExprId>,\n+        args: Box<[ExprId]>,\n     },\n     MethodCall {\n         receiver: ExprId,\n         method_name: Name,\n-        args: Vec<ExprId>,\n+        args: Box<[ExprId]>,\n         generic_args: Option<Box<GenericArgs>>,\n     },\n     Match {\n         expr: ExprId,\n-        arms: Vec<MatchArm>,\n+        arms: Box<[MatchArm]>,\n     },\n     Continue {\n         label: Option<Name>,\n@@ -109,7 +109,7 @@ pub enum Expr {\n     },\n     RecordLit {\n         path: Option<Box<Path>>,\n-        fields: Vec<RecordLitField>,\n+        fields: Box<[RecordLitField]>,\n         spread: Option<ExprId>,\n     },\n     Field {\n@@ -162,13 +162,13 @@ pub enum Expr {\n         index: ExprId,\n     },\n     Lambda {\n-        args: Vec<PatId>,\n-        arg_types: Vec<Option<Interned<TypeRef>>>,\n+        args: Box<[PatId]>,\n+        arg_types: Box<[Option<Interned<TypeRef>>]>,\n         ret_type: Option<Interned<TypeRef>>,\n         body: ExprId,\n     },\n     Tuple {\n-        exprs: Vec<ExprId>,\n+        exprs: Box<[ExprId]>,\n     },\n     Unsafe {\n         body: ExprId,\n@@ -182,7 +182,7 @@ pub enum Expr {\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Array {\n-    ElementList(Vec<ExprId>),\n+    ElementList(Box<[ExprId]>),\n     Repeat { initializer: ExprId, repeat: ExprId },\n }\n \n@@ -228,23 +228,23 @@ impl Expr {\n             Expr::If { condition, then_branch, else_branch } => {\n                 f(*condition);\n                 f(*then_branch);\n-                if let Some(else_branch) = else_branch {\n-                    f(*else_branch);\n+                if let &Some(else_branch) = else_branch {\n+                    f(else_branch);\n                 }\n             }\n             Expr::Block { statements, tail, .. } => {\n-                for stmt in statements {\n+                for stmt in statements.iter() {\n                     match stmt {\n                         Statement::Let { initializer, .. } => {\n-                            if let Some(expr) = initializer {\n-                                f(*expr);\n+                            if let &Some(expr) = initializer {\n+                                f(expr);\n                             }\n                         }\n                         Statement::Expr { expr: expression, .. } => f(*expression),\n                     }\n                 }\n-                if let Some(expr) = tail {\n-                    f(*expr);\n+                if let &Some(expr) = tail {\n+                    f(expr);\n                 }\n             }\n             Expr::TryBlock { body }\n@@ -262,34 +262,28 @@ impl Expr {\n             }\n             Expr::Call { callee, args } => {\n                 f(*callee);\n-                for arg in args {\n-                    f(*arg);\n-                }\n+                args.iter().copied().for_each(f);\n             }\n             Expr::MethodCall { receiver, args, .. } => {\n                 f(*receiver);\n-                for arg in args {\n-                    f(*arg);\n-                }\n+                args.iter().copied().for_each(f);\n             }\n             Expr::Match { expr, arms } => {\n                 f(*expr);\n-                for arm in arms {\n-                    f(arm.expr);\n-                }\n+                arms.iter().map(|arm| arm.expr).for_each(f);\n             }\n             Expr::Continue { .. } => {}\n             Expr::Break { expr, .. } | Expr::Return { expr } | Expr::Yield { expr } => {\n-                if let Some(expr) = expr {\n-                    f(*expr);\n+                if let &Some(expr) = expr {\n+                    f(expr);\n                 }\n             }\n             Expr::RecordLit { fields, spread, .. } => {\n-                for field in fields {\n+                for field in fields.iter() {\n                     f(field.expr);\n                 }\n-                if let Some(expr) = spread {\n-                    f(*expr);\n+                if let &Some(expr) = spread {\n+                    f(expr);\n                 }\n             }\n             Expr::Lambda { body, .. } => {\n@@ -300,11 +294,11 @@ impl Expr {\n                 f(*rhs);\n             }\n             Expr::Range { lhs, rhs, .. } => {\n-                if let Some(lhs) = rhs {\n-                    f(*lhs);\n+                if let &Some(lhs) = rhs {\n+                    f(lhs);\n                 }\n-                if let Some(rhs) = lhs {\n-                    f(*rhs);\n+                if let &Some(rhs) = lhs {\n+                    f(rhs);\n                 }\n             }\n             Expr::Index { base, index } => {\n@@ -320,17 +314,9 @@ impl Expr {\n             | Expr::Box { expr } => {\n                 f(*expr);\n             }\n-            Expr::Tuple { exprs } => {\n-                for expr in exprs {\n-                    f(*expr);\n-                }\n-            }\n+            Expr::Tuple { exprs } => exprs.iter().copied().for_each(f),\n             Expr::Array(a) => match a {\n-                Array::ElementList(exprs) => {\n-                    for expr in exprs {\n-                        f(*expr);\n-                    }\n-                }\n+                Array::ElementList(exprs) => exprs.iter().copied().for_each(f),\n                 Array::Repeat { initializer, repeat } => {\n                     f(*initializer);\n                     f(*repeat)\n@@ -386,15 +372,15 @@ pub struct RecordFieldPat {\n pub enum Pat {\n     Missing,\n     Wild,\n-    Tuple { args: Vec<PatId>, ellipsis: Option<usize> },\n-    Or(Vec<PatId>),\n-    Record { path: Option<Box<Path>>, args: Vec<RecordFieldPat>, ellipsis: bool },\n+    Tuple { args: Box<[PatId]>, ellipsis: Option<usize> },\n+    Or(Box<[PatId]>),\n+    Record { path: Option<Box<Path>>, args: Box<[RecordFieldPat]>, ellipsis: bool },\n     Range { start: ExprId, end: ExprId },\n-    Slice { prefix: Vec<PatId>, slice: Option<PatId>, suffix: Vec<PatId> },\n+    Slice { prefix: Box<[PatId]>, slice: Option<PatId>, suffix: Box<[PatId]> },\n     Path(Box<Path>),\n     Lit(ExprId),\n     Bind { mode: BindingAnnotation, name: Name, subpat: Option<PatId> },\n-    TupleStruct { path: Option<Box<Path>>, args: Vec<PatId>, ellipsis: Option<usize> },\n+    TupleStruct { path: Option<Box<Path>>, args: Box<[PatId]>, ellipsis: Option<usize> },\n     Ref { pat: PatId, mutability: Mutability },\n     Box { inner: PatId },\n     ConstBlock(ExprId),"}, {"sha": "5bb8afa5cc9963a1a85e6256e9ed9de426b6b776", "filename": "crates/hir_def/src/path.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f2707bce362f33caad4f5d25c09dd4acfa7df717/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2707bce362f33caad4f5d25c09dd4acfa7df717/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=f2707bce362f33caad4f5d25c09dd4acfa7df717", "patch": "@@ -22,7 +22,7 @@ pub struct ModPath {\n     segments: Vec<Name>,\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub enum PathKind {\n     Plain,\n     /// `self::` is `Super(0)`\n@@ -119,7 +119,7 @@ pub struct Path {\n     type_anchor: Option<Interned<TypeRef>>,\n     mod_path: Interned<ModPath>,\n     /// Invariant: the same len as `self.mod_path.segments`\n-    generic_args: Vec<Option<Interned<GenericArgs>>>,\n+    generic_args: Box<[Option<Interned<GenericArgs>>]>,\n }\n \n /// Generic arguments to a path segment (e.g. the `i32` in `Option<i32>`). This\n@@ -171,9 +171,9 @@ impl Path {\n     /// Converts a known mod path to `Path`.\n     pub fn from_known_path(\n         path: ModPath,\n-        generic_args: Vec<Option<Interned<GenericArgs>>>,\n+        generic_args: impl Into<Box<[Option<Interned<GenericArgs>>]>>,\n     ) -> Path {\n-        Path { type_anchor: None, mod_path: Interned::new(path), generic_args }\n+        Path { type_anchor: None, mod_path: Interned::new(path), generic_args: generic_args.into() }\n     }\n \n     pub fn kind(&self) -> &PathKind {\n@@ -187,7 +187,7 @@ impl Path {\n     pub fn segments(&self) -> PathSegments<'_> {\n         PathSegments {\n             segments: self.mod_path.segments.as_slice(),\n-            generic_args: self.generic_args.as_slice(),\n+            generic_args: &self.generic_args,\n         }\n     }\n \n@@ -205,14 +205,14 @@ impl Path {\n                 self.mod_path.kind.clone(),\n                 self.mod_path.segments[..self.mod_path.segments.len() - 1].iter().cloned(),\n             )),\n-            generic_args: self.generic_args[..self.generic_args.len() - 1].to_vec(),\n+            generic_args: self.generic_args[..self.generic_args.len() - 1].to_vec().into(),\n         };\n         Some(res)\n     }\n \n     pub fn is_self_type(&self) -> bool {\n         self.type_anchor.is_none()\n-            && self.generic_args == [None]\n+            && *self.generic_args == [None]\n             && self.mod_path.as_ident() == Some(&name!(Self))\n     }\n }\n@@ -286,7 +286,7 @@ impl From<Name> for Path {\n         Path {\n             type_anchor: None,\n             mod_path: Interned::new(ModPath::from_segments(PathKind::Plain, iter::once(name))),\n-            generic_args: vec![None],\n+            generic_args: Box::new([None]),\n         }\n     }\n }"}, {"sha": "c84cd50ce6e6c0424ec1a02f28a1574cdb9d370d", "filename": "crates/hir_def/src/path/lower.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f2707bce362f33caad4f5d25c09dd4acfa7df717/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2707bce362f33caad4f5d25c09dd4acfa7df717/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs?ref=f2707bce362f33caad4f5d25c09dd4acfa7df717", "patch": "@@ -70,18 +70,13 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx) -> Option<Path> {\n                     }\n                     // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n                     Some(trait_ref) => {\n-                        let path = Path::from_src(trait_ref.path()?, ctx)?;\n-                        let mod_path = (*path.mod_path).clone();\n-                        let num_segments = path.mod_path.segments.len();\n+                        let Path { mod_path, generic_args: path_generic_args, .. } =\n+                            Path::from_src(trait_ref.path()?, ctx)?;\n+                        let num_segments = mod_path.segments.len();\n                         kind = mod_path.kind;\n \n-                        let mut prefix_segments = mod_path.segments;\n-                        prefix_segments.reverse();\n-                        segments.extend(prefix_segments);\n-\n-                        let mut prefix_args = path.generic_args;\n-                        prefix_args.reverse();\n-                        generic_args.extend(prefix_args);\n+                        segments.extend(mod_path.segments.iter().cloned().rev());\n+                        generic_args.extend(path_generic_args.iter().cloned().rev());\n \n                         // Insert the type reference (T in the above example) as Self parameter for the trait\n                         let last_segment =\n@@ -139,7 +134,7 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx) -> Option<Path> {\n     }\n \n     let mod_path = Interned::new(ModPath::from_segments(kind, segments));\n-    return Some(Path { type_anchor, mod_path, generic_args });\n+    return Some(Path { type_anchor, mod_path, generic_args: generic_args.into() });\n \n     fn qualifier(path: &ast::Path) -> Option<ast::Path> {\n         if let Some(q) = path.qualifier() {"}, {"sha": "195c53c17e211fb3a2f514e53a2f87b4a668e51a", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f2707bce362f33caad4f5d25c09dd4acfa7df717/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2707bce362f33caad4f5d25c09dd4acfa7df717/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=f2707bce362f33caad4f5d25c09dd4acfa7df717", "patch": "@@ -202,19 +202,16 @@ impl ExprValidator {\n         }\n \n         let is_method_call = matches!(expr, Expr::MethodCall { .. });\n-        let (sig, args) = match expr {\n+        let (sig, mut arg_count) = match expr {\n             Expr::Call { callee, args } => {\n                 let callee = &self.infer.type_of_expr[*callee];\n                 let sig = match callee.callable_sig(db) {\n                     Some(sig) => sig,\n                     None => return,\n                 };\n-                (sig, args.clone())\n+                (sig, args.len())\n             }\n             Expr::MethodCall { receiver, args, .. } => {\n-                let mut args = args.clone();\n-                args.insert(0, *receiver);\n-\n                 let receiver = &self.infer.type_of_expr[*receiver];\n                 if receiver.strip_references().is_unknown() {\n                     // if the receiver is of unknown type, it's very likely we\n@@ -229,7 +226,7 @@ impl ExprValidator {\n                 };\n                 let sig = db.callable_item_signature(callee.into()).substitute(&Interner, &subst);\n \n-                (sig, args)\n+                (sig, args.len() + 1)\n             }\n             _ => return,\n         };\n@@ -241,7 +238,6 @@ impl ExprValidator {\n         let params = sig.params();\n \n         let mut param_count = params.len();\n-        let mut arg_count = args.len();\n \n         if arg_count != param_count {\n             if is_method_call {"}, {"sha": "5fb227c0e4986d66deb0e7e5e8aa5efdcb031e91", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2707bce362f33caad4f5d25c09dd4acfa7df717/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2707bce362f33caad4f5d25c09dd4acfa7df717/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=f2707bce362f33caad4f5d25c09dd4acfa7df717", "patch": "@@ -375,7 +375,7 @@ impl<'a> InferenceContext<'a> {\n                 let matchee_diverges = self.diverges;\n                 let mut all_arms_diverge = Diverges::Always;\n \n-                for arm in arms {\n+                for arm in arms.iter() {\n                     self.diverges = Diverges::Maybe;\n                     let _pat_ty = self.infer_pat(arm.pat, &input_ty, BindingMode::default());\n                     match arm.guard {"}, {"sha": "cc919327457aad2e46159f245a83458b57376075", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2707bce362f33caad4f5d25c09dd4acfa7df717/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2707bce362f33caad4f5d25c09dd4acfa7df717/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=f2707bce362f33caad4f5d25c09dd4acfa7df717", "patch": "@@ -226,17 +226,17 @@ impl<'a> InferenceContext<'a> {\n                     _ => self.err_ty(),\n                 };\n \n-                for pat_id in prefix.iter().chain(suffix) {\n-                    self.infer_pat(*pat_id, &elem_ty, default_bm);\n+                for &pat_id in prefix.iter().chain(suffix.iter()) {\n+                    self.infer_pat(pat_id, &elem_ty, default_bm);\n                 }\n \n                 let pat_ty = match expected.kind(&Interner) {\n                     TyKind::Array(_, const_) => TyKind::Array(elem_ty, const_.clone()),\n                     _ => TyKind::Slice(elem_ty),\n                 }\n                 .intern(&Interner);\n-                if let Some(slice_pat_id) = slice {\n-                    self.infer_pat(*slice_pat_id, &pat_ty, default_bm);\n+                if let &Some(slice_pat_id) = slice {\n+                    self.infer_pat(slice_pat_id, &pat_ty, default_bm);\n                 }\n \n                 pat_ty"}]}