{"sha": "3924dac7bb29bc8eb348059c901e8f912399c857", "node_id": "C_kwDOAAsO6NoAKDM5MjRkYWM3YmIyOWJjOGViMzQ4MDU5YzkwMWU4ZjkxMjM5OWM4NTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-29T18:44:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-29T18:44:53Z"}, "message": "Auto merge of #99577 - est31:remove_box_librustdoc, r=jsha\n\nRemove remaining uses of box syntax from librustdoc\n\nRemove the remaining uses of box syntax from librustdoc. Followup of #99066 where these changes were split out because they were responsible for a small but noticeable regression. This PR avoids the regression by boxing some large variants of `ItemKind` to reduce the enum's size by half from 224 bytes to 112 bytes (on x86-64). This should also help with reducing memory usage.", "tree": {"sha": "df1528b681e283e23213ee4cb98c83622f0aebbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df1528b681e283e23213ee4cb98c83622f0aebbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3924dac7bb29bc8eb348059c901e8f912399c857", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3924dac7bb29bc8eb348059c901e8f912399c857", "html_url": "https://github.com/rust-lang/rust/commit/3924dac7bb29bc8eb348059c901e8f912399c857", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3924dac7bb29bc8eb348059c901e8f912399c857/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5dda74a48cd50de10539478c1e0b6699bfdab665", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dda74a48cd50de10539478c1e0b6699bfdab665", "html_url": "https://github.com/rust-lang/rust/commit/5dda74a48cd50de10539478c1e0b6699bfdab665"}, {"sha": "fabb4b0661c1ece43d7e0011c88f9ae225691608", "url": "https://api.github.com/repos/rust-lang/rust/commits/fabb4b0661c1ece43d7e0011c88f9ae225691608", "html_url": "https://github.com/rust-lang/rust/commit/fabb4b0661c1ece43d7e0011c88f9ae225691608"}], "stats": {"total": 131, "additions": 67, "deletions": 64}, "files": [{"sha": "5fe2c9ab4e37b3bd607a46cce346d437f7f9e569", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=3924dac7bb29bc8eb348059c901e8f912399c857", "patch": "@@ -117,15 +117,15 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             attrs: Default::default(),\n             visibility: Inherited,\n             item_id: ItemId::Auto { trait_: trait_def_id, for_: item_def_id },\n-            kind: Box::new(ImplItem(Impl {\n+            kind: Box::new(ImplItem(Box::new(Impl {\n                 unsafety: hir::Unsafety::Normal,\n                 generics: new_generics,\n                 trait_: Some(trait_ref.clean(self.cx)),\n                 for_: clean_middle_ty(ty, self.cx, None),\n                 items: Vec::new(),\n                 polarity,\n                 kind: ImplKind::Auto,\n-            })),\n+            }))),\n             cfg: None,\n         })\n     }"}, {"sha": "8aecd9b15e842e2c95253f3da4dc71e917458bf2", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=3924dac7bb29bc8eb348059c901e8f912399c857", "patch": "@@ -106,7 +106,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                         attrs: Default::default(),\n                         visibility: Inherited,\n                         item_id: ItemId::Blanket { impl_id: impl_def_id, for_: item_def_id },\n-                        kind: Box::new(ImplItem(Impl {\n+                        kind: Box::new(ImplItem(Box::new(Impl {\n                             unsafety: hir::Unsafety::Normal,\n                             generics: clean_ty_generics(\n                                 cx,\n@@ -124,7 +124,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                                 .collect::<Vec<_>>(),\n                             polarity: ty::ImplPolarity::Positive,\n                             kind: ImplKind::Blanket(Box::new(clean_middle_ty(trait_ref.0.self_ty(), cx, None))),\n-                        })),\n+                        }))),\n                         cfg: None,\n                     });\n                 }"}, {"sha": "55d77a63f61418d19f51e0443f61501720019651", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=3924dac7bb29bc8eb348059c901e8f912399c857", "patch": "@@ -218,7 +218,7 @@ pub(crate) fn build_external_trait(cx: &mut DocContext<'_>, did: DefId) -> clean\n     clean::Trait { def_id: did, generics, items: trait_items, bounds: supertrait_bounds }\n }\n \n-fn build_external_function<'tcx>(cx: &mut DocContext<'tcx>, did: DefId) -> clean::Function {\n+fn build_external_function<'tcx>(cx: &mut DocContext<'tcx>, did: DefId) -> Box<clean::Function> {\n     let sig = cx.tcx.fn_sig(did);\n \n     let predicates = cx.tcx.predicates_of(did);\n@@ -228,7 +228,7 @@ fn build_external_function<'tcx>(cx: &mut DocContext<'tcx>, did: DefId) -> clean\n         let decl = clean_fn_decl_from_did_and_sig(cx, Some(did), sig);\n         (generics, decl)\n     });\n-    clean::Function { decl, generics }\n+    Box::new(clean::Function { decl, generics })\n }\n \n fn build_enum(cx: &mut DocContext<'_>, did: DefId) -> clean::Enum {\n@@ -260,15 +260,15 @@ fn build_union(cx: &mut DocContext<'_>, did: DefId) -> clean::Union {\n     clean::Union { generics, fields }\n }\n \n-fn build_type_alias(cx: &mut DocContext<'_>, did: DefId) -> clean::Typedef {\n+fn build_type_alias(cx: &mut DocContext<'_>, did: DefId) -> Box<clean::Typedef> {\n     let predicates = cx.tcx.explicit_predicates_of(did);\n     let type_ = clean_middle_ty(cx.tcx.type_of(did), cx, Some(did));\n \n-    clean::Typedef {\n+    Box::new(clean::Typedef {\n         type_,\n         generics: clean_ty_generics(cx, cx.tcx.generics_of(did), predicates),\n         item_type: None,\n-    }\n+    })\n }\n \n /// Builds all inherent implementations of an ADT (struct/union/enum) or Trait item/path/reexport.\n@@ -493,7 +493,7 @@ pub(crate) fn build_impl(\n     ret.push(clean::Item::from_def_id_and_attrs_and_parts(\n         did,\n         None,\n-        clean::ImplItem(clean::Impl {\n+        clean::ImplItem(Box::new(clean::Impl {\n             unsafety: hir::Unsafety::Normal,\n             generics,\n             trait_,\n@@ -505,7 +505,7 @@ pub(crate) fn build_impl(\n             } else {\n                 ImplKind::Normal\n             },\n-        }),\n+        })),\n         Box::new(merged_attrs),\n         cx,\n         cfg,\n@@ -538,7 +538,7 @@ fn build_module(\n                     attrs: Box::new(clean::Attributes::default()),\n                     item_id: ItemId::Primitive(prim_ty, did.krate),\n                     visibility: clean::Public,\n-                    kind: box clean::ImportItem(clean::Import::new_simple(\n+                    kind: Box::new(clean::ImportItem(clean::Import::new_simple(\n                         item.ident.name,\n                         clean::ImportSource {\n                             path: clean::Path {\n@@ -554,7 +554,7 @@ fn build_module(\n                             did: None,\n                         },\n                         true,\n-                    )),\n+                    ))),\n                     cfg: None,\n                 });\n             } else if let Some(i) = try_inline(cx, did, None, res, item.ident.name, None, visited) {"}, {"sha": "10676aca480dd2506c1fc2791874fb3e1aaf13f5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3924dac7bb29bc8eb348059c901e8f912399c857", "patch": "@@ -908,15 +908,15 @@ fn clean_function<'tcx>(\n     sig: &hir::FnSig<'tcx>,\n     generics: &hir::Generics<'tcx>,\n     body_id: hir::BodyId,\n-) -> Function {\n+) -> Box<Function> {\n     let (generics, decl) = enter_impl_trait(cx, |cx| {\n         // NOTE: generics must be cleaned before args\n         let generics = generics.clean(cx);\n         let args = clean_args_from_types_and_body_id(cx, sig.decl.inputs, body_id);\n         let decl = clean_fn_decl_with_args(cx, sig.decl, args);\n         (generics, decl)\n     });\n-    Function { decl, generics }\n+    Box::new(Function { decl, generics })\n }\n \n fn clean_args_from_types_and_names<'tcx>(\n@@ -1061,18 +1061,18 @@ impl<'tcx> Clean<'tcx, Item> for hir::TraitItem<'tcx> {\n                         let decl = clean_fn_decl_with_args(cx, sig.decl, args);\n                         (generics, decl)\n                     });\n-                    TyMethodItem(Function { decl, generics })\n+                    TyMethodItem(Box::new(Function { decl, generics }))\n                 }\n                 hir::TraitItemKind::Type(bounds, Some(default)) => {\n                     let generics = enter_impl_trait(cx, |cx| self.generics.clean(cx));\n                     let bounds = bounds.iter().filter_map(|x| x.clean(cx)).collect();\n                     let item_type = clean_middle_ty(hir_ty_to_ty(cx.tcx, default), cx, None);\n                     AssocTypeItem(\n-                        Typedef {\n+                        Box::new(Typedef {\n                             type_: clean_ty(default, cx),\n                             generics,\n                             item_type: Some(item_type),\n-                        },\n+                        }),\n                         bounds,\n                     )\n                 }\n@@ -1109,7 +1109,7 @@ impl<'tcx> Clean<'tcx, Item> for hir::ImplItem<'tcx> {\n                     let generics = self.generics.clean(cx);\n                     let item_type = clean_middle_ty(hir_ty_to_ty(cx.tcx, hir_ty), cx, None);\n                     AssocTypeItem(\n-                        Typedef { type_, generics, item_type: Some(item_type) },\n+                        Box::new(Typedef { type_, generics, item_type: Some(item_type) }),\n                         Vec::new(),\n                     )\n                 }\n@@ -1186,9 +1186,9 @@ impl<'tcx> Clean<'tcx, Item> for ty::AssocItem {\n                         ty::ImplContainer(_) => Some(self.defaultness),\n                         ty::TraitContainer(_) => None,\n                     };\n-                    MethodItem(Function { generics, decl }, defaultness)\n+                    MethodItem(Box::new(Function { generics, decl }), defaultness)\n                 } else {\n-                    TyMethodItem(Function { generics, decl })\n+                    TyMethodItem(Box::new(Function { generics, decl }))\n                 }\n             }\n             ty::AssocKind::Type => {\n@@ -1282,7 +1282,7 @@ impl<'tcx> Clean<'tcx, Item> for ty::AssocItem {\n \n                     if self.defaultness.has_value() {\n                         AssocTypeItem(\n-                            Typedef {\n+                            Box::new(Typedef {\n                                 type_: clean_middle_ty(\n                                     tcx.type_of(self.def_id),\n                                     cx,\n@@ -1291,7 +1291,7 @@ impl<'tcx> Clean<'tcx, Item> for ty::AssocItem {\n                                 generics,\n                                 // FIXME: should we obtain the Type from HIR and pass it on here?\n                                 item_type: None,\n-                            },\n+                            }),\n                             bounds,\n                         )\n                     } else {\n@@ -1300,11 +1300,11 @@ impl<'tcx> Clean<'tcx, Item> for ty::AssocItem {\n                 } else {\n                     // FIXME: when could this happen? Associated items in inherent impls?\n                     AssocTypeItem(\n-                        Typedef {\n+                        Box::new(Typedef {\n                             type_: clean_middle_ty(tcx.type_of(self.def_id), cx, Some(self.def_id)),\n                             generics: Generics { params: Vec::new(), where_predicates: Vec::new() },\n                             item_type: None,\n-                        },\n+                        }),\n                         Vec::new(),\n                     )\n                 }\n@@ -1949,11 +1949,11 @@ fn clean_maybe_renamed_item<'tcx>(\n             ItemKind::TyAlias(hir_ty, generics) => {\n                 let rustdoc_ty = clean_ty(hir_ty, cx);\n                 let ty = clean_middle_ty(hir_ty_to_ty(cx.tcx, hir_ty), cx, None);\n-                TypedefItem(Typedef {\n+                TypedefItem(Box::new(Typedef {\n                     type_: rustdoc_ty,\n                     generics: generics.clean(cx),\n                     item_type: Some(ty),\n-                })\n+                }))\n             }\n             ItemKind::Enum(ref def, generics) => EnumItem(Enum {\n                 variants: def.variants.iter().map(|v| v.clean(cx)).collect(),\n@@ -2041,7 +2041,7 @@ fn clean_impl<'tcx>(\n         _ => None,\n     });\n     let mut make_item = |trait_: Option<Path>, for_: Type, items: Vec<Item>| {\n-        let kind = ImplItem(Impl {\n+        let kind = ImplItem(Box::new(Impl {\n             unsafety: impl_.unsafety,\n             generics: impl_.generics.clean(cx),\n             trait_,\n@@ -2053,7 +2053,7 @@ fn clean_impl<'tcx>(\n             } else {\n                 ImplKind::Normal\n             },\n-        });\n+        }));\n         Item::from_hir_id_and_parts(hir_id, None, kind, cx)\n     };\n     if let Some(type_alias) = type_alias {\n@@ -2108,7 +2108,7 @@ fn clean_extern_crate<'tcx>(\n         attrs: Box::new(attrs.clean(cx)),\n         item_id: crate_def_id.into(),\n         visibility: clean_visibility(ty_vis),\n-        kind: box ExternCrateItem { src: orig_name },\n+        kind: Box::new(ExternCrateItem { src: orig_name }),\n         cfg: attrs.cfg(cx.tcx, &cx.cache.hidden_cfg),\n     }]\n }\n@@ -2243,7 +2243,7 @@ fn clean_maybe_renamed_foreign_item<'tcx>(\n                     let decl = clean_fn_decl_with_args(cx, decl, args);\n                     (generics, decl)\n                 });\n-                ForeignFunctionItem(Function { decl, generics })\n+                ForeignFunctionItem(Box::new(Function { decl, generics }))\n             }\n             hir::ForeignItemKind::Static(ty, mutability) => {\n                 ForeignStaticItem(Static { type_: clean_ty(ty, cx), mutability, expr: None })"}, {"sha": "d022ce9696ad0a9c794a16acd974c3cc63653c4a", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=3924dac7bb29bc8eb348059c901e8f912399c857", "patch": "@@ -430,8 +430,8 @@ impl Item {\n         };\n         match kind {\n             ItemKind::ModuleItem(Module { span, .. }) => *span,\n-            ItemKind::ImplItem(Impl { kind: ImplKind::Auto, .. }) => Span::dummy(),\n-            ItemKind::ImplItem(Impl { kind: ImplKind::Blanket(_), .. }) => {\n+            ItemKind::ImplItem(box Impl { kind: ImplKind::Auto, .. }) => Span::dummy(),\n+            ItemKind::ImplItem(box Impl { kind: ImplKind::Blanket(_), .. }) => {\n                 if let ItemId::Blanket { impl_id, .. } = self.item_id {\n                     rustc_span(impl_id, tcx)\n                 } else {\n@@ -502,7 +502,7 @@ impl Item {\n             clean_visibility(cx.tcx.visibility(def_id))\n         };\n \n-        Item { item_id: def_id.into(), kind: box kind, name, attrs, visibility, cfg }\n+        Item { item_id: def_id.into(), kind: Box::new(kind), name, attrs, visibility, cfg }\n     }\n \n     /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n@@ -730,25 +730,25 @@ pub(crate) enum ItemKind {\n     StructItem(Struct),\n     UnionItem(Union),\n     EnumItem(Enum),\n-    FunctionItem(Function),\n+    FunctionItem(Box<Function>),\n     ModuleItem(Module),\n-    TypedefItem(Typedef),\n+    TypedefItem(Box<Typedef>),\n     OpaqueTyItem(OpaqueTy),\n     StaticItem(Static),\n     ConstantItem(Constant),\n     TraitItem(Trait),\n     TraitAliasItem(TraitAlias),\n-    ImplItem(Impl),\n+    ImplItem(Box<Impl>),\n     /// A required method in a trait declaration meaning it's only a function signature.\n-    TyMethodItem(Function),\n+    TyMethodItem(Box<Function>),\n     /// A method in a trait impl or a provided method in a trait declaration.\n     ///\n     /// Compared to [TyMethodItem], it also contains a method body.\n-    MethodItem(Function, Option<hir::Defaultness>),\n+    MethodItem(Box<Function>, Option<hir::Defaultness>),\n     StructFieldItem(Type),\n     VariantItem(Variant),\n     /// `fn`s from an extern block\n-    ForeignFunctionItem(Function),\n+    ForeignFunctionItem(Box<Function>),\n     /// `static`s from an extern block\n     ForeignStaticItem(Static),\n     /// `type`s from an extern block\n@@ -765,12 +765,16 @@ pub(crate) enum ItemKind {\n     /// The bounds may be non-empty if there is a `where` clause.\n     TyAssocTypeItem(Box<Generics>, Vec<GenericBound>),\n     /// An associated type in a trait impl or a provided one in a trait declaration.\n-    AssocTypeItem(Typedef, Vec<GenericBound>),\n+    AssocTypeItem(Box<Typedef>, Vec<GenericBound>),\n     /// An item that has been stripped by a rustdoc pass\n     StrippedItem(Box<ItemKind>),\n     KeywordItem,\n }\n \n+// `ItemKind` is an enum and large variants can bloat up memory usage even for smaller ones\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+rustc_data_structures::static_assert_size!(ItemKind, 112);\n+\n impl ItemKind {\n     /// Some items contain others such as structs (for their fields) and Enums\n     /// (for their variants). This method returns those contained items."}, {"sha": "213f564ce2db593adcf111041aefdba1d48bf7b6", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=3924dac7bb29bc8eb348059c901e8f912399c857", "patch": "@@ -740,7 +740,7 @@ fn check_if_attr_is_complete(source: &str, edition: Edition) -> bool {\n                 rustc_errors::fallback_fluent_bundle(rustc_errors::DEFAULT_LOCALE_RESOURCES, false);\n \n             let emitter = EmitterWriter::new(\n-                box io::sink(),\n+                Box::new(io::sink()),\n                 None,\n                 None,\n                 fallback_bundle,\n@@ -751,7 +751,7 @@ fn check_if_attr_is_complete(source: &str, edition: Edition) -> bool {\n                 false,\n             );\n \n-            let handler = Handler::with_emitter(false, None, box emitter);\n+            let handler = Handler::with_emitter(false, None, Box::new(emitter));\n             let sess = ParseSess::with_span_handler(handler, sm);\n             let mut parser =\n                 match maybe_new_parser_from_source_str(&sess, filename, source.to_owned()) {"}, {"sha": "6b7e67e2ce34269eca68fdf136a10016c10a4587", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=3924dac7bb29bc8eb348059c901e8f912399c857", "patch": "@@ -2,7 +2,7 @@ use crate::clean::*;\n \n pub(crate) fn strip_item(mut item: Item) -> Item {\n     if !matches!(*item.kind, StrippedItem(..)) {\n-        item.kind = box StrippedItem(item.kind);\n+        item.kind = Box::new(StrippedItem(item.kind));\n     }\n     item\n }\n@@ -75,10 +75,10 @@ pub(crate) trait DocFolder: Sized {\n \n     /// don't override!\n     fn fold_item_recur(&mut self, mut item: Item) -> Item {\n-        item.kind = box match *item.kind {\n-            StrippedItem(box i) => StrippedItem(box self.fold_inner_recur(i)),\n+        item.kind = Box::new(match *item.kind {\n+            StrippedItem(box i) => StrippedItem(Box::new(self.fold_inner_recur(i))),\n             _ => self.fold_inner_recur(*item.kind),\n-        };\n+        });\n         item\n     }\n "}, {"sha": "2b2691e53bbcc900a01f2297a2f44dc82992f5cc", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=3924dac7bb29bc8eb348059c901e8f912399c857", "patch": "@@ -536,7 +536,7 @@ enum ParentStackItem {\n impl ParentStackItem {\n     fn new(item: &clean::Item) -> Self {\n         match &*item.kind {\n-            clean::ItemKind::ImplItem(clean::Impl { for_, trait_, generics, kind, .. }) => {\n+            clean::ItemKind::ImplItem(box clean::Impl { for_, trait_, generics, kind, .. }) => {\n                 ParentStackItem::Impl {\n                     for_: for_.clone(),\n                     trait_: trait_.clone(),"}, {"sha": "a262c8f7d1948657041bbbba1d392a042a182ace", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=3924dac7bb29bc8eb348059c901e8f912399c857", "patch": "@@ -1160,7 +1160,7 @@ fn render_deref_methods(\n         .items\n         .iter()\n         .find_map(|item| match *item.kind {\n-            clean::AssocTypeItem(ref t, _) => Some(match *t {\n+            clean::AssocTypeItem(box ref t, _) => Some(match *t {\n                 clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n                 _ => (&t.type_, &t.type_),\n             }),\n@@ -2054,7 +2054,7 @@ fn sidebar_deref_methods(\n     debug!(\"found Deref: {:?}\", impl_);\n     if let Some((target, real_target)) =\n         impl_.inner_impl().items.iter().find_map(|item| match *item.kind {\n-            clean::AssocTypeItem(ref t, _) => Some(match *t {\n+            clean::AssocTypeItem(box ref t, _) => Some(match *t {\n                 clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n                 _ => (&t.type_, &t.type_),\n             }),"}, {"sha": "716a4c9ea4319d1d56ab74535fab1465f4b75bde", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=3924dac7bb29bc8eb348059c901e8f912399c857", "patch": "@@ -568,10 +568,10 @@ impl FromWithTcx<clean::Trait> for Trait {\n     }\n }\n \n-impl FromWithTcx<clean::Impl> for Impl {\n-    fn from_tcx(impl_: clean::Impl, tcx: TyCtxt<'_>) -> Self {\n+impl FromWithTcx<Box<clean::Impl>> for Impl {\n+    fn from_tcx(impl_: Box<clean::Impl>, tcx: TyCtxt<'_>) -> Self {\n         let provided_trait_methods = impl_.provided_trait_methods(tcx);\n-        let clean::Impl { unsafety, generics, trait_, for_, items, polarity, kind } = impl_;\n+        let clean::Impl { unsafety, generics, trait_, for_, items, polarity, kind } = *impl_;\n         // FIXME: should `trait_` be a clean::Path equivalent in JSON?\n         let trait_ = trait_.map(|path| clean::Type::Path { path }.into_tcx(tcx));\n         // FIXME: use something like ImplKind in JSON?\n@@ -602,11 +602,11 @@ impl FromWithTcx<clean::Impl> for Impl {\n }\n \n pub(crate) fn from_function(\n-    function: clean::Function,\n+    function: Box<clean::Function>,\n     header: rustc_hir::FnHeader,\n     tcx: TyCtxt<'_>,\n ) -> Function {\n-    let clean::Function { decl, generics } = function;\n+    let clean::Function { decl, generics } = *function;\n     Function {\n         decl: decl.into_tcx(tcx),\n         generics: generics.into_tcx(tcx),\n@@ -615,12 +615,12 @@ pub(crate) fn from_function(\n }\n \n pub(crate) fn from_function_method(\n-    function: clean::Function,\n+    function: Box<clean::Function>,\n     has_body: bool,\n     header: rustc_hir::FnHeader,\n     tcx: TyCtxt<'_>,\n ) -> Method {\n-    let clean::Function { decl, generics } = function;\n+    let clean::Function { decl, generics } = *function;\n     Method {\n         decl: decl.into_tcx(tcx),\n         generics: generics.into_tcx(tcx),\n@@ -721,9 +721,9 @@ pub(crate) fn from_macro_kind(kind: rustc_span::hygiene::MacroKind) -> MacroKind\n     }\n }\n \n-impl FromWithTcx<clean::Typedef> for Typedef {\n-    fn from_tcx(typedef: clean::Typedef, tcx: TyCtxt<'_>) -> Self {\n-        let clean::Typedef { type_, generics, item_type: _ } = typedef;\n+impl FromWithTcx<Box<clean::Typedef>> for Typedef {\n+    fn from_tcx(typedef: Box<clean::Typedef>, tcx: TyCtxt<'_>) -> Self {\n+        let clean::Typedef { type_, generics, item_type: _ } = *typedef;\n         Typedef { type_: type_.into_tcx(tcx), generics: generics.into_tcx(tcx) }\n     }\n }"}, {"sha": "0fe720e70cf0fe37dec340cc3810e6ffb7df3e33", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=3924dac7bb29bc8eb348059c901e8f912399c857", "patch": "@@ -7,7 +7,6 @@\n #![feature(assert_matches)]\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n-#![feature(box_syntax)]\n #![feature(drain_filter)]\n #![cfg_attr(bootstrap, feature(let_chains))]\n #![feature(let_else)]"}, {"sha": "e86f9083394cf55a4857e4cea93621803428043b", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=3924dac7bb29bc8eb348059c901e8f912399c857", "patch": "@@ -71,7 +71,7 @@ pub(crate) fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -\n                 | clean::PrimitiveItem(_)\n                 | clean::KeywordItem\n                 // check for trait impl\n-                | clean::ImplItem(clean::Impl { trait_: Some(_), .. })\n+                | clean::ImplItem(box clean::Impl { trait_: Some(_), .. })\n         )\n     {\n         return false;"}, {"sha": "6b699c7901434c8afe5a2bf37e2a4c2cc6977bf2", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3924dac7bb29bc8eb348059c901e8f912399c857/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=3924dac7bb29bc8eb348059c901e8f912399c857", "patch": "@@ -146,7 +146,7 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n \n     // scan through included items ahead of time to splice in Deref targets to the \"valid\" sets\n     for it in new_items_external.iter().chain(new_items_local.iter()) {\n-        if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = *it.kind {\n+        if let ImplItem(box Impl { ref for_, ref trait_, ref items, .. }) = *it.kind {\n             if trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait()\n                 && cleaner.keep_impl(for_, true)\n             {\n@@ -187,7 +187,7 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n \n     // Filter out external items that are not needed\n     new_items_external.retain(|it| {\n-        if let ImplItem(Impl { ref for_, ref trait_, ref kind, .. }) = *it.kind {\n+        if let ImplItem(box Impl { ref for_, ref trait_, ref kind, .. }) = *it.kind {\n             cleaner.keep_impl(\n                 for_,\n                 trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait(),"}]}