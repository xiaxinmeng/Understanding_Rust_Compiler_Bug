{"sha": "034018cd9036ae3375e9b59d940b98b6aec766da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzNDAxOGNkOTAzNmFlMzM3NWU5YjU5ZDk0MGI5OGI2YWVjNzY2ZGE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-05T19:46:58Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-16T10:57:44Z"}, "message": "rustfmt `lexical_region_resolve`", "tree": {"sha": "0c6c0b73c2c1e627ea92e5368276f6b6f9e270ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c6c0b73c2c1e627ea92e5368276f6b6f9e270ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/034018cd9036ae3375e9b59d940b98b6aec766da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/034018cd9036ae3375e9b59d940b98b6aec766da", "html_url": "https://github.com/rust-lang/rust/commit/034018cd9036ae3375e9b59d940b98b6aec766da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/034018cd9036ae3375e9b59d940b98b6aec766da/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1430a600ded4b3697fee8ce16fdb6714dbbc06ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/1430a600ded4b3697fee8ce16fdb6714dbbc06ba", "html_url": "https://github.com/rust-lang/rust/commit/1430a600ded4b3697fee8ce16fdb6714dbbc06ba"}], "stats": {"total": 56, "additions": 24, "deletions": 32}, "files": [{"sha": "0692d284d7c16eb4f106397a18b670cfb4f3d22f", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 24, "deletions": 32, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/034018cd9036ae3375e9b59d940b98b6aec766da/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034018cd9036ae3375e9b59d940b98b6aec766da/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=034018cd9036ae3375e9b59d940b98b6aec766da", "patch": "@@ -38,14 +38,18 @@ mod graphviz;\n pub fn resolve<'tcx>(\n     region_rels: &RegionRelations<'_, '_, 'tcx>,\n     var_origins: VarOrigins,\n-    data: RegionConstraintData<'tcx>\n+    data: RegionConstraintData<'tcx>,\n ) -> (\n     LexicalRegionResolutions<'tcx>,\n     Vec<RegionResolutionError<'tcx>>,\n ) {\n     debug!(\"RegionConstraintData: resolve_regions()\");\n     let mut errors = vec![];\n-    let mut resolver = LexicalResolver { region_rels, var_origins, data };\n+    let mut resolver = LexicalResolver {\n+        region_rels,\n+        var_origins,\n+        data,\n+    };\n     let values = resolver.infer_variable_values(&mut errors);\n     (values, errors)\n }\n@@ -100,7 +104,7 @@ type RegionGraph<'tcx> = graph::Graph<(), Constraint<'tcx>>;\n struct LexicalResolver<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     region_rels: &'cx RegionRelations<'cx, 'gcx, 'tcx>,\n     var_origins: VarOrigins,\n-    data: RegionConstraintData<'tcx>\n+    data: RegionConstraintData<'tcx>,\n }\n \n impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n@@ -165,7 +169,6 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n \n         let seeds: Vec<_> = self.data.givens.iter().cloned().collect();\n         for (r, vid) in seeds {\n-\n             // While all things transitively reachable in the graph\n             // from the variable (`'0` in the example above).\n             let seed_index = NodeIndex(vid.index as usize);\n@@ -185,10 +188,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn expansion(\n-        &self,\n-        var_values: &mut LexicalRegionResolutions<'tcx>,\n-    ) {\n+    fn expansion(&self, var_values: &mut LexicalRegionResolutions<'tcx>) {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint, origin| {\n             debug!(\"expansion: constraint={:?} origin={:?}\", constraint, origin);\n             match *constraint {\n@@ -222,12 +222,11 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n \n         // Check if this relationship is implied by a given.\n         match *a_region {\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n-                if self.data.givens.contains(&(a_region, b_vid)) {\n-                    debug!(\"given\");\n-                    return false;\n-                }\n-            }\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => if self.data.givens.contains(&(a_region, b_vid))\n+            {\n+                debug!(\"given\");\n+                return false;\n+            },\n             _ => {}\n         }\n \n@@ -256,11 +255,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n     }\n \n \n-    fn lub_concrete_regions(\n-        &self,\n-        a: Region<'tcx>,\n-        b: Region<'tcx>,\n-    ) -> Region<'tcx> {\n+    fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n         let tcx = self.region_rels.tcx;\n         match (a, b) {\n             (&ReLateBound(..), _) | (_, &ReLateBound(..)) | (&ReErased, _) | (_, &ReErased) => {\n@@ -293,12 +288,12 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n                 // at least as big as fr.scope\".  So, we can\n                 // reasonably compare free regions and scopes:\n                 let fr_scope = match (a, b) {\n-                    (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => {\n-                        self.region_rels.region_scope_tree.early_free_scope(self.region_rels.tcx, br)\n-                    }\n-                    (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => {\n-                        self.region_rels.region_scope_tree.free_scope(self.region_rels.tcx, fr)\n-                    }\n+                    (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => self.region_rels\n+                        .region_scope_tree\n+                        .early_free_scope(self.region_rels.tcx, br),\n+                    (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => self.region_rels\n+                        .region_scope_tree\n+                        .free_scope(self.region_rels.tcx, fr),\n                     _ => bug!(),\n                 };\n                 let r_id = self.region_rels\n@@ -490,12 +485,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n                        that is not used is not a problem, so if this rule\n                        starts to create problems we'll have to revisit\n                        this portion of the code and think hard about it. =) */\n-                    self.collect_error_for_expanding_node(\n-                        graph,\n-                        &mut dup_vec,\n-                        node_vid,\n-                        errors,\n-                    );\n+                    self.collect_error_for_expanding_node(graph, &mut dup_vec, node_vid, errors);\n                 }\n             }\n         }\n@@ -576,7 +566,9 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n \n         for lower_bound in &lower_bounds {\n             for upper_bound in &upper_bounds {\n-                if !self.region_rels.is_subregion_of(lower_bound.region, upper_bound.region) {\n+                if !self.region_rels\n+                    .is_subregion_of(lower_bound.region, upper_bound.region)\n+                {\n                     let origin = self.var_origins[node_idx].clone();\n                     debug!(\n                         \"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\"}]}