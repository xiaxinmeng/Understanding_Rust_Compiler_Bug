{"sha": "c6c8693b4c2c6a63a86478112ff617a67e1f6bf6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2Yzg2OTNiNGMyYzZhNjNhODY0NzgxMTJmZjYxN2E2N2UxZjZiZjY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-26T16:56:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-26T16:56:52Z"}, "message": "Rollup merge of #62956 - ia0:fix_62831, r=petrochenkov\n\nImplement slow-path for FirstSets::first\n\nWhen 2 or more sequences share the same span, we can't use the precomputed map\nfor their first set. So we compute it recursively.\n\nFixes #62831.", "tree": {"sha": "52ad0fa8395e630d9b91c82ad1cb68bf3debb986", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52ad0fa8395e630d9b91c82ad1cb68bf3debb986"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6c8693b4c2c6a63a86478112ff617a67e1f6bf6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdOzDUCRBK7hj4Ov3rIwAAdHIIAEYjHJqXF91n7h+uUEb/9laE\nWBvVGimLQXg89ILWeBZEL25La/ZDPEIweHoPzDmzux2BEuidTqjGG/N3zvY2q0Vn\nIm2fXqnsqnQ244BwkQD/aYKhmwbDbbSGzvb3wNtInL14ELz3qUm9+W4sdak4fSGV\nvyYV1rz82ctxczrIrACRU1nS82ow3CTngF/LbzsDkQFHVyMHN0+bt610KR34CeP5\nCMvscWV0Ps3pt8OH7X5RT2T3mnaUoUB0UJh7ry4puTVg1pVFvZcs9D+AmV3lG7k2\nBY7QoiBMHuxrq8VAOmCADYvPjbUESa9u2WrHgUDt/IWx9JeZAHEz3LwkgGdODww=\n=NTYM\n-----END PGP SIGNATURE-----\n", "payload": "tree 52ad0fa8395e630d9b91c82ad1cb68bf3debb986\nparent 183aab3575ebd7c82ce1e982fa335b9a84388d12\nparent df4b23e7212b8f7a3f62f469f666021226e29c17\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1564160212 +0200\ncommitter GitHub <noreply@github.com> 1564160212 +0200\n\nRollup merge of #62956 - ia0:fix_62831, r=petrochenkov\n\nImplement slow-path for FirstSets::first\n\nWhen 2 or more sequences share the same span, we can't use the precomputed map\nfor their first set. So we compute it recursively.\n\nFixes #62831.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6c8693b4c2c6a63a86478112ff617a67e1f6bf6", "html_url": "https://github.com/rust-lang/rust/commit/c6c8693b4c2c6a63a86478112ff617a67e1f6bf6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6c8693b4c2c6a63a86478112ff617a67e1f6bf6/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "183aab3575ebd7c82ce1e982fa335b9a84388d12", "url": "https://api.github.com/repos/rust-lang/rust/commits/183aab3575ebd7c82ce1e982fa335b9a84388d12", "html_url": "https://github.com/rust-lang/rust/commit/183aab3575ebd7c82ce1e982fa335b9a84388d12"}, {"sha": "df4b23e7212b8f7a3f62f469f666021226e29c17", "url": "https://api.github.com/repos/rust-lang/rust/commits/df4b23e7212b8f7a3f62f469f666021226e29c17", "html_url": "https://github.com/rust-lang/rust/commit/df4b23e7212b8f7a3f62f469f666021226e29c17"}], "stats": {"total": 146, "additions": 119, "deletions": 27}, "files": [{"sha": "1731c0f713bad52c355671f254c2200976a4c3c8", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c6c8693b4c2c6a63a86478112ff617a67e1f6bf6/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c8693b4c2c6a63a86478112ff617a67e1f6bf6/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=c6c8693b4c2c6a63a86478112ff617a67e1f6bf6", "patch": "@@ -625,38 +625,37 @@ impl FirstSets {\n                     return first;\n                 }\n                 TokenTree::Sequence(sp, ref seq_rep) => {\n-                    match self.first.get(&sp.entire()) {\n-                        Some(&Some(ref subfirst)) => {\n-                            // If the sequence contents can be empty, then the first\n-                            // token could be the separator token itself.\n-\n-                            if let (Some(sep), true) = (&seq_rep.separator, subfirst.maybe_empty) {\n-                                first.add_one_maybe(TokenTree::Token(sep.clone()));\n-                            }\n-\n-                            assert!(first.maybe_empty);\n-                            first.add_all(subfirst);\n-                            if subfirst.maybe_empty\n-                                || seq_rep.kleene.op == quoted::KleeneOp::ZeroOrMore\n-                                || seq_rep.kleene.op == quoted::KleeneOp::ZeroOrOne\n-                            {\n-                                // continue scanning for more first\n-                                // tokens, but also make sure we\n-                                // restore empty-tracking state\n-                                first.maybe_empty = true;\n-                                continue;\n-                            } else {\n-                                return first;\n-                            }\n-                        }\n-\n+                    let subfirst_owned;\n+                    let subfirst = match self.first.get(&sp.entire()) {\n+                        Some(&Some(ref subfirst)) => subfirst,\n                         Some(&None) => {\n-                            panic!(\"assume all sequences have (unique) spans for now\");\n+                            subfirst_owned = self.first(&seq_rep.tts[..]);\n+                            &subfirst_owned\n                         }\n-\n                         None => {\n                             panic!(\"We missed a sequence during FirstSets construction\");\n                         }\n+                    };\n+\n+                    // If the sequence contents can be empty, then the first\n+                    // token could be the separator token itself.\n+                    if let (Some(sep), true) = (&seq_rep.separator, subfirst.maybe_empty) {\n+                        first.add_one_maybe(TokenTree::Token(sep.clone()));\n+                    }\n+\n+                    assert!(first.maybe_empty);\n+                    first.add_all(subfirst);\n+                    if subfirst.maybe_empty\n+                        || seq_rep.kleene.op == quoted::KleeneOp::ZeroOrMore\n+                        || seq_rep.kleene.op == quoted::KleeneOp::ZeroOrOne\n+                    {\n+                        // Continue scanning for more first\n+                        // tokens, but also make sure we\n+                        // restore empty-tracking state.\n+                        first.maybe_empty = true;\n+                        continue;\n+                    } else {\n+                        return first;\n                     }\n                 }\n             }"}, {"sha": "b50ed7ca92ad5e74a29bb53b86f42b52d80d6408", "filename": "src/test/ui/macros/auxiliary/proc_macro_sequence.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c6c8693b4c2c6a63a86478112ff617a67e1f6bf6/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fproc_macro_sequence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c8693b4c2c6a63a86478112ff617a67e1f6bf6/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fproc_macro_sequence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fproc_macro_sequence.rs?ref=c6c8693b4c2c6a63a86478112ff617a67e1f6bf6", "patch": "@@ -0,0 +1,36 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro_span, proc_macro_hygiene, proc_macro_quote)]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::{quote, Span, TokenStream};\n+\n+fn assert_same_span(a: Span, b: Span) {\n+    assert_eq!(a.start(), b.start());\n+    assert_eq!(a.end(), b.end());\n+}\n+\n+// This macro generates a macro with the same macro definition as `manual_foo` in\n+// `same-sequence-span.rs` but with the same span for all sequences.\n+#[proc_macro]\n+pub fn make_foo(_: TokenStream) -> TokenStream {\n+    let result = quote! {\n+        macro_rules! generated_foo {\n+            (1 $$x:expr $$($$y:tt,)* $$(= $$z:tt)*) => {};\n+        }\n+    };\n+\n+    // Check that all spans are equal.\n+    let mut span = None;\n+    for tt in result.clone() {\n+        match span {\n+            None => span = Some(tt.span()),\n+            Some(span) => assert_same_span(tt.span(), span),\n+        }\n+    }\n+\n+    result\n+}"}, {"sha": "a4f70b6b68d1ee29d8886ec34a7bcb92ae5264e7", "filename": "src/test/ui/macros/same-sequence-span.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c6c8693b4c2c6a63a86478112ff617a67e1f6bf6/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c8693b4c2c6a63a86478112ff617a67e1f6bf6/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.rs?ref=c6c8693b4c2c6a63a86478112ff617a67e1f6bf6", "patch": "@@ -0,0 +1,23 @@\n+// aux-build:proc_macro_sequence.rs\n+\n+// Regression test for issue #62831: Check that multiple sequences with the same span in the\n+// left-hand side of a macro definition behave as if they had unique spans, and in particular that\n+// they don't crash the compiler.\n+\n+#![feature(proc_macro_hygiene)]\n+#![allow(unused_macros)]\n+\n+extern crate proc_macro_sequence;\n+\n+// When ignoring spans, this macro has the same macro definition as `generated_foo` in\n+// `proc_macro_sequence.rs`.\n+macro_rules! manual_foo {\n+    (1 $x:expr $($y:tt,)*   //~ERROR `$x:expr` may be followed by `$y:tt`\n+               $(= $z:tt)*  //~ERROR `$x:expr` may be followed by `=`\n+    ) => {};\n+}\n+\n+proc_macro_sequence::make_foo!(); //~ERROR `$x:expr` may be followed by `$y:tt`\n+                                  //~^ERROR `$x:expr` may be followed by `=`\n+\n+fn main() {}"}, {"sha": "aee1b4c9c5d99a269b72dc6939b9bbfa45630930", "filename": "src/test/ui/macros/same-sequence-span.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c6c8693b4c2c6a63a86478112ff617a67e1f6bf6/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6c8693b4c2c6a63a86478112ff617a67e1f6bf6/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr?ref=c6c8693b4c2c6a63a86478112ff617a67e1f6bf6", "patch": "@@ -0,0 +1,34 @@\n+error: `$x:expr` may be followed by `$y:tt`, which is not allowed for `expr` fragments\n+  --> $DIR/same-sequence-span.rs:15:18\n+   |\n+LL |     (1 $x:expr $($y:tt,)*\n+   |                  ^^^^^ not allowed after `expr` fragments\n+   |\n+   = note: allowed there are: `=>`, `,` or `;`\n+\n+error: `$x:expr` may be followed by `=`, which is not allowed for `expr` fragments\n+  --> $DIR/same-sequence-span.rs:16:18\n+   |\n+LL |                $(= $z:tt)*\n+   |                  ^ not allowed after `expr` fragments\n+   |\n+   = note: allowed there are: `=>`, `,` or `;`\n+\n+error: `$x:expr` may be followed by `$y:tt`, which is not allowed for `expr` fragments\n+  --> $DIR/same-sequence-span.rs:20:1\n+   |\n+LL | proc_macro_sequence::make_foo!();\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not allowed after `expr` fragments\n+   |\n+   = note: allowed there are: `=>`, `,` or `;`\n+\n+error: `$x:expr` may be followed by `=`, which is not allowed for `expr` fragments\n+  --> $DIR/same-sequence-span.rs:20:1\n+   |\n+LL | proc_macro_sequence::make_foo!();\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not allowed after `expr` fragments\n+   |\n+   = note: allowed there are: `=>`, `,` or `;`\n+\n+error: aborting due to 4 previous errors\n+"}]}