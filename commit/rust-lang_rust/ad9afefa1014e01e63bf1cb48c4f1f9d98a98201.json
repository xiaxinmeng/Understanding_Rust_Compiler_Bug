{"sha": "ad9afefa1014e01e63bf1cb48c4f1f9d98a98201", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkOWFmZWZhMTAxNGUwMWU2M2JmMWNiNDhjNGYxZjlkOThhOTgyMDE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-03T01:07:30Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-03T01:11:26Z"}, "message": "rustc: Typecheck patterns from the top down; remove pushdown_pat", "tree": {"sha": "f02b6022cf6b6cbd521a90bec0b6072edc5edad7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f02b6022cf6b6cbd521a90bec0b6072edc5edad7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad9afefa1014e01e63bf1cb48c4f1f9d98a98201", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad9afefa1014e01e63bf1cb48c4f1f9d98a98201", "html_url": "https://github.com/rust-lang/rust/commit/ad9afefa1014e01e63bf1cb48c4f1f9d98a98201", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad9afefa1014e01e63bf1cb48c4f1f9d98a98201/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76bcbfd269891cf22d1f3b1a312fe15717cb7a00", "url": "https://api.github.com/repos/rust-lang/rust/commits/76bcbfd269891cf22d1f3b1a312fe15717cb7a00", "html_url": "https://github.com/rust-lang/rust/commit/76bcbfd269891cf22d1f3b1a312fe15717cb7a00"}], "stats": {"total": 228, "additions": 72, "deletions": 156}, "files": [{"sha": "8d8f0151df247a445284b1de3683f6bb55f05d4b", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 72, "deletions": 156, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/ad9afefa1014e01e63bf1cb48c4f1f9d98a98201/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9afefa1014e01e63bf1cb48c4f1f9d98a98201/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=ad9afefa1014e01e63bf1cb48c4f1f9d98a98201", "patch": "@@ -1098,97 +1098,6 @@ fn variant_arg_types(&@crate_ctxt ccx, &span sp, &ast::def_id vid,\n // directly inside check_expr(). This results in a quadratic algorithm.\n \n mod pushdown {\n-    // Push-down over typed patterns. Note that the pattern that you pass to\n-    // this function must have been passed to check_pat() first.\n-    //\n-    // TODO: enforce this via a predicate.\n-\n-    fn pushdown_pat(&@stmt_ctxt scx, &ty::t expected, &@ast::pat pat) {\n-        alt (pat.node) {\n-            case (ast::pat_wild(?ann)) {\n-                auto t = demand::simple(scx, pat.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n-                write::ty_only_fixup(scx, ann.id, t);\n-            }\n-            case (ast::pat_lit(?lit, ?ann)) {\n-                auto t = demand::simple(scx, pat.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n-                write::ty_only_fixup(scx, ann.id, t);\n-            }\n-            case (ast::pat_bind(?id, ?did, ?ann)) {\n-                auto t = demand::simple(scx, pat.span, expected,\n-                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n-                scx.fcx.locals.insert(did, t);\n-                write::ty_only_fixup(scx, ann.id, t);\n-            }\n-            case (ast::pat_tag(?id, ?subpats, ?ann)) {\n-                // Take the variant's type parameters out of the expected\n-                // type.\n-                auto tag_tps;\n-                alt (struct(scx.fcx.ccx.tcx, expected)) {\n-                    case (ty::ty_tag(_, ?tps)) { tag_tps = tps; }\n-                    case (_) {\n-                        scx.fcx.ccx.tcx.sess.span_err(pat.span,\n-                          \"Non-constructor used in a pattern\");\n-                    }\n-                }\n-\n-                // Get the types of the arguments of the variant.\n-\n-                let vec[ty::t] tparams = [];\n-                auto j = 0u;\n-                auto actual_ty_params =\n-                  ty::ann_to_type_params(scx.fcx.ccx.tcx.node_types, ann);\n-\n-                for (ty::t some_ty in tag_tps) {\n-                    let ty::t t1 = some_ty;\n-                    let ty::t t2 = actual_ty_params.(j);\n-\n-                    let ty::t res = demand::simple(scx, pat.span, t1, t2);\n-\n-                    vec::push(tparams, res);\n-                    j += 1u;\n-                }\n-\n-                auto arg_tys;\n-                alt (scx.fcx.ccx.tcx.def_map.get(ann.id)) {\n-                    case (ast::def_variant(_, ?vdefid)) {\n-                        arg_tys = variant_arg_types(scx.fcx.ccx, pat.span,\n-                                                    vdefid, tparams);\n-                    }\n-                }\n-\n-                auto i = 0u;\n-                for (@ast::pat subpat in subpats) {\n-                    pushdown_pat(scx, arg_tys.(i), subpat);\n-                    i += 1u;\n-                }\n-\n-                auto tps =\n-                    ty::ann_to_type_params(scx.fcx.ccx.tcx.node_types, ann);\n-                auto tt = ann_to_type(scx.fcx.ccx.tcx.node_types, ann);\n-\n-                let ty_param_substs_and_ty res_t = demand::full(scx, pat.span,\n-                      expected, tt, tps, NO_AUTODEREF);\n-\n-                auto ty_params_subst = ty::ann_to_ty_param_substs_opt_and_ty\n-                    (scx.fcx.ccx.tcx.node_types, ann);\n-\n-                auto ty_params_opt;\n-                alt (ty_params_subst._0) {\n-                    case (none) {\n-                        ty_params_opt = none[vec[ty::t]];\n-                    }\n-                    case (some(?tps)) {\n-                        ty_params_opt = some[vec[ty::t]](tag_tps);\n-                    }\n-                }\n-\n-                write::ty_fixup(scx, ann.id, tup(ty_params_opt, tt));\n-            }\n-        }\n-    }\n-\n     // Push-down over typed expressions. Note that the expression that you\n     // pass to this function must have been passed to check_expr() first.\n     //\n@@ -1673,75 +1582,88 @@ fn check_lit(@crate_ctxt ccx, &@ast::lit lit) -> ty::t {\n     fail; // not reached\n }\n \n-fn check_pat(&@stmt_ctxt scx, &@ast::pat pat) {\n+// Pattern checking is top-down rather than bottom-up so that bindings get\n+// their types immediately.\n+fn check_pat(&@stmt_ctxt scx, &@ast::pat pat, ty::t expected) {\n     alt (pat.node) {\n         case (ast::pat_wild(?ann)) {\n-            auto typ = next_ty_var(scx);\n-            write::ty_only_fixup(scx, ann.id, typ);\n+            write::ty_only_fixup(scx, ann.id, expected);\n         }\n         case (ast::pat_lit(?lt, ?ann)) {\n             auto typ = check_lit(scx.fcx.ccx, lt);\n+            typ = demand::simple(scx, pat.span, expected, typ);\n             write::ty_only_fixup(scx, ann.id, typ);\n         }\n-        case (ast::pat_bind(?id, ?def_id, ?a)) {\n-            auto typ = next_ty_var(scx);\n-            write::ty_only_fixup(scx, a.id, typ);\n+        case (ast::pat_bind(?id, ?def_id, ?ann)) {\n+            scx.fcx.locals.insert(def_id, expected);\n+            write::ty_only_fixup(scx, ann.id, expected);\n         }\n-        case (ast::pat_tag(?p, ?subpats, ?old_ann)) {\n-            auto vdef = ast::variant_def_ids\n-                (scx.fcx.ccx.tcx.def_map.get(old_ann.id));\n-            auto t = ty::lookup_item_type(scx.fcx.ccx.tcx,\n-                                          vdef._1)._1;\n-            auto len = vec::len[ast::ident](p.node.idents);\n-            auto last_id = p.node.idents.(len - 1u);\n-\n-            auto tpt = ty::lookup_item_type(scx.fcx.ccx.tcx,\n-                                            vdef._0);\n-\n-            auto path_tpot = instantiate_path(scx, p, tpt, pat.span);\n-\n-            alt (struct(scx.fcx.ccx.tcx, t)) {\n-                // N-ary variants have function types.\n-                case (ty::ty_fn(_, ?args, ?tag_ty, _)) {\n-                    auto arg_len = vec::len[arg](args);\n-                    auto subpats_len = vec::len[@ast::pat](subpats);\n-                    if (arg_len != subpats_len) {\n-                        // TODO: pluralize properly\n-                        auto err_msg = \"tag type \" + last_id + \" has \" +\n-                                       uint::to_str(arg_len, 10u) +\n-                                       \" field(s), but this pattern has \" +\n-                                       uint::to_str(subpats_len, 10u) +\n-                                       \" field(s)\";\n-\n-                        scx.fcx.ccx.tcx.sess.span_err(pat.span, err_msg);\n-                        fail;   // TODO: recover\n-                    }\n-\n-                    for (@ast::pat subpat in subpats) {\n-                        check_pat(scx, subpat);\n-                    }\n+        case (ast::pat_tag(?path, ?subpats, ?ann)) {\n+            // Typecheck the path.\n+            auto v_def = scx.fcx.ccx.tcx.def_map.get(ann.id);\n+            auto v_def_ids = ast::variant_def_ids(v_def);\n \n-                    write::ty_fixup(scx, old_ann.id, path_tpot);\n-                }\n-\n-                // Nullary variants have tag types.\n-                case (ty::ty_tag(?tid, _)) {\n-                    auto subpats_len = vec::len[@ast::pat](subpats);\n-                    if (subpats_len > 0u) {\n-                        // TODO: pluralize properly\n-                        auto err_msg = \"tag type \" + last_id +\n-                                       \" has no field(s),\" +\n-                                       \" but this pattern has \" +\n-                                       uint::to_str(subpats_len, 10u) +\n-                                       \" field(s)\";\n-\n-                        scx.fcx.ccx.tcx.sess.span_err(pat.span, err_msg);\n-                        fail;   // TODO: recover\n-                    }\n+            auto tag_tpt = ty::lookup_item_type(scx.fcx.ccx.tcx,\n+                                                v_def_ids._0);\n+            auto path_tpot = instantiate_path(scx, path, tag_tpt, pat.span);\n \n-                    write::ty_fixup(scx, old_ann.id, path_tpot);\n+            // Take the tag type params out of `expected`.\n+            auto expected_tps;\n+            alt (struct(scx.fcx.ccx.tcx, expected)) {\n+                case (ty::ty_tag(_, ?tps)) { expected_tps = tps; }\n+                case (_) {\n+                    // FIXME: Switch expected and actual in this message? I\n+                    // can never tell.\n+                    scx.fcx.ccx.tcx.sess.span_err(pat.span,\n+                        #fmt(\"mismatched types: expected tag but found %s\",\n+                             ty::ty_to_str(scx.fcx.ccx.tcx, expected)));\n+                }\n+            }\n+\n+            // Unify with the expected tag type.\n+            auto path_tpt = demand::full(scx, pat.span, expected,\n+                                         path_tpot._1, expected_tps,\n+                                         NO_AUTODEREF);\n+            path_tpot = tup(some[vec[ty::t]](path_tpt._0), path_tpt._1);\n+\n+            // Get the number of arguments in this tag variant.\n+            auto arg_types = variant_arg_types(scx.fcx.ccx, pat.span,\n+                                               v_def_ids._1, expected_tps);\n+\n+            auto subpats_len = vec::len[@ast::pat](subpats);\n+\n+            if (vec::len[ty::t](arg_types) > 0u) {\n+                // N-ary variant.\n+                auto arg_len = vec::len[ty::t](arg_types);\n+                if (arg_len != subpats_len) {\n+                    // TODO: note definition of tag variant\n+                    // TODO (issue #448): Wrap a #fmt string over multiple\n+                    // lines...\n+                    scx.fcx.ccx.tcx.sess.span_err(pat.span, #fmt(\n+  \"this pattern has %u field%s, but the corresponding variant has %u field%s\",\n+                        subpats_len,\n+                        if (subpats_len == 0u) { \"\" } else { \"s\" },\n+                        arg_len,\n+                        if (arg_len == 0u) { \"\" } else { \"s\" }));\n+                }\n+\n+                // TODO: vec::iter2\n+                auto i = 0u;\n+                for (@ast::pat subpat in subpats) {\n+                    check_pat(scx, subpat, arg_types.(i));\n+                    i += 1u;\n                 }\n+            } else if (subpats_len > 0u) {\n+                // TODO: note definition of tag variant\n+                // TODO (issue #448): Wrap a #fmt string over multiple\n+                // lines...\n+                scx.fcx.ccx.tcx.sess.span_err(pat.span, #fmt(\n+\"this pattern has %u field%s, but the corresponding variant has no fields\",\n+                    subpats_len,\n+                    if (subpats_len == 0u) { \"\" } else { \"s\" }));\n             }\n+\n+            write::ty_fixup(scx, ann.id, path_tpot);\n         }\n     }\n }\n@@ -2247,20 +2169,14 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n             // Typecheck the patterns first, so that we get types for all the\n             // bindings.\n-            auto pattern_ty = expr_ty(scx.fcx.ccx.tcx, expr);\n+            auto pattern_ty = ty::expr_ty(scx.fcx.ccx.tcx, expr);\n \n             let vec[@ast::pat] pats = [];\n             for (ast::arm arm in arms) {\n-                check_pat(scx, arm.pat);\n-                pattern_ty = demand::simple(scx, arm.pat.span, pattern_ty,\n-                    pat_ty(scx.fcx.ccx.tcx, arm.pat));\n+                check_pat(scx, arm.pat, pattern_ty);\n                 pats += [arm.pat];\n             }\n \n-            for (@ast::pat pat in pats) {\n-                pushdown::pushdown_pat(scx, pattern_ty, pat);\n-            }\n-\n             // Now typecheck the blocks.\n             auto result_ty = next_ty_var(scx);\n "}]}