{"sha": "09f4c9af13e8dcd9d0bee69db61291f0ad85f266", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ZjRjOWFmMTNlOGRjZDlkMGJlZTY5ZGI2MTI5MWYwYWQ4NWYyNjY=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-10T19:59:52Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-10T19:59:52Z"}, "message": "Merge branch 'enum-method-privacy' of https://github.com/michaelwoerister/rust into rollup\n\nConflicts:\n\tsrc/libsyntax/opt_vec.rs", "tree": {"sha": "4caa526c583f7a6b5e0a0d19cd328047ccdb8969", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4caa526c583f7a6b5e0a0d19cd328047ccdb8969"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09f4c9af13e8dcd9d0bee69db61291f0ad85f266", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09f4c9af13e8dcd9d0bee69db61291f0ad85f266", "html_url": "https://github.com/rust-lang/rust/commit/09f4c9af13e8dcd9d0bee69db61291f0ad85f266", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09f4c9af13e8dcd9d0bee69db61291f0ad85f266/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8a93efdae48b88bf594480705a5c0aac39c75e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8a93efdae48b88bf594480705a5c0aac39c75e1", "html_url": "https://github.com/rust-lang/rust/commit/c8a93efdae48b88bf594480705a5c0aac39c75e1"}, {"sha": "2c9922aa491f406d0a17631ef2f0bfc0bbf85346", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c9922aa491f406d0a17631ef2f0bfc0bbf85346", "html_url": "https://github.com/rust-lang/rust/commit/2c9922aa491f406d0a17631ef2f0bfc0bbf85346"}], "stats": {"total": 85, "additions": 59, "deletions": 26}, "files": [{"sha": "a4b88870b97390deb3140287e71cf3542563af34", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09f4c9af13e8dcd9d0bee69db61291f0ad85f266/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f4c9af13e8dcd9d0bee69db61291f0ad85f266/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=09f4c9af13e8dcd9d0bee69db61291f0ad85f266", "patch": "@@ -403,6 +403,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                     // Ditto\n                     match ty::get(ty::type_autoderef(tcx, ty::expr_ty(tcx,\n                                                           base))).sty {\n+                        ty_enum(id, _) |\n                         ty_struct(id, _)\n                         if id.crate != LOCAL_CRATE ||\n                            !privileged_items.iter().any(|x| x == &(id.node)) => {"}, {"sha": "dfaffa0c2759dd3fc2e52329f1c5b4dfe61a45f3", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/09f4c9af13e8dcd9d0bee69db61291f0ad85f266/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f4c9af13e8dcd9d0bee69db61291f0ad85f266/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=09f4c9af13e8dcd9d0bee69db61291f0ad85f266", "patch": "@@ -421,12 +421,12 @@ pub enum MapChain<K,V> {\n // get the map from an env frame\n impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n     // Constructor. I don't think we need a zero-arg one.\n-    fn new(init: ~HashMap<K,@V>) -> @mut MapChain<K,V> {\n+    pub fn new(init: ~HashMap<K,@V>) -> @mut MapChain<K,V> {\n         @mut BaseMapChain(init)\n     }\n \n     // add a new frame to the environment (functionally)\n-    fn push_frame (@mut self) -> @mut MapChain<K,V> {\n+    pub fn push_frame (@mut self) -> @mut MapChain<K,V> {\n         @mut ConsMapChain(~HashMap::new() ,self)\n     }\n \n@@ -436,7 +436,7 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n \n     // ugh: can't get this to compile with mut because of the\n     // lack of flow sensitivity.\n-    fn get_map<'a>(&'a self) -> &'a HashMap<K,@V> {\n+    pub fn get_map<'a>(&'a self) -> &'a HashMap<K,@V> {\n         match *self {\n             BaseMapChain (~ref map) => map,\n             ConsMapChain (~ref map,_) => map\n@@ -446,7 +446,7 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n // traits just don't work anywhere...?\n //impl Map<Name,SyntaxExtension> for MapChain {\n \n-    fn contains_key (&self, key: &K) -> bool {\n+    pub fn contains_key (&self, key: &K) -> bool {\n         match *self {\n             BaseMapChain (ref map) => map.contains_key(key),\n             ConsMapChain (ref map,ref rest) =>\n@@ -457,17 +457,17 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n     // should each_key and each_value operate on shadowed\n     // names? I think not.\n     // delaying implementing this....\n-    fn each_key (&self, _f: &fn (&K)->bool) {\n+    pub fn each_key (&self, _f: &fn (&K)->bool) {\n         fail!(\"unimplemented 2013-02-15T10:01\");\n     }\n \n-    fn each_value (&self, _f: &fn (&V) -> bool) {\n+    pub fn each_value (&self, _f: &fn (&V) -> bool) {\n         fail!(\"unimplemented 2013-02-15T10:02\");\n     }\n \n     // Returns a copy of the value that the name maps to.\n     // Goes down the chain 'til it finds one (or bottom out).\n-    fn find (&self, key: &K) -> Option<@V> {\n+    pub fn find (&self, key: &K) -> Option<@V> {\n         match self.get_map().find (key) {\n             Some(ref v) => Some(**v),\n             None => match *self {\n@@ -477,7 +477,7 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n         }\n     }\n \n-    fn find_in_topmost_frame(&self, key: &K) -> Option<@V> {\n+    pub fn find_in_topmost_frame(&self, key: &K) -> Option<@V> {\n         let map = match *self {\n             BaseMapChain(ref map) => map,\n             ConsMapChain(ref map,_) => map\n@@ -487,7 +487,7 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n     }\n \n     // insert the binding into the top-level map\n-    fn insert (&mut self, key: K, ext: @V) -> bool {\n+    pub fn insert (&mut self, key: K, ext: @V) -> bool {\n         // can't abstract over get_map because of flow sensitivity...\n         match *self {\n             BaseMapChain (~ref mut map) => map.insert(key, ext),\n@@ -499,7 +499,7 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n     // ... there are definitely some opportunities for abstraction\n     // here that I'm ignoring. (e.g., manufacturing a predicate on\n     // the maps in the chain, and using an abstract \"find\".\n-    fn insert_into_frame(&mut self, key: K, ext: @V, n: K, pred: &fn(&@V)->bool) {\n+    pub fn insert_into_frame(&mut self, key: K, ext: @V, n: K, pred: &fn(&@V)->bool) {\n         match *self {\n             BaseMapChain (~ref mut map) => {\n                 if satisfies_pred(map,&n,pred) {"}, {"sha": "3a10206b513f8920d7adbc84a2310cb9f91b423c", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/09f4c9af13e8dcd9d0bee69db61291f0ad85f266/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f4c9af13e8dcd9d0bee69db61291f0ad85f266/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=09f4c9af13e8dcd9d0bee69db61291f0ad85f266", "patch": "@@ -36,7 +36,7 @@ pub fn from<T>(t: ~[T]) -> OptVec<T> {\n }\n \n impl<T> OptVec<T> {\n-    fn push(&mut self, t: T) {\n+    pub fn push(&mut self, t: T) {\n         match *self {\n             Vec(ref mut v) => {\n                 v.push(t);\n@@ -50,52 +50,52 @@ impl<T> OptVec<T> {\n         *self = Vec(~[t]);\n     }\n \n-    fn map<U>(&self, op: &fn(&T) -> U) -> OptVec<U> {\n+    pub fn map<U>(&self, op: &fn(&T) -> U) -> OptVec<U> {\n         match *self {\n             Empty => Empty,\n             Vec(ref v) => Vec(v.map(op))\n         }\n     }\n \n-    fn map_move<U>(self, op: &fn(T) -> U) -> OptVec<U> {\n+    pub fn map_move<U>(self, op: &fn(T) -> U) -> OptVec<U> {\n         match self {\n             Empty => Empty,\n             Vec(v) => Vec(v.move_iter().map(op).collect())\n         }\n     }\n \n-    fn get<'a>(&'a self, i: uint) -> &'a T {\n+    pub fn get<'a>(&'a self, i: uint) -> &'a T {\n         match *self {\n             Empty => fail!(\"Invalid index %u\", i),\n             Vec(ref v) => &v[i]\n         }\n     }\n \n-    fn is_empty(&self) -> bool {\n+    pub fn is_empty(&self) -> bool {\n         self.len() == 0\n     }\n \n-    fn len(&self) -> uint {\n+    pub fn len(&self) -> uint {\n         match *self {\n             Empty => 0,\n             Vec(ref v) => v.len()\n         }\n     }\n \n     #[inline]\n-    fn iter<'r>(&'r self) -> OptVecIterator<'r, T> {\n+    pub fn iter<'r>(&'r self) -> OptVecIterator<'r, T> {\n         match *self {\n             Empty => OptVecIterator{iter: None},\n             Vec(ref v) => OptVecIterator{iter: Some(v.iter())}\n         }\n     }\n \n     #[inline]\n-    fn map_to_vec<B>(&self, op: &fn(&T) -> B) -> ~[B] {\n+    pub fn map_to_vec<B>(&self, op: &fn(&T) -> B) -> ~[B] {\n         self.iter().map(op).collect()\n     }\n \n-    fn mapi_to_vec<B>(&self, op: &fn(uint, &T) -> B) -> ~[B] {\n+    pub fn mapi_to_vec<B>(&self, op: &fn(uint, &T) -> B) -> ~[B] {\n         let mut index = 0;\n         self.map_to_vec(|a| {\n             let i = index;\n@@ -113,7 +113,7 @@ pub fn take_vec<T>(v: OptVec<T>) -> ~[T] {\n }\n \n impl<T:Clone> OptVec<T> {\n-    fn prepend(&self, t: T) -> OptVec<T> {\n+    pub fn prepend(&self, t: T) -> OptVec<T> {\n         let mut v0 = ~[t];\n         match *self {\n             Empty => {}\n@@ -124,7 +124,7 @@ impl<T:Clone> OptVec<T> {\n }\n \n impl<A:Eq> Eq for OptVec<A> {\n-    fn eq(&self, other: &OptVec<A>) -> bool {\n+    pub fn eq(&self, other: &OptVec<A>) -> bool {\n         // Note: cannot use #[deriving(Eq)] here because\n         // (Empty, Vec(~[])) ought to be equal.\n         match (self, other) {\n@@ -135,7 +135,7 @@ impl<A:Eq> Eq for OptVec<A> {\n         }\n     }\n \n-    fn ne(&self, other: &OptVec<A>) -> bool {\n+    pub fn ne(&self, other: &OptVec<A>) -> bool {\n         !self.eq(other)\n     }\n }"}, {"sha": "8290f62bada26aed8db31e617f91a21765dcebbb", "filename": "src/test/auxiliary/xc_private_method_lib.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/09f4c9af13e8dcd9d0bee69db61291f0ad85f266/src%2Ftest%2Fauxiliary%2Fxc_private_method_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f4c9af13e8dcd9d0bee69db61291f0ad85f266/src%2Ftest%2Fauxiliary%2Fxc_private_method_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fxc_private_method_lib.rs?ref=09f4c9af13e8dcd9d0bee69db61291f0ad85f266", "patch": "@@ -1,9 +1,33 @@\n #[crate_type=\"lib\"];\n \n-pub struct Foo {\n+pub struct Struct {\n     x: int\n }\n \n-impl Foo {\n-    fn new() -> Foo { Foo { x: 1 } }\n+impl Struct {\n+    fn static_meth_struct() -> Struct {\n+        Struct { x: 1 }\n+    }\n+\n+    fn meth_struct(&self) -> int {\n+        self.x\n+    }\n+}\n+\n+pub enum Enum {\n+    Variant1(int),\n+    Variant2(int)\n+}\n+\n+impl Enum {\n+    fn static_meth_enum() -> Enum {\n+        Variant2(10)\n+    }\n+\n+    fn meth_enum(&self) -> int {\n+        match *self {\n+            Variant1(x) |\n+            Variant2(x) => x\n+        }\n+    }\n }"}, {"sha": "8314755af3b3d7195303d6aa1d34248bf0df6e79", "filename": "src/test/compile-fail/xc-private-method.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09f4c9af13e8dcd9d0bee69db61291f0ad85f266/src%2Ftest%2Fcompile-fail%2Fxc-private-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f4c9af13e8dcd9d0bee69db61291f0ad85f266/src%2Ftest%2Fcompile-fail%2Fxc-private-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fxc-private-method.rs?ref=09f4c9af13e8dcd9d0bee69db61291f0ad85f266", "patch": "@@ -4,5 +4,13 @@\n extern mod xc_private_method_lib;\n \n fn main() {\n-    let _ = xc_private_method_lib::Foo::new();  //~ ERROR function `new` is private\n+    // normal method on struct\n+    let _ = xc_private_method_lib::Struct{ x: 10 }.meth_struct();  //~ ERROR method `meth_struct` is private\n+    // static method on struct\n+    let _ = xc_private_method_lib::Struct::static_meth_struct();  //~ ERROR function `static_meth_struct` is private\n+\n+    // normal method on enum\n+    let _ = xc_private_method_lib::Variant1(20).meth_enum();  //~ ERROR method `meth_enum` is private\n+    // static method on enum\n+    let _ = xc_private_method_lib::Enum::static_meth_enum();  //~ ERROR function `static_meth_enum` is private\n }"}]}