{"sha": "249d5acaec0b10ee15b21b888977b5445baba42e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0OWQ1YWNhZWMwYjEwZWUxNWIyMWI4ODg5NzdiNTQ0NWJhYmE0MmU=", "commit": {"author": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-06-27T14:57:25Z"}, "committer": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-07-30T15:27:52Z"}, "message": "rustc_codegen_llvm: use safe references for Context and Module.", "tree": {"sha": "966ea8d75c9e97d2b6e70d0bcd30ceef689d4b8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/966ea8d75c9e97d2b6e70d0bcd30ceef689d4b8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/249d5acaec0b10ee15b21b888977b5445baba42e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/249d5acaec0b10ee15b21b888977b5445baba42e", "html_url": "https://github.com/rust-lang/rust/commit/249d5acaec0b10ee15b21b888977b5445baba42e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/249d5acaec0b10ee15b21b888977b5445baba42e/comments", "author": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af04e9426c71ac1050b9007c93b03864e45a81df", "url": "https://api.github.com/repos/rust-lang/rust/commits/af04e9426c71ac1050b9007c93b03864e45a81df", "html_url": "https://github.com/rust-lang/rust/commit/af04e9426c71ac1050b9007c93b03864e45a81df"}], "stats": {"total": 1105, "additions": 549, "deletions": 556}, "files": [{"sha": "2d401da958b13fa6465af1612a64b95774198862", "filename": "src/librustc_codegen_llvm/allocator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fallocator.rs?ref=249d5acaec0b10ee15b21b888977b5445baba42e", "patch": "@@ -20,8 +20,8 @@ use ModuleLlvm;\n use llvm::{self, False, True};\n \n pub(crate) unsafe fn codegen(tcx: TyCtxt, mods: &ModuleLlvm, kind: AllocatorKind) {\n-    let llcx = mods.llcx;\n-    let llmod = mods.llmod;\n+    let llcx = &*mods.llcx;\n+    let llmod = mods.llmod();\n     let usize = match &tcx.sess.target.target.target_pointer_width[..] {\n         \"16\" => llvm::LLVMInt16TypeInContext(llcx),\n         \"32\" => llvm::LLVMInt32TypeInContext(llcx),"}, {"sha": "fce34710b814302a94a2c24eb0225ee9705ac07e", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 166, "deletions": 160, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=249d5acaec0b10ee15b21b888977b5445baba42e", "patch": "@@ -14,7 +14,7 @@ use back::write::{ModuleConfig, with_llvm_pmb, CodegenContext};\n use back::write;\n use errors::{FatalError, Handler};\n use llvm::archive_ro::ArchiveRO;\n-use llvm::{ModuleRef, TargetMachineRef, True, False};\n+use llvm::{TargetMachineRef, True, False};\n use llvm;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::exported_symbols::SymbolExportLevel;\n@@ -73,11 +73,13 @@ impl LtoModuleCodegen {\n         match *self {\n             LtoModuleCodegen::Fat { ref mut module, .. } => {\n                 let module = module.take().unwrap();\n-                let config = cgcx.config(module.kind);\n-                let llmod = module.llvm().unwrap().llmod;\n-                let tm = module.llvm().unwrap().tm;\n-                run_pass_manager(cgcx, tm, llmod, config, false);\n-                timeline.record(\"fat-done\");\n+                {\n+                    let config = cgcx.config(module.kind);\n+                    let llmod = module.llvm().unwrap().llmod();\n+                    let tm = &*module.llvm().unwrap().tm;\n+                    run_pass_manager(cgcx, tm, llmod, config, false);\n+                    timeline.record(\"fat-done\");\n+                }\n                 Ok(module)\n             }\n             LtoModuleCodegen::Thin(ref mut thin) => thin.optimize(cgcx, timeline),\n@@ -223,66 +225,68 @@ fn fat_lto(cgcx: &CodegenContext,\n         .filter(|&(_, module)| module.kind == ModuleKind::Regular)\n         .map(|(i, module)| {\n             let cost = unsafe {\n-                llvm::LLVMRustModuleCost(module.llvm().unwrap().llmod)\n+                llvm::LLVMRustModuleCost(module.llvm().unwrap().llmod())\n             };\n             (cost, i)\n         })\n         .max()\n         .expect(\"must be codegen'ing at least one module\");\n     let module = modules.remove(costliest_module);\n-    let llmod = module.llvm().expect(\"can't lto pre-codegened modules\").llmod;\n-    info!(\"using {:?} as a base module\", module.llmod_id);\n-\n-    // For all other modules we codegened we'll need to link them into our own\n-    // bitcode. All modules were codegened in their own LLVM context, however,\n-    // and we want to move everything to the same LLVM context. Currently the\n-    // way we know of to do that is to serialize them to a string and them parse\n-    // them later. Not great but hey, that's why it's \"fat\" LTO, right?\n-    for module in modules {\n-        let llvm = module.llvm().expect(\"can't lto pre-codegened modules\");\n-        let buffer = ModuleBuffer::new(llvm.llmod);\n-        let llmod_id = CString::new(&module.llmod_id[..]).unwrap();\n-        serialized_modules.push((SerializedModule::Local(buffer), llmod_id));\n-    }\n-\n-    // For all serialized bitcode files we parse them and link them in as we did\n-    // above, this is all mostly handled in C++. Like above, though, we don't\n-    // know much about the memory management here so we err on the side of being\n-    // save and persist everything with the original module.\n     let mut serialized_bitcode = Vec::new();\n-    let mut linker = Linker::new(llmod);\n-    for (bc_decoded, name) in serialized_modules {\n-        info!(\"linking {:?}\", name);\n-        time_ext(cgcx.time_passes, None, &format!(\"ll link {:?}\", name), || {\n-            let data = bc_decoded.data();\n-            linker.add(&data).map_err(|()| {\n-                let msg = format!(\"failed to load bc of {:?}\", name);\n-                write::llvm_err(&diag_handler, msg)\n-            })\n-        })?;\n-        timeline.record(&format!(\"link {:?}\", name));\n-        serialized_bitcode.push(bc_decoded);\n-    }\n-    drop(linker);\n-    cgcx.save_temp_bitcode(&module, \"lto.input\");\n+    {\n+        let llmod = module.llvm().expect(\"can't lto pre-codegened modules\").llmod();\n+        info!(\"using {:?} as a base module\", module.llmod_id);\n+\n+        // For all other modules we codegened we'll need to link them into our own\n+        // bitcode. All modules were codegened in their own LLVM context, however,\n+        // and we want to move everything to the same LLVM context. Currently the\n+        // way we know of to do that is to serialize them to a string and them parse\n+        // them later. Not great but hey, that's why it's \"fat\" LTO, right?\n+        for module in modules {\n+            let llvm = module.llvm().expect(\"can't lto pre-codegened modules\");\n+            let buffer = ModuleBuffer::new(llvm.llmod());\n+            let llmod_id = CString::new(&module.llmod_id[..]).unwrap();\n+            serialized_modules.push((SerializedModule::Local(buffer), llmod_id));\n+        }\n \n-    // Internalize everything that *isn't* in our whitelist to help strip out\n-    // more modules and such\n-    unsafe {\n-        let ptr = symbol_white_list.as_ptr();\n-        llvm::LLVMRustRunRestrictionPass(llmod,\n-                                         ptr as *const *const libc::c_char,\n-                                         symbol_white_list.len() as libc::size_t);\n-        cgcx.save_temp_bitcode(&module, \"lto.after-restriction\");\n-    }\n+        // For all serialized bitcode files we parse them and link them in as we did\n+        // above, this is all mostly handled in C++. Like above, though, we don't\n+        // know much about the memory management here so we err on the side of being\n+        // save and persist everything with the original module.\n+        let mut linker = Linker::new(llmod);\n+        for (bc_decoded, name) in serialized_modules {\n+            info!(\"linking {:?}\", name);\n+            time_ext(cgcx.time_passes, None, &format!(\"ll link {:?}\", name), || {\n+                let data = bc_decoded.data();\n+                linker.add(&data).map_err(|()| {\n+                    let msg = format!(\"failed to load bc of {:?}\", name);\n+                    write::llvm_err(&diag_handler, msg)\n+                })\n+            })?;\n+            timeline.record(&format!(\"link {:?}\", name));\n+            serialized_bitcode.push(bc_decoded);\n+        }\n+        drop(linker);\n+        cgcx.save_temp_bitcode(&module, \"lto.input\");\n \n-    if cgcx.no_landing_pads {\n+        // Internalize everything that *isn't* in our whitelist to help strip out\n+        // more modules and such\n         unsafe {\n-            llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n+            let ptr = symbol_white_list.as_ptr();\n+            llvm::LLVMRustRunRestrictionPass(llmod,\n+                                            ptr as *const *const libc::c_char,\n+                                            symbol_white_list.len() as libc::size_t);\n+            cgcx.save_temp_bitcode(&module, \"lto.after-restriction\");\n         }\n-        cgcx.save_temp_bitcode(&module, \"lto.after-nounwind\");\n+\n+        if cgcx.no_landing_pads {\n+            unsafe {\n+                llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n+            }\n+            cgcx.save_temp_bitcode(&module, \"lto.after-nounwind\");\n+        }\n+        timeline.record(\"passes\");\n     }\n-    timeline.record(\"passes\");\n \n     Ok(vec![LtoModuleCodegen::Fat {\n         module: Some(module),\n@@ -293,7 +297,7 @@ fn fat_lto(cgcx: &CodegenContext,\n struct Linker(llvm::LinkerRef);\n \n impl Linker {\n-    fn new(llmod: ModuleRef) -> Linker {\n+    fn new(llmod: &llvm::Module) -> Linker {\n         unsafe { Linker(llvm::LLVMRustLinkerNew(llmod)) }\n     }\n \n@@ -371,7 +375,7 @@ fn thin_lto(diag_handler: &Handler,\n             info!(\"local module: {} - {}\", i, module.llmod_id);\n             let llvm = module.llvm().expect(\"can't lto precodegened module\");\n             let name = CString::new(module.llmod_id.clone()).unwrap();\n-            let buffer = ThinBuffer::new(llvm.llmod);\n+            let buffer = ThinBuffer::new(llvm.llmod());\n             thin_modules.push(llvm::ThinLTOModule {\n                 identifier: name.as_ptr(),\n                 data: buffer.data().as_ptr(),\n@@ -449,7 +453,7 @@ fn thin_lto(diag_handler: &Handler,\n \n fn run_pass_manager(cgcx: &CodegenContext,\n                     tm: TargetMachineRef,\n-                    llmod: ModuleRef,\n+                    llmod: &llvm::Module,\n                     config: &ModuleConfig,\n                     thin: bool) {\n     // Now we have one massive module inside of llmod. Time to run the\n@@ -531,7 +535,7 @@ unsafe impl Send for ModuleBuffer {}\n unsafe impl Sync for ModuleBuffer {}\n \n impl ModuleBuffer {\n-    pub fn new(m: ModuleRef) -> ModuleBuffer {\n+    pub fn new(m: &llvm::Module) -> ModuleBuffer {\n         ModuleBuffer(unsafe {\n             llvm::LLVMRustModuleBufferCreate(m)\n         })\n@@ -583,7 +587,7 @@ unsafe impl Send for ThinBuffer {}\n unsafe impl Sync for ThinBuffer {}\n \n impl ThinBuffer {\n-    pub fn new(m: ModuleRef) -> ThinBuffer {\n+    pub fn new(m: &llvm::Module) -> ThinBuffer {\n         unsafe {\n             let buffer = llvm::LLVMRustThinLTOBufferCreate(m);\n             ThinBuffer(buffer)\n@@ -640,124 +644,126 @@ impl ThinModule {\n         // crates but for locally codegened modules we may be able to reuse\n         // that LLVM Context and Module.\n         let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n-        let llmod = llvm::LLVMRustParseBitcodeForThinLTO(\n+        let llmod_raw = llvm::LLVMRustParseBitcodeForThinLTO(\n             llcx,\n             self.data().as_ptr(),\n             self.data().len(),\n             self.shared.module_names[self.idx].as_ptr(),\n-        );\n-        if llmod.is_null() {\n+        ).ok_or_else(|| {\n             let msg = \"failed to parse bitcode for thin LTO module\".to_string();\n-            return Err(write::llvm_err(&diag_handler, msg));\n-        }\n+            write::llvm_err(&diag_handler, msg)\n+        })? as *const _;\n         let module = ModuleCodegen {\n             source: ModuleSource::Codegened(ModuleLlvm {\n-                llmod,\n+                llmod_raw,\n                 llcx,\n                 tm,\n             }),\n             llmod_id: self.name().to_string(),\n             name: self.name().to_string(),\n             kind: ModuleKind::Regular,\n         };\n-        cgcx.save_temp_bitcode(&module, \"thin-lto-input\");\n-\n-        // Before we do much else find the \"main\" `DICompileUnit` that we'll be\n-        // using below. If we find more than one though then rustc has changed\n-        // in a way we're not ready for, so generate an ICE by returning\n-        // an error.\n-        let mut cu1 = ptr::null_mut();\n-        let mut cu2 = ptr::null_mut();\n-        llvm::LLVMRustThinLTOGetDICompileUnit(llmod, &mut cu1, &mut cu2);\n-        if !cu2.is_null() {\n-            let msg = \"multiple source DICompileUnits found\".to_string();\n-            return Err(write::llvm_err(&diag_handler, msg))\n-        }\n+        {\n+            let llmod = module.llvm().unwrap().llmod();\n+            cgcx.save_temp_bitcode(&module, \"thin-lto-input\");\n+\n+            // Before we do much else find the \"main\" `DICompileUnit` that we'll be\n+            // using below. If we find more than one though then rustc has changed\n+            // in a way we're not ready for, so generate an ICE by returning\n+            // an error.\n+            let mut cu1 = ptr::null_mut();\n+            let mut cu2 = ptr::null_mut();\n+            llvm::LLVMRustThinLTOGetDICompileUnit(llmod, &mut cu1, &mut cu2);\n+            if !cu2.is_null() {\n+                let msg = \"multiple source DICompileUnits found\".to_string();\n+                return Err(write::llvm_err(&diag_handler, msg))\n+            }\n \n-        // Like with \"fat\" LTO, get some better optimizations if landing pads\n-        // are disabled by removing all landing pads.\n-        if cgcx.no_landing_pads {\n-            llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n-            cgcx.save_temp_bitcode(&module, \"thin-lto-after-nounwind\");\n-            timeline.record(\"nounwind\");\n-        }\n+            // Like with \"fat\" LTO, get some better optimizations if landing pads\n+            // are disabled by removing all landing pads.\n+            if cgcx.no_landing_pads {\n+                llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n+                cgcx.save_temp_bitcode(&module, \"thin-lto-after-nounwind\");\n+                timeline.record(\"nounwind\");\n+            }\n \n-        // Up next comes the per-module local analyses that we do for Thin LTO.\n-        // Each of these functions is basically copied from the LLVM\n-        // implementation and then tailored to suit this implementation. Ideally\n-        // each of these would be supported by upstream LLVM but that's perhaps\n-        // a patch for another day!\n-        //\n-        // You can find some more comments about these functions in the LLVM\n-        // bindings we've got (currently `PassWrapper.cpp`)\n-        if !llvm::LLVMRustPrepareThinLTORename(self.shared.data.0, llmod) {\n-            let msg = \"failed to prepare thin LTO module\".to_string();\n-            return Err(write::llvm_err(&diag_handler, msg))\n-        }\n-        cgcx.save_temp_bitcode(&module, \"thin-lto-after-rename\");\n-        timeline.record(\"rename\");\n-        if !llvm::LLVMRustPrepareThinLTOResolveWeak(self.shared.data.0, llmod) {\n-            let msg = \"failed to prepare thin LTO module\".to_string();\n-            return Err(write::llvm_err(&diag_handler, msg))\n-        }\n-        cgcx.save_temp_bitcode(&module, \"thin-lto-after-resolve\");\n-        timeline.record(\"resolve\");\n-        if !llvm::LLVMRustPrepareThinLTOInternalize(self.shared.data.0, llmod) {\n-            let msg = \"failed to prepare thin LTO module\".to_string();\n-            return Err(write::llvm_err(&diag_handler, msg))\n-        }\n-        cgcx.save_temp_bitcode(&module, \"thin-lto-after-internalize\");\n-        timeline.record(\"internalize\");\n-        if !llvm::LLVMRustPrepareThinLTOImport(self.shared.data.0, llmod) {\n-            let msg = \"failed to prepare thin LTO module\".to_string();\n-            return Err(write::llvm_err(&diag_handler, msg))\n+            // Up next comes the per-module local analyses that we do for Thin LTO.\n+            // Each of these functions is basically copied from the LLVM\n+            // implementation and then tailored to suit this implementation. Ideally\n+            // each of these would be supported by upstream LLVM but that's perhaps\n+            // a patch for another day!\n+            //\n+            // You can find some more comments about these functions in the LLVM\n+            // bindings we've got (currently `PassWrapper.cpp`)\n+            if !llvm::LLVMRustPrepareThinLTORename(self.shared.data.0, llmod) {\n+                let msg = \"failed to prepare thin LTO module\".to_string();\n+                return Err(write::llvm_err(&diag_handler, msg))\n+            }\n+            cgcx.save_temp_bitcode(&module, \"thin-lto-after-rename\");\n+            timeline.record(\"rename\");\n+            if !llvm::LLVMRustPrepareThinLTOResolveWeak(self.shared.data.0, llmod) {\n+                let msg = \"failed to prepare thin LTO module\".to_string();\n+                return Err(write::llvm_err(&diag_handler, msg))\n+            }\n+            cgcx.save_temp_bitcode(&module, \"thin-lto-after-resolve\");\n+            timeline.record(\"resolve\");\n+            if !llvm::LLVMRustPrepareThinLTOInternalize(self.shared.data.0, llmod) {\n+                let msg = \"failed to prepare thin LTO module\".to_string();\n+                return Err(write::llvm_err(&diag_handler, msg))\n+            }\n+            cgcx.save_temp_bitcode(&module, \"thin-lto-after-internalize\");\n+            timeline.record(\"internalize\");\n+            if !llvm::LLVMRustPrepareThinLTOImport(self.shared.data.0, llmod) {\n+                let msg = \"failed to prepare thin LTO module\".to_string();\n+                return Err(write::llvm_err(&diag_handler, msg))\n+            }\n+            cgcx.save_temp_bitcode(&module, \"thin-lto-after-import\");\n+            timeline.record(\"import\");\n+\n+            // Ok now this is a bit unfortunate. This is also something you won't\n+            // find upstream in LLVM's ThinLTO passes! This is a hack for now to\n+            // work around bugs in LLVM.\n+            //\n+            // First discovered in #45511 it was found that as part of ThinLTO\n+            // importing passes LLVM will import `DICompileUnit` metadata\n+            // information across modules. This means that we'll be working with one\n+            // LLVM module that has multiple `DICompileUnit` instances in it (a\n+            // bunch of `llvm.dbg.cu` members). Unfortunately there's a number of\n+            // bugs in LLVM's backend which generates invalid DWARF in a situation\n+            // like this:\n+            //\n+            //  https://bugs.llvm.org/show_bug.cgi?id=35212\n+            //  https://bugs.llvm.org/show_bug.cgi?id=35562\n+            //\n+            // While the first bug there is fixed the second ended up causing #46346\n+            // which was basically a resurgence of #45511 after LLVM's bug 35212 was\n+            // fixed.\n+            //\n+            // This function below is a huge hack around this problem. The function\n+            // below is defined in `PassWrapper.cpp` and will basically \"merge\"\n+            // all `DICompileUnit` instances in a module. Basically it'll take all\n+            // the objects, rewrite all pointers of `DISubprogram` to point to the\n+            // first `DICompileUnit`, and then delete all the other units.\n+            //\n+            // This is probably mangling to the debug info slightly (but hopefully\n+            // not too much) but for now at least gets LLVM to emit valid DWARF (or\n+            // so it appears). Hopefully we can remove this once upstream bugs are\n+            // fixed in LLVM.\n+            llvm::LLVMRustThinLTOPatchDICompileUnit(llmod, cu1);\n+            cgcx.save_temp_bitcode(&module, \"thin-lto-after-patch\");\n+            timeline.record(\"patch\");\n+\n+            // Alright now that we've done everything related to the ThinLTO\n+            // analysis it's time to run some optimizations! Here we use the same\n+            // `run_pass_manager` as the \"fat\" LTO above except that we tell it to\n+            // populate a thin-specific pass manager, which presumably LLVM treats a\n+            // little differently.\n+            info!(\"running thin lto passes over {}\", module.name);\n+            let config = cgcx.config(module.kind);\n+            run_pass_manager(cgcx, module.llvm().unwrap().tm, llmod, config, true);\n+            cgcx.save_temp_bitcode(&module, \"thin-lto-after-pm\");\n+            timeline.record(\"thin-done\");\n         }\n-        cgcx.save_temp_bitcode(&module, \"thin-lto-after-import\");\n-        timeline.record(\"import\");\n-\n-        // Ok now this is a bit unfortunate. This is also something you won't\n-        // find upstream in LLVM's ThinLTO passes! This is a hack for now to\n-        // work around bugs in LLVM.\n-        //\n-        // First discovered in #45511 it was found that as part of ThinLTO\n-        // importing passes LLVM will import `DICompileUnit` metadata\n-        // information across modules. This means that we'll be working with one\n-        // LLVM module that has multiple `DICompileUnit` instances in it (a\n-        // bunch of `llvm.dbg.cu` members). Unfortunately there's a number of\n-        // bugs in LLVM's backend which generates invalid DWARF in a situation\n-        // like this:\n-        //\n-        //  https://bugs.llvm.org/show_bug.cgi?id=35212\n-        //  https://bugs.llvm.org/show_bug.cgi?id=35562\n-        //\n-        // While the first bug there is fixed the second ended up causing #46346\n-        // which was basically a resurgence of #45511 after LLVM's bug 35212 was\n-        // fixed.\n-        //\n-        // This function below is a huge hack around this problem. The function\n-        // below is defined in `PassWrapper.cpp` and will basically \"merge\"\n-        // all `DICompileUnit` instances in a module. Basically it'll take all\n-        // the objects, rewrite all pointers of `DISubprogram` to point to the\n-        // first `DICompileUnit`, and then delete all the other units.\n-        //\n-        // This is probably mangling to the debug info slightly (but hopefully\n-        // not too much) but for now at least gets LLVM to emit valid DWARF (or\n-        // so it appears). Hopefully we can remove this once upstream bugs are\n-        // fixed in LLVM.\n-        llvm::LLVMRustThinLTOPatchDICompileUnit(llmod, cu1);\n-        cgcx.save_temp_bitcode(&module, \"thin-lto-after-patch\");\n-        timeline.record(\"patch\");\n-\n-        // Alright now that we've done everything related to the ThinLTO\n-        // analysis it's time to run some optimizations! Here we use the same\n-        // `run_pass_manager` as the \"fat\" LTO above except that we tell it to\n-        // populate a thin-specific pass manager, which presumably LLVM treats a\n-        // little differently.\n-        info!(\"running thin lto passes over {}\", module.name);\n-        let config = cgcx.config(module.kind);\n-        run_pass_manager(cgcx, tm, llmod, config, true);\n-        cgcx.save_temp_bitcode(&module, \"thin-lto-after-pm\");\n-        timeline.record(\"thin-done\");\n \n         Ok(module)\n     }"}, {"sha": "f5c2ca22ec8563dc0bb908f259f09569a4484706", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 177, "deletions": 180, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=249d5acaec0b10ee15b21b888977b5445baba42e", "patch": "@@ -26,8 +26,8 @@ use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n use time_graph::{self, TimeGraph, Timeline};\n use llvm;\n-use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef};\n-use llvm::{SMDiagnosticRef, ContextRef};\n+use llvm::{TargetMachineRef, PassManagerRef, DiagnosticInfoRef};\n+use llvm::SMDiagnosticRef;\n use {CodegenResults, ModuleSource, ModuleCodegen, CompiledModule, ModuleKind};\n use CrateInfo;\n use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n@@ -96,7 +96,7 @@ pub fn write_output_file(\n         handler: &errors::Handler,\n         target: llvm::TargetMachineRef,\n         pm: llvm::PassManagerRef,\n-        m: ModuleRef,\n+        m: &llvm::Module,\n         output: &Path,\n         file_type: llvm::FileType) -> Result<(), FatalError> {\n     unsafe {\n@@ -130,7 +130,7 @@ fn get_llvm_opt_size(optimize: config::OptLevel) -> llvm::CodeGenOptSize {\n     }\n }\n \n-pub fn create_target_machine(sess: &Session, find_features: bool) -> TargetMachineRef {\n+pub fn create_target_machine(sess: &Session, find_features: bool) -> &'static mut llvm::TargetMachine {\n     target_machine_factory(sess, find_features)().unwrap_or_else(|err| {\n         llvm_err(sess.diagnostic(), err).raise()\n     })\n@@ -140,7 +140,7 @@ pub fn create_target_machine(sess: &Session, find_features: bool) -> TargetMachi\n // that `is_pie_binary` is false. When we discover LLVM target features\n // `sess.crate_types` is uninitialized so we cannot access it.\n pub fn target_machine_factory(sess: &Session, find_features: bool)\n-    -> Arc<dyn Fn() -> Result<TargetMachineRef, String> + Send + Sync>\n+    -> Arc<dyn Fn() -> Result<&'static mut llvm::TargetMachine, String> + Send + Sync>\n {\n     let reloc_model = get_reloc_model(sess);\n \n@@ -199,12 +199,10 @@ pub fn target_machine_factory(sess: &Session, find_features: bool)\n             )\n         };\n \n-        if tm.is_null() {\n-            Err(format!(\"Could not create LLVM TargetMachine for triple: {}\",\n-                        triple.to_str().unwrap()))\n-        } else {\n-            Ok(tm)\n-        }\n+        tm.ok_or_else(|| {\n+            format!(\"Could not create LLVM TargetMachine for triple: {}\",\n+                    triple.to_str().unwrap())\n+        })\n     })\n }\n \n@@ -343,7 +341,7 @@ pub struct CodegenContext {\n     regular_module_config: Arc<ModuleConfig>,\n     metadata_module_config: Arc<ModuleConfig>,\n     allocator_module_config: Arc<ModuleConfig>,\n-    pub tm_factory: Arc<dyn Fn() -> Result<TargetMachineRef, String> + Send + Sync>,\n+    pub tm_factory: Arc<dyn Fn() -> Result<&'static mut llvm::TargetMachine, String> + Send + Sync>,\n     pub msvc_imps_needed: bool,\n     pub target_pointer_width: String,\n     debuginfo: config::DebugInfoLevel,\n@@ -392,21 +390,21 @@ impl CodegenContext {\n             let cgu = Some(&module.name[..]);\n             let path = self.output_filenames.temp_path_ext(&ext, cgu);\n             let cstr = path2cstr(&path);\n-            let llmod = module.llvm().unwrap().llmod;\n+            let llmod = module.llvm().unwrap().llmod();\n             llvm::LLVMWriteBitcodeToFile(llmod, cstr.as_ptr());\n         }\n     }\n }\n \n struct DiagnosticHandlers<'a> {\n     data: *mut (&'a CodegenContext, &'a Handler),\n-    llcx: ContextRef,\n+    llcx: &'a llvm::Context,\n }\n \n impl<'a> DiagnosticHandlers<'a> {\n     fn new(cgcx: &'a CodegenContext,\n            handler: &'a Handler,\n-           llcx: ContextRef) -> DiagnosticHandlers<'a> {\n+           llcx: &'a llvm::Context) -> Self {\n         let data = Box::into_raw(Box::new((cgcx, handler)));\n         unsafe {\n             llvm::LLVMRustSetInlineAsmDiagnosticHandler(llcx, inline_asm_handler, data as *mut _);\n@@ -495,7 +493,7 @@ unsafe fn optimize(cgcx: &CodegenContext,\n     -> Result<(), FatalError>\n {\n     let (llmod, llcx, tm) = match module.source {\n-        ModuleSource::Codegened(ref llvm) => (llvm.llmod, llvm.llcx, llvm.tm),\n+        ModuleSource::Codegened(ref llvm) => (llvm.llmod(), &*llvm.llcx, &*llvm.tm),\n         ModuleSource::Preexisting(_) => {\n             bug!(\"optimize_and_codegen: called with ModuleSource::Preexisting\")\n         }\n@@ -617,192 +615,191 @@ unsafe fn codegen(cgcx: &CodegenContext,\n     -> Result<CompiledModule, FatalError>\n {\n     timeline.record(\"codegen\");\n-    let (llmod, llcx, tm) = match module.source {\n-        ModuleSource::Codegened(ref llvm) => (llvm.llmod, llvm.llcx, llvm.tm),\n-        ModuleSource::Preexisting(_) => {\n-            bug!(\"codegen: called with ModuleSource::Preexisting\")\n-        }\n-    };\n-    let module_name = module.name.clone();\n-    let module_name = Some(&module_name[..]);\n-    let handlers = DiagnosticHandlers::new(cgcx, diag_handler, llcx);\n-\n-    if cgcx.msvc_imps_needed {\n-        create_msvc_imps(cgcx, llcx, llmod);\n-    }\n-\n-    // A codegen-specific pass manager is used to generate object\n-    // files for an LLVM module.\n-    //\n-    // Apparently each of these pass managers is a one-shot kind of\n-    // thing, so we create a new one for each type of output. The\n-    // pass manager passed to the closure should be ensured to not\n-    // escape the closure itself, and the manager should only be\n-    // used once.\n-    unsafe fn with_codegen<F, R>(tm: TargetMachineRef,\n-                                 llmod: ModuleRef,\n-                                 no_builtins: bool,\n-                                 f: F) -> R\n-        where F: FnOnce(PassManagerRef) -> R,\n     {\n-        let cpm = llvm::LLVMCreatePassManager();\n-        llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n-        llvm::LLVMRustAddLibraryInfo(cpm, llmod, no_builtins);\n-        f(cpm)\n-    }\n-\n-    // If we don't have the integrated assembler, then we need to emit asm\n-    // from LLVM and use `gcc` to create the object file.\n-    let asm_to_obj = config.emit_obj && config.no_integrated_as;\n-\n-    // Change what we write and cleanup based on whether obj files are\n-    // just llvm bitcode. In that case write bitcode, and possibly\n-    // delete the bitcode if it wasn't requested. Don't generate the\n-    // machine code, instead copy the .o file from the .bc\n-    let write_bc = config.emit_bc || config.obj_is_bitcode;\n-    let rm_bc = !config.emit_bc && config.obj_is_bitcode;\n-    let write_obj = config.emit_obj && !config.obj_is_bitcode && !asm_to_obj;\n-    let copy_bc_to_obj = config.emit_obj && config.obj_is_bitcode;\n-\n-    let bc_out = cgcx.output_filenames.temp_path(OutputType::Bitcode, module_name);\n-    let obj_out = cgcx.output_filenames.temp_path(OutputType::Object, module_name);\n-\n-\n-    if write_bc || config.emit_bc_compressed || config.embed_bitcode {\n-        let thin;\n-        let old;\n-        let data = if llvm::LLVMRustThinLTOAvailable() {\n-            thin = ThinBuffer::new(llmod);\n-            thin.data()\n-        } else {\n-            old = ModuleBuffer::new(llmod);\n-            old.data()\n+        let (llmod, llcx, tm) = match module.source {\n+            ModuleSource::Codegened(ref llvm) => (llvm.llmod(), &*llvm.llcx, &*llvm.tm),\n+            ModuleSource::Preexisting(_) => {\n+                bug!(\"codegen: called with ModuleSource::Preexisting\")\n+            }\n         };\n-        timeline.record(\"make-bc\");\n+        let module_name = module.name.clone();\n+        let module_name = Some(&module_name[..]);\n+        let handlers = DiagnosticHandlers::new(cgcx, diag_handler, llcx);\n \n-        if write_bc {\n-            if let Err(e) = fs::write(&bc_out, data) {\n-                diag_handler.err(&format!(\"failed to write bytecode: {}\", e));\n-            }\n-            timeline.record(\"write-bc\");\n+        if cgcx.msvc_imps_needed {\n+            create_msvc_imps(cgcx, llcx, llmod);\n         }\n \n-        if config.embed_bitcode {\n-            embed_bitcode(cgcx, llcx, llmod, Some(data));\n-            timeline.record(\"embed-bc\");\n-        }\n+        // A codegen-specific pass manager is used to generate object\n+        // files for an LLVM module.\n+        //\n+        // Apparently each of these pass managers is a one-shot kind of\n+        // thing, so we create a new one for each type of output. The\n+        // pass manager passed to the closure should be ensured to not\n+        // escape the closure itself, and the manager should only be\n+        // used once.\n+        unsafe fn with_codegen<F, R>(tm: TargetMachineRef,\n+                                    llmod: &llvm::Module,\n+                                    no_builtins: bool,\n+                                    f: F) -> R\n+            where F: FnOnce(PassManagerRef) -> R,\n+        {\n+            let cpm = llvm::LLVMCreatePassManager();\n+            llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n+            llvm::LLVMRustAddLibraryInfo(cpm, llmod, no_builtins);\n+            f(cpm)\n+        }\n+\n+        // If we don't have the integrated assembler, then we need to emit asm\n+        // from LLVM and use `gcc` to create the object file.\n+        let asm_to_obj = config.emit_obj && config.no_integrated_as;\n+\n+        // Change what we write and cleanup based on whether obj files are\n+        // just llvm bitcode. In that case write bitcode, and possibly\n+        // delete the bitcode if it wasn't requested. Don't generate the\n+        // machine code, instead copy the .o file from the .bc\n+        let write_bc = config.emit_bc || config.obj_is_bitcode;\n+        let rm_bc = !config.emit_bc && config.obj_is_bitcode;\n+        let write_obj = config.emit_obj && !config.obj_is_bitcode && !asm_to_obj;\n+        let copy_bc_to_obj = config.emit_obj && config.obj_is_bitcode;\n+\n+        let bc_out = cgcx.output_filenames.temp_path(OutputType::Bitcode, module_name);\n+        let obj_out = cgcx.output_filenames.temp_path(OutputType::Object, module_name);\n+\n+\n+        if write_bc || config.emit_bc_compressed || config.embed_bitcode {\n+            let thin;\n+            let old;\n+            let data = if llvm::LLVMRustThinLTOAvailable() {\n+                thin = ThinBuffer::new(llmod);\n+                thin.data()\n+            } else {\n+                old = ModuleBuffer::new(llmod);\n+                old.data()\n+            };\n+            timeline.record(\"make-bc\");\n \n-        if config.emit_bc_compressed {\n-            let dst = bc_out.with_extension(RLIB_BYTECODE_EXTENSION);\n-            let data = bytecode::encode(&module.llmod_id, data);\n-            if let Err(e) = fs::write(&dst, data) {\n-                diag_handler.err(&format!(\"failed to write bytecode: {}\", e));\n+            if write_bc {\n+                if let Err(e) = fs::write(&bc_out, data) {\n+                    diag_handler.err(&format!(\"failed to write bytecode: {}\", e));\n+                }\n+                timeline.record(\"write-bc\");\n             }\n-            timeline.record(\"compress-bc\");\n-        }\n-    } else if config.embed_bitcode_marker {\n-        embed_bitcode(cgcx, llcx, llmod, None);\n-    }\n \n-    time_ext(config.time_passes, None, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n-         || -> Result<(), FatalError> {\n-        if config.emit_ir {\n-            let out = cgcx.output_filenames.temp_path(OutputType::LlvmAssembly, module_name);\n-            let out = path2cstr(&out);\n-\n-            extern \"C\" fn demangle_callback(input_ptr: *const c_char,\n-                                            input_len: size_t,\n-                                            output_ptr: *mut c_char,\n-                                            output_len: size_t) -> size_t {\n-                let input = unsafe {\n-                    slice::from_raw_parts(input_ptr as *const u8, input_len as usize)\n-                };\n+            if config.embed_bitcode {\n+                embed_bitcode(cgcx, llcx, llmod, Some(data));\n+                timeline.record(\"embed-bc\");\n+            }\n \n-                let input = match str::from_utf8(input) {\n-                    Ok(s) => s,\n-                    Err(_) => return 0,\n-                };\n+            if config.emit_bc_compressed {\n+                let dst = bc_out.with_extension(RLIB_BYTECODE_EXTENSION);\n+                let data = bytecode::encode(&module.llmod_id, data);\n+                if let Err(e) = fs::write(&dst, data) {\n+                    diag_handler.err(&format!(\"failed to write bytecode: {}\", e));\n+                }\n+                timeline.record(\"compress-bc\");\n+            }\n+        } else if config.embed_bitcode_marker {\n+            embed_bitcode(cgcx, llcx, llmod, None);\n+        }\n+\n+        time_ext(config.time_passes, None, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n+            || -> Result<(), FatalError> {\n+            if config.emit_ir {\n+                let out = cgcx.output_filenames.temp_path(OutputType::LlvmAssembly, module_name);\n+                let out = path2cstr(&out);\n+\n+                extern \"C\" fn demangle_callback(input_ptr: *const c_char,\n+                                                input_len: size_t,\n+                                                output_ptr: *mut c_char,\n+                                                output_len: size_t) -> size_t {\n+                    let input = unsafe {\n+                        slice::from_raw_parts(input_ptr as *const u8, input_len as usize)\n+                    };\n \n-                let output = unsafe {\n-                    slice::from_raw_parts_mut(output_ptr as *mut u8, output_len as usize)\n-                };\n-                let mut cursor = io::Cursor::new(output);\n+                    let input = match str::from_utf8(input) {\n+                        Ok(s) => s,\n+                        Err(_) => return 0,\n+                    };\n \n-                let demangled = match rustc_demangle::try_demangle(input) {\n-                    Ok(d) => d,\n-                    Err(_) => return 0,\n-                };\n+                    let output = unsafe {\n+                        slice::from_raw_parts_mut(output_ptr as *mut u8, output_len as usize)\n+                    };\n+                    let mut cursor = io::Cursor::new(output);\n+\n+                    let demangled = match rustc_demangle::try_demangle(input) {\n+                        Ok(d) => d,\n+                        Err(_) => return 0,\n+                    };\n \n-                if let Err(_) = write!(cursor, \"{:#}\", demangled) {\n-                    // Possible only if provided buffer is not big enough\n-                    return 0;\n+                    if let Err(_) = write!(cursor, \"{:#}\", demangled) {\n+                        // Possible only if provided buffer is not big enough\n+                        return 0;\n+                    }\n+\n+                    cursor.position() as size_t\n                 }\n \n-                cursor.position() as size_t\n+                with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                    llvm::LLVMRustPrintModule(cpm, llmod, out.as_ptr(), demangle_callback);\n+                    llvm::LLVMDisposePassManager(cpm);\n+                });\n+                timeline.record(\"ir\");\n             }\n \n-            with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                llvm::LLVMRustPrintModule(cpm, llmod, out.as_ptr(), demangle_callback);\n-                llvm::LLVMDisposePassManager(cpm);\n-            });\n-            timeline.record(\"ir\");\n-        }\n+            if config.emit_asm || asm_to_obj {\n+                let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n \n-        if config.emit_asm || asm_to_obj {\n-            let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n-\n-            // We can't use the same module for asm and binary output, because that triggers\n-            // various errors like invalid IR or broken binaries, so we might have to clone the\n-            // module to produce the asm output\n-            let llmod = if config.emit_obj {\n-                llvm::LLVMCloneModule(llmod)\n-            } else {\n-                llmod\n-            };\n-            with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                write_output_file(diag_handler, tm, cpm, llmod, &path,\n-                                  llvm::FileType::AssemblyFile)\n-            })?;\n-            if config.emit_obj {\n-                llvm::LLVMDisposeModule(llmod);\n+                // We can't use the same module for asm and binary output, because that triggers\n+                // various errors like invalid IR or broken binaries, so we might have to clone the\n+                // module to produce the asm output\n+                let llmod = if config.emit_obj {\n+                    llvm::LLVMCloneModule(llmod)\n+                } else {\n+                    llmod\n+                };\n+                with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                    write_output_file(diag_handler, tm, cpm, llmod, &path,\n+                                    llvm::FileType::AssemblyFile)\n+                })?;\n+                timeline.record(\"asm\");\n             }\n-            timeline.record(\"asm\");\n-        }\n \n-        if write_obj {\n-            with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                write_output_file(diag_handler, tm, cpm, llmod, &obj_out,\n-                                  llvm::FileType::ObjectFile)\n-            })?;\n-            timeline.record(\"obj\");\n-        } else if asm_to_obj {\n-            let assembly = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n-            run_assembler(cgcx, diag_handler, &assembly, &obj_out);\n-            timeline.record(\"asm_to_obj\");\n-\n-            if !config.emit_asm && !cgcx.save_temps {\n-                drop(fs::remove_file(&assembly));\n+            if write_obj {\n+                with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                    write_output_file(diag_handler, tm, cpm, llmod, &obj_out,\n+                                    llvm::FileType::ObjectFile)\n+                })?;\n+                timeline.record(\"obj\");\n+            } else if asm_to_obj {\n+                let assembly = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n+                run_assembler(cgcx, diag_handler, &assembly, &obj_out);\n+                timeline.record(\"asm_to_obj\");\n+\n+                if !config.emit_asm && !cgcx.save_temps {\n+                    drop(fs::remove_file(&assembly));\n+                }\n             }\n-        }\n \n-        Ok(())\n-    })?;\n+            Ok(())\n+        })?;\n \n-    if copy_bc_to_obj {\n-        debug!(\"copying bitcode {:?} to obj {:?}\", bc_out, obj_out);\n-        if let Err(e) = link_or_copy(&bc_out, &obj_out) {\n-            diag_handler.err(&format!(\"failed to copy bitcode to object file: {}\", e));\n+        if copy_bc_to_obj {\n+            debug!(\"copying bitcode {:?} to obj {:?}\", bc_out, obj_out);\n+            if let Err(e) = link_or_copy(&bc_out, &obj_out) {\n+                diag_handler.err(&format!(\"failed to copy bitcode to object file: {}\", e));\n+            }\n         }\n-    }\n \n-    if rm_bc {\n-        debug!(\"removing_bitcode {:?}\", bc_out);\n-        if let Err(e) = fs::remove_file(&bc_out) {\n-            diag_handler.err(&format!(\"failed to remove bitcode: {}\", e));\n+        if rm_bc {\n+            debug!(\"removing_bitcode {:?}\", bc_out);\n+            if let Err(e) = fs::remove_file(&bc_out) {\n+                diag_handler.err(&format!(\"failed to remove bitcode: {}\", e));\n+            }\n         }\n-    }\n \n-    drop(handlers);\n+        drop(handlers);\n+    }\n     Ok(module.into_compiled_module(config.emit_obj,\n                                    config.emit_bc,\n                                    config.emit_bc_compressed,\n@@ -828,8 +825,8 @@ unsafe fn codegen(cgcx: &CodegenContext,\n /// Basically all of this is us attempting to follow in the footsteps of clang\n /// on iOS. See #35968 for lots more info.\n unsafe fn embed_bitcode(cgcx: &CodegenContext,\n-                        llcx: ContextRef,\n-                        llmod: ModuleRef,\n+                        llcx: &llvm::Context,\n+                        llmod: &llvm::Module,\n                         bitcode: Option<&[u8]>) {\n     let llconst = C_bytes_in_context(llcx, bitcode.unwrap_or(&[]));\n     let llglobal = llvm::LLVMAddGlobal(\n@@ -2050,7 +2047,7 @@ pub fn run_assembler(cgcx: &CodegenContext, handler: &Handler, assembly: &Path,\n     }\n }\n \n-pub unsafe fn with_llvm_pmb(llmod: ModuleRef,\n+pub unsafe fn with_llvm_pmb(llmod: &llvm::Module,\n                             config: &ModuleConfig,\n                             opt_level: llvm::CodeGenOptLevel,\n                             prepare_for_thin_lto: bool,\n@@ -2353,7 +2350,7 @@ fn msvc_imps_needed(tcx: TyCtxt) -> bool {\n // when using MSVC linker.  We do this only for data, as linker can fix up\n // code references on its own.\n // See #26591, #27438\n-fn create_msvc_imps(cgcx: &CodegenContext, llcx: ContextRef, llmod: ModuleRef) {\n+fn create_msvc_imps(cgcx: &CodegenContext, llcx: &llvm::Context, llmod: &llvm::Module) {\n     if !cgcx.msvc_imps_needed {\n         return\n     }"}, {"sha": "c4fb251c5f42c208e4aedf012908f784493074d4", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 26, "deletions": 46, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=249d5acaec0b10ee15b21b888977b5445baba42e", "patch": "@@ -30,8 +30,8 @@ use super::ModuleKind;\n \n use abi;\n use back::link;\n-use back::write::{self, OngoingCodegen, create_target_machine};\n-use llvm::{ContextRef, ModuleRef, ValueRef, Vector, get_param};\n+use back::write::{self, OngoingCodegen};\n+use llvm::{ValueRef, Vector, get_param};\n use llvm;\n use metadata;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n@@ -59,7 +59,7 @@ use rustc_mir::monomorphize::collector::{self, MonoItemCollectionMode};\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n use common::{self, C_struct_in_context, C_array, val_ty};\n use consts;\n-use context::{self, CodegenCx};\n+use context::CodegenCx;\n use debuginfo;\n use declare;\n use meth;\n@@ -77,7 +77,6 @@ use rustc_data_structures::sync::Lrc;\n \n use std::any::Any;\n use std::ffi::CString;\n-use std::str;\n use std::sync::Arc;\n use std::time::{Instant, Duration};\n use std::i32;\n@@ -609,16 +608,14 @@ fn maybe_create_entry_wrapper(cx: &CodegenCx) {\n }\n \n fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-                            llmod_id: &str,\n+                            llvm_module: &ModuleLlvm,\n                             link_meta: &LinkMeta)\n-                            -> (ContextRef, ModuleRef, EncodedMetadata) {\n+                            -> EncodedMetadata {\n     use std::io::Write;\n     use flate2::Compression;\n     use flate2::write::DeflateEncoder;\n \n-    let (metadata_llcx, metadata_llmod) = unsafe {\n-        context::create_context_and_module(tcx.sess, llmod_id)\n-    };\n+    let (metadata_llcx, metadata_llmod) = (&*llvm_module.llcx, llvm_module.llmod());\n \n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n     enum MetadataKind {\n@@ -641,14 +638,12 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     }).max().unwrap_or(MetadataKind::None);\n \n     if kind == MetadataKind::None {\n-        return (metadata_llcx,\n-                metadata_llmod,\n-                EncodedMetadata::new());\n+        return EncodedMetadata::new();\n     }\n \n     let metadata = tcx.encode_metadata(link_meta);\n     if kind == MetadataKind::Uncompressed {\n-        return (metadata_llcx, metadata_llmod, metadata);\n+        return metadata;\n     }\n \n     assert!(kind == MetadataKind::Compressed);\n@@ -676,7 +671,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n         let directive = CString::new(directive).unwrap();\n         llvm::LLVMSetModuleInlineAsm(metadata_llmod, directive.as_ptr())\n     }\n-    return (metadata_llcx, metadata_llmod, metadata);\n+    return metadata;\n }\n \n pub struct ValueIter {\n@@ -698,7 +693,7 @@ impl Iterator for ValueIter {\n     }\n }\n \n-pub fn iter_globals(llmod: llvm::ModuleRef) -> ValueIter {\n+pub fn iter_globals(llmod: &llvm::Module) -> ValueIter {\n     unsafe {\n         ValueIter {\n             cur: llvm::LLVMGetFirstGlobal(llmod),\n@@ -731,19 +726,15 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Codegen the metadata.\n     let llmod_id = \"metadata\";\n-    let (metadata_llcx, metadata_llmod, metadata) =\n-        time(tcx.sess, \"write metadata\", || {\n-            write_metadata(tcx, llmod_id, &link_meta)\n-        });\n+    let metadata_llvm_module = ModuleLlvm::new(tcx.sess, llmod_id);\n+    let metadata = time(tcx.sess, \"write metadata\", || {\n+        write_metadata(tcx, &metadata_llvm_module, &link_meta)\n+    });\n \n     let metadata_module = ModuleCodegen {\n         name: link::METADATA_MODULE_NAME.to_string(),\n         llmod_id: llmod_id.to_string(),\n-        source: ModuleSource::Codegened(ModuleLlvm {\n-            llcx: metadata_llcx,\n-            llmod: metadata_llmod,\n-            tm: create_target_machine(tcx.sess, false),\n-        }),\n+        source: ModuleSource::Codegened(metadata_llvm_module),\n         kind: ModuleKind::Metadata,\n     };\n \n@@ -803,13 +794,7 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let allocator_module = if let Some(kind) = *tcx.sess.allocator_kind.get() {\n         unsafe {\n             let llmod_id = \"allocator\";\n-            let (llcx, llmod) =\n-                context::create_context_and_module(tcx.sess, llmod_id);\n-            let modules = ModuleLlvm {\n-                llmod,\n-                llcx,\n-                tm: create_target_machine(tcx.sess, false),\n-            };\n+            let modules = ModuleLlvm::new(tcx.sess, llmod_id);\n             time(tcx.sess, \"write allocator module\", || {\n                 allocator::codegen(tcx, &modules, kind)\n             });\n@@ -1200,8 +1185,9 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    .to_fingerprint().to_hex());\n \n         // Instantiate monomorphizations without filling out definitions yet...\n-        let cx = CodegenCx::new(tcx, cgu, &llmod_id);\n-        let module = {\n+        let llvm_module = ModuleLlvm::new(tcx.sess, &llmod_id);\n+        let stats = {\n+            let cx = CodegenCx::new(tcx, cgu, &llvm_module);\n             let mono_items = cx.codegen_unit\n                                  .items_in_deterministic_order(cx.tcx);\n             for &(mono_item, (linkage, visibility)) in &mono_items {\n@@ -1248,21 +1234,15 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 debuginfo::finalize(&cx);\n             }\n \n-            let llvm_module = ModuleLlvm {\n-                llcx: cx.llcx,\n-                llmod: cx.llmod,\n-                tm: create_target_machine(cx.sess(), false),\n-            };\n-\n-            ModuleCodegen {\n-                name: cgu_name,\n-                source: ModuleSource::Codegened(llvm_module),\n-                kind: ModuleKind::Regular,\n-                llmod_id,\n-            }\n+            cx.stats.into_inner()\n         };\n \n-        (cx.into_stats(), module)\n+        (stats, ModuleCodegen {\n+            name: cgu_name,\n+            source: ModuleSource::Codegened(llvm_module),\n+            kind: ModuleKind::Regular,\n+            llmod_id,\n+        })\n     }\n }\n "}, {"sha": "be948442707c1dd5de3af95700a0e03f74b8cbc9", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=249d5acaec0b10ee15b21b888977b5445baba42e", "patch": "@@ -13,7 +13,7 @@\n //! Code that is useful in various codegen modules.\n \n use llvm;\n-use llvm::{ValueRef, ContextRef, TypeKind};\n+use llvm::{ValueRef, TypeKind};\n use llvm::{True, False, Bool, OperandBundleDef};\n use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::LangItem;\n@@ -225,7 +225,7 @@ pub fn C_struct(cx: &CodegenCx, elts: &[ValueRef], packed: bool) -> ValueRef {\n     C_struct_in_context(cx.llcx, elts, packed)\n }\n \n-pub fn C_struct_in_context(llcx: ContextRef, elts: &[ValueRef], packed: bool) -> ValueRef {\n+pub fn C_struct_in_context(llcx: &llvm::Context, elts: &[ValueRef], packed: bool) -> ValueRef {\n     unsafe {\n         llvm::LLVMConstStructInContext(llcx,\n                                        elts.as_ptr(), elts.len() as c_uint,\n@@ -249,7 +249,7 @@ pub fn C_bytes(cx: &CodegenCx, bytes: &[u8]) -> ValueRef {\n     C_bytes_in_context(cx.llcx, bytes)\n }\n \n-pub fn C_bytes_in_context(llcx: ContextRef, bytes: &[u8]) -> ValueRef {\n+pub fn C_bytes_in_context(llcx: &llvm::Context, bytes: &[u8]) -> ValueRef {\n     unsafe {\n         let ptr = bytes.as_ptr() as *const c_char;\n         return llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True);"}, {"sha": "f91173226c48d4bad7e9a828fde7dc1c60816d9a", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 51, "deletions": 59, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=249d5acaec0b10ee15b21b888977b5445baba42e", "patch": "@@ -10,7 +10,7 @@\n \n use common;\n use llvm;\n-use llvm::{ContextRef, ModuleRef, ValueRef};\n+use llvm::ValueRef;\n use rustc::dep_graph::DepGraphSafe;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -42,16 +42,16 @@ use syntax::symbol::LocalInternedString;\n use abi::Abi;\n \n /// There is one `CodegenCx` per compilation unit. Each one has its own LLVM\n-/// `ContextRef` so that several compilation units may be optimized in parallel.\n-/// All other LLVM data structures in the `CodegenCx` are tied to that `ContextRef`.\n+/// `llvm::Context` so that several compilation units may be optimized in parallel.\n+/// All other LLVM data structures in the `CodegenCx` are tied to that `llvm::Context`.\n pub struct CodegenCx<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub check_overflow: bool,\n     pub use_dll_storage_attrs: bool,\n     pub tls_model: llvm::ThreadLocalMode,\n \n-    pub llmod: ModuleRef,\n-    pub llcx: ContextRef,\n+    pub llmod: &'a llvm::Module,\n+    pub llcx: &'a llvm::Context,\n     pub stats: RefCell<Stats>,\n     pub codegen_unit: Arc<CodegenUnit<'tcx>>,\n \n@@ -94,7 +94,7 @@ pub struct CodegenCx<'a, 'tcx: 'a> {\n     pub pointee_infos: RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>>,\n     pub isize_ty: Type,\n \n-    pub dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n+    pub dbg_cx: Option<debuginfo::CrateDebugContext<'a, 'tcx>>,\n \n     eh_personality: Cell<Option<ValueRef>>,\n     eh_unwind_resume: Cell<Option<ValueRef>>,\n@@ -155,8 +155,7 @@ pub fn is_pie_binary(sess: &Session) -> bool {\n     !is_any_library(sess) && get_reloc_model(sess) == llvm::RelocMode::PIC\n }\n \n-pub unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextRef, ModuleRef) {\n-    let llcx = llvm::LLVMRustContextCreate(sess.fewer_names());\n+pub unsafe fn create_module(sess: &Session, llcx: &'ll llvm::Context, mod_name: &str) -> &'ll llvm::Module {\n     let mod_name = CString::new(mod_name).unwrap();\n     let llmod = llvm::LLVMModuleCreateWithNameInContext(mod_name.as_ptr(), llcx);\n \n@@ -208,13 +207,13 @@ pub unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (Cont\n         llvm::LLVMRustSetModulePIELevel(llmod);\n     }\n \n-    (llcx, llmod)\n+    llmod\n }\n \n impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    crate fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                codegen_unit: Arc<CodegenUnit<'tcx>>,\n-               llmod_id: &str)\n+               llvm_module: &'a ::ModuleLlvm)\n                -> CodegenCx<'a, 'tcx> {\n         // An interesting part of Windows which MSVC forces our hand on (and\n         // apparently MinGW didn't) is the usage of `dllimport` and `dllexport`\n@@ -265,55 +264,48 @@ impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n \n         let tls_model = get_tls_model(&tcx.sess);\n \n-        unsafe {\n-            let (llcx, llmod) = create_context_and_module(&tcx.sess,\n-                                                          &llmod_id[..]);\n-\n-            let dbg_cx = if tcx.sess.opts.debuginfo != NoDebugInfo {\n-                let dctx = debuginfo::CrateDebugContext::new(llmod);\n-                debuginfo::metadata::compile_unit_metadata(tcx,\n-                                                           &codegen_unit.name().as_str(),\n-                                                           &dctx);\n-                Some(dctx)\n-            } else {\n-                None\n-            };\n-\n-            let isize_ty = Type::ix_llcx(llcx, tcx.data_layout.pointer_size.bits());\n-\n-            CodegenCx {\n-                tcx,\n-                check_overflow,\n-                use_dll_storage_attrs,\n-                tls_model,\n-                llmod,\n-                llcx,\n-                stats: RefCell::new(Stats::default()),\n-                codegen_unit,\n-                instances: RefCell::new(FxHashMap()),\n-                vtables: RefCell::new(FxHashMap()),\n-                const_cstr_cache: RefCell::new(FxHashMap()),\n-                const_unsized: RefCell::new(FxHashMap()),\n-                const_globals: RefCell::new(FxHashMap()),\n-                statics: RefCell::new(FxHashMap()),\n-                statics_to_rauw: RefCell::new(Vec::new()),\n-                used_statics: RefCell::new(Vec::new()),\n-                lltypes: RefCell::new(FxHashMap()),\n-                scalar_lltypes: RefCell::new(FxHashMap()),\n-                pointee_infos: RefCell::new(FxHashMap()),\n-                isize_ty,\n-                dbg_cx,\n-                eh_personality: Cell::new(None),\n-                eh_unwind_resume: Cell::new(None),\n-                rust_try_fn: Cell::new(None),\n-                intrinsics: RefCell::new(FxHashMap()),\n-                local_gen_sym_counter: Cell::new(0),\n-            }\n-        }\n-    }\n+        let (llcx, llmod) = (&*llvm_module.llcx, llvm_module.llmod());\n \n-    pub fn into_stats(self) -> Stats {\n-        self.stats.into_inner()\n+        let dbg_cx = if tcx.sess.opts.debuginfo != NoDebugInfo {\n+            let dctx = debuginfo::CrateDebugContext::new(llmod);\n+            debuginfo::metadata::compile_unit_metadata(tcx,\n+                                                        &codegen_unit.name().as_str(),\n+                                                        &dctx);\n+            Some(dctx)\n+        } else {\n+            None\n+        };\n+\n+        let isize_ty = Type::ix_llcx(llcx, tcx.data_layout.pointer_size.bits());\n+\n+        CodegenCx {\n+            tcx,\n+            check_overflow,\n+            use_dll_storage_attrs,\n+            tls_model,\n+            llmod,\n+            llcx,\n+            stats: RefCell::new(Stats::default()),\n+            codegen_unit,\n+            instances: RefCell::new(FxHashMap()),\n+            vtables: RefCell::new(FxHashMap()),\n+            const_cstr_cache: RefCell::new(FxHashMap()),\n+            const_unsized: RefCell::new(FxHashMap()),\n+            const_globals: RefCell::new(FxHashMap()),\n+            statics: RefCell::new(FxHashMap()),\n+            statics_to_rauw: RefCell::new(Vec::new()),\n+            used_statics: RefCell::new(Vec::new()),\n+            lltypes: RefCell::new(FxHashMap()),\n+            scalar_lltypes: RefCell::new(FxHashMap()),\n+            pointee_infos: RefCell::new(FxHashMap()),\n+            isize_ty,\n+            dbg_cx,\n+            eh_personality: Cell::new(None),\n+            eh_unwind_resume: Cell::new(None),\n+            rust_try_fn: Cell::new(None),\n+            intrinsics: RefCell::new(FxHashMap()),\n+            local_gen_sym_counter: Cell::new(0),\n+        }\n     }\n }\n "}, {"sha": "e7a6dc452221462c0634b89ec3af0a8151bb2cc7", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=249d5acaec0b10ee15b21b888977b5445baba42e", "patch": "@@ -862,7 +862,7 @@ pub fn compile_unit_metadata(tcx: TyCtxt,\n         return unit_metadata;\n     };\n \n-    fn path_to_mdstring(llcx: llvm::ContextRef, path: &Path) -> llvm::ValueRef {\n+    fn path_to_mdstring(llcx: &llvm::Context, path: &Path) -> llvm::ValueRef {\n         let path_str = path2cstr(path);\n         unsafe {\n             llvm::LLVMMDStringInContext(llcx,"}, {"sha": "d4b5110603369b4385cf2b1ee4552e1812fcfc53", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=249d5acaec0b10ee15b21b888977b5445baba42e", "patch": "@@ -21,7 +21,7 @@ use self::metadata::{type_metadata, file_metadata, TypeMap};\n use self::source_loc::InternalDebugLocation::{self, UnknownLocation};\n \n use llvm;\n-use llvm::{ModuleRef, ContextRef, ValueRef};\n+use llvm::ValueRef;\n use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilderRef, DISubprogram, DIArray, DIFlags};\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::{DefId, CrateNum};\n@@ -67,9 +67,9 @@ const DW_TAG_auto_variable: c_uint = 0x100;\n const DW_TAG_arg_variable: c_uint = 0x101;\n \n /// A context object for maintaining all state needed by the debuginfo module.\n-pub struct CrateDebugContext<'tcx> {\n-    llcontext: ContextRef,\n-    llmod: ModuleRef,\n+pub struct CrateDebugContext<'a, 'tcx> {\n+    llcontext: &'a llvm::Context,\n+    llmod: &'a llvm::Module,\n     builder: DIBuilderRef,\n     created_files: RefCell<FxHashMap<(Symbol, Symbol), DIFile>>,\n     created_enum_disr_types: RefCell<FxHashMap<(DefId, layout::Primitive), DIType>>,\n@@ -82,8 +82,8 @@ pub struct CrateDebugContext<'tcx> {\n     composite_types_completed: RefCell<FxHashSet<DIType>>,\n }\n \n-impl<'tcx> CrateDebugContext<'tcx> {\n-    pub fn new(llmod: ModuleRef) -> CrateDebugContext<'tcx> {\n+impl<'a, 'tcx> CrateDebugContext<'a, 'tcx> {\n+    pub fn new(llmod: &'a llvm::Module) -> Self {\n         debug!(\"CrateDebugContext::new\");\n         let builder = unsafe { llvm::LLVMRustDIBuilderCreate(llmod) };\n         // DIBuilder inherits context from the module, so we'd better use the same one"}, {"sha": "85cddb0a580a58731854626f907135b75e5dd42b", "filename": "src/librustc_codegen_llvm/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs?ref=249d5acaec0b10ee15b21b888977b5445baba42e", "patch": "@@ -50,7 +50,7 @@ pub fn span_start(cx: &CodegenCx, span: Span) -> syntax_pos::Loc {\n \n #[inline]\n pub fn debug_context<'a, 'tcx>(cx: &'a CodegenCx<'a, 'tcx>)\n-                           -> &'a CrateDebugContext<'tcx> {\n+                           -> &'a CrateDebugContext<'a, 'tcx> {\n     cx.dbg_cx.as_ref().unwrap()\n }\n "}, {"sha": "724a2e3e65f4247a7a12c6936af79e58638fb46c", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=249d5acaec0b10ee15b21b888977b5445baba42e", "patch": "@@ -20,9 +20,11 @@\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(crate_visibility_modifier)]\n #![feature(custom_attribute)]\n #![feature(extern_types)]\n #![feature(fs_read_write)]\n+#![feature(in_band_lifetimes)]\n #![allow(unused_attributes)]\n #![feature(libc)]\n #![feature(quote)]\n@@ -34,6 +36,7 @@\n #![feature(link_args)]\n #![feature(static_nobundle)]\n \n+use back::write::create_target_machine;\n use rustc::dep_graph::WorkProduct;\n use syntax_pos::symbol::Symbol;\n \n@@ -340,22 +343,41 @@ enum ModuleSource {\n     Codegened(ModuleLlvm),\n }\n \n-#[derive(Debug)]\n struct ModuleLlvm {\n-    llcx: llvm::ContextRef,\n-    llmod: llvm::ModuleRef,\n-    tm: llvm::TargetMachineRef,\n+    llcx: &'static mut llvm::Context,\n+    llmod_raw: *const llvm::Module,\n+    tm: &'static mut llvm::TargetMachine,\n }\n \n unsafe impl Send for ModuleLlvm { }\n unsafe impl Sync for ModuleLlvm { }\n \n+impl ModuleLlvm {\n+    fn new(sess: &Session, mod_name: &str) -> Self {\n+        unsafe {\n+            let llcx = llvm::LLVMRustContextCreate(sess.fewer_names());\n+            let llmod_raw = context::create_module(sess, llcx, mod_name) as *const _;\n+\n+            ModuleLlvm {\n+                llmod_raw,\n+                llcx,\n+                tm: create_target_machine(sess, false),\n+            }\n+        }\n+    }\n+\n+    fn llmod(&self) -> &llvm::Module {\n+        unsafe {\n+            &*self.llmod_raw\n+        }\n+    }\n+}\n+\n impl Drop for ModuleLlvm {\n     fn drop(&mut self) {\n         unsafe {\n-            llvm::LLVMDisposeModule(self.llmod);\n-            llvm::LLVMContextDispose(self.llcx);\n-            llvm::LLVMRustDisposeTargetMachine(self.tm);\n+            llvm::LLVMContextDispose(&mut *(self.llcx as *mut _));\n+            llvm::LLVMRustDisposeTargetMachine(&mut *(self.tm as *mut _));\n         }\n     }\n }"}, {"sha": "9d94869dab06e85e2d0c32387d66d7ecace9585a", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 82, "deletions": 86, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=249d5acaec0b10ee15b21b888977b5445baba42e", "patch": "@@ -375,10 +375,8 @@ pub enum ThreadLocalMode {\n }\n \n // Opaque pointer types\n-extern { pub type Module_opaque; }\n-pub type ModuleRef = *mut Module_opaque;\n-extern { pub type Context_opaque; }\n-pub type ContextRef = *mut Context_opaque;\n+extern { pub type Module; }\n+extern { pub type Context; }\n extern { pub type Type_opaque; }\n pub type TypeRef = *mut Type_opaque;\n extern { pub type Value_opaque; }\n@@ -407,8 +405,8 @@ extern { pub type SectionIterator_opaque; }\n pub type SectionIteratorRef = *mut SectionIterator_opaque;\n extern { pub type Pass_opaque; }\n pub type PassRef = *mut Pass_opaque;\n-extern { pub type TargetMachine_opaque; }\n-pub type TargetMachineRef = *mut TargetMachine_opaque;\n+extern { pub type TargetMachine; }\n+pub type TargetMachineRef = *const TargetMachine;\n extern { pub type Archive_opaque; }\n pub type ArchiveRef = *mut Archive_opaque;\n extern { pub type ArchiveIterator_opaque; }\n@@ -498,43 +496,42 @@ extern { pub type ModuleBuffer; }\n #[allow(improper_ctypes)] // TODO remove this (use for NonNull)\n extern \"C\" {\n     // Create and destroy contexts.\n-    pub fn LLVMRustContextCreate(shouldDiscardNames: bool) -> ContextRef;\n-    pub fn LLVMContextDispose(C: ContextRef);\n-    pub fn LLVMGetMDKindIDInContext(C: ContextRef, Name: *const c_char, SLen: c_uint) -> c_uint;\n+    pub fn LLVMRustContextCreate(shouldDiscardNames: bool) -> &'static mut Context;\n+    pub fn LLVMContextDispose(C: &'static mut Context);\n+    pub fn LLVMGetMDKindIDInContext(C: &Context, Name: *const c_char, SLen: c_uint) -> c_uint;\n \n-    // Create and destroy modules.\n-    pub fn LLVMModuleCreateWithNameInContext(ModuleID: *const c_char, C: ContextRef) -> ModuleRef;\n-    pub fn LLVMGetModuleContext(M: ModuleRef) -> ContextRef;\n-    pub fn LLVMCloneModule(M: ModuleRef) -> ModuleRef;\n-    pub fn LLVMDisposeModule(M: ModuleRef);\n+    // Create modules.\n+    pub fn LLVMModuleCreateWithNameInContext(ModuleID: *const c_char, C: &Context) -> &Module;\n+    pub fn LLVMGetModuleContext(M: &Module) -> &Context;\n+    pub fn LLVMCloneModule(M: &Module) -> &Module;\n \n     /// Data layout. See Module::getDataLayout.\n-    pub fn LLVMGetDataLayout(M: ModuleRef) -> *const c_char;\n-    pub fn LLVMSetDataLayout(M: ModuleRef, Triple: *const c_char);\n+    pub fn LLVMGetDataLayout(M: &Module) -> *const c_char;\n+    pub fn LLVMSetDataLayout(M: &Module, Triple: *const c_char);\n \n     /// See Module::dump.\n-    pub fn LLVMDumpModule(M: ModuleRef);\n+    pub fn LLVMDumpModule(M: &Module);\n \n     /// See Module::setModuleInlineAsm.\n-    pub fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *const c_char);\n-    pub fn LLVMRustAppendModuleInlineAsm(M: ModuleRef, Asm: *const c_char);\n+    pub fn LLVMSetModuleInlineAsm(M: &Module, Asm: *const c_char);\n+    pub fn LLVMRustAppendModuleInlineAsm(M: &Module, Asm: *const c_char);\n \n     /// See llvm::LLVMTypeKind::getTypeID.\n     pub fn LLVMRustGetTypeKind(Ty: TypeRef) -> TypeKind;\n \n     // Operations on integer types\n-    pub fn LLVMInt1TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMInt8TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMInt16TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMInt32TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMInt64TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMIntTypeInContext(C: ContextRef, NumBits: c_uint) -> TypeRef;\n+    pub fn LLVMInt1TypeInContext(C: &Context) -> TypeRef;\n+    pub fn LLVMInt8TypeInContext(C: &Context) -> TypeRef;\n+    pub fn LLVMInt16TypeInContext(C: &Context) -> TypeRef;\n+    pub fn LLVMInt32TypeInContext(C: &Context) -> TypeRef;\n+    pub fn LLVMInt64TypeInContext(C: &Context) -> TypeRef;\n+    pub fn LLVMIntTypeInContext(C: &Context, NumBits: c_uint) -> TypeRef;\n \n     pub fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> c_uint;\n \n     // Operations on real types\n-    pub fn LLVMFloatTypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMDoubleTypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMFloatTypeInContext(C: &Context) -> TypeRef;\n+    pub fn LLVMDoubleTypeInContext(C: &Context) -> TypeRef;\n \n     // Operations on function types\n     pub fn LLVMFunctionType(ReturnType: TypeRef,\n@@ -547,7 +544,7 @@ extern \"C\" {\n     pub fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *mut TypeRef);\n \n     // Operations on struct types\n-    pub fn LLVMStructTypeInContext(C: ContextRef,\n+    pub fn LLVMStructTypeInContext(C: &Context,\n                                    ElementTypes: *const TypeRef,\n                                    ElementCount: c_uint,\n                                    Packed: Bool)\n@@ -563,9 +560,9 @@ extern \"C\" {\n     pub fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n \n     // Operations on other types\n-    pub fn LLVMVoidTypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMX86MMXTypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMRustMetadataTypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMVoidTypeInContext(C: &Context) -> TypeRef;\n+    pub fn LLVMX86MMXTypeInContext(C: &Context) -> TypeRef;\n+    pub fn LLVMRustMetadataTypeInContext(C: &Context) -> TypeRef;\n \n     // Operations on all values\n     pub fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n@@ -589,9 +586,9 @@ extern \"C\" {\n     pub fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n \n     // Operations on metadata\n-    pub fn LLVMMDStringInContext(C: ContextRef, Str: *const c_char, SLen: c_uint) -> ValueRef;\n-    pub fn LLVMMDNodeInContext(C: ContextRef, Vals: *const ValueRef, Count: c_uint) -> ValueRef;\n-    pub fn LLVMAddNamedMetadataOperand(M: ModuleRef, Name: *const c_char, Val: ValueRef);\n+    pub fn LLVMMDStringInContext(C: &Context, Str: *const c_char, SLen: c_uint) -> ValueRef;\n+    pub fn LLVMMDNodeInContext(C: &Context, Vals: *const ValueRef, Count: c_uint) -> ValueRef;\n+    pub fn LLVMAddNamedMetadataOperand(M: &Module, Name: *const c_char, Val: ValueRef);\n \n     // Operations on scalar constants\n     pub fn LLVMConstInt(IntTy: TypeRef, N: c_ulonglong, SignExtend: Bool) -> ValueRef;\n@@ -604,12 +601,12 @@ extern \"C\" {\n \n \n     // Operations on composite constants\n-    pub fn LLVMConstStringInContext(C: ContextRef,\n+    pub fn LLVMConstStringInContext(C: &Context,\n                                     Str: *const c_char,\n                                     Length: c_uint,\n                                     DontNullTerminate: Bool)\n                                     -> ValueRef;\n-    pub fn LLVMConstStructInContext(C: ContextRef,\n+    pub fn LLVMConstStructInContext(C: &Context,\n                                     ConstantVals: *const ValueRef,\n                                     Count: c_uint,\n                                     Packed: Bool)\n@@ -679,7 +676,6 @@ extern \"C\" {\n \n \n     // Operations on global variables, functions, and aliases (globals)\n-    pub fn LLVMGetGlobalParent(Global: ValueRef) -> ModuleRef;\n     pub fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n     pub fn LLVMRustGetLinkage(Global: ValueRef) -> Linkage;\n     pub fn LLVMRustSetLinkage(Global: ValueRef, RustLinkage: Linkage);\n@@ -694,10 +690,10 @@ extern \"C\" {\n \n     // Operations on global variables\n     pub fn LLVMIsAGlobalVariable(GlobalVar: ValueRef) -> ValueRef;\n-    pub fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMGetNamedGlobal(M: ModuleRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMRustGetOrInsertGlobal(M: ModuleRef, Name: *const c_char, T: TypeRef) -> ValueRef;\n-    pub fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n+    pub fn LLVMAddGlobal(M: &Module, Ty: TypeRef, Name: *const c_char) -> ValueRef;\n+    pub fn LLVMGetNamedGlobal(M: &Module, Name: *const c_char) -> ValueRef;\n+    pub fn LLVMRustGetOrInsertGlobal(M: &Module, Name: *const c_char, T: TypeRef) -> ValueRef;\n+    pub fn LLVMGetFirstGlobal(M: &Module) -> ValueRef;\n     pub fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n     pub fn LLVMDeleteGlobal(GlobalVar: ValueRef);\n     pub fn LLVMGetInitializer(GlobalVar: ValueRef) -> ValueRef;\n@@ -706,15 +702,15 @@ extern \"C\" {\n     pub fn LLVMSetThreadLocalMode(GlobalVar: ValueRef, Mode: ThreadLocalMode);\n     pub fn LLVMIsGlobalConstant(GlobalVar: ValueRef) -> Bool;\n     pub fn LLVMSetGlobalConstant(GlobalVar: ValueRef, IsConstant: Bool);\n-    pub fn LLVMRustGetNamedValue(M: ModuleRef, Name: *const c_char) -> ValueRef;\n+    pub fn LLVMRustGetNamedValue(M: &Module, Name: *const c_char) -> ValueRef;\n     pub fn LLVMSetTailCall(CallInst: ValueRef, IsTailCall: Bool);\n \n     // Operations on functions\n-    pub fn LLVMAddFunction(M: ModuleRef, Name: *const c_char, FunctionTy: TypeRef) -> ValueRef;\n-    pub fn LLVMGetNamedFunction(M: ModuleRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMGetFirstFunction(M: ModuleRef) -> ValueRef;\n+    pub fn LLVMAddFunction(M: &Module, Name: *const c_char, FunctionTy: TypeRef) -> ValueRef;\n+    pub fn LLVMGetNamedFunction(M: &Module, Name: *const c_char) -> ValueRef;\n+    pub fn LLVMGetFirstFunction(M: &Module) -> ValueRef;\n     pub fn LLVMGetNextFunction(Fn: ValueRef) -> ValueRef;\n-    pub fn LLVMRustGetOrInsertFunction(M: ModuleRef,\n+    pub fn LLVMRustGetOrInsertFunction(M: &Module,\n                                        Name: *const c_char,\n                                        FunctionTy: TypeRef)\n                                        -> ValueRef;\n@@ -736,7 +732,7 @@ extern \"C\" {\n     // Operations on basic blocks\n     pub fn LLVMBasicBlockAsValue(BB: BasicBlockRef) -> ValueRef;\n     pub fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMAppendBasicBlockInContext(C: ContextRef,\n+    pub fn LLVMAppendBasicBlockInContext(C: &Context,\n                                          Fn: ValueRef,\n                                          Name: *const c_char)\n                                          -> BasicBlockRef;\n@@ -767,7 +763,7 @@ extern \"C\" {\n                            Count: c_uint);\n \n     // Instruction builders\n-    pub fn LLVMCreateBuilderInContext(C: ContextRef) -> BuilderRef;\n+    pub fn LLVMCreateBuilderInContext(C: &Context) -> BuilderRef;\n     pub fn LLVMPositionBuilder(Builder: BuilderRef, Block: BasicBlockRef, Instr: ValueRef);\n     pub fn LLVMPositionBuilderBefore(Builder: BuilderRef, Instr: ValueRef);\n     pub fn LLVMPositionBuilderAtEnd(Builder: BuilderRef, Block: BasicBlockRef);\n@@ -1277,7 +1273,7 @@ extern \"C\" {\n     pub fn LLVMIsAStoreInst(Inst: ValueRef) -> ValueRef;\n \n     /// Writes a module to the specified path. Returns 0 on success.\n-    pub fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: *const c_char) -> c_int;\n+    pub fn LLVMWriteBitcodeToFile(M: &Module, Path: *const c_char) -> c_int;\n \n     /// Creates target data from a target layout string.\n     pub fn LLVMCreateTargetData(StringRep: *const c_char) -> TargetDataRef;\n@@ -1289,13 +1285,13 @@ extern \"C\" {\n     pub fn LLVMCreatePassManager() -> PassManagerRef;\n \n     /// Creates a function-by-function pass manager\n-    pub fn LLVMCreateFunctionPassManagerForModule(M: ModuleRef) -> PassManagerRef;\n+    pub fn LLVMCreateFunctionPassManagerForModule(M: &Module) -> PassManagerRef;\n \n     /// Disposes a pass manager.\n     pub fn LLVMDisposePassManager(PM: PassManagerRef);\n \n     /// Runs a pass manager on a module.\n-    pub fn LLVMRunPassManager(PM: PassManagerRef, M: ModuleRef) -> Bool;\n+    pub fn LLVMRunPassManager(PM: PassManagerRef, M: &Module) -> Bool;\n \n     pub fn LLVMInitializePasses();\n \n@@ -1351,7 +1347,7 @@ extern \"C\" {\n     /// Print the pass timings since static dtors aren't picking them up.\n     pub fn LLVMRustPrintPassTimings();\n \n-    pub fn LLVMStructCreateNamed(C: ContextRef, Name: *const c_char) -> TypeRef;\n+    pub fn LLVMStructCreateNamed(C: &Context, Name: *const c_char) -> TypeRef;\n \n     pub fn LLVMStructSetBody(StructTy: TypeRef,\n                              ElementTypes: *const TypeRef,\n@@ -1371,11 +1367,11 @@ extern \"C\" {\n     pub fn LLVMRustVersionMajor() -> u32;\n     pub fn LLVMRustVersionMinor() -> u32;\n \n-    pub fn LLVMRustAddModuleFlag(M: ModuleRef, name: *const c_char, value: u32);\n+    pub fn LLVMRustAddModuleFlag(M: &Module, name: *const c_char, value: u32);\n \n-    pub fn LLVMRustMetadataAsValue(C: ContextRef, MD: MetadataRef) -> ValueRef;\n+    pub fn LLVMRustMetadataAsValue(C: &Context, MD: MetadataRef) -> ValueRef;\n \n-    pub fn LLVMRustDIBuilderCreate(M: ModuleRef) -> DIBuilderRef;\n+    pub fn LLVMRustDIBuilderCreate(M: &Module) -> DIBuilderRef;\n \n     pub fn LLVMRustDIBuilderDispose(Builder: DIBuilderRef);\n \n@@ -1582,7 +1578,7 @@ extern \"C\" {\n                                                TypeArray: DIArray);\n \n \n-    pub fn LLVMRustDIBuilderCreateDebugLocation(Context: ContextRef,\n+    pub fn LLVMRustDIBuilderCreateDebugLocation(Context: &Context,\n                                                 Line: c_uint,\n                                                 Column: c_uint,\n                                                 Scope: DIScope,\n@@ -1618,11 +1614,11 @@ extern \"C\" {\n                                        DataSections: bool,\n                                        TrapUnreachable: bool,\n                                        Singlethread: bool)\n-                                       -> TargetMachineRef;\n-    pub fn LLVMRustDisposeTargetMachine(T: TargetMachineRef);\n-    pub fn LLVMRustAddAnalysisPasses(T: TargetMachineRef, PM: PassManagerRef, M: ModuleRef);\n+                                       -> Option<&'static mut TargetMachine>;\n+    pub fn LLVMRustDisposeTargetMachine(T: &'static mut TargetMachine);\n+    pub fn LLVMRustAddAnalysisPasses(T: TargetMachineRef, PM: PassManagerRef, M: &Module);\n     pub fn LLVMRustAddBuilderLibraryInfo(PMB: PassManagerBuilderRef,\n-                                         M: ModuleRef,\n+                                         M: &Module,\n                                          DisableSimplifyLibCalls: bool);\n     pub fn LLVMRustConfigurePassManagerBuilder(PMB: PassManagerBuilderRef,\n                                                OptLevel: CodeGenOptLevel,\n@@ -1633,28 +1629,28 @@ extern \"C\" {\n                                                PGOGenPath: *const c_char,\n                                                PGOUsePath: *const c_char);\n     pub fn LLVMRustAddLibraryInfo(PM: PassManagerRef,\n-                                  M: ModuleRef,\n+                                  M: &Module,\n                                   DisableSimplifyLibCalls: bool);\n-    pub fn LLVMRustRunFunctionPassManager(PM: PassManagerRef, M: ModuleRef);\n+    pub fn LLVMRustRunFunctionPassManager(PM: PassManagerRef, M: &Module);\n     pub fn LLVMRustWriteOutputFile(T: TargetMachineRef,\n                                    PM: PassManagerRef,\n-                                   M: ModuleRef,\n+                                   M: &Module,\n                                    Output: *const c_char,\n                                    FileType: FileType)\n                                    -> LLVMRustResult;\n     pub fn LLVMRustPrintModule(PM: PassManagerRef,\n-                               M: ModuleRef,\n+                               M: &Module,\n                                Output: *const c_char,\n                                Demangle: extern fn(*const c_char,\n                                                    size_t,\n                                                    *mut c_char,\n                                                    size_t) -> size_t);\n     pub fn LLVMRustSetLLVMOptions(Argc: c_int, Argv: *const *const c_char);\n     pub fn LLVMRustPrintPasses();\n-    pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *const c_char);\n+    pub fn LLVMRustSetNormalizedTarget(M: &Module, triple: *const c_char);\n     pub fn LLVMRustAddAlwaysInlinePass(P: PassManagerBuilderRef, AddLifetimes: bool);\n-    pub fn LLVMRustRunRestrictionPass(M: ModuleRef, syms: *const *const c_char, len: size_t);\n-    pub fn LLVMRustMarkAllFunctionsNounwind(M: ModuleRef);\n+    pub fn LLVMRustRunRestrictionPass(M: &Module, syms: *const *const c_char, len: size_t);\n+    pub fn LLVMRustMarkAllFunctionsNounwind(M: &Module);\n \n     pub fn LLVMRustOpenArchive(path: *const c_char) -> ArchiveRef;\n     pub fn LLVMRustArchiveIteratorNew(AR: ArchiveRef) -> ArchiveIteratorRef;\n@@ -1669,7 +1665,7 @@ extern \"C\" {\n \n     pub fn LLVMRustWriteTwineToString(T: TwineRef, s: RustStringRef);\n \n-    pub fn LLVMContextSetDiagnosticHandler(C: ContextRef,\n+    pub fn LLVMContextSetDiagnosticHandler(C: &Context,\n                                            Handler: DiagnosticHandler,\n                                            DiagnosticContext: *mut c_void);\n \n@@ -1688,7 +1684,7 @@ extern \"C\" {\n     pub fn LLVMRustWriteDiagnosticInfoToString(DI: DiagnosticInfoRef, s: RustStringRef);\n     pub fn LLVMRustGetDiagInfoKind(DI: DiagnosticInfoRef) -> DiagnosticKind;\n \n-    pub fn LLVMRustSetInlineAsmDiagnosticHandler(C: ContextRef,\n+    pub fn LLVMRustSetInlineAsmDiagnosticHandler(C: &Context,\n                                                  H: InlineAsmDiagHandler,\n                                                  CX: *mut c_void);\n \n@@ -1706,7 +1702,7 @@ extern \"C\" {\n                                     -> RustArchiveMemberRef;\n     pub fn LLVMRustArchiveMemberFree(Member: RustArchiveMemberRef);\n \n-    pub fn LLVMRustSetDataLayoutFromTargetMachine(M: ModuleRef, TM: TargetMachineRef);\n+    pub fn LLVMRustSetDataLayoutFromTargetMachine(M: &Module, TM: TargetMachineRef);\n \n     pub fn LLVMRustBuildOperandBundleDef(Name: *const c_char,\n                                          Inputs: *const ValueRef,\n@@ -1716,21 +1712,21 @@ extern \"C\" {\n \n     pub fn LLVMRustPositionBuilderAtStart(B: BuilderRef, BB: BasicBlockRef);\n \n-    pub fn LLVMRustSetComdat(M: ModuleRef, V: ValueRef, Name: *const c_char);\n+    pub fn LLVMRustSetComdat(M: &Module, V: ValueRef, Name: *const c_char);\n     pub fn LLVMRustUnsetComdat(V: ValueRef);\n-    pub fn LLVMRustSetModulePIELevel(M: ModuleRef);\n-    pub fn LLVMRustModuleBufferCreate(M: ModuleRef) -> *mut ModuleBuffer;\n+    pub fn LLVMRustSetModulePIELevel(M: &Module);\n+    pub fn LLVMRustModuleBufferCreate(M: &Module) -> *mut ModuleBuffer;\n     pub fn LLVMRustModuleBufferPtr(p: *const ModuleBuffer) -> *const u8;\n     pub fn LLVMRustModuleBufferLen(p: *const ModuleBuffer) -> usize;\n     pub fn LLVMRustModuleBufferFree(p: *mut ModuleBuffer);\n-    pub fn LLVMRustModuleCost(M: ModuleRef) -> u64;\n+    pub fn LLVMRustModuleCost(M: &Module) -> u64;\n \n     pub fn LLVMRustThinLTOAvailable() -> bool;\n     pub fn LLVMRustPGOAvailable() -> bool;\n     pub fn LLVMRustWriteThinBitcodeToFile(PMR: PassManagerRef,\n-                                          M: ModuleRef,\n+                                          M: &Module,\n                                           BC: *const c_char) -> bool;\n-    pub fn LLVMRustThinLTOBufferCreate(M: ModuleRef) -> *mut ThinLTOBuffer;\n+    pub fn LLVMRustThinLTOBufferCreate(M: &Module) -> *mut ThinLTOBuffer;\n     pub fn LLVMRustThinLTOBufferFree(M: *mut ThinLTOBuffer);\n     pub fn LLVMRustThinLTOBufferPtr(M: *const ThinLTOBuffer) -> *const c_char;\n     pub fn LLVMRustThinLTOBufferLen(M: *const ThinLTOBuffer) -> size_t;\n@@ -1742,34 +1738,34 @@ extern \"C\" {\n     ) -> *mut ThinLTOData;\n     pub fn LLVMRustPrepareThinLTORename(\n         Data: *const ThinLTOData,\n-        Module: ModuleRef,\n+        Module: &Module,\n     ) -> bool;\n     pub fn LLVMRustPrepareThinLTOResolveWeak(\n         Data: *const ThinLTOData,\n-        Module: ModuleRef,\n+        Module: &Module,\n     ) -> bool;\n     pub fn LLVMRustPrepareThinLTOInternalize(\n         Data: *const ThinLTOData,\n-        Module: ModuleRef,\n+        Module: &Module,\n     ) -> bool;\n     pub fn LLVMRustPrepareThinLTOImport(\n         Data: *const ThinLTOData,\n-        Module: ModuleRef,\n+        Module: &Module,\n     ) -> bool;\n     pub fn LLVMRustFreeThinLTOData(Data: *mut ThinLTOData);\n     pub fn LLVMRustParseBitcodeForThinLTO(\n-        Context: ContextRef,\n+        Context: &Context,\n         Data: *const u8,\n         len: usize,\n         Identifier: *const c_char,\n-    ) -> ModuleRef;\n-    pub fn LLVMGetModuleIdentifier(M: ModuleRef, size: *mut usize) -> *const c_char;\n-    pub fn LLVMRustThinLTOGetDICompileUnit(M: ModuleRef,\n+    ) -> Option<&Module>;\n+    pub fn LLVMGetModuleIdentifier(M: &Module, size: *mut usize) -> *const c_char;\n+    pub fn LLVMRustThinLTOGetDICompileUnit(M: &Module,\n                                            CU1: *mut *mut c_void,\n                                            CU2: *mut *mut c_void);\n-    pub fn LLVMRustThinLTOPatchDICompileUnit(M: ModuleRef, CU: *mut c_void);\n+    pub fn LLVMRustThinLTOPatchDICompileUnit(M: &Module, CU: *mut c_void);\n \n-    pub fn LLVMRustLinkerNew(M: ModuleRef) -> LinkerRef;\n+    pub fn LLVMRustLinkerNew(M: &Module) -> LinkerRef;\n     pub fn LLVMRustLinkerAdd(linker: LinkerRef,\n                              bytecode: *const c_char,\n                              bytecode_len: usize) -> bool;"}, {"sha": "75f13e888586602eb72a043cc8184ee89f07586d", "filename": "src/librustc_codegen_llvm/llvm/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs?ref=249d5acaec0b10ee15b21b888977b5445baba42e", "patch": "@@ -127,7 +127,7 @@ pub fn SetFunctionCallConv(fn_: ValueRef, cc: CallConv) {\n // value's name as the comdat value to make sure that it is in a 1-to-1 relationship to the\n // function.\n // For more details on COMDAT sections see e.g. http://www.airs.com/blog/archives/52\n-pub fn SetUniqueComdat(llmod: ModuleRef, val: ValueRef) {\n+pub fn SetUniqueComdat(llmod: &Module, val: ValueRef) {\n     unsafe {\n         LLVMRustSetComdat(llmod, val, LLVMGetValueName(val));\n     }"}, {"sha": "cb77ce0039756020d941ab60efda17a81b1cfce0", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249d5acaec0b10ee15b21b888977b5445baba42e/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=249d5acaec0b10ee15b21b888977b5445baba42e", "patch": "@@ -11,7 +11,7 @@\n #![allow(non_upper_case_globals)]\n \n use llvm;\n-use llvm::{ContextRef, TypeRef, Bool, False, True, TypeKind};\n+use llvm::{TypeRef, Bool, False, True, TypeKind};\n use llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n \n use context::CodegenCx;\n@@ -77,7 +77,7 @@ impl Type {\n         ty!(llvm::LLVMInt8TypeInContext(cx.llcx))\n     }\n \n-    pub fn i8_llcx(llcx: ContextRef) -> Type {\n+    pub fn i8_llcx(llcx: &llvm::Context) -> Type {\n         ty!(llvm::LLVMInt8TypeInContext(llcx))\n     }\n \n@@ -103,7 +103,7 @@ impl Type {\n     }\n \n     // Creates an integer type with the given number of bits, e.g. i24\n-    pub fn ix_llcx(llcx: ContextRef, num_bits: u64) -> Type {\n+    pub fn ix_llcx(llcx: &llvm::Context, num_bits: u64) -> Type {\n         ty!(llvm::LLVMIntTypeInContext(llcx, num_bits as c_uint))\n     }\n \n@@ -127,7 +127,7 @@ impl Type {\n         Type::i8(cx).ptr_to()\n     }\n \n-    pub fn i8p_llcx(llcx: ContextRef) -> Type {\n+    pub fn i8p_llcx(llcx: &llvm::Context) -> Type {\n         Type::i8_llcx(llcx).ptr_to()\n     }\n "}]}