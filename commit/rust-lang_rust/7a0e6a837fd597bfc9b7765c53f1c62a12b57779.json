{"sha": "7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMGU2YTgzN2ZkNTk3YmZjOWI3NzY1YzUzZjFjNjJhMTJiNTc3Nzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-26T12:03:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-26T12:03:28Z"}, "message": "Auto merge of #51082 - kennytm:rollup, r=kennytm\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #50987 (Underline multiple suggested replacements in the same line)\n - #51014 (Add documentation about env! second argument)\n - #51034 (Remove unused lowering field and method)\n - #51047 (Use AllFacts from polonius-engine)\n - #51048 (Add more missing examples for Formatter)\n - #51056 (Mention and use `Once::new` instead of `ONCE_INIT`)\n - #51059 (What does an expression look like, that consists only of special characters?)\n - #51065 (Update nomicon link in transmute docs)\n - #51067 (Add inner links in documentation)\n - #51070 (Fail typecheck if we encounter a bogus break)\n - #51073 (Rename TokenStream::empty to TokenStream::new)\n\nFailed merges:", "tree": {"sha": "3fea0488e6ce74f438c160e8c3aac1aad7380870", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fea0488e6ce74f438c160e8c3aac1aad7380870"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "html_url": "https://github.com/rust-lang/rust/commit/7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4247d45a555ccdf567e5b70f929d35198841951", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4247d45a555ccdf567e5b70f929d35198841951", "html_url": "https://github.com/rust-lang/rust/commit/b4247d45a555ccdf567e5b70f929d35198841951"}, {"sha": "84b2e14b9d00d6d50e87d113bdf819e9eb18b3c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/84b2e14b9d00d6d50e87d113bdf819e9eb18b3c8", "html_url": "https://github.com/rust-lang/rust/commit/84b2e14b9d00d6d50e87d113bdf819e9eb18b3c8"}], "stats": {"total": 807, "additions": 512, "deletions": 295}, "files": [{"sha": "83e061d20bdaa0ec4bf8fcf2c7f5806957e33966", "filename": "src/Cargo.lock", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -1441,6 +1441,11 @@ name = \"pkg-config\"\n version = \"0.3.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"polonius-engine\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"precomputed-hash\"\n version = \"0.1.1\"\n@@ -1763,6 +1768,7 @@ dependencies = [\n  \"jobserver 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"polonius-engine 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc_macro 0.0.0\",\n  \"rustc_apfloat 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n@@ -2135,6 +2141,7 @@ dependencies = [\n  \"graphviz 0.0.0\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"polonius-engine 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_apfloat 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n@@ -3134,6 +3141,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum phf_generator 0.7.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6b07ffcc532ccc85e3afc45865469bf5d9e4ef5bfcf9622e3cfe80c2d275ec03\"\n \"checksum phf_shared 0.7.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"07e24b0ca9643bdecd0632f2b3da6b1b89bbb0030e0b992afc1113b23a7bc2f2\"\n \"checksum pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a8b4c6b8165cd1a1cd4b9b120978131389f64bdaf456435caa41e630edba903\"\n+\"checksum polonius-engine 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6201ffe79e3da53bd065fbec2a9b391e5a0dc21038b39bb300612ddc658eb7ee\"\n \"checksum precomputed-hash 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"925383efa346730478fb4838dbe9137d2a47675ad789c546d150a6e1dd4ab31c\"\n \"checksum pretty_assertions 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a029430f0d744bc3d15dd474d591bed2402b645d024583082b9f63bb936dac6\"\n \"checksum proc-macro2 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"49b6a521dc81b643e9a51e0d1cf05df46d5a2f3c0280ea72bcb68276ba64a118\""}, {"sha": "a4e5373d90757b9f3f4ad48da50147835a0717cb", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -340,7 +340,8 @@\n //!\n //! ## Fill/Alignment\n //!\n-//! The fill character is provided normally in conjunction with the `width`\n+//! The fill character is provided normally in conjunction with the\n+//! [`width`](#width)\n //! parameter. This indicates that if the value being formatted is smaller than\n //! `width` some extra characters will be printed around it. The extra\n //! characters are specified by `fill`, and the alignment can be one of the\n@@ -388,7 +389,8 @@\n //! padding specified by fill/alignment will be used to take up the required\n //! space.\n //!\n-//! The default fill/alignment for non-numerics is a space and left-aligned. The\n+//! The default [fill/alignment](#fillalignment) for non-numerics is a space and\n+//! left-aligned. The\n //! defaults for numeric formatters is also a space but with right-alignment. If\n //! the `0` flag is specified for numerics, then the implicit fill character is\n //! `0`."}, {"sha": "1dc0faa156d69293ac0fe9930c221c2c83985b23", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 78, "deletions": 3, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -1202,6 +1202,23 @@ impl<'a> Formatter<'a> {\n     ///               is longer than this length\n     ///\n     /// Notably this function ignores the `flag` parameters.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo;\n+    ///\n+    /// impl fmt::Display for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///         formatter.pad(\"Foo\")\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(&format!(\"{:<4}\", Foo), \"Foo \");\n+    /// assert_eq!(&format!(\"{:0>4}\", Foo), \"0Foo\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pad(&mut self, s: &str) -> Result {\n         // Make sure there's a fast path up front\n@@ -1368,7 +1385,7 @@ impl<'a> Formatter<'a> {\n         self.buf.write_str(data)\n     }\n \n-    /// Writes some formatted information into this instance\n+    /// Writes some formatted information into this instance.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write_fmt(&mut self, fmt: Arguments) -> Result {\n         write(self.buf, fmt)\n@@ -1381,11 +1398,69 @@ impl<'a> Formatter<'a> {\n                                  or `sign_aware_zero_pad` methods instead\")]\n     pub fn flags(&self) -> u32 { self.flags }\n \n-    /// Character used as 'fill' whenever there is alignment\n+    /// Character used as 'fill' whenever there is alignment.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo;\n+    ///\n+    /// impl fmt::Display for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///         let c = formatter.fill();\n+    ///         if let Some(width) = formatter.width() {\n+    ///             for _ in 0..width {\n+    ///                 write!(formatter, \"{}\", c)?;\n+    ///             }\n+    ///             Ok(())\n+    ///         } else {\n+    ///             write!(formatter, \"{}\", c)\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// // We set alignment to the left with \">\".\n+    /// assert_eq!(&format!(\"{:G>3}\", Foo), \"GGG\");\n+    /// assert_eq!(&format!(\"{:t>6}\", Foo), \"tttttt\");\n+    /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn fill(&self) -> char { self.fill }\n \n-    /// Flag indicating what form of alignment was requested\n+    /// Flag indicating what form of alignment was requested.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(fmt_flags_align)]\n+    ///\n+    /// extern crate core;\n+    ///\n+    /// use std::fmt;\n+    /// use core::fmt::Alignment;\n+    ///\n+    /// struct Foo;\n+    ///\n+    /// impl fmt::Display for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///         let s = match formatter.align() {\n+    ///             Alignment::Left    => \"left\",\n+    ///             Alignment::Right   => \"right\",\n+    ///             Alignment::Center  => \"center\",\n+    ///             Alignment::Unknown => \"into the void\",\n+    ///         };\n+    ///         write!(formatter, \"{}\", s)\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(&format!(\"{:<}\", Foo), \"left\");\n+    ///     assert_eq!(&format!(\"{:>}\", Foo), \"right\");\n+    ///     assert_eq!(&format!(\"{:^}\", Foo), \"center\");\n+    ///     assert_eq!(&format!(\"{}\", Foo), \"into the void\");\n+    /// }\n+    /// ```\n     #[unstable(feature = \"fmt_flags_align\", reason = \"method was just created\",\n                issue = \"27726\")]\n     pub fn align(&self) -> Alignment {"}, {"sha": "95f13daf841ee16a4035bcd53cd57d6c631b18f2", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -717,7 +717,7 @@ extern \"rust-intrinsic\" {\n     /// Reinterprets the bits of a value of one type as another type.\n     ///\n     /// Both types must have the same size. Neither the original, nor the result,\n-    /// may be an [invalid value](../../nomicon/meet-safe-and-unsafe.html).\n+    /// may be an [invalid value](../../nomicon/what-unsafe-does.html).\n     ///\n     /// `transmute` is semantically equivalent to a bitwise move of one type\n     /// into another. It copies the bits from the source value into the"}, {"sha": "35e2d6b23167e658391eb3a2f9b703f66410b08e", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -93,7 +93,7 @@ impl !Sync for LexError {}\n impl TokenStream {\n     /// Returns an empty `TokenStream` containing no token trees.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-    pub fn empty() -> TokenStream {\n+    pub fn new() -> TokenStream {\n         TokenStream(tokenstream::TokenStream::empty())\n     }\n "}, {"sha": "c9d0bc1405fc01dcb17fcf6432590a0f32864786", "filename": "src/libproc_macro/quote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fquote.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -71,7 +71,7 @@ macro_rules! quote_tree {\n }\n \n macro_rules! quote {\n-    () => { TokenStream::empty() };\n+    () => { TokenStream::new() };\n     ($($t:tt)*) => {\n         [$(quote_tree!($t),)*].iter()\n             .cloned()\n@@ -104,7 +104,7 @@ impl<T: Quote> Quote for Option<T> {\n impl Quote for TokenStream {\n     fn quote(self) -> TokenStream {\n         if self.is_empty() {\n-            return quote!(::TokenStream::empty());\n+            return quote!(::TokenStream::new());\n         }\n         let mut after_dollar = false;\n         let tokens = self.into_iter().filter_map(|tree| {"}, {"sha": "83cf4469f4d9402d4c72a54a73e048069793d936", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -16,6 +16,7 @@ graphviz = { path = \"../libgraphviz\" }\n jobserver = \"0.1\"\n lazy_static = \"1.0.0\"\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n+polonius-engine = \"0.1.1\"\n proc_macro = { path = \"../libproc_macro\" }\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_target = { path = \"../librustc_target\" }"}, {"sha": "d2dce2c7f69baaab71cb0c2a292fd3d7ac89242a", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 184, "deletions": 215, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -82,10 +82,6 @@ pub struct LoweringContext<'a> {\n \n     cstore: &'a CrateStore,\n \n-    // As we walk the AST we must keep track of the current 'parent' def id (in\n-    // the form of a DefIndex) so that if we create a new node which introduces\n-    // a definition, then we can properly create the def id.\n-    parent_def: Option<DefIndex>,\n     resolver: &'a mut Resolver,\n     name_map: FxHashMap<Ident, Name>,\n \n@@ -205,7 +201,6 @@ pub fn lower_crate(\n         crate_root: std_inject::injected_crate_name(),\n         sess,\n         cstore,\n-        parent_def: None,\n         resolver,\n         name_map: FxHashMap(),\n         items: BTreeMap::new(),\n@@ -885,22 +880,6 @@ impl<'a> LoweringContext<'a> {\n         result\n     }\n \n-    fn with_parent_def<T, F>(&mut self, parent_id: NodeId, f: F) -> T\n-    where\n-        F: FnOnce(&mut LoweringContext) -> T,\n-    {\n-        let old_def = self.parent_def;\n-        self.parent_def = {\n-            let defs = self.resolver.definitions();\n-            Some(defs.opt_def_index(parent_id).unwrap())\n-        };\n-\n-        let result = f(self);\n-\n-        self.parent_def = old_def;\n-        result\n-    }\n-\n     fn def_key(&mut self, id: DefId) -> DefKey {\n         if id.is_local() {\n             self.resolver.definitions().def_key(id.index)\n@@ -2461,74 +2440,72 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_trait_item(&mut self, i: &TraitItem) -> hir::TraitItem {\n-        self.with_parent_def(i.id, |this| {\n-            let LoweredNodeId { node_id, hir_id } = this.lower_node_id(i.id);\n-            let trait_item_def_id = this.resolver.definitions().local_def_id(node_id);\n-\n-            let (generics, node) = match i.node {\n-                TraitItemKind::Const(ref ty, ref default) => (\n-                    this.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n-                    hir::TraitItemKind::Const(\n-                        this.lower_ty(ty, ImplTraitContext::Disallowed),\n-                        default\n-                            .as_ref()\n-                            .map(|x| this.lower_body(None, |this| this.lower_expr(x))),\n-                    ),\n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(i.id);\n+        let trait_item_def_id = self.resolver.definitions().local_def_id(node_id);\n+\n+        let (generics, node) = match i.node {\n+            TraitItemKind::Const(ref ty, ref default) => (\n+                self.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n+                hir::TraitItemKind::Const(\n+                    self.lower_ty(ty, ImplTraitContext::Disallowed),\n+                    default\n+                        .as_ref()\n+                        .map(|x| self.lower_body(None, |this| this.lower_expr(x))),\n                 ),\n-                TraitItemKind::Method(ref sig, None) => {\n-                    let names = this.lower_fn_args_to_names(&sig.decl);\n-                    this.add_in_band_defs(\n-                        &i.generics,\n-                        trait_item_def_id,\n-                        AnonymousLifetimeMode::PassThrough,\n-                        |this| {\n-                            hir::TraitItemKind::Method(\n-                                this.lower_method_sig(sig, trait_item_def_id, false),\n-                                hir::TraitMethod::Required(names),\n-                            )\n-                        },\n-                    )\n-                }\n-                TraitItemKind::Method(ref sig, Some(ref body)) => {\n-                    let body_id = this.lower_body(Some(&sig.decl), |this| {\n-                        let body = this.lower_block(body, false);\n-                        this.expr_block(body, ThinVec::new())\n-                    });\n+            ),\n+            TraitItemKind::Method(ref sig, None) => {\n+                let names = self.lower_fn_args_to_names(&sig.decl);\n+                self.add_in_band_defs(\n+                    &i.generics,\n+                    trait_item_def_id,\n+                    AnonymousLifetimeMode::PassThrough,\n+                    |this| {\n+                        hir::TraitItemKind::Method(\n+                            this.lower_method_sig(sig, trait_item_def_id, false),\n+                            hir::TraitMethod::Required(names),\n+                        )\n+                    },\n+                )\n+            }\n+            TraitItemKind::Method(ref sig, Some(ref body)) => {\n+                let body_id = self.lower_body(Some(&sig.decl), |this| {\n+                    let body = this.lower_block(body, false);\n+                    this.expr_block(body, ThinVec::new())\n+                });\n \n-                    this.add_in_band_defs(\n-                        &i.generics,\n-                        trait_item_def_id,\n-                        AnonymousLifetimeMode::PassThrough,\n-                        |this| {\n-                            hir::TraitItemKind::Method(\n-                                this.lower_method_sig(sig, trait_item_def_id, false),\n-                                hir::TraitMethod::Provided(body_id),\n-                            )\n-                        },\n-                    )\n-                }\n-                TraitItemKind::Type(ref bounds, ref default) => (\n-                    this.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n-                    hir::TraitItemKind::Type(\n-                        this.lower_bounds(bounds, ImplTraitContext::Disallowed),\n-                        default\n-                            .as_ref()\n-                            .map(|x| this.lower_ty(x, ImplTraitContext::Disallowed)),\n-                    ),\n+                self.add_in_band_defs(\n+                    &i.generics,\n+                    trait_item_def_id,\n+                    AnonymousLifetimeMode::PassThrough,\n+                    |this| {\n+                        hir::TraitItemKind::Method(\n+                            this.lower_method_sig(sig, trait_item_def_id, false),\n+                            hir::TraitMethod::Provided(body_id),\n+                        )\n+                    },\n+                )\n+            }\n+            TraitItemKind::Type(ref bounds, ref default) => (\n+                self.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n+                hir::TraitItemKind::Type(\n+                    self.lower_bounds(bounds, ImplTraitContext::Disallowed),\n+                    default\n+                        .as_ref()\n+                        .map(|x| self.lower_ty(x, ImplTraitContext::Disallowed)),\n                 ),\n-                TraitItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n-            };\n+            ),\n+            TraitItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n+        };\n \n-            hir::TraitItem {\n-                id: node_id,\n-                hir_id,\n-                name: this.lower_ident(i.ident),\n-                attrs: this.lower_attrs(&i.attrs),\n-                generics,\n-                node,\n-                span: i.span,\n-            }\n-        })\n+        hir::TraitItem {\n+            id: node_id,\n+            hir_id,\n+            name: self.lower_ident(i.ident),\n+            attrs: self.lower_attrs(&i.attrs),\n+            generics,\n+            node,\n+            span: i.span,\n+        }\n     }\n \n     fn lower_trait_item_ref(&mut self, i: &TraitItem) -> hir::TraitItemRef {\n@@ -2557,63 +2534,61 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_impl_item(&mut self, i: &ImplItem) -> hir::ImplItem {\n-        self.with_parent_def(i.id, |this| {\n-            let LoweredNodeId { node_id, hir_id } = this.lower_node_id(i.id);\n-            let impl_item_def_id = this.resolver.definitions().local_def_id(node_id);\n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(i.id);\n+        let impl_item_def_id = self.resolver.definitions().local_def_id(node_id);\n+\n+        let (generics, node) = match i.node {\n+            ImplItemKind::Const(ref ty, ref expr) => {\n+                let body_id = self.lower_body(None, |this| this.lower_expr(expr));\n+                (\n+                    self.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n+                    hir::ImplItemKind::Const(\n+                        self.lower_ty(ty, ImplTraitContext::Disallowed),\n+                        body_id,\n+                    ),\n+                )\n+            }\n+            ImplItemKind::Method(ref sig, ref body) => {\n+                let body_id = self.lower_body(Some(&sig.decl), |this| {\n+                    let body = this.lower_block(body, false);\n+                    this.expr_block(body, ThinVec::new())\n+                });\n+                let impl_trait_return_allow = !self.is_in_trait_impl;\n \n-            let (generics, node) = match i.node {\n-                ImplItemKind::Const(ref ty, ref expr) => {\n-                    let body_id = this.lower_body(None, |this| this.lower_expr(expr));\n-                    (\n-                        this.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n-                        hir::ImplItemKind::Const(\n-                            this.lower_ty(ty, ImplTraitContext::Disallowed),\n+                self.add_in_band_defs(\n+                    &i.generics,\n+                    impl_item_def_id,\n+                    AnonymousLifetimeMode::PassThrough,\n+                    |this| {\n+                        hir::ImplItemKind::Method(\n+                            this.lower_method_sig(\n+                                sig,\n+                                impl_item_def_id,\n+                                impl_trait_return_allow,\n+                            ),\n                             body_id,\n-                        ),\n-                    )\n-                }\n-                ImplItemKind::Method(ref sig, ref body) => {\n-                    let body_id = this.lower_body(Some(&sig.decl), |this| {\n-                        let body = this.lower_block(body, false);\n-                        this.expr_block(body, ThinVec::new())\n-                    });\n-                    let impl_trait_return_allow = !this.is_in_trait_impl;\n-\n-                    this.add_in_band_defs(\n-                        &i.generics,\n-                        impl_item_def_id,\n-                        AnonymousLifetimeMode::PassThrough,\n-                        |this| {\n-                            hir::ImplItemKind::Method(\n-                                this.lower_method_sig(\n-                                    sig,\n-                                    impl_item_def_id,\n-                                    impl_trait_return_allow,\n-                                ),\n-                                body_id,\n-                            )\n-                        },\n-                    )\n-                }\n-                ImplItemKind::Type(ref ty) => (\n-                    this.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n-                    hir::ImplItemKind::Type(this.lower_ty(ty, ImplTraitContext::Disallowed)),\n-                ),\n-                ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n-            };\n-\n-            hir::ImplItem {\n-                id: node_id,\n-                hir_id,\n-                name: this.lower_ident(i.ident),\n-                attrs: this.lower_attrs(&i.attrs),\n-                generics,\n-                vis: this.lower_visibility(&i.vis, None),\n-                defaultness: this.lower_defaultness(i.defaultness, true /* [1] */),\n-                node,\n-                span: i.span,\n+                        )\n+                    },\n+                )\n             }\n-        })\n+            ImplItemKind::Type(ref ty) => (\n+                self.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n+                hir::ImplItemKind::Type(self.lower_ty(ty, ImplTraitContext::Disallowed)),\n+            ),\n+            ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n+        };\n+\n+        hir::ImplItem {\n+            id: node_id,\n+            hir_id,\n+            name: self.lower_ident(i.ident),\n+            attrs: self.lower_attrs(&i.attrs),\n+            generics,\n+            vis: self.lower_visibility(&i.vis, None),\n+            defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),\n+            node,\n+            span: i.span,\n+        }\n \n         // [1] since `default impl` is not yet implemented, this is always true in impls\n     }\n@@ -2689,9 +2664,7 @@ impl<'a> LoweringContext<'a> {\n             return None;\n         }\n \n-        let node = self.with_parent_def(i.id, |this| {\n-            this.lower_item_kind(i.id, &mut name, &attrs, &mut vis, &i.node)\n-        });\n+        let node = self.lower_item_kind(i.id, &mut name, &attrs, &mut vis, &i.node);\n \n         let LoweredNodeId { node_id, hir_id } = self.lower_node_id(i.id);\n \n@@ -2707,40 +2680,38 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem {\n-        self.with_parent_def(i.id, |this| {\n-            let node_id = this.lower_node_id(i.id).node_id;\n-            let def_id = this.resolver.definitions().local_def_id(node_id);\n-            hir::ForeignItem {\n-                id: node_id,\n-                name: i.ident.name,\n-                attrs: this.lower_attrs(&i.attrs),\n-                node: match i.node {\n-                    ForeignItemKind::Fn(ref fdec, ref generics) => {\n-                        let (generics, (fn_dec, fn_args)) = this.add_in_band_defs(\n-                            generics,\n-                            def_id,\n-                            AnonymousLifetimeMode::PassThrough,\n-                            |this| {\n-                                (\n-                                    // Disallow impl Trait in foreign items\n-                                    this.lower_fn_decl(fdec, None, false),\n-                                    this.lower_fn_args_to_names(fdec),\n-                                )\n-                            },\n-                        );\n+        let node_id = self.lower_node_id(i.id).node_id;\n+        let def_id = self.resolver.definitions().local_def_id(node_id);\n+        hir::ForeignItem {\n+            id: node_id,\n+            name: i.ident.name,\n+            attrs: self.lower_attrs(&i.attrs),\n+            node: match i.node {\n+                ForeignItemKind::Fn(ref fdec, ref generics) => {\n+                    let (generics, (fn_dec, fn_args)) = self.add_in_band_defs(\n+                        generics,\n+                        def_id,\n+                        AnonymousLifetimeMode::PassThrough,\n+                        |this| {\n+                            (\n+                                // Disallow impl Trait in foreign items\n+                                this.lower_fn_decl(fdec, None, false),\n+                                this.lower_fn_args_to_names(fdec),\n+                            )\n+                        },\n+                    );\n \n-                        hir::ForeignItemFn(fn_dec, fn_args, generics)\n-                    }\n-                    ForeignItemKind::Static(ref t, m) => {\n-                        hir::ForeignItemStatic(this.lower_ty(t, ImplTraitContext::Disallowed), m)\n-                    }\n-                    ForeignItemKind::Ty => hir::ForeignItemType,\n-                    ForeignItemKind::Macro(_) => panic!(\"shouldn't exist here\"),\n-                },\n-                vis: this.lower_visibility(&i.vis, None),\n-                span: i.span,\n-            }\n-        })\n+                    hir::ForeignItemFn(fn_dec, fn_args, generics)\n+                }\n+                ForeignItemKind::Static(ref t, m) => {\n+                    hir::ForeignItemStatic(self.lower_ty(t, ImplTraitContext::Disallowed), m)\n+                }\n+                ForeignItemKind::Ty => hir::ForeignItemType,\n+                ForeignItemKind::Macro(_) => panic!(\"shouldn't exist here\"),\n+            },\n+            vis: self.lower_visibility(&i.vis, None),\n+            span: i.span,\n+        }\n     }\n \n     fn lower_method_sig(\n@@ -3064,46 +3035,44 @@ impl<'a> LoweringContext<'a> {\n             ),\n             ExprKind::Closure(capture_clause, movability, ref decl, ref body, fn_decl_span) => {\n                 self.with_new_scopes(|this| {\n-                    this.with_parent_def(e.id, |this| {\n-                        let mut is_generator = false;\n-                        let body_id = this.lower_body(Some(decl), |this| {\n-                            let e = this.lower_expr(body);\n-                            is_generator = this.is_generator;\n-                            e\n-                        });\n-                        let generator_option = if is_generator {\n-                            if !decl.inputs.is_empty() {\n-                                span_err!(\n-                                    this.sess,\n-                                    fn_decl_span,\n-                                    E0628,\n-                                    \"generators cannot have explicit arguments\"\n-                                );\n-                                this.sess.abort_if_errors();\n-                            }\n-                            Some(match movability {\n-                                Movability::Movable => hir::GeneratorMovability::Movable,\n-                                Movability::Static => hir::GeneratorMovability::Static,\n-                            })\n-                        } else {\n-                            if movability == Movability::Static {\n-                                span_err!(\n-                                    this.sess,\n-                                    fn_decl_span,\n-                                    E0906,\n-                                    \"closures cannot be static\"\n-                                );\n-                            }\n-                            None\n-                        };\n-                        hir::ExprClosure(\n-                            this.lower_capture_clause(capture_clause),\n-                            this.lower_fn_decl(decl, None, false),\n-                            body_id,\n-                            fn_decl_span,\n-                            generator_option,\n-                        )\n-                    })\n+                    let mut is_generator = false;\n+                    let body_id = this.lower_body(Some(decl), |this| {\n+                        let e = this.lower_expr(body);\n+                        is_generator = this.is_generator;\n+                        e\n+                    });\n+                    let generator_option = if is_generator {\n+                        if !decl.inputs.is_empty() {\n+                            span_err!(\n+                                this.sess,\n+                                fn_decl_span,\n+                                E0628,\n+                                \"generators cannot have explicit arguments\"\n+                            );\n+                            this.sess.abort_if_errors();\n+                        }\n+                        Some(match movability {\n+                            Movability::Movable => hir::GeneratorMovability::Movable,\n+                            Movability::Static => hir::GeneratorMovability::Static,\n+                        })\n+                    } else {\n+                        if movability == Movability::Static {\n+                            span_err!(\n+                                this.sess,\n+                                fn_decl_span,\n+                                E0906,\n+                                \"closures cannot be static\"\n+                            );\n+                        }\n+                        None\n+                    };\n+                    hir::ExprClosure(\n+                        this.lower_capture_clause(capture_clause),\n+                        this.lower_fn_decl(decl, None, false),\n+                        body_id,\n+                        fn_decl_span,\n+                        generator_option,\n+                    )\n                 })\n             }\n             ExprKind::Block(ref blk, opt_label) => {"}, {"sha": "486ea93588cc6c7a4c8601f98480b1e1dd2aa145", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -81,6 +81,7 @@ extern crate graphviz;\n #[macro_use] extern crate lazy_static;\n #[cfg(windows)]\n extern crate libc;\n+extern crate polonius_engine;\n extern crate rustc_target;\n #[macro_use] extern crate rustc_data_structures;\n extern crate serialize;"}, {"sha": "6fda152f9a118c9cfcdcf387384a80cf0db2d3a8", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -14,6 +14,7 @@ use hir::def_id::DefId;\n \n use middle::const_val::ConstVal;\n use middle::region;\n+use polonius_engine::Atom;\n use rustc_data_structures::indexed_vec::Idx;\n use ty::subst::{Substs, Subst, Kind, UnpackedKind};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n@@ -1169,6 +1170,24 @@ newtype_index!(RegionVid\n         DEBUG_FORMAT = custom,\n     });\n \n+impl Atom for RegionVid {\n+    fn index(self) -> usize {\n+        Idx::index(self)\n+    }\n+}\n+\n+impl From<usize> for RegionVid {\n+    fn from(i: usize) -> RegionVid {\n+        RegionVid::new(i)\n+    }\n+}\n+\n+impl From<RegionVid> for usize {\n+    fn from(vid: RegionVid) -> usize {\n+        Idx::index(vid)\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub enum InferTy {\n     TyVar(TyVid),"}, {"sha": "4d1d33e1325b8b550286205eac062e2675114c9c", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 52, "deletions": 18, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -1215,19 +1215,20 @@ impl EmitterWriter {\n \n             let mut row_num = 2;\n             for &(ref complete, ref parts) in suggestions.iter().take(MAX_SUGGESTIONS) {\n-                let show_underline = parts.len() == 1\n-                    && complete.lines().count() == 1\n-                    && parts[0].snippet.trim() != complete.trim();\n+                // Only show underline if the suggestion spans a single line and doesn't cover the\n+                // entirety of the code output. If you have multiple replacements in the same line\n+                // of code, show the underline.\n+                let show_underline = !(parts.len() == 1\n+                    && parts[0].snippet.trim() == complete.trim())\n+                    && complete.lines().count() == 1;\n \n                 let lines = cm.span_to_lines(parts[0].span).unwrap();\n \n                 assert!(!lines.lines.is_empty());\n \n-                let span_start_pos = cm.lookup_char_pos(parts[0].span.lo());\n-                let line_start = span_start_pos.line;\n+                let line_start = cm.lookup_char_pos(parts[0].span.lo()).line;\n                 draw_col_separator_no_space(&mut buffer, 1, max_line_num_len + 1);\n                 let mut line_pos = 0;\n-                // Only show underline if there's a single suggestion and it is a single line\n                 let mut lines = complete.lines();\n                 for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n                     // Print the span column to avoid confusion\n@@ -1241,22 +1242,55 @@ impl EmitterWriter {\n                     line_pos += 1;\n                     row_num += 1;\n                 }\n+\n+                // This offset and the ones below need to be signed to account for replacement code\n+                // that is shorter than the original code.\n+                let mut offset: isize = 0;\n                 // Only show an underline in the suggestions if the suggestion is not the\n                 // entirety of the code being shown and the displayed code is not multiline.\n                 if show_underline {\n                     draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n-                    let start = parts[0].snippet.len() - parts[0].snippet.trim_left().len();\n-                    // account for substitutions containing unicode characters\n-                    let sub_len = parts[0].snippet.trim().chars().fold(0, |acc, ch| {\n-                        acc + unicode_width::UnicodeWidthChar::width(ch).unwrap_or(0)\n-                    });\n-                    let underline_start = span_start_pos.col_display + start;\n-                    let underline_end = span_start_pos.col_display + start + sub_len;\n-                    for p in underline_start..underline_end {\n-                        buffer.putc(row_num,\n-                                    max_line_num_len + 3 + p,\n-                                    '^',\n-                                    Style::UnderlinePrimary);\n+                    for part in parts {\n+                        let span_start_pos = cm.lookup_char_pos(part.span.lo()).col_display;\n+                        let span_end_pos = cm.lookup_char_pos(part.span.hi()).col_display;\n+\n+                        // Do not underline the leading...\n+                        let start = part.snippet.len()\n+                            .saturating_sub(part.snippet.trim_left().len());\n+                        // ...or trailing spaces. Account for substitutions containing unicode\n+                        // characters.\n+                        let sub_len = part.snippet.trim().chars().fold(0, |acc, ch| {\n+                            acc + unicode_width::UnicodeWidthChar::width(ch).unwrap_or(0)\n+                        });\n+\n+                        let underline_start = (span_start_pos + start) as isize + offset;\n+                        let underline_end = (span_start_pos + start + sub_len) as isize + offset;\n+                        for p in underline_start..underline_end {\n+                            buffer.putc(row_num,\n+                                        max_line_num_len + 3 + p as usize,\n+                                        '^',\n+                                        Style::UnderlinePrimary);\n+                        }\n+                        // underline removals too\n+                        if underline_start == underline_end {\n+                            for p in underline_start-1..underline_start+1 {\n+                                buffer.putc(row_num,\n+                                            max_line_num_len + 3 + p as usize,\n+                                            '-',\n+                                            Style::UnderlineSecondary);\n+                            }\n+                        }\n+\n+                        // length of the code after substitution\n+                        let full_sub_len = part.snippet.chars().fold(0, |acc, ch| {\n+                            acc + unicode_width::UnicodeWidthChar::width(ch).unwrap_or(0) as isize\n+                        });\n+\n+                        // length of the code to be substituted\n+                        let snippet_len = (span_end_pos - span_start_pos) as isize;\n+                        // For multiple substitutions, use the position *after* the previous\n+                        // substitutions have happened.\n+                        offset += full_sub_len - snippet_len;\n                     }\n                     row_num += 1;\n                 }"}, {"sha": "e88ff38ed7d34efcd847f6c4db331d467f16bfb2", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -14,6 +14,7 @@ bitflags = \"1.0\"\n graphviz = { path = \"../libgraphviz\" }\n log = \"0.4\"\n log_settings = \"0.1.1\"\n+polonius-engine = \"0.1.1\"\n rustc = { path = \"../librustc\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "6cb8e64b9f5b46d0226b27c2158abe524f75156d", "filename": "src/librustc_mir/borrow_check/nll/facts.rs", "status": "modified", "additions": 48, "deletions": 25, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -10,41 +10,28 @@\n \n use borrow_check::location::{LocationIndex, LocationTable};\n use dataflow::indexes::BorrowIndex;\n+use polonius_engine::AllFacts as PoloniusAllFacts;\n+use polonius_engine::Atom;\n use rustc::ty::RegionVid;\n+use rustc_data_structures::indexed_vec::Idx;\n use std::error::Error;\n use std::fmt::Debug;\n use std::fs::{self, File};\n use std::io::Write;\n use std::path::Path;\n \n-/// The \"facts\" which are the basis of the NLL borrow analysis.\n-#[derive(Default)]\n-crate struct AllFacts {\n-    // `borrow_region(R, B, P)` -- the region R may refer to data from borrow B\n-    // starting at the point P (this is usually the point *after* a borrow rvalue)\n-    crate borrow_region: Vec<(RegionVid, BorrowIndex, LocationIndex)>,\n+crate type AllFacts = PoloniusAllFacts<RegionVid, BorrowIndex, LocationIndex>;\n \n-    // universal_region(R) -- this is a \"free region\" within fn body\n-    crate universal_region: Vec<RegionVid>,\n-\n-    // `cfg_edge(P,Q)` for each edge P -> Q in the control flow\n-    crate cfg_edge: Vec<(LocationIndex, LocationIndex)>,\n-\n-    // `killed(B,P)` when some prefix of the path borrowed at B is assigned at point P\n-    crate killed: Vec<(BorrowIndex, LocationIndex)>,\n-\n-    // `outlives(R1, R2, P)` when we require `R1@P: R2@P`\n-    crate outlives: Vec<(RegionVid, RegionVid, LocationIndex)>,\n-\n-    // `region_live_at(R, P)` when the region R appears in a live variable at P\n-    crate region_live_at: Vec<(RegionVid, LocationIndex)>,\n-\n-    // `invalidates(P, B)` when the borrow B is invalidated at point P\n-    crate invalidates: Vec<(LocationIndex, BorrowIndex)>,\n+crate trait AllFactsExt {\n+    fn write_to_dir(\n+        &self,\n+        dir: impl AsRef<Path>,\n+        location_table: &LocationTable,\n+    ) -> Result<(), Box<dyn Error>>;\n }\n \n-impl AllFacts {\n-    crate fn write_to_dir(\n+impl AllFactsExt for AllFacts {\n+    fn write_to_dir(\n         &self,\n         dir: impl AsRef<Path>,\n         location_table: &LocationTable,\n@@ -79,6 +66,42 @@ impl AllFacts {\n     }\n }\n \n+impl Atom for BorrowIndex {\n+    fn index(self) -> usize {\n+        Idx::index(self)\n+    }\n+}\n+\n+impl From<usize> for BorrowIndex {\n+    fn from(i: usize) -> BorrowIndex {\n+        BorrowIndex::new(i)\n+    }\n+}\n+\n+impl From<BorrowIndex> for usize {\n+    fn from(vid: BorrowIndex) -> usize {\n+        Idx::index(vid)\n+    }\n+}\n+\n+impl Atom for LocationIndex {\n+    fn index(self) -> usize {\n+        Idx::index(self)\n+    }\n+}\n+\n+impl From<usize> for LocationIndex {\n+    fn from(i: usize) -> LocationIndex {\n+        LocationIndex::new(i)\n+    }\n+}\n+\n+impl From<LocationIndex> for usize {\n+    fn from(vid: LocationIndex) -> usize {\n+        Idx::index(vid)\n+    }\n+}\n+\n struct FactWriter<'w> {\n     location_table: &'w LocationTable,\n     dir: &'w Path,"}, {"sha": "a91789733a95e9ed4222d763ee92c2e121044473", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -10,6 +10,7 @@\n \n use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n+use borrow_check::nll::facts::AllFactsExt;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n use dataflow::MaybeInitializedPlaces;"}, {"sha": "610963af9e13c67eeb6cea6c4099b46ea2380925", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -34,7 +34,7 @@ pub(crate) mod indexes {\n \n     macro_rules! new_index {\n         ($Index:ident, $debug_name:expr) => {\n-            #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+            #[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n             pub struct $Index(NonZeroUsize);\n \n             impl Idx for $Index {"}, {"sha": "ace4709ba1d645d057815258bb02b547e18e6bff", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -39,6 +39,7 @@ extern crate arena;\n extern crate bitflags;\n #[macro_use] extern crate log;\n extern crate graphviz as dot;\n+extern crate polonius_engine;\n #[macro_use]\n extern crate rustc;\n #[macro_use] extern crate rustc_data_structures;"}, {"sha": "808c134e9944864f964cb85648ee0474fb0e67a0", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -777,7 +777,7 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         let new_generics_span = tcx\n                             .sess\n                             .codemap()\n-                            .generate_fn_name_span(impl_m.span)?\n+                            .generate_fn_name_span(impl_span)?\n                             .shrink_to_hi();\n                         // in case there are generics, just replace them\n                         let generics_span = impl_m"}, {"sha": "16695dcef8f7108cbded11795f02845f30262665", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -3764,6 +3764,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   }\n \n                   ctxt.may_break = true;\n+\n+                  // the type of a `break` is always `!`, since it diverges\n+                  tcx.types.never\n               } else {\n                   // Otherwise, we failed to find the enclosing loop;\n                   // this can only happen if the `break` was not\n@@ -3784,10 +3787,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           }\n                       }\n                   }\n+                  // There was an error, make typecheck fail\n+                  tcx.types.err\n               }\n \n-              // the type of a `break` is always `!`, since it diverges\n-              tcx.types.never\n           }\n           hir::ExprAgain(_) => { tcx.types.never }\n           hir::ExprRet(ref expr_opt) => {"}, {"sha": "8da70f5717e71bef576648a60ad34baf9075e0f0", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -364,7 +364,6 @@ pub mod builtin {\n     ///\n     /// let s = fmt::format(format_args!(\"hello {}\", \"world\"));\n     /// assert_eq!(s, format!(\"hello {}\", \"world\"));\n-    ///\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n@@ -379,7 +378,7 @@ pub mod builtin {\n     /// compile time, yielding an expression of type `&'static str`.\n     ///\n     /// If the environment variable is not defined, then a compilation error\n-    /// will be emitted.  To not emit a compile error, use the [`option_env!`]\n+    /// will be emitted. To not emit a compile error, use the [`option_env!`]\n     /// macro instead.\n     ///\n     /// [`option_env!`]: ../std/macro.option_env.html\n@@ -390,6 +389,20 @@ pub mod builtin {\n     /// let path: &'static str = env!(\"PATH\");\n     /// println!(\"the $PATH variable at the time of compiling was: {}\", path);\n     /// ```\n+    ///\n+    /// You can customize the error message by passing a string as the second\n+    /// parameter:\n+    ///\n+    /// ```compile_fail\n+    /// let doc: &'static str = env!(\"documentation\", \"what's that?!\");\n+    /// ```\n+    ///\n+    /// If the `documentation` environment variable is not defined, you'll get\n+    /// the following error:\n+    ///\n+    /// ```text\n+    /// error: what's that?!\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n     macro_rules! env {"}, {"sha": "7eb7be23128b3143ec4a0e0c833445b95a5cbcfa", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -73,16 +73,17 @@ use thread::{self, Thread};\n /// A synchronization primitive which can be used to run a one-time global\n /// initialization. Useful for one-time initialization for FFI or related\n /// functionality. This type can only be constructed with the [`ONCE_INIT`]\n-/// value.\n+/// value or the equivalent [`Once::new`] constructor.\n ///\n /// [`ONCE_INIT`]: constant.ONCE_INIT.html\n+/// [`Once::new`]: struct.Once.html#method.new\n ///\n /// # Examples\n ///\n /// ```\n-/// use std::sync::{Once, ONCE_INIT};\n+/// use std::sync::Once;\n ///\n-/// static START: Once = ONCE_INIT;\n+/// static START: Once = Once::new();\n ///\n /// START.call_once(|| {\n ///     // run initialization here\n@@ -180,10 +181,10 @@ impl Once {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::{Once, ONCE_INIT};\n+    /// use std::sync::Once;\n     ///\n     /// static mut VAL: usize = 0;\n-    /// static INIT: Once = ONCE_INIT;\n+    /// static INIT: Once = Once::new();\n     ///\n     /// // Accessing a `static mut` is unsafe much of the time, but if we do so\n     /// // in a synchronized fashion (e.g. write once or read all) then we're\n@@ -248,10 +249,10 @@ impl Once {\n     /// ```\n     /// #![feature(once_poison)]\n     ///\n-    /// use std::sync::{Once, ONCE_INIT};\n+    /// use std::sync::Once;\n     /// use std::thread;\n     ///\n-    /// static INIT: Once = ONCE_INIT;\n+    /// static INIT: Once = Once::new();\n     ///\n     /// // poison the once\n     /// let handle = thread::spawn(|| {\n@@ -431,10 +432,10 @@ impl OnceState {\n     /// ```\n     /// #![feature(once_poison)]\n     ///\n-    /// use std::sync::{Once, ONCE_INIT};\n+    /// use std::sync::Once;\n     /// use std::thread;\n     ///\n-    /// static INIT: Once = ONCE_INIT;\n+    /// static INIT: Once = Once::new();\n     ///\n     /// // poison the once\n     /// let handle = thread::spawn(|| {\n@@ -452,9 +453,9 @@ impl OnceState {\n     /// ```\n     /// #![feature(once_poison)]\n     ///\n-    /// use std::sync::{Once, ONCE_INIT};\n+    /// use std::sync::Once;\n     ///\n-    /// static INIT: Once = ONCE_INIT;\n+    /// static INIT: Once = Once::new();\n     ///\n     /// INIT.call_once_force(|state| {\n     ///     assert!(!state.poisoned());"}, {"sha": "b236283f75764df226ac90130d0bd1f7d2e82df3", "filename": "src/test/compile-fail/issue-43162.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Ftest%2Fcompile-fail%2Fissue-43162.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Ftest%2Fcompile-fail%2Fissue-43162.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43162.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n fn foo() -> bool {\n+    //~^ ERROR E0308\n     break true; //~ ERROR E0268\n }\n "}, {"sha": "c37682220da3358d40da13e9906f03d546cb164f", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/modify-ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fmodify-ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fmodify-ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fmodify-ast.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -26,7 +26,7 @@ pub fn assert1(_a: TokenStream, b: TokenStream) -> TokenStream {\n #[proc_macro_derive(Foo, attributes(foo))]\n pub fn assert2(a: TokenStream) -> TokenStream {\n     assert_eq(a, \"pub struct MyStructc { _a: i32, }\".parse().unwrap());\n-    TokenStream::empty()\n+    TokenStream::new()\n }\n \n fn assert_eq(a: TokenStream, b: TokenStream) {"}, {"sha": "a640fabe04fac7f0a0bccc31f9e814c9f1126335", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/not-joint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fnot-joint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fnot-joint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fnot-joint.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -20,13 +20,13 @@ use proc_macro::*;\n #[proc_macro]\n pub fn tokens(input: TokenStream) -> TokenStream {\n     assert_nothing_joint(input);\n-    TokenStream::empty()\n+    TokenStream::new()\n }\n \n #[proc_macro_attribute]\n pub fn nothing(_: TokenStream, input: TokenStream) -> TokenStream {\n     assert_nothing_joint(input);\n-    TokenStream::empty()\n+    TokenStream::new()\n }\n \n fn assert_nothing_joint(s: TokenStream) {"}, {"sha": "37ab2ea27150a0fb61f554eca1f334b429053932", "filename": "src/test/run-pass/weird-exprs.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Ftest%2Frun-pass%2Fweird-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Ftest%2Frun-pass%2Fweird-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fweird-exprs.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -112,6 +112,12 @@ fn union() {\n     union union<'union> { union: &'union union<'union>, }\n }\n \n+fn special_characters() {\n+    let val = !((|(..):(_,_),__@_|__)((&*\"\\\\\",'\ud83e\udd14')/**/,{})=={&[..=..][..];})//\n+    ;\n+    assert!(!val);\n+}\n+\n pub fn main() {\n     strange();\n     funny();\n@@ -125,4 +131,5 @@ pub fn main() {\n     you_eight();\n     fishy();\n     union();\n+    special_characters();\n }"}, {"sha": "5b8fcab0baaa70903b112f1c93918adf843f7752", "filename": "src/test/ui-fulldeps/proc-macro/auxiliary/three-equals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fthree-equals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fthree-equals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fthree-equals.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -50,7 +50,7 @@ fn parse(input: TokenStream) -> Result<(), Diagnostic> {\n pub fn three_equals(input: TokenStream) -> TokenStream {\n     if let Err(diag) = parse(input) {\n         diag.emit();\n-        return TokenStream::empty();\n+        return TokenStream::new();\n     }\n \n     \"3\".parse().unwrap()"}, {"sha": "a5f1580b60d2f6ee0290a1a3e3780f9c0ebe868e", "filename": "src/test/ui/impl-trait/impl-generic-mismatch.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.stderr?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -9,7 +9,7 @@ LL |     fn foo<U: Debug>(&self, _: &U) { }\n help: try removing the generic parameter and using `impl Trait` instead\n    |\n LL |     fn foo(&self, _: &impl Debug) { }\n-   |\n+   |          --           ^^^^^^^^^^\n \n error[E0643]: method `bar` has incompatible signature for trait\n   --> $DIR/impl-generic-mismatch.rs:27:23\n@@ -21,12 +21,8 @@ LL |     fn bar(&self, _: &impl Debug) { }\n    |                       ^^^^^^^^^^ expected generic parameter, found `impl Trait`\n help: try changing the `impl Trait` argument to a generic parameter\n    |\n-LL |     fn bar<U: Debug><U: Debug>(&self, _: &U);\n-LL | }\n-LL | \n-LL | impl Bar for () {\n-LL |     fn bar(&self, _: &U) { }\n-   |\n+LL |     fn bar<U: Debug>(&self, _: &U) { }\n+   |           ^^^^^^^^^^            ^\n \n error[E0643]: method `hash` has incompatible signature for trait\n   --> $DIR/impl-generic-mismatch.rs:38:33"}, {"sha": "b2032fb226bd13e6dd295bfb9463247a7165681c", "filename": "src/test/ui/issue-50576.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Ftest%2Fui%2Fissue-50576.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Ftest%2Fui%2Fissue-50576.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-50576.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    |bool: [u8; break 'L]| 0;\n+    //~^ ERROR [E0426]\n+    //~| ERROR [E0268]\n+    Vec::<[u8; break]>::new(); //~ ERROR [E0268]\n+}"}, {"sha": "e661be2133900abe5d69c0a5112b9d09c0c16d71", "filename": "src/test/ui/issue-50576.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Ftest%2Fui%2Fissue-50576.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Ftest%2Fui%2Fissue-50576.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-50576.stderr?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -0,0 +1,22 @@\n+error[E0426]: use of undeclared label `'L`\n+  --> $DIR/issue-50576.rs:12:23\n+   |\n+LL |     |bool: [u8; break 'L]| 0;\n+   |                       ^^ undeclared label `'L`\n+\n+error[E0268]: `break` outside of loop\n+  --> $DIR/issue-50576.rs:12:17\n+   |\n+LL |     |bool: [u8; break 'L]| 0;\n+   |                 ^^^^^^^^ cannot break outside of a loop\n+\n+error[E0268]: `break` outside of loop\n+  --> $DIR/issue-50576.rs:15:16\n+   |\n+LL |     Vec::<[u8; break]>::new(); //~ ERROR [E0268]\n+   |                ^^^^^ cannot break outside of a loop\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors occurred: E0268, E0426.\n+For more information about an error, try `rustc --explain E0268`."}, {"sha": "97b3f81eaf5fb1ff058d90e758158d2dd2a0cee2", "filename": "src/test/ui/issue-50581.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Ftest%2Fui%2Fissue-50581.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Ftest%2Fui%2Fissue-50581.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-50581.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    |_: [u8; break]| (); //~ ERROR [E0268]\n+}"}, {"sha": "38a87b1e78a1bc671d2b8f5967c7bce67ef4db1b", "filename": "src/test/ui/issue-50581.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Ftest%2Fui%2Fissue-50581.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Ftest%2Fui%2Fissue-50581.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-50581.stderr?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -0,0 +1,9 @@\n+error[E0268]: `break` outside of loop\n+  --> $DIR/issue-50581.rs:12:14\n+   |\n+LL |     |_: [u8; break]| (); //~ ERROR [E0268]\n+   |              ^^^^^ cannot break outside of a loop\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0268`."}, {"sha": "86a600ddc2fa379eab62c4ca3240b5e665e3d98c", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0e6a837fd597bfc9b7765c53f1c62a12b57779/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=7a0e6a837fd597bfc9b7765c53f1c62a12b57779", "patch": "@@ -96,6 +96,7 @@ static WHITELIST: &'static [Crate] = &[\n     Crate(\"owning_ref\"),\n     Crate(\"parking_lot\"),\n     Crate(\"parking_lot_core\"),\n+    Crate(\"polonius-engine\"),\n     Crate(\"quick-error\"),\n     Crate(\"rand\"),\n     Crate(\"redox_syscall\"),"}]}