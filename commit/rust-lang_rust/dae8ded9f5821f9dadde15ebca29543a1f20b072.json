{"sha": "dae8ded9f5821f9dadde15ebca29543a1f20b072", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZThkZWQ5ZjU4MjFmOWRhZGRlMTVlYmNhMjk1NDNhMWYyMGIwNzI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-27T15:46:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-27T15:46:56Z"}, "message": "Rollup merge of #65839 - ecstatic-morse:promo-sanity-fixes, r=eddyb\n\nClean up `check_consts` now that new promotion pass is implemented\n\n`check_consts::resolver` contained a layer of abstraction (`QualifResolver`) to allow the existing, eager style of qualif propagation to work with either a dataflow results cursor or by applying the transfer function directly (if dataflow was not needed e.g. for promotion). However, #63812 uses a different, lazy paradigm for checking promotability, which makes this unnecessary. This PR cleans up `check_consts::validation` to use `FlowSensitiveResolver` directly, instead of through the now obselete `QualifResolver` API.\n\nAlso, this contains a few commits (the first four) that address some FIXMEs in #63812 regarding code duplication. They could be split out, but I think they will be relatively noncontroversial? Notably, `validation::Mode` is renamed to `ConstKind` and used in `promote_consts` to denote what kind of item we are in.\n\nThis is best reviewed commit-by-commit and is low priority.\n\nr? @eddyb", "tree": {"sha": "689d86610502f5fcf547ecb91455567c05251868", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/689d86610502f5fcf547ecb91455567c05251868"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dae8ded9f5821f9dadde15ebca29543a1f20b072", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdtbvxCRBK7hj4Ov3rIwAAdHIIAKz0qAqY98gNC1cUzttQtsZb\nMsjW0zQ9GFYCzBFNyRUGeEM4ozy8+5C+Kq2NaezjEfqDPzOIvPmEz+lekaoNwOBw\nGV9KBfeWh4SlKlLOhxH/ci0aozb2AHkKGsg30GlQ7kv9sQU9xE8BXEoIZ50W+mPJ\nknx+hJu2KQV7YgLj6WVBwv2Wryy92F1iWdPdmwlGuVZUa61KrIugRkce76LiIEWj\nB4UZItgKdzTQLsn/wy+A6MpHwtskmcnU4qk7bn1n/mmFRTnicM7k4EHHsnYKJwgA\nVbbUTluNhWPn+3M0Q2OLet9FuO7+NFuHph2vwK6KEXpctJvIdMMc5wCcgj0c6mk=\n=Qt1i\n-----END PGP SIGNATURE-----\n", "payload": "tree 689d86610502f5fcf547ecb91455567c05251868\nparent 0982060a69e7a3faaa705d0e64bf651872b2f640\nparent b93cdbce36b1a42c77b5f3f721d7d64dec80f8f3\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1572191216 +0100\ncommitter GitHub <noreply@github.com> 1572191216 +0100\n\nRollup merge of #65839 - ecstatic-morse:promo-sanity-fixes, r=eddyb\n\nClean up `check_consts` now that new promotion pass is implemented\n\n`check_consts::resolver` contained a layer of abstraction (`QualifResolver`) to allow the existing, eager style of qualif propagation to work with either a dataflow results cursor or by applying the transfer function directly (if dataflow was not needed e.g. for promotion). However, #63812 uses a different, lazy paradigm for checking promotability, which makes this unnecessary. This PR cleans up `check_consts::validation` to use `FlowSensitiveResolver` directly, instead of through the now obselete `QualifResolver` API.\n\nAlso, this contains a few commits (the first four) that address some FIXMEs in #63812 regarding code duplication. They could be split out, but I think they will be relatively noncontroversial? Notably, `validation::Mode` is renamed to `ConstKind` and used in `promote_consts` to denote what kind of item we are in.\n\nThis is best reviewed commit-by-commit and is low priority.\n\nr? @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dae8ded9f5821f9dadde15ebca29543a1f20b072", "html_url": "https://github.com/rust-lang/rust/commit/dae8ded9f5821f9dadde15ebca29543a1f20b072", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dae8ded9f5821f9dadde15ebca29543a1f20b072/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0982060a69e7a3faaa705d0e64bf651872b2f640", "url": "https://api.github.com/repos/rust-lang/rust/commits/0982060a69e7a3faaa705d0e64bf651872b2f640", "html_url": "https://github.com/rust-lang/rust/commit/0982060a69e7a3faaa705d0e64bf651872b2f640"}, {"sha": "b93cdbce36b1a42c77b5f3f721d7d64dec80f8f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b93cdbce36b1a42c77b5f3f721d7d64dec80f8f3", "html_url": "https://github.com/rust-lang/rust/commit/b93cdbce36b1a42c77b5f3f721d7d64dec80f8f3"}], "stats": {"total": 611, "additions": 240, "deletions": 371}, "files": [{"sha": "364e23ed8d0f94d9117357119f69c0ab19b14e71", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 79, "deletions": 30, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/dae8ded9f5821f9dadde15ebca29543a1f20b072/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae8ded9f5821f9dadde15ebca29543a1f20b072/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=dae8ded9f5821f9dadde15ebca29543a1f20b072", "patch": "@@ -4,26 +4,27 @@\n //! has interior mutability or needs to be dropped, as well as the visitor that emits errors when\n //! it finds operations that are invalid in a certain context.\n \n-use rustc::hir::def_id::DefId;\n+use rustc::hir::{self, def_id::DefId};\n use rustc::mir;\n use rustc::ty::{self, TyCtxt};\n \n+use std::fmt;\n+\n pub use self::qualifs::Qualif;\n \n pub mod ops;\n pub mod qualifs;\n mod resolver;\n pub mod validation;\n \n-/// Information about the item currently being validated, as well as a reference to the global\n+/// Information about the item currently being const-checked, as well as a reference to the global\n /// context.\n pub struct Item<'mir, 'tcx> {\n-    body: &'mir mir::Body<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-    param_env: ty::ParamEnv<'tcx>,\n-    mode: validation::Mode,\n-    for_promotion: bool,\n+    pub body: &'mir mir::Body<'tcx>,\n+    pub tcx: TyCtxt<'tcx>,\n+    pub def_id: DefId,\n+    pub param_env: ty::ParamEnv<'tcx>,\n+    pub const_kind: Option<ConstKind>,\n }\n \n impl Item<'mir, 'tcx> {\n@@ -33,43 +34,91 @@ impl Item<'mir, 'tcx> {\n         body: &'mir mir::Body<'tcx>,\n     ) -> Self {\n         let param_env = tcx.param_env(def_id);\n-        let mode = validation::Mode::for_item(tcx, def_id)\n-            .expect(\"const validation must only be run inside a const context\");\n+        let const_kind = ConstKind::for_item(tcx, def_id);\n \n         Item {\n             body,\n             tcx,\n             def_id,\n             param_env,\n-            mode,\n-            for_promotion: false,\n+            const_kind,\n         }\n     }\n \n-    // HACK(eddyb) this is to get around the panic for a runtime fn from `Item::new`.\n-    // Also, it allows promoting `&mut []`.\n-    pub fn for_promotion(\n-        tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n-        body: &'mir mir::Body<'tcx>,\n-    ) -> Self {\n-        let param_env = tcx.param_env(def_id);\n-        let mode = validation::Mode::for_item(tcx, def_id)\n-            .unwrap_or(validation::Mode::ConstFn);\n+    /// Returns the kind of const context this `Item` represents (`const`, `static`, etc.).\n+    ///\n+    /// Panics if this `Item` is not const.\n+    pub fn const_kind(&self) -> ConstKind {\n+        self.const_kind.expect(\"`const_kind` must not be called on a non-const fn\")\n+    }\n+}\n \n-        Item {\n-            body,\n-            tcx,\n-            def_id,\n-            param_env,\n-            mode,\n-            for_promotion: true,\n+/// The kinds of items which require compile-time evaluation.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum ConstKind {\n+    /// A `static` item.\n+    Static,\n+    /// A `static mut` item.\n+    StaticMut,\n+    /// A `const fn` item.\n+    ConstFn,\n+    /// A `const` item or an anonymous constant (e.g. in array lengths).\n+    Const,\n+}\n+\n+impl ConstKind {\n+    /// Returns the validation mode for the item with the given `DefId`, or `None` if this item\n+    /// does not require validation (e.g. a non-const `fn`).\n+    pub fn for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<Self> {\n+        use hir::BodyOwnerKind as HirKind;\n+\n+        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+\n+        let mode = match tcx.hir().body_owner_kind(hir_id) {\n+            HirKind::Closure => return None,\n+\n+            HirKind::Fn if tcx.is_const_fn(def_id) => ConstKind::ConstFn,\n+            HirKind::Fn => return None,\n+\n+            HirKind::Const => ConstKind::Const,\n+\n+            HirKind::Static(hir::MutImmutable) => ConstKind::Static,\n+            HirKind::Static(hir::MutMutable) => ConstKind::StaticMut,\n+        };\n+\n+        Some(mode)\n+    }\n+\n+    pub fn is_static(self) -> bool {\n+        match self {\n+            ConstKind::Static | ConstKind::StaticMut => true,\n+            ConstKind::ConstFn | ConstKind::Const => false,\n+        }\n+    }\n+\n+    /// Returns `true` if the value returned by this item must be `Sync`.\n+    ///\n+    /// This returns false for `StaticMut` since all accesses to one are `unsafe` anyway.\n+    pub fn requires_sync(self) -> bool {\n+        match self {\n+            ConstKind::Static => true,\n+            ConstKind::ConstFn | ConstKind::Const |  ConstKind::StaticMut => false,\n         }\n     }\n }\n \n+impl fmt::Display for ConstKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            ConstKind::Const => write!(f, \"constant\"),\n+            ConstKind::Static | ConstKind::StaticMut => write!(f, \"static\"),\n+            ConstKind::ConstFn => write!(f, \"constant function\"),\n+        }\n+    }\n+}\n \n-fn is_lang_panic_fn(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n+/// Returns `true` if this `DefId` points to one of the official `panic` lang items.\n+pub fn is_lang_panic_fn(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n     Some(def_id) == tcx.lang_items().panic_fn() ||\n     Some(def_id) == tcx.lang_items().begin_panic_fn()\n }"}, {"sha": "4b374cff8093067807e131f1cfa392ad0d5360a7", "filename": "src/librustc_mir/transform/check_consts/ops.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/dae8ded9f5821f9dadde15ebca29543a1f20b072/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae8ded9f5821f9dadde15ebca29543a1f20b072/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs?ref=dae8ded9f5821f9dadde15ebca29543a1f20b072", "patch": "@@ -8,8 +8,7 @@ use syntax::feature_gate::{emit_feature_err, GateIssue};\n use syntax::symbol::sym;\n use syntax_pos::{Span, Symbol};\n \n-use super::Item;\n-use super::validation::Mode;\n+use super::{ConstKind, Item};\n \n /// An operation that is not *always* allowed in a const context.\n pub trait NonConstOp: std::fmt::Debug {\n@@ -36,7 +35,7 @@ pub trait NonConstOp: std::fmt::Debug {\n             span,\n             E0019,\n             \"{} contains unimplemented expression type\",\n-            item.mode\n+            item.const_kind()\n         );\n         if item.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\"A function call isn't allowed in the const's initialization expression \\\n@@ -76,7 +75,7 @@ impl NonConstOp for FnCallNonConst {\n             E0015,\n             \"calls in {}s are limited to constant functions, \\\n              tuple structs and tuple variants\",\n-            item.mode,\n+            item.const_kind(),\n         );\n         err.emit();\n     }\n@@ -121,8 +120,8 @@ impl NonConstOp for HeapAllocation {\n \n     fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n         let mut err = struct_span_err!(item.tcx.sess, span, E0010,\n-                                       \"allocations are not allowed in {}s\", item.mode);\n-        err.span_label(span, format!(\"allocation not allowed in {}s\", item.mode));\n+                                       \"allocations are not allowed in {}s\", item.const_kind());\n+        err.span_label(span, format!(\"allocation not allowed in {}s\", item.const_kind()));\n         if item.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"The value of statics and constants must be known at compile time, \\\n@@ -146,7 +145,7 @@ impl NonConstOp for LiveDrop {\n         struct_span_err!(item.tcx.sess, span, E0493,\n                          \"destructors cannot be evaluated at compile-time\")\n             .span_label(span, format!(\"{}s cannot evaluate destructors\",\n-                                      item.mode))\n+                                      item.const_kind()))\n             .emit();\n     }\n }\n@@ -163,9 +162,9 @@ impl NonConstOp for MutBorrow {\n         if let BorrowKind::Mut { .. } = kind {\n             let mut err = struct_span_err!(item.tcx.sess, span, E0017,\n                                            \"references in {}s may only refer \\\n-                                            to immutable values\", item.mode);\n+                                            to immutable values\", item.const_kind());\n             err.span_label(span, format!(\"{}s require immutable values\",\n-                                                item.mode));\n+                                                item.const_kind()));\n             if item.tcx.sess.teach(&err.get_code().unwrap()) {\n                 err.note(\"References in statics and constants may only refer \\\n                           to immutable values.\\n\\n\\\n@@ -202,7 +201,7 @@ impl NonConstOp for Panic {\n             sym::const_panic,\n             span,\n             GateIssue::Language,\n-            &format!(\"panicking in {}s is unstable\", item.mode),\n+            &format!(\"panicking in {}s is unstable\", item.const_kind()),\n         );\n     }\n }\n@@ -220,7 +219,7 @@ impl NonConstOp for RawPtrComparison {\n             sym::const_compare_raw_pointers,\n             span,\n             GateIssue::Language,\n-            &format!(\"comparing raw pointers inside {}\", item.mode),\n+            &format!(\"comparing raw pointers inside {}\", item.const_kind()),\n         );\n     }\n }\n@@ -238,7 +237,7 @@ impl NonConstOp for RawPtrDeref {\n             span, GateIssue::Language,\n             &format!(\n                 \"dereferencing raw pointers in {}s is unstable\",\n-                item.mode,\n+                item.const_kind(),\n             ),\n         );\n     }\n@@ -257,7 +256,7 @@ impl NonConstOp for RawPtrToIntCast {\n             span, GateIssue::Language,\n             &format!(\n                 \"casting pointers to integers in {}s is unstable\",\n-                item.mode,\n+                item.const_kind(),\n             ),\n         );\n     }\n@@ -268,13 +267,13 @@ impl NonConstOp for RawPtrToIntCast {\n pub struct StaticAccess;\n impl NonConstOp for StaticAccess {\n     fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n-        item.mode.is_static()\n+        item.const_kind().is_static()\n     }\n \n     fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n         let mut err = struct_span_err!(item.tcx.sess, span, E0013,\n                                         \"{}s cannot refer to statics, use \\\n-                                        a constant instead\", item.mode);\n+                                        a constant instead\", item.const_kind());\n         if item.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"Static and const variables can refer to other const variables. \\\n@@ -313,7 +312,7 @@ impl NonConstOp for Transmute {\n             &item.tcx.sess.parse_sess, sym::const_transmute,\n             span, GateIssue::Language,\n             &format!(\"The use of std::mem::transmute() \\\n-            is gated in {}s\", item.mode));\n+            is gated in {}s\", item.const_kind()));\n     }\n }\n \n@@ -322,7 +321,7 @@ pub struct UnionAccess;\n impl NonConstOp for UnionAccess {\n     fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n         // Union accesses are stable in all contexts except `const fn`.\n-        item.mode != Mode::ConstFn || Self::feature_gate(item.tcx).unwrap()\n+        item.const_kind() != ConstKind::ConstFn || Self::feature_gate(item.tcx).unwrap()\n     }\n \n     fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {"}, {"sha": "840ad303016074239ea2b81202ae91a1c5f29b07", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dae8ded9f5821f9dadde15ebca29543a1f20b072/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae8ded9f5821f9dadde15ebca29543a1f20b072/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=dae8ded9f5821f9dadde15ebca29543a1f20b072", "patch": "@@ -5,8 +5,7 @@ use rustc::mir::interpret::ConstValue;\n use rustc::ty::{self, Ty};\n use syntax_pos::DUMMY_SP;\n \n-use super::Item as ConstCx;\n-use super::validation::Mode;\n+use super::{ConstKind, Item as ConstCx};\n \n #[derive(Clone, Copy)]\n pub struct QualifSet(u8);\n@@ -236,13 +235,17 @@ impl Qualif for HasMutInterior {\n                     // mutably without consequences.\n                     match ty.kind {\n                         // Inside a `static mut`, &mut [...] is also allowed.\n-                        ty::Array(..) | ty::Slice(_) if cx.mode == Mode::StaticMut => {},\n-\n-                        // FIXME(eddyb) the `cx.for_promotion` condition\n-                        // seems unnecessary, given that this is merely a ZST.\n-                        ty::Array(_, len)\n-                            if len.try_eval_usize(cx.tcx, cx.param_env) == Some(0)\n-                                && cx.for_promotion => {},\n+                        | ty::Array(..)\n+                        | ty::Slice(_)\n+                        if cx.const_kind == Some(ConstKind::StaticMut)\n+                        => {},\n+\n+                        // FIXME(eddyb): We only return false for `&mut []` outside a const\n+                        // context which seems unnecessary given that this is merely a ZST.\n+                        | ty::Array(_, len)\n+                        if len.try_eval_usize(cx.tcx, cx.param_env) == Some(0)\n+                            && cx.const_kind == None\n+                        => {},\n \n                         _ => return true,\n                     }"}, {"sha": "8909ef7db683d17f2682a5a01acb480ccd3227bd", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 9, "deletions": 144, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/dae8ded9f5821f9dadde15ebca29543a1f20b072/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae8ded9f5821f9dadde15ebca29543a1f20b072/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=dae8ded9f5821f9dadde15ebca29543a1f20b072", "patch": "@@ -1,21 +1,18 @@\n //! Propagate `Qualif`s between locals and query the results.\n //!\n-//! This also contains the dataflow analysis used to track `Qualif`s on complex control-flow\n-//! graphs.\n+//! This contains the dataflow analysis used to track `Qualif`s on complex control-flow graphs.\n \n use rustc::mir::visit::Visitor;\n use rustc::mir::{self, BasicBlock, Local, Location};\n use rustc_index::bit_set::BitSet;\n \n-use std::cell::RefCell;\n use std::marker::PhantomData;\n \n use crate::dataflow::{self as old_dataflow, generic as dataflow};\n use super::{Item, Qualif};\n-use self::old_dataflow::IndirectlyMutableLocals;\n \n /// A `Visitor` that propagates qualifs between locals. This defines the transfer function of\n-/// `FlowSensitiveAnalysis` as well as the logic underlying `TempPromotionResolver`.\n+/// `FlowSensitiveAnalysis`.\n ///\n /// This transfer does nothing when encountering an indirect assignment. Consumers should rely on\n /// the `IndirectlyMutableLocals` dataflow pass to see if a `Local` may have become qualified via\n@@ -147,145 +144,6 @@ where\n     }\n }\n \n-/// Types that can compute the qualifs of each local at each location in a `mir::Body`.\n-///\n-/// Code that wishes to use a `QualifResolver` must call `visit_{statement,terminator}` for each\n-/// statement or terminator, processing blocks in reverse post-order beginning from the\n-/// `START_BLOCK`. Calling code may optionally call `get` after visiting each statement or\n-/// terminator to query the qualification state immediately before that statement or terminator.\n-///\n-/// These conditions are much more restrictive than woud be required by `FlowSensitiveResolver`\n-/// alone. This is to allow a linear, on-demand `TempPromotionResolver` that can operate\n-/// efficiently on simple CFGs.\n-pub trait QualifResolver<Q> {\n-    /// Get the qualifs of each local at the last location visited.\n-    ///\n-    /// This takes `&mut self` so qualifs can be computed lazily.\n-    fn get(&mut self) -> &BitSet<Local>;\n-\n-    /// A convenience method for `self.get().contains(local)`.\n-    fn contains(&mut self, local: Local) -> bool {\n-        self.get().contains(local)\n-    }\n-\n-    /// Resets the resolver to the `START_BLOCK`. This allows a resolver to be reused\n-    /// for multiple passes over a `mir::Body`.\n-    fn reset(&mut self);\n-}\n-\n-pub type IndirectlyMutableResults<'mir, 'tcx> =\n-    old_dataflow::DataflowResultsCursor<'mir, 'tcx, IndirectlyMutableLocals<'mir, 'tcx>>;\n-\n-/// A resolver for qualifs that works on arbitrarily complex CFGs.\n-///\n-/// As soon as a `Local` becomes writable through a reference (as determined by the\n-/// `IndirectlyMutableLocals` dataflow pass), we must assume that it takes on all other qualifs\n-/// possible for its type. This is because no effort is made to track qualifs across indirect\n-/// assignments (e.g. `*p = x` or calls to opaque functions).\n-///\n-/// It is possible to be more precise here by waiting until an indirect assignment actually occurs\n-/// before marking a borrowed `Local` as qualified.\n-pub struct FlowSensitiveResolver<'a, 'mir, 'tcx, Q>\n-where\n-    Q: Qualif,\n-{\n-    location: Location,\n-    indirectly_mutable_locals: &'a RefCell<IndirectlyMutableResults<'mir, 'tcx>>,\n-    cursor: dataflow::ResultsCursor<'mir, 'tcx, FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q>>,\n-    qualifs_per_local: BitSet<Local>,\n-\n-    /// The value of `Q::in_any_value_of_ty` for each local.\n-    qualifs_in_any_value_of_ty: BitSet<Local>,\n-}\n-\n-impl<Q> FlowSensitiveResolver<'a, 'mir, 'tcx, Q>\n-where\n-    Q: Qualif,\n-{\n-    pub fn new(\n-        _: Q,\n-        item: &'a Item<'mir, 'tcx>,\n-        indirectly_mutable_locals: &'a RefCell<IndirectlyMutableResults<'mir, 'tcx>>,\n-        dead_unwinds: &BitSet<BasicBlock>,\n-    ) -> Self {\n-        let analysis = FlowSensitiveAnalysis {\n-            item,\n-            _qualif: PhantomData,\n-        };\n-        let results =\n-            dataflow::Engine::new(item.tcx, item.body, item.def_id, dead_unwinds, analysis)\n-                .iterate_to_fixpoint();\n-        let cursor = dataflow::ResultsCursor::new(item.body, results);\n-\n-        let mut qualifs_in_any_value_of_ty = BitSet::new_empty(item.body.local_decls.len());\n-        for (local, decl) in item.body.local_decls.iter_enumerated() {\n-            if Q::in_any_value_of_ty(item, decl.ty) {\n-                qualifs_in_any_value_of_ty.insert(local);\n-            }\n-        }\n-\n-        FlowSensitiveResolver {\n-            cursor,\n-            indirectly_mutable_locals,\n-            qualifs_per_local: BitSet::new_empty(item.body.local_decls.len()),\n-            qualifs_in_any_value_of_ty,\n-            location: Location { block: mir::START_BLOCK, statement_index: 0 },\n-        }\n-    }\n-}\n-\n-impl<Q> Visitor<'tcx> for FlowSensitiveResolver<'_, '_, 'tcx, Q>\n-where\n-    Q: Qualif\n-{\n-    fn visit_statement(&mut self, _: &mir::Statement<'tcx>, location: Location) {\n-        self.location = location;\n-    }\n-\n-    fn visit_terminator(&mut self, _: &mir::Terminator<'tcx>, location: Location) {\n-        self.location = location;\n-    }\n-}\n-\n-impl<Q> QualifResolver<Q> for FlowSensitiveResolver<'_, '_, '_, Q>\n-where\n-    Q: Qualif\n-{\n-    fn get(&mut self) -> &BitSet<Local> {\n-        let mut indirectly_mutable_locals = self.indirectly_mutable_locals.borrow_mut();\n-\n-        indirectly_mutable_locals.seek(self.location);\n-        self.cursor.seek_before(self.location);\n-\n-        self.qualifs_per_local.overwrite(indirectly_mutable_locals.get());\n-        self.qualifs_per_local.union(self.cursor.get());\n-        self.qualifs_per_local.intersect(&self.qualifs_in_any_value_of_ty);\n-        &self.qualifs_per_local\n-    }\n-\n-    fn contains(&mut self, local: Local) -> bool {\n-        // No need to update the cursor if we know that `Local` cannot possibly be qualified.\n-        if !self.qualifs_in_any_value_of_ty.contains(local) {\n-            return false;\n-        }\n-\n-        // Otherwise, return `true` if this local is qualified or was indirectly mutable at any\n-        // point before this statement.\n-        self.cursor.seek_before(self.location);\n-        if self.cursor.get().contains(local) {\n-            return true;\n-        }\n-\n-        let mut indirectly_mutable_locals = self.indirectly_mutable_locals.borrow_mut();\n-        indirectly_mutable_locals.seek(self.location);\n-        indirectly_mutable_locals.get().contains(local)\n-    }\n-\n-    fn reset(&mut self)  {\n-        self.location = Location { block: mir::START_BLOCK, statement_index: 0 };\n-    }\n-}\n-\n /// The dataflow analysis used to propagate qualifs on arbitrary CFGs.\n pub(super) struct FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q> {\n     item: &'a Item<'mir, 'tcx>,\n@@ -296,6 +154,13 @@ impl<'a, 'mir, 'tcx, Q> FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q>\n where\n     Q: Qualif,\n {\n+    pub(super) fn new(_: Q, item: &'a Item<'mir, 'tcx>) -> Self {\n+        FlowSensitiveAnalysis {\n+            item,\n+            _qualif: PhantomData,\n+        }\n+    }\n+\n     fn transfer_function(\n         &self,\n         state: &'a mut BitSet<Local>,"}, {"sha": "244d434a51eabc8c96c2a37e697b831a698dfab4", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 92, "deletions": 115, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/dae8ded9f5821f9dadde15ebca29543a1f20b072/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae8ded9f5821f9dadde15ebca29543a1f20b072/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=dae8ded9f5821f9dadde15ebca29543a1f20b072", "patch": "@@ -1,24 +1,23 @@\n //! The `Visitor` responsible for actually checking a `mir::Body` for invalid operations.\n \n-use rustc::hir::{self, def_id::DefId};\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::*;\n use rustc::ty::cast::CastTy;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty;\n use rustc_index::bit_set::BitSet;\n use rustc_target::spec::abi::Abi;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n \n-use std::cell::RefCell;\n use std::fmt;\n use std::ops::Deref;\n \n-use crate::dataflow as old_dataflow;\n-use super::{Item, Qualif, is_lang_panic_fn};\n-use super::resolver::{FlowSensitiveResolver, IndirectlyMutableResults, QualifResolver};\n-use super::qualifs::{HasMutInterior, NeedsDrop};\n+use crate::dataflow::{self as old_dataflow, generic as dataflow};\n+use self::old_dataflow::IndirectlyMutableLocals;\n use super::ops::{self, NonConstOp};\n+use super::qualifs::{HasMutInterior, NeedsDrop};\n+use super::resolver::FlowSensitiveAnalysis;\n+use super::{ConstKind, Item, Qualif, is_lang_panic_fn};\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum CheckOpResult {\n@@ -27,73 +26,75 @@ pub enum CheckOpResult {\n     Allowed,\n }\n \n-/// What kind of item we are in.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum Mode {\n-    /// A `static` item.\n-    Static,\n-    /// A `static mut` item.\n-    StaticMut,\n-    /// A `const fn` item.\n-    ConstFn,\n-    /// A `const` item or an anonymous constant (e.g. in array lengths).\n-    Const,\n-}\n-\n-impl Mode {\n-    /// Returns the validation mode for the item with the given `DefId`, or `None` if this item\n-    /// does not require validation (e.g. a non-const `fn`).\n-    pub fn for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<Self> {\n-        use hir::BodyOwnerKind as HirKind;\n-\n-        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+pub type IndirectlyMutableResults<'mir, 'tcx> =\n+    old_dataflow::DataflowResultsCursor<'mir, 'tcx, IndirectlyMutableLocals<'mir, 'tcx>>;\n \n-        let mode = match tcx.hir().body_owner_kind(hir_id) {\n-            HirKind::Closure => return None,\n-\n-            HirKind::Fn if tcx.is_const_fn(def_id) => Mode::ConstFn,\n-            HirKind::Fn => return None,\n-\n-            HirKind::Const => Mode::Const,\n+struct QualifCursor<'a, 'mir, 'tcx, Q: Qualif> {\n+    cursor: dataflow::ResultsCursor<'mir, 'tcx, FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q>>,\n+    in_any_value_of_ty: BitSet<Local>,\n+}\n \n-            HirKind::Static(hir::MutImmutable) => Mode::Static,\n-            HirKind::Static(hir::MutMutable) => Mode::StaticMut,\n-        };\n+impl<Q: Qualif> QualifCursor<'a, 'mir, 'tcx, Q> {\n+    pub fn new(\n+        q: Q,\n+        item: &'a Item<'mir, 'tcx>,\n+        dead_unwinds: &BitSet<BasicBlock>,\n+    ) -> Self {\n+        let analysis = FlowSensitiveAnalysis::new(q, item);\n+        let results =\n+            dataflow::Engine::new(item.tcx, item.body, item.def_id, dead_unwinds, analysis)\n+                .iterate_to_fixpoint();\n+        let cursor = dataflow::ResultsCursor::new(item.body, results);\n+\n+        let mut in_any_value_of_ty = BitSet::new_empty(item.body.local_decls.len());\n+        for (local, decl) in item.body.local_decls.iter_enumerated() {\n+            if Q::in_any_value_of_ty(item, decl.ty) {\n+                in_any_value_of_ty.insert(local);\n+            }\n+        }\n \n-        Some(mode)\n+        QualifCursor {\n+            cursor,\n+            in_any_value_of_ty,\n+        }\n     }\n+}\n \n-    pub fn is_static(self) -> bool {\n-        match self {\n-            Mode::Static | Mode::StaticMut => true,\n-            Mode::ConstFn | Mode::Const => false,\n-        }\n+pub struct Qualifs<'a, 'mir, 'tcx> {\n+    has_mut_interior: QualifCursor<'a, 'mir, 'tcx, HasMutInterior>,\n+    needs_drop: QualifCursor<'a, 'mir, 'tcx, NeedsDrop>,\n+    indirectly_mutable: IndirectlyMutableResults<'mir, 'tcx>,\n+}\n+\n+impl Qualifs<'a, 'mir, 'tcx> {\n+    fn indirectly_mutable(&mut self, local: Local, location: Location) -> bool {\n+        self.indirectly_mutable.seek(location);\n+        self.indirectly_mutable.get().contains(local)\n     }\n \n-    /// Returns `true` if the value returned by this item must be `Sync`.\n+    /// Returns `true` if `local` is `NeedsDrop` at the given `Location`.\n     ///\n-    /// This returns false for `StaticMut` since all accesses to one are `unsafe` anyway.\n-    pub fn requires_sync(self) -> bool {\n-        match self {\n-            Mode::Static => true,\n-            Mode::ConstFn | Mode::Const |  Mode::StaticMut => false,\n+    /// Only updates the cursor if absolutely necessary\n+    fn needs_drop_lazy_seek(&mut self, local: Local, location: Location) -> bool {\n+        if !self.needs_drop.in_any_value_of_ty.contains(local) {\n+            return false;\n         }\n+\n+        self.needs_drop.cursor.seek_before(location);\n+        self.needs_drop.cursor.get().contains(local)\n+            || self.indirectly_mutable(local, location)\n     }\n-}\n \n-impl fmt::Display for Mode {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            Mode::Const => write!(f, \"constant\"),\n-            Mode::Static | Mode::StaticMut => write!(f, \"static\"),\n-            Mode::ConstFn => write!(f, \"constant function\"),\n+    /// Returns `true` if `local` is `HasMutInterior`, but requires the `has_mut_interior` and\n+    /// `indirectly_mutable` cursors to be updated beforehand.\n+    fn has_mut_interior_eager_seek(&self, local: Local) -> bool {\n+        if !self.has_mut_interior.in_any_value_of_ty.contains(local) {\n+            return false;\n         }\n-    }\n-}\n \n-pub struct Qualifs<'a, 'mir, 'tcx> {\n-    has_mut_interior: FlowSensitiveResolver<'a, 'mir, 'tcx, HasMutInterior>,\n-    needs_drop: FlowSensitiveResolver<'a, 'mir, 'tcx, NeedsDrop>,\n+        self.has_mut_interior.cursor.get().contains(local)\n+            || self.indirectly_mutable.get().contains(local)\n+    }\n }\n \n pub struct Validator<'a, 'mir, 'tcx> {\n@@ -128,53 +129,43 @@ impl Deref for Validator<'_, 'mir, 'tcx> {\n     }\n }\n \n-pub fn compute_indirectly_mutable_locals<'mir, 'tcx>(\n-    item: &Item<'mir, 'tcx>,\n-) -> RefCell<IndirectlyMutableResults<'mir, 'tcx>> {\n-    let dead_unwinds = BitSet::new_empty(item.body.basic_blocks().len());\n-\n-    let indirectly_mutable_locals = old_dataflow::do_dataflow(\n-        item.tcx,\n-        item.body,\n-        item.def_id,\n-        &item.tcx.get_attrs(item.def_id),\n-        &dead_unwinds,\n-        old_dataflow::IndirectlyMutableLocals::new(item.tcx, item.body, item.param_env),\n-        |_, local| old_dataflow::DebugFormatted::new(&local),\n-    );\n-\n-    let indirectly_mutable_locals = old_dataflow::DataflowResultsCursor::new(\n-        indirectly_mutable_locals,\n-        item.body,\n-    );\n-\n-    RefCell::new(indirectly_mutable_locals)\n-}\n-\n impl Validator<'a, 'mir, 'tcx> {\n     pub fn new(\n         item: &'a Item<'mir, 'tcx>,\n-        indirectly_mutable_locals: &'a RefCell<IndirectlyMutableResults<'mir, 'tcx>>,\n     ) -> Self {\n         let dead_unwinds = BitSet::new_empty(item.body.basic_blocks().len());\n \n-        let needs_drop = FlowSensitiveResolver::new(\n+        let needs_drop = QualifCursor::new(\n             NeedsDrop,\n             item,\n-            indirectly_mutable_locals,\n             &dead_unwinds,\n         );\n \n-        let has_mut_interior = FlowSensitiveResolver::new(\n+        let has_mut_interior = QualifCursor::new(\n             HasMutInterior,\n             item,\n-            indirectly_mutable_locals,\n             &dead_unwinds,\n         );\n \n+        let indirectly_mutable = old_dataflow::do_dataflow(\n+            item.tcx,\n+            item.body,\n+            item.def_id,\n+            &item.tcx.get_attrs(item.def_id),\n+            &dead_unwinds,\n+            old_dataflow::IndirectlyMutableLocals::new(item.tcx, item.body, item.param_env),\n+            |_, local| old_dataflow::DebugFormatted::new(&local),\n+        );\n+\n+        let indirectly_mutable = old_dataflow::DataflowResultsCursor::new(\n+            indirectly_mutable,\n+            item.body,\n+        );\n+\n         let qualifs = Qualifs {\n             needs_drop,\n             has_mut_interior,\n+            indirectly_mutable,\n         };\n \n         Validator {\n@@ -187,14 +178,6 @@ impl Validator<'a, 'mir, 'tcx> {\n         }\n     }\n \n-    /// Resets the `QualifResolver`s used by this `Validator` and returns them so they can be\n-    /// reused.\n-    pub fn into_qualifs(mut self) -> Qualifs<'a, 'mir, 'tcx> {\n-        self.qualifs.needs_drop.reset();\n-        self.qualifs.has_mut_interior.reset();\n-        self.qualifs\n-    }\n-\n     pub fn take_errors(&mut self) -> Vec<(Span, String)> {\n         std::mem::replace(&mut self.errors, vec![])\n     }\n@@ -343,7 +326,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 let is_thread_local = self.tcx.has_attr(*def_id, sym::thread_local);\n                 if is_thread_local {\n                     self.check_op(ops::ThreadLocalAccess);\n-                } else if self.mode == Mode::Static && context.is_mutating_use() {\n+                } else if self.const_kind() == ConstKind::Static && context.is_mutating_use() {\n                     // this is not strictly necessary as miri will also bail out\n                     // For interior mutability we can't really catch this statically as that\n                     // goes through raw pointers and intermediate temporaries, so miri has\n@@ -369,10 +352,16 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         // it depends on `HasMutInterior` being set for mutable borrows as well as values with\n         // interior mutability.\n         if let Rvalue::Ref(_, kind, ref borrowed_place) = *rvalue {\n-            let rvalue_has_mut_interior = {\n-                let has_mut_interior = self.qualifs.has_mut_interior.get();\n-                HasMutInterior::in_rvalue(&self.item, &|l| has_mut_interior.contains(l), rvalue)\n-            };\n+            // FIXME: Change the `in_*` methods to take a `FnMut` so we don't have to manually seek\n+            // the cursors beforehand.\n+            self.qualifs.has_mut_interior.cursor.seek_before(location);\n+            self.qualifs.indirectly_mutable.seek(location);\n+\n+            let rvalue_has_mut_interior = HasMutInterior::in_rvalue(\n+                &self.item,\n+                &|local| self.qualifs.has_mut_interior_eager_seek(local),\n+                rvalue,\n+            );\n \n             if rvalue_has_mut_interior {\n                 let is_derived_from_illegal_borrow = match borrowed_place.as_local() {\n@@ -467,9 +456,6 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n     fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n         trace!(\"visit_statement: statement={:?} location={:?}\", statement, location);\n \n-        self.qualifs.needs_drop.visit_statement(statement, location);\n-        self.qualifs.has_mut_interior.visit_statement(statement, location);\n-\n         match statement.kind {\n             StatementKind::Assign(..) => {\n                 self.super_statement(statement, location);\n@@ -489,15 +475,6 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         }\n     }\n \n-    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n-        trace!(\"visit_terminator: terminator={:?} location={:?}\", terminator, location);\n-\n-        self.qualifs.needs_drop.visit_terminator(terminator, location);\n-        self.qualifs.has_mut_interior.visit_terminator(terminator, location);\n-\n-        self.super_terminator(terminator, location);\n-    }\n-\n     fn visit_terminator_kind(&mut self, kind: &TerminatorKind<'tcx>, location: Location) {\n         trace!(\"visit_terminator_kind: kind={:?} location={:?}\", kind, location);\n         self.super_terminator_kind(kind, location);\n@@ -576,7 +553,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 let needs_drop = if let Some(local) = dropped_place.as_local() {\n                     // Use the span where the local was declared as the span of the drop error.\n                     err_span = self.body.local_decls[local].source_info.span;\n-                    self.qualifs.needs_drop.contains(local)\n+                    self.qualifs.needs_drop_lazy_seek(local, location)\n                 } else {\n                     true\n                 };"}, {"sha": "3af08090853a6bfa46754ae2b350d8a855ee0b36", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 31, "deletions": 54, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/dae8ded9f5821f9dadde15ebca29543a1f20b072/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae8ded9f5821f9dadde15ebca29543a1f20b072/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=dae8ded9f5821f9dadde15ebca29543a1f20b072", "patch": "@@ -12,7 +12,6 @@\n //! initialization and can otherwise silence errors, if\n //! move analysis runs after promotion on broken MIR.\n \n-use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::mir::*;\n use rustc::mir::interpret::ConstValue;\n@@ -30,7 +29,7 @@ use rustc_target::spec::abi::Abi;\n \n use std::{iter, mem, usize};\n \n-use crate::transform::check_consts::{qualifs, Item as ConstCx};\n+use crate::transform::check_consts::{qualifs, Item, ConstKind, is_lang_panic_fn};\n \n /// State of a temporary during collection and promotion.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -224,18 +223,13 @@ pub fn collect_temps_and_candidates(\n     (collector.temps, collector.candidates)\n }\n \n+/// Checks whether locals that appear in a promotion context (`Candidate`) are actually promotable.\n+///\n+/// This wraps an `Item`, and has access to all fields of that `Item` via `Deref` coercion.\n struct Validator<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    body: &'a Body<'tcx>,\n-    is_static: bool,\n-    is_static_mut: bool,\n-    is_non_const_fn: bool,\n+    item: Item<'a, 'tcx>,\n     temps: &'a IndexVec<Local, TempState>,\n \n-    // FIXME(eddyb) deduplicate the data in this vs other fields.\n-    const_cx: ConstCx<'a, 'tcx>,\n-\n     /// Explicit promotion happens e.g. for constant arguments declared via\n     /// `rustc_args_required_const`.\n     /// Implicit promotion has almost the same rules, except that disallows `const fn`\n@@ -245,14 +239,17 @@ struct Validator<'a, 'tcx> {\n     explicit: bool,\n }\n \n-struct Unpromotable;\n+impl std::ops::Deref for Validator<'a, 'tcx> {\n+    type Target = Item<'a, 'tcx>;\n \n-impl<'tcx> Validator<'_, 'tcx> {\n-    fn is_const_panic_fn(&self, def_id: DefId) -> bool {\n-        Some(def_id) == self.tcx.lang_items().panic_fn() ||\n-        Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n+    fn deref(&self) -> &Self::Target {\n+        &self.item\n     }\n+}\n+\n+struct Unpromotable;\n \n+impl<'tcx> Validator<'_, 'tcx> {\n     fn validate_candidate(&self, candidate: Candidate) -> Result<(), Unpromotable> {\n         match candidate {\n             Candidate::Ref(loc) => {\n@@ -317,13 +314,14 @@ impl<'tcx> Validator<'_, 'tcx> {\n                         if self.qualif_local::<qualifs::NeedsDrop>(base) {\n                             return Err(Unpromotable);\n                         }\n+\n                         if let BorrowKind::Mut { .. } = kind {\n                             let ty = place.ty(self.body, self.tcx).ty;\n \n                             // In theory, any zero-sized value could be borrowed\n                             // mutably without consequences. However, only &mut []\n                             // is allowed right now, and only in functions.\n-                            if self.is_static_mut {\n+                            if self.const_kind == Some(ConstKind::StaticMut) {\n                                 // Inside a `static mut`, &mut [...] is also allowed.\n                                 match ty.kind {\n                                     ty::Array(..) | ty::Slice(_) => {}\n@@ -333,7 +331,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                                 // FIXME(eddyb) the `self.is_non_const_fn` condition\n                                 // seems unnecessary, given that this is merely a ZST.\n                                 match len.try_eval_usize(self.tcx, self.param_env) {\n-                                    Some(0) if self.is_non_const_fn => {},\n+                                    Some(0) if self.const_kind.is_none() => {},\n                                     _ => return Err(Unpromotable),\n                                 }\n                             } else {\n@@ -386,7 +384,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 let statement = &self.body[loc.block].statements[loc.statement_index];\n                 match &statement.kind {\n                     StatementKind::Assign(box(_, rhs)) => {\n-                        Q::in_rvalue(&self.const_cx, per_local, rhs)\n+                        Q::in_rvalue(&self.item, per_local, rhs)\n                     }\n                     _ => {\n                         span_bug!(statement.source_info.span, \"{:?} is not an assignment\",\n@@ -398,7 +396,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 match &terminator.kind {\n                     TerminatorKind::Call { func, args, .. } => {\n                         let return_ty = self.body.local_decls[local].ty;\n-                        Q::in_call(&self.const_cx, per_local, func, args, return_ty)\n+                        Q::in_call(&self.item, per_local, func, args, return_ty)\n                     }\n                     kind => {\n                         span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n@@ -462,8 +460,8 @@ impl<'tcx> Validator<'_, 'tcx> {\n             } => {\n                 // Only allow statics (not consts) to refer to other statics.\n                 // FIXME(eddyb) does this matter at all for promotion?\n-                let allowed = self.is_static || self.is_static_mut;\n-                if !allowed {\n+                let is_static = self.const_kind.map_or(false, |k| k.is_static());\n+                if !is_static {\n                     return Err(Unpromotable);\n                 }\n \n@@ -490,7 +488,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     }\n \n                     ProjectionElem::Field(..) => {\n-                        if self.is_non_const_fn {\n+                        if self.const_kind.is_none() {\n                             let base_ty =\n                                 Place::ty_from(place.base, proj_base, self.body, self.tcx).ty;\n                             if let Some(def) = base_ty.ty_adt_def() {\n@@ -545,7 +543,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n     fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n         match *rvalue {\n-            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if self.is_non_const_fn => {\n+            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if self.const_kind.is_none() => {\n                 let operand_ty = operand.ty(self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n@@ -559,7 +557,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 }\n             }\n \n-            Rvalue::BinaryOp(op, ref lhs, _) if self.is_non_const_fn => {\n+            Rvalue::BinaryOp(op, ref lhs, _) if self.const_kind.is_none() => {\n                 if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n@@ -600,17 +598,17 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     // In theory, any zero-sized value could be borrowed\n                     // mutably without consequences. However, only &mut []\n                     // is allowed right now, and only in functions.\n-                    if self.is_static_mut {\n+                    if self.const_kind == Some(ConstKind::StaticMut) {\n                         // Inside a `static mut`, &mut [...] is also allowed.\n                         match ty.kind {\n                             ty::Array(..) | ty::Slice(_) => {}\n                             _ => return Err(Unpromotable),\n                         }\n                     } else if let ty::Array(_, len) = ty.kind {\n-                        // FIXME(eddyb) the `self.is_non_const_fn` condition\n-                        // seems unnecessary, given that this is merely a ZST.\n+                        // FIXME(eddyb): We only return `Unpromotable` for `&mut []` inside a\n+                        // const context which seems unnecessary given that this is merely a ZST.\n                         match len.try_eval_usize(self.tcx, self.param_env) {\n-                            Some(0) if self.is_non_const_fn => {},\n+                            Some(0) if self.const_kind.is_none() => {},\n                             _ => return Err(Unpromotable),\n                         }\n                     } else {\n@@ -683,7 +681,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n     ) -> Result<(), Unpromotable> {\n         let fn_ty = callee.ty(self.body, self.tcx);\n \n-        if !self.explicit && self.is_non_const_fn {\n+        if !self.explicit && self.const_kind.is_none() {\n             if let ty::FnDef(def_id, _) = fn_ty.kind {\n                 // Never promote runtime `const fn` calls of\n                 // functions without `#[rustc_promotable]`.\n@@ -697,7 +695,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n             ty::FnDef(def_id, _) => {\n                 self.tcx.is_const_fn(def_id) ||\n                 self.tcx.is_unstable_const_fn(def_id).is_some() ||\n-                self.is_const_panic_fn(def_id)\n+                is_lang_panic_fn(self.tcx, self.def_id)\n             }\n             _ => false,\n         };\n@@ -714,6 +712,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n     }\n }\n \n+// FIXME(eddyb) remove the differences for promotability in `static`, `const`, `const fn`.\n pub fn validate_candidates(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n@@ -722,33 +721,11 @@ pub fn validate_candidates(\n     candidates: &[Candidate],\n ) -> Vec<Candidate> {\n     let mut validator = Validator {\n-        tcx,\n-        param_env: tcx.param_env(def_id),\n-        body,\n-        is_static: false,\n-        is_static_mut: false,\n-        is_non_const_fn: false,\n+        item: Item::new(tcx, def_id, body),\n         temps,\n-\n-        const_cx: ConstCx::for_promotion(tcx, def_id, body),\n-\n         explicit: false,\n     };\n \n-    // FIXME(eddyb) remove the distinctions that make this necessary.\n-    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    match tcx.hir().body_owner_kind(id) {\n-        hir::BodyOwnerKind::Closure => validator.is_non_const_fn = true,\n-        hir::BodyOwnerKind::Fn => {\n-            if !tcx.is_const_fn(def_id) {\n-                validator.is_non_const_fn = true;\n-            }\n-        },\n-        hir::BodyOwnerKind::Static(hir::MutImmutable) => validator.is_static = true,\n-        hir::BodyOwnerKind::Static(hir::MutMutable) => validator.is_static_mut = true,\n-        _ => {}\n-    }\n-\n     candidates.iter().copied().filter(|&candidate| {\n         validator.explicit = match candidate {\n             Candidate::Ref(_) |"}, {"sha": "2f77cd5ddf71634aa427c40f238da5f6dc5eaf7f", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dae8ded9f5821f9dadde15ebca29543a1f20b072/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae8ded9f5821f9dadde15ebca29543a1f20b072/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=dae8ded9f5821f9dadde15ebca29543a1f20b072", "patch": "@@ -968,8 +968,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         }\n \n         let item = new_checker::Item::new(self.tcx, self.def_id, self.body);\n-        let mut_borrowed_locals = new_checker::validation::compute_indirectly_mutable_locals(&item);\n-        let mut validator = new_checker::validation::Validator::new(&item, &mut_borrowed_locals);\n+        let mut validator = new_checker::validation::Validator::new(&item);\n \n         validator.suppress_errors = !use_new_validator;\n         self.suppress_errors = use_new_validator;"}]}