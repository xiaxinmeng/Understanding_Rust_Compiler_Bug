{"sha": "83f5cf8c4de38f15eafa9e7da44c35a101b74b5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzZjVjZjhjNGRlMzhmMTVlYWZhOWU3ZGE0NGMzNWExMDFiNzRiNWU=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2019-12-31T12:44:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-31T12:44:03Z"}, "message": "Rollup merge of #67697 - cjgillot:passes-scope-tree, r=Zoxc\n\nMove the region_scope_tree query to librustc_passes.\n\nSplit out of #67688.\n\nr? @Zoxc", "tree": {"sha": "33ede22955cd9337b51e58f7619ddcd5237ce2e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33ede22955cd9337b51e58f7619ddcd5237ce2e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83f5cf8c4de38f15eafa9e7da44c35a101b74b5e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeC0KTCRBK7hj4Ov3rIwAAdHIIAKKl9n9oga4O20zlNbHh6Uk9\n3dqRlSpNdVNoK1Fdu3xRqDzC0FxhKtdn90XDJXOgock7/vzcARn8dDsPGeYx4jw/\nIj7HwCTDQ2Bmh+YGG94ILRAv65K7OKEbrrZQ6kvnuYJw+fVUFwtTfRYL78XN8n6F\ng4Mavu3rVaZ/lFWS8O2RZ5Frb9JqqOnIZMBlx/h7YJyKSky6fSJus2OlEiELvA32\nLWsmJofefFvwN76LOMu553PkSMxgYpcX7KjBkh/2N27YOaqQO92TY/dvpewf/86N\nQ9PUxwRo32NMSGDAqGo4iJxWKsR/nAR/AwOAtrdStJobZoEFeJrQ2E3dUA6OiHw=\n=Mdmn\n-----END PGP SIGNATURE-----\n", "payload": "tree 33ede22955cd9337b51e58f7619ddcd5237ce2e7\nparent 2c64475069cc20701b84395af24110334fa0c15c\nparent 5ed625a86eac34988d7a25e0cc98bf737d65603d\nauthor Dylan DPC <dylan.dpc@gmail.com> 1577796243 +0530\ncommitter GitHub <noreply@github.com> 1577796243 +0530\n\nRollup merge of #67697 - cjgillot:passes-scope-tree, r=Zoxc\n\nMove the region_scope_tree query to librustc_passes.\n\nSplit out of #67688.\n\nr? @Zoxc\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83f5cf8c4de38f15eafa9e7da44c35a101b74b5e", "html_url": "https://github.com/rust-lang/rust/commit/83f5cf8c4de38f15eafa9e7da44c35a101b74b5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83f5cf8c4de38f15eafa9e7da44c35a101b74b5e/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c64475069cc20701b84395af24110334fa0c15c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c64475069cc20701b84395af24110334fa0c15c", "html_url": "https://github.com/rust-lang/rust/commit/2c64475069cc20701b84395af24110334fa0c15c"}, {"sha": "5ed625a86eac34988d7a25e0cc98bf737d65603d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ed625a86eac34988d7a25e0cc98bf737d65603d", "html_url": "https://github.com/rust-lang/rust/commit/5ed625a86eac34988d7a25e0cc98bf737d65603d"}], "stats": {"total": 1724, "additions": 847, "deletions": 877}, "files": [{"sha": "a4c489735a96d56159ec88b00b221c40de7df05c", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 10, "deletions": 876, "changes": 886, "blob_url": "https://github.com/rust-lang/rust/blob/83f5cf8c4de38f15eafa9e7da44c35a101b74b5e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83f5cf8c4de38f15eafa9e7da44c35a101b74b5e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=83f5cf8c4de38f15eafa9e7da44c35a101b74b5e", "patch": "@@ -1,4 +1,4 @@\n-//! This file builds up the `ScopeTree`, which describes\n+//! This file declares the `ScopeTree` type, which describes\n //! the parent links in the region hierarchy.\n //!\n //! For more information about how MIR-based region-checking works,\n@@ -8,22 +8,17 @@\n \n use crate::hir;\n use crate::hir::def_id::DefId;\n-use crate::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use crate::hir::Node;\n-use crate::hir::{Arm, Block, Expr, Local, Pat, PatKind, Stmt};\n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n-use crate::ty::query::Providers;\n use crate::ty::{self, DefIdTree, TyCtxt};\n-use crate::util::nodemap::{FxHashMap, FxHashSet};\n+use crate::util::nodemap::FxHashMap;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_index::vec::Idx;\n use rustc_macros::HashStable;\n-use syntax::source_map;\n use syntax_pos::{Span, DUMMY_SP};\n \n use std::fmt;\n-use std::mem;\n \n /// Represents a statically-describable scope that can be used to\n /// bound the lifetime/region for values.\n@@ -232,20 +227,20 @@ pub type ScopeDepth = u32;\n #[derive(Default, Debug)]\n pub struct ScopeTree {\n     /// If not empty, this body is the root of this region hierarchy.\n-    root_body: Option<hir::HirId>,\n+    pub root_body: Option<hir::HirId>,\n \n     /// The parent of the root body owner, if the latter is an\n     /// an associated const or method, as impls/traits can also\n     /// have lifetime parameters free in this body.\n-    root_parent: Option<hir::HirId>,\n+    pub root_parent: Option<hir::HirId>,\n \n     /// Maps from a scope ID to the enclosing scope id;\n     /// this is usually corresponding to the lexical nesting, though\n     /// in the case of closures the parent scope is the innermost\n     /// conditional expression or repeating block. (Note that the\n     /// enclosing scope ID for the block associated with a closure is\n     /// the closure itself.)\n-    parent_map: FxHashMap<Scope, (Scope, ScopeDepth)>,\n+    pub parent_map: FxHashMap<Scope, (Scope, ScopeDepth)>,\n \n     /// Maps from a variable or binding ID to the block in which that\n     /// variable is declared.\n@@ -345,12 +340,12 @@ pub struct ScopeTree {\n     /// The reason is that semantically, until the `box` expression returns,\n     /// the values are still owned by their containing expressions. So\n     /// we'll see that `&x`.\n-    yield_in_scope: FxHashMap<Scope, YieldData>,\n+    pub yield_in_scope: FxHashMap<Scope, YieldData>,\n \n     /// The number of visit_expr and visit_pat calls done in the body.\n     /// Used to sanity check visit_expr/visit_pat call count when\n     /// calculating generator interiors.\n-    body_expr_count: FxHashMap<hir::BodyId, usize>,\n+    pub body_expr_count: FxHashMap<hir::BodyId, usize>,\n }\n \n #[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n@@ -362,101 +357,6 @@ pub struct YieldData {\n     pub source: hir::YieldSource,\n }\n \n-#[derive(Debug, Copy, Clone)]\n-pub struct Context {\n-    /// The root of the current region tree. This is typically the id\n-    /// of the innermost fn body. Each fn forms its own disjoint tree\n-    /// in the region hierarchy. These fn bodies are themselves\n-    /// arranged into a tree. See the \"Modeling closures\" section of\n-    /// the README in `infer::region_constraints` for more\n-    /// details.\n-    root_id: Option<hir::ItemLocalId>,\n-\n-    /// The scope that contains any new variables declared, plus its depth in\n-    /// the scope tree.\n-    var_parent: Option<(Scope, ScopeDepth)>,\n-\n-    /// Region parent of expressions, etc., plus its depth in the scope tree.\n-    parent: Option<(Scope, ScopeDepth)>,\n-}\n-\n-struct RegionResolutionVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-\n-    // The number of expressions and patterns visited in the current body.\n-    expr_and_pat_count: usize,\n-    // When this is `true`, we record the `Scopes` we encounter\n-    // when processing a Yield expression. This allows us to fix\n-    // up their indices.\n-    pessimistic_yield: bool,\n-    // Stores scopes when `pessimistic_yield` is `true`.\n-    fixup_scopes: Vec<Scope>,\n-    // The generated scope tree.\n-    scope_tree: ScopeTree,\n-\n-    cx: Context,\n-\n-    /// `terminating_scopes` is a set containing the ids of each\n-    /// statement, or conditional/repeating expression. These scopes\n-    /// are calling \"terminating scopes\" because, when attempting to\n-    /// find the scope of a temporary, by default we search up the\n-    /// enclosing scopes until we encounter the terminating scope. A\n-    /// conditional/repeating expression is one which is not\n-    /// guaranteed to execute exactly once upon entering the parent\n-    /// scope. This could be because the expression only executes\n-    /// conditionally, such as the expression `b` in `a && b`, or\n-    /// because the expression may execute many times, such as a loop\n-    /// body. The reason that we distinguish such expressions is that,\n-    /// upon exiting the parent scope, we cannot statically know how\n-    /// many times the expression executed, and thus if the expression\n-    /// creates temporaries we cannot know statically how many such\n-    /// temporaries we would have to cleanup. Therefore, we ensure that\n-    /// the temporaries never outlast the conditional/repeating\n-    /// expression, preventing the need for dynamic checks and/or\n-    /// arbitrary amounts of stack space. Terminating scopes end\n-    /// up being contained in a DestructionScope that contains the\n-    /// destructor's execution.\n-    terminating_scopes: FxHashSet<hir::ItemLocalId>,\n-}\n-\n-struct ExprLocatorVisitor {\n-    hir_id: hir::HirId,\n-    result: Option<usize>,\n-    expr_and_pat_count: usize,\n-}\n-\n-// This visitor has to have the same `visit_expr` calls as `RegionResolutionVisitor`\n-// since `expr_count` is compared against the results there.\n-impl<'tcx> Visitor<'tcx> for ExprLocatorVisitor {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_pat(&mut self, pat: &'tcx Pat<'tcx>) {\n-        intravisit::walk_pat(self, pat);\n-\n-        self.expr_and_pat_count += 1;\n-\n-        if pat.hir_id == self.hir_id {\n-            self.result = Some(self.expr_and_pat_count);\n-        }\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        debug!(\"ExprLocatorVisitor - pre-increment {} expr = {:?}\", self.expr_and_pat_count, expr);\n-\n-        intravisit::walk_expr(self, expr);\n-\n-        self.expr_and_pat_count += 1;\n-\n-        debug!(\"ExprLocatorVisitor - post-increment {} expr = {:?}\", self.expr_and_pat_count, expr);\n-\n-        if expr.hir_id == self.hir_id {\n-            self.result = Some(self.expr_and_pat_count);\n-        }\n-    }\n-}\n-\n impl<'tcx> ScopeTree {\n     pub fn record_scope_parent(&mut self, child: Scope, parent: Option<(Scope, ScopeDepth)>) {\n         debug!(\"{:?}.parent = {:?}\", child, parent);\n@@ -497,7 +397,7 @@ impl<'tcx> ScopeTree {\n     /// Records that `sub_closure` is defined within `sup_closure`. These IDs\n     /// should be the ID of the block that is the fn body, which is\n     /// also the root of the region hierarchy for that fn.\n-    fn record_closure_parent(\n+    pub fn record_closure_parent(\n         &mut self,\n         sub_closure: hir::ItemLocalId,\n         sup_closure: hir::ItemLocalId,\n@@ -511,13 +411,13 @@ impl<'tcx> ScopeTree {\n         assert!(previous.is_none());\n     }\n \n-    fn record_var_scope(&mut self, var: hir::ItemLocalId, lifetime: Scope) {\n+    pub fn record_var_scope(&mut self, var: hir::ItemLocalId, lifetime: Scope) {\n         debug!(\"record_var_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.item_local_id());\n         self.var_map.insert(var, lifetime);\n     }\n \n-    fn record_rvalue_scope(&mut self, var: hir::ItemLocalId, lifetime: Option<Scope>) {\n+    pub fn record_rvalue_scope(&mut self, var: hir::ItemLocalId, lifetime: Option<Scope>) {\n         debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n         if let Some(lifetime) = lifetime {\n             assert!(var != lifetime.item_local_id());\n@@ -732,23 +632,6 @@ impl<'tcx> ScopeTree {\n         self.yield_in_scope.get(&scope).cloned()\n     }\n \n-    /// Checks whether the given scope contains a `yield` and if that yield could execute\n-    /// after `expr`. If so, it returns the span of that `yield`.\n-    /// `scope` must be inside the body.\n-    pub fn yield_in_scope_for_expr(\n-        &self,\n-        scope: Scope,\n-        expr_hir_id: hir::HirId,\n-        body: &'tcx hir::Body<'tcx>,\n-    ) -> Option<Span> {\n-        self.yield_in_scope(scope).and_then(|YieldData { span, expr_and_pat_count, .. }| {\n-            let mut visitor =\n-                ExprLocatorVisitor { hir_id: expr_hir_id, result: None, expr_and_pat_count: 0 };\n-            visitor.visit_body(body);\n-            if expr_and_pat_count >= visitor.result.unwrap() { Some(span) } else { None }\n-        })\n-    }\n-\n     /// Gives the number of expressions visited in a body.\n     /// Used to sanity check visit_expr call count when\n     /// calculating generator interiors.\n@@ -757,755 +640,6 @@ impl<'tcx> ScopeTree {\n     }\n }\n \n-/// Records the lifetime of a local variable as `cx.var_parent`\n-fn record_var_lifetime(\n-    visitor: &mut RegionResolutionVisitor<'_>,\n-    var_id: hir::ItemLocalId,\n-    _sp: Span,\n-) {\n-    match visitor.cx.var_parent {\n-        None => {\n-            // this can happen in extern fn declarations like\n-            //\n-            // extern fn isalnum(c: c_int) -> c_int\n-        }\n-        Some((parent_scope, _)) => visitor.scope_tree.record_var_scope(var_id, parent_scope),\n-    }\n-}\n-\n-fn resolve_block<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, blk: &'tcx hir::Block<'tcx>) {\n-    debug!(\"resolve_block(blk.hir_id={:?})\", blk.hir_id);\n-\n-    let prev_cx = visitor.cx;\n-\n-    // We treat the tail expression in the block (if any) somewhat\n-    // differently from the statements. The issue has to do with\n-    // temporary lifetimes. Consider the following:\n-    //\n-    //    quux({\n-    //        let inner = ... (&bar()) ...;\n-    //\n-    //        (... (&foo()) ...) // (the tail expression)\n-    //    }, other_argument());\n-    //\n-    // Each of the statements within the block is a terminating\n-    // scope, and thus a temporary (e.g., the result of calling\n-    // `bar()` in the initializer expression for `let inner = ...;`)\n-    // will be cleaned up immediately after its corresponding\n-    // statement (i.e., `let inner = ...;`) executes.\n-    //\n-    // On the other hand, temporaries associated with evaluating the\n-    // tail expression for the block are assigned lifetimes so that\n-    // they will be cleaned up as part of the terminating scope\n-    // *surrounding* the block expression. Here, the terminating\n-    // scope for the block expression is the `quux(..)` call; so\n-    // those temporaries will only be cleaned up *after* both\n-    // `other_argument()` has run and also the call to `quux(..)`\n-    // itself has returned.\n-\n-    visitor.enter_node_scope_with_dtor(blk.hir_id.local_id);\n-    visitor.cx.var_parent = visitor.cx.parent;\n-\n-    {\n-        // This block should be kept approximately in sync with\n-        // `intravisit::walk_block`. (We manually walk the block, rather\n-        // than call `walk_block`, in order to maintain precise\n-        // index information.)\n-\n-        for (i, statement) in blk.stmts.iter().enumerate() {\n-            match statement.kind {\n-                hir::StmtKind::Local(..) | hir::StmtKind::Item(..) => {\n-                    // Each declaration introduces a subscope for bindings\n-                    // introduced by the declaration; this subscope covers a\n-                    // suffix of the block. Each subscope in a block has the\n-                    // previous subscope in the block as a parent, except for\n-                    // the first such subscope, which has the block itself as a\n-                    // parent.\n-                    visitor.enter_scope(Scope {\n-                        id: blk.hir_id.local_id,\n-                        data: ScopeData::Remainder(FirstStatementIndex::new(i)),\n-                    });\n-                    visitor.cx.var_parent = visitor.cx.parent;\n-                }\n-                hir::StmtKind::Expr(..) | hir::StmtKind::Semi(..) => {}\n-            }\n-            visitor.visit_stmt(statement)\n-        }\n-        walk_list!(visitor, visit_expr, &blk.expr);\n-    }\n-\n-    visitor.cx = prev_cx;\n-}\n-\n-fn resolve_arm<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, arm: &'tcx hir::Arm<'tcx>) {\n-    let prev_cx = visitor.cx;\n-\n-    visitor.enter_scope(Scope { id: arm.hir_id.local_id, data: ScopeData::Node });\n-    visitor.cx.var_parent = visitor.cx.parent;\n-\n-    visitor.terminating_scopes.insert(arm.body.hir_id.local_id);\n-\n-    if let Some(hir::Guard::If(ref expr)) = arm.guard {\n-        visitor.terminating_scopes.insert(expr.hir_id.local_id);\n-    }\n-\n-    intravisit::walk_arm(visitor, arm);\n-\n-    visitor.cx = prev_cx;\n-}\n-\n-fn resolve_pat<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, pat: &'tcx hir::Pat<'tcx>) {\n-    visitor.record_child_scope(Scope { id: pat.hir_id.local_id, data: ScopeData::Node });\n-\n-    // If this is a binding then record the lifetime of that binding.\n-    if let PatKind::Binding(..) = pat.kind {\n-        record_var_lifetime(visitor, pat.hir_id.local_id, pat.span);\n-    }\n-\n-    debug!(\"resolve_pat - pre-increment {} pat = {:?}\", visitor.expr_and_pat_count, pat);\n-\n-    intravisit::walk_pat(visitor, pat);\n-\n-    visitor.expr_and_pat_count += 1;\n-\n-    debug!(\"resolve_pat - post-increment {} pat = {:?}\", visitor.expr_and_pat_count, pat);\n-}\n-\n-fn resolve_stmt<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, stmt: &'tcx hir::Stmt<'tcx>) {\n-    let stmt_id = stmt.hir_id.local_id;\n-    debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n-\n-    // Every statement will clean up the temporaries created during\n-    // execution of that statement. Therefore each statement has an\n-    // associated destruction scope that represents the scope of the\n-    // statement plus its destructors, and thus the scope for which\n-    // regions referenced by the destructors need to survive.\n-    visitor.terminating_scopes.insert(stmt_id);\n-\n-    let prev_parent = visitor.cx.parent;\n-    visitor.enter_node_scope_with_dtor(stmt_id);\n-\n-    intravisit::walk_stmt(visitor, stmt);\n-\n-    visitor.cx.parent = prev_parent;\n-}\n-\n-fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx hir::Expr<'tcx>) {\n-    debug!(\"resolve_expr - pre-increment {} expr = {:?}\", visitor.expr_and_pat_count, expr);\n-\n-    let prev_cx = visitor.cx;\n-    visitor.enter_node_scope_with_dtor(expr.hir_id.local_id);\n-\n-    {\n-        let terminating_scopes = &mut visitor.terminating_scopes;\n-        let mut terminating = |id: hir::ItemLocalId| {\n-            terminating_scopes.insert(id);\n-        };\n-        match expr.kind {\n-            // Conditional or repeating scopes are always terminating\n-            // scopes, meaning that temporaries cannot outlive them.\n-            // This ensures fixed size stacks.\n-            hir::ExprKind::Binary(\n-                source_map::Spanned { node: hir::BinOpKind::And, .. },\n-                _,\n-                ref r,\n-            )\n-            | hir::ExprKind::Binary(\n-                source_map::Spanned { node: hir::BinOpKind::Or, .. },\n-                _,\n-                ref r,\n-            ) => {\n-                // For shortcircuiting operators, mark the RHS as a terminating\n-                // scope since it only executes conditionally.\n-                terminating(r.hir_id.local_id);\n-            }\n-\n-            hir::ExprKind::Loop(ref body, _, _) => {\n-                terminating(body.hir_id.local_id);\n-            }\n-\n-            hir::ExprKind::DropTemps(ref expr) => {\n-                // `DropTemps(expr)` does not denote a conditional scope.\n-                // Rather, we want to achieve the same behavior as `{ let _t = expr; _t }`.\n-                terminating(expr.hir_id.local_id);\n-            }\n-\n-            hir::ExprKind::AssignOp(..)\n-            | hir::ExprKind::Index(..)\n-            | hir::ExprKind::Unary(..)\n-            | hir::ExprKind::Call(..)\n-            | hir::ExprKind::MethodCall(..) => {\n-                // FIXME(https://github.com/rust-lang/rfcs/issues/811) Nested method calls\n-                //\n-                // The lifetimes for a call or method call look as follows:\n-                //\n-                // call.id\n-                // - arg0.id\n-                // - ...\n-                // - argN.id\n-                // - call.callee_id\n-                //\n-                // The idea is that call.callee_id represents *the time when\n-                // the invoked function is actually running* and call.id\n-                // represents *the time to prepare the arguments and make the\n-                // call*.  See the section \"Borrows in Calls\" borrowck/README.md\n-                // for an extended explanation of why this distinction is\n-                // important.\n-                //\n-                // record_superlifetime(new_cx, expr.callee_id);\n-            }\n-\n-            _ => {}\n-        }\n-    }\n-\n-    let prev_pessimistic = visitor.pessimistic_yield;\n-\n-    // Ordinarily, we can rely on the visit order of HIR intravisit\n-    // to correspond to the actual execution order of statements.\n-    // However, there's a weird corner case with compund assignment\n-    // operators (e.g. `a += b`). The evaluation order depends on whether\n-    // or not the operator is overloaded (e.g. whether or not a trait\n-    // like AddAssign is implemented).\n-\n-    // For primitive types (which, despite having a trait impl, don't actually\n-    // end up calling it), the evluation order is right-to-left. For example,\n-    // the following code snippet:\n-    //\n-    //    let y = &mut 0;\n-    //    *{println!(\"LHS!\"); y} += {println!(\"RHS!\"); 1};\n-    //\n-    // will print:\n-    //\n-    // RHS!\n-    // LHS!\n-    //\n-    // However, if the operator is used on a non-primitive type,\n-    // the evaluation order will be left-to-right, since the operator\n-    // actually get desugared to a method call. For example, this\n-    // nearly identical code snippet:\n-    //\n-    //     let y = &mut String::new();\n-    //    *{println!(\"LHS String\"); y} += {println!(\"RHS String\"); \"hi\"};\n-    //\n-    // will print:\n-    // LHS String\n-    // RHS String\n-    //\n-    // To determine the actual execution order, we need to perform\n-    // trait resolution. Unfortunately, we need to be able to compute\n-    // yield_in_scope before type checking is even done, as it gets\n-    // used by AST borrowcheck.\n-    //\n-    // Fortunately, we don't need to know the actual execution order.\n-    // It suffices to know the 'worst case' order with respect to yields.\n-    // Specifically, we need to know the highest 'expr_and_pat_count'\n-    // that we could assign to the yield expression. To do this,\n-    // we pick the greater of the two values from the left-hand\n-    // and right-hand expressions. This makes us overly conservative\n-    // about what types could possibly live across yield points,\n-    // but we will never fail to detect that a type does actually\n-    // live across a yield point. The latter part is critical -\n-    // we're already overly conservative about what types will live\n-    // across yield points, as the generated MIR will determine\n-    // when things are actually live. However, for typecheck to work\n-    // properly, we can't miss any types.\n-\n-    match expr.kind {\n-        // Manually recurse over closures, because they are the only\n-        // case of nested bodies that share the parent environment.\n-        hir::ExprKind::Closure(.., body, _, _) => {\n-            let body = visitor.tcx.hir().body(body);\n-            visitor.visit_body(body);\n-        }\n-        hir::ExprKind::AssignOp(_, ref left_expr, ref right_expr) => {\n-            debug!(\n-                \"resolve_expr - enabling pessimistic_yield, was previously {}\",\n-                prev_pessimistic\n-            );\n-\n-            let start_point = visitor.fixup_scopes.len();\n-            visitor.pessimistic_yield = true;\n-\n-            // If the actual execution order turns out to be right-to-left,\n-            // then we're fine. However, if the actual execution order is left-to-right,\n-            // then we'll assign too low a count to any `yield` expressions\n-            // we encounter in 'right_expression' - they should really occur after all of the\n-            // expressions in 'left_expression'.\n-            visitor.visit_expr(&right_expr);\n-            visitor.pessimistic_yield = prev_pessimistic;\n-\n-            debug!(\"resolve_expr - restoring pessimistic_yield to {}\", prev_pessimistic);\n-            visitor.visit_expr(&left_expr);\n-            debug!(\"resolve_expr - fixing up counts to {}\", visitor.expr_and_pat_count);\n-\n-            // Remove and process any scopes pushed by the visitor\n-            let target_scopes = visitor.fixup_scopes.drain(start_point..);\n-\n-            for scope in target_scopes {\n-                let mut yield_data = visitor.scope_tree.yield_in_scope.get_mut(&scope).unwrap();\n-                let count = yield_data.expr_and_pat_count;\n-                let span = yield_data.span;\n-\n-                // expr_and_pat_count never decreases. Since we recorded counts in yield_in_scope\n-                // before walking the left-hand side, it should be impossible for the recorded\n-                // count to be greater than the left-hand side count.\n-                if count > visitor.expr_and_pat_count {\n-                    bug!(\n-                        \"Encountered greater count {} at span {:?} - expected no greater than {}\",\n-                        count,\n-                        span,\n-                        visitor.expr_and_pat_count\n-                    );\n-                }\n-                let new_count = visitor.expr_and_pat_count;\n-                debug!(\n-                    \"resolve_expr - increasing count for scope {:?} from {} to {} at span {:?}\",\n-                    scope, count, new_count, span\n-                );\n-\n-                yield_data.expr_and_pat_count = new_count;\n-            }\n-        }\n-\n-        _ => intravisit::walk_expr(visitor, expr),\n-    }\n-\n-    visitor.expr_and_pat_count += 1;\n-\n-    debug!(\"resolve_expr post-increment {}, expr = {:?}\", visitor.expr_and_pat_count, expr);\n-\n-    if let hir::ExprKind::Yield(_, source) = &expr.kind {\n-        // Mark this expr's scope and all parent scopes as containing `yield`.\n-        let mut scope = Scope { id: expr.hir_id.local_id, data: ScopeData::Node };\n-        loop {\n-            let data = YieldData {\n-                span: expr.span,\n-                expr_and_pat_count: visitor.expr_and_pat_count,\n-                source: *source,\n-            };\n-            visitor.scope_tree.yield_in_scope.insert(scope, data);\n-            if visitor.pessimistic_yield {\n-                debug!(\"resolve_expr in pessimistic_yield - marking scope {:?} for fixup\", scope);\n-                visitor.fixup_scopes.push(scope);\n-            }\n-\n-            // Keep traversing up while we can.\n-            match visitor.scope_tree.parent_map.get(&scope) {\n-                // Don't cross from closure bodies to their parent.\n-                Some(&(superscope, _)) => match superscope.data {\n-                    ScopeData::CallSite => break,\n-                    _ => scope = superscope,\n-                },\n-                None => break,\n-            }\n-        }\n-    }\n-\n-    visitor.cx = prev_cx;\n-}\n-\n-fn resolve_local<'tcx>(\n-    visitor: &mut RegionResolutionVisitor<'tcx>,\n-    pat: Option<&'tcx hir::Pat<'tcx>>,\n-    init: Option<&'tcx hir::Expr<'tcx>>,\n-) {\n-    debug!(\"resolve_local(pat={:?}, init={:?})\", pat, init);\n-\n-    let blk_scope = visitor.cx.var_parent.map(|(p, _)| p);\n-\n-    // As an exception to the normal rules governing temporary\n-    // lifetimes, initializers in a let have a temporary lifetime\n-    // of the enclosing block. This means that e.g., a program\n-    // like the following is legal:\n-    //\n-    //     let ref x = HashMap::new();\n-    //\n-    // Because the hash map will be freed in the enclosing block.\n-    //\n-    // We express the rules more formally based on 3 grammars (defined\n-    // fully in the helpers below that implement them):\n-    //\n-    // 1. `E&`, which matches expressions like `&<rvalue>` that\n-    //    own a pointer into the stack.\n-    //\n-    // 2. `P&`, which matches patterns like `ref x` or `(ref x, ref\n-    //    y)` that produce ref bindings into the value they are\n-    //    matched against or something (at least partially) owned by\n-    //    the value they are matched against. (By partially owned,\n-    //    I mean that creating a binding into a ref-counted or managed value\n-    //    would still count.)\n-    //\n-    // 3. `ET`, which matches both rvalues like `foo()` as well as places\n-    //    based on rvalues like `foo().x[2].y`.\n-    //\n-    // A subexpression `<rvalue>` that appears in a let initializer\n-    // `let pat [: ty] = expr` has an extended temporary lifetime if\n-    // any of the following conditions are met:\n-    //\n-    // A. `pat` matches `P&` and `expr` matches `ET`\n-    //    (covers cases where `pat` creates ref bindings into an rvalue\n-    //     produced by `expr`)\n-    // B. `ty` is a borrowed pointer and `expr` matches `ET`\n-    //    (covers cases where coercion creates a borrow)\n-    // C. `expr` matches `E&`\n-    //    (covers cases `expr` borrows an rvalue that is then assigned\n-    //     to memory (at least partially) owned by the binding)\n-    //\n-    // Here are some examples hopefully giving an intuition where each\n-    // rule comes into play and why:\n-    //\n-    // Rule A. `let (ref x, ref y) = (foo().x, 44)`. The rvalue `(22, 44)`\n-    // would have an extended lifetime, but not `foo()`.\n-    //\n-    // Rule B. `let x = &foo().x`. The rvalue `foo()` would have extended\n-    // lifetime.\n-    //\n-    // In some cases, multiple rules may apply (though not to the same\n-    // rvalue). For example:\n-    //\n-    //     let ref x = [&a(), &b()];\n-    //\n-    // Here, the expression `[...]` has an extended lifetime due to rule\n-    // A, but the inner rvalues `a()` and `b()` have an extended lifetime\n-    // due to rule C.\n-\n-    if let Some(expr) = init {\n-        record_rvalue_scope_if_borrow_expr(visitor, &expr, blk_scope);\n-\n-        if let Some(pat) = pat {\n-            if is_binding_pat(pat) {\n-                record_rvalue_scope(visitor, &expr, blk_scope);\n-            }\n-        }\n-    }\n-\n-    // Make sure we visit the initializer first, so expr_and_pat_count remains correct\n-    if let Some(expr) = init {\n-        visitor.visit_expr(expr);\n-    }\n-    if let Some(pat) = pat {\n-        visitor.visit_pat(pat);\n-    }\n-\n-    /// Returns `true` if `pat` match the `P&` non-terminal.\n-    ///\n-    ///     P& = ref X\n-    ///        | StructName { ..., P&, ... }\n-    ///        | VariantName(..., P&, ...)\n-    ///        | [ ..., P&, ... ]\n-    ///        | ( ..., P&, ... )\n-    ///        | ... \"|\" P& \"|\" ...\n-    ///        | box P&\n-    fn is_binding_pat(pat: &hir::Pat<'_>) -> bool {\n-        // Note that the code below looks for *explicit* refs only, that is, it won't\n-        // know about *implicit* refs as introduced in #42640.\n-        //\n-        // This is not a problem. For example, consider\n-        //\n-        //      let (ref x, ref y) = (Foo { .. }, Bar { .. });\n-        //\n-        // Due to the explicit refs on the left hand side, the below code would signal\n-        // that the temporary value on the right hand side should live until the end of\n-        // the enclosing block (as opposed to being dropped after the let is complete).\n-        //\n-        // To create an implicit ref, however, you must have a borrowed value on the RHS\n-        // already, as in this example (which won't compile before #42640):\n-        //\n-        //      let Foo { x, .. } = &Foo { x: ..., ... };\n-        //\n-        // in place of\n-        //\n-        //      let Foo { ref x, .. } = Foo { ... };\n-        //\n-        // In the former case (the implicit ref version), the temporary is created by the\n-        // & expression, and its lifetime would be extended to the end of the block (due\n-        // to a different rule, not the below code).\n-        match pat.kind {\n-            PatKind::Binding(hir::BindingAnnotation::Ref, ..)\n-            | PatKind::Binding(hir::BindingAnnotation::RefMut, ..) => true,\n-\n-            PatKind::Struct(_, ref field_pats, _) => {\n-                field_pats.iter().any(|fp| is_binding_pat(&fp.pat))\n-            }\n-\n-            PatKind::Slice(ref pats1, ref pats2, ref pats3) => {\n-                pats1.iter().any(|p| is_binding_pat(&p))\n-                    || pats2.iter().any(|p| is_binding_pat(&p))\n-                    || pats3.iter().any(|p| is_binding_pat(&p))\n-            }\n-\n-            PatKind::Or(ref subpats)\n-            | PatKind::TupleStruct(_, ref subpats, _)\n-            | PatKind::Tuple(ref subpats, _) => subpats.iter().any(|p| is_binding_pat(&p)),\n-\n-            PatKind::Box(ref subpat) => is_binding_pat(&subpat),\n-\n-            PatKind::Ref(_, _)\n-            | PatKind::Binding(hir::BindingAnnotation::Unannotated, ..)\n-            | PatKind::Binding(hir::BindingAnnotation::Mutable, ..)\n-            | PatKind::Wild\n-            | PatKind::Path(_)\n-            | PatKind::Lit(_)\n-            | PatKind::Range(_, _, _) => false,\n-        }\n-    }\n-\n-    /// If `expr` matches the `E&` grammar, then records an extended rvalue scope as appropriate:\n-    ///\n-    ///     E& = & ET\n-    ///        | StructName { ..., f: E&, ... }\n-    ///        | [ ..., E&, ... ]\n-    ///        | ( ..., E&, ... )\n-    ///        | {...; E&}\n-    ///        | box E&\n-    ///        | E& as ...\n-    ///        | ( E& )\n-    fn record_rvalue_scope_if_borrow_expr<'tcx>(\n-        visitor: &mut RegionResolutionVisitor<'tcx>,\n-        expr: &hir::Expr<'_>,\n-        blk_id: Option<Scope>,\n-    ) {\n-        match expr.kind {\n-            hir::ExprKind::AddrOf(_, _, ref subexpr) => {\n-                record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n-                record_rvalue_scope(visitor, &subexpr, blk_id);\n-            }\n-            hir::ExprKind::Struct(_, fields, _) => {\n-                for field in fields {\n-                    record_rvalue_scope_if_borrow_expr(visitor, &field.expr, blk_id);\n-                }\n-            }\n-            hir::ExprKind::Array(subexprs) | hir::ExprKind::Tup(subexprs) => {\n-                for subexpr in subexprs {\n-                    record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n-                }\n-            }\n-            hir::ExprKind::Cast(ref subexpr, _) => {\n-                record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id)\n-            }\n-            hir::ExprKind::Block(ref block, _) => {\n-                if let Some(ref subexpr) = block.expr {\n-                    record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    /// Applied to an expression `expr` if `expr` -- or something owned or partially owned by\n-    /// `expr` -- is going to be indirectly referenced by a variable in a let statement. In that\n-    /// case, the \"temporary lifetime\" or `expr` is extended to be the block enclosing the `let`\n-    /// statement.\n-    ///\n-    /// More formally, if `expr` matches the grammar `ET`, record the rvalue scope of the matching\n-    /// `<rvalue>` as `blk_id`:\n-    ///\n-    ///     ET = *ET\n-    ///        | ET[...]\n-    ///        | ET.f\n-    ///        | (ET)\n-    ///        | <rvalue>\n-    ///\n-    /// Note: ET is intended to match \"rvalues or places based on rvalues\".\n-    fn record_rvalue_scope<'tcx>(\n-        visitor: &mut RegionResolutionVisitor<'tcx>,\n-        expr: &hir::Expr<'_>,\n-        blk_scope: Option<Scope>,\n-    ) {\n-        let mut expr = expr;\n-        loop {\n-            // Note: give all the expressions matching `ET` with the\n-            // extended temporary lifetime, not just the innermost rvalue,\n-            // because in codegen if we must compile e.g., `*rvalue()`\n-            // into a temporary, we request the temporary scope of the\n-            // outer expression.\n-            visitor.scope_tree.record_rvalue_scope(expr.hir_id.local_id, blk_scope);\n-\n-            match expr.kind {\n-                hir::ExprKind::AddrOf(_, _, ref subexpr)\n-                | hir::ExprKind::Unary(hir::UnDeref, ref subexpr)\n-                | hir::ExprKind::Field(ref subexpr, _)\n-                | hir::ExprKind::Index(ref subexpr, _) => {\n-                    expr = &subexpr;\n-                }\n-                _ => {\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> RegionResolutionVisitor<'tcx> {\n-    /// Records the current parent (if any) as the parent of `child_scope`.\n-    /// Returns the depth of `child_scope`.\n-    fn record_child_scope(&mut self, child_scope: Scope) -> ScopeDepth {\n-        let parent = self.cx.parent;\n-        self.scope_tree.record_scope_parent(child_scope, parent);\n-        // If `child_scope` has no parent, it must be the root node, and so has\n-        // a depth of 1. Otherwise, its depth is one more than its parent's.\n-        parent.map_or(1, |(_p, d)| d + 1)\n-    }\n-\n-    /// Records the current parent (if any) as the parent of `child_scope`,\n-    /// and sets `child_scope` as the new current parent.\n-    fn enter_scope(&mut self, child_scope: Scope) {\n-        let child_depth = self.record_child_scope(child_scope);\n-        self.cx.parent = Some((child_scope, child_depth));\n-    }\n-\n-    fn enter_node_scope_with_dtor(&mut self, id: hir::ItemLocalId) {\n-        // If node was previously marked as a terminating scope during the\n-        // recursive visit of its parent node in the AST, then we need to\n-        // account for the destruction scope representing the scope of\n-        // the destructors that run immediately after it completes.\n-        if self.terminating_scopes.contains(&id) {\n-            self.enter_scope(Scope { id, data: ScopeData::Destruction });\n-        }\n-        self.enter_scope(Scope { id, data: ScopeData::Node });\n-    }\n-}\n-\n-impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_block(&mut self, b: &'tcx Block<'tcx>) {\n-        resolve_block(self, b);\n-    }\n-\n-    fn visit_body(&mut self, body: &'tcx hir::Body<'tcx>) {\n-        let body_id = body.id();\n-        let owner_id = self.tcx.hir().body_owner(body_id);\n-\n-        debug!(\n-            \"visit_body(id={:?}, span={:?}, body.id={:?}, cx.parent={:?})\",\n-            owner_id,\n-            self.tcx.sess.source_map().span_to_string(body.value.span),\n-            body_id,\n-            self.cx.parent\n-        );\n-\n-        let outer_ec = mem::replace(&mut self.expr_and_pat_count, 0);\n-        let outer_cx = self.cx;\n-        let outer_ts = mem::take(&mut self.terminating_scopes);\n-        self.terminating_scopes.insert(body.value.hir_id.local_id);\n-\n-        if let Some(root_id) = self.cx.root_id {\n-            self.scope_tree.record_closure_parent(body.value.hir_id.local_id, root_id);\n-        }\n-        self.cx.root_id = Some(body.value.hir_id.local_id);\n-\n-        self.enter_scope(Scope { id: body.value.hir_id.local_id, data: ScopeData::CallSite });\n-        self.enter_scope(Scope { id: body.value.hir_id.local_id, data: ScopeData::Arguments });\n-\n-        // The arguments and `self` are parented to the fn.\n-        self.cx.var_parent = self.cx.parent.take();\n-        for param in body.params {\n-            self.visit_pat(&param.pat);\n-        }\n-\n-        // The body of the every fn is a root scope.\n-        self.cx.parent = self.cx.var_parent;\n-        if self.tcx.hir().body_owner_kind(owner_id).is_fn_or_closure() {\n-            self.visit_expr(&body.value)\n-        } else {\n-            // Only functions have an outer terminating (drop) scope, while\n-            // temporaries in constant initializers may be 'static, but only\n-            // according to rvalue lifetime semantics, using the same\n-            // syntactical rules used for let initializers.\n-            //\n-            // e.g., in `let x = &f();`, the temporary holding the result from\n-            // the `f()` call lives for the entirety of the surrounding block.\n-            //\n-            // Similarly, `const X: ... = &f();` would have the result of `f()`\n-            // live for `'static`, implying (if Drop restrictions on constants\n-            // ever get lifted) that the value *could* have a destructor, but\n-            // it'd get leaked instead of the destructor running during the\n-            // evaluation of `X` (if at all allowed by CTFE).\n-            //\n-            // However, `const Y: ... = g(&f());`, like `let y = g(&f());`,\n-            // would *not* let the `f()` temporary escape into an outer scope\n-            // (i.e., `'static`), which means that after `g` returns, it drops,\n-            // and all the associated destruction scope rules apply.\n-            self.cx.var_parent = None;\n-            resolve_local(self, None, Some(&body.value));\n-        }\n-\n-        if body.generator_kind.is_some() {\n-            self.scope_tree.body_expr_count.insert(body_id, self.expr_and_pat_count);\n-        }\n-\n-        // Restore context we had at the start.\n-        self.expr_and_pat_count = outer_ec;\n-        self.cx = outer_cx;\n-        self.terminating_scopes = outer_ts;\n-    }\n-\n-    fn visit_arm(&mut self, a: &'tcx Arm<'tcx>) {\n-        resolve_arm(self, a);\n-    }\n-    fn visit_pat(&mut self, p: &'tcx Pat<'tcx>) {\n-        resolve_pat(self, p);\n-    }\n-    fn visit_stmt(&mut self, s: &'tcx Stmt<'tcx>) {\n-        resolve_stmt(self, s);\n-    }\n-    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n-        resolve_expr(self, ex);\n-    }\n-    fn visit_local(&mut self, l: &'tcx Local<'tcx>) {\n-        resolve_local(self, Some(&l.pat), l.init.as_ref().map(|e| &**e));\n-    }\n-}\n-\n-fn region_scope_tree(tcx: TyCtxt<'_>, def_id: DefId) -> &ScopeTree {\n-    let closure_base_def_id = tcx.closure_base_def_id(def_id);\n-    if closure_base_def_id != def_id {\n-        return tcx.region_scope_tree(closure_base_def_id);\n-    }\n-\n-    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let scope_tree = if let Some(body_id) = tcx.hir().maybe_body_owned_by(id) {\n-        let mut visitor = RegionResolutionVisitor {\n-            tcx,\n-            scope_tree: ScopeTree::default(),\n-            expr_and_pat_count: 0,\n-            cx: Context { root_id: None, parent: None, var_parent: None },\n-            terminating_scopes: Default::default(),\n-            pessimistic_yield: false,\n-            fixup_scopes: vec![],\n-        };\n-\n-        let body = tcx.hir().body(body_id);\n-        visitor.scope_tree.root_body = Some(body.value.hir_id);\n-\n-        // If the item is an associated const or a method,\n-        // record its impl/trait parent, as it can also have\n-        // lifetime parameters free in this body.\n-        match tcx.hir().get(id) {\n-            Node::ImplItem(_) | Node::TraitItem(_) => {\n-                visitor.scope_tree.root_parent = Some(tcx.hir().get_parent_item(id));\n-            }\n-            _ => {}\n-        }\n-\n-        visitor.visit_body(body);\n-\n-        visitor.scope_tree\n-    } else {\n-        ScopeTree::default()\n-    };\n-\n-    tcx.arena.alloc(scope_tree)\n-}\n-\n-pub fn provide(providers: &mut Providers<'_>) {\n-    *providers = Providers { region_scope_tree, ..*providers };\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for ScopeTree {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let ScopeTree {"}, {"sha": "c30f3e68110e8317a651470bc486319feb25513e", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83f5cf8c4de38f15eafa9e7da44c35a101b74b5e/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83f5cf8c4de38f15eafa9e7da44c35a101b74b5e/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=83f5cf8c4de38f15eafa9e7da44c35a101b74b5e", "patch": "@@ -686,7 +686,6 @@ pub fn default_provide(providers: &mut ty::query::Providers<'_>) {\n     stability::provide(providers);\n     rustc_passes::provide(providers);\n     rustc_traits::provide(providers);\n-    middle::region::provide(providers);\n     rustc_metadata::provide(providers);\n     lint::provide(providers);\n     rustc_lint::provide(providers);"}, {"sha": "8a10c8fe89d6278c26d708fd73f762bb9a7686dc", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83f5cf8c4de38f15eafa9e7da44c35a101b74b5e/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83f5cf8c4de38f15eafa9e7da44c35a101b74b5e/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=83f5cf8c4de38f15eafa9e7da44c35a101b74b5e", "patch": "@@ -31,6 +31,7 @@ mod lib_features;\n mod liveness;\n pub mod loops;\n mod reachable;\n+mod region;\n \n pub fn provide(providers: &mut Providers<'_>) {\n     check_const::provide(providers);\n@@ -41,4 +42,5 @@ pub fn provide(providers: &mut Providers<'_>) {\n     liveness::provide(providers);\n     intrinsicck::provide(providers);\n     reachable::provide(providers);\n+    region::provide(providers);\n }"}, {"sha": "7630e3e8950c17268d2e0db178f9c3a2755f0a6f", "filename": "src/librustc_passes/region.rs", "status": "added", "additions": 835, "deletions": 0, "changes": 835, "blob_url": "https://github.com/rust-lang/rust/blob/83f5cf8c4de38f15eafa9e7da44c35a101b74b5e/src%2Flibrustc_passes%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83f5cf8c4de38f15eafa9e7da44c35a101b74b5e/src%2Flibrustc_passes%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fregion.rs?ref=83f5cf8c4de38f15eafa9e7da44c35a101b74b5e", "patch": "@@ -0,0 +1,835 @@\n+//! This file builds up the `ScopeTree`, which describes\n+//! the parent links in the region hierarchy.\n+//!\n+//! For more information about how MIR-based region-checking works,\n+//! see the [rustc guide].\n+//!\n+//! [rustc guide]: https://rust-lang.github.io/rustc-guide/mir/borrowck.html\n+\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc::hir::Node;\n+use rustc::hir::{Arm, Block, Expr, Local, Pat, PatKind, Stmt};\n+use rustc::middle::region::*;\n+use rustc::ty::query::Providers;\n+use rustc::ty::TyCtxt;\n+use rustc::util::nodemap::FxHashSet;\n+\n+use rustc_index::vec::Idx;\n+use syntax::source_map;\n+use syntax_pos::Span;\n+\n+use std::mem;\n+\n+#[derive(Debug, Copy, Clone)]\n+pub struct Context {\n+    /// The root of the current region tree. This is typically the id\n+    /// of the innermost fn body. Each fn forms its own disjoint tree\n+    /// in the region hierarchy. These fn bodies are themselves\n+    /// arranged into a tree. See the \"Modeling closures\" section of\n+    /// the README in `infer::region_constraints` for more\n+    /// details.\n+    root_id: Option<hir::ItemLocalId>,\n+\n+    /// The scope that contains any new variables declared, plus its depth in\n+    /// the scope tree.\n+    var_parent: Option<(Scope, ScopeDepth)>,\n+\n+    /// Region parent of expressions, etc., plus its depth in the scope tree.\n+    parent: Option<(Scope, ScopeDepth)>,\n+}\n+\n+struct RegionResolutionVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+\n+    // The number of expressions and patterns visited in the current body.\n+    expr_and_pat_count: usize,\n+    // When this is `true`, we record the `Scopes` we encounter\n+    // when processing a Yield expression. This allows us to fix\n+    // up their indices.\n+    pessimistic_yield: bool,\n+    // Stores scopes when `pessimistic_yield` is `true`.\n+    fixup_scopes: Vec<Scope>,\n+    // The generated scope tree.\n+    scope_tree: ScopeTree,\n+\n+    cx: Context,\n+\n+    /// `terminating_scopes` is a set containing the ids of each\n+    /// statement, or conditional/repeating expression. These scopes\n+    /// are calling \"terminating scopes\" because, when attempting to\n+    /// find the scope of a temporary, by default we search up the\n+    /// enclosing scopes until we encounter the terminating scope. A\n+    /// conditional/repeating expression is one which is not\n+    /// guaranteed to execute exactly once upon entering the parent\n+    /// scope. This could be because the expression only executes\n+    /// conditionally, such as the expression `b` in `a && b`, or\n+    /// because the expression may execute many times, such as a loop\n+    /// body. The reason that we distinguish such expressions is that,\n+    /// upon exiting the parent scope, we cannot statically know how\n+    /// many times the expression executed, and thus if the expression\n+    /// creates temporaries we cannot know statically how many such\n+    /// temporaries we would have to cleanup. Therefore, we ensure that\n+    /// the temporaries never outlast the conditional/repeating\n+    /// expression, preventing the need for dynamic checks and/or\n+    /// arbitrary amounts of stack space. Terminating scopes end\n+    /// up being contained in a DestructionScope that contains the\n+    /// destructor's execution.\n+    terminating_scopes: FxHashSet<hir::ItemLocalId>,\n+}\n+\n+/// Records the lifetime of a local variable as `cx.var_parent`\n+fn record_var_lifetime(\n+    visitor: &mut RegionResolutionVisitor<'_>,\n+    var_id: hir::ItemLocalId,\n+    _sp: Span,\n+) {\n+    match visitor.cx.var_parent {\n+        None => {\n+            // this can happen in extern fn declarations like\n+            //\n+            // extern fn isalnum(c: c_int) -> c_int\n+        }\n+        Some((parent_scope, _)) => visitor.scope_tree.record_var_scope(var_id, parent_scope),\n+    }\n+}\n+\n+fn resolve_block<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, blk: &'tcx hir::Block<'tcx>) {\n+    debug!(\"resolve_block(blk.hir_id={:?})\", blk.hir_id);\n+\n+    let prev_cx = visitor.cx;\n+\n+    // We treat the tail expression in the block (if any) somewhat\n+    // differently from the statements. The issue has to do with\n+    // temporary lifetimes. Consider the following:\n+    //\n+    //    quux({\n+    //        let inner = ... (&bar()) ...;\n+    //\n+    //        (... (&foo()) ...) // (the tail expression)\n+    //    }, other_argument());\n+    //\n+    // Each of the statements within the block is a terminating\n+    // scope, and thus a temporary (e.g., the result of calling\n+    // `bar()` in the initializer expression for `let inner = ...;`)\n+    // will be cleaned up immediately after its corresponding\n+    // statement (i.e., `let inner = ...;`) executes.\n+    //\n+    // On the other hand, temporaries associated with evaluating the\n+    // tail expression for the block are assigned lifetimes so that\n+    // they will be cleaned up as part of the terminating scope\n+    // *surrounding* the block expression. Here, the terminating\n+    // scope for the block expression is the `quux(..)` call; so\n+    // those temporaries will only be cleaned up *after* both\n+    // `other_argument()` has run and also the call to `quux(..)`\n+    // itself has returned.\n+\n+    visitor.enter_node_scope_with_dtor(blk.hir_id.local_id);\n+    visitor.cx.var_parent = visitor.cx.parent;\n+\n+    {\n+        // This block should be kept approximately in sync with\n+        // `intravisit::walk_block`. (We manually walk the block, rather\n+        // than call `walk_block`, in order to maintain precise\n+        // index information.)\n+\n+        for (i, statement) in blk.stmts.iter().enumerate() {\n+            match statement.kind {\n+                hir::StmtKind::Local(..) | hir::StmtKind::Item(..) => {\n+                    // Each declaration introduces a subscope for bindings\n+                    // introduced by the declaration; this subscope covers a\n+                    // suffix of the block. Each subscope in a block has the\n+                    // previous subscope in the block as a parent, except for\n+                    // the first such subscope, which has the block itself as a\n+                    // parent.\n+                    visitor.enter_scope(Scope {\n+                        id: blk.hir_id.local_id,\n+                        data: ScopeData::Remainder(FirstStatementIndex::new(i)),\n+                    });\n+                    visitor.cx.var_parent = visitor.cx.parent;\n+                }\n+                hir::StmtKind::Expr(..) | hir::StmtKind::Semi(..) => {}\n+            }\n+            visitor.visit_stmt(statement)\n+        }\n+        walk_list!(visitor, visit_expr, &blk.expr);\n+    }\n+\n+    visitor.cx = prev_cx;\n+}\n+\n+fn resolve_arm<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, arm: &'tcx hir::Arm<'tcx>) {\n+    let prev_cx = visitor.cx;\n+\n+    visitor.enter_scope(Scope { id: arm.hir_id.local_id, data: ScopeData::Node });\n+    visitor.cx.var_parent = visitor.cx.parent;\n+\n+    visitor.terminating_scopes.insert(arm.body.hir_id.local_id);\n+\n+    if let Some(hir::Guard::If(ref expr)) = arm.guard {\n+        visitor.terminating_scopes.insert(expr.hir_id.local_id);\n+    }\n+\n+    intravisit::walk_arm(visitor, arm);\n+\n+    visitor.cx = prev_cx;\n+}\n+\n+fn resolve_pat<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, pat: &'tcx hir::Pat<'tcx>) {\n+    visitor.record_child_scope(Scope { id: pat.hir_id.local_id, data: ScopeData::Node });\n+\n+    // If this is a binding then record the lifetime of that binding.\n+    if let PatKind::Binding(..) = pat.kind {\n+        record_var_lifetime(visitor, pat.hir_id.local_id, pat.span);\n+    }\n+\n+    debug!(\"resolve_pat - pre-increment {} pat = {:?}\", visitor.expr_and_pat_count, pat);\n+\n+    intravisit::walk_pat(visitor, pat);\n+\n+    visitor.expr_and_pat_count += 1;\n+\n+    debug!(\"resolve_pat - post-increment {} pat = {:?}\", visitor.expr_and_pat_count, pat);\n+}\n+\n+fn resolve_stmt<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, stmt: &'tcx hir::Stmt<'tcx>) {\n+    let stmt_id = stmt.hir_id.local_id;\n+    debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n+\n+    // Every statement will clean up the temporaries created during\n+    // execution of that statement. Therefore each statement has an\n+    // associated destruction scope that represents the scope of the\n+    // statement plus its destructors, and thus the scope for which\n+    // regions referenced by the destructors need to survive.\n+    visitor.terminating_scopes.insert(stmt_id);\n+\n+    let prev_parent = visitor.cx.parent;\n+    visitor.enter_node_scope_with_dtor(stmt_id);\n+\n+    intravisit::walk_stmt(visitor, stmt);\n+\n+    visitor.cx.parent = prev_parent;\n+}\n+\n+fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx hir::Expr<'tcx>) {\n+    debug!(\"resolve_expr - pre-increment {} expr = {:?}\", visitor.expr_and_pat_count, expr);\n+\n+    let prev_cx = visitor.cx;\n+    visitor.enter_node_scope_with_dtor(expr.hir_id.local_id);\n+\n+    {\n+        let terminating_scopes = &mut visitor.terminating_scopes;\n+        let mut terminating = |id: hir::ItemLocalId| {\n+            terminating_scopes.insert(id);\n+        };\n+        match expr.kind {\n+            // Conditional or repeating scopes are always terminating\n+            // scopes, meaning that temporaries cannot outlive them.\n+            // This ensures fixed size stacks.\n+            hir::ExprKind::Binary(\n+                source_map::Spanned { node: hir::BinOpKind::And, .. },\n+                _,\n+                ref r,\n+            )\n+            | hir::ExprKind::Binary(\n+                source_map::Spanned { node: hir::BinOpKind::Or, .. },\n+                _,\n+                ref r,\n+            ) => {\n+                // For shortcircuiting operators, mark the RHS as a terminating\n+                // scope since it only executes conditionally.\n+                terminating(r.hir_id.local_id);\n+            }\n+\n+            hir::ExprKind::Loop(ref body, _, _) => {\n+                terminating(body.hir_id.local_id);\n+            }\n+\n+            hir::ExprKind::DropTemps(ref expr) => {\n+                // `DropTemps(expr)` does not denote a conditional scope.\n+                // Rather, we want to achieve the same behavior as `{ let _t = expr; _t }`.\n+                terminating(expr.hir_id.local_id);\n+            }\n+\n+            hir::ExprKind::AssignOp(..)\n+            | hir::ExprKind::Index(..)\n+            | hir::ExprKind::Unary(..)\n+            | hir::ExprKind::Call(..)\n+            | hir::ExprKind::MethodCall(..) => {\n+                // FIXME(https://github.com/rust-lang/rfcs/issues/811) Nested method calls\n+                //\n+                // The lifetimes for a call or method call look as follows:\n+                //\n+                // call.id\n+                // - arg0.id\n+                // - ...\n+                // - argN.id\n+                // - call.callee_id\n+                //\n+                // The idea is that call.callee_id represents *the time when\n+                // the invoked function is actually running* and call.id\n+                // represents *the time to prepare the arguments and make the\n+                // call*.  See the section \"Borrows in Calls\" borrowck/README.md\n+                // for an extended explanation of why this distinction is\n+                // important.\n+                //\n+                // record_superlifetime(new_cx, expr.callee_id);\n+            }\n+\n+            _ => {}\n+        }\n+    }\n+\n+    let prev_pessimistic = visitor.pessimistic_yield;\n+\n+    // Ordinarily, we can rely on the visit order of HIR intravisit\n+    // to correspond to the actual execution order of statements.\n+    // However, there's a weird corner case with compund assignment\n+    // operators (e.g. `a += b`). The evaluation order depends on whether\n+    // or not the operator is overloaded (e.g. whether or not a trait\n+    // like AddAssign is implemented).\n+\n+    // For primitive types (which, despite having a trait impl, don't actually\n+    // end up calling it), the evluation order is right-to-left. For example,\n+    // the following code snippet:\n+    //\n+    //    let y = &mut 0;\n+    //    *{println!(\"LHS!\"); y} += {println!(\"RHS!\"); 1};\n+    //\n+    // will print:\n+    //\n+    // RHS!\n+    // LHS!\n+    //\n+    // However, if the operator is used on a non-primitive type,\n+    // the evaluation order will be left-to-right, since the operator\n+    // actually get desugared to a method call. For example, this\n+    // nearly identical code snippet:\n+    //\n+    //     let y = &mut String::new();\n+    //    *{println!(\"LHS String\"); y} += {println!(\"RHS String\"); \"hi\"};\n+    //\n+    // will print:\n+    // LHS String\n+    // RHS String\n+    //\n+    // To determine the actual execution order, we need to perform\n+    // trait resolution. Unfortunately, we need to be able to compute\n+    // yield_in_scope before type checking is even done, as it gets\n+    // used by AST borrowcheck.\n+    //\n+    // Fortunately, we don't need to know the actual execution order.\n+    // It suffices to know the 'worst case' order with respect to yields.\n+    // Specifically, we need to know the highest 'expr_and_pat_count'\n+    // that we could assign to the yield expression. To do this,\n+    // we pick the greater of the two values from the left-hand\n+    // and right-hand expressions. This makes us overly conservative\n+    // about what types could possibly live across yield points,\n+    // but we will never fail to detect that a type does actually\n+    // live across a yield point. The latter part is critical -\n+    // we're already overly conservative about what types will live\n+    // across yield points, as the generated MIR will determine\n+    // when things are actually live. However, for typecheck to work\n+    // properly, we can't miss any types.\n+\n+    match expr.kind {\n+        // Manually recurse over closures, because they are the only\n+        // case of nested bodies that share the parent environment.\n+        hir::ExprKind::Closure(.., body, _, _) => {\n+            let body = visitor.tcx.hir().body(body);\n+            visitor.visit_body(body);\n+        }\n+        hir::ExprKind::AssignOp(_, ref left_expr, ref right_expr) => {\n+            debug!(\n+                \"resolve_expr - enabling pessimistic_yield, was previously {}\",\n+                prev_pessimistic\n+            );\n+\n+            let start_point = visitor.fixup_scopes.len();\n+            visitor.pessimistic_yield = true;\n+\n+            // If the actual execution order turns out to be right-to-left,\n+            // then we're fine. However, if the actual execution order is left-to-right,\n+            // then we'll assign too low a count to any `yield` expressions\n+            // we encounter in 'right_expression' - they should really occur after all of the\n+            // expressions in 'left_expression'.\n+            visitor.visit_expr(&right_expr);\n+            visitor.pessimistic_yield = prev_pessimistic;\n+\n+            debug!(\"resolve_expr - restoring pessimistic_yield to {}\", prev_pessimistic);\n+            visitor.visit_expr(&left_expr);\n+            debug!(\"resolve_expr - fixing up counts to {}\", visitor.expr_and_pat_count);\n+\n+            // Remove and process any scopes pushed by the visitor\n+            let target_scopes = visitor.fixup_scopes.drain(start_point..);\n+\n+            for scope in target_scopes {\n+                let mut yield_data = visitor.scope_tree.yield_in_scope.get_mut(&scope).unwrap();\n+                let count = yield_data.expr_and_pat_count;\n+                let span = yield_data.span;\n+\n+                // expr_and_pat_count never decreases. Since we recorded counts in yield_in_scope\n+                // before walking the left-hand side, it should be impossible for the recorded\n+                // count to be greater than the left-hand side count.\n+                if count > visitor.expr_and_pat_count {\n+                    bug!(\n+                        \"Encountered greater count {} at span {:?} - expected no greater than {}\",\n+                        count,\n+                        span,\n+                        visitor.expr_and_pat_count\n+                    );\n+                }\n+                let new_count = visitor.expr_and_pat_count;\n+                debug!(\n+                    \"resolve_expr - increasing count for scope {:?} from {} to {} at span {:?}\",\n+                    scope, count, new_count, span\n+                );\n+\n+                yield_data.expr_and_pat_count = new_count;\n+            }\n+        }\n+\n+        _ => intravisit::walk_expr(visitor, expr),\n+    }\n+\n+    visitor.expr_and_pat_count += 1;\n+\n+    debug!(\"resolve_expr post-increment {}, expr = {:?}\", visitor.expr_and_pat_count, expr);\n+\n+    if let hir::ExprKind::Yield(_, source) = &expr.kind {\n+        // Mark this expr's scope and all parent scopes as containing `yield`.\n+        let mut scope = Scope { id: expr.hir_id.local_id, data: ScopeData::Node };\n+        loop {\n+            let data = YieldData {\n+                span: expr.span,\n+                expr_and_pat_count: visitor.expr_and_pat_count,\n+                source: *source,\n+            };\n+            visitor.scope_tree.yield_in_scope.insert(scope, data);\n+            if visitor.pessimistic_yield {\n+                debug!(\"resolve_expr in pessimistic_yield - marking scope {:?} for fixup\", scope);\n+                visitor.fixup_scopes.push(scope);\n+            }\n+\n+            // Keep traversing up while we can.\n+            match visitor.scope_tree.parent_map.get(&scope) {\n+                // Don't cross from closure bodies to their parent.\n+                Some(&(superscope, _)) => match superscope.data {\n+                    ScopeData::CallSite => break,\n+                    _ => scope = superscope,\n+                },\n+                None => break,\n+            }\n+        }\n+    }\n+\n+    visitor.cx = prev_cx;\n+}\n+\n+fn resolve_local<'tcx>(\n+    visitor: &mut RegionResolutionVisitor<'tcx>,\n+    pat: Option<&'tcx hir::Pat<'tcx>>,\n+    init: Option<&'tcx hir::Expr<'tcx>>,\n+) {\n+    debug!(\"resolve_local(pat={:?}, init={:?})\", pat, init);\n+\n+    let blk_scope = visitor.cx.var_parent.map(|(p, _)| p);\n+\n+    // As an exception to the normal rules governing temporary\n+    // lifetimes, initializers in a let have a temporary lifetime\n+    // of the enclosing block. This means that e.g., a program\n+    // like the following is legal:\n+    //\n+    //     let ref x = HashMap::new();\n+    //\n+    // Because the hash map will be freed in the enclosing block.\n+    //\n+    // We express the rules more formally based on 3 grammars (defined\n+    // fully in the helpers below that implement them):\n+    //\n+    // 1. `E&`, which matches expressions like `&<rvalue>` that\n+    //    own a pointer into the stack.\n+    //\n+    // 2. `P&`, which matches patterns like `ref x` or `(ref x, ref\n+    //    y)` that produce ref bindings into the value they are\n+    //    matched against or something (at least partially) owned by\n+    //    the value they are matched against. (By partially owned,\n+    //    I mean that creating a binding into a ref-counted or managed value\n+    //    would still count.)\n+    //\n+    // 3. `ET`, which matches both rvalues like `foo()` as well as places\n+    //    based on rvalues like `foo().x[2].y`.\n+    //\n+    // A subexpression `<rvalue>` that appears in a let initializer\n+    // `let pat [: ty] = expr` has an extended temporary lifetime if\n+    // any of the following conditions are met:\n+    //\n+    // A. `pat` matches `P&` and `expr` matches `ET`\n+    //    (covers cases where `pat` creates ref bindings into an rvalue\n+    //     produced by `expr`)\n+    // B. `ty` is a borrowed pointer and `expr` matches `ET`\n+    //    (covers cases where coercion creates a borrow)\n+    // C. `expr` matches `E&`\n+    //    (covers cases `expr` borrows an rvalue that is then assigned\n+    //     to memory (at least partially) owned by the binding)\n+    //\n+    // Here are some examples hopefully giving an intuition where each\n+    // rule comes into play and why:\n+    //\n+    // Rule A. `let (ref x, ref y) = (foo().x, 44)`. The rvalue `(22, 44)`\n+    // would have an extended lifetime, but not `foo()`.\n+    //\n+    // Rule B. `let x = &foo().x`. The rvalue `foo()` would have extended\n+    // lifetime.\n+    //\n+    // In some cases, multiple rules may apply (though not to the same\n+    // rvalue). For example:\n+    //\n+    //     let ref x = [&a(), &b()];\n+    //\n+    // Here, the expression `[...]` has an extended lifetime due to rule\n+    // A, but the inner rvalues `a()` and `b()` have an extended lifetime\n+    // due to rule C.\n+\n+    if let Some(expr) = init {\n+        record_rvalue_scope_if_borrow_expr(visitor, &expr, blk_scope);\n+\n+        if let Some(pat) = pat {\n+            if is_binding_pat(pat) {\n+                record_rvalue_scope(visitor, &expr, blk_scope);\n+            }\n+        }\n+    }\n+\n+    // Make sure we visit the initializer first, so expr_and_pat_count remains correct\n+    if let Some(expr) = init {\n+        visitor.visit_expr(expr);\n+    }\n+    if let Some(pat) = pat {\n+        visitor.visit_pat(pat);\n+    }\n+\n+    /// Returns `true` if `pat` match the `P&` non-terminal.\n+    ///\n+    /// ```text\n+    ///     P& = ref X\n+    ///        | StructName { ..., P&, ... }\n+    ///        | VariantName(..., P&, ...)\n+    ///        | [ ..., P&, ... ]\n+    ///        | ( ..., P&, ... )\n+    ///        | ... \"|\" P& \"|\" ...\n+    ///        | box P&\n+    /// ```\n+    fn is_binding_pat(pat: &hir::Pat<'_>) -> bool {\n+        // Note that the code below looks for *explicit* refs only, that is, it won't\n+        // know about *implicit* refs as introduced in #42640.\n+        //\n+        // This is not a problem. For example, consider\n+        //\n+        //      let (ref x, ref y) = (Foo { .. }, Bar { .. });\n+        //\n+        // Due to the explicit refs on the left hand side, the below code would signal\n+        // that the temporary value on the right hand side should live until the end of\n+        // the enclosing block (as opposed to being dropped after the let is complete).\n+        //\n+        // To create an implicit ref, however, you must have a borrowed value on the RHS\n+        // already, as in this example (which won't compile before #42640):\n+        //\n+        //      let Foo { x, .. } = &Foo { x: ..., ... };\n+        //\n+        // in place of\n+        //\n+        //      let Foo { ref x, .. } = Foo { ... };\n+        //\n+        // In the former case (the implicit ref version), the temporary is created by the\n+        // & expression, and its lifetime would be extended to the end of the block (due\n+        // to a different rule, not the below code).\n+        match pat.kind {\n+            PatKind::Binding(hir::BindingAnnotation::Ref, ..)\n+            | PatKind::Binding(hir::BindingAnnotation::RefMut, ..) => true,\n+\n+            PatKind::Struct(_, ref field_pats, _) => {\n+                field_pats.iter().any(|fp| is_binding_pat(&fp.pat))\n+            }\n+\n+            PatKind::Slice(ref pats1, ref pats2, ref pats3) => {\n+                pats1.iter().any(|p| is_binding_pat(&p))\n+                    || pats2.iter().any(|p| is_binding_pat(&p))\n+                    || pats3.iter().any(|p| is_binding_pat(&p))\n+            }\n+\n+            PatKind::Or(ref subpats)\n+            | PatKind::TupleStruct(_, ref subpats, _)\n+            | PatKind::Tuple(ref subpats, _) => subpats.iter().any(|p| is_binding_pat(&p)),\n+\n+            PatKind::Box(ref subpat) => is_binding_pat(&subpat),\n+\n+            PatKind::Ref(_, _)\n+            | PatKind::Binding(hir::BindingAnnotation::Unannotated, ..)\n+            | PatKind::Binding(hir::BindingAnnotation::Mutable, ..)\n+            | PatKind::Wild\n+            | PatKind::Path(_)\n+            | PatKind::Lit(_)\n+            | PatKind::Range(_, _, _) => false,\n+        }\n+    }\n+\n+    /// If `expr` matches the `E&` grammar, then records an extended rvalue scope as appropriate:\n+    ///\n+    /// ```text\n+    ///     E& = & ET\n+    ///        | StructName { ..., f: E&, ... }\n+    ///        | [ ..., E&, ... ]\n+    ///        | ( ..., E&, ... )\n+    ///        | {...; E&}\n+    ///        | box E&\n+    ///        | E& as ...\n+    ///        | ( E& )\n+    /// ```\n+    fn record_rvalue_scope_if_borrow_expr<'tcx>(\n+        visitor: &mut RegionResolutionVisitor<'tcx>,\n+        expr: &hir::Expr<'_>,\n+        blk_id: Option<Scope>,\n+    ) {\n+        match expr.kind {\n+            hir::ExprKind::AddrOf(_, _, ref subexpr) => {\n+                record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n+                record_rvalue_scope(visitor, &subexpr, blk_id);\n+            }\n+            hir::ExprKind::Struct(_, fields, _) => {\n+                for field in fields {\n+                    record_rvalue_scope_if_borrow_expr(visitor, &field.expr, blk_id);\n+                }\n+            }\n+            hir::ExprKind::Array(subexprs) | hir::ExprKind::Tup(subexprs) => {\n+                for subexpr in subexprs {\n+                    record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n+                }\n+            }\n+            hir::ExprKind::Cast(ref subexpr, _) => {\n+                record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id)\n+            }\n+            hir::ExprKind::Block(ref block, _) => {\n+                if let Some(ref subexpr) = block.expr {\n+                    record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    /// Applied to an expression `expr` if `expr` -- or something owned or partially owned by\n+    /// `expr` -- is going to be indirectly referenced by a variable in a let statement. In that\n+    /// case, the \"temporary lifetime\" or `expr` is extended to be the block enclosing the `let`\n+    /// statement.\n+    ///\n+    /// More formally, if `expr` matches the grammar `ET`, record the rvalue scope of the matching\n+    /// `<rvalue>` as `blk_id`:\n+    ///\n+    /// ```text\n+    ///     ET = *ET\n+    ///        | ET[...]\n+    ///        | ET.f\n+    ///        | (ET)\n+    ///        | <rvalue>\n+    /// ```\n+    ///\n+    /// Note: ET is intended to match \"rvalues or places based on rvalues\".\n+    fn record_rvalue_scope<'tcx>(\n+        visitor: &mut RegionResolutionVisitor<'tcx>,\n+        expr: &hir::Expr<'_>,\n+        blk_scope: Option<Scope>,\n+    ) {\n+        let mut expr = expr;\n+        loop {\n+            // Note: give all the expressions matching `ET` with the\n+            // extended temporary lifetime, not just the innermost rvalue,\n+            // because in codegen if we must compile e.g., `*rvalue()`\n+            // into a temporary, we request the temporary scope of the\n+            // outer expression.\n+            visitor.scope_tree.record_rvalue_scope(expr.hir_id.local_id, blk_scope);\n+\n+            match expr.kind {\n+                hir::ExprKind::AddrOf(_, _, ref subexpr)\n+                | hir::ExprKind::Unary(hir::UnDeref, ref subexpr)\n+                | hir::ExprKind::Field(ref subexpr, _)\n+                | hir::ExprKind::Index(ref subexpr, _) => {\n+                    expr = &subexpr;\n+                }\n+                _ => {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> RegionResolutionVisitor<'tcx> {\n+    /// Records the current parent (if any) as the parent of `child_scope`.\n+    /// Returns the depth of `child_scope`.\n+    fn record_child_scope(&mut self, child_scope: Scope) -> ScopeDepth {\n+        let parent = self.cx.parent;\n+        self.scope_tree.record_scope_parent(child_scope, parent);\n+        // If `child_scope` has no parent, it must be the root node, and so has\n+        // a depth of 1. Otherwise, its depth is one more than its parent's.\n+        parent.map_or(1, |(_p, d)| d + 1)\n+    }\n+\n+    /// Records the current parent (if any) as the parent of `child_scope`,\n+    /// and sets `child_scope` as the new current parent.\n+    fn enter_scope(&mut self, child_scope: Scope) {\n+        let child_depth = self.record_child_scope(child_scope);\n+        self.cx.parent = Some((child_scope, child_depth));\n+    }\n+\n+    fn enter_node_scope_with_dtor(&mut self, id: hir::ItemLocalId) {\n+        // If node was previously marked as a terminating scope during the\n+        // recursive visit of its parent node in the AST, then we need to\n+        // account for the destruction scope representing the scope of\n+        // the destructors that run immediately after it completes.\n+        if self.terminating_scopes.contains(&id) {\n+            self.enter_scope(Scope { id, data: ScopeData::Destruction });\n+        }\n+        self.enter_scope(Scope { id, data: ScopeData::Node });\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_block(&mut self, b: &'tcx Block<'tcx>) {\n+        resolve_block(self, b);\n+    }\n+\n+    fn visit_body(&mut self, body: &'tcx hir::Body<'tcx>) {\n+        let body_id = body.id();\n+        let owner_id = self.tcx.hir().body_owner(body_id);\n+\n+        debug!(\n+            \"visit_body(id={:?}, span={:?}, body.id={:?}, cx.parent={:?})\",\n+            owner_id,\n+            self.tcx.sess.source_map().span_to_string(body.value.span),\n+            body_id,\n+            self.cx.parent\n+        );\n+\n+        let outer_ec = mem::replace(&mut self.expr_and_pat_count, 0);\n+        let outer_cx = self.cx;\n+        let outer_ts = mem::take(&mut self.terminating_scopes);\n+        self.terminating_scopes.insert(body.value.hir_id.local_id);\n+\n+        if let Some(root_id) = self.cx.root_id {\n+            self.scope_tree.record_closure_parent(body.value.hir_id.local_id, root_id);\n+        }\n+        self.cx.root_id = Some(body.value.hir_id.local_id);\n+\n+        self.enter_scope(Scope { id: body.value.hir_id.local_id, data: ScopeData::CallSite });\n+        self.enter_scope(Scope { id: body.value.hir_id.local_id, data: ScopeData::Arguments });\n+\n+        // The arguments and `self` are parented to the fn.\n+        self.cx.var_parent = self.cx.parent.take();\n+        for param in body.params {\n+            self.visit_pat(&param.pat);\n+        }\n+\n+        // The body of the every fn is a root scope.\n+        self.cx.parent = self.cx.var_parent;\n+        if self.tcx.hir().body_owner_kind(owner_id).is_fn_or_closure() {\n+            self.visit_expr(&body.value)\n+        } else {\n+            // Only functions have an outer terminating (drop) scope, while\n+            // temporaries in constant initializers may be 'static, but only\n+            // according to rvalue lifetime semantics, using the same\n+            // syntactical rules used for let initializers.\n+            //\n+            // e.g., in `let x = &f();`, the temporary holding the result from\n+            // the `f()` call lives for the entirety of the surrounding block.\n+            //\n+            // Similarly, `const X: ... = &f();` would have the result of `f()`\n+            // live for `'static`, implying (if Drop restrictions on constants\n+            // ever get lifted) that the value *could* have a destructor, but\n+            // it'd get leaked instead of the destructor running during the\n+            // evaluation of `X` (if at all allowed by CTFE).\n+            //\n+            // However, `const Y: ... = g(&f());`, like `let y = g(&f());`,\n+            // would *not* let the `f()` temporary escape into an outer scope\n+            // (i.e., `'static`), which means that after `g` returns, it drops,\n+            // and all the associated destruction scope rules apply.\n+            self.cx.var_parent = None;\n+            resolve_local(self, None, Some(&body.value));\n+        }\n+\n+        if body.generator_kind.is_some() {\n+            self.scope_tree.body_expr_count.insert(body_id, self.expr_and_pat_count);\n+        }\n+\n+        // Restore context we had at the start.\n+        self.expr_and_pat_count = outer_ec;\n+        self.cx = outer_cx;\n+        self.terminating_scopes = outer_ts;\n+    }\n+\n+    fn visit_arm(&mut self, a: &'tcx Arm<'tcx>) {\n+        resolve_arm(self, a);\n+    }\n+    fn visit_pat(&mut self, p: &'tcx Pat<'tcx>) {\n+        resolve_pat(self, p);\n+    }\n+    fn visit_stmt(&mut self, s: &'tcx Stmt<'tcx>) {\n+        resolve_stmt(self, s);\n+    }\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n+        resolve_expr(self, ex);\n+    }\n+    fn visit_local(&mut self, l: &'tcx Local<'tcx>) {\n+        resolve_local(self, Some(&l.pat), l.init.as_ref().map(|e| &**e));\n+    }\n+}\n+\n+fn region_scope_tree(tcx: TyCtxt<'_>, def_id: DefId) -> &ScopeTree {\n+    let closure_base_def_id = tcx.closure_base_def_id(def_id);\n+    if closure_base_def_id != def_id {\n+        return tcx.region_scope_tree(closure_base_def_id);\n+    }\n+\n+    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let scope_tree = if let Some(body_id) = tcx.hir().maybe_body_owned_by(id) {\n+        let mut visitor = RegionResolutionVisitor {\n+            tcx,\n+            scope_tree: ScopeTree::default(),\n+            expr_and_pat_count: 0,\n+            cx: Context { root_id: None, parent: None, var_parent: None },\n+            terminating_scopes: Default::default(),\n+            pessimistic_yield: false,\n+            fixup_scopes: vec![],\n+        };\n+\n+        let body = tcx.hir().body(body_id);\n+        visitor.scope_tree.root_body = Some(body.value.hir_id);\n+\n+        // If the item is an associated const or a method,\n+        // record its impl/trait parent, as it can also have\n+        // lifetime parameters free in this body.\n+        match tcx.hir().get(id) {\n+            Node::ImplItem(_) | Node::TraitItem(_) => {\n+                visitor.scope_tree.root_parent = Some(tcx.hir().get_parent_item(id));\n+            }\n+            _ => {}\n+        }\n+\n+        visitor.visit_body(body);\n+\n+        visitor.scope_tree\n+    } else {\n+        ScopeTree::default()\n+    };\n+\n+    tcx.arena.alloc(scope_tree)\n+}\n+\n+pub fn provide(providers: &mut Providers<'_>) {\n+    *providers = Providers { region_scope_tree, ..*providers };\n+}"}]}