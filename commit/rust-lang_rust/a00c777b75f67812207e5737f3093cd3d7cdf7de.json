{"sha": "a00c777b75f67812207e5737f3093cd3d7cdf7de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwMGM3NzdiNzVmNjc4MTIyMDdlNTczN2YzMDkzY2QzZDdjZGY3ZGU=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2019-11-08T04:42:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-08T04:42:14Z"}, "message": "Rollup merge of #65580 - SimonSapin:maybeuninit-array, r=Amanieu\n\nAdd `MaybeUninit` methods `uninit_array`, `slice_get_ref`, `slice_get_mut`\n\nEventually these will hopefully become the idiomatic way to work with partially-initialized stack buffers.\n\nAll methods are unstable. Note that `uninit_array` takes a type-level `const usize` parameter, so it is blocked (at least in its current form) on const generics.\n\nExample:\n\n```rust\nuse std::mem::MaybeUninit;\n\nlet input = b\"Foo\";\nlet f = u8::to_ascii_uppercase;\n\nlet mut buffer: [MaybeUninit<u8>; 32] = MaybeUninit::uninit_array();\nlet vec;\nlet output = if let Some(buffer) = buffer.get_mut(..input.len()) {\n    buffer.iter_mut().zip(input).for_each(|(a, b)| { a.write(f(b)); });\n    unsafe { MaybeUninit::slice_get_ref(buffer) }\n} else {\n    vec = input.iter().map(f).collect::<Vec<u8>>();\n    &vec\n};\n\nassert_eq!(output, b\"FOO\");\n```", "tree": {"sha": "160ff19f291c0c04886c585ad2f04f8cccbf4e05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/160ff19f291c0c04886c585ad2f04f8cccbf4e05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a00c777b75f67812207e5737f3093cd3d7cdf7de", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdxPImCRBK7hj4Ov3rIwAAdHIIAJ8RgkiJyu62YwJj/GogmtGx\nplSQP9aGb6w0hry0Up0FDxdOml6lnjGwEEdAQruQW0/e14slIFAgITEVErXTH5yS\nyyTIZQe1MaTgHMkoYtJORVSGbCceY5C7NG/yhePGnc20ujrdNkltsPBh5PUpst47\nWXc7b+nvyaXIczkPmsIH3ZS9osSxsbFwEUux7oK8WYQZJbhR3Um+KocAKXSqVHke\nqis1UgqdIVyDkHH5vkbqryh88e/r7n8oUHAYGrxQd5nKukq8Zpzrmea0OmF5hdtR\n8/ljv3CS+5DrKh1h25isrGXo1iWNWYCXePka7OuRk111VtDEy9Hf6o2n4rJaJAI=\n=5J9/\n-----END PGP SIGNATURE-----\n", "payload": "tree 160ff19f291c0c04886c585ad2f04f8cccbf4e05\nparent 32aa327ba35c4b0f95c7c4cd983f1867fc498897\nparent 639c4f779c60119383dd8a49b44522f6a6958a53\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1573188134 +0900\ncommitter GitHub <noreply@github.com> 1573188134 +0900\n\nRollup merge of #65580 - SimonSapin:maybeuninit-array, r=Amanieu\n\nAdd `MaybeUninit` methods `uninit_array`, `slice_get_ref`, `slice_get_mut`\n\nEventually these will hopefully become the idiomatic way to work with partially-initialized stack buffers.\n\nAll methods are unstable. Note that `uninit_array` takes a type-level `const usize` parameter, so it is blocked (at least in its current form) on const generics.\n\nExample:\n\n```rust\nuse std::mem::MaybeUninit;\n\nlet input = b\"Foo\";\nlet f = u8::to_ascii_uppercase;\n\nlet mut buffer: [MaybeUninit<u8>; 32] = MaybeUninit::uninit_array();\nlet vec;\nlet output = if let Some(buffer) = buffer.get_mut(..input.len()) {\n    buffer.iter_mut().zip(input).for_each(|(a, b)| { a.write(f(b)); });\n    unsafe { MaybeUninit::slice_get_ref(buffer) }\n} else {\n    vec = input.iter().map(f).collect::<Vec<u8>>();\n    &vec\n};\n\nassert_eq!(output, b\"FOO\");\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a00c777b75f67812207e5737f3093cd3d7cdf7de", "html_url": "https://github.com/rust-lang/rust/commit/a00c777b75f67812207e5737f3093cd3d7cdf7de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a00c777b75f67812207e5737f3093cd3d7cdf7de/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32aa327ba35c4b0f95c7c4cd983f1867fc498897", "url": "https://api.github.com/repos/rust-lang/rust/commits/32aa327ba35c4b0f95c7c4cd983f1867fc498897", "html_url": "https://github.com/rust-lang/rust/commit/32aa327ba35c4b0f95c7c4cd983f1867fc498897"}, {"sha": "639c4f779c60119383dd8a49b44522f6a6958a53", "url": "https://api.github.com/repos/rust-lang/rust/commits/639c4f779c60119383dd8a49b44522f6a6958a53", "html_url": "https://github.com/rust-lang/rust/commit/639c4f779c60119383dd8a49b44522f6a6958a53"}], "stats": {"total": 63, "additions": 63, "deletions": 0}, "files": [{"sha": "d35a5ce57fe9f8f7bca5fc63d161c81c4d81e704", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a00c777b75f67812207e5737f3093cd3d7cdf7de/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00c777b75f67812207e5737f3093cd3d7cdf7de/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=a00c777b75f67812207e5737f3093cd3d7cdf7de", "patch": "@@ -260,6 +260,43 @@ impl<T> MaybeUninit<T> {\n         MaybeUninit { uninit: () }\n     }\n \n+    /// Create a new array of `MaybeUninit<T>` items, in an uninitialized state.\n+    ///\n+    /// Note: in a future Rust version this method may become unnecessary\n+    /// when array literal syntax allows\n+    /// [repeating const expressions](https://github.com/rust-lang/rust/issues/49147).\n+    /// The example below could then use `let mut buf = [MaybeUninit::<u8>::uninit(); 32];`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(maybe_uninit_uninit_array, maybe_uninit_extra, maybe_uninit_slice_assume_init)]\n+    ///\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// extern \"C\" {\n+    ///     fn read_into_buffer(ptr: *mut u8, max_len: usize) -> usize;\n+    /// }\n+    ///\n+    /// /// Returns a (possibly smaller) slice of data that was actually read\n+    /// fn read(buf: &mut [MaybeUninit<u8>]) -> &[u8] {\n+    ///     unsafe {\n+    ///         let len = read_into_buffer(buf.as_mut_ptr() as *mut u8, buf.len());\n+    ///         MaybeUninit::slice_get_ref(&buf[..len])\n+    ///     }\n+    /// }\n+    ///\n+    /// let mut buf: [MaybeUninit<u8>; 32] = MaybeUninit::uninit_array();\n+    /// let data = read(&mut buf);\n+    /// ```\n+    #[unstable(feature = \"maybe_uninit_uninit_array\", issue = \"0\")]\n+    #[inline(always)]\n+    pub fn uninit_array<const LEN: usize>() -> [Self; LEN] {\n+        unsafe {\n+            MaybeUninit::<[MaybeUninit<T>; LEN]>::uninit().assume_init()\n+        }\n+    }\n+\n     /// A promotable constant, equivalent to `uninit()`.\n     #[unstable(feature = \"internal_uninit_const\", issue = \"0\",\n         reason = \"hack to work around promotability\")]\n@@ -692,6 +729,32 @@ impl<T> MaybeUninit<T> {\n         &mut *self.value\n     }\n \n+    /// Assuming all the elements are initialized, get a slice to them.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` elements\n+    /// really are in an initialized state.\n+    /// Calling this when the content is not yet fully initialized causes undefined behavior.\n+    #[unstable(feature = \"maybe_uninit_slice_assume_init\", issue = \"0\")]\n+    #[inline(always)]\n+    pub unsafe fn slice_get_ref(slice: &[Self]) -> &[T] {\n+        &*(slice as *const [Self] as *const [T])\n+    }\n+\n+    /// Assuming all the elements are initialized, get a mutable slice to them.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` elements\n+    /// really are in an initialized state.\n+    /// Calling this when the content is not yet fully initialized causes undefined behavior.\n+    #[unstable(feature = \"maybe_uninit_slice_assume_init\", issue = \"0\")]\n+    #[inline(always)]\n+    pub unsafe fn slice_get_mut(slice: &mut [Self]) -> &mut [T] {\n+        &mut *(slice as *mut [Self] as *mut [T])\n+    }\n+\n     /// Gets a pointer to the first element of the array.\n     #[unstable(feature = \"maybe_uninit_slice\", issue = \"63569\")]\n     #[inline(always)]"}]}