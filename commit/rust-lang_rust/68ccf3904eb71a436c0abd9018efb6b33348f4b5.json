{"sha": "68ccf3904eb71a436c0abd9018efb6b33348f4b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4Y2NmMzkwNGViNzFhNDM2YzBhYmQ5MDE4ZWZiNmIzMzM0OGY0YjU=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-27T05:25:35Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-27T05:25:35Z"}, "message": "Add method for checking if a range is defined in an allocation.", "tree": {"sha": "57ac58c4e68ac5cf8b45ab6db4852c4edefc11de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57ac58c4e68ac5cf8b45ab6db4852c4edefc11de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68ccf3904eb71a436c0abd9018efb6b33348f4b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68ccf3904eb71a436c0abd9018efb6b33348f4b5", "html_url": "https://github.com/rust-lang/rust/commit/68ccf3904eb71a436c0abd9018efb6b33348f4b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68ccf3904eb71a436c0abd9018efb6b33348f4b5/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33e924d38347db97f403fc775dfb3a31cd3e0c37", "url": "https://api.github.com/repos/rust-lang/rust/commits/33e924d38347db97f403fc775dfb3a31cd3e0c37", "html_url": "https://github.com/rust-lang/rust/commit/33e924d38347db97f403fc775dfb3a31cd3e0c37"}], "stats": {"total": 48, "additions": 48, "deletions": 0}, "files": [{"sha": "4a3160607b6547e8cc2ae8aa42861df3e5cd8ec3", "filename": "src/memory.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/68ccf3904eb71a436c0abd9018efb6b33348f4b5/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68ccf3904eb71a436c0abd9018efb6b33348f4b5/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=68ccf3904eb71a436c0abd9018efb6b33348f4b5", "patch": "@@ -336,9 +336,38 @@ impl Memory {\n ////////////////////////////////////////////////////////////////////////////////\n \n impl Allocation {\n+    /// Check whether the range `start..end` (end-exclusive) in this allocation is entirely\n+    /// defined.\n+    fn is_range_defined(&self, start: usize, end: usize) -> bool {\n+        debug_assert!(start <= end);\n+        debug_assert!(end <= self.bytes.len());\n+\n+        // An empty range is always fully defined.\n+        if start == end {\n+            return true;\n+        }\n+\n+        match self.undef_mask {\n+            Some(ref undef_mask) => {\n+                // If `start` lands directly on a boundary, it belongs to the range after the\n+                // boundary, hence the increment in the `Ok` arm.\n+                let i = match undef_mask.binary_search(&start) { Ok(j) => j + 1, Err(j) => j };\n+\n+                // The range is fully defined if and only if both:\n+                //   1. The start value falls into a defined range (with even parity).\n+                //   2. The end value is in the same range as the start value.\n+                i % 2 == 0 && undef_mask.get(i).map(|&x| end <= x).unwrap_or(true)\n+            }\n+            None => false,\n+        }\n+    }\n+\n     /// Mark the range `start..end` (end-exclusive) as defined or undefined, depending on\n     /// `new_state`.\n     fn mark_definedness(&mut self, start: usize, end: usize, new_state: bool) {\n+        debug_assert!(start <= end);\n+        debug_assert!(end <= self.bytes.len());\n+\n         // There is no need to track undef masks for zero-sized allocations.\n         let len = self.bytes.len();\n         if len == 0 {\n@@ -439,6 +468,22 @@ mod test {\n     fn large_undef_mask() {\n         let mut alloc = alloc_with_mask(20, Some(vec![4, 8, 12, 16]));\n \n+        assert!(alloc.is_range_defined(0, 0));\n+        assert!(alloc.is_range_defined(0, 3));\n+        assert!(alloc.is_range_defined(0, 4));\n+        assert!(alloc.is_range_defined(1, 3));\n+        assert!(alloc.is_range_defined(1, 4));\n+        assert!(alloc.is_range_defined(4, 4));\n+        assert!(!alloc.is_range_defined(0, 5));\n+        assert!(!alloc.is_range_defined(1, 5));\n+        assert!(!alloc.is_range_defined(4, 5));\n+        assert!(!alloc.is_range_defined(4, 8));\n+        assert!(alloc.is_range_defined(8, 12));\n+        assert!(!alloc.is_range_defined(12, 16));\n+        assert!(alloc.is_range_defined(16, 20));\n+        assert!(!alloc.is_range_defined(15, 20));\n+        assert!(!alloc.is_range_defined(0, 20));\n+\n         alloc.mark_definedness(8, 11, false);\n         assert_eq!(alloc.undef_mask, Some(vec![4, 11, 12, 16]));\n \n@@ -467,12 +512,15 @@ mod test {\n     #[test]\n     fn empty_undef_mask() {\n         let mut alloc = alloc_with_mask(0, None);\n+        assert!(alloc.is_range_defined(0, 0));\n \n         alloc.mark_definedness(0, 0, false);\n         assert_eq!(alloc.undef_mask, None);\n+        assert!(alloc.is_range_defined(0, 0));\n \n         alloc.mark_definedness(0, 0, true);\n         assert_eq!(alloc.undef_mask, None);\n+        assert!(alloc.is_range_defined(0, 0));\n     }\n \n     #[test]"}]}