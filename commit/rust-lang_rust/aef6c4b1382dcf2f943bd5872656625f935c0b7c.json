{"sha": "aef6c4b1382dcf2f943bd5872656625f935c0b7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlZjZjNGIxMzgyZGNmMmY5NDNiZDU4NzI2NTY2MjVmOTM1YzBiN2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-20T03:11:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-20T03:11:12Z"}, "message": "auto merge of #17399 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "95920a7c62cbc07301ec8fe4b189b33e208327cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95920a7c62cbc07301ec8fe4b189b33e208327cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aef6c4b1382dcf2f943bd5872656625f935c0b7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aef6c4b1382dcf2f943bd5872656625f935c0b7c", "html_url": "https://github.com/rust-lang/rust/commit/aef6c4b1382dcf2f943bd5872656625f935c0b7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aef6c4b1382dcf2f943bd5872656625f935c0b7c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b6e880fffb8e09b15bc6fc41d5b23f21bf5056d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b6e880fffb8e09b15bc6fc41d5b23f21bf5056d", "html_url": "https://github.com/rust-lang/rust/commit/3b6e880fffb8e09b15bc6fc41d5b23f21bf5056d"}, {"sha": "f082416bece7cbb16ec46f870fb7f91ca15f2231", "url": "https://api.github.com/repos/rust-lang/rust/commits/f082416bece7cbb16ec46f870fb7f91ca15f2231", "html_url": "https://github.com/rust-lang/rust/commit/f082416bece7cbb16ec46f870fb7f91ca15f2231"}], "stats": {"total": 4456, "additions": 2667, "deletions": 1789}, "files": [{"sha": "03a73db8aa48de541a55dcf4e342a16a69bac6b5", "filename": "src/doc/guide.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -1575,8 +1575,6 @@ we haven't seen before. Here's a simple program that reads some input,\n and then prints it back out:\n \n ```{rust,ignore}\n-use std::io;\n-\n fn main() {\n     println!(\"Type something!\");\n "}, {"sha": "f4e8f6f7873c9baa0bc64f59eb11530dd753e017", "filename": "src/etc/zsh/_rust", "status": "modified", "additions": 131, "deletions": 68, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Fetc%2Fzsh%2F_rust", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Fetc%2Fzsh%2F_rust", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fzsh%2F_rust?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -4,109 +4,166 @@ local -a _rustc_opts_switches _rustc_opts_lint _rustc_opts_debug\n \n typeset -A opt_args\n \n+_rustc_debuginfo_levels=(\n+    \"0[no debug info]\"\n+    \"1[line-tables only (for stacktraces and breakpoints)]\"\n+    \"2[full debug info with variable and type information (same as -g)]\"\n+)\n+\n+_rustc_crate_types=(\n+    'bin'\n+    'lib'\n+    'rlib'\n+    'dylib'\n+    'staticlib'\n+)\n+\n+_rustc_emit_types=(\n+    'asm'\n+    'bc'\n+    'ir'\n+    'obj'\n+    'link'\n+)\n+_rustc_pretty_types=(\n+    'normal[un-annotated source]'\n+    'expanded[crates expanded]'\n+    'typed[crates  expanded,  with  type  annotations]'\n+    'identified[fully parenthesized, AST nodes and blocks with IDs]'\n+    'flowgraph=[graphviz formatted flowgraph for node]:NODEID:'\n+)\n+_rustc_color_types=(\n+    'auto[colorize, if output goes to a tty (default)]'\n+    'always[always colorize output]'\n+    'never[never colorize output]'\n+)\n+\n+_rustc_opts_vals=(\n+    --crate-name='[Specify the name of the crate being built]'\n+    --crate-type='[Comma separated list of types of crates for the compiler to emit]:TYPES:_values -s \",\" \"Crate types\"  \"$_rustc_crate_types[@]\"'\n+    --emit='[Comma separated list of types of output for the compiler to emit]:TYPES:_values -s \",\" \"Emit Targets\" \"$_rustc_emit_types[@]\"'\n+    --debuginfo='[Emit DWARF debug info to the objects created]:LEVEL:_values \"Debug Levels\" \"$_rustc_debuginfo_levels[@]\"'\n+    --dep-info='[Output dependency info to <filename> after compiling]::FILE:_files -/'\n+    --sysroot='[Override the system root]:PATH:_files -/'\n+    --cfg='[Configure the compilation environment]:SPEC:'\n+    --out-dir='[Write output to compiler-chosen filename in <dir>.  Ignored  if  -o  is  specified. (default the current directory)]:DIR:_files -/'\n+    -o'[Write output to <filename>. Ignored if more than one --emit is specified.]:FILENAME:_files'\n+    --opt-level='[Optimize with possible levels 0-3]:LEVEL:(0 1 2 3)'\n+    --pretty='[Pretty-print the input instead of compiling]::TYPE:_values \"TYPES\" \"$_rustc_pretty_types[@]\"'\n+    -L'[Add a directory to the library search path]:DIR:_files -/'\n+    --target='[Target triple cpu-manufacturer-kernel\\[-os\\] to compile]:TRIPLE:'\n+    --color='[Configure coloring of output]:CONF:_values \"COLORS\" \"$_rustc_color_types[@]\"'\n+    {-v,--version}'[Print version info and exit]::VERBOSE:(verbose)'\n+    --explain='[Provide a detailed explanation of an error message]:OPT:'\n+    --extern'[Specify where an external rust library is located]:ARG:'\n+)\n+\n _rustc_opts_switches=(\n-    --ar'[Program to use for managing archives instead of the default.]'\n-    -c'[Compile and assemble, but do not link]'\n-    --cfg'[Configure the compilation environment]'\n-    --crate-id'[Output the crate id and exit]'\n-    --crate-file-name'[deprecated in favor of --print-file-name]'\n-    --crate-name'[Specify the name of the crate being built]'\n-    --crate-type'[Specify the type of crate to crate]'\n-    --debuginfo'[Emit DWARF debug info to the objects created: 0 = no debug info, 1 = line-tables only (for stacktraces and breakpoints), 2 = full debug info with variable and type information (same as -g)]'\n-    --dep-info'[Output dependency info to <filename> after compiling]'\n     -g'[Equivalent to --debuginfo=2]'\n     {-h,--help}'[Display this message]'\n-    -L'[Add a directory to the library search path]'\n-    --linker'[Program to use for linking instead of the default.]'\n-    --link-args'[FLAGS is a space-separated list of flags passed to the linker]'\n-    --llvm-args'[A list of arguments to pass to llvm, comma separated]'\n-    --ls'[List the symbols defined by a library crate]'\n     --no-analysis'[Parse and expand the output, but run no analysis or produce output]'\n-    --no-rpath'[Disables setting the rpath in libs/exes]'\n     --no-trans'[Run all passes except translation; no output]'\n     -O'[Equivalent to --opt-level=2]'\n-    -o'[Write output to <filename>]'\n-    --opt-level'[Optimize with possible levels 0-3]'\n-    --out-dir'[Write output to compiler-chosen filename in <dir>]'\n     --parse-only'[Parse only; do not compile, assemble, or link]'\n-    --passes'[Comma or space separated list of pass names to use]'\n-    --pretty'[Pretty-print the input instead of compiling]'\n     --print-crate-name'[Output the crate name and exit]'\n     --print-file-name'[Output the file(s) that would be written if compilation continued and exit]'\n-    --save-temps'[Write intermediate files (.bc, .opt.bc, .o) in addition to normal output]'\n-    --sysroot'[Override the system root]'\n     --test'[Build a test harness]'\n-    --target'[Target triple cpu-manufacturer-kernel\\[-os\\] to compile]'\n-    --target-cpu'[Select target processor (llc -mcpu=help for details)]'\n-    --target-feature'[Target specific attributes (llc -mattr=help for details)]'\n-    --relocation-model'[Relocation model (llc --help for details)]'\n-    {-v,--version}'[Print version info and exit]'\n )\n+_rustc_opts_codegen=(\n+    'ar=[Path to the archive utility to use when assembling archives.]:BIN:_path_files'\n+    'linker=[Path to the linker utility to use when linking libraries, executables, and objects.]:BIN:_path_files'\n+    'link-args=[A space-separated list of extra arguments to pass to the linker when the linker is invoked.]:ARGS:'\n+    'target-cpu=[Selects a target processor. If the value is \"help\", then a list of  available  CPUs is printed.]:CPU:'\n+    'target-feature=[A space-separated list of features to enable or disable for the target. A preceding \"+\" enables a feature while a preceding \"-\" disables it. Available features can be discovered through target-cpu=help.]:FEATURE:'\n+    'passes=[A space-separated list of extra LLVM passes to run. A value of \"list\" will cause rustc to print all known passes and exit. The passes specified are appended at the end of the normal pass manager.]:LIST:'\n+    'llvm-args=[A space-separated list of arguments to pass through to LLVM.]:ARGS:'\n+    'save-temps[If specified, the compiler will save more files (.bc, .o, .no-opt.bc) generated throughout compilation in the output directory.]'\n+    'rpath[If specified, then the rpath value for dynamic libraries will be set in either dynamic library or executable outputs.]'\n+    'no-prepopulate-passes[Suppresses pre-population of the LLVM pass manager that is run over the module.]'\n+    'no-vectorize-loops[Suppresses running the loop vectorization LLVM pass, regardless of optimization level.]'\n+    'no-vectorize-slp[Suppresses running the LLVM SLP vectorization pass, regardless of optimization level.]'\n+    'soft-float[Generates software floating point library calls instead of hardware instructions.]'\n+    'prefer-dynamic[Prefers dynamic linking to static linking.]'\n+    \"no-integrated-as[Force usage of an external assembler rather than LLVM's integrated one.]\"\n+    'no-redzone[disable the use of the redzone]'\n+    'relocation-model=[The relocation model to use. (default: pic)]:MODEL:(pic static dynamic-no-pic)'\n+    'code-model=[choose the code model to use (llc -code-model for details)]:MODEL:'\n+    'metadata=[metadata to mangle symbol names with]:VAL:'\n+    'extra-filenames=[extra data to put in each output filename]:VAL:'\n+    'codegen-units=[divide crate into N units to optimize in parallel]:N:'\n+    'help[Show all codegen options]'\n+)\n+\n _rustc_opts_lint=(\n-    'attribute-usage[detects bad use of attributes]'\n-    'ctypes[proper use of libc types in foreign modules]'\n-    'dead-assignment[detect assignments that will never be read]'\n-    'dead-code[detect piece of code that will never be used]'\n-    'default-type-param-usage[prevents explicitly setting a type parameter with a default]'\n-    'deprecated[detects use of #\\[deprecated\\] items]'\n+    'help[Show a list of all lints]'\n     'experimental[detects use of #\\[experimental\\] items]'\n-    'heap-memory[use of any (~ type or @ type) heap memory]'\n+    'heap-memory[use of any (Box type or @ type) heap memory]'\n     'managed-heap-memory[use of managed (@ type) heap memory]'\n     'missing-doc[detects missing documentation for public members]'\n-    'non-camel-case-types[types, variants and traits should have camel case names]'\n-    'non-uppercase-pattern-statics[static constants in match patterns should be all caps]'\n     'non-uppercase-statics[static constants should have uppercase identifiers]'\n     'owned-heap-memory[use of owned (~ type) heap memory]'\n+    'unnecessary-qualification[detects unnecessarily qualified names]'\n+    'unsafe-block[usage of an `unsafe` block]'\n+    'unstable[detects use of #\\[unstable\\] items (incl. items with no stability attribute)]'\n+    'unused-result[unused result of an expression in a statement]'\n+    'variant-size-difference[detects enums with widely varying variant sizes]'\n+    'ctypes[proper use of libc types in foreign modules]'\n+    'dead-assignment[detect assignments that will never be read]'\n+    'dead-code[detect piece of code that will never be used]'\n+    'deprecated[detects use of #\\[deprecated\\] items]'\n+    'non-camel-case-types[types, variants and traits should have camel case names]'\n+    'non-snake-case[methods, functions, lifetime parameters and modules should have snake case names]'\n     'path-statement[path statements with no effect]'\n+    'raw-pointer-deriving[uses of #\\[deriving\\] with raw pointers are rarely correct]'\n     'type-limits[comparisons made useless by limits of the types involved]'\n     'type-overflow[literal out of range for its type]'\n-    'unknown-crate-type[unknown crate type found in #\\[crate_type\\] directive]'\n-    'unknown-features[unknown features found in crate-level #\\[feature\\] directives]'\n     'unnecessary-allocation[detects unnecessary allocations that can be eliminated]'\n     'unnecessary-parens[`if`, `match`, `while` and `return` do not need parentheses]'\n-    'unnecessary-qualification[detects unnecessarily qualified names]'\n-    'unnecessary-typecast[detects unnecessary type casts, that can be removed]'\n     'unreachable-code[detects unreachable code]'\n     'unrecognized-lint[unrecognized lint attribute]'\n-    'unsafe-block[usage of an `unsafe` block]'\n-    'unstable[detects use of #\\[unstable\\] items (incl. items with no stability attribute)]'\n+    'unsigned-negate[using an unary minus operator on unsigned type]'\n+    'unused-attribute[detects attributes that were not used by the compiler]'\n     'unused-imports[imports that are never used]'\n     'unused-must-use[unused result of a type flagged as #\\[must_use\\]]'\n     \"unused-mut[detect mut variables which don't need to be mutable]\"\n-    'unused-result[unused result of an expression in a statement]'\n     'unused-unsafe[unnecessary use of an `unsafe` block]'\n     'unused-variable[detect variables which are not used in any way]'\n+    'visible-private-types[detect use of private types in exported type signatures]'\n     'warnings[mass-change the level for lints which produce warnings]'\n     'while-true[suggest using `loop { }` instead of `while true { }`]'\n+    'unknown-crate-type[unknown crate type found in #\\[crate_type\\] directive]'\n+    'unknown-features[unknown features found in crate-level #\\[feature\\] directives]'\n+    'bad-style[group of non_camel_case_types, non_snake_case, non_uppercase_statics]'\n+    'unused[group of unused_imports, unused_variable, dead_assignment, dead_code, unused_mut, unreachable_code]'\n )\n \n _rustc_opts_debug=(\n+    'verbose[in general, enable more debug printouts]'\n+    'time-passes[measure time of each rustc pass]'\n+    'count-llvm-insns[count where LLVM instrs originate]'\n+    'time-llvm-passes[measure time of each LLVM pass]'\n+    'trans-stats[gather trans statistics]'\n     'asm-comments[generate comments into the assembly (may change behavior)]'\n+    'no-verify[skip LLVM verification]'\n     'borrowck-stats[gather borrowck statistics]'\n-    'count-llvm-insns[count where LLVM instrs originate]'\n-    'count-type-sizes[count the sizes of aggregate types]'\n-    'debug-info[Produce debug info (experimental)]'\n+    'no-landing-pads[omit landing pads for unwinding]'\n     'debug-llvm[enable debug output from LLVM]'\n-    'extra-debug-info[Extra debugging info (experimental)]'\n-    'gc[Garbage collect shared data (experimental)]'\n-    'gen-crate-map[Force generation of a toplevel crate map]'\n-    'lto[Perform LLVM link-time optimizations]'\n+    'show-span[show spans for compiler debugging]'\n+    'count-type-sizes[count the sizes of aggregate types]'\n     'meta-stats[gather metadata statistics]'\n-    \"no-integrated-as[Use external assembler rather than LLVM's integrated one]\"\n-    'no-landing-pads[omit landing pads for unwinding]'\n     'no-opt[do not optimize, even if -O is passed]'\n-    \"no-prepopulate-passes[Don't pre-populate the pass managers with a list of passes, only use the passes from --passes]\"\n-    \"no-vectorize-loops[Don't run the loop vectorization optimization passes]\"\n-    \"no-vectorize-slp[Don't run LLVM's SLP vectorization passes]\"\n-    'no-verify[skip LLVM verification]'\n-    'prefer-dynamic[Prefer dynamic linking to static linking]'\n     'print-link-args[Print the arguments passed to the linker]'\n+    'gc[Garbage collect shared data (experimental)]'\n     'print-llvm-passes[Prints the llvm optimization passes being run]'\n-    'soft-float[Generate software floating point library calls]'\n-    'time-llvm-passes[measure time of each LLVM pass]'\n-    'time-passes[measure time of each rustc pass]'\n-    'trans-stats[gather trans statistics]'\n-    'verbose[in general, enable more debug printouts]'\n+    'lto[Perform LLVM link-time optimizations]'\n+    'ast-json[Print the AST as JSON and halt]'\n+    'ast-json-noexpand[Print the pre-expansion AST as JSON and halt]'\n+    'ls[List the symbols defined by a library crate]'\n+    'save-analysis[Write syntax and type analysis information in addition to normal output]'\n+    'flowgraph-print-loans[Include loan analysis data in --pretty flowgraph output]'\n+    'flowgraph-print-moves[Include move analysis data in --pretty flowgraph output]'\n+    'flowgraph-print-assigns[Include assignment analysis data in --pretty flowgraph output]'\n+    'flowgraph-print-all[Include all dataflow analysis data in --pretty flowgraph output]'\n )\n \n _rustc_opts_fun_lint(){\n@@ -115,14 +172,20 @@ _rustc_opts_fun_lint(){\n }\n \n _rustc_opts_fun_debug(){\n-    _describe 'options' _rustc_opts_debug\n+    _values 'options' \"$_rustc_opts_debug[@]\"\n+}\n+\n+_rustc_opts_fun_codegen(){\n+    _values 'options' \"$_rustc_opts_codegen[@]\"\n }\n \n _arguments -s :  \\\n-    '(-W --warn)'{-W,--warn}'[Set lint warnings]:lint options:_rustc_opts_fun_lint' \\\n-    '(-A --allow)'{-A,--allow}'[Set lint allowed]:lint options:_rustc_opts_fun_lint' \\\n-    '(-D --deny)'{-D,--deny}'[Set lint denied]:lint options:_rustc_opts_fun_lint' \\\n-    '(-F --forbid)'{-F,--forbid}'[Set lint forbidden]:lint options:_rustc_opts_fun_lint' \\\n+    '(-W --warn)'{-W,--warn=}'[Set lint warnings]:lint options:_rustc_opts_fun_lint' \\\n+    '(-A --allow)'{-A,--allow=}'[Set lint allowed]:lint options:_rustc_opts_fun_lint' \\\n+    '(-D --deny)'{-D,--deny=}'[Set lint denied]:lint options:_rustc_opts_fun_lint' \\\n+    '(-F --forbid)'{-F,--forbid=}'[Set lint forbidden]:lint options:_rustc_opts_fun_lint' \\\n     '*-Z[Set internal debugging options]:debug options:_rustc_opts_fun_debug' \\\n+    '*-C[Set internal Codegen options]:codegen options:_rustc_opts_fun_codegen' \\\n     \"$_rustc_opts_switches[@]\" \\\n-    '*::files:_files -g \"*.rs\"'\n+    \"$_rustc_opts_vals[@]\" \\\n+    '::files:_files -g \"*.rs\"'"}, {"sha": "a95eeb3c97dc2c4dfff6530d0a4bbf64df251d6c", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -211,7 +211,7 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, Token>) -> TokenAndSpan {\n     let sp = syntax::codemap::Span {\n         lo: syntax::codemap::BytePos(from_str::<u32>(start).unwrap() - offset),\n         hi: syntax::codemap::BytePos(from_str::<u32>(end).unwrap() + 1),\n-        expn_info: None\n+        expn_id: syntax::codemap::NO_EXPANSION\n     };\n \n     TokenAndSpan {"}, {"sha": "a12d403603fe89df557ff4b063a40d266490cde3", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -872,7 +872,7 @@ mod tests {\n \n     use {Mutable, MutableSeq};\n     use str;\n-    use str::{Str, StrSlice, Owned, Slice};\n+    use str::{Str, StrSlice, Owned};\n     use super::String;\n     use vec::Vec;\n \n@@ -898,10 +898,10 @@ mod tests {\n     #[test]\n     fn test_from_utf8_lossy() {\n         let xs = b\"hello\";\n-        assert_eq!(String::from_utf8_lossy(xs), Slice(\"hello\"));\n+        assert_eq!(String::from_utf8_lossy(xs), str::Slice(\"hello\"));\n \n         let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes();\n-        assert_eq!(String::from_utf8_lossy(xs), Slice(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n+        assert_eq!(String::from_utf8_lossy(xs), str::Slice(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n \n         let xs = b\"Hello\\xC2 There\\xFF Goodbye\";\n         assert_eq!(String::from_utf8_lossy(xs),"}, {"sha": "4051f682134367be27630c47bdf056b03ba6d7cc", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -20,6 +20,7 @@ use core::default::Default;\n use core::fmt;\n use core::mem;\n use core::num;\n+use core::ops;\n use core::ptr;\n use core::raw::Slice as RawSlice;\n use core::uint;\n@@ -464,6 +465,47 @@ impl<T> Index<uint,T> for Vec<T> {\n     }\n }*/\n \n+impl<T> ops::Slice<uint, [T]> for Vec<T> {\n+    #[inline]\n+    fn as_slice_<'a>(&'a self) -> &'a [T] {\n+        self.as_slice()\n+    }\n+\n+    #[inline]\n+    fn slice_from_<'a>(&'a self, start: &uint) -> &'a [T] {\n+        self.as_slice().slice_from_(start)\n+    }\n+\n+    #[inline]\n+    fn slice_to_<'a>(&'a self, end: &uint) -> &'a [T] {\n+        self.as_slice().slice_to_(end)\n+    }\n+    #[inline]\n+    fn slice_<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n+        self.as_slice().slice_(start, end)\n+    }\n+}\n+\n+impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n+    #[inline]\n+    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n+        self.as_mut_slice()\n+    }\n+\n+    #[inline]\n+    fn slice_from_mut_<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n+        self.as_mut_slice().slice_from_mut_(start)\n+    }\n+\n+    #[inline]\n+    fn slice_to_mut_<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n+        self.as_mut_slice().slice_to_mut_(end)\n+    }\n+    #[inline]\n+    fn slice_mut_<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n+        self.as_mut_slice().slice_mut_(start, end)\n+    }\n+}\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n     fn from_iter<I:Iterator<T>>(mut iterator: I) -> Vec<T> {\n@@ -2327,6 +2369,44 @@ mod tests {\n         let _ = vec[3];\n     }\n \n+    // NOTE uncomment after snapshot\n+    /*\n+    #[test]\n+    #[should_fail]\n+    fn test_slice_out_of_bounds_1() {\n+        let x: Vec<int> = vec![1, 2, 3, 4, 5];\n+        x[-1..];\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_slice_out_of_bounds_2() {\n+        let x: Vec<int> = vec![1, 2, 3, 4, 5];\n+        x[..6];\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_slice_out_of_bounds_3() {\n+        let x: Vec<int> = vec![1, 2, 3, 4, 5];\n+        x[-1..4];\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_slice_out_of_bounds_4() {\n+        let x: Vec<int> = vec![1, 2, 3, 4, 5];\n+        x[1..6];\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_slice_out_of_bounds_5() {\n+        let x: Vec<int> = vec![1, 2, 3, 4, 5];\n+        x[3..2];\n+    }\n+    */\n+\n     #[test]\n     fn test_swap_remove_empty() {\n         let mut vec: Vec<uint> = vec!();"}, {"sha": "718d311999552ef7390375babb41952e4b754224", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 102, "deletions": 3, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -638,7 +638,7 @@ shr_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n  * ```\n  */\n #[lang=\"index\"]\n-pub trait Index<Index,Result> {\n+pub trait Index<Index, Result> {\n     /// The method for the indexing (`Foo[Bar]`) operation\n     fn index<'a>(&'a self, index: &Index) -> &'a Result;\n }\n@@ -651,7 +651,7 @@ pub trait Index<Index,Result> {\n  * # Example\n  *\n  * A trivial implementation of `IndexMut`. When `Foo[Foo]` happens, it ends up\n- * calling `index`, and therefore, `main` prints `Indexing!`.\n+ * calling `index_mut`, and therefore, `main` prints `Indexing!`.\n  *\n  * ```\n  * struct Foo;\n@@ -669,11 +669,110 @@ pub trait Index<Index,Result> {\n  * ```\n  */\n #[lang=\"index_mut\"]\n-pub trait IndexMut<Index,Result> {\n+pub trait IndexMut<Index, Result> {\n     /// The method for the indexing (`Foo[Bar]`) operation\n     fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Result;\n }\n \n+/**\n+ *\n+ * The `Slice` trait is used to specify the functionality of slicing operations\n+ * like `arr[from..to]` when used in an immutable context.\n+ *\n+ * # Example\n+ *\n+ * A trivial implementation of `Slice`. When `Foo[..Foo]` happens, it ends up\n+ * calling `slice_to`, and therefore, `main` prints `Slicing!`.\n+ *\n+ * ```\n+ * struct Foo;\n+ *\n+ * impl ::core::ops::Slice<Foo, Foo> for Foo {\n+ *     fn as_slice_<'a>(&'a self) -> &'a Foo {\n+ *         println!(\"Slicing!\");\n+ *         self\n+ *     }\n+ *     fn slice_from_<'a>(&'a self, from: &Foo) -> &'a Foo {\n+ *         println!(\"Slicing!\");\n+ *         self\n+ *     }\n+ *     fn slice_to_<'a>(&'a self, to: &Foo) -> &'a Foo {\n+ *         println!(\"Slicing!\");\n+ *         self\n+ *     }\n+ *     fn slice_<'a>(&'a self, from: &Foo, to: &Foo) -> &'a Foo {\n+ *         println!(\"Slicing!\");\n+ *         self\n+ *     }\n+ * }\n+ *\n+ * fn main() {\n+ *     Foo[..Foo];\n+ * }\n+ * ```\n+ */\n+// FIXME(#17273) remove the postscript _s\n+#[lang=\"slice\"]\n+pub trait Slice<Idx, Sized? Result> for Sized? {\n+    /// The method for the slicing operation foo[]\n+    fn as_slice_<'a>(&'a self) -> &'a Result;\n+    /// The method for the slicing operation foo[from..]\n+    fn slice_from_<'a>(&'a self, from: &Idx) -> &'a Result;\n+    /// The method for the slicing operation foo[..to]\n+    fn slice_to_<'a>(&'a self, to: &Idx) -> &'a Result;\n+    /// The method for the slicing operation foo[from..to]\n+    fn slice_<'a>(&'a self, from: &Idx, to: &Idx) -> &'a Result;\n+}\n+\n+/**\n+ *\n+ * The `SliceMut` trait is used to specify the functionality of slicing\n+ * operations like `arr[from..to]`, when used in a mutable context.\n+ *\n+ * # Example\n+ *\n+ * A trivial implementation of `SliceMut`. When `Foo[Foo..]` happens, it ends up\n+ * calling `slice_from_mut`, and therefore, `main` prints `Slicing!`.\n+ *\n+ * ```\n+ * struct Foo;\n+ *\n+ * impl ::core::ops::SliceMut<Foo, Foo> for Foo {\n+ *     fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Foo {\n+ *         println!(\"Slicing!\");\n+ *         self\n+ *     }\n+ *     fn slice_from_mut_<'a>(&'a mut self, from: &Foo) -> &'a mut Foo {\n+ *         println!(\"Slicing!\");\n+ *         self\n+ *     }\n+ *     fn slice_to_mut_<'a>(&'a mut self, to: &Foo) -> &'a mut Foo {\n+ *         println!(\"Slicing!\");\n+ *         self\n+ *     }\n+ *     fn slice_mut_<'a>(&'a mut self, from: &Foo, to: &Foo) -> &'a mut Foo {\n+ *         println!(\"Slicing!\");\n+ *         self\n+ *     }\n+ * }\n+ *\n+ * fn main() {\n+ *     Foo[mut Foo..];\n+ * }\n+ * ```\n+ */\n+// FIXME(#17273) remove the postscript _s\n+#[lang=\"slice_mut\"]\n+pub trait SliceMut<Idx, Sized? Result> for Sized? {\n+    /// The method for the slicing operation foo[]\n+    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Result;\n+    /// The method for the slicing operation foo[from..]\n+    fn slice_from_mut_<'a>(&'a mut self, from: &Idx) -> &'a mut Result;\n+    /// The method for the slicing operation foo[..to]\n+    fn slice_to_mut_<'a>(&'a mut self, to: &Idx) -> &'a mut Result;\n+    /// The method for the slicing operation foo[from..to]\n+    fn slice_mut_<'a>(&'a mut self, from: &Idx, to: &Idx) -> &'a mut Result;\n+}\n /**\n  *\n  * The `Deref` trait is used to specify the functionality of dereferencing"}, {"sha": "5368cb4450294e2dd726c0cf4bafc49700c83311", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -42,6 +42,7 @@ use cmp;\n use default::Default;\n use iter::*;\n use num::{CheckedAdd, Saturating, div_rem};\n+use ops;\n use option::{None, Option, Some};\n use ptr;\n use ptr::RawPtr;\n@@ -475,6 +476,63 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     }\n }\n \n+impl<T> ops::Slice<uint, [T]> for [T] {\n+    #[inline]\n+    fn as_slice_<'a>(&'a self) -> &'a [T] {\n+        self\n+    }\n+\n+    #[inline]\n+    fn slice_from_<'a>(&'a self, start: &uint) -> &'a [T] {\n+        self.slice_(start, &self.len())\n+    }\n+\n+    #[inline]\n+    fn slice_to_<'a>(&'a self, end: &uint) -> &'a [T] {\n+        self.slice_(&0, end)\n+    }\n+    #[inline]\n+    fn slice_<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n+        assert!(*start <= *end);\n+        assert!(*end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                    data: self.as_ptr().offset(*start as int),\n+                    len: (*end - *start)\n+                })\n+        }\n+    }\n+}\n+\n+impl<T> ops::SliceMut<uint, [T]> for [T] {\n+    #[inline]\n+    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n+        self\n+    }\n+\n+    #[inline]\n+    fn slice_from_mut_<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n+        let len = &self.len();\n+        self.slice_mut_(start, len)\n+    }\n+\n+    #[inline]\n+    fn slice_to_mut_<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n+        self.slice_mut_(&0, end)\n+    }\n+    #[inline]\n+    fn slice_mut_<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n+        assert!(*start <= *end);\n+        assert!(*end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                    data: self.as_ptr().offset(*start as int),\n+                    len: (*end - *start)\n+                })\n+        }\n+    }\n+}\n+\n /// Extension methods for vectors such that their elements are\n /// mutable.\n #[experimental = \"may merge with other traits; may lose region param; needs review\"]"}, {"sha": "a9f34e1195ce622ec57f0ad52006130c785e4032", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -23,6 +23,7 @@\n \n use std::char;\n use std::str;\n+use std::string;\n \n /// A piece is a portion of the format string which represents the next part\n /// to emit. These are emitted as a stream by the `Parser` class.\n@@ -32,7 +33,7 @@ pub enum Piece<'a> {\n     String(&'a str),\n     /// This describes that formatting should process the next argument (as\n     /// specified inside) for emission.\n-    Argument(Argument<'a>),\n+    NextArgument(Argument<'a>),\n }\n \n /// Representation of an argument specification.\n@@ -129,7 +130,7 @@ pub struct Parser<'a> {\n     input: &'a str,\n     cur: str::CharOffsets<'a>,\n     /// Error messages accumulated during parsing\n-    pub errors: Vec<String>,\n+    pub errors: Vec<string::String>,\n }\n \n impl<'a> Iterator<Piece<'a>> for Parser<'a> {\n@@ -140,7 +141,7 @@ impl<'a> Iterator<Piece<'a>> for Parser<'a> {\n                 if self.consume('{') {\n                     Some(String(self.string(pos + 1)))\n                 } else {\n-                    let ret = Some(Argument(self.argument()));\n+                    let ret = Some(NextArgument(self.argument()));\n                     self.must_consume('}');\n                     ret\n                 }\n@@ -469,28 +470,28 @@ mod tests {\n \n     #[test]\n     fn format_nothing() {\n-        same(\"{}\", [Argument(Argument {\n+        same(\"{}\", [NextArgument(Argument {\n             position: ArgumentNext,\n             format: fmtdflt(),\n         })]);\n     }\n     #[test]\n     fn format_position() {\n-        same(\"{3}\", [Argument(Argument {\n+        same(\"{3}\", [NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: fmtdflt(),\n         })]);\n     }\n     #[test]\n     fn format_position_nothing_else() {\n-        same(\"{3:}\", [Argument(Argument {\n+        same(\"{3:}\", [NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: fmtdflt(),\n         })]);\n     }\n     #[test]\n     fn format_type() {\n-        same(\"{3:a}\", [Argument(Argument {\n+        same(\"{3:a}\", [NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: None,\n@@ -504,7 +505,7 @@ mod tests {\n     }\n     #[test]\n     fn format_align_fill() {\n-        same(\"{3:>}\", [Argument(Argument {\n+        same(\"{3:>}\", [NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: None,\n@@ -515,7 +516,7 @@ mod tests {\n                 ty: \"\",\n             },\n         })]);\n-        same(\"{3:0<}\", [Argument(Argument {\n+        same(\"{3:0<}\", [NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: Some('0'),\n@@ -526,7 +527,7 @@ mod tests {\n                 ty: \"\",\n             },\n         })]);\n-        same(\"{3:*<abcd}\", [Argument(Argument {\n+        same(\"{3:*<abcd}\", [NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: Some('*'),\n@@ -540,7 +541,7 @@ mod tests {\n     }\n     #[test]\n     fn format_counts() {\n-        same(\"{:10s}\", [Argument(Argument {\n+        same(\"{:10s}\", [NextArgument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -551,7 +552,7 @@ mod tests {\n                 ty: \"s\",\n             },\n         })]);\n-        same(\"{:10$.10s}\", [Argument(Argument {\n+        same(\"{:10$.10s}\", [NextArgument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -562,7 +563,7 @@ mod tests {\n                 ty: \"s\",\n             },\n         })]);\n-        same(\"{:.*s}\", [Argument(Argument {\n+        same(\"{:.*s}\", [NextArgument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -573,7 +574,7 @@ mod tests {\n                 ty: \"s\",\n             },\n         })]);\n-        same(\"{:.10$s}\", [Argument(Argument {\n+        same(\"{:.10$s}\", [NextArgument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -584,7 +585,7 @@ mod tests {\n                 ty: \"s\",\n             },\n         })]);\n-        same(\"{:a$.b$s}\", [Argument(Argument {\n+        same(\"{:a$.b$s}\", [NextArgument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -598,7 +599,7 @@ mod tests {\n     }\n     #[test]\n     fn format_flags() {\n-        same(\"{:-}\", [Argument(Argument {\n+        same(\"{:-}\", [NextArgument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -609,7 +610,7 @@ mod tests {\n                 ty: \"\",\n             },\n         })]);\n-        same(\"{:+#}\", [Argument(Argument {\n+        same(\"{:+#}\", [NextArgument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -623,7 +624,7 @@ mod tests {\n     }\n     #[test]\n     fn format_mixture() {\n-        same(\"abcd {3:a} efg\", [String(\"abcd \"), Argument(Argument {\n+        same(\"abcd {3:a} efg\", [String(\"abcd \"), NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: None,"}, {"sha": "8418e741167e8bac5391cee7188ae2c51b991a72", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -37,7 +37,7 @@ pub fn ntohs(u: u16) -> u16 {\n }\n \n enum InAddr {\n-    InAddr(libc::in_addr),\n+    In4Addr(libc::in_addr),\n     In6Addr(libc::in6_addr),\n }\n \n@@ -48,7 +48,7 @@ fn ip_to_inaddr(ip: rtio::IpAddr) -> InAddr {\n                      (b as u32 << 16) |\n                      (c as u32 <<  8) |\n                      (d as u32 <<  0);\n-            InAddr(libc::in_addr {\n+            In4Addr(libc::in_addr {\n                 s_addr: Int::from_be(ip)\n             })\n         }\n@@ -74,7 +74,7 @@ fn addr_to_sockaddr(addr: rtio::SocketAddr,\n                     -> libc::socklen_t {\n     unsafe {\n         let len = match ip_to_inaddr(addr.ip) {\n-            InAddr(inaddr) => {\n+            In4Addr(inaddr) => {\n                 let storage = storage as *mut _ as *mut libc::sockaddr_in;\n                 (*storage).sin_family = libc::AF_INET as libc::sa_family_t;\n                 (*storage).sin_port = htons(addr.port);\n@@ -723,7 +723,7 @@ impl UdpSocket {\n     pub fn set_membership(&mut self, addr: rtio::IpAddr,\n                           opt: libc::c_int) -> IoResult<()> {\n         match ip_to_inaddr(addr) {\n-            InAddr(addr) => {\n+            In4Addr(addr) => {\n                 let mreq = libc::ip_mreq {\n                     imr_multiaddr: addr,\n                     // interface == INADDR_ANY"}, {"sha": "efa3402073f2eff827a091aae9f24487b3f50a8e", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -618,7 +618,7 @@ impl ToBigUint for BigInt {\n     fn to_biguint(&self) -> Option<BigUint> {\n         if self.sign == Plus {\n             Some(self.data.clone())\n-        } else if self.sign == Zero {\n+        } else if self.sign == NoSign {\n             Some(Zero::zero())\n         } else {\n             None\n@@ -838,15 +838,15 @@ fn get_radix_base(radix: uint) -> (DoubleBigDigit, uint) {\n \n /// A Sign is a `BigInt`'s composing element.\n #[deriving(PartialEq, PartialOrd, Eq, Ord, Clone, Show)]\n-pub enum Sign { Minus, Zero, Plus }\n+pub enum Sign { Minus, NoSign, Plus }\n \n impl Neg<Sign> for Sign {\n     /// Negate Sign value.\n     #[inline]\n     fn neg(&self) -> Sign {\n         match *self {\n           Minus => Plus,\n-          Zero  => Zero,\n+          NoSign  => NoSign,\n           Plus  => Minus\n         }\n     }\n@@ -882,7 +882,7 @@ impl Ord for BigInt {\n         if scmp != Equal { return scmp; }\n \n         match self.sign {\n-            Zero  => Equal,\n+            NoSign  => Equal,\n             Plus  => self.data.cmp(&other.data),\n             Minus => other.data.cmp(&self.data),\n         }\n@@ -933,11 +933,11 @@ impl Shr<uint, BigInt> for BigInt {\n impl Zero for BigInt {\n     #[inline]\n     fn zero() -> BigInt {\n-        BigInt::from_biguint(Zero, Zero::zero())\n+        BigInt::from_biguint(NoSign, Zero::zero())\n     }\n \n     #[inline]\n-    fn is_zero(&self) -> bool { self.sign == Zero }\n+    fn is_zero(&self) -> bool { self.sign == NoSign }\n }\n \n impl One for BigInt {\n@@ -951,7 +951,7 @@ impl Signed for BigInt {\n     #[inline]\n     fn abs(&self) -> BigInt {\n         match self.sign {\n-            Plus | Zero => self.clone(),\n+            Plus | NoSign => self.clone(),\n             Minus => BigInt::from_biguint(Plus, self.data.clone())\n         }\n     }\n@@ -966,7 +966,7 @@ impl Signed for BigInt {\n         match self.sign {\n             Plus  => BigInt::from_biguint(Plus, One::one()),\n             Minus => BigInt::from_biguint(Minus, One::one()),\n-            Zero  => Zero::zero(),\n+            NoSign  => Zero::zero(),\n         }\n     }\n \n@@ -981,8 +981,8 @@ impl Add<BigInt, BigInt> for BigInt {\n     #[inline]\n     fn add(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n-            (Zero, _)      => other.clone(),\n-            (_,    Zero)   => self.clone(),\n+            (NoSign, _)      => other.clone(),\n+            (_,    NoSign)   => self.clone(),\n             (Plus, Plus)   => BigInt::from_biguint(Plus, self.data + other.data),\n             (Plus, Minus)  => self - (-*other),\n             (Minus, Plus)  => other - (-*self),\n@@ -995,8 +995,8 @@ impl Sub<BigInt, BigInt> for BigInt {\n     #[inline]\n     fn sub(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n-            (Zero, _)    => -other,\n-            (_,    Zero) => self.clone(),\n+            (NoSign, _)    => -other,\n+            (_,    NoSign) => self.clone(),\n             (Plus, Plus) => match self.data.cmp(&other.data) {\n                 Less    => BigInt::from_biguint(Minus, other.data - self.data),\n                 Greater => BigInt::from_biguint(Plus, self.data - other.data),\n@@ -1013,7 +1013,7 @@ impl Mul<BigInt, BigInt> for BigInt {\n     #[inline]\n     fn mul(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n-            (Zero, _)     | (_,     Zero)  => Zero::zero(),\n+            (NoSign, _)     | (_,     NoSign)  => Zero::zero(),\n             (Plus, Plus)  | (Minus, Minus) => {\n                 BigInt::from_biguint(Plus, self.data * other.data)\n             },\n@@ -1087,9 +1087,9 @@ impl Integer for BigInt {\n         let d = BigInt::from_biguint(Plus, d_ui);\n         let r = BigInt::from_biguint(Plus, r_ui);\n         match (self.sign, other.sign) {\n-            (_,    Zero)   => fail!(),\n-            (Plus, Plus)  | (Zero, Plus)  => ( d,  r),\n-            (Plus, Minus) | (Zero, Minus) => (-d,  r),\n+            (_,    NoSign)   => fail!(),\n+            (Plus, Plus)  | (NoSign, Plus)  => ( d,  r),\n+            (Plus, Minus) | (NoSign, Minus) => (-d,  r),\n             (Minus, Plus)                 => (-d, -r),\n             (Minus, Minus)                => ( d, -r)\n         }\n@@ -1113,9 +1113,9 @@ impl Integer for BigInt {\n         let d = BigInt::from_biguint(Plus, d_ui);\n         let m = BigInt::from_biguint(Plus, m_ui);\n         match (self.sign, other.sign) {\n-            (_,    Zero)   => fail!(),\n-            (Plus, Plus)  | (Zero, Plus)  => (d, m),\n-            (Plus, Minus) | (Zero, Minus) => if m.is_zero() {\n+            (_,    NoSign)   => fail!(),\n+            (Plus, Plus)  | (NoSign, Plus)  => (d, m),\n+            (Plus, Minus) | (NoSign, Minus) => if m.is_zero() {\n                 (-d, Zero::zero())\n             } else {\n                 (-d - One::one(), m + *other)\n@@ -1166,7 +1166,7 @@ impl ToPrimitive for BigInt {\n     fn to_i64(&self) -> Option<i64> {\n         match self.sign {\n             Plus  => self.data.to_i64(),\n-            Zero  => Some(0),\n+            NoSign  => Some(0),\n             Minus => {\n                 self.data.to_u64().and_then(|n| {\n                     let m: u64 = 1 << 63;\n@@ -1186,7 +1186,7 @@ impl ToPrimitive for BigInt {\n     fn to_u64(&self) -> Option<u64> {\n         match self.sign {\n             Plus => self.data.to_u64(),\n-            Zero => Some(0),\n+            NoSign => Some(0),\n             Minus => None\n         }\n     }\n@@ -1272,7 +1272,7 @@ impl ToStrRadix for BigInt {\n     fn to_str_radix(&self, radix: uint) -> String {\n         match self.sign {\n             Plus  => self.data.to_str_radix(radix),\n-            Zero  => \"0\".to_string(),\n+            NoSign  => \"0\".to_string(),\n             Minus => format!(\"-{}\", self.data.to_str_radix(radix)),\n         }\n     }\n@@ -1334,7 +1334,7 @@ impl<R: Rng> RandBigInt for R {\n             if self.gen() {\n                 return self.gen_bigint(bit_size);\n             } else {\n-                Zero\n+                NoSign\n             }\n         } else if self.gen() {\n             Plus\n@@ -1385,8 +1385,8 @@ impl BigInt {\n     /// The digits are be in base 2^32.\n     #[inline]\n     pub fn from_biguint(sign: Sign, data: BigUint) -> BigInt {\n-        if sign == Zero || data.is_zero() {\n-            return BigInt { sign: Zero, data: Zero::zero() };\n+        if sign == NoSign || data.is_zero() {\n+            return BigInt { sign: NoSign, data: Zero::zero() };\n         }\n         BigInt { sign: sign, data: data }\n     }\n@@ -1415,7 +1415,7 @@ impl BigInt {\n     pub fn to_biguint(&self) -> Option<BigUint> {\n         match self.sign {\n             Plus => Some(self.data.clone()),\n-            Zero => Some(Zero::zero()),\n+            NoSign => Some(Zero::zero()),\n             Minus => None\n         }\n     }\n@@ -2288,7 +2288,7 @@ mod biguint_tests {\n mod bigint_tests {\n     use Integer;\n     use super::{BigDigit, BigUint, ToBigUint};\n-    use super::{Sign, Minus, Zero, Plus, BigInt, RandBigInt, ToBigInt};\n+    use super::{Sign, Minus, NoSign, Plus, BigInt, RandBigInt, ToBigInt};\n \n     use std::cmp::{Less, Equal, Greater};\n     use std::i64;\n@@ -2307,9 +2307,9 @@ mod bigint_tests {\n             assert_eq!(inp, ans);\n         }\n         check(Plus, 1, Plus, 1);\n-        check(Plus, 0, Zero, 0);\n+        check(Plus, 0, NoSign, 0);\n         check(Minus, 1, Minus, 1);\n-        check(Zero, 1, Zero, 0);\n+        check(NoSign, 1, NoSign, 0);\n     }\n \n     #[test]\n@@ -2357,8 +2357,8 @@ mod bigint_tests {\n \n     #[test]\n     fn test_hash() {\n-        let a = BigInt::new(Zero, vec!());\n-        let b = BigInt::new(Zero, vec!(0));\n+        let a = BigInt::new(NoSign, vec!());\n+        let b = BigInt::new(NoSign, vec!(0));\n         let c = BigInt::new(Plus, vec!(1));\n         let d = BigInt::new(Plus, vec!(1,0,0,0,0,0));\n         let e = BigInt::new(Plus, vec!(0,0,0,0,0,1));"}, {"sha": "c4b517c525963a62024ced88446a139c533eec60", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -16,7 +16,7 @@ use std::cmp;\n use parse;\n use parse::{\n     Flags, FLAG_EMPTY,\n-    Nothing, Literal, Dot, Class, Begin, End, WordBoundary, Capture, Cat, Alt,\n+    Nothing, Literal, Dot, AstClass, Begin, End, WordBoundary, Capture, Cat, Alt,\n     Rep,\n     ZeroOne, ZeroMore, OneMore,\n };\n@@ -148,7 +148,7 @@ impl<'r> Compiler<'r> {\n             Nothing => {},\n             Literal(c, flags) => self.push(OneChar(c, flags)),\n             Dot(nl) => self.push(Any(nl)),\n-            Class(ranges, flags) =>\n+            AstClass(ranges, flags) =>\n                 self.push(CharClass(ranges, flags)),\n             Begin(flags) => self.push(EmptyBegin(flags)),\n             End(flags) => self.push(EmptyEnd(flags)),"}, {"sha": "9ff65fe3e2ad79a1b9a6fe31ee50b5d09a8c4c1e", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -425,7 +425,7 @@ pub mod native {\n         FLAG_EMPTY, FLAG_NOCASE, FLAG_MULTI, FLAG_DOTNL,\n         FLAG_SWAP_GREED, FLAG_NEGATED,\n     };\n-    pub use re::{Dynamic, Native};\n+    pub use re::{Dynamic, ExDynamic, Native, ExNative};\n     pub use vm::{\n         MatchKind, Exists, Location, Submatches,\n         StepState, StepMatchEarlyReturn, StepMatch, StepContinue,"}, {"sha": "ad60829c088003fc746337ab45681b1ec920affd", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -53,7 +53,7 @@ pub enum Ast {\n     Nothing,\n     Literal(char, Flags),\n     Dot(Flags),\n-    Class(Vec<(char, char)>, Flags),\n+    AstClass(Vec<(char, char)>, Flags),\n     Begin(Flags),\n     End(Flags),\n     WordBoundary(Flags),\n@@ -101,7 +101,7 @@ impl Greed {\n /// state.\n #[deriving(Show)]\n enum BuildAst {\n-    Ast(Ast),\n+    Expr(Ast),\n     Paren(Flags, uint, String), // '('\n     Bar, // '|'\n }\n@@ -152,7 +152,7 @@ impl BuildAst {\n \n     fn unwrap(self) -> Result<Ast, Error> {\n         match self {\n-            Ast(x) => Ok(x),\n+            Expr(x) => Ok(x),\n             _ => fail!(\"Tried to unwrap non-AST item: {}\", self),\n         }\n     }\n@@ -311,7 +311,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn push(&mut self, ast: Ast) {\n-        self.stack.push(Ast(ast))\n+        self.stack.push(Expr(ast))\n     }\n \n     fn push_repeater(&mut self, c: char) -> Result<(), Error> {\n@@ -388,8 +388,8 @@ impl<'a> Parser<'a> {\n             match c {\n                 '[' =>\n                     match self.try_parse_ascii() {\n-                        Some(Class(asciis, flags)) => {\n-                            alts.push(Class(asciis, flags ^ negated));\n+                        Some(AstClass(asciis, flags)) => {\n+                            alts.push(AstClass(asciis, flags ^ negated));\n                             continue\n                         }\n                         Some(ast) =>\n@@ -399,8 +399,8 @@ impl<'a> Parser<'a> {\n                     },\n                 '\\\\' => {\n                     match try!(self.parse_escape()) {\n-                        Class(asciis, flags) => {\n-                            alts.push(Class(asciis, flags ^ negated));\n+                        AstClass(asciis, flags) => {\n+                            alts.push(AstClass(asciis, flags ^ negated));\n                             continue\n                         }\n                         Literal(c2, _) => c = c2, // process below\n@@ -417,7 +417,7 @@ impl<'a> Parser<'a> {\n                 ']' => {\n                     if ranges.len() > 0 {\n                         let flags = negated | (self.flags & FLAG_NOCASE);\n-                        let mut ast = Class(combine_ranges(ranges), flags);\n+                        let mut ast = AstClass(combine_ranges(ranges), flags);\n                         for alt in alts.into_iter() {\n                             ast = Alt(box alt, box ast)\n                         }\n@@ -485,7 +485,7 @@ impl<'a> Parser<'a> {\n             Some(ranges) => {\n                 self.chari = closer;\n                 let flags = negated | (self.flags & FLAG_NOCASE);\n-                Some(Class(combine_ranges(ranges), flags))\n+                Some(AstClass(combine_ranges(ranges), flags))\n             }\n         }\n     }\n@@ -611,7 +611,7 @@ impl<'a> Parser<'a> {\n                 let ranges = perl_unicode_class(c);\n                 let mut flags = self.flags & FLAG_NOCASE;\n                 if c.is_uppercase() { flags |= FLAG_NEGATED }\n-                Ok(Class(ranges, flags))\n+                Ok(AstClass(ranges, flags))\n             }\n             _ => {\n                 self.err(format!(\"Invalid escape sequence '\\\\\\\\{}'\",\n@@ -655,7 +655,7 @@ impl<'a> Parser<'a> {\n                                         name).as_slice())\n             }\n             Some(ranges) => {\n-                Ok(Class(ranges, negated | (self.flags & FLAG_NOCASE)))\n+                Ok(AstClass(ranges, negated | (self.flags & FLAG_NOCASE)))\n             }\n         }\n     }\n@@ -888,7 +888,7 @@ impl<'a> Parser<'a> {\n         while i > from {\n             i = i - 1;\n             match self.stack.pop().unwrap() {\n-                Ast(x) => combined = mk(x, combined),\n+                Expr(x) => combined = mk(x, combined),\n                 _ => {},\n             }\n         }"}, {"sha": "c2578d227ee384839d806da04f1e9de374134a17", "filename": "src/libregex/re.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -110,22 +110,22 @@ pub enum Regex {\n     // See the comments for the `program` module in `lib.rs` for a more\n     // detailed explanation for what `regex!` requires.\n     #[doc(hidden)]\n-    Dynamic(Dynamic),\n+    Dynamic(ExDynamic),\n     #[doc(hidden)]\n-    Native(Native),\n+    Native(ExNative),\n }\n \n #[deriving(Clone)]\n #[doc(hidden)]\n-pub struct Dynamic {\n+pub struct ExDynamic {\n     original: String,\n     names: Vec<Option<String>>,\n     #[doc(hidden)]\n     pub prog: Program\n }\n \n #[doc(hidden)]\n-pub struct Native {\n+pub struct ExNative {\n     #[doc(hidden)]\n     pub original: &'static str,\n     #[doc(hidden)]\n@@ -134,8 +134,8 @@ pub struct Native {\n     pub prog: fn(MatchKind, &str, uint, uint) -> Vec<Option<uint>>\n }\n \n-impl Clone for Native {\n-    fn clone(&self) -> Native { *self }\n+impl Clone for ExNative {\n+    fn clone(&self) -> ExNative { *self }\n }\n \n impl fmt::Show for Regex {\n@@ -156,7 +156,7 @@ impl Regex {\n     pub fn new(re: &str) -> Result<Regex, parse::Error> {\n         let ast = try!(parse::parse(re));\n         let (prog, names) = Program::new(ast);\n-        Ok(Dynamic(Dynamic {\n+        Ok(Dynamic(ExDynamic {\n             original: re.to_string(),\n             names: names,\n             prog: prog,\n@@ -510,8 +510,8 @@ impl Regex {\n     /// Returns the original string of this regex.\n     pub fn as_str<'a>(&'a self) -> &'a str {\n         match *self {\n-            Dynamic(Dynamic { ref original, .. }) => original.as_slice(),\n-            Native(Native { ref original, .. }) => original.as_slice(),\n+            Dynamic(ExDynamic { ref original, .. }) => original.as_slice(),\n+            Native(ExNative { ref original, .. }) => original.as_slice(),\n         }\n     }\n \n@@ -915,8 +915,8 @@ fn exec(re: &Regex, which: MatchKind, input: &str) -> CaptureLocs {\n fn exec_slice(re: &Regex, which: MatchKind,\n               input: &str, s: uint, e: uint) -> CaptureLocs {\n     match *re {\n-        Dynamic(Dynamic { ref prog, .. }) => vm::run(which, prog, input, s, e),\n-        Native(Native { prog, .. }) => prog(which, input, s, e),\n+        Dynamic(ExDynamic { ref prog, .. }) => vm::run(which, prog, input, s, e),\n+        Native(ExNative { prog, .. }) => prog(which, input, s, e),\n     }\n }\n "}, {"sha": "ae6dd2a4d70a78b8d3053ea44b836a4c6c4fc150", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -42,7 +42,7 @@ use regex::Regex;\n use regex::native::{\n     OneChar, CharClass, Any, Save, Jump, Split,\n     Match, EmptyBegin, EmptyEnd, EmptyWordBoundary,\n-    Program, Dynamic, Native,\n+    Program, Dynamic, ExDynamic, Native,\n     FLAG_NOCASE, FLAG_MULTI, FLAG_DOTNL, FLAG_NEGATED,\n };\n \n@@ -91,7 +91,7 @@ fn native(cx: &mut ExtCtxt, sp: codemap::Span, tts: &[ast::TokenTree])\n         }\n     };\n     let prog = match re {\n-        Dynamic(Dynamic { ref prog, .. }) => prog.clone(),\n+        Dynamic(ExDynamic { ref prog, .. }) => prog.clone(),\n         Native(_) => unreachable!(),\n     };\n \n@@ -322,7 +322,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n     }\n }\n \n-::regex::native::Native(::regex::native::Native {\n+::regex::native::Native(::regex::native::ExNative {\n     original: $regex,\n     names: CAP_NAMES,\n     prog: exec,"}, {"sha": "d31e19b4467f87d966b0aaedf270ae014a22d691", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -659,19 +659,18 @@ fn link_rlib<'a>(sess: &'a Session,\n             ab.add_file(&metadata).unwrap();\n             remove(sess, &metadata);\n \n-            if sess.opts.cg.codegen_units == 1 {\n-                // For LTO purposes, the bytecode of this library is also\n-                // inserted into the archive.  We currently do this only when\n-                // codegen_units == 1, so we don't have to deal with multiple\n-                // bitcode files per crate.\n-                //\n+            // For LTO purposes, the bytecode of this library is also inserted\n+            // into the archive.  If codegen_units > 1, we insert each of the\n+            // bitcode files.\n+            for i in range(0, sess.opts.cg.codegen_units) {\n                 // Note that we make sure that the bytecode filename in the\n                 // archive is never exactly 16 bytes long by adding a 16 byte\n                 // extension to it. This is to work around a bug in LLDB that\n                 // would cause it to crash if the name of a file in an archive\n                 // was exactly 16 bytes.\n-                let bc_filename = obj_filename.with_extension(\"bc\");\n-                let bc_deflated_filename = obj_filename.with_extension(\"bytecode.deflate\");\n+                let bc_filename = obj_filename.with_extension(format!(\"{}.bc\", i).as_slice());\n+                let bc_deflated_filename = obj_filename.with_extension(\n+                    format!(\"{}.bytecode.deflate\", i).as_slice());\n \n                 let bc_data = match fs::File::open(&bc_filename).read_to_end() {\n                     Ok(buffer) => buffer,\n@@ -705,8 +704,13 @@ fn link_rlib<'a>(sess: &'a Session,\n \n                 ab.add_file(&bc_deflated_filename).unwrap();\n                 remove(sess, &bc_deflated_filename);\n-                if !sess.opts.cg.save_temps &&\n-                   !sess.opts.output_types.contains(&OutputTypeBitcode) {\n+\n+                // See the bottom of back::write::run_passes for an explanation\n+                // of when we do and don't keep .0.bc files around.\n+                let user_wants_numbered_bitcode =\n+                        sess.opts.output_types.contains(&OutputTypeBitcode) &&\n+                        sess.opts.cg.codegen_units > 1;\n+                if !sess.opts.cg.save_temps && !user_wants_numbered_bitcode {\n                     remove(sess, &bc_filename);\n                 }\n             }\n@@ -1024,7 +1028,9 @@ fn link_args(cmd: &mut Command,\n \n         // Mark all dynamic libraries and executables as compatible with ASLR\n         // FIXME #17098: ASLR breaks gdb\n-        // cmd.arg(\"-Wl,--dynamicbase\");\n+        if sess.opts.debuginfo == NoDebugInfo {\n+            cmd.arg(\"-Wl,--dynamicbase\");\n+        }\n \n         // Mark all dynamic libraries and executables as compatible with the larger 4GiB address\n         // space available to x86 Windows binaries on x86_64."}, {"sha": "cd425b5fec170fafad637280fd6c4ffe5c23faed", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 72, "deletions": 65, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -21,6 +21,7 @@ use util::common::time;\n use libc;\n use flate;\n \n+use std::iter;\n use std::mem;\n \n pub fn run(sess: &session::Session, llmod: ModuleRef,\n@@ -60,78 +61,84 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n         let file = path.filename_str().unwrap();\n         let file = file.slice(3, file.len() - 5); // chop off lib/.rlib\n         debug!(\"reading {}\", file);\n-        let bc_encoded = time(sess.time_passes(),\n-                              format!(\"read {}.bytecode.deflate\", name).as_slice(),\n-                              (),\n-                              |_| {\n-                                  archive.read(format!(\"{}.bytecode.deflate\",\n-                                                       file).as_slice())\n-                              });\n-        let bc_encoded = match bc_encoded {\n-            Some(data) => data,\n-            None => {\n-                sess.fatal(format!(\"missing compressed bytecode in {} \\\n-                                    (perhaps it was compiled with -C codegen-units > 1)\",\n-                                   path.display()).as_slice());\n-            },\n-        };\n-        let bc_extractor = if is_versioned_bytecode_format(bc_encoded) {\n-            |_| {\n-                // Read the version\n-                let version = extract_bytecode_format_version(bc_encoded);\n-\n-                if version == 1 {\n-                    // The only version existing so far\n-                    let data_size = extract_compressed_bytecode_size_v1(bc_encoded);\n-                    let compressed_data = bc_encoded.slice(\n-                        link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET,\n-                        link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint);\n-\n-                    match flate::inflate_bytes(compressed_data) {\n-                        Some(inflated) => inflated,\n+        for i in iter::count(0u, 1) {\n+            let bc_encoded = time(sess.time_passes(),\n+                                  format!(\"check for {}.{}.bytecode.deflate\", name, i).as_slice(),\n+                                  (),\n+                                  |_| {\n+                                      archive.read(format!(\"{}.{}.bytecode.deflate\",\n+                                                           file, i).as_slice())\n+                                  });\n+            let bc_encoded = match bc_encoded {\n+                Some(data) => data,\n+                None => {\n+                    if i == 0 {\n+                        // No bitcode was found at all.\n+                        sess.fatal(format!(\"missing compressed bytecode in {}\",\n+                                           path.display()).as_slice());\n+                    }\n+                    // No more bitcode files to read.\n+                    break;\n+                },\n+            };\n+            let bc_extractor = if is_versioned_bytecode_format(bc_encoded) {\n+                |_| {\n+                    // Read the version\n+                    let version = extract_bytecode_format_version(bc_encoded);\n+\n+                    if version == 1 {\n+                        // The only version existing so far\n+                        let data_size = extract_compressed_bytecode_size_v1(bc_encoded);\n+                        let compressed_data = bc_encoded.slice(\n+                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET,\n+                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint);\n+\n+                        match flate::inflate_bytes(compressed_data) {\n+                            Some(inflated) => inflated,\n+                            None => {\n+                                sess.fatal(format!(\"failed to decompress bc of `{}`\",\n+                                                   name).as_slice())\n+                            }\n+                        }\n+                    } else {\n+                        sess.fatal(format!(\"Unsupported bytecode format version {}\",\n+                                           version).as_slice())\n+                    }\n+                }\n+            } else {\n+                // the object must be in the old, pre-versioning format, so simply\n+                // inflate everything and let LLVM decide if it can make sense of it\n+                |_| {\n+                    match flate::inflate_bytes(bc_encoded) {\n+                        Some(bc) => bc,\n                         None => {\n                             sess.fatal(format!(\"failed to decompress bc of `{}`\",\n                                                name).as_slice())\n                         }\n                     }\n-                } else {\n-                    sess.fatal(format!(\"Unsupported bytecode format version {}\",\n-                                       version).as_slice())\n                 }\n-            }\n-        } else {\n-            // the object must be in the old, pre-versioning format, so simply\n-            // inflate everything and let LLVM decide if it can make sense of it\n-            |_| {\n-                match flate::inflate_bytes(bc_encoded) {\n-                    Some(bc) => bc,\n-                    None => {\n-                        sess.fatal(format!(\"failed to decompress bc of `{}`\",\n-                                           name).as_slice())\n-                    }\n+            };\n+\n+            let bc_decoded = time(sess.time_passes(),\n+                                  format!(\"decode {}.{}.bc\", file, i).as_slice(),\n+                                  (),\n+                                  bc_extractor);\n+\n+            let ptr = bc_decoded.as_slice().as_ptr();\n+            debug!(\"linking {}, part {}\", name, i);\n+            time(sess.time_passes(),\n+                 format!(\"ll link {}.{}\", name, i).as_slice(),\n+                 (),\n+                 |()| unsafe {\n+                if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n+                                                        ptr as *const libc::c_char,\n+                                                        bc_decoded.len() as libc::size_t) {\n+                    write::llvm_err(sess.diagnostic().handler(),\n+                                    format!(\"failed to load bc of `{}`\",\n+                                            name.as_slice()));\n                 }\n-            }\n-        };\n-\n-        let bc_decoded = time(sess.time_passes(),\n-                              format!(\"decode {}.bc\", file).as_slice(),\n-                              (),\n-                              bc_extractor);\n-\n-        let ptr = bc_decoded.as_slice().as_ptr();\n-        debug!(\"linking {}\", name);\n-        time(sess.time_passes(),\n-             format!(\"ll link {}\", name).as_slice(),\n-             (),\n-             |()| unsafe {\n-            if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n-                                                    ptr as *const libc::c_char,\n-                                                    bc_decoded.len() as libc::size_t) {\n-                write::llvm_err(sess.diagnostic().handler(),\n-                                format!(\"failed to load bc of `{}`\",\n-                                        name.as_slice()));\n-            }\n-        });\n+            });\n+        }\n     }\n \n     // Internalize everything but the reachable symbols of the current module"}, {"sha": "7242c12ae0c7a1630ff704280f29e11629fff2ef", "filename": "src/librustc/back/write.rs", "status": "modified", "additions": 36, "deletions": 33, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fwrite.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -11,7 +11,7 @@\n use back::lto;\n use back::link::{get_cc_prog, remove};\n use driver::driver::{CrateTranslation, ModuleTranslation, OutputFilenames};\n-use driver::config::{NoDebugInfo, Passes, AllPasses};\n+use driver::config::{NoDebugInfo, Passes, SomePasses, AllPasses};\n use driver::session::Session;\n use driver::config;\n use llvm;\n@@ -341,7 +341,7 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n             let pass_name = pass_name.as_str().expect(\"got a non-UTF8 pass name from LLVM\");\n             let enabled = match cgcx.remark {\n                 AllPasses => true,\n-                Passes(ref v) => v.iter().any(|s| s.as_slice() == pass_name),\n+                SomePasses(ref v) => v.iter().any(|s| s.as_slice() == pass_name),\n             };\n \n             if enabled {\n@@ -482,14 +482,14 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         if config.emit_asm {\n             let path = output_names.with_extension(format!(\"{}.s\", name_extra).as_slice());\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::AssemblyFile);\n+                write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::AssemblyFileType);\n             });\n         }\n \n         if config.emit_obj {\n             let path = output_names.with_extension(format!(\"{}.o\", name_extra).as_slice());\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::ObjectFile);\n+                write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::ObjectFileType);\n             });\n         }\n     });\n@@ -540,13 +540,12 @@ pub fn run_passes(sess: &Session,\n         metadata_config.emit_bc = true;\n     }\n \n-    // Emit a bitcode file for the crate if we're emitting an rlib.\n+    // Emit bitcode files for the crate if we're emitting an rlib.\n     // Whenever an rlib is created, the bitcode is inserted into the\n     // archive in order to allow LTO against it.\n     let needs_crate_bitcode =\n             sess.crate_types.borrow().contains(&config::CrateTypeRlib) &&\n-            sess.opts.output_types.contains(&OutputTypeExe) &&\n-            sess.opts.cg.codegen_units == 1;\n+            sess.opts.output_types.contains(&OutputTypeExe);\n     if needs_crate_bitcode {\n         modules_config.emit_bc = true;\n     }\n@@ -602,19 +601,8 @@ pub fn run_passes(sess: &Session,\n     // Process the work items, optionally using worker threads.\n     if sess.opts.cg.codegen_units == 1 {\n         run_work_singlethreaded(sess, trans.reachable.as_slice(), work_items);\n-\n-        if needs_crate_bitcode {\n-            // The only bitcode file produced (aside from metadata) was\n-            // \"crate.0.bc\".  Rename to \"crate.bc\" since that's what\n-            // `link_rlib` expects to find.\n-            fs::copy(&crate_output.with_extension(\"0.bc\"),\n-                     &crate_output.temp_path(OutputTypeBitcode)).unwrap();\n-        }\n     } else {\n         run_work_multithreaded(sess, work_items, sess.opts.cg.codegen_units);\n-\n-        assert!(!needs_crate_bitcode,\n-               \"can't produce a crate bitcode file from multiple compilation units\");\n     }\n \n     // All codegen is finished.\n@@ -624,14 +612,14 @@ pub fn run_passes(sess: &Session,\n \n     // Produce final compile outputs.\n \n-    let copy_if_one_unit = |ext: &str, output_type: OutputType| {\n+    let copy_if_one_unit = |ext: &str, output_type: OutputType, keep_numbered: bool| {\n         // Three cases:\n         if sess.opts.cg.codegen_units == 1 {\n             // 1) Only one codegen unit.  In this case it's no difficulty\n             //    to copy `foo.0.x` to `foo.x`.\n             fs::copy(&crate_output.with_extension(ext),\n                      &crate_output.path(output_type)).unwrap();\n-            if !sess.opts.cg.save_temps {\n+            if !sess.opts.cg.save_temps && !keep_numbered {\n                 // The user just wants `foo.x`, not `foo.0.x`.\n                 remove(sess, &crate_output.with_extension(ext));\n             }\n@@ -716,17 +704,18 @@ pub fn run_passes(sess: &Session,\n     // Flag to indicate whether the user explicitly requested bitcode.\n     // Otherwise, we produced it only as a temporary output, and will need\n     // to get rid of it.\n-    // FIXME: Since we don't support LTO anyway, maybe we can avoid\n-    // producing the temporary .0.bc's in the first place?\n-    let mut save_bitcode = false;\n+    let mut user_wants_bitcode = false;\n     for output_type in output_types.iter() {\n         match *output_type {\n             OutputTypeBitcode => {\n-                save_bitcode = true;\n-                copy_if_one_unit(\"0.bc\", OutputTypeBitcode);\n+                user_wants_bitcode = true;\n+                // Copy to .bc, but always keep the .0.bc.  There is a later\n+                // check to figure out if we should delete .0.bc files, or keep\n+                // them for making an rlib.\n+                copy_if_one_unit(\"0.bc\", OutputTypeBitcode, true);\n             },\n-            OutputTypeLlvmAssembly => { copy_if_one_unit(\"0.ll\", OutputTypeLlvmAssembly); },\n-            OutputTypeAssembly => { copy_if_one_unit(\"0.s\", OutputTypeAssembly); },\n+            OutputTypeLlvmAssembly => { copy_if_one_unit(\"0.ll\", OutputTypeLlvmAssembly, false); },\n+            OutputTypeAssembly => { copy_if_one_unit(\"0.s\", OutputTypeAssembly, false); },\n             OutputTypeObject => { link_obj(&crate_output.path(OutputTypeObject)); },\n             OutputTypeExe => {\n                 // If OutputTypeObject is already in the list, then\n@@ -739,7 +728,7 @@ pub fn run_passes(sess: &Session,\n             },\n         }\n     }\n-    let save_bitcode = save_bitcode;\n+    let user_wants_bitcode = user_wants_bitcode;\n \n     // Clean up unwanted temporary files.\n \n@@ -755,22 +744,36 @@ pub fn run_passes(sess: &Session,\n \n     if !sess.opts.cg.save_temps {\n         // Remove the temporary .0.o objects.  If the user didn't\n-        // explicitly request bitcode (with --emit=bc), we must remove\n-        // .0.bc as well.  (We don't touch the crate.bc that may have been\n-        // produced earlier.)\n+        // explicitly request bitcode (with --emit=bc), and the bitcode is not\n+        // needed for building an rlib, then we must remove .0.bc as well.\n+\n+        // Specific rules for keeping .0.bc:\n+        //  - If we're building an rlib (`needs_crate_bitcode`), then keep\n+        //    it.\n+        //  - If the user requested bitcode (`user_wants_bitcode`), and\n+        //    codegen_units > 1, then keep it.\n+        //  - If the user requested bitcode but codegen_units == 1, then we\n+        //    can toss .0.bc because we copied it to .bc earlier.\n+        //  - If we're not building an rlib and the user didn't request\n+        //    bitcode, then delete .0.bc.\n+        // If you change how this works, also update back::link::link_rlib,\n+        // where .0.bc files are (maybe) deleted after making an rlib.\n+        let keep_numbered_bitcode = needs_crate_bitcode ||\n+                (user_wants_bitcode && sess.opts.cg.codegen_units > 1);\n+\n         for i in range(0, trans.modules.len()) {\n             if modules_config.emit_obj {\n                 let ext = format!(\"{}.o\", i);\n                 remove(sess, &crate_output.with_extension(ext.as_slice()));\n             }\n \n-            if modules_config.emit_bc && !save_bitcode {\n+            if modules_config.emit_bc && !keep_numbered_bitcode {\n                 let ext = format!(\"{}.bc\", i);\n                 remove(sess, &crate_output.with_extension(ext.as_slice()));\n             }\n         }\n \n-        if metadata_config.emit_bc && !save_bitcode {\n+        if metadata_config.emit_bc && !user_wants_bitcode {\n             remove(sess, &crate_output.with_extension(\"metadata.bc\"));\n         }\n     }"}, {"sha": "72e2d244ad333091c4f1e540108a9477f6a6e1be", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -237,14 +237,14 @@ pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {\n \n #[deriving(Clone)]\n pub enum Passes {\n-    Passes(Vec<String>),\n+    SomePasses(Vec<String>),\n     AllPasses,\n }\n \n impl Passes {\n     pub fn is_empty(&self) -> bool {\n         match *self {\n-            Passes(ref v) => v.is_empty(),\n+            SomePasses(ref v) => v.is_empty(),\n             AllPasses => false,\n         }\n     }\n@@ -276,7 +276,7 @@ macro_rules! cgoptions(\n         &[ $( (stringify!($opt), cgsetters::$opt, $desc) ),* ];\n \n     mod cgsetters {\n-        use super::{CodegenOptions, Passes, AllPasses};\n+        use super::{CodegenOptions, Passes, SomePasses, AllPasses};\n \n         $(\n             pub fn $opt(cg: &mut CodegenOptions, v: Option<&str>) -> bool {\n@@ -335,7 +335,7 @@ macro_rules! cgoptions(\n                 v => {\n                     let mut passes = vec!();\n                     if parse_list(&mut passes, v) {\n-                        *slot = Passes(passes);\n+                        *slot = SomePasses(passes);\n                         true\n                     } else {\n                         false\n@@ -389,7 +389,7 @@ cgoptions!(\n          \"extra data to put in each output filename\"),\n     codegen_units: uint = (1, parse_uint,\n         \"divide crate into N units to optimize in parallel\"),\n-    remark: Passes = (Passes(Vec::new()), parse_passes,\n+    remark: Passes = (SomePasses(Vec::new()), parse_passes,\n         \"print remarks for these optimization passes (space separated, or \\\"all\\\")\"),\n )\n "}, {"sha": "4ff9133c8a534e9748c2beabee67dec375118f63", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -17,7 +17,7 @@ use lint;\n use llvm::{ContextRef, ModuleRef};\n use metadata::common::LinkMeta;\n use metadata::creader;\n-use middle::{trans, freevars, stability, kind, ty, typeck, reachable};\n+use middle::{trans, stability, kind, ty, typeck, reachable};\n use middle::dependency_format;\n use middle;\n use plugin::load::Plugins;\n@@ -378,11 +378,13 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n                           middle::lang_items::collect_language_items(krate, &sess));\n \n     let middle::resolve::CrateMap {\n-        def_map: def_map,\n-        exp_map2: exp_map2,\n-        trait_map: trait_map,\n-        external_exports: external_exports,\n-        last_private_map: last_private_map\n+        def_map,\n+        freevars,\n+        capture_mode_map,\n+        exp_map2,\n+        trait_map,\n+        external_exports,\n+        last_private_map\n     } =\n         time(time_passes, \"resolution\", (), |_|\n              middle::resolve::resolve_crate(&sess, &lang_items, krate));\n@@ -401,10 +403,6 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n             plugin::build::find_plugin_registrar(\n                 sess.diagnostic(), krate)));\n \n-    let (freevars, capture_modes) =\n-        time(time_passes, \"freevar finding\", (), |_|\n-             freevars::annotate_freevars(&def_map, krate));\n-\n     let region_map = time(time_passes, \"region resolution\", (), |_|\n                           middle::region::resolve_crate(&sess, krate));\n \n@@ -423,7 +421,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n                             named_region_map,\n                             ast_map,\n                             freevars,\n-                            capture_modes,\n+                            capture_mode_map,\n                             region_map,\n                             lang_items,\n                             stability_index);"}, {"sha": "2994954c3d72726c64a5e6788caecb0a34babf6f", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -29,7 +29,7 @@ This API is completely unstable and subject to change.\n       html_root_url = \"http://doc.rust-lang.org/master/\")]\n \n #![allow(deprecated)]\n-#![feature(macro_rules, globs, struct_variant, managed_boxes, quote)]\n+#![feature(macro_rules, globs, struct_variant, quote)]\n #![feature(default_type_params, phase, unsafe_destructor)]\n \n #![allow(unknown_features)] // NOTE: Remove after next snapshot\n@@ -93,7 +93,6 @@ pub mod middle {\n     pub mod effect;\n     pub mod entry;\n     pub mod expr_use_visitor;\n-    pub mod freevars;\n     pub mod graph;\n     pub mod intrinsicck;\n     pub mod kind;"}, {"sha": "588e275455afe5d9e2d345b150dcf778d488f050", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -42,7 +42,7 @@ use syntax::abi;\n use syntax::ast_map;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, NO_EXPANSION};\n use syntax::parse::token;\n use syntax::{ast, ast_util, visit};\n use syntax::ptr::P;\n@@ -954,8 +954,7 @@ impl LintPass for NonSnakeCase {\n         match &p.node {\n             &ast::PatIdent(_, ref path1, _) => {\n                 match cx.tcx.def_map.borrow().find(&p.id) {\n-                    Some(&def::DefLocal(_, _)) | Some(&def::DefBinding(_, _)) |\n-                            Some(&def::DefArg(_, _)) => {\n+                    Some(&def::DefLocal(_)) => {\n                         self.check_snake_case(cx, \"variable\", path1.node, p.span);\n                     }\n                     _ => {}\n@@ -1297,7 +1296,7 @@ impl LintPass for UnnecessaryAllocation {\n         match cx.tcx.adjustments.borrow().find(&e.id) {\n             Some(adjustment) => {\n                 match *adjustment {\n-                    ty::AutoDerefRef(ty::AutoDerefRef { ref autoref, .. }) => {\n+                    ty::AdjustDerefRef(ty::AutoDerefRef { ref autoref, .. }) => {\n                         match (allocation, autoref) {\n                             (VectorAllocation, &Some(ty::AutoPtr(_, _, None))) => {\n                                 cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n@@ -1492,7 +1491,7 @@ impl LintPass for Stability {\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         // if the expression was produced by a macro expansion,\n-        if e.span.expn_info.is_some() { return }\n+        if e.span.expn_id != NO_EXPANSION { return }\n \n         let id = match e.node {\n             ast::ExprPath(..) | ast::ExprStruct(..) => {\n@@ -1512,12 +1511,12 @@ impl LintPass for Stability {\n                             typeck::MethodStaticUnboxedClosure(def_id) => {\n                                 def_id\n                             }\n-                            typeck::MethodParam(typeck::MethodParam {\n+                            typeck::MethodTypeParam(typeck::MethodParam {\n                                 trait_ref: ref trait_ref,\n                                 method_num: index,\n                                 ..\n                             }) |\n-                            typeck::MethodObject(typeck::MethodObject {\n+                            typeck::MethodTraitObject(typeck::MethodObject {\n                                 trait_ref: ref trait_ref,\n                                 method_num: index,\n                                 .."}, {"sha": "acb4f1be85ca2c799ff592e473f2b682e38dbbf2", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 35, "deletions": 40, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -18,13 +18,12 @@ use driver::session::Session;\n use metadata::decoder;\n use middle::def;\n use metadata::encoder as e;\n-use middle::freevars::{CaptureMode, freevar_entry};\n-use middle::freevars;\n use middle::region;\n use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter};\n use metadata::tydecode::{RegionParameter};\n use metadata::tyencode;\n+use middle::mem_categorization::Typer;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::typeck::{MethodCall, MethodCallee, MethodOrigin};\n@@ -42,7 +41,6 @@ use syntax;\n use libc;\n use std::io::Seek;\n use std::mem;\n-use std::gc::GC;\n use std::rc::Rc;\n \n use rbml::io::SeekableMemWriter;\n@@ -462,8 +460,7 @@ impl tr for def::Def {\n           def::DefMod(did) => { def::DefMod(did.tr(dcx)) }\n           def::DefForeignMod(did) => { def::DefForeignMod(did.tr(dcx)) }\n           def::DefStatic(did, m) => { def::DefStatic(did.tr(dcx), m) }\n-          def::DefArg(nid, b) => { def::DefArg(dcx.tr_id(nid), b) }\n-          def::DefLocal(nid, b) => { def::DefLocal(dcx.tr_id(nid), b) }\n+          def::DefLocal(nid) => { def::DefLocal(dcx.tr_id(nid)) }\n           def::DefVariant(e_did, v_did, is_s) => {\n             def::DefVariant(e_did.tr(dcx), v_did.tr(dcx), is_s)\n           },\n@@ -472,11 +469,9 @@ impl tr for def::Def {\n           def::DefAssociatedTy(did) => def::DefAssociatedTy(did.tr(dcx)),\n           def::DefPrimTy(p) => def::DefPrimTy(p),\n           def::DefTyParam(s, did, v) => def::DefTyParam(s, did.tr(dcx), v),\n-          def::DefBinding(nid, bm) => def::DefBinding(dcx.tr_id(nid), bm),\n           def::DefUse(did) => def::DefUse(did.tr(dcx)),\n-          def::DefUpvar(nid1, def, nid2, nid3) => {\n+          def::DefUpvar(nid1, nid2, nid3) => {\n             def::DefUpvar(dcx.tr_id(nid1),\n-                           box(GC) (*def).tr(dcx),\n                            dcx.tr_id(nid2),\n                            dcx.tr_id(nid3))\n           }\n@@ -541,36 +536,36 @@ impl tr for ty::TraitStore {\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n-fn encode_freevar_entry(rbml_w: &mut Encoder, fv: &freevar_entry) {\n+fn encode_freevar_entry(rbml_w: &mut Encoder, fv: &ty::Freevar) {\n     (*fv).encode(rbml_w).unwrap();\n }\n \n-fn encode_capture_mode(rbml_w: &mut Encoder, cm: CaptureMode) {\n+fn encode_capture_mode(rbml_w: &mut Encoder, cm: ast::CaptureClause) {\n     cm.encode(rbml_w).unwrap();\n }\n \n trait rbml_decoder_helper {\n     fn read_freevar_entry(&mut self, dcx: &DecodeContext)\n-                          -> freevar_entry;\n-    fn read_capture_mode(&mut self) -> CaptureMode;\n+                          -> ty::Freevar;\n+    fn read_capture_mode(&mut self) -> ast::CaptureClause;\n }\n \n impl<'a> rbml_decoder_helper for reader::Decoder<'a> {\n     fn read_freevar_entry(&mut self, dcx: &DecodeContext)\n-                          -> freevar_entry {\n-        let fv: freevar_entry = Decodable::decode(self).unwrap();\n+                          -> ty::Freevar {\n+        let fv: ty::Freevar = Decodable::decode(self).unwrap();\n         fv.tr(dcx)\n     }\n \n-    fn read_capture_mode(&mut self) -> CaptureMode {\n-        let cm: CaptureMode = Decodable::decode(self).unwrap();\n+    fn read_capture_mode(&mut self) -> ast::CaptureClause {\n+        let cm: ast::CaptureClause = Decodable::decode(self).unwrap();\n         cm\n     }\n }\n \n-impl tr for freevar_entry {\n-    fn tr(&self, dcx: &DecodeContext) -> freevar_entry {\n-        freevar_entry {\n+impl tr for ty::Freevar {\n+    fn tr(&self, dcx: &DecodeContext) -> ty::Freevar {\n+        ty::Freevar {\n             def: self.def.tr(dcx),\n             span: self.span.tr(dcx),\n         }\n@@ -646,17 +641,17 @@ impl tr for MethodOrigin {\n             typeck::MethodStaticUnboxedClosure(did) => {\n                 typeck::MethodStaticUnboxedClosure(did.tr(dcx))\n             }\n-            typeck::MethodParam(ref mp) => {\n-                typeck::MethodParam(\n+            typeck::MethodTypeParam(ref mp) => {\n+                typeck::MethodTypeParam(\n                     typeck::MethodParam {\n                         // def-id is already translated when we read it out\n                         trait_ref: mp.trait_ref.clone(),\n                         method_num: mp.method_num,\n                     }\n                 )\n             }\n-            typeck::MethodObject(ref mo) => {\n-                typeck::MethodObject(\n+            typeck::MethodTraitObject(ref mo) => {\n+                typeck::MethodTraitObject(\n                     typeck::MethodObject {\n                         trait_ref: mo.trait_ref.clone(),\n                         .. *mo\n@@ -962,8 +957,8 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n                     })\n                 }\n \n-                typeck::MethodParam(ref p) => {\n-                    this.emit_enum_variant(\"MethodParam\", 2, 1, |this| {\n+                typeck::MethodTypeParam(ref p) => {\n+                    this.emit_enum_variant(\"MethodTypeParam\", 2, 1, |this| {\n                         this.emit_struct(\"MethodParam\", 2, |this| {\n                             try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n                                 Ok(this.emit_trait_ref(ecx, &*p.trait_ref))\n@@ -976,8 +971,8 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n                     })\n                 }\n \n-                typeck::MethodObject(ref o) => {\n-                    this.emit_enum_variant(\"MethodObject\", 3, 1, |this| {\n+                typeck::MethodTraitObject(ref o) => {\n+                    this.emit_enum_variant(\"MethodTraitObject\", 3, 1, |this| {\n                         this.emit_struct(\"MethodObject\", 2, |this| {\n                             try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n                                 Ok(this.emit_trait_ref(ecx, &*o.trait_ref))\n@@ -1072,13 +1067,13 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n \n         self.emit_enum(\"AutoAdjustment\", |this| {\n             match *adj {\n-                ty::AutoAddEnv(store) => {\n+                ty::AdjustAddEnv(store) => {\n                     this.emit_enum_variant(\"AutoAddEnv\", 0, 1, |this| {\n                         this.emit_enum_variant_arg(0, |this| store.encode(this))\n                     })\n                 }\n \n-                ty::AutoDerefRef(ref auto_deref_ref) => {\n+                ty::AdjustDerefRef(ref auto_deref_ref) => {\n                     this.emit_enum_variant(\"AutoDerefRef\", 1, 1, |this| {\n                         this.emit_enum_variant_arg(0,\n                             |this| Ok(this.emit_auto_deref_ref(ecx, auto_deref_ref)))\n@@ -1292,8 +1287,8 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         });\n \n         for freevar in fv.iter() {\n-            match freevars::get_capture_mode(tcx, id) {\n-                freevars::CaptureByRef => {\n+            match tcx.capture_mode(id) {\n+                ast::CaptureByRef => {\n                     rbml_w.tag(c::tag_table_upvar_borrow_map, |rbml_w| {\n                         rbml_w.id(id);\n                         rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1374,7 +1369,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                     })\n                 }\n             }\n-            ty::AutoDerefRef(ref adj) => {\n+            ty::AdjustDerefRef(ref adj) => {\n                 assert!(!ty::adjust_is_object(adjustment));\n                 for autoderef in range(0, adj.autoderefs) {\n                     let method_call = MethodCall::autoderef(id, autoderef);\n@@ -1505,7 +1500,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n     {\n         self.read_enum(\"MethodOrigin\", |this| {\n             let variants = [\"MethodStatic\", \"MethodStaticUnboxedClosure\",\n-                            \"MethodParam\", \"MethodObject\"];\n+                            \"MethodTypeParam\", \"MethodTraitObject\"];\n             this.read_enum_variant(variants, |this, i| {\n                 Ok(match i {\n                     0 => {\n@@ -1519,8 +1514,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                     }\n \n                     2 => {\n-                        this.read_struct(\"MethodParam\", 2, |this| {\n-                            Ok(typeck::MethodParam(\n+                        this.read_struct(\"MethodTypeParam\", 2, |this| {\n+                            Ok(typeck::MethodTypeParam(\n                                 typeck::MethodParam {\n                                     trait_ref: {\n                                         this.read_struct_field(\"trait_ref\", 0, |this| {\n@@ -1537,8 +1532,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                     }\n \n                     3 => {\n-                        this.read_struct(\"MethodObject\", 2, |this| {\n-                            Ok(typeck::MethodObject(\n+                        this.read_struct(\"MethodTraitObject\", 2, |this| {\n+                            Ok(typeck::MethodTraitObject(\n                                 typeck::MethodObject {\n                                     trait_ref: {\n                                         this.read_struct_field(\"trait_ref\", 0, |this| {\n@@ -1685,14 +1680,14 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                         let store: ty::TraitStore =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n \n-                        ty::AutoAddEnv(store.tr(dcx))\n+                        ty::AdjustAddEnv(store.tr(dcx))\n                     }\n                     1 => {\n                         let auto_deref_ref: ty::AutoDerefRef =\n                             this.read_enum_variant_arg(0,\n                                 |this| Ok(this.read_auto_deref_ref(dcx))).unwrap();\n \n-                        ty::AutoDerefRef(auto_deref_ref)\n+                        ty::AdjustDerefRef(auto_deref_ref)\n                     }\n                     _ => fail!(\"bad enum variant for ty::AutoAdjustment\")\n                 })\n@@ -2035,7 +2030,7 @@ impl fake_ext_ctxt for parse::ParseSess {\n         codemap::Span {\n             lo: codemap::BytePos(0),\n             hi: codemap::BytePos(0),\n-            expn_info: None\n+            expn_id: codemap::NO_EXPANSION\n         }\n     }\n     fn ident_of(&self, st: &str) -> ast::Ident {"}, {"sha": "95009bc2dbfc084ce661f3a809afa6b070032207", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -514,9 +514,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         true\n     }\n \n-    pub fn is_local_variable_or_arg(&self, cmt: mc::cmt) -> bool {\n+    fn is_local_variable_or_arg(&self, cmt: mc::cmt) -> bool {\n         match cmt.cat {\n-          mc::cat_local(_) | mc::cat_arg(_) => true,\n+          mc::cat_local(_) => true,\n           _ => false\n         }\n     }\n@@ -775,7 +775,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 debug!(\"mark_variable_as_used_mut(cmt={})\", cmt.repr(this.tcx()));\n                 match cmt.cat.clone() {\n                     mc::cat_copied_upvar(mc::CopiedUpvar { upvar_id: id, .. }) |\n-                    mc::cat_local(id) | mc::cat_arg(id) => {\n+                    mc::cat_local(id) => {\n                         this.tcx().used_mut_nodes.borrow_mut().insert(id);\n                         return;\n                     }"}, {"sha": "25439fce68c9f1936412018c10bad0b27a4d7965", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -147,8 +147,7 @@ fn check_and_get_illegal_move_origin(bccx: &BorrowckCtxt,\n         }\n \n         mc::cat_rvalue(..) |\n-        mc::cat_local(..) |\n-        mc::cat_arg(..) => {\n+        mc::cat_local(..) => {\n             None\n         }\n "}, {"sha": "c07123325253b37bd4bbb7d6b1da67698a3afd90", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -69,7 +69,6 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n             mc::cat_rvalue(..) |\n             mc::cat_copied_upvar(..) |                  // L-Local\n             mc::cat_local(..) |                         // L-Local\n-            mc::cat_arg(..) |                           // L-Local\n             mc::cat_upvar(..) |\n             mc::cat_deref(_, _, mc::BorrowedPtr(..)) |  // L-Deref-Borrowed\n             mc::cat_deref(_, _, mc::Implicit(..)) |\n@@ -174,8 +173,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n             mc::cat_static_item => {\n                 ty::ReStatic\n             }\n-            mc::cat_local(local_id) |\n-            mc::cat_arg(local_id) => {\n+            mc::cat_local(local_id) => {\n                 ty::ReScope(self.bccx.tcx.region_maps.var_scope(local_id))\n             }\n             mc::cat_deref(_, _, mc::UnsafePtr(..)) => {"}, {"sha": "e0018919b9823f57b4946d183991e3d64defe5f5", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -66,8 +66,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 Safe\n             }\n \n-            mc::cat_local(local_id) |\n-            mc::cat_arg(local_id) => {\n+            mc::cat_local(local_id) => {\n                 // R-Variable, locally declared\n                 let lp = Rc::new(LpVar(local_id));\n                 SafeIf(lp.clone(), vec![lp])"}, {"sha": "e1e37b3d371a5461b47999c7f0fa7c3d817b6be6", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -321,8 +321,7 @@ pub fn opt_loan_path(cmt: &mc::cmt) -> Option<Rc<LoanPath>> {\n             None\n         }\n \n-        mc::cat_local(id) |\n-        mc::cat_arg(id) => {\n+        mc::cat_local(id) => {\n             Some(Rc::new(LpVar(id)))\n         }\n \n@@ -425,12 +424,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                adj: &ty::AutoAdjustment)\n                                -> mc::cmt {\n         let r = match *adj {\n-            ty::AutoDerefRef(\n+            ty::AdjustDerefRef(\n                 ty::AutoDerefRef {\n                     autoderefs: autoderefs, ..}) => {\n                 self.mc().cat_expr_autoderefd(expr, autoderefs)\n             }\n-            ty::AutoAddEnv(..) => {\n+            ty::AdjustAddEnv(..) => {\n                 // no autoderefs\n                 self.mc().cat_expr_unadjusted(expr)\n             }"}, {"sha": "b268c2a7a518b7ae08f975a3542453c82c74f7c5", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -424,6 +424,13 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.call(expr, pred, &**l, Some(&**r).into_iter())\n             }\n \n+            ast::ExprSlice(ref base, ref start, ref end, _) => {\n+                self.call(expr,\n+                          pred,\n+                          &**base,\n+                          start.iter().chain(end.iter()).map(|x| &**x))\n+            }\n+\n             ast::ExprUnary(_, ref e) if self.is_method_call(expr) => {\n                 self.call(expr, pred, &**e, None::<ast::Expr>.iter())\n             }"}, {"sha": "345b8c8837253cb5e38893560b96aca3fc729bf4", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -101,12 +101,12 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                         }\n                     }\n                     typeck::MethodStaticUnboxedClosure(_) => {}\n-                    typeck::MethodParam(typeck::MethodParam {\n+                    typeck::MethodTypeParam(typeck::MethodParam {\n                         trait_ref: ref trait_ref,\n                         method_num: index,\n                         ..\n                     }) |\n-                    typeck::MethodObject(typeck::MethodObject {\n+                    typeck::MethodTraitObject(typeck::MethodObject {\n                         trait_ref: ref trait_ref,\n                         method_num: index,\n                         .."}, {"sha": "1863a19b56d02ad462992580a00b7b1c49a423b4", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -12,8 +12,6 @@ use middle::subst::ParamSpace;\n use syntax::ast;\n use syntax::ast_util::local_def;\n \n-use std::gc::Gc;\n-\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Def {\n     DefFn(ast::DefId, ast::FnStyle),\n@@ -22,20 +20,18 @@ pub enum Def {\n     DefMod(ast::DefId),\n     DefForeignMod(ast::DefId),\n     DefStatic(ast::DefId, bool /* is_mutbl */),\n-    DefArg(ast::NodeId, ast::BindingMode),\n-    DefLocal(ast::NodeId, ast::BindingMode),\n+    DefLocal(ast::NodeId),\n     DefVariant(ast::DefId /* enum */, ast::DefId /* variant */, bool /* is_structure */),\n     DefTy(ast::DefId, bool /* is_enum */),\n     DefAssociatedTy(ast::DefId),\n     DefTrait(ast::DefId),\n     DefPrimTy(ast::PrimTy),\n     DefTyParam(ParamSpace, ast::DefId, uint),\n-    DefBinding(ast::NodeId, ast::BindingMode),\n     DefUse(ast::DefId),\n-    DefUpvar(ast::NodeId,  // id of closed over var\n-             Gc<Def>,     // closed over def\n+    DefUpvar(ast::NodeId,  // id of closed over local\n              ast::NodeId,  // expr node that creates the closure\n-             ast::NodeId), // id for the block/body of the closure expr\n+             ast::NodeId), // block node for the closest enclosing proc\n+                           // or unboxed closure, DUMMY_NODE_ID otherwise\n \n     /// Note that if it's a tuple struct's definition, the node id of the ast::DefId\n     /// may either refer to the item definition's id or the StructDef.ctor_id.\n@@ -68,11 +64,9 @@ impl Def {\n             DefMethod(id, _) => {\n                 id\n             }\n-            DefArg(id, _) |\n-            DefLocal(id, _) |\n+            DefLocal(id) |\n             DefSelfTy(id) |\n-            DefUpvar(id, _, _, _) |\n-            DefBinding(id, _) |\n+            DefUpvar(id, _, _) |\n             DefRegion(id) |\n             DefTyParamBinder(id) |\n             DefLabel(id) => {"}, {"sha": "0b4f661a16ab2c75c0eaaf2f3ae32f179da6eebf", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -16,10 +16,11 @@\n \n use middle::mem_categorization as mc;\n use middle::def;\n-use middle::freevars;\n+use middle::mem_categorization::Typer;\n use middle::pat_util;\n use middle::ty;\n-use middle::typeck::{MethodCall, MethodObject, MethodOrigin, MethodParam};\n+use middle::typeck::{MethodCall, MethodObject, MethodTraitObject};\n+use middle::typeck::{MethodOrigin, MethodParam, MethodTypeParam};\n use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure};\n use middle::typeck;\n use util::ppaux::Repr;\n@@ -177,8 +178,8 @@ impl OverloadedCallType {\n             MethodStaticUnboxedClosure(def_id) => {\n                 OverloadedCallType::from_unboxed_closure(tcx, def_id)\n             }\n-            MethodParam(MethodParam { trait_ref: ref trait_ref, .. }) |\n-            MethodObject(MethodObject { trait_ref: ref trait_ref, .. }) => {\n+            MethodTypeParam(MethodParam { trait_ref: ref trait_ref, .. }) |\n+            MethodTraitObject(MethodObject { trait_ref: ref trait_ref, .. }) => {\n                 OverloadedCallType::from_trait_id(tcx, trait_ref.def_id)\n             }\n         }\n@@ -316,7 +317,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n             ast::ExprPath(..) => { }\n \n             ast::ExprUnary(ast::UnDeref, ref base) => {      // *base\n-                if !self.walk_overloaded_operator(expr, &**base, None) {\n+                if !self.walk_overloaded_operator(expr, &**base, Vec::new()) {\n                     self.select_from_expr(&**base);\n                 }\n             }\n@@ -330,12 +331,23 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n             }\n \n             ast::ExprIndex(ref lhs, ref rhs) => {       // lhs[rhs]\n-                if !self.walk_overloaded_operator(expr, &**lhs, Some(&**rhs)) {\n+                if !self.walk_overloaded_operator(expr, &**lhs, vec![&**rhs]) {\n                     self.select_from_expr(&**lhs);\n                     self.consume_expr(&**rhs);\n                 }\n             }\n \n+            ast::ExprSlice(ref base, ref start, ref end, _) => {    // base[start..end]\n+                let args = match (start, end) {\n+                    (&Some(ref e1), &Some(ref e2)) => vec![&**e1, &**e2],\n+                    (&Some(ref e), &None) => vec![&**e],\n+                    (&None, &Some(ref e)) => vec![&**e],\n+                    (&None, &None) => Vec::new()\n+                };\n+                let overloaded = self.walk_overloaded_operator(expr, &**base, args);\n+                assert!(overloaded);\n+            }\n+\n             ast::ExprCall(ref callee, ref args) => {    // callee(args)\n                 self.walk_callee(expr, &**callee);\n                 self.consume_exprs(args);\n@@ -430,13 +442,13 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n             }\n \n             ast::ExprUnary(_, ref lhs) => {\n-                if !self.walk_overloaded_operator(expr, &**lhs, None) {\n+                if !self.walk_overloaded_operator(expr, &**lhs, Vec::new()) {\n                     self.consume_expr(&**lhs);\n                 }\n             }\n \n             ast::ExprBinary(_, ref lhs, ref rhs) => {\n-                if !self.walk_overloaded_operator(expr, &**lhs, Some(&**rhs)) {\n+                if !self.walk_overloaded_operator(expr, &**lhs, vec![&**rhs]) {\n                     self.consume_expr(&**lhs);\n                     self.consume_expr(&**rhs);\n                 }\n@@ -673,15 +685,15 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n             None => { }\n             Some(adjustment) => {\n                 match *adjustment {\n-                    ty::AutoAddEnv(..) => {\n+                    ty::AdjustAddEnv(..) => {\n                         // Creating a closure consumes the input and stores it\n                         // into the resulting rvalue.\n                         debug!(\"walk_adjustment(AutoAddEnv)\");\n                         let cmt_unadjusted =\n                             return_if_err!(self.mc.cat_expr_unadjusted(expr));\n                         self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n                     }\n-                    ty::AutoDerefRef(ty::AutoDerefRef {\n+                    ty::AdjustDerefRef(ty::AutoDerefRef {\n                         autoref: ref opt_autoref,\n                         autoderefs: n\n                     }) => {\n@@ -774,7 +786,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n     fn walk_overloaded_operator(&mut self,\n                                 expr: &ast::Expr,\n                                 receiver: &ast::Expr,\n-                                rhs: Option<&ast::Expr>)\n+                                rhs: Vec<&ast::Expr>)\n                                 -> bool\n     {\n         if !self.typer.is_method_call(expr.id) {\n@@ -911,12 +923,12 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n         debug!(\"walk_captures({})\", closure_expr.repr(self.tcx()));\n \n         let tcx = self.typer.tcx();\n-        freevars::with_freevars(tcx, closure_expr.id, |freevars| {\n-            match freevars::get_capture_mode(self.tcx(), closure_expr.id) {\n-                freevars::CaptureByRef => {\n+        ty::with_freevars(tcx, closure_expr.id, |freevars| {\n+            match self.tcx().capture_mode(closure_expr.id) {\n+                ast::CaptureByRef => {\n                     self.walk_by_ref_captures(closure_expr, freevars);\n                 }\n-                freevars::CaptureByValue => {\n+                ast::CaptureByValue => {\n                     self.walk_by_value_captures(closure_expr, freevars);\n                 }\n             }\n@@ -925,7 +937,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n \n     fn walk_by_ref_captures(&mut self,\n                             closure_expr: &ast::Expr,\n-                            freevars: &[freevars::freevar_entry]) {\n+                            freevars: &[ty::Freevar]) {\n         for freevar in freevars.iter() {\n             let id_var = freevar.def.def_id().node;\n             let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n@@ -950,7 +962,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n \n     fn walk_by_value_captures(&mut self,\n                               closure_expr: &ast::Expr,\n-                              freevars: &[freevars::freevar_entry]) {\n+                              freevars: &[ty::Freevar]) {\n         for freevar in freevars.iter() {\n             let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n                                                                closure_expr.span,"}, {"sha": "5b7c72208ea7d181976aa2d0a0913c425352dbdf", "filename": "src/librustc/middle/freevars.rs", "status": "removed", "additions": 0, "deletions": 190, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e880fffb8e09b15bc6fc41d5b23f21bf5056d/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e880fffb8e09b15bc6fc41d5b23f21bf5056d/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=3b6e880fffb8e09b15bc6fc41d5b23f21bf5056d", "patch": "@@ -1,190 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// A pass that annotates for each loops and functions with the free\n-// variables that they contain.\n-\n-#![allow(non_camel_case_types)]\n-\n-use middle::def;\n-use middle::mem_categorization::Typer;\n-use middle::resolve;\n-use middle::ty;\n-use util::nodemap::{NodeMap, NodeSet};\n-\n-use syntax::ast;\n-use syntax::codemap::Span;\n-use syntax::visit::Visitor;\n-use syntax::visit;\n-\n-#[deriving(Clone, Decodable, Encodable, Show)]\n-pub enum CaptureMode {\n-    /// Copy/move the value from this llvm ValueRef into the environment.\n-    CaptureByValue,\n-\n-    /// Access by reference (used for stack closures).\n-    CaptureByRef\n-}\n-\n-// A vector of defs representing the free variables referred to in a function.\n-// (The def_upvar will already have been stripped).\n-#[deriving(Encodable, Decodable)]\n-pub struct freevar_entry {\n-    pub def: def::Def, //< The variable being accessed free.\n-    pub span: Span     //< First span where it is accessed (there can be multiple)\n-}\n-\n-pub type freevar_map = NodeMap<Vec<freevar_entry>>;\n-\n-pub type CaptureModeMap = NodeMap<CaptureMode>;\n-\n-struct CollectFreevarsVisitor<'a> {\n-    seen: NodeSet,\n-    refs: Vec<freevar_entry>,\n-    def_map: &'a resolve::DefMap,\n-    capture_mode_map: &'a mut CaptureModeMap,\n-    depth: uint\n-}\n-\n-impl<'a, 'v> Visitor<'v> for CollectFreevarsVisitor<'a> {\n-    fn visit_item(&mut self, _: &ast::Item) {\n-        // ignore_item\n-    }\n-\n-    fn visit_expr(&mut self, expr: &ast::Expr) {\n-        match expr.node {\n-            ast::ExprProc(..) => {\n-                self.capture_mode_map.insert(expr.id, CaptureByValue);\n-                self.depth += 1;\n-                visit::walk_expr(self, expr);\n-                self.depth -= 1;\n-            }\n-            ast::ExprFnBlock(_, _, _) => {\n-                // NOTE(stage0): After snapshot, change to:\n-                //\n-                //let capture_mode = match capture_clause {\n-                //    ast::CaptureByValue => CaptureByValue,\n-                //    ast::CaptureByRef => CaptureByRef,\n-                //};\n-                let capture_mode = CaptureByRef;\n-                self.capture_mode_map.insert(expr.id, capture_mode);\n-                self.depth += 1;\n-                visit::walk_expr(self, expr);\n-                self.depth -= 1;\n-            }\n-            ast::ExprUnboxedFn(capture_clause, _, _, _) => {\n-                let capture_mode = match capture_clause {\n-                    ast::CaptureByValue => CaptureByValue,\n-                    ast::CaptureByRef => CaptureByRef,\n-                };\n-                self.capture_mode_map.insert(expr.id, capture_mode);\n-                self.depth += 1;\n-                visit::walk_expr(self, expr);\n-                self.depth -= 1;\n-            }\n-            ast::ExprPath(..) => {\n-                let mut def = *self.def_map.borrow().find(&expr.id)\n-                                                    .expect(\"path not found\");\n-                let mut i = 0;\n-                while i < self.depth {\n-                    match def {\n-                        def::DefUpvar(_, inner, _, _) => { def = *inner; }\n-                        _ => break\n-                    }\n-                    i += 1;\n-                }\n-                if i == self.depth { // Made it to end of loop\n-                    let dnum = def.def_id().node;\n-                    if !self.seen.contains(&dnum) {\n-                        self.refs.push(freevar_entry {\n-                            def: def,\n-                            span: expr.span,\n-                        });\n-                        self.seen.insert(dnum);\n-                    }\n-                }\n-            }\n-            _ => visit::walk_expr(self, expr)\n-        }\n-    }\n-}\n-\n-// Searches through part of the AST for all references to locals or\n-// upvars in this frame and returns the list of definition IDs thus found.\n-// Since we want to be able to collect upvars in some arbitrary piece\n-// of the AST, we take a walker function that we invoke with a visitor\n-// in order to start the search.\n-fn collect_freevars(def_map: &resolve::DefMap,\n-                    blk: &ast::Block,\n-                    capture_mode_map: &mut CaptureModeMap)\n-                    -> Vec<freevar_entry> {\n-    let mut v = CollectFreevarsVisitor {\n-        seen: NodeSet::new(),\n-        refs: Vec::new(),\n-        def_map: def_map,\n-        capture_mode_map: &mut *capture_mode_map,\n-        depth: 1\n-    };\n-\n-    v.visit_block(blk);\n-\n-    v.refs\n-}\n-\n-struct AnnotateFreevarsVisitor<'a> {\n-    def_map: &'a resolve::DefMap,\n-    freevars: freevar_map,\n-    capture_mode_map: CaptureModeMap,\n-}\n-\n-impl<'a, 'v> Visitor<'v> for AnnotateFreevarsVisitor<'a> {\n-    fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n-                blk: &'v ast::Block, s: Span, nid: ast::NodeId) {\n-        let vars = collect_freevars(self.def_map,\n-                                    blk,\n-                                    &mut self.capture_mode_map);\n-        self.freevars.insert(nid, vars);\n-        visit::walk_fn(self, fk, fd, blk, s);\n-    }\n-}\n-\n-// Build a map from every function and for-each body to a set of the\n-// freevars contained in it. The implementation is not particularly\n-// efficient as it fully recomputes the free variables at every\n-// node of interest rather than building up the free variables in\n-// one pass. This could be improved upon if it turns out to matter.\n-pub fn annotate_freevars(def_map: &resolve::DefMap, krate: &ast::Crate)\n-                         -> (freevar_map, CaptureModeMap) {\n-    let mut visitor = AnnotateFreevarsVisitor {\n-        def_map: def_map,\n-        freevars: NodeMap::new(),\n-        capture_mode_map: NodeMap::new(),\n-    };\n-    visit::walk_crate(&mut visitor, krate);\n-\n-    let AnnotateFreevarsVisitor {\n-        freevars,\n-        capture_mode_map,\n-        ..\n-    } = visitor;\n-    (freevars, capture_mode_map)\n-}\n-\n-pub fn with_freevars<T>(tcx: &ty::ctxt, fid: ast::NodeId, f: |&[freevar_entry]| -> T) -> T {\n-    match tcx.freevars.borrow().find(&fid) {\n-        None => fail!(\"with_freevars: {} has no freevars\", fid),\n-        Some(d) => f(d.as_slice())\n-    }\n-}\n-\n-pub fn get_capture_mode<'tcx, T:Typer<'tcx>>(tcx: &T, closure_expr_id: ast::NodeId)\n-                                             -> CaptureMode {\n-    tcx.capture_mode(closure_expr_id)\n-}"}, {"sha": "4a5b2e01463ad93aaa070cc14480c68caec2bd7a", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::freevars::freevar_entry;\n-use middle::freevars;\n use middle::mem_categorization::Typer;\n use middle::subst;\n use middle::ty;\n@@ -146,10 +144,10 @@ fn check_item(cx: &mut Context, item: &Item) {\n fn with_appropriate_checker(cx: &Context,\n                             id: NodeId,\n                             fn_span: Span,\n-                            b: |checker: |&Context, &freevar_entry||) {\n+                            b: |checker: |&Context, &ty::Freevar||) {\n     fn check_for_uniq(cx: &Context,\n                       fn_span: Span,\n-                      fv: &freevar_entry,\n+                      fv: &ty::Freevar,\n                       bounds: ty::BuiltinBounds) {\n         // all captured data must be owned, regardless of whether it is\n         // moved in or copied in.\n@@ -162,7 +160,7 @@ fn with_appropriate_checker(cx: &Context,\n     fn check_for_block(cx: &Context,\n                        fn_span: Span,\n                        fn_id: NodeId,\n-                       fv: &freevar_entry,\n+                       fv: &ty::Freevar,\n                        bounds: ty::BuiltinBounds) {\n         let id = fv.def.def_id().node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n@@ -177,7 +175,7 @@ fn with_appropriate_checker(cx: &Context,\n                              bounds, Some(var_t));\n     }\n \n-    fn check_for_bare(cx: &Context, fv: &freevar_entry) {\n+    fn check_for_bare(cx: &Context, fv: &ty::Freevar) {\n         span_err!(cx.tcx.sess, fv.span, E0143,\n                   \"can't capture dynamic environment in a fn item; \\\n                    use the || {} closure form instead\", \"{ ... }\");\n@@ -227,7 +225,7 @@ fn check_fn(\n \n     // <Check kinds on free variables:\n     with_appropriate_checker(cx, fn_id, sp, |chk| {\n-        freevars::with_freevars(cx.tcx, fn_id, |freevars| {\n+        ty::with_freevars(cx.tcx, fn_id, |freevars| {\n             for fv in freevars.iter() {\n                 chk(cx, fv);\n             }\n@@ -274,6 +272,7 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n \n     visit::walk_expr(cx, e);\n }\n+\n fn check_ty(cx: &mut Context, aty: &Ty) {\n     match aty.node {\n         TyPath(_, _, id) => {"}, {"sha": "daba3b701c03bdac4e8907a6040e04b903f21a51", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -247,6 +247,8 @@ lets_do_this! {\n     ShrTraitLangItem,                \"shr\",                     shr_trait;\n     IndexTraitLangItem,              \"index\",                   index_trait;\n     IndexMutTraitLangItem,           \"index_mut\",               index_mut_trait;\n+    SliceTraitLangItem,              \"slice\",                   slice_trait;\n+    SliceMutTraitLangItem,           \"slice_mut\",               slice_mut_trait;\n \n     UnsafeTypeLangItem,              \"unsafe\",                  unsafe_type;\n "}, {"sha": "b6893a6a3b41925100f5f110eba322e79c146e41", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 29, "deletions": 41, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -103,7 +103,6 @@\n  */\n \n use middle::def::*;\n-use middle::freevars;\n use middle::mem_categorization::Typer;\n use middle::pat_util;\n use middle::ty;\n@@ -116,6 +115,7 @@ use std::mem::transmute;\n use std::rc::Rc;\n use std::str;\n use std::uint;\n+use syntax::ast;\n use syntax::ast::*;\n use syntax::codemap::{BytePos, original_sp, Span};\n use syntax::parse::token::special_idents;\n@@ -183,7 +183,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IrMaps<'a, 'tcx> {\n                 b: &'v Block, s: Span, n: NodeId) {\n         visit_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_local(&mut self, l: &Local) { visit_local(self, l); }\n+    fn visit_local(&mut self, l: &ast::Local) { visit_local(self, l); }\n     fn visit_expr(&mut self, ex: &Expr) { visit_expr(self, ex); }\n     fn visit_arm(&mut self, a: &Arm) { visit_arm(self, a); }\n }\n@@ -346,7 +346,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Liveness<'a, 'tcx> {\n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Block, s: Span, n: NodeId) {\n         check_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_local(&mut self, l: &Local) {\n+    fn visit_local(&mut self, l: &ast::Local) {\n         check_local(self, l);\n     }\n     fn visit_expr(&mut self, ex: &Expr) {\n@@ -408,7 +408,7 @@ fn visit_fn(ir: &mut IrMaps,\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n \n-fn visit_local(ir: &mut IrMaps, local: &Local) {\n+fn visit_local(ir: &mut IrMaps, local: &ast::Local) {\n     pat_util::pat_bindings(&ir.tcx.def_map, &*local.pat, |_, p_id, sp, path1| {\n         debug!(\"adding local variable {}\", p_id);\n         let name = path1.node;\n@@ -437,24 +437,15 @@ fn visit_arm(ir: &mut IrMaps, arm: &Arm) {\n     visit::walk_arm(ir, arm);\n }\n \n-fn moved_variable_node_id_from_def(def: Def) -> Option<NodeId> {\n-    match def {\n-        DefBinding(nid, _) |\n-        DefArg(nid, _) |\n-        DefLocal(nid, _) => Some(nid),\n-\n-      _ => None\n-    }\n-}\n-\n fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       ExprPath(_) => {\n         let def = ir.tcx.def_map.borrow().get_copy(&expr.id);\n         debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n-        if moved_variable_node_id_from_def(def).is_some() {\n-            ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n+        match def {\n+            DefLocal(..) => ir.add_live_node_for_node(expr.id, ExprNode(expr.span)),\n+            _ => {}\n         }\n         visit::walk_expr(ir, expr);\n       }\n@@ -468,15 +459,15 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         // in better error messages than just pointing at the closure\n         // construction site.\n         let mut call_caps = Vec::new();\n-        freevars::with_freevars(ir.tcx, expr.id, |freevars| {\n+        ty::with_freevars(ir.tcx, expr.id, |freevars| {\n             for fv in freevars.iter() {\n-                match moved_variable_node_id_from_def(fv.def) {\n-                    Some(rv) => {\n+                match fv.def {\n+                    DefLocal(rv) => {\n                         let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n                         call_caps.push(CaptureInfo {ln: fv_ln,\n                                                     var_nid: rv});\n                     }\n-                    None => {}\n+                    _ => {}\n                 }\n             }\n         });\n@@ -511,7 +502,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n \n       // otherwise, live nodes are not required:\n       ExprIndex(..) | ExprField(..) | ExprTupField(..) | ExprVec(..) |\n-      ExprCall(..) | ExprMethodCall(..) | ExprTup(..) |\n+      ExprCall(..) | ExprMethodCall(..) | ExprTup(..) | ExprSlice(..) |\n       ExprBinary(..) | ExprAddrOf(..) |\n       ExprCast(..) | ExprUnary(..) | ExprBreak(_) |\n       ExprAgain(_) | ExprLit(_) | ExprRet(..) | ExprBlock(..) |\n@@ -913,7 +904,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn propagate_through_local(&mut self, local: &Local, succ: LiveNode)\n+    fn propagate_through_local(&mut self, local: &ast::Local, succ: LiveNode)\n                                -> LiveNode {\n         // Note: we mark the variable as defined regardless of whether\n         // there is an initializer.  Initially I had thought to only mark\n@@ -1184,6 +1175,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&**l, r_succ)\n           }\n \n+          ExprSlice(ref e1, ref e2, ref e3, _) => {\n+            let succ = e3.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ));\n+            let succ = e2.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ));\n+            self.propagate_through_expr(&**e1, succ)\n+          }\n+\n           ExprAddrOf(_, ref e) |\n           ExprCast(ref e, _) |\n           ExprUnary(_, ref e) |\n@@ -1296,9 +1293,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: uint)\n                    -> LiveNode {\n-        let def = self.ir.tcx.def_map.borrow().get_copy(&expr.id);\n-        match moved_variable_node_id_from_def(def) {\n-          Some(nid) => {\n+        match self.ir.tcx.def_map.borrow().get_copy(&expr.id) {\n+          DefLocal(nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0u {\n                 self.init_from_succ(ln, succ);\n@@ -1307,7 +1303,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n             ln\n           }\n-          None => succ\n+          _ => succ\n         }\n     }\n \n@@ -1403,7 +1399,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n // _______________________________________________________________________\n // Checking for error conditions\n \n-fn check_local(this: &mut Liveness, local: &Local) {\n+fn check_local(this: &mut Liveness, local: &ast::Local) {\n     match local.init {\n         Some(_) => {\n             this.warn_about_unused_or_dead_vars_in_pat(&*local.pat);\n@@ -1468,7 +1464,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ExprWhile(..) | ExprLoop(..) | ExprIndex(..) | ExprField(..) |\n       ExprTupField(..) | ExprVec(..) | ExprTup(..) | ExprBinary(..) |\n       ExprCast(..) | ExprUnary(..) | ExprRet(..) | ExprBreak(..) |\n-      ExprAgain(..) | ExprLit(_) | ExprBlock(..) |\n+      ExprAgain(..) | ExprLit(_) | ExprBlock(..) | ExprSlice(..) |\n       ExprMac(..) | ExprAddrOf(..) | ExprStruct(..) | ExprRepeat(..) |\n       ExprParen(..) | ExprFnBlock(..) | ExprProc(..) | ExprUnboxedFn(..) |\n       ExprPath(..) | ExprBox(..) => {\n@@ -1520,11 +1516,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     sp, \"not all control paths return a value\");\n                 if ends_with_stmt {\n                     let last_stmt = body.stmts.last().unwrap();\n-                    let original_span = original_sp(last_stmt.span, sp);\n+                    let original_span = original_sp(self.ir.tcx.sess.codemap(),\n+                                                    last_stmt.span, sp);\n                     let span_semicolon = Span {\n                         lo: original_span.hi - BytePos(1),\n                         hi: original_span.hi,\n-                        expn_info: original_span.expn_info\n+                        expn_id: original_span.expn_id\n                     };\n                     self.ir.tcx.sess.span_note(\n                         span_semicolon, \"consider removing this semicolon:\");\n@@ -1537,7 +1534,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         match expr.node {\n           ExprPath(_) => {\n             match self.ir.tcx.def_map.borrow().get_copy(&expr.id) {\n-              DefLocal(nid, _) => {\n+              DefLocal(nid) => {\n                 // Assignment to an immutable variable or argument: only legal\n                 // if there is no later assignment. If this local is actually\n                 // mutable, then check for a reassignment to flag the mutability\n@@ -1546,16 +1543,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 let var = self.variable(nid, expr.span);\n                 self.warn_about_dead_assign(expr.span, expr.id, ln, var);\n               }\n-              def => {\n-                match moved_variable_node_id_from_def(def) {\n-                  Some(nid) => {\n-                    let ln = self.live_node(expr.id, expr.span);\n-                    let var = self.variable(nid, expr.span);\n-                    self.warn_about_dead_assign(expr.span, expr.id, ln, var);\n-                  }\n-                  None => {}\n-                }\n-              }\n+              _ => {}\n             }\n           }\n "}, {"sha": "6350fa6a5068713dbb52c748b40caeba8738456a", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 33, "deletions": 59, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -63,14 +63,14 @@\n #![allow(non_camel_case_types)]\n \n use middle::def;\n-use middle::freevars;\n use middle::ty;\n use middle::typeck;\n use util::nodemap::{DefIdMap, NodeMap};\n use util::ppaux::{ty_to_string, Repr};\n \n use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n+use syntax::ast_map;\n use syntax::codemap::Span;\n use syntax::print::pprust;\n use syntax::parse::token;\n@@ -85,7 +85,6 @@ pub enum categorization {\n     cat_copied_upvar(CopiedUpvar),     // upvar copied into proc env\n     cat_upvar(ty::UpvarId, ty::UpvarBorrow), // by ref upvar from stack closure\n     cat_local(ast::NodeId),            // local variable\n-    cat_arg(ast::NodeId),              // formal argument\n     cat_deref(cmt, uint, PointerKind), // deref of a ptr\n     cat_interior(cmt, InteriorKind),   // something interior: field, tuple, etc\n     cat_downcast(cmt),                 // selects a particular enum variant (*1)\n@@ -273,7 +272,7 @@ pub trait Typer<'tcx> {\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<ast::NodeId>;\n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow;\n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> freevars::CaptureMode;\n+                    -> ast::CaptureClause;\n     fn unboxed_closures<'a>(&'a self)\n                         -> &'a RefCell<DefIdMap<ty::UnboxedClosure>>;\n }\n@@ -312,28 +311,19 @@ impl MutabilityCategory {\n         }\n     }\n \n-    fn from_def(def: &def::Def) -> MutabilityCategory {\n-        match *def {\n-            def::DefFn(..) | def::DefStaticMethod(..) | def::DefSelfTy(..) |\n-            def::DefMod(..) | def::DefForeignMod(..) | def::DefVariant(..) |\n-            def::DefTy(..) | def::DefTrait(..) | def::DefPrimTy(..) |\n-            def::DefTyParam(..) | def::DefUse(..) | def::DefStruct(..) |\n-            def::DefTyParamBinder(..) | def::DefRegion(..) | def::DefLabel(..) |\n-            def::DefMethod(..) | def::DefAssociatedTy(..) => {\n-                fail!(\"no MutabilityCategory for def: {}\", *def)\n-            }\n-\n-            def::DefStatic(_, false) => McImmutable,\n-            def::DefStatic(_, true) => McDeclared,\n-\n-            def::DefArg(_, binding_mode) |\n-            def::DefBinding(_, binding_mode) |\n-            def::DefLocal(_, binding_mode)  => match binding_mode {\n-                ast::BindByValue(ast::MutMutable) => McDeclared,\n-                _ => McImmutable\n+    fn from_local(tcx: &ty::ctxt, id: ast::NodeId) -> MutabilityCategory {\n+        match tcx.map.get(id) {\n+            ast_map::NodeLocal(p) | ast_map::NodeArg(p) => match p.node {\n+                ast::PatIdent(bind_mode, _, _) => {\n+                    if bind_mode == ast::BindByValue(ast::MutMutable) {\n+                        McDeclared\n+                    } else {\n+                        McImmutable\n+                    }\n+                }\n+                _ => tcx.sess.span_bug(p.span, \"expected identifier pattern\")\n             },\n-\n-            def::DefUpvar(_, def, _, _) => MutabilityCategory::from_def(&*def)\n+            _ => tcx.sess.span_bug(tcx.map.span(id), \"expected identifier pattern\")\n         }\n     }\n \n@@ -414,14 +404,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n             Some(adjustment) => {\n                 match *adjustment {\n-                    ty::AutoAddEnv(..) => {\n+                    ty::AdjustAddEnv(..) => {\n                         // Convert a bare fn to a closure by adding NULL env.\n                         // Result is an rvalue.\n                         let expr_ty = if_ok!(self.expr_ty_adjusted(expr));\n                         Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n                     }\n \n-                    ty::AutoDerefRef(\n+                    ty::AdjustDerefRef(\n                         ty::AutoDerefRef {\n                             autoref: Some(_), ..}) => {\n                         // Equivalent to &*expr or something similar.\n@@ -430,7 +420,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                         Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n                     }\n \n-                    ty::AutoDerefRef(\n+                    ty::AdjustDerefRef(\n                         ty::AutoDerefRef {\n                             autoref: None, autoderefs: autoderefs}) => {\n                         // Equivalent to *expr or something similar.\n@@ -504,7 +494,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::ExprAssign(..) | ast::ExprAssignOp(..) |\n           ast::ExprFnBlock(..) | ast::ExprProc(..) |\n           ast::ExprUnboxedFn(..) | ast::ExprRet(..) |\n-          ast::ExprUnary(..) |\n+          ast::ExprUnary(..) | ast::ExprSlice(..) |\n           ast::ExprMethodCall(..) | ast::ExprCast(..) |\n           ast::ExprVec(..) | ast::ExprTup(..) | ast::ExprIf(..) |\n           ast::ExprBinary(..) | ast::ExprWhile(..) |\n@@ -546,30 +536,17 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n               }))\n           }\n \n-          def::DefStatic(_, _) => {\n+          def::DefStatic(_, mutbl) => {\n               Ok(Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n                   cat:cat_static_item,\n-                  mutbl: MutabilityCategory::from_def(&def),\n+                  mutbl: if mutbl { McDeclared } else { McImmutable},\n                   ty:expr_ty\n               }))\n           }\n \n-          def::DefArg(vid, _) => {\n-            // Idea: make this could be rewritten to model by-ref\n-            // stuff as `&const` and `&mut`?\n-\n-            Ok(Rc::new(cmt_ {\n-                id: id,\n-                span: span,\n-                cat: cat_arg(vid),\n-                mutbl: MutabilityCategory::from_def(&def),\n-                ty:expr_ty\n-            }))\n-          }\n-\n-          def::DefUpvar(var_id, _, fn_node_id, _) => {\n+          def::DefUpvar(var_id, fn_node_id, _) => {\n               let ty = if_ok!(self.node_ty(fn_node_id));\n               match ty::get(ty).sty {\n                   ty::ty_closure(ref closure_ty) => {\n@@ -597,7 +574,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                   onceness: closure_ty.onceness,\n                                   capturing_proc: fn_node_id,\n                               }),\n-                              mutbl: MutabilityCategory::from_def(&def),\n+                              mutbl: MutabilityCategory::from_local(self.tcx(), var_id),\n                               ty:expr_ty\n                           }))\n                       }\n@@ -620,7 +597,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                               onceness: onceness,\n                               capturing_proc: fn_node_id,\n                           }),\n-                          mutbl: MutabilityCategory::from_def(&def),\n+                          mutbl: MutabilityCategory::from_local(self.tcx(), var_id),\n                           ty: expr_ty\n                       }))\n                   }\n@@ -634,14 +611,12 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n               }\n           }\n \n-          def::DefLocal(vid, _) |\n-          def::DefBinding(vid, _) => {\n-            // by-value/by-ref bindings are local variables\n+          def::DefLocal(vid) => {\n             Ok(Rc::new(cmt_ {\n                 id: id,\n                 span: span,\n                 cat: cat_local(vid),\n-                mutbl: MutabilityCategory::from_def(&def),\n+                mutbl: MutabilityCategory::from_local(self.tcx(), vid),\n                 ty: expr_ty\n             }))\n           }\n@@ -1196,11 +1171,13 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           cat_rvalue(..) => {\n               \"non-lvalue\".to_string()\n           }\n-          cat_local(_) => {\n-              \"local variable\".to_string()\n-          }\n-          cat_arg(..) => {\n-              \"argument\".to_string()\n+          cat_local(vid) => {\n+              match self.tcx().map.find(vid) {\n+                  Some(ast_map::NodeArg(_)) => {\n+                      \"argument\".to_string()\n+                  }\n+                  _ => \"local variable\".to_string()\n+              }\n           }\n           cat_deref(ref base, _, pk) => {\n               match base.cat {\n@@ -1267,7 +1244,6 @@ impl cmt_ {\n             cat_static_item |\n             cat_copied_upvar(..) |\n             cat_local(..) |\n-            cat_arg(..) |\n             cat_deref(_, _, UnsafePtr(..)) |\n             cat_deref(_, _, GcPtr(..)) |\n             cat_deref(_, _, BorrowedPtr(..)) |\n@@ -1311,7 +1287,6 @@ impl cmt_ {\n             cat_rvalue(..) |\n             cat_local(..) |\n             cat_upvar(..) |\n-            cat_arg(_) |\n             cat_deref(_, _, UnsafePtr(..)) => { // yes, it's aliasable, but...\n                 None\n             }\n@@ -1363,8 +1338,7 @@ impl Repr for categorization {\n             cat_rvalue(..) |\n             cat_copied_upvar(..) |\n             cat_local(..) |\n-            cat_upvar(..) |\n-            cat_arg(..) => {\n+            cat_upvar(..) => {\n                 format!(\"{:?}\", *self)\n             }\n             cat_deref(ref cmt, derefs, ptr) => {"}, {"sha": "36778e7cfc32c91dd4e0189e5f2df3b06730f57a", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -19,8 +19,8 @@ use middle::def;\n use lint;\n use middle::resolve;\n use middle::ty;\n-use middle::typeck::{MethodCall, MethodMap, MethodOrigin, MethodParam};\n-use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure, MethodObject};\n+use middle::typeck::{MethodCall, MethodMap, MethodOrigin, MethodParam, MethodTypeParam};\n+use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure, MethodObject, MethodTraitObject};\n use util::nodemap::{NodeMap, NodeSet};\n \n use syntax::ast;\n@@ -829,8 +829,8 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             MethodStaticUnboxedClosure(_) => {}\n             // Trait methods are always all public. The only controlling factor\n             // is whether the trait itself is accessible or not.\n-            MethodParam(MethodParam { trait_ref: ref trait_ref, .. }) |\n-            MethodObject(MethodObject { trait_ref: ref trait_ref, .. }) => {\n+            MethodTypeParam(MethodParam { trait_ref: ref trait_ref, .. }) |\n+            MethodTraitObject(MethodObject { trait_ref: ref trait_ref, .. }) => {\n                 self.report_error(self.ensure_public(span, trait_ref.def_id,\n                                                      None, \"source trait\"));\n             }"}, {"sha": "11ea84c75d39f7b9888db2c65406506fc73fae10", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 206, "deletions": 165, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -19,7 +19,8 @@ use middle::lang_items::LanguageItems;\n use middle::pat_util::pat_bindings;\n use middle::subst::{ParamSpace, FnSpace, TypeSpace};\n use middle::ty::{ExplicitSelfCategory, StaticExplicitSelfCategory};\n-use util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n+use middle::ty::{CaptureModeMap, Freevar, FreevarMap};\n+use util::nodemap::{NodeMap, NodeSet, DefIdSet, FnvHashMap};\n \n use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block, Crate, CrateNum};\n use syntax::ast::{DeclItem, DefId, Expr, ExprAgain, ExprBreak, ExprField};\n@@ -28,7 +29,7 @@ use syntax::ast::{ExprPath, ExprProc, ExprStruct, ExprUnboxedFn, FnDecl};\n use syntax::ast::{ForeignItem, ForeignItemFn, ForeignItemStatic, Generics};\n use syntax::ast::{Ident, ImplItem, Item, ItemEnum, ItemFn, ItemForeignMod};\n use syntax::ast::{ItemImpl, ItemMac, ItemMod, ItemStatic, ItemStruct};\n-use syntax::ast::{ItemTrait, ItemTy, LOCAL_CRATE, Local, Method};\n+use syntax::ast::{ItemTrait, ItemTy, LOCAL_CRATE, Local};\n use syntax::ast::{MethodImplItem, Mod, Name, NamedField, NodeId};\n use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n use syntax::ast::{PatRange, PatStruct, Path, PathListIdent, PathListMod};\n@@ -59,7 +60,6 @@ use syntax::visit::Visitor;\n \n use std::collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n-use std::gc::GC;\n use std::mem::replace;\n use std::rc::{Rc, Weak};\n use std::uint;\n@@ -270,16 +270,16 @@ enum TypeParameters<'a> {\n         RibKind)\n }\n \n-// The rib kind controls the translation of argument or local definitions\n-// (`def_arg` or `def_local`) to upvars (`def_upvar`).\n+// The rib kind controls the translation of local\n+// definitions (`DefLocal`) to upvars (`DefUpvar`).\n \n enum RibKind {\n     // No translation needs to be applied.\n     NormalRibKind,\n \n-    // We passed through a function scope at the given node ID. Translate\n-    // upvars as appropriate.\n-    FunctionRibKind(NodeId /* func id */, NodeId /* body id */),\n+    // We passed through a closure scope at the given node ID.\n+    // Translate upvars as appropriate.\n+    ClosureRibKind(NodeId /* func id */, NodeId /* body id if proc or unboxed */),\n \n     // We passed through an impl or trait and are now in one of its\n     // methods. Allow references to ty params that impl or trait\n@@ -891,6 +891,9 @@ struct Resolver<'a> {\n     primitive_type_table: PrimitiveTypeTable,\n \n     def_map: DefMap,\n+    freevars: RefCell<FreevarMap>,\n+    freevars_seen: RefCell<NodeMap<NodeSet>>,\n+    capture_mode_map: RefCell<CaptureModeMap>,\n     export_map2: ExportMap2,\n     trait_map: TraitMap,\n     external_exports: ExternalExports,\n@@ -996,6 +999,9 @@ impl<'a> Resolver<'a> {\n             primitive_type_table: PrimitiveTypeTable::new(),\n \n             def_map: RefCell::new(NodeMap::new()),\n+            freevars: RefCell::new(NodeMap::new()),\n+            freevars_seen: RefCell::new(NodeMap::new()),\n+            capture_mode_map: RefCell::new(NodeMap::new()),\n             export_map2: RefCell::new(NodeMap::new()),\n             trait_map: NodeMap::new(),\n             used_imports: HashSet::new(),\n@@ -1523,33 +1529,31 @@ impl<'a> Resolver<'a> {\n     }\n \n     // Constructs the reduced graph for one variant. Variants exist in the\n-    // type and/or value namespaces.\n+    // type and value namespaces.\n     fn build_reduced_graph_for_variant(&mut self,\n                                        variant: &Variant,\n                                        item_id: DefId,\n                                        parent: ReducedGraphParent,\n                                        is_public: bool) {\n         let ident = variant.node.name;\n-\n-        match variant.node.kind {\n-            TupleVariantKind(_) => {\n-                let child = self.add_child(ident, parent, ForbidDuplicateValues, variant.span);\n-                child.define_value(DefVariant(item_id,\n-                                              local_def(variant.node.id), false),\n-                                   variant.span, is_public);\n-            }\n+        let is_exported = match variant.node.kind {\n+            TupleVariantKind(_) => false,\n             StructVariantKind(_) => {\n-                let child = self.add_child(ident, parent,\n-                                           ForbidDuplicateTypesAndValues,\n-                                           variant.span);\n-                child.define_type(DefVariant(item_id,\n-                                             local_def(variant.node.id), true),\n-                                  variant.span, is_public);\n-\n                 // Not adding fields for variants as they are not accessed with a self receiver\n                 self.structs.insert(local_def(variant.node.id), Vec::new());\n+                true\n             }\n-        }\n+        };\n+\n+        let child = self.add_child(ident, parent,\n+                                   ForbidDuplicateTypesAndValues,\n+                                   variant.span);\n+        child.define_value(DefVariant(item_id,\n+                                      local_def(variant.node.id), is_exported),\n+                           variant.span, is_public);\n+        child.define_type(DefVariant(item_id,\n+                                     local_def(variant.node.id), is_exported),\n+                          variant.span, is_public);\n     }\n \n     /// Constructs the reduced graph for one 'view item'. View items consist\n@@ -1895,8 +1899,7 @@ impl<'a> Resolver<'a> {\n                       ignoring {:?}\", def);\n               // Ignored; handled elsewhere.\n           }\n-          DefArg(..) | DefLocal(..) | DefPrimTy(..) |\n-          DefTyParam(..) | DefBinding(..) |\n+          DefLocal(..) | DefPrimTy(..) | DefTyParam(..) |\n           DefUse(..) | DefUpvar(..) | DefRegion(..) |\n           DefTyParamBinder(..) | DefLabel(..) | DefSelfTy(..) => {\n             fail!(\"didn't expect `{:?}`\", def);\n@@ -3828,155 +3831,164 @@ impl<'a> Resolver<'a> {\n         self.current_module = orig_module;\n     }\n \n-    /// Wraps the given definition in the appropriate number of `def_upvar`\n+    /// Wraps the given definition in the appropriate number of `DefUpvar`\n     /// wrappers.\n     fn upvarify(&self,\n                 ribs: &[Rib],\n-                rib_index: uint,\n                 def_like: DefLike,\n                 span: Span)\n                 -> Option<DefLike> {\n-        let mut def;\n-        let is_ty_param;\n-\n         match def_like {\n-            DlDef(d @ DefLocal(..)) | DlDef(d @ DefUpvar(..)) |\n-            DlDef(d @ DefArg(..)) | DlDef(d @ DefBinding(..)) => {\n-                def = d;\n-                is_ty_param = false;\n-            }\n-            DlDef(d @ DefTyParam(..)) |\n-            DlDef(d @ DefSelfTy(..)) => {\n-                def = d;\n-                is_ty_param = true;\n-            }\n-            _ => {\n-                return Some(def_like);\n-            }\n-        }\n+            DlDef(d @ DefUpvar(..)) => {\n+                self.session.span_bug(span,\n+                    format!(\"unexpected {} in bindings\", d).as_slice())\n+            }\n+            DlDef(d @ DefLocal(_)) => {\n+                let node_id = d.def_id().node;\n+                let mut def = d;\n+                let mut last_proc_body_id = ast::DUMMY_NODE_ID;\n+                for rib in ribs.iter() {\n+                    match rib.kind {\n+                        NormalRibKind => {\n+                            // Nothing to do. Continue.\n+                        }\n+                        ClosureRibKind(function_id, maybe_proc_body) => {\n+                            let prev_def = def;\n+                            if maybe_proc_body != ast::DUMMY_NODE_ID {\n+                                last_proc_body_id = maybe_proc_body;\n+                            }\n+                            def = DefUpvar(node_id, function_id, last_proc_body_id);\n \n-        let mut rib_index = rib_index + 1;\n-        while rib_index < ribs.len() {\n-            match ribs[rib_index].kind {\n-                NormalRibKind => {\n-                    // Nothing to do. Continue.\n-                }\n-                FunctionRibKind(function_id, body_id) => {\n-                    if !is_ty_param {\n-                        def = DefUpvar(def.def_id().node,\n-                                       box(GC) def,\n-                                       function_id,\n-                                       body_id);\n-                    }\n-                }\n-                MethodRibKind(item_id, _) => {\n-                  // If the def is a ty param, and came from the parent\n-                  // item, it's ok\n-                  match def {\n-                    DefTyParam(_, did, _) if {\n-                        self.def_map.borrow().find(&did.node).map(|x| *x)\n-                            == Some(DefTyParamBinder(item_id))\n-                    } => {\n-                      // ok\n-                    }\n+                            let mut seen = self.freevars_seen.borrow_mut();\n+                            let seen = seen.find_or_insert(function_id, NodeSet::new());\n+                            if seen.contains(&node_id) {\n+                                continue;\n+                            }\n+                            self.freevars.borrow_mut().find_or_insert(function_id, vec![])\n+                                         .push(Freevar { def: prev_def, span: span });\n+                            seen.insert(node_id);\n+                        }\n+                        MethodRibKind(item_id, _) => {\n+                            // If the def is a ty param, and came from the parent\n+                            // item, it's ok\n+                            match def {\n+                                DefTyParam(_, did, _) if {\n+                                    self.def_map.borrow().find_copy(&did.node)\n+                                        == Some(DefTyParamBinder(item_id))\n+                                } => {} // ok\n+                                DefSelfTy(did) if did == item_id => {} // ok\n+                                _ => {\n+                                    // This was an attempt to access an upvar inside a\n+                                    // named function item. This is not allowed, so we\n+                                    // report an error.\n \n-                    DefSelfTy(did) if {\n-                        did == item_id\n-                    } => {\n-                      // ok\n-                    }\n+                                    self.resolve_error(\n+                                        span,\n+                                        \"can't capture dynamic environment in a fn item; \\\n+                                        use the || { ... } closure form instead\");\n \n-                    _ => {\n-                    if !is_ty_param {\n-                        // This was an attempt to access an upvar inside a\n-                        // named function item. This is not allowed, so we\n-                        // report an error.\n+                                    return None;\n+                                }\n+                            }\n+                        }\n+                        ItemRibKind => {\n+                            // This was an attempt to access an upvar inside a\n+                            // named function item. This is not allowed, so we\n+                            // report an error.\n \n-                        self.resolve_error(\n-                            span,\n-                            \"can't capture dynamic environment in a fn item; \\\n-                            use the || { ... } closure form instead\");\n-                    } else {\n-                        // This was an attempt to use a type parameter outside\n-                        // its scope.\n+                            self.resolve_error(\n+                                span,\n+                                \"can't capture dynamic environment in a fn item; \\\n+                                use the || { ... } closure form instead\");\n \n-                        self.resolve_error(span,\n-                                              \"can't use type parameters from \\\n-                                              outer function; try using a local \\\n-                                              type parameter instead\");\n-                    }\n+                            return None;\n+                        }\n+                        ConstantItemRibKind => {\n+                            // Still doesn't deal with upvars\n+                            self.resolve_error(span,\n+                                               \"attempt to use a non-constant \\\n+                                                value in a constant\");\n \n-                    return None;\n+                        }\n                     }\n-                  }\n                 }\n-                ItemRibKind => {\n-                    if !is_ty_param {\n-                        // This was an attempt to access an upvar inside a\n-                        // named function item. This is not allowed, so we\n-                        // report an error.\n+                Some(DlDef(def))\n+            }\n+            DlDef(def @ DefTyParam(..)) |\n+            DlDef(def @ DefSelfTy(..)) => {\n+                for rib in ribs.iter() {\n+                    match rib.kind {\n+                        NormalRibKind | ClosureRibKind(..) => {\n+                            // Nothing to do. Continue.\n+                        }\n+                        MethodRibKind(item_id, _) => {\n+                            // If the def is a ty param, and came from the parent\n+                            // item, it's ok\n+                            match def {\n+                                DefTyParam(_, did, _) if {\n+                                    self.def_map.borrow().find_copy(&did.node)\n+                                        == Some(DefTyParamBinder(item_id))\n+                                } => {} // ok\n+                                DefSelfTy(did) if did == item_id => {} // ok\n \n-                        self.resolve_error(\n-                            span,\n-                            \"can't capture dynamic environment in a fn item; \\\n-                            use the || { ... } closure form instead\");\n-                    } else {\n-                        // This was an attempt to use a type parameter outside\n-                        // its scope.\n+                                _ => {\n+                                    // This was an attempt to use a type parameter outside\n+                                    // its scope.\n \n-                        self.resolve_error(span,\n-                                              \"can't use type parameters from \\\n-                                              outer function; try using a local \\\n-                                              type parameter instead\");\n-                    }\n+                                    self.resolve_error(span,\n+                                                        \"can't use type parameters from \\\n+                                                        outer function; try using a local \\\n+                                                        type parameter instead\");\n \n-                    return None;\n-                }\n-                ConstantItemRibKind => {\n-                    if is_ty_param {\n-                        // see #9186\n-                        self.resolve_error(span,\n-                                              \"cannot use an outer type \\\n-                                               parameter in this context\");\n-                    } else {\n-                        // Still doesn't deal with upvars\n-                        self.resolve_error(span,\n-                                              \"attempt to use a non-constant \\\n-                                               value in a constant\");\n-                    }\n+                                    return None;\n+                                }\n+                            }\n+                        }\n+                        ItemRibKind => {\n+                            // This was an attempt to use a type parameter outside\n+                            // its scope.\n+\n+                            self.resolve_error(span,\n+                                               \"can't use type parameters from \\\n+                                                outer function; try using a local \\\n+                                                type parameter instead\");\n \n+                            return None;\n+                        }\n+                        ConstantItemRibKind => {\n+                            // see #9186\n+                            self.resolve_error(span,\n+                                               \"cannot use an outer type \\\n+                                                parameter in this context\");\n+\n+                        }\n+                    }\n                 }\n+                Some(DlDef(def))\n             }\n-\n-            rib_index += 1;\n+            _ => Some(def_like)\n         }\n-\n-        return Some(DlDef(def));\n     }\n \n     fn search_ribs(&self,\n                    ribs: &[Rib],\n                    name: Name,\n                    span: Span)\n                    -> Option<DefLike> {\n-        // FIXME #4950: This should not use a while loop.\n         // FIXME #4950: Try caching?\n \n-        let mut i = ribs.len();\n-        while i != 0 {\n-            i -= 1;\n-            let binding_opt = ribs[i].bindings.borrow().find_copy(&name);\n-            match binding_opt {\n+        for (i, rib) in ribs.iter().enumerate().rev() {\n+            match rib.bindings.borrow().find_copy(&name) {\n                 Some(def_like) => {\n-                    return self.upvarify(ribs, i, def_like, span);\n+                    return self.upvarify(ribs.slice_from(i + 1), def_like, span);\n                 }\n                 None => {\n                     // Continue.\n                 }\n             }\n         }\n \n-        return None;\n+        None\n     }\n \n     fn resolve_crate(&mut self, krate: &ast::Crate) {\n@@ -4328,6 +4340,34 @@ impl<'a> Resolver<'a> {\n                 self.resolve_trait_reference(id, tref, reference_type)\n             }\n             UnboxedFnTyParamBound(ref unboxed_function) => {\n+                match self.resolve_path(unboxed_function.ref_id,\n+                                        &unboxed_function.path,\n+                                        TypeNS,\n+                                        true) {\n+                    None => {\n+                        let path_str = self.path_idents_to_string(\n+                            &unboxed_function.path);\n+                        self.resolve_error(unboxed_function.path.span,\n+                                           format!(\"unresolved trait `{}`\",\n+                                                   path_str).as_slice())\n+                    }\n+                    Some(def) => {\n+                        match def {\n+                            (DefTrait(_), _) => {\n+                                self.record_def(unboxed_function.ref_id, def);\n+                            }\n+                            _ => {\n+                                let msg =\n+                                    format!(\"`{}` is not a trait\",\n+                                            self.path_idents_to_string(\n+                                                &unboxed_function.path));\n+                                self.resolve_error(unboxed_function.path.span,\n+                                                   msg.as_slice());\n+                            }\n+                        }\n+                    }\n+                }\n+\n                 for argument in unboxed_function.decl.inputs.iter() {\n                     self.resolve_type(&*argument.ty);\n                 }\n@@ -4471,7 +4511,7 @@ impl<'a> Resolver<'a> {\n     // to be NormalRibKind?\n     fn resolve_method(&mut self,\n                       rib_kind: RibKind,\n-                      method: &Method) {\n+                      method: &ast::Method) {\n         let method_generics = method.pe_generics();\n         let type_parameters = HasTypeParameters(method_generics,\n                                                 FnSpace,\n@@ -4942,22 +4982,7 @@ impl<'a> Resolver<'a> {\n                             debug!(\"(resolving pattern) binding `{}`\",\n                                    token::get_name(renamed));\n \n-                            let def = match mode {\n-                                RefutableMode => {\n-                                    // For pattern arms, we must use\n-                                    // `def_binding` definitions.\n-\n-                                    DefBinding(pattern.id, binding_mode)\n-                                }\n-                                LocalIrrefutableMode => {\n-                                    // But for locals, we use `def_local`.\n-                                    DefLocal(pattern.id, binding_mode)\n-                                }\n-                                ArgumentIrrefutableMode => {\n-                                    // And for function arguments, `def_arg`.\n-                                    DefArg(pattern.id, binding_mode)\n-                                }\n-                            };\n+                            let def = DefLocal(pattern.id);\n \n                             // Record the definition so that later passes\n                             // will be able to distinguish variants from\n@@ -5775,10 +5800,24 @@ impl<'a> Resolver<'a> {\n                 visit::walk_expr(self, expr);\n             }\n \n-            ExprFnBlock(_, ref fn_decl, ref block) |\n-            ExprProc(ref fn_decl, ref block) |\n-            ExprUnboxedFn(_, _, ref fn_decl, ref block) => {\n-                self.resolve_function(FunctionRibKind(expr.id, block.id),\n+            ExprFnBlock(_, ref fn_decl, ref block) => {\n+                // NOTE(stage0): After snapshot, change to:\n+                //\n+                //self.capture_mode_map.borrow_mut().insert(expr.id, capture_clause);\n+                self.capture_mode_map.borrow_mut().insert(expr.id, ast::CaptureByRef);\n+                self.resolve_function(ClosureRibKind(expr.id, ast::DUMMY_NODE_ID),\n+                                      Some(&**fn_decl), NoTypeParameters,\n+                                      &**block);\n+            }\n+            ExprProc(ref fn_decl, ref block) => {\n+                self.capture_mode_map.borrow_mut().insert(expr.id, ast::CaptureByValue);\n+                self.resolve_function(ClosureRibKind(expr.id, block.id),\n+                                      Some(&**fn_decl), NoTypeParameters,\n+                                      &**block);\n+            }\n+            ExprUnboxedFn(capture_clause, _, ref fn_decl, ref block) => {\n+                self.capture_mode_map.borrow_mut().insert(expr.id, capture_clause);\n+                self.resolve_function(ClosureRibKind(expr.id, block.id),\n                                       Some(&**fn_decl), NoTypeParameters,\n                                       &**block);\n             }\n@@ -6209,6 +6248,8 @@ impl<'a> Resolver<'a> {\n \n pub struct CrateMap {\n     pub def_map: DefMap,\n+    pub freevars: RefCell<FreevarMap>,\n+    pub capture_mode_map: RefCell<CaptureModeMap>,\n     pub exp_map2: ExportMap2,\n     pub trait_map: TraitMap,\n     pub external_exports: ExternalExports,\n@@ -6222,13 +6263,13 @@ pub fn resolve_crate(session: &Session,\n                   -> CrateMap {\n     let mut resolver = Resolver::new(session, krate.span);\n     resolver.resolve(krate);\n-    let Resolver { def_map, export_map2, trait_map, last_private,\n-                   external_exports, .. } = resolver;\n     CrateMap {\n-        def_map: def_map,\n-        exp_map2: export_map2,\n-        trait_map: trait_map,\n-        external_exports: external_exports,\n-        last_private_map: last_private,\n+        def_map: resolver.def_map,\n+        freevars: resolver.freevars,\n+        capture_mode_map: resolver.capture_mode_map,\n+        exp_map2: resolver.export_map2,\n+        trait_map: resolver.trait_map,\n+        external_exports: resolver.external_exports,\n+        last_private_map: resolver.last_private,\n     }\n }"}, {"sha": "0f4ed202ec20750c9b80030fd92db4b841d4d188", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 20, "deletions": 29, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -71,7 +71,7 @@ fn escape(s: String) -> String {\n \n // If the expression is a macro expansion or other generated code, run screaming and don't index.\n fn generated_code(span: Span) -> bool {\n-    span.expn_info.is_some() || span  == DUMMY_SP\n+    span.expn_id != NO_EXPANSION || span  == DUMMY_SP\n }\n \n struct DxrVisitor<'l, 'tcx: 'l> {\n@@ -230,11 +230,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefAssociatedTy(..) |\n             def::DefTrait(_) => Some(recorder::TypeRef),\n             def::DefStatic(_, _) |\n-            def::DefBinding(_, _) |\n-            def::DefArg(_, _) |\n-            def::DefLocal(_, _) |\n+            def::DefLocal(_) |\n             def::DefVariant(_, _, _) |\n-            def::DefUpvar(_, _, _, _) => Some(recorder::VarRef),\n+            def::DefUpvar(..) => Some(recorder::VarRef),\n \n             def::DefFn(_, _) => Some(recorder::FnRef),\n \n@@ -739,20 +737,14 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let def = def_map.get(&ex.id);\n         let sub_span = self.span.span_for_last_ident(ex.span);\n         match *def {\n-            def::DefLocal(id, _) |\n-            def::DefArg(id, _) |\n-            def::DefUpvar(id, _, _, _) |\n-            def::DefBinding(id, _) => self.fmt.ref_str(recorder::VarRef,\n-                                                       ex.span,\n-                                                       sub_span,\n-                                                       ast_util::local_def(id),\n-                                                       self.cur_scope),\n-            def::DefStatic(def_id,_) |\n-            def::DefVariant(_, def_id, _) => self.fmt.ref_str(recorder::VarRef,\n-                                                              ex.span,\n-                                                              sub_span,\n-                                                              def_id,\n-                                                              self.cur_scope),\n+            def::DefUpvar(..) |\n+            def::DefLocal(..) |\n+            def::DefStatic(..) |\n+            def::DefVariant(..) => self.fmt.ref_str(recorder::VarRef,\n+                                                    ex.span,\n+                                                    sub_span,\n+                                                    def.def_id(),\n+                                                    self.cur_scope),\n             def::DefStruct(def_id) => self.fmt.ref_str(recorder::StructRef,\n                                                        ex.span,\n                                                        sub_span,\n@@ -813,8 +805,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefStaticMethod(_, _, _) => {\n                 self.write_sub_path_trait_truncated(path);\n             },\n-            def::DefLocal(_, _) |\n-            def::DefArg(_, _) |\n+            def::DefLocal(_) |\n             def::DefStatic(_,_) |\n             def::DefStruct(_) |\n             def::DefFn(_, _) => self.write_sub_paths_truncated(path),\n@@ -904,14 +895,14 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 };\n                 (Some(def_id), decl_id)\n             }\n-            typeck::MethodParam(ref mp) => {\n+            typeck::MethodTypeParam(ref mp) => {\n                 // method invoked on a type parameter\n                 let trait_item = ty::trait_item(&self.analysis.ty_cx,\n                                                 mp.trait_ref.def_id,\n                                                 mp.method_num);\n                 (None, Some(trait_item.def_id()))\n             }\n-            typeck::MethodObject(ref mo) => {\n+            typeck::MethodTraitObject(ref mo) => {\n                 // method invoked on a trait instance\n                 let trait_item = ty::trait_item(&self.analysis.ty_cx,\n                                                 mo.trait_ref.def_id,\n@@ -1382,12 +1373,12 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             }\n             let def = def_map.get(&id);\n             match *def {\n-                def::DefBinding(id, _)  => self.fmt.variable_str(p.span,\n-                                                                 sub_span,\n-                                                                 id,\n-                                                                 path_to_string(p).as_slice(),\n-                                                                 value.as_slice(),\n-                                                                 \"\"),\n+                def::DefLocal(id)  => self.fmt.variable_str(p.span,\n+                                                            sub_span,\n+                                                            id,\n+                                                            path_to_string(p).as_slice(),\n+                                                            value.as_slice(),\n+                                                            \"\"),\n                 def::DefVariant(_,id,_) => self.fmt.ref_str(ref_kind,\n                                                             p.span,\n                                                             sub_span,"}, {"sha": "1086dc608a352abf163db2a09c223e310b19da55", "filename": "src/librustc/middle/save/span_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fspan_utils.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -57,7 +57,7 @@ impl<'a> SpanUtils<'a> {\n                 Some(Span {\n                     lo: base + self.sess.codemap().lookup_byte_offset(sub.lo).pos,\n                     hi: base + self.sess.codemap().lookup_byte_offset(sub.hi).pos,\n-                    expn_info: None,\n+                    expn_id: NO_EXPANSION,\n                 })\n             }\n         }"}, {"sha": "e7b1053b3589ef77398a72cb34d5d41c57a7f531", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -13,10 +13,10 @@ use middle::typeck::infer::{InferCtxt, skolemize};\n use util::nodemap::DefIdMap;\n use util::ppaux::Repr;\n \n-use super::Ambiguity;\n+use super::CodeAmbiguity;\n use super::Obligation;\n use super::FulfillmentError;\n-use super::SelectionError;\n+use super::CodeSelectionError;\n use super::select::SelectionContext;\n use super::Unimplemented;\n \n@@ -78,7 +78,7 @@ impl FulfillmentContext {\n         let errors: Vec<FulfillmentError> =\n             self.trait_obligations\n             .iter()\n-            .map(|o| FulfillmentError::new((*o).clone(), Ambiguity))\n+            .map(|o| FulfillmentError::new((*o).clone(), CodeAmbiguity))\n             .collect();\n \n         if errors.is_empty() {\n@@ -129,7 +129,7 @@ impl FulfillmentContext {\n \n                         errors.push(FulfillmentError::new(\n                             (*obligation).clone(),\n-                            SelectionError(selection_err)));\n+                            CodeSelectionError(selection_err)));\n                         false\n                     }\n                 }\n@@ -237,7 +237,7 @@ impl FulfillmentContext {\n             errors.push(\n                 FulfillmentError::new(\n                     (*obligation).clone(),\n-                    SelectionError(Unimplemented)));\n+                    CodeSelectionError(Unimplemented)));\n         }\n \n         if errors.is_empty() {"}, {"sha": "dde733a6a3ec163e8963c63777f44326fc8ad809", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -97,8 +97,8 @@ pub struct FulfillmentError {\n \n #[deriving(Clone)]\n pub enum FulfillmentErrorCode {\n-    SelectionError(SelectionError),\n-    Ambiguity,\n+    CodeSelectionError(SelectionError),\n+    CodeAmbiguity,\n }\n \n /**\n@@ -110,7 +110,7 @@ pub enum FulfillmentErrorCode {\n  *   to inconclusive type inference.\n  * - `Err(e)`: error `e` occurred\n  */\n-pub type SelectionResult<T> = Result<Option<T>,SelectionError>;\n+pub type SelectionResult<T> = Result<Option<T>, SelectionError>;\n \n #[deriving(PartialEq,Eq,Show)]\n pub enum EvaluationResult {\n@@ -157,12 +157,12 @@ pub enum EvaluationResult {\n  *\n  * ### The type parameter `N`\n  *\n- * See explanation on `VtableImpl`.\n+ * See explanation on `VtableImplData`.\n  */\n #[deriving(Show,Clone)]\n pub enum Vtable<N> {\n     /// Vtable identifying a particular impl.\n-    VtableImpl(VtableImpl<N>),\n+    VtableImpl(VtableImplData<N>),\n \n     /// Vtable automatically generated for an unboxed closure. The def\n     /// ID is the ID of the closure expression. This is a `VtableImpl`\n@@ -172,7 +172,7 @@ pub enum Vtable<N> {\n \n     /// Successful resolution to an obligation provided by the caller\n     /// for some type parameter.\n-    VtableParam(VtableParam),\n+    VtableParam(VtableParamData),\n \n     /// Successful resolution for a builtin trait.\n     VtableBuiltin,\n@@ -191,7 +191,7 @@ pub enum Vtable<N> {\n  * impl, and nested obligations are satisfied later.\n  */\n #[deriving(Clone)]\n-pub struct VtableImpl<N> {\n+pub struct VtableImplData<N> {\n     pub impl_def_id: ast::DefId,\n     pub substs: subst::Substs,\n     pub nested: subst::VecPerParamSpace<N>\n@@ -203,7 +203,7 @@ pub struct VtableImpl<N> {\n  * on an instance of `T`, the vtable would be of type `VtableParam`.\n  */\n #[deriving(Clone)]\n-pub struct VtableParam {\n+pub struct VtableParamData {\n     // In the above example, this would `Eq`\n     pub bound: Rc<ty::TraitRef>,\n }\n@@ -274,7 +274,7 @@ pub fn select_inherent_impl(infcx: &InferCtxt,\n                             cause: ObligationCause,\n                             impl_def_id: ast::DefId,\n                             self_ty: ty::t)\n-                            -> SelectionResult<VtableImpl<Obligation>>\n+                            -> SelectionResult<VtableImplData<Obligation>>\n {\n     /*!\n      * Matches the self type of the inherent impl `impl_def_id`\n@@ -398,21 +398,21 @@ impl<N> Vtable<N> {\n     }\n }\n \n-impl<N> VtableImpl<N> {\n+impl<N> VtableImplData<N> {\n     pub fn map_nested<M>(&self,\n                          op: |&N| -> M)\n-                         -> VtableImpl<M>\n+                         -> VtableImplData<M>\n     {\n-        VtableImpl {\n+        VtableImplData {\n             impl_def_id: self.impl_def_id,\n             substs: self.substs.clone(),\n             nested: self.nested.map(op)\n         }\n     }\n \n-    pub fn map_move_nested<M>(self, op: |N| -> M) -> VtableImpl<M> {\n-        let VtableImpl { impl_def_id, substs, nested } = self;\n-        VtableImpl {\n+    pub fn map_move_nested<M>(self, op: |N| -> M) -> VtableImplData<M> {\n+        let VtableImplData { impl_def_id, substs, nested } = self;\n+        VtableImplData {\n             impl_def_id: impl_def_id,\n             substs: substs,\n             nested: nested.map_move(op)"}, {"sha": "e475dc6063d5d768bdad107eb95301a15ec944a5", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -18,6 +18,7 @@ use super::{SelectionError, Unimplemented, Overflow,\n use super::{Selection};\n use super::{SelectionResult};\n use super::{VtableBuiltin, VtableImpl, VtableParam, VtableUnboxedClosure};\n+use super::{VtableImplData, VtableParamData};\n use super::{util};\n \n use middle::subst::{Subst, Substs, VecPerParamSpace};\n@@ -82,7 +83,7 @@ enum MatchResult<T> {\n enum Candidate {\n     MatchedBuiltinCandidate,\n     AmbiguousBuiltinCandidate,\n-    MatchedParamCandidate(VtableParam),\n+    MatchedParamCandidate(VtableParamData),\n     AmbiguousParamCandidate,\n     Impl(ImplCandidate),\n     MatchedUnboxedClosureCandidate(/* closure */ ast::DefId)\n@@ -142,7 +143,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                 impl_def_id: ast::DefId,\n                                 obligation_cause: ObligationCause,\n                                 obligation_self_ty: ty::t)\n-                                -> SelectionResult<VtableImpl<Obligation>>\n+                                -> SelectionResult<VtableImplData<Obligation>>\n     {\n         debug!(\"select_inherent_impl(impl_def_id={}, obligation_self_ty={})\",\n                impl_def_id.repr(self.tcx()),\n@@ -597,8 +598,8 @@ v         */\n \n     fn confirm_param_candidate(&self,\n                                obligation: &Obligation,\n-                               param: VtableParam)\n-                               -> Result<VtableParam,SelectionError>\n+                               param: VtableParamData)\n+                               -> Result<VtableParamData,SelectionError>\n     {\n         debug!(\"confirm_param_candidate({},{})\",\n                obligation.repr(self.tcx()),\n@@ -613,7 +614,7 @@ v         */\n     fn confirm_impl_candidate(&self,\n                               obligation: &Obligation,\n                               impl_def_id: ast::DefId)\n-                              -> Result<VtableImpl<Obligation>,SelectionError>\n+                              -> Result<VtableImplData<Obligation>,SelectionError>\n     {\n         debug!(\"confirm_impl_candidate({},{})\",\n                obligation.repr(self.tcx()),\n@@ -642,7 +643,7 @@ v         */\n                                        obligation_cause: ObligationCause,\n                                        obligation_self_ty: ty::t,\n                                        obligation_recursion_depth: uint)\n-                                       -> Result<VtableImpl<Obligation>,\n+                                       -> Result<VtableImplData<Obligation>,\n                                                  SelectionError>\n     {\n         let substs = match self.match_impl_self_types(impl_def_id,\n@@ -663,7 +664,7 @@ v         */\n                                   obligation_recursion_depth,\n                                   impl_def_id,\n                                   &substs);\n-        let vtable_impl = VtableImpl { impl_def_id: impl_def_id,\n+        let vtable_impl = VtableImplData { impl_def_id: impl_def_id,\n                                        substs: substs,\n                                        nested: impl_obligations };\n "}, {"sha": "c48b125ac355d6e5df30ff62bb22094172038cfa", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -19,7 +19,7 @@ use syntax::ast;\n use syntax::codemap::Span;\n use util::ppaux::Repr;\n \n-use super::{Obligation, ObligationCause, VtableImpl, VtableParam};\n+use super::{Obligation, ObligationCause, VtableImpl, VtableParam, VtableParamData, VtableImplData};\n \n ///////////////////////////////////////////////////////////////////////////\n // Supertrait iterator\n@@ -137,13 +137,13 @@ pub fn fresh_substs_for_impl(infcx: &InferCtxt,\n     infcx.fresh_substs_for_generics(span, &impl_generics)\n }\n \n-impl<N> fmt::Show for VtableImpl<N> {\n+impl<N> fmt::Show for VtableImplData<N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"VtableImpl({})\", self.impl_def_id)\n     }\n }\n \n-impl fmt::Show for VtableParam {\n+impl fmt::Show for VtableParamData {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"VtableParam(...)\")\n     }\n@@ -239,7 +239,7 @@ pub fn obligation_for_builtin_bound(\n pub fn search_trait_and_supertraits_from_bound(tcx: &ty::ctxt,\n                                                caller_bound: Rc<ty::TraitRef>,\n                                                test: |ast::DefId| -> bool)\n-                                               -> Option<VtableParam>\n+                                               -> Option<VtableParamData>\n {\n     /*!\n      * Starting from a caller obligation `caller_bound` (which has\n@@ -252,7 +252,7 @@ pub fn search_trait_and_supertraits_from_bound(tcx: &ty::ctxt,\n \n     for bound in transitive_bounds(tcx, &[caller_bound]) {\n         if test(bound.def_id) {\n-            let vtable_param = VtableParam { bound: bound };\n+            let vtable_param = VtableParamData { bound: bound };\n             return Some(vtable_param);\n         }\n     }\n@@ -287,7 +287,7 @@ impl<N:Repr> Repr for super::Vtable<N> {\n     }\n }\n \n-impl<N:Repr> Repr for super::VtableImpl<N> {\n+impl<N:Repr> Repr for super::VtableImplData<N> {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         format!(\"VtableImpl(impl_def_id={}, substs={}, nested={})\",\n                 self.impl_def_id.repr(tcx),\n@@ -296,7 +296,7 @@ impl<N:Repr> Repr for super::VtableImpl<N> {\n     }\n }\n \n-impl Repr for super::VtableParam {\n+impl Repr for super::VtableParamData {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         format!(\"VtableParam(bound={})\",\n                 self.bound.repr(tcx))\n@@ -331,17 +331,17 @@ impl Repr for super::FulfillmentError {\n impl Repr for super::FulfillmentErrorCode {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         match *self {\n-            super::SelectionError(ref o) => o.repr(tcx),\n-            super::Ambiguity => format!(\"Ambiguity\")\n+            super::CodeSelectionError(ref o) => o.repr(tcx),\n+            super::CodeAmbiguity => format!(\"Ambiguity\")\n         }\n     }\n }\n \n impl fmt::Show for super::FulfillmentErrorCode {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            super::SelectionError(ref e) => write!(f, \"{}\", e),\n-            super::Ambiguity => write!(f, \"Ambiguity\")\n+            super::CodeSelectionError(ref e) => write!(f, \"{}\", e),\n+            super::CodeAmbiguity => write!(f, \"Ambiguity\")\n         }\n     }\n }"}, {"sha": "68d0bb2d8b49805220a6e796172a7d989c31eed6", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 22, "deletions": 44, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -1226,8 +1226,7 @@ pub fn trans_match<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn is_discr_reassigned(bcx: Block, discr: &ast::Expr, body: &ast::Expr) -> bool {\n     match discr.node {\n         ast::ExprPath(..) => match bcx.def(discr.id) {\n-            def::DefArg(vid, _) | def::DefBinding(vid, _) |\n-            def::DefLocal(vid, _) | def::DefUpvar(vid, _, _, _) => {\n+            def::DefLocal(vid) | def::DefUpvar(vid, _, _) => {\n                 let mut rc = ReassignmentChecker {\n                     node: vid,\n                     reassigned: false\n@@ -1259,7 +1258,7 @@ impl euv::Delegate for ReassignmentChecker {\n     fn mutate(&mut self, _: ast::NodeId, _: Span, cmt: mc::cmt, _: euv::MutateMode) {\n         match cmt.cat {\n             mc::cat_copied_upvar(mc::CopiedUpvar { upvar_id: vid, .. }) |\n-            mc::cat_arg(vid) | mc::cat_local(vid) => self.reassigned = self.node == vid,\n+            mc::cat_local(vid) => self.reassigned = self.node == vid,\n             _ => {}\n         }\n     }\n@@ -1391,13 +1390,6 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n     return bcx;\n }\n \n-enum IrrefutablePatternBindingMode {\n-    // Stores the association between node ID and LLVM value in `lllocals`.\n-    BindLocal,\n-    // Stores the association between node ID and LLVM value in `llargs`.\n-    BindArgument\n-}\n-\n pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                local: &ast::Local)\n                                -> Block<'blk, 'tcx> {\n@@ -1419,7 +1411,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         pat_bindings(&tcx.def_map, pat, |_, p_id, _, path1| {\n             let scope = cleanup::var_scope(tcx, p_id);\n             bcx = mk_binding_alloca(\n-                bcx, p_id, &path1.node, BindLocal, scope, (),\n+                bcx, p_id, &path1.node, scope, (),\n                 |(), bcx, llval, ty| { zero_mem(bcx, llval, ty); bcx });\n         });\n         bcx\n@@ -1441,7 +1433,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 Some(ident) => {\n                     let var_scope = cleanup::var_scope(tcx, local.id);\n                     return mk_binding_alloca(\n-                        bcx, pat.id, ident, BindLocal, var_scope, (),\n+                        bcx, pat.id, ident, var_scope, (),\n                         |(), bcx, v, _| expr::trans_into(bcx, &**init_expr,\n                                                          expr::SaveIn(v)));\n                 }\n@@ -1459,7 +1451,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     add_comment(bcx, \"creating zeroable ref llval\");\n                 }\n                 let var_scope = cleanup::var_scope(tcx, local.id);\n-                bind_irrefutable_pat(bcx, pat, init_datum.val, BindLocal, var_scope)\n+                bind_irrefutable_pat(bcx, pat, init_datum.val, var_scope)\n             }\n         }\n         None => {\n@@ -1475,7 +1467,7 @@ pub fn store_arg<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                              -> Block<'blk, 'tcx> {\n     /*!\n      * Generates code for argument patterns like `fn foo(<pat>: T)`.\n-     * Creates entries in the `llargs` map for each of the bindings\n+     * Creates entries in the `lllocals` map for each of the bindings\n      * in `pat`.\n      *\n      * # Arguments\n@@ -1499,12 +1491,12 @@ pub fn store_arg<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 // already put it in a temporary alloca and gave it up, unless\n                 // we emit extra-debug-info, which requires local allocas :(.\n                 let arg_val = arg.add_clean(bcx.fcx, arg_scope);\n-                bcx.fcx.llargs.borrow_mut()\n+                bcx.fcx.lllocals.borrow_mut()\n                    .insert(pat.id, Datum::new(arg_val, arg_ty, Lvalue));\n                 bcx\n             } else {\n                 mk_binding_alloca(\n-                    bcx, pat.id, ident, BindArgument, arg_scope, arg,\n+                    bcx, pat.id, ident, arg_scope, arg,\n                     |arg, bcx, llval, _| arg.store_to(bcx, llval))\n             }\n         }\n@@ -1514,8 +1506,7 @@ pub fn store_arg<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             // pattern.\n             let arg = unpack_datum!(\n                 bcx, arg.to_lvalue_datum_in_scope(bcx, \"__arg\", arg_scope));\n-            bind_irrefutable_pat(bcx, pat, arg.val,\n-                                 BindArgument, arg_scope)\n+            bind_irrefutable_pat(bcx, pat, arg.val, arg_scope)\n         }\n     }\n }\n@@ -1541,13 +1532,12 @@ pub fn store_for_loop_binding<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     // General path. Copy out the values that are used in the pattern.\n-    bind_irrefutable_pat(bcx, pat, llvalue, BindLocal, body_scope)\n+    bind_irrefutable_pat(bcx, pat, llvalue, body_scope)\n }\n \n fn mk_binding_alloca<'blk, 'tcx, A>(bcx: Block<'blk, 'tcx>,\n                                     p_id: ast::NodeId,\n                                     ident: &ast::Ident,\n-                                    binding_mode: IrrefutablePatternBindingMode,\n                                     cleanup_scope: cleanup::ScopeId,\n                                     arg: A,\n                                     populate: |A, Block<'blk, 'tcx>, ValueRef, ty::t|\n@@ -1567,18 +1557,13 @@ fn mk_binding_alloca<'blk, 'tcx, A>(bcx: Block<'blk, 'tcx>,\n     // Now that memory is initialized and has cleanup scheduled,\n     // create the datum and insert into the local variable map.\n     let datum = Datum::new(llval, var_ty, Lvalue);\n-    let mut llmap = match binding_mode {\n-        BindLocal => bcx.fcx.lllocals.borrow_mut(),\n-        BindArgument => bcx.fcx.llargs.borrow_mut()\n-    };\n-    llmap.insert(p_id, datum);\n+    bcx.fcx.lllocals.borrow_mut().insert(p_id, datum);\n     bcx\n }\n \n fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     pat: &ast::Pat,\n                                     val: ValueRef,\n-                                    binding_mode: IrrefutablePatternBindingMode,\n                                     cleanup_scope: cleanup::ScopeId)\n                                     -> Block<'blk, 'tcx> {\n     /*!\n@@ -1594,13 +1579,11 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n      * - bcx: starting basic block context\n      * - pat: the irrefutable pattern being matched.\n      * - val: the value being matched -- must be an lvalue (by ref, with cleanup)\n-     * - binding_mode: is this for an argument or a local variable?\n      */\n \n-    debug!(\"bind_irrefutable_pat(bcx={}, pat={}, binding_mode={:?})\",\n+    debug!(\"bind_irrefutable_pat(bcx={}, pat={})\",\n            bcx.to_str(),\n-           pat.repr(bcx.tcx()),\n-           binding_mode);\n+           pat.repr(bcx.tcx()));\n \n     if bcx.sess().asm_comments() {\n         add_comment(bcx, format!(\"bind_irrefutable_pat(pat={})\",\n@@ -1620,7 +1603,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // binding will live and place it into the appropriate\n                 // map.\n                 bcx = mk_binding_alloca(\n-                    bcx, pat.id, &path1.node, binding_mode, cleanup_scope, (),\n+                    bcx, pat.id, &path1.node, cleanup_scope, (),\n                     |(), bcx, llval, ty| {\n                         match pat_binding_mode {\n                             ast::BindByValue(_) => {\n@@ -1641,8 +1624,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n \n             for inner_pat in inner.iter() {\n-                bcx = bind_irrefutable_pat(bcx, &**inner_pat, val,\n-                                           binding_mode, cleanup_scope);\n+                bcx = bind_irrefutable_pat(bcx, &**inner_pat, val, cleanup_scope);\n             }\n         }\n         ast::PatEnum(_, ref sub_pats) => {\n@@ -1660,8 +1642,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     for sub_pat in sub_pats.iter() {\n                         for (i, &argval) in args.vals.iter().enumerate() {\n                             bcx = bind_irrefutable_pat(bcx, &**sub_pat.get(i),\n-                                                       argval, binding_mode,\n-                                                       cleanup_scope);\n+                                                       argval, cleanup_scope);\n                         }\n                     }\n                 }\n@@ -1678,8 +1659,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 let fldptr = adt::trans_field_ptr(bcx, &*repr,\n                                                                   val, 0, i);\n                                 bcx = bind_irrefutable_pat(bcx, &**elem,\n-                                                           fldptr, binding_mode,\n-                                                           cleanup_scope);\n+                                                           fldptr, cleanup_scope);\n                             }\n                         }\n                     }\n@@ -1698,26 +1678,24 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     let ix = ty::field_idx_strict(tcx, f.ident.name, field_tys);\n                     let fldptr = adt::trans_field_ptr(bcx, &*pat_repr, val,\n                                                       discr, ix);\n-                    bcx = bind_irrefutable_pat(bcx, &*f.pat, fldptr,\n-                                               binding_mode, cleanup_scope);\n+                    bcx = bind_irrefutable_pat(bcx, &*f.pat, fldptr, cleanup_scope);\n                 }\n             })\n         }\n         ast::PatTup(ref elems) => {\n             let repr = adt::represent_node(bcx, pat.id);\n             for (i, elem) in elems.iter().enumerate() {\n                 let fldptr = adt::trans_field_ptr(bcx, &*repr, val, 0, i);\n-                bcx = bind_irrefutable_pat(bcx, &**elem, fldptr,\n-                                           binding_mode, cleanup_scope);\n+                bcx = bind_irrefutable_pat(bcx, &**elem, fldptr, cleanup_scope);\n             }\n         }\n         ast::PatBox(ref inner) => {\n             let llbox = Load(bcx, val);\n-            bcx = bind_irrefutable_pat(bcx, &**inner, llbox, binding_mode, cleanup_scope);\n+            bcx = bind_irrefutable_pat(bcx, &**inner, llbox, cleanup_scope);\n         }\n         ast::PatRegion(ref inner) => {\n             let loaded_val = Load(bcx, val);\n-            bcx = bind_irrefutable_pat(bcx, &**inner, loaded_val, binding_mode, cleanup_scope);\n+            bcx = bind_irrefutable_pat(bcx, &**inner, loaded_val, cleanup_scope);\n         }\n         ast::PatVec(ref before, ref slice, ref after) => {\n             let pat_ty = node_id_type(bcx, pat.id);\n@@ -1737,7 +1715,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 .chain(after.iter())\n                 .zip(extracted.vals.into_iter())\n                 .fold(bcx, |bcx, (inner, elem)|\n-                    bind_irrefutable_pat(bcx, &**inner, elem, binding_mode, cleanup_scope)\n+                    bind_irrefutable_pat(bcx, &**inner, elem, cleanup_scope)\n                 );\n         }\n         ast::PatMac(..) => {"}, {"sha": "72e0401e7ab772b2a7e1f07a2845c2de1591733c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -191,21 +191,13 @@ pub fn decl_fn(ccx: &CrateContext, name: &str, cc: llvm::CallConv,\n     match ty::get(output).sty {\n         // functions returning bottom may unwind, but can never return normally\n         ty::ty_bot => {\n-            unsafe {\n-                llvm::LLVMAddFunctionAttribute(llfn,\n-                                               llvm::FunctionIndex as c_uint,\n-                                               llvm::NoReturnAttribute as uint64_t)\n-            }\n+            llvm::SetFunctionAttribute(llfn, llvm::NoReturnAttribute)\n         }\n         _ => {}\n     }\n \n     if ccx.tcx().sess.opts.cg.no_redzone {\n-        unsafe {\n-            llvm::LLVMAddFunctionAttribute(llfn,\n-                                           llvm::FunctionIndex as c_uint,\n-                                           llvm::NoRedZoneAttribute as uint64_t)\n-        }\n+        llvm::SetFunctionAttribute(llfn, llvm::NoRedZoneAttribute)\n     }\n \n     llvm::SetFunctionCallConv(llfn, cc);\n@@ -1468,7 +1460,6 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n           needs_ret_allocas: nested_returns,\n           personality: Cell::new(None),\n           caller_expects_out_pointer: uses_outptr,\n-          llargs: RefCell::new(NodeMap::new()),\n           lllocals: RefCell::new(NodeMap::new()),\n           llupvars: RefCell::new(NodeMap::new()),\n           id: id,"}, {"sha": "53c13f5628455864fee4c8e36546284165f92085", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -196,9 +196,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 }\n             }\n             def::DefStatic(..) |\n-            def::DefArg(..) |\n             def::DefLocal(..) |\n-            def::DefBinding(..) |\n             def::DefUpvar(..) => {\n                 datum_callee(bcx, ref_expr)\n             }\n@@ -860,10 +858,10 @@ pub enum CallArgs<'a> {\n     // value.\n     ArgVals(&'a [ValueRef]),\n \n-    // For overloaded operators: `(lhs, Option(rhs, rhs_id))`. `lhs`\n+    // For overloaded operators: `(lhs, Vec(rhs, rhs_id))`. `lhs`\n     // is the left-hand-side and `rhs/rhs_id` is the datum/expr-id of\n-    // the right-hand-side (if any).\n-    ArgOverloadedOp(Datum<Expr>, Option<(Datum<Expr>, ast::NodeId)>),\n+    // the right-hand-side arguments (if any).\n+    ArgOverloadedOp(Datum<Expr>, Vec<(Datum<Expr>, ast::NodeId)>),\n \n     // Supply value of arguments as a list of expressions that must be\n     // translated, for overloaded call operators.\n@@ -1047,17 +1045,13 @@ pub fn trans_args<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                 DontAutorefArg)\n             }));\n \n-            match rhs {\n-                Some((rhs, rhs_id)) => {\n-                    assert_eq!(arg_tys.len(), 2);\n-\n-                    llargs.push(unpack_result!(bcx, {\n-                        trans_arg_datum(bcx, *arg_tys.get(1), rhs,\n-                                        arg_cleanup_scope,\n-                                        DoAutorefArg(rhs_id))\n-                    }));\n-                }\n-                None => assert_eq!(arg_tys.len(), 1)\n+            assert_eq!(arg_tys.len(), 1 + rhs.len());\n+            for (rhs, rhs_id) in rhs.move_iter() {\n+                llargs.push(unpack_result!(bcx, {\n+                    trans_arg_datum(bcx, *arg_tys.get(1), rhs,\n+                                    arg_cleanup_scope,\n+                                    DoAutorefArg(rhs_id))\n+                }));\n             }\n         }\n         ArgVals(vs) => {"}, {"sha": "fa8c6b8b4482f63ad514c2930dbc87ed79a04305", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -14,7 +14,7 @@ use back::link::mangle_internal_name_by_path_and_seq;\n use driver::config::FullDebugInfo;\n use llvm::ValueRef;\n use middle::def;\n-use middle::freevars;\n+use middle::mem_categorization::Typer;\n use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n@@ -100,7 +100,7 @@ use syntax::ast_util;\n // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n pub struct EnvValue {\n-    action: freevars::CaptureMode,\n+    action: ast::CaptureClause,\n     datum: Datum<Lvalue>\n }\n \n@@ -120,8 +120,8 @@ pub fn mk_closure_tys(tcx: &ty::ctxt,\n     // converted to ptrs.\n     let bound_tys = bound_values.iter().map(|bv| {\n         match bv.action {\n-            freevars::CaptureByValue => bv.datum.ty,\n-            freevars::CaptureByRef => ty::mk_mut_ptr(tcx, bv.datum.ty)\n+            ast::CaptureByValue => bv.datum.ty,\n+            ast::CaptureByRef => ty::mk_mut_ptr(tcx, bv.datum.ty)\n         }\n     }).collect();\n     let cdata_ty = ty::mk_tup(tcx, bound_tys);\n@@ -208,10 +208,10 @@ pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let bound_data = GEPi(bcx, llbox, [0u, abi::box_field_body, i]);\n \n         match bv.action {\n-            freevars::CaptureByValue => {\n+            ast::CaptureByValue => {\n                 bcx = bv.datum.store_to(bcx, bound_data);\n             }\n-            freevars::CaptureByRef => {\n+            ast::CaptureByRef => {\n                 Store(bcx, bv.datum.to_llref(), bound_data);\n             }\n         }\n@@ -223,8 +223,8 @@ pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n // Given a context and a list of upvars, build a closure. This just\n // collects the upvars and packages them up for store_environment.\n fn build_closure<'blk, 'tcx>(bcx0: Block<'blk, 'tcx>,\n-                             freevar_mode: freevars::CaptureMode,\n-                             freevars: &Vec<freevars::freevar_entry>,\n+                             freevar_mode: ast::CaptureClause,\n+                             freevars: &Vec<ty::Freevar>,\n                              store: ty::TraitStore)\n                              -> ClosureResult<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::build_closure\");\n@@ -247,7 +247,7 @@ fn build_closure<'blk, 'tcx>(bcx0: Block<'blk, 'tcx>,\n // with the upvars and type descriptors.\n fn load_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 cdata_ty: ty::t,\n-                                freevars: &Vec<freevars::freevar_entry>,\n+                                freevars: &Vec<ty::Freevar>,\n                                 store: ty::TraitStore)\n                                 -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::load_environment\");\n@@ -301,7 +301,7 @@ fn load_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn load_unboxed_closure_environment<'blk, 'tcx>(\n                                     bcx: Block<'blk, 'tcx>,\n                                     arg_scope_id: ScopeId,\n-                                    freevars: &Vec<freevars::freevar_entry>,\n+                                    freevars: &Vec<ty::Freevar>,\n                                     closure_id: ast::DefId)\n                                     -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::load_environment\");\n@@ -386,11 +386,9 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n \n-    let freevar_mode = freevars::get_capture_mode(tcx, id);\n-    let freevars: Vec<freevars::freevar_entry> =\n-        freevars::with_freevars(tcx,\n-                                id,\n-                                |fv| fv.iter().map(|&fv| fv).collect());\n+    let freevar_mode = tcx.capture_mode(id);\n+    let freevars: Vec<ty::Freevar> =\n+        ty::with_freevars(tcx, id, |fv| fv.iter().map(|&fv| fv).collect());\n \n     let ClosureResult {\n         llbox,\n@@ -476,10 +474,8 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n                                         .clone();\n     let function_type = ty::mk_closure(bcx.tcx(), function_type);\n \n-    let freevars: Vec<freevars::freevar_entry> =\n-        freevars::with_freevars(bcx.tcx(),\n-                                id,\n-                                |fv| fv.iter().map(|&fv| fv).collect());\n+    let freevars: Vec<ty::Freevar> =\n+        ty::with_freevars(bcx.tcx(), id, |fv| fv.iter().map(|&fv| fv).collect());\n     let freevars_ptr = &freevars;\n \n     trans_closure(bcx.ccx(),"}, {"sha": "a5a9d6851762a7bcc0e567294a1fd2bb5205a8db", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -17,7 +17,6 @@ use llvm;\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ContextRef};\n use llvm::{True, False, Bool};\n use middle::def;\n-use middle::freevars;\n use middle::lang_items::LangItem;\n use middle::mem_categorization as mc;\n use middle::subst;\n@@ -267,10 +266,7 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // points to, but if this value is false, that slot will be a local alloca.\n     pub caller_expects_out_pointer: bool,\n \n-    // Maps arguments to allocas created for them in llallocas.\n-    pub llargs: RefCell<NodeMap<LvalueDatum>>,\n-\n-    // Maps the def_ids for local variables to the allocas created for\n+    // Maps the DefId's for local variables to the allocas created for\n     // them in llallocas.\n     pub lllocals: RefCell<NodeMap<LvalueDatum>>,\n \n@@ -528,7 +524,7 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n     }\n \n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> freevars::CaptureMode {\n+                    -> ast::CaptureClause {\n         self.tcx().capture_modes.borrow().get_copy(&closure_expr_id)\n     }\n }"}, {"sha": "d39fe4a1e700306551513c542c6be122bfa4d739", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -207,7 +207,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n         None => { }\n         Some(adj) => {\n             match adj {\n-                ty::AutoAddEnv(ty::RegionTraitStore(ty::ReStatic, _)) => {\n+                ty::AdjustAddEnv(ty::RegionTraitStore(ty::ReStatic, _)) => {\n                     let def = ty::resolve_expr(cx.tcx(), e);\n                     let wrapper = closure::get_wrapper_for_bare_fn(cx,\n                                                                    ety_adjusted,\n@@ -216,13 +216,13 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                                                                    is_local);\n                     llconst = C_struct(cx, [wrapper, C_null(Type::i8p(cx))], false)\n                 }\n-                ty::AutoAddEnv(store) => {\n+                ty::AdjustAddEnv(store) => {\n                     cx.sess()\n                       .span_bug(e.span,\n                                 format!(\"unexpected static function: {:?}\",\n                                         store).as_slice())\n                 }\n-                ty::AutoDerefRef(ref adj) => {\n+                ty::AdjustDerefRef(ref adj) => {\n                     let mut ty = ety;\n                     // Save the last autoderef in case we can avoid it.\n                     if adj.autoderefs > 0 {"}, {"sha": "1980d67fc47146cb577f081af9acf12c6acff6dd", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -664,7 +664,7 @@ pub struct FunctionDebugContext {\n }\n \n enum FunctionDebugContextRepr {\n-    FunctionDebugContext(Box<FunctionDebugContextData>),\n+    DebugInfo(Box<FunctionDebugContextData>),\n     DebugInfoDisabled,\n     FunctionWithoutDebugInfo,\n }\n@@ -675,7 +675,7 @@ impl FunctionDebugContext {\n                    span: Span)\n                    -> &'a FunctionDebugContextData {\n         match self.repr {\n-            FunctionDebugContext(box ref data) => data,\n+            DebugInfo(box ref data) => data,\n             DebugInfoDisabled => {\n                 cx.sess().span_bug(span,\n                                    FunctionDebugContext::debuginfo_disabled_message());\n@@ -999,11 +999,11 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n \n     pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, path1| {\n-        let llarg = match bcx.fcx.llargs.borrow().find_copy(&node_id) {\n+        let llarg = match bcx.fcx.lllocals.borrow().find_copy(&node_id) {\n             Some(v) => v,\n             None => {\n                 bcx.sess().span_bug(span,\n-                    format!(\"no entry in llargs table for {:?}\",\n+                    format!(\"no entry in lllocals table for {:?}\",\n                             node_id).as_slice());\n             }\n         };\n@@ -1044,7 +1044,7 @@ pub fn set_source_location(fcx: &FunctionContext,\n             set_debug_location(fcx.ccx, UnknownLocation);\n             return;\n         }\n-        FunctionDebugContext(box ref function_debug_context) => {\n+        DebugInfo(box ref function_debug_context) => {\n             let cx = fcx.ccx;\n \n             debug!(\"set_source_location: {}\", cx.sess().codemap().span_to_string(span));\n@@ -1082,7 +1082,7 @@ pub fn clear_source_location(fcx: &FunctionContext) {\n /// first real statement/expression of the function is translated.\n pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n     match fcx.debug_context.repr {\n-        FunctionDebugContext(box ref data) => {\n+        DebugInfo(box ref data) => {\n             data.source_locations_enabled.set(true)\n         },\n         _ => { /* safe to ignore */ }\n@@ -1291,7 +1291,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                        fn_metadata,\n                        &mut *fn_debug_context.scope_map.borrow_mut());\n \n-    return FunctionDebugContext { repr: FunctionDebugContext(fn_debug_context) };\n+    return FunctionDebugContext { repr: DebugInfo(fn_debug_context) };\n \n     fn get_function_signature(cx: &CrateContext,\n                               fn_ast_id: ast::NodeId,\n@@ -3134,7 +3134,7 @@ fn DIB(cx: &CrateContext) -> DIBuilderRef {\n \n fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n     match fcx.debug_context.repr {\n-        FunctionDebugContext(_) => false,\n+        DebugInfo(_) => false,\n         _ => true\n     }\n }\n@@ -3479,6 +3479,12 @@ fn populate_scope_map(cx: &CrateContext,\n                 walk_expr(cx, &**rhs, scope_stack, scope_map);\n             }\n \n+            ast::ExprSlice(ref base, ref start, ref end, _) => {\n+                walk_expr(cx, &**base, scope_stack, scope_map);\n+                start.as_ref().map(|x| walk_expr(cx, &**x, scope_stack, scope_map));\n+                end.as_ref().map(|x| walk_expr(cx, &**x, scope_stack, scope_map));\n+            }\n+\n             ast::ExprVec(ref init_expressions) |\n             ast::ExprTup(ref init_expressions) => {\n                 for ie in init_expressions.iter() {"}, {"sha": "75c28477414a92309395079ece1abe56f3a61d05", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 51, "deletions": 34, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -64,14 +64,13 @@ use middle::trans::inline;\n use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::ty::{struct_fields, tup_fields};\n-use middle::ty::{AutoDerefRef, AutoAddEnv, AutoUnsafe};\n+use middle::ty::{AdjustDerefRef, AdjustAddEnv, AutoUnsafe};\n use middle::ty::{AutoPtr};\n use middle::ty;\n use middle::typeck;\n use middle::typeck::MethodCall;\n use util::common::indenter;\n use util::ppaux::Repr;\n-use util::nodemap::NodeMap;\n use middle::trans::machine::{llsize_of, llsize_of_alloc};\n use middle::trans::type_::Type;\n \n@@ -190,10 +189,10 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     debug!(\"unadjusted datum for expr {}: {}\",\n            expr.id, datum.to_string(bcx.ccx()));\n     match adjustment {\n-        AutoAddEnv(..) => {\n+        AdjustAddEnv(..) => {\n             datum = unpack_datum!(bcx, add_env(bcx, expr, datum));\n         }\n-        AutoDerefRef(ref adj) => {\n+        AdjustDerefRef(ref adj) => {\n             let (autoderefs, use_autoref) = match adj.autoref {\n                 // Extracting a value from a box counts as a deref, but if we are\n                 // just converting Box<[T, ..n]> to Box<[T]> we aren't really doing\n@@ -590,6 +589,34 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprIndex(ref base, ref idx) => {\n             trans_index(bcx, expr, &**base, &**idx, MethodCall::expr(expr.id))\n         }\n+        ast::ExprSlice(ref base, ref start, ref end, _) => {\n+            let _icx = push_ctxt(\"trans_slice\");\n+            let ccx = bcx.ccx();\n+\n+            let method_call = MethodCall::expr(expr.id);\n+            let method_ty = ccx.tcx()\n+                               .method_map\n+                               .borrow()\n+                               .find(&method_call)\n+                               .map(|method| method.ty);\n+            let base_datum = unpack_datum!(bcx, trans(bcx, &**base));\n+\n+            let mut args = vec![];\n+            start.as_ref().map(|e| args.push((unpack_datum!(bcx, trans(bcx, &**e)), e.id)));\n+            end.as_ref().map(|e| args.push((unpack_datum!(bcx, trans(bcx, &**e)), e.id)));\n+\n+            let result_ty = ty::ty_fn_ret(monomorphize_type(bcx, method_ty.unwrap()));\n+            let scratch = rvalue_scratch_datum(bcx, result_ty, \"trans_slice\");\n+\n+            unpack_result!(bcx,\n+                           trans_overloaded_op(bcx,\n+                                               expr,\n+                                               method_call,\n+                                               base_datum,\n+                                               args,\n+                                               Some(SaveIn(scratch.val))));\n+            DatumBlock::new(bcx, scratch.to_expr_datum())\n+        }\n         ast::ExprBox(_, ref contents) => {\n             // Special case for `Box<T>` and `Gc<T>`\n             let box_ty = expr_ty(bcx, expr);\n@@ -725,7 +752,7 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                    index_expr,\n                                                    method_call,\n                                                    base_datum,\n-                                                   Some((ix_datum, idx.id)),\n+                                                   vec![(ix_datum, idx.id)],\n                                                    None));\n             let ref_ty = ty::ty_fn_ret(monomorphize_type(bcx, method_ty));\n             let elt_ty = match ty::deref(ref_ty, true) {\n@@ -1044,20 +1071,20 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let lhs = unpack_datum!(bcx, trans(bcx, &**lhs));\n             let rhs_datum = unpack_datum!(bcx, trans(bcx, &**rhs));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), lhs,\n-                                Some((rhs_datum, rhs.id)), Some(dest)).bcx\n+                                vec![(rhs_datum, rhs.id)], Some(dest)).bcx\n         }\n         ast::ExprUnary(_, ref subexpr) => {\n             // if not overloaded, would be RvalueDatumExpr\n             let arg = unpack_datum!(bcx, trans(bcx, &**subexpr));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id),\n-                                arg, None, Some(dest)).bcx\n+                                arg, Vec::new(), Some(dest)).bcx\n         }\n         ast::ExprIndex(ref base, ref idx) => {\n             // if not overloaded, would be RvalueDatumExpr\n             let base = unpack_datum!(bcx, trans(bcx, &**base));\n             let idx_datum = unpack_datum!(bcx, trans(bcx, &**idx));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), base,\n-                                Some((idx_datum, idx.id)), Some(dest)).bcx\n+                                vec![(idx_datum, idx.id)], Some(dest)).bcx\n         }\n         ast::ExprCast(ref val, _) => {\n             // DPS output mode means this is a trait cast:\n@@ -1176,8 +1203,8 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let _icx = push_ctxt(\"trans_local_var\");\n \n-    return match def {\n-        def::DefUpvar(nid, _, _, _) => {\n+    match def {\n+        def::DefUpvar(nid, _, _) => {\n             // Can't move upvars, so this is never a ZeroMemLastUse.\n             let local_ty = node_id_type(bcx, nid);\n             match bcx.fcx.llupvars.borrow().find(&nid) {\n@@ -1189,34 +1216,24 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n             }\n         }\n-        def::DefArg(nid, _) => {\n-            take_local(bcx, &*bcx.fcx.llargs.borrow(), nid)\n-        }\n-        def::DefLocal(nid, _) | def::DefBinding(nid, _) => {\n-            take_local(bcx, &*bcx.fcx.lllocals.borrow(), nid)\n+        def::DefLocal(nid) => {\n+            let datum = match bcx.fcx.lllocals.borrow().find(&nid) {\n+                Some(&v) => v,\n+                None => {\n+                    bcx.sess().bug(format!(\n+                        \"trans_local_var: no datum for local/arg {:?} found\",\n+                        nid).as_slice());\n+                }\n+            };\n+            debug!(\"take_local(nid={:?}, v={}, ty={})\",\n+                   nid, bcx.val_to_string(datum.val), bcx.ty_to_string(datum.ty));\n+            datum\n         }\n         _ => {\n             bcx.sess().unimpl(format!(\n                 \"unsupported def type in trans_local_var: {:?}\",\n                 def).as_slice());\n         }\n-    };\n-\n-    fn take_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              table: &NodeMap<Datum<Lvalue>>,\n-                              nid: ast::NodeId)\n-                              -> Datum<Lvalue> {\n-        let datum = match table.find(&nid) {\n-            Some(&v) => v,\n-            None => {\n-                bcx.sess().bug(format!(\n-                    \"trans_local_var: no datum for local/arg {:?} found\",\n-                    nid).as_slice());\n-            }\n-        };\n-        debug!(\"take_local(nid={:?}, v={}, ty={})\",\n-               nid, bcx.val_to_string(datum.val), bcx.ty_to_string(datum.ty));\n-        datum\n     }\n }\n \n@@ -1751,7 +1768,7 @@ fn trans_overloaded_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    expr: &ast::Expr,\n                                    method_call: MethodCall,\n                                    lhs: Datum<Expr>,\n-                                   rhs: Option<(Datum<Expr>, ast::NodeId)>,\n+                                   rhs: Vec<(Datum<Expr>, ast::NodeId)>,\n                                    dest: Option<Dest>)\n                                    -> Result<'blk, 'tcx> {\n     let method_ty = bcx.tcx().method_map.borrow().get(&method_call).ty;\n@@ -2074,7 +2091,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let scratch = rvalue_scratch_datum(bcx, ref_ty, \"overloaded_deref\");\n \n             unpack_result!(bcx, trans_overloaded_op(bcx, expr, method_call,\n-                                                    datum, None, Some(SaveIn(scratch.val))));\n+                                                    datum, Vec::new(), Some(SaveIn(scratch.val))));\n             scratch.to_expr_datum()\n         }\n         None => {"}, {"sha": "9cff7261806dd2bb389cf73470459cdb8006aed7", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -998,7 +998,7 @@ fn add_argument_attributes(tys: &ForeignTypes,\n \n     match tys.fn_ty.ret_ty.attr {\n         Some(attr) => unsafe {\n-            llvm::LLVMAddFunctionAttribute(llfn, i as c_uint, attr as u64);\n+            llvm::LLVMAddFunctionAttribute(llfn, i as c_uint, attr.bits() as u64);\n         },\n         None => {}\n     }\n@@ -1014,7 +1014,7 @@ fn add_argument_attributes(tys: &ForeignTypes,\n \n         match arg_ty.attr {\n             Some(attr) => unsafe {\n-                llvm::LLVMAddFunctionAttribute(llfn, i as c_uint, attr as u64);\n+                llvm::LLVMAddFunctionAttribute(llfn, i as c_uint, attr.bits() as u64);\n             },\n             None => ()\n         }"}, {"sha": "3b3d7d02a2c8a7c47a8e254ee62f516620bd39bb", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -11,7 +11,7 @@\n #![allow(non_uppercase_statics)]\n \n use llvm;\n-use llvm::{SequentiallyConsistent, Acquire, Release, Xchg, ValueRef};\n+use llvm::{SequentiallyConsistent, Acquire, Release, AtomicXchg, ValueRef};\n use middle::subst;\n use middle::subst::FnSpace;\n use middle::trans::base::*;\n@@ -510,17 +510,17 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n                 // These are all AtomicRMW ops\n                 op => {\n                     let atom_op = match op {\n-                        \"xchg\"  => llvm::Xchg,\n-                        \"xadd\"  => llvm::Add,\n-                        \"xsub\"  => llvm::Sub,\n-                        \"and\"   => llvm::And,\n-                        \"nand\"  => llvm::Nand,\n-                        \"or\"    => llvm::Or,\n-                        \"xor\"   => llvm::Xor,\n-                        \"max\"   => llvm::Max,\n-                        \"min\"   => llvm::Min,\n-                        \"umax\"  => llvm::UMax,\n-                        \"umin\"  => llvm::UMin,\n+                        \"xchg\"  => llvm::AtomicXchg,\n+                        \"xadd\"  => llvm::AtomicAdd,\n+                        \"xsub\"  => llvm::AtomicSub,\n+                        \"and\"   => llvm::AtomicAnd,\n+                        \"nand\"  => llvm::AtomicNand,\n+                        \"or\"    => llvm::AtomicOr,\n+                        \"xor\"   => llvm::AtomicXor,\n+                        \"max\"   => llvm::AtomicMax,\n+                        \"min\"   => llvm::AtomicMin,\n+                        \"umax\"  => llvm::AtomicUMax,\n+                        \"umin\"  => llvm::AtomicUMin,\n                         _ => ccx.sess().fatal(\"unknown atomic operation\")\n                     };\n "}, {"sha": "844ee0a60c67279336fc4b27b9969ffcb30e45bc", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -131,7 +131,7 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n \n-        typeck::MethodParam(typeck::MethodParam {\n+        typeck::MethodTypeParam(typeck::MethodParam {\n             trait_ref: ref trait_ref,\n             method_num: method_num\n         }) => {\n@@ -147,7 +147,7 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                        method_num, origin)\n         }\n \n-        typeck::MethodObject(ref mt) => {\n+        typeck::MethodTraitObject(ref mt) => {\n             let self_expr = match self_expr {\n                 Some(self_expr) => self_expr,\n                 None => {\n@@ -243,7 +243,7 @@ pub fn trans_static_method_callee(bcx: Block,\n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:\n     match vtbl {\n-        traits::VtableImpl(traits::VtableImpl {\n+        traits::VtableImpl(traits::VtableImplData {\n             impl_def_id: impl_did,\n             substs: impl_substs,\n             nested: _ }) =>\n@@ -562,7 +562,7 @@ pub fn get_vtable(bcx: Block,\n                                         trait_ref.clone());\n         match vtable {\n             traits::VtableImpl(\n-                traits::VtableImpl {\n+                traits::VtableImplData {\n                     impl_def_id: id,\n                     substs: substs,\n                     nested: _ }) => {"}, {"sha": "33ade80afd3cf12c25b73cc5ad830fd11c055b7e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -17,8 +17,6 @@ use metadata::csearch;\n use middle::const_eval;\n use middle::def;\n use middle::dependency_format;\n-use middle::freevars::CaptureModeMap;\n-use middle::freevars;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem};\n use middle::lang_items::{FnOnceTraitLangItem, OpaqueStructLangItem};\n use middle::lang_items::{TyDescStructLangItem, TyVisitorTraitLangItem};\n@@ -279,8 +277,8 @@ pub enum Variance {\n \n #[deriving(Clone)]\n pub enum AutoAdjustment {\n-    AutoAddEnv(ty::TraitStore),\n-    AutoDerefRef(AutoDerefRef)\n+    AdjustAddEnv(ty::TraitStore),\n+    AdjustDerefRef(AutoDerefRef)\n }\n \n #[deriving(Clone, PartialEq)]\n@@ -352,7 +350,7 @@ fn autoref_object_region(autoref: &AutoRef) -> (bool, bool, Option<Region>) {\n // returns the region of the borrowed reference.\n pub fn adjusted_object_region(adj: &AutoAdjustment) -> Option<Region> {\n     match adj {\n-        &AutoDerefRef(AutoDerefRef{autoref: Some(ref autoref), ..}) => {\n+        &AdjustDerefRef(AutoDerefRef{autoref: Some(ref autoref), ..}) => {\n             let (b, _, r) = autoref_object_region(autoref);\n             if b {\n                 r\n@@ -367,7 +365,7 @@ pub fn adjusted_object_region(adj: &AutoAdjustment) -> Option<Region> {\n // Returns true if there is a trait cast at the bottom of the adjustment.\n pub fn adjust_is_object(adj: &AutoAdjustment) -> bool {\n     match adj {\n-        &AutoDerefRef(AutoDerefRef{autoref: Some(ref autoref), ..}) => {\n+        &AdjustDerefRef(AutoDerefRef{autoref: Some(ref autoref), ..}) => {\n             let (b, _, _) = autoref_object_region(autoref);\n             b\n         }\n@@ -409,7 +407,7 @@ pub fn type_of_adjust(cx: &ctxt, adj: &AutoAdjustment) -> Option<t> {\n     }\n \n     match adj {\n-        &AutoDerefRef(AutoDerefRef{autoref: Some(ref autoref), ..}) => {\n+        &AdjustDerefRef(AutoDerefRef{autoref: Some(ref autoref), ..}) => {\n             type_of_autoref(cx, autoref)\n         }\n         _ => None\n@@ -480,7 +478,7 @@ pub struct ctxt<'tcx> {\n \n     pub map: ast_map::Map<'tcx>,\n     pub intrinsic_defs: RefCell<DefIdMap<t>>,\n-    pub freevars: RefCell<freevars::freevar_map>,\n+    pub freevars: RefCell<FreevarMap>,\n     pub tcache: type_cache,\n     pub rcache: creader_cache,\n     pub short_names_cache: RefCell<HashMap<t, String>>,\n@@ -1463,8 +1461,8 @@ pub fn mk_ctxt<'tcx>(s: Session,\n                      dm: resolve::DefMap,\n                      named_region_map: resolve_lifetime::NamedRegionMap,\n                      map: ast_map::Map<'tcx>,\n-                     freevars: freevars::freevar_map,\n-                     capture_modes: freevars::CaptureModeMap,\n+                     freevars: RefCell<FreevarMap>,\n+                     capture_modes: RefCell<CaptureModeMap>,\n                      region_maps: middle::region::RegionMaps,\n                      lang_items: middle::lang_items::LanguageItems,\n                      stability: stability::Index) -> ctxt<'tcx> {\n@@ -1485,7 +1483,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         object_cast_map: RefCell::new(NodeMap::new()),\n         map: map,\n         intrinsic_defs: RefCell::new(DefIdMap::new()),\n-        freevars: RefCell::new(freevars),\n+        freevars: freevars,\n         tcache: RefCell::new(DefIdMap::new()),\n         rcache: RefCell::new(HashMap::new()),\n         short_names_cache: RefCell::new(HashMap::new()),\n@@ -1522,7 +1520,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         node_lint_levels: RefCell::new(HashMap::new()),\n         transmute_restrictions: RefCell::new(Vec::new()),\n         stability: RefCell::new(stability),\n-        capture_modes: RefCell::new(capture_modes),\n+        capture_modes: capture_modes,\n         associated_types: RefCell::new(DefIdMap::new()),\n         trait_associated_types: RefCell::new(DefIdMap::new()),\n     }\n@@ -3425,7 +3423,7 @@ pub fn adjust_ty(cx: &ctxt,\n     return match adjustment {\n         Some(adjustment) => {\n             match *adjustment {\n-                AutoAddEnv(store) => {\n+                AdjustAddEnv(store) => {\n                     match ty::get(unadjusted_ty).sty {\n                         ty::ty_bare_fn(ref b) => {\n                             let bounds = ty::ExistentialBounds {\n@@ -3451,7 +3449,7 @@ pub fn adjust_ty(cx: &ctxt,\n                     }\n                 }\n \n-                AutoDerefRef(ref adj) => {\n+                AdjustDerefRef(ref adj) => {\n                     let mut adjusted_ty = unadjusted_ty;\n \n                     if !ty::type_is_error(adjusted_ty) {\n@@ -3584,12 +3582,12 @@ pub fn method_call_type_param_defs<'tcx, T>(typer: &T,\n                               .trait_did(typer.tcx());\n             lookup_trait_def(typer.tcx(), def_id).generics.types.clone()\n         }\n-        typeck::MethodParam(typeck::MethodParam{\n+        typeck::MethodTypeParam(typeck::MethodParam{\n             trait_ref: ref trait_ref,\n             method_num: n_mth,\n             ..\n         }) |\n-        typeck::MethodObject(typeck::MethodObject{\n+        typeck::MethodTraitObject(typeck::MethodObject{\n                 trait_ref: ref trait_ref,\n                 method_num: n_mth,\n                 ..\n@@ -3648,6 +3646,9 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n             // the index method invoked for `a[i]` always yields an `&T`\n             ast::ExprIndex(..) => LvalueExpr,\n \n+            // the slice method invoked for `a[..]` always yields an `&T`\n+            ast::ExprSlice(..) => LvalueExpr,\n+\n             // `for` loops are statements\n             ast::ExprForLoop(..) => RvalueStmtExpr,\n \n@@ -3684,9 +3685,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                 // DefArg's, particularly those of immediate type, ought to\n                 // considered rvalues.\n                 def::DefStatic(..) |\n-                def::DefBinding(..) |\n                 def::DefUpvar(..) |\n-                def::DefArg(..) |\n                 def::DefLocal(..) => LvalueExpr,\n \n                 def => {\n@@ -3702,7 +3701,8 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         ast::ExprUnary(ast::UnDeref, _) |\n         ast::ExprField(..) |\n         ast::ExprTupField(..) |\n-        ast::ExprIndex(..) => {\n+        ast::ExprIndex(..) |\n+        ast::ExprSlice(..) => {\n             LvalueExpr\n         }\n \n@@ -4759,7 +4759,7 @@ pub fn unboxed_closure_upvars(tcx: &ctxt, closure_id: ast::DefId)\n                               -> Vec<UnboxedClosureUpvar> {\n     if closure_id.krate == ast::LOCAL_CRATE {\n         match tcx.freevars.borrow().find(&closure_id.node) {\n-            None => tcx.sess.bug(\"no freevars for unboxed closure?!\"),\n+            None => vec![],\n             Some(ref freevars) => {\n                 freevars.iter().map(|freevar| {\n                     let freevar_def_id = freevar.def.def_id();\n@@ -5617,7 +5617,7 @@ impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n     }\n \n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> freevars::CaptureMode {\n+                    -> ast::CaptureClause {\n         self.capture_modes.borrow().get_copy(&closure_expr_id)\n     }\n \n@@ -5688,3 +5688,24 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n         }\n     })\n }\n+\n+/// A free variable referred to in a function.\n+#[deriving(Encodable, Decodable)]\n+pub struct Freevar {\n+    /// The variable being accessed free.\n+    pub def: def::Def,\n+\n+    // First span where it is accessed (there can be multiple).\n+    pub span: Span\n+}\n+\n+pub type FreevarMap = NodeMap<Vec<Freevar>>;\n+\n+pub type CaptureModeMap = NodeMap<ast::CaptureClause>;\n+\n+pub fn with_freevars<T>(tcx: &ty::ctxt, fid: ast::NodeId, f: |&[Freevar]| -> T) -> T {\n+    match tcx.freevars.borrow().find(&fid) {\n+        None => f(&[]),\n+        Some(d) => f(d.as_slice())\n+    }\n+}"}, {"sha": "2e964c457bf29782d276dd506f7f433f90c38e09", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -353,9 +353,9 @@ impl TypeFoldable for traits::Obligation {\n     }\n }\n \n-impl<N:TypeFoldable> TypeFoldable for traits::VtableImpl<N> {\n-    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableImpl<N> {\n-        traits::VtableImpl {\n+impl<N:TypeFoldable> TypeFoldable for traits::VtableImplData<N> {\n+    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableImplData<N> {\n+        traits::VtableImplData {\n             impl_def_id: self.impl_def_id,\n             substs: self.substs.fold_with(folder),\n             nested: self.nested.fold_with(folder),\n@@ -374,9 +374,9 @@ impl<N:TypeFoldable> TypeFoldable for traits::Vtable<N> {\n     }\n }\n \n-impl TypeFoldable for traits::VtableParam {\n-    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableParam {\n-        traits::VtableParam {\n+impl TypeFoldable for traits::VtableParamData {\n+    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableParamData {\n+        traits::VtableParamData {\n             bound: self.bound.fold_with(folder),\n         }\n     }"}, {"sha": "2503fb2541b900824d4698e7bc48e46a6dfb1c5a", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -585,32 +585,29 @@ pub fn trait_ref_for_unboxed_function<'tcx, AC: AstConv<'tcx>,\n                                       RS:RegionScope>(\n                                       this: &AC,\n                                       rscope: &RS,\n-                                      unboxed_function: &ast::UnboxedFnTy,\n+                                      kind: ast::UnboxedClosureKind,\n+                                      decl: &ast::FnDecl,\n                                       self_ty: Option<ty::t>)\n                                       -> ty::TraitRef {\n-    let lang_item = match unboxed_function.kind {\n+    let lang_item = match kind {\n         ast::FnUnboxedClosureKind => FnTraitLangItem,\n         ast::FnMutUnboxedClosureKind => FnMutTraitLangItem,\n         ast::FnOnceUnboxedClosureKind => FnOnceTraitLangItem,\n     };\n     let trait_did = this.tcx().lang_items.require(lang_item).unwrap();\n-    let input_types =\n-        unboxed_function.decl\n-                        .inputs\n-                        .iter()\n-                        .map(|input| {\n+    let input_types = decl.inputs\n+                          .iter()\n+                          .map(|input| {\n                             ast_ty_to_ty(this, rscope, &*input.ty)\n-                        }).collect::<Vec<_>>();\n+                          }).collect::<Vec<_>>();\n     let input_tuple = if input_types.len() == 0 {\n         ty::mk_nil()\n     } else {\n         ty::mk_tup(this.tcx(), input_types)\n     };\n-    let output_type = ast_ty_to_ty(this,\n-                                   rscope,\n-                                   &*unboxed_function.decl.output);\n+    let output_type = ast_ty_to_ty(this, rscope, &*decl.output);\n     let mut substs = Substs::new_type(vec!(input_tuple, output_type),\n-                                             Vec::new());\n+                                      Vec::new());\n \n     match self_ty {\n         Some(s) => substs.types.push(SelfSpace, s),\n@@ -648,7 +645,8 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                 substs\n             } = trait_ref_for_unboxed_function(this,\n                                                rscope,\n-                                               &**unboxed_function,\n+                                               unboxed_function.kind,\n+                                               &*unboxed_function.decl,\n                                                None);\n             let r = ptr_ty.default_region();\n             let tr = ty::mk_trait(this.tcx(),\n@@ -1510,7 +1508,7 @@ fn compute_region_bound<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n pub struct PartitionedBounds<'a> {\n     pub builtin_bounds: ty::BuiltinBounds,\n     pub trait_bounds: Vec<&'a ast::TraitRef>,\n-    pub unboxed_fn_ty_bounds: Vec<&'a ast::UnboxedFnTy>,\n+    pub unboxed_fn_ty_bounds: Vec<&'a ast::UnboxedFnBound>,\n     pub region_bounds: Vec<&'a ast::Lifetime>,\n }\n \n@@ -1574,7 +1572,7 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n                 region_bounds.push(l);\n             }\n             ast::UnboxedFnTyParamBound(ref unboxed_function) => {\n-                unboxed_fn_ty_bounds.push(unboxed_function);\n+                unboxed_fn_ty_bounds.push(&**unboxed_function);\n             }\n         }\n     }"}, {"sha": "7d28a63d93578823b35cd4d1c4a8339477734523", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -90,8 +90,8 @@ use middle::typeck::check::{FnCtxt, PreferMutLvalue, impl_self_ty};\n use middle::typeck::check;\n use middle::typeck::infer;\n use middle::typeck::MethodCallee;\n-use middle::typeck::{MethodOrigin, MethodParam};\n-use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure, MethodObject};\n+use middle::typeck::{MethodOrigin, MethodParam, MethodTypeParam};\n+use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure, MethodObject, MethodTraitObject};\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::TypeAndSubsts;\n use util::common::indenter;\n@@ -636,7 +636,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     rcvr_match_condition: RcvrMatchesIfObject(did),\n                     rcvr_substs: new_trait_ref.substs.clone(),\n                     method_ty: Rc::new(m),\n-                    origin: MethodObject(MethodObject {\n+                    origin: MethodTraitObject(MethodObject {\n                         trait_ref: new_trait_ref,\n                         object_trait_id: did,\n                         method_num: method_num,\n@@ -702,7 +702,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     rcvr_match_condition: condition,\n                     rcvr_substs: trait_ref.substs.clone(),\n                     method_ty: m,\n-                    origin: MethodParam(MethodParam {\n+                    origin: MethodTypeParam(MethodParam {\n                         trait_ref: trait_ref,\n                         method_num: method_num,\n                     })\n@@ -874,7 +874,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         }\n \n         let (self_ty, auto_deref_ref) = self.consider_reborrow(self_ty, autoderefs);\n-        let adjustment = Some((self.self_expr.unwrap().id, ty::AutoDerefRef(auto_deref_ref)));\n+        let adjustment = Some((self.self_expr.unwrap().id, ty::AdjustDerefRef(auto_deref_ref)));\n \n         match self.search_for_method(self_ty) {\n             None => None,\n@@ -1159,7 +1159,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                             self.fcx.write_adjustment(\n                                 self_expr_id,\n                                 self.span,\n-                                ty::AutoDerefRef(ty::AutoDerefRef {\n+                                ty::AdjustDerefRef(ty::AutoDerefRef {\n                                     autoderefs: autoderefs,\n                                     autoref: Some(kind(region, *mutbl))\n                                 }));\n@@ -1245,7 +1245,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                        candidate_a.repr(self.tcx()),\n                        candidate_b.repr(self.tcx()));\n                 match (&candidate_a.origin, &candidate_b.origin) {\n-                    (&MethodParam(ref p1), &MethodParam(ref p2)) => {\n+                    (&MethodTypeParam(ref p1), &MethodTypeParam(ref p2)) => {\n                         let same_trait =\n                             p1.trait_ref.def_id == p2.trait_ref.def_id;\n                         let same_method =\n@@ -1330,7 +1330,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n         let fn_sig = &bare_fn_ty.sig;\n         let inputs = match candidate.origin {\n-            MethodObject(..) => {\n+            MethodTraitObject(..) => {\n                 // For annoying reasons, we've already handled the\n                 // substitution of self for object calls.\n                 let args = fn_sig.inputs.slice_from(1).iter().map(|t| {\n@@ -1403,11 +1403,11 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n         match candidate.origin {\n             MethodStatic(..) |\n-            MethodParam(..) |\n+            MethodTypeParam(..) |\n             MethodStaticUnboxedClosure(..) => {\n                 return; // not a call to a trait instance\n             }\n-            MethodObject(..) => {}\n+            MethodTraitObject(..) => {}\n         }\n \n         match candidate.method_ty.explicit_self {\n@@ -1463,8 +1463,8 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             MethodStaticUnboxedClosure(_) => bad = false,\n             // FIXME: does this properly enforce this on everything now\n             // that self has been merged in? -sully\n-            MethodParam(MethodParam { trait_ref: ref trait_ref, .. }) |\n-            MethodObject(MethodObject { trait_ref: ref trait_ref, .. }) => {\n+            MethodTypeParam(MethodParam { trait_ref: ref trait_ref, .. }) |\n+            MethodTraitObject(MethodObject { trait_ref: ref trait_ref, .. }) => {\n                 bad = self.tcx().destructor_for_type.borrow()\n                           .contains_key(&trait_ref.def_id);\n             }\n@@ -1612,10 +1612,10 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             MethodStaticUnboxedClosure(did) => {\n                 self.report_static_candidate(idx, did)\n             }\n-            MethodParam(ref mp) => {\n+            MethodTypeParam(ref mp) => {\n                 self.report_param_candidate(idx, mp.trait_ref.def_id)\n             }\n-            MethodObject(ref mo) => {\n+            MethodTraitObject(ref mo) => {\n                 self.report_trait_candidate(idx, mo.trait_ref.def_id)\n             }\n         }"}, {"sha": "a8b2e0bbff257c2d929a099401b550382dd68769", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 210, "deletions": 74, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -79,7 +79,6 @@ type parameter).\n \n use middle::const_eval;\n use middle::def;\n-use middle::freevars;\n use middle::lang_items::IteratorItem;\n use middle::mem_categorization::McResult;\n use middle::mem_categorization;\n@@ -110,7 +109,7 @@ use middle::typeck::rscope::RegionScope;\n use middle::typeck::{lookup_def_ccx};\n use middle::typeck::no_params;\n use middle::typeck::{require_same_types};\n-use middle::typeck::{MethodCall, MethodMap, ObjectCastMap};\n+use middle::typeck::{MethodCall, MethodCallee, MethodMap, ObjectCastMap};\n use middle::typeck::{TypeAndSubsts};\n use middle::typeck;\n use middle::lang_items::TypeIdLangItem;\n@@ -124,7 +123,6 @@ use std::cell::{Cell, RefCell};\n use std::collections::HashMap;\n use std::mem::replace;\n use std::rc::Rc;\n-use std::slice;\n use syntax::abi;\n use syntax::ast::{ProvidedMethod, RequiredMethod, TypeTraitItem};\n use syntax::ast;\n@@ -318,7 +316,7 @@ impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n         self.ccx.tcx.upvar_borrow(upvar_id)\n     }\n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> freevars::CaptureMode {\n+                    -> ast::CaptureClause {\n         self.ccx.tcx.capture_mode(closure_expr_id)\n     }\n     fn unboxed_closures<'a>(&'a self)\n@@ -1704,7 +1702,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.write_adjustment(\n             node_id,\n             span,\n-            ty::AutoDerefRef(ty::AutoDerefRef {\n+            ty::AdjustDerefRef(ty::AutoDerefRef {\n                 autoderefs: derefs,\n                 autoref: None })\n         );\n@@ -1730,8 +1728,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                        span: Span,\n                                        adj: &ty::AutoAdjustment) {\n         match *adj {\n-            ty::AutoAddEnv(..) => { }\n-            ty::AutoDerefRef(ref d_r) => {\n+            ty::AdjustAddEnv(..) => { }\n+            ty::AdjustDerefRef(ref d_r) => {\n                 match d_r.autoref {\n                     Some(ref a_r) => {\n                         self.register_autoref_obligations(span, a_r);\n@@ -2188,12 +2186,12 @@ pub fn autoderef<T>(fcx: &FnCtxt, sp: Span, base_ty: ty::t,\n }\n \n /// Attempts to resolve a call expression as an overloaded call.\n-fn try_overloaded_call(fcx: &FnCtxt,\n-                       call_expression: &ast::Expr,\n-                       callee: &ast::Expr,\n-                       callee_type: ty::t,\n-                       args: &[P<ast::Expr>])\n-                       -> bool {\n+fn try_overloaded_call<'a>(fcx: &FnCtxt,\n+                           call_expression: &ast::Expr,\n+                           callee: &ast::Expr,\n+                           callee_type: ty::t,\n+                           args: &[&'a P<ast::Expr>])\n+                           -> bool {\n     // Bail out if the callee is a bare function or a closure. We check those\n     // manually.\n     match *structure_of(fcx, callee.span, callee_type) {\n@@ -2276,18 +2274,125 @@ fn try_overloaded_deref(fcx: &FnCtxt,\n         (method, _) => method\n     };\n \n+    make_return_type(fcx, method_call, method)\n+}\n+\n+fn get_method_ty(method: &Option<MethodCallee>) -> ty::t {\n+    match method {\n+        &Some(ref method) => method.ty,\n+        &None => ty::mk_err()\n+    }\n+}\n+\n+fn make_return_type(fcx: &FnCtxt,\n+                    method_call: Option<MethodCall>,\n+                    method: Option<MethodCallee>)\n+                    -> Option<ty::mt> {\n     match method {\n         Some(method) => {\n             let ref_ty = ty::ty_fn_ret(method.ty);\n             match method_call {\n                 Some(method_call) => {\n-                    fcx.inh.method_map.borrow_mut().insert(method_call, method);\n+                    fcx.inh.method_map.borrow_mut().insert(method_call,\n+                                                           method);\n                 }\n                 None => {}\n             }\n             ty::deref(ref_ty, true)\n         }\n-        None => None\n+        None => None,\n+    }\n+}\n+\n+fn try_overloaded_slice(fcx: &FnCtxt,\n+                        method_call: Option<MethodCall>,\n+                        expr: &ast::Expr,\n+                        base_expr: &ast::Expr,\n+                        base_ty: ty::t,\n+                        start_expr: &Option<P<ast::Expr>>,\n+                        end_expr: &Option<P<ast::Expr>>,\n+                        mutbl: &ast::Mutability)\n+                        -> Option<ty::mt> {\n+    let method = if mutbl == &ast::MutMutable {\n+        // Try `SliceMut` first, if preferred.\n+        match fcx.tcx().lang_items.slice_mut_trait() {\n+            Some(trait_did) => {\n+                let method_name = match (start_expr, end_expr) {\n+                    (&Some(_), &Some(_)) => \"slice_mut_\",\n+                    (&Some(_), &None) => \"slice_from_mut_\",\n+                    (&None, &Some(_)) => \"slice_to_mut_\",\n+                    (&None, &None) => \"as_mut_slice_\",\n+                };\n+\n+                method::lookup_in_trait(fcx,\n+                                        expr.span,\n+                                        Some(&*base_expr),\n+                                        token::intern(method_name),\n+                                        trait_did,\n+                                        base_ty,\n+                                        [],\n+                                        DontAutoderefReceiver,\n+                                        IgnoreStaticMethods)\n+            }\n+            _ => None,\n+        }\n+    } else {\n+        // Otherwise, fall back to `Slice`.\n+        // FIXME(#17293) this will not coerce base_expr, so we miss the Slice\n+        // trait for `&mut [T]`.\n+        match fcx.tcx().lang_items.slice_trait() {\n+            Some(trait_did) => {\n+                let method_name = match (start_expr, end_expr) {\n+                    (&Some(_), &Some(_)) => \"slice_\",\n+                    (&Some(_), &None) => \"slice_from_\",\n+                    (&None, &Some(_)) => \"slice_to_\",\n+                    (&None, &None) => \"as_slice_\",\n+                };\n+\n+                method::lookup_in_trait(fcx,\n+                                        expr.span,\n+                                        Some(&*base_expr),\n+                                        token::intern(method_name),\n+                                        trait_did,\n+                                        base_ty,\n+                                        [],\n+                                        DontAutoderefReceiver,\n+                                        IgnoreStaticMethods)\n+            }\n+            _ => None,\n+        }\n+    };\n+\n+\n+    // Regardless of whether the lookup succeeds, check the method arguments\n+    // so that we have *some* type for each argument.\n+    let method_type = get_method_ty(&method);\n+\n+    let mut args = vec![];\n+    start_expr.as_ref().map(|x| args.push(x));\n+    end_expr.as_ref().map(|x| args.push(x));\n+\n+    check_method_argument_types(fcx,\n+                                expr.span,\n+                                method_type,\n+                                expr,\n+                                args.as_slice(),\n+                                DoDerefArgs,\n+                                DontTupleArguments);\n+\n+    match method {\n+        Some(method) => {\n+            let result_ty = ty::ty_fn_ret(method.ty);\n+            match method_call {\n+                Some(method_call) => {\n+                    fcx.inh.method_map.borrow_mut().insert(method_call,\n+                                                           method);\n+                }\n+                None => {}\n+            }\n+            Some(ty::mt { ty: result_ty, mutbl: ast::MutImmutable })\n+        }\n+        None => None,\n     }\n }\n \n@@ -2333,32 +2438,16 @@ fn try_overloaded_index(fcx: &FnCtxt,\n \n     // Regardless of whether the lookup succeeds, check the method arguments\n     // so that we have *some* type for each argument.\n-    let method_type = match method {\n-        Some(ref method) => method.ty,\n-        None => ty::mk_err()\n-    };\n+    let method_type = get_method_ty(&method);\n     check_method_argument_types(fcx,\n                                 expr.span,\n                                 method_type,\n                                 expr,\n-                                slice::ref_slice(index_expr),\n+                                &[index_expr],\n                                 DoDerefArgs,\n                                 DontTupleArguments);\n \n-    match method {\n-        Some(method) => {\n-            let ref_ty = ty::ty_fn_ret(method.ty);\n-            match method_call {\n-                Some(method_call) => {\n-                    fcx.inh.method_map.borrow_mut().insert(method_call,\n-                                                           method);\n-                }\n-                None => {}\n-            }\n-            ty::deref(ref_ty, true)\n-        }\n-        None => None,\n-    }\n+    make_return_type(fcx, method_call, method)\n }\n \n /// Given the head of a `for` expression, looks up the `next` method in the\n@@ -2442,14 +2531,14 @@ fn lookup_method_for_for_loop(fcx: &FnCtxt,\n     }\n }\n \n-fn check_method_argument_types(fcx: &FnCtxt,\n-                               sp: Span,\n-                               method_fn_ty: ty::t,\n-                               callee_expr: &ast::Expr,\n-                               args_no_rcvr: &[P<ast::Expr>],\n-                               deref_args: DerefArgs,\n-                               tuple_arguments: TupleArgumentsFlag)\n-                               -> ty::t {\n+fn check_method_argument_types<'a>(fcx: &FnCtxt,\n+                                   sp: Span,\n+                                   method_fn_ty: ty::t,\n+                                   callee_expr: &ast::Expr,\n+                                   args_no_rcvr: &[&'a P<ast::Expr>],\n+                                   deref_args: DerefArgs,\n+                                   tuple_arguments: TupleArgumentsFlag)\n+                                   -> ty::t {\n     if ty::type_is_error(method_fn_ty) {\n        let err_inputs = err_args(args_no_rcvr.len());\n         check_argument_types(fcx,\n@@ -2483,14 +2572,14 @@ fn check_method_argument_types(fcx: &FnCtxt,\n     }\n }\n \n-fn check_argument_types(fcx: &FnCtxt,\n-                        sp: Span,\n-                        fn_inputs: &[ty::t],\n-                        _callee_expr: &ast::Expr,\n-                        args: &[P<ast::Expr>],\n-                        deref_args: DerefArgs,\n-                        variadic: bool,\n-                        tuple_arguments: TupleArgumentsFlag) {\n+fn check_argument_types<'a>(fcx: &FnCtxt,\n+                            sp: Span,\n+                            fn_inputs: &[ty::t],\n+                            _callee_expr: &ast::Expr,\n+                            args: &[&'a P<ast::Expr>],\n+                            deref_args: DerefArgs,\n+                            variadic: bool,\n+                            tuple_arguments: TupleArgumentsFlag) {\n     /*!\n      *\n      * Generic function that factors out common logic from\n@@ -2627,7 +2716,7 @@ fn check_argument_types(fcx: &FnCtxt,\n                     DontDerefArgs => {}\n                 }\n \n-                check_expr_coercable_to_type(fcx, &**arg, formal_ty);\n+                check_expr_coercable_to_type(fcx, &***arg, formal_ty);\n             }\n         }\n     }\n@@ -2636,12 +2725,12 @@ fn check_argument_types(fcx: &FnCtxt,\n     // arguments which we skipped above.\n     if variadic {\n         for arg in args.iter().skip(expected_arg_count) {\n-            check_expr(fcx, &**arg);\n+            check_expr(fcx, &***arg);\n \n             // There are a few types which get autopromoted when passed via varargs\n             // in C but we just error out instead and require explicit casts.\n             let arg_ty = structurally_resolved_type(fcx, arg.span,\n-                                                    fcx.expr_ty(&**arg));\n+                                                    fcx.expr_ty(&***arg));\n             match ty::get(arg_ty).sty {\n                 ty::ty_float(ast::TyF32) => {\n                     fcx.type_error_message(arg.span,\n@@ -2877,10 +2966,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n            expr.repr(fcx.tcx()), expected.repr(fcx.tcx()));\n \n     // A generic function for doing all of the checking for call expressions\n-    fn check_call(fcx: &FnCtxt,\n-                  call_expr: &ast::Expr,\n-                  f: &ast::Expr,\n-                  args: &[P<ast::Expr>]) {\n+    fn check_call<'a>(fcx: &FnCtxt,\n+                      call_expr: &ast::Expr,\n+                      f: &ast::Expr,\n+                      args: &[&'a P<ast::Expr>]) {\n         // Store the type of `f` as the type of the callee\n         let fn_ty = fcx.expr_ty(f);\n \n@@ -2990,11 +3079,12 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         };\n \n         // Call the generic checker.\n+        let args: Vec<_> = args.slice_from(1).iter().map(|x| x).collect();\n         let ret_ty = check_method_argument_types(fcx,\n                                                  method_name.span,\n                                                  fn_ty,\n                                                  expr,\n-                                                 args.slice_from(1),\n+                                                 args.as_slice(),\n                                                  DontDerefArgs,\n                                                  DontTupleArguments);\n \n@@ -3085,12 +3175,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             None => None\n         };\n         let args = match rhs {\n-            Some(rhs) => slice::ref_slice(rhs),\n-            None => {\n-                // Work around the lack of coercion.\n-                let empty: &[_] = &[];\n-                empty\n-            }\n+            Some(rhs) => vec![rhs],\n+            None => vec![]\n         };\n         match method {\n             Some(method) => {\n@@ -3102,7 +3188,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                             op_ex.span,\n                                             method_ty,\n                                             op_ex,\n-                                            args,\n+                                            args.as_slice(),\n                                             DoDerefArgs,\n                                             DontTupleArguments)\n             }\n@@ -3115,7 +3201,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                             op_ex.span,\n                                             expected_ty,\n                                             op_ex,\n-                                            args,\n+                                            args.as_slice(),\n                                             DoDerefArgs,\n                                             DontTupleArguments);\n                 ty::mk_err()\n@@ -4136,12 +4222,13 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n           check_expr(fcx, &**f);\n           let f_ty = fcx.expr_ty(&**f);\n \n+          let args: Vec<_> = args.iter().map(|x| x).collect();\n           if !try_overloaded_call(fcx, expr, &**f, f_ty, args.as_slice()) {\n               check_call(fcx, expr, &**f, args.as_slice());\n               let (args_bot, args_err) = args.iter().fold((false, false),\n                  |(rest_bot, rest_err), a| {\n                      // is this not working?\n-                     let a_ty = fcx.expr_ty(&**a);\n+                     let a_ty = fcx.expr_ty(&***a);\n                      (rest_bot || ty::type_is_bot(a_ty),\n                       rest_err || ty::type_is_error(a_ty))});\n               if ty::type_is_error(f_ty) || args_err {\n@@ -4427,6 +4514,61 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n               }\n           }\n        }\n+       ast::ExprSlice(ref base, ref start, ref end, ref mutbl) => {\n+          check_expr_with_lvalue_pref(fcx, &**base, lvalue_pref);\n+          let raw_base_t = fcx.expr_ty(&**base);\n+\n+          let mut some_err = false;\n+          if ty::type_is_error(raw_base_t) || ty::type_is_bot(raw_base_t) {\n+              fcx.write_ty(id, raw_base_t);\n+              some_err = true;\n+          }\n+\n+          {\n+              let check_slice_idx = |e: &ast::Expr| {\n+                  check_expr(fcx, e);\n+                  let e_t = fcx.expr_ty(e);\n+                  if ty::type_is_error(e_t) || ty::type_is_bot(e_t) {\n+                    fcx.write_ty(id, e_t);\n+                    some_err = true;\n+                  }\n+              };\n+              start.as_ref().map(|e| check_slice_idx(&**e));\n+              end.as_ref().map(|e| check_slice_idx(&**e));\n+          }\n+\n+          if !some_err {\n+              let base_t = structurally_resolved_type(fcx,\n+                                                      expr.span,\n+                                                      raw_base_t);\n+              let method_call = MethodCall::expr(expr.id);\n+              match try_overloaded_slice(fcx,\n+                                         Some(method_call),\n+                                         expr,\n+                                         &**base,\n+                                         base_t,\n+                                         start,\n+                                         end,\n+                                         mutbl) {\n+                  Some(mt) => fcx.write_ty(id, mt.ty),\n+                  None => {\n+                        fcx.type_error_message(expr.span,\n+                           |actual| {\n+                                format!(\"cannot take a {}slice of a value with type `{}`\",\n+                                        if mutbl == &ast::MutMutable {\n+                                            \"mutable \"\n+                                        } else {\n+                                            \"\"\n+                                        },\n+                                        actual)\n+                           },\n+                           base_t,\n+                           None);\n+                        fcx.write_ty(id, ty::mk_err())\n+                  }\n+              }\n+          }\n+       }\n     }\n \n     debug!(\"type of expr({}) {} is...\", expr.id,\n@@ -5027,8 +5169,7 @@ pub fn polytype_for_def(fcx: &FnCtxt,\n                         defn: def::Def)\n                         -> Polytype {\n     match defn {\n-      def::DefArg(nid, _) | def::DefLocal(nid, _) |\n-      def::DefBinding(nid, _) => {\n+      def::DefLocal(nid) | def::DefUpvar(nid, _, _) => {\n           let typ = fcx.local_ty(sp, nid);\n           return no_params(typ);\n       }\n@@ -5037,9 +5178,6 @@ pub fn polytype_for_def(fcx: &FnCtxt,\n       def::DefStruct(id) => {\n         return ty::lookup_item_type(fcx.ccx.tcx, id);\n       }\n-      def::DefUpvar(_, inner, _, _) => {\n-        return polytype_for_def(fcx, sp, *inner);\n-      }\n       def::DefTrait(_) |\n       def::DefTy(..) |\n       def::DefAssociatedTy(..) |\n@@ -5183,10 +5321,8 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         // elsewhere. (I hope)\n         def::DefMod(..) |\n         def::DefForeignMod(..) |\n-        def::DefArg(..) |\n         def::DefLocal(..) |\n         def::DefMethod(..) |\n-        def::DefBinding(..) |\n         def::DefUse(..) |\n         def::DefRegion(..) |\n         def::DefLabel(..) |"}, {"sha": "d0791191c0fc090ae4672b8591be939206aa51fa", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -119,8 +119,6 @@ and report an error, and it just seems like more mess in the end.)\n */\n \n use middle::def;\n-use middle::def::{DefArg, DefBinding, DefLocal, DefUpvar};\n-use middle::freevars;\n use middle::mem_categorization as mc;\n use middle::ty::{ReScope};\n use middle::ty;\n@@ -243,14 +241,14 @@ fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n \n     let tcx = fcx.tcx();\n     match def {\n-        DefLocal(node_id, _) | DefArg(node_id, _) |\n-        DefBinding(node_id, _) => {\n+        def::DefLocal(node_id) => {\n             tcx.region_maps.var_region(node_id)\n         }\n-        DefUpvar(_, subdef, closure_id, body_id) => {\n-            match ty::ty_closure_store(fcx.node_ty(closure_id)) {\n-                ty::RegionTraitStore(..) => region_of_def(fcx, *subdef),\n-                ty::UniqTraitStore => ReScope(body_id)\n+        def::DefUpvar(node_id, _, body_id) => {\n+            if body_id == ast::DUMMY_NODE_ID {\n+                tcx.region_maps.var_region(node_id)\n+            } else {\n+                ReScope(body_id)\n             }\n         }\n         _ => {\n@@ -479,7 +477,7 @@ impl<'fcx, 'tcx> mc::Typer<'tcx> for Rcx<'fcx, 'tcx> {\n     }\n \n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> freevars::CaptureMode {\n+                    -> ast::CaptureClause {\n         self.tcx().capture_modes.borrow().get_copy(&closure_expr_id)\n     }\n \n@@ -592,7 +590,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     for &adjustment in rcx.fcx.inh.adjustments.borrow().find(&expr.id).iter() {\n         debug!(\"adjustment={:?}\", adjustment);\n         match *adjustment {\n-            ty::AutoDerefRef(ty::AutoDerefRef {autoderefs, autoref: ref opt_autoref}) => {\n+            ty::AdjustDerefRef(ty::AutoDerefRef {autoderefs, autoref: ref opt_autoref}) => {\n                 let expr_ty = rcx.resolve_node_type(expr.id);\n                 constrain_autoderefs(rcx, expr, autoderefs, expr_ty);\n                 for autoref in opt_autoref.iter() {\n@@ -852,7 +850,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                                          ..}) => {\n             // For closure, ensure that the variables outlive region\n             // bound, since they are captured by reference.\n-            freevars::with_freevars(tcx, expr.id, |freevars| {\n+            ty::with_freevars(tcx, expr.id, |freevars| {\n                 if freevars.is_empty() {\n                     // No free variables means that the environment\n                     // will be NULL at runtime and hence the closure\n@@ -875,13 +873,13 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                                          ..}) => {\n             // For proc, ensure that the *types* of the variables\n             // outlive region bound, since they are captured by value.\n-            freevars::with_freevars(tcx, expr.id, |freevars| {\n+            ty::with_freevars(tcx, expr.id, |freevars| {\n                 ensure_free_variable_types_outlive_closure_bound(\n                     rcx, bounds.region_bound, expr, freevars);\n             });\n         }\n         ty::ty_unboxed_closure(_, region) => {\n-            freevars::with_freevars(tcx, expr.id, |freevars| {\n+            ty::with_freevars(tcx, expr.id, |freevars| {\n                 // No free variables means that there is no environment and\n                 // hence the closure has static lifetime. Otherwise, the\n                 // closure must not outlive the variables it closes over\n@@ -907,7 +905,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                 store: ty::RegionTraitStore(..),\n                 ..\n             }) => {\n-            freevars::with_freevars(tcx, expr.id, |freevars| {\n+            ty::with_freevars(tcx, expr.id, |freevars| {\n                 propagate_upupvar_borrow_kind(rcx, expr, freevars);\n             })\n         }\n@@ -918,7 +916,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         rcx: &mut Rcx,\n         region_bound: ty::Region,\n         expr: &ast::Expr,\n-        freevars: &[freevars::freevar_entry])\n+        freevars: &[ty::Freevar])\n     {\n         /*!\n          * Make sure that the type of all free variables referenced\n@@ -951,7 +949,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         rcx: &mut Rcx,\n         region_bound: ty::Region,\n         expr: &ast::Expr,\n-        freevars: &[freevars::freevar_entry])\n+        freevars: &[ty::Freevar])\n     {\n         /*!\n          * Make sure that all free variables referenced inside the\n@@ -1001,7 +999,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n \n     fn propagate_upupvar_borrow_kind(rcx: &mut Rcx,\n                                      expr: &ast::Expr,\n-                                     freevars: &[freevars::freevar_entry]) {\n+                                     freevars: &[ty::Freevar]) {\n         let tcx = rcx.fcx.ccx.tcx;\n         debug!(\"propagate_upupvar_borrow_kind({})\", expr.repr(tcx));\n         for freevar in freevars.iter() {\n@@ -1031,7 +1029,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             // determining the final borrow_kind) and propagate that as\n             // a constraint on the outer closure.\n             match freevar.def {\n-                def::DefUpvar(var_id, _, outer_closure_id, _) => {\n+                def::DefUpvar(var_id, outer_closure_id, _) => {\n                     // thing being captured is itself an upvar:\n                     let outer_upvar_id = ty::UpvarId {\n                         var_id: var_id,\n@@ -1475,7 +1473,6 @@ fn link_region(rcx: &Rcx,\n             mc::cat_static_item |\n             mc::cat_copied_upvar(..) |\n             mc::cat_local(..) |\n-            mc::cat_arg(..) |\n             mc::cat_upvar(..) |\n             mc::cat_rvalue(..) => {\n                 // These are all \"base cases\" with independent lifetimes\n@@ -1701,7 +1698,6 @@ fn adjust_upvar_borrow_kind_for_mut(rcx: &Rcx,\n             mc::cat_rvalue(_) |\n             mc::cat_copied_upvar(_) |\n             mc::cat_local(_) |\n-            mc::cat_arg(_) |\n             mc::cat_upvar(..) => {\n                 return;\n             }\n@@ -1753,7 +1749,6 @@ fn adjust_upvar_borrow_kind_for_unique(rcx: &Rcx, cmt: mc::cmt) {\n             mc::cat_rvalue(_) |\n             mc::cat_copied_upvar(_) |\n             mc::cat_local(_) |\n-            mc::cat_arg(_) |\n             mc::cat_upvar(..) => {\n                 return;\n             }"}, {"sha": "0022efd845e30f1d88765f000f3f03b9124b6f3a", "filename": "src/librustc/middle/typeck/check/vtable2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -13,7 +13,7 @@ use middle::traits;\n use middle::traits::{SelectionError, Overflow,\n                      OutputTypeParameterMismatch, Unimplemented};\n use middle::traits::{Obligation, obligation_for_builtin_bound};\n-use middle::traits::{FulfillmentError, Ambiguity};\n+use middle::traits::{FulfillmentError, CodeSelectionError, CodeAmbiguity};\n use middle::traits::{ObligationCause};\n use middle::ty;\n use middle::typeck::check::{FnCtxt,\n@@ -244,10 +244,10 @@ pub fn report_fulfillment_errors(fcx: &FnCtxt,\n pub fn report_fulfillment_error(fcx: &FnCtxt,\n                                 error: &FulfillmentError) {\n     match error.code {\n-        SelectionError(ref e) => {\n+        CodeSelectionError(ref e) => {\n             report_selection_error(fcx, &error.obligation, e);\n         }\n-        Ambiguity => {\n+        CodeAmbiguity => {\n             maybe_report_ambiguity(fcx, &error.obligation);\n         }\n     }"}, {"sha": "e2a04116f9008f2b82ceae2b742f8aec83643b50", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -282,7 +282,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             Some(adjustment) => {\n                 let adj_object = ty::adjust_is_object(&adjustment);\n                 let resolved_adjustment = match adjustment {\n-                    ty::AutoAddEnv(store) => {\n+                    ty::AdjustAddEnv(store) => {\n                         // FIXME(eddyb) #2190 Allow only statically resolved\n                         // bare functions to coerce to a closure to avoid\n                         // constructing (slower) indirect call wrappers.\n@@ -298,10 +298,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                             }\n                         }\n \n-                        ty::AutoAddEnv(self.resolve(&store, reason))\n+                        ty::AdjustAddEnv(self.resolve(&store, reason))\n                     }\n \n-                    ty::AutoDerefRef(adj) => {\n+                    ty::AdjustDerefRef(adj) => {\n                         for autoderef in range(0, adj.autoderefs) {\n                             let method_call = MethodCall::autoderef(id, autoderef);\n                             self.visit_method_map_entry(reason, method_call);\n@@ -312,7 +312,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                             self.visit_method_map_entry(reason, method_call);\n                         }\n \n-                        ty::AutoDerefRef(ty::AutoDerefRef {\n+                        ty::AdjustDerefRef(ty::AutoDerefRef {\n                             autoderefs: adj.autoderefs,\n                             autoref: self.resolve(&adj.autoref, reason),\n                         })"}, {"sha": "40c52fd36b9c15a278fabe6597842c48857f8601", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -1427,7 +1427,8 @@ pub fn instantiate_unboxed_fn_ty<'tcx,AC>(this: &AC,\n     let param_ty = param_ty.to_ty(this.tcx());\n     Rc::new(astconv::trait_ref_for_unboxed_function(this,\n                                                     &rscope,\n-                                                    unboxed_function,\n+                                                    unboxed_function.kind,\n+                                                    &*unboxed_function.decl,\n                                                     Some(param_ty)))\n }\n \n@@ -2165,9 +2166,42 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n                                      region_bounds,\n                                      unboxed_fn_ty_bounds } =\n         astconv::partition_bounds(this.tcx(), span, all_bounds.as_slice());\n-    let unboxed_fn_ty_bounds =\n-        unboxed_fn_ty_bounds.into_iter()\n-        .map(|b| instantiate_unboxed_fn_ty(this, b, param_ty));\n+\n+    let unboxed_fn_ty_bounds = unboxed_fn_ty_bounds.move_iter().map(|b| {\n+        let trait_id = this.tcx().def_map.borrow().get(&b.ref_id).def_id();\n+        let mut kind = None;\n+        for &(lang_item, this_kind) in [\n+            (this.tcx().lang_items.fn_trait(), ast::FnUnboxedClosureKind),\n+            (this.tcx().lang_items.fn_mut_trait(),\n+             ast::FnMutUnboxedClosureKind),\n+            (this.tcx().lang_items.fn_once_trait(),\n+             ast::FnOnceUnboxedClosureKind)\n+        ].iter() {\n+            if Some(trait_id) == lang_item {\n+                kind = Some(this_kind);\n+                break\n+            }\n+        }\n+\n+        let kind = match kind {\n+            Some(kind) => kind,\n+            None => {\n+                this.tcx().sess.span_err(b.path.span,\n+                                         \"unboxed function trait must be one \\\n+                                          of `Fn`, `FnMut`, or `FnOnce`\");\n+                ast::FnMutUnboxedClosureKind\n+            }\n+        };\n+\n+        let rscope = ExplicitRscope;\n+        let param_ty = param_ty.to_ty(this.tcx());\n+        Rc::new(astconv::trait_ref_for_unboxed_function(this,\n+                                                        &rscope,\n+                                                        kind,\n+                                                        &*b.decl,\n+                                                        Some(param_ty)))\n+    });\n+\n     let trait_bounds: Vec<Rc<ty::TraitRef>> =\n         trait_bounds.into_iter()\n         .map(|b| {"}, {"sha": "7f9f569c37ea2f72c2b90ca7c13fc5f4467cb0e1", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -65,7 +65,7 @@ we may want to adjust precisely when coercions occur.\n */\n \n use middle::subst;\n-use middle::ty::{AutoPtr, AutoDerefRef, AutoUnsize, AutoUnsafe};\n+use middle::ty::{AutoPtr, AutoDerefRef, AdjustDerefRef, AutoUnsize, AutoUnsafe};\n use middle::ty::{mt};\n use middle::ty;\n use middle::typeck::infer::{CoerceResult, resolve_type, Coercion};\n@@ -270,7 +270,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                      mt {ty: inner_ty, mutbl: mutbl_b});\n         try!(sub.tys(a_borrowed, b));\n \n-        Ok(Some(AutoDerefRef(AutoDerefRef {\n+        Ok(Some(AdjustDerefRef(AutoDerefRef {\n             autoderefs: 1,\n             autoref: Some(AutoPtr(r_borrow, mutbl_b, None))\n         })))\n@@ -295,7 +295,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 let unsized_ty = ty::mk_slice(self.get_ref().infcx.tcx, r_borrow,\n                                               mt {ty: t_a, mutbl: mutbl_b});\n                 try!(self.get_ref().infcx.try(|| sub.tys(unsized_ty, b)));\n-                Ok(Some(AutoDerefRef(AutoDerefRef {\n+                Ok(Some(AdjustDerefRef(AutoDerefRef {\n                     autoderefs: 0,\n                     autoref: Some(ty::AutoPtr(r_borrow,\n                                               mutbl_b,\n@@ -343,7 +343,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoPtr(AutoUnsize({:?})))\", kind);\n-                            Ok(Some(AutoDerefRef(AutoDerefRef {\n+                            Ok(Some(AdjustDerefRef(AutoDerefRef {\n                                 autoderefs: 1,\n                                 autoref: Some(ty::AutoPtr(r_borrow, mt_b.mutbl,\n                                                           Some(box AutoUnsize(kind))))\n@@ -366,7 +366,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoPtr(AutoUnsize({:?})))\", kind);\n-                            Ok(Some(AutoDerefRef(AutoDerefRef {\n+                            Ok(Some(AdjustDerefRef(AutoDerefRef {\n                                 autoderefs: 1,\n                                 autoref: Some(ty::AutoUnsafe(mt_b.mutbl,\n                                                              Some(box AutoUnsize(kind))))\n@@ -384,7 +384,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoUnsizeUniq({:?}))\", kind);\n-                            Ok(Some(AutoDerefRef(AutoDerefRef {\n+                            Ok(Some(AdjustDerefRef(AutoDerefRef {\n                                 autoderefs: 1,\n                                 autoref: Some(ty::AutoUnsizeUniq(kind))\n                             })))\n@@ -537,7 +537,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                     let tr = ty::mk_trait(tcx, def_id, substs.clone(), bounds);\n                     try!(self.subtype(mk_ty(tr), b));\n-                    Ok(Some(AutoDerefRef(AutoDerefRef {\n+                    Ok(Some(AdjustDerefRef(AutoDerefRef {\n                         autoderefs: 1,\n                         autoref: Some(mk_adjust())\n                     })))\n@@ -593,7 +593,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 _ => return self.subtype(a, b)\n             };\n \n-            let adj = ty::AutoAddEnv(fn_ty_b.store);\n+            let adj = ty::AdjustAddEnv(fn_ty_b.store);\n             let a_closure = ty::mk_closure(self.get_ref().infcx.tcx,\n                                            ty::ClosureTy {\n                                                 sig: fn_ty_a.sig.clone(),\n@@ -630,7 +630,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // Although references and unsafe ptrs have the same\n         // representation, we still register an AutoDerefRef so that\n         // regionck knows that the region for `a` must be valid here.\n-        Ok(Some(AutoDerefRef(AutoDerefRef {\n+        Ok(Some(AdjustDerefRef(AutoDerefRef {\n             autoderefs: 1,\n             autoref: Some(ty::AutoUnsafe(mutbl_b, None))\n         })))"}, {"sha": "29cd2e77e8b1f05a2bb1d8e3f6aa963c0df8389e", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -22,7 +22,6 @@ use driver::diagnostic;\n use driver::diagnostic::Emitter;\n use driver::driver;\n use driver::session;\n-use middle::freevars;\n use middle::lang_items;\n use middle::region;\n use middle::resolve;\n@@ -125,10 +124,8 @@ fn test_env(_test_name: &str,\n \n     // run just enough stuff to build a tcx:\n     let lang_items = lang_items::collect_language_items(krate, &sess);\n-    let resolve::CrateMap { def_map: def_map, .. } =\n+    let resolve::CrateMap { def_map, freevars, capture_mode_map, .. } =\n         resolve::resolve_crate(&sess, &lang_items, krate);\n-    let (freevars_map, captures_map) = freevars::annotate_freevars(&def_map,\n-                                                                   krate);\n     let named_region_map = resolve_lifetime::krate(&sess, krate);\n     let region_map = region::resolve_crate(&sess, krate);\n     let stability_index = stability::Index::build(krate);\n@@ -138,8 +135,8 @@ fn test_env(_test_name: &str,\n                           def_map,\n                           named_region_map,\n                           ast_map,\n-                          freevars_map,\n-                          captures_map,\n+                          freevars,\n+                          capture_mode_map,\n                           region_map,\n                           lang_items,\n                           stability_index);"}, {"sha": "e93ad056051f5bb3723ffbb4b0f0238a2414c5ea", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -102,10 +102,10 @@ pub enum MethodOrigin {\n     MethodStaticUnboxedClosure(ast::DefId),\n \n     // method invoked on a type parameter with a bounded trait\n-    MethodParam(MethodParam),\n+    MethodTypeParam(MethodParam),\n \n     // method invoked on a trait instance\n-    MethodObject(MethodObject),\n+    MethodTraitObject(MethodObject),\n \n }\n "}, {"sha": "88e6f0ad186c6cd2bed5752bf11e248c8f9a1df0", "filename": "src/librustc/plugin/registry.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fplugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Fplugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fregistry.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -13,7 +13,7 @@\n use lint::{LintPassObject, LintId, Lint};\n \n use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT};\n-use syntax::ext::base::{IdentTT, LetSyntaxTT, ItemDecorator, ItemModifier};\n+use syntax::ext::base::{IdentTT, LetSyntaxTT, Decorator, Modifier};\n use syntax::ext::base::{MacroExpanderFn};\n use syntax::codemap::Span;\n use syntax::parse::token;\n@@ -61,8 +61,8 @@ impl Registry {\n         self.syntax_exts.push((name, match extension {\n             NormalTT(ext, _) => NormalTT(ext, Some(self.krate_span)),\n             IdentTT(ext, _) => IdentTT(ext, Some(self.krate_span)),\n-            ItemDecorator(ext) => ItemDecorator(ext),\n-            ItemModifier(ext) => ItemModifier(ext),\n+            Decorator(ext) => Decorator(ext),\n+            Modifier(ext) => Modifier(ext),\n             // there's probably a nicer way to signal this:\n             LetSyntaxTT(_, _) => fail!(\"can't register a new LetSyntax!\"),\n         }));"}, {"sha": "5b83f024309bf34acb582b6f0f9cbee42932e5b2", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -962,10 +962,10 @@ impl Repr for typeck::MethodOrigin {\n             &typeck::MethodStaticUnboxedClosure(def_id) => {\n                 format!(\"MethodStaticUnboxedClosure({})\", def_id.repr(tcx))\n             }\n-            &typeck::MethodParam(ref p) => {\n+            &typeck::MethodTypeParam(ref p) => {\n                 p.repr(tcx)\n             }\n-            &typeck::MethodObject(ref p) => {\n+            &typeck::MethodTraitObject(ref p) => {\n                 p.repr(tcx)\n             }\n         }"}, {"sha": "f98a2dac0841cd5ebbd37a7252b26a11fdd8a748", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -245,6 +245,7 @@ mod svh_visitor {\n         SawExprAssign,\n         SawExprAssignOp(ast::BinOp),\n         SawExprIndex,\n+        SawExprSlice,\n         SawExprPath,\n         SawExprAddrOf(ast::Mutability),\n         SawExprRet,\n@@ -279,6 +280,7 @@ mod svh_visitor {\n             ExprField(_, id, _)      => SawExprField(content(id.node)),\n             ExprTupField(_, id, _)   => SawExprTupField(id.node),\n             ExprIndex(..)            => SawExprIndex,\n+            ExprSlice(..)            => SawExprSlice,\n             ExprPath(..)             => SawExprPath,\n             ExprAddrOf(m, _)         => SawExprAddrOf(m),\n             ExprBreak(id)            => SawExprBreak(id.map(content)),"}, {"sha": "22e7ec6124f0dadb5606491072889e843803573e", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 46, "deletions": 45, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -91,34 +91,35 @@ pub enum DiagnosticSeverity {\n     Note,\n }\n \n-#[deriving(Clone)]\n-pub enum Attribute {\n-    ZExtAttribute = 1 << 0,\n-    SExtAttribute = 1 << 1,\n-    NoReturnAttribute = 1 << 2,\n-    InRegAttribute = 1 << 3,\n-    StructRetAttribute = 1 << 4,\n-    NoUnwindAttribute = 1 << 5,\n-    NoAliasAttribute = 1 << 6,\n-    ByValAttribute = 1 << 7,\n-    NestAttribute = 1 << 8,\n-    ReadNoneAttribute = 1 << 9,\n-    ReadOnlyAttribute = 1 << 10,\n-    NoInlineAttribute = 1 << 11,\n-    AlwaysInlineAttribute = 1 << 12,\n-    OptimizeForSizeAttribute = 1 << 13,\n-    StackProtectAttribute = 1 << 14,\n-    StackProtectReqAttribute = 1 << 15,\n-    AlignmentAttribute = 31 << 16,\n-    NoCaptureAttribute = 1 << 21,\n-    NoRedZoneAttribute = 1 << 22,\n-    NoImplicitFloatAttribute = 1 << 23,\n-    NakedAttribute = 1 << 24,\n-    InlineHintAttribute = 1 << 25,\n-    StackAttribute = 7 << 26,\n-    ReturnsTwiceAttribute = 1 << 29,\n-    UWTableAttribute = 1 << 30,\n-    NonLazyBindAttribute = 1 << 31,\n+bitflags! {\n+    flags Attribute : u32 {\n+        static ZExtAttribute = 1 << 0,\n+        static SExtAttribute = 1 << 1,\n+        static NoReturnAttribute = 1 << 2,\n+        static InRegAttribute = 1 << 3,\n+        static StructRetAttribute = 1 << 4,\n+        static NoUnwindAttribute = 1 << 5,\n+        static NoAliasAttribute = 1 << 6,\n+        static ByValAttribute = 1 << 7,\n+        static NestAttribute = 1 << 8,\n+        static ReadNoneAttribute = 1 << 9,\n+        static ReadOnlyAttribute = 1 << 10,\n+        static NoInlineAttribute = 1 << 11,\n+        static AlwaysInlineAttribute = 1 << 12,\n+        static OptimizeForSizeAttribute = 1 << 13,\n+        static StackProtectAttribute = 1 << 14,\n+        static StackProtectReqAttribute = 1 << 15,\n+        static AlignmentAttribute = 31 << 16,\n+        static NoCaptureAttribute = 1 << 21,\n+        static NoRedZoneAttribute = 1 << 22,\n+        static NoImplicitFloatAttribute = 1 << 23,\n+        static NakedAttribute = 1 << 24,\n+        static InlineHintAttribute = 1 << 25,\n+        static StackAttribute = 7 << 26,\n+        static ReturnsTwiceAttribute = 1 << 29,\n+        static UWTableAttribute = 1 << 30,\n+        static NonLazyBindAttribute = 1 << 31,\n+    }\n }\n \n #[repr(u64)]\n@@ -160,13 +161,13 @@ trait AttrHelper {\n impl AttrHelper for Attribute {\n     fn apply_llfn(&self, idx: c_uint, llfn: ValueRef) {\n         unsafe {\n-            LLVMAddFunctionAttribute(llfn, idx, *self as uint64_t);\n+            LLVMAddFunctionAttribute(llfn, idx, self.bits() as uint64_t);\n         }\n     }\n \n     fn apply_callsite(&self, idx: c_uint, callsite: ValueRef) {\n         unsafe {\n-            LLVMAddCallSiteAttribute(callsite, idx, *self as uint64_t);\n+            LLVMAddCallSiteAttribute(callsite, idx, self.bits() as uint64_t);\n         }\n     }\n }\n@@ -296,17 +297,17 @@ pub enum TypeKind {\n \n #[repr(C)]\n pub enum AtomicBinOp {\n-    Xchg = 0,\n-    Add  = 1,\n-    Sub  = 2,\n-    And  = 3,\n-    Nand = 4,\n-    Or   = 5,\n-    Xor  = 6,\n-    Max  = 7,\n-    Min  = 8,\n-    UMax = 9,\n-    UMin = 10,\n+    AtomicXchg = 0,\n+    AtomicAdd  = 1,\n+    AtomicSub  = 2,\n+    AtomicAnd  = 3,\n+    AtomicNand = 4,\n+    AtomicOr   = 5,\n+    AtomicXor  = 6,\n+    AtomicMax  = 7,\n+    AtomicMin  = 8,\n+    AtomicUMax = 9,\n+    AtomicUMin = 10,\n }\n \n #[repr(C)]\n@@ -324,11 +325,11 @@ pub enum AtomicOrdering {\n // Consts for the LLVMCodeGenFileType type (in include/llvm/c/TargetMachine.h)\n #[repr(C)]\n pub enum FileType {\n-    AssemblyFile = 0,\n-    ObjectFile = 1\n+    AssemblyFileType = 0,\n+    ObjectFileType = 1\n }\n \n-pub enum Metadata {\n+pub enum MetadataType {\n     MD_dbg = 0,\n     MD_tbaa = 1,\n     MD_prof = 2,\n@@ -2009,7 +2010,7 @@ pub fn ConstFCmp(pred: RealPredicate, v1: ValueRef, v2: ValueRef) -> ValueRef {\n \n pub fn SetFunctionAttribute(fn_: ValueRef, attr: Attribute) {\n     unsafe {\n-        LLVMAddFunctionAttribute(fn_, FunctionIndex as c_uint, attr as uint64_t)\n+        LLVMAddFunctionAttribute(fn_, FunctionIndex as c_uint, attr.bits() as uint64_t)\n     }\n }\n "}, {"sha": "b4d44aab239214b1d068c74c6be8fea4efb4a00a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -99,7 +99,7 @@ pub struct Crate {\n     pub name: String,\n     pub module: Option<Item>,\n     pub externs: Vec<(ast::CrateNum, ExternalCrate)>,\n-    pub primitives: Vec<Primitive>,\n+    pub primitives: Vec<PrimitiveType>,\n }\n \n impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n@@ -147,7 +147,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n                     ModuleItem(ref mut m) => m,\n                     _ => continue,\n                 };\n-                let prim = match Primitive::find(child.attrs.as_slice()) {\n+                let prim = match PrimitiveType::find(child.attrs.as_slice()) {\n                     Some(prim) => prim,\n                     None => continue,\n                 };\n@@ -187,7 +187,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n pub struct ExternalCrate {\n     pub name: String,\n     pub attrs: Vec<Attribute>,\n-    pub primitives: Vec<Primitive>,\n+    pub primitives: Vec<PrimitiveType>,\n }\n \n impl Clean<ExternalCrate> for cstore::crate_metadata {\n@@ -202,7 +202,7 @@ impl Clean<ExternalCrate> for cstore::crate_metadata {\n                     _ => return\n                 };\n                 let attrs = inline::load_attrs(cx, tcx, did);\n-                Primitive::find(attrs.as_slice()).map(|prim| primitives.push(prim));\n+                PrimitiveType::find(attrs.as_slice()).map(|prim| primitives.push(prim));\n             })\n         });\n         ExternalCrate {\n@@ -316,7 +316,7 @@ pub enum ItemEnum {\n     /// `static`s from an extern block\n     ForeignStaticItem(Static),\n     MacroItem(Macro),\n-    PrimitiveItem(Primitive),\n+    PrimitiveItem(PrimitiveType),\n     AssociatedTypeItem,\n }\n \n@@ -901,7 +901,7 @@ impl Clean<RetStyle> for ast::RetStyle {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct Trait {\n-    pub items: Vec<TraitItem>,\n+    pub items: Vec<TraitMethod>,\n     pub generics: Generics,\n     pub bounds: Vec<TyParamBound>,\n }\n@@ -931,13 +931,13 @@ impl Clean<Type> for ast::TraitRef {\n }\n \n #[deriving(Clone, Encodable, Decodable)]\n-pub enum TraitItem {\n+pub enum TraitMethod {\n     RequiredMethod(Item),\n     ProvidedMethod(Item),\n     TypeTraitItem(Item),\n }\n \n-impl TraitItem {\n+impl TraitMethod {\n     pub fn is_req(&self) -> bool {\n         match self {\n             &RequiredMethod(..) => true,\n@@ -959,8 +959,8 @@ impl TraitItem {\n     }\n }\n \n-impl Clean<TraitItem> for ast::TraitItem {\n-    fn clean(&self, cx: &DocContext) -> TraitItem {\n+impl Clean<TraitMethod> for ast::TraitItem {\n+    fn clean(&self, cx: &DocContext) -> TraitMethod {\n         match self {\n             &ast::RequiredMethod(ref t) => RequiredMethod(t.clean(cx)),\n             &ast::ProvidedMethod(ref t) => ProvidedMethod(t.clean(cx)),\n@@ -970,13 +970,13 @@ impl Clean<TraitItem> for ast::TraitItem {\n }\n \n #[deriving(Clone, Encodable, Decodable)]\n-pub enum ImplItem {\n+pub enum ImplMethod {\n     MethodImplItem(Item),\n     TypeImplItem(Item),\n }\n \n-impl Clean<ImplItem> for ast::ImplItem {\n-    fn clean(&self, cx: &DocContext) -> ImplItem {\n+impl Clean<ImplMethod> for ast::ImplItem {\n+    fn clean(&self, cx: &DocContext) -> ImplMethod {\n         match self {\n             &ast::MethodImplItem(ref t) => MethodImplItem(t.clean(cx)),\n             &ast::TypeImplItem(ref t) => TypeImplItem(t.clean(cx)),\n@@ -1058,7 +1058,7 @@ pub enum Type {\n     /// For references to self\n     Self(ast::DefId),\n     /// Primitives are just the fixed-size numeric types (plus int/uint/float), and char.\n-    Primitive(Primitive),\n+    Primitive(PrimitiveType),\n     Closure(Box<ClosureDecl>),\n     Proc(Box<ClosureDecl>),\n     /// extern \"ABI\" fn\n@@ -1080,7 +1080,7 @@ pub enum Type {\n }\n \n #[deriving(Clone, Encodable, Decodable, PartialEq, Eq, Hash)]\n-pub enum Primitive {\n+pub enum PrimitiveType {\n     Int, I8, I16, I32, I64,\n     Uint, U8, U16, U32, U64,\n     F32, F64,\n@@ -1104,8 +1104,8 @@ pub enum TypeKind {\n     TypeTypedef,\n }\n \n-impl Primitive {\n-    fn from_str(s: &str) -> Option<Primitive> {\n+impl PrimitiveType {\n+    fn from_str(s: &str) -> Option<PrimitiveType> {\n         match s.as_slice() {\n             \"int\" => Some(Int),\n             \"i8\" => Some(I8),\n@@ -1129,7 +1129,7 @@ impl Primitive {\n         }\n     }\n \n-    fn find(attrs: &[Attribute]) -> Option<Primitive> {\n+    fn find(attrs: &[Attribute]) -> Option<PrimitiveType> {\n         for attr in attrs.iter() {\n             let list = match *attr {\n                 List(ref k, ref l) if k.as_slice() == \"doc\" => l,\n@@ -1141,7 +1141,7 @@ impl Primitive {\n                         if k.as_slice() == \"primitive\" => v.as_slice(),\n                     _ => continue,\n                 };\n-                match Primitive::from_str(value) {\n+                match PrimitiveType::from_str(value) {\n                     Some(p) => return Some(p),\n                     None => {}\n                 }"}, {"sha": "b771473473c115b6be6e2803abf93557450fcd9d", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -40,8 +40,8 @@ pub trait DocFolder {\n                 EnumItem(i)\n             },\n             TraitItem(mut i) => {\n-                fn vtrm<T: DocFolder>(this: &mut T, trm: TraitItem)\n-                        -> Option<TraitItem> {\n+                fn vtrm<T: DocFolder>(this: &mut T, trm: TraitMethod)\n+                        -> Option<TraitMethod> {\n                     match trm {\n                         RequiredMethod(it) => {\n                             match this.fold_item(it) {"}, {"sha": "c807c180e640ee4301f1628501298c964e291b76", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -277,7 +277,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n }\n \n fn primitive_link(f: &mut fmt::Formatter,\n-                  prim: clean::Primitive,\n+                  prim: clean::PrimitiveType,\n                   name: &str) -> fmt::Result {\n     let m = cache_key.get().unwrap();\n     let mut needs_termination = false;"}, {"sha": "cf625d4ddfc799ebd06afe33bfb1f004adbbbe4c", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -177,7 +177,7 @@ pub struct Cache {\n     pub extern_locations: HashMap<ast::CrateNum, ExternalLocation>,\n \n     /// Cache of where documentation for primitives can be found.\n-    pub primitive_locations: HashMap<clean::Primitive, ast::CrateNum>,\n+    pub primitive_locations: HashMap<clean::PrimitiveType, ast::CrateNum>,\n \n     /// Set of definitions which have been inlined from external crates.\n     pub inlined: HashSet<ast::DefId>,\n@@ -1637,15 +1637,15 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                                   _ => false,\n                               }\n                           })\n-                          .collect::<Vec<&clean::TraitItem>>();\n+                          .collect::<Vec<&clean::TraitMethod>>();\n     let provided = t.items.iter()\n                           .filter(|m| {\n                               match **m {\n                                   clean::ProvidedMethod(_) => true,\n                                   _ => false,\n                               }\n                           })\n-                          .collect::<Vec<&clean::TraitItem>>();\n+                          .collect::<Vec<&clean::TraitMethod>>();\n \n     if t.items.len() == 0 {\n         try!(write!(w, \"{{ }}\"));\n@@ -1671,7 +1671,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     // Trait documentation\n     try!(document(w, it));\n \n-    fn trait_item(w: &mut fmt::Formatter, m: &clean::TraitItem)\n+    fn trait_item(w: &mut fmt::Formatter, m: &clean::TraitMethod)\n                   -> fmt::Result {\n         try!(write!(w, \"<h3 id='{}.{}' class='method'>{}<code>\",\n                     shortty(m.item()),\n@@ -2180,7 +2180,7 @@ fn item_macro(w: &mut fmt::Formatter, it: &clean::Item,\n \n fn item_primitive(w: &mut fmt::Formatter,\n                   it: &clean::Item,\n-                  _p: &clean::Primitive) -> fmt::Result {\n+                  _p: &clean::PrimitiveType) -> fmt::Result {\n     try!(document(w, it));\n     render_methods(w, it)\n }"}, {"sha": "f7d430377230c4ffbac6e706fbecd09b71dbf25c", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -21,7 +21,7 @@ use syntax::attr::{Deprecated, Experimental, Unstable, Stable, Frozen, Locked};\n use syntax::ast::Public;\n \n use clean::{Crate, Item, ModuleItem, Module, StructItem, Struct, EnumItem, Enum};\n-use clean::{ImplItem, Impl, Trait, TraitItem, ProvidedMethod, RequiredMethod};\n+use clean::{ImplItem, Impl, Trait, TraitItem, TraitMethod, ProvidedMethod, RequiredMethod};\n use clean::{TypeTraitItem, ViewItemItem, PrimitiveItem};\n \n #[deriving(Zero, Encodable, Decodable, PartialEq, Eq)]\n@@ -128,7 +128,7 @@ fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n             items: ref trait_items,\n             ..\n         }) => {\n-            fn extract_item<'a>(trait_item: &'a TraitItem) -> &'a Item {\n+            fn extract_item<'a>(trait_item: &'a TraitMethod) -> &'a Item {\n                 match *trait_item {\n                     ProvidedMethod(ref item) |\n                     RequiredMethod(ref item) |"}, {"sha": "04a4e96ecc40ee07d7c45763220474596499ea8a", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -36,6 +36,12 @@ not tied to the lifetime of the original string/data buffer). If C strings are\n heavily used in applications, then caching may be advisable to prevent\n unnecessary amounts of allocations.\n \n+Be carefull to remember that the memory is managed by C allocator API and not\n+by Rust allocator API.\n+That means that the CString pointers should be freed with C allocator API\n+if you intend to do that on your own, as the behaviour if you free them with\n+Rust's allocator API is not well defined\n+\n An example of creating and using a C string would be:\n \n ```rust\n@@ -91,8 +97,8 @@ pub struct CString {\n \n impl Clone for CString {\n     /// Clone this CString into a new, uniquely owned CString. For safety\n-    /// reasons, this is always a deep clone, rather than the usual shallow\n-    /// clone.\n+    /// reasons, this is always a deep clone with the memory allocated\n+    /// with C's allocator API, rather than the usual shallow clone.\n     fn clone(&self) -> CString {\n         let len = self.len() + 1;\n         let buf = unsafe { malloc_raw(len) } as *mut libc::c_char;\n@@ -131,7 +137,9 @@ impl<S: hash::Writer> hash::Hash<S> for CString {\n }\n \n impl CString {\n-    /// Create a C String from a pointer.\n+    /// Create a C String from a pointer, with memory managed by C's allocator\n+    /// API, so avoid calling it with a pointer to memory managed by Rust's\n+    /// allocator API, as the behaviour would not be well defined.\n     ///\n     ///# Failure\n     ///\n@@ -265,7 +273,8 @@ impl CString {\n     /// forgotten, meaning that the backing allocation of this\n     /// `CString` is not automatically freed if it owns the\n     /// allocation. In this case, a user of `.unwrap()` should ensure\n-    /// the allocation is freed, to avoid leaking memory.\n+    /// the allocation is freed, to avoid leaking memory. You should\n+    /// use libc's memory allocator in this case.\n     ///\n     /// Prefer `.as_ptr()` when just retrieving a pointer to the\n     /// string data, as that does not relinquish ownership."}, {"sha": "ba5a4dc3f2195e6379c860a3545100c2708c1cff", "filename": "src/librustrt/local_data.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustrt%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibrustrt%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_data.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -67,7 +67,7 @@ use task::{Task, LocalStorage};\n pub type Key<T> = &'static KeyValue<T>;\n \n #[allow(missing_doc)]\n-pub enum KeyValue<T> { Key }\n+pub enum KeyValue<T> { KeyValueKey }\n \n // The task-local-map stores all TLD information for the currently running\n // task. It is stored as an owned pointer into the runtime, and it's only\n@@ -417,7 +417,7 @@ mod tests {\n \n     #[test]\n     fn test_tls_multitask() {\n-        static my_key: Key<String> = &Key;\n+        static my_key: Key<String> = &KeyValueKey;\n         my_key.replace(Some(\"parent data\".to_string()));\n         task::spawn(proc() {\n             // TLD shouldn't carry over.\n@@ -435,15 +435,15 @@ mod tests {\n \n     #[test]\n     fn test_tls_overwrite() {\n-        static my_key: Key<String> = &Key;\n+        static my_key: Key<String> = &KeyValueKey;\n         my_key.replace(Some(\"first data\".to_string()));\n         my_key.replace(Some(\"next data\".to_string())); // Shouldn't leak.\n         assert!(my_key.get().unwrap().as_slice() == \"next data\");\n     }\n \n     #[test]\n     fn test_tls_pop() {\n-        static my_key: Key<String> = &Key;\n+        static my_key: Key<String> = &KeyValueKey;\n         my_key.replace(Some(\"weasel\".to_string()));\n         assert!(my_key.replace(None).unwrap() == \"weasel\".to_string());\n         // Pop must remove the data from the map.\n@@ -458,17 +458,17 @@ mod tests {\n         // to get recorded as something within a rust stack segment. Then a\n         // subsequent upcall (esp. for logging, think vsnprintf) would run on\n         // a stack smaller than 1 MB.\n-        static my_key: Key<String> = &Key;\n+        static my_key: Key<String> = &KeyValueKey;\n         task::spawn(proc() {\n             my_key.replace(Some(\"hax\".to_string()));\n         });\n     }\n \n     #[test]\n     fn test_tls_multiple_types() {\n-        static str_key: Key<String> = &Key;\n-        static box_key: Key<Gc<()>> = &Key;\n-        static int_key: Key<int> = &Key;\n+        static str_key: Key<String> = &KeyValueKey;\n+        static box_key: Key<Gc<()>> = &KeyValueKey;\n+        static int_key: Key<int> = &KeyValueKey;\n         task::spawn(proc() {\n             str_key.replace(Some(\"string data\".to_string()));\n             box_key.replace(Some(box(GC) ()));\n@@ -478,9 +478,9 @@ mod tests {\n \n     #[test]\n     fn test_tls_overwrite_multiple_types() {\n-        static str_key: Key<String> = &Key;\n-        static box_key: Key<Gc<()>> = &Key;\n-        static int_key: Key<int> = &Key;\n+        static str_key: Key<String> = &KeyValueKey;\n+        static box_key: Key<Gc<()>> = &KeyValueKey;\n+        static int_key: Key<int> = &KeyValueKey;\n         task::spawn(proc() {\n             str_key.replace(Some(\"string data\".to_string()));\n             str_key.replace(Some(\"string data 2\".to_string()));\n@@ -497,9 +497,9 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_tls_cleanup_on_failure() {\n-        static str_key: Key<String> = &Key;\n-        static box_key: Key<Gc<()>> = &Key;\n-        static int_key: Key<int> = &Key;\n+        static str_key: Key<String> = &KeyValueKey;\n+        static box_key: Key<Gc<()>> = &KeyValueKey;\n+        static int_key: Key<int> = &KeyValueKey;\n         str_key.replace(Some(\"parent data\".to_string()));\n         box_key.replace(Some(box(GC) ()));\n         task::spawn(proc() {\n@@ -524,7 +524,7 @@ mod tests {\n                 self.tx.send(());\n             }\n         }\n-        static key: Key<Dropper> = &Key;\n+        static key: Key<Dropper> = &KeyValueKey;\n         let _ = task::try(proc() {\n             key.replace(Some(Dropper{ tx: tx }));\n         });\n@@ -535,14 +535,14 @@ mod tests {\n \n     #[test]\n     fn test_static_pointer() {\n-        static key: Key<&'static int> = &Key;\n+        static key: Key<&'static int> = &KeyValueKey;\n         static VALUE: int = 0;\n         key.replace(Some(&VALUE));\n     }\n \n     #[test]\n     fn test_owned() {\n-        static key: Key<Box<int>> = &Key;\n+        static key: Key<Box<int>> = &KeyValueKey;\n         key.replace(Some(box 1));\n \n         {\n@@ -559,11 +559,11 @@ mod tests {\n \n     #[test]\n     fn test_same_key_type() {\n-        static key1: Key<int> = &Key;\n-        static key2: Key<int> = &Key;\n-        static key3: Key<int> = &Key;\n-        static key4: Key<int> = &Key;\n-        static key5: Key<int> = &Key;\n+        static key1: Key<int> = &KeyValueKey;\n+        static key2: Key<int> = &KeyValueKey;\n+        static key3: Key<int> = &KeyValueKey;\n+        static key4: Key<int> = &KeyValueKey;\n+        static key5: Key<int> = &KeyValueKey;\n         key1.replace(Some(1));\n         key2.replace(Some(2));\n         key3.replace(Some(3));\n@@ -580,7 +580,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_nested_get_set1() {\n-        static key: Key<int> = &Key;\n+        static key: Key<int> = &KeyValueKey;\n         assert_eq!(key.replace(Some(4)), None);\n \n         let _k = key.get();\n@@ -602,7 +602,7 @@ mod tests {\n \n     #[bench]\n     fn bench_replace_none(b: &mut test::Bencher) {\n-        static key: Key<uint> = &Key;\n+        static key: Key<uint> = &KeyValueKey;\n         let _clear = ClearKey(key);\n         key.replace(None);\n         b.iter(|| {\n@@ -612,7 +612,7 @@ mod tests {\n \n     #[bench]\n     fn bench_replace_some(b: &mut test::Bencher) {\n-        static key: Key<uint> = &Key;\n+        static key: Key<uint> = &KeyValueKey;\n         let _clear = ClearKey(key);\n         key.replace(Some(1u));\n         b.iter(|| {\n@@ -622,7 +622,7 @@ mod tests {\n \n     #[bench]\n     fn bench_replace_none_some(b: &mut test::Bencher) {\n-        static key: Key<uint> = &Key;\n+        static key: Key<uint> = &KeyValueKey;\n         let _clear = ClearKey(key);\n         key.replace(Some(0u));\n         b.iter(|| {\n@@ -634,7 +634,7 @@ mod tests {\n \n     #[bench]\n     fn bench_100_keys_replace_last(b: &mut test::Bencher) {\n-        static keys: [KeyValue<uint>, ..100] = [Key, ..100];\n+        static keys: [KeyValue<uint>, ..100] = [KeyValueKey, ..100];\n         let _clear = keys.iter().map(ClearKey).collect::<Vec<ClearKey<uint>>>();\n         for (i, key) in keys.iter().enumerate() {\n             key.replace(Some(i));\n@@ -647,7 +647,7 @@ mod tests {\n \n     #[bench]\n     fn bench_1000_keys_replace_last(b: &mut test::Bencher) {\n-        static keys: [KeyValue<uint>, ..1000] = [Key, ..1000];\n+        static keys: [KeyValue<uint>, ..1000] = [KeyValueKey, ..1000];\n         let _clear = keys.iter().map(ClearKey).collect::<Vec<ClearKey<uint>>>();\n         for (i, key) in keys.iter().enumerate() {\n             key.replace(Some(i));\n@@ -661,7 +661,7 @@ mod tests {\n \n     #[bench]\n     fn bench_get(b: &mut test::Bencher) {\n-        static key: Key<uint> = &Key;\n+        static key: Key<uint> = &KeyValueKey;\n         let _clear = ClearKey(key);\n         key.replace(Some(42));\n         b.iter(|| {\n@@ -671,7 +671,7 @@ mod tests {\n \n     #[bench]\n     fn bench_100_keys_get_last(b: &mut test::Bencher) {\n-        static keys: [KeyValue<uint>, ..100] = [Key, ..100];\n+        static keys: [KeyValue<uint>, ..100] = [KeyValueKey, ..100];\n         let _clear = keys.iter().map(ClearKey).collect::<Vec<ClearKey<uint>>>();\n         for (i, key) in keys.iter().enumerate() {\n             key.replace(Some(i));\n@@ -684,7 +684,7 @@ mod tests {\n \n     #[bench]\n     fn bench_1000_keys_get_last(b: &mut test::Bencher) {\n-        static keys: [KeyValue<uint>, ..1000] = [Key, ..1000];\n+        static keys: [KeyValue<uint>, ..1000] = [KeyValueKey, ..1000];\n         let _clear = keys.iter().map(ClearKey).collect::<Vec<ClearKey<uint>>>();\n         for (i, key) in keys.iter().enumerate() {\n             key.replace(Some(i));"}, {"sha": "14274ef9f9b04f09ed76fe2f1c68e885b70bfc19", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 53, "deletions": 52, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -28,7 +28,7 @@ Data types that can be encoded are JavaScript types (see the `Json` enum for mor\n * `Boolean`: equivalent to rust's `bool`\n * `Number`: equivalent to rust's `f64`\n * `String`: equivalent to rust's `String`\n-* `Array`: equivalent to rust's `Vec<T>`, but also allowing objects of different types in the same\n+* `List`: equivalent to rust's `Vec<T>`, but also allowing objects of different types in the same\n array\n * `Object`: equivalent to rust's `Treemap<String, json::Json>`\n * `Null`\n@@ -201,7 +201,7 @@ use std::io::MemWriter;\n use std::mem::{swap, transmute};\n use std::num::{FPNaN, FPInfinite};\n use std::str::ScalarValue;\n-use std::string::String;\n+use std::string;\n use std::vec::Vec;\n \n use Encodable;\n@@ -212,15 +212,15 @@ pub enum Json {\n     I64(i64),\n     U64(u64),\n     F64(f64),\n-    String(String),\n+    String(string::String),\n     Boolean(bool),\n-    List(List),\n-    Object(Object),\n+    List(JsonList),\n+    Object(JsonObject),\n     Null,\n }\n \n-pub type List = Vec<Json>;\n-pub type Object = TreeMap<String, Json>;\n+pub type JsonList = Vec<Json>;\n+pub type JsonObject = TreeMap<string::String, Json>;\n \n /// The errors that can arise while parsing a JSON stream.\n #[deriving(Clone, PartialEq)]\n@@ -257,10 +257,10 @@ pub type BuilderError = ParserError;\n #[deriving(Clone, PartialEq, Show)]\n pub enum DecoderError {\n     ParseError(ParserError),\n-    ExpectedError(String, String),\n-    MissingFieldError(String),\n-    UnknownVariantError(String),\n-    ApplicationError(String)\n+    ExpectedError(string::String, string::String),\n+    MissingFieldError(string::String),\n+    UnknownVariantError(string::String),\n+    ApplicationError(string::String)\n }\n \n /// Returns a readable error string for a given error code.\n@@ -298,9 +298,9 @@ pub fn decode<T: ::Decodable<Decoder, DecoderError>>(s: &str) -> DecodeResult<T>\n }\n \n /// Shortcut function to encode a `T` into a JSON `String`\n-pub fn encode<'a, T: Encodable<Encoder<'a>, io::IoError>>(object: &T) -> String {\n+pub fn encode<'a, T: Encodable<Encoder<'a>, io::IoError>>(object: &T) -> string::String {\n     let buff = Encoder::buffer_encode(object);\n-    String::from_utf8(buff).unwrap()\n+    string::String::from_utf8(buff).unwrap()\n }\n \n impl fmt::Show for ErrorCode {\n@@ -375,9 +375,9 @@ fn spaces(wr: &mut io::Writer, mut n: uint) -> Result<(), io::IoError> {\n     }\n }\n \n-fn fmt_number_or_null(v: f64) -> String {\n+fn fmt_number_or_null(v: f64) -> string::String {\n     match v.classify() {\n-        FPNaN | FPInfinite => String::from_str(\"null\"),\n+        FPNaN | FPInfinite => string::String::from_str(\"null\"),\n         _ => f64::to_str_digits(v, 6u)\n     }\n }\n@@ -411,7 +411,7 @@ impl<'a> Encoder<'a> {\n     ///\n     /// Note: this function is deprecated. Consider using `json::encode` instead.\n     #[deprecated = \"Replaced by `json::encode`\"]\n-    pub fn str_encode<T: Encodable<Encoder<'a>, io::IoError>>(object: &T) -> String {\n+    pub fn str_encode<T: Encodable<Encoder<'a>, io::IoError>>(object: &T) -> string::String {\n         encode(object)\n     }\n }\n@@ -877,15 +877,15 @@ impl Json {\n     }\n \n     /// Encodes a json value into a string\n-    pub fn to_pretty_str(&self) -> String {\n+    pub fn to_pretty_str(&self) -> string::String {\n         let mut s = MemWriter::new();\n         self.to_pretty_writer(&mut s as &mut io::Writer).unwrap();\n-        String::from_utf8(s.unwrap()).unwrap()\n+        string::String::from_utf8(s.unwrap()).unwrap()\n     }\n \n      /// If the Json value is an Object, returns the value associated with the provided key.\n     /// Otherwise, returns None.\n-    pub fn find<'a>(&'a self, key: &String) -> Option<&'a Json>{\n+    pub fn find<'a>(&'a self, key: &string::String) -> Option<&'a Json>{\n         match self {\n             &Object(ref map) => map.find(key),\n             _ => None\n@@ -895,7 +895,7 @@ impl Json {\n     /// Attempts to get a nested Json Object for each key in `keys`.\n     /// If any key is found not to exist, find_path will return None.\n     /// Otherwise, it will return the Json value associated with the final key.\n-    pub fn find_path<'a>(&'a self, keys: &[&String]) -> Option<&'a Json>{\n+    pub fn find_path<'a>(&'a self, keys: &[&string::String]) -> Option<&'a Json>{\n         let mut target = self;\n         for key in keys.iter() {\n             match target.find(*key) {\n@@ -909,7 +909,7 @@ impl Json {\n     /// If the Json value is an Object, performs a depth-first search until\n     /// a value associated with the provided key is found. If no value is found\n     /// or the Json value is not an Object, returns None.\n-    pub fn search<'a>(&'a self, key: &String) -> Option<&'a Json> {\n+    pub fn search<'a>(&'a self, key: &string::String) -> Option<&'a Json> {\n         match self {\n             &Object(ref map) => {\n                 match map.find(key) {\n@@ -937,7 +937,7 @@ impl Json {\n \n     /// If the Json value is an Object, returns the associated TreeMap.\n     /// Returns None otherwise.\n-    pub fn as_object<'a>(&'a self) -> Option<&'a Object> {\n+    pub fn as_object<'a>(&'a self) -> Option<&'a JsonObject> {\n         match self {\n             &Object(ref map) => Some(map),\n             _ => None\n@@ -951,7 +951,7 @@ impl Json {\n \n     /// If the Json value is a List, returns the associated vector.\n     /// Returns None otherwise.\n-    pub fn as_list<'a>(&'a self) -> Option<&'a List> {\n+    pub fn as_list<'a>(&'a self) -> Option<&'a JsonList> {\n         match self {\n             &List(ref list) => Some(&*list),\n             _ => None\n@@ -1075,15 +1075,15 @@ pub enum JsonEvent {\n     I64Value(i64),\n     U64Value(u64),\n     F64Value(f64),\n-    StringValue(String),\n+    StringValue(string::String),\n     NullValue,\n     Error(ParserError),\n }\n \n #[deriving(PartialEq, Show)]\n enum ParserState {\n     // Parse a value in a list, true means first element.\n-    ParseList(bool),\n+    ParseArray(bool),\n     // Parse ',' or ']' after an element in a list.\n     ParseListComma,\n     // Parse a key:value in an object, true means first element.\n@@ -1191,7 +1191,7 @@ impl Stack {\n     }\n \n     // Used by Parser to insert Key elements at the top of the stack.\n-    fn push_key(&mut self, key: String) {\n+    fn push_key(&mut self, key: string::String) {\n         self.stack.push(InternalKey(self.str_buffer.len() as u16, key.len() as u16));\n         for c in key.as_bytes().iter() {\n             self.str_buffer.push(*c);\n@@ -1502,9 +1502,9 @@ impl<T: Iterator<char>> Parser<T> {\n         Ok(n)\n     }\n \n-    fn parse_str(&mut self) -> Result<String, ParserError> {\n+    fn parse_str(&mut self) -> Result<string::String, ParserError> {\n         let mut escape = false;\n-        let mut res = String::new();\n+        let mut res = string::String::new();\n \n         loop {\n             self.bump();\n@@ -1574,7 +1574,7 @@ impl<T: Iterator<char>> Parser<T> {\n             // The only paths where the loop can spin a new iteration\n             // are in the cases ParseListComma and ParseObjectComma if ','\n             // is parsed. In these cases the state is set to (respectively)\n-            // ParseList(false) and ParseObject(false), which always return,\n+            // ParseArray(false) and ParseObject(false), which always return,\n             // so there is no risk of getting stuck in an infinite loop.\n             // All other paths return before the end of the loop's iteration.\n             self.parse_whitespace();\n@@ -1583,7 +1583,7 @@ impl<T: Iterator<char>> Parser<T> {\n                 ParseStart => {\n                     return self.parse_start();\n                 }\n-                ParseList(first) => {\n+                ParseArray(first) => {\n                     return self.parse_list(first);\n                 }\n                 ParseListComma => {\n@@ -1615,7 +1615,7 @@ impl<T: Iterator<char>> Parser<T> {\n         let val = self.parse_value();\n         self.state = match val {\n             Error(_) => { ParseFinished }\n-            ListStart => { ParseList(true) }\n+            ListStart => { ParseArray(true) }\n             ObjectStart => { ParseObject(true) }\n             _ => { ParseBeforeFinish }\n         };\n@@ -1647,7 +1647,7 @@ impl<T: Iterator<char>> Parser<T> {\n \n         self.state = match val {\n             Error(_) => { ParseFinished }\n-            ListStart => { ParseList(true) }\n+            ListStart => { ParseArray(true) }\n             ObjectStart => { ParseObject(true) }\n             _ => { ParseListComma }\n         };\n@@ -1657,7 +1657,7 @@ impl<T: Iterator<char>> Parser<T> {\n     fn parse_list_comma_or_end(&mut self) -> Option<JsonEvent> {\n         if self.ch_is(',') {\n             self.stack.bump_index();\n-            self.state = ParseList(false);\n+            self.state = ParseArray(false);\n             self.bump();\n             return None;\n         } else if self.ch_is(']') {\n@@ -1728,7 +1728,7 @@ impl<T: Iterator<char>> Parser<T> {\n \n         self.state = match val {\n             Error(_) => { ParseFinished }\n-            ListStart => { ParseList(true) }\n+            ListStart => { ParseArray(true) }\n             ObjectStart => { ParseObject(true) }\n             _ => { ParseObjectComma }\n         };\n@@ -1830,7 +1830,7 @@ impl<T: Iterator<char>> Builder<T> {\n             Some(F64Value(n)) => { Ok(F64(n)) }\n             Some(BooleanValue(b)) => { Ok(Boolean(b)) }\n             Some(StringValue(ref mut s)) => {\n-                let mut temp = String::new();\n+                let mut temp = string::String::new();\n                 swap(s, &mut temp);\n                 Ok(String(temp))\n             }\n@@ -2034,7 +2034,7 @@ impl ::Decoder<DecoderError> for Decoder {\n         Err(ExpectedError(\"single character string\".to_string(), format!(\"{}\", s)))\n     }\n \n-    fn read_str(&mut self) -> DecodeResult<String> {\n+    fn read_str(&mut self) -> DecodeResult<string::String> {\n         debug!(\"read_str\");\n         expect!(self.pop(), String)\n     }\n@@ -2284,7 +2284,7 @@ impl ToJson for bool {\n     fn to_json(&self) -> Json { Boolean(*self) }\n }\n \n-impl ToJson for String {\n+impl ToJson for string::String {\n     fn to_json(&self) -> Json { String((*self).clone()) }\n }\n \n@@ -2328,7 +2328,7 @@ impl<A: ToJson> ToJson for Vec<A> {\n     fn to_json(&self) -> Json { List(self.iter().map(|elt| elt.to_json()).collect()) }\n }\n \n-impl<A: ToJson> ToJson for TreeMap<String, A> {\n+impl<A: ToJson> ToJson for TreeMap<string::String, A> {\n     fn to_json(&self) -> Json {\n         let mut d = TreeMap::new();\n         for (key, value) in self.iter() {\n@@ -2338,7 +2338,7 @@ impl<A: ToJson> ToJson for TreeMap<String, A> {\n     }\n }\n \n-impl<A: ToJson> ToJson for HashMap<String, A> {\n+impl<A: ToJson> ToJson for HashMap<string::String, A> {\n     fn to_json(&self) -> Json {\n         let mut d = TreeMap::new();\n         for (key, value) in self.iter() {\n@@ -2375,7 +2375,7 @@ mod tests {\n     extern crate test;\n     use self::test::Bencher;\n     use {Encodable, Decodable};\n-    use super::{Encoder, Decoder, Error, Boolean, I64, U64, F64, List, String, Null,\n+    use super::{List, Encoder, Decoder, Error, Boolean, I64, U64, F64, String, Null,\n                 PrettyEncoder, Object, Json, from_str, ParseError, ExpectedError,\n                 MissingFieldError, UnknownVariantError, DecodeResult, DecoderError,\n                 JsonEvent, Parser, StackElement,\n@@ -2386,6 +2386,7 @@ mod tests {\n                 TrailingCharacters, TrailingComma};\n     use std::{i64, u64, f32, f64, io};\n     use std::collections::TreeMap;\n+    use std::string;\n \n     #[deriving(Decodable, Eq, PartialEq, Show)]\n     struct OptionData {\n@@ -2417,22 +2418,22 @@ mod tests {\n     #[deriving(PartialEq, Encodable, Decodable, Show)]\n     enum Animal {\n         Dog,\n-        Frog(String, int)\n+        Frog(string::String, int)\n     }\n \n     #[deriving(PartialEq, Encodable, Decodable, Show)]\n     struct Inner {\n         a: (),\n         b: uint,\n-        c: Vec<String>,\n+        c: Vec<string::String>,\n     }\n \n     #[deriving(PartialEq, Encodable, Decodable, Show)]\n     struct Outer {\n         inner: Vec<Inner>,\n     }\n \n-    fn mk_object(items: &[(String, Json)]) -> Json {\n+    fn mk_object(items: &[(string::String, Json)]) -> Json {\n         let mut d = TreeMap::new();\n \n         for item in items.iter() {\n@@ -2610,7 +2611,7 @@ mod tests {\n                    from_str(a.to_pretty_str().as_slice()).unwrap());\n     }\n \n-    fn with_str_writer(f: |&mut io::Writer|) -> String {\n+    fn with_str_writer(f: |&mut io::Writer|) -> string::String {\n         use std::io::MemWriter;\n         use std::str;\n \n@@ -2678,7 +2679,7 @@ mod tests {\n \n     #[test]\n     fn test_write_none() {\n-        let value: Option<String> = None;\n+        let value: Option<string::String> = None;\n         let s = with_str_writer(|writer| {\n             let mut encoder = Encoder::new(writer);\n             value.encode(&mut encoder).unwrap();\n@@ -2825,7 +2826,7 @@ mod tests {\n                  (\"\\\"\\\\uAB12\\\"\", \"\\uAB12\")];\n \n         for &(i, o) in s.iter() {\n-            let v: String = super::decode(i).unwrap();\n+            let v: string::String = super::decode(i).unwrap();\n             assert_eq!(v.as_slice(), o);\n         }\n     }\n@@ -2959,10 +2960,10 @@ mod tests {\n \n     #[test]\n     fn test_decode_option() {\n-        let value: Option<String> = super::decode(\"null\").unwrap();\n+        let value: Option<string::String> = super::decode(\"null\").unwrap();\n         assert_eq!(value, None);\n \n-        let value: Option<String> = super::decode(\"\\\"jodhpurs\\\"\").unwrap();\n+        let value: Option<string::String> = super::decode(\"\\\"jodhpurs\\\"\").unwrap();\n         assert_eq!(value, Some(\"jodhpurs\".to_string()));\n     }\n \n@@ -2980,7 +2981,7 @@ mod tests {\n     fn test_decode_map() {\n         let s = \"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\n                   \\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n-        let mut map: TreeMap<String, Animal> = super::decode(s).unwrap();\n+        let mut map: TreeMap<string::String, Animal> = super::decode(s).unwrap();\n \n         assert_eq!(map.pop(&\"a\".to_string()), Some(Dog));\n         assert_eq!(map.pop(&\"b\".to_string()), Some(Frog(\"Henry\".to_string(), 349)));\n@@ -2997,13 +2998,13 @@ mod tests {\n     struct DecodeStruct {\n         x: f64,\n         y: bool,\n-        z: String,\n+        z: string::String,\n         w: Vec<DecodeStruct>\n     }\n     #[deriving(Decodable)]\n     enum DecodeEnum {\n         A(f64),\n-        B(String)\n+        B(string::String)\n     }\n     fn check_err<T: Decodable<Decoder, DecoderError>>(to_parse: &'static str,\n                                                       expected: DecoderError) {\n@@ -3709,7 +3710,7 @@ mod tests {\n         });\n     }\n \n-    fn big_json() -> String {\n+    fn big_json() -> string::String {\n         let mut src = \"[\\n\".to_string();\n         for _ in range(0i, 500) {\n             src.push_str(r#\"{ \"a\": true, \"b\": null, \"c\":3.1415, \"d\": \"Hello world\", \"e\": \\"}, {"sha": "86c03708e4041af204044baa1494bbad99e4bf21", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -304,10 +304,10 @@ macro_rules! println(\n #[macro_export]\n macro_rules! local_data_key(\n     ($name:ident: $ty:ty) => (\n-        static $name: ::std::local_data::Key<$ty> = &::std::local_data::Key;\n+        static $name: ::std::local_data::Key<$ty> = &::std::local_data::KeyValueKey;\n     );\n     (pub $name:ident: $ty:ty) => (\n-        pub static $name: ::std::local_data::Key<$ty> = &::std::local_data::Key;\n+        pub static $name: ::std::local_data::Key<$ty> = &::std::local_data::KeyValueKey;\n     );\n )\n "}, {"sha": "f4887a143d1dc74ce721264384caa3711898c44b", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -831,9 +831,11 @@ mod imp {\n     mod arch {\n         use libc::{c_longlong, c_ulonglong};\n         use libc::types::os::arch::extra::{WORD, DWORD, DWORDLONG};\n+        use simd;\n \n         #[repr(C)]\n         pub struct CONTEXT {\n+            _align_hack: [simd::u64x2, ..0], // FIXME align on 16-byte\n             P1Home: DWORDLONG,\n             P2Home: DWORDLONG,\n             P3Home: DWORDLONG,\n@@ -892,12 +894,14 @@ mod imp {\n \n         #[repr(C)]\n         pub struct M128A {\n+            _align_hack: [simd::u64x2, ..0], // FIXME align on 16-byte\n             Low:  c_ulonglong,\n             High: c_longlong\n         }\n \n         #[repr(C)]\n         pub struct FLOATING_SAVE_AREA {\n+            _align_hack: [simd::u64x2, ..0], // FIXME align on 16-byte\n             _Dummy: [u8, ..512] // FIXME: Fill this out\n         }\n "}, {"sha": "5c84745c20c6fabc1d4c8cd5854c72c356a91d2d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -213,12 +213,19 @@ pub static DUMMY_NODE_ID: NodeId = -1;\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum TyParamBound {\n     TraitTyParamBound(TraitRef),\n-    UnboxedFnTyParamBound(UnboxedFnTy),\n+    UnboxedFnTyParamBound(P<UnboxedFnBound>),\n     RegionTyParamBound(Lifetime)\n }\n \n pub type TyParamBounds = OwnedSlice<TyParamBound>;\n \n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct UnboxedFnBound {\n+    pub path: Path,\n+    pub decl: P<FnDecl>,\n+    pub ref_id: NodeId,\n+}\n+\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct TyParam {\n     pub ident: Ident,\n@@ -531,6 +538,7 @@ pub enum Expr_ {\n     ExprField(P<Expr>, SpannedIdent, Vec<P<Ty>>),\n     ExprTupField(P<Expr>, Spanned<uint>, Vec<P<Ty>>),\n     ExprIndex(P<Expr>, P<Expr>),\n+    ExprSlice(P<Expr>, Option<P<Expr>>, Option<P<Expr>>, Mutability),\n \n     /// Variable reference, possibly containing `::` and/or\n     /// type parameters, e.g. foo::bar::<baz>\n@@ -1363,7 +1371,7 @@ mod test {\n                 inner: Span {\n                     lo: BytePos(11),\n                     hi: BytePos(19),\n-                    expn_info: None,\n+                    expn_id: NO_EXPANSION,\n                 },\n                 view_items: Vec::new(),\n                 items: Vec::new(),\n@@ -1373,7 +1381,7 @@ mod test {\n             span: Span {\n                 lo: BytePos(10),\n                 hi: BytePos(20),\n-                expn_info: None,\n+                expn_id: NO_EXPANSION,\n             },\n             exported_macros: Vec::new(),\n         };"}, {"sha": "9072889463cd631cde0e0e170213953ae1bcb203", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -25,7 +25,6 @@ source code snippets, etc.\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::cell::RefCell;\n-use std::gc::Gc;\n use std::rc::Rc;\n \n pub trait Pos {\n@@ -93,10 +92,10 @@ pub struct Span {\n     pub hi: BytePos,\n     /// Information about where the macro came from, if this piece of\n     /// code was created by a macro expansion.\n-    pub expn_info: Option<Gc<ExpnInfo>>\n+    pub expn_id: ExpnId\n }\n \n-pub static DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_info: None };\n+pub static DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_id: NO_EXPANSION };\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Spanned<T> {\n@@ -140,17 +139,19 @@ pub fn dummy_spanned<T>(t: T) -> Spanned<T> {\n \n /* assuming that we're not in macro expansion */\n pub fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n-    Span {lo: lo, hi: hi, expn_info: None}\n+    Span {lo: lo, hi: hi, expn_id: NO_EXPANSION}\n }\n \n /// Return the span itself if it doesn't come from a macro expansion,\n /// otherwise return the call site span up to the `enclosing_sp` by\n /// following the `expn_info` chain.\n-pub fn original_sp(sp: Span, enclosing_sp: Span) -> Span {\n-    match (sp.expn_info, enclosing_sp.expn_info) {\n+pub fn original_sp(cm: &CodeMap, sp: Span, enclosing_sp: Span) -> Span {\n+    let call_site1 = cm.with_expn_info(sp.expn_id, |ei| ei.map(|ei| ei.call_site));\n+    let call_site2 = cm.with_expn_info(enclosing_sp.expn_id, |ei| ei.map(|ei| ei.call_site));\n+    match (call_site1, call_site2) {\n         (None, _) => sp,\n-        (Some(expn1), Some(expn2)) if expn1.call_site == expn2.call_site => sp,\n-        (Some(expn1), _) => original_sp(expn1.call_site, enclosing_sp),\n+        (Some(call_site1), Some(call_site2)) if call_site1 == call_site2 => sp,\n+        (Some(call_site1), _) => original_sp(cm, call_site1, enclosing_sp),\n     }\n }\n \n@@ -222,6 +223,11 @@ pub struct ExpnInfo {\n     pub callee: NameAndSpan\n }\n \n+#[deriving(PartialEq, Eq, Clone, Show, Hash)]\n+pub struct ExpnId(u32);\n+\n+pub static NO_EXPANSION: ExpnId = ExpnId(-1);\n+\n pub type FileName = String;\n \n pub struct FileLines {\n@@ -299,13 +305,15 @@ impl FileMap {\n }\n \n pub struct CodeMap {\n-    pub files: RefCell<Vec<Rc<FileMap>>>\n+    pub files: RefCell<Vec<Rc<FileMap>>>,\n+    expansions: RefCell<Vec<ExpnInfo>>\n }\n \n impl CodeMap {\n     pub fn new() -> CodeMap {\n         CodeMap {\n             files: RefCell::new(Vec::new()),\n+            expansions: RefCell::new(Vec::new()),\n         }\n     }\n \n@@ -527,6 +535,19 @@ impl CodeMap {\n             col: chpos - linechpos\n         }\n     }\n+\n+    pub fn record_expansion(&self, expn_info: ExpnInfo) -> ExpnId {\n+        let mut expansions = self.expansions.borrow_mut();\n+        expansions.push(expn_info);\n+        ExpnId(expansions.len().to_u32().expect(\"too many ExpnInfo's!\") - 1)\n+    }\n+\n+    pub fn with_expn_info<T>(&self, id: ExpnId, f: |Option<&ExpnInfo>| -> T) -> T {\n+        match id {\n+            NO_EXPANSION => f(None),\n+            ExpnId(i) => f(Some(&(*self.expansions.borrow())[i as uint]))\n+        }\n+    }\n }\n \n #[cfg(test)]\n@@ -665,7 +686,7 @@ mod test {\n     fn t7() {\n         // Test span_to_lines for a span ending at the end of filemap\n         let cm = init_code_map();\n-        let span = Span {lo: BytePos(12), hi: BytePos(23), expn_info: None};\n+        let span = Span {lo: BytePos(12), hi: BytePos(23), expn_id: NO_EXPANSION};\n         let file_lines = cm.span_to_lines(span);\n \n         assert_eq!(file_lines.file.name, \"blork.rs\".to_string());\n@@ -677,7 +698,7 @@ mod test {\n     fn t8() {\n         // Test span_to_snippet for a span ending at the end of filemap\n         let cm = init_code_map();\n-        let span = Span {lo: BytePos(12), hi: BytePos(23), expn_info: None};\n+        let span = Span {lo: BytePos(12), hi: BytePos(23), expn_id: NO_EXPANSION};\n         let snippet = cm.span_to_snippet(span);\n \n         assert_eq!(snippet, Some(\"second line\".to_string()));\n@@ -687,7 +708,7 @@ mod test {\n     fn t9() {\n         // Test span_to_str for a span ending at the end of filemap\n         let cm = init_code_map();\n-        let span = Span {lo: BytePos(12), hi: BytePos(23), expn_info: None};\n+        let span = Span {lo: BytePos(12), hi: BytePos(23), expn_id: NO_EXPANSION};\n         let sstr =  cm.span_to_string(span);\n \n         assert_eq!(sstr, \"blork.rs:2:1: 2:12\".to_string());"}, {"sha": "f33c768d647575607a821aad4a6dc364604558bc", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -389,7 +389,7 @@ fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n         // we want to tell compiletest/runtest to look at the last line of the\n         // span (since `custom_highlight_lines` displays an arrow to the end of\n         // the span)\n-        let span_end = Span { lo: sp.hi, hi: sp.hi, expn_info: sp.expn_info};\n+        let span_end = Span { lo: sp.hi, hi: sp.hi, expn_id: sp.expn_id};\n         let ses = cm.span_to_string(span_end);\n         try!(print_diagnostic(dst, ses.as_slice(), lvl, msg, code));\n         if rsp.is_full_span() {\n@@ -523,24 +523,24 @@ fn print_macro_backtrace(w: &mut EmitterWriter,\n                          cm: &codemap::CodeMap,\n                          sp: Span)\n                          -> io::IoResult<()> {\n-    for ei in sp.expn_info.iter() {\n-        let ss = ei.callee\n-                   .span\n-                   .as_ref()\n-                   .map_or(\"\".to_string(), |span| cm.span_to_string(*span));\n-        let (pre, post) = match ei.callee.format {\n-            codemap::MacroAttribute => (\"#[\", \"]\"),\n-            codemap::MacroBang => (\"\", \"!\")\n-        };\n-        try!(print_diagnostic(w, ss.as_slice(), Note,\n-                              format!(\"in expansion of {}{}{}\", pre,\n-                                      ei.callee.name,\n-                                      post).as_slice(), None));\n-        let ss = cm.span_to_string(ei.call_site);\n-        try!(print_diagnostic(w, ss.as_slice(), Note, \"expansion site\", None));\n-        try!(print_macro_backtrace(w, cm, ei.call_site));\n-    }\n-    Ok(())\n+    let cs = try!(cm.with_expn_info(sp.expn_id, |expn_info| match expn_info {\n+        Some(ei) => {\n+            let ss = ei.callee.span.map_or(String::new(), |span| cm.span_to_string(span));\n+            let (pre, post) = match ei.callee.format {\n+                codemap::MacroAttribute => (\"#[\", \"]\"),\n+                codemap::MacroBang => (\"\", \"!\")\n+            };\n+            try!(print_diagnostic(w, ss.as_slice(), Note,\n+                                  format!(\"in expansion of {}{}{}\", pre,\n+                                          ei.callee.name,\n+                                          post).as_slice(), None));\n+            let ss = cm.span_to_string(ei.call_site);\n+            try!(print_diagnostic(w, ss.as_slice(), Note, \"expansion site\", None));\n+            Ok(Some(ei.call_site))\n+        }\n+        None => Ok(None)\n+    }));\n+    cs.map_or(Ok(()), |call_site| print_macro_backtrace(w, cm, call_site))\n }\n \n pub fn expect<T>(diag: &SpanHandler, opt: Option<T>, msg: || -> String) -> T {"}, {"sha": "d3c39284f55822f5d701d39d1df7176a4cebf859", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -13,7 +13,7 @@ use std::collections::HashMap;\n use ast;\n use ast::{Ident, Name, TokenTree};\n use codemap::Span;\n-use ext::base::{ExtCtxt, MacExpr, MacItem, MacResult};\n+use ext::base::{ExtCtxt, MacExpr, MacResult, MacItems};\n use ext::build::AstBuilder;\n use parse::token;\n use ptr::P;\n@@ -102,7 +102,7 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n     let sym = Ident::new(token::gensym((\n         \"__register_diagnostic_\".to_string() + token::get_ident(*code).get()\n     ).as_slice()));\n-    MacItem::new(quote_item!(ecx, mod $sym {}).unwrap())\n+    MacItems::new(vec![quote_item!(ecx, mod $sym {}).unwrap()].into_iter())\n }\n \n pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n@@ -133,7 +133,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n             (descriptions.len(), ecx.expr_vec(span, descriptions))\n         })\n     });\n-    MacItem::new(quote_item!(ecx,\n+    MacItems::new(vec![quote_item!(ecx,\n         pub static $name: [(&'static str, &'static str), ..$count] = $expr;\n-    ).unwrap())\n+    ).unwrap()].into_iter())\n }"}, {"sha": "b35a945675761364e600015bba6224871f566dc1", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 69, "deletions": 39, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -11,7 +11,7 @@\n use ast;\n use ast::Name;\n use codemap;\n-use codemap::{CodeMap, Span, ExpnInfo};\n+use codemap::{CodeMap, Span, ExpnId, ExpnInfo, NO_EXPANSION};\n use ext;\n use ext::expand;\n use parse;\n@@ -24,7 +24,6 @@ use ext::mtwt;\n use fold::Folder;\n \n use std::collections::HashMap;\n-use std::gc::{Gc, GC};\n use std::rc::Rc;\n \n // new-style macro! tt code:\n@@ -203,25 +202,20 @@ impl MacResult for MacPat {\n         Some(self.p)\n     }\n }\n-/// A convenience type for macros that return a single item.\n-pub struct MacItem {\n-    i: P<ast::Item>\n+/// A type for macros that return multiple items.\n+pub struct MacItems {\n+    items: SmallVector<P<ast::Item>>\n }\n-impl MacItem {\n-    pub fn new(i: P<ast::Item>) -> Box<MacResult+'static> {\n-        box MacItem { i: i } as Box<MacResult+'static>\n+\n+impl MacItems {\n+    pub fn new<I: Iterator<P<ast::Item>>>(mut it: I) -> Box<MacResult+'static> {\n+        box MacItems { items: it.collect() } as Box<MacResult+'static>\n     }\n }\n-impl MacResult for MacItem {\n-    fn make_items(self: Box<MacItem>) -> Option<SmallVector<P<ast::Item>>> {\n-        Some(SmallVector::one(self.i))\n-    }\n-    fn make_stmt(self: Box<MacItem>) -> Option<P<ast::Stmt>> {\n-        Some(P(codemap::respan(\n-            self.i.span,\n-            ast::StmtDecl(\n-                P(codemap::respan(self.i.span, ast::DeclItem(self.i))),\n-                ast::DUMMY_NODE_ID))))\n+\n+impl MacResult for MacItems {\n+    fn make_items(self: Box<MacItems>) -> Option<SmallVector<P<ast::Item>>> {\n+        Some(self.items)\n     }\n }\n \n@@ -305,11 +299,11 @@ pub enum SyntaxExtension {\n     /// based upon it.\n     ///\n     /// `#[deriving(...)]` is an `ItemDecorator`.\n-    ItemDecorator(Box<ItemDecorator + 'static>),\n+    Decorator(Box<ItemDecorator + 'static>),\n \n     /// A syntax extension that is attached to an item and modifies it\n     /// in-place.\n-    ItemModifier(Box<ItemModifier + 'static>),\n+    Modifier(Box<ItemModifier + 'static>),\n \n     /// A normal, function-like syntax extension.\n     ///\n@@ -387,7 +381,7 @@ fn initial_syntax_expander_table() -> SyntaxEnv {\n                             builtin_normal_expander(\n                                     ext::log_syntax::expand_syntax_ext));\n     syntax_expanders.insert(intern(\"deriving\"),\n-                            ItemDecorator(box ext::deriving::expand_meta_deriving));\n+                            Decorator(box ext::deriving::expand_meta_deriving));\n \n     // Quasi-quoting expanders\n     syntax_expanders.insert(intern(\"quote_tokens\"),\n@@ -457,7 +451,7 @@ fn initial_syntax_expander_table() -> SyntaxEnv {\n pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a parse::ParseSess,\n     pub cfg: ast::CrateConfig,\n-    pub backtrace: Option<Gc<ExpnInfo>>,\n+    pub backtrace: ExpnId,\n     pub ecfg: expand::ExpansionConfig,\n \n     pub mod_path: Vec<ast::Ident> ,\n@@ -473,7 +467,7 @@ impl<'a> ExtCtxt<'a> {\n         ExtCtxt {\n             parse_sess: parse_sess,\n             cfg: cfg,\n-            backtrace: None,\n+            backtrace: NO_EXPANSION,\n             mod_path: Vec::new(),\n             ecfg: ecfg,\n             trace_mac: false,\n@@ -501,13 +495,49 @@ impl<'a> ExtCtxt<'a> {\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> ast::CrateConfig { self.cfg.clone() }\n     pub fn call_site(&self) -> Span {\n-        match self.backtrace {\n+        self.codemap().with_expn_info(self.backtrace, |ei| match ei {\n             Some(expn_info) => expn_info.call_site,\n             None => self.bug(\"missing top span\")\n-        }\n+        })\n     }\n     pub fn print_backtrace(&self) { }\n-    pub fn backtrace(&self) -> Option<Gc<ExpnInfo>> { self.backtrace }\n+    pub fn backtrace(&self) -> ExpnId { self.backtrace }\n+    pub fn original_span(&self) -> Span {\n+        let mut expn_id = self.backtrace;\n+        let mut call_site = None;\n+        loop {\n+            match self.codemap().with_expn_info(expn_id, |ei| ei.map(|ei| ei.call_site)) {\n+                None => break,\n+                Some(cs) => {\n+                    call_site = Some(cs);\n+                    expn_id = cs.expn_id;\n+                }\n+            }\n+        }\n+        call_site.expect(\"missing expansion backtrace\")\n+    }\n+    pub fn original_span_in_file(&self) -> Span {\n+        let mut expn_id = self.backtrace;\n+        let mut call_site = None;\n+        loop {\n+            let expn_info = self.codemap().with_expn_info(expn_id, |ei| {\n+                ei.map(|ei| (ei.call_site, ei.callee.name.as_slice() == \"include\"))\n+            });\n+            match expn_info {\n+                None => break,\n+                Some((cs, is_include)) => {\n+                    if is_include {\n+                        // Don't recurse into file using \"include!\".\n+                        break;\n+                    }\n+                    call_site = Some(cs);\n+                    expn_id = cs.expn_id;\n+                }\n+            }\n+        }\n+        call_site.expect(\"missing expansion backtrace\")\n+    }\n+\n     pub fn mod_push(&mut self, i: ast::Ident) { self.mod_path.push(i); }\n     pub fn mod_pop(&mut self) { self.mod_path.pop().unwrap(); }\n     pub fn mod_path(&self) -> Vec<ast::Ident> {\n@@ -516,22 +546,22 @@ impl<'a> ExtCtxt<'a> {\n         v.extend(self.mod_path.iter().map(|a| *a));\n         return v;\n     }\n-    pub fn bt_push(&mut self, ei: codemap::ExpnInfo) {\n-        match ei {\n-            ExpnInfo {call_site: cs, callee: ref callee} => {\n-                self.backtrace =\n-                    Some(box(GC) ExpnInfo {\n-                        call_site: Span {lo: cs.lo, hi: cs.hi,\n-                                         expn_info: self.backtrace.clone()},\n-                        callee: (*callee).clone()\n-                    });\n-            }\n-        }\n+    pub fn bt_push(&mut self, ei: ExpnInfo) {\n+        let mut call_site = ei.call_site;\n+        call_site.expn_id = self.backtrace;\n+        self.backtrace = self.codemap().record_expansion(ExpnInfo {\n+            call_site: call_site,\n+            callee: ei.callee\n+        });\n     }\n     pub fn bt_pop(&mut self) {\n         match self.backtrace {\n-            Some(expn_info) => self.backtrace = expn_info.call_site.expn_info,\n-            _ => self.bug(\"tried to pop without a push\")\n+            NO_EXPANSION => self.bug(\"tried to pop without a push\"),\n+            expn_id => {\n+                self.backtrace = self.codemap().with_expn_info(expn_id, |expn_info| {\n+                    expn_info.map_or(NO_EXPANSION, |ei| ei.call_site.expn_id)\n+                });\n+            }\n         }\n     }\n     /// Emit `msg` attached to `sp`, and stop compilation immediately."}, {"sha": "16ecd83180ed15826026c66ae41ac79ed0675ac7", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -573,7 +573,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let field_span = Span {\n             lo: sp.lo - Pos::from_uint(field_name.get().len()),\n             hi: sp.hi,\n-            expn_info: sp.expn_info,\n+            expn_id: sp.expn_id,\n         };\n \n         let id = Spanned { node: ident, span: field_span };\n@@ -583,7 +583,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let field_span = Span {\n             lo: sp.lo - Pos::from_uint(idx.to_string().len()),\n             hi: sp.hi,\n-            expn_info: sp.expn_info,\n+            expn_id: sp.expn_id,\n         };\n \n         let id = Spanned { node: idx, span: field_span };"}, {"sha": "142adc9b721e00d462c8d7e36bb97554b1c76c5c", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -181,7 +181,6 @@\n //! ~~~\n \n use std::cell::RefCell;\n-use std::gc::GC;\n use std::vec;\n \n use abi::Abi;\n@@ -1169,7 +1168,7 @@ impl<'a> TraitDef<'a> {\n             None => cx.span_bug(self.span, \"trait with empty path in generic `deriving`\"),\n             Some(name) => *name\n         };\n-        to_set.expn_info = Some(box(GC) codemap::ExpnInfo {\n+        to_set.expn_id = cx.codemap().record_expansion(codemap::ExpnInfo {\n             call_site: to_set,\n             callee: codemap::NameAndSpan {\n                 name: format!(\"deriving({})\", trait_name),"}, {"sha": "e173b93e4680862b781320ad48b959527d1f05e0", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 8, "deletions": 25, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -30,8 +30,6 @@ use util::small_vector::SmallVector;\n use visit;\n use visit::Visitor;\n \n-use std::gc::Gc;\n-\n enum Either<L,R> {\n     Left(L),\n     Right(R)\n@@ -161,11 +159,11 @@ fn expand_mac_invoc<T>(mac: ast::Mac, span: codemap::Span,\n                         // be the root of the call stack. That's the most\n                         // relevant span and it's the actual invocation of\n                         // the macro.\n-                        let mac_span = original_span(fld.cx);\n+                        let mac_span = fld.cx.original_span();\n \n                         let opt_parsed = {\n                             let expanded = expandfun.expand(fld.cx,\n-                                                            mac_span.call_site,\n+                                                            mac_span,\n                                                             marked_before.as_slice());\n                             parse_thunk(expanded)\n                         };\n@@ -254,7 +252,7 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n \n         match fld.cx.syntax_env.find(&intern(mname.get())) {\n             Some(rc) => match *rc {\n-                ItemDecorator(ref dec) => {\n+                Decorator(ref dec) => {\n                     attr::mark_used(attr);\n \n                     fld.cx.bt_push(ExpnInfo {\n@@ -311,7 +309,7 @@ fn expand_item_modifiers(mut it: P<ast::Item>, fld: &mut MacroExpander)\n     // partition the attributes into ItemModifiers and others\n     let (modifiers, other_attrs) = it.attrs.partitioned(|attr| {\n         match fld.cx.syntax_env.find(&intern(attr.name().get())) {\n-            Some(rc) => match *rc { ItemModifier(_) => true, _ => false },\n+            Some(rc) => match *rc { Modifier(_) => true, _ => false },\n             _ => false\n         }\n     });\n@@ -330,7 +328,7 @@ fn expand_item_modifiers(mut it: P<ast::Item>, fld: &mut MacroExpander)\n \n         match fld.cx.syntax_env.find(&intern(mname.get())) {\n             Some(rc) => match *rc {\n-                ItemModifier(ref mac) => {\n+                Modifier(ref mac) => {\n                     attr::mark_used(attr);\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: attr.span,\n@@ -759,9 +757,9 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n \n                     let fm = fresh_mark();\n                     let marked_before = mark_tts(tts.as_slice(), fm);\n-                    let mac_span = original_span(fld.cx);\n+                    let mac_span = fld.cx.original_span();\n                     let expanded = match expander.expand(fld.cx,\n-                                        mac_span.call_site,\n+                                        mac_span,\n                                         marked_before.as_slice()).make_pat() {\n                         Some(e) => e,\n                         None => {\n@@ -969,7 +967,7 @@ fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n     Span {\n         lo: sp.lo,\n         hi: sp.hi,\n-        expn_info: cx.backtrace(),\n+        expn_id: cx.backtrace(),\n     }\n }\n \n@@ -1083,21 +1081,6 @@ fn mark_method(expr: P<ast::Method>, m: Mrk) -> P<ast::Method> {\n         .expect_one(\"marking an item didn't return exactly one method\")\n }\n \n-fn original_span(cx: &ExtCtxt) -> Gc<codemap::ExpnInfo> {\n-    let mut relevant_info = cx.backtrace();\n-    let mut einfo = relevant_info.unwrap();\n-    loop {\n-        match relevant_info {\n-            None => { break }\n-            Some(e) => {\n-                einfo = e;\n-                relevant_info = einfo.call_site.expn_info;\n-            }\n-        }\n-    }\n-    return einfo;\n-}\n-\n /// Check that there are no macro invocations left in the AST:\n pub fn check_for_macros(sess: &parse::ParseSess, krate: &ast::Crate) {\n     visit::walk_crate(&mut MacroExterminator{sess:sess}, krate);"}, {"sha": "b760c893a106c88608770a2e6f64616f4666a268", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -19,17 +19,18 @@ use parse::token;\n use ptr::P;\n \n use std::collections::HashMap;\n+use std::string;\n \n #[deriving(PartialEq)]\n enum ArgumentType {\n-    Known(String),\n+    Known(string::String),\n     Unsigned,\n     String,\n }\n \n enum Position {\n     Exact(uint),\n-    Named(String),\n+    Named(string::String),\n }\n \n struct Context<'a, 'b:'a> {\n@@ -44,12 +45,12 @@ struct Context<'a, 'b:'a> {\n     /// Note that we keep a side-array of the ordering of the named arguments\n     /// found to be sure that we can translate them in the same order that they\n     /// were declared in.\n-    names: HashMap<String, P<ast::Expr>>,\n-    name_types: HashMap<String, ArgumentType>,\n-    name_ordering: Vec<String>,\n+    names: HashMap<string::String, P<ast::Expr>>,\n+    name_types: HashMap<string::String, ArgumentType>,\n+    name_ordering: Vec<string::String>,\n \n     /// The latest consecutive literal strings, or empty if there weren't any.\n-    literal: String,\n+    literal: string::String,\n \n     /// Collection of the compiled `rt::Argument` structures\n     pieces: Vec<P<ast::Expr>>,\n@@ -58,7 +59,7 @@ struct Context<'a, 'b:'a> {\n     /// Stays `true` if all formatting parameters are default (as in \"{}{}\").\n     all_pieces_simple: bool,\n \n-    name_positions: HashMap<String, uint>,\n+    name_positions: HashMap<string::String, uint>,\n     method_statics: Vec<P<ast::Item>>,\n \n     /// Updated as arguments are consumed or methods are entered\n@@ -81,10 +82,10 @@ pub enum Invocation {\n ///           named arguments))\n fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n               tts: &[ast::TokenTree])\n-    -> (Invocation, Option<(P<ast::Expr>, Vec<P<ast::Expr>>, Vec<String>,\n-                            HashMap<String, P<ast::Expr>>)>) {\n+    -> (Invocation, Option<(P<ast::Expr>, Vec<P<ast::Expr>>, Vec<string::String>,\n+                            HashMap<string::String, P<ast::Expr>>)>) {\n     let mut args = Vec::new();\n-    let mut names = HashMap::<String, P<ast::Expr>>::new();\n+    let mut names = HashMap::<string::String, P<ast::Expr>>::new();\n     let mut order = Vec::new();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n@@ -167,7 +168,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     fn verify_piece(&mut self, p: &parse::Piece) {\n         match *p {\n             parse::String(..) => {}\n-            parse::Argument(ref arg) => {\n+            parse::NextArgument(ref arg) => {\n                 // width/precision first, if they have implicit positional\n                 // parameters it makes more sense to consume them first.\n                 self.verify_count(arg.format.width);\n@@ -222,7 +223,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    fn describe_num_args(&self) -> String {\n+    fn describe_num_args(&self) -> string::String {\n         match self.args.len() {\n             0 => \"no arguments given\".to_string(),\n             1 => \"there is 1 argument\".to_string(),\n@@ -391,7 +392,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 self.literal.push_str(s);\n                 None\n             }\n-            parse::Argument(ref arg) => {\n+            parse::NextArgument(ref arg) => {\n                 // Translate the position\n                 let pos = match arg.position {\n                     // These two have a direct mapping\n@@ -747,8 +748,8 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n                                     invocation: Invocation,\n                                     efmt: P<ast::Expr>,\n                                     args: Vec<P<ast::Expr>>,\n-                                    name_ordering: Vec<String>,\n-                                    names: HashMap<String, P<ast::Expr>>)\n+                                    name_ordering: Vec<string::String>,\n+                                    names: HashMap<string::String, P<ast::Expr>>)\n                                     -> P<ast::Expr> {\n     let arg_types = Vec::from_fn(args.len(), |_| None);\n     let mut cx = Context {\n@@ -761,7 +762,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         name_ordering: name_ordering,\n         nest_level: 0,\n         next_arg: 0,\n-        literal: String::new(),\n+        literal: string::String::new(),\n         pieces: Vec::new(),\n         str_pieces: Vec::new(),\n         all_pieces_simple: true,"}, {"sha": "41967b0680cffa9684c5c0765e025940a472cb13", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 9, "deletions": 37, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -11,15 +11,13 @@\n use ast;\n use codemap;\n use codemap::{Pos, Span};\n-use codemap::{ExpnInfo, NameAndSpan};\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n use parse;\n use parse::token;\n use print::pprust;\n \n-use std::gc::Gc;\n use std::io::File;\n use std::rc::Rc;\n \n@@ -32,20 +30,20 @@ pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                    -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n-    let topmost = topmost_expn_info(cx.backtrace().unwrap());\n-    let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n+    let topmost = cx.original_span_in_file();\n+    let loc = cx.codemap().lookup_char_pos(topmost.lo);\n \n-    base::MacExpr::new(cx.expr_uint(topmost.call_site, loc.line))\n+    base::MacExpr::new(cx.expr_uint(topmost, loc.line))\n }\n \n /* col!(): expands to the current column number */\n pub fn expand_col(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                   -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"col!\");\n \n-    let topmost = topmost_expn_info(cx.backtrace().unwrap());\n-    let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n-    base::MacExpr::new(cx.expr_uint(topmost.call_site, loc.col.to_uint()))\n+    let topmost = cx.original_span_in_file();\n+    let loc = cx.codemap().lookup_char_pos(topmost.lo);\n+    base::MacExpr::new(cx.expr_uint(topmost, loc.col.to_uint()))\n }\n \n /// file!(): expands to the current filename */\n@@ -55,10 +53,10 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                    -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n-    let topmost = topmost_expn_info(cx.backtrace().unwrap());\n-    let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n+    let topmost = cx.original_span_in_file();\n+    let loc = cx.codemap().lookup_char_pos(topmost.lo);\n     let filename = token::intern_and_get_ident(loc.file.name.as_slice());\n-    base::MacExpr::new(cx.expr_str(topmost.call_site, filename))\n+    base::MacExpr::new(cx.expr_str(topmost, filename))\n }\n \n pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n@@ -162,32 +160,6 @@ pub fn expand_include_bin(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     }\n }\n \n-// recur along an ExpnInfo chain to find the original expression\n-fn topmost_expn_info(expn_info: Gc<codemap::ExpnInfo>) -> Gc<codemap::ExpnInfo> {\n-    match *expn_info {\n-        ExpnInfo { call_site: ref call_site, .. } => {\n-            match call_site.expn_info {\n-                Some(next_expn_info) => {\n-                    match *next_expn_info {\n-                        ExpnInfo {\n-                            callee: NameAndSpan { name: ref name, .. },\n-                            ..\n-                        } => {\n-                            // Don't recurse into file using \"include!\"\n-                            if \"include\" == name.as_slice() {\n-                                expn_info\n-                            } else {\n-                                topmost_expn_info(next_expn_info)\n-                            }\n-                        }\n-                    }\n-                },\n-                None => expn_info\n-            }\n-        }\n-    }\n-}\n-\n // resolve a file-system path to an absolute file-system path (if it\n // isn't already)\n fn res_rel_file(cx: &mut ExtCtxt, sp: codemap::Span, arg: &Path) -> Path {"}, {"sha": "7ebb11c148bd2964973becee5635e76b2c87a025", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -657,16 +657,26 @@ pub fn noop_fold_fn_decl<T: Folder>(decl: P<FnDecl>, fld: &mut T) -> P<FnDecl> {\n     })\n }\n \n-pub fn noop_fold_ty_param_bound<T: Folder>(tpb: TyParamBound, fld: &mut T)\n-                                           -> TyParamBound {\n+pub fn noop_fold_ty_param_bound<T>(tpb: TyParamBound, fld: &mut T)\n+                                   -> TyParamBound\n+                                   where T: Folder {\n     match tpb {\n         TraitTyParamBound(ty) => TraitTyParamBound(fld.fold_trait_ref(ty)),\n         RegionTyParamBound(lifetime) => RegionTyParamBound(fld.fold_lifetime(lifetime)),\n-        UnboxedFnTyParamBound(UnboxedFnTy {decl, kind}) => {\n-            UnboxedFnTyParamBound(UnboxedFnTy {\n-                decl: fld.fold_fn_decl(decl),\n-                kind: kind,\n-            })\n+        UnboxedFnTyParamBound(bound) => {\n+            match *bound {\n+                UnboxedFnBound {\n+                    ref path,\n+                    ref decl,\n+                    ref_id\n+                } => {\n+                    UnboxedFnTyParamBound(P(UnboxedFnBound {\n+                        path: fld.fold_path(path.clone()),\n+                        decl: fld.fold_fn_decl(decl.clone()),\n+                        ref_id: fld.new_id(ref_id),\n+                    }))\n+                }\n+            }\n         }\n     }\n }\n@@ -1242,6 +1252,12 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n             ExprIndex(el, er) => {\n                 ExprIndex(folder.fold_expr(el), folder.fold_expr(er))\n             }\n+            ExprSlice(e, e1, e2, m) => {\n+                ExprSlice(folder.fold_expr(e),\n+                          e1.map(|x| folder.fold_expr(x)),\n+                          e2.map(|x| folder.fold_expr(x)),\n+                          m)\n+            }\n             ExprPath(pth) => ExprPath(folder.fold_path(pth)),\n             ExprBreak(opt_ident) => ExprBreak(opt_ident.map(|x| folder.fold_ident(x))),\n             ExprAgain(opt_ident) => ExprAgain(opt_ident.map(|x| folder.fold_ident(x))),"}, {"sha": "153b3cc90d60101f8f9f66d32b5e4c25789cefc0", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -23,7 +23,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/master/\")]\n \n-#![feature(macro_rules, globs, managed_boxes, default_type_params, phase)]\n+#![feature(macro_rules, globs, default_type_params, phase)]\n #![feature(quote, struct_variant, unsafe_destructor, import_shadowing)]\n #![allow(deprecated)]\n "}, {"sha": "68ddd17dd012b4917e15f9ae810c5e9b08d29156", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -1406,7 +1406,7 @@ fn ident_continue(c: Option<char>) -> bool {\n mod test {\n     use super::*;\n \n-    use codemap::{BytePos, CodeMap, Span};\n+    use codemap::{BytePos, CodeMap, Span, NO_EXPANSION};\n     use diagnostic;\n     use parse::token;\n     use parse::token::{str_to_ident};\n@@ -1436,7 +1436,7 @@ mod test {\n         let tok1 = string_reader.next_token();\n         let tok2 = TokenAndSpan{\n             tok:token::IDENT(id, false),\n-            sp:Span {lo:BytePos(21),hi:BytePos(23),expn_info: None}};\n+            sp:Span {lo:BytePos(21),hi:BytePos(23),expn_id: NO_EXPANSION}};\n         assert_eq!(tok1,tok2);\n         assert_eq!(string_reader.next_token().tok, token::WS);\n         // the 'main' id is already read:\n@@ -1445,7 +1445,7 @@ mod test {\n         let tok3 = string_reader.next_token();\n         let tok4 = TokenAndSpan{\n             tok:token::IDENT(str_to_ident(\"main\"), false),\n-            sp:Span {lo:BytePos(24),hi:BytePos(28),expn_info: None}};\n+            sp:Span {lo:BytePos(24),hi:BytePos(28),expn_id: NO_EXPANSION}};\n         assert_eq!(tok3,tok4);\n         // the lparen is already read:\n         assert_eq!(string_reader.last_pos.clone(), BytePos(29))"}, {"sha": "66ecdbfca02d4f774ecb99e711aa7788ced95257", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -721,7 +721,7 @@ pub fn integer_lit(s: &str, sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n mod test {\n     use super::*;\n     use serialize::json;\n-    use codemap::{Span, BytePos, Spanned};\n+    use codemap::{Span, BytePos, Spanned, NO_EXPANSION};\n     use owned_slice::OwnedSlice;\n     use ast;\n     use abi;\n@@ -736,7 +736,7 @@ mod test {\n \n     // produce a codemap::span\n     fn sp(a: u32, b: u32) -> Span {\n-        Span{lo:BytePos(a),hi:BytePos(b),expn_info:None}\n+        Span {lo: BytePos(a), hi: BytePos(b), expn_id: NO_EXPANSION}\n     }\n \n     #[test] fn path_exprs_1() {"}, {"sha": "069d30cbd835416c3e655a47aed42593b6fc9605", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 124, "deletions": 59, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -23,7 +23,7 @@ use ast::{DeclLocal, DefaultBlock, UnDeref, BiDiv, EMPTY_CTXT, EnumDef, Explicit\n use ast::{Expr, Expr_, ExprAddrOf, ExprMatch, ExprAgain};\n use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock, ExprBox};\n use ast::{ExprBreak, ExprCall, ExprCast};\n-use ast::{ExprField, ExprTupField, ExprFnBlock, ExprIf, ExprIndex};\n+use ast::{ExprField, ExprTupField, ExprFnBlock, ExprIf, ExprIndex, ExprSlice};\n use ast::{ExprLit, ExprLoop, ExprMac};\n use ast::{ExprMethodCall, ExprParen, ExprPath, ExprProc};\n use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary, ExprUnboxedFn};\n@@ -55,7 +55,8 @@ use ast::{TyTypeof, TyInfer, TypeMethod};\n use ast::{TyNil, TyParam, TyParamBound, TyParen, TyPath, TyPtr, TyQPath};\n use ast::{TyRptr, TyTup, TyU32, TyUnboxedFn, TyUniq, TyVec, UnUniq};\n use ast::{TypeImplItem, TypeTraitItem, Typedef, UnboxedClosureKind};\n-use ast::{UnboxedFnTy, UnboxedFnTyParamBound, UnnamedField, UnsafeBlock};\n+use ast::{UnboxedFnBound, UnboxedFnTy, UnboxedFnTyParamBound};\n+use ast::{UnnamedField, UnsafeBlock};\n use ast::{UnsafeFn, ViewItem, ViewItem_, ViewItemExternCrate, ViewItemUse};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause, WherePredicate};\n@@ -1986,6 +1987,14 @@ impl<'a> Parser<'a> {\n         ExprIndex(expr, idx)\n     }\n \n+    pub fn mk_slice(&mut self, expr: P<Expr>,\n+                    start: Option<P<Expr>>,\n+                    end: Option<P<Expr>>,\n+                    mutbl: Mutability)\n+                    -> ast::Expr_ {\n+        ExprSlice(expr, start, end, mutbl)\n+    }\n+\n     pub fn mk_field(&mut self, expr: P<Expr>, ident: ast::SpannedIdent,\n                     tys: Vec<P<Ty>>) -> ast::Expr_ {\n         ExprField(expr, ident, tys)\n@@ -2400,13 +2409,87 @@ impl<'a> Parser<'a> {\n               }\n \n               // expr[...]\n+              // Could be either an index expression or a slicing expression.\n+              // Any slicing non-terminal can have a mutable version with `mut`\n+              // after the opening square bracket.\n               token::LBRACKET => {\n                 self.bump();\n-                let ix = self.parse_expr();\n-                hi = self.span.hi;\n-                self.commit_expr_expecting(&*ix, token::RBRACKET);\n-                let index = self.mk_index(e, ix);\n-                e = self.mk_expr(lo, hi, index)\n+                let mutbl = if self.eat_keyword(keywords::Mut) {\n+                    MutMutable\n+                } else {\n+                    MutImmutable\n+                };\n+                match self.token {\n+                    // e[]\n+                    token::RBRACKET => {\n+                        self.bump();\n+                        hi = self.span.hi;\n+                        let slice = self.mk_slice(e, None, None, mutbl);\n+                        e = self.mk_expr(lo, hi, slice)\n+                    }\n+                    // e[..e]\n+                    token::DOTDOT => {\n+                        self.bump();\n+                        match self.token {\n+                            // e[..]\n+                            token::RBRACKET => {\n+                                self.bump();\n+                                hi = self.span.hi;\n+                                let slice = self.mk_slice(e, None, None, mutbl);\n+                                e = self.mk_expr(lo, hi, slice);\n+\n+                                self.span_err(e.span, \"incorrect slicing expression: `[..]`\");\n+                                self.span_note(e.span,\n+                                    \"use `expr[]` to construct a slice of the whole of expr\");\n+                            }\n+                            // e[..e]\n+                            _ => {\n+                                hi = self.span.hi;\n+                                let e2 = self.parse_expr();\n+                                self.commit_expr_expecting(&*e2, token::RBRACKET);\n+                                let slice = self.mk_slice(e, None, Some(e2), mutbl);\n+                                e = self.mk_expr(lo, hi, slice)\n+                            }\n+                        }\n+                    }\n+                    // e[e] | e[e..] | e[e..e]\n+                    _ => {\n+                        let ix = self.parse_expr();\n+                        match self.token {\n+                            // e[e..] | e[e..e]\n+                            token::DOTDOT => {\n+                                self.bump();\n+                                let e2 = match self.token {\n+                                    // e[e..]\n+                                    token::RBRACKET => {\n+                                        self.bump();\n+                                        None\n+                                    }\n+                                    // e[e..e]\n+                                    _ => {\n+                                        let e2 = self.parse_expr();\n+                                        self.commit_expr_expecting(&*e2, token::RBRACKET);\n+                                        Some(e2)\n+                                    }\n+                                };\n+                                hi = self.span.hi;\n+                                let slice = self.mk_slice(e, Some(ix), e2, mutbl);\n+                                e = self.mk_expr(lo, hi, slice)\n+                            }\n+                            // e[e]\n+                            _ => {\n+                                if mutbl == ast::MutMutable {\n+                                    self.span_err(e.span,\n+                                                  \"`mut` keyword is invalid in index expressions\");\n+                                }\n+                                hi = self.span.hi;\n+                                self.commit_expr_expecting(&*ix, token::RBRACKET);\n+                                let index = self.mk_index(e, ix);\n+                                e = self.mk_expr(lo, hi, index)\n+                            }\n+                        }\n+                    }\n+                }\n               }\n \n               _ => return e\n@@ -3153,7 +3236,8 @@ impl<'a> Parser<'a> {\n             // These expressions are limited to literals (possibly\n             // preceded by unary-minus) or identifiers.\n             let val = self.parse_literal_maybe_minus();\n-            if self.token == token::DOTDOT &&\n+            // FIXME(#17295) remove the DOTDOT option.\n+            if (self.token == token::DOTDOTDOT || self.token == token::DOTDOT) &&\n                     self.look_ahead(1, |t| {\n                         *t != token::COMMA && *t != token::RBRACKET\n                     }) {\n@@ -3198,12 +3282,16 @@ impl<'a> Parser<'a> {\n                 }\n             });\n \n-            if self.look_ahead(1, |t| *t == token::DOTDOT) &&\n+            // FIXME(#17295) remove the DOTDOT option.\n+            if self.look_ahead(1, |t| *t == token::DOTDOTDOT || *t == token::DOTDOT) &&\n                     self.look_ahead(2, |t| {\n                         *t != token::COMMA && *t != token::RBRACKET\n                     }) {\n                 let start = self.parse_expr_res(RestrictionNoBarOp);\n-                self.eat(&token::DOTDOT);\n+                // FIXME(#17295) remove the DOTDOT option (self.eat(&token::DOTDOTDOT)).\n+                if self.token == token::DOTDOTDOT || self.token == token::DOTDOT {\n+                    self.bump();\n+                }\n                 let end = self.parse_expr_res(RestrictionNoBarOp);\n                 pat = PatRange(start, end);\n             } else if is_plain_ident(&self.token) && !can_be_enum_or_struct {\n@@ -3590,7 +3678,7 @@ impl<'a> Parser<'a> {\n                                     let span_with_semi = Span {\n                                         lo: span.lo,\n                                         hi: self.last_span.hi,\n-                                        expn_info: span.expn_info,\n+                                        expn_id: span.expn_id,\n                                     };\n                                     stmts.push(P(Spanned {\n                                         node: StmtSemi(e, stmt_id),\n@@ -3666,39 +3754,6 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn parse_unboxed_function_type(&mut self) -> UnboxedFnTy {\n-        let (optional_unboxed_closure_kind, inputs) =\n-            if self.eat(&token::OROR) {\n-                (None, Vec::new())\n-            } else {\n-                self.expect_or();\n-\n-                let optional_unboxed_closure_kind =\n-                    self.parse_optional_unboxed_closure_kind();\n-\n-                let inputs = self.parse_seq_to_before_or(&token::COMMA,\n-                                                         |p| {\n-                    p.parse_arg_general(false)\n-                });\n-                self.expect_or();\n-                (optional_unboxed_closure_kind, inputs)\n-            };\n-\n-        let (return_style, output) = self.parse_ret_ty();\n-        UnboxedFnTy {\n-            decl: P(FnDecl {\n-                inputs: inputs,\n-                output: output,\n-                cf: return_style,\n-                variadic: false,\n-            }),\n-            kind: match optional_unboxed_closure_kind {\n-                Some(kind) => kind,\n-                None => FnMutUnboxedClosureKind,\n-            },\n-        }\n-    }\n-\n     // Parses a sequence of bounds if a `:` is found,\n     // otherwise returns empty list.\n     fn parse_colon_then_ty_param_bounds(&mut self)\n@@ -3730,13 +3785,31 @@ impl<'a> Parser<'a> {\n                     self.bump();\n                 }\n                 token::MOD_SEP | token::IDENT(..) => {\n-                    let tref = self.parse_trait_ref();\n-                    result.push(TraitTyParamBound(tref));\n-                }\n-                token::BINOP(token::OR) | token::OROR => {\n-                    let unboxed_function_type =\n-                        self.parse_unboxed_function_type();\n-                    result.push(UnboxedFnTyParamBound(unboxed_function_type));\n+                    let path =\n+                        self.parse_path(LifetimeAndTypesWithoutColons).path;\n+                    if self.token == token::LPAREN {\n+                        self.bump();\n+                        let inputs = self.parse_seq_to_end(\n+                            &token::RPAREN,\n+                            seq_sep_trailing_allowed(token::COMMA),\n+                            |p| p.parse_arg_general(false));\n+                        let (return_style, output) = self.parse_ret_ty();\n+                        result.push(UnboxedFnTyParamBound(P(UnboxedFnBound {\n+                            path: path,\n+                            decl: P(FnDecl {\n+                                inputs: inputs,\n+                                output: output,\n+                                cf: return_style,\n+                                variadic: false,\n+                            }),\n+                            ref_id: ast::DUMMY_NODE_ID,\n+                        })));\n+                    } else {\n+                        result.push(TraitTyParamBound(ast::TraitRef {\n+                            path: path,\n+                            ref_id: ast::DUMMY_NODE_ID,\n+                        }))\n+                    }\n                 }\n                 _ => break,\n             }\n@@ -4423,14 +4496,6 @@ impl<'a> Parser<'a> {\n          Some(attrs))\n     }\n \n-    /// Parse a::B<String,int>\n-    fn parse_trait_ref(&mut self) -> TraitRef {\n-        ast::TraitRef {\n-            path: self.parse_path(LifetimeAndTypesWithoutColons).path,\n-            ref_id: ast::DUMMY_NODE_ID,\n-        }\n-    }\n-\n     /// Parse struct Foo { ... }\n     fn parse_item_struct(&mut self, is_virtual: bool) -> ItemInfo {\n         let class_name = self.parse_ident();"}, {"sha": "f71190da4301172d4a909389374e004adbad0b07", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 48, "deletions": 35, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -431,9 +431,11 @@ macro_rules! declare_special_idents_and_keywords {(\n // If the special idents get renumbered, remember to modify these two as appropriate\n pub static SELF_KEYWORD_NAME: Name = Name(SELF_KEYWORD_NAME_NUM);\n static STATIC_KEYWORD_NAME: Name = Name(STATIC_KEYWORD_NAME_NUM);\n+static SUPER_KEYWORD_NAME: Name = Name(SUPER_KEYWORD_NAME_NUM);\n \n pub static SELF_KEYWORD_NAME_NUM: u32 = 1;\n static STATIC_KEYWORD_NAME_NUM: u32 = 2;\n+static SUPER_KEYWORD_NAME_NUM: u32 = 3;\n \n // NB: leaving holes in the ident table is bad! a different ident will get\n // interned with the id from the hole, but it will be between the min and max\n@@ -443,52 +445,53 @@ declare_special_idents_and_keywords! {\n     pub mod special_idents {\n         // These ones are statics\n         (0,                          invalid,                \"\");\n-        (super::SELF_KEYWORD_NAME_NUM,   self_,                  \"self\");\n-        (super::STATIC_KEYWORD_NAME_NUM, statik,                 \"static\");\n-        (3,                          static_lifetime,        \"'static\");\n+        (super::SELF_KEYWORD_NAME_NUM,   self_,              \"self\");\n+        (super::STATIC_KEYWORD_NAME_NUM, statik,             \"static\");\n+        (super::SUPER_KEYWORD_NAME_NUM, super_,              \"super\");\n+        (4,                          static_lifetime,        \"'static\");\n \n         // for matcher NTs\n-        (4,                          tt,                     \"tt\");\n-        (5,                          matchers,               \"matchers\");\n+        (5,                          tt,                     \"tt\");\n+        (6,                          matchers,               \"matchers\");\n \n         // outside of libsyntax\n-        (6,                          clownshoe_abi,          \"__rust_abi\");\n-        (7,                          opaque,                 \"<opaque>\");\n-        (8,                          unnamed_field,          \"<unnamed_field>\");\n-        (9,                          type_self,              \"Self\");\n-        (10,                         prelude_import,         \"prelude_import\");\n+        (7,                          clownshoe_abi,          \"__rust_abi\");\n+        (8,                          opaque,                 \"<opaque>\");\n+        (9,                          unnamed_field,          \"<unnamed_field>\");\n+        (10,                         type_self,              \"Self\");\n+        (11,                         prelude_import,         \"prelude_import\");\n     }\n \n     pub mod keywords {\n         // These ones are variants of the Keyword enum\n \n         'strict:\n-        (11,                         As,         \"as\");\n-        (12,                         Break,      \"break\");\n-        (13,                         Crate,      \"crate\");\n-        (14,                         Else,       \"else\");\n-        (15,                         Enum,       \"enum\");\n-        (16,                         Extern,     \"extern\");\n-        (17,                         False,      \"false\");\n-        (18,                         Fn,         \"fn\");\n-        (19,                         For,        \"for\");\n-        (20,                         If,         \"if\");\n-        (21,                         Impl,       \"impl\");\n-        (22,                         In,         \"in\");\n-        (23,                         Let,        \"let\");\n-        (24,                         Loop,       \"loop\");\n-        (25,                         Match,      \"match\");\n-        (26,                         Mod,        \"mod\");\n-        (27,                         Mut,        \"mut\");\n-        (28,                         Once,       \"once\");\n-        (29,                         Pub,        \"pub\");\n-        (30,                         Ref,        \"ref\");\n-        (31,                         Return,     \"return\");\n+        (12,                         As,         \"as\");\n+        (13,                         Break,      \"break\");\n+        (14,                         Crate,      \"crate\");\n+        (15,                         Else,       \"else\");\n+        (16,                         Enum,       \"enum\");\n+        (17,                         Extern,     \"extern\");\n+        (18,                         False,      \"false\");\n+        (19,                         Fn,         \"fn\");\n+        (20,                         For,        \"for\");\n+        (21,                         If,         \"if\");\n+        (22,                         Impl,       \"impl\");\n+        (23,                         In,         \"in\");\n+        (24,                         Let,        \"let\");\n+        (25,                         Loop,       \"loop\");\n+        (26,                         Match,      \"match\");\n+        (27,                         Mod,        \"mod\");\n+        (28,                         Mut,        \"mut\");\n+        (29,                         Once,       \"once\");\n+        (30,                         Pub,        \"pub\");\n+        (31,                         Ref,        \"ref\");\n+        (32,                         Return,     \"return\");\n         // Static and Self are also special idents (prefill de-dupes)\n-        (super::STATIC_KEYWORD_NAME_NUM, Static,     \"static\");\n-        (super::SELF_KEYWORD_NAME_NUM,   Self,       \"self\");\n-        (32,                         Struct,     \"struct\");\n-        (33,                         Super,      \"super\");\n+        (super::STATIC_KEYWORD_NAME_NUM, Static, \"static\");\n+        (super::SELF_KEYWORD_NAME_NUM,   Self,   \"self\");\n+        (33,                         Struct,     \"struct\");\n+        (super::SUPER_KEYWORD_NAME_NUM, Super,   \"super\");\n         (34,                         True,       \"true\");\n         (35,                         Trait,      \"trait\");\n         (36,                         Type,       \"type\");\n@@ -713,6 +716,7 @@ pub fn is_any_keyword(tok: &Token) -> bool {\n \n                n == SELF_KEYWORD_NAME\n             || n == STATIC_KEYWORD_NAME\n+            || n == SUPER_KEYWORD_NAME\n             || STRICT_KEYWORD_START <= n\n             && n <= RESERVED_KEYWORD_FINAL\n         },\n@@ -727,9 +731,18 @@ pub fn is_strict_keyword(tok: &Token) -> bool {\n \n                n == SELF_KEYWORD_NAME\n             || n == STATIC_KEYWORD_NAME\n+            || n == SUPER_KEYWORD_NAME\n             || STRICT_KEYWORD_START <= n\n             && n <= STRICT_KEYWORD_FINAL\n         },\n+        token::IDENT(sid, true) => {\n+            let n = sid.name;\n+\n+               n != SELF_KEYWORD_NAME\n+            && n != SUPER_KEYWORD_NAME\n+            && STRICT_KEYWORD_START <= n\n+            && n <= STRICT_KEYWORD_FINAL\n+        }\n         _ => false,\n     }\n }"}, {"sha": "f1fdc71b9c6f5672d619369fac16372773b631f8", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -60,7 +60,7 @@\n //! avoid combining it with other lines and making matters even worse.\n \n use std::io;\n-use std::string::String;\n+use std::string;\n \n #[deriving(Clone, PartialEq)]\n pub enum Breaks {\n@@ -82,7 +82,7 @@ pub struct BeginToken {\n \n #[deriving(Clone)]\n pub enum Token {\n-    String(String, int),\n+    String(string::String, int),\n     Break(BreakToken),\n     Begin(BeginToken),\n     End,\n@@ -107,7 +107,7 @@ impl Token {\n     }\n }\n \n-pub fn tok_str(t: Token) -> String {\n+pub fn tok_str(t: Token) -> string::String {\n     match t {\n         String(s, len) => return format!(\"STR({},{})\", s, len),\n         Break(_) => return \"BREAK\".to_string(),\n@@ -122,12 +122,12 @@ pub fn buf_str(toks: Vec<Token>,\n                left: uint,\n                right: uint,\n                lim: uint)\n-               -> String {\n+               -> string::String {\n     let n = toks.len();\n     assert_eq!(n, szs.len());\n     let mut i = left;\n     let mut l = lim;\n-    let mut s = String::from_str(\"[\");\n+    let mut s = string::String::from_str(\"[\");\n     while i != right && l != 0u {\n         l -= 1u;\n         if i != left {"}, {"sha": "473179a037a527409aad2c14b3e51e04aa73d706", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 48, "deletions": 25, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -1651,6 +1651,28 @@ impl<'a> State<'a> {\n                 try!(self.print_expr(&**index));\n                 try!(word(&mut self.s, \"]\"));\n             }\n+            ast::ExprSlice(ref e, ref start, ref end, ref mutbl) => {\n+                try!(self.print_expr(&**e));\n+                try!(word(&mut self.s, \"[\"));\n+                if mutbl == &ast::MutMutable {\n+                    try!(word(&mut self.s, \"mut\"));\n+                    if start.is_some() || end.is_some() {\n+                        try!(space(&mut self.s));\n+                    }\n+                }\n+                match start {\n+                    &Some(ref e) => try!(self.print_expr(&**e)),\n+                    _ => {}\n+                }\n+                if start.is_some() || end.is_some() {\n+                    try!(word(&mut self.s, \"..\"));\n+                }\n+                match end {\n+                    &Some(ref e) => try!(self.print_expr(&**e)),\n+                    _ => {}\n+                }\n+                try!(word(&mut self.s, \"]\"));\n+            }\n             ast::ExprPath(ref path) => try!(self.print_path(path, true)),\n             ast::ExprBreak(opt_ident) => {\n                 try!(word(&mut self.s, \"break\"));\n@@ -1944,7 +1966,7 @@ impl<'a> State<'a> {\n             ast::PatRange(ref begin, ref end) => {\n                 try!(self.print_expr(&**begin));\n                 try!(space(&mut self.s));\n-                try!(word(&mut self.s, \"..\"));\n+                try!(word(&mut self.s, \"...\"));\n                 try!(self.print_expr(&**end));\n             }\n             ast::PatVec(ref before, ref slice, ref after) => {\n@@ -2190,16 +2212,13 @@ impl<'a> State<'a> {\n                         self.print_lifetime(lt)\n                     }\n                     UnboxedFnTyParamBound(ref unboxed_function_type) => {\n-                        self.print_ty_fn(None,\n-                                         None,\n-                                         ast::NormalFn,\n-                                         ast::Many,\n-                                         &*unboxed_function_type.decl,\n-                                         None,\n-                                         &OwnedSlice::empty(),\n-                                         None,\n-                                         None,\n-                                         Some(unboxed_function_type.kind))\n+                        try!(self.print_path(&unboxed_function_type.path,\n+                                             false));\n+                        try!(self.popen());\n+                        try!(self.print_fn_args(&*unboxed_function_type.decl,\n+                                                None));\n+                        try!(self.pclose());\n+                        self.print_fn_output(&*unboxed_function_type.decl)\n                     }\n                 })\n             }\n@@ -2430,6 +2449,23 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n+    pub fn print_fn_output(&mut self, decl: &ast::FnDecl) -> IoResult<()> {\n+        match decl.output.node {\n+            ast::TyNil => Ok(()),\n+            _ => {\n+                try!(self.space_if_not_bol());\n+                try!(self.ibox(indent_unit));\n+                try!(self.word_space(\"->\"));\n+                if decl.cf == ast::NoReturn {\n+                    try!(self.word_nbsp(\"!\"));\n+                } else {\n+                    try!(self.print_type(&*decl.output));\n+                }\n+                self.end()\n+            }\n+        }\n+    }\n+\n     pub fn print_ty_fn(&mut self,\n                        opt_abi: Option<abi::Abi>,\n                        opt_sigil: Option<char>,\n@@ -2510,20 +2546,7 @@ impl<'a> State<'a> {\n \n         try!(self.maybe_print_comment(decl.output.span.lo));\n \n-        match decl.output.node {\n-            ast::TyNil => {}\n-            _ => {\n-                try!(self.space_if_not_bol());\n-                try!(self.ibox(indent_unit));\n-                try!(self.word_space(\"->\"));\n-                if decl.cf == ast::NoReturn {\n-                    try!(self.word_nbsp(\"!\"));\n-                } else {\n-                    try!(self.print_type(&*decl.output));\n-                }\n-                try!(self.end());\n-            }\n-        }\n+        try!(self.print_fn_output(decl));\n \n         match generics {\n             Some(generics) => try!(self.print_where_clause(generics)),"}, {"sha": "32084856817e1e961652cacfe54a1deb993625ff", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -785,6 +785,11 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(&**main_expression);\n             visitor.visit_expr(&**index_expression)\n         }\n+        ExprSlice(ref main_expression, ref start, ref end, _) => {\n+            visitor.visit_expr(&**main_expression);\n+            walk_expr_opt(visitor, start);\n+            walk_expr_opt(visitor, end)\n+        }\n         ExprPath(ref path) => {\n             visitor.visit_path(path, expression.id)\n         }"}, {"sha": "93f773f430d409b75aca60667ced2e5b5c331367", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -41,7 +41,7 @@ enum FormatState {\n #[allow(missing_doc)]\n #[deriving(Clone)]\n pub enum Param {\n-    String(String),\n+    Words(String),\n     Number(int)\n }\n \n@@ -140,8 +140,8 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     '{' => state = IntConstant(0),\n                     'l' => if stack.len() > 0 {\n                         match stack.pop().unwrap() {\n-                            String(s) => stack.push(Number(s.len() as int)),\n-                            _         => return Err(\"a non-str was used with %l\".to_string())\n+                            Words(s) => stack.push(Number(s.len() as int)),\n+                            _        => return Err(\"a non-str was used with %l\".to_string())\n                         }\n                     } else { return Err(\"stack is empty\".to_string()) },\n                     '+' => if stack.len() > 1 {\n@@ -543,7 +543,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n             }\n             s\n         }\n-        String(s) => {\n+        Words(s) => {\n             match op {\n                 FormatString => {\n                     let mut s = Vec::from_slice(s.as_bytes());\n@@ -575,7 +575,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n \n #[cfg(test)]\n mod test {\n-    use super::{expand,String,Variables,Number};\n+    use super::{expand,Words,Variables,Number};\n     use std::result::Ok;\n \n     #[test]\n@@ -611,7 +611,7 @@ mod test {\n             assert!(res.is_err(),\n                     \"Op {} succeeded incorrectly with 0 stack entries\", *cap);\n             let p = if *cap == \"%s\" || *cap == \"%l\" {\n-                String(\"foo\".to_string())\n+                Words(\"foo\".to_string())\n             } else {\n                 Number(97)\n             };\n@@ -689,12 +689,12 @@ mod test {\n         let mut varstruct = Variables::new();\n         let vars = &mut varstruct;\n         assert_eq!(expand(b\"%p1%s%p2%2s%p3%2s%p4%.2s\",\n-                          [String(\"foo\".to_string()),\n-                           String(\"foo\".to_string()),\n-                           String(\"f\".to_string()),\n-                           String(\"foo\".to_string())], vars),\n+                          [Words(\"foo\".to_string()),\n+                           Words(\"foo\".to_string()),\n+                           Words(\"f\".to_string()),\n+                           Words(\"foo\".to_string())], vars),\n                    Ok(\"foofoo ffo\".bytes().collect()));\n-        assert_eq!(expand(b\"%p1%:-4.2s\", [String(\"foo\".to_string())], vars),\n+        assert_eq!(expand(b\"%p1%:-4.2s\", [Words(\"foo\".to_string())], vars),\n                    Ok(\"fo  \".bytes().collect()));\n \n         assert_eq!(expand(b\"%p1%d%p1%.3d%p1%5d%p1%:+d\", [Number(1)], vars),"}, {"sha": "269afea52c2625a9052fe42d42f37821667162b7", "filename": "src/test/auxiliary/issue_16723_multiple_items_syntax_ext.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fauxiliary%2Fissue_16723_multiple_items_syntax_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fauxiliary%2Fissue_16723_multiple_items_syntax_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_16723_multiple_items_syntax_ext.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// ignore-stage1\n+#![feature(plugin_registrar, managed_boxes, quote)]\n+#![crate_type = \"dylib\"]\n+\n+extern crate syntax;\n+extern crate rustc;\n+\n+use syntax::ast;\n+use syntax::codemap;\n+use syntax::ext::base::{ExtCtxt, MacResult, MacItems};\n+use rustc::plugin::Registry;\n+\n+#[plugin_registrar]\n+pub fn plugin_registrar(reg: &mut Registry) {\n+    reg.register_macro(\"multiple_items\", expand)\n+}\n+\n+fn expand(cx: &mut ExtCtxt, _: codemap::Span, _: &[ast::TokenTree]) -> Box<MacResult+'static> {\n+    MacItems::new(vec![\n+        quote_item!(cx, struct Struct1;).unwrap(),\n+        quote_item!(cx, struct Struct2;).unwrap()\n+    ].into_iter())\n+}"}, {"sha": "befd33fca4eebf6bfb1c58a9da9c40f456b211a3", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -35,7 +35,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_macro(\"identity\", expand_identity);\n     reg.register_syntax_extension(\n         token::intern(\"into_foo\"),\n-        ItemModifier(box expand_into_foo));\n+        Modifier(box expand_into_foo));\n }\n \n fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])"}, {"sha": "6487c704765b352b1454c480461e8e122a3bce80", "filename": "src/test/auxiliary/xcrate_unit_struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fauxiliary%2Fxcrate_unit_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fauxiliary%2Fxcrate_unit_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fxcrate_unit_struct.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -15,7 +15,7 @@\n pub struct Struct;\n \n pub enum Unit {\n-    Unit,\n+    UnitVariant,\n     Argument(Struct)\n }\n "}, {"sha": "61c77ce7bbaa9ac2acaa571ac4e126775d3ae845", "filename": "src/test/compile-fail/borrowck-closures-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-unique.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -43,7 +43,7 @@ fn d(x: &mut int) {\n }\n \n fn e(x: &mut int) {\n-    let c1: || = || x = fail!(); //~ ERROR closure cannot assign to immutable argument `x`\n+    let c1: || = || x = fail!(); //~ ERROR closure cannot assign to immutable local variable\n }\n \n fn main() {"}, {"sha": "5f9dd72f5bf148733a611321bb5d014d4d3abe5f", "filename": "src/test/compile-fail/borrowck-unboxed-closures.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fborrowck-unboxed-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fborrowck-unboxed-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-unboxed-closures.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -10,17 +10,17 @@\n \n #![feature(overloaded_calls)]\n \n-fn a<F:|&: int, int| -> int>(mut f: F) {\n+fn a<F:Fn(int, int) -> int>(mut f: F) {\n     let g = &mut f;\n     f(1, 2);    //~ ERROR cannot borrow `f` as immutable\n     //~^ ERROR cannot borrow `f` as immutable\n }\n \n-fn b<F:|&mut: int, int| -> int>(f: F) {\n-    f(1, 2);    //~ ERROR cannot borrow immutable argument\n+fn b<F:FnMut(int, int) -> int>(f: F) {\n+    f(1, 2);    //~ ERROR cannot borrow immutable local variable\n }\n \n-fn c<F:|: int, int| -> int>(f: F) {\n+fn c<F:FnOnce(int, int) -> int>(f: F) {\n     f(1, 2);\n     f(1, 2);    //~ ERROR use of moved value\n }"}, {"sha": "bf80626793d6d18cea6fe803e88a9381c5804182", "filename": "src/test/compile-fail/enum-variant-type-2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fenum-variant-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fenum-variant-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-variant-type-2.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that enum variants are not actually types.\n+\n+enum Foo {\n+    Bar\n+}\n+\n+fn foo(x: Bar) {} //~ERROR found value name used as a type\n+\n+fn main() {}"}, {"sha": "93d44f96c8aa0578f4cf7f436c2a871ec6fa4085", "filename": "src/test/compile-fail/enum-variant-type.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fenum-variant-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fenum-variant-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-variant-type.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that enum variants are in the type namespace.\n+\n+enum Foo {\n+    Foo //~ERROR duplicate definition of type or module `Foo`\n+}\n+\n+enum Bar {\n+    Baz\n+}\n+\n+trait Baz {} //~ERROR duplicate definition of type or module `Baz`\n+\n+pub fn main() {}"}, {"sha": "d2d7d800470fe8a22cd3e8734055cc4a65e13238", "filename": "src/test/compile-fail/issue-3008-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fissue-3008-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fissue-3008-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3008-1.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum foo { foo(bar) }\n+enum foo { foo_(bar) }\n enum bar { bar_none, bar_some(bar) }\n //~^ ERROR illegal recursive enum type; wrap the inner value in a box to make it representable\n "}, {"sha": "1e8f81a05e7f9c51ba67ceb903c68f3f09bb1e33", "filename": "src/test/compile-fail/issue-3008-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum foo { foo(bar) }\n+enum foo { foo_(bar) }\n struct bar { x: bar }\n //~^ ERROR illegal recursive struct type; wrap the inner value in a box to make it representable\n //~^^ ERROR this type cannot be instantiated without an instance of itself"}, {"sha": "f69b041597edfcf153eca1888cdce13cf1d1ef31", "filename": "src/test/compile-fail/keywords-followed-by-double-colon.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fkeywords-followed-by-double-colon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fkeywords-followed-by-double-colon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkeywords-followed-by-double-colon.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum y { x }\n+fn main() {\n+    struct::foo();  //~ ERROR expected identifier\n+    mut::baz(); //~ ERROR expected identifier\n+}\n \n-enum x {}\n-\n-pub fn main() {}", "previous_filename": "src/test/run-pass/issue-3186.rs"}, {"sha": "06d473baea878403c7d12375fd41129b8cb19de2", "filename": "src/test/compile-fail/qquote-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -39,7 +39,7 @@ impl fake_ext_ctxt for fake_session {\n         codemap::span {\n             lo: codemap::BytePos(0),\n             hi: codemap::BytePos(0),\n-            expn_info: None\n+            expn_id: NO_EXPANSION\n         }\n     }\n     fn ident_of(st: &str) -> ast::ident {"}, {"sha": "f63dd91eb2bc14465beefa07878d214028736f72", "filename": "src/test/compile-fail/qquote-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -36,7 +36,7 @@ impl fake_ext_ctxt for fake_session {\n         codemap::span {\n             lo: codemap::BytePos(0),\n             hi: codemap::BytePos(0),\n-            expn_info: None\n+            expn_id: codemap::NO_EXPANSION\n         }\n     }\n     fn ident_of(st: &str) -> ast::ident {"}, {"sha": "c99ec5187b00ffcac8e507396cc0f203c942f306", "filename": "src/test/compile-fail/recursion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Frecursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Frecursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursion.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum Nil {Nil}\n+enum Nil {NilValue}\n struct Cons<T> {head:int, tail:T}\n trait Dot {fn dot(&self, other:Self) -> int;}\n impl Dot for Nil {\n@@ -29,6 +29,6 @@ fn test<T:Dot> (n:int, i:int, first:T, second:T) ->int {\n   }\n }\n pub fn main() {\n-  let n = test(1, 0, Nil, Nil);\n+  let n = test(1, 0, NilValue, NilValue);\n   println!(\"{}\", n);\n }"}, {"sha": "d0339745c9eafc9cb4e43599c967b8cb5ec2f47e", "filename": "src/test/compile-fail/slice-1.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fslice-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fslice-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-1.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test slicing expr[..] is an error and gives a helpful error message.\n+\n+struct Foo;\n+\n+fn main() {\n+    let x = Foo;\n+    x[..]; //~ ERROR incorrect slicing expression: `[..]`\n+    //~^ NOTE use `expr[]` to construct a slice of the whole of expr\n+}"}, {"sha": "fbfc438321c8e4ab22dea549b83bc52af85cb958", "filename": "src/test/compile-fail/slice-2.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fslice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fslice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-2.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that slicing syntax gives errors if we have not implemented the trait.\n+\n+struct Foo;\n+\n+fn main() {\n+    let x = Foo;\n+    x[]; //~ ERROR cannot take a slice of a value with type `Foo`\n+    x[Foo..]; //~ ERROR cannot take a slice of a value with type `Foo`\n+    x[..Foo]; //~ ERROR cannot take a slice of a value with type `Foo`\n+    x[Foo..Foo]; //~ ERROR cannot take a slice of a value with type `Foo`\n+    x[mut]; //~ ERROR cannot take a mutable slice of a value with type `Foo`\n+    x[mut Foo..]; //~ ERROR cannot take a mutable slice of a value with type `Foo`\n+    x[mut ..Foo]; //~ ERROR cannot take a mutable slice of a value with type `Foo`\n+    x[mut Foo..Foo]; //~ ERROR cannot take a mutable slice of a value with type `Foo`\n+}"}, {"sha": "3d12511134fa003d869babf982460a1a79ff9ea3", "filename": "src/test/compile-fail/slice-borrow.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fslice-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fslice-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-borrow.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test slicing expressions doesn't defeat the borrow checker.\n+\n+fn main() {\n+    let y;\n+    {\n+        let x: &[int] = &[1, 2, 3, 4, 5]; //~ ERROR borrowed value does not live long enough\n+        y = x[1..];\n+    }\n+}"}, {"sha": "1176b637cece091337be1faa8eceef0644442c63", "filename": "src/test/compile-fail/slice-mut-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test mutability and slicing syntax.\n+\n+fn main() {\n+    let x: &[int] = &[1, 2, 3, 4, 5];\n+    // Can't mutably slice an immutable slice\n+    let y = x[mut 2..4]; //~ ERROR cannot take a mutable slice of a value with type `&[int]`\n+}"}, {"sha": "8cd7c4ed0bb077d4808c382fa5c3df76807fe454", "filename": "src/test/compile-fail/slice-mut.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test mutability and slicing syntax.\n+\n+fn main() {\n+    let x: &[int] = &[1, 2, 3, 4, 5];\n+    // Immutable slices are not mutable.\n+    let y: &mut[_] = x[2..4]; //~ ERROR cannot borrow immutable dereference of `&`-pointer as mutabl\n+\n+    let x: &mut [int] = &mut [1, 2, 3, 4, 5];\n+    // Can't borrow mutably twice\n+    let y = x[mut 1..2];\n+    let y = x[mut 4..5]; //~ERROR cannot borrow\n+}"}, {"sha": "f51160a1b233d3bc86d11fdf5d3861d7d0a3a2f0", "filename": "src/test/compile-fail/unboxed-closure-sugar-nonexistent-trait.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn f<F:Nonexist(int) -> int>(x: F) {} //~ ERROR unresolved trait\n+\n+type Typedef = int;\n+\n+fn g<F:Typedef(int) -> int>(x: F) {} //~ ERROR `Typedef` is not a trait\n+\n+fn main() {}\n+"}, {"sha": "a751ae1c518ea9bee7a19a0db18f090199728d62", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-trait.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Trait {}\n+\n+fn f<F:Trait(int) -> int>(x: F) {}\n+//~^ ERROR unboxed function trait must be one of `Fn`, `FnMut`, or `FnOnce`\n+\n+fn main() {}\n+"}, {"sha": "97ad64a77baf44cb18c2d556fe648a2febdbf3c5", "filename": "src/test/compile-fail/unboxed-closures-wrong-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(lang_items, overloaded_calls, unboxed_closures)]\n \n-fn c<F:|: int, int| -> int>(f: F) -> int {\n+fn c<F:FnOnce(int, int) -> int>(f: F) -> int {\n     f(5, 6)\n }\n "}, {"sha": "29a3b965251ec36422a2bc5c487152523e586f57", "filename": "src/test/pretty/tag-blank-lines.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fpretty%2Ftag-blank-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Fpretty%2Ftag-blank-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Ftag-blank-lines.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -11,8 +11,8 @@\n // pp-exact\n \n enum foo {\n-    foo, // a foo.\n-    bar,\n+    bar, // a bar.\n+    baz,\n }\n \n fn main() { }"}, {"sha": "9a5a8e7c38f81be52786510ddccca6455c495693", "filename": "src/test/run-fail/issue-2444.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-fail%2Fissue-2444.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-fail%2Fissue-2444.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-2444.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -12,7 +12,7 @@\n \n use std::sync::Arc;\n \n-enum e<T> { e(Arc<T>) }\n+enum e<T> { ee(Arc<T>) }\n \n fn foo() -> e<int> {fail!();}\n "}, {"sha": "c5cfabd74e1341d420c656bca922c0f2fbfde1f0", "filename": "src/test/run-pass-fulldeps/issue_16723_multiple_items_syntax_ext.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass-fulldeps%2Fissue_16723_multiple_items_syntax_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass-fulldeps%2Fissue_16723_multiple_items_syntax_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue_16723_multiple_items_syntax_ext.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-stage1\n+// ignore-android\n+// aux-build:issue_16723_multiple_items_syntax_ext.rs\n+#![feature(phase)]\n+\n+#[phase(plugin)] extern crate issue_16723_multiple_items_syntax_ext;\n+\n+multiple_items!()\n+\n+impl Struct1 {\n+    fn foo() {}\n+}\n+impl Struct2 {\n+    fn foo() {}\n+}\n+\n+fn main() {\n+    Struct1::foo();\n+    Struct2::foo();\n+    println!(\"hallo\");\n+}"}, {"sha": "252d297d12d3053d44f3be816057c9d146d0e928", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -41,7 +41,7 @@ impl fake_ext_ctxt for fake_session {\n         codemap::span {\n             lo: codemap::BytePos(0),\n             hi: codemap::BytePos(0),\n-            expn_info: None\n+            expn_id: codemap::NO_EXPANSION\n         }\n     }\n     fn ident_of(st: &str) -> ast::ident {"}, {"sha": "8192566da19656c5c22f59232fc1bf646efbcc1a", "filename": "src/test/run-pass/borrowck-univariant-enum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -13,7 +13,7 @@ use std::cell::Cell;\n use std::gc::GC;\n \n enum newtype {\n-    newtype(int)\n+    newvar(int)\n }\n \n pub fn main() {\n@@ -22,9 +22,9 @@ pub fn main() {\n     // specially.\n \n     let x = box(GC) Cell::new(5);\n-    let y = box(GC) Cell::new(newtype(3));\n+    let y = box(GC) Cell::new(newvar(3));\n     let z = match y.get() {\n-      newtype(b) => {\n+      newvar(b) => {\n         x.set(x.get() + 1);\n         x.get() * b\n       }"}, {"sha": "44a3517cc758aab551c9f82259cf64b8cccb23e2", "filename": "src/test/run-pass/coerce-to-closure-and-proc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fcoerce-to-closure-and-proc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fcoerce-to-closure-and-proc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-to-closure-and-proc.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -17,7 +17,7 @@ struct Foo<T>(T);\n \n #[deriving(PartialEq, Show)]\n enum Bar<T> {\n-    Bar(T)\n+    Baz(T)\n }\n \n pub fn main() {\n@@ -33,11 +33,11 @@ pub fn main() {\n     let f: proc(int) -> Foo<int> = Foo;\n     assert_eq!(f(5), Foo(5));\n \n-    let f: |int| -> Bar<int> = Bar;\n-    assert_eq!(f(5), Bar(5));\n+    let f: |int| -> Bar<int> = Baz;\n+    assert_eq!(f(5), Baz(5));\n \n-    let f: proc(int) -> Bar<int> = Bar;\n-    assert_eq!(f(5), Bar(5));\n+    let f: proc(int) -> Bar<int> = Baz;\n+    assert_eq!(f(5), Baz(5));\n \n     let f: |int| -> Option<int> = Some;\n     assert_eq!(f(5), Some(5));"}, {"sha": "b0947f46a86ae9b6ef6842b0c03792aa352b0a3f", "filename": "src/test/run-pass/fn-trait-sugar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Ffn-trait-sugar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Ffn-trait-sugar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-trait-sugar.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -21,7 +21,7 @@ impl FnMut<(int,),int> for S {\n     }\n }\n \n-fn call_it<F:|int|->int>(mut f: F, x: int) -> int {\n+fn call_it<F:FnMut(int)->int>(mut f: F, x: int) -> int {\n     f.call_mut((x,)) + 3\n }\n "}, {"sha": "b160fa34c91b6a6a790882c4c37b2f096ef4baaa", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -22,7 +22,7 @@ enum object {\n     int_value(i64),\n }\n \n-fn lookup(table: json::Object, key: String, default: String) -> String\n+fn lookup(table: json::JsonObject, key: String, default: String) -> String\n {\n     match table.find(&key.to_string()) {\n         option::Some(&json::String(ref s)) => {"}, {"sha": "75f6a2faa80552558cd9630a2061ed76782eddf4", "filename": "src/test/run-pass/issue-3874.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fissue-3874.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fissue-3874.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3874.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum PureCounter { PureCounter(uint) }\n+enum PureCounter { PureCounterVariant(uint) }\n \n fn each(thing: PureCounter, blk: |v: &uint|) {\n-    let PureCounter(ref x) = thing;\n+    let PureCounterVariant(ref x) = thing;\n     blk(x);\n }\n "}, {"sha": "6eb0a4dad1b6aa0928c7d6016604d3dbda154721", "filename": "src/test/run-pass/match-arm-statics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -88,10 +88,10 @@ fn issue_14576() {\n }\n \n fn issue_13731() {\n-    enum A { A(()) }\n-    static B: A = A(());\n+    enum A { AA(()) }\n+    static B: A = AA(());\n \n-    match A(()) {\n+    match AA(()) {\n         B => ()\n     }\n }"}, {"sha": "088756992453e2423b723ebfe8544b88244bb2d7", "filename": "src/test/run-pass/match-range-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fmatch-range-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fmatch-range-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-range-static.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -13,7 +13,7 @@ static e: int = 42;\n \n pub fn main() {\n     match 7 {\n-        s..e => (),\n+        s...e => (),\n         _ => (),\n     }\n }"}, {"sha": "51fd83a54ccb1e48553c4f1ca693a6b6f3c982c9", "filename": "src/test/run-pass/sepcomp-lib-lto.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fsepcomp-lib-lto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fsepcomp-lib-lto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsepcomp-lib-lto.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Make sure we give a sane error message when the user requests LTO with a\n-// library built with -C codegen-units > 1.\n+// Check that we can use `-Z lto` when linking against libraries that were\n+// separately compiled.\n \n // aux-build:sepcomp_lib.rs\n // compile-flags: -Z lto\n-// error-pattern:missing compressed bytecode\n // no-prefer-dynamic\n \n extern crate sepcomp_lib;", "previous_filename": "src/test/compile-fail/sepcomp-lib-lto.rs"}, {"sha": "3c0933a055cba7e788d85cadfecbb85327f43da4", "filename": "src/test/run-pass/slice-2.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fslice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fslice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-2.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test slicing expressions on slices and Vecs.\n+\n+fn main() {\n+    let x: &[int] = &[1, 2, 3, 4, 5];\n+    let cmp: &[int] = &[1, 2, 3, 4, 5];\n+    assert!(x[] == cmp)\n+    let cmp: &[int] = &[3, 4, 5];\n+    assert!(x[2..] == cmp)\n+    let cmp: &[int] = &[1, 2, 3];\n+    assert!(x[..3] == cmp)\n+    let cmp: &[int] = &[2, 3, 4];\n+    assert!(x[1..4] == cmp)\n+\n+    let x: Vec<int> = vec![1, 2, 3, 4, 5];\n+    let cmp: &[int] = &[1, 2, 3, 4, 5];\n+    assert!(x[] == cmp)\n+    let cmp: &[int] = &[3, 4, 5];\n+    assert!(x[2..] == cmp)\n+    let cmp: &[int] = &[1, 2, 3];\n+    assert!(x[..3] == cmp)\n+    let cmp: &[int] = &[2, 3, 4];\n+    assert!(x[1..4] == cmp)\n+\n+    let x: &mut [int] = &mut [1, 2, 3, 4, 5];\n+    {\n+        let cmp: &mut [int] = &mut [1, 2, 3, 4, 5];\n+        assert!(x[mut] == cmp)\n+    }\n+    {\n+        let cmp: &mut [int] = &mut [3, 4, 5];\n+        assert!(x[mut 2..] == cmp)\n+    }\n+    {\n+        let cmp: &mut [int] = &mut [1, 2, 3];\n+        assert!(x[mut ..3] == cmp)\n+    }\n+    {\n+        let cmp: &mut [int] = &mut [2, 3, 4];\n+        assert!(x[mut 1..4] == cmp)\n+    }\n+\n+    let mut x: Vec<int> = vec![1, 2, 3, 4, 5];\n+    {\n+        let cmp: &mut [int] = &mut [1, 2, 3, 4, 5];\n+        assert!(x[mut] == cmp)\n+    }\n+    {\n+        let cmp: &mut [int] = &mut [3, 4, 5];\n+        assert!(x[mut 2..] == cmp)\n+    }\n+    {\n+        let cmp: &mut [int] = &mut [1, 2, 3];\n+        assert!(x[mut ..3] == cmp)\n+    }\n+    {\n+        let cmp: &mut [int] = &mut [2, 3, 4];\n+        assert!(x[mut 1..4] == cmp)\n+    }\n+}"}, {"sha": "f6972023a72a5830653b58c5adf5d429951fce83", "filename": "src/test/run-pass/slice-fail-1.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fslice-fail-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fslice-fail-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-fail-1.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that is a slicing expr[..] fails, the correct cleanups happen.\n+\n+use std::task;\n+\n+struct Foo;\n+\n+static mut DTOR_COUNT: int = 0;\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) { unsafe { DTOR_COUNT += 1; } }\n+}\n+\n+fn foo() {\n+    let x: &[_] = &[Foo, Foo];\n+    x[3..4];\n+}\n+\n+fn main() {\n+    let _ = task::try(proc() foo());\n+    unsafe { assert!(DTOR_COUNT == 2); }\n+}"}, {"sha": "cbe65fcd83d2dcaa1c44c4fd487e5b5e52049e11", "filename": "src/test/run-pass/slice-fail-2.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fslice-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fslice-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-fail-2.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that is a slicing expr[..] fails, the correct cleanups happen.\n+\n+use std::task;\n+\n+struct Foo;\n+\n+static mut DTOR_COUNT: int = 0;\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) { unsafe { DTOR_COUNT += 1; } }\n+}\n+\n+fn bar() -> uint {\n+    fail!();\n+}\n+\n+fn foo() {\n+    let x: &[_] = &[Foo, Foo];\n+    x[3..bar()];\n+}\n+\n+fn main() {\n+    let _ = task::try(proc() foo());\n+    unsafe { assert!(DTOR_COUNT == 2); }\n+}"}, {"sha": "39feb075add55ff87fa3e46dd50a275c724a9c49", "filename": "src/test/run-pass/slice.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test slicing sugar.\n+\n+extern crate core;\n+use core::ops::{Slice,SliceMut};\n+\n+static mut COUNT: uint = 0;\n+\n+struct Foo;\n+\n+impl Slice<Foo, Foo> for Foo {\n+    fn as_slice_<'a>(&'a self) -> &'a Foo {\n+        unsafe { COUNT += 1; }\n+        self\n+    }\n+    fn slice_from_<'a>(&'a self, _from: &Foo) -> &'a Foo {\n+        unsafe { COUNT += 1; }\n+        self\n+    }\n+    fn slice_to_<'a>(&'a self, _to: &Foo) -> &'a Foo {\n+        unsafe { COUNT += 1; }\n+        self\n+    }\n+    fn slice_<'a>(&'a self, _from: &Foo, _to: &Foo) -> &'a Foo {\n+        unsafe { COUNT += 1; }\n+        self\n+    }\n+}\n+\n+impl SliceMut<Foo, Foo> for Foo {\n+    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Foo {\n+        unsafe { COUNT += 1; }\n+        self\n+    }\n+    fn slice_from_mut_<'a>(&'a mut self, _from: &Foo) -> &'a mut Foo {\n+        unsafe { COUNT += 1; }\n+        self\n+    }\n+    fn slice_to_mut_<'a>(&'a mut self, _to: &Foo) -> &'a mut Foo {\n+        unsafe { COUNT += 1; }\n+        self\n+    }\n+    fn slice_mut_<'a>(&'a mut self, _from: &Foo, _to: &Foo) -> &'a mut Foo {\n+        unsafe { COUNT += 1; }\n+        self\n+    }\n+}\n+fn main() {\n+    let mut x = Foo;\n+    x[];\n+    x[Foo..];\n+    x[..Foo];\n+    x[Foo..Foo];\n+    x[mut];\n+    x[mut Foo..];\n+    x[mut ..Foo];\n+    x[mut Foo..Foo];\n+    unsafe {\n+        assert!(COUNT == 8);\n+    }\n+}"}, {"sha": "d6a154edd789be3f884abad29d9764e44469dd75", "filename": "src/test/run-pass/tag-align-dyn-u64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Ftag-align-dyn-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Ftag-align-dyn-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-align-dyn-u64.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -14,7 +14,7 @@\n use std::mem;\n \n enum Tag<A> {\n-    Tag(A)\n+    Tag2(A)\n }\n \n struct Rec {\n@@ -23,7 +23,7 @@ struct Rec {\n }\n \n fn mk_rec() -> Rec {\n-    return Rec { c8:0u8, t:Tag(0u64) };\n+    return Rec { c8:0u8, t:Tag2(0u64) };\n }\n \n fn is_8_byte_aligned(u: &Tag<u64>) -> bool {"}, {"sha": "e032a5e4156c36240b84364b30ee04c6f970557c", "filename": "src/test/run-pass/tag-align-shape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Ftag-align-shape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Ftag-align-shape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-align-shape.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -11,7 +11,7 @@\n extern crate debug;\n \n enum a_tag {\n-    a_tag(u64)\n+    a_tag_var(u64)\n }\n \n struct t_rec {\n@@ -20,8 +20,8 @@ struct t_rec {\n }\n \n pub fn main() {\n-    let x = t_rec {c8: 22u8, t: a_tag(44u64)};\n+    let x = t_rec {c8: 22u8, t: a_tag_var(44u64)};\n     let y = format!(\"{:?}\", x);\n     println!(\"y = {}\", y);\n-    assert_eq!(y, \"t_rec{c8: 22u8, t: a_tag(44u64)}\".to_string());\n+    assert_eq!(y, \"t_rec{c8: 22u8, t: a_tag_var(44u64)}\".to_string());\n }"}, {"sha": "398a0939d97d7ce9827df24cf36f787fe8ed3700", "filename": "src/test/run-pass/tag-align-u64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Ftag-align-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Ftag-align-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-align-u64.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -14,7 +14,7 @@\n use std::mem;\n \n enum Tag {\n-    Tag(u64)\n+    TagInner(u64)\n }\n \n struct Rec {\n@@ -23,7 +23,7 @@ struct Rec {\n }\n \n fn mk_rec() -> Rec {\n-    return Rec { c8:0u8, t:Tag(0u64) };\n+    return Rec { c8:0u8, t:TagInner(0u64) };\n }\n \n fn is_8_byte_aligned(u: &Tag) -> bool {"}, {"sha": "d91204951551a3577649e7a164f3a74a1bd38e6f", "filename": "src/test/run-pass/unboxed-closures-all-traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Funboxed-closures-all-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Funboxed-closures-all-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-all-traits.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -10,15 +10,15 @@\n \n #![feature(lang_items, overloaded_calls, unboxed_closures)]\n \n-fn a<F:|&: int, int| -> int>(f: F) -> int {\n+fn a<F:Fn(int, int) -> int>(f: F) -> int {\n     f(1, 2)\n }\n \n-fn b<F:|&mut: int, int| -> int>(mut f: F) -> int {\n+fn b<F:FnMut(int, int) -> int>(mut f: F) -> int {\n     f(3, 4)\n }\n \n-fn c<F:|: int, int| -> int>(f: F) -> int {\n+fn c<F:FnOnce(int, int) -> int>(f: F) -> int {\n     f(5, 6)\n }\n "}, {"sha": "a455e4d2032630f21de4cfe5ef7ab80a52db474c", "filename": "src/test/run-pass/unboxed-closures-drop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Funboxed-closures-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Funboxed-closures-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-drop.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -41,15 +41,15 @@ impl Drop for Droppable {\n     }\n }\n \n-fn a<F:|&: int, int| -> int>(f: F) -> int {\n+fn a<F:Fn(int, int) -> int>(f: F) -> int {\n     f(1, 2)\n }\n \n-fn b<F:|&mut: int, int| -> int>(mut f: F) -> int {\n+fn b<F:FnMut(int, int) -> int>(mut f: F) -> int {\n     f(3, 4)\n }\n \n-fn c<F:|: int, int| -> int>(f: F) -> int {\n+fn c<F:FnOnce(int, int) -> int>(f: F) -> int {\n     f(5, 6)\n }\n "}, {"sha": "aef6956118ecb7b39b1bc5fcf0aa79426df631e4", "filename": "src/test/run-pass/unboxed-closures-single-word-env.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Funboxed-closures-single-word-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Funboxed-closures-single-word-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-single-word-env.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -13,15 +13,15 @@\n \n #![feature(overloaded_calls, unboxed_closures)]\n \n-fn a<F:|&: int, int| -> int>(f: F) -> int {\n+fn a<F:Fn(int, int) -> int>(f: F) -> int {\n     f(1, 2)\n }\n \n-fn b<F:|&mut: int, int| -> int>(mut f: F) -> int {\n+fn b<F:FnMut(int, int) -> int>(mut f: F) -> int {\n     f(3, 4)\n }\n \n-fn c<F:|: int, int| -> int>(f: F) -> int {\n+fn c<F:FnOnce(int, int) -> int>(f: F) -> int {\n     f(5, 6)\n }\n "}, {"sha": "f35daa65a43900fcd5202ae665674f07ee72c927", "filename": "src/test/run-pass/unboxed-closures-unique-type-id.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -21,8 +21,7 @@\n \n use std::ptr;\n \n-pub fn replace_map<'a, T, F>(src: &mut T, prod: F)\n-where F: |: T| -> T {\n+pub fn replace_map<'a, T, F>(src: &mut T, prod: F) where F: FnOnce(T) -> T {\n     unsafe { *src = prod(ptr::read(src as *mut T as *const T)); }\n }\n "}, {"sha": "808e937bc72e3d1c0ad46a6b3a773d4ac50535fe", "filename": "src/test/run-pass/where-clauses-unboxed-closures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fwhere-clauses-unboxed-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fwhere-clauses-unboxed-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhere-clauses-unboxed-closures.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -13,7 +13,7 @@\n struct Bencher;\n \n // ICE\n-fn warm_up<'a, F>(f: F) where F: |&: &'a mut Bencher| {\n+fn warm_up<'a, F>(f: F) where F: Fn(&'a mut Bencher) {\n }\n \n fn main() {"}, {"sha": "9ba4b707268a07b756f98cd6d539616ed997b423", "filename": "src/test/run-pass/xcrate-unit-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fxcrate-unit-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef6c4b1382dcf2f943bd5872656625f935c0b7c/src%2Ftest%2Frun-pass%2Fxcrate-unit-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fxcrate-unit-struct.rs?ref=aef6c4b1382dcf2f943bd5872656625f935c0b7c", "patch": "@@ -12,7 +12,7 @@\n extern crate xcrate_unit_struct;\n \n static s1: xcrate_unit_struct::Struct = xcrate_unit_struct::Struct;\n-static s2: xcrate_unit_struct::Unit = xcrate_unit_struct::Unit;\n+static s2: xcrate_unit_struct::Unit = xcrate_unit_struct::UnitVariant;\n static s3: xcrate_unit_struct::Unit =\n                 xcrate_unit_struct::Argument(xcrate_unit_struct::Struct);\n static s4: xcrate_unit_struct::Unit = xcrate_unit_struct::Argument(s1);\n@@ -22,7 +22,7 @@ fn f2(_: xcrate_unit_struct::Unit) {}\n \n pub fn main() {\n     f1(xcrate_unit_struct::Struct);\n-    f2(xcrate_unit_struct::Unit);\n+    f2(xcrate_unit_struct::UnitVariant);\n     f2(xcrate_unit_struct::Argument(xcrate_unit_struct::Struct));\n \n     f1(s1);"}]}