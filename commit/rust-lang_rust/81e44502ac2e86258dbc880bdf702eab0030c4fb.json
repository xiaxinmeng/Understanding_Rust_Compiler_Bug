{"sha": "81e44502ac2e86258dbc880bdf702eab0030c4fb", "node_id": "C_kwDOAAsO6NoAKDgxZTQ0NTAyYWMyZTg2MjU4ZGJjODgwYmRmNzAyZWFiMDAzMGM0ZmI", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-03T16:14:24Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-03T16:14:24Z"}, "message": "Merge `CollapsibleMatch` into `Matches` lint pass", "tree": {"sha": "effea91c4f355668e9019c859c8f77b94a7d9464", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/effea91c4f355668e9019c859c8f77b94a7d9464"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81e44502ac2e86258dbc880bdf702eab0030c4fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81e44502ac2e86258dbc880bdf702eab0030c4fb", "html_url": "https://github.com/rust-lang/rust/commit/81e44502ac2e86258dbc880bdf702eab0030c4fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81e44502ac2e86258dbc880bdf702eab0030c4fb/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c0d649db2a538fd0c63c846ecaa671a277e23f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c0d649db2a538fd0c63c846ecaa671a277e23f5", "html_url": "https://github.com/rust-lang/rust/commit/7c0d649db2a538fd0c63c846ecaa671a277e23f5"}], "stats": {"total": 252, "additions": 139, "deletions": 113}, "files": [{"sha": "b1da36a0d4017c52ebd6b4a4cfdbd077ef4f05c2", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81e44502ac2e86258dbc880bdf702eab0030c4fb/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81e44502ac2e86258dbc880bdf702eab0030c4fb/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=81e44502ac2e86258dbc880bdf702eab0030c4fb", "patch": "@@ -38,7 +38,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(casts::UNNECESSARY_CAST),\n     LintId::of(collapsible_if::COLLAPSIBLE_ELSE_IF),\n     LintId::of(collapsible_if::COLLAPSIBLE_IF),\n-    LintId::of(collapsible_match::COLLAPSIBLE_MATCH),\n     LintId::of(comparison_chain::COMPARISON_CHAIN),\n     LintId::of(copies::IFS_SAME_COND),\n     LintId::of(copies::IF_SAME_THEN_ELSE),\n@@ -143,6 +142,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(map_unit_fn::RESULT_MAP_UNIT_FN),\n     LintId::of(match_result_ok::MATCH_RESULT_OK),\n     LintId::of(match_str_case_mismatch::MATCH_STR_CASE_MISMATCH),\n+    LintId::of(matches::COLLAPSIBLE_MATCH),\n     LintId::of(matches::INFALLIBLE_DESTRUCTURING_MATCH),\n     LintId::of(matches::MATCH_AS_REF),\n     LintId::of(matches::MATCH_LIKE_MATCHES_MACRO),"}, {"sha": "58e18b710ea8816f5edb775a05049a66ac73b5d5", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81e44502ac2e86258dbc880bdf702eab0030c4fb/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81e44502ac2e86258dbc880bdf702eab0030c4fb/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=81e44502ac2e86258dbc880bdf702eab0030c4fb", "patch": "@@ -93,7 +93,6 @@ store.register_lints(&[\n     cognitive_complexity::COGNITIVE_COMPLEXITY,\n     collapsible_if::COLLAPSIBLE_ELSE_IF,\n     collapsible_if::COLLAPSIBLE_IF,\n-    collapsible_match::COLLAPSIBLE_MATCH,\n     comparison_chain::COMPARISON_CHAIN,\n     copies::BRANCHES_SHARING_CODE,\n     copies::IFS_SAME_COND,\n@@ -263,6 +262,7 @@ store.register_lints(&[\n     match_on_vec_items::MATCH_ON_VEC_ITEMS,\n     match_result_ok::MATCH_RESULT_OK,\n     match_str_case_mismatch::MATCH_STR_CASE_MISMATCH,\n+    matches::COLLAPSIBLE_MATCH,\n     matches::INFALLIBLE_DESTRUCTURING_MATCH,\n     matches::MATCH_AS_REF,\n     matches::MATCH_BOOL,"}, {"sha": "07e90b8b656e5029ba5340a83bd908885cf2993b", "filename": "clippy_lints/src/lib.register_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81e44502ac2e86258dbc880bdf702eab0030c4fb/clippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81e44502ac2e86258dbc880bdf702eab0030c4fb/clippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_style.rs?ref=81e44502ac2e86258dbc880bdf702eab0030c4fb", "patch": "@@ -12,7 +12,6 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(casts::FN_TO_NUMERIC_CAST_WITH_TRUNCATION),\n     LintId::of(collapsible_if::COLLAPSIBLE_ELSE_IF),\n     LintId::of(collapsible_if::COLLAPSIBLE_IF),\n-    LintId::of(collapsible_match::COLLAPSIBLE_MATCH),\n     LintId::of(comparison_chain::COMPARISON_CHAIN),\n     LintId::of(default::FIELD_REASSIGN_WITH_DEFAULT),\n     LintId::of(dereference::NEEDLESS_BORROW),\n@@ -50,6 +49,7 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n     LintId::of(map_clone::MAP_CLONE),\n     LintId::of(match_result_ok::MATCH_RESULT_OK),\n+    LintId::of(matches::COLLAPSIBLE_MATCH),\n     LintId::of(matches::INFALLIBLE_DESTRUCTURING_MATCH),\n     LintId::of(matches::MATCH_LIKE_MATCHES_MACRO),\n     LintId::of(matches::MATCH_OVERLAPPING_ARM),"}, {"sha": "6e16d470ac878505f3786ca530cf910ec6c3654b", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81e44502ac2e86258dbc880bdf702eab0030c4fb/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81e44502ac2e86258dbc880bdf702eab0030c4fb/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=81e44502ac2e86258dbc880bdf702eab0030c4fb", "patch": "@@ -192,7 +192,6 @@ mod casts;\n mod checked_conversions;\n mod cognitive_complexity;\n mod collapsible_if;\n-mod collapsible_match;\n mod comparison_chain;\n mod copies;\n mod copy_iterator;\n@@ -568,7 +567,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(len_zero::LenZero));\n     store.register_late_pass(|| Box::new(attrs::Attributes));\n     store.register_late_pass(|| Box::new(blocks_in_if_conditions::BlocksInIfConditions));\n-    store.register_late_pass(|| Box::new(collapsible_match::CollapsibleMatch));\n     store.register_late_pass(|| Box::new(unicode::Unicode));\n     store.register_late_pass(|| Box::new(uninit_vec::UninitVec));\n     store.register_late_pass(|| Box::new(unit_hash::UnitHash));"}, {"sha": "07021f1bcad8db24b6f625a618a2c03d24477392", "filename": "clippy_lints/src/matches/collapsible_match.rs", "status": "renamed", "additions": 15, "deletions": 55, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/81e44502ac2e86258dbc880bdf702eab0030c4fb/clippy_lints%2Fsrc%2Fmatches%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81e44502ac2e86258dbc880bdf702eab0030c4fb/clippy_lints%2Fsrc%2Fmatches%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fcollapsible_match.rs?ref=81e44502ac2e86258dbc880bdf702eab0030c4fb", "patch": "@@ -6,68 +6,28 @@ use if_chain::if_chain;\n use rustc_errors::MultiSpan;\n use rustc_hir::LangItem::OptionNone;\n use rustc_hir::{Arm, Expr, Guard, HirId, Let, Pat, PatKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_lint::LateContext;\n use rustc_span::Span;\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Finds nested `match` or `if let` expressions where the patterns may be \"collapsed\" together\n-    /// without adding any branches.\n-    ///\n-    /// Note that this lint is not intended to find _all_ cases where nested match patterns can be merged, but only\n-    /// cases where merging would most likely make the code more readable.\n-    ///\n-    /// ### Why is this bad?\n-    /// It is unnecessarily verbose and complex.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// fn func(opt: Option<Result<u64, String>>) {\n-    ///     let n = match opt {\n-    ///         Some(n) => match n {\n-    ///             Ok(n) => n,\n-    ///             _ => return,\n-    ///         }\n-    ///         None => return,\n-    ///     };\n-    /// }\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// fn func(opt: Option<Result<u64, String>>) {\n-    ///     let n = match opt {\n-    ///         Some(Ok(n)) => n,\n-    ///         _ => return,\n-    ///     };\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.50.0\"]\n-    pub COLLAPSIBLE_MATCH,\n-    style,\n-    \"Nested `match` or `if let` expressions where the patterns may be \\\"collapsed\\\" together.\"\n-}\n-\n-declare_lint_pass!(CollapsibleMatch => [COLLAPSIBLE_MATCH]);\n+use super::COLLAPSIBLE_MATCH;\n \n-impl<'tcx> LateLintPass<'tcx> for CollapsibleMatch {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n-        match IfLetOrMatch::parse(cx, expr) {\n-            Some(IfLetOrMatch::Match(_, arms, _)) => {\n-                if let Some(els_arm) = arms.iter().rfind(|arm| arm_is_wild_like(cx, arm)) {\n-                    for arm in arms {\n-                        check_arm(cx, true, arm.pat, arm.body, arm.guard.as_ref(), Some(els_arm.body));\n-                    }\n-                }\n-            },\n-            Some(IfLetOrMatch::IfLet(_, pat, body, els)) => {\n-                check_arm(cx, false, pat, body, None, els);\n-            },\n-            None => {},\n+pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n+    if let Some(els_arm) = arms.iter().rfind(|arm| arm_is_wild_like(cx, arm)) {\n+        for arm in arms {\n+            check_arm(cx, true, arm.pat, arm.body, arm.guard.as_ref(), Some(els_arm.body));\n         }\n     }\n }\n \n+pub(super) fn check_if_let<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    body: &'tcx Expr<'_>,\n+    else_expr: Option<&'tcx Expr<'_>>,\n+) {\n+    check_arm(cx, false, pat, body, None, else_expr);\n+}\n+\n fn check_arm<'tcx>(\n     cx: &LateContext<'tcx>,\n     outer_is_match: bool,", "previous_filename": "clippy_lints/src/collapsible_match.rs"}, {"sha": "a68eec842abc51a08418e793c9b670e93e5b45a6", "filename": "clippy_lints/src/matches/match_like_matches.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/81e44502ac2e86258dbc880bdf702eab0030c4fb/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81e44502ac2e86258dbc880bdf702eab0030c4fb/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs?ref=81e44502ac2e86258dbc880bdf702eab0030c4fb", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_wild;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{higher, is_wild};\n use rustc_ast::{Attribute, LitKind};\n use rustc_errors::Applicability;\n use rustc_hir::{Arm, BorrowKind, Expr, ExprKind, Guard, Pat};\n@@ -11,22 +11,24 @@ use rustc_span::source_map::Spanned;\n use super::MATCH_LIKE_MATCHES_MACRO;\n \n /// Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`\n-pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-    if let Some(higher::IfLet {\n-        let_pat,\n+pub(crate) fn check_if_let<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    let_pat: &'tcx Pat<'_>,\n+    let_expr: &'tcx Expr<'_>,\n+    then_expr: &'tcx Expr<'_>,\n+    else_expr: &'tcx Expr<'_>,\n+) {\n+    find_matches_sugg(\n+        cx,\n         let_expr,\n-        if_then,\n-        if_else: Some(if_else),\n-    }) = higher::IfLet::hir(cx, expr)\n-    {\n-        find_matches_sugg(\n-            cx,\n-            let_expr,\n-            IntoIterator::into_iter([(&[][..], Some(let_pat), if_then, None), (&[][..], None, if_else, None)]),\n-            expr,\n-            true,\n-        );\n-    }\n+        IntoIterator::into_iter([\n+            (&[][..], Some(let_pat), then_expr, None),\n+            (&[][..], None, else_expr, None),\n+        ]),\n+        expr,\n+        true,\n+    );\n }\n \n pub(super) fn check_match<'tcx>("}, {"sha": "4a77fb8c31bbd952325f29eb6a457b8d0d295ed2", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 78, "deletions": 12, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/81e44502ac2e86258dbc880bdf702eab0030c4fb/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81e44502ac2e86258dbc880bdf702eab0030c4fb/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=81e44502ac2e86258dbc880bdf702eab0030c4fb", "patch": "@@ -1,12 +1,14 @@\n use clippy_utils::source::{snippet_opt, span_starts_with, walk_span_to_context};\n-use clippy_utils::{meets_msrv, msrvs};\n+use clippy_utils::{higher, meets_msrv, msrvs};\n use rustc_hir::{Arm, Expr, ExprKind, Local, MatchSource, Pat};\n use rustc_lexer::{tokenize, TokenKind};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{Span, SpanData, SyntaxContext};\n \n+mod collapsible_match;\n mod infallible_destructuring_match;\n mod match_as_ref;\n mod match_bool;\n@@ -610,6 +612,44 @@ declare_clippy_lint! {\n     \"`match` or match-like `if let` that are unnecessary\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Finds nested `match` or `if let` expressions where the patterns may be \"collapsed\" together\n+    /// without adding any branches.\n+    ///\n+    /// Note that this lint is not intended to find _all_ cases where nested match patterns can be merged, but only\n+    /// cases where merging would most likely make the code more readable.\n+    ///\n+    /// ### Why is this bad?\n+    /// It is unnecessarily verbose and complex.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// fn func(opt: Option<Result<u64, String>>) {\n+    ///     let n = match opt {\n+    ///         Some(n) => match n {\n+    ///             Ok(n) => n,\n+    ///             _ => return,\n+    ///         }\n+    ///         None => return,\n+    ///     };\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn func(opt: Option<Result<u64, String>>) {\n+    ///     let n = match opt {\n+    ///         Some(Ok(n)) => n,\n+    ///         _ => return,\n+    ///     };\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.50.0\"]\n+    pub COLLAPSIBLE_MATCH,\n+    style,\n+    \"Nested `match` or `if let` expressions where the patterns may be \\\"collapsed\\\" together.\"\n+}\n+\n #[derive(Default)]\n pub struct Matches {\n     msrv: Option<RustcVersion>,\n@@ -644,19 +684,29 @@ impl_lint_pass!(Matches => [\n     MATCH_LIKE_MATCHES_MACRO,\n     MATCH_SAME_ARMS,\n     NEEDLESS_MATCH,\n+    COLLAPSIBLE_MATCH,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Matches {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if expr.span.from_expansion() {\n+        if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n+        let from_expansion = expr.span.from_expansion();\n \n         if let ExprKind::Match(ex, arms, source) = expr.kind {\n             if !span_starts_with(cx, expr.span, \"match\") {\n                 return;\n             }\n-            if !contains_cfg_arm(cx, expr, ex, arms) {\n+\n+            collapsible_match::check_match(cx, arms);\n+            if !from_expansion {\n+                // These don't depend on a relationship between multiple arms\n+                match_wild_err_arm::check(cx, ex, arms);\n+                wild_in_or_pats::check(cx, arms);\n+            }\n+\n+            if !from_expansion && !contains_cfg_arm(cx, expr, ex, arms) {\n                 if source == MatchSource::Normal {\n                     if !(meets_msrv(self.msrv, msrvs::MATCHES_MACRO)\n                         && match_like_matches::check_match(cx, expr, ex, arms))\n@@ -680,16 +730,32 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                 }\n                 match_ref_pats::check(cx, ex, arms.iter().map(|el| el.pat), expr);\n             }\n-\n-            // These don't depend on a relationship between multiple arms\n-            match_wild_err_arm::check(cx, ex, arms);\n-            wild_in_or_pats::check(cx, arms);\n-        } else {\n-            if meets_msrv(self.msrv, msrvs::MATCHES_MACRO) {\n-                match_like_matches::check(cx, expr);\n+        } else if let Some(if_let) = higher::IfLet::hir(cx, expr) {\n+            collapsible_match::check_if_let(cx, if_let.let_pat, if_let.if_then, if_let.if_else);\n+            if !from_expansion {\n+                if let Some(else_expr) = if_let.if_else {\n+                    if meets_msrv(self.msrv, msrvs::MATCHES_MACRO) {\n+                        match_like_matches::check_if_let(\n+                            cx,\n+                            expr,\n+                            if_let.let_pat,\n+                            if_let.let_expr,\n+                            if_let.if_then,\n+                            else_expr,\n+                        );\n+                    }\n+                }\n+                redundant_pattern_match::check_if_let(\n+                    cx,\n+                    expr,\n+                    if_let.let_pat,\n+                    if_let.let_expr,\n+                    if_let.if_else.is_some(),\n+                );\n+                needless_match::check_if_let(cx, expr, &if_let);\n             }\n+        } else if !from_expansion {\n             redundant_pattern_match::check(cx, expr);\n-            needless_match::check(cx, expr);\n         }\n     }\n "}, {"sha": "fa19cddd35ec7afff4258f68eb901967e01b411b", "filename": "clippy_lints/src/matches/needless_match.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/81e44502ac2e86258dbc880bdf702eab0030c4fb/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81e44502ac2e86258dbc880bdf702eab0030c4fb/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs?ref=81e44502ac2e86258dbc880bdf702eab0030c4fb", "patch": "@@ -47,20 +47,18 @@ pub(crate) fn check_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>],\n ///     some_enum\n /// }\n /// ```\n-pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>) {\n-    if let Some(ref if_let) = higher::IfLet::hir(cx, ex) {\n-        if !is_else_clause(cx.tcx, ex) && expr_ty_matches_p_ty(cx, if_let.let_expr, ex) && check_if_let(cx, if_let) {\n-            let mut applicability = Applicability::MachineApplicable;\n-            span_lint_and_sugg(\n-                cx,\n-                NEEDLESS_MATCH,\n-                ex.span,\n-                \"this if-let expression is unnecessary\",\n-                \"replace it with\",\n-                snippet_with_applicability(cx, if_let.let_expr.span, \"..\", &mut applicability).to_string(),\n-                applicability,\n-            );\n-        }\n+pub(crate) fn check_if_let<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'_>, if_let: &higher::IfLet<'tcx>) {\n+    if !is_else_clause(cx.tcx, ex) && expr_ty_matches_p_ty(cx, if_let.let_expr, ex) && check_if_let_inner(cx, if_let) {\n+        let mut applicability = Applicability::MachineApplicable;\n+        span_lint_and_sugg(\n+            cx,\n+            NEEDLESS_MATCH,\n+            ex.span,\n+            \"this if-let expression is unnecessary\",\n+            \"replace it with\",\n+            snippet_with_applicability(cx, if_let.let_expr.span, \"..\", &mut applicability).to_string(),\n+            applicability,\n+        );\n     }\n }\n \n@@ -77,15 +75,15 @@ fn check_all_arms(cx: &LateContext<'_>, match_expr: &Expr<'_>, arms: &[Arm<'_>])\n     true\n }\n \n-fn check_if_let(cx: &LateContext<'_>, if_let: &higher::IfLet<'_>) -> bool {\n+fn check_if_let_inner(cx: &LateContext<'_>, if_let: &higher::IfLet<'_>) -> bool {\n     if let Some(if_else) = if_let.if_else {\n         if !pat_same_as_expr(if_let.let_pat, peel_blocks_with_stmt(if_let.if_then)) {\n             return false;\n         }\n \n         // Recursively check for each `else if let` phrase,\n         if let Some(ref nested_if_let) = higher::IfLet::hir(cx, if_else) {\n-            return check_if_let(cx, nested_if_let);\n+            return check_if_let_inner(cx, nested_if_let);\n         }\n \n         if matches!(if_else.kind, ExprKind::Block(..)) {"}, {"sha": "095cd43ea13fb2f9bda22d36d3a7d9dc690fd8b9", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/81e44502ac2e86258dbc880bdf702eab0030c4fb/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81e44502ac2e86258dbc880bdf702eab0030c4fb/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=81e44502ac2e86258dbc880bdf702eab0030c4fb", "patch": "@@ -18,19 +18,21 @@ use rustc_middle::ty::{self, subst::GenericArgKind, DefIdTree, Ty};\n use rustc_span::sym;\n \n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-    if let Some(higher::IfLet {\n-        if_else,\n-        let_pat,\n-        let_expr,\n-        ..\n-    }) = higher::IfLet::hir(cx, expr)\n-    {\n-        find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"if\", if_else.is_some());\n-    } else if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n+    if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n         find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"while\", false);\n     }\n }\n \n+pub(super) fn check_if_let<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    pat: &'tcx Pat<'_>,\n+    scrutinee: &'tcx Expr<'_>,\n+    has_else: bool,\n+) {\n+    find_sugg_for_if_let(cx, expr, pat, scrutinee, \"if\", has_else);\n+}\n+\n // Extract the generic arguments out of a type\n fn try_get_generic_ty(ty: Ty<'_>, index: usize) -> Option<Ty<'_>> {\n     if_chain! {"}]}