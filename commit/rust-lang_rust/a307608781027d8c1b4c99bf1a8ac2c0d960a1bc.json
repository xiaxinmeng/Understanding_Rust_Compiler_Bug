{"sha": "a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzMDc2MDg3ODEwMjdkOGMxYjRjOTliZjFhOGFjMmMwZDk2MGExYmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-21T03:16:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-21T03:16:33Z"}, "message": "auto merge of #5066 : catamorphism/rust/luqmana-derecording, r=catamorphism\n\nMost work done by @luqmana and @pcwalton - I just rebased.", "tree": {"sha": "de21bbaee519beef168121273338c87ddff25684", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de21bbaee519beef168121273338c87ddff25684"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "html_url": "https://github.com/rust-lang/rust/commit/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b04be6858bdf7c3ab06a45b8e4049d1042a5a3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b04be6858bdf7c3ab06a45b8e4049d1042a5a3d", "html_url": "https://github.com/rust-lang/rust/commit/1b04be6858bdf7c3ab06a45b8e4049d1042a5a3d"}, {"sha": "ad9c54c631a39bbaf926021f18d683feba49fc09", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad9c54c631a39bbaf926021f18d683feba49fc09", "html_url": "https://github.com/rust-lang/rust/commit/ad9c54c631a39bbaf926021f18d683feba49fc09"}], "stats": {"total": 2649, "additions": 1513, "deletions": 1136}, "files": [{"sha": "faaddfed1e8ba1d992355d85bcf804797df239d4", "filename": "src/librustc/back/arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fback%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fback%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farm.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -14,7 +14,7 @@ use session::sess_os_to_meta_os;\n use metadata::loader::meta_section_name;\n \n pub fn get_target_strs(target_os: session::os) -> target_strs::t {\n-    return {\n+    return target_strs::t {\n         module_asm: ~\"\",\n \n         meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)),"}, {"sha": "b30f9fcb9dd830fc02271fe2709dfeaae6f9d613", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 36, "deletions": 21, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -16,10 +16,10 @@ use lib::llvm::llvm;\n use lib::llvm::{ModuleRef, mk_pass_manager, mk_target_data, True, False};\n use lib::llvm::{PassManagerRef, FileType};\n use lib;\n-use metadata::common::link_meta;\n+use metadata::common::LinkMeta;\n use metadata::filesearch;\n use metadata::{encoder, cstore};\n-use middle::trans::common::crate_ctxt;\n+use middle::trans::common::CrateContext;\n use middle::ty;\n use session::Session;\n use session;\n@@ -451,15 +451,16 @@ pub mod write {\n  */\n \n pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n-                   symbol_hasher: &hash::State) -> link_meta {\n+                   symbol_hasher: &hash::State) -> LinkMeta {\n \n-    type provided_metas =\n-        {name: Option<@str>,\n-         vers: Option<@str>,\n-         cmh_items: ~[@ast::meta_item]};\n+    struct ProvidedMetas {\n+        name: Option<@str>,\n+        vers: Option<@str>,\n+        cmh_items: ~[@ast::meta_item]\n+    }\n \n     fn provided_link_metas(sess: Session, c: &ast::crate) ->\n-       provided_metas {\n+       ProvidedMetas {\n         let mut name = None;\n         let mut vers = None;\n         let mut cmh_items = ~[];\n@@ -480,7 +481,12 @@ pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n                 }\n             } else { cmh_items.push(*meta); }\n         }\n-        return {name: name, vers: vers, cmh_items: cmh_items};\n+\n+        ProvidedMetas {\n+            name: name,\n+            vers: vers,\n+            cmh_items: cmh_items\n+        }\n     }\n \n     // This calculates CMH as defined above\n@@ -563,16 +569,23 @@ pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n             };\n     }\n \n-    let {name: opt_name, vers: opt_vers,\n-         cmh_items: cmh_items} = provided_link_metas(sess, c);\n+    let ProvidedMetas {\n+        name: opt_name,\n+        vers: opt_vers,\n+        cmh_items: cmh_items\n+    } = provided_link_metas(sess, c);\n     let name = crate_meta_name(sess, output, opt_name);\n     let vers = crate_meta_vers(sess, opt_vers);\n     let dep_hashes = cstore::get_dep_hashes(sess.cstore);\n     let extras_hash =\n         crate_meta_extras_hash(symbol_hasher, cmh_items,\n                                dep_hashes);\n \n-    return {name: name, vers: vers, extras_hash: extras_hash};\n+    LinkMeta {\n+        name: name,\n+        vers: vers,\n+        extras_hash: extras_hash\n+    }\n }\n \n pub fn truncated_hash_result(symbol_hasher: &hash::State) -> ~str {\n@@ -584,7 +597,7 @@ pub fn truncated_hash_result(symbol_hasher: &hash::State) -> ~str {\n \n // This calculates STH for a symbol, as defined above\n pub fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &hash::State, t: ty::t,\n-               link_meta: link_meta) -> @str {\n+               link_meta: LinkMeta) -> @str {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n \n@@ -601,7 +614,7 @@ pub fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &hash::State, t: ty::t,\n     hash.to_managed()\n }\n \n-pub fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> @str {\n+pub fn get_symbol_hash(ccx: @CrateContext, t: ty::t) -> @str {\n     match ccx.type_hashcodes.find(&t) {\n       Some(h) => h,\n       None => {\n@@ -673,14 +686,16 @@ pub fn exported_name(sess: Session,\n             path_name(sess.ident_of(vers.to_owned()))));\n }\n \n-pub fn mangle_exported_name(ccx: @crate_ctxt, +path: path, t: ty::t) -> ~str {\n+pub fn mangle_exported_name(ccx: @CrateContext,\n+                            +path: path,\n+                            t: ty::t) -> ~str {\n     let hash = get_symbol_hash(ccx, t);\n     return exported_name(ccx.sess, path,\n                          hash,\n                          ccx.link_meta.vers);\n }\n \n-pub fn mangle_internal_name_by_type_only(ccx: @crate_ctxt,\n+pub fn mangle_internal_name_by_type_only(ccx: @CrateContext,\n                                          t: ty::t,\n                                          name: &str) -> ~str {\n     let s = ppaux::ty_to_short_str(ccx.tcx, t);\n@@ -691,23 +706,23 @@ pub fn mangle_internal_name_by_type_only(ccx: @crate_ctxt,\n           path_name(ccx.sess.ident_of(hash.to_owned()))]);\n }\n \n-pub fn mangle_internal_name_by_path_and_seq(ccx: @crate_ctxt,\n+pub fn mangle_internal_name_by_path_and_seq(ccx: @CrateContext,\n                                             +path: path,\n                                             +flav: ~str) -> ~str {\n     return mangle(ccx.sess,\n                   vec::append_one(path, path_name((ccx.names)(flav))));\n }\n \n-pub fn mangle_internal_name_by_path(ccx: @crate_ctxt, +path: path) -> ~str {\n+pub fn mangle_internal_name_by_path(ccx: @CrateContext, +path: path) -> ~str {\n     return mangle(ccx.sess, path);\n }\n \n-pub fn mangle_internal_name_by_seq(ccx: @crate_ctxt, +flav: ~str) -> ~str {\n+pub fn mangle_internal_name_by_seq(ccx: @CrateContext, +flav: ~str) -> ~str {\n     return fmt!(\"%s_%u\", flav, (ccx.names)(flav).repr);\n }\n \n \n-pub fn output_dll_filename(os: session::os, lm: link_meta) -> ~str {\n+pub fn output_dll_filename(os: session::os, lm: LinkMeta) -> ~str {\n     let libname = fmt!(\"%s-%s-%s\", lm.name, lm.extras_hash, lm.vers);\n     let (dll_prefix, dll_suffix) = match os {\n         session::os_win32 => (win32::DLL_PREFIX, win32::DLL_SUFFIX),\n@@ -725,7 +740,7 @@ pub fn output_dll_filename(os: session::os, lm: link_meta) -> ~str {\n pub fn link_binary(sess: Session,\n                    obj_filename: &Path,\n                    out_filename: &Path,\n-                   lm: link_meta) {\n+                   lm: LinkMeta) {\n     // Converts a library file-stem into a cc -l argument\n     fn unlib(config: @session::config, +stem: ~str) -> ~str {\n         if stem.starts_with(\"lib\") &&"}, {"sha": "7baaac4fc9537687b37466cc23dd066ca9971159", "filename": "src/librustc/back/target_strs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fback%2Ftarget_strs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fback%2Ftarget_strs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Ftarget_strs.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n \n-pub type t = {\n+pub struct t {\n     module_asm: ~str,\n     meta_sect_name: ~str,\n     data_layout: ~str,\n     target_triple: ~str,\n     cc_args: ~[~str]\n-};\n+}"}, {"sha": "d9c4b27298ea86f36dc721b38a785673a0447da0", "filename": "src/librustc/back/upcall.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fupcall.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -15,17 +15,18 @@ use middle::trans::common::{T_fn, T_i1, T_i8, T_i32,\n                                T_int, T_nil,\n                                T_opaque_vec, T_ptr, T_unique_ptr,\n                                T_size_t, T_void, T_vec2};\n-use lib::llvm::{type_names, ModuleRef, ValueRef, TypeRef};\n+use lib::llvm::{TypeNames, ModuleRef, ValueRef, TypeRef};\n \n-pub type upcalls =\n-    {trace: ValueRef,\n-     call_shim_on_c_stack: ValueRef,\n-     call_shim_on_rust_stack: ValueRef,\n-     rust_personality: ValueRef,\n-     reset_stack_limit: ValueRef};\n+pub struct Upcalls {\n+    trace: ValueRef,\n+    call_shim_on_c_stack: ValueRef,\n+    call_shim_on_rust_stack: ValueRef,\n+    rust_personality: ValueRef,\n+    reset_stack_limit: ValueRef\n+}\n \n pub fn declare_upcalls(targ_cfg: @session::config,\n-                       llmod: ModuleRef) -> @upcalls {\n+                       llmod: ModuleRef) -> @Upcalls {\n     fn decl(llmod: ModuleRef, prefix: ~str, name: ~str,\n             tys: ~[TypeRef], rv: TypeRef) ->\n        ValueRef {\n@@ -43,22 +44,23 @@ pub fn declare_upcalls(targ_cfg: @session::config,\n \n     let int_t = T_int(targ_cfg);\n \n-    return @{trace: dv(~\"trace\", ~[T_ptr(T_i8()),\n+    @Upcalls {\n+        trace: dv(~\"trace\", ~[T_ptr(T_i8()),\n                               T_ptr(T_i8()),\n                               int_t]),\n-          call_shim_on_c_stack:\n-              d(~\"call_shim_on_c_stack\",\n-                // arguments: void *args, void *fn_ptr\n-                ~[T_ptr(T_i8()), T_ptr(T_i8())],\n-                int_t),\n-          call_shim_on_rust_stack:\n-              d(~\"call_shim_on_rust_stack\",\n-                ~[T_ptr(T_i8()), T_ptr(T_i8())], int_t),\n-          rust_personality:\n-              nothrow(d(~\"rust_personality\", ~[], T_i32())),\n-          reset_stack_limit:\n-              nothrow(dv(~\"reset_stack_limit\", ~[]))\n-         };\n+        call_shim_on_c_stack:\n+            d(~\"call_shim_on_c_stack\",\n+              // arguments: void *args, void *fn_ptr\n+              ~[T_ptr(T_i8()), T_ptr(T_i8())],\n+              int_t),\n+        call_shim_on_rust_stack:\n+            d(~\"call_shim_on_rust_stack\",\n+              ~[T_ptr(T_i8()), T_ptr(T_i8())], int_t),\n+        rust_personality:\n+            nothrow(d(~\"rust_personality\", ~[], T_i32())),\n+        reset_stack_limit:\n+            nothrow(dv(~\"reset_stack_limit\", ~[]))\n+    }\n }\n //\n // Local Variables:"}, {"sha": "a768edcc00bb9ac0e1c61fda9d83283b802d3471", "filename": "src/librustc/back/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -15,7 +15,7 @@ use metadata::loader::meta_section_name;\n use session::sess_os_to_meta_os;\n \n pub fn get_target_strs(target_os: session::os) -> target_strs::t {\n-    return {\n+    return target_strs::t {\n         module_asm: ~\"\",\n \n         meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)),"}, {"sha": "dc48831375960e6a0c8da9b880ec2fe9647cb5a3", "filename": "src/librustc/back/x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fback%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fback%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86_64.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -15,7 +15,7 @@ use metadata::loader::meta_section_name;\n use session::sess_os_to_meta_os;\n \n pub fn get_target_strs(target_os: session::os) -> target_strs::t {\n-    return {\n+    return target_strs::t {\n         module_asm: ~\"\",\n \n         meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)),"}, {"sha": "45bbe5d091e06fc8b9524029cb8eaf3ffe45b669", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 58, "deletions": 44, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -190,9 +190,9 @@ pub enum compile_upto {\n // For continuing compilation after a parsed crate has been\n // modified\n pub fn compile_rest(sess: Session, cfg: ast::crate_cfg,\n-                    upto: compile_upto, outputs: Option<output_filenames>,\n+                    upto: compile_upto, outputs: Option<@OutputFilenames>,\n                     curr: Option<@ast::crate>)\n-    -> {crate: @ast::crate, tcx: Option<ty::ctxt>} {\n+    -> (@ast::crate, Option<ty::ctxt>) {\n     let time_passes = sess.time_passes();\n     let mut crate = curr.get();\n \n@@ -209,7 +209,7 @@ pub fn compile_rest(sess: Session, cfg: ast::crate_cfg,\n         syntax::ext::expand::expand_crate(sess.parse_sess, copy cfg,\n                                           crate));\n \n-    if upto == cu_expand { return {crate: crate, tcx: None}; }\n+    if upto == cu_expand { return (crate, None); }\n \n     crate = time(time_passes, ~\"intrinsic injection\", ||\n         front::intrinsic_inject::inject_intrinsic(sess, crate));\n@@ -227,15 +227,17 @@ pub fn compile_rest(sess: Session, cfg: ast::crate_cfg,\n         creader::read_crates(sess.diagnostic(), *crate, sess.cstore,\n                              sess.filesearch,\n                              session::sess_os_to_meta_os(sess.targ_cfg.os),\n-                             sess.opts.static,\n+                             sess.opts.is_static,\n                              sess.parse_sess.interner));\n \n     let lang_items = time(time_passes, ~\"language item collection\", ||\n          middle::lang_items::collect_language_items(crate, sess));\n \n-    let { def_map: def_map,\n-          exp_map2: exp_map2,\n-          trait_map: trait_map } =\n+    let middle::resolve::CrateMap {\n+        def_map: def_map,\n+        exp_map2: exp_map2,\n+        trait_map: trait_map\n+    } =\n         time(time_passes, ~\"resolution\", ||\n              middle::resolve::resolve_crate(sess, lang_items, crate));\n \n@@ -270,7 +272,7 @@ pub fn compile_rest(sess: Session, cfg: ast::crate_cfg,\n              middle::check_const::check_crate(sess, crate, ast_map, def_map,\n                                               method_map, ty_cx));\n \n-        if upto == cu_typeck { return {crate: crate, tcx: Some(ty_cx)}; }\n+        if upto == cu_typeck { return (crate, Some(ty_cx)); }\n \n         time(time_passes, ~\"privacy checking\", ||\n              middle::privacy::check_crate(ty_cx, &method_map, crate));\n@@ -305,7 +307,7 @@ pub fn compile_rest(sess: Session, cfg: ast::crate_cfg,\n         time(time_passes, ~\"lint checking\", ||\n              lint::check_crate(ty_cx, crate));\n \n-        if upto == cu_no_trans { return {crate: crate, tcx: Some(ty_cx)}; }\n+        if upto == cu_no_trans { return (crate, Some(ty_cx)); }\n \n         let maps = astencode::Maps {\n             mutbl_map: mutbl_map,\n@@ -331,27 +333,27 @@ pub fn compile_rest(sess: Session, cfg: ast::crate_cfg,\n \n     let stop_after_codegen =\n         sess.opts.output_type != link::output_type_exe ||\n-        (sess.opts.static && *sess.building_library)   ||\n+        (sess.opts.is_static && *sess.building_library)   ||\n         sess.opts.jit;\n \n-    if stop_after_codegen { return {crate: crate, tcx: None}; }\n+    if stop_after_codegen { return (crate, None); }\n \n     time(time_passes, ~\"linking\", ||\n          link::link_binary(sess,\n                            &outputs.obj_filename,\n                            &outputs.out_filename, link_meta));\n \n-    return {crate: crate, tcx: None};\n+    return (crate, None);\n }\n \n pub fn compile_upto(sess: Session, +cfg: ast::crate_cfg,\n                 input: input, upto: compile_upto,\n-                outputs: Option<output_filenames>)\n-    -> {crate: @ast::crate, tcx: Option<ty::ctxt>} {\n+                outputs: Option<@OutputFilenames>)\n+    -> (@ast::crate, Option<ty::ctxt>) {\n     let time_passes = sess.time_passes();\n     let mut crate = time(time_passes, ~\"parsing\",\n                          || parse_input(sess, copy cfg, input) );\n-    if upto == cu_parse { return {crate: crate, tcx: None}; }\n+    if upto == cu_parse { return (crate, None); }\n \n     compile_rest(sess, cfg, upto, outputs, Some(crate))\n }\n@@ -417,7 +419,7 @@ pub fn pretty_print_input(sess: Session, +cfg: ast::crate_cfg, input: input,\n       ppm_typed => cu_typeck,\n       _ => cu_parse\n     };\n-    let {crate, tcx} = compile_upto(sess, cfg, input, upto, None);\n+    let (crate, tcx) = compile_upto(sess, cfg, input, upto, None);\n \n     let ann = match ppm {\n       ppm_typed => {\n@@ -494,9 +496,14 @@ pub fn build_target_config(sopts: @session::options,\n       session::arch_x86_64 => x86_64::get_target_strs(os),\n       session::arch_arm => arm::get_target_strs(os)\n     };\n-    let target_cfg: @session::config =\n-        @{os: os, arch: arch, target_strs: target_strs, int_type: int_type,\n-          uint_type: uint_type, float_type: float_type};\n+    let target_cfg = @session::config {\n+        os: os,\n+        arch: arch,\n+        target_strs: target_strs,\n+        int_type: int_type,\n+        uint_type: uint_type,\n+        float_type: float_type\n+    };\n     return target_cfg;\n }\n \n@@ -634,26 +641,27 @@ pub fn build_session_options(+binary: ~str,\n         .map(|s| Path(*s));\n     let cfg = parse_cfgspecs(getopts::opt_strs(matches, ~\"cfg\"));\n     let test = opt_present(matches, ~\"test\");\n-    let sopts: @session::options =\n-        @{crate_type: crate_type,\n-          static: static,\n-          gc: gc,\n-          optimize: opt_level,\n-          debuginfo: debuginfo,\n-          extra_debuginfo: extra_debuginfo,\n-          lint_opts: lint_opts,\n-          save_temps: save_temps,\n-          jit: jit,\n-          output_type: output_type,\n-          addl_lib_search_paths: addl_lib_search_paths,\n-          maybe_sysroot: sysroot_opt,\n-          target_triple: target,\n-          cfg: cfg,\n-          binary: binary,\n-          test: test,\n-          parse_only: parse_only,\n-          no_trans: no_trans,\n-          debugging_opts: debugging_opts};\n+    let sopts = @session::options {\n+        crate_type: crate_type,\n+        is_static: static,\n+        gc: gc,\n+        optimize: opt_level,\n+        debuginfo: debuginfo,\n+        extra_debuginfo: extra_debuginfo,\n+        lint_opts: lint_opts,\n+        save_temps: save_temps,\n+        jit: jit,\n+        output_type: output_type,\n+        addl_lib_search_paths: addl_lib_search_paths,\n+        maybe_sysroot: sysroot_opt,\n+        target_triple: target,\n+        cfg: cfg,\n+        binary: binary,\n+        test: test,\n+        parse_only: parse_only,\n+        no_trans: no_trans,\n+        debugging_opts: debugging_opts\n+    };\n     return sopts;\n }\n \n@@ -770,19 +778,22 @@ pub fn optgroups() -> ~[getopts::groups::OptGroup] {\n  ]\n }\n \n-pub type output_filenames = @{out_filename:Path, obj_filename:Path};\n+pub struct OutputFilenames {\n+    out_filename: Path,\n+    obj_filename: Path\n+}\n \n pub fn build_output_filenames(input: input,\n                               odir: &Option<Path>,\n                               ofile: &Option<Path>,\n                               sess: Session)\n-                           -> output_filenames {\n+                           -> @OutputFilenames {\n     let obj_path;\n     let out_path;\n     let sopts = sess.opts;\n     let stop_after_codegen =\n         sopts.output_type != link::output_type_exe ||\n-            sopts.static && *sess.building_library;\n+            sopts.is_static && *sess.building_library;\n \n \n     let obj_suffix =\n@@ -842,8 +853,11 @@ pub fn build_output_filenames(input: input,\n         }\n       }\n     }\n-    return @{out_filename: out_path,\n-             obj_filename: obj_path};\n+\n+    @OutputFilenames {\n+        out_filename: out_path,\n+        obj_filename: obj_path\n+    }\n }\n \n pub fn early_error(emitter: diagnostic::Emitter, msg: ~str) -> ! {"}, {"sha": "b91cc86eb26303230b80d98acb3e8da19686aaf7", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -37,13 +37,14 @@ pub enum arch { arch_x86, arch_x86_64, arch_arm, }\n \n pub enum crate_type { bin_crate, lib_crate, unknown_crate, }\n \n-pub type config =\n-    {os: os,\n-     arch: arch,\n-     target_strs: target_strs::t,\n-     int_type: int_ty,\n-     uint_type: uint_ty,\n-     float_type: float_ty};\n+pub struct config {\n+    os: os,\n+    arch: arch,\n+    target_strs: target_strs::t,\n+    int_type: int_ty,\n+    uint_type: uint_ty,\n+    float_type: float_ty\n+}\n \n pub const verbose: uint = 1 << 0;\n pub const time_passes: uint = 1 << 1;\n@@ -113,35 +114,38 @@ pub enum OptLevel {\n     Aggressive // -O3\n }\n \n-pub type options =\n+pub struct options {\n     // The crate config requested for the session, which may be combined\n     // with additional crate configurations during the compile process\n-    {crate_type: crate_type,\n-     static: bool,\n-     gc: bool,\n-     optimize: OptLevel,\n-     debuginfo: bool,\n-     extra_debuginfo: bool,\n-     lint_opts: ~[(lint::lint, lint::level)],\n-     save_temps: bool,\n-     jit: bool,\n-     output_type: back::link::output_type,\n-     addl_lib_search_paths: ~[Path],\n-     maybe_sysroot: Option<Path>,\n-     target_triple: ~str,\n-     // User-specified cfg meta items. The compiler itself will add additional\n-     // items to the crate config, and during parsing the entire crate config\n-     // will be added to the crate AST node.  This should not be used for\n-     // anything except building the full crate config prior to parsing.\n-     cfg: ast::crate_cfg,\n-     binary: ~str,\n-     test: bool,\n-     parse_only: bool,\n-     no_trans: bool,\n-     debugging_opts: uint,\n-    };\n-\n-pub type crate_metadata = {name: ~str, data: ~[u8]};\n+    crate_type: crate_type,\n+    is_static: bool,\n+    gc: bool,\n+    optimize: OptLevel,\n+    debuginfo: bool,\n+    extra_debuginfo: bool,\n+    lint_opts: ~[(lint::lint, lint::level)],\n+    save_temps: bool,\n+    jit: bool,\n+    output_type: back::link::output_type,\n+    addl_lib_search_paths: ~[Path],\n+    maybe_sysroot: Option<Path>,\n+    target_triple: ~str,\n+    // User-specified cfg meta items. The compiler itself will add additional\n+    // items to the crate config, and during parsing the entire crate config\n+    // will be added to the crate AST node.  This should not be used for\n+    // anything except building the full crate config prior to parsing.\n+    cfg: ast::crate_cfg,\n+    binary: ~str,\n+    test: bool,\n+    parse_only: bool,\n+    no_trans: bool,\n+    debugging_opts: uint,\n+}\n+\n+pub struct crate_metadata {\n+    name: ~str,\n+    data: ~[u8]\n+}\n \n pub struct Session_ {\n     targ_cfg: @config,\n@@ -155,7 +159,7 @@ pub struct Session_ {\n     filesearch: filesearch::FileSearch,\n     building_library: @mut bool,\n     working_dir: Path,\n-    lint_settings: lint::lint_settings\n+    lint_settings: lint::LintSettings\n }\n \n pub type Session = @Session_;\n@@ -266,9 +270,9 @@ pub impl Session {\n \n /// Some reasonable defaults\n pub fn basic_options() -> @options {\n-    @{\n+    @options {\n         crate_type: session::lib_crate,\n-        static: false,\n+        is_static: false,\n         gc: false,\n         optimize: No,\n         debuginfo: false,"}, {"sha": "afb73a6e7c35c91e0a407afd90d43de2c03d245f", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -17,9 +17,9 @@ use core::vec;\n \n type in_cfg_pred = fn@(+attrs: ~[ast::attribute]) -> bool;\n \n-type ctxt = @{\n+struct Context {\n     in_cfg: in_cfg_pred\n-};\n+}\n \n // Support conditional compilation by transforming the AST, stripping out\n // any items that do not belong in the current configuration\n@@ -32,7 +32,7 @@ pub fn strip_unconfigured_items(crate: @ast::crate) -> @ast::crate {\n pub fn strip_items(crate: @ast::crate, in_cfg: in_cfg_pred)\n     -> @ast::crate {\n \n-    let ctxt = @{in_cfg: in_cfg};\n+    let ctxt = @Context { in_cfg: in_cfg };\n \n     let precursor = @fold::AstFoldFns {\n           fold_mod: |a,b| fold_mod(ctxt, a, b),\n@@ -49,12 +49,12 @@ pub fn strip_items(crate: @ast::crate, in_cfg: in_cfg_pred)\n     return res;\n }\n \n-fn filter_item(cx: ctxt, &&item: @ast::item) ->\n+fn filter_item(cx: @Context, &&item: @ast::item) ->\n    Option<@ast::item> {\n     if item_in_cfg(cx, item) { option::Some(item) } else { option::None }\n }\n \n-fn filter_view_item(cx: ctxt, &&view_item: @ast::view_item\n+fn filter_view_item(cx: @Context, &&view_item: @ast::view_item\n                    )-> Option<@ast::view_item> {\n     if view_item_in_cfg(cx, view_item) {\n         option::Some(view_item)\n@@ -63,7 +63,7 @@ fn filter_view_item(cx: ctxt, &&view_item: @ast::view_item\n     }\n }\n \n-fn fold_mod(cx: ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n+fn fold_mod(cx: @Context, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n     let filtered_items =\n         m.items.filter_mapped(|a| filter_item(cx, *a));\n     let filtered_view_items =\n@@ -74,15 +74,15 @@ fn fold_mod(cx: ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n     }\n }\n \n-fn filter_foreign_item(cx: ctxt, &&item: @ast::foreign_item) ->\n+fn filter_foreign_item(cx: @Context, &&item: @ast::foreign_item) ->\n    Option<@ast::foreign_item> {\n     if foreign_item_in_cfg(cx, item) {\n         option::Some(item)\n     } else { option::None }\n }\n \n fn fold_foreign_mod(\n-    cx: ctxt,\n+    cx: @Context,\n     nm: ast::foreign_mod,\n     fld: fold::ast_fold\n ) -> ast::foreign_mod {\n@@ -98,7 +98,7 @@ fn fold_foreign_mod(\n     }\n }\n \n-fn fold_item_underscore(cx: ctxt, +item: ast::item_,\n+fn fold_item_underscore(cx: @Context, +item: ast::item_,\n                         fld: fold::ast_fold) -> ast::item_ {\n     let item = match item {\n         ast::item_impl(a, b, c, methods) => {\n@@ -115,7 +115,7 @@ fn fold_item_underscore(cx: ctxt, +item: ast::item_,\n     fold::noop_fold_item_underscore(item, fld)\n }\n \n-fn filter_stmt(cx: ctxt, &&stmt: @ast::stmt) ->\n+fn filter_stmt(cx: @Context, &&stmt: @ast::stmt) ->\n    Option<@ast::stmt> {\n     match stmt.node {\n       ast::stmt_decl(decl, _) => {\n@@ -133,7 +133,7 @@ fn filter_stmt(cx: ctxt, &&stmt: @ast::stmt) ->\n }\n \n fn fold_block(\n-    cx: ctxt,\n+    cx: @Context,\n     b: ast::blk_,\n     fld: fold::ast_fold\n ) -> ast::blk_ {\n@@ -148,23 +148,23 @@ fn fold_block(\n     }\n }\n \n-fn item_in_cfg(cx: ctxt, item: @ast::item) -> bool {\n+fn item_in_cfg(cx: @Context, item: @ast::item) -> bool {\n     return (cx.in_cfg)(/*bad*/copy item.attrs);\n }\n \n-fn foreign_item_in_cfg(cx: ctxt, item: @ast::foreign_item) -> bool {\n+fn foreign_item_in_cfg(cx: @Context, item: @ast::foreign_item) -> bool {\n     return (cx.in_cfg)(/*bad*/copy item.attrs);\n }\n \n-fn view_item_in_cfg(cx: ctxt, item: @ast::view_item) -> bool {\n+fn view_item_in_cfg(cx: @Context, item: @ast::view_item) -> bool {\n     return (cx.in_cfg)(/*bad*/copy item.attrs);\n }\n \n-fn method_in_cfg(cx: ctxt, meth: @ast::method) -> bool {\n+fn method_in_cfg(cx: @Context, meth: @ast::method) -> bool {\n     return (cx.in_cfg)(/*bad*/copy meth.attrs);\n }\n \n-fn trait_method_in_cfg(cx: ctxt, meth: &ast::trait_method) -> bool {\n+fn trait_method_in_cfg(cx: @Context, meth: &ast::trait_method) -> bool {\n     match *meth {\n         ast::required(ref meth) => (cx.in_cfg)(/*bad*/copy meth.attrs),\n         ast::provided(@ref meth) => (cx.in_cfg)(/*bad*/copy meth.attrs)"}, {"sha": "1d396983f4e90f58b2dd0dead38cd7a6c04eb8bb", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -10,6 +10,10 @@\n \n // Code that generates a test runner to run all the tests in a crate\n \n+// XXX - Need to finish off libsyntax first\n+#[legacy_records];\n+#[allow(structural_records)];\n+\n use core::prelude::*;\n \n use driver::session;\n@@ -32,20 +36,20 @@ use syntax::ext::base::{mk_ctxt, ext_ctxt};\n \n type node_id_gen = fn@() -> ast::node_id;\n \n-type test = {\n+struct Test {\n     span: span,\n     path: ~[ast::ident],\n     bench: bool,\n     ignore: bool,\n     should_fail: bool\n-};\n+}\n \n struct TestCtxt {\n     sess: session::Session,\n     crate: @ast::crate,\n     path: ~[ast::ident],\n-      ext_cx: ext_ctxt,\n-    testfns: ~[test]\n+    ext_cx: ext_ctxt,\n+    testfns: ~[Test]\n }\n \n // Traverse the crate, collecting all the test functions, eliding any\n@@ -77,9 +81,11 @@ fn generate_test_harness(sess: session::Session,\n         testfns: ~[]\n     };\n \n-    cx.ext_cx.bt_push(ExpandedFrom({call_site: dummy_sp(),\n-                                    callie: {name: ~\"test\",\n-                                             span: None}}));\n+    cx.ext_cx.bt_push(ExpandedFrom({\n+                        call_site: dummy_sp(),\n+                        callie: {\n+                            name: ~\"test\",\n+                            span: None}}));\n \n     let precursor = @fold::AstFoldFns {\n         fold_crate: fold::wrap(|a,b| fold_crate(cx, a, b) ),\n@@ -153,11 +159,13 @@ fn fold_item(cx: @mut TestCtxt, &&i: @ast::item, fld: fold::ast_fold)\n           }\n           _ => {\n             debug!(\"this is a test function\");\n-            let test = {span: i.span,\n-                        path: /*bad*/copy cx.path,\n-                        bench: is_bench_fn(i),\n-                        ignore: is_ignored(cx, i),\n-                        should_fail: should_fail(i)};\n+            let test = Test {\n+                span: i.span,\n+                path: /*bad*/copy cx.path,\n+                bench: is_bench_fn(i),\n+                ignore: is_ignored(cx, i),\n+                should_fail: should_fail(i)\n+            };\n             cx.testfns.push(test);\n             debug!(\"have %u test/bench functions\", cx.testfns.len());\n           }\n@@ -396,7 +404,7 @@ fn mk_test_descs(cx: &TestCtxt) -> @ast::expr {\n     }\n }\n \n-fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: test) -> @ast::expr {\n+fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: Test) -> @ast::expr {\n     let span = test.span;\n     let path = /*bad*/copy test.path;\n "}, {"sha": "e42d3aeaf144cb9298b5fc9c8c58f85c81988b11", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 55, "deletions": 24, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -1298,32 +1298,36 @@ pub fn SetLinkage(Global: ValueRef, Link: Linkage) {\n \n /* Memory-managed object interface to type handles. */\n \n-pub type type_names = @{type_names: HashMap<TypeRef, @str>,\n-                    named_types: HashMap<@str, TypeRef>};\n+pub struct TypeNames {\n+    type_names: HashMap<TypeRef, @str>,\n+    named_types: HashMap<@str, TypeRef>\n+}\n \n-pub fn associate_type(tn: type_names, s: @str, t: TypeRef) {\n+pub fn associate_type(tn: @TypeNames, s: @str, t: TypeRef) {\n     assert tn.type_names.insert(t, s);\n     assert tn.named_types.insert(s, t);\n }\n \n-pub fn type_has_name(tn: type_names, t: TypeRef) -> Option<@str> {\n+pub fn type_has_name(tn: @TypeNames, t: TypeRef) -> Option<@str> {\n     return tn.type_names.find(&t);\n }\n \n-pub fn name_has_type(tn: type_names, s: @str) -> Option<TypeRef> {\n+pub fn name_has_type(tn: @TypeNames, s: @str) -> Option<TypeRef> {\n     return tn.named_types.find(&s);\n }\n \n-pub fn mk_type_names() -> type_names {\n-    @{type_names: HashMap(),\n-      named_types: HashMap()}\n+pub fn mk_type_names() -> @TypeNames {\n+    @TypeNames {\n+        type_names: HashMap(),\n+        named_types: HashMap()\n+    }\n }\n \n-pub fn type_to_str(names: type_names, ty: TypeRef) -> @str {\n+pub fn type_to_str(names: @TypeNames, ty: TypeRef) -> @str {\n     return type_to_str_inner(names, [], ty);\n }\n \n-pub fn type_to_str_inner(names: type_names, +outer0: &[TypeRef], ty: TypeRef)\n+pub fn type_to_str_inner(names: @TypeNames, +outer0: &[TypeRef], ty: TypeRef)\n                       -> @str {\n     unsafe {\n         match type_has_name(names, ty) {\n@@ -1335,7 +1339,7 @@ pub fn type_to_str_inner(names: type_names, +outer0: &[TypeRef], ty: TypeRef)\n \n         let kind = llvm::LLVMGetTypeKind(ty);\n \n-        fn tys_str(names: type_names, outer: &[TypeRef],\n+        fn tys_str(names: @TypeNames, outer: &[TypeRef],\n                    tys: ~[TypeRef]) -> @str {\n             let mut s = ~\"\";\n             let mut first: bool = true;\n@@ -1473,14 +1477,21 @@ pub fn target_data_res(TD: TargetDataRef) -> target_data_res {\n     }\n }\n \n-pub type target_data = {lltd: TargetDataRef, dtor: @target_data_res};\n+pub struct TargetData {\n+    lltd: TargetDataRef,\n+    dtor: @target_data_res\n+}\n \n-pub fn mk_target_data(string_rep: ~str) -> target_data {\n+pub fn mk_target_data(string_rep: ~str) -> TargetData {\n     let lltd =\n         str::as_c_str(string_rep, |buf| unsafe {\n             llvm::LLVMCreateTargetData(buf)\n         });\n-    return {lltd: lltd, dtor: @target_data_res(lltd)};\n+\n+    TargetData {\n+        lltd: lltd,\n+        dtor: @target_data_res(lltd)\n+    }\n }\n \n /* Memory-managed interface to pass managers. */\n@@ -1500,12 +1511,19 @@ pub fn pass_manager_res(PM: PassManagerRef) -> pass_manager_res {\n     }\n }\n \n-pub type pass_manager = {llpm: PassManagerRef, dtor: @pass_manager_res};\n+pub struct PassManager {\n+    llpm: PassManagerRef,\n+    dtor: @pass_manager_res\n+}\n \n-pub fn mk_pass_manager() -> pass_manager {\n+pub fn mk_pass_manager() -> PassManager {\n     unsafe {\n         let llpm = llvm::LLVMCreatePassManager();\n-        return {llpm: llpm, dtor: @pass_manager_res(llpm)};\n+\n+        PassManager {\n+            llpm: llpm,\n+            dtor: @pass_manager_res(llpm)\n+        }\n     }\n }\n \n@@ -1526,13 +1544,20 @@ pub fn object_file_res(ObjFile: ObjectFileRef) -> object_file_res {\n     }\n }\n \n-pub type object_file = {llof: ObjectFileRef, dtor: @object_file_res};\n+pub struct ObjectFile {\n+    llof: ObjectFileRef,\n+    dtor: @object_file_res\n+}\n \n-pub fn mk_object_file(llmb: MemoryBufferRef) -> Option<object_file> {\n+pub fn mk_object_file(llmb: MemoryBufferRef) -> Option<ObjectFile> {\n     unsafe {\n         let llof = llvm::LLVMCreateObjectFile(llmb);\n-        if llof as int == 0 { return option::None::<object_file>; }\n-        return option::Some({llof: llof, dtor: @object_file_res(llof)});\n+        if llof as int == 0 { return option::None::<ObjectFile>; }\n+\n+        option::Some(ObjectFile {\n+            llof: llof,\n+            dtor: @object_file_res(llof)\n+        })\n     }\n }\n \n@@ -1553,12 +1578,18 @@ pub fn section_iter_res(SI: SectionIteratorRef) -> section_iter_res {\n     }\n }\n \n-pub type section_iter = {llsi: SectionIteratorRef, dtor: @section_iter_res};\n+pub struct SectionIter {\n+    llsi: SectionIteratorRef,\n+    dtor: @section_iter_res\n+}\n \n-pub fn mk_section_iter(llof: ObjectFileRef) -> section_iter {\n+pub fn mk_section_iter(llof: ObjectFileRef) -> SectionIter {\n     unsafe {\n         let llsi = llvm::LLVMGetSections(llof);\n-        return {llsi: llsi, dtor: @section_iter_res(llsi)};\n+        SectionIter {\n+            llsi: llsi,\n+            dtor: @section_iter_res(llsi)\n+        }\n     }\n }\n "}, {"sha": "877098ed49fe684c0adf95603c20fd3961699944", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -156,5 +156,9 @@ pub const tag_lang_items_item_node_id: uint = 0x75;\n pub const tag_item_unnamed_field: uint = 0x76;\n pub const tag_items_data_item_struct_ctor: uint = 0x77;\n \n-pub type link_meta = {name: @str, vers: @str, extras_hash: @str};\n+pub struct LinkMeta {\n+    name: @str,\n+    vers: @str,\n+    extras_hash: @str\n+}\n "}, {"sha": "79dec35e4abb85c85237602ea37bd1d8402e2254", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -61,12 +61,12 @@ pub fn read_crates(diag: span_handler,\n     warn_if_multiple_versions(e, diag, e.crate_cache);\n }\n \n-type cache_entry = {\n+struct cache_entry {\n     cnum: int,\n     span: span,\n     hash: @~str,\n     metas: @~[@ast::meta_item]\n-};\n+}\n \n fn dump_crates(+crate_cache: @mut ~[cache_entry]) {\n     debug!(\"resolved crates:\");\n@@ -244,30 +244,34 @@ fn resolve_crate(e: @mut Env,\n \n     match existing_match(e, metas, hash) {\n       None => {\n-        let load_ctxt: loader::ctxt = {\n+        let load_ctxt = loader::Context {\n             diag: e.diag,\n             filesearch: e.filesearch,\n             span: span,\n             ident: ident,\n             metas: metas,\n             hash: hash,\n             os: e.os,\n-            static: e.statik,\n+            is_static: e.statik,\n             intr: e.intr\n         };\n-        let cinfo = loader::load_library_crate(load_ctxt);\n+        let (lident, ldata) = loader::load_library_crate(load_ctxt);\n \n-        let cfilename = Path(cinfo.ident);\n-        let cdata = cinfo.data;\n+        let cfilename = Path(lident);\n+        let cdata = ldata;\n \n         let attrs = decoder::get_crate_attributes(cdata);\n         let linkage_metas = attr::find_linkage_metas(attrs);\n         let hash = decoder::get_crate_hash(cdata);\n \n         // Claim this crate number and cache it\n         let cnum = e.next_crate_num;\n-        e.crate_cache.push({cnum: cnum, span: span,\n-                            hash: hash, metas: @linkage_metas});\n+        e.crate_cache.push(cache_entry {\n+            cnum: cnum,\n+            span: span,\n+            hash: hash,\n+            metas: @linkage_metas\n+        });\n         e.next_crate_num += 1;\n \n         // Now resolve the crates referenced by this crate\n@@ -279,8 +283,12 @@ fn resolve_crate(e: @mut Env,\n                 Some(v) => v,\n                 None => e.intr.get(ident),\n             };\n-        let cmeta = @{name: cname, data: cdata,\n-                      cnum_map: cnum_map, cnum: cnum};\n+        let cmeta = @cstore::crate_metadata {\n+            name: cname,\n+            data: cdata,\n+            cnum_map: cnum_map,\n+            cnum: cnum\n+        };\n \n         let cstore = e.cstore;\n         cstore::set_crate_data(cstore, cnum, cmeta);"}, {"sha": "eda7362b9c17764a1eb2befa85ebab61d778efd5", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -17,7 +17,7 @@ use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n use metadata;\n-use middle::ty;\n+use middle::{ty, resolve};\n \n use core::dvec::DVec;\n use core::vec;\n@@ -110,7 +110,7 @@ pub fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id)\n \n pub fn get_impls_for_mod(cstore: @mut cstore::CStore, def: ast::def_id,\n                          name: Option<ast::ident>)\n-                      -> @~[@decoder::_impl] {\n+                      -> @~[@resolve::Impl] {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     do decoder::get_impls_for_mod(cstore.intr, cdata, def.node, name) |cnum| {\n         cstore::get_crate_data(cstore, cnum)\n@@ -204,9 +204,11 @@ pub fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n                  class_id, def) );\n     debug!(\"got field data %?\", the_field);\n     let ty = decoder::item_type(def, the_field, tcx, cdata);\n-    return {bounds: @~[],\n-            region_param: None,\n-            ty: ty};\n+    ty::ty_param_bounds_and_ty {\n+        bounds: @~[],\n+        region_param: None,\n+        ty: ty\n+    }\n }\n \n // Given a def_id for an impl or class, return the traits it implements,"}, {"sha": "667a9c200580fd73dcd71e46cc422fd8b9282533", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -33,13 +33,15 @@ use syntax::parse::token::ident_interner;\n // own crate numbers.\n pub type cnum_map = oldmap::HashMap<ast::crate_num, ast::crate_num>;\n \n-pub type crate_metadata = @{name: @~str,\n-                            data: @~[u8],\n-                            cnum_map: cnum_map,\n-                            cnum: ast::crate_num};\n+pub struct crate_metadata {\n+    name: @~str,\n+    data: @~[u8],\n+    cnum_map: cnum_map,\n+    cnum: ast::crate_num\n+}\n \n pub struct CStore {\n-    priv metas: oldmap::HashMap<ast::crate_num, crate_metadata>,\n+    priv metas: oldmap::HashMap<ast::crate_num, @crate_metadata>,\n     priv extern_mod_crate_map: extern_mod_crate_map,\n     priv used_crate_files: ~[Path],\n     priv used_libraries: ~[~str],\n@@ -64,7 +66,7 @@ pub fn mk_cstore(intr: @ident_interner) -> CStore {\n }\n \n pub fn get_crate_data(cstore: @mut CStore, cnum: ast::crate_num)\n-                   -> crate_metadata {\n+                   -> @crate_metadata {\n     return cstore.metas.get(&cnum);\n }\n \n@@ -80,7 +82,7 @@ pub fn get_crate_vers(cstore: @mut CStore, cnum: ast::crate_num) -> @~str {\n \n pub fn set_crate_data(cstore: @mut CStore,\n                       cnum: ast::crate_num,\n-                      data: crate_metadata) {\n+                      data: @crate_metadata) {\n     let metas = cstore.metas;\n     metas.insert(cnum, data);\n }\n@@ -90,7 +92,7 @@ pub fn have_crate_data(cstore: @mut CStore, cnum: ast::crate_num) -> bool {\n }\n \n pub fn iter_crate_data(cstore: @mut CStore,\n-                       i: fn(ast::crate_num, crate_metadata)) {\n+                       i: fn(ast::crate_num, @crate_metadata)) {\n     let metas = cstore.metas;\n     for metas.each |&k, &v| {\n         i(k, v);\n@@ -144,15 +146,18 @@ pub fn find_extern_mod_stmt_cnum(cstore: @mut CStore,\n // returns hashes of crates directly used by this crate. Hashes are\n // sorted by crate name.\n pub fn get_dep_hashes(cstore: @mut CStore) -> ~[~str] {\n-    type crate_hash = {name: ~str, hash: ~str};\n+    struct crate_hash { name: @~str, hash: @~str }\n     let mut result = ~[];\n \n     let extern_mod_crate_map = cstore.extern_mod_crate_map;\n     for extern_mod_crate_map.each_value |&cnum| {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n         debug!(\"Add hash[%s]: %s\", *cdata.name, *hash);\n-        result.push({name: /*bad*/copy cdata.name, hash: hash});\n+        result.push(crate_hash {\n+            name: cdata.name,\n+            hash: hash\n+        });\n     }\n \n     let sorted = std::sort::merge_sort(result, |a, b| a.name <= b.name);"}, {"sha": "ca55c8a4072769f96872dad7819cb6502fbf02d5", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -13,7 +13,7 @@\n \n use core::prelude::*;\n \n-use cmd = metadata::cstore::crate_metadata;\n+use metadata::cstore::crate_metadata;\n use dvec::DVec;\n use hash::{Hash, HashUtil};\n use io::WriterUtil;\n@@ -24,7 +24,7 @@ use metadata::cstore;\n use metadata::decoder;\n use metadata::tydecode::{parse_ty_data, parse_def_id, parse_bounds_data};\n use metadata::tydecode::{parse_ident};\n-use middle::ty;\n+use middle::{ty, resolve};\n use util::ppaux::ty_to_str;\n \n use core::cmp;\n@@ -47,6 +47,8 @@ use syntax::print::pprust;\n use syntax::{ast, ast_util};\n use syntax::codemap;\n \n+type cmd = @crate_metadata;\n+\n // A function that takes a def_id relative to the crate being searched and\n // returns a def_id relative to the compilation environment, i.e. if we hit a\n // def_id for an item defined in another crate, somebody needs to figure out\n@@ -98,6 +100,7 @@ fn lookup_item(item_id: int, data: @~[u8]) -> ebml::Doc {\n     }\n }\n \n+#[deriving_eq]\n enum Family {\n     Const,                 // c\n     Fn,                    // f\n@@ -121,13 +124,6 @@ enum Family {\n     InheritedField         // N\n }\n \n-impl cmp::Eq for Family {\n-    pure fn eq(&self, other: &Family) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &Family) -> bool { !(*self).eq(other) }\n-}\n-\n fn item_family(item: ebml::Doc) -> Family {\n     let fam = reader::get_doc(item, tag_items_data_item_family);\n     match reader::doc_as_u8(fam) as char {\n@@ -360,9 +356,11 @@ pub fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n         item_ty_param_bounds(item, tcx, cdata)\n     } else { @~[] };\n     let rp = item_ty_region_param(item);\n-    return {bounds: tp_bounds,\n-            region_param: rp,\n-            ty: t};\n+    ty::ty_param_bounds_and_ty {\n+        bounds: tp_bounds,\n+        region_param: rp,\n+        ty: t\n+    }\n }\n \n pub fn get_region_param(cdata: cmd, id: ast::node_id)\n@@ -544,7 +542,7 @@ pub fn get_item_path(intr: @ident_interner, cdata: cmd, id: ast::node_id)\n }\n \n pub type decode_inlined_item = fn(\n-    cdata: cstore::crate_metadata,\n+    cdata: @cstore::crate_metadata,\n     tcx: ty::ctxt,\n     path: ast_map::path,\n     par_doc: ebml::Doc) -> Option<ast::inlined_item>;\n@@ -606,20 +604,6 @@ pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     return infos;\n }\n \n-// NB: These types are duplicated in resolve.rs\n-pub type method_info = {\n-    did: ast::def_id,\n-    n_tps: uint,\n-    ident: ast::ident,\n-    self_type: ast::self_ty_\n-};\n-\n-pub type _impl = {\n-    did: ast::def_id,\n-    ident: ast::ident,\n-    methods: ~[@method_info]\n-};\n-\n fn get_self_ty(item: ebml::Doc) -> ast::self_ty_ {\n     fn get_mutability(ch: u8) -> ast::mutability {\n         match ch as char {\n@@ -650,16 +634,17 @@ fn get_self_ty(item: ebml::Doc) -> ast::self_ty_ {\n }\n \n fn item_impl_methods(intr: @ident_interner, cdata: cmd, item: ebml::Doc,\n-                     base_tps: uint) -> ~[@method_info] {\n+                     base_tps: uint) -> ~[@resolve::MethodInfo] {\n     let mut rslt = ~[];\n     for reader::tagged_docs(item, tag_item_impl_method) |doc| {\n         let m_did = reader::with_doc_data(doc, |d| parse_def_id(d));\n         let mth_item = lookup_item(m_did.node, cdata.data);\n         let self_ty = get_self_ty(mth_item);\n-        rslt.push(@{did: translate_def_id(cdata, m_did),\n-                   n_tps: item_ty_param_count(mth_item) - base_tps,\n-                   ident: item_name(intr, mth_item),\n-                   self_type: self_ty});\n+        rslt.push(@resolve::MethodInfo {\n+                    did: translate_def_id(cdata, m_did),\n+                    n_tps: item_ty_param_count(mth_item) - base_tps,\n+                    ident: item_name(intr, mth_item),\n+                    self_type: self_ty});\n     }\n     rslt\n }\n@@ -669,7 +654,7 @@ pub fn get_impls_for_mod(intr: @ident_interner,\n                          m_id: ast::node_id,\n                          name: Option<ast::ident>,\n                          get_cdata: &fn(ast::crate_num) -> cmd)\n-                      -> @~[@_impl] {\n+                      -> @~[@resolve::Impl] {\n     let data = cdata.data;\n     let mod_item = lookup_item(m_id, data);\n     let mut result = ~[];\n@@ -686,7 +671,7 @@ pub fn get_impls_for_mod(intr: @ident_interner,\n         let nm = item_name(intr, item);\n         if match name { Some(n) => { n == nm } None => { true } } {\n            let base_tps = item_ty_param_count(item);\n-           result.push(@{\n+           result.push(@resolve::Impl {\n                 did: local_did, ident: nm,\n                 methods: item_impl_methods(intr, impl_cdata, item, base_tps)\n             });\n@@ -714,8 +699,14 @@ pub fn get_trait_methods(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n             }\n         };\n         let self_ty = get_self_ty(mth);\n-        result.push({ident: name, tps: bounds, fty: fty, self_ty: self_ty,\n-                     vis: ast::public, def_id: def_id});\n+        result.push(ty::method {\n+            ident: name,\n+            tps: bounds,\n+            fty: fty,\n+            self_ty: self_ty,\n+            vis: ast::public,\n+            def_id: def_id\n+        });\n     }\n     debug!(\"get_trait_methods: }\");\n     @result\n@@ -746,8 +737,14 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n         };\n \n         let self_ty = get_self_ty(mth);\n-        let ty_method = {ident: name, tps: bounds, fty: fty, self_ty: self_ty,\n-                         vis: ast::public, def_id: did};\n+        let ty_method = ty::method {\n+            ident: name,\n+            tps: bounds,\n+            fty: fty,\n+            self_ty: self_ty,\n+            vis: ast::public,\n+            def_id: did\n+        };\n         let provided_trait_method_info = ProvidedTraitMethodInfo {\n             ty: ty_method,\n             def_id: did\n@@ -915,12 +912,13 @@ fn family_names_type(fam: Family) -> bool {\n     match fam { Type | Mod | Trait => true, _ => false }\n }\n \n-fn read_path(d: ebml::Doc) -> {path: ~str, pos: uint} {\n+fn read_path(d: ebml::Doc) -> (~str, uint) {\n     let desc = reader::doc_data(d);\n     let pos = io::u64_from_be_bytes(desc, 0u, 4u) as uint;\n     let pathbytes = vec::slice::<u8>(desc, 4u, vec::len::<u8>(desc));\n     let path = str::from_bytes(pathbytes);\n-    return {path: path, pos: pos};\n+\n+    (path, pos)\n }\n \n fn describe_def(items: ebml::Doc, id: ast::def_id) -> ~str {\n@@ -1030,8 +1028,12 @@ pub fn get_crate_attributes(data: @~[u8]) -> ~[ast::attribute] {\n     return get_attributes(reader::Doc(data));\n }\n \n-pub type crate_dep = {cnum: ast::crate_num, name: ast::ident,\n-                      vers: @~str, hash: @~str};\n+pub struct crate_dep {\n+    cnum: ast::crate_num,\n+    name: ast::ident,\n+    vers: @~str,\n+    hash: @~str\n+}\n \n pub fn get_crate_deps(intr: @ident_interner, data: @~[u8]) -> ~[crate_dep] {\n     let mut deps: ~[crate_dep] = ~[];\n@@ -1042,7 +1044,7 @@ pub fn get_crate_deps(intr: @ident_interner, data: @~[u8]) -> ~[crate_dep] {\n         str::from_bytes(reader::doc_data(reader::get_doc(doc, tag_)))\n     }\n     for reader::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n-        deps.push({cnum: crate_num,\n+        deps.push(crate_dep {cnum: crate_num,\n                   name: intr.intern(@docstr(depdoc, tag_crate_dep_name)),\n                   vers: @docstr(depdoc, tag_crate_dep_vers),\n                   hash: @docstr(depdoc, tag_crate_dep_hash)});"}, {"sha": "5343b832de503d3fd0ce52f69a62a28a396423f7", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 63, "deletions": 58, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -55,22 +55,22 @@ use writer = std::ebml::writer;\n // used by astencode:\n type abbrev_map = oldmap::HashMap<ty::t, tyencode::ty_abbrev>;\n \n-pub type encode_inlined_item = fn@(ecx: @encode_ctxt,\n+pub type encode_inlined_item = fn@(ecx: @EncodeContext,\n                                    ebml_w: writer::Encoder,\n                                    path: &[ast_map::path_elt],\n                                    ii: ast::inlined_item);\n \n-pub type encode_parms = {\n+pub struct EncodeParams {\n     diag: span_handler,\n     tcx: ty::ctxt,\n     reachable: HashMap<ast::node_id, ()>,\n     reexports2: middle::resolve::ExportMap2,\n     item_symbols: HashMap<ast::node_id, ~str>,\n     discrim_symbols: HashMap<ast::node_id, ~str>,\n-    link_meta: link_meta,\n+    link_meta: LinkMeta,\n     cstore: @mut cstore::CStore,\n     encode_inlined_item: encode_inlined_item\n-};\n+}\n \n struct Stats {\n     inline_bytes: uint,\n@@ -85,29 +85,29 @@ struct Stats {\n     n_inlines: uint\n }\n \n-pub enum encode_ctxt = {\n+pub struct EncodeContext {\n     diag: span_handler,\n     tcx: ty::ctxt,\n     stats: @mut Stats,\n     reachable: HashMap<ast::node_id, ()>,\n     reexports2: middle::resolve::ExportMap2,\n     item_symbols: HashMap<ast::node_id, ~str>,\n     discrim_symbols: HashMap<ast::node_id, ~str>,\n-    link_meta: link_meta,\n+    link_meta: LinkMeta,\n     cstore: @mut cstore::CStore,\n     encode_inlined_item: encode_inlined_item,\n     type_abbrevs: abbrev_map\n-};\n+}\n \n-pub fn reachable(ecx: @encode_ctxt, id: node_id) -> bool {\n+pub fn reachable(ecx: @EncodeContext, id: node_id) -> bool {\n     ecx.reachable.contains_key(&id)\n }\n \n-fn encode_name(ecx: @encode_ctxt, ebml_w: writer::Encoder, name: ident) {\n+fn encode_name(ecx: @EncodeContext, ebml_w: writer::Encoder, name: ident) {\n     ebml_w.wr_tagged_str(tag_paths_data_name, *ecx.tcx.sess.str_of(name));\n }\n \n-fn encode_impl_type_basename(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n+fn encode_impl_type_basename(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                              name: ident) {\n     ebml_w.wr_tagged_str(tag_item_impl_type_basename,\n                          *ecx.tcx.sess.str_of(name));\n@@ -117,7 +117,7 @@ pub fn encode_def_id(ebml_w: writer::Encoder, id: def_id) {\n     ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n-fn encode_region_param(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n+fn encode_region_param(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                        it: @ast::item) {\n     let opt_rp = ecx.tcx.region_paramd_items.find(&it.id);\n     for opt_rp.each |rp| {\n@@ -137,20 +137,25 @@ fn encode_mutability(ebml_w: writer::Encoder, mt: struct_mutability) {\n     }\n }\n \n-type entry<T> = {val: T, pos: uint};\n+struct entry<T> {\n+    val: T,\n+    pos: uint\n+}\n \n-fn add_to_index(ecx: @encode_ctxt, ebml_w: writer::Encoder, path: &[ident],\n+fn add_to_index(ecx: @EncodeContext, ebml_w: writer::Encoder, path: &[ident],\n                 index: &mut ~[entry<~str>], name: ident) {\n     let mut full_path = ~[];\n     full_path.push_all(path);\n     full_path.push(name);\n     index.push(\n-        {val: ast_util::path_name_i(full_path,\n-                                    ecx.tcx.sess.parse_sess.interner),\n-         pos: ebml_w.writer.tell()});\n+        entry {\n+            val: ast_util::path_name_i(full_path,\n+                                       ecx.tcx.sess.parse_sess.interner),\n+            pos: ebml_w.writer.tell()\n+        });\n }\n \n-fn encode_trait_ref(ebml_w: writer::Encoder, ecx: @encode_ctxt,\n+fn encode_trait_ref(ebml_w: writer::Encoder, ecx: @EncodeContext,\n                     t: @trait_ref) {\n     ebml_w.start_tag(tag_impl_trait);\n     encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, t.ref_id));\n@@ -167,7 +172,7 @@ fn encode_family(ebml_w: writer::Encoder, c: char) {\n \n pub fn def_to_str(did: def_id) -> ~str { fmt!(\"%d:%d\", did.crate, did.node) }\n \n-fn encode_ty_type_param_bounds(ebml_w: writer::Encoder, ecx: @encode_ctxt,\n+fn encode_ty_type_param_bounds(ebml_w: writer::Encoder, ecx: @EncodeContext,\n                                params: @~[ty::param_bounds]) {\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n@@ -182,7 +187,7 @@ fn encode_ty_type_param_bounds(ebml_w: writer::Encoder, ecx: @encode_ctxt,\n     }\n }\n \n-fn encode_type_param_bounds(ebml_w: writer::Encoder, ecx: @encode_ctxt,\n+fn encode_type_param_bounds(ebml_w: writer::Encoder, ecx: @EncodeContext,\n                             params: &[ty_param]) {\n     let ty_param_bounds =\n         @params.map(|param| ecx.tcx.ty_param_bounds.get(&param.id));\n@@ -196,7 +201,7 @@ fn encode_variant_id(ebml_w: writer::Encoder, vid: def_id) {\n     ebml_w.end_tag();\n }\n \n-pub fn write_type(ecx: @encode_ctxt, ebml_w: writer::Encoder, typ: ty::t) {\n+pub fn write_type(ecx: @EncodeContext, ebml_w: writer::Encoder, typ: ty::t) {\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n@@ -206,7 +211,7 @@ pub fn write_type(ecx: @encode_ctxt, ebml_w: writer::Encoder, typ: ty::t) {\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n-pub fn write_vstore(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n+pub fn write_vstore(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                     vstore: ty::vstore) {\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n@@ -217,13 +222,13 @@ pub fn write_vstore(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n     tyencode::enc_vstore(ebml_w.writer, ty_str_ctxt, vstore);\n }\n \n-fn encode_type(ecx: @encode_ctxt, ebml_w: writer::Encoder, typ: ty::t) {\n+fn encode_type(ecx: @EncodeContext, ebml_w: writer::Encoder, typ: ty::t) {\n     ebml_w.start_tag(tag_items_data_item_type);\n     write_type(ecx, ebml_w, typ);\n     ebml_w.end_tag();\n }\n \n-fn encode_symbol(ecx: @encode_ctxt, ebml_w: writer::Encoder, id: node_id) {\n+fn encode_symbol(ecx: @EncodeContext, ebml_w: writer::Encoder, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     let sym = match ecx.item_symbols.find(&id) {\n       Some(ref x) => (/*bad*/copy *x),\n@@ -236,14 +241,14 @@ fn encode_symbol(ecx: @encode_ctxt, ebml_w: writer::Encoder, id: node_id) {\n     ebml_w.end_tag();\n }\n \n-fn encode_discriminant(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n+fn encode_discriminant(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                        id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     ebml_w.writer.write(str::to_bytes(ecx.discrim_symbols.get(&id)));\n     ebml_w.end_tag();\n }\n \n-fn encode_disr_val(_ecx: @encode_ctxt, ebml_w: writer::Encoder,\n+fn encode_disr_val(_ecx: @EncodeContext, ebml_w: writer::Encoder,\n                    disr_val: int) {\n     ebml_w.start_tag(tag_disr_val);\n     ebml_w.writer.write(str::to_bytes(int::to_str(disr_val)));\n@@ -256,7 +261,7 @@ fn encode_parent_item(ebml_w: writer::Encoder, id: def_id) {\n     ebml_w.end_tag();\n }\n \n-fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n+fn encode_enum_variant_info(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                             id: node_id, variants: &[variant],\n                             path: &[ast_map::path_elt],\n                             index: @mut ~[entry<int>],\n@@ -266,7 +271,7 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n     let vi = ty::enum_variants(ecx.tcx,\n                                ast::def_id { crate: local_crate, node: id });\n     for variants.each |variant| {\n-        index.push({val: variant.node.id, pos: ebml_w.writer.tell()});\n+        index.push(entry {val: variant.node.id, pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n         encode_family(ebml_w, 'v');\n@@ -296,9 +301,9 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n     }\n }\n \n-fn encode_path(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n+fn encode_path(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                path: &[ast_map::path_elt], name: ast_map::path_elt) {\n-    fn encode_path_elt(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n+    fn encode_path_elt(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                        elt: ast_map::path_elt) {\n         let (tag, name) = match elt {\n           ast_map::path_mod(name) => (tag_path_elt_mod, name),\n@@ -317,7 +322,7 @@ fn encode_path(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n     }\n }\n \n-fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n+fn encode_info_for_mod(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                        md: _mod, id: node_id, path: &[ast_map::path_elt],\n                        name: ident) {\n     ebml_w.start_tag(tag_items_data_item);\n@@ -422,7 +427,7 @@ fn encode_method_sort(ebml_w: writer::Encoder, sort: char) {\n }\n \n /* Returns an index of items in this class */\n-fn encode_info_for_struct(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n+fn encode_info_for_struct(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                          path: &[ast_map::path_elt],\n                          fields: &[@struct_field],\n                          global_index: @mut~[entry<int>]) -> ~[entry<int>] {\n@@ -443,8 +448,8 @@ fn encode_info_for_struct(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         };\n \n         let id = field.node.id;\n-        index.push({val: id, pos: ebml_w.writer.tell()});\n-        global_index.push({val: id, pos: ebml_w.writer.tell()});\n+        index.push(entry {val: id, pos: ebml_w.writer.tell()});\n+        global_index.push(entry {val: id, pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_items_data_item);\n         debug!(\"encode_info_for_struct: doing %s %d\",\n                *tcx.sess.str_of(nm), id);\n@@ -460,7 +465,7 @@ fn encode_info_for_struct(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n }\n \n // This is for encoding info for ctors and dtors\n-fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n+fn encode_info_for_ctor(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                         id: node_id, ident: ident, path: &[ast_map::path_elt],\n                         item: Option<inlined_item>, tps: &[ty_param]) {\n         ebml_w.start_tag(tag_items_data_item);\n@@ -485,13 +490,13 @@ fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         ebml_w.end_tag();\n }\n \n-fn encode_info_for_struct_ctor(ecx: @encode_ctxt,\n+fn encode_info_for_struct_ctor(ecx: @EncodeContext,\n                                ebml_w: writer::Encoder,\n                                path: &[ast_map::path_elt],\n                                name: ast::ident,\n                                ctor_id: node_id,\n                                index: @mut ~[entry<int>]) {\n-    index.push({ val: ctor_id, pos: ebml_w.writer.tell() });\n+    index.push(entry { val: ctor_id, pos: ebml_w.writer.tell() });\n \n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(ctor_id));\n@@ -507,7 +512,7 @@ fn encode_info_for_struct_ctor(ecx: @encode_ctxt,\n     ebml_w.end_tag();\n }\n \n-fn encode_info_for_method(ecx: @encode_ctxt,\n+fn encode_info_for_method(ecx: @EncodeContext,\n                           ebml_w: writer::Encoder,\n                           impl_path: &[ast_map::path_elt],\n                           should_inline: bool,\n@@ -566,7 +571,7 @@ fn should_inline(attrs: &[attribute]) -> bool {\n }\n \n \n-fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n+fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                         item: @item, index: @mut ~[entry<int>],\n                         path: &[ast_map::path_elt]) {\n \n@@ -581,7 +586,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n \n     fn add_to_index_(item: @item, ebml_w: writer::Encoder,\n                      index: @mut ~[entry<int>]) {\n-        index.push({val: item.id, pos: ebml_w.writer.tell()});\n+        index.push(entry { val: item.id, pos: ebml_w.writer.tell() });\n     }\n     let add_to_index: &fn() = || add_to_index_(item, ebml_w, index);\n \n@@ -673,7 +678,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                                          struct_def.fields, index);\n         /* Encode the dtor */\n         do struct_def.dtor.iter |dtor| {\n-            index.push({val: dtor.node.id, pos: ebml_w.writer.tell()});\n+            index.push(entry {val: dtor.node.id, pos: ebml_w.writer.tell()});\n           encode_info_for_ctor(ecx,\n                                ebml_w,\n                                dtor.node.id,\n@@ -788,7 +793,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         impl_path += ~[ast_map::path_name(item.ident)];\n \n         for methods.each |m| {\n-            index.push({val: m.id, pos: ebml_w.writer.tell()});\n+            index.push(entry {val: m.id, pos: ebml_w.writer.tell()});\n             encode_info_for_method(ecx, ebml_w, impl_path,\n                                    should_inline(m.attrs),\n                                    item.id, *m,\n@@ -855,7 +860,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n             let ty_m = ast_util::trait_method_to_ty_method(*m);\n             if ty_m.self_ty.node != ast::sty_static { loop; }\n \n-            index.push({val: ty_m.id, pos: ebml_w.writer.tell()});\n+            index.push(entry { val: ty_m.id, pos: ebml_w.writer.tell() });\n \n             ebml_w.start_tag(tag_items_data_item);\n             encode_def_id(ebml_w, local_def(ty_m.id));\n@@ -874,7 +879,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n \n         // Finally, output all the provided methods as items.\n         for provided_methods.each |m| {\n-            index.push({val: m.id, pos: ebml_w.writer.tell()});\n+            index.push(entry { val: m.id, pos: ebml_w.writer.tell() });\n             encode_info_for_method(ecx, ebml_w, /*bad*/copy path,\n                                    true, item.id, *m, /*bad*/copy m.tps);\n         }\n@@ -883,14 +888,14 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n     }\n }\n \n-fn encode_info_for_foreign_item(ecx: @encode_ctxt,\n+fn encode_info_for_foreign_item(ecx: @EncodeContext,\n                                 ebml_w: writer::Encoder,\n                                 nitem: @foreign_item,\n                                 index: @mut ~[entry<int>],\n                                 +path: ast_map::path,\n                                 abi: foreign_abi) {\n     if !reachable(ecx, nitem.id) { return; }\n-    index.push({val: nitem.id, pos: ebml_w.writer.tell()});\n+    index.push(entry { val: nitem.id, pos: ebml_w.writer.tell() });\n \n     ebml_w.start_tag(tag_items_data_item);\n     match /*bad*/copy nitem.node {\n@@ -917,11 +922,11 @@ fn encode_info_for_foreign_item(ecx: @encode_ctxt,\n     ebml_w.end_tag();\n }\n \n-fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n+fn encode_info_for_items(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                          crate: &crate) -> ~[entry<int>] {\n     let index = @mut ~[];\n     ebml_w.start_tag(tag_items_data);\n-    index.push({val: crate_node_id, pos: ebml_w.writer.tell()});\n+    index.push(entry { val: crate_node_id, pos: ebml_w.writer.tell() });\n     encode_info_for_mod(ecx, ebml_w, crate.node.module,\n                         crate_node_id, ~[],\n                         syntax::parse::token::special_idents::invalid);\n@@ -1066,9 +1071,10 @@ fn encode_attributes(ebml_w: writer::Encoder, attrs: &[attribute]) {\n // metadata that Rust cares about for linking crates. This attribute requires\n // 'name' and 'vers' items, so if the user didn't provide them we will throw\n // them in anyway with default values.\n-fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: &crate) -> ~[attribute] {\n+fn synthesize_crate_attrs(ecx: @EncodeContext,\n+                          crate: &crate) -> ~[attribute] {\n \n-    fn synthesize_link_attr(ecx: @encode_ctxt, +items: ~[@meta_item]) ->\n+    fn synthesize_link_attr(ecx: @EncodeContext, +items: ~[@meta_item]) ->\n        attribute {\n \n         assert !ecx.link_meta.name.is_empty();\n@@ -1115,18 +1121,17 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: &crate) -> ~[attribute] {\n     return attrs;\n }\n \n-fn encode_crate_deps(ecx: @encode_ctxt,\n+fn encode_crate_deps(ecx: @EncodeContext,\n                      ebml_w: writer::Encoder,\n                      cstore: @mut cstore::CStore) {\n-    fn get_ordered_deps(ecx: @encode_ctxt, cstore: @mut cstore::CStore)\n+    fn get_ordered_deps(ecx: @EncodeContext, cstore: @mut cstore::CStore)\n                      -> ~[decoder::crate_dep] {\n-        type hashkv = @{key: crate_num, val: cstore::crate_metadata};\n         type numdep = decoder::crate_dep;\n \n         // Pull the cnums and name,vers,hash out of cstore\n         let mut deps = ~[];\n         do cstore::iter_crate_data(cstore) |key, val| {\n-            let dep = {cnum: key,\n+            let dep = decoder::crate_dep {cnum: key,\n                        name: ecx.tcx.sess.ident_of(/*bad*/ copy *val.name),\n                        vers: decoder::get_crate_vers(val.data),\n                        hash: decoder::get_crate_hash(val.data)};\n@@ -1158,7 +1163,7 @@ fn encode_crate_deps(ecx: @encode_ctxt,\n     ebml_w.end_tag();\n }\n \n-fn encode_lang_items(ecx: @encode_ctxt, ebml_w: writer::Encoder) {\n+fn encode_lang_items(ecx: @EncodeContext, ebml_w: writer::Encoder) {\n     ebml_w.start_tag(tag_lang_items);\n \n     for ecx.tcx.lang_items.each_item |def_id, i| {\n@@ -1182,7 +1187,7 @@ fn encode_lang_items(ecx: @encode_ctxt, ebml_w: writer::Encoder) {\n     ebml_w.end_tag();   // tag_lang_items\n }\n \n-fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n+fn encode_crate_dep(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                     dep: decoder::crate_dep) {\n     ebml_w.start_tag(tag_crate_dep);\n     ebml_w.start_tag(tag_crate_dep_name);\n@@ -1210,7 +1215,7 @@ pub const metadata_encoding_version : &[u8] = &[0x72, //'r' as u8,\n                                                 0x74, //'t' as u8,\n                                                 0, 0, 0, 1 ];\n \n-pub fn encode_metadata(parms: encode_parms, crate: &crate) -> ~[u8] {\n+pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n     let wr = @io::BytesWriter();\n     let mut stats = Stats {\n         inline_bytes: 0,\n@@ -1223,7 +1228,7 @@ pub fn encode_metadata(parms: encode_parms, crate: &crate) -> ~[u8] {\n         total_bytes: 0,\n         n_inlines: 0\n     };\n-    let ecx: @encode_ctxt = @encode_ctxt({\n+    let ecx = @EncodeContext {\n         diag: parms.diag,\n         tcx: parms.tcx,\n         stats: @mut stats,\n@@ -1235,7 +1240,7 @@ pub fn encode_metadata(parms: encode_parms, crate: &crate) -> ~[u8] {\n         cstore: parms.cstore,\n         encode_inlined_item: parms.encode_inlined_item,\n         type_abbrevs: ty::new_ty_hash()\n-     });\n+     };\n \n     let ebml_w = writer::Encoder(wr as io::Writer);\n "}, {"sha": "664a5e861af72558a0bfaf65d12d444f6741b37a", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -38,10 +38,12 @@ pub trait FileSearch {\n pub fn mk_filesearch(maybe_sysroot: Option<Path>,\n                      target_triple: &str,\n                      +addl_lib_search_paths: ~[Path]) -> FileSearch {\n-    type filesearch_impl = {sysroot: Path,\n-                            addl_lib_search_paths: ~[Path],\n-                            target_triple: ~str};\n-    impl FileSearch for filesearch_impl {\n+    struct FileSearchImpl {\n+        sysroot: Path,\n+        addl_lib_search_paths: ~[Path],\n+        target_triple: ~str\n+    }\n+    impl FileSearch for FileSearchImpl {\n         fn sysroot() -> Path { /*bad*/copy self.sysroot }\n         fn lib_search_paths() -> ~[Path] {\n             let mut paths = /*bad*/copy self.addl_lib_search_paths;\n@@ -69,9 +71,11 @@ pub fn mk_filesearch(maybe_sysroot: Option<Path>,\n \n     let sysroot = get_sysroot(maybe_sysroot);\n     debug!(\"using sysroot = %s\", sysroot.to_str());\n-    {sysroot: sysroot,\n-     addl_lib_search_paths: addl_lib_search_paths,\n-     target_triple: str::from_slice(target_triple)} as FileSearch\n+    FileSearchImpl {\n+        sysroot: sysroot,\n+        addl_lib_search_paths: addl_lib_search_paths,\n+        target_triple: str::from_slice(target_triple)\n+    } as FileSearch\n }\n \n pub fn search<T: Copy>(filesearch: FileSearch, pick: pick<T>) -> Option<T> {"}, {"sha": "da7f3635c0e2425905ebfbec5d9dce8aac570982", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -43,19 +43,19 @@ pub enum os {\n     os_freebsd\n }\n \n-pub type ctxt = {\n+pub struct Context {\n     diag: span_handler,\n     filesearch: FileSearch,\n     span: span,\n     ident: ast::ident,\n     metas: ~[@ast::meta_item],\n     hash: @~str,\n     os: os,\n-    static: bool,\n+    is_static: bool,\n     intr: @ident_interner\n-};\n+}\n \n-pub fn load_library_crate(cx: ctxt) -> {ident: ~str, data: @~[u8]} {\n+pub fn load_library_crate(cx: Context) -> (~str, @~[u8]) {\n     match find_library_crate(cx) {\n       Some(ref t) => return (/*bad*/copy *t),\n       None => {\n@@ -66,33 +66,31 @@ pub fn load_library_crate(cx: ctxt) -> {ident: ~str, data: @~[u8]} {\n     }\n }\n \n-fn find_library_crate(cx: ctxt) -> Option<{ident: ~str, data: @~[u8]}> {\n+fn find_library_crate(cx: Context) -> Option<(~str, @~[u8])> {\n     attr::require_unique_names(cx.diag, cx.metas);\n     find_library_crate_aux(cx, libname(cx), cx.filesearch)\n }\n \n-fn libname(cx: ctxt) -> {prefix: ~str, suffix: ~str} {\n-    if cx.static { return {prefix: ~\"lib\", suffix: ~\".rlib\"}; }\n+fn libname(cx: Context) -> (~str, ~str) {\n+    if cx.is_static { return (~\"lib\", ~\".rlib\"); }\n     let (dll_prefix, dll_suffix) = match cx.os {\n         os_win32 => (win32::DLL_PREFIX, win32::DLL_SUFFIX),\n         os_macos => (macos::DLL_PREFIX, macos::DLL_SUFFIX),\n         os_linux => (linux::DLL_PREFIX, linux::DLL_SUFFIX),\n         os_android => (android::DLL_PREFIX, android::DLL_SUFFIX),\n         os_freebsd => (freebsd::DLL_PREFIX, freebsd::DLL_SUFFIX),\n     };\n-    return {\n-        prefix: str::from_slice(dll_prefix),\n-        suffix: str::from_slice(dll_suffix)\n-    }\n+\n+    (str::from_slice(dll_prefix), str::from_slice(dll_suffix))\n }\n \n-fn find_library_crate_aux(cx: ctxt,\n-                          nn: {prefix: ~str, suffix: ~str},\n+fn find_library_crate_aux(cx: Context,\n+                          (prefix, suffix): (~str, ~str),\n                           filesearch: filesearch::FileSearch) ->\n-   Option<{ident: ~str, data: @~[u8]}> {\n+   Option<(~str, @~[u8])> {\n     let crate_name = crate_name_from_metas(/*bad*/copy cx.metas);\n-    let prefix: ~str = nn.prefix + *crate_name + ~\"-\";\n-    let suffix: ~str = /*bad*/copy nn.suffix;\n+    let prefix: ~str = prefix + *crate_name + ~\"-\";\n+    let suffix: ~str = /*bad*/copy suffix;\n \n     let mut matches = ~[];\n     filesearch::search(filesearch, |path| {\n@@ -112,7 +110,7 @@ fn find_library_crate_aux(cx: ctxt,\n                     option::None::<()>\n                 } else {\n                     debug!(\"found %s with matching metadata\", path.to_str());\n-                    matches.push({ident: path.to_str(), data: cvec});\n+                    matches.push((path.to_str(), cvec));\n                     option::None::<()>\n                 }\n               }\n@@ -132,9 +130,9 @@ fn find_library_crate_aux(cx: ctxt,\n         cx.diag.span_err(\n             cx.span, fmt!(\"multiple matching crates for `%s`\", *crate_name));\n         cx.diag.handler().note(~\"candidates:\");\n-        for matches.each |match_| {\n-            cx.diag.handler().note(fmt!(\"path: %s\", match_.ident));\n-            let attrs = decoder::get_crate_attributes(match_.data);\n+        for matches.each |&(ident, data)| {\n+            cx.diag.handler().note(fmt!(\"path: %s\", ident));\n+            let attrs = decoder::get_crate_attributes(data);\n             note_linkage_attrs(cx.intr, cx.diag, attrs);\n         }\n         cx.diag.handler().abort_if_errors();"}, {"sha": "12d998ee9448faa7e96104917910827cef7e7ba9", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -39,7 +39,11 @@ pub struct ctxt {\n // Compact string representation for ty.t values. API ty_str & parse_from_str.\n // Extra parameters are for converting to/from def_ids in the string rep.\n // Whatever format you choose should not contain pipe characters.\n-pub type ty_abbrev = {pos: uint, len: uint, s: @~str};\n+pub struct ty_abbrev {\n+    pos: uint,\n+    len: uint,\n+    s: @~str\n+}\n \n pub enum abbrev_ctxt {\n     ac_no_abbrevs,\n@@ -100,7 +104,7 @@ pub fn enc_ty(w: io::Writer, cx: @ctxt, t: ty::t) {\n                 // I.e. it's actually an abbreviation.\n                 let s = ~\"#\" + uint::to_str_radix(pos, 16u) + ~\":\" +\n                     uint::to_str_radix(len, 16u) + ~\"#\";\n-                let a = {pos: pos, len: len, s: @s};\n+                let a = ty_abbrev { pos: pos, len: len, s: @s };\n                 abbrevs.insert(t, a);\n             }\n             return;"}, {"sha": "9440c951be5e910d2c03e32c03c4671d3febe432", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 83, "deletions": 79, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -62,34 +62,30 @@ pub struct Maps {\n     capture_map: middle::moves::CaptureMap,\n }\n \n-type decode_ctxt = @{\n-    cdata: cstore::crate_metadata,\n+struct DecodeContext {\n+    cdata: @cstore::crate_metadata,\n     tcx: ty::ctxt,\n     maps: Maps\n-};\n+}\n \n-type extended_decode_ctxt_ = {\n-    dcx: decode_ctxt,\n+struct ExtendedDecodeContext {\n+    dcx: @DecodeContext,\n     from_id_range: ast_util::id_range,\n     to_id_range: ast_util::id_range\n-};\n-\n-enum extended_decode_ctxt {\n-    extended_decode_ctxt_(@extended_decode_ctxt_)\n }\n \n trait tr {\n-    fn tr(xcx: extended_decode_ctxt) -> Self;\n+    fn tr(xcx: @ExtendedDecodeContext) -> Self;\n }\n \n trait tr_intern {\n-    fn tr_intern(xcx: extended_decode_ctxt) -> ast::def_id;\n+    fn tr_intern(xcx: @ExtendedDecodeContext) -> ast::def_id;\n }\n \n // ______________________________________________________________________\n // Top-level methods.\n \n-pub fn encode_inlined_item(ecx: @e::encode_ctxt,\n+pub fn encode_inlined_item(ecx: @e::EncodeContext,\n                            ebml_w: writer::Encoder,\n                            path: &[ast_map::path_elt],\n                            ii: ast::inlined_item,\n@@ -112,13 +108,17 @@ pub fn encode_inlined_item(ecx: @e::encode_ctxt,\n            ebml_w.writer.tell());\n }\n \n-pub fn decode_inlined_item(cdata: cstore::crate_metadata,\n+pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n                            tcx: ty::ctxt,\n                            maps: Maps,\n                            +path: ast_map::path,\n                            par_doc: ebml::Doc)\n                         -> Option<ast::inlined_item> {\n-    let dcx = @{cdata: cdata, tcx: tcx, maps: maps};\n+    let dcx = @DecodeContext {\n+        cdata: cdata,\n+        tcx: tcx,\n+        maps: maps\n+    };\n     match par_doc.opt_child(c::tag_ast) {\n       None => None,\n       Some(ast_doc) => {\n@@ -127,9 +127,11 @@ pub fn decode_inlined_item(cdata: cstore::crate_metadata,\n         let ast_dsr = &reader::Decoder(ast_doc);\n         let from_id_range = Decodable::decode(ast_dsr);\n         let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n-        let xcx = extended_decode_ctxt_(@{dcx: dcx,\n-                                          from_id_range: from_id_range,\n-                                          to_id_range: to_id_range});\n+        let xcx = @ExtendedDecodeContext {\n+            dcx: dcx,\n+            from_id_range: from_id_range,\n+            to_id_range: to_id_range\n+        };\n         let raw_ii = decode_ast(ast_doc);\n         let ii = renumber_ast(xcx, raw_ii);\n         debug!(\"Fn named: %s\", *tcx.sess.str_of(ii.ident()));\n@@ -165,8 +167,8 @@ fn reserve_id_range(sess: Session,\n     ast_util::id_range { min: to_id_min, max: to_id_min }\n }\n \n-impl extended_decode_ctxt {\n-    fn tr_id(id: ast::node_id) -> ast::node_id {\n+impl ExtendedDecodeContext {\n+    fn tr_id(&self, id: ast::node_id) -> ast::node_id {\n         /*!\n          *\n          * Translates an internal id, meaning a node id that is known\n@@ -182,7 +184,7 @@ impl extended_decode_ctxt {\n         assert !ast_util::empty(self.from_id_range);\n         (id - self.from_id_range.min + self.to_id_range.min)\n     }\n-    fn tr_def_id(did: ast::def_id) -> ast::def_id {\n+    fn tr_def_id(&self, did: ast::def_id) -> ast::def_id {\n         /*!\n          *\n          * Translates an EXTERNAL def-id, converting the crate number\n@@ -207,7 +209,7 @@ impl extended_decode_ctxt {\n \n         decoder::translate_def_id(self.dcx.cdata, did)\n     }\n-    fn tr_intern_def_id(did: ast::def_id) -> ast::def_id {\n+    fn tr_intern_def_id(&self, did: ast::def_id) -> ast::def_id {\n         /*!\n          *\n          * Translates an INTERNAL def-id, meaning a def-id that is\n@@ -219,25 +221,25 @@ impl extended_decode_ctxt {\n         assert did.crate == ast::local_crate;\n         ast::def_id { crate: ast::local_crate, node: self.tr_id(did.node) }\n     }\n-    fn tr_span(_span: span) -> span {\n+    fn tr_span(&self, _span: span) -> span {\n         codemap::dummy_sp() // FIXME (#1972): handle span properly\n     }\n }\n \n impl tr_intern for ast::def_id {\n-    fn tr_intern(xcx: extended_decode_ctxt) -> ast::def_id {\n+    fn tr_intern(xcx: @ExtendedDecodeContext) -> ast::def_id {\n         xcx.tr_intern_def_id(self)\n     }\n }\n \n impl tr for ast::def_id {\n-    fn tr(xcx: extended_decode_ctxt) -> ast::def_id {\n+    fn tr(xcx: @ExtendedDecodeContext) -> ast::def_id {\n         xcx.tr_def_id(self)\n     }\n }\n \n impl tr for span {\n-    fn tr(xcx: extended_decode_ctxt) -> span {\n+    fn tr(xcx: @ExtendedDecodeContext) -> span {\n         xcx.tr_span(self)\n     }\n }\n@@ -253,12 +255,12 @@ impl<S: serialize::Encoder> def_id_encoder_helpers for S {\n }\n \n trait def_id_decoder_helpers {\n-    fn read_def_id(xcx: extended_decode_ctxt) -> ast::def_id;\n+    fn read_def_id(xcx: @ExtendedDecodeContext) -> ast::def_id;\n }\n \n impl<D: serialize::Decoder> def_id_decoder_helpers for D {\n \n-    fn read_def_id(xcx: extended_decode_ctxt) -> ast::def_id {\n+    fn read_def_id(xcx: @ExtendedDecodeContext) -> ast::def_id {\n         let did: ast::def_id = Decodable::decode(&self);\n         did.tr(xcx)\n     }\n@@ -351,7 +353,7 @@ fn decode_ast(par_doc: ebml::Doc) -> ast::inlined_item {\n     Decodable::decode(d)\n }\n \n-fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n+fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n     -> ast::inlined_item {\n     let fld = fold::make_fold(@fold::AstFoldFns{\n         new_id: |a| xcx.tr_id(a),\n@@ -396,14 +398,14 @@ fn encode_def(ebml_w: writer::Encoder, def: ast::def) {\n     def.encode(&ebml_w)\n }\n \n-fn decode_def(xcx: extended_decode_ctxt, doc: ebml::Doc) -> ast::def {\n+fn decode_def(xcx: @ExtendedDecodeContext, doc: ebml::Doc) -> ast::def {\n     let dsr = &reader::Decoder(doc);\n     let def: ast::def = Decodable::decode(dsr);\n     def.tr(xcx)\n }\n \n impl tr for ast::def {\n-    fn tr(xcx: extended_decode_ctxt) -> ast::def {\n+    fn tr(xcx: @ExtendedDecodeContext) -> ast::def {\n         match self {\n           ast::def_fn(did, p) => { ast::def_fn(did.tr(xcx), p) }\n           ast::def_static_method(did, did2_opt, p) => {\n@@ -448,7 +450,7 @@ impl tr for ast::def {\n // Encoding and decoding of adjustment information\n \n impl tr for ty::AutoAdjustment {\n-    fn tr(xcx: extended_decode_ctxt) -> ty::AutoAdjustment {\n+    fn tr(xcx: @ExtendedDecodeContext) -> ty::AutoAdjustment {\n         ty::AutoAdjustment {\n             autoderefs: self.autoderefs,\n             autoref: self.autoref.map(|ar| ar.tr(xcx)),\n@@ -457,7 +459,7 @@ impl tr for ty::AutoAdjustment {\n }\n \n impl tr for ty::AutoRef {\n-    fn tr(xcx: extended_decode_ctxt) -> ty::AutoRef {\n+    fn tr(xcx: @ExtendedDecodeContext) -> ty::AutoRef {\n         ty::AutoRef {\n             kind: self.kind,\n             region: self.region.tr(xcx),\n@@ -467,7 +469,7 @@ impl tr for ty::AutoRef {\n }\n \n impl tr for ty::Region {\n-    fn tr(xcx: extended_decode_ctxt) -> ty::Region {\n+    fn tr(xcx: @ExtendedDecodeContext) -> ty::Region {\n         match self {\n             ty::re_bound(br) => ty::re_bound(br.tr(xcx)),\n             ty::re_free(id, br) => ty::re_free(xcx.tr_id(id), br.tr(xcx)),\n@@ -478,7 +480,7 @@ impl tr for ty::Region {\n }\n \n impl tr for ty::bound_region {\n-    fn tr(xcx: extended_decode_ctxt) -> ty::bound_region {\n+    fn tr(xcx: @ExtendedDecodeContext) -> ty::bound_region {\n         match self {\n             ty::br_anon(_) | ty::br_named(_) | ty::br_self |\n             ty::br_fresh(_) => self,\n@@ -496,18 +498,18 @@ fn encode_freevar_entry(ebml_w: writer::Encoder, fv: @freevar_entry) {\n }\n \n trait ebml_decoder_helper {\n-    fn read_freevar_entry(xcx: extended_decode_ctxt) -> freevar_entry;\n+    fn read_freevar_entry(xcx: @ExtendedDecodeContext) -> freevar_entry;\n }\n \n impl ebml_decoder_helper for reader::Decoder {\n-    fn read_freevar_entry(xcx: extended_decode_ctxt) -> freevar_entry {\n+    fn read_freevar_entry(xcx: @ExtendedDecodeContext) -> freevar_entry {\n         let fv: freevar_entry = Decodable::decode(&self);\n         fv.tr(xcx)\n     }\n }\n \n impl tr for freevar_entry {\n-    fn tr(xcx: extended_decode_ctxt) -> freevar_entry {\n+    fn tr(xcx: @ExtendedDecodeContext) -> freevar_entry {\n         freevar_entry {\n             def: self.def.tr(xcx),\n             span: self.span.tr(xcx),\n@@ -519,18 +521,18 @@ impl tr for freevar_entry {\n // Encoding and decoding of CaptureVar information\n \n trait capture_var_helper {\n-    fn read_capture_var(xcx: extended_decode_ctxt) -> moves::CaptureVar;\n+    fn read_capture_var(xcx: @ExtendedDecodeContext) -> moves::CaptureVar;\n }\n \n impl capture_var_helper for reader::Decoder {\n-    fn read_capture_var(xcx: extended_decode_ctxt) -> moves::CaptureVar {\n+    fn read_capture_var(xcx: @ExtendedDecodeContext) -> moves::CaptureVar {\n         let cvar: moves::CaptureVar = Decodable::decode(&self);\n         cvar.tr(xcx)\n     }\n }\n \n impl tr for moves::CaptureVar {\n-    fn tr(xcx: extended_decode_ctxt) -> moves::CaptureVar {\n+    fn tr(xcx: @ExtendedDecodeContext) -> moves::CaptureVar {\n         moves::CaptureVar {\n             def: self.def.tr(xcx),\n             span: self.span.tr(xcx),\n@@ -543,10 +545,10 @@ impl tr for moves::CaptureVar {\n // Encoding and decoding of method_map_entry\n \n trait read_method_map_entry_helper {\n-    fn read_method_map_entry(xcx: extended_decode_ctxt) -> method_map_entry;\n+    fn read_method_map_entry(xcx: @ExtendedDecodeContext) -> method_map_entry;\n }\n \n-fn encode_method_map_entry(ecx: @e::encode_ctxt,\n+fn encode_method_map_entry(ecx: @e::EncodeContext,\n                               ebml_w: writer::Encoder,\n                               mme: method_map_entry) {\n     do ebml_w.emit_rec {\n@@ -563,7 +565,8 @@ fn encode_method_map_entry(ecx: @e::encode_ctxt,\n }\n \n impl read_method_map_entry_helper for reader::Decoder {\n-    fn read_method_map_entry(xcx: extended_decode_ctxt) -> method_map_entry {\n+    fn read_method_map_entry(xcx: @ExtendedDecodeContext)\n+        -> method_map_entry {\n         do self.read_rec {\n             method_map_entry {\n                 self_arg: self.read_field(~\"self_arg\", 0u, || {\n@@ -584,7 +587,7 @@ impl read_method_map_entry_helper for reader::Decoder {\n }\n \n impl tr for method_origin {\n-    fn tr(xcx: extended_decode_ctxt) -> method_origin {\n+    fn tr(xcx: @ExtendedDecodeContext) -> method_origin {\n         match self {\n           typeck::method_static(did) => {\n               typeck::method_static(did.tr(xcx))\n@@ -613,7 +616,7 @@ impl tr for method_origin {\n // ______________________________________________________________________\n // Encoding and decoding vtable_res\n \n-fn encode_vtable_res(ecx: @e::encode_ctxt,\n+fn encode_vtable_res(ecx: @e::EncodeContext,\n                      ebml_w: writer::Encoder,\n                      dr: typeck::vtable_res) {\n     // can't autogenerate this code because automatic code of\n@@ -625,7 +628,7 @@ fn encode_vtable_res(ecx: @e::encode_ctxt,\n     }\n }\n \n-fn encode_vtable_origin(ecx: @e::encode_ctxt,\n+fn encode_vtable_origin(ecx: @e::EncodeContext,\n                       ebml_w: writer::Encoder,\n                       vtable_origin: typeck::vtable_origin) {\n     do ebml_w.emit_enum(~\"vtable_origin\") {\n@@ -669,16 +672,17 @@ fn encode_vtable_origin(ecx: @e::encode_ctxt,\n }\n \n trait vtable_decoder_helpers {\n-    fn read_vtable_res(xcx: extended_decode_ctxt) -> typeck::vtable_res;\n-    fn read_vtable_origin(xcx: extended_decode_ctxt) -> typeck::vtable_origin;\n+    fn read_vtable_res(xcx: @ExtendedDecodeContext) -> typeck::vtable_res;\n+    fn read_vtable_origin(xcx: @ExtendedDecodeContext)\n+        -> typeck::vtable_origin;\n }\n \n impl vtable_decoder_helpers for reader::Decoder {\n-    fn read_vtable_res(xcx: extended_decode_ctxt) -> typeck::vtable_res {\n+    fn read_vtable_res(xcx: @ExtendedDecodeContext) -> typeck::vtable_res {\n         @self.read_to_vec(|| self.read_vtable_origin(xcx) )\n     }\n \n-    fn read_vtable_origin(xcx: extended_decode_ctxt)\n+    fn read_vtable_origin(xcx: @ExtendedDecodeContext)\n         -> typeck::vtable_origin {\n         do self.read_enum(~\"vtable_origin\") {\n             do self.read_enum_variant |i| {\n@@ -731,7 +735,7 @@ trait get_ty_str_ctxt {\n     fn ty_str_ctxt() -> @tyencode::ctxt;\n }\n \n-impl get_ty_str_ctxt for @e::encode_ctxt {\n+impl get_ty_str_ctxt for @e::EncodeContext {\n     fn ty_str_ctxt() -> @tyencode::ctxt {\n         @tyencode::ctxt {diag: self.tcx.sess.diagnostic(),\n                         ds: e::def_to_str,\n@@ -742,46 +746,46 @@ impl get_ty_str_ctxt for @e::encode_ctxt {\n }\n \n trait ebml_writer_helpers {\n-    fn emit_arg(ecx: @e::encode_ctxt, arg: ty::arg);\n-    fn emit_ty(ecx: @e::encode_ctxt, ty: ty::t);\n-    fn emit_vstore(ecx: @e::encode_ctxt, vstore: ty::vstore);\n-    fn emit_tys(ecx: @e::encode_ctxt, tys: ~[ty::t]);\n-    fn emit_bounds(ecx: @e::encode_ctxt, bs: ty::param_bounds);\n-    fn emit_tpbt(ecx: @e::encode_ctxt, tpbt: ty::ty_param_bounds_and_ty);\n+    fn emit_arg(ecx: @e::EncodeContext, arg: ty::arg);\n+    fn emit_ty(ecx: @e::EncodeContext, ty: ty::t);\n+    fn emit_vstore(ecx: @e::EncodeContext, vstore: ty::vstore);\n+    fn emit_tys(ecx: @e::EncodeContext, tys: ~[ty::t]);\n+    fn emit_bounds(ecx: @e::EncodeContext, bs: ty::param_bounds);\n+    fn emit_tpbt(ecx: @e::EncodeContext, tpbt: ty::ty_param_bounds_and_ty);\n }\n \n impl ebml_writer_helpers for writer::Encoder {\n-    fn emit_ty(ecx: @e::encode_ctxt, ty: ty::t) {\n+    fn emit_ty(ecx: @e::EncodeContext, ty: ty::t) {\n         do self.emit_opaque {\n             e::write_type(ecx, self, ty)\n         }\n     }\n \n-    fn emit_vstore(ecx: @e::encode_ctxt, vstore: ty::vstore) {\n+    fn emit_vstore(ecx: @e::EncodeContext, vstore: ty::vstore) {\n         do self.emit_opaque {\n             e::write_vstore(ecx, self, vstore)\n         }\n     }\n \n-    fn emit_arg(ecx: @e::encode_ctxt, arg: ty::arg) {\n+    fn emit_arg(ecx: @e::EncodeContext, arg: ty::arg) {\n         do self.emit_opaque {\n             tyencode::enc_arg(self.writer, ecx.ty_str_ctxt(), arg);\n         }\n     }\n \n-    fn emit_tys(ecx: @e::encode_ctxt, tys: ~[ty::t]) {\n+    fn emit_tys(ecx: @e::EncodeContext, tys: ~[ty::t]) {\n         do self.emit_from_vec(tys) |ty| {\n             self.emit_ty(ecx, *ty)\n         }\n     }\n \n-    fn emit_bounds(ecx: @e::encode_ctxt, bs: ty::param_bounds) {\n+    fn emit_bounds(ecx: @e::EncodeContext, bs: ty::param_bounds) {\n         do self.emit_opaque {\n             tyencode::enc_bounds(self.writer, ecx.ty_str_ctxt(), bs)\n         }\n     }\n \n-    fn emit_tpbt(ecx: @e::encode_ctxt, tpbt: ty::ty_param_bounds_and_ty) {\n+    fn emit_tpbt(ecx: @e::EncodeContext, tpbt: ty::ty_param_bounds_and_ty) {\n         do self.emit_rec {\n             do self.emit_field(~\"bounds\", 0) {\n                 do self.emit_from_vec(*tpbt.bounds) |bs| {\n@@ -813,7 +817,7 @@ impl write_tag_and_id for writer::Encoder {\n     }\n }\n \n-fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n+fn encode_side_tables_for_ii(ecx: @e::EncodeContext,\n                              maps: Maps,\n                              ebml_w: writer::Encoder,\n                              ii: ast::inlined_item) {\n@@ -830,7 +834,7 @@ fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n     }\n }\n \n-fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n+fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n                              maps: Maps,\n                              ebml_w: writer::Encoder,\n                              id: ast::node_id) {\n@@ -989,27 +993,27 @@ impl doc_decoder_helpers for ebml::Doc {\n }\n \n trait ebml_decoder_decoder_helpers {\n-    fn read_arg(xcx: extended_decode_ctxt) -> ty::arg;\n-    fn read_ty(xcx: extended_decode_ctxt) -> ty::t;\n-    fn read_tys(xcx: extended_decode_ctxt) -> ~[ty::t];\n-    fn read_bounds(xcx: extended_decode_ctxt) -> @~[ty::param_bound];\n-    fn read_ty_param_bounds_and_ty(xcx: extended_decode_ctxt)\n+    fn read_arg(xcx: @ExtendedDecodeContext) -> ty::arg;\n+    fn read_ty(xcx: @ExtendedDecodeContext) -> ty::t;\n+    fn read_tys(xcx: @ExtendedDecodeContext) -> ~[ty::t];\n+    fn read_bounds(xcx: @ExtendedDecodeContext) -> @~[ty::param_bound];\n+    fn read_ty_param_bounds_and_ty(xcx: @ExtendedDecodeContext)\n                                 -> ty::ty_param_bounds_and_ty;\n-    fn convert_def_id(xcx: extended_decode_ctxt,\n+    fn convert_def_id(xcx: @ExtendedDecodeContext,\n                       source: DefIdSource,\n                       did: ast::def_id) -> ast::def_id;\n }\n \n impl ebml_decoder_decoder_helpers for reader::Decoder {\n-    fn read_arg(xcx: extended_decode_ctxt) -> ty::arg {\n+    fn read_arg(xcx: @ExtendedDecodeContext) -> ty::arg {\n         do self.read_opaque |doc| {\n             tydecode::parse_arg_data(\n                 doc.data, xcx.dcx.cdata.cnum, doc.start, xcx.dcx.tcx,\n                 |s, a| self.convert_def_id(xcx, s, a))\n         }\n     }\n \n-    fn read_ty(xcx: extended_decode_ctxt) -> ty::t {\n+    fn read_ty(xcx: @ExtendedDecodeContext) -> ty::t {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n         // context.  However, we do not bother, because region types\n@@ -1036,23 +1040,23 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         }\n     }\n \n-    fn read_tys(xcx: extended_decode_ctxt) -> ~[ty::t] {\n+    fn read_tys(xcx: @ExtendedDecodeContext) -> ~[ty::t] {\n         self.read_to_vec(|| self.read_ty(xcx) )\n     }\n \n-    fn read_bounds(xcx: extended_decode_ctxt) -> @~[ty::param_bound] {\n+    fn read_bounds(xcx: @ExtendedDecodeContext) -> @~[ty::param_bound] {\n         do self.read_opaque |doc| {\n             tydecode::parse_bounds_data(\n                 doc.data, doc.start, xcx.dcx.cdata.cnum, xcx.dcx.tcx,\n                 |s, a| self.convert_def_id(xcx, s, a))\n         }\n     }\n \n-    fn read_ty_param_bounds_and_ty(xcx: extended_decode_ctxt)\n+    fn read_ty_param_bounds_and_ty(xcx: @ExtendedDecodeContext)\n         -> ty::ty_param_bounds_and_ty\n     {\n         do self.read_rec {\n-            {\n+            ty::ty_param_bounds_and_ty {\n                 bounds: self.read_field(~\"bounds\", 0u, || {\n                     @self.read_to_vec(|| self.read_bounds(xcx) )\n                 }),\n@@ -1066,7 +1070,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         }\n     }\n \n-    fn convert_def_id(xcx: extended_decode_ctxt,\n+    fn convert_def_id(xcx: @ExtendedDecodeContext,\n                       source: tydecode::DefIdSource,\n                       did: ast::def_id) -> ast::def_id {\n         /*!\n@@ -1092,7 +1096,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n     }\n }\n \n-fn decode_side_tables(xcx: extended_decode_ctxt,\n+fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                       ast_doc: ebml::Doc) {\n     let dcx = xcx.dcx;\n     let tbl_doc = ast_doc[c::tag_table as uint];"}, {"sha": "8519439ee934c35f350660158b9d1649603a1f5c", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -21,7 +21,7 @@ use core::prelude::*;\n \n use middle::moves;\n use middle::borrowck::{Loan, bckerr, BorrowckCtxt, inherent_mutability};\n-use middle::borrowck::{req_maps, root_map_key, save_and_restore_managed};\n+use middle::borrowck::{ReqMaps, root_map_key, save_and_restore_managed};\n use middle::borrowck::{MoveError, MoveOk, MoveFromIllegalCmt};\n use middle::borrowck::{MoveWhileBorrowed};\n use middle::mem_categorization::{cat_arg, cat_binding, cat_comp, cat_deref};\n@@ -45,7 +45,7 @@ use syntax::visit;\n \n struct CheckLoanCtxt {\n     bccx: @BorrowckCtxt,\n-    req_maps: req_maps,\n+    req_maps: ReqMaps,\n \n     reported: HashMap<ast::node_id, ()>,\n \n@@ -66,7 +66,7 @@ enum purity_cause {\n }\n \n pub fn check_loans(bccx: @BorrowckCtxt,\n-                   req_maps: req_maps,\n+                   req_maps: ReqMaps,\n                    crate: @ast::crate) {\n     let clcx = @mut CheckLoanCtxt {\n         bccx: bccx,"}, {"sha": "546e9359a32d9da7b4fc2e295b2acf17068f29be", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -22,7 +22,7 @@ use middle::borrowck::preserve::{PreserveCondition, PcOk, PcIfPure};\n use middle::borrowck::{Loan, bckerr, bckres, BorrowckCtxt, err_mutbl};\n use middle::borrowck::{LoanKind, TotalFreeze, PartialFreeze,\n                        TotalTake, PartialTake, Immobile};\n-use middle::borrowck::{req_maps};\n+use middle::borrowck::ReqMaps;\n use middle::borrowck::loan;\n use middle::mem_categorization::{cat_binding, cat_discr, cmt, comp_variant};\n use middle::mem_categorization::{mem_categorization_ctxt};\n@@ -47,7 +47,7 @@ use syntax::visit;\n ///\n /// - `bccx`: the the borrow check context\n /// - `req_maps`: the maps computed by `gather_loans()`, see def'n of the\n-///   type `req_maps` for more info\n+///   struct `ReqMaps` for more info\n /// - `item_ub`: the id of the block for the enclosing fn/method item\n /// - `root_ub`: the id of the outermost block for which we can root\n ///   an `@T`.  This is the id of the innermost enclosing\n@@ -73,16 +73,16 @@ use syntax::visit;\n /// because it would have to be rooted for a region greater than `root_ub`.\n struct GatherLoanCtxt {\n     bccx: @BorrowckCtxt,\n-    req_maps: req_maps,\n+    req_maps: ReqMaps,\n     item_ub: ast::node_id,\n     root_ub: ast::node_id,\n     ignore_adjustments: LinearSet<ast::node_id>\n }\n \n-pub fn gather_loans(bccx: @BorrowckCtxt, crate: @ast::crate) -> req_maps {\n+pub fn gather_loans(bccx: @BorrowckCtxt, crate: @ast::crate) -> ReqMaps {\n     let glcx = @mut GatherLoanCtxt {\n         bccx: bccx,\n-        req_maps: {req_loan_map: HashMap(), pure_map: HashMap()},\n+        req_maps: ReqMaps { req_loan_map: HashMap(), pure_map: HashMap() },\n         item_ub: 0,\n         root_ub: 0,\n         ignore_adjustments: LinearSet::new()"}, {"sha": "2c72544845728d1b49d2c75fdf4bbc254c228911", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -400,20 +400,22 @@ pub enum LoanKind {\n }\n \n /// a complete record of a loan that was granted\n-pub struct Loan {lp: @loan_path,\n-                 cmt: cmt,\n-                 kind: LoanKind}\n+pub struct Loan {\n+    lp: @loan_path,\n+    cmt: cmt,\n+    kind: LoanKind\n+}\n \n /// maps computed by `gather_loans` that are then used by `check_loans`\n ///\n /// - `req_loan_map`: map from each block/expr to the required loans needed\n ///   for the duration of that block/expr\n /// - `pure_map`: map from block/expr that must be pure to the error message\n ///   that should be reported if they are not pure\n-pub type req_maps = {\n+pub struct ReqMaps {\n     req_loan_map: HashMap<ast::node_id, @DVec<Loan>>,\n     pure_map: HashMap<ast::node_id, bckerr>\n-};\n+}\n \n pub fn save_and_restore<T:Copy,U>(save_and_restore_t: &mut T,\n                                   f: &fn() -> U) -> U {"}, {"sha": "34665fe7b7d2744734cb51df4c62f7938ed67e7e", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -14,34 +14,49 @@ use middle::ty;\n use syntax::ast::*;\n use syntax::visit;\n \n-pub type ctx = {in_loop: bool, can_ret: bool};\n+pub struct Context {\n+    in_loop: bool,\n+    can_ret: bool\n+}\n \n pub fn check_crate(tcx: ty::ctxt, crate: @crate) {\n     visit::visit_crate(*crate,\n-                       {in_loop: false, can_ret: true},\n+                       Context { in_loop: false, can_ret: true },\n                        visit::mk_vt(@visit::Visitor {\n         visit_item: |i, _cx, v| {\n-            visit::visit_item(i, {in_loop: false, can_ret: true}, v);\n+            visit::visit_item(i, Context {\n+                                    in_loop: false,\n+                                    can_ret: true\n+                                 }, v);\n         },\n-        visit_expr: |e: @expr, cx: ctx, v: visit::vt<ctx>| {\n+        visit_expr: |e: @expr, cx: Context, v: visit::vt<Context>| {\n             match e.node {\n               expr_while(e, ref b) => {\n                 (v.visit_expr)(e, cx, v);\n-                (v.visit_block)((*b), {in_loop: true,.. cx}, v);\n+                (v.visit_block)((*b), Context { in_loop: true,.. cx }, v);\n               }\n               expr_loop(ref b, _) => {\n-                (v.visit_block)((*b), {in_loop: true,.. cx}, v);\n+                (v.visit_block)((*b), Context { in_loop: true,.. cx }, v);\n               }\n               expr_fn(*) => {\n-                visit::visit_expr(e, {in_loop: false, can_ret: true}, v);\n+                visit::visit_expr(e, Context {\n+                                        in_loop: false,\n+                                        can_ret: true\n+                                     }, v);\n               }\n               expr_fn_block(_, ref b) => {\n-                (v.visit_block)((*b), {in_loop: false, can_ret: false}, v);\n+                (v.visit_block)((*b), Context {\n+                                         in_loop: false,\n+                                         can_ret: false\n+                                      }, v);\n               }\n               expr_loop_body(@expr {node: expr_fn_block(_, ref b), _}) => {\n                 let sigil = ty::ty_closure_sigil(ty::expr_ty(tcx, e));\n                 let blk = (sigil == BorrowedSigil);\n-                (v.visit_block)((*b), {in_loop: true, can_ret: blk}, v);\n+                (v.visit_block)((*b), Context {\n+                                         in_loop: true,\n+                                         can_ret: blk\n+                                      }, v);\n               }\n               expr_break(_) => {\n                 if !cx.in_loop {"}, {"sha": "b08adef88c98c30516b5f9814c1d99f546bf2309", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -62,42 +62,44 @@ pub const try_adding: &str = \"Try adding a move\";\n \n pub type rval_map = HashMap<node_id, ()>;\n \n-pub type ctx = {\n+pub struct Context {\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n     last_use_map: liveness::last_use_map,\n     current_item: node_id\n-};\n+}\n \n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: typeck::method_map,\n                    last_use_map: liveness::last_use_map,\n                    crate: @crate) {\n-    let ctx = {tcx: tcx,\n-               method_map: method_map,\n-               last_use_map: last_use_map,\n-               current_item: -1};\n+    let ctx = Context {\n+        tcx: tcx,\n+        method_map: method_map,\n+        last_use_map: last_use_map,\n+        current_item: -1\n+    };\n     let visit = visit::mk_vt(@visit::Visitor {\n         visit_arm: check_arm,\n         visit_expr: check_expr,\n         visit_fn: check_fn,\n         visit_ty: check_ty,\n-        visit_item: fn@(i: @item, cx: ctx, v: visit::vt<ctx>) {\n-            visit::visit_item(i, {current_item: i.id,.. cx}, v);\n+        visit_item: fn@(i: @item, cx: Context, v: visit::vt<Context>) {\n+            visit::visit_item(i, Context { current_item: i.id,.. cx }, v);\n         },\n         .. *visit::default_visitor()\n     });\n     visit::visit_crate(*crate, ctx, visit);\n     tcx.sess.abort_if_errors();\n }\n \n-type check_fn = fn@(ctx, @freevar_entry);\n+type check_fn = fn@(Context, @freevar_entry);\n \n // Yields the appropriate function to check the kind of closed over\n // variables. `id` is the node_id for some expression that creates the\n // closure.\n-fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n-    fn check_for_uniq(cx: ctx, fv: @freevar_entry) {\n+fn with_appropriate_checker(cx: Context, id: node_id, b: fn(check_fn)) {\n+    fn check_for_uniq(cx: Context, fv: @freevar_entry) {\n         // all captured data must be owned, regardless of whether it is\n         // moved in or copied in.\n         let id = ast_util::def_id_of_def(fv.def).node;\n@@ -108,7 +110,7 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n         check_imm_free_var(cx, fv.def, fv.span);\n     }\n \n-    fn check_for_box(cx: ctx, fv: @freevar_entry) {\n+    fn check_for_box(cx: Context, fv: @freevar_entry) {\n         // all captured data must be owned\n         let id = ast_util::def_id_of_def(fv.def).node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n@@ -118,11 +120,11 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n         check_imm_free_var(cx, fv.def, fv.span);\n     }\n \n-    fn check_for_block(_cx: ctx, _fv: @freevar_entry) {\n+    fn check_for_block(_cx: Context, _fv: @freevar_entry) {\n         // no restrictions\n     }\n \n-    fn check_for_bare(cx: ctx, fv: @freevar_entry) {\n+    fn check_for_bare(cx: Context, fv: @freevar_entry) {\n         cx.tcx.sess.span_err(\n             fv.span,\n             ~\"attempted dynamic environment capture\");\n@@ -152,7 +154,7 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n // Check that the free variables used in a shared/sendable closure conform\n // to the copy/move kind bounds. Then recursively check the function body.\n fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n-            fn_id: node_id, cx: ctx, v: visit::vt<ctx>) {\n+            fn_id: node_id, cx: Context, v: visit::vt<Context>) {\n \n     // Check kinds on free variables:\n     do with_appropriate_checker(cx, fn_id) |chk| {\n@@ -164,7 +166,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n     visit::visit_fn(fk, decl, body, sp, fn_id, cx, v);\n }\n \n-fn check_arm(a: arm, cx: ctx, v: visit::vt<ctx>) {\n+fn check_arm(a: arm, cx: Context, v: visit::vt<Context>) {\n     for vec::each(a.pats) |p| {\n         do pat_util::pat_bindings(cx.tcx.def_map, *p) |mode, id, span, _pth| {\n             if mode == bind_by_copy {\n@@ -177,7 +179,7 @@ fn check_arm(a: arm, cx: ctx, v: visit::vt<ctx>) {\n     visit::visit_arm(a, cx, v);\n }\n \n-pub fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n+pub fn check_expr(e: @expr, cx: Context, v: visit::vt<Context>) {\n     debug!(\"kind::check_expr(%s)\", expr_to_str(e, cx.tcx.sess.intr()));\n \n     // Handle any kind bounds on type parameters\n@@ -244,7 +246,7 @@ pub fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n     visit::visit_expr(e, cx, v);\n }\n \n-fn check_ty(aty: @Ty, cx: ctx, v: visit::vt<ctx>) {\n+fn check_ty(aty: @Ty, cx: Context, v: visit::vt<Context>) {\n     match aty.node {\n       ty_path(_, id) => {\n         do option::iter(&cx.tcx.node_type_substs.find(&id)) |ts| {\n@@ -260,7 +262,7 @@ fn check_ty(aty: @Ty, cx: ctx, v: visit::vt<ctx>) {\n     visit::visit_ty(aty, cx, v);\n }\n \n-pub fn check_bounds(cx: ctx,\n+pub fn check_bounds(cx: Context,\n                     _type_parameter_id: node_id,\n                     sp: span,\n                     ty: ty::t,\n@@ -310,7 +312,7 @@ pub fn check_bounds(cx: ctx,\n     }\n }\n \n-fn is_nullary_variant(cx: ctx, ex: @expr) -> bool {\n+fn is_nullary_variant(cx: Context, ex: @expr) -> bool {\n     match ex.node {\n       expr_path(_) => {\n         match cx.tcx.def_map.get(&ex.id) {\n@@ -324,7 +326,7 @@ fn is_nullary_variant(cx: ctx, ex: @expr) -> bool {\n     }\n }\n \n-fn check_imm_free_var(cx: ctx, def: def, sp: span) {\n+fn check_imm_free_var(cx: Context, def: def, sp: span) {\n     match def {\n         def_local(_, is_mutbl) => {\n             if is_mutbl {\n@@ -344,7 +346,7 @@ fn check_imm_free_var(cx: ctx, def: def, sp: span) {\n     }\n }\n \n-fn check_copy(cx: ctx, ty: ty::t, sp: span, reason: &str) {\n+fn check_copy(cx: Context, ty: ty::t, sp: span, reason: &str) {\n     debug!(\"type_contents(%s)=%s\",\n            ty_to_str(cx.tcx, ty),\n            ty::type_contents(cx.tcx, ty).to_str());\n@@ -356,7 +358,7 @@ fn check_copy(cx: ctx, ty: ty::t, sp: span, reason: &str) {\n     }\n }\n \n-pub fn check_owned(cx: ctx, ty: ty::t, sp: span) -> bool {\n+pub fn check_owned(cx: Context, ty: ty::t, sp: span) -> bool {\n     if !ty::type_is_owned(cx.tcx, ty) {\n         cx.tcx.sess.span_err(\n             sp, fmt!(\"value has non-owned type `%s`\",\n@@ -410,7 +412,7 @@ pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n /// (3) The type parameter is owned (and therefore does not contain\n /// borrowed ptrs).\n pub fn check_cast_for_escaping_regions(\n-    cx: ctx,\n+    cx: Context,\n     source: @expr,\n     target: @expr)\n {\n@@ -454,7 +456,7 @@ pub fn check_cast_for_escaping_regions(\n }\n \n /// Ensures that values placed into a ~Trait are copyable and sendable.\n-pub fn check_kind_bounds_of_cast(cx: ctx, source: @expr, target: @expr) {\n+pub fn check_kind_bounds_of_cast(cx: Context, source: @expr, target: @expr) {\n     let target_ty = ty::expr_ty(cx.tcx, target);\n     match ty::get(target_ty).sty {\n         ty::ty_trait(_, _, ty::vstore_uniq) => {"}, {"sha": "61eff69d979e0464ea71124e9b04103b08a1dd47", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 154, "deletions": 110, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -102,165 +102,205 @@ pub fn level_to_str(lv: level) -> &static/str {\n     }\n }\n \n+#[deriving_eq]\n pub enum level {\n     allow, warn, deny, forbid\n }\n \n-impl cmp::Eq for level {\n-    pure fn eq(&self, other: &level) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &level) -> bool { !(*self).eq(other) }\n+struct LintSpec {\n+    lint: lint,\n+    desc: &static/str,\n+    default: level\n }\n \n-type lint_spec = @{lint: lint,\n-                   desc: &static/str,\n-                   default: level};\n-\n-pub type lint_dict = HashMap<@~str, lint_spec>;\n+pub type LintDict = HashMap<@~str, @LintSpec>;\n \n /*\n   Pass names should not contain a '-', as the compiler normalizes\n   '-' to '_' in command-line flags\n  */\n-pub fn get_lint_dict() -> lint_dict {\n+pub fn get_lint_dict() -> LintDict {\n     let v = ~[\n         (@~\"ctypes\",\n-         @{lint: ctypes,\n-           desc: \"proper use of core::libc types in foreign modules\",\n-           default: warn}),\n+         @LintSpec {\n+            lint: ctypes,\n+            desc: \"proper use of core::libc types in foreign modules\",\n+            default: warn\n+         }),\n \n         (@~\"unused_imports\",\n-         @{lint: unused_imports,\n-           desc: \"imports that are never used\",\n-           default: allow}),\n+         @LintSpec {\n+            lint: unused_imports,\n+            desc: \"imports that are never used\",\n+            default: allow\n+         }),\n \n         (@~\"while_true\",\n-         @{lint: while_true,\n-           desc: \"suggest using loop { } instead of while(true) { }\",\n-           default: warn}),\n+         @LintSpec {\n+            lint: while_true,\n+            desc: \"suggest using loop { } instead of while(true) { }\",\n+            default: warn\n+         }),\n \n         (@~\"path_statement\",\n-         @{lint: path_statement,\n-           desc: \"path statements with no effect\",\n-           default: warn}),\n+         @LintSpec {\n+            lint: path_statement,\n+            desc: \"path statements with no effect\",\n+            default: warn\n+         }),\n \n         (@~\"unrecognized_lint\",\n-         @{lint: unrecognized_lint,\n-           desc: \"unrecognized lint attribute\",\n-           default: warn}),\n+         @LintSpec {\n+            lint: unrecognized_lint,\n+            desc: \"unrecognized lint attribute\",\n+            default: warn\n+         }),\n \n         (@~\"non_implicitly_copyable_typarams\",\n-         @{lint: non_implicitly_copyable_typarams,\n-           desc: \"passing non implicitly copyable types as copy type params\",\n-           default: warn}),\n+         @LintSpec {\n+            lint: non_implicitly_copyable_typarams,\n+            desc: \"passing non implicitly copyable types as copy type params\",\n+            default: warn\n+         }),\n \n         (@~\"vecs_implicitly_copyable\",\n-         @{lint: vecs_implicitly_copyable,\n-           desc: \"make vecs and strs not implicitly copyable \\\n+         @LintSpec {\n+            lint: vecs_implicitly_copyable,\n+            desc: \"make vecs and strs not implicitly copyable \\\n                   (only checked at top level)\",\n-           default: warn}),\n+            default: warn\n+         }),\n \n         (@~\"implicit_copies\",\n-         @{lint: implicit_copies,\n-           desc: \"implicit copies of non implicitly copyable data\",\n-           default: warn}),\n+         @LintSpec {\n+            lint: implicit_copies,\n+            desc: \"implicit copies of non implicitly copyable data\",\n+            default: warn\n+         }),\n \n         (@~\"deprecated_mode\",\n-         @{lint: deprecated_mode,\n-           desc: \"warn about deprecated uses of modes\",\n-           default: warn}),\n+         @LintSpec {\n+            lint: deprecated_mode,\n+            desc: \"warn about deprecated uses of modes\",\n+            default: warn\n+         }),\n \n         (@~\"deprecated_pattern\",\n-         @{lint: deprecated_pattern,\n-           desc: \"warn about deprecated uses of pattern bindings\",\n-           default: allow}),\n+         @LintSpec {\n+            lint: deprecated_pattern,\n+            desc: \"warn about deprecated uses of pattern bindings\",\n+            default: allow\n+         }),\n \n         (@~\"non_camel_case_types\",\n-         @{lint: non_camel_case_types,\n-           desc: \"types, variants and traits should have camel case names\",\n-           default: allow}),\n+         @LintSpec {\n+            lint: non_camel_case_types,\n+            desc: \"types, variants and traits should have camel case names\",\n+            default: allow\n+         }),\n \n         (@~\"managed_heap_memory\",\n-         @{lint: managed_heap_memory,\n-           desc: \"use of managed (@ type) heap memory\",\n-           default: allow}),\n+         @LintSpec {\n+            lint: managed_heap_memory,\n+            desc: \"use of managed (@ type) heap memory\",\n+            default: allow\n+         }),\n \n         (@~\"owned_heap_memory\",\n-         @{lint: owned_heap_memory,\n-           desc: \"use of owned (~ type) heap memory\",\n-           default: allow}),\n+         @LintSpec {\n+            lint: owned_heap_memory,\n+            desc: \"use of owned (~ type) heap memory\",\n+            default: allow\n+         }),\n \n         (@~\"heap_memory\",\n-         @{lint: heap_memory,\n-           desc: \"use of any (~ type or @ type) heap memory\",\n-           default: allow}),\n+         @LintSpec {\n+            lint: heap_memory,\n+            desc: \"use of any (~ type or @ type) heap memory\",\n+            default: allow\n+         }),\n \n         (@~\"structural_records\",\n-         @{lint: structural_records,\n-           desc: \"use of any structural records\",\n-           default: deny}),\n+         @LintSpec {\n+            lint: structural_records,\n+            desc: \"use of any structural records\",\n+            default: deny\n+         }),\n \n         (@~\"legacy modes\",\n-         @{lint: legacy_modes,\n-           desc: \"allow legacy modes\",\n-           default: forbid}),\n+         @LintSpec {\n+            lint: legacy_modes,\n+            desc: \"allow legacy modes\",\n+            default: forbid\n+         }),\n \n         (@~\"type_limits\",\n-         @{lint: type_limits,\n-           desc: \"comparisons made useless by limits of the types involved\",\n-           default: warn}),\n+         @LintSpec {\n+            lint: type_limits,\n+            desc: \"comparisons made useless by limits of the types involved\",\n+            default: warn\n+         }),\n \n         (@~\"default_methods\",\n-         @{lint: default_methods,\n-           desc: \"allow default methods\",\n-           default: deny}),\n+         @LintSpec {\n+            lint: default_methods,\n+            desc: \"allow default methods\",\n+            default: deny\n+         }),\n \n         (@~\"deprecated_self\",\n-         @{lint: deprecated_self,\n-           desc: \"warn about deprecated uses of `self`\",\n-           default: warn}),\n+         @LintSpec {\n+            lint: deprecated_self,\n+            desc: \"warn about deprecated uses of `self`\",\n+            default: warn\n+         }),\n \n         /* FIXME(#3266)--make liveness warnings lintable\n         (@~\"unused_variable\",\n-         @{lint: unused_variable,\n-           desc: \"detect variables which are not used in any way\",\n-           default: warn}),\n+         @LintSpec {\n+            lint: unused_variable,\n+            desc: \"detect variables which are not used in any way\",\n+            default: warn\n+         }),\n \n         (@~\"dead_assignment\",\n-         @{lint: dead_assignment,\n-           desc: \"detect assignments that will never be read\",\n-           default: warn}),\n+         @LintSpec {\n+            lint: dead_assignment,\n+            desc: \"detect assignments that will never be read\",\n+            default: warn\n+         }),\n         */\n     ];\n     oldmap::hash_from_vec(v)\n }\n \n // This is a highly not-optimal set of data structure decisions.\n-type lint_modes = SmallIntMap<level>;\n-type lint_mode_map = HashMap<ast::node_id, lint_modes>;\n+type LintModes = SmallIntMap<level>;\n+type LintModeMap = HashMap<ast::node_id, LintModes>;\n \n // settings_map maps node ids of items with non-default lint settings\n // to their settings; default_settings contains the settings for everything\n // not in the map.\n-pub type lint_settings = {\n-    default_settings: lint_modes,\n-    settings_map: lint_mode_map\n-};\n-\n-pub fn mk_lint_settings() -> lint_settings {\n-    {default_settings: oldsmallintmap::mk(),\n-     settings_map: HashMap()}\n+pub struct LintSettings {\n+    default_settings: LintModes,\n+    settings_map: LintModeMap\n+}\n+\n+pub fn mk_lint_settings() -> LintSettings {\n+    LintSettings {\n+        default_settings: oldsmallintmap::mk(),\n+        settings_map: HashMap()\n+    }\n }\n \n-pub fn get_lint_level(modes: lint_modes, lint: lint) -> level {\n+pub fn get_lint_level(modes: LintModes, lint: lint) -> level {\n     match modes.find(lint as uint) {\n       Some(c) => c,\n       None => allow\n     }\n }\n \n-pub fn get_lint_settings_level(settings: lint_settings,\n+pub fn get_lint_settings_level(settings: LintSettings,\n                                lint_mode: lint,\n                                _expr_id: ast::node_id,\n                                item_id: ast::node_id)\n@@ -273,34 +313,32 @@ pub fn get_lint_settings_level(settings: lint_settings,\n \n // This is kind of unfortunate. It should be somewhere else, or we should use\n // a persistent data structure...\n-fn clone_lint_modes(modes: lint_modes) -> lint_modes {\n+fn clone_lint_modes(modes: LintModes) -> LintModes {\n     oldsmallintmap::SmallIntMap_(@oldsmallintmap::SmallIntMap_\n     {v: copy modes.v})\n }\n \n-type ctxt_ = {dict: lint_dict,\n-              curr: lint_modes,\n-              is_default: bool,\n-              sess: Session};\n-\n-enum ctxt {\n-    ctxt_(ctxt_)\n+struct Context {\n+    dict: LintDict,\n+    curr: LintModes,\n+    is_default: bool,\n+    sess: Session\n }\n \n-impl ctxt {\n-    fn get_level(lint: lint) -> level {\n+impl Context {\n+    fn get_level(&self, lint: lint) -> level {\n         get_lint_level(self.curr, lint)\n     }\n \n-    fn set_level(lint: lint, level: level) {\n+    fn set_level(&self, lint: lint, level: level) {\n         if level == allow {\n             self.curr.remove(lint as uint);\n         } else {\n             self.curr.insert(lint as uint, level);\n         }\n     }\n \n-    fn span_lint(level: level, span: span, +msg: ~str) {\n+    fn span_lint(&self, level: level, span: span, +msg: ~str) {\n         self.sess.span_lint_level(level, span, msg);\n     }\n \n@@ -309,9 +347,9 @@ impl ctxt {\n      * current lint context, call the provided function, then reset the\n      * lints in effect to their previous state.\n      */\n-    fn with_lint_attrs(attrs: ~[ast::attribute], f: fn(ctxt)) {\n+    fn with_lint_attrs(&self, attrs: ~[ast::attribute], f: fn(Context)) {\n \n-        let mut new_ctxt = self;\n+        let mut new_ctxt = *self;\n         let mut triples = ~[];\n \n         for [allow, warn, deny, forbid].each |level| {\n@@ -376,10 +414,11 @@ impl ctxt {\n                 // this shouldn't actually be a problem...\n \n                 let c = clone_lint_modes(new_ctxt.curr);\n-                new_ctxt =\n-                    ctxt_({is_default: false,\n-                           curr: c,\n-                           .. *new_ctxt});\n+                new_ctxt = Context {\n+                    is_default: false,\n+                    curr: c,\n+                    .. new_ctxt\n+                };\n                 new_ctxt.set_level(lint.lint, level);\n               }\n             }\n@@ -389,7 +428,7 @@ impl ctxt {\n }\n \n \n-fn build_settings_item(i: @ast::item, &&cx: ctxt, v: visit::vt<ctxt>) {\n+fn build_settings_item(i: @ast::item, &&cx: Context, v: visit::vt<Context>) {\n     do cx.with_lint_attrs(/*bad*/copy i.attrs) |cx| {\n         if !cx.is_default {\n             cx.sess.lint_settings.settings_map.insert(i.id, cx.curr);\n@@ -399,10 +438,12 @@ fn build_settings_item(i: @ast::item, &&cx: ctxt, v: visit::vt<ctxt>) {\n }\n \n pub fn build_settings_crate(sess: session::Session, crate: @ast::crate) {\n-    let cx = ctxt_({dict: get_lint_dict(),\n-                    curr: oldsmallintmap::mk(),\n-                    is_default: true,\n-                    sess: sess});\n+    let cx = Context {\n+        dict: get_lint_dict(),\n+        curr: oldsmallintmap::mk(),\n+        is_default: true,\n+        sess: sess\n+    };\n \n     // Install defaults.\n     for cx.dict.each_value |&spec| {\n@@ -421,7 +462,10 @@ pub fn build_settings_crate(sess: session::Session, crate: @ast::crate) {\n             sess.lint_settings.default_settings.insert(k, v);\n         }\n \n-        let cx = ctxt_({is_default: true,.. *cx});\n+        let cx = Context {\n+            is_default: true,\n+            .. cx\n+        };\n \n         let visit = visit::mk_vt(@visit::Visitor {\n             visit_item: build_settings_item,"}, {"sha": "72ef23b3fd712737cb40bc2442fdb15b44823a73", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -99,14 +99,18 @@ pub type BindingMap = HashMap<ident,binding_info>;\n // FIXME #4946: This kind of duplicates information kept in\n // ty::method. Maybe it should go away.\n \n-pub type MethodInfo = {\n+pub struct MethodInfo {\n     did: def_id,\n     n_tps: uint,\n     ident: ident,\n     self_type: self_ty_\n-};\n+}\n \n-pub type Impl = { did: def_id, ident: ident, methods: ~[@MethodInfo] };\n+pub struct Impl {\n+    did: def_id,\n+    ident: ident,\n+    methods: ~[@MethodInfo]\n+}\n \n // Trait method resolution\n pub type TraitMap = @HashMap<node_id,@DVec<def_id>>;\n@@ -5323,21 +5327,23 @@ pub impl Resolver {\n     }\n }\n \n+pub struct CrateMap {\n+    def_map: DefMap,\n+    exp_map2: ExportMap2,\n+    trait_map: TraitMap\n+}\n+\n /// Entry point to crate resolution.\n pub fn resolve_crate(session: Session,\n                      lang_items: LanguageItems,\n                      crate: @crate)\n-                  -> {\n-                    def_map: DefMap,\n-                    exp_map2: ExportMap2,\n-                    trait_map: TraitMap\n-                  } {\n+                  -> CrateMap {\n     let resolver = @Resolver(session, lang_items, crate);\n     resolver.resolve(resolver);\n-    return {\n+    CrateMap {\n         def_map: resolver.def_map,\n         exp_map2: resolver.export_map2,\n         trait_map: resolver.trait_map\n-    };\n+    }\n }\n "}, {"sha": "5e37406bdd7521df75de56f23fe0052b07c7aaf8", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -189,7 +189,7 @@ pub enum Lit {\n // range)\n pub enum Opt {\n     lit(Lit),\n-    var(/* disr val */int, /* variant dids */{enm: def_id, var: def_id}),\n+    var(/* disr val */int, /* variant dids (enm, var) */(def_id, def_id)),\n     range(@ast::expr, @ast::expr),\n     vec_len_eq(uint),\n     vec_len_ge(uint)\n@@ -287,7 +287,7 @@ pub fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> Opt {\n             let variants = ty::enum_variants(tcx, enum_id);\n             for vec::each(*variants) |v| {\n                 if var_id == v.id {\n-                    return var(v.disr_val, {enm: enum_id, var: var_id});\n+                    return var(v.disr_val, (enum_id, var_id));\n                 }\n             }\n             ::core::util::unreachable();\n@@ -760,7 +760,7 @@ pub fn enter_region(bcx: block,\n // Returns the options in one column of matches. An option is something that\n // needs to be conditionally matched at runtime; for example, the discriminant\n // on a set of enum variants or a literal.\n-pub fn get_options(ccx: @crate_ctxt, m: &[@Match], col: uint) -> ~[Opt] {\n+pub fn get_options(ccx: @CrateContext, m: &[@Match], col: uint) -> ~[Opt] {\n     fn add_to_set(tcx: ty::ctxt, set: &DVec<Opt>, val: Opt) {\n         if set.any(|l| opt_eq(tcx, l, &val)) {return;}\n         set.push(val);\n@@ -819,44 +819,51 @@ pub fn get_options(ccx: @crate_ctxt, m: &[@Match], col: uint) -> ~[Opt] {\n     return dvec::unwrap(found);\n }\n \n+pub struct ExtractedBlock {\n+    vals: ~[ValueRef],\n+    bcx: block\n+}\n+\n pub fn extract_variant_args(bcx: block,\n                             pat_id: ast::node_id,\n-                            vdefs: {enm: def_id, var: def_id},\n+                            vdefs: (def_id, def_id),\n                             val: ValueRef)\n-                         -> {vals: ~[ValueRef], bcx: block} {\n+                         -> ExtractedBlock {\n+    let (enm, evar) = vdefs;\n     let _icx = bcx.insn_ctxt(\"match::extract_variant_args\");\n     let ccx = bcx.fcx.ccx;\n     let enum_ty_substs = match ty::get(node_id_type(bcx, pat_id)).sty {\n       ty::ty_enum(id, ref substs) => {\n-        assert id == vdefs.enm;\n+        assert id == enm;\n         /*bad*/copy (*substs).tps\n       }\n       _ => bcx.sess().bug(~\"extract_variant_args: pattern has non-enum type\")\n     };\n     let mut blobptr = val;\n-    let variants = ty::enum_variants(ccx.tcx, vdefs.enm);\n-    let size = ty::enum_variant_with_id(ccx.tcx, vdefs.enm,\n-                                        vdefs.var).args.len();\n+    let variants = ty::enum_variants(ccx.tcx, enm);\n+    let size = ty::enum_variant_with_id(ccx.tcx, enm,\n+                                        evar).args.len();\n     if size > 0u && (*variants).len() != 1u {\n         let enumptr =\n             PointerCast(bcx, val, T_opaque_enum_ptr(ccx));\n         blobptr = GEPi(bcx, enumptr, [0u, 1u]);\n     }\n-    let vdefs_tg = vdefs.enm;\n-    let vdefs_var = vdefs.var;\n+    let vdefs_tg = enm;\n+    let vdefs_var = evar;\n     let args = do vec::from_fn(size) |i| {\n         GEP_enum(bcx, blobptr, vdefs_tg, vdefs_var,\n                  /*bad*/copy enum_ty_substs, i)\n     };\n-    return {vals: args, bcx: bcx};\n+\n+    ExtractedBlock { vals: args, bcx: bcx }\n }\n \n pub fn extract_vec_elems(bcx: block,\n                          pat_id: ast::node_id,\n                          elem_count: uint,\n                          tail: bool,\n                          val: ValueRef)\n-                      -> {vals: ~[ValueRef], bcx: block} {\n+                      -> ExtractedBlock {\n     let _icx = bcx.insn_ctxt(\"match::extract_vec_elems\");\n     let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n     let unboxed = load_if_immediate(bcx, val, vt.vec_ty);\n@@ -885,7 +892,8 @@ pub fn extract_vec_elems(bcx: block,\n         elems.push(scratch.val);\n         scratch.add_clean(bcx);\n     }\n-    return {vals: elems, bcx: bcx};\n+\n+    ExtractedBlock { vals: elems, bcx: bcx }\n }\n \n // NB: This function does not collect fields from struct-like enum variants.\n@@ -1360,8 +1368,8 @@ pub fn compile_submatch(bcx: block,\n     let mut test_val = val;\n     if opts.len() > 0u {\n         match opts[0] {\n-            var(_, vdef) => {\n-                let variants = ty::enum_variants(tcx, vdef.enm);\n+            var(_, (enm, _)) => {\n+                let variants = ty::enum_variants(tcx, enm);\n                 if variants.len() == 1 {\n                     kind = single;\n                 } else {"}, {"sha": "4eed47ebafcc97e065e1a432421a4a9f5e25d5c3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 97, "deletions": 78, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -37,7 +37,7 @@ use lib::llvm::{ModuleRef, ValueRef, TypeRef, BasicBlockRef};\n use lib::llvm::{True, False};\n use lib::llvm::{llvm, mk_target_data, mk_type_names};\n use lib;\n-use metadata::common::link_meta;\n+use metadata::common::LinkMeta;\n use metadata::{csearch, cstore, decoder, encoder};\n use middle::astencode;\n use middle::borrowck::RootInfo;\n@@ -90,15 +90,15 @@ use syntax::visit::vt;\n use syntax::{ast, ast_util, codemap, ast_map};\n \n pub struct icx_popper {\n-    ccx: @crate_ctxt,\n+    ccx: @CrateContext,\n     drop {\n       if self.ccx.sess.count_llvm_insns() {\n           self.ccx.stats.llvm_insn_ctxt.pop();\n       }\n     }\n }\n \n-pub fn icx_popper(ccx: @crate_ctxt) -> icx_popper {\n+pub fn icx_popper(ccx: @CrateContext) -> icx_popper {\n     icx_popper {\n         ccx: ccx\n     }\n@@ -108,7 +108,7 @@ pub trait get_insn_ctxt {\n     fn insn_ctxt(s: &str) -> icx_popper;\n }\n \n-pub impl get_insn_ctxt for @crate_ctxt {\n+pub impl get_insn_ctxt for @CrateContext {\n     fn insn_ctxt(s: &str) -> icx_popper {\n         debug!(\"new insn_ctxt: %s\", s);\n         if self.sess.count_llvm_insns() {\n@@ -130,11 +130,11 @@ pub impl get_insn_ctxt for fn_ctxt {\n     }\n }\n \n-pub fn log_fn_time(ccx: @crate_ctxt, +name: ~str, start: time::Timespec,\n+pub fn log_fn_time(ccx: @CrateContext, +name: ~str, start: time::Timespec,\n                    end: time::Timespec) {\n     let elapsed = 1000 * ((end.sec - start.sec) as int) +\n         ((end.nsec as int) - (start.nsec as int)) / 1000000;\n-    ccx.stats.fn_times.push({ident: name, time: elapsed});\n+    ccx.stats.fn_times.push((name, elapsed));\n }\n \n pub fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv,\n@@ -339,38 +339,45 @@ pub fn malloc_raw(bcx: block, t: ty::t, heap: heap) -> Result {\n     malloc_raw_dyn(bcx, t, heap, llsize_of(bcx.ccx(), type_of(bcx.ccx(), t)))\n }\n \n+pub struct MallocResult {\n+    bcx: block,\n+    box: ValueRef,\n+    body: ValueRef\n+}\n+\n // malloc_general_dyn: usefully wraps malloc_raw_dyn; allocates a box,\n // and pulls out the body\n pub fn malloc_general_dyn(bcx: block, t: ty::t, heap: heap, size: ValueRef)\n-    -> {bcx: block, box: ValueRef, body: ValueRef} {\n+    -> MallocResult {\n     let _icx = bcx.insn_ctxt(\"malloc_general\");\n     let Result {bcx: bcx, val: llbox} = malloc_raw_dyn(bcx, t, heap, size);\n     let non_gc_box = non_gc_box_cast(bcx, llbox);\n     let body = GEPi(bcx, non_gc_box, [0u, abi::box_field_body]);\n-    return {bcx: bcx, box: llbox, body: body};\n+\n+    MallocResult { bcx: bcx, box: llbox, body: body }\n }\n \n pub fn malloc_general(bcx: block, t: ty::t, heap: heap)\n-    -> {bcx: block, box: ValueRef, body: ValueRef} {\n+    -> MallocResult {\n     malloc_general_dyn(bcx, t, heap,\n                        llsize_of(bcx.ccx(), type_of(bcx.ccx(), t)))\n }\n pub fn malloc_boxed(bcx: block, t: ty::t)\n-    -> {bcx: block, box: ValueRef, body: ValueRef} {\n+    -> MallocResult {\n     malloc_general(bcx, t, heap_shared)\n }\n pub fn malloc_unique(bcx: block, t: ty::t)\n-    -> {bcx: block, box: ValueRef, body: ValueRef} {\n+    -> MallocResult {\n     malloc_general(bcx, t, heap_exchange)\n }\n \n // Type descriptor and type glue stuff\n \n-pub fn get_tydesc_simple(ccx: @crate_ctxt, t: ty::t) -> ValueRef {\n+pub fn get_tydesc_simple(ccx: @CrateContext, t: ty::t) -> ValueRef {\n     get_tydesc(ccx, t).tydesc\n }\n \n-pub fn get_tydesc(ccx: @crate_ctxt, t: ty::t) -> @mut tydesc_info {\n+pub fn get_tydesc(ccx: @CrateContext, t: ty::t) -> @mut tydesc_info {\n     match ccx.tydescs.find(&t) {\n       Some(inf) => inf,\n       _ => {\n@@ -455,15 +462,15 @@ pub fn set_glue_inlining(f: ValueRef, t: ty::t) {\n \n // Double-check that we never ask LLVM to declare the same symbol twice. It\n // silently mangles such symbols, breaking our linkage model.\n-pub fn note_unique_llvm_symbol(ccx: @crate_ctxt, +sym: ~str) {\n+pub fn note_unique_llvm_symbol(ccx: @CrateContext, +sym: ~str) {\n     if ccx.all_llvm_symbols.contains_key(&sym) {\n         ccx.sess.bug(~\"duplicate LLVM symbol: \" + sym);\n     }\n     ccx.all_llvm_symbols.insert(sym, ());\n }\n \n \n-pub fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id,\n+pub fn get_res_dtor(ccx: @CrateContext, did: ast::def_id,\n                     parent_id: ast::def_id, substs: ~[ty::t])\n    -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"trans_res_dtor\");\n@@ -472,7 +479,10 @@ pub fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id,\n             inline::maybe_instantiate_inline(ccx, did, true)\n         } else { did };\n         assert did.crate == ast::local_crate;\n-        monomorphize::monomorphic_fn(ccx, did, substs, None, None, None).val\n+        let (val, _) =\n+            monomorphize::monomorphic_fn(ccx, did, substs, None, None, None);\n+\n+        val\n     } else if did.crate == ast::local_crate {\n         get_item_val(ccx, did.node)\n     } else {\n@@ -488,7 +498,7 @@ pub fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id,\n }\n \n // Structural comparison: a rather involved form of glue.\n-pub fn maybe_name_value(cx: @crate_ctxt, v: ValueRef, s: ~str) {\n+pub fn maybe_name_value(cx: @CrateContext, v: ValueRef, s: ~str) {\n     if cx.sess.opts.save_temps {\n         let _: () = str::as_c_str(s, |buf| {\n             unsafe {\n@@ -784,7 +794,7 @@ pub fn null_env_ptr(bcx: block) -> ValueRef {\n     C_null(T_opaque_box_ptr(bcx.ccx()))\n }\n \n-pub fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n+pub fn trans_external_path(ccx: @CrateContext, did: ast::def_id, t: ty::t)\n     -> ValueRef {\n     let name = csearch::get_symbol(ccx.sess.cstore, did).to_managed(); // Sad\n     match ty::get(t).sty {\n@@ -800,7 +810,7 @@ pub fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n     };\n }\n \n-pub fn get_discrim_val(cx: @crate_ctxt, span: span, enum_did: ast::def_id,\n+pub fn get_discrim_val(cx: @CrateContext, span: span, enum_did: ast::def_id,\n                        variant_did: ast::def_id) -> ValueRef {\n     // Can't use `discrims` from the crate context here because\n     // those discriminants have an extra level of indirection,\n@@ -990,7 +1000,7 @@ pub fn add_root_cleanup(bcx: block,\n         let mut bcx_sid = bcx;\n         loop {\n             bcx_sid = match bcx_sid.node_info {\n-              Some({id, _}) if id == scope_id => {\n+              Some(NodeInfo { id, _ }) if id == scope_id => {\n                 return bcx_sid\n               }\n               _ => {\n@@ -1037,21 +1047,19 @@ pub fn load_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     return v;\n }\n \n-pub fn trans_trace(bcx: block, sp_opt: Option<span>, trace_str: ~str) {\n+pub fn trans_trace(bcx: block, sp_opt: Option<span>, trace_str: @~str) {\n     if !bcx.sess().trace() { return; }\n     let _icx = bcx.insn_ctxt(\"trans_trace\");\n-    add_comment(bcx, /*bad*/ copy trace_str);\n-    let V_trace_str = C_cstr(bcx.ccx(), @/*bad*/ copy trace_str);\n-    let {V_filename, V_line} = match sp_opt {\n+    add_comment(bcx, *trace_str);\n+    let V_trace_str = C_cstr(bcx.ccx(), trace_str);\n+    let (V_filename, V_line) = match sp_opt {\n       Some(sp) => {\n         let sess = bcx.sess();\n         let loc = sess.parse_sess.cm.lookup_char_pos(sp.lo);\n-        {V_filename: C_cstr(bcx.ccx(), @/*bad*/copy loc.file.name),\n-         V_line: loc.line as int}\n+        (C_cstr(bcx.ccx(), @/*bad*/copy loc.file.name), loc.line as int)\n       }\n       None => {\n-        {V_filename: C_cstr(bcx.ccx(), @~\"<runtime>\"),\n-         V_line: 0}\n+        (C_cstr(bcx.ccx(), @~\"<runtime>\"), 0)\n       }\n     };\n     let ccx = bcx.ccx();\n@@ -1161,7 +1169,7 @@ pub fn trans_stmt(cx: block, s: ast::stmt) -> block {\n // You probably don't want to use this one. See the\n // next three functions instead.\n pub fn new_block(cx: fn_ctxt, parent: Option<block>, +kind: block_kind,\n-                 is_lpad: bool, +name: ~str, opt_node_info: Option<node_info>)\n+                 is_lpad: bool, +name: ~str, opt_node_info: Option<NodeInfo>)\n     -> block {\n \n     let s = if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {\n@@ -1197,14 +1205,14 @@ pub fn simple_block_scope() -> block_kind {\n }\n \n // Use this when you're at the top block of a function or the like.\n-pub fn top_scope_block(fcx: fn_ctxt, opt_node_info: Option<node_info>)\n+pub fn top_scope_block(fcx: fn_ctxt, opt_node_info: Option<NodeInfo>)\n                     -> block {\n     return new_block(fcx, None, simple_block_scope(), false,\n                   ~\"function top level\", opt_node_info);\n }\n \n pub fn scope_block(bcx: block,\n-                   opt_node_info: Option<node_info>,\n+                   opt_node_info: Option<NodeInfo>,\n                    +n: ~str) -> block {\n     return new_block(bcx.fcx, Some(bcx), simple_block_scope(), bcx.is_lpad,\n                   n, opt_node_info);\n@@ -1214,7 +1222,7 @@ pub fn loop_scope_block(bcx: block,\n                         loop_break: block,\n                         loop_label: Option<ident>,\n                         +n: ~str,\n-                        opt_node_info: Option<node_info>) -> block {\n+                        opt_node_info: Option<NodeInfo>) -> block {\n     return new_block(bcx.fcx, Some(bcx), block_scope(scope_info {\n         loop_break: Some(loop_break),\n         loop_label: loop_label,\n@@ -1290,19 +1298,22 @@ pub fn cleanup_and_leave(bcx: block,\n         if bcx.sess().trace() {\n             trans_trace(\n                 bcx, None,\n-                fmt!(\"cleanup_and_leave(%s)\", cur.to_str()));\n+                @fmt!(\"cleanup_and_leave(%s)\", cur.to_str()));\n         }\n \n         match cur.kind {\n-          block_scope(ref inf) if (*inf).cleanups.len() > 0u => {\n+          block_scope(ref inf) if !inf.cleanups.is_empty() => {\n             for vec::find((*inf).cleanup_paths,\n                           |cp| cp.target == leave).each |cp| {\n                 Br(bcx, cp.dest);\n                 return;\n             }\n             let sub_cx = sub_block(bcx, ~\"cleanup\");\n             Br(bcx, sub_cx.llbb);\n-            (*inf).cleanup_paths.push({target: leave, dest: sub_cx.llbb});\n+            (*inf).cleanup_paths.push(cleanup_path {\n+                target: leave,\n+                dest: sub_cx.llbb\n+            });\n             bcx = trans_block_cleanups_(sub_cx, block_cleanups(cur), is_lpad);\n           }\n           _ => ()\n@@ -1336,7 +1347,7 @@ pub fn leave_block(bcx: block, out_of: block) -> block {\n }\n \n pub fn with_scope(bcx: block,\n-                  opt_node_info: Option<node_info>,\n+                  opt_node_info: Option<NodeInfo>,\n                   +name: ~str,\n                   f: fn(block) -> block) -> block {\n     let _icx = bcx.insn_ctxt(\"with_scope\");\n@@ -1351,7 +1362,7 @@ pub fn with_scope(bcx: block,\n }\n \n pub fn with_scope_result(bcx: block,\n-                         opt_node_info: Option<node_info>,\n+                         opt_node_info: Option<NodeInfo>,\n                          +name: ~str,\n                          f: fn(block) -> Result) -> Result {\n     let _icx = bcx.insn_ctxt(\"with_scope_result\");\n@@ -1361,7 +1372,7 @@ pub fn with_scope_result(bcx: block,\n     rslt(leave_block(bcx, scope_cx), val)\n }\n \n-pub fn with_scope_datumblock(bcx: block, opt_node_info: Option<node_info>,\n+pub fn with_scope_datumblock(bcx: block, opt_node_info: Option<NodeInfo>,\n                              +name: ~str, f: fn(block) -> datum::DatumBlock)\n                           -> datum::DatumBlock {\n     use middle::trans::datum::DatumBlock;\n@@ -1529,14 +1540,20 @@ pub fn arrayalloca(cx: block, t: TypeRef, v: ValueRef) -> ValueRef {\n         base::raw_block(cx.fcx, false, cx.fcx.llstaticallocas), t, v);\n }\n \n+pub struct BasicBlocks {\n+    sa: BasicBlockRef,\n+    rt: BasicBlockRef\n+}\n+\n // Creates the standard set of basic blocks for a function\n-pub fn mk_standard_basic_blocks(llfn: ValueRef) ->\n-   {sa: BasicBlockRef, rt: BasicBlockRef} {\n+pub fn mk_standard_basic_blocks(llfn: ValueRef) -> BasicBlocks {\n     unsafe {\n-        {sa: str::as_c_str(~\"static_allocas\",\n+        BasicBlocks {\n+            sa: str::as_c_str(~\"static_allocas\",\n                            |buf| llvm::LLVMAppendBasicBlock(llfn, buf)),\n-         rt: str::as_c_str(~\"return\",\n-                           |buf| llvm::LLVMAppendBasicBlock(llfn, buf))}\n+            rt: str::as_c_str(~\"return\",\n+                           |buf| llvm::LLVMAppendBasicBlock(llfn, buf))\n+        }\n     }\n }\n \n@@ -1547,7 +1564,7 @@ pub fn mk_standard_basic_blocks(llfn: ValueRef) ->\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n-pub fn new_fn_ctxt_w_id(ccx: @crate_ctxt,\n+pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n                         +path: path,\n                         llfndecl: ValueRef,\n                         id: ast::node_id,\n@@ -1577,7 +1594,7 @@ pub fn new_fn_ctxt_w_id(ccx: @crate_ctxt,\n     };\n }\n \n-pub fn new_fn_ctxt(ccx: @crate_ctxt,\n+pub fn new_fn_ctxt(ccx: @CrateContext,\n                    +path: path,\n                    llfndecl: ValueRef,\n                    sp: Option<span>)\n@@ -1735,7 +1752,7 @@ pub enum self_arg { impl_self(ty::t), impl_owned_self(ty::t), no_self, }\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n-pub fn trans_closure(ccx: @crate_ctxt,\n+pub fn trans_closure(ccx: @CrateContext,\n                      +path: path,\n                      decl: &ast::fn_decl,\n                      body: &ast::blk,\n@@ -1799,7 +1816,7 @@ pub fn trans_closure(ccx: @crate_ctxt,\n \n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n-pub fn trans_fn(ccx: @crate_ctxt,\n+pub fn trans_fn(ccx: @CrateContext,\n                 +path: path,\n                 decl: &ast::fn_decl,\n                 body: &ast::blk,\n@@ -1829,7 +1846,7 @@ pub fn trans_fn(ccx: @crate_ctxt,\n     }\n }\n \n-pub fn trans_enum_variant(ccx: @crate_ctxt,\n+pub fn trans_enum_variant(ccx: @CrateContext,\n                           enum_id: ast::node_id,\n                           variant: ast::variant,\n                           args: ~[ast::variant_arg],\n@@ -1894,7 +1911,7 @@ pub fn trans_enum_variant(ccx: @crate_ctxt,\n \n // NB: In theory this should be merged with the function above. But the AST\n // structures are completely different, so very little code would be shared.\n-pub fn trans_tuple_struct(ccx: @crate_ctxt,\n+pub fn trans_tuple_struct(ccx: @CrateContext,\n                           fields: ~[@ast::struct_field],\n                           ctor_id: ast::node_id,\n                           param_substs: Option<@param_substs>,\n@@ -1947,7 +1964,7 @@ pub fn trans_tuple_struct(ccx: @crate_ctxt,\n     finish_fn(fcx, lltop);\n }\n \n-pub fn trans_struct_dtor(ccx: @crate_ctxt,\n+pub fn trans_struct_dtor(ccx: @CrateContext,\n                          +path: path,\n                          body: &ast::blk,\n                          dtor_id: ast::node_id,\n@@ -1986,7 +2003,7 @@ pub fn trans_struct_dtor(ccx: @crate_ctxt,\n   lldecl\n }\n \n-pub fn trans_enum_def(ccx: @crate_ctxt, enum_definition: ast::enum_def,\n+pub fn trans_enum_def(ccx: @CrateContext, enum_definition: ast::enum_def,\n                       id: ast::node_id, degen: bool,\n                       path: @ast_map::path, vi: @~[ty::VariantInfo],\n                       i: &mut uint) {\n@@ -2020,7 +2037,7 @@ pub fn trans_enum_def(ccx: @crate_ctxt, enum_definition: ast::enum_def,\n     }\n }\n \n-pub fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n+pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n     let _icx = ccx.insn_ctxt(\"trans_item\");\n     let path = match ccx.tcx.items.get(&item.id) {\n         ast_map::node_item(_, p) => p,\n@@ -2087,7 +2104,7 @@ pub fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n     }\n }\n \n-pub fn trans_struct_def(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n+pub fn trans_struct_def(ccx: @CrateContext, struct_def: @ast::struct_def,\n                         path: @ast_map::path,\n                         id: ast::node_id) {\n     // Translate the destructor.\n@@ -2114,7 +2131,7 @@ pub fn trans_struct_def(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n // separate modules in the compiled program.  That's because modules exist\n // only as a convenience for humans working with the code, to organize names\n // and control visibility.\n-pub fn trans_mod(ccx: @crate_ctxt, m: ast::_mod) {\n+pub fn trans_mod(ccx: @CrateContext, m: ast::_mod) {\n     let _icx = ccx.insn_ctxt(\"trans_mod\");\n     for vec::each(m.items) |item| {\n         trans_item(ccx, **item);\n@@ -2126,7 +2143,7 @@ pub fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n     return struct_elt(llpairty, 0u);\n }\n \n-pub fn register_fn(ccx: @crate_ctxt,\n+pub fn register_fn(ccx: @CrateContext,\n                    sp: span,\n                    +path: path,\n                    node_id: ast::node_id,\n@@ -2136,7 +2153,7 @@ pub fn register_fn(ccx: @crate_ctxt,\n     register_fn_full(ccx, sp, path, node_id, attrs, t)\n }\n \n-pub fn register_fn_full(ccx: @crate_ctxt,\n+pub fn register_fn_full(ccx: @CrateContext,\n                         sp: span,\n                         +path: path,\n                         node_id: ast::node_id,\n@@ -2148,7 +2165,7 @@ pub fn register_fn_full(ccx: @crate_ctxt,\n                        lib::llvm::CCallConv, llfty)\n }\n \n-pub fn register_fn_fuller(ccx: @crate_ctxt,\n+pub fn register_fn_fuller(ccx: @CrateContext,\n                           sp: span,\n                           +path: path,\n                           node_id: ast::node_id,\n@@ -2189,12 +2206,13 @@ pub fn is_main_fn(sess: &Session, node_id: ast::node_id) -> bool {\n \n // Create a _rust_main(args: ~[str]) function which will be called from the\n // runtime rust_start function\n-pub fn create_main_wrapper(ccx: @crate_ctxt, _sp: span, main_llfn: ValueRef) {\n+pub fn create_main_wrapper(ccx: @CrateContext,\n+                           _sp: span, main_llfn: ValueRef) {\n \n     let llfn = create_main(ccx, main_llfn);\n     create_entry_fn(ccx, llfn);\n \n-    fn create_main(ccx: @crate_ctxt, main_llfn: ValueRef) -> ValueRef {\n+    fn create_main(ccx: @CrateContext, main_llfn: ValueRef) -> ValueRef {\n         let nt = ty::mk_nil(ccx.tcx);\n         let llfty = type_of_fn(ccx, ~[], nt);\n         let llfdecl = decl_fn(ccx.llmod, ~\"_rust_main\",\n@@ -2216,7 +2234,7 @@ pub fn create_main_wrapper(ccx: @crate_ctxt, _sp: span, main_llfn: ValueRef) {\n         return llfdecl;\n     }\n \n-    fn create_entry_fn(ccx: @crate_ctxt, rust_main: ValueRef) {\n+    fn create_entry_fn(ccx: @CrateContext, rust_main: ValueRef) {\n         #[cfg(windows)]\n         fn main_name() -> ~str { return ~\"WinMain@16\"; }\n         #[cfg(unix)]\n@@ -2281,7 +2299,7 @@ pub fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n     Store(bcx, llenvblobptr, env_cell);\n }\n \n-pub fn item_path(ccx: @crate_ctxt, i: @ast::item) -> path {\n+pub fn item_path(ccx: @CrateContext, i: @ast::item) -> path {\n     vec::append(\n         /*bad*/copy *match ccx.tcx.items.get(&i.id) {\n             ast_map::node_item(_, p) => p,\n@@ -2293,7 +2311,7 @@ pub fn item_path(ccx: @crate_ctxt, i: @ast::item) -> path {\n \n /* If there's already a symbol for the dtor with <id> and substs <substs>,\n    return it; otherwise, create one and register it, returning it as well */\n-pub fn get_dtor_symbol(ccx: @crate_ctxt,\n+pub fn get_dtor_symbol(ccx: @CrateContext,\n                        +path: path,\n                        id: ast::node_id,\n                        substs: Option<@param_substs>)\n@@ -2331,7 +2349,7 @@ pub fn get_dtor_symbol(ccx: @crate_ctxt,\n   }\n }\n \n-pub fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n+pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n     debug!(\"get_item_val(id=`%?`)\", id);\n     let tcx = ccx.tcx;\n     match ccx.item_vals.find(&id) {\n@@ -2500,7 +2518,7 @@ pub fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n     }\n }\n \n-pub fn register_method(ccx: @crate_ctxt,\n+pub fn register_method(ccx: @CrateContext,\n                        id: ast::node_id,\n                        pth: @ast_map::path,\n                        m: @ast::method) -> ValueRef {\n@@ -2513,7 +2531,7 @@ pub fn register_method(ccx: @crate_ctxt,\n }\n \n // The constant translation pass.\n-pub fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n+pub fn trans_constant(ccx: @CrateContext, it: @ast::item) {\n     let _icx = ccx.insn_ctxt(\"trans_constant\");\n     match it.node {\n       ast::item_enum(ref enum_definition, _) => {\n@@ -2550,7 +2568,7 @@ pub fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n     }\n }\n \n-pub fn trans_constants(ccx: @crate_ctxt, crate: &ast::crate) {\n+pub fn trans_constants(ccx: @CrateContext, crate: &ast::crate) {\n     visit::visit_crate(\n         *crate, (),\n         visit::mk_simple_visitor(@visit::SimpleVisitor {\n@@ -2564,7 +2582,7 @@ pub fn vp2i(cx: block, v: ValueRef) -> ValueRef {\n     return PtrToInt(cx, v, ccx.int_type);\n }\n \n-pub fn p2i(ccx: @crate_ctxt, v: ValueRef) -> ValueRef {\n+pub fn p2i(ccx: @CrateContext, v: ValueRef) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstPtrToInt(v, ccx.int_type);\n     }\n@@ -2784,7 +2802,7 @@ pub fn trap(bcx: block) {\n     }\n }\n \n-pub fn decl_gc_metadata(ccx: @crate_ctxt, llmod_id: ~str) {\n+pub fn decl_gc_metadata(ccx: @CrateContext, llmod_id: ~str) {\n     if !ccx.sess.opts.gc || !ccx.uses_gc {\n         return;\n     }\n@@ -2802,7 +2820,7 @@ pub fn decl_gc_metadata(ccx: @crate_ctxt, llmod_id: ~str) {\n     }\n }\n \n-pub fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n+pub fn create_module_map(ccx: @CrateContext) -> ValueRef {\n     let elttype = T_struct(~[ccx.int_type, ccx.int_type]);\n     let maptype = T_array(elttype, ccx.module_data.len() + 1);\n     let map = str::as_c_str(~\"_rust_mod_map\", |buf| {\n@@ -2828,7 +2846,7 @@ pub fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n }\n \n \n-pub fn decl_crate_map(sess: session::Session, mapmeta: link_meta,\n+pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n                       llmod: ModuleRef) -> ValueRef {\n     let targ_cfg = sess.targ_cfg;\n     let int_type = T_int(targ_cfg);\n@@ -2853,7 +2871,7 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: link_meta,\n     return map;\n }\n \n-pub fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n+pub fn fill_crate_map(ccx: @CrateContext, map: ValueRef) {\n     let mut subcrates: ~[ValueRef] = ~[];\n     let mut i = 1;\n     let cstore = ccx.sess.cstore;\n@@ -2894,12 +2912,13 @@ pub fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n     }\n }\n \n-pub fn crate_ctxt_to_encode_parms(cx: @crate_ctxt) -> encoder::encode_parms {\n+pub fn crate_ctxt_to_encode_parms(cx: @CrateContext)\n+    -> encoder::EncodeParams {\n     let encode_inlined_item: encoder::encode_inlined_item =\n         |ecx, ebml_w, path, ii|\n         astencode::encode_inlined_item(ecx, ebml_w, path, ii, cx.maps);\n \n-    return {\n+    encoder::EncodeParams {\n         diag: cx.sess.diagnostic(),\n         tcx: cx.tcx,\n         reachable: cx.reachable,\n@@ -2909,10 +2928,10 @@ pub fn crate_ctxt_to_encode_parms(cx: @crate_ctxt) -> encoder::encode_parms {\n         link_meta: /*bad*/copy cx.link_meta,\n         cstore: cx.sess.cstore,\n         encode_inlined_item: encode_inlined_item\n-    };\n+    }\n }\n \n-pub fn write_metadata(cx: @crate_ctxt, crate: &ast::crate) {\n+pub fn write_metadata(cx: @CrateContext, crate: &ast::crate) {\n     if !*cx.sess.building_library { return; }\n     let encode_parms = crate_ctxt_to_encode_parms(cx);\n     let llmeta = C_bytes(encoder::encode_metadata(encode_parms, crate));\n@@ -2940,7 +2959,7 @@ pub fn write_metadata(cx: @crate_ctxt, crate: &ast::crate) {\n }\n \n // Writes the current ABI version into the crate.\n-pub fn write_abi_version(ccx: @crate_ctxt) {\n+pub fn write_abi_version(ccx: @CrateContext) {\n     mk_global(ccx, ~\"rust_abi_version\", C_uint(ccx, abi::abi_version),\n                      false);\n }\n@@ -2950,7 +2969,7 @@ pub fn trans_crate(sess: session::Session,\n                    tcx: ty::ctxt,\n                    output: &Path,\n                    emap2: resolve::ExportMap2,\n-                   maps: astencode::Maps) -> (ModuleRef, link_meta) {\n+                   maps: astencode::Maps) -> (ModuleRef, LinkMeta) {\n \n     let symbol_hasher = @hash::default_state();\n     let link_meta =\n@@ -3003,7 +3022,7 @@ pub fn trans_crate(sess: session::Session,\n             None\n         };\n \n-        let ccx = @crate_ctxt {\n+        let ccx = @CrateContext {\n               sess: sess,\n               llmod: llmod,\n               td: td,"}, {"sha": "c1dac70ae97d957a9574bf4ebaea80e6f29d07da", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -256,7 +256,7 @@ pub fn trans_fn_ref_with_vtables(\n         // Should be either intra-crate or inlined.\n         assert def_id.crate == ast::local_crate;\n \n-        let mut {val, must_cast} =\n+        let mut (val, must_cast) =\n             monomorphize::monomorphic_fn(ccx, def_id, type_params,\n                                          vtables, opt_impl_did, Some(ref_id));\n         if must_cast && ref_id != 0 {\n@@ -410,7 +410,7 @@ pub fn body_contains_ret(body: ast::blk) -> bool {\n // See [Note-arg-mode]\n pub fn trans_call_inner(\n     ++in_cx: block,\n-    call_info: Option<node_info>,\n+    call_info: Option<NodeInfo>,\n     fn_expr_ty: ty::t,\n     ret_ty: ty::t,\n     get_callee: fn(block) -> Callee,\n@@ -510,8 +510,8 @@ pub fn trans_call_inner(\n         } else if ret_in_loop {\n             let ret_flag_result = bool_to_i1(bcx, Load(bcx, ret_flag.get()));\n             bcx = do with_cond(bcx, ret_flag_result) |bcx| {\n-                do option::iter(&copy bcx.fcx.loop_ret) |lret| {\n-                    Store(bcx, C_bool(true), lret.flagptr);\n+                do option::iter(&copy bcx.fcx.loop_ret) |&(flagptr, _)| {\n+                    Store(bcx, C_bool(true), flagptr);\n                     Store(bcx, C_bool(false), bcx.fcx.llretptr);\n                 }\n                 base::cleanup_and_leave(bcx, None, Some(bcx.fcx.llreturn));\n@@ -529,14 +529,19 @@ pub enum CallArgs {\n     ArgVals(&[ValueRef])\n }\n \n+pub struct Args {\n+    bcx: block,\n+    args: ~[ValueRef],\n+    retslot: ValueRef\n+}\n+\n pub fn trans_args(cx: block,\n                   llenv: ValueRef,\n                   +args: CallArgs,\n                   fn_ty: ty::t,\n                   dest: expr::Dest,\n                   ret_flag: Option<ValueRef>,\n-                  +autoref_arg: AutorefArg)\n-               -> {bcx: block, args: ~[ValueRef], retslot: ValueRef} {\n+                  +autoref_arg: AutorefArg) -> Args {\n     let _icx = cx.insn_ctxt(\"trans_args\");\n     let mut temp_cleanups = ~[];\n     let arg_tys = ty::ty_fn_args(fn_ty);\n@@ -593,7 +598,7 @@ pub fn trans_args(cx: block,\n         revoke_clean(bcx, *c)\n     }\n \n-    return {bcx: bcx, args: llargs, retslot: llretslot};\n+    Args { bcx: bcx, args: llargs, retslot: llretslot }\n }\n \n pub enum AutorefArg {"}, {"sha": "94051f1ce13d604fe642ce972fca14a186e250e1", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -131,7 +131,7 @@ pub impl EnvAction {\n }\n \n pub impl EnvValue {\n-    fn to_str(ccx: @crate_ctxt) -> ~str {\n+    fn to_str(ccx: @CrateContext) -> ~str {\n         fmt!(\"%s(%s)\", self.action.to_str(), self.datum.to_str(ccx))\n     }\n }\n@@ -192,19 +192,19 @@ pub fn allocate_cbox(bcx: block, sigil: ast::Sigil, cdata_ty: ty::t)\n     }\n }\n \n-pub type closure_result = {\n-    llbox: ValueRef,     // llvalue of ptr to closure\n-    cdata_ty: ty::t,      // type of the closure data\n-    bcx: block     // final bcx\n-};\n+pub struct ClosureResult {\n+    llbox: ValueRef, // llvalue of ptr to closure\n+    cdata_ty: ty::t, // type of the closure data\n+    bcx: block       // final bcx\n+}\n \n // Given a block context and a list of tydescs and values to bind\n // construct a closure out of them. If copying is true, it is a\n // heap allocated closure that copies the upvars into environment.\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n pub fn store_environment(bcx: block,\n                          bound_values: ~[EnvValue],\n-                         sigil: ast::Sigil) -> closure_result {\n+                         sigil: ast::Sigil) -> ClosureResult {\n     let _icx = bcx.insn_ctxt(\"closure::store_environment\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n@@ -254,15 +254,15 @@ pub fn store_environment(bcx: block,\n         revoke_clean(bcx, *cleanup);\n     }\n \n-    return {llbox: llbox, cdata_ty: cdata_ty, bcx: bcx};\n+    ClosureResult { llbox: llbox, cdata_ty: cdata_ty, bcx: bcx }\n }\n \n // Given a context and a list of upvars, build a closure. This just\n // collects the upvars and packages them up for store_environment.\n pub fn build_closure(bcx0: block,\n                      cap_vars: &[moves::CaptureVar],\n                      sigil: ast::Sigil,\n-                     include_ret_handle: Option<ValueRef>) -> closure_result {\n+                     include_ret_handle: Option<ValueRef>) -> ClosureResult {\n     let _icx = bcx0.insn_ctxt(\"closure::build_closure\");\n     // If we need to, package up the iterator body to call\n     let mut bcx = bcx0;;\n@@ -302,7 +302,7 @@ pub fn build_closure(bcx0: block,\n         // Return value (we just pass a by-ref () and cast it later to\n         // the right thing):\n         let ret_true = match bcx.fcx.loop_ret {\n-            Some({retptr, _}) => retptr,\n+            Some((_, retptr)) => retptr,\n             None => bcx.fcx.llretptr\n         };\n         let ret_casted = PointerCast(bcx, ret_true, T_ptr(T_nil()));\n@@ -360,7 +360,7 @@ pub fn load_environment(fcx: fn_ctxt,\n         let flagptr = Load(bcx, GEPi(bcx, llcdata, [0u, i]));\n         let retptr = Load(bcx,\n                           GEPi(bcx, llcdata, [0u, i+1u]));\n-        fcx.loop_ret = Some({flagptr: flagptr, retptr: retptr});\n+        fcx.loop_ret = Some((flagptr, retptr));\n     }\n }\n \n@@ -418,8 +418,8 @@ pub fn trans_expr_fn(bcx: block,\n             let cap_vars = ccx.maps.capture_map.get(&user_id);\n             let ret_handle = match is_loop_body {Some(x) => x,\n                                                  None => None};\n-            let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, sigil,\n-                                                       ret_handle);\n+            let ClosureResult {llbox, cdata_ty, bcx}\n+                = build_closure(bcx, cap_vars, sigil, ret_handle);\n             trans_closure(ccx, sub_path, decl,\n                           body, llfn, no_self,\n                           /*bad*/ copy bcx.fcx.param_substs, user_id, None,"}, {"sha": "9f39cc8575d019f5c095f52dfeec94b2a3c31e2f", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 66, "deletions": 63, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -21,9 +21,9 @@ use driver::session;\n use driver::session::Session;\n use lib::llvm::{ModuleRef, ValueRef, TypeRef, BasicBlockRef, BuilderRef};\n use lib::llvm::{True, False, Bool};\n-use lib::llvm::{llvm, target_data, type_names, associate_type, name_has_type};\n+use lib::llvm::{llvm, TargetData, TypeNames, associate_type, name_has_type};\n use lib;\n-use metadata::common::link_meta;\n+use metadata::common::LinkMeta;\n use metadata::{csearch};\n use middle::astencode;\n use middle::resolve;\n@@ -136,7 +136,7 @@ pub struct Stats {\n     n_closures: uint,\n     llvm_insn_ctxt: @mut ~[~str],\n     llvm_insns: HashMap<~str, uint>,\n-    fn_times: @mut ~[{ident: ~str, time: int}]\n+    fn_times: @mut ~[(~str, int)] // (ident, time)\n }\n \n pub struct BuilderRef_res {\n@@ -157,18 +157,18 @@ pub fn BuilderRef_res(B: BuilderRef) -> BuilderRef_res {\n type ExternMap = HashMap<@str, ValueRef>;\n \n // Crate context.  Every crate we compile has one of these.\n-pub struct crate_ctxt {\n+pub struct CrateContext {\n      sess: session::Session,\n      llmod: ModuleRef,\n-     td: target_data,\n-     tn: type_names,\n+     td: TargetData,\n+     tn: @TypeNames,\n      externs: ExternMap,\n      intrinsics: HashMap<~str, ValueRef>,\n      item_vals: HashMap<ast::node_id, ValueRef>,\n      exp_map2: resolve::ExportMap2,\n      reachable: reachable::map,\n      item_symbols: HashMap<ast::node_id, ~str>,\n-     link_meta: link_meta,\n+     link_meta: LinkMeta,\n      enum_sizes: HashMap<ty::t, uint>,\n      discrims: HashMap<ast::def_id, ValueRef>,\n      discrim_symbols: HashMap<ast::node_id, ~str>,\n@@ -212,7 +212,7 @@ pub struct crate_ctxt {\n      tcx: ty::ctxt,\n      maps: astencode::Maps,\n      stats: @mut Stats,\n-     upcalls: @upcall::upcalls,\n+     upcalls: @upcall::Upcalls,\n      tydesc_type: TypeRef,\n      int_type: TypeRef,\n      float_type: TypeRef,\n@@ -225,7 +225,7 @@ pub struct crate_ctxt {\n      // decl_gc_metadata knows whether to link to the module metadata, which\n      // is not emitted by LLVM's GC pass when no functions use GC.\n      mut uses_gc: bool,\n-     dbg_cx: Option<debuginfo::debug_ctxt>,\n+     dbg_cx: Option<debuginfo::DebugContext>,\n      mut do_not_commit_warning_issued: bool\n }\n \n@@ -291,8 +291,8 @@ pub struct fn_ctxt_ {\n     // outputting the resume instruction.\n     mut personality: Option<ValueRef>,\n     // If this is a for-loop body that returns, this holds the pointers needed\n-    // for that\n-    mut loop_ret: Option<{flagptr: ValueRef, retptr: ValueRef}>,\n+    // for that (flagptr, retptr)\n+    mut loop_ret: Option<(ValueRef, ValueRef)>,\n \n     // Maps arguments to allocas created for them in llallocas.\n     llargs: HashMap<ast::node_id, local_val>,\n@@ -319,12 +319,12 @@ pub struct fn_ctxt_ {\n     path: path,\n \n     // This function's enclosing crate context.\n-    ccx: @crate_ctxt\n+    ccx: @CrateContext\n }\n \n pub type fn_ctxt = @fn_ctxt_;\n \n-pub fn warn_not_to_commit(ccx: @crate_ctxt, msg: ~str) {\n+pub fn warn_not_to_commit(ccx: @CrateContext, msg: ~str) {\n     if !ccx.do_not_commit_warning_issued {\n         ccx.do_not_commit_warning_issued = true;\n         ccx.sess.warn(msg + ~\" -- do not commit like this!\");\n@@ -350,7 +350,10 @@ pub enum cleanup {\n \n // Used to remember and reuse existing cleanup paths\n // target: none means the path ends in an resume instruction\n-pub type cleanup_path = {target: Option<BasicBlockRef>, dest: BasicBlockRef};\n+pub struct cleanup_path {\n+    target: Option<BasicBlockRef>,\n+    dest: BasicBlockRef\n+}\n \n pub fn scope_clean_changed(scope_info: scope_info) {\n     if scope_info.cleanup_paths.len() > 0u { scope_info.cleanup_paths = ~[]; }\n@@ -372,17 +375,17 @@ pub fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n // non-immediates, we must add an additional level of indirection, which\n // allows us to alloca a pointer with the right addrspace.\n pub fn root_for_cleanup(bcx: block, v: ValueRef, t: ty::t)\n-    -> {root: ValueRef, rooted: bool} {\n+    -> (ValueRef, bool) {\n     let ccx = bcx.ccx();\n \n     let addrspace = base::get_tydesc(ccx, t).addrspace;\n     if addrspace > gc_box_addrspace {\n         let llty = type_of::type_of_rooted(ccx, t);\n         let root = base::alloca(bcx, llty);\n         build::Store(bcx, build::PointerCast(bcx, v, llty), root);\n-        {root: root, rooted: true}\n+        (root, true)\n     } else {\n-        {root: v, rooted: false}\n+        (v, false)\n     }\n }\n \n@@ -391,7 +394,7 @@ pub fn add_clean(bcx: block, val: ValueRef, t: ty::t) {\n     debug!(\"add_clean(%s, %s, %s)\",\n            bcx.to_str(), val_str(bcx.ccx().tn, val),\n            ty_to_str(bcx.ccx().tcx, t));\n-    let {root, rooted} = root_for_cleanup(bcx, val, t);\n+    let (root, rooted) = root_for_cleanup(bcx, val, t);\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     do in_scope_cx(bcx) |scope_info| {\n         scope_info.cleanups.push(\n@@ -419,7 +422,7 @@ pub fn add_clean_temp_mem(bcx: block, val: ValueRef, t: ty::t) {\n     debug!(\"add_clean_temp_mem(%s, %s, %s)\",\n            bcx.to_str(), val_str(bcx.ccx().tn, val),\n            ty_to_str(bcx.ccx().tcx, t));\n-    let {root, rooted} = root_for_cleanup(bcx, val, t);\n+    let (root, rooted) = root_for_cleanup(bcx, val, t);\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     do in_scope_cx(bcx) |scope_info| {\n         scope_info.cleanups.push(\n@@ -432,7 +435,7 @@ pub fn add_clean_frozen_root(bcx: block, val: ValueRef, t: ty::t) {\n     debug!(\"add_clean_frozen_root(%s, %s, %s)\",\n            bcx.to_str(), val_str(bcx.ccx().tn, val),\n            ty_to_str(bcx.ccx().tcx, t));\n-    let {root, rooted} = root_for_cleanup(bcx, val, t);\n+    let (root, rooted) = root_for_cleanup(bcx, val, t);\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     do in_scope_cx(bcx) |scope_info| {\n         scope_info.cleanups.push(\n@@ -530,34 +533,34 @@ pub struct scope_info {\n }\n \n pub trait get_node_info {\n-    fn info() -> Option<node_info>;\n+    fn info() -> Option<NodeInfo>;\n }\n \n pub impl get_node_info for @ast::expr {\n-    fn info() -> Option<node_info> {\n-        Some({id: self.id, span: self.span})\n+    fn info() -> Option<NodeInfo> {\n+        Some(NodeInfo { id: self.id, span: self.span })\n     }\n }\n \n pub impl get_node_info for ast::blk {\n-    fn info() -> Option<node_info> {\n-        Some({id: self.node.id, span: self.span})\n+    fn info() -> Option<NodeInfo> {\n+        Some(NodeInfo { id: self.node.id, span: self.span })\n     }\n }\n \n // XXX: Work around a trait parsing bug. remove after snapshot\n pub type optional_boxed_ast_expr = Option<@ast::expr>;\n \n pub impl get_node_info for optional_boxed_ast_expr {\n-    fn info() -> Option<node_info> {\n+    fn info() -> Option<NodeInfo> {\n         self.chain_ref(|s| s.info())\n     }\n }\n \n-pub type node_info = {\n+pub struct NodeInfo {\n     id: ast::node_id,\n     span: span\n-};\n+}\n \n // Basic block context.  We create a block context for each basic block\n // (single-entry, single-exit sequence of instructions) we generate from Rust\n@@ -579,14 +582,14 @@ pub struct block_ {\n     // Is this block part of a landing pad?\n     is_lpad: bool,\n     // info about the AST node this block originated from, if any\n-    node_info: Option<node_info>,\n+    node_info: Option<NodeInfo>,\n     // The function context for the function to which this block is\n     // attached.\n     fcx: fn_ctxt\n }\n \n pub fn block_(llbb: BasicBlockRef, parent: Option<block>, -kind: block_kind,\n-              is_lpad: bool, node_info: Option<node_info>, fcx: fn_ctxt)\n+              is_lpad: bool, node_info: Option<NodeInfo>, fcx: fn_ctxt)\n     -> block_ {\n \n     block_ {\n@@ -606,7 +609,7 @@ pub fn block_(llbb: BasicBlockRef, parent: Option<block>, -kind: block_kind,\n pub enum block = @block_;\n \n pub fn mk_block(llbb: BasicBlockRef, parent: Option<block>, -kind: block_kind,\n-            is_lpad: bool, node_info: Option<node_info>, fcx: fn_ctxt)\n+            is_lpad: bool, node_info: Option<NodeInfo>, fcx: fn_ctxt)\n     -> block {\n     block(@block_(llbb, parent, kind, is_lpad, node_info, fcx))\n }\n@@ -630,7 +633,7 @@ pub impl Result {\n     }\n }\n \n-pub fn ty_str(tn: type_names, t: TypeRef) -> @str {\n+pub fn ty_str(tn: @TypeNames, t: TypeRef) -> @str {\n     return lib::llvm::type_to_str(tn, t);\n }\n \n@@ -640,7 +643,7 @@ pub fn val_ty(v: ValueRef) -> TypeRef {\n     }\n }\n \n-pub fn val_str(tn: type_names, v: ValueRef) -> @str {\n+pub fn val_str(tn: @TypeNames, v: ValueRef) -> @str {\n     return ty_str(tn, val_ty(v));\n }\n \n@@ -684,7 +687,7 @@ pub fn block_parent(cx: block) -> block {\n // Accessors\n \n pub impl block {\n-    pure fn ccx() -> @crate_ctxt { self.fcx.ccx }\n+    pure fn ccx() -> @CrateContext { self.fcx.ccx }\n     pure fn tcx() -> ty::ctxt { self.fcx.ccx.tcx }\n     pure fn sess() -> Session { self.fcx.ccx.sess }\n \n@@ -774,7 +777,7 @@ pub fn T_int(targ_cfg: @session::config) -> TypeRef {\n     };\n }\n \n-pub fn T_int_ty(cx: @crate_ctxt, t: ast::int_ty) -> TypeRef {\n+pub fn T_int_ty(cx: @CrateContext, t: ast::int_ty) -> TypeRef {\n     match t {\n       ast::ty_i => cx.int_type,\n       ast::ty_char => T_char(),\n@@ -785,7 +788,7 @@ pub fn T_int_ty(cx: @crate_ctxt, t: ast::int_ty) -> TypeRef {\n     }\n }\n \n-pub fn T_uint_ty(cx: @crate_ctxt, t: ast::uint_ty) -> TypeRef {\n+pub fn T_uint_ty(cx: @CrateContext, t: ast::uint_ty) -> TypeRef {\n     match t {\n       ast::ty_u => cx.int_type,\n       ast::ty_u8 => T_i8(),\n@@ -795,7 +798,7 @@ pub fn T_uint_ty(cx: @crate_ctxt, t: ast::uint_ty) -> TypeRef {\n     }\n }\n \n-pub fn T_float_ty(cx: @crate_ctxt, t: ast::float_ty) -> TypeRef {\n+pub fn T_float_ty(cx: @CrateContext, t: ast::float_ty) -> TypeRef {\n     match t {\n       ast::ty_f => cx.float_type,\n       ast::ty_f32 => T_f32(),\n@@ -825,7 +828,7 @@ pub fn T_fn(inputs: ~[TypeRef], output: TypeRef) -> TypeRef {\n     }\n }\n \n-pub fn T_fn_pair(cx: @crate_ctxt, tfn: TypeRef) -> TypeRef {\n+pub fn T_fn_pair(cx: @CrateContext, tfn: TypeRef) -> TypeRef {\n     return T_struct(~[T_ptr(tfn), T_opaque_cbox_ptr(cx)]);\n }\n \n@@ -895,7 +898,7 @@ pub fn T_task(targ_cfg: @session::config) -> TypeRef {\n     return t;\n }\n \n-pub fn T_tydesc_field(cx: @crate_ctxt, field: uint) -> TypeRef {\n+pub fn T_tydesc_field(cx: @CrateContext, field: uint) -> TypeRef {\n     // Bit of a kludge: pick the fn typeref out of the tydesc..\n \n     unsafe {\n@@ -910,7 +913,7 @@ pub fn T_tydesc_field(cx: @crate_ctxt, field: uint) -> TypeRef {\n     }\n }\n \n-pub fn T_generic_glue_fn(cx: @crate_ctxt) -> TypeRef {\n+pub fn T_generic_glue_fn(cx: @CrateContext) -> TypeRef {\n     let s = @\"glue_fn\";\n     match name_has_type(cx.tn, s) {\n       Some(t) => return t,\n@@ -951,7 +954,7 @@ pub fn T_vec2(targ_cfg: @session::config, t: TypeRef) -> TypeRef {\n                   T_array(t, 0u)]); // elements\n }\n \n-pub fn T_vec(ccx: @crate_ctxt, t: TypeRef) -> TypeRef {\n+pub fn T_vec(ccx: @CrateContext, t: TypeRef) -> TypeRef {\n     return T_vec2(ccx.sess.targ_cfg, t);\n }\n \n@@ -973,16 +976,16 @@ pub fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n                          t]);\n }\n \n-pub fn T_box_header_fields(cx: @crate_ctxt) -> ~[TypeRef] {\n+pub fn T_box_header_fields(cx: @CrateContext) -> ~[TypeRef] {\n     let ptr = T_ptr(T_i8());\n     return ~[cx.int_type, T_ptr(cx.tydesc_type), ptr, ptr];\n }\n \n-pub fn T_box_header(cx: @crate_ctxt) -> TypeRef {\n+pub fn T_box_header(cx: @CrateContext) -> TypeRef {\n     return T_struct(T_box_header_fields(cx));\n }\n \n-pub fn T_box(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n+pub fn T_box(cx: @CrateContext, t: TypeRef) -> TypeRef {\n     return T_struct(vec::append(T_box_header_fields(cx), ~[t]));\n }\n \n@@ -992,15 +995,15 @@ pub fn T_box_ptr(t: TypeRef) -> TypeRef {\n     }\n }\n \n-pub fn T_opaque_box(cx: @crate_ctxt) -> TypeRef {\n+pub fn T_opaque_box(cx: @CrateContext) -> TypeRef {\n     return T_box(cx, T_i8());\n }\n \n-pub fn T_opaque_box_ptr(cx: @crate_ctxt) -> TypeRef {\n+pub fn T_opaque_box_ptr(cx: @CrateContext) -> TypeRef {\n     return T_box_ptr(T_opaque_box(cx));\n }\n \n-pub fn T_unique(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n+pub fn T_unique(cx: @CrateContext, t: TypeRef) -> TypeRef {\n     return T_struct(vec::append(T_box_header_fields(cx), ~[t]));\n }\n \n@@ -1010,21 +1013,21 @@ pub fn T_unique_ptr(t: TypeRef) -> TypeRef {\n     }\n }\n \n-pub fn T_port(cx: @crate_ctxt, _t: TypeRef) -> TypeRef {\n+pub fn T_port(cx: @CrateContext, _t: TypeRef) -> TypeRef {\n     return T_struct(~[cx.int_type]); // Refcount\n \n }\n \n-pub fn T_chan(cx: @crate_ctxt, _t: TypeRef) -> TypeRef {\n+pub fn T_chan(cx: @CrateContext, _t: TypeRef) -> TypeRef {\n     return T_struct(~[cx.int_type]); // Refcount\n \n }\n \n-pub fn T_taskptr(cx: @crate_ctxt) -> TypeRef { return T_ptr(cx.task_type); }\n+pub fn T_taskptr(cx: @CrateContext) -> TypeRef { return T_ptr(cx.task_type); }\n \n \n // This type must never be used directly; it must always be cast away.\n-pub fn T_typaram(tn: type_names) -> TypeRef {\n+pub fn T_typaram(tn: @TypeNames) -> TypeRef {\n     let s = @\"typaram\";\n     match name_has_type(tn, s) {\n       Some(t) => return t,\n@@ -1035,21 +1038,21 @@ pub fn T_typaram(tn: type_names) -> TypeRef {\n     return t;\n }\n \n-pub fn T_typaram_ptr(tn: type_names) -> TypeRef {\n+pub fn T_typaram_ptr(tn: @TypeNames) -> TypeRef {\n     return T_ptr(T_typaram(tn));\n }\n \n-pub fn T_opaque_cbox_ptr(cx: @crate_ctxt) -> TypeRef {\n+pub fn T_opaque_cbox_ptr(cx: @CrateContext) -> TypeRef {\n     // closures look like boxes (even when they are fn~ or fn&)\n     // see trans_closure.rs\n     return T_opaque_box_ptr(cx);\n }\n \n-pub fn T_enum_discrim(cx: @crate_ctxt) -> TypeRef {\n+pub fn T_enum_discrim(cx: @CrateContext) -> TypeRef {\n     return cx.int_type;\n }\n \n-pub fn T_opaque_enum(cx: @crate_ctxt) -> TypeRef {\n+pub fn T_opaque_enum(cx: @CrateContext) -> TypeRef {\n     let s = @\"opaque_enum\";\n     match name_has_type(cx.tn, s) {\n       Some(t) => return t,\n@@ -1060,15 +1063,15 @@ pub fn T_opaque_enum(cx: @crate_ctxt) -> TypeRef {\n     return t;\n }\n \n-pub fn T_opaque_enum_ptr(cx: @crate_ctxt) -> TypeRef {\n+pub fn T_opaque_enum_ptr(cx: @CrateContext) -> TypeRef {\n     return T_ptr(T_opaque_enum(cx));\n }\n \n-pub fn T_captured_tydescs(cx: @crate_ctxt, n: uint) -> TypeRef {\n+pub fn T_captured_tydescs(cx: @CrateContext, n: uint) -> TypeRef {\n     return T_struct(vec::from_elem::<TypeRef>(n, T_ptr(cx.tydesc_type)));\n }\n \n-pub fn T_opaque_trait(cx: @crate_ctxt, vstore: ty::vstore) -> TypeRef {\n+pub fn T_opaque_trait(cx: @CrateContext, vstore: ty::vstore) -> TypeRef {\n     match vstore {\n         ty::vstore_box => {\n             T_struct(~[T_ptr(cx.tydesc_type), T_opaque_box_ptr(cx)])\n@@ -1126,11 +1129,11 @@ pub fn C_i64(i: i64) -> ValueRef {\n     return C_integral(T_i64(), i as u64, True);\n }\n \n-pub fn C_int(cx: @crate_ctxt, i: int) -> ValueRef {\n+pub fn C_int(cx: @CrateContext, i: int) -> ValueRef {\n     return C_integral(cx.int_type, i as u64, True);\n }\n \n-pub fn C_uint(cx: @crate_ctxt, i: uint) -> ValueRef {\n+pub fn C_uint(cx: @CrateContext, i: uint) -> ValueRef {\n     return C_integral(cx.int_type, i as u64, False);\n }\n \n@@ -1141,7 +1144,7 @@ pub fn C_u8(i: uint) -> ValueRef {\n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-pub fn C_cstr(cx: @crate_ctxt, s: @~str) -> ValueRef {\n+pub fn C_cstr(cx: @CrateContext, s: @~str) -> ValueRef {\n     unsafe {\n         match cx.const_cstr_cache.find(&s) {\n             Some(llval) => return llval,\n@@ -1166,7 +1169,7 @@ pub fn C_cstr(cx: @crate_ctxt, s: @~str) -> ValueRef {\n \n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n-pub fn C_estr_slice(cx: @crate_ctxt, s: @~str) -> ValueRef {\n+pub fn C_estr_slice(cx: @CrateContext, s: @~str) -> ValueRef {\n     unsafe {\n         let len = s.len();\n         let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), T_ptr(T_i8()));\n@@ -1241,7 +1244,7 @@ pub fn C_bytes_plus_null(bytes: ~[u8]) -> ValueRef {\n     }\n }\n \n-pub fn C_shape(ccx: @crate_ctxt, +bytes: ~[u8]) -> ValueRef {\n+pub fn C_shape(ccx: @CrateContext, +bytes: ~[u8]) -> ValueRef {\n     unsafe {\n         let llshape = C_bytes_plus_null(bytes);\n         let name = fmt!(\"shape%u\", (ccx.names)(~\"shape\").repr);"}, {"sha": "ab85da304cb890fd698f8bbe36d26c3b6f2338c9", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -20,7 +20,7 @@ use middle::ty;\n \n use syntax::{ast, ast_util, codemap, ast_map};\n \n-pub fn const_lit(cx: @crate_ctxt, e: @ast::expr, lit: ast::lit)\n+pub fn const_lit(cx: @CrateContext, e: @ast::expr, lit: ast::lit)\n     -> ValueRef {\n     let _icx = cx.insn_ctxt(\"trans_lit\");\n     match lit.node {\n@@ -59,15 +59,15 @@ pub fn const_lit(cx: @crate_ctxt, e: @ast::expr, lit: ast::lit)\n     }\n }\n \n-pub fn const_ptrcast(cx: @crate_ctxt, a: ValueRef, t: TypeRef) -> ValueRef {\n+pub fn const_ptrcast(cx: @CrateContext, a: ValueRef, t: TypeRef) -> ValueRef {\n     unsafe {\n         let b = llvm::LLVMConstPointerCast(a, T_ptr(t));\n         assert cx.const_globals.insert(b as int, a);\n         b\n     }\n }\n \n-pub fn const_vec(cx: @crate_ctxt, e: @ast::expr, es: &[@ast::expr])\n+pub fn const_vec(cx: @CrateContext, e: @ast::expr, es: &[@ast::expr])\n     -> (ValueRef, ValueRef, TypeRef) {\n     unsafe {\n         let vec_ty = ty::expr_ty(cx.tcx, e);\n@@ -86,7 +86,7 @@ pub fn const_vec(cx: @crate_ctxt, e: @ast::expr, es: &[@ast::expr])\n     }\n }\n \n-pub fn const_deref(cx: @crate_ctxt, v: ValueRef) -> ValueRef {\n+pub fn const_deref(cx: @CrateContext, v: ValueRef) -> ValueRef {\n     unsafe {\n         let v = match cx.const_globals.find(&(v as int)) {\n             Some(v) => v,\n@@ -98,7 +98,7 @@ pub fn const_deref(cx: @crate_ctxt, v: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn const_get_elt(cx: @crate_ctxt, v: ValueRef, us: &[c_uint])\n+pub fn const_get_elt(cx: @CrateContext, v: ValueRef, us: &[c_uint])\n                   -> ValueRef {\n     unsafe {\n         let r = do vec::as_imm_buf(us) |p, len| {\n@@ -112,7 +112,7 @@ pub fn const_get_elt(cx: @crate_ctxt, v: ValueRef, us: &[c_uint])\n     }\n }\n \n-pub fn const_autoderef(cx: @crate_ctxt, ty: ty::t, v: ValueRef)\n+pub fn const_autoderef(cx: @CrateContext, ty: ty::t, v: ValueRef)\n     -> (ty::t, ValueRef) {\n     let mut t1 = ty;\n     let mut v1 = v;\n@@ -128,7 +128,7 @@ pub fn const_autoderef(cx: @crate_ctxt, ty: ty::t, v: ValueRef)\n     }\n }\n \n-pub fn get_const_val(cx: @crate_ctxt, def_id: ast::def_id) -> ValueRef {\n+pub fn get_const_val(cx: @CrateContext, def_id: ast::def_id) -> ValueRef {\n     if !ast_util::is_local(def_id) {\n         cx.tcx.sess.bug(~\"cross-crate constants\");\n     }\n@@ -145,7 +145,7 @@ pub fn get_const_val(cx: @crate_ctxt, def_id: ast::def_id) -> ValueRef {\n     cx.const_values.get(&def_id.node)\n }\n \n-pub fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n+pub fn const_expr(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n     unsafe {\n         let _icx = cx.insn_ctxt(\"const_expr\");\n         return match /*bad*/copy e.node {\n@@ -483,7 +483,7 @@ pub fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n     }\n }\n \n-pub fn trans_const(ccx: @crate_ctxt, _e: @ast::expr, id: ast::node_id) {\n+pub fn trans_const(ccx: @CrateContext, _e: @ast::expr, id: ast::node_id) {\n     unsafe {\n         let _icx = ccx.insn_ctxt(\"trans_const\");\n         let g = base::get_item_val(ccx, id);"}, {"sha": "b5aab1f3ac5e9d162f803dc757aecf8cddfb05ff", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -289,7 +289,7 @@ pub fn trans_ret(bcx: block, e: Option<@ast::expr>) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_ret\");\n     let mut bcx = bcx;\n     let retptr = match copy bcx.fcx.loop_ret {\n-      Some({flagptr, retptr}) => {\n+      Some((flagptr, retptr)) => {\n         // This is a loop body return. Must set continue flag (our retptr)\n         // to false, return flag to true, and then store the value in the\n         // parent's retptr.\n@@ -375,16 +375,15 @@ fn trans_fail_value(bcx: block,\n                  -> block {\n     let _icx = bcx.insn_ctxt(\"trans_fail_value\");\n     let ccx = bcx.ccx();\n-    let {V_filename, V_line} = match sp_opt {\n+    let (V_filename, V_line) = match sp_opt {\n       Some(sp) => {\n         let sess = bcx.sess();\n         let loc = sess.parse_sess.cm.lookup_char_pos(sp.lo);\n-        {V_filename: C_cstr(bcx.ccx(), @/*bad*/ copy loc.file.name),\n-         V_line: loc.line as int}\n+        (C_cstr(bcx.ccx(), @/*bad*/ copy loc.file.name),\n+         loc.line as int)\n       }\n       None => {\n-        {V_filename: C_cstr(bcx.ccx(), @~\"<runtime>\"),\n-         V_line: 0}\n+        (C_cstr(bcx.ccx(), @~\"<runtime>\"), 0)\n       }\n     };\n     let V_str = PointerCast(bcx, V_fail_str, T_ptr(T_i8()));"}, {"sha": "ffeffa5775e9cda31391b5b90f1e055982d9062a", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -396,7 +396,7 @@ pub impl Datum {\n         }\n     }\n \n-    fn to_str(ccx: &crate_ctxt) -> ~str {\n+    fn to_str(ccx: &CrateContext) -> ~str {\n         fmt!(\"Datum { val=%s, ty=%s, mode=%?, source=%? }\",\n              val_str(ccx.tn, self.val),\n              ty_to_str(ccx.tcx, self.ty),\n@@ -530,7 +530,7 @@ pub impl Datum {\n         if bcx.sess().trace() {\n             trans_trace(\n                 bcx, None,\n-                fmt!(\"preserving until end of scope %d\",\n+                @fmt!(\"preserving until end of scope %d\",\n                      root_info.scope));\n         }\n \n@@ -841,7 +841,7 @@ pub impl DatumBlock {\n         rslt(self.bcx, self.datum.to_appropriate_llval(self.bcx))\n     }\n \n-    fn ccx() -> @crate_ctxt {\n+    fn ccx() -> @CrateContext {\n         self.bcx.ccx()\n     }\n "}, {"sha": "641c3e6b0a38d193d20df664ba71923e23d92a2d", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 149, "deletions": 70, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -93,7 +93,7 @@ fn llnull() -> ValueRef {\n     }\n }\n \n-fn add_named_metadata(cx: @crate_ctxt, name: ~str, val: ValueRef) {\n+fn add_named_metadata(cx: @CrateContext, name: ~str, val: ValueRef) {\n     str::as_c_str(name, |sbuf| {\n         unsafe {\n             llvm::LLVMAddNamedMetadataOperand(cx.llmod, sbuf, val)\n@@ -103,16 +103,18 @@ fn add_named_metadata(cx: @crate_ctxt, name: ~str, val: ValueRef) {\n \n ////////////////\n \n-pub type debug_ctxt = {\n+pub struct DebugContext {\n     llmetadata: metadata_cache,\n     names: namegen,\n     crate_file: ~str\n-};\n+}\n \n-pub fn mk_ctxt(+crate: ~str, intr: @ident_interner) -> debug_ctxt {\n-    {llmetadata: oldmap::HashMap(),\n-     names: new_namegen(intr),\n-     crate_file: crate}\n+pub fn mk_ctxt(+crate: ~str, intr: @ident_interner) -> DebugContext {\n+    DebugContext {\n+        llmetadata: oldmap::HashMap(),\n+        names: new_namegen(intr),\n+        crate_file: crate\n+    }\n }\n \n fn update_cache(cache: metadata_cache, mdtag: int, val: debug_metadata) {\n@@ -124,28 +126,48 @@ fn update_cache(cache: metadata_cache, mdtag: int, val: debug_metadata) {\n     cache.insert(mdtag, vec::append_one(existing, val));\n }\n \n-type metadata<T> = {node: ValueRef, data: T};\n+struct Metadata<T> {\n+    node: ValueRef,\n+    data: T\n+}\n \n-type file_md = {path: ~str};\n-type compile_unit_md = {name: ~str};\n-type subprogram_md = {id: ast::node_id};\n-type local_var_md = {id: ast::node_id};\n-type tydesc_md = {hash: uint};\n-type block_md = {start: codemap::Loc, end: codemap::Loc};\n-type argument_md = {id: ast::node_id};\n-type retval_md = {id: ast::node_id};\n+struct FileMetadata {\n+    path: ~str\n+}\n+struct CompileUnitMetadata {\n+    name: ~str\n+}\n+struct SubProgramMetadata {\n+    id: ast::node_id\n+}\n+struct LocalVarMetadata {\n+    id: ast::node_id\n+}\n+struct TyDescMetadata {\n+    hash: uint\n+}\n+struct BlockMetadata {\n+    start: codemap::Loc,\n+    end: codemap::Loc\n+}\n+struct ArgumentMetadata {\n+    id: ast::node_id\n+}\n+struct RetvalMetadata {\n+    id: ast::node_id\n+}\n \n type metadata_cache = HashMap<int, ~[debug_metadata]>;\n \n enum debug_metadata {\n-    file_metadata(@metadata<file_md>),\n-    compile_unit_metadata(@metadata<compile_unit_md>),\n-    subprogram_metadata(@metadata<subprogram_md>),\n-    local_var_metadata(@metadata<local_var_md>),\n-    tydesc_metadata(@metadata<tydesc_md>),\n-    block_metadata(@metadata<block_md>),\n-    argument_metadata(@metadata<argument_md>),\n-    retval_metadata(@metadata<retval_md>),\n+    file_metadata(@Metadata<FileMetadata>),\n+    compile_unit_metadata(@Metadata<CompileUnitMetadata>),\n+    subprogram_metadata(@Metadata<SubProgramMetadata>),\n+    local_var_metadata(@Metadata<LocalVarMetadata>),\n+    tydesc_metadata(@Metadata<TyDescMetadata>),\n+    block_metadata(@Metadata<BlockMetadata>),\n+    argument_metadata(@Metadata<ArgumentMetadata>),\n+    retval_metadata(@Metadata<RetvalMetadata>),\n }\n \n fn cast_safely<T: Copy, U>(val: T) -> U {\n@@ -188,12 +210,12 @@ fn cached_metadata<T: Copy>(cache: metadata_cache,\n     }\n }\n \n-fn create_compile_unit(cx: @crate_ctxt) -> @metadata<compile_unit_md> {\n+fn create_compile_unit(cx: @CrateContext) -> @Metadata<CompileUnitMetadata> {\n     unsafe {\n         let cache = get_cache(cx);\n         let crate_name = /*bad*/copy (/*bad*/copy cx.dbg_cx).get().crate_file;\n         let tg = CompileUnitTag;\n-        match cached_metadata::<@metadata<compile_unit_md>>(cache, tg,\n+        match cached_metadata::<@Metadata<CompileUnitMetadata>>(cache, tg,\n                             |md| md.data.name == crate_name) {\n           option::Some(md) => return md,\n           option::None => ()\n@@ -214,14 +236,19 @@ fn create_compile_unit(cx: @crate_ctxt) -> @metadata<compile_unit_md> {\n                             ];\n         let unit_node = llmdnode(unit_metadata);\n         add_named_metadata(cx, ~\"llvm.dbg.cu\", unit_node);\n-        let mdval = @{node: unit_node, data: {name: crate_name}};\n+        let mdval = @Metadata {\n+            node: unit_node,\n+            data: CompileUnitMetadata {\n+                name: crate_name\n+            }\n+        };\n         update_cache(cache, tg, compile_unit_metadata(mdval));\n \n         return mdval;\n     }\n }\n \n-fn get_cache(cx: @crate_ctxt) -> metadata_cache {\n+fn get_cache(cx: @CrateContext) -> metadata_cache {\n     (/*bad*/copy cx.dbg_cx).get().llmetadata\n }\n \n@@ -234,10 +261,11 @@ fn get_file_path_and_dir(work_dir: &str, full_path: &str) -> (~str, ~str) {\n     }, str::from_slice(work_dir))\n }\n \n-fn create_file(cx: @crate_ctxt, +full_path: ~str) -> @metadata<file_md> {\n+fn create_file(cx: @CrateContext, +full_path: ~str)\n+    -> @Metadata<FileMetadata> {\n     let cache = get_cache(cx);;\n     let tg = FileDescriptorTag;\n-    match cached_metadata::<@metadata<file_md>>(\n+    match cached_metadata::<@Metadata<FileMetadata>>(\n         cache, tg, |md| md.data.path == full_path) {\n         option::Some(md) => return md,\n         option::None => ()\n@@ -252,7 +280,12 @@ fn create_file(cx: @crate_ctxt, +full_path: ~str) -> @metadata<file_md> {\n                    llstr(work_dir),\n                    unit_node];\n     let val = llmdnode(file_md);\n-    let mdval = @{node: val, data: {path: full_path}};\n+    let mdval = @Metadata {\n+        node: val,\n+        data: FileMetadata {\n+            path: full_path\n+        }\n+    };\n     update_cache(cache, tg, file_metadata(mdval));\n     return mdval;\n }\n@@ -261,7 +294,7 @@ fn line_from_span(cm: @codemap::CodeMap, sp: span) -> uint {\n     cm.lookup_char_pos(sp.lo).line\n }\n \n-fn create_block(cx: block) -> @metadata<block_md> {\n+fn create_block(cx: block) -> @Metadata<BlockMetadata> {\n     let cache = get_cache(cx.ccx());\n     let mut cx = cx;\n     while cx.node_info.is_none() {\n@@ -276,7 +309,7 @@ fn create_block(cx: block) -> @metadata<block_md> {\n     let fname = /*bad*/copy start.file.name;\n     let end = cx.sess().codemap.lookup_char_pos(sp.hi);\n     let tg = LexicalBlockTag;\n-    /*match cached_metadata::<@metadata<block_md>>(\n+    /*match cached_metadata::<@Metadata<BlockMetadata>>(\n         cache, tg,\n         {|md| start == md.data.start && end == md.data.end}) {\n       option::Some(md) { return md; }\n@@ -300,22 +333,28 @@ fn create_block(cx: block) -> @metadata<block_md> {\n                   lli32(unique_id)\n                  ];\n     let val = llmdnode(lldata);\n-    let mdval = @{node: val, data: {start: start, end: end}};\n+    let mdval = @Metadata {\n+        node: val,\n+        data: BlockMetadata {\n+            start: start,\n+            end: end\n+        }\n+    };\n     //update_cache(cache, tg, block_metadata(mdval));\n     return mdval;\n }\n \n-fn size_and_align_of(cx: @crate_ctxt, t: ty::t) -> (int, int) {\n+fn size_and_align_of(cx: @CrateContext, t: ty::t) -> (int, int) {\n     let llty = type_of::type_of(cx, t);\n     (machine::llsize_of_real(cx, llty) as int,\n      machine::llalign_of_pref(cx, llty) as int)\n }\n \n-fn create_basic_type(cx: @crate_ctxt, t: ty::t, span: span)\n-    -> @metadata<tydesc_md> {\n+fn create_basic_type(cx: @CrateContext, t: ty::t, span: span)\n+    -> @Metadata<TyDescMetadata> {\n     let cache = get_cache(cx);\n     let tg = BasicTypeDescriptorTag;\n-    match cached_metadata::<@metadata<tydesc_md>>(\n+    match cached_metadata::<@Metadata<TyDescMetadata>>(\n         cache, tg, |md| ty::type_id(t) == md.data.hash) {\n       option::Some(md) => return md,\n       option::None => ()\n@@ -338,18 +377,23 @@ fn create_basic_type(cx: @crate_ctxt, t: ty::t, span: span)\n                   lli32(0), //XXX flags?\n                   lli32(encoding)];\n     let llnode = llmdnode(lldata);\n-    let mdval = @{node: llnode, data: {hash: ty::type_id(t)}};\n+    let mdval = @Metadata {\n+        node: llnode,\n+        data: TyDescMetadata {\n+            hash: ty::type_id(t)\n+        }\n+    };\n     update_cache(cache, tg, tydesc_metadata(mdval));\n     add_named_metadata(cx, ~\"llvm.dbg.ty\", llnode);\n     return mdval;\n }\n \n-fn create_pointer_type(cx: @crate_ctxt, t: ty::t, span: span,\n-                       pointee: @metadata<tydesc_md>)\n-    -> @metadata<tydesc_md> {\n+fn create_pointer_type(cx: @CrateContext, t: ty::t, span: span,\n+                       pointee: @Metadata<TyDescMetadata>)\n+    -> @Metadata<TyDescMetadata> {\n     let tg = PointerTypeTag;\n     /*let cache = cx.llmetadata;\n-    match cached_metadata::<@metadata<tydesc_md>>(\n+    match cached_metadata::<@Metadata<TyDescMetadata>>(\n         cache, tg, {|md| ty::hash_ty(t) == ty::hash_ty(md.data.hash)}) {\n       option::Some(md) { return md; }\n       option::None {}\n@@ -360,7 +404,12 @@ fn create_pointer_type(cx: @crate_ctxt, t: ty::t, span: span,\n     //let cu_node = create_compile_unit(cx, fname);\n     let llnode = create_derived_type(tg, file_node.node, ~\"\", 0, size * 8,\n                                      align * 8, 0, pointee.node);\n-    let mdval = @{node: llnode, data: {hash: ty::type_id(t)}};\n+    let mdval = @Metadata {\n+        node: llnode,\n+        data: TyDescMetadata {\n+            hash: ty::type_id(t)\n+        }\n+    };\n     //update_cache(cache, tg, tydesc_metadata(mdval));\n     add_named_metadata(cx, ~\"llvm.dbg.ty\", llnode);\n     return mdval;\n@@ -387,7 +436,7 @@ fn finish_structure(cx: @mut StructCtxt) -> ValueRef {\n                                  Some(/*bad*/copy cx.members));\n }\n \n-fn create_structure(file: @metadata<file_md>, name: @~str, line: int)\n+fn create_structure(file: @Metadata<FileMetadata>, name: @~str, line: int)\n                  -> @mut StructCtxt {\n     let cx = @mut StructCtxt {\n         file: file.node,\n@@ -428,8 +477,8 @@ fn add_member(cx: @mut StructCtxt,\n     cx.total_size += size * 8;\n }\n \n-fn create_record(cx: @crate_ctxt, t: ty::t, fields: ~[ast::ty_field],\n-                 span: span) -> @metadata<tydesc_md> {\n+fn create_record(cx: @CrateContext, t: ty::t, fields: ~[ast::ty_field],\n+                 span: span) -> @Metadata<TyDescMetadata> {\n     let fname = filename_from_span(cx, span);\n     let file_node = create_file(cx, fname);\n     let scx = create_structure(file_node,\n@@ -446,16 +495,21 @@ fn create_record(cx: @crate_ctxt, t: ty::t, fields: ~[ast::ty_field],\n                    line_from_span(cx.sess.codemap, field.span) as int,\n                    size as int, align as int, ty_md.node);\n     }\n-    let mdval = @{node: finish_structure(scx), data:{hash: ty::type_id(t)}};\n+    let mdval = @Metadata {\n+        node: finish_structure(scx),\n+        data: TyDescMetadata {\n+            hash: ty::type_id(t)\n+        }\n+    };\n     return mdval;\n }\n \n-fn create_boxed_type(cx: @crate_ctxt, outer: ty::t, _inner: ty::t,\n-                     span: span, boxed: @metadata<tydesc_md>)\n-    -> @metadata<tydesc_md> {\n+fn create_boxed_type(cx: @CrateContext, outer: ty::t, _inner: ty::t,\n+                     span: span, boxed: @Metadata<TyDescMetadata>)\n+    -> @Metadata<TyDescMetadata> {\n     //let tg = StructureTypeTag;\n     /*let cache = cx.llmetadata;\n-    match cached_metadata::<@metadata<tydesc_md>>(\n+    match cached_metadata::<@Metadata<TyDescMetadata>>(\n         cache, tg, {|md| ty::hash_ty(outer) == ty::hash_ty(md.data.hash)}) {\n       option::Some(md) { return md; }\n       option::None {}\n@@ -473,7 +527,12 @@ fn create_boxed_type(cx: @crate_ctxt, outer: ty::t, _inner: ty::t,\n                8, //XXX just a guess\n                boxed.node);\n     let llnode = finish_structure(scx);\n-    let mdval = @{node: llnode, data: {hash: ty::type_id(outer)}};\n+    let mdval = @Metadata {\n+        node: llnode,\n+        data: TyDescMetadata {\n+            hash: ty::type_id(outer)\n+        }\n+    };\n     //update_cache(cache, tg, tydesc_metadata(mdval));\n     add_named_metadata(cx, ~\"llvm.dbg.ty\", llnode);\n     return mdval;\n@@ -509,9 +568,9 @@ fn create_composite_type(type_tag: int, name: &str, file: ValueRef,\n     return llmdnode(lldata);\n }\n \n-fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n+fn create_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n               vec_ty_span: codemap::span, elem_ty: @ast::Ty)\n-    -> @metadata<tydesc_md> {\n+    -> @Metadata<TyDescMetadata> {\n     let fname = filename_from_span(cx, vec_ty_span);\n     let file_node = create_file(cx, fname);\n     let elem_ty_md = create_ty(cx, elem_t, elem_ty);\n@@ -531,13 +590,18 @@ fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n     add_member(scx, ~\"data\", 0, 0, // clang says the size should be 0\n                sys::min_align_of::<u8>() as int, data_ptr);\n     let llnode = finish_structure(scx);\n-    return @{node: llnode, data: {hash: ty::type_id(vec_t)}};\n+    @Metadata {\n+        node: llnode,\n+        data: TyDescMetadata {\n+            hash: ty::type_id(vec_t)\n+        }\n+    }\n }\n \n-fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::Ty)\n-    -> @metadata<tydesc_md> {\n+fn create_ty(_cx: @CrateContext, _t: ty::t, _ty: @ast::Ty)\n+    -> @Metadata<TyDescMetadata> {\n     /*let cache = get_cache(cx);\n-    match cached_metadata::<@metadata<tydesc_md>>(\n+    match cached_metadata::<@Metadata<TyDescMetadata>>(\n         cache, tg, {|md| t == md.data.hash}) {\n       option::Some(md) { return md; }\n       option::None {}\n@@ -556,7 +620,7 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::Ty)\n \n     fail!();\n     /*\n-    fn t_to_ty(cx: crate_ctxt, t: ty::t, span: span) -> @ast::ty {\n+    fn t_to_ty(cx: CrateContext, t: ty::t, span: span) -> @ast::ty {\n         let ty = match ty::get(t).struct {\n           ty::ty_nil { ast::ty_nil }\n           ty::ty_bot { ast::ty_bot }\n@@ -638,7 +702,7 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::Ty)\n     */\n }\n \n-fn filename_from_span(cx: @crate_ctxt, sp: codemap::span) -> ~str {\n+fn filename_from_span(cx: @CrateContext, sp: codemap::span) -> ~str {\n     /*bad*/copy cx.sess.codemap.lookup_char_pos(sp.lo).file.name\n }\n \n@@ -656,12 +720,12 @@ fn create_var(type_tag: int, context: ValueRef, name: &str, file: ValueRef,\n }\n \n pub fn create_local_var(bcx: block, local: @ast::local)\n-    -> @metadata<local_var_md> {\n+    -> @Metadata<LocalVarMetadata> {\n     unsafe {\n         let cx = bcx.ccx();\n         let cache = get_cache(cx);\n         let tg = AutoVariableTag;\n-        match cached_metadata::<@metadata<local_var_md>>(\n+        match cached_metadata::<@Metadata<LocalVarMetadata>>(\n             cache, tg, |md| md.data.id == local.node.id) {\n           option::Some(md) => return md,\n           option::None => ()\n@@ -682,7 +746,12 @@ pub fn create_local_var(bcx: block, local: @ast::local)\n         };\n         let mdnode = create_var(tg, context, *cx.sess.str_of(name),\n                                 filemd.node, loc.line as int, tymd.node);\n-        let mdval = @{node: mdnode, data: {id: local.node.id}};\n+        let mdval = @Metadata {\n+            node: mdnode,\n+            data: LocalVarMetadata {\n+                id: local.node.id\n+            }\n+        };\n         update_cache(cache, AutoVariableTag, local_var_metadata(mdval));\n \n         let llptr = match bcx.fcx.lllocals.find(&local.node.id) {\n@@ -707,12 +776,12 @@ pub fn create_local_var(bcx: block, local: @ast::local)\n }\n \n pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n-    -> Option<@metadata<argument_md>> {\n+    -> Option<@Metadata<ArgumentMetadata>> {\n     unsafe {\n         let fcx = bcx.fcx, cx = fcx.ccx;\n         let cache = get_cache(cx);\n         let tg = ArgVariableTag;\n-        match cached_metadata::<@metadata<argument_md>>(\n+        match cached_metadata::<@Metadata<ArgumentMetadata>>(\n             cache, ArgVariableTag, |md| md.data.id == arg.id) {\n           option::Some(md) => return Some(md),\n           option::None => ()\n@@ -734,7 +803,12 @@ pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n                                         loc.line as int,\n                                         tymd.node);\n \n-                let mdval = @{node: mdnode, data: {id: arg.id}};\n+                let mdval = @Metadata {\n+                    node: mdnode,\n+                    data: ArgumentMetadata {\n+                        id: arg.id\n+                    }\n+                };\n                 update_cache(cache, tg, argument_metadata(mdval));\n \n                 let llptr = match fcx.llargs.get(&arg.id) {\n@@ -770,7 +844,7 @@ pub fn update_source_pos(cx: block, s: span) {\n     }\n }\n \n-pub fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n+pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n     let cx = fcx.ccx;\n     let dbg_cx = (/*bad*/copy cx.dbg_cx).get();\n \n@@ -817,7 +891,7 @@ pub fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     log(debug, id);\n \n     let cache = get_cache(cx);\n-    match cached_metadata::<@metadata<subprogram_md>>(\n+    match cached_metadata::<@Metadata<SubProgramMetadata>>(\n         cache, SubprogramTag, |md| md.data.id == id) {\n       option::Some(md) => return md,\n       option::None => ()\n@@ -861,7 +935,12 @@ pub fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n                       ];\n     let val = llmdnode(fn_metadata);\n     add_named_metadata(cx, ~\"llvm.dbg.sp\", val);\n-    let mdval = @{node: val, data: {id: id}};\n+    let mdval = @Metadata {\n+        node: val,\n+        data: SubProgramMetadata {\n+            id: id\n+        }\n+    };\n     update_cache(cache, SubprogramTag, subprogram_metadata(mdval));\n \n     return mdval;"}, {"sha": "936c8cf1ce550e9925d8e185a49ebd050d4dc5bb", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -157,7 +157,7 @@ pub enum Dest {\n }\n \n impl Dest {\n-    fn to_str(ccx: @crate_ctxt) -> ~str {\n+    fn to_str(ccx: @CrateContext) -> ~str {\n         match self {\n             SaveIn(v) => fmt!(\"SaveIn(%s)\", val_str(ccx.tn, v)),\n             Ignore => ~\"Ignore\"\n@@ -409,7 +409,7 @@ fn trans_to_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     let _icx = bcx.insn_ctxt(\"trans_rvalue_datum_unadjusted\");\n \n-    trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n+    trace_span!(bcx, expr.span, @shorten(bcx.expr_to_str(expr)));\n \n     match expr.node {\n         ast::expr_vstore(contents, ast::expr_vstore_box) |\n@@ -456,7 +456,7 @@ fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n     let mut bcx = bcx;\n     let _icx = bcx.insn_ctxt(\"trans_rvalue_stmt\");\n \n-    trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n+    trace_span!(bcx, expr.span, @shorten(bcx.expr_to_str(expr)));\n \n     match expr.node {\n         ast::expr_break(label_opt) => {\n@@ -537,7 +537,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n     let _icx = bcx.insn_ctxt(\"trans_rvalue_dps_unadjusted\");\n     let tcx = bcx.tcx();\n \n-    trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n+    trace_span!(bcx, expr.span, @shorten(bcx.expr_to_str(expr)));\n \n     match expr.node {\n         ast::expr_paren(e) => {\n@@ -728,7 +728,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     debug!(\"trans_lvalue(expr=%s)\", bcx.expr_to_str(expr));\n     let _indenter = indenter();\n \n-    trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n+    trace_span!(bcx, expr.span, @shorten(bcx.expr_to_str(expr)));\n \n     let unrooted_datum = unpack_datum!(bcx, unrooted(bcx, expr));\n \n@@ -1290,7 +1290,7 @@ fn trans_unary_datum(bcx: block,\n                         contents_ty: ty::t,\n                         heap: heap) -> DatumBlock {\n         let _icx = bcx.insn_ctxt(\"trans_boxed_expr\");\n-        let {bcx, box: bx, body} =\n+        let base::MallocResult { bcx, box: bx, body } =\n             base::malloc_general(bcx, contents_ty, heap);\n         add_clean_free(bcx, bx, heap);\n         let bcx = trans_into(bcx, contents, SaveIn(body));\n@@ -1583,34 +1583,34 @@ fn trans_imm_cast(bcx: block, expr: @ast::expr,\n     let s_in = k_in == cast_integral && ty::type_is_signed(t_in);\n \n     let newval =\n-        match {in: k_in, out: k_out} {\n-            {in: cast_integral, out: cast_integral} => {\n+        match (k_in, k_out) {\n+            (cast_integral, cast_integral) => {\n                 int_cast(bcx, ll_t_out, ll_t_in, llexpr, s_in)\n             }\n-            {in: cast_float, out: cast_float} => {\n+            (cast_float, cast_float) => {\n                 float_cast(bcx, ll_t_out, ll_t_in, llexpr)\n             }\n-            {in: cast_integral, out: cast_float} => {\n+            (cast_integral, cast_float) => {\n                 if s_in {\n                     SIToFP(bcx, llexpr, ll_t_out)\n                 } else { UIToFP(bcx, llexpr, ll_t_out) }\n             }\n-            {in: cast_float, out: cast_integral} => {\n+            (cast_float, cast_integral) => {\n                 if ty::type_is_signed(t_out) {\n                     FPToSI(bcx, llexpr, ll_t_out)\n                 } else { FPToUI(bcx, llexpr, ll_t_out) }\n             }\n-            {in: cast_integral, out: cast_pointer} => {\n+            (cast_integral, cast_pointer) => {\n                 IntToPtr(bcx, llexpr, ll_t_out)\n             }\n-            {in: cast_pointer, out: cast_integral} => {\n+            (cast_pointer, cast_integral) => {\n                 PtrToInt(bcx, llexpr, ll_t_out)\n             }\n-            {in: cast_pointer, out: cast_pointer} => {\n+            (cast_pointer, cast_pointer) => {\n                 PointerCast(bcx, llexpr, ll_t_out)\n             }\n-            {in: cast_enum, out: cast_integral} |\n-            {in: cast_enum, out: cast_float} => {\n+            (cast_enum, cast_integral) |\n+            (cast_enum, cast_float) => {\n                 let bcx = bcx;\n                 let in_tid = match ty::get(t_in).sty {\n                     ty::ty_enum(did, _) => did,"}, {"sha": "3d1d70abefda17a2c5b54106bc636cff9b797068", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -47,23 +47,23 @@ fn abi_info(arch: session::arch) -> cabi::ABIInfo {\n     }\n }\n \n-pub fn link_name(ccx: @crate_ctxt, i: @ast::foreign_item) -> @~str {\n-    match attr::first_attr_value_str_by_name(i.attrs, ~\"link_name\") {\n+pub fn link_name(ccx: @CrateContext, i: @ast::foreign_item) -> @~str {\n+     match attr::first_attr_value_str_by_name(i.attrs, ~\"link_name\") {\n         None => ccx.sess.str_of(i.ident),\n         Some(ln) => ln,\n     }\n }\n \n-type c_stack_tys = {\n+struct c_stack_tys {\n     arg_tys: ~[TypeRef],\n     ret_ty: TypeRef,\n     ret_def: bool,\n     bundle_ty: TypeRef,\n     shim_fn_ty: TypeRef,\n     fn_ty: cabi::FnType\n-};\n+}\n \n-fn c_arg_and_ret_lltys(ccx: @crate_ctxt,\n+fn c_arg_and_ret_lltys(ccx: @CrateContext,\n                        id: ast::node_id) -> (~[TypeRef], TypeRef, ty::t) {\n     match ty::get(ty::node_id_to_type(ccx.tcx, id)).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n@@ -75,15 +75,15 @@ fn c_arg_and_ret_lltys(ccx: @crate_ctxt,\n     }\n }\n \n-fn c_stack_tys(ccx: @crate_ctxt,\n+fn c_stack_tys(ccx: @CrateContext,\n                id: ast::node_id) -> @c_stack_tys {\n     let (llargtys, llretty, ret_ty) = c_arg_and_ret_lltys(ccx, id);\n     // XXX: Bad copy.\n     let bundle_ty = T_struct(vec::append_one(copy llargtys, T_ptr(llretty)));\n     let ret_def = !ty::type_is_bot(ret_ty) && !ty::type_is_nil(ret_ty);\n     let fn_ty = abi_info(ccx.sess.targ_cfg.arch).\n                     compute_info(llargtys, llretty, ret_def);\n-    return @{\n+    return @c_stack_tys {\n         arg_tys: llargtys,\n         ret_ty: llretty,\n         ret_def: ret_def,\n@@ -99,7 +99,7 @@ type shim_arg_builder = fn(bcx: block, tys: @c_stack_tys,\n type shim_ret_builder = fn(bcx: block, tys: @c_stack_tys,\n                            llargbundle: ValueRef, llretval: ValueRef);\n \n-fn build_shim_fn_(ccx: @crate_ctxt,\n+fn build_shim_fn_(ccx: @CrateContext,\n                   +shim_name: ~str,\n                   llbasefn: ValueRef,\n                   tys: @c_stack_tys,\n@@ -136,7 +136,7 @@ type wrap_arg_builder = fn(bcx: block, tys: @c_stack_tys,\n type wrap_ret_builder = fn(bcx: block, tys: @c_stack_tys,\n                            llargbundle: ValueRef);\n \n-fn build_wrap_fn_(ccx: @crate_ctxt,\n+fn build_wrap_fn_(ccx: @CrateContext,\n                   tys: @c_stack_tys,\n                   llshimfn: ValueRef,\n                   llwrapfn: ValueRef,\n@@ -201,13 +201,13 @@ fn build_wrap_fn_(ccx: @crate_ctxt,\n // stack pointer appropriately to avoid a round of copies.  (In fact, the shim\n // function itself is unnecessary). We used to do this, in fact, and will\n // perhaps do so in the future.\n-pub fn trans_foreign_mod(ccx: @crate_ctxt,\n+pub fn trans_foreign_mod(ccx: @CrateContext,\n                          foreign_mod: ast::foreign_mod,\n                          abi: ast::foreign_abi) {\n \n     let _icx = ccx.insn_ctxt(\"foreign::trans_foreign_mod\");\n \n-    fn build_shim_fn(ccx: @crate_ctxt,\n+    fn build_shim_fn(ccx: @CrateContext,\n                      foreign_item: @ast::foreign_item,\n                      tys: @c_stack_tys,\n                      cc: lib::llvm::CallConv) -> ValueRef {\n@@ -235,7 +235,7 @@ pub fn trans_foreign_mod(ccx: @crate_ctxt,\n                            build_args, build_ret);\n     }\n \n-    fn base_fn(ccx: @crate_ctxt, lname: &str, tys: @c_stack_tys,\n+    fn base_fn(ccx: @CrateContext, lname: &str, tys: @c_stack_tys,\n                cc: lib::llvm::CallConv) -> ValueRef {\n         // Declare the \"prototype\" for the base function F:\n         do tys.fn_ty.decl_fn |fnty| {\n@@ -245,7 +245,7 @@ pub fn trans_foreign_mod(ccx: @crate_ctxt,\n \n     // FIXME (#2535): this is very shaky and probably gets ABIs wrong all\n     // over the place\n-    fn build_direct_fn(ccx: @crate_ctxt, decl: ValueRef,\n+    fn build_direct_fn(ccx: @CrateContext, decl: ValueRef,\n                        item: @ast::foreign_item, tys: @c_stack_tys,\n                        cc: lib::llvm::CallConv) {\n         let fcx = new_fn_ctxt(ccx, ~[], decl, None);\n@@ -264,7 +264,7 @@ pub fn trans_foreign_mod(ccx: @crate_ctxt,\n         finish_fn(fcx, lltop);\n     }\n \n-    fn build_wrap_fn(ccx: @crate_ctxt,\n+    fn build_wrap_fn(ccx: @CrateContext,\n                      tys: @c_stack_tys,\n                      llshimfn: ValueRef,\n                      llwrapfn: ValueRef) {\n@@ -328,7 +328,7 @@ pub fn trans_foreign_mod(ccx: @crate_ctxt,\n     }\n }\n \n-pub fn trans_intrinsic(ccx: @crate_ctxt,\n+pub fn trans_intrinsic(ccx: @CrateContext,\n                        decl: ValueRef,\n                        item: @ast::foreign_item,\n                        +path: ast_map::path,\n@@ -838,15 +838,15 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n     finish_fn(fcx, lltop);\n }\n \n-pub fn trans_foreign_fn(ccx: @crate_ctxt,\n+pub fn trans_foreign_fn(ccx: @CrateContext,\n                         +path: ast_map::path,\n                         decl: &ast::fn_decl,\n                         body: &ast::blk,\n                         llwrapfn: ValueRef,\n                         id: ast::node_id) {\n     let _icx = ccx.insn_ctxt(\"foreign::build_foreign_fn\");\n \n-    fn build_rust_fn(ccx: @crate_ctxt, +path: ast_map::path,\n+    fn build_rust_fn(ccx: @CrateContext, +path: ast_map::path,\n                      decl: &ast::fn_decl, body: &ast::blk,\n                      id: ast::node_id) -> ValueRef {\n         let _icx = ccx.insn_ctxt(\"foreign::foreign::build_rust_fn\");\n@@ -862,7 +862,7 @@ pub fn trans_foreign_fn(ccx: @crate_ctxt,\n         return llfndecl;\n     }\n \n-    fn build_shim_fn(ccx: @crate_ctxt, +path: ast_map::path,\n+    fn build_shim_fn(ccx: @CrateContext, +path: ast_map::path,\n                      llrustfn: ValueRef, tys: @c_stack_tys) -> ValueRef {\n         let _icx = ccx.insn_ctxt(\"foreign::foreign::build_shim_fn\");\n \n@@ -899,7 +899,7 @@ pub fn trans_foreign_fn(ccx: @crate_ctxt,\n                            build_args, build_ret);\n     }\n \n-    fn build_wrap_fn(ccx: @crate_ctxt, llshimfn: ValueRef,\n+    fn build_wrap_fn(ccx: @CrateContext, llshimfn: ValueRef,\n                      llwrapfn: ValueRef, tys: @c_stack_tys) {\n \n         let _icx = ccx.insn_ctxt(\"foreign::foreign::build_wrap_fn\");\n@@ -932,7 +932,7 @@ pub fn trans_foreign_fn(ccx: @crate_ctxt,\n     build_wrap_fn(ccx, llshimfn, llwrapfn, tys)\n }\n \n-pub fn register_foreign_fn(ccx: @crate_ctxt,\n+pub fn register_foreign_fn(ccx: @CrateContext,\n                            sp: span,\n                            +path: ast_map::path,\n                            node_id: ast::node_id,\n@@ -950,7 +950,7 @@ pub fn register_foreign_fn(ccx: @crate_ctxt,\n     }\n }\n \n-fn abi_of_foreign_fn(ccx: @crate_ctxt, i: @ast::foreign_item)\n+fn abi_of_foreign_fn(ccx: @CrateContext, i: @ast::foreign_item)\n     -> ast::foreign_abi {\n     match attr::first_attr_value_str_by_name(i.attrs, ~\"abi\") {\n       None => match ccx.tcx.items.get(&i.id) {"}, {"sha": "2a07e7a80e762f0adbbcce52766adfb8b43f3984", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -142,7 +142,7 @@ pub fn free_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n     }\n }\n \n-pub fn lazily_emit_all_tydesc_glue(ccx: @crate_ctxt,\n+pub fn lazily_emit_all_tydesc_glue(ccx: @CrateContext,\n                                    static_ti: @mut tydesc_info) {\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_take_glue, static_ti);\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_drop_glue, static_ti);\n@@ -204,15 +204,15 @@ pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n     return t;\n }\n \n-pub pure fn cast_glue(ccx: @crate_ctxt, ti: @mut tydesc_info, v: ValueRef)\n+pub pure fn cast_glue(ccx: @CrateContext, ti: @mut tydesc_info, v: ValueRef)\n                    -> ValueRef {\n     unsafe {\n         let llfnty = type_of_glue_fn(ccx, ti.ty);\n         llvm::LLVMConstPointerCast(v, T_ptr(llfnty))\n     }\n }\n \n-pub fn lazily_emit_simplified_tydesc_glue(ccx: @crate_ctxt,\n+pub fn lazily_emit_simplified_tydesc_glue(ccx: @CrateContext,\n                                           field: uint,\n                                           ti: @mut tydesc_info) -> bool {\n     let _icx = ccx.insn_ctxt(\"lazily_emit_simplified_tydesc_glue\");\n@@ -239,7 +239,7 @@ pub fn lazily_emit_simplified_tydesc_glue(ccx: @crate_ctxt,\n }\n \n \n-pub fn lazily_emit_tydesc_glue(ccx: @crate_ctxt,\n+pub fn lazily_emit_tydesc_glue(ccx: @CrateContext,\n                                field: uint,\n                                ti: @mut tydesc_info) {\n     let _icx = ccx.insn_ctxt(\"lazily_emit_tydesc_glue\");\n@@ -636,7 +636,7 @@ pub fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n \n \n // Chooses the addrspace for newly declared types.\n-pub fn declare_tydesc_addrspace(ccx: @crate_ctxt, t: ty::t) -> addrspace {\n+pub fn declare_tydesc_addrspace(ccx: @CrateContext, t: ty::t) -> addrspace {\n     if !ty::type_needs_drop(ccx.tcx, t) {\n         return default_addrspace;\n     } else if ty::type_is_immediate(t) {\n@@ -650,7 +650,7 @@ pub fn declare_tydesc_addrspace(ccx: @crate_ctxt, t: ty::t) -> addrspace {\n }\n \n // Generates the declaration for (but doesn't emit) a type descriptor.\n-pub fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @mut tydesc_info {\n+pub fn declare_tydesc(ccx: @CrateContext, t: ty::t) -> @mut tydesc_info {\n     let _icx = ccx.insn_ctxt(\"declare_tydesc\");\n     // If emit_tydescs already ran, then we shouldn't be creating any new\n     // tydescs.\n@@ -698,7 +698,7 @@ pub fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @mut tydesc_info {\n \n pub type glue_helper = fn@(block, ValueRef, ty::t);\n \n-pub fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n+pub fn declare_generic_glue(ccx: @CrateContext, t: ty::t, llfnty: TypeRef,\n                             +name: ~str) -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"declare_generic_glue\");\n     let name = name;\n@@ -717,7 +717,7 @@ pub fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n     return llfn;\n }\n \n-pub fn make_generic_glue_inner(ccx: @crate_ctxt,\n+pub fn make_generic_glue_inner(ccx: @CrateContext,\n                                t: ty::t,\n                                llfn: ValueRef,\n                                helper: glue_helper)\n@@ -742,7 +742,7 @@ pub fn make_generic_glue_inner(ccx: @crate_ctxt,\n     return llfn;\n }\n \n-pub fn make_generic_glue(ccx: @crate_ctxt, t: ty::t, llfn: ValueRef,\n+pub fn make_generic_glue(ccx: @CrateContext, t: ty::t, llfn: ValueRef,\n                          helper: glue_helper, name: ~str)\n                       -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"make_generic_glue\");\n@@ -758,7 +758,7 @@ pub fn make_generic_glue(ccx: @crate_ctxt, t: ty::t, llfn: ValueRef,\n     return llval;\n }\n \n-pub fn emit_tydescs(ccx: @crate_ctxt) {\n+pub fn emit_tydescs(ccx: @CrateContext) {\n     let _icx = ccx.insn_ctxt(\"emit_tydescs\");\n     // As of this point, allow no more tydescs to be created.\n     ccx.finished_tydescs = true;"}, {"sha": "43369aa9d755e3018987765279fd1a87724f5aca", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -27,7 +27,7 @@ use syntax::ast_util::local_def;\n // `translate` will be true if this function is allowed to translate the\n // item and false otherwise. Currently, this parameter is set to false when\n // translating default methods.\n-pub fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id,\n+pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::def_id,\n                                 translate: bool)\n     -> ast::def_id {\n     let _icx = ccx.insn_ctxt(\"maybe_instantiate_inline\");\n@@ -86,8 +86,11 @@ pub fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id,\n           csearch::found(ast::ii_method(impl_did, mth)) => {\n             ccx.stats.n_inlines += 1;\n             ccx.external.insert(fn_id, Some(mth.id));\n-            let {bounds: impl_bnds, region_param: _, ty: _} =\n-                ty::lookup_item_type(ccx.tcx, impl_did);\n+            let ty::ty_param_bounds_and_ty {\n+                bounds: impl_bnds,\n+                region_param: _,\n+                ty: _\n+            } = ty::lookup_item_type(ccx.tcx, impl_did);\n             if translate && (*impl_bnds).len() + mth.tps.len() == 0u {\n                 let llfn = get_item_val(ccx, mth.id);\n                 let path = vec::append("}, {"sha": "bfada859bc2c995ffd6d51c4fb3e3634a224acb1", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -33,15 +33,15 @@ pub type tag_metrics = {\n };\n \n // Returns the number of bytes clobbered by a Store to this type.\n-pub fn llsize_of_store(cx: @crate_ctxt, t: TypeRef) -> uint {\n+pub fn llsize_of_store(cx: @CrateContext, t: TypeRef) -> uint {\n     unsafe {\n         return llvm::LLVMStoreSizeOfType(cx.td.lltd, t) as uint;\n     }\n }\n \n // Returns the number of bytes between successive elements of type T in an\n // array of T. This is the \"ABI\" size. It includes any ABI-mandated padding.\n-pub fn llsize_of_alloc(cx: @crate_ctxt, t: TypeRef) -> uint {\n+pub fn llsize_of_alloc(cx: @CrateContext, t: TypeRef) -> uint {\n     unsafe {\n         return llvm::LLVMABISizeOfType(cx.td.lltd, t) as uint;\n     }\n@@ -55,7 +55,7 @@ pub fn llsize_of_alloc(cx: @crate_ctxt, t: TypeRef) -> uint {\n // that LLVM *does* distinguish between e.g. a 1-bit value and an 8-bit value\n // at the codegen level! In general you should prefer `llbitsize_of_real`\n // below.\n-pub fn llsize_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n+pub fn llsize_of_real(cx: @CrateContext, t: TypeRef) -> uint {\n     unsafe {\n         let nbits = llvm::LLVMSizeOfTypeInBits(cx.td.lltd, t) as uint;\n         if nbits & 7u != 0u {\n@@ -68,14 +68,14 @@ pub fn llsize_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n }\n \n /// Returns the \"real\" size of the type in bits.\n-pub fn llbitsize_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n+pub fn llbitsize_of_real(cx: @CrateContext, t: TypeRef) -> uint {\n     unsafe {\n         llvm::LLVMSizeOfTypeInBits(cx.td.lltd, t) as uint\n     }\n }\n \n /// Returns the size of the type as an LLVM constant integer value.\n-pub fn llsize_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n+pub fn llsize_of(cx: @CrateContext, t: TypeRef) -> ValueRef {\n     // Once upon a time, this called LLVMSizeOf, which does a\n     // getelementptr(1) on a null pointer and casts to an int, in\n     // order to obtain the type size as a value without requiring the\n@@ -89,7 +89,7 @@ pub fn llsize_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n // Returns the \"default\" size of t (see above), or 1 if the size would\n // be zero.  This is important for things like vectors that expect\n // space to be consumed.\n-pub fn nonzero_llsize_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n+pub fn nonzero_llsize_of(cx: @CrateContext, t: TypeRef) -> ValueRef {\n     if llbitsize_of_real(cx, t) == 0 {\n         unsafe { llvm::LLVMConstInt(cx.int_type, 1, False) }\n     } else {\n@@ -101,7 +101,7 @@ pub fn nonzero_llsize_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n // The preffered alignment may be larger than the alignment used when\n // packing the type into structs. This will be used for things like\n // allocations inside a stack frame, which LLVM has a free hand in.\n-pub fn llalign_of_pref(cx: @crate_ctxt, t: TypeRef) -> uint {\n+pub fn llalign_of_pref(cx: @CrateContext, t: TypeRef) -> uint {\n     unsafe {\n         return llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, t) as uint;\n     }\n@@ -110,7 +110,7 @@ pub fn llalign_of_pref(cx: @crate_ctxt, t: TypeRef) -> uint {\n // Returns the minimum alignment of a type required by the plattform.\n // This is the alignment that will be used for struct fields, arrays,\n // and similar ABI-mandated things.\n-pub fn llalign_of_min(cx: @crate_ctxt, t: TypeRef) -> uint {\n+pub fn llalign_of_min(cx: @CrateContext, t: TypeRef) -> uint {\n     unsafe {\n         return llvm::LLVMABIAlignmentOfType(cx.td.lltd, t) as uint;\n     }\n@@ -119,15 +119,15 @@ pub fn llalign_of_min(cx: @crate_ctxt, t: TypeRef) -> uint {\n // Returns the \"default\" alignment of t, which is calculated by casting\n // null to a record containing a single-bit followed by a t value, then\n // doing gep(0,1) to get at the trailing (and presumably padded) t cell.\n-pub fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n+pub fn llalign_of(cx: @CrateContext, t: TypeRef) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstIntCast(\n             lib::llvm::llvm::LLVMAlignOf(t), cx.int_type, False);\n     }\n }\n \n // Computes the size of the data part of an enum.\n-pub fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n+pub fn static_size_of_enum(cx: @CrateContext, t: ty::t) -> uint {\n     if cx.enum_sizes.contains_key(&t) {\n         return cx.enum_sizes.get(&t);\n     }"}, {"sha": "ac050a74df442af248e7472b3d1e5114b8a8181c", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -50,7 +50,7 @@ for non-monomorphized methods only.  Other methods will\n be generated once they are invoked with specific type parameters,\n see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n */\n-pub fn trans_impl(ccx: @crate_ctxt, +path: path, name: ast::ident,\n+pub fn trans_impl(ccx: @CrateContext, +path: path, name: ast::ident,\n                   methods: ~[@ast::method], tps: ~[ast::ty_param],\n                   self_ty: Option<ty::t>, id: ast::node_id) {\n     let _icx = ccx.insn_ctxt(\"impl::trans_impl\");\n@@ -96,7 +96,7 @@ Translates a (possibly monomorphized) method body.\n - `llfn`: the LLVM ValueRef for the method\n - `impl_id`: the node ID of the impl this method is inside\n */\n-pub fn trans_method(ccx: @crate_ctxt,\n+pub fn trans_method(ccx: @CrateContext,\n                     +path: path,\n                     method: &ast::method,\n                     param_substs: Option<@param_substs>,\n@@ -359,7 +359,7 @@ pub fn method_from_methods(ms: ~[@ast::method], name: ast::ident)\n     ms.find(|m| m.ident == name).map(|m| local_def(m.id))\n }\n \n-pub fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n+pub fn method_with_name(ccx: @CrateContext, impl_id: ast::def_id,\n                         name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n         match ccx.tcx.items.get(&impl_id.node) {\n@@ -376,7 +376,7 @@ pub fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n     }\n }\n \n-pub fn method_with_name_or_default(ccx: @crate_ctxt, impl_id: ast::def_id,\n+pub fn method_with_name_or_default(ccx: @CrateContext, impl_id: ast::def_id,\n                                    name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n         match ccx.tcx.items.get(&impl_id.node) {\n@@ -410,7 +410,7 @@ pub fn method_with_name_or_default(ccx: @crate_ctxt, impl_id: ast::def_id,\n     }\n }\n \n-pub fn method_ty_param_count(ccx: @crate_ctxt, m_id: ast::def_id,\n+pub fn method_ty_param_count(ccx: @CrateContext, m_id: ast::def_id,\n                              i_id: ast::def_id) -> uint {\n     debug!(\"method_ty_param_count: m_id: %?, i_id: %?\", m_id, i_id);\n     if m_id.crate == ast::local_crate {\n@@ -559,7 +559,8 @@ pub fn combine_impl_and_methods_origins(bcx: block,\n     // rcvr + method bounds.\n     let ccx = bcx.ccx(), tcx = bcx.tcx();\n     let n_m_tps = method_ty_param_count(ccx, mth_did, impl_did);\n-    let {bounds: r_m_bounds, _} = ty::lookup_item_type(tcx, mth_did);\n+    let ty::ty_param_bounds_and_ty {bounds: r_m_bounds, _}\n+        = ty::lookup_item_type(tcx, mth_did);\n     let n_r_m_tps = r_m_bounds.len(); // rcvr + method tps\n     let m_boundss = vec::slice(*r_m_bounds, n_r_m_tps - n_m_tps, n_r_m_tps);\n \n@@ -745,7 +746,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n     };\n }\n \n-pub fn vtable_id(ccx: @crate_ctxt,\n+pub fn vtable_id(ccx: @CrateContext,\n                  +origin: typeck::vtable_origin)\n               -> mono_id {\n     match origin {\n@@ -774,7 +775,7 @@ pub fn vtable_id(ccx: @crate_ctxt,\n     }\n }\n \n-pub fn get_vtable(ccx: @crate_ctxt,\n+pub fn get_vtable(ccx: @CrateContext,\n                   +origin: typeck::vtable_origin)\n                -> ValueRef {\n     // XXX: Bad copy.\n@@ -790,7 +791,7 @@ pub fn get_vtable(ccx: @crate_ctxt,\n     }\n }\n \n-pub fn make_vtable(ccx: @crate_ctxt, ptrs: ~[ValueRef]) -> ValueRef {\n+pub fn make_vtable(ccx: @CrateContext, ptrs: ~[ValueRef]) -> ValueRef {\n     unsafe {\n         let _icx = ccx.insn_ctxt(\"impl::make_vtable\");\n         let tbl = C_struct(ptrs);\n@@ -805,7 +806,7 @@ pub fn make_vtable(ccx: @crate_ctxt, ptrs: ~[ValueRef]) -> ValueRef {\n     }\n }\n \n-pub fn make_impl_vtable(ccx: @crate_ctxt,\n+pub fn make_impl_vtable(ccx: @CrateContext,\n                         impl_id: ast::def_id,\n                         substs: ~[ty::t],\n                         vtables: typeck::vtable_res)\n@@ -838,8 +839,9 @@ pub fn make_impl_vtable(ccx: @crate_ctxt,\n                     // XXX: Set impl ID here?\n                     m_id = inline::maybe_instantiate_inline(ccx, m_id, true);\n                 }\n-                monomorphize::monomorphic_fn(ccx, m_id, substs,\n-                                             Some(vtables), None, None).val\n+                let (val, _) = monomorphize::monomorphic_fn(ccx, m_id, substs,\n+                                Some(vtables), None, None);\n+                val\n             } else if m_id.crate == ast::local_crate {\n                 get_item_val(ccx, m_id.node)\n             } else {\n@@ -873,7 +875,7 @@ pub fn trans_trait_cast(bcx: block,\n             let mut llboxdest = GEPi(bcx, lldest, [0u, 1u]);\n             if bcx.tcx().legacy_boxed_traits.contains_key(&id) {\n                 // Allocate an @ box and store the value into it\n-                let {bcx: new_bcx, box: llbox, body: body} =\n+                let MallocResult {bcx: new_bcx, box: llbox, body: body} =\n                     malloc_boxed(bcx, v_ty);\n                 bcx = new_bcx;\n                 add_clean_free(bcx, llbox, heap_shared);"}, {"sha": "e4ae6a00847d997f2494e97266e0acf15179dd20", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -36,13 +36,13 @@ use syntax::ast_map::{path, path_mod, path_name};\n use syntax::ast_util::local_def;\n use syntax::parse::token::special_idents;\n \n-pub fn monomorphic_fn(ccx: @crate_ctxt,\n+pub fn monomorphic_fn(ccx: @CrateContext,\n                       fn_id: ast::def_id,\n                       real_substs: ~[ty::t],\n                       vtables: Option<typeck::vtable_res>,\n                       impl_did_opt: Option<ast::def_id>,\n                       ref_id: Option<ast::node_id>) ->\n-                      {val: ValueRef, must_cast: bool} {\n+                      (ValueRef, bool) {\n     let _icx = ccx.insn_ctxt(\"monomorphic_fn\");\n     let mut must_cast = false;\n     let substs = vec::map(real_substs, |t| {\n@@ -73,7 +73,7 @@ pub fn monomorphic_fn(ccx: @crate_ctxt,\n       Some(val) => {\n         debug!(\"leaving monomorphic fn %s\",\n                ty::item_path_str(ccx.tcx, fn_id));\n-        return {val: val, must_cast: must_cast};\n+        return (val, must_cast);\n       }\n       None => ()\n     }\n@@ -94,8 +94,7 @@ pub fn monomorphic_fn(ccx: @crate_ctxt,\n       => (pt, i.ident, i.span),\n       ast_map::node_foreign_item(*) => {\n         // Foreign externs don't have to be monomorphized.\n-        return {val: get_item_val(ccx, fn_id.node),\n-                must_cast: true};\n+        return (get_item_val(ccx, fn_id.node), true);\n       }\n       ast_map::node_dtor(_, dtor, _, pt) =>\n           (pt, special_idents::dtor, dtor.span),\n@@ -261,7 +260,7 @@ pub fn monomorphic_fn(ccx: @crate_ctxt,\n     ccx.monomorphizing.insert(fn_id, depth);\n \n     debug!(\"leaving monomorphic fn %s\", ty::item_path_str(ccx.tcx, fn_id));\n-    {val: lldecl, must_cast: must_cast}\n+    (lldecl, must_cast)\n }\n \n pub fn normalize_for_monomorphization(tcx: ty::ctxt,\n@@ -319,7 +318,7 @@ pub fn normalize_for_monomorphization(tcx: ty::ctxt,\n     }\n }\n \n-pub fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n+pub fn make_mono_id(ccx: @CrateContext, item: ast::def_id, substs: ~[ty::t],\n                     vtables: Option<typeck::vtable_res>,\n                     impl_did_opt: Option<ast::def_id>,\n                     param_uses: Option<~[type_use::type_uses]>) -> mono_id {"}, {"sha": "72e2369111d659cc9784071d78f5b0c10e24c0ba", "filename": "src/librustc/middle/trans/shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -40,7 +40,7 @@ pub struct Ctxt {\n     pad2: u32\n }\n \n-pub fn mk_global(ccx: @crate_ctxt,\n+pub fn mk_global(ccx: @CrateContext,\n                  name: ~str,\n                  llval: ValueRef,\n                  internal: bool)"}, {"sha": "caf70f7b239d06d4d4bac2b8276ad002edaf2e88", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -81,7 +81,7 @@ pub fn alloc_raw(bcx: block, unit_ty: ty::t,\n     let vecbodyty = ty::mk_mut_unboxed_vec(bcx.tcx(), unit_ty);\n     let vecsize = Add(bcx, alloc, llsize_of(ccx, ccx.opaque_vec_type));\n \n-    let {bcx, box: bx, body} =\n+    let MallocResult {bcx, box: bx, body} =\n         base::malloc_general_dyn(bcx, vecbodyty, heap, vecsize);\n     Store(bcx, fill, GEPi(bcx, body, [0u, abi::vec_elt_fill]));\n     Store(bcx, alloc, GEPi(bcx, body, [0u, abi::vec_elt_alloc]));\n@@ -144,7 +144,7 @@ pub struct VecTypes {\n }\n \n pub impl VecTypes {\n-    fn to_str(ccx: @crate_ctxt) -> ~str {\n+    fn to_str(ccx: @CrateContext) -> ~str {\n         fmt!(\"VecTypes {vec_ty=%s, unit_ty=%s, llunit_ty=%s, llunit_size=%s}\",\n              ty_to_str(ccx.tcx, self.vec_ty),\n              ty_to_str(ccx.tcx, self.unit_ty),"}, {"sha": "8275db8cdb29298b1f69de0e158cd43797a980a9", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -20,7 +20,7 @@ use util::ppaux;\n use std::oldmap::HashMap;\n use syntax::ast;\n \n-pub fn type_of_explicit_arg(ccx: @crate_ctxt, arg: ty::arg) -> TypeRef {\n+pub fn type_of_explicit_arg(ccx: @CrateContext, arg: ty::arg) -> TypeRef {\n     let llty = type_of(ccx, arg.ty);\n     match ty::resolved_mode(ccx.tcx, arg.mode) {\n         ast::by_val => llty,\n@@ -35,12 +35,12 @@ pub fn type_of_explicit_arg(ccx: @crate_ctxt, arg: ty::arg) -> TypeRef {\n     }\n }\n \n-pub fn type_of_explicit_args(ccx: @crate_ctxt,\n+pub fn type_of_explicit_args(ccx: @CrateContext,\n                              inputs: &[ty::arg]) -> ~[TypeRef] {\n     inputs.map(|arg| type_of_explicit_arg(ccx, *arg))\n }\n \n-pub fn type_of_fn(cx: @crate_ctxt, inputs: &[ty::arg],\n+pub fn type_of_fn(cx: @CrateContext, inputs: &[ty::arg],\n                   output: ty::t) -> TypeRef {\n     unsafe {\n         let mut atys: ~[TypeRef] = ~[];\n@@ -58,7 +58,7 @@ pub fn type_of_fn(cx: @crate_ctxt, inputs: &[ty::arg],\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n-pub fn type_of_fn_from_ty(cx: @crate_ctxt, fty: ty::t) -> TypeRef {\n+pub fn type_of_fn_from_ty(cx: @CrateContext, fty: ty::t) -> TypeRef {\n     match ty::get(fty).sty {\n         ty::ty_closure(ref f) => type_of_fn(cx, f.sig.inputs, f.sig.output),\n         ty::ty_bare_fn(ref f) => type_of_fn(cx, f.sig.inputs, f.sig.output),\n@@ -68,7 +68,7 @@ pub fn type_of_fn_from_ty(cx: @crate_ctxt, fty: ty::t) -> TypeRef {\n     }\n }\n \n-pub fn type_of_non_gc_box(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n+pub fn type_of_non_gc_box(cx: @CrateContext, t: ty::t) -> TypeRef {\n     assert !ty::type_needs_infer(t);\n \n     let t_norm = ty::normalize_ty(cx.tcx, t);\n@@ -101,7 +101,7 @@ pub fn type_of_non_gc_box(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n //     recursive types. For example, `static_size_of_enum()` relies on this\n //     behavior.\n \n-pub fn sizing_type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n+pub fn sizing_type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n     if cx.llsizingtypes.contains_key(&t) {\n         return cx.llsizingtypes.get(&t);\n     }\n@@ -178,7 +178,7 @@ pub fn sizing_type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n }\n \n // NB: If you update this, be sure to update `sizing_type_of()` as well.\n-pub fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n+pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n     debug!(\"type_of %?: %?\", t, ty::get(t));\n \n     // Check the cache.\n@@ -325,7 +325,7 @@ pub fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     return llty;\n }\n \n-pub fn enum_body_types(cx: @crate_ctxt, did: ast::def_id, t: ty::t)\n+pub fn enum_body_types(cx: @CrateContext, did: ast::def_id, t: ty::t)\n                     -> ~[TypeRef] {\n     let univar = ty::enum_is_univariant(cx.tcx, did);\n     if !univar {\n@@ -345,7 +345,7 @@ pub fn enum_body_types(cx: @crate_ctxt, did: ast::def_id, t: ty::t)\n     }\n }\n \n-pub fn fill_type_of_enum(cx: @crate_ctxt,\n+pub fn fill_type_of_enum(cx: @CrateContext,\n                          did: ast::def_id,\n                          t: ty::t,\n                          llty: TypeRef) {\n@@ -356,7 +356,7 @@ pub fn fill_type_of_enum(cx: @crate_ctxt,\n // Want refinements! (Or case classes, I guess\n pub enum named_ty { a_struct, an_enum }\n \n-pub fn llvm_type_name(cx: @crate_ctxt,\n+pub fn llvm_type_name(cx: @CrateContext,\n                       what: named_ty,\n                       did: ast::def_id,\n                       tps: ~[ty::t]) -> ~str {\n@@ -376,22 +376,22 @@ pub fn llvm_type_name(cx: @crate_ctxt,\n     );\n }\n \n-pub fn type_of_dtor(ccx: @crate_ctxt, self_ty: ty::t) -> TypeRef {\n+pub fn type_of_dtor(ccx: @CrateContext, self_ty: ty::t) -> TypeRef {\n     unsafe {\n         T_fn(~[T_ptr(type_of(ccx, ty::mk_nil(ccx.tcx))), // output pointer\n                T_ptr(type_of(ccx, self_ty))],            // self arg\n              llvm::LLVMVoidType())\n     }\n }\n \n-pub fn type_of_rooted(ccx: @crate_ctxt, t: ty::t) -> TypeRef {\n+pub fn type_of_rooted(ccx: @CrateContext, t: ty::t) -> TypeRef {\n     let addrspace = base::get_tydesc(ccx, t).addrspace;\n     debug!(\"type_of_rooted %s in addrspace %u\",\n            ty_to_str(ccx.tcx, t), addrspace as uint);\n     return T_root(type_of(ccx, t), addrspace);\n }\n \n-pub fn type_of_glue_fn(ccx: @crate_ctxt, t: ty::t) -> TypeRef {\n+pub fn type_of_glue_fn(ccx: @CrateContext, t: ty::t) -> TypeRef {\n     let tydescpp = T_ptr(T_ptr(ccx.tydesc_type));\n     let llty = T_ptr(type_of(ccx, t));\n     return T_fn(~[T_ptr(T_nil()), T_ptr(T_nil()), tydescpp, llty],"}, {"sha": "3013f928b75dadeab997a0b89d5f0730dbf37f38", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -49,9 +49,12 @@ pub const use_repr: uint = 1u;   /* Dependency on size/alignment/mode and\n                                     take/drop glue */\n pub const use_tydesc: uint = 2u; /* Takes the tydesc, or compares */\n \n-pub type ctx = {ccx: @crate_ctxt, uses: ~[mut type_uses]};\n+pub struct Context {\n+    ccx: @CrateContext,\n+    uses: ~[mut type_uses]\n+}\n \n-pub fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n+pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n     -> ~[type_uses] {\n     match ccx.type_use_cache.find(&fn_id) {\n       Some(uses) => return uses,\n@@ -67,7 +70,10 @@ pub fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n     // Conservatively assume full use for recursive loops\n     ccx.type_use_cache.insert(fn_id, vec::from_elem(n_tps, 3u));\n \n-    let cx = {ccx: ccx, uses: vec::cast_to_mut(vec::from_elem(n_tps, 0u))};\n+    let cx = Context {\n+        ccx: ccx,\n+        uses: vec::cast_to_mut(vec::from_elem(n_tps, 0u))\n+    };\n     match ty::get(ty::lookup_item_type(cx.ccx.tcx, fn_id).ty).sty {\n         ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n         ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => {\n@@ -175,7 +181,7 @@ pub fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n     uses\n }\n \n-pub fn type_needs(cx: ctx, use_: uint, ty: ty::t) {\n+pub fn type_needs(cx: Context, use_: uint, ty: ty::t) {\n     // Optimization -- don't descend type if all params already have this use\n     for vec::each_mut(cx.uses) |u| {\n         if *u & use_ != use_ {\n@@ -185,7 +191,7 @@ pub fn type_needs(cx: ctx, use_: uint, ty: ty::t) {\n     }\n }\n \n-pub fn type_needs_inner(cx: ctx,\n+pub fn type_needs_inner(cx: Context,\n                         use_: uint,\n                         ty: ty::t,\n                         enums_seen: @List<def_id>) {\n@@ -226,11 +232,11 @@ pub fn type_needs_inner(cx: ctx,\n     }\n }\n \n-pub fn node_type_needs(cx: ctx, use_: uint, id: node_id) {\n+pub fn node_type_needs(cx: Context, use_: uint, id: node_id) {\n     type_needs(cx, use_, ty::node_id_to_type(cx.ccx.tcx, id));\n }\n \n-pub fn mark_for_method_call(cx: ctx, e_id: node_id, callee_id: node_id) {\n+pub fn mark_for_method_call(cx: Context, e_id: node_id, callee_id: node_id) {\n     do option::iter(&cx.ccx.maps.method_map.find(&e_id)) |mth| {\n         match mth.origin {\n           typeck::method_static(did) => {\n@@ -253,7 +259,7 @@ pub fn mark_for_method_call(cx: ctx, e_id: node_id, callee_id: node_id) {\n     }\n }\n \n-pub fn mark_for_expr(cx: ctx, e: @expr) {\n+pub fn mark_for_expr(cx: Context, e: @expr) {\n     match e.node {\n       expr_vstore(_, _) |\n       expr_vec(_, _) |\n@@ -353,7 +359,7 @@ pub fn mark_for_expr(cx: ctx, e: @expr) {\n     }\n }\n \n-pub fn handle_body(cx: ctx, body: blk) {\n+pub fn handle_body(cx: Context, body: blk) {\n     let v = visit::mk_vt(@visit::Visitor {\n         visit_expr: |e, cx, v| {\n             visit::visit_expr(e, cx, v);"}, {"sha": "e2b1a1485eed711f716b5ed7236ef53eec1844d2", "filename": "src/librustc/middle/trans/uniq.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -42,8 +42,11 @@ pub fn duplicate(bcx: block, src_box: ValueRef, src_ty: ty::t) -> Result {\n     let body_datum = src_datum.box_body(bcx);\n \n     // Malloc space in exchange heap and copy src into it\n-    let {bcx: bcx, box: dst_box, body: dst_body} =\n-        malloc_unique(bcx, body_datum.ty);\n+    let MallocResult {\n+        bcx: bcx,\n+        box: dst_box,\n+        body: dst_body\n+    } = malloc_unique(bcx, body_datum.ty);\n     body_datum.copy_to(bcx, datum::INIT, dst_body);\n \n     // Copy the type descriptor"}, {"sha": "96107c141bec7e4c4dd3d24571a6278e9c266f32", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -70,14 +70,14 @@ pub struct field {\n \n pub type param_bounds = @~[param_bound];\n \n-pub type method = {\n+pub struct method {\n     ident: ast::ident,\n     tps: @~[param_bounds],\n     fty: BareFnTy,\n     self_ty: ast::self_ty_,\n     vis: ast::visibility,\n     def_id: ast::def_id\n-};\n+}\n \n pub struct mt {\n     ty: t,\n@@ -303,10 +303,14 @@ enum tbox_flag {\n     needs_subst = 1 | 2 | 8\n }\n \n-type t_box = @{sty: sty,\n-               id: uint,\n-               flags: uint,\n-               o_def_id: Option<ast::def_id>};\n+type t_box = @t_box_;\n+\n+struct t_box_ {\n+    sty: sty,\n+    id: uint,\n+    flags: uint,\n+    o_def_id: Option<ast::def_id>\n+}\n \n // To reduce refcounting cost, we're representing types as unsafe pointers\n // throughout the compiler. These are simply casted t_box values. Use ty::get\n@@ -749,11 +753,16 @@ pub impl to_bytes::IterBytes for RegionVid {\n ///\n /// - `ty`: the base type.  May have reference to the (unsubstituted) bound\n ///   region `&self` or to (unsubstituted) ty_param types\n-pub type ty_param_bounds_and_ty = {bounds: @~[param_bounds],\n-                                   region_param: Option<region_variance>,\n-                                   ty: t};\n+pub struct ty_param_bounds_and_ty {\n+    bounds: @~[param_bounds],\n+    region_param: Option<region_variance>,\n+    ty: t\n+}\n \n-pub type ty_param_substs_and_ty = {substs: ty::substs, ty: ty::t};\n+pub struct ty_param_substs_and_ty {\n+    substs: ty::substs,\n+    ty: ty::t\n+}\n \n type type_cache = HashMap<ast::def_id, ty_param_bounds_and_ty>;\n \n@@ -909,9 +918,17 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n       }\n     }\n \n-    let t = @{sty: st, id: cx.next_id, flags: flags, o_def_id: o_def_id};\n+    let t = @t_box_ {\n+        sty: st,\n+        id: cx.next_id,\n+        flags: flags,\n+        o_def_id: o_def_id\n+    };\n+    let key = intern_key {\n+        sty: to_unsafe_ptr(&t.sty),\n+        o_def_id: o_def_id\n+    };\n \n-    let key = intern_key {sty: to_unsafe_ptr(&t.sty), o_def_id: o_def_id};\n     cx.interner.insert(key, t);\n \n     cx.next_id += 1u;\n@@ -3010,11 +3027,18 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: @ast::expr) -> t {\n     }\n }\n \n+pub struct ParamsTy {\n+    params: ~[t],\n+    ty: t\n+}\n+\n pub fn expr_ty_params_and_ty(cx: ctxt,\n                              expr: @ast::expr)\n-                          -> {params: ~[t], ty: t} {\n-    return {params: node_id_to_type_params(cx, expr.id),\n-         ty: node_id_to_type(cx, expr.id)};\n+                          -> ParamsTy {\n+    ParamsTy {\n+        params: node_id_to_type_params(cx, expr.id),\n+        ty: node_id_to_type(cx, expr.id)\n+    }\n }\n \n pub fn expr_has_ty_params(cx: ctxt, expr: @ast::expr) -> bool {\n@@ -3609,7 +3633,10 @@ pub fn trait_supertraits(cx: ctxt,\n             ty_trait(def_id, ref substs, _) => {\n                 result.push(InstantiatedTraitRef {\n                     def_id: def_id,\n-                    tpt: { substs: (/*bad*/copy *substs), ty: *trait_type }\n+                    tpt: ty_param_substs_and_ty {\n+                        substs: (/*bad*/copy *substs),\n+                        ty: *trait_type\n+                    }\n                 });\n             }\n             _ => cx.sess.bug(~\"trait_supertraits: trait ref wasn't a trait\")"}, {"sha": "c04141b25968170f54d6c2f8b83f09dfb6d92577", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -117,8 +117,11 @@ pub fn ast_path_to_substs_and_ty<AC: AstConv, RS: region_scope Copy Durable>(\n         path: @ast::path)\n      -> ty_param_substs_and_ty {\n     let tcx = self.tcx();\n-    let {bounds: decl_bounds, region_param: decl_rp, ty: decl_ty} =\n-        self.get_item_ty(did);\n+    let ty::ty_param_bounds_and_ty {\n+        bounds: decl_bounds,\n+        region_param: decl_rp,\n+        ty: decl_ty\n+    } = self.get_item_ty(did);\n \n     debug!(\"ast_path_to_substs_and_ty: did=%? decl_rp=%?\",\n            did, decl_rp);\n@@ -159,7 +162,8 @@ pub fn ast_path_to_substs_and_ty<AC: AstConv, RS: region_scope Copy Durable>(\n \n     let substs = substs {self_r:self_r, self_ty:None, tps:tps};\n     let ty = ty::subst(tcx, &substs, decl_ty);\n-    {substs: substs, ty: ty}\n+\n+    ty_param_substs_and_ty { substs: substs, ty: ty }\n }\n \n pub fn ast_path_to_ty<AC: AstConv, RS: region_scope Copy Durable>(\n@@ -172,11 +176,14 @@ pub fn ast_path_to_ty<AC: AstConv, RS: region_scope Copy Durable>(\n     // Look up the polytype of the item and then substitute the provided types\n     // for any type/region parameters.\n     let tcx = self.tcx();\n-    let {substs: substs, ty: ty} =\n-        ast_path_to_substs_and_ty(self, rscope, did, path);\n+    let ty::ty_param_substs_and_ty {\n+        substs: substs,\n+        ty: ty\n+    } = ast_path_to_substs_and_ty(self, rscope, did, path);\n     write_ty_to_tcx(tcx, path_id, ty);\n     write_substs_to_tcx(tcx, path_id, /*bad*/copy substs.tps);\n-    return {substs: substs, ty: ty};\n+\n+    ty_param_substs_and_ty { substs: substs, ty: ty }\n }\n \n pub const NO_REGIONS: uint = 1;"}, {"sha": "82f9828db3fb3027837ba92f6632f72bb8e2d3ac", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -93,10 +93,10 @@ pub fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n         ty::ty_enum(_, ref expected_substs) => {\n             // Lookup the enum and variant def ids:\n             let v_def = lookup_def(pcx.fcx, pat.span, pat.id);\n-            let v_def_ids = ast_util::variant_def_ids(v_def);\n+            let (enm, var) = ast_util::variant_def_ids(v_def);\n \n             // Assign the pattern the type of the *enum*, not the variant.\n-            let enum_tpt = ty::lookup_item_type(tcx, v_def_ids.enm);\n+            let enum_tpt = ty::lookup_item_type(tcx, enm);\n             instantiate_path(pcx.fcx, path, enum_tpt, pat.span, pat.id,\n                              pcx.block_region);\n \n@@ -108,9 +108,8 @@ pub fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n             // Get the expected types of the arguments.\n             arg_types = {\n                 let vinfo =\n-                    ty::enum_variant_with_id(\n-                        tcx, v_def_ids.enm, v_def_ids.var);\n-                let var_tpt = ty::lookup_item_type(tcx, v_def_ids.var);\n+                    ty::enum_variant_with_id(tcx, enm, var);\n+                let var_tpt = ty::lookup_item_type(tcx, var);\n                 vinfo.args.map(|t| {\n                     if var_tpt.bounds.len() == expected_substs.tps.len() {\n                         ty::subst(tcx, expected_substs, *t)\n@@ -132,7 +131,8 @@ pub fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n             // Assign the pattern the type of the struct.\n             let ctor_tpt = ty::lookup_item_type(tcx, s_def_id);\n             let struct_tpt = if ty::is_fn_ty(ctor_tpt.ty) {\n-                {ty: ty::ty_fn_ret(ctor_tpt.ty), ..ctor_tpt}\n+                ty::ty_param_bounds_and_ty {ty: ty::ty_fn_ret(ctor_tpt.ty),\n+                                        ..ctor_tpt}\n             } else {\n                 ctor_tpt\n             };"}, {"sha": "698bd0a6b4b7efaaa42c036605e369b0c3ee497f", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -641,8 +641,10 @@ pub impl LookupContext {\n             ccx: self.fcx.ccx,\n             infcx: self.fcx.infcx()\n         };\n-        let {substs: impl_substs, ty: impl_ty} =\n-            impl_self_ty(&vcx, location_info, impl_info.did);\n+        let ty::ty_param_substs_and_ty {\n+            substs: impl_substs,\n+            ty: impl_ty\n+        } = impl_self_ty(&vcx, location_info, impl_info.did);\n \n         let (impl_ty, impl_substs) =\n             self.create_rcvr_ty_and_substs_for_method("}, {"sha": "16846f6c2d01b763800b7ad8a78d9dadfb28ff2e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -137,12 +137,12 @@ pub mod regionck;\n pub mod demand;\n pub mod method;\n \n-pub type self_info = {\n+pub struct SelfInfo {\n     self_ty: ty::t,\n     self_id: ast::node_id,\n     def_id: ast::def_id,\n     explicit_self: ast::self_ty\n-};\n+}\n \n /// Fields that are part of a `FnCtxt` which are inherited by\n /// closures defined within the function.  For example:\n@@ -171,7 +171,7 @@ pub struct FnCtxt {\n \n     // Refers to whichever `self` is in scope, even this FnCtxt is\n     // for a nested closure that captures `self`\n-    self_info: Option<self_info>,\n+    self_info: Option<SelfInfo>,\n     ret_ty: ty::t,\n     // Used by loop bodies that return from the outer function\n     indirect_ret_ty: Option<ty::t>,\n@@ -246,7 +246,7 @@ pub fn check_bare_fn(ccx: @mut CrateCtxt,\n                      decl: &ast::fn_decl,\n                      body: ast::blk,\n                      id: ast::node_id,\n-                     self_info: Option<self_info>) {\n+                     self_info: Option<SelfInfo>) {\n     let fty = ty::node_id_to_type(ccx.tcx, id);\n     match ty::get(fty).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n@@ -259,7 +259,7 @@ pub fn check_bare_fn(ccx: @mut CrateCtxt,\n }\n \n pub fn check_fn(ccx: @mut CrateCtxt,\n-                +self_info: Option<self_info>,\n+                +self_info: Option<SelfInfo>,\n                 purity: ast::purity,\n                 sigil: Option<ast::Sigil>,\n                 fn_sig: &ty::FnSig,\n@@ -277,7 +277,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n     // types with free ones.  The free region references will be bound\n     // the node_id of the body block.\n \n-    let {isr, self_info, fn_sig} = {\n+    let (isr, self_info, fn_sig) = {\n         let old_isr = option::map_default(&old_fcx, @Nil,\n                                           |fcx| fcx.in_scope_regions);\n         replace_bound_regions_in_fn_sig(tcx, old_isr, self_info, fn_sig,\n@@ -326,7 +326,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         }\n     };\n \n-    // Update the self_info to contain an accurate self type (taking\n+    // Update the SelfInfo to contain an accurate self type (taking\n     // into account explicit self).\n     let self_info = do self_info.chain_ref |self_info| {\n         // If the self type is sty_static, we don't have a self ty.\n@@ -341,7 +341,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                 self_info.self_ty,\n                 self_info.explicit_self.node,\n                 TransformTypeNormally);\n-            Some({self_ty: ty,.. *self_info})\n+            Some(SelfInfo { self_ty: ty,.. *self_info })\n         }\n     };\n \n@@ -383,7 +383,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                      decl: &ast::fn_decl,\n                      body: ast::blk,\n                      arg_tys: &[ty::t],\n-                     self_info: Option<self_info>) {\n+                     self_info: Option<SelfInfo>) {\n         let tcx = fcx.ccx.tcx;\n \n         let assign = fn@(nid: ast::node_id, ty_opt: Option<ty::t>) {\n@@ -491,10 +491,12 @@ pub fn check_method(ccx: @mut CrateCtxt,\n                     method: @ast::method,\n                     self_ty: ty::t,\n                     self_impl_def_id: ast::def_id) {\n-    let self_info = {self_ty: self_ty,\n-                     self_id: method.self_id,\n-                     def_id: self_impl_def_id,\n-                     explicit_self: method.self_ty };\n+    let self_info = SelfInfo {\n+        self_ty: self_ty,\n+        self_id: method.self_id,\n+        def_id: self_impl_def_id,\n+        explicit_self: method.self_ty\n+    };\n     check_bare_fn(ccx, &method.decl, method.body, method.id, Some(self_info));\n }\n \n@@ -528,12 +530,15 @@ pub fn check_struct(ccx: @mut CrateCtxt,\n     let self_ty = ty::node_id_to_type(tcx, id);\n \n     do struct_def.dtor.iter() |dtor| {\n-        let class_t = { self_ty: self_ty,\n-                        self_id: dtor.node.self_id,\n-                        def_id: local_def(id),\n-                        explicit_self:\n-                            spanned { node: ast::sty_by_ref,\n-                                      span: codemap::dummy_sp() } };\n+        let class_t = SelfInfo {\n+            self_ty: self_ty,\n+            self_id: dtor.node.self_id,\n+            def_id: local_def(id),\n+            explicit_self: spanned {\n+                node: ast::sty_by_ref,\n+                span: codemap::dummy_sp()\n+            }\n+        };\n         // typecheck the dtor\n         let dtor_dec = ast_util::dtor_dec();\n         check_bare_fn(ccx, &dtor_dec,\n@@ -1050,16 +1055,15 @@ pub fn impl_self_ty(vcx: &VtableContext,\n                  -> ty_param_substs_and_ty {\n     let tcx = vcx.tcx();\n \n-    let {n_tps, region_param, raw_ty} = if did.crate == ast::local_crate {\n+    let (n_tps, region_param, raw_ty) = if did.crate == ast::local_crate {\n         let region_param = tcx.region_paramd_items.find(&did.node);\n         match tcx.items.find(&did.node) {\n           Some(ast_map::node_item(@ast::item {\n                   node: ast::item_impl(ref ts, _, st, _),\n                   _\n               }, _)) => {\n-            {n_tps: ts.len(),\n-             region_param: region_param,\n-             raw_ty: vcx.ccx.to_ty(rscope::type_rscope(region_param), st)}\n+            (ts.len(), region_param,\n+                vcx.ccx.to_ty(rscope::type_rscope(region_param), st))\n           }\n           Some(ast_map::node_item(@ast::item {\n                   node: ast::item_struct(_, ref ts),\n@@ -1070,23 +1074,20 @@ pub fn impl_self_ty(vcx: &VtableContext,\n                  (doing a no-op subst for the ty params; in the next step,\n                  we substitute in fresh vars for them)\n                */\n-              {n_tps: ts.len(),\n-               region_param: region_param,\n-               raw_ty: ty::mk_struct(tcx, local_def(class_id),\n+              (ts.len(), region_param,\n+                  ty::mk_struct(tcx, local_def(class_id),\n                       substs {\n                         self_r: rscope::bound_self_region(region_param),\n                         self_ty: None,\n                         tps: ty::ty_params_to_tys(tcx, /*bad*/copy *ts)\n-                      })}\n+                      }))\n           }\n           _ => { tcx.sess.bug(~\"impl_self_ty: unbound item or item that \\\n                doesn't have a self_ty\"); }\n         }\n     } else {\n         let ity = ty::lookup_item_type(tcx, did);\n-        {n_tps: vec::len(*ity.bounds),\n-         region_param: ity.region_param,\n-         raw_ty: ity.ty}\n+        (vec::len(*ity.bounds), ity.region_param, ity.ty)\n     };\n \n     let self_r = if region_param.is_some() {\n@@ -1099,7 +1100,8 @@ pub fn impl_self_ty(vcx: &VtableContext,\n \n     let substs = substs { self_r: self_r, self_ty: None, tps: tps };\n     let substd_ty = ty::subst(tcx, &substs, raw_ty);\n-    {substs: substs, ty: substd_ty}\n+\n+    ty_param_substs_and_ty { substs: substs, ty: substd_ty }\n }\n \n // Only for fields! Returns <none> for methods>\n@@ -1163,7 +1165,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let ret_ty = match structure_of(fcx, sp, in_fty) {\n             ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n             ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => {\n-                let {fn_sig: sig, _} =\n+                let (_, _, sig) =\n                     replace_bound_regions_in_fn_sig(\n                         tcx, @Nil, None, sig,\n                         |_br| fcx.infcx().next_region_var(\n@@ -1628,7 +1630,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             match expected_sty {\n                 Some(ty::ty_closure(ref cenv)) => {\n                     let id = expr.id;\n-                    let {fn_sig: sig, _} =\n+                    let (_, _, sig) =\n                         replace_bound_regions_in_fn_sig(\n                             tcx, @Nil, None, &cenv.sig,\n                             |br| ty::re_bound(ty::br_cap_avoid(id, @br)));\n@@ -2929,7 +2931,7 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n       }\n       ast::def_fn(_, ast::extern_fn) => {\n         // extern functions are just u8 pointers\n-        return {\n+        return ty_param_bounds_and_ty {\n             bounds: @~[],\n             region_param: None,\n             ty: ty::mk_ptr("}, {"sha": "841365652ff2907098c02bbc2bd5b521d873dcd5", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -13,7 +13,7 @@\n use core::prelude::*;\n \n use middle::ty;\n-use middle::typeck::check::self_info;\n+use middle::typeck::check::SelfInfo;\n use middle::typeck::isr_alist;\n use util::common::indenter;\n use util::ppaux::region_to_str;\n@@ -29,19 +29,20 @@ use syntax::print::pprust::{expr_to_str};\n pub fn replace_bound_regions_in_fn_sig(\n     tcx: ty::ctxt,\n     isr: isr_alist,\n-    self_info: Option<self_info>,\n+    self_info: Option<SelfInfo>,\n     fn_sig: &ty::FnSig,\n     mapf: fn(ty::bound_region) -> ty::Region) ->\n-    {isr: isr_alist, self_info: Option<self_info>, fn_sig: ty::FnSig} {\n+    (isr_alist, Option<SelfInfo>, ty::FnSig) {\n     // Take self_info apart; the self_ty part is the only one we want\n     // to update here.\n     let self_ty = self_info.map(|s| s.self_ty);\n-    let rebuild_self_info = |t| self_info.map(|s| {self_ty: t, ..*s});\n+    let rebuild_self_info = |t| self_info.map(|s| SelfInfo{self_ty: t, ..*s});\n \n     let mut all_tys = ty::tys_in_fn_sig(fn_sig);\n \n     match self_info {\n-      Some({explicit_self: codemap::spanned { node: ast::sty_region(m),\n+      Some(SelfInfo {\n+            explicit_self: codemap::spanned { node: ast::sty_region(m),\n                                           _}, _}) => {\n         let region = ty::re_bound(ty::br_self);\n         let ty = ty::mk_rptr(tcx, region,\n@@ -76,14 +77,12 @@ pub fn replace_bound_regions_in_fn_sig(\n            ppaux::fn_sig_to_str(tcx, &new_fn_sig));\n \n     // Glue updated self_ty back together with its original def_id.\n-    let new_self_info: Option<self_info> = match t_self {\n+    let new_self_info: Option<SelfInfo> = match t_self {\n       None    => None,\n       Some(t) => rebuild_self_info(t)\n     };\n \n-    return {isr: isr,\n-            self_info: new_self_info,\n-            fn_sig: new_fn_sig};\n+    return (isr, new_self_info, new_fn_sig);\n \n     // Takes `isr`, a (possibly empty) mapping from in-scope region\n     // names (\"isr\"s) to their corresponding regions; `tys`, a list of"}, {"sha": "e6b837fa9492ae774a543e9e190dedaa1dfbc802", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -315,8 +315,10 @@ pub fn lookup_vtable(vcx: &VtableContext,\n                             // of the thing that we're trying to cast\n                             // to some_trait.  If not, then we try the next\n                             // impl.\n-                            let {substs: substs, ty: for_ty} =\n-                                impl_self_ty(vcx, location_info, im.did);\n+                            let ty::ty_param_substs_and_ty {\n+                                substs: substs,\n+                                ty: for_ty\n+                            } = impl_self_ty(vcx, location_info, im.did);\n                             match infer::mk_subty(vcx.infcx,\n                                                   false,\n                                                   location_info.span,"}, {"sha": "a16dab4bdeaefeb2ad1aae1d7ad17f45eaaadcca", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -17,7 +17,7 @@ use core::prelude::*;\n use middle::pat_util;\n use middle::ty::arg;\n use middle::ty;\n-use middle::typeck::check::{FnCtxt, self_info};\n+use middle::typeck::check::{FnCtxt, SelfInfo};\n use middle::typeck::infer::{force_all, resolve_all, resolve_region};\n use middle::typeck::infer::{resolve_type};\n use middle::typeck::infer;\n@@ -261,7 +261,7 @@ pub fn resolve_type_vars_in_expr(fcx: @mut FnCtxt, e: @ast::expr) -> bool {\n pub fn resolve_type_vars_in_fn(fcx: @mut FnCtxt,\n                                decl: &ast::fn_decl,\n                                blk: ast::blk,\n-                               self_info: Option<self_info>) -> bool {\n+                               self_info: Option<SelfInfo>) -> bool {\n     let wbcx = @mut WbCtxt { fcx: fcx, success: true };\n     let visit = mk_visitor();\n     (visit.visit_block)(blk, wbcx, visit);"}, {"sha": "649f4c798785c6e92f866df0b5c1595e1f7a4870", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -145,7 +145,7 @@ pub fn get_base_type_def_id(inference_context: @mut InferCtxt,\n \n \n pub fn method_to_MethodInfo(ast_method: @method) -> @MethodInfo {\n-    @{\n+    @MethodInfo {\n         did: local_def(ast_method.id),\n         n_tps: ast_method.tps.len(),\n         ident: ast_method.ident,\n@@ -345,7 +345,7 @@ pub impl CoherenceChecker {\n \n             let provided_method_info =\n                 @ProvidedMethodInfo {\n-                    method_info: @{\n+                    method_info: @MethodInfo {\n                         did: new_did,\n                         n_tps: trait_method.tps.len(),\n                         ident: trait_method.ident,\n@@ -792,7 +792,7 @@ pub impl CoherenceChecker {\n                     }\n                 }\n \n-                return @{\n+                return @Impl {\n                     did: local_def(item.id),\n                     ident: item.ident,\n                     methods: methods\n@@ -925,7 +925,7 @@ pub impl CoherenceChecker {\n \n             let provided_method_info =\n                 @ProvidedMethodInfo {\n-                    method_info: @{\n+                    method_info: @MethodInfo {\n                         did: new_did,\n                         n_tps: trait_method_info.ty.tps.len(),\n                         ident: trait_method_info.ty.ident,"}, {"sha": "3f2b5ea56b1005ef29a84ebe74eb3a00d2833ef7", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 96, "deletions": 70, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -34,7 +34,7 @@ use core::prelude::*;\n \n use metadata::csearch;\n use middle::ty::{InstantiatedTraitRef, arg};\n-use middle::ty::{substs, ty_param_substs_and_ty};\n+use middle::ty::{substs, ty_param_bounds_and_ty, ty_param_substs_and_ty};\n use middle::ty;\n use middle::typeck::astconv::{AstConv, ty_of_arg};\n use middle::typeck::astconv::{ast_ty_to_ty};\n@@ -174,9 +174,11 @@ pub fn get_enum_variant_types(ccx: @mut CrateCtxt,\n             }\n \n             ast::struct_variant_kind(struct_def) => {\n-                let tpt = {bounds: ty_param_bounds(ccx, ty_params),\n-                           region_param: rp,\n-                           ty: enum_ty};\n+                let tpt = ty_param_bounds_and_ty {\n+                    bounds: ty_param_bounds(ccx, ty_params),\n+                    region_param: rp,\n+                    ty: enum_ty\n+                };\n \n                 convert_struct(ccx,\n                                rp,\n@@ -203,9 +205,11 @@ pub fn get_enum_variant_types(ccx: @mut CrateCtxt,\n         match result_ty {\n             None => {}\n             Some(result_ty) => {\n-                let tpt = {bounds: ty_param_bounds(ccx, ty_params),\n-                           region_param: rp,\n-                           ty: result_ty};\n+                let tpt = ty_param_bounds_and_ty {\n+                    bounds: ty_param_bounds(ccx, ty_params),\n+                    region_param: rp,\n+                    ty: result_ty\n+                };\n                 tcx.tcache.insert(local_def(variant.node.id), tpt);\n                 write_ty_to_tcx(tcx, variant.node.id, result_ty);\n             }\n@@ -261,9 +265,10 @@ pub fn ensure_trait_methods(ccx: @mut CrateCtxt,\n         let bounds = @(*trait_bounds + ~[@~[ty::bound_trait(trait_ty)]]\n                        + *m.tps);\n         ccx.tcx.tcache.insert(local_def(am.id),\n-                              {bounds: bounds,\n-                               region_param: rp,\n-                               ty: ty});\n+                              ty_param_bounds_and_ty {\n+                                bounds: bounds,\n+                                region_param: rp,\n+                                ty: ty});\n     }\n \n \n@@ -541,9 +546,11 @@ pub fn convert_field(ccx: @mut CrateCtxt,\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n     ccx.tcx.tcache.insert(local_def(v.node.id),\n-                          {bounds: bounds,\n-                           region_param: rp,\n-                           ty: tt});\n+                          ty::ty_param_bounds_and_ty {\n+                              bounds: bounds,\n+                              region_param: rp,\n+                              ty: tt\n+                          });\n }\n \n pub struct ConvertedMethod {\n@@ -569,9 +576,11 @@ pub fn convert_methods(ccx: @mut CrateCtxt,\n \n             // n.b.: the type of a method is parameterized by both\n             // the tps on the receiver and those on the method itself\n-            {bounds: @(vec::append(/*bad*/copy *rcvr_bounds, *bounds)),\n-             region_param: rp,\n-             ty: fty});\n+            ty_param_bounds_and_ty {\n+                bounds: @(vec::append(/*bad*/copy *rcvr_bounds, *bounds)),\n+                region_param: rp,\n+                ty: fty\n+            });\n         write_ty_to_tcx(tcx, m.id, fty);\n         ConvertedMethod {mty: mty, id: m.id,\n                          span: m.span, body_id: m.body.node.id}\n@@ -615,9 +624,10 @@ pub fn convert(ccx: @mut CrateCtxt, it: @ast::item) {\n         let selfty = ccx.to_ty(type_rscope(rp), selfty);\n         write_ty_to_tcx(tcx, it.id, selfty);\n         tcx.tcache.insert(local_def(it.id),\n-                          {bounds: i_bounds,\n-                           region_param: rp,\n-                           ty: selfty});\n+                          ty_param_bounds_and_ty {\n+                            bounds: i_bounds,\n+                            region_param: rp,\n+                            ty: selfty});\n \n         // XXX: Bad copy of `ms` below.\n         let cms = convert_methods(ccx, /*bad*/copy *ms, rp, i_bounds);\n@@ -636,7 +646,7 @@ pub fn convert(ccx: @mut CrateCtxt, it: @ast::item) {\n \n         let (_, provided_methods) =\n             split_trait_methods(/*bad*/copy *trait_methods);\n-        let {bounds, _} = mk_substs(ccx, /*bad*/copy *tps, rp);\n+        let (bounds, _) = mk_substs(ccx, /*bad*/copy *tps, rp);\n         let _ = convert_methods(ccx, provided_methods, rp, bounds);\n       }\n       ast::item_struct(struct_def, tps) => {\n@@ -682,16 +692,17 @@ pub fn convert_struct(ccx: @mut CrateCtxt,\n                 ast_util::dtor_dec()));\n         write_ty_to_tcx(tcx, dtor.node.id, t_dtor);\n         tcx.tcache.insert(local_def(dtor.node.id),\n-                          {bounds: tpt.bounds,\n-                           region_param: rp,\n-                           ty: t_dtor});\n+                          ty_param_bounds_and_ty {\n+                            bounds: tpt.bounds,\n+                            region_param: rp,\n+                            ty: t_dtor});\n     };\n \n     // Write the type of each of the members\n     for struct_def.fields.each |f| {\n        convert_field(ccx, rp, tpt.bounds, *f);\n     }\n-    let {bounds: _, substs: substs} = mk_substs(ccx, tps, rp);\n+    let (_, substs) = mk_substs(ccx, tps, rp);\n     let selfty = ty::mk_struct(tcx, local_def(id), substs);\n \n     // If this struct is enum-like or tuple-like, create the type of its\n@@ -711,7 +722,7 @@ pub fn convert_struct(ccx: @mut CrateCtxt,\n                             &local_def(field.node.id)).ty);\n                 let ctor_fn_ty = ty::mk_ctor_fn(tcx, inputs, selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n-                tcx.tcache.insert(local_def(ctor_id), {\n+                tcx.tcache.insert(local_def(ctor_id), ty_param_bounds_and_ty {\n                     bounds: tpt.bounds,\n                     region_param: tpt.region_param,\n                     ty: ctor_fn_ty\n@@ -733,27 +744,31 @@ pub fn convert_foreign(ccx: @mut CrateCtxt, i: @ast::foreign_item) {\n pub fn ty_of_method(ccx: @mut CrateCtxt,\n                     m: @ast::method,\n                     rp: Option<ty::region_variance>) -> ty::method {\n-    {ident: m.ident,\n-     tps: ty_param_bounds(ccx, m.tps),\n-     fty: astconv::ty_of_bare_fn(ccx, type_rscope(rp), m.purity,\n-                                 ast::RustAbi, m.decl),\n-     self_ty: m.self_ty.node,\n-     vis: m.vis,\n-     def_id: local_def(m.id)}\n+    ty::method {\n+        ident: m.ident,\n+        tps: ty_param_bounds(ccx, m.tps),\n+        fty: astconv::ty_of_bare_fn(ccx, type_rscope(rp), m.purity,\n+                                    ast::RustAbi, m.decl),\n+        self_ty: m.self_ty.node,\n+        vis: m.vis,\n+        def_id: local_def(m.id)\n+    }\n }\n \n pub fn ty_of_ty_method(self: @mut CrateCtxt,\n                        m: ast::ty_method,\n                        rp: Option<ty::region_variance>,\n                        id: ast::def_id) -> ty::method {\n-    {ident: m.ident,\n-     tps: ty_param_bounds(self, m.tps),\n-     fty: astconv::ty_of_bare_fn(self, type_rscope(rp), m.purity,\n-                                 ast::RustAbi, m.decl),\n-     // assume public, because this is only invoked on trait methods\n-     self_ty: m.self_ty.node,\n-     vis: ast::public,\n-     def_id: id}\n+    ty::method {\n+        ident: m.ident,\n+        tps: ty_param_bounds(self, m.tps),\n+        fty: astconv::ty_of_bare_fn(self, type_rscope(rp), m.purity,\n+                                    ast::RustAbi, m.decl),\n+        // assume public, because this is only invoked on trait methods\n+        self_ty: m.self_ty.node,\n+        vis: ast::public,\n+        def_id: id\n+    }\n }\n \n /*\n@@ -805,9 +820,11 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n         let bounds = ty_param_bounds(ccx, tps);\n         let tofd = astconv::ty_of_bare_fn(ccx, empty_rscope, purity,\n                                           ast::RustAbi, decl);\n-        let tpt = {bounds: bounds,\n-                   region_param: None,\n-                   ty: ty::mk_bare_fn(ccx.tcx, tofd)};\n+        let tpt = ty_param_bounds_and_ty {\n+            bounds: bounds,\n+            region_param: None,\n+            ty: ty::mk_bare_fn(ccx.tcx, tofd)\n+        };\n         debug!(\"type of %s (id %d) is %s\",\n                *tcx.sess.str_of(it.ident),\n                it.id,\n@@ -833,39 +850,47 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n                     ty::mk_with_id(tcx, t0, def_id)\n                 }\n             };\n-            {bounds: ty_param_bounds(ccx, tps),\n-             region_param: rp,\n-             ty: ty}\n+            ty_param_bounds_and_ty {\n+                bounds: ty_param_bounds(ccx, tps),\n+                region_param: rp,\n+                ty: ty\n+            }\n         };\n \n         tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n       ast::item_enum(_, tps) => {\n         // Create a new generic polytype.\n-        let {bounds: bounds, substs: substs} = mk_substs(ccx, tps, rp);\n+        let (bounds, substs) = mk_substs(ccx, tps, rp);\n         let t = ty::mk_enum(tcx, local_def(it.id), substs);\n-        let tpt = {bounds: bounds,\n-                   region_param: rp,\n-                   ty: t};\n+        let tpt = ty_param_bounds_and_ty {\n+            bounds: bounds,\n+            region_param: rp,\n+            ty: t\n+        };\n         tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n       ast::item_trait(tps, _, _) => {\n-        let {bounds: bounds, substs: substs} = mk_substs(ccx, tps, rp);\n+        let (bounds, substs) = mk_substs(ccx, tps, rp);\n         let t = ty::mk_trait(tcx, local_def(it.id), substs, ty::vstore_box);\n-        let tpt = {bounds: bounds,\n-                   region_param: rp,\n-                   ty: t};\n+        let tpt = ty_param_bounds_and_ty {\n+            bounds: bounds,\n+            region_param: rp,\n+            ty: t\n+        };\n         tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n       ast::item_struct(_, tps) => {\n-          let {bounds: bounds, substs: substs} = mk_substs(ccx, tps, rp);\n+          let (bounds, substs) = mk_substs(ccx, tps, rp);\n           let t = ty::mk_struct(tcx, local_def(it.id), substs);\n-          let tpt = {bounds: bounds,\n-                     region_param: rp,\n-                     ty: t};\n+          let tpt = ty_param_bounds_and_ty {\n+            bounds: bounds,\n+            region_param: rp,\n+            ty: t\n+          };\n           tcx.tcache.insert(local_def(it.id), tpt);\n           return tpt;\n       }\n@@ -883,7 +908,7 @@ pub fn ty_of_foreign_item(ccx: @mut CrateCtxt, it: @ast::foreign_item)\n       }\n       ast::foreign_item_const(t) => {\n         let rb = in_binding_rscope(empty_rscope);\n-        return {\n+        return ty::ty_param_bounds_and_ty {\n             bounds: @~[],\n             region_param: None,\n             ty: ast_ty_to_ty(ccx, rb, t)\n@@ -964,32 +989,33 @@ pub fn ty_of_foreign_fn_decl(ccx: @mut CrateCtxt,\n             purity: ast::unsafe_fn,\n             sig: ty::FnSig {inputs: input_tys, output: output_ty}\n         });\n-    let tpt = {bounds: bounds, region_param: None, ty: t_fn};\n+    let tpt = ty_param_bounds_and_ty {\n+        bounds: bounds,\n+        region_param: None,\n+        ty: t_fn\n+    };\n     ccx.tcx.tcache.insert(def_id, tpt);\n     return tpt;\n }\n \n pub fn mk_ty_params(ccx: @mut CrateCtxt, atps: ~[ast::ty_param])\n-    -> {bounds: @~[ty::param_bounds], params: ~[ty::t]} {\n+    -> (@~[ty::param_bounds], ~[ty::t]) {\n \n     let mut i = 0u;\n     let bounds = ty_param_bounds(ccx, atps);\n-    {bounds: bounds,\n-     params: vec::map(atps, |atp| {\n+    (bounds,\n+     vec::map(atps, |atp| {\n          let t = ty::mk_param(ccx.tcx, i, local_def(atp.id));\n          i += 1u;\n          t\n-     })}\n+     }))\n }\n \n pub fn mk_substs(ccx: @mut CrateCtxt,\n                  +atps: ~[ast::ty_param],\n                  rp: Option<ty::region_variance>)\n-              -> {bounds: @~[ty::param_bounds], substs: ty::substs} {\n-    let {bounds, params} = mk_ty_params(ccx, atps);\n+              -> (@~[ty::param_bounds], ty::substs) {\n+    let (bounds, params) = mk_ty_params(ccx, atps);\n     let self_r = rscope::bound_self_region(rp);\n-    {\n-        bounds: bounds,\n-        substs: substs { self_r: self_r, self_ty: None, tps: params }\n-    }\n+    (bounds, substs { self_r: self_r, self_ty: None, tps: params })\n }"}, {"sha": "0d342e338ec23753ddd0cbf23d8c62aa4b3e3ef5", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -138,7 +138,7 @@ pub impl CombineFields {\n         let node_a = self.infcx.get(a_id);\n         let a_id = node_a.root;\n         let a_bounds = &node_a.possible_types;\n-        let b_bounds = &{lb: None, ub: Some(b)};\n+        let b_bounds = &Bounds { lb: None, ub: Some(b) };\n \n         debug!(\"var_sub_t(%s=%s <: %s)\",\n                a_id.to_str(),\n@@ -159,7 +159,7 @@ pub impl CombineFields {\n          *\n          * Make a concrete type (`a`) a subtype of the variable `b_id` */\n \n-        let a_bounds = &{lb: Some(a), ub: None};\n+        let a_bounds = &Bounds { lb: Some(a), ub: None };\n         let node_b = self.infcx.get(b_id);\n         let b_id = node_b.root;\n         let b_bounds = &node_b.possible_types;\n@@ -251,7 +251,7 @@ pub impl CombineFields {\n         let () = if_ok!(self.bnds(&b.lb, &a.ub));\n         let ub = if_ok!(self.merge_bnd(&a.ub, &b.ub, LatticeValue::glb));\n         let lb = if_ok!(self.merge_bnd(&a.lb, &b.lb, LatticeValue::lub));\n-        let bounds = {lb: lb, ub: ub};\n+        let bounds = Bounds { lb: lb, ub: ub };\n         debug!(\"merge(%s): bounds=%s\",\n                v_id.to_str(),\n                bounds.inf_str(self.infcx));\n@@ -305,7 +305,7 @@ pub impl LatticeDir for Lub {\n     fn combine_fields() -> CombineFields { *self }\n     fn bnd<T:Copy>(b: &Bounds<T>) -> Option<T> { b.ub }\n     fn with_bnd<T:Copy>(b: &Bounds<T>, +t: T) -> Bounds<T> {\n-        {ub: Some(t), ..*b}\n+        Bounds { ub: Some(t), ..*b }\n     }\n }\n \n@@ -319,7 +319,7 @@ pub impl LatticeDir for Glb {\n     fn combine_fields() -> CombineFields { *self }\n     fn bnd<T:Copy>(b: &Bounds<T>) -> Option<T> { b.lb }\n     fn with_bnd<T:Copy>(b: &Bounds<T>, +t: T) -> Bounds<T> {\n-        {lb: Some(t), ..*b}\n+        Bounds { lb: Some(t), ..*b }\n     }\n }\n "}, {"sha": "4c6fb721956eb83fb592004b3c13c968083d48a3", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -299,7 +299,10 @@ pub mod unify;\n pub mod coercion;\n \n pub type Bound<T> = Option<T>;\n-pub type Bounds<T> = {lb: Bound<T>, ub: Bound<T>};\n+pub struct Bounds<T> {\n+    lb: Bound<T>,\n+    ub: Bound<T>\n+}\n \n pub type cres<T> = Result<T,ty::type_err>; // \"combine result\"\n pub type ures = cres<()>; // \"unify result\"\n@@ -644,7 +647,7 @@ impl @mut InferCtxt {\n         let id = self.ty_var_counter;\n         self.ty_var_counter += 1;\n         let vals = self.ty_var_bindings.vals;\n-        vals.insert(id, Root({lb: None, ub: None}, 0u));\n+        vals.insert(id, Root(Bounds { lb: None, ub: None }, 0u));\n         return TyVid(id);\n     }\n \n@@ -750,7 +753,7 @@ impl @mut InferCtxt {\n             span: span,\n             fsig: &ty::FnSig)\n          -> (ty::FnSig, isr_alist) {\n-        let {fn_sig: fn_sig, isr: isr, _} =\n+        let(isr, _, fn_sig) =\n             replace_bound_regions_in_fn_sig(self.tcx, @Nil, None, fsig, |br| {\n                 // N.B.: The name of the bound region doesn't have anything to\n                 // do with the region variable that's created for it.  The"}, {"sha": "a4e706db60e9c29e907a526dd7ddf9926e3c8106", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -51,7 +51,7 @@ use core::prelude::*;\n use middle::ty::{FloatVar, FloatVid, IntVar, IntVid, RegionVid, TyVar, TyVid};\n use middle::ty::{type_is_bot, IntType, UintType};\n use middle::ty;\n-use middle::typeck::infer::{cyclic_ty, fixup_err, fres, InferCtxt};\n+use middle::typeck::infer::{Bounds, cyclic_ty, fixup_err, fres, InferCtxt};\n use middle::typeck::infer::{region_var_bound_by_region_var, unresolved_ty};\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::unify::Root;\n@@ -223,10 +223,11 @@ pub impl ResolveState {\n             let bounds = nde.possible_types;\n \n             let t1 = match bounds {\n-              { ub:_, lb:Some(t) } if !type_is_bot(t) => self.resolve_type(t),\n-              { ub:Some(t), lb:_ } => self.resolve_type(t),\n-              { ub:_, lb:Some(t) } => self.resolve_type(t),\n-              { ub:None, lb:None } => {\n+              Bounds { ub:_, lb:Some(t) } if !type_is_bot(t)\n+                => self.resolve_type(t),\n+              Bounds { ub:Some(t), lb:_ } => self.resolve_type(t),\n+              Bounds { ub:_, lb:Some(t) } => self.resolve_type(t),\n+              Bounds { ub:None, lb:None } => {\n                 if self.should(force_tvar) {\n                     self.err = Some(unresolved_ty(vid));\n                 }"}, {"sha": "2c8c60a84fb8ba41737fef2c1eccffa42e092477", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -160,7 +160,7 @@ pub impl Combine for Sub {\n \n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region.\n-        let {fn_sig: b_sig, isr: skol_isr, _} = {\n+        let (skol_isr, _, b_sig) = {\n             do replace_bound_regions_in_fn_sig(self.infcx.tcx, @Nil,\n                                               None, b) |br| {\n                 let skol = self.infcx.region_vars.new_skolemized(br);"}, {"sha": "1fe8b9b51a0c3913f8ae8467dad7951a54cde3d6", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -235,7 +235,11 @@ pub fn lookup_def_ccx(ccx: @mut CrateCtxt, sp: span, id: ast::node_id)\n }\n \n pub fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n-    {bounds: @~[], region_param: None, ty: t}\n+    ty::ty_param_bounds_and_ty {\n+        bounds: @~[],\n+        region_param: None,\n+        ty: t\n+    }\n }\n \n pub fn require_same_types("}, {"sha": "046c2a025beeef9c3e1b29d26cc5452360e597c1", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -68,10 +68,10 @@ pub fn bound_self_region(rp: Option<ty::region_variance>)\n     }\n }\n \n-pub enum anon_rscope = {anon: ty::Region, base: region_scope};\n+pub struct anon_rscope { anon: ty::Region, base: region_scope }\n pub fn in_anon_rscope<RS: region_scope Copy Durable>(self: RS, r: ty::Region)\n     -> @anon_rscope {\n-    @anon_rscope({anon: r, base: self as region_scope})\n+    @anon_rscope { anon: r, base: self as region_scope }\n }\n pub impl region_scope for @anon_rscope {\n     pure fn anon_region(_span: span) -> Result<ty::Region, ~str> {"}, {"sha": "93bc0dc0a2cda9c643254f5f138cb0d64d6a10ce", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -19,7 +19,6 @@\n #[crate_type = \"lib\"];\n \n #[legacy_modes];\n-#[legacy_records];\n \n #[allow(non_implicitly_copyable_typarams)];\n #[allow(non_camel_case_types)];"}, {"sha": "257c651efc6f104bab84f66f13b5680aac7e7b1d", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -131,7 +131,7 @@ fn record(repl: Repl, blk: @ast::blk, intr: @token::ident_interner) -> Repl {\n \n /// Run an input string in a Repl, returning the new Repl.\n fn run(repl: Repl, input: ~str) -> Repl {\n-    let options: @session::options = @{\n+    let options = @session::options {\n         crate_type: session::unknown_crate,\n         binary: repl.binary,\n         addl_lib_search_paths: repl.lib_search_paths.map(|p| Path(*p)),\n@@ -157,7 +157,7 @@ fn run(repl: Repl, input: ~str) -> Repl {\n \n     let outputs = driver::build_output_filenames(wrapped, &None, &None, sess);\n     debug!(\"calling compile_upto\");\n-    let {crate: crate, tcx: _} = driver::compile_upto(sess, cfg, wrapped,\n+    let (crate, _) = driver::compile_upto(sess, cfg, wrapped,\n                                                  driver::cu_everything,\n                                                  Some(outputs));\n \n@@ -196,7 +196,7 @@ fn run(repl: Repl, input: ~str) -> Repl {\n fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n     match do task::try {\n         let src_path = Path(src_filename);\n-        let options: @session::options = @{\n+        let options = @session::options {\n             binary: binary,\n             addl_lib_search_paths: ~[os::getcwd()],\n             .. *session::basic_options()"}, {"sha": "f4393425e18d44cc9846d1a94843968d8eddbfb2", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -64,15 +64,15 @@ impl PackageScript {\n         }\n \n         let binary = os::args()[0];\n-        let options: @session::options = @{\n+        let options = @session::options {\n             binary: binary,\n             crate_type: session::bin_crate,\n             .. *session::basic_options()\n         };\n         let input = driver::file_input(script);\n         let sess = driver::build_session(options, diagnostic::emit);\n         let cfg = driver::build_configuration(sess, binary, input);\n-        let {crate, _} = driver::compile_upto(sess, cfg, input,\n+        let (crate, _) = driver::compile_upto(sess, cfg, input,\n                                               driver::cu_parse, None);\n         let mut id = None;\n         let mut vers = None;"}, {"sha": "5e549d9649080c68c20f814109617eb628c003fe", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -599,7 +599,7 @@ pub fn compile_input(sysroot: Option<Path>, input: driver::input, dir: &Path,\n     let test_dir = dir.push(~\"test\");\n     let binary = os::args()[0];\n     let matches = getopts(flags, driver::optgroups()).get();\n-    let options = @{\n+    let options = @session::options {\n         crate_type: session::unknown_crate,\n         optimize: if opt { session::Aggressive } else { session::No },\n         test: test,\n@@ -612,15 +612,15 @@ pub fn compile_input(sysroot: Option<Path>, input: driver::input, dir: &Path,\n         crate_cfg.push(attr::mk_word_item(@cfg));\n     }\n \n-    let options = @{\n+    let options = @session::options {\n         cfg: vec::append(options.cfg, crate_cfg),\n         .. *options\n     };\n     let sess = driver::build_session(options, diagnostic::emit);\n     let cfg = driver::build_configuration(sess, binary, input);\n     let mut outputs = driver::build_output_filenames(input, &None, &None,\n                                                      sess);\n-    let {crate, _} = driver::compile_upto(sess, cfg, input, driver::cu_parse,\n+    let (crate, _) = driver::compile_upto(sess, cfg, input, driver::cu_parse,\n                                           Some(outputs));\n \n     let mut name = None;"}, {"sha": "fec3a961a52a226d742f61681f288763e0012f70", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "patch": "@@ -48,10 +48,10 @@ pub pure fn stmt_id(s: stmt) -> node_id {\n     }\n }\n \n-pub fn variant_def_ids(d: def) -> {enm: def_id, var: def_id} {\n+pub fn variant_def_ids(d: def) -> (def_id, def_id) {\n     match d {\n       def_variant(enum_id, var_id) => {\n-        return {enm: enum_id, var: var_id}\n+        return (enum_id, var_id);\n       }\n       _ => fail!(~\"non-variant in variant_def_ids\")\n     }"}]}