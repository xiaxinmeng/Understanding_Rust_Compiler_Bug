{"sha": "6e3e74dd719334e84edd70ba0a842f5d4f94d266", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlM2U3NGRkNzE5MzM0ZTg0ZWRkNzBiYTBhODQyZjVkNGY5NGQyNjY=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-08-24T02:57:47Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-08-24T02:57:47Z"}, "message": "Fix bad rebase\n\nHad to use -Xignore-whitespace-conflicts to avoid awful conflicts, but\nthat threw off the indentation", "tree": {"sha": "613a20087d2bfd57eb4a7616c9438f8def50bc83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/613a20087d2bfd57eb4a7616c9438f8def50bc83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e3e74dd719334e84edd70ba0a842f5d4f94d266", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e3e74dd719334e84edd70ba0a842f5d4f94d266", "html_url": "https://github.com/rust-lang/rust/commit/6e3e74dd719334e84edd70ba0a842f5d4f94d266", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e3e74dd719334e84edd70ba0a842f5d4f94d266/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a549c3ae70c88c04621a57cf1a5feb0982224176", "url": "https://api.github.com/repos/rust-lang/rust/commits/a549c3ae70c88c04621a57cf1a5feb0982224176", "html_url": "https://github.com/rust-lang/rust/commit/a549c3ae70c88c04621a57cf1a5feb0982224176"}], "stats": {"total": 328, "additions": 164, "deletions": 164}, "files": [{"sha": "7a0cf3717c93f77a1476a9ab975ca447da8e6963", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 164, "deletions": 164, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/6e3e74dd719334e84edd70ba0a842f5d4f94d266/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3e74dd719334e84edd70ba0a842f5d4f94d266/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=6e3e74dd719334e84edd70ba0a842f5d4f94d266", "patch": "@@ -410,7 +410,7 @@ pub fn run_core(\n                 let body = hir.body(hir.body_owned_by(hir.local_def_id_to_hir_id(def_id)));\n                 debug!(\"visiting body for {:?}\", def_id);\n                 tcx.sess.time(\"emit_ignored_resolution_errors\", || {\n-                EmitIgnoredResolutionErrors::new(tcx).visit_body(body);\n+                    EmitIgnoredResolutionErrors::new(tcx).visit_body(body);\n                 });\n                 (rustc_interface::DEFAULT_QUERY_PROVIDERS.typeck)(tcx, def_id)\n             };\n@@ -434,19 +434,19 @@ pub fn run_core(\n                 // intra-doc-links\n                 resolver.borrow_mut().access(|resolver| {\n                     sess.time(\"load_extern_crates\", || {\n-                    for extern_name in &extern_names {\n-                        resolver\n-                            .resolve_str_path_error(\n-                                DUMMY_SP,\n-                                extern_name,\n-                                TypeNS,\n-                                LocalDefId { local_def_index: CRATE_DEF_INDEX }.to_def_id(),\n-                            )\n-                            .unwrap_or_else(|()| {\n-                                panic!(\"Unable to resolve external crate {}\", extern_name)\n-                            });\n-                    }\n-                });\n+                        for extern_name in &extern_names {\n+                            resolver\n+                                .resolve_str_path_error(\n+                                    DUMMY_SP,\n+                                    extern_name,\n+                                    TypeNS,\n+                                    LocalDefId { local_def_index: CRATE_DEF_INDEX }.to_def_id(),\n+                                )\n+                                .unwrap_or_else(|()| {\n+                                    panic!(\"Unable to resolve external crate {}\", extern_name)\n+                                });\n+                        }\n+                    });\n                 });\n \n                 // Now we're good to clone the resolver because everything should be loaded\n@@ -484,176 +484,176 @@ fn run_global_ctxt(\n     render_options: RenderOptions,\n     output_format: Option<OutputFormat>,\n ) -> (clean::Crate, RenderInfo, RenderOptions) {\n-                // Certain queries assume that some checks were run elsewhere\n-                // (see https://github.com/rust-lang/rust/pull/73566#issuecomment-656954425),\n-                // so type-check everything other than function bodies in this crate before running lints.\n-\n-                // NOTE: this does not call `tcx.analysis()` so that we won't\n-                // typeck function bodies or run the default rustc lints.\n-                // (see `override_queries` in the `config`)\n-\n-                // HACK(jynelson) this calls an _extremely_ limited subset of `typeck`\n-                // and might break if queries change their assumptions in the future.\n-\n-                // NOTE: This is copy/pasted from typeck/lib.rs and should be kept in sync with those changes.\n-                tcx.sess.time(\"item_types_checking\", || {\n-                    for &module in tcx.hir().krate().modules.keys() {\n-                        tcx.ensure().check_mod_item_types(tcx.hir().local_def_id(module));\n-                    }\n-                });\n-                tcx.sess.abort_if_errors();\n+    // Certain queries assume that some checks were run elsewhere\n+    // (see https://github.com/rust-lang/rust/pull/73566#issuecomment-656954425),\n+    // so type-check everything other than function bodies in this crate before running lints.\n+\n+    // NOTE: this does not call `tcx.analysis()` so that we won't\n+    // typeck function bodies or run the default rustc lints.\n+    // (see `override_queries` in the `config`)\n+\n+    // HACK(jynelson) this calls an _extremely_ limited subset of `typeck`\n+    // and might break if queries change their assumptions in the future.\n+\n+    // NOTE: This is copy/pasted from typeck/lib.rs and should be kept in sync with those changes.\n+    tcx.sess.time(\"item_types_checking\", || {\n+        for &module in tcx.hir().krate().modules.keys() {\n+            tcx.ensure().check_mod_item_types(tcx.hir().local_def_id(module));\n+        }\n+    });\n+    tcx.sess.abort_if_errors();\n     tcx.sess.time(\"missing_docs\", || {\n-                    rustc_lint::check_crate(tcx, rustc_lint::builtin::MissingDoc::new);\n-                });\n+        rustc_lint::check_crate(tcx, rustc_lint::builtin::MissingDoc::new);\n+    });\n     tcx.sess.time(\"check_mod_attrs\", || {\n-                for &module in tcx.hir().krate().modules.keys() {\n-                    let local_def_id = tcx.hir().local_def_id(module);\n-                    tcx.ensure().check_mod_attrs(local_def_id);\n-                }\n+        for &module in tcx.hir().krate().modules.keys() {\n+            let local_def_id = tcx.hir().local_def_id(module);\n+            tcx.ensure().check_mod_attrs(local_def_id);\n+        }\n     });\n \n-                let access_levels = tcx.privacy_access_levels(LOCAL_CRATE);\n-                // Convert from a HirId set to a DefId set since we don't always have easy access\n-                // to the map from defid -> hirid\n-                let access_levels = AccessLevels {\n-                    map: access_levels\n-                        .map\n-                        .iter()\n-                        .map(|(&k, &v)| (tcx.hir().local_def_id(k).to_def_id(), v))\n-                        .collect(),\n-                };\n-\n-                let mut renderinfo = RenderInfo::default();\n-                renderinfo.access_levels = access_levels;\n-                renderinfo.output_format = output_format;\n-\n-                let mut ctxt = DocContext {\n-                    tcx,\n-                    resolver,\n-                    external_traits: Default::default(),\n-                    active_extern_traits: Default::default(),\n-                    renderinfo: RefCell::new(renderinfo),\n-                    ty_substs: Default::default(),\n-                    lt_substs: Default::default(),\n-                    ct_substs: Default::default(),\n-                    impl_trait_bounds: Default::default(),\n-                    fake_def_ids: Default::default(),\n-                    all_fake_def_ids: Default::default(),\n-                    generated_synthetics: Default::default(),\n-                    auto_traits: tcx\n-                        .all_traits(LOCAL_CRATE)\n-                        .iter()\n-                        .cloned()\n-                        .filter(|trait_def_id| tcx.trait_is_auto(*trait_def_id))\n-                        .collect(),\n-                    render_options,\n-                    module_trait_cache: RefCell::new(FxHashMap::default()),\n-                };\n-                debug!(\"crate: {:?}\", tcx.hir().krate());\n+    let access_levels = tcx.privacy_access_levels(LOCAL_CRATE);\n+    // Convert from a HirId set to a DefId set since we don't always have easy access\n+    // to the map from defid -> hirid\n+    let access_levels = AccessLevels {\n+        map: access_levels\n+            .map\n+            .iter()\n+            .map(|(&k, &v)| (tcx.hir().local_def_id(k).to_def_id(), v))\n+            .collect(),\n+    };\n+\n+    let mut renderinfo = RenderInfo::default();\n+    renderinfo.access_levels = access_levels;\n+    renderinfo.output_format = output_format;\n+\n+    let mut ctxt = DocContext {\n+        tcx,\n+        resolver,\n+        external_traits: Default::default(),\n+        active_extern_traits: Default::default(),\n+        renderinfo: RefCell::new(renderinfo),\n+        ty_substs: Default::default(),\n+        lt_substs: Default::default(),\n+        ct_substs: Default::default(),\n+        impl_trait_bounds: Default::default(),\n+        fake_def_ids: Default::default(),\n+        all_fake_def_ids: Default::default(),\n+        generated_synthetics: Default::default(),\n+        auto_traits: tcx\n+            .all_traits(LOCAL_CRATE)\n+            .iter()\n+            .cloned()\n+            .filter(|trait_def_id| tcx.trait_is_auto(*trait_def_id))\n+            .collect(),\n+        render_options,\n+        module_trait_cache: RefCell::new(FxHashMap::default()),\n+    };\n+    debug!(\"crate: {:?}\", tcx.hir().krate());\n \n     let mut krate = tcx.sess.time(\"clean_crate\", || clean::krate(&mut ctxt));\n \n-                if let Some(ref m) = krate.module {\n-                    if let None | Some(\"\") = m.doc_value() {\n-                        let help = \"The following guide may be of use:\\n\\\n-                             https://doc.rust-lang.org/nightly/rustdoc/how-to-write-documentation\\\n-                             .html\";\n-                        tcx.struct_lint_node(\n-                            rustc_lint::builtin::MISSING_CRATE_LEVEL_DOCS,\n-                            ctxt.as_local_hir_id(m.def_id).unwrap(),\n-                            |lint| {\n+    if let Some(ref m) = krate.module {\n+        if let None | Some(\"\") = m.doc_value() {\n+            let help = \"The following guide may be of use:\\n\\\n+                    https://doc.rust-lang.org/nightly/rustdoc/how-to-write-documentation\\\n+                    .html\";\n+            tcx.struct_lint_node(\n+                rustc_lint::builtin::MISSING_CRATE_LEVEL_DOCS,\n+                ctxt.as_local_hir_id(m.def_id).unwrap(),\n+                |lint| {\n                     let mut diag =\n                         lint.build(\"no documentation found for this crate's top-level module\");\n-                                diag.help(help);\n-                                diag.emit();\n-                            },\n-                        );\n-                    }\n-                }\n+                    diag.help(help);\n+                    diag.emit();\n+                },\n+            );\n+        }\n+    }\n \n-                fn report_deprecated_attr(name: &str, diag: &rustc_errors::Handler) {\n+    fn report_deprecated_attr(name: &str, diag: &rustc_errors::Handler) {\n         let mut msg = diag\n             .struct_warn(&format!(\"the `#![doc({})]` attribute is considered deprecated\", name));\n-                    msg.warn(\n-                        \"see issue #44136 <https://github.com/rust-lang/rust/issues/44136> \\\n-                         for more information\",\n-                    );\n+        msg.warn(\n+            \"see issue #44136 <https://github.com/rust-lang/rust/issues/44136> \\\n+                for more information\",\n+        );\n+\n+        if name == \"no_default_passes\" {\n+            msg.help(\"you may want to use `#![doc(document_private_items)]`\");\n+        }\n \n-                    if name == \"no_default_passes\" {\n-                        msg.help(\"you may want to use `#![doc(document_private_items)]`\");\n-                    }\n+        msg.emit();\n+    }\n \n-                    msg.emit();\n+    // Process all of the crate attributes, extracting plugin metadata along\n+    // with the passes which we are supposed to run.\n+    for attr in krate.module.as_ref().unwrap().attrs.lists(sym::doc) {\n+        let diag = ctxt.sess().diagnostic();\n+\n+        let name = attr.name_or_empty();\n+        if attr.is_word() {\n+            if name == sym::no_default_passes {\n+                report_deprecated_attr(\"no_default_passes\", diag);\n+                if default_passes == passes::DefaultPassOption::Default {\n+                    default_passes = passes::DefaultPassOption::None;\n+                }\n+            }\n+        } else if let Some(value) = attr.value_str() {\n+            let sink = match name {\n+                sym::passes => {\n+                    report_deprecated_attr(\"passes = \\\"...\\\"\", diag);\n+                    &mut manual_passes\n+                }\n+                sym::plugins => {\n+                    report_deprecated_attr(\"plugins = \\\"...\\\"\", diag);\n+                    eprintln!(\n+                        \"WARNING: `#![doc(plugins = \\\"...\\\")]` \\\n+                            no longer functions; see CVE-2018-1000622\"\n+                    );\n+                    continue;\n                 }\n+                _ => continue,\n+            };\n+            for name in value.as_str().split_whitespace() {\n+                sink.push(name.to_string());\n+            }\n+        }\n \n-                // Process all of the crate attributes, extracting plugin metadata along\n-                // with the passes which we are supposed to run.\n-                for attr in krate.module.as_ref().unwrap().attrs.lists(sym::doc) {\n-                    let diag = ctxt.sess().diagnostic();\n-\n-                    let name = attr.name_or_empty();\n-                    if attr.is_word() {\n-                        if name == sym::no_default_passes {\n-                            report_deprecated_attr(\"no_default_passes\", diag);\n-                            if default_passes == passes::DefaultPassOption::Default {\n-                                default_passes = passes::DefaultPassOption::None;\n-                            }\n-                        }\n-                    } else if let Some(value) = attr.value_str() {\n-                        let sink = match name {\n-                            sym::passes => {\n-                                report_deprecated_attr(\"passes = \\\"...\\\"\", diag);\n-                                &mut manual_passes\n-                            }\n-                            sym::plugins => {\n-                                report_deprecated_attr(\"plugins = \\\"...\\\"\", diag);\n-                                eprintln!(\n-                                    \"WARNING: `#![doc(plugins = \\\"...\\\")]` \\\n-                                      no longer functions; see CVE-2018-1000622\"\n-                                );\n-                                continue;\n-                            }\n-                            _ => continue,\n-                        };\n-                        for name in value.as_str().split_whitespace() {\n-                            sink.push(name.to_string());\n-                        }\n-                    }\n+        if attr.is_word() && name == sym::document_private_items {\n+            ctxt.render_options.document_private = true;\n+        }\n+    }\n \n-                    if attr.is_word() && name == sym::document_private_items {\n-                        ctxt.render_options.document_private = true;\n-                    }\n-                }\n+    let passes = passes::defaults(default_passes).iter().copied().chain(\n+        manual_passes.into_iter().flat_map(|name| {\n+            if let Some(pass) = passes::find_pass(&name) {\n+                Some(ConditionalPass::always(pass))\n+            } else {\n+                error!(\"unknown pass {}, skipping\", name);\n+                None\n+            }\n+        }),\n+    );\n \n-                let passes = passes::defaults(default_passes).iter().copied().chain(\n-                    manual_passes.into_iter().flat_map(|name| {\n-                        if let Some(pass) = passes::find_pass(&name) {\n-                            Some(ConditionalPass::always(pass))\n-                        } else {\n-                            error!(\"unknown pass {}, skipping\", name);\n-                            None\n-                        }\n-                    }),\n-                );\n-\n-                info!(\"Executing passes\");\n-\n-                for p in passes {\n-                    let run = match p.condition {\n-                        Always => true,\n-                        WhenDocumentPrivate => ctxt.render_options.document_private,\n-                        WhenNotDocumentPrivate => !ctxt.render_options.document_private,\n-                        WhenNotDocumentHidden => !ctxt.render_options.document_hidden,\n-                    };\n-                    if run {\n-                        debug!(\"running pass {}\", p.pass.name);\n-                        krate = ctxt.tcx.sess.time(p.pass.name, || (p.pass.run)(krate, &ctxt));\n-                    }\n-                }\n+    info!(\"Executing passes\");\n+\n+    for p in passes {\n+        let run = match p.condition {\n+            Always => true,\n+            WhenDocumentPrivate => ctxt.render_options.document_private,\n+            WhenNotDocumentPrivate => !ctxt.render_options.document_private,\n+            WhenNotDocumentHidden => !ctxt.render_options.document_hidden,\n+        };\n+        if run {\n+            debug!(\"running pass {}\", p.pass.name);\n+            krate = ctxt.tcx.sess.time(p.pass.name, || (p.pass.run)(krate, &ctxt));\n+        }\n+    }\n \n-                ctxt.sess().abort_if_errors();\n+    ctxt.sess().abort_if_errors();\n \n-                (krate, ctxt.renderinfo.into_inner(), ctxt.render_options)\n+    (krate, ctxt.renderinfo.into_inner(), ctxt.render_options)\n }\n \n /// Due to https://github.com/rust-lang/rust/pull/73566,"}]}