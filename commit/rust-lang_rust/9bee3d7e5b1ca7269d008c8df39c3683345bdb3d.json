{"sha": "9bee3d7e5b1ca7269d008c8df39c3683345bdb3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliZWUzZDdlNWIxY2E3MjY5ZDAwOGM4ZGYzOWMzNjgzMzQ1YmRiM2Q=", "commit": {"author": {"name": "David Creswick", "email": "dcrewi@gyrae.net", "date": "2013-09-09T16:15:03Z"}, "committer": {"name": "David Creswick", "email": "dcrewi@gyrae.net", "date": "2013-09-09T16:15:03Z"}, "message": "Convert between BigInts, BigUints, ints, and uints\n\nPreviously, conversion to ints, uints, and BigUints clamped the value\nwithin the range of that datatype. With this commit, conversion\noverflows fail the task. To handle overflows gracefully, use the new\nto_*_opt() methods.", "tree": {"sha": "31a1a1f3d649c7229424da29945512713637189e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31a1a1f3d649c7229424da29945512713637189e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bee3d7e5b1ca7269d008c8df39c3683345bdb3d", "comment_count": 17, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bee3d7e5b1ca7269d008c8df39c3683345bdb3d", "html_url": "https://github.com/rust-lang/rust/commit/9bee3d7e5b1ca7269d008c8df39c3683345bdb3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bee3d7e5b1ca7269d008c8df39c3683345bdb3d/comments", "author": {"login": "dcrewi", "id": 1852207, "node_id": "MDQ6VXNlcjE4NTIyMDc=", "avatar_url": "https://avatars.githubusercontent.com/u/1852207?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dcrewi", "html_url": "https://github.com/dcrewi", "followers_url": "https://api.github.com/users/dcrewi/followers", "following_url": "https://api.github.com/users/dcrewi/following{/other_user}", "gists_url": "https://api.github.com/users/dcrewi/gists{/gist_id}", "starred_url": "https://api.github.com/users/dcrewi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dcrewi/subscriptions", "organizations_url": "https://api.github.com/users/dcrewi/orgs", "repos_url": "https://api.github.com/users/dcrewi/repos", "events_url": "https://api.github.com/users/dcrewi/events{/privacy}", "received_events_url": "https://api.github.com/users/dcrewi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dcrewi", "id": 1852207, "node_id": "MDQ6VXNlcjE4NTIyMDc=", "avatar_url": "https://avatars.githubusercontent.com/u/1852207?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dcrewi", "html_url": "https://github.com/dcrewi", "followers_url": "https://api.github.com/users/dcrewi/followers", "following_url": "https://api.github.com/users/dcrewi/following{/other_user}", "gists_url": "https://api.github.com/users/dcrewi/gists{/gist_id}", "starred_url": "https://api.github.com/users/dcrewi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dcrewi/subscriptions", "organizations_url": "https://api.github.com/users/dcrewi/orgs", "repos_url": "https://api.github.com/users/dcrewi/repos", "events_url": "https://api.github.com/users/dcrewi/events{/privacy}", "received_events_url": "https://api.github.com/users/dcrewi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfb04d9953f640301c80cbe910b91ca9c92af55a", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfb04d9953f640301c80cbe910b91ca9c92af55a", "html_url": "https://github.com/rust-lang/rust/commit/dfb04d9953f640301c80cbe910b91ca9c92af55a"}], "stats": {"total": 153, "additions": 100, "deletions": 53}, "files": [{"sha": "4294b2afbb06d978b67c0ae223872fac90d7c421", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 100, "deletions": 53, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/9bee3d7e5b1ca7269d008c8df39c3683345bdb3d/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bee3d7e5b1ca7269d008c8df39c3683345bdb3d/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=9bee3d7e5b1ca7269d008c8df39c3683345bdb3d", "patch": "@@ -465,7 +465,7 @@ impl Integer for BigUint {\n impl IntConvertible for BigUint {\n     #[inline]\n     fn to_int(&self) -> int {\n-        num::min(self.to_uint(), int::max_value as uint) as int\n+        self.to_int_opt().expect(\"BigUint conversion would overflow int\")\n     }\n \n     #[inline]\n@@ -577,19 +577,38 @@ impl BigUint {\n     }\n \n \n-    /// Converts this big integer into a uint, returning the uint::max_value if\n-    /// it's too large to fit in a uint.\n+    /// Converts this BigUint into a uint, failing if the conversion\n+    /// would overflow.\n     #[inline]\n     pub fn to_uint(&self) -> uint {\n+        self.to_uint_opt().expect(\"BigUint conversion would overflow uint\")\n+    }\n+\n+    /// Converts this BigUint into a uint, unless it would overflow.\n+    #[inline]\n+    pub fn to_uint_opt(&self) -> Option<uint> {\n         match self.data.len() {\n-            0 => 0,\n-            1 => self.data[0] as uint,\n-            2 => BigDigit::to_uint(self.data[1], self.data[0]),\n-            _ => uint::max_value\n+            0 => Some(0),\n+            1 => Some(self.data[0] as uint),\n+            2 => Some(BigDigit::to_uint(self.data[1], self.data[0])),\n+            _ => None\n         }\n     }\n \n-    /// Converts this BigUint into a positively-signed BigInt.\n+    // Converts this BigUint into an int, unless it would overflow.\n+    pub fn to_int_opt(&self) -> Option<int> {\n+        self.to_uint_opt().chain(|n| {\n+            // If top bit of uint is set, it's too large to convert to\n+            // int.\n+            if (n >> (2*BigDigit::bits - 1) != 0) {\n+                None\n+            } else {\n+                Some(n as int)\n+            }\n+        })\n+    }\n+\n+    /// Converts this BigUint into a BigInt.\n     #[inline]\n     pub fn to_bigint(&self) -> BigInt {\n         BigInt::from_biguint(Plus, self.clone())\n@@ -1016,12 +1035,7 @@ impl Integer for BigInt {\n impl IntConvertible for BigInt {\n     #[inline]\n     fn to_int(&self) -> int {\n-        match self.sign {\n-            Plus  => num::min(self.to_uint(), int::max_value as uint) as int,\n-            Zero  => 0,\n-            Minus => num::min((-self).to_uint(),\n-                               (int::max_value as uint) + 1) as int\n-        }\n+        self.to_int_opt().expect(\"BigInt conversion would overflow int\")\n     }\n \n     #[inline]\n@@ -1100,22 +1114,55 @@ impl BigInt {\n             .map_move(|bu| BigInt::from_biguint(sign, bu));\n     }\n \n+    /// Converts this BigInt into a uint, failing if the conversion\n+    /// would overflow.\n     #[inline]\n     pub fn to_uint(&self) -> uint {\n+        self.to_uint_opt().expect(\"BigInt conversion would overflow uint\")\n+    }\n+\n+    /// Converts this BigInt into a uint, unless it would overflow.\n+    #[inline]\n+    pub fn to_uint_opt(&self) -> Option<uint> {\n         match self.sign {\n-            Plus  => self.data.to_uint(),\n-            Zero  => 0,\n-            Minus => 0\n+            Plus => self.data.to_uint_opt(),\n+            Zero => Some(0),\n+            Minus => None\n         }\n     }\n \n-    /// Converts this BigInt into a BigUint. Negative BigInts are\n-    /// converted to zero-valued BigUints.\n+    /// Converts this BigInt into an int, unless it would overflow.\n+    pub fn to_int_opt(&self) -> Option<int> {\n+        match self.sign {\n+            Plus  => self.data.to_int_opt(),\n+            Zero  => Some(0),\n+            Minus => self.data.to_uint_opt().chain(|n| {\n+                let m: uint = 1 << (2*BigDigit::bits-1);\n+                if (n > m) {\n+                    None\n+                } else if (n == m) {\n+                    Some(int::min_value)\n+                } else {\n+                    Some(-(n as int))\n+                }\n+            })\n+        }\n+    }\n+\n+    /// Converts this BigInt into a BigUint, failing if BigInt is\n+    /// negative.\n     #[inline]\n     pub fn to_biguint(&self) -> BigUint {\n+        self.to_biguint_opt().expect(\"negative BigInt cannot convert to BigUint\")\n+    }\n+\n+    /// Converts this BigInt into a BigUint, if it's not negative.\n+    #[inline]\n+    pub fn to_biguint_opt(&self) -> Option<BigUint> {\n         match self.sign {\n-            Plus => self.data.clone(),\n-            _ => Zero::zero()\n+            Plus => Some(self.data.clone()),\n+            Zero => Some(Zero::zero()),\n+            Minus => None\n         }\n     }\n }\n@@ -1273,9 +1320,9 @@ mod biguint_tests {\n         check(~[ 0,  1], ((uint::max_value >> BigDigit::bits) + 1) as int);\n         check(~[-1, -1 >> 1], int::max_value);\n \n-        assert_eq!(BigUint::new(~[0, -1]).to_int(), int::max_value);\n-        assert_eq!(BigUint::new(~[0, 0, 1]).to_int(), int::max_value);\n-        assert_eq!(BigUint::new(~[0, 0, -1]).to_int(), int::max_value);\n+        assert_eq!(BigUint::new(~[0, -1]).to_int_opt(), None);\n+        assert_eq!(BigUint::new(~[0, 0, 1]).to_int_opt(), None);\n+        assert_eq!(BigUint::new(~[0, 0, -1]).to_int_opt(), None);\n     }\n \n     #[test]\n@@ -1293,8 +1340,8 @@ mod biguint_tests {\n         check(~[ 0, -1], uint::max_value << BigDigit::bits);\n         check(~[-1, -1], uint::max_value);\n \n-        assert_eq!(BigUint::new(~[0, 0, 1]).to_uint(), uint::max_value);\n-        assert_eq!(BigUint::new(~[0, 0, -1]).to_uint(), uint::max_value);\n+        assert_eq!(BigUint::new(~[0, 0, 1]).to_uint_opt(), None);\n+        assert_eq!(BigUint::new(~[0, 0, -1]).to_uint_opt(), None);\n     }\n \n     #[test]\n@@ -1304,7 +1351,8 @@ mod biguint_tests {\n             assert_eq!(n.to_bigint().to_biguint(), n);\n         }\n         check(Zero::zero(), Zero::zero());\n-        check(BigUint::from_uint(637), BigInt::from_uint(637));\n+        check(BigUint::new(~[1,2,3]),\n+              BigInt::from_biguint(Plus, BigUint::new(~[1,2,3])));\n     }\n \n     static sum_triples: &'static [(&'static [BigDigit],\n@@ -1683,22 +1731,21 @@ mod bigint_tests {\n             Plus, BigUint::from_uint(int::max_value as uint)\n         ), int::max_value);\n \n-        assert!(BigInt::from_biguint(\n+        assert_eq!(BigInt::from_biguint(\n             Plus, BigUint::from_uint(int::max_value as uint + 1)\n-        ).to_int() == int::max_value);\n-        assert!(BigInt::from_biguint(\n+        ).to_int_opt(), None);\n+        assert_eq!(BigInt::from_biguint(\n             Plus, BigUint::new(~[1, 2, 3])\n-        ).to_int() == int::max_value);\n+        ).to_int_opt(), None);\n \n         check(BigInt::from_biguint(\n-            Minus, BigUint::from_uint(-int::min_value as uint)\n+            Minus, BigUint::new(~[0, 1<<(BigDigit::bits-1)])\n         ), int::min_value);\n-        assert!(BigInt::from_biguint(\n-            Minus, BigUint::from_uint(-int::min_value as uint + 1)\n-        ).to_int() == int::min_value);\n-        assert!(BigInt::from_biguint(\n-            Minus, BigUint::new(~[1, 2, 3])\n-        ).to_int() == int::min_value);\n+        assert_eq!(BigInt::from_biguint(\n+            Minus, BigUint::new(~[1, 1<<(BigDigit::bits-1)])\n+        ).to_int_opt(), None);\n+        assert_eq!(BigInt::from_biguint(\n+            Minus, BigUint::new(~[1, 2, 3])).to_int_opt(), None);\n     }\n \n     #[test]\n@@ -1714,31 +1761,31 @@ mod bigint_tests {\n         check(\n             BigInt::from_biguint(Plus, BigUint::from_uint(uint::max_value)),\n             uint::max_value);\n-        assert!(BigInt::from_biguint(\n-            Plus, BigUint::new(~[1, 2, 3])\n-        ).to_uint() == uint::max_value);\n+        assert_eq!(BigInt::from_biguint(\n+            Plus, BigUint::new(~[1, 2, 3])).to_uint_opt(), None);\n \n-        assert!(BigInt::from_biguint(\n-            Minus, BigUint::from_uint(uint::max_value)\n-        ).to_uint() == 0);\n-        assert!(BigInt::from_biguint(\n-            Minus, BigUint::new(~[1, 2, 3])\n-        ).to_uint() == 0);\n+        assert_eq!(BigInt::from_biguint(\n+            Minus, BigUint::from_uint(uint::max_value)).to_uint_opt(), None);\n+        assert_eq!(BigInt::from_biguint(\n+            Minus, BigUint::new(~[1, 2, 3])).to_uint_opt(), None);\n     }\n \n     #[test]\n     fn test_convert_to_biguint() {\n-        fn check(n: BigInt, ans_1: BigUint, ans_2: BigInt) {\n+        fn check(n: BigInt, ans_1: BigUint) {\n             assert_eq!(n.to_biguint(), ans_1);\n-            assert_eq!(n.to_biguint().to_bigint(), ans_2);\n+            assert_eq!(n.to_biguint().to_bigint(), n);\n         }\n         let zero: BigInt = Zero::zero();\n         let unsigned_zero: BigUint = Zero::zero();\n-        let positive: BigInt = BigInt::from_uint(637);\n+        let positive = BigInt::from_biguint(\n+            Plus, BigUint::new(~[1,2,3]));\n         let negative = -positive;\n-        check(zero.clone(), unsigned_zero.clone(), zero.clone());\n-        check(positive.clone(), BigUint::from_uint(637), positive);\n-        check(negative, unsigned_zero, zero);\n+\n+        check(zero, unsigned_zero);\n+        check(positive, BigUint::new(~[1,2,3]));\n+\n+        assert_eq!(negative.to_biguint_opt(), None);\n     }\n \n     static sum_triples: &'static [(&'static [BigDigit],"}]}