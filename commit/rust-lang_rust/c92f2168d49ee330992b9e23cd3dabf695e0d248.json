{"sha": "c92f2168d49ee330992b9e23cd3dabf695e0d248", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5MmYyMTY4ZDQ5ZWUzMzA5OTJiOWUyM2NkM2RhYmY2OTVlMGQyNDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-17T01:11:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-17T01:11:22Z"}, "message": "auto merge of #9833 : alexcrichton/rust/fixes, r=brson\n\nCommits have all the fun details", "tree": {"sha": "0c46e9f339892186b981cdf253d9cf9e4d0e543b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c46e9f339892186b981cdf253d9cf9e4d0e543b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c92f2168d49ee330992b9e23cd3dabf695e0d248", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c92f2168d49ee330992b9e23cd3dabf695e0d248", "html_url": "https://github.com/rust-lang/rust/commit/c92f2168d49ee330992b9e23cd3dabf695e0d248", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c92f2168d49ee330992b9e23cd3dabf695e0d248/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63e097d8c34143411ea6d3146493bd6d8f3428d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/63e097d8c34143411ea6d3146493bd6d8f3428d7", "html_url": "https://github.com/rust-lang/rust/commit/63e097d8c34143411ea6d3146493bd6d8f3428d7"}, {"sha": "fc06f7922db0b4d1063f4f29157635117d853426", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc06f7922db0b4d1063f4f29157635117d853426", "html_url": "https://github.com/rust-lang/rust/commit/fc06f7922db0b4d1063f4f29157635117d853426"}], "stats": {"total": 478, "additions": 366, "deletions": 112}, "files": [{"sha": "372e2313de7b22aa4cd5e7828448678c6ee587d1", "filename": "src/libextra/crypto/digest.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibextra%2Fcrypto%2Fdigest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibextra%2Fcrypto%2Fdigest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fdigest.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Common functionality related to cryptographic digest functions\n+\n use std::vec;\n \n use hex::ToHex;"}, {"sha": "864fc64f82bec9af50535848e15389f0d777f387", "filename": "src/libextra/crypto/md5.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibextra%2Fcrypto%2Fmd5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibextra%2Fcrypto%2Fmd5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fmd5.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(missing_doc)];\n+\n use std::iter::range_step;\n \n use cryptoutil::{write_u32_le, read_u32v_le, FixedBuffer, FixedBuffer64, StandardPadding};"}, {"sha": "fb9a6df50e48c21df37b6f4e3b46ba8c2184e52c", "filename": "src/libextra/crypto/sha2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibextra%2Fcrypto%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibextra%2Fcrypto%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha2.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(missing_doc)];\n+\n use std::iter::range_step;\n \n use cryptoutil::{write_u64_be, write_u32_be, read_u64v_be, read_u32v_be, add_bytes_to_bits,"}, {"sha": "da9e0a225ba1b47f9b35410912274b9db328e474", "filename": "src/libextra/enum_set.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibextra%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibextra%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fenum_set.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! A structure for holding a set of enum variants\n+//!\n+//! This module defines a container which uses an efficient bit mask\n+//! representation to hold C-like enum variants.\n+\n #[deriving(Clone, Eq, IterBytes, ToStr)]\n /// A specialized Set implementation to use enum types.\n pub struct EnumSet<E> {"}, {"sha": "904ed13eabbcc9f7ea12b09b6d79ab99746187df", "filename": "src/libextra/io_util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibextra%2Fio_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibextra%2Fio_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fio_util.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(missing_doc)];\n+\n use std::io::{Reader, BytesReader};\n use std::io;\n use std::cast;"}, {"sha": "96238986bf1c8ef81c376d3455999c33cfefc9fd", "filename": "src/libextra/md4.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibextra%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibextra%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fmd4.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(missing_doc)];\n \n use std::vec;\n "}, {"sha": "c8a17451a705197cae4a141e48490903b960b98c", "filename": "src/libextra/rl.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibextra%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibextra%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frl.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -8,12 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Bindings for the ability to read lines of input from the console\n+\n use std::c_str::ToCStr;\n use std::libc::{c_char, c_int};\n use std::{local_data, str, rt};\n use std::unstable::finally::Finally;\n \n-pub mod rustrt {\n+mod rustrt {\n     use std::libc::{c_char, c_int};\n \n     externfn!(fn linenoise(prompt: *c_char) -> *c_char)"}, {"sha": "cc6ce715ad331c236b3d39750e31629f60ed5405", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(missing_doc)];\n+\n use sort;\n use std::cmp;\n use std::hashmap;"}, {"sha": "b5b182ea8c5809fe4678e580a88cbc44057fac7c", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(missing_doc)];\n+\n /**\n  * The concurrency primitives you know and love.\n  *"}, {"sha": "57e00885b2fb12e40431bb95bb83ba1d74b63561", "filename": "src/libextra/terminfo/terminfo.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibextra%2Fterminfo%2Fterminfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibextra%2Fterminfo%2Fterminfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fterminfo.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(missing_doc)];\n+\n use std::hashmap::HashMap;\n \n /// A parsed terminfo entry."}, {"sha": "5ca81a91bfd0b36ba3751b84d8b462436971e215", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -200,6 +200,7 @@ pub fn phase_2_configure_and_expand(sess: Session,\n \n pub struct CrateAnalysis {\n     exp_map2: middle::resolve::ExportMap2,\n+    exported_items: middle::privacy::ExportedItems,\n     ty_cx: ty::ctxt,\n     maps: astencode::Maps,\n     reachable: @mut HashSet<ast::NodeId>\n@@ -311,6 +312,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n     CrateAnalysis {\n         exp_map2: exp_map2,\n         ty_cx: ty_cx,\n+        exported_items: exported_items,\n         maps: astencode::Maps {\n             root_map: root_map,\n             method_map: method_map,"}, {"sha": "8b21ce320243234a8340c55673ae1b76f94879fe", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -955,6 +955,11 @@ impl Visitor<()> for MissingDocLintVisitor {\n                                  ~\"missing documentation for a function\");\n             }\n \n+            ast::item_mod(*) if it.vis == ast::public => {\n+                self.check_attrs(it.attrs, it.id, it.span,\n+                                 ~\"missing documentation for a module\");\n+            }\n+\n             ast::item_enum(ref edef, _) if it.vis == ast::public => {\n                 self.check_attrs(it.attrs, it.id, it.span,\n                                  ~\"missing documentation for an enum\");"}, {"sha": "d596139f5c006b3a6e33320ce847b7374d6f8ca9", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -10,14 +10,17 @@\n \n use rustc;\n use rustc::{driver, middle};\n+use rustc::middle::privacy;\n \n use syntax::ast;\n+use syntax::ast_util::is_local;\n use syntax::diagnostic;\n use syntax::parse;\n use syntax;\n \n use std::os;\n use std::local_data;\n+use std::hashmap::HashMap;\n \n use visit_ast::RustdocVisitor;\n use clean;\n@@ -29,10 +32,19 @@ pub struct DocContext {\n     sess: driver::session::Session\n }\n \n+pub struct CrateAnalysis {\n+    exported_items: privacy::ExportedItems,\n+    reexports: HashMap<ast::NodeId, ~[ast::NodeId]>,\n+}\n+\n /// Parses, resolves, and typechecks the given crate\n-fn get_ast_and_resolve(cpath: &Path, libs: ~[Path]) -> DocContext {\n+fn get_ast_and_resolve(cpath: &Path,\n+                       libs: ~[Path]) -> (DocContext, CrateAnalysis) {\n     use syntax::codemap::dummy_spanned;\n-    use rustc::driver::driver::*;\n+    use rustc::driver::driver::{file_input, build_configuration,\n+                                phase_1_parse_input,\n+                                phase_2_configure_and_expand,\n+                                phase_3_run_analysis_passes};\n \n     let parsesess = parse::new_parse_sess(None);\n     let input = file_input(cpath.clone());\n@@ -60,14 +72,26 @@ fn get_ast_and_resolve(cpath: &Path, libs: ~[Path]) -> DocContext {\n \n     let mut crate = phase_1_parse_input(sess, cfg.clone(), &input);\n     crate = phase_2_configure_and_expand(sess, cfg, crate);\n-    let analysis = phase_3_run_analysis_passes(sess, &crate);\n+    let driver::driver::CrateAnalysis {\n+        exported_items, ty_cx, exp_map2, _\n+    } = phase_3_run_analysis_passes(sess, &crate);\n+\n+    let mut reexports = HashMap::new();\n+    for (&module, nodes) in exp_map2.iter() {\n+        reexports.insert(module, nodes.iter()\n+                                      .filter(|e| e.reexport && is_local(e.def_id))\n+                                      .map(|e| e.def_id.node)\n+                                      .to_owned_vec());\n+    }\n \n     debug2!(\"crate: {:?}\", crate);\n-    DocContext { crate: crate, tycx: analysis.ty_cx, sess: sess }\n+    return (DocContext { crate: crate, tycx: ty_cx, sess: sess },\n+            CrateAnalysis { reexports: reexports, exported_items: exported_items });\n }\n \n-pub fn run_core (libs: ~[Path], path: &Path) -> clean::Crate {\n-    let ctxt = @get_ast_and_resolve(path, libs);\n+pub fn run_core (libs: ~[Path], path: &Path) -> (clean::Crate, CrateAnalysis) {\n+    let (ctxt, analysis) = get_ast_and_resolve(path, libs);\n+    let ctxt = @ctxt;\n     debug2!(\"defmap:\");\n     for (k, v) in ctxt.tycx.def_map.iter() {\n         debug2!(\"{:?}: {:?}\", k, v);\n@@ -77,5 +101,5 @@ pub fn run_core (libs: ~[Path], path: &Path) -> clean::Crate {\n     let v = @mut RustdocVisitor::new();\n     v.visit(&ctxt.crate);\n \n-    v.clean()\n+    (v.clean(), analysis)\n }"}, {"sha": "b12dd338fff1fc1c6b9c233b33a085067da50719", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -219,7 +219,7 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n     };\n     mkdir(&cx.dst);\n \n-    match crate.module.get_ref().doc_list() {\n+    match crate.module.as_ref().map(|m| m.doc_list().unwrap_or(&[])) {\n         Some(attrs) => {\n             for attr in attrs.iter() {\n                 match *attr {\n@@ -581,7 +581,7 @@ impl DocFolder for Cache {\n             clean::StructItem(*) | clean::EnumItem(*) |\n             clean::TypedefItem(*) | clean::TraitItem(*) |\n             clean::FunctionItem(*) | clean::ModuleItem(*) |\n-            clean::VariantItem(*) => {\n+            clean::ForeignFunctionItem(*) | clean::VariantItem(*) => {\n                 self.paths.insert(item.id, (self.stack.clone(), shortty(&item)));\n             }\n             _ => {}"}, {"sha": "aa419a90563b75e71aea168e469ce700fa2420e5", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 128, "deletions": 78, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -9,11 +9,14 @@\n // except according to those terms.\n \n use std::num;\n+use std::cell::Cell;\n use std::uint;\n use std::hashmap::HashSet;\n+use std::local_data;\n \n use syntax::ast;\n \n+use core;\n use clean;\n use clean::Item;\n use plugins;\n@@ -51,110 +54,157 @@ pub fn strip_hidden(crate: clean::Crate) -> plugins::PluginResult {\n \n /// Strip private items from the point of view of a crate or externally from a\n /// crate, specified by the `xcrate` flag.\n-pub fn strip_private(mut crate: clean::Crate) -> plugins::PluginResult {\n+pub fn strip_private(crate: clean::Crate) -> plugins::PluginResult {\n     // This stripper collects all *retained* nodes.\n-    struct Stripper<'self>(&'self mut HashSet<ast::NodeId>);\n-    impl<'self> fold::DocFolder for Stripper<'self> {\n-        fn fold_item(&mut self, i: Item) -> Option<Item> {\n-            match i.inner {\n-                // These items can all get re-exported\n-                clean::TypedefItem(*) | clean::StaticItem(*) |\n-                clean::StructItem(*) | clean::EnumItem(*) |\n-                clean::TraitItem(*) | clean::FunctionItem(*) |\n-                clean::ViewItemItem(*) | clean::MethodItem(*) |\n-                clean::ForeignFunctionItem(*) | clean::ForeignStaticItem(*) => {\n-                    // XXX: re-exported items should get surfaced in the docs as\n-                    //      well (using the output of resolve analysis)\n-                    if i.visibility != Some(ast::public) {\n-                        return None;\n-                    }\n-                }\n+    let mut retained = HashSet::new();\n+    let crate = Cell::new(crate);\n+    let exported_items = do local_data::get(super::analysiskey) |analysis| {\n+        let analysis = analysis.unwrap();\n+        let mut exported_items = analysis.exported_items.clone();\n+        {\n+            let mut finder = ExportedItemsFinder {\n+                exported_items: &mut exported_items,\n+                analysis: analysis,\n+            };\n+            let c = finder.fold_crate(crate.take());\n+            crate.put_back(c);\n+        }\n+        exported_items\n+    };\n+    let mut crate = crate.take();\n \n-                // These are public-by-default (if the enum/struct was public)\n-                clean::VariantItem(*) | clean::StructFieldItem(*) => {\n-                    if i.visibility == Some(ast::private) {\n-                        return None;\n+    // strip all private items\n+    {\n+        let mut stripper = Stripper {\n+            retained: &mut retained,\n+            exported_items: &exported_items,\n+        };\n+        crate = stripper.fold_crate(crate);\n+    }\n+\n+    // strip all private implementations of traits\n+    {\n+        let mut stripper = ImplStripper(&retained);\n+        crate = stripper.fold_crate(crate);\n+    }\n+    (crate, None)\n+}\n+\n+struct ExportedItemsFinder<'self> {\n+    exported_items: &'self mut HashSet<ast::NodeId>,\n+    analysis: &'self core::CrateAnalysis,\n+}\n+\n+impl<'self> fold::DocFolder for ExportedItemsFinder<'self> {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        match i.inner {\n+            clean::ModuleItem(*) => {\n+                if self.analysis.exported_items.contains(&i.id) {\n+                    match self.analysis.reexports.find(&i.id) {\n+                        Some(l) => {\n+                            for &id in l.iter() {\n+                                self.exported_items.insert(id);\n+                            }\n+                        }\n+                        None => {}\n                     }\n                 }\n+            }\n+            _ => {}\n+        }\n+        return self.fold_item_recur(i);\n+    }\n+}\n+\n+struct Stripper<'self> {\n+    retained: &'self mut HashSet<ast::NodeId>,\n+    exported_items: &'self HashSet<ast::NodeId>,\n+}\n \n-                // handled below\n-                clean::ModuleItem(*) => {}\n+impl<'self> fold::DocFolder for Stripper<'self> {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        match i.inner {\n+            // These items can all get re-exported\n+            clean::TypedefItem(*) | clean::StaticItem(*) |\n+            clean::StructItem(*) | clean::EnumItem(*) |\n+            clean::TraitItem(*) | clean::FunctionItem(*) |\n+            clean::VariantItem(*) | clean::MethodItem(*) |\n+            clean::ForeignFunctionItem(*) | clean::ForeignStaticItem(*) => {\n+                if !self.exported_items.contains(&i.id) {\n+                    return None;\n+                }\n+            }\n \n-                // impls/tymethods have no control over privacy\n-                clean::ImplItem(*) | clean::TyMethodItem(*) => {}\n+            clean::ViewItemItem(*) | clean::StructFieldItem(*) => {\n+                if i.visibility != Some(ast::public) {\n+                    return None;\n+                }\n             }\n \n-            let fastreturn = match i.inner {\n-                // nothing left to do for traits (don't want to filter their\n-                // methods out, visibility controlled by the trait)\n-                clean::TraitItem(*) => true,\n+            // handled below\n+            clean::ModuleItem(*) => {}\n \n-                // implementations of traits are always public.\n-                clean::ImplItem(ref imp) if imp.trait_.is_some() => true,\n+            // impls/tymethods have no control over privacy\n+            clean::ImplItem(*) | clean::TyMethodItem(*) => {}\n+        }\n \n-                _ => false,\n-            };\n+        let fastreturn = match i.inner {\n+            // nothing left to do for traits (don't want to filter their\n+            // methods out, visibility controlled by the trait)\n+            clean::TraitItem(*) => true,\n \n-            let i = if fastreturn {\n-                self.insert(i.id);\n-                return Some(i);\n-            } else {\n-                self.fold_item_recur(i)\n-            };\n+            // implementations of traits are always public.\n+            clean::ImplItem(ref imp) if imp.trait_.is_some() => true,\n \n-            match i {\n-                Some(i) => {\n-                    match i.inner {\n-                        // emptied modules/impls have no need to exist\n-                        clean::ModuleItem(ref m) if m.items.len() == 0 => None,\n-                        clean::ImplItem(ref i) if i.methods.len() == 0 => None,\n-                        _ => {\n-                            self.insert(i.id);\n-                            Some(i)\n-                        }\n+            _ => false,\n+        };\n+\n+        let i = if fastreturn {\n+            self.retained.insert(i.id);\n+            return Some(i);\n+        } else {\n+            self.fold_item_recur(i)\n+        };\n+\n+        match i {\n+            Some(i) => {\n+                match i.inner {\n+                    // emptied modules/impls have no need to exist\n+                    clean::ModuleItem(ref m) if m.items.len() == 0 => None,\n+                    clean::ImplItem(ref i) if i.methods.len() == 0 => None,\n+                    _ => {\n+                        self.retained.insert(i.id);\n+                        Some(i)\n                     }\n                 }\n-                None => None,\n             }\n+            None => None,\n         }\n     }\n+}\n \n-    // This stripper discards all private impls of traits\n-    struct ImplStripper<'self>(&'self HashSet<ast::NodeId>);\n-    impl<'self> fold::DocFolder for ImplStripper<'self> {\n-        fn fold_item(&mut self, i: Item) -> Option<Item> {\n-            match i.inner {\n-                clean::ImplItem(ref imp) => {\n-                    match imp.trait_ {\n-                        Some(clean::ResolvedPath{ id, _ }) => {\n-                            if !self.contains(&id) {\n-                                return None;\n-                            }\n+// This stripper discards all private impls of traits\n+struct ImplStripper<'self>(&'self HashSet<ast::NodeId>);\n+impl<'self> fold::DocFolder for ImplStripper<'self> {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        match i.inner {\n+            clean::ImplItem(ref imp) => {\n+                match imp.trait_ {\n+                    Some(clean::ResolvedPath{ id, _ }) => {\n+                        if !self.contains(&id) {\n+                            return None;\n                         }\n-                        Some(*) | None => {}\n                     }\n+                    Some(*) | None => {}\n                 }\n-                _ => {}\n             }\n-            self.fold_item_recur(i)\n+            _ => {}\n         }\n+        self.fold_item_recur(i)\n     }\n-\n-    let mut retained = HashSet::new();\n-    // First, strip all private items\n-    {\n-        let mut stripper = Stripper(&mut retained);\n-        crate = stripper.fold_crate(crate);\n-    }\n-\n-    // Next, strip all private implementations of traits\n-    {\n-        let mut stripper = ImplStripper(&retained);\n-        crate = stripper.fold_crate(crate);\n-    }\n-    (crate, None)\n }\n \n+\n pub fn unindent_comments(crate: clean::Crate) -> plugins::PluginResult {\n     struct CommentCleaner;\n     impl fold::DocFolder for CommentCleaner {"}, {"sha": "df732f1fc8694e2b7b9af5a1d7f3c0913a9da5ff", "filename": "src/librustdoc/rustdoc.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibrustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibrustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -24,6 +24,7 @@ extern mod rustc;\n extern mod extra;\n \n use std::cell::Cell;\n+use std::local_data;\n use std::rt::io::Writer;\n use std::rt::io::file::FileInfo;\n use std::rt::io;\n@@ -73,6 +74,7 @@ static DEFAULT_PASSES: &'static [&'static str] = &[\n ];\n \n local_data_key!(pub ctxtkey: @core::DocContext)\n+local_data_key!(pub analysiskey: core::CrateAnalysis)\n \n type Output = (clean::Crate, ~[plugins::PluginJson]);\n \n@@ -191,11 +193,12 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     let libs = Cell::new(matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice())));\n     let cr = Cell::new(Path::new(cratefile));\n     info2!(\"starting to run rustc\");\n-    let crate = do std::task::try {\n+    let (crate, analysis) = do std::task::try {\n         let cr = cr.take();\n         core::run_core(libs.take(), &cr)\n     }.unwrap();\n     info2!(\"finished with rustc\");\n+    local_data::set(analysiskey, analysis);\n \n     // Process all of the crate attributes, extracting plugin metadata along\n     // with the passes which we are supposed to run."}, {"sha": "f6669893170ae211f66217b632a460679f4bdcc8", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -135,6 +135,7 @@ impl<T> Clone for @[T] {\n }\n \n #[cfg(not(test))]\n+#[allow(missing_doc)]\n pub mod traits {\n     use at_vec::append;\n     use clone::Clone;\n@@ -152,6 +153,7 @@ pub mod traits {\n #[cfg(test)]\n pub mod traits {}\n \n+#[allow(missing_doc)]\n pub mod raw {\n     use at_vec::capacity;\n     use cast;"}, {"sha": "4032515f985e3b1a0a5d9d2f24d55057b6bfcadf", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -647,21 +647,6 @@ impl<'self> Formatter<'self> {\n     // the format! syntax extension.\n \n     fn run(&mut self, piece: &rt::Piece, cur: Option<&str>) {\n-        let setcount = |slot: &mut Option<uint>, cnt: &parse::Count| {\n-            match *cnt {\n-                parse::CountIs(n) => { *slot = Some(n); }\n-                parse::CountImplied => { *slot = None; }\n-                parse::CountIsParam(i) => {\n-                    let v = self.args[i].value;\n-                    unsafe { *slot = Some(*(v as *util::Void as *uint)); }\n-                }\n-                parse::CountIsNextParam => {\n-                    let v = self.curarg.next().unwrap().value;\n-                    unsafe { *slot = Some(*(v as *util::Void as *uint)); }\n-                }\n-            }\n-        };\n-\n         match *piece {\n             rt::String(s) => { self.buf.write(s.as_bytes()); }\n             rt::CurrentArgument(()) => { self.buf.write(cur.unwrap().as_bytes()); }\n@@ -670,8 +655,8 @@ impl<'self> Formatter<'self> {\n                 self.fill = arg.format.fill;\n                 self.align = arg.format.align;\n                 self.flags = arg.format.flags;\n-                setcount(&mut self.width, &arg.format.width);\n-                setcount(&mut self.precision, &arg.format.precision);\n+                self.width = self.getcount(&arg.format.width);\n+                self.precision = self.getcount(&arg.format.precision);\n \n                 // Extract the correct argument\n                 let value = match arg.position {\n@@ -688,6 +673,39 @@ impl<'self> Formatter<'self> {\n         }\n     }\n \n+    #[cfg(stage0)]\n+    fn getcount(&mut self, cnt: &parse::Count) -> Option<uint> {\n+        match *cnt {\n+            parse::CountIs(n) => { Some(n) }\n+            parse::CountImplied => { None }\n+            parse::CountIsParam(i) => {\n+                let v = self.args[i].value;\n+                unsafe { Some(*(v as *util::Void as *uint)) }\n+            }\n+            parse::CountIsNextParam => {\n+                let v = self.curarg.next().unwrap().value;\n+                unsafe { Some(*(v as *util::Void as *uint)) }\n+            }\n+            parse::CountIsName(*) => unreachable!()\n+        }\n+    }\n+\n+    #[cfg(not(stage0))]\n+    fn getcount(&mut self, cnt: &rt::Count) -> Option<uint> {\n+        match *cnt {\n+            rt::CountIs(n) => { Some(n) }\n+            rt::CountImplied => { None }\n+            rt::CountIsParam(i) => {\n+                let v = self.args[i].value;\n+                unsafe { Some(*(v as *util::Void as *uint)) }\n+            }\n+            rt::CountIsNextParam => {\n+                let v = self.curarg.next().unwrap().value;\n+                unsafe { Some(*(v as *util::Void as *uint)) }\n+            }\n+        }\n+    }\n+\n     fn execute(&mut self, method: &rt::Method, arg: Argument) {\n         match *method {\n             // Pluralization is selection upon a numeric value specified as the"}, {"sha": "11b869c930ef446504d0aa8122d85fafa6491be3", "filename": "src/libstd/fmt/parse.rs", "status": "modified", "additions": 91, "deletions": 2, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -8,6 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Parsing of format strings\n+//!\n+//! These structures are used when parsing format strings for the compiler.\n+//! Parsing does not currently happen at runtime (structures of std::fmt::rt are\n+//! generated instead).\n+\n use prelude::*;\n \n use char;\n@@ -42,6 +48,7 @@ pub struct Argument<'self> {\n \n /// Specification for the formatting of an argument in the format string.\n #[deriving(Eq)]\n+#[cfg(stage0)]\n pub struct FormatSpec<'self> {\n     /// Optionally specified character to fill alignment with\n     fill: Option<char>,\n@@ -59,6 +66,26 @@ pub struct FormatSpec<'self> {\n     ty: &'self str\n }\n \n+/// Specification for the formatting of an argument in the format string.\n+#[deriving(Eq)]\n+#[cfg(not(stage0))]\n+pub struct FormatSpec<'self> {\n+    /// Optionally specified character to fill alignment with\n+    fill: Option<char>,\n+    /// Optionally specified alignment\n+    align: Alignment,\n+    /// Packed version of various flags provided\n+    flags: uint,\n+    /// The integer precision to use\n+    precision: Count<'self>,\n+    /// The string width requested for the resulting format\n+    width: Count<'self>,\n+    /// The descriptor string representing the name of the format desired for\n+    /// this argument, this can be empty or any number of characters, although\n+    /// it is required to be one word.\n+    ty: &'self str\n+}\n+\n /// Enum describing where an argument for a format can be located.\n #[deriving(Eq)]\n #[allow(missing_doc)]\n@@ -86,9 +113,22 @@ pub enum Flag {\n /// can reference either an argument or a literal integer.\n #[deriving(Eq)]\n #[allow(missing_doc)]\n+#[cfg(stage0)]\n pub enum Count {\n     CountIs(uint),\n     CountIsParam(uint),\n+    CountIsName(&'static str), // not actually used, see stage1\n+    CountIsNextParam,\n+    CountImplied,\n+}\n+\n+#[deriving(Eq)]\n+#[allow(missing_doc)]\n+#[cfg(not(stage0))]\n+pub enum Count<'self> {\n+    CountIs(uint),\n+    CountIsName(&'self str),\n+    CountIsParam(uint),\n     CountIsNextParam,\n     CountImplied,\n }\n@@ -338,10 +378,22 @@ impl<'self> Parser<'self> {\n             spec.flags |= 1 << (FlagAlternate as uint);\n         }\n         // Width and precision\n+        let mut havewidth = false;\n         if self.consume('0') {\n-            spec.flags |= 1 << (FlagSignAwareZeroPad as uint);\n+            // small ambiguity with '0$' as a format string. In theory this is a\n+            // '0' flag and then an ill-formatted format string with just a '$'\n+            // and no count, but this is better if we instead interpret this as\n+            // no '0' flag and '0$' as the width instead.\n+            if self.consume('$') {\n+                spec.width = CountIsParam(0);\n+                havewidth = true;\n+            } else {\n+                spec.flags |= 1 << (FlagSignAwareZeroPad as uint);\n+            }\n+        }\n+        if !havewidth {\n+            spec.width = self.count();\n         }\n-        spec.width = self.count();\n         if self.consume('.') {\n             if self.consume('*') {\n                 spec.precision = CountIsNextParam;\n@@ -542,6 +594,7 @@ impl<'self> Parser<'self> {\n     /// Parses a Count parameter at the current position. This does not check\n     /// for 'CountIsNextParam' because that is only used in precision, not\n     /// width.\n+    #[cfg(stage0)]\n     fn count(&mut self) -> Count {\n         match self.integer() {\n             Some(i) => {\n@@ -554,6 +607,30 @@ impl<'self> Parser<'self> {\n             None => { CountImplied }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn count(&mut self) -> Count<'self> {\n+        match self.integer() {\n+            Some(i) => {\n+                if self.consume('$') {\n+                    CountIsParam(i)\n+                } else {\n+                    CountIs(i)\n+                }\n+            }\n+            None => {\n+                let tmp = self.cur.clone();\n+                match self.word() {\n+                    word if word.len() > 0 && self.consume('$') => {\n+                        CountIsName(word)\n+                    }\n+                    _ => {\n+                        self.cur = tmp;\n+                        CountImplied\n+                    }\n+                }\n+            }\n+        }\n+    }\n \n     /// Parses a word starting at the current position. A word is considered to\n     /// be an alphabetic character followed by any number of alphanumeric\n@@ -777,6 +854,18 @@ mod tests {\n             },\n             method: None,\n         })]);\n+        same(\"{:a$.b$s}\", ~[Argument(Argument {\n+            position: ArgumentNext,\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: 0,\n+                precision: CountIsName(\"b\"),\n+                width: CountIsName(\"a\"),\n+                ty: \"s\",\n+            },\n+            method: None,\n+        })]);\n     }\n     #[test]\n     fn format_flags() {"}, {"sha": "063d712dfa9fe3492753e9091a5853b323bfb4b7", "filename": "src/libstd/fmt/rt.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibstd%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibstd%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Frt.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -34,6 +34,7 @@ pub struct Argument<'self> {\n     method: Option<&'self Method<'self>>\n }\n \n+#[cfg(stage0)]\n pub struct FormatSpec {\n     fill: char,\n     align: parse::Alignment,\n@@ -42,6 +43,20 @@ pub struct FormatSpec {\n     width: parse::Count,\n }\n \n+#[cfg(not(stage0))]\n+pub struct FormatSpec {\n+    fill: char,\n+    align: parse::Alignment,\n+    flags: uint,\n+    precision: Count,\n+    width: Count,\n+}\n+\n+#[cfg(not(stage0))]\n+pub enum Count {\n+    CountIs(uint), CountIsParam(uint), CountIsNextParam, CountImplied,\n+}\n+\n pub enum Position {\n     ArgumentNext, ArgumentIs(uint)\n }"}, {"sha": "8ce23f4b53b276fbd9b60227771f87d9122bcd3d", "filename": "src/libstd/select.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(missing_doc)];\n+\n use cell::Cell;\n use comm;\n use container::Container;"}, {"sha": "decfbb0785c385b8c69630c51a2c275080529cf4", "filename": "src/libstd/str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -1253,6 +1253,7 @@ Section: Trait implementations\n */\n \n #[cfg(not(test))]\n+#[allow(missing_doc)]\n pub mod traits {\n     use ops::Add;\n     use cmp::{TotalOrd, Ordering, Less, Equal, Greater, Eq, Ord, Equiv, TotalEq};"}, {"sha": "3962df8e3bd8d84df1931eefa80ae6b69ae8a298", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -603,6 +603,7 @@ impl<'self, T> RandomAccessIterator<&'self [T]> for ChunkIter<'self, T> {\n // Equality\n \n #[cfg(not(test))]\n+#[allow(missing_doc)]\n pub mod traits {\n     use super::*;\n "}, {"sha": "1114e3a9893f58e90c63a0b89ee9681ff14f526c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -991,6 +991,7 @@ pub fn std_macros() -> @str {\n             pub mod $c {\n                 #[allow(unused_imports)];\n                 #[allow(non_uppercase_statics)];\n+                #[allow(missing_doc)];\n \n                 use super::*;\n "}, {"sha": "31befed6c0cd4f1e195a35d80cdca81290448812", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -177,6 +177,9 @@ impl Context {\n             parse::CountIsParam(i) => {\n                 self.verify_arg_type(Left(i), Unsigned);\n             }\n+            parse::CountIsName(s) => {\n+                self.verify_arg_type(Right(s.to_managed()), Unsigned);\n+            }\n             parse::CountIsNextParam => {\n                 if self.check_positional_ok() {\n                     self.verify_arg_type(Left(self.next_arg), Unsigned);\n@@ -361,21 +364,31 @@ impl Context {\n         let trans_count = |c: parse::Count| {\n             match c {\n                 parse::CountIs(i) => {\n-                    self.ecx.expr_call_global(sp, ctpath(\"CountIs\"),\n+                    self.ecx.expr_call_global(sp, rtpath(\"CountIs\"),\n                                               ~[self.ecx.expr_uint(sp, i)])\n                 }\n                 parse::CountIsParam(i) => {\n-                    self.ecx.expr_call_global(sp, ctpath(\"CountIsParam\"),\n+                    self.ecx.expr_call_global(sp, rtpath(\"CountIsParam\"),\n                                               ~[self.ecx.expr_uint(sp, i)])\n                 }\n                 parse::CountImplied => {\n-                    let path = self.ecx.path_global(sp, ctpath(\"CountImplied\"));\n+                    let path = self.ecx.path_global(sp, rtpath(\"CountImplied\"));\n                     self.ecx.expr_path(path)\n                 }\n                 parse::CountIsNextParam => {\n-                    let path = self.ecx.path_global(sp, ctpath(\"CountIsNextParam\"));\n+                    let path = self.ecx.path_global(sp, rtpath(\"CountIsNextParam\"));\n                     self.ecx.expr_path(path)\n                 }\n+                parse::CountIsName(n) => {\n+                    let n = n.to_managed();\n+                    let i = match self.name_positions.find_copy(&n) {\n+                        Some(i) => i,\n+                        None => 0, // error already emitted elsewhere\n+                    };\n+                    let i = i + self.args.len();\n+                    self.ecx.expr_call_global(sp, rtpath(\"CountIsParam\"),\n+                                              ~[self.ecx.expr_uint(sp, i)])\n+                }\n             }\n         };\n         let trans_method = |method: &parse::Method| {"}, {"sha": "22710ad90e873ad87341b15ef52e5f60552c29a6", "filename": "src/test/compile-fail/lint-missing-doc.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -29,6 +29,9 @@ pub struct PubFoo2 {\n     c: int,\n }\n \n+mod module_no_dox {}\n+pub mod pub_module_no_dox {} //~ ERROR: missing documentation\n+\n /// dox\n pub fn foo() {}\n pub fn foo2() {} //~ ERROR: missing documentation"}, {"sha": "75d11eddb1bc68a0fc80016c5fed0ed7c4231031", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -119,7 +119,10 @@ pub fn main() {\n     t!(format!(\"{:0>2s}\", \"a\"), \"0a\");\n     t!(format!(\"{:.*s}\", 4, \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n     t!(format!(\"{:.1$s}\", \"aaaaaaaaaaaaaaaaaa\", 4), \"aaaa\");\n+    t!(format!(\"{:.a$s}\", \"aaaaaaaaaaaaaaaaaa\", a=4), \"aaaa\");\n     t!(format!(\"{:1$s}\", \"a\", 4), \"a   \");\n+    t!(format!(\"{1:0$s}\", 4, \"a\"), \"a   \");\n+    t!(format!(\"{:a$s}\", \"a\", a=4), \"a   \");\n     t!(format!(\"{:-#s}\", \"a\"), \"a\");\n     t!(format!(\"{:+#s}\", \"a\"), \"a\");\n "}]}