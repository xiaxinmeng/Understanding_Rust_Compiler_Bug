{"sha": "e5ea13da6e2d9365fea063e6df5507c527390029", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1ZWExM2RhNmUyZDkzNjVmZWEwNjNlNmRmNTUwN2M1MjczOTAwMjk=", "commit": {"author": {"name": "Ga\u00ebtan Cassiers", "email": "gaetan.cassiers@gmail.com", "date": "2015-08-27T12:07:15Z"}, "committer": {"name": "Ga\u00ebtan Cassiers", "email": "gaetan.cassiers@gmail.com", "date": "2015-08-28T12:32:02Z"}, "message": "Add a generic tool for searching comments in code\n\nThis make a base for all functions searching for comments, or searching\ncode excluding comments, etc. These functions where too simple and\ndidn't handle complicated cases like nested comments or comment marks\ninside string litterals (\"/*\").", "tree": {"sha": "ed6db99dd70c4f56aa63e970e3fad3f9f419e2e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed6db99dd70c4f56aa63e970e3fad3f9f419e2e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5ea13da6e2d9365fea063e6df5507c527390029", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5ea13da6e2d9365fea063e6df5507c527390029", "html_url": "https://github.com/rust-lang/rust/commit/e5ea13da6e2d9365fea063e6df5507c527390029", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5ea13da6e2d9365fea063e6df5507c527390029/comments", "author": {"login": "cassiersg", "id": 9348542, "node_id": "MDQ6VXNlcjkzNDg1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/9348542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cassiersg", "html_url": "https://github.com/cassiersg", "followers_url": "https://api.github.com/users/cassiersg/followers", "following_url": "https://api.github.com/users/cassiersg/following{/other_user}", "gists_url": "https://api.github.com/users/cassiersg/gists{/gist_id}", "starred_url": "https://api.github.com/users/cassiersg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cassiersg/subscriptions", "organizations_url": "https://api.github.com/users/cassiersg/orgs", "repos_url": "https://api.github.com/users/cassiersg/repos", "events_url": "https://api.github.com/users/cassiersg/events{/privacy}", "received_events_url": "https://api.github.com/users/cassiersg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cassiersg", "id": 9348542, "node_id": "MDQ6VXNlcjkzNDg1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/9348542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cassiersg", "html_url": "https://github.com/cassiersg", "followers_url": "https://api.github.com/users/cassiersg/followers", "following_url": "https://api.github.com/users/cassiersg/following{/other_user}", "gists_url": "https://api.github.com/users/cassiersg/gists{/gist_id}", "starred_url": "https://api.github.com/users/cassiersg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cassiersg/subscriptions", "organizations_url": "https://api.github.com/users/cassiersg/orgs", "repos_url": "https://api.github.com/users/cassiersg/repos", "events_url": "https://api.github.com/users/cassiersg/events{/privacy}", "received_events_url": "https://api.github.com/users/cassiersg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25650c2a8bc2873cd0eb13a4511aeee7e2f94f25", "url": "https://api.github.com/repos/rust-lang/rust/commits/25650c2a8bc2873cd0eb13a4511aeee7e2f94f25", "html_url": "https://github.com/rust-lang/rust/commit/25650c2a8bc2873cd0eb13a4511aeee7e2f94f25"}], "stats": {"total": 228, "additions": 187, "deletions": 41}, "files": [{"sha": "9c97325ec9671a6ee88f36b0c05c1c88c0efe1af", "filename": "src/comment.rs", "status": "modified", "additions": 185, "deletions": 38, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/e5ea13da6e2d9365fea063e6df5507c527390029/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5ea13da6e2d9365fea063e6df5507c527390029/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=e5ea13da6e2d9365fea063e6df5507c527390029", "patch": "@@ -10,6 +10,8 @@\n \n // Format comments.\n \n+use std::iter;\n+\n use string::{StringFormat, rewrite_string};\n use utils::make_indent;\n \n@@ -118,27 +120,18 @@ pub trait FindUncommented {\n impl FindUncommented for str {\n     fn find_uncommented(&self, pat: &str) -> Option<usize> {\n         let mut needle_iter = pat.chars();\n-        let mut possible_comment = false;\n-\n-        for (i, b) in self.char_indices() {\n+        for (kind, (i, b)) in CharClasses::new(self.char_indices()) {\n             match needle_iter.next() {\n-                Some(c) => {\n-                    if b != c {\n+                None => {\n+                    return Some(i - pat.len());\n+                }\n+                Some(c) => match kind {\n+                    CodeCharKind::Normal if b == c => {}\n+                    _ => {\n                         needle_iter = pat.chars();\n                     }\n-                }\n-                None => return Some(i - pat.len()),\n+                },\n             }\n-\n-            if possible_comment && (b == '/' || b == '*') {\n-                return find_comment_end(&self[(i-1)..])\n-                    .and_then(|end| {\n-                        self[(end + i - 1)..].find_uncommented(pat)\n-                                             .map(|idx| idx + end + i - 1)\n-                    });\n-            }\n-\n-            possible_comment = b == '/';\n         }\n \n         // Handle case where the pattern is a suffix of the search string\n@@ -167,36 +160,29 @@ fn test_find_uncommented() {\n     check(\"hel/*lohello*/lo\", \"hello\", None);\n     check(\"acb\", \"ab\", None);\n     check(\",/*A*/ \", \",\", Some(0));\n+    check(\"abc\", \"abc\", Some(0));\n+    check(\"/* abc */\", \"abc\", None);\n+    check(\"/**/abc/* */\", \"abc\", Some(4));\n+    check(\"\\\"/* abc */\\\"\", \"abc\", Some(4));\n+    check(\"\\\"/* abc\", \"abc\", Some(4));\n }\n \n // Returns the first byte position after the first comment. The given string\n // is expected to be prefixed by a comment, including delimiters.\n // Good: \"/* /* inner */ outer */ code();\"\n // Bad:  \"code(); // hello\\n world!\"\n pub fn find_comment_end(s: &str) -> Option<usize> {\n-    if s.starts_with(\"//\") {\n-        s.find('\\n').map(|idx| idx + 1)\n-    } else {\n-        // Block comment\n-        let mut levels = 0;\n-        let mut prev_char = 'a';\n-\n-        for (i, mut c) in s.char_indices() {\n-            if c == '*' && prev_char == '/' {\n-                levels += 1;\n-                c = 'a'; // Invalidate prev_char\n-            } else if c == '/' && prev_char == '*' {\n-                levels -= 1;\n-\n-                if levels == 0 {\n-                    return Some(i + 1);\n-                }\n-                c = 'a';\n-            }\n-\n-            prev_char = c;\n+    let mut iter = CharClasses::new(s.char_indices());\n+    for (kind, (i, _c)) in &mut iter {\n+        if kind == CodeCharKind::Normal {\n+            return Some(i);\n         }\n+    }\n \n+    // Handle case where the comment ends at the end of s.\n+    if iter.status == CharClassesStatus::Normal {\n+        Some(s.len())\n+    } else {\n         None\n     }\n }\n@@ -211,3 +197,164 @@ fn comment_end() {\n     assert_eq!(None, find_comment_end(\"// hi /* test */\"));\n     assert_eq!(Some(9), find_comment_end(\"// hi /*\\n.\"));\n }\n+\n+\n+/// Returns true if text contains any comment.\n+pub fn contains_comment(text: &str) -> bool {\n+    CharClasses::new(text.chars()).any(|(kind, _)| kind == CodeCharKind::Comment )\n+}\n+\n+pub fn uncommented(text: &str) -> String {\n+    CharClasses::new(text.chars()).filter_map(|(s, c)| match s {\n+        CodeCharKind::Normal => Some(c),\n+        CodeCharKind::Comment => None\n+    }).collect()\n+}\n+\n+#[test]\n+fn test_uncommented() {\n+    assert_eq!(&uncommented(\"abc/*...*/\"), \"abc\");\n+    assert_eq!(&uncommented(\"// .... /* \\n../* /* *** / */ */a/* // */c\\n\"), \"..ac\\n\");\n+    assert_eq!(&uncommented(\"abc \\\" /* */\\\" qsdf\"), \"abc \\\" /* */\\\" qsdf\");\n+}\n+\n+#[test]\n+fn test_contains_comment() {\n+    assert_eq!(contains_comment(\"abc\"), false);\n+    assert_eq!(contains_comment(\"abc // qsdf\"), true);\n+    assert_eq!(contains_comment(\"abc /* kqsdf\"), true);\n+    assert_eq!(contains_comment(\"abc \\\" /* */\\\" qsdf\"), false);\n+}\n+\n+struct CharClasses<T>\n+    where T: Iterator,\n+          T::Item: RichChar\n+{\n+    base: iter::Peekable<T>,\n+    status: CharClassesStatus,\n+}\n+\n+trait RichChar {\n+    fn get_char(&self) -> char;\n+}\n+\n+impl RichChar for char {\n+    fn get_char(&self) -> char {\n+        *self\n+    }\n+}\n+\n+impl RichChar for (usize, char) {\n+    fn get_char(&self) -> char {\n+        self.1\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Debug, Clone, Copy)]\n+enum CharClassesStatus {\n+    Normal,\n+    LitString,\n+    LitStringEscape,\n+    LitChar,\n+    LitCharEscape,\n+    // The u32 is the nesting deepness of the comment\n+    BlockComment(u32),\n+    // Status when the '/' has been consumed, but not yet the '*', deepness is the new deepness\n+    // (after the comment opening).\n+    BlockCommentOpening(u32),\n+    // Status when the '*' has been consumed, but not yet the '/', deepness is the new deepness\n+    // (after the comment closing).\n+    BlockCommentClosing(u32),\n+    LineComment,\n+}\n+\n+#[derive(PartialEq, Eq, Debug, Clone, Copy)]\n+enum CodeCharKind {\n+    Normal,\n+    Comment,\n+}\n+\n+impl<T> CharClasses<T> where T: Iterator, T::Item: RichChar {\n+    fn new(base: T) -> CharClasses<T> {\n+        CharClasses { base: base.peekable(), status: CharClassesStatus::Normal }\n+    }\n+}\n+\n+impl<T> Iterator for CharClasses<T> where T: Iterator, T::Item: RichChar {\n+    type Item = (CodeCharKind, T::Item);\n+\n+    fn next(&mut self) -> Option<(CodeCharKind, T::Item)> {\n+        let item = try_opt!(self.base.next());\n+        let chr = item.get_char();\n+        self.status = match self.status {\n+            CharClassesStatus::LitString => match chr {\n+                '\"' => CharClassesStatus::Normal,\n+                '\\\\' => CharClassesStatus::LitStringEscape,\n+                _ => CharClassesStatus::LitString,\n+            },\n+            CharClassesStatus::LitStringEscape => CharClassesStatus::LitString,\n+            CharClassesStatus::LitChar => match chr {\n+                '\\\\' => CharClassesStatus::LitCharEscape,\n+                '\\'' => CharClassesStatus::Normal,\n+                _ => CharClassesStatus::LitChar,\n+            },\n+            CharClassesStatus::LitCharEscape => CharClassesStatus::LitChar,\n+            CharClassesStatus::Normal => {\n+                match chr {\n+                    '\"' => CharClassesStatus::LitString,\n+                    '\\'' => CharClassesStatus::LitChar,\n+                    '/' => match self.base.peek() {\n+                        Some(next) if next.get_char() == '*' => {\n+                            self.status = CharClassesStatus::BlockCommentOpening(1);\n+                            return Some((CodeCharKind::Comment, item));\n+                        }\n+                        Some(next) if next.get_char() == '/' => {\n+                            self.status = CharClassesStatus::LineComment;\n+                            return Some((CodeCharKind::Comment, item));\n+                        }\n+                        _ => CharClassesStatus::Normal,\n+                    },\n+                    _ => CharClassesStatus::Normal,\n+                }\n+            }\n+            CharClassesStatus::BlockComment(deepness) => {\n+                if deepness == 0 {\n+                    // This is the closing '/'\n+                    assert_eq!(chr, '/');\n+                    self.status = CharClassesStatus::Normal;\n+                    return Some((CodeCharKind::Comment, item));\n+                }\n+                self.status = match self.base.peek() {\n+                    Some(next) if next.get_char() == '/' && chr == '*' =>\n+                        CharClassesStatus::BlockCommentClosing(deepness - 1),\n+                    Some(next) if next.get_char() == '*' && chr == '/' =>\n+                        CharClassesStatus::BlockCommentOpening(deepness + 1),\n+                    _ => CharClassesStatus::BlockComment(deepness),\n+                };\n+                return Some((CodeCharKind::Comment, item));\n+            }\n+            CharClassesStatus::BlockCommentOpening(deepness) => {\n+                assert_eq!(chr, '*');\n+                self.status = CharClassesStatus::BlockComment(deepness);\n+                return Some((CodeCharKind::Comment, item));\n+            }\n+            CharClassesStatus::BlockCommentClosing(deepness) => {\n+                assert_eq!(chr, '/');\n+                self.status = if deepness == 0 {\n+                    CharClassesStatus::Normal\n+                } else {\n+                    CharClassesStatus::BlockComment(deepness)\n+                };\n+                return Some((CodeCharKind::Comment, item));\n+            }\n+            CharClassesStatus::LineComment => {\n+                self.status = match chr {\n+                    '\\n' => CharClassesStatus::Normal,\n+                    _ => CharClassesStatus::LineComment,\n+                };\n+                return Some((CodeCharKind::Comment, item));\n+            }\n+        };\n+        return Some((CodeCharKind::Normal, item));\n+    }\n+}"}, {"sha": "cbcecc4cdcf9f4de591afe627661f50815111276", "filename": "src/expr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e5ea13da6e2d9365fea063e6df5507c527390029/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5ea13da6e2d9365fea063e6df5507c527390029/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=e5ea13da6e2d9365fea063e6df5507c527390029", "patch": "@@ -15,7 +15,7 @@ use StructLitStyle;\n use utils::{span_after, make_indent, extra_offset, first_line_width, last_line_width};\n use visitor::FmtVisitor;\n use config::BlockIndentStyle;\n-use comment::{FindUncommented, rewrite_comment};\n+use comment::{FindUncommented, rewrite_comment, contains_comment};\n use types::rewrite_path;\n use items::{span_lo_for_arg, span_hi_for_arg, rewrite_fn_input};\n \n@@ -518,8 +518,7 @@ fn is_simple_block(block: &ast::Block, codemap: &CodeMap) -> bool {\n \n     let snippet = codemap.span_to_snippet(block.span).unwrap();\n \n-    // FIXME: fails when either // or /* is contained in a string literal.\n-    !snippet.contains(\"//\") && !snippet.contains(\"/*\")\n+    !contains_comment(&snippet)\n }\n \n fn rewrite_match(context: &RewriteContext,"}]}