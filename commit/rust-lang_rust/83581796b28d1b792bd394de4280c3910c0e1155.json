{"sha": "83581796b28d1b792bd394de4280c3910c0e1155", "node_id": "C_kwDOAAsO6NoAKDgzNTgxNzk2YjI4ZDFiNzkyYmQzOTRkZTQyODBjMzkxMGMwZTExNTU", "commit": {"author": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2022-03-27T05:04:08Z"}, "committer": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2022-04-12T09:27:25Z"}, "message": "Ban subnormals and NaNs in const {from,to}_bits", "tree": {"sha": "e438d64ee753efefb4b19eb6a5c6c4e7164410fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e438d64ee753efefb4b19eb6a5c6c4e7164410fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83581796b28d1b792bd394de4280c3910c0e1155", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83581796b28d1b792bd394de4280c3910c0e1155", "html_url": "https://github.com/rust-lang/rust/commit/83581796b28d1b792bd394de4280c3910c0e1155", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83581796b28d1b792bd394de4280c3910c0e1155/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b200483412b1195d0ca9deffe011c659606e5b3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b200483412b1195d0ca9deffe011c659606e5b3b", "html_url": "https://github.com/rust-lang/rust/commit/b200483412b1195d0ca9deffe011c659606e5b3b"}], "stats": {"total": 430, "additions": 392, "deletions": 38}, "files": [{"sha": "d3d8bd1bf48bb224fa5784b56390a5966596d4ef", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 112, "deletions": 4, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/83581796b28d1b792bd394de4280c3910c0e1155/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83581796b28d1b792bd394de4280c3910c0e1155/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=83581796b28d1b792bd394de4280c3910c0e1155", "patch": "@@ -623,6 +623,23 @@ impl f32 {\n         }\n     }\n \n+    // This operates on bits, and only bits, so it can ignore concerns about weird FPUs.\n+    // FIXME(jubilee): In a just world, this would be the entire impl for classify,\n+    // plus a transmute. We do not live in a just world, but we can make it more so.\n+    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n+    const fn classify_bits(b: u32) -> FpCategory {\n+        const EXP_MASK: u32 = 0x7f800000;\n+        const MAN_MASK: u32 = 0x007fffff;\n+\n+        match (b & MAN_MASK, b & EXP_MASK) {\n+            (0, EXP_MASK) => FpCategory::Infinite,\n+            (_, EXP_MASK) => FpCategory::Nan,\n+            (0, 0) => FpCategory::Zero,\n+            (_, 0) => FpCategory::Subnormal,\n+            _ => FpCategory::Normal,\n+        }\n+    }\n+\n     /// Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s with\n     /// positive sign bit and positive infinity.\n     ///\n@@ -874,8 +891,59 @@ impl f32 {\n     #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n     #[inline]\n     pub const fn to_bits(self) -> u32 {\n-        // SAFETY: `u32` is a plain old datatype so we can always transmute to it\n-        unsafe { mem::transmute(self) }\n+        // SAFETY: `u32` is a plain old datatype so we can always transmute to it.\n+        // ...sorta.\n+        //\n+        // It turns out that at runtime, it is possible for a floating point number\n+        // to be subject to a floating point mode that alters nonzero subnormal numbers\n+        // to zero on reads and writes, aka \"denormals are zero\" and \"flush to zero\".\n+        // This is not a problem per se, but at least one tier2 platform for Rust\n+        // actually exhibits this behavior by default.\n+        //\n+        // In addition, on x86 targets with SSE or SSE2 disabled and the x87 FPU enabled,\n+        // i.e. not soft-float, the way Rust does parameter passing can actually alter\n+        // a number that is \"not infinity\" to have the same exponent as infinity,\n+        // in a slightly unpredictable manner.\n+        //\n+        // And, of course evaluating to a NaN value is fairly nondeterministic.\n+        // More precisely: when NaN should be returned is knowable, but which NaN?\n+        // So far that's defined by a combination of LLVM and the CPU, not Rust.\n+        // This function, however, allows observing the bitstring of a NaN,\n+        // thus introspection on CTFE.\n+        //\n+        // In order to preserve, at least for the moment, const-to-runtime equivalence,\n+        // we reject any of these possible situations from happening.\n+        #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n+        const fn ct_f32_to_u32(ct: f32) -> u32 {\n+            match ct.classify() {\n+                FpCategory::Nan => {\n+                    panic!(\"const-eval error: cannot use f32::to_bits on a NaN\")\n+                }\n+                FpCategory::Subnormal => {\n+                    panic!(\"const-eval error: cannot use f32::to_bits on a subnormal number\")\n+                }\n+                FpCategory::Infinite =>\n+                // SAFETY: Infinity per se is fine\n+                unsafe { mem::transmute::<f32, u32>(ct) },\n+                FpCategory::Zero | FpCategory::Normal => {\n+                    // SAFETY: We have a normal floating point number. Now we transmute, i.e. do a bitcopy.\n+                    let bits: u32 = unsafe { mem::transmute::<f32, u32>(ct) };\n+                    // Let's doublecheck to make sure it wasn't a weird float by truncating it.\n+                    if bits >> 23 & 0xFF == 0xFF {\n+                        panic!(\n+                            \"const-eval error: an unusually large x87 floating point value should not leak into const eval\"\n+                        )\n+                    };\n+                    bits\n+                }\n+            }\n+        }\n+        // SAFETY: `u32` is a plain old datatype so we can always... uh...\n+        // ...look, just pretend you forgot what you just read.\n+        // Stability concerns.\n+        let rt_f32_to_u32 = |rt| unsafe { mem::transmute::<f32, u32>(rt) };\n+        // SAFETY: We use internal implementations that either always work or fail at compile time.\n+        unsafe { intrinsics::const_eval_select((self,), ct_f32_to_u32, rt_f32_to_u32) }\n     }\n \n     /// Raw transmutation from `u32`.\n@@ -919,9 +987,49 @@ impl f32 {\n     #[must_use]\n     #[inline]\n     pub const fn from_bits(v: u32) -> Self {\n-        // SAFETY: `u32` is a plain old datatype so we can always transmute from it\n         // It turns out the safety issues with sNaN were overblown! Hooray!\n-        unsafe { mem::transmute::<u32, f32>(v) }\n+        // SAFETY: `u32` is a plain old datatype so we can always transmute from it\n+        // ...sorta.\n+        //\n+        // It turns out that at runtime, it is possible for a floating point number\n+        // to be subject to a floating point mode that alters nonzero subnormal numbers\n+        // to zero on reads and writes, aka \"denormals are zero\" and \"flush to zero\".\n+        // This is not a problem usually, but at least one tier2 platform for Rust\n+        // actually exhibits this behavior by default: thumbv7neon\n+        // aka \"the Neon FPU in AArch32 state\"\n+        //\n+        // In addition, on x86 targets with SSE or SSE2 disabled and the x87 FPU enabled,\n+        // i.e. not soft-float, the way Rust does parameter passing can actually alter\n+        // a number that is \"not infinity\" to have the same exponent as infinity,\n+        // in a slightly unpredictable manner.\n+        //\n+        // And, of course evaluating to a NaN value is fairly nondeterministic.\n+        // More precisely: when NaN should be returned is knowable, but which NaN?\n+        // So far that's defined by a combination of LLVM and the CPU, not Rust.\n+        // This function, however, allows observing the bitstring of a NaN,\n+        // thus introspection on CTFE.\n+        //\n+        // In order to preserve, at least for the moment, const-to-runtime equivalence,\n+        // reject any of these possible situations from happening.\n+        #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n+        const fn ct_u32_to_f32(ct: u32) -> f32 {\n+            match f32::classify_bits(ct) {\n+                FpCategory::Subnormal => {\n+                    panic!(\"const-eval error: cannot use f32::from_bits on a subnormal number\");\n+                }\n+                FpCategory::Nan => {\n+                    panic!(\"const-eval error: cannot use f32::from_bits on NaN\");\n+                }\n+                // SAFETY: It's not a frumious number\n+                _ => unsafe { mem::transmute::<u32, f32>(ct) },\n+            }\n+        }\n+        // SAFETY: `u32` is a plain old datatype so we can always... uh...\n+        // ...look, just pretend you forgot what you just read.\n+        // Stability concerns.\n+        let rt_u32_to_f32 = |rt| unsafe { mem::transmute::<u32, f32>(rt) };\n+        // SAFETY: We use internal implementations that either always work or fail at compile time.\n+        unsafe { intrinsics::const_eval_select((v,), ct_u32_to_f32, rt_u32_to_f32) }\n     }\n \n     /// Return the memory representation of this floating point number as a byte array in"}, {"sha": "264971d586bfd046f66657886f09c0adf152fe35", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 99, "deletions": 4, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/83581796b28d1b792bd394de4280c3910c0e1155/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83581796b28d1b792bd394de4280c3910c0e1155/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=83581796b28d1b792bd394de4280c3910c0e1155", "patch": "@@ -621,6 +621,23 @@ impl f64 {\n         }\n     }\n \n+    // This operates on bits, and only bits, so it can ignore concerns about weird FPUs.\n+    // FIXME(jubilee): In a just world, this would be the entire impl for classify,\n+    // plus a transmute. We do not live in a just world, but we can make it more so.\n+    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n+    const fn classify_bits(b: u64) -> FpCategory {\n+        const EXP_MASK: u64 = 0x7ff0000000000000;\n+        const MAN_MASK: u64 = 0x000fffffffffffff;\n+\n+        match (b & MAN_MASK, b & EXP_MASK) {\n+            (0, EXP_MASK) => FpCategory::Infinite,\n+            (_, EXP_MASK) => FpCategory::Nan,\n+            (0, 0) => FpCategory::Zero,\n+            (_, 0) => FpCategory::Subnormal,\n+            _ => FpCategory::Normal,\n+        }\n+    }\n+\n     /// Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s with\n     /// positive sign bit and positive infinity.\n     ///\n@@ -891,8 +908,41 @@ impl f64 {\n     #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n     #[inline]\n     pub const fn to_bits(self) -> u64 {\n-        // SAFETY: `u64` is a plain old datatype so we can always transmute to it\n-        unsafe { mem::transmute(self) }\n+        // SAFETY: `u64` is a plain old datatype so we can always transmute to it.\n+        // ...sorta.\n+        //\n+        // See the SAFETY comment in f64::from_bits for more.\n+        #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n+        const fn ct_f64_to_u64(ct: f64) -> u64 {\n+            match ct.classify() {\n+                FpCategory::Nan => {\n+                    panic!(\"const-eval error: cannot use f64::to_bits on a NaN\")\n+                }\n+                FpCategory::Subnormal => {\n+                    panic!(\"const-eval error: cannot use f64::to_bits on a subnormal number\")\n+                }\n+                FpCategory::Infinite =>\n+                // SAFETY: Infinity per se is fine\n+                unsafe { mem::transmute::<f64, u64>(ct) },\n+                FpCategory::Zero | FpCategory::Normal => {\n+                    // SAFETY: We have a normal floating point number. Now we transmute, i.e. do a bitcopy.\n+                    let bits: u64 = unsafe { mem::transmute::<f64, u64>(ct) };\n+                    // Let's doublecheck to make sure it wasn't a weird float by truncating it.\n+                    if (bits >> 52) & 0x7FF == 0x7FF {\n+                        panic!(\n+                            \"const-eval error: an unusually large x87 floating point value should not leak into const eval\"\n+                        )\n+                    };\n+                    bits\n+                }\n+            }\n+        }\n+        // SAFETY: `u64` is a plain old datatype so we can always... uh...\n+        // ...look, just pretend you forgot what you just read.\n+        // Stability concerns.\n+        let rt_f64_to_u64 = |rt| unsafe { mem::transmute::<f64, u64>(rt) };\n+        // SAFETY: We use internal implementations that either always work or fail at compile time.\n+        unsafe { intrinsics::const_eval_select((self,), ct_f64_to_u64, rt_f64_to_u64) }\n     }\n \n     /// Raw transmutation from `u64`.\n@@ -936,9 +986,54 @@ impl f64 {\n     #[must_use]\n     #[inline]\n     pub const fn from_bits(v: u64) -> Self {\n-        // SAFETY: `u64` is a plain old datatype so we can always transmute from it\n         // It turns out the safety issues with sNaN were overblown! Hooray!\n-        unsafe { mem::transmute::<u64, f64>(v) }\n+        // SAFETY: `u64` is a plain old datatype so we can always transmute from it\n+        // ...sorta.\n+        //\n+        // It turns out that at runtime, it is possible for a floating point number\n+        // to be subject to floating point modes that alters nonzero subnormal numbers\n+        // to zero on reads and writes, aka \"denormals are zero\" and \"flush to zero\".\n+        // This is not a problem usually, but at least one tier2 platform for Rust\n+        // actually exhibits an FTZ behavior kby default: thumbv7neon\n+        // aka \"the Neon FPU in AArch32 state\"\n+        //\n+        // Even with this, not all instructions exhibit the FTZ behaviors on thumbv7neon,\n+        // so this should load the same bits if LLVM emits the \"correct\" instructions,\n+        // but LLVM sometimes makes interesting choices about float optimization,\n+        // and other FPUs may do similar. Thus, it is wise to indulge luxuriously in caution.\n+        //\n+        // In addition, on x86 targets with SSE or SSE2 disabled and the x87 FPU enabled,\n+        // i.e. not soft-float, the way Rust does parameter passing can actually alter\n+        // a number that is \"not infinity\" to have the same exponent as infinity,\n+        // in a slightly unpredictable manner.\n+        //\n+        // And, of course evaluating to a NaN value is fairly nondeterministic.\n+        // More precisely: when NaN should be returned is knowable, but which NaN?\n+        // So far that's defined by a combination of LLVM and the CPU, not Rust.\n+        // This function, however, allows observing the bitstring of a NaN,\n+        // thus introspection on CTFE.\n+        //\n+        // In order to preserve, at least for the moment, const-to-runtime equivalence,\n+        // reject any of these possible situations from happening.\n+        #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n+        const fn ct_u64_to_f64(ct: u64) -> f64 {\n+            match f64::classify_bits(ct) {\n+                FpCategory::Subnormal => {\n+                    panic!(\"const-eval error: cannot use f64::from_bits on a subnormal number\");\n+                }\n+                FpCategory::Nan => {\n+                    panic!(\"const-eval error: cannot use f64::from_bits on NaN\");\n+                }\n+                // SAFETY: It's not a frumious number\n+                _ => unsafe { mem::transmute::<u64, f64>(ct) },\n+            }\n+        }\n+        // SAFETY: `u64` is a plain old datatype so we can always... uh...\n+        // ...look, just pretend you forgot what you just read.\n+        // Stability concerns.\n+        let rt_u64_to_f64 = |rt| unsafe { mem::transmute::<u64, f64>(rt) };\n+        // SAFETY: We use internal implementations that either always work or fail at compile time.\n+        unsafe { intrinsics::const_eval_select((v,), ct_u64_to_f64, rt_u64_to_f64) }\n     }\n \n     /// Return the memory representation of this floating point number as a byte array in"}, {"sha": "310db2174aafa34627b53fea6852346e56af4301", "filename": "src/test/ui/consts/const-float-bits-conv.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/83581796b28d1b792bd394de4280c3910c0e1155/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-conv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83581796b28d1b792bd394de4280c3910c0e1155/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-conv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-conv.rs?ref=83581796b28d1b792bd394de4280c3910c0e1155", "patch": "@@ -37,22 +37,6 @@ fn f32() {\n     const_assert!(f32::from_bits(0x44a72000), 1337.0);\n     const_assert!(f32::from_ne_bytes(0x44a72000u32.to_ne_bytes()), 1337.0);\n     const_assert!(f32::from_bits(0xc1640000), -14.25);\n-\n-    // Check that NaNs roundtrip their bits regardless of signalingness\n-    // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n-    const MASKED_NAN1: u32 = f32::NAN.to_bits() ^ 0x002A_AAAA;\n-    const MASKED_NAN2: u32 = f32::NAN.to_bits() ^ 0x0055_5555;\n-\n-    const_assert!(f32::from_bits(MASKED_NAN1).is_nan());\n-    const_assert!(f32::from_bits(MASKED_NAN1).is_nan());\n-\n-    // LLVM does not guarantee that loads and stores of NaNs preserve their exact bit pattern.\n-    // In practice, this seems to only cause a problem on x86, since the most widely used calling\n-    // convention mandates that floating point values are returned on the x87 FPU stack. See #73328.\n-    if !cfg!(target_arch = \"x86\") {\n-        const_assert!(f32::from_bits(MASKED_NAN1).to_bits(), MASKED_NAN1);\n-        const_assert!(f32::from_bits(MASKED_NAN2).to_bits(), MASKED_NAN2);\n-    }\n }\n \n fn f64() {\n@@ -70,20 +54,6 @@ fn f64() {\n     const_assert!(f64::from_bits(0x4094e40000000000), 1337.0);\n     const_assert!(f64::from_ne_bytes(0x4094e40000000000u64.to_ne_bytes()), 1337.0);\n     const_assert!(f64::from_bits(0xc02c800000000000), -14.25);\n-\n-    // Check that NaNs roundtrip their bits regardless of signalingness\n-    // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n-    const MASKED_NAN1: u64 = f64::NAN.to_bits() ^ 0x000A_AAAA_AAAA_AAAA;\n-    const MASKED_NAN2: u64 = f64::NAN.to_bits() ^ 0x0005_5555_5555_5555;\n-\n-    const_assert!(f64::from_bits(MASKED_NAN1).is_nan());\n-    const_assert!(f64::from_bits(MASKED_NAN1).is_nan());\n-\n-    // See comment above.\n-    if !cfg!(target_arch = \"x86\") {\n-        const_assert!(f64::from_bits(MASKED_NAN1).to_bits(), MASKED_NAN1);\n-        const_assert!(f64::from_bits(MASKED_NAN2).to_bits(), MASKED_NAN2);\n-    }\n }\n \n fn main() {"}, {"sha": "122f5b97eee06ed6df5797ac96be77bb27884d02", "filename": "src/test/ui/consts/const-float-bits-reject-conv.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/83581796b28d1b792bd394de4280c3910c0e1155/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83581796b28d1b792bd394de4280c3910c0e1155/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.rs?ref=83581796b28d1b792bd394de4280c3910c0e1155", "patch": "@@ -0,0 +1,62 @@\n+// compile-flags: -Zmir-opt-level=0\n+#![feature(const_float_bits_conv)]\n+#![feature(const_float_classify)]\n+\n+// Don't promote\n+const fn nop<T>(x: T) -> T { x }\n+\n+macro_rules! const_assert {\n+    ($a:expr) => {\n+        {\n+            const _: () = assert!($a);\n+            assert!(nop($a));\n+        }\n+    };\n+    ($a:expr, $b:expr) => {\n+        {\n+            const _: () = assert!($a == $b);\n+            assert_eq!(nop($a), nop($b));\n+        }\n+    };\n+}\n+\n+fn f32() {\n+    // Check that NaNs roundtrip their bits regardless of signalingness\n+    // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n+    // ...actually, let's just check that these break. :D\n+    const MASKED_NAN1: u32 = f32::NAN.to_bits() ^ 0x002A_AAAA;\n+    const MASKED_NAN2: u32 = f32::NAN.to_bits() ^ 0x0055_5555;\n+\n+    const_assert!(f32::from_bits(MASKED_NAN1).is_nan());\n+    const_assert!(f32::from_bits(MASKED_NAN1).is_nan());\n+\n+    // LLVM does not guarantee that loads and stores of NaNs preserve their exact bit pattern.\n+    // In practice, this seems to only cause a problem on x86, since the most widely used calling\n+    // convention mandates that floating point values are returned on the x87 FPU stack. See #73328.\n+    if !cfg!(target_arch = \"x86\") {\n+        const_assert!(f32::from_bits(MASKED_NAN1).to_bits(), MASKED_NAN1);\n+        const_assert!(f32::from_bits(MASKED_NAN2).to_bits(), MASKED_NAN2);\n+    }\n+}\n+\n+fn f64() {\n+    // Check that NaNs roundtrip their bits regardless of signalingness\n+    // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n+    // ...actually, let's just check that these break. :D\n+    const MASKED_NAN1: u64 = f64::NAN.to_bits() ^ 0x000A_AAAA_AAAA_AAAA;\n+    const MASKED_NAN2: u64 = f64::NAN.to_bits() ^ 0x0005_5555_5555_5555;\n+\n+    const_assert!(f64::from_bits(MASKED_NAN1).is_nan());\n+    const_assert!(f64::from_bits(MASKED_NAN1).is_nan());\n+\n+    // See comment above.\n+    if !cfg!(target_arch = \"x86\") {\n+        const_assert!(f64::from_bits(MASKED_NAN1).to_bits(), MASKED_NAN1);\n+        const_assert!(f64::from_bits(MASKED_NAN2).to_bits(), MASKED_NAN2);\n+    }\n+}\n+\n+fn main() {\n+    f32();\n+    f64();\n+}"}, {"sha": "b39e881970176d54e9b9b2cc8ab18c12849a756d", "filename": "src/test/ui/consts/const-float-bits-reject-conv.stderr", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/83581796b28d1b792bd394de4280c3910c0e1155/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83581796b28d1b792bd394de4280c3910c0e1155/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.stderr?ref=83581796b28d1b792bd394de4280c3910c0e1155", "patch": "@@ -0,0 +1,119 @@\n+error[E0080]: evaluation of constant value failed\n+  --> $SRC_DIR/core/src/num/f32.rs:LL:COL\n+   |\n+LL |                     panic!(\"const-eval error: cannot use f32::to_bits on a NaN\")\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                     |\n+   |                     the evaluated program panicked at 'const-eval error: cannot use f32::to_bits on a NaN', $SRC_DIR/core/src/num/f32.rs:LL:COL\n+   |                     inside `core::f32::<impl f32>::to_bits::ct_f32_to_u32` at $SRC_DIR/core/src/panic.rs:LL:COL\n+...\n+LL |         unsafe { intrinsics::const_eval_select((self,), ct_f32_to_u32, rt_f32_to_u32) }\n+   |                  -------------------------------------------------------------------- inside `core::f32::<impl f32>::to_bits` at $SRC_DIR/core/src/num/f32.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n+   |\n+LL |     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+   |     ------------------------------------------------------------------ inside `<fn(f32) -> u32 {core::f32::<impl f32>::to_bits::ct_f32_to_u32} as FnOnce<(f32,)>>::call_once - shim(fn(f32) -> u32 {core::f32::<impl f32>::to_bits::ct_f32_to_u32})` at $SRC_DIR/core/src/ops/function.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+   |\n+LL |     called_in_const.call_once(arg)\n+   |     ------------------------------ inside `const_eval_select::<(f32,), fn(f32) -> u32 {core::f32::<impl f32>::to_bits::ct_f32_to_u32}, [closure@core::f32::<impl f32>::to_bits::{closure#0}], u32>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+   |\n+  ::: $DIR/const-float-bits-reject-conv.rs:27:30\n+   |\n+LL |     const MASKED_NAN1: u32 = f32::NAN.to_bits() ^ 0x002A_AAAA;\n+   |                              ------------------ inside `f32::MASKED_NAN1` at $DIR/const-float-bits-reject-conv.rs:27:30\n+   |\n+   = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $SRC_DIR/core/src/num/f32.rs:LL:COL\n+   |\n+LL |                     panic!(\"const-eval error: cannot use f32::to_bits on a NaN\")\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                     |\n+   |                     the evaluated program panicked at 'const-eval error: cannot use f32::to_bits on a NaN', $SRC_DIR/core/src/num/f32.rs:LL:COL\n+   |                     inside `core::f32::<impl f32>::to_bits::ct_f32_to_u32` at $SRC_DIR/core/src/panic.rs:LL:COL\n+...\n+LL |         unsafe { intrinsics::const_eval_select((self,), ct_f32_to_u32, rt_f32_to_u32) }\n+   |                  -------------------------------------------------------------------- inside `core::f32::<impl f32>::to_bits` at $SRC_DIR/core/src/num/f32.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n+   |\n+LL |     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+   |     ------------------------------------------------------------------ inside `<fn(f32) -> u32 {core::f32::<impl f32>::to_bits::ct_f32_to_u32} as FnOnce<(f32,)>>::call_once - shim(fn(f32) -> u32 {core::f32::<impl f32>::to_bits::ct_f32_to_u32})` at $SRC_DIR/core/src/ops/function.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+   |\n+LL |     called_in_const.call_once(arg)\n+   |     ------------------------------ inside `const_eval_select::<(f32,), fn(f32) -> u32 {core::f32::<impl f32>::to_bits::ct_f32_to_u32}, [closure@core::f32::<impl f32>::to_bits::{closure#0}], u32>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+   |\n+  ::: $DIR/const-float-bits-reject-conv.rs:28:30\n+   |\n+LL |     const MASKED_NAN2: u32 = f32::NAN.to_bits() ^ 0x0055_5555;\n+   |                              ------------------ inside `f32::MASKED_NAN2` at $DIR/const-float-bits-reject-conv.rs:28:30\n+   |\n+   = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $SRC_DIR/core/src/num/f64.rs:LL:COL\n+   |\n+LL |                     panic!(\"const-eval error: cannot use f64::to_bits on a NaN\")\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                     |\n+   |                     the evaluated program panicked at 'const-eval error: cannot use f64::to_bits on a NaN', $SRC_DIR/core/src/num/f64.rs:LL:COL\n+   |                     inside `core::f64::<impl f64>::to_bits::ct_f64_to_u64` at $SRC_DIR/core/src/panic.rs:LL:COL\n+...\n+LL |         unsafe { intrinsics::const_eval_select((self,), ct_f64_to_u64, rt_f64_to_u64) }\n+   |                  -------------------------------------------------------------------- inside `core::f64::<impl f64>::to_bits` at $SRC_DIR/core/src/num/f64.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n+   |\n+LL |     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+   |     ------------------------------------------------------------------ inside `<fn(f64) -> u64 {core::f64::<impl f64>::to_bits::ct_f64_to_u64} as FnOnce<(f64,)>>::call_once - shim(fn(f64) -> u64 {core::f64::<impl f64>::to_bits::ct_f64_to_u64})` at $SRC_DIR/core/src/ops/function.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+   |\n+LL |     called_in_const.call_once(arg)\n+   |     ------------------------------ inside `const_eval_select::<(f64,), fn(f64) -> u64 {core::f64::<impl f64>::to_bits::ct_f64_to_u64}, [closure@core::f64::<impl f64>::to_bits::{closure#0}], u64>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+   |\n+  ::: $DIR/const-float-bits-reject-conv.rs:46:30\n+   |\n+LL |     const MASKED_NAN1: u64 = f64::NAN.to_bits() ^ 0x000A_AAAA_AAAA_AAAA;\n+   |                              ------------------ inside `f64::MASKED_NAN1` at $DIR/const-float-bits-reject-conv.rs:46:30\n+   |\n+   = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $SRC_DIR/core/src/num/f64.rs:LL:COL\n+   |\n+LL |                     panic!(\"const-eval error: cannot use f64::to_bits on a NaN\")\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                     |\n+   |                     the evaluated program panicked at 'const-eval error: cannot use f64::to_bits on a NaN', $SRC_DIR/core/src/num/f64.rs:LL:COL\n+   |                     inside `core::f64::<impl f64>::to_bits::ct_f64_to_u64` at $SRC_DIR/core/src/panic.rs:LL:COL\n+...\n+LL |         unsafe { intrinsics::const_eval_select((self,), ct_f64_to_u64, rt_f64_to_u64) }\n+   |                  -------------------------------------------------------------------- inside `core::f64::<impl f64>::to_bits` at $SRC_DIR/core/src/num/f64.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n+   |\n+LL |     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+   |     ------------------------------------------------------------------ inside `<fn(f64) -> u64 {core::f64::<impl f64>::to_bits::ct_f64_to_u64} as FnOnce<(f64,)>>::call_once - shim(fn(f64) -> u64 {core::f64::<impl f64>::to_bits::ct_f64_to_u64})` at $SRC_DIR/core/src/ops/function.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+   |\n+LL |     called_in_const.call_once(arg)\n+   |     ------------------------------ inside `const_eval_select::<(f64,), fn(f64) -> u64 {core::f64::<impl f64>::to_bits::ct_f64_to_u64}, [closure@core::f64::<impl f64>::to_bits::{closure#0}], u64>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+   |\n+  ::: $DIR/const-float-bits-reject-conv.rs:47:30\n+   |\n+LL |     const MASKED_NAN2: u64 = f64::NAN.to_bits() ^ 0x0005_5555_5555_5555;\n+   |                              ------------------ inside `f64::MASKED_NAN2` at $DIR/const-float-bits-reject-conv.rs:47:30\n+   |\n+   = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0080`."}]}