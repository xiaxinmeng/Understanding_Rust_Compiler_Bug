{"sha": "4b8089daf8046d7999310d44e5c68ccff4ab255a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiODA4OWRhZjgwNDZkNzk5OTMxMGQ0NGU1YzY4Y2NmZjRhYjI1NWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-06T14:07:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-06T14:07:22Z"}, "message": "Auto merge of #52990 - Aaron1011:fix/rustdoc-auto-trait-static, r=eddyb\n\nFix ICE when rustdoc encounters certain usages of HRTBs\n\nFixes #51236\n\nUnder certain circumstances, `AutoTraitFinder` could end up computing a `ParamEnv` involving two trait predicates that differed only in the region parameters involved. One of these parameters would be a HRTB, while the other would be a normal region parameter.\n\nWhen this `ParamEnv` was later passed to `SelectionContext`, an `Ambiguity` error would occur, since the erased versions of these predicates would be identical. To solve the issue, we de-duplicate our list of predicates as we build it up. Whenever we encounter two predicates that differ only in their assignment of region parameters (a HRTB vs a normal lifetime parameter), we pick the HRTB. This corresponds to selecting a 'stricter' bound to display in the generated documentation: we're requiring that a particular type works for all possible lifetime parameters if it's going to implement a particular auto trait.", "tree": {"sha": "d0af26b70ad7864085f4201d8399c4bcbfb682f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0af26b70ad7864085f4201d8399c4bcbfb682f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b8089daf8046d7999310d44e5c68ccff4ab255a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b8089daf8046d7999310d44e5c68ccff4ab255a", "html_url": "https://github.com/rust-lang/rust/commit/4b8089daf8046d7999310d44e5c68ccff4ab255a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b8089daf8046d7999310d44e5c68ccff4ab255a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78ec12df020453836c3b8990c0a8dd859b774e84", "url": "https://api.github.com/repos/rust-lang/rust/commits/78ec12df020453836c3b8990c0a8dd859b774e84", "html_url": "https://github.com/rust-lang/rust/commit/78ec12df020453836c3b8990c0a8dd859b774e84"}, {"sha": "b010d1f9295821f2f37de76a84ea4e26620456dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/b010d1f9295821f2f37de76a84ea4e26620456dd", "html_url": "https://github.com/rust-lang/rust/commit/b010d1f9295821f2f37de76a84ea4e26620456dd"}], "stats": {"total": 141, "additions": 136, "deletions": 5}, "files": [{"sha": "cfe3583a9806f7836431f78a97c027aaf018c41f", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 90, "deletions": 3, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/4b8089daf8046d7999310d44e5c68ccff4ab255a/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8089daf8046d7999310d44e5c68ccff4ab255a/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=4b8089daf8046d7999310d44e5c68ccff4ab255a", "patch": "@@ -358,7 +358,8 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 &Err(SelectionError::Unimplemented) => {\n                     if self.is_of_param(pred.skip_binder().trait_ref.substs) {\n                         already_visited.remove(&pred);\n-                        user_computed_preds.insert(ty::Predicate::Trait(pred.clone()));\n+                        self.add_user_pred(&mut user_computed_preds,\n+                                           ty::Predicate::Trait(pred.clone()));\n                         predicates.push_back(pred);\n                     } else {\n                         debug!(\n@@ -393,6 +394,92 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         return Some((new_env, final_user_env));\n     }\n \n+    // This method is designed to work around the following issue:\n+    // When we compute auto trait bounds, we repeatedly call SelectionContext.select,\n+    // progressively building a ParamEnv based on the results we get.\n+    // However, our usage of SelectionContext differs from its normal use within the compiler,\n+    // in that we capture and re-reprocess predicates from Unimplemented errors.\n+    //\n+    // This can lead to a corner case when dealing with region parameters.\n+    // During our selection loop in evaluate_predicates, we might end up with\n+    // two trait predicates that differ only in their region parameters:\n+    // one containing a HRTB lifetime parameter, and one containing a 'normal'\n+    // lifetime parameter. For example:\n+    //\n+    // T as MyTrait<'a>\n+    // T as MyTrait<'static>\n+    //\n+    // If we put both of these predicates in our computed ParamEnv, we'll\n+    // confuse SelectionContext, since it will (correctly) view both as being applicable.\n+    //\n+    // To solve this, we pick the 'more strict' lifetime bound - i.e. the HRTB\n+    // Our end goal is to generate a user-visible description of the conditions\n+    // under which a type implements an auto trait. A trait predicate involving\n+    // a HRTB means that the type needs to work with any choice of lifetime,\n+    // not just one specific lifetime (e.g. 'static).\n+    fn add_user_pred<'c>(&self, user_computed_preds: &mut FxHashSet<ty::Predicate<'c>>,\n+                         new_pred: ty::Predicate<'c>) {\n+        let mut should_add_new = true;\n+        user_computed_preds.retain(|&old_pred| {\n+            match (&new_pred, old_pred) {\n+                (&ty::Predicate::Trait(new_trait), ty::Predicate::Trait(old_trait)) => {\n+                    if new_trait.def_id() == old_trait.def_id() {\n+                        let new_substs = new_trait.skip_binder().trait_ref.substs;\n+                        let old_substs = old_trait.skip_binder().trait_ref.substs;\n+                        if !new_substs.types().eq(old_substs.types()) {\n+                            // We can't compare lifetimes if the types are different,\n+                            // so skip checking old_pred\n+                            return true\n+                        }\n+\n+                        for (new_region, old_region) in new_substs\n+                            .regions()\n+                            .zip(old_substs.regions()) {\n+\n+                            match (new_region, old_region) {\n+                                // If both predicates have an 'ReLateBound' (a HRTB) in the\n+                                // same spot, we do nothing\n+                                (\n+                                    ty::RegionKind::ReLateBound(_, _),\n+                                    ty::RegionKind::ReLateBound(_, _)\n+                                ) => {},\n+\n+                                (ty::RegionKind::ReLateBound(_, _), _) => {\n+                                    // The new predicate has a HRTB in a spot where the old\n+                                    // predicate does not (if they both had a HRTB, the previous\n+                                    // match arm would have executed).\n+                                    //\n+                                    // The means we want to remove the older predicate from\n+                                    // user_computed_preds, since having both it and the new\n+                                    // predicate in a ParamEnv would confuse SelectionContext\n+                                    // We're currently in the predicate passed to 'retain',\n+                                    // so we return 'false' to remove the old predicate from\n+                                    // user_computed_preds\n+                                    return false;\n+                                },\n+                                (_, ty::RegionKind::ReLateBound(_, _)) => {\n+                                    // This is the opposite situation as the previous arm - the\n+                                    // old predicate has a HRTB lifetime in a place where the\n+                                    // new predicate does not. We want to leave the old\n+                                    // predicate in user_computed_preds, and skip adding\n+                                    // new_pred to user_computed_params.\n+                                    should_add_new = false\n+                                }\n+                                _ => {}\n+                            }\n+                        }\n+                    }\n+                },\n+                _ => {}\n+            }\n+            return true\n+        });\n+\n+        if should_add_new {\n+            user_computed_preds.insert(new_pred);\n+        }\n+    }\n+\n     pub fn region_name(&self, region: Region) -> Option<String> {\n         match region {\n             &ty::ReEarlyBound(r) => Some(r.name.to_string()),\n@@ -555,15 +642,15 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     let substs = &p.skip_binder().trait_ref.substs;\n \n                     if self.is_of_param(substs) && !only_projections && is_new_pred {\n-                        computed_preds.insert(predicate);\n+                        self.add_user_pred(computed_preds, predicate);\n                     }\n                     predicates.push_back(p.clone());\n                 }\n                 &ty::Predicate::Projection(p) => {\n                     // If the projection isn't all type vars, then\n                     // we don't want to add it as a bound\n                     if self.is_of_param(p.skip_binder().projection_ty.substs) && is_new_pred {\n-                        computed_preds.insert(predicate);\n+                        self.add_user_pred(computed_preds, predicate);\n                     } else {\n                         match poly_project_and_unify_type(select, &obligation.with(p.clone())) {\n                             Err(e) => {"}, {"sha": "4390a31d3e33f84111b207ee3ab6e1e6741e0c15", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b8089daf8046d7999310d44e5c68ccff4ab255a/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8089daf8046d7999310d44e5c68ccff4ab255a/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=4b8089daf8046d7999310d44e5c68ccff4ab255a", "patch": "@@ -418,8 +418,8 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n                                 name: name.to_string(),\n                                 kind: GenericParamDefKind::Lifetime,\n                             })\n-                        }\n-                        &ty::ReVar(_) | &ty::ReEarlyBound(_) => None,\n+                        },\n+                        &ty::ReVar(_) | &ty::ReEarlyBound(_) | &ty::ReStatic => None,\n                         _ => panic!(\"Unexpected region type {:?}\", r),\n                     }\n                 })"}, {"sha": "541a1c5e19f2a321f2787f131b6621625deab5d7", "filename": "src/test/rustdoc/issue-51236.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4b8089daf8046d7999310d44e5c68ccff4ab255a/src%2Ftest%2Frustdoc%2Fissue-51236.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8089daf8046d7999310d44e5c68ccff4ab255a/src%2Ftest%2Frustdoc%2Fissue-51236.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-51236.rs?ref=4b8089daf8046d7999310d44e5c68ccff4ab255a", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::marker::PhantomData;\n+\n+pub mod traits {\n+    pub trait Owned<'a> {\n+        type Reader;\n+    }\n+}\n+\n+// @has issue_51236/struct.Owned.html\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl<T> Send for \\\n+// Owned<T> where <T as Owned<'static>>::Reader: Send\"\n+pub struct Owned<T> where T: for<'a> ::traits::Owned<'a> {\n+    marker: PhantomData<<T as ::traits::Owned<'static>>::Reader>,\n+}"}, {"sha": "96e8b8ed5f695c8aa0e7131eb1409be1d023bd77", "filename": "src/test/rustdoc/synthetic_auto/static-region.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4b8089daf8046d7999310d44e5c68ccff4ab255a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fstatic-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8089daf8046d7999310d44e5c68ccff4ab255a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fstatic-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fstatic-region.rs?ref=4b8089daf8046d7999310d44e5c68ccff4ab255a", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait OwnedTrait<'a> {\n+    type Reader;\n+}\n+\n+// @has static_region/struct.Owned.html\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl<T> Send for \\\n+// Owned<T> where <T as OwnedTrait<'static>>::Reader: Send\"\n+pub struct Owned<T> where T: OwnedTrait<'static> {\n+    marker: <T as OwnedTrait<'static>>::Reader,\n+}"}]}