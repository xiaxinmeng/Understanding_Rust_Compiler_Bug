{"sha": "ecfc9a82231eef47bf522e6d18138a0f3414d914", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjZmM5YTgyMjMxZWVmNDdiZjUyMmU2ZDE4MTM4YTBmMzQxNGQ5MTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-12T11:29:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-12T11:29:11Z"}, "message": "auto merge of #8428 : blake2-ppc/rust/peekable-iterators, r=thestinger\n\nPeekable changes by @SimonSapin and original PR is #8396", "tree": {"sha": "ff63280c5acf72993b1d494637123f6b9aed9707", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff63280c5acf72993b1d494637123f6b9aed9707"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecfc9a82231eef47bf522e6d18138a0f3414d914", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecfc9a82231eef47bf522e6d18138a0f3414d914", "html_url": "https://github.com/rust-lang/rust/commit/ecfc9a82231eef47bf522e6d18138a0f3414d914", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecfc9a82231eef47bf522e6d18138a0f3414d914/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de48274c50952dc629914e33d8b65ba222c1e093", "url": "https://api.github.com/repos/rust-lang/rust/commits/de48274c50952dc629914e33d8b65ba222c1e093", "html_url": "https://github.com/rust-lang/rust/commit/de48274c50952dc629914e33d8b65ba222c1e093"}, {"sha": "0b35e3b5a3468d5a8b5b86f0f6b369b8f663ce17", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b35e3b5a3468d5a8b5b86f0f6b369b8f663ce17", "html_url": "https://github.com/rust-lang/rust/commit/0b35e3b5a3468d5a8b5b86f0f6b369b8f663ce17"}], "stats": {"total": 245, "additions": 138, "deletions": 107}, "files": [{"sha": "f5a61692509ad2a322907d867eca00c2b59ec7f1", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 46, "deletions": 88, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/ecfc9a82231eef47bf522e6d18138a0f3414d914/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecfc9a82231eef47bf522e6d18138a0f3414d914/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=ecfc9a82231eef47bf522e6d18138a0f3414d914", "patch": "@@ -14,7 +14,8 @@\n \n \n use std::util::{swap, replace};\n-use std::iterator::{FromIterator, Extendable};\n+use std::iterator::{FromIterator, Extendable, Peekable};\n+use std::cmp::Ordering;\n \n // This is implemented as an AA tree, which is a simplified variation of\n // a red-black tree where red (horizontal) nodes can only be added\n@@ -529,24 +530,24 @@ impl<T: TotalOrd> TreeSet<T> {\n \n     /// Visit the values (in-order) representing the difference\n     pub fn difference<'a>(&'a self, other: &'a TreeSet<T>) -> Difference<'a, T> {\n-        Difference{a: Focus::new(self.iter()), b: Focus::new(other.iter())}\n+        Difference{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visit the values (in-order) representing the symmetric difference\n     pub fn symmetric_difference<'a>(&'a self, other: &'a TreeSet<T>)\n         -> SymDifference<'a, T> {\n-        SymDifference{a: Focus::new(self.iter()), b: Focus::new(other.iter())}\n+        SymDifference{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visit the values (in-order) representing the intersection\n     pub fn intersection<'a>(&'a self, other: &'a TreeSet<T>)\n         -> Intersection<'a, T> {\n-        Intersection{a: Focus::new(self.iter()), b: Focus::new(other.iter())}\n+        Intersection{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visit the values (in-order) representing the union\n     pub fn union<'a>(&'a self, other: &'a TreeSet<T>) -> Union<'a, T> {\n-        Union{a: Focus::new(self.iter()), b: Focus::new(other.iter())}\n+        Union{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n }\n \n@@ -560,61 +561,47 @@ pub struct TreeSetRevIterator<'self, T> {\n     priv iter: TreeMapRevIterator<'self, T, ()>\n }\n \n-// Encapsulate an iterator and hold its latest value until stepped forward\n-struct Focus<A, T> {\n-    priv iter: T,\n-    priv focus: Option<A>,\n-}\n-\n-impl<A, T: Iterator<A>> Focus<A, T> {\n-    fn new(mut it: T) -> Focus<A, T> {\n-        Focus{focus: it.next(), iter: it}\n-    }\n-    fn step(&mut self) {\n-        self.focus = self.iter.next()\n-    }\n-}\n-\n /// Lazy iterator producing elements in the set difference (in-order)\n pub struct Difference<'self, T> {\n-    priv a: Focus<&'self T, TreeSetIterator<'self, T>>,\n-    priv b: Focus<&'self T, TreeSetIterator<'self, T>>,\n+    priv a: Peekable<&'self T, TreeSetIterator<'self, T>>,\n+    priv b: Peekable<&'self T, TreeSetIterator<'self, T>>,\n }\n \n /// Lazy iterator producing elements in the set symmetric difference (in-order)\n pub struct SymDifference<'self, T> {\n-    priv a: Focus<&'self T, TreeSetIterator<'self, T>>,\n-    priv b: Focus<&'self T, TreeSetIterator<'self, T>>,\n+    priv a: Peekable<&'self T, TreeSetIterator<'self, T>>,\n+    priv b: Peekable<&'self T, TreeSetIterator<'self, T>>,\n }\n \n /// Lazy iterator producing elements in the set intersection (in-order)\n pub struct Intersection<'self, T> {\n-    priv a: Focus<&'self T, TreeSetIterator<'self, T>>,\n-    priv b: Focus<&'self T, TreeSetIterator<'self, T>>,\n+    priv a: Peekable<&'self T, TreeSetIterator<'self, T>>,\n+    priv b: Peekable<&'self T, TreeSetIterator<'self, T>>,\n }\n \n /// Lazy iterator producing elements in the set intersection (in-order)\n pub struct Union<'self, T> {\n-    priv a: Focus<&'self T, TreeSetIterator<'self, T>>,\n-    priv b: Focus<&'self T, TreeSetIterator<'self, T>>,\n+    priv a: Peekable<&'self T, TreeSetIterator<'self, T>>,\n+    priv b: Peekable<&'self T, TreeSetIterator<'self, T>>,\n+}\n+\n+/// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n+fn cmp_opt<T: TotalOrd>(x: Option<&T>, y: Option<&T>,\n+                        short: Ordering, long: Ordering) -> Ordering {\n+    match (x, y) {\n+        (None    , _       ) => short,\n+        (_       , None    ) => long,\n+        (Some(x1), Some(y1)) => x1.cmp(y1),\n+    }\n }\n \n impl<'self, T: TotalOrd> Iterator<&'self T> for Difference<'self, T> {\n     fn next(&mut self) -> Option<&'self T> {\n         loop {\n-            match (self.a.focus, self.b.focus) {\n-                (None    , _       ) => return None,\n-                (ret     , None    ) => { self.a.step(); return ret },\n-                (Some(a1), Some(b1)) => {\n-                    let cmp = a1.cmp(b1);\n-                    if cmp == Less {\n-                        self.a.step();\n-                        return Some(a1);\n-                    } else {\n-                        if cmp == Equal { self.a.step() }\n-                        self.b.step();\n-                    }\n-                }\n+            match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n+                Less    => return self.a.next(),\n+                Equal   => { self.a.next(); self.b.next(); }\n+                Greater => { self.b.next(); }\n             }\n         }\n     }\n@@ -623,23 +610,10 @@ impl<'self, T: TotalOrd> Iterator<&'self T> for Difference<'self, T> {\n impl<'self, T: TotalOrd> Iterator<&'self T> for SymDifference<'self, T> {\n     fn next(&mut self) -> Option<&'self T> {\n         loop {\n-            match (self.a.focus, self.b.focus) {\n-                (ret     , None    ) => { self.a.step(); return ret },\n-                (None    , ret     ) => { self.b.step(); return ret },\n-                (Some(a1), Some(b1)) => {\n-                    let cmp = a1.cmp(b1);\n-                    if cmp == Less {\n-                        self.a.step();\n-                        return Some(a1);\n-                    } else {\n-                        self.b.step();\n-                        if cmp == Greater {\n-                            return Some(b1);\n-                        } else {\n-                            self.a.step();\n-                        }\n-                    }\n-                }\n+            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n+                Less    => return self.a.next(),\n+                Equal   => { self.a.next(); self.b.next(); }\n+                Greater => return self.b.next(),\n             }\n         }\n     }\n@@ -648,20 +622,16 @@ impl<'self, T: TotalOrd> Iterator<&'self T> for SymDifference<'self, T> {\n impl<'self, T: TotalOrd> Iterator<&'self T> for Intersection<'self, T> {\n     fn next(&mut self) -> Option<&'self T> {\n         loop {\n-            match (self.a.focus, self.b.focus) {\n-                (None    , _       ) => return None,\n-                (_       , None    ) => return None,\n-                (Some(a1), Some(b1)) => {\n-                    let cmp = a1.cmp(b1);\n-                    if cmp == Less {\n-                        self.a.step();\n-                    } else {\n-                        self.b.step();\n-                        if cmp == Equal {\n-                            return Some(a1);\n-                        }\n-                    }\n-                },\n+            let o_cmp = match (self.a.peek(), self.b.peek()) {\n+                (None    , _       ) => None,\n+                (_       , None    ) => None,\n+                (Some(a1), Some(b1)) => Some(a1.cmp(b1)),\n+            };\n+            match o_cmp {\n+                None          => return None,\n+                Some(Less)    => { self.a.next(); }\n+                Some(Equal)   => { self.b.next(); return self.a.next() }\n+                Some(Greater) => { self.b.next(); }\n             }\n         }\n     }\n@@ -670,22 +640,10 @@ impl<'self, T: TotalOrd> Iterator<&'self T> for Intersection<'self, T> {\n impl<'self, T: TotalOrd> Iterator<&'self T> for Union<'self, T> {\n     fn next(&mut self) -> Option<&'self T> {\n         loop {\n-            match (self.a.focus, self.b.focus) {\n-                (ret     , None) => { self.a.step(); return ret },\n-                (None    , ret ) => { self.b.step(); return ret },\n-                (Some(a1), Some(b1)) => {\n-                    let cmp = a1.cmp(b1);\n-                    if cmp == Greater {\n-                        self.b.step();\n-                        return Some(b1);\n-                    } else {\n-                        self.a.step();\n-                        if cmp == Equal {\n-                            self.b.step();\n-                        }\n-                        return Some(a1);\n-                    }\n-                }\n+            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n+                Less    => return self.a.next(),\n+                Equal   => { self.b.next(); return self.a.next() }\n+                Greater => return self.b.next(),\n             }\n         }\n     }"}, {"sha": "e2d157c2a59ea6cabd4429dfa6f23023242f34fe", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 92, "deletions": 19, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/ecfc9a82231eef47bf522e6d18138a0f3414d914/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecfc9a82231eef47bf522e6d18138a0f3414d914/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=ecfc9a82231eef47bf522e6d18138a0f3414d914", "patch": "@@ -156,6 +156,28 @@ pub trait Iterator<A> {\n         Enumerate{iter: self, count: 0}\n     }\n \n+\n+    /// Creates an iterator that has a `.peek()` method\n+    /// that returns a optional reference to the next element.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// let a = [100, 200, 300];\n+    /// let mut it = xs.iter().map(|&x|x).peekable();\n+    /// assert_eq!(it.peek().unwrap(), &100);\n+    /// assert_eq!(it.next().unwrap(), 100);\n+    /// assert_eq!(it.next().unwrap(), 200);\n+    /// assert_eq!(it.peek().unwrap(), &300);\n+    /// assert_eq!(it.peek().unwrap(), &300);\n+    /// assert_eq!(it.next().unwrap(), 300);\n+    /// assert!(it.peek().is_none());\n+    /// assert!(it.next().is_none());\n+    /// ~~~\n+    fn peekable(self) -> Peekable<A, Self> {\n+        Peekable{iter: self, peeked: None}\n+    }\n+\n     /// Creates an iterator which invokes the predicate on elements until it\n     /// returns false. Once the predicate returns false, all further elements are\n     /// yielded.\n@@ -286,15 +308,15 @@ pub trait Iterator<A> {\n     ///let xs = [1u, 4, 2, 3, 8, 9, 6];\n     ///let sum = xs.iter()\n     ///            .map(|&x| x)\n-    ///            .peek(|&x| debug!(\"filtering %u\", x))\n+    ///            .inspect(|&x| debug!(\"filtering %u\", x))\n     ///            .filter(|&x| x % 2 == 0)\n-    ///            .peek(|&x| debug!(\"%u made it through\", x))\n+    ///            .inspect(|&x| debug!(\"%u made it through\", x))\n     ///            .sum();\n     ///println(sum.to_str());\n     /// ~~~\n     #[inline]\n-    fn peek<'r>(self, f: &'r fn(&A)) -> Peek<'r, A, Self> {\n-        Peek{iter: self, f: f}\n+    fn inspect<'r>(self, f: &'r fn(&A)) -> Inspect<'r, A, Self> {\n+        Inspect{iter: self, f: f}\n     }\n \n     /// An adaptation of an external iterator to the for-loop protocol of rust.\n@@ -1059,6 +1081,38 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<(uint, A)> for Enumerat\n     }\n }\n \n+/// An iterator with a `peek()` that returns an optional reference to the next element.\n+pub struct Peekable<A, T> {\n+    priv iter: T,\n+    priv peeked: Option<A>,\n+}\n+\n+impl<A, T: Iterator<A>> Iterator<A> for Peekable<A, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        if self.peeked.is_some() { self.peeked.take() }\n+        else { self.iter.next() }\n+    }\n+}\n+\n+impl<'self, A, T: Iterator<A>> Peekable<A, T> {\n+    /// Return a reference to the next element of the iterator with out advancing it,\n+    /// or None if the iterator is exhausted.\n+    #[inline]\n+    pub fn peek(&'self mut self) -> Option<&'self A> {\n+        match self.peeked {\n+            Some(ref value) => Some(value),\n+            None => {\n+                self.peeked = self.iter.next();\n+                match self.peeked {\n+                    Some(ref value) => Some(value),\n+                    None => None,\n+                }\n+            },\n+        }\n+    }\n+}\n+\n /// An iterator which rejects elements while `predicate` is true\n pub struct SkipWhile<'self, A, T> {\n     priv iter: T,\n@@ -1329,14 +1383,14 @@ impl<'self,\n \n /// An iterator that calls a function with a reference to each\n /// element before yielding it.\n-pub struct Peek<'self, A, T> {\n+pub struct Inspect<'self, A, T> {\n     priv iter: T,\n     priv f: &'self fn(&A)\n }\n \n-impl<'self, A, T> Peek<'self, A, T> {\n+impl<'self, A, T> Inspect<'self, A, T> {\n     #[inline]\n-    fn do_peek(&self, elt: Option<A>) -> Option<A> {\n+    fn do_inspect(&self, elt: Option<A>) -> Option<A> {\n         match elt {\n             Some(ref a) => (self.f)(a),\n             None => ()\n@@ -1346,11 +1400,11 @@ impl<'self, A, T> Peek<'self, A, T> {\n     }\n }\n \n-impl<'self, A, T: Iterator<A>> Iterator<A> for Peek<'self, A, T> {\n+impl<'self, A, T: Iterator<A>> Iterator<A> for Inspect<'self, A, T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         let next = self.iter.next();\n-        self.do_peek(next)\n+        self.do_inspect(next)\n     }\n \n     #[inline]\n@@ -1359,23 +1413,25 @@ impl<'self, A, T: Iterator<A>> Iterator<A> for Peek<'self, A, T> {\n     }\n }\n \n-impl<'self, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Peek<'self, A, T> {\n+impl<'self, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A>\n+for Inspect<'self, A, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         let next = self.iter.next_back();\n-        self.do_peek(next)\n+        self.do_inspect(next)\n     }\n }\n \n-impl<'self, A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Peek<'self, A, T> {\n+impl<'self, A, T: RandomAccessIterator<A>> RandomAccessIterator<A>\n+for Inspect<'self, A, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         self.iter.indexable()\n     }\n \n     #[inline]\n     fn idx(&self, index: uint) -> Option<A> {\n-        self.do_peek(self.iter.idx(index))\n+        self.do_inspect(self.iter.idx(index))\n     }\n }\n \n@@ -1566,6 +1622,24 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_iterator_peekable() {\n+        let xs = ~[0u, 1, 2, 3, 4, 5];\n+        let mut it = xs.iter().map(|&x|x).peekable();\n+        assert_eq!(it.peek().unwrap(), &0);\n+        assert_eq!(it.next().unwrap(), 0);\n+        assert_eq!(it.next().unwrap(), 1);\n+        assert_eq!(it.next().unwrap(), 2);\n+        assert_eq!(it.peek().unwrap(), &3);\n+        assert_eq!(it.peek().unwrap(), &3);\n+        assert_eq!(it.next().unwrap(), 3);\n+        assert_eq!(it.next().unwrap(), 4);\n+        assert_eq!(it.peek().unwrap(), &5);\n+        assert_eq!(it.next().unwrap(), 5);\n+        assert!(it.peek().is_none());\n+        assert!(it.next().is_none());\n+    }\n+\n     #[test]\n     fn test_iterator_take_while() {\n         let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n@@ -1651,13 +1725,13 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_peek() {\n+    fn test_inspect() {\n         let xs = [1u, 2, 3, 4];\n         let mut n = 0;\n \n         let ys = xs.iter()\n                    .map(|&x| x)\n-                   .peek(|_| n += 1)\n+                   .inspect(|_| n += 1)\n                    .collect::<~[uint]>();\n \n         assert_eq!(n, xs.len());\n@@ -2011,11 +2085,11 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_random_access_peek() {\n+    fn test_random_access_inspect() {\n         let xs = [1, 2, 3, 4, 5];\n \n-        // test .map and .peek that don't implement Clone\n-        let it = xs.iter().peek(|_| {});\n+        // test .map and .inspect that don't implement Clone\n+        let it = xs.iter().inspect(|_| {});\n         assert_eq!(xs.len(), it.indexable());\n         for (i, elt) in xs.iter().enumerate() {\n             assert_eq!(Some(elt), it.idx(i));\n@@ -2027,7 +2101,6 @@ mod tests {\n     fn test_random_access_map() {\n         let xs = [1, 2, 3, 4, 5];\n \n-        // test .map and .peek that don't implement Clone\n         let it = xs.iter().map(|x| *x);\n         assert_eq!(xs.len(), it.indexable());\n         for (i, elt) in xs.iter().enumerate() {"}]}