{"sha": "e12711540a00ded4021250f7b2a31773fc4dc734", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxMjcxMTU0MGEwMGRlZDQwMjEyNTBmN2IyYTMxNzczZmM0ZGM3MzQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-18T00:46:18Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-10T00:05:34Z"}, "message": "librustc: Implement placement `box` for GC and unique pointers.", "tree": {"sha": "036d04e2767d3bda4217c832f1a083c1a68b2c55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/036d04e2767d3bda4217c832f1a083c1a68b2c55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e12711540a00ded4021250f7b2a31773fc4dc734", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e12711540a00ded4021250f7b2a31773fc4dc734", "html_url": "https://github.com/rust-lang/rust/commit/e12711540a00ded4021250f7b2a31773fc4dc734", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e12711540a00ded4021250f7b2a31773fc4dc734/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd11fe17c7cf3661905c952d8233527abbff4c11", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd11fe17c7cf3661905c952d8233527abbff4c11", "html_url": "https://github.com/rust-lang/rust/commit/dd11fe17c7cf3661905c952d8233527abbff4c11"}], "stats": {"total": 338, "additions": 296, "deletions": 42}, "files": [{"sha": "0beae3ce5c1fa3e590da36175a697d09a3bc2663", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=e12711540a00ded4021250f7b2a31773fc4dc734", "patch": "@@ -394,6 +394,10 @@ impl CFGBuilder {\n                 self.straightline(expr, pred, [l, r])\n             }\n \n+            ast::ExprBox(p, e) => {\n+                self.straightline(expr, pred, [p, e])\n+            }\n+\n             ast::ExprAddrOf(_, e) |\n             ast::ExprDoBody(e) |\n             ast::ExprCast(e, _) |"}, {"sha": "ffa356d6b06437f7099aac8d77b02be606d8a7f2", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=e12711540a00ded4021250f7b2a31773fc4dc734", "patch": "@@ -721,6 +721,11 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                 self.walk_expr(e, in_out, loop_scopes);\n             }\n \n+            ast::ExprBox(s, e) => {\n+                self.walk_expr(s, in_out, loop_scopes);\n+                self.walk_expr(e, in_out, loop_scopes);\n+            }\n+\n             ast::ExprInlineAsm(ref inline_asm) => {\n                 for &(_, expr) in inline_asm.inputs.iter() {\n                     self.walk_expr(expr, in_out, loop_scopes);"}, {"sha": "31b36f10b40f19b2961acef3d06709c0063c866f", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=e12711540a00ded4021250f7b2a31773fc4dc734", "patch": "@@ -207,7 +207,7 @@ pub fn collect_language_items(crate: &ast::Crate,\n }\n \n lets_do_this! {\n-    There are 37 lang items.\n+    There are 40 lang items.\n \n //  ID, Variant name,                    Name,                      Method name;\n     0,  FreezeTraitLangItem,             \"freeze\",                  freeze_trait;\n@@ -256,5 +256,9 @@ lets_do_this! {\n     35, TypeIdLangItem,                  \"type_id\",                 type_id;\n \n     36, EhPersonalityLangItem,           \"eh_personality\",          eh_personality_fn;\n+\n+    37, ManagedHeapLangItem,             \"managed_heap\",            managed_heap;\n+    38, ExchangeHeapLangItem,            \"exchange_heap\",           exchange_heap;\n+    39, GcLangItem,                      \"gc\",                      gc;\n }\n "}, {"sha": "9e74c57c581adef54aa5ecf52e907e1a96029e7c", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e12711540a00ded4021250f7b2a31773fc4dc734", "patch": "@@ -556,7 +556,7 @@ fn visit_expr(v: &mut LivenessVisitor, expr: &Expr, this: @IrMaps) {\n       ExprAgain(_) | ExprLit(_) | ExprRet(..) | ExprBlock(..) |\n       ExprAssign(..) | ExprAssignOp(..) | ExprMac(..) |\n       ExprStruct(..) | ExprRepeat(..) | ExprParen(..) |\n-      ExprInlineAsm(..) => {\n+      ExprInlineAsm(..) | ExprBox(..) => {\n           visit::walk_expr(v, expr, this);\n       }\n     }\n@@ -1252,7 +1252,8 @@ impl Liveness {\n           }\n \n           ExprIndex(_, l, r) |\n-          ExprBinary(_, _, l, r) => {\n+          ExprBinary(_, _, l, r) |\n+          ExprBox(l, r) => {\n             self.propagate_through_exprs([l, r], succ)\n           }\n \n@@ -1546,7 +1547,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ExprAgain(..) | ExprLit(_) | ExprBlock(..) |\n       ExprMac(..) | ExprAddrOf(..) | ExprStruct(..) | ExprRepeat(..) |\n       ExprParen(..) | ExprFnBlock(..) | ExprProc(..) | ExprPath(..) |\n-      ExprSelf(..) => {\n+      ExprSelf(..) | ExprBox(..) => {\n         visit::walk_expr(this, expr, ());\n       }\n       ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\")"}, {"sha": "14eb5643147188d687de4930e07bf3edfea4bdc5", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e12711540a00ded4021250f7b2a31773fc4dc734", "patch": "@@ -438,7 +438,7 @@ impl mem_categorization_ctxt {\n           ast::ExprBlock(..) | ast::ExprLoop(..) | ast::ExprMatch(..) |\n           ast::ExprLit(..) | ast::ExprBreak(..) | ast::ExprMac(..) |\n           ast::ExprAgain(..) | ast::ExprStruct(..) | ast::ExprRepeat(..) |\n-          ast::ExprInlineAsm(..) => {\n+          ast::ExprInlineAsm(..) | ast::ExprBox(..) => {\n             return self.cat_rvalue_node(expr, expr_ty);\n           }\n "}, {"sha": "462c557c61d34875713eaad1c484bf3f245f9db8", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=e12711540a00ded4021250f7b2a31773fc4dc734", "patch": "@@ -591,6 +591,11 @@ impl VisitContext {\n                 self.use_expr(base, comp_mode);\n             }\n \n+            ExprBox(place, base) => {\n+                self.use_expr(place, comp_mode);\n+                self.use_expr(base, comp_mode);\n+            }\n+\n             ExprMac(..) => {\n                 self.tcx.sess.span_bug(\n                     expr.span,"}, {"sha": "5690802b7e0462ecaaddf6faa192ffffb9132931", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=e12711540a00ded4021250f7b2a31773fc4dc734", "patch": "@@ -2616,6 +2616,11 @@ fn populate_scope_map(cx: &CrateContext,\n             ast::ExprField(@ref sub_exp, _, _) |\n             ast::ExprParen(@ref sub_exp)       => walk_expr(cx, sub_exp, scope_stack, scope_map),\n \n+            ast::ExprBox(@ref place, @ref sub_expr) => {\n+                walk_expr(cx, place, scope_stack, scope_map);\n+                walk_expr(cx, sub_expr, scope_stack, scope_map);\n+            }\n+\n             ast::ExprRet(exp_opt) => match exp_opt {\n                 Some(@ref sub_exp) => walk_expr(cx, sub_exp, scope_stack, scope_map),\n                 None => ()"}, {"sha": "8505109dab2aa7dc193731aae2d8ec9b40287e9e", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 77, "deletions": 28, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=e12711540a00ded4021250f7b2a31773fc4dc734", "patch": "@@ -619,6 +619,14 @@ fn trans_rvalue_datum_unadjusted<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n             return tvec::trans_uniq_or_managed_vstore(bcx, heap,\n                                                       expr, contents);\n         }\n+        ast::ExprBox(_, contents) => {\n+            // Special case for `~T`. (The other case, for GC, is handled in\n+            // `trans_rvalue_dps_unadjusted`.)\n+            let box_ty = expr_ty(bcx, expr);\n+            let contents_ty = expr_ty(bcx, contents);\n+            let heap = heap_for_unique(bcx, contents_ty);\n+            return trans_boxed_expr(bcx, box_ty, contents, contents_ty, heap)\n+        }\n         ast::ExprLit(lit) => {\n             return trans_immediate_lit(bcx, expr, *lit);\n         }\n@@ -828,6 +836,11 @@ fn trans_rvalue_dps_unadjusted<'a>(\n         ast::ExprAssignOp(callee_id, op, dst, src) => {\n             return trans_assign_op(bcx, expr, callee_id, op, dst, src);\n         }\n+        ast::ExprBox(_, contents) => {\n+            // Special case for `Gc<T>` for now. The other case, for unique\n+            // pointers, is handled in `trans_rvalue_datum_unadjusted`.\n+            return trans_gc(bcx, expr, contents, dest)\n+        }\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n@@ -1463,35 +1476,35 @@ fn trans_unary_datum<'a>(\n                             trans_unary_datum()\")\n         }\n     };\n+}\n \n-    fn trans_boxed_expr<'a>(\n-                        bcx: &'a Block<'a>,\n-                        box_ty: ty::t,\n-                        contents: &ast::Expr,\n-                        contents_ty: ty::t,\n-                        heap: heap)\n-                        -> DatumBlock<'a> {\n-        let _icx = push_ctxt(\"trans_boxed_expr\");\n-        if heap == heap_exchange {\n-            let llty = type_of::type_of(bcx.ccx(), contents_ty);\n-            let size = llsize_of(bcx.ccx(), llty);\n-            let Result { bcx: bcx, val: val } = malloc_raw_dyn(bcx, contents_ty,\n-                                                               heap_exchange, size);\n-            add_clean_free(bcx, val, heap_exchange);\n-            let bcx = trans_into(bcx, contents, SaveIn(val));\n-            revoke_clean(bcx, val);\n-            return immediate_rvalue_bcx(bcx, val, box_ty);\n-        } else {\n-            let base::MallocResult {\n-                bcx,\n-                smart_ptr: bx,\n-                body\n-            } = base::malloc_general(bcx, contents_ty, heap);\n-            add_clean_free(bcx, bx, heap);\n-            let bcx = trans_into(bcx, contents, SaveIn(body));\n-            revoke_clean(bcx, bx);\n-            return immediate_rvalue_bcx(bcx, bx, box_ty);\n-        }\n+fn trans_boxed_expr<'a>(\n+                    bcx: &'a Block<'a>,\n+                    box_ty: ty::t,\n+                    contents: &ast::Expr,\n+                    contents_ty: ty::t,\n+                    heap: heap)\n+                    -> DatumBlock<'a> {\n+    let _icx = push_ctxt(\"trans_boxed_expr\");\n+    if heap == heap_exchange {\n+        let llty = type_of::type_of(bcx.ccx(), contents_ty);\n+        let size = llsize_of(bcx.ccx(), llty);\n+        let Result { bcx: bcx, val: val } = malloc_raw_dyn(bcx, contents_ty,\n+                                                           heap_exchange, size);\n+        add_clean_free(bcx, val, heap_exchange);\n+        let bcx = trans_into(bcx, contents, SaveIn(val));\n+        revoke_clean(bcx, val);\n+        return immediate_rvalue_bcx(bcx, val, box_ty);\n+    } else {\n+        let base::MallocResult {\n+            bcx,\n+            smart_ptr: bx,\n+            body\n+        } = base::malloc_general(bcx, contents_ty, heap);\n+        add_clean_free(bcx, bx, heap);\n+        let bcx = trans_into(bcx, contents, SaveIn(body));\n+        revoke_clean(bcx, bx);\n+        return immediate_rvalue_bcx(bcx, bx, box_ty);\n     }\n }\n \n@@ -1507,6 +1520,42 @@ fn trans_addr_of<'a>(\n     return immediate_rvalue_bcx(bcx, llval, expr_ty(bcx, expr));\n }\n \n+pub fn trans_gc<'a>(\n+                mut bcx: &'a Block<'a>,\n+                expr: &ast::Expr,\n+                contents: &ast::Expr,\n+                dest: Dest)\n+                -> &'a Block<'a> {\n+    let contents_ty = expr_ty(bcx, contents);\n+    let box_ty = ty::mk_box(bcx.tcx(), contents_ty);\n+    let expr_ty = expr_ty(bcx, expr);\n+\n+    let addr = match dest {\n+        Ignore => {\n+            return trans_boxed_expr(bcx,\n+                                    box_ty,\n+                                    contents,\n+                                    contents_ty,\n+                                    heap_managed).bcx\n+        }\n+        SaveIn(addr) => addr,\n+    };\n+\n+    let repr = adt::represent_type(bcx.ccx(), expr_ty);\n+    adt::trans_start_init(bcx, repr, addr, 0);\n+    let field_dest = adt::trans_field_ptr(bcx, repr, addr, 0, 0);\n+    let contents_datum_block = trans_boxed_expr(bcx,\n+                                                box_ty,\n+                                                contents,\n+                                                contents_ty,\n+                                                heap_managed);\n+    bcx = contents_datum_block.bcx;\n+    bcx = contents_datum_block.datum.move_to(bcx, INIT, field_dest);\n+\n+    // Next, wrap it up in the struct.\n+    bcx\n+}\n+\n // Important to get types for both lhs and rhs, because one might be _|_\n // and the other not.\n fn trans_eager_binop<'a>("}, {"sha": "ba7d9642ad9d28b3adfe413bfd40a15d83807ca7", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=e12711540a00ded4021250f7b2a31773fc4dc734", "patch": "@@ -13,8 +13,8 @@ use back::abi;\n use lib;\n use lib::llvm::{llvm, ValueRef};\n use middle::lang_items::StrDupUniqFnLangItem;\n-use middle::trans::base;\n use middle::trans::base::*;\n+use middle::trans::base;\n use middle::trans::build::*;\n use middle::trans::callee;\n use middle::trans::common::*;\n@@ -23,14 +23,12 @@ use middle::trans::expr::{Dest, Ignore, SaveIn};\n use middle::trans::expr;\n use middle::trans::glue;\n use middle::trans::machine::{llsize_of, nonzero_llsize_of, llsize_of_alloc};\n+use middle::trans::type_::Type;\n use middle::trans::type_of;\n use middle::ty;\n use util::common::indenter;\n use util::ppaux::ty_to_str;\n \n-use middle::trans::type_::Type;\n-\n-use std::option::None;\n use syntax::ast;\n use syntax::codemap;\n \n@@ -689,3 +687,4 @@ pub fn iter_vec_unboxed<'r,\n     let dataptr = get_dataptr(bcx, body_ptr);\n     return iter_vec_raw(bcx, dataptr, vec_ty, fill, f);\n }\n+"}, {"sha": "34351ebc09b95b85318ed959521435ba71dceca9", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e12711540a00ded4021250f7b2a31773fc4dc734", "patch": "@@ -12,8 +12,8 @@ use driver::session;\n use metadata::csearch;\n use metadata;\n use middle::const_eval;\n+use middle::lang_items::{ExchangeHeapLangItem, OpaqueStructLangItem};\n use middle::lang_items::{TyDescStructLangItem, TyVisitorTraitLangItem};\n-use middle::lang_items::OpaqueStructLangItem;\n use middle::freevars;\n use middle::resolve;\n use middle::resolve_lifetime;\n@@ -3241,6 +3241,20 @@ pub fn expr_kind(tcx: ctxt,\n             RvalueDatumExpr\n         }\n \n+        ast::ExprBox(place, _) => {\n+            // Special case `~T` for now:\n+            let def_map = tcx.def_map.borrow();\n+            let definition = match def_map.get().find(&place.id) {\n+                Some(&def) => def,\n+                None => fail!(\"no def for place\"),\n+            };\n+            let def_id = ast_util::def_id_of_def(definition);\n+            match tcx.lang_items.items[ExchangeHeapLangItem as uint] {\n+                Some(item_def_id) if def_id == item_def_id => RvalueDatumExpr,\n+                Some(_) | None => RvalueDpsExpr,\n+            }\n+        }\n+\n         ast::ExprParen(e) => expr_kind(tcx, method_map, e),\n \n         ast::ExprMac(..) => {"}, {"sha": "cf7fe77f7b64969d240c780fdad149426ab7dfd8", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 70, "deletions": 1, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=e12711540a00ded4021250f7b2a31773fc4dc734", "patch": "@@ -78,9 +78,11 @@ type parameter).\n \n \n use middle::const_eval;\n+use middle::lang_items::{ExchangeHeapLangItem, GcLangItem};\n+use middle::lang_items::{ManagedHeapLangItem};\n+use middle::lint::unreachable_code;\n use middle::pat_util::pat_id_map;\n use middle::pat_util;\n-use middle::lint::unreachable_code;\n use middle::subst::Subst;\n use middle::ty::{FnSig, VariantInfo};\n use middle::ty::{ty_param_bounds_and_ty, ty_param_substs_and_ty};\n@@ -2679,6 +2681,73 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         fcx.write_ty(id, typ);\n       }\n \n+      ast::ExprBox(place, subexpr) => {\n+          check_expr(fcx, place);\n+          check_expr(fcx, subexpr);\n+\n+          let mut checked = false;\n+          match place.node {\n+              ast::ExprPath(ref path) => {\n+                  // XXX(pcwalton): For now we hardcode the two permissible\n+                  // places: the exchange heap and the managed heap.\n+                  let definition = lookup_def(fcx, path.span, place.id);\n+                  let def_id = ast_util::def_id_of_def(definition);\n+                  match tcx.lang_items.items[ExchangeHeapLangItem as uint] {\n+                      Some(item_def_id) if def_id == item_def_id => {\n+                          fcx.write_ty(id, ty::mk_uniq(tcx, ty::mt {\n+                              ty: fcx.expr_ty(subexpr),\n+                              mutbl: ast::MutImmutable,\n+                          }));\n+                          checked = true\n+                      }\n+                      Some(_) | None => {}\n+                  }\n+                  if !checked {\n+                      match tcx.lang_items\n+                               .items[ManagedHeapLangItem as uint] {\n+                          Some(item_def_id) if def_id == item_def_id => {\n+                              // Assign the magic `Gc<T>` struct.\n+                              let gc_struct_id =\n+                                  match tcx.lang_items\n+                                           .require(GcLangItem) {\n+                                      Ok(id) => id,\n+                                      Err(msg) => {\n+                                          tcx.sess.span_err(expr.span, msg);\n+                                          ast::DefId {\n+                                              crate: ast::CRATE_NODE_ID,\n+                                              node: ast::DUMMY_NODE_ID,\n+                                          }\n+                                      }\n+                                  };\n+                              let regions =\n+                                  ty::NonerasedRegions(opt_vec::Empty);\n+                              let sty = ty::mk_struct(tcx,\n+                                                      gc_struct_id,\n+                                                      substs {\n+                                                        self_ty: None,\n+                                                        tps: ~[\n+                                                            fcx.expr_ty(\n+                                                                subexpr)\n+                                                        ],\n+                                                        regions: regions,\n+                                                      });\n+                              fcx.write_ty(id, sty);\n+                              checked = true\n+                          }\n+                          Some(_) | None => {}\n+                      }\n+                  }\n+              }\n+              _ => {}\n+          }\n+\n+          if !checked {\n+              tcx.sess.span_err(expr.span,\n+                                \"only the managed heap and exchange heap are \\\n+                                 currently supported\")\n+          }\n+      }\n+\n       ast::ExprLit(lit) => {\n         let typ = check_lit(fcx, lit);\n         fcx.write_ty(id, typ);"}, {"sha": "aea5111edee3d1356883d5c70517eda675afa22d", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=e12711540a00ded4021250f7b2a31773fc4dc734", "patch": "@@ -1048,6 +1048,7 @@ pub mod guarantor {\n             ast::ExprAddrOf(..) |\n             ast::ExprBinary(..) |\n             ast::ExprVstore(..) |\n+            ast::ExprBox(..) |\n             ast::ExprBreak(..) |\n             ast::ExprAgain(..) |\n             ast::ExprRet(..) |"}, {"sha": "4cbecc9b42f851e4cda79c97b733fe1255e870fb", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=e12711540a00ded4021250f7b2a31773fc4dc734", "patch": "@@ -21,6 +21,14 @@ use clone::{Clone, DeepClone};\n use managed;\n \n /// Immutable garbage-collected pointer type\n+#[lang=\"gc\"]\n+#[cfg(not(test))]\n+#[no_send]\n+pub struct Gc<T> {\n+    priv ptr: @T\n+}\n+\n+#[cfg(test)]\n #[no_send]\n pub struct Gc<T> {\n     priv ptr: @T\n@@ -54,6 +62,16 @@ impl<T> Clone for Gc<T> {\n     }\n }\n \n+/// An value that represents the task-local managed heap.\n+///\n+/// Use this like `let foo = box(GC) Bar::new(...);`\n+#[lang=\"managed_heap\"]\n+#[cfg(not(test))]\n+pub static GC: () = ();\n+\n+#[cfg(test)]\n+pub static GC: () = ();\n+\n /// The `Send` bound restricts this to acyclic graphs where it is well-defined.\n ///\n /// A `Freeze` bound would also work, but `Send` *or* `Freeze` cannot be expressed."}, {"sha": "dc8ea34c84bd395ee7b1b5661fdd7798886419a5", "filename": "src/libstd/owned.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibstd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibstd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fowned.rs?ref=e12711540a00ded4021250f7b2a31773fc4dc734", "patch": "@@ -12,6 +12,20 @@\n \n #[cfg(not(test))] use cmp::*;\n \n+/// A value that represents the global exchange heap. This is the default\n+/// place that the `box` keyword allocates into when no place is supplied.\n+///\n+/// The following two examples are equivalent:\n+///\n+///     let foo = box(HEAP) Bar::new(...);\n+///     let foo = box Bar::new(...);\n+#[lang=\"exchange_heap\"]\n+#[cfg(not(test))]\n+pub static HEAP: () = ();\n+\n+#[cfg(test)]\n+pub static HEAP: () = ();\n+\n #[cfg(not(test))]\n impl<T:Eq> Eq for ~T {\n     #[inline]"}, {"sha": "36bcc81c06de975d57d6db5e7c8d024ad424cb69", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=e12711540a00ded4021250f7b2a31773fc4dc734", "patch": "@@ -86,6 +86,10 @@ pub use vec::{Vector, VectorVector, CopyableVector, ImmutableVector};\n pub use comm::{Port, Chan, SharedChan};\n pub use task::spawn;\n \n+// Reexported statics\n+#[cfg(not(test))]\n+pub use gc::GC;\n+\n /// Disposes of a value.\n #[inline]\n pub fn drop<T>(_x: T) { }"}, {"sha": "bdc5c375bc4451c0835cae29dff310b31b24727c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e12711540a00ded4021250f7b2a31773fc4dc734", "patch": "@@ -547,6 +547,8 @@ pub enum CallSugar {\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum Expr_ {\n     ExprVstore(@Expr, ExprVstore),\n+    // First expr is the place; second expr is the value.\n+    ExprBox(@Expr, @Expr),\n     ExprVec(~[@Expr], Mutability),\n     ExprCall(@Expr, ~[@Expr], CallSugar),\n     ExprMethodCall(NodeId, @Expr, Ident, ~[P<Ty>], ~[@Expr], CallSugar),"}, {"sha": "a681de65c7ab705543598ad280fcb92d54469f1d", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=e12711540a00ded4021250f7b2a31773fc4dc734", "patch": "@@ -724,6 +724,9 @@ pub fn noop_fold_expr<T: ast_fold>(e: @Expr, folder: &mut T) -> @Expr {\n         ExprVstore(e, v) => {\n             ExprVstore(folder.fold_expr(e), v)\n         }\n+        ExprBox(p, e) => {\n+            ExprBox(folder.fold_expr(p), folder.fold_expr(e))\n+        }\n         ExprVec(ref exprs, mutt) => {\n             ExprVec(exprs.map(|&x| folder.fold_expr(x)), mutt)\n         }"}, {"sha": "0847167267d560fb307c2bcf177f4fb4b8e6ae63", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e12711540a00ded4021250f7b2a31773fc4dc734", "patch": "@@ -23,7 +23,7 @@ use ast::{BlockCheckMode, UnBox};\n use ast::{Crate, CrateConfig, Decl, DeclItem};\n use ast::{DeclLocal, DefaultBlock, UnDeref, BiDiv, EMPTY_CTXT, enum_def, explicit_self};\n use ast::{Expr, Expr_, ExprAddrOf, ExprMatch, ExprAgain};\n-use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock};\n+use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock, ExprBox};\n use ast::{ExprBreak, ExprCall, ExprCast, ExprDoBody};\n use ast::{ExprField, ExprFnBlock, ExprIf, ExprIndex};\n use ast::{ExprLit, ExprLogLevel, ExprLoop, ExprMac};\n@@ -2325,6 +2325,20 @@ impl Parser {\n           token::IDENT(_, _) if self.is_keyword(keywords::Box) => {\n             self.bump();\n \n+            // Check for a place: `box(PLACE) EXPR`.\n+            if self.eat(&token::LPAREN) {\n+                // Support `box() EXPR` as the default.\n+                if !self.eat(&token::RPAREN) {\n+                    let place = self.parse_expr();\n+                    self.expect(&token::RPAREN);\n+                    let subexpression = self.parse_prefix_expr();\n+                    hi = subexpression.span.hi;\n+                    ex = ExprBox(place, subexpression);\n+                    return self.mk_expr(lo, hi, ex);\n+                }\n+            }\n+\n+            // Otherwise, we use the unique pointer default.\n             let subexpression = self.parse_prefix_expr();\n             hi = subexpression.span.hi;\n             // HACK: turn `box [...]` into a boxed-evec"}, {"sha": "f8b7720da7ba14eff519de4593f9ccfff3ec4716", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e12711540a00ded4021250f7b2a31773fc4dc734", "patch": "@@ -1155,6 +1155,13 @@ pub fn print_expr(s: &mut ps, expr: &ast::Expr) {\n             print_expr_vstore(s, v);\n             print_expr(s, e);\n         },\n+        ast::ExprBox(p, e) => {\n+            word(&mut s.s, \"box\");\n+            word(&mut s.s, \"(\");\n+            print_expr(s, p);\n+            word_space(s, \")\");\n+            print_expr(s, e);\n+        }\n       ast::ExprVec(ref exprs, mutbl) => {\n         ibox(s, indent_unit);\n         word(&mut s.s, \"[\");"}, {"sha": "b67e2e7d9fa1952c5624535f21cf7ec7d9c1d708", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=e12711540a00ded4021250f7b2a31773fc4dc734", "patch": "@@ -618,6 +618,10 @@ pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, en\n         ExprVstore(subexpression, _) => {\n             visitor.visit_expr(subexpression, env.clone())\n         }\n+        ExprBox(place, subexpression) => {\n+            visitor.visit_expr(place, env.clone());\n+            visitor.visit_expr(subexpression, env.clone())\n+        }\n         ExprVec(ref subexpressions, _) => {\n             walk_exprs(visitor, *subexpressions, env.clone())\n         }"}, {"sha": "942c862120792e1bd443e60282019794757c1479", "filename": "src/test/compile-fail/new-box-syntax-bad.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Ftest%2Fcompile-fail%2Fnew-box-syntax-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Ftest%2Fcompile-fail%2Fnew-box-syntax-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnew-box-syntax-bad.rs?ref=e12711540a00ded4021250f7b2a31773fc4dc734", "patch": "@@ -0,0 +1,14 @@\n+/* Any copyright is dedicated to the Public Domain.\n+ * http://creativecommons.org/publicdomain/zero/1.0/ */\n+\n+// Tests that the new `box` syntax works with unique pointers and GC pointers.\n+\n+use std::gc::Gc;\n+use std::owned::HEAP;\n+\n+pub fn main() {\n+    let x: Gc<int> = box(HEAP) 2;  //~ ERROR mismatched types\n+    let y: Gc<int> = box(HEAP)(1 + 2);  //~ ERROR mismatched types\n+    let z: ~int = box(GC)(4 + 5);   //~ ERROR mismatched types\n+}\n+"}, {"sha": "d237c4d9a4e8530d61950e2b81114d98b8fac779", "filename": "src/test/run-pass/new-box-syntax.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Ftest%2Frun-pass%2Fnew-box-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12711540a00ded4021250f7b2a31773fc4dc734/src%2Ftest%2Frun-pass%2Fnew-box-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-box-syntax.rs?ref=e12711540a00ded4021250f7b2a31773fc4dc734", "patch": "@@ -1,8 +1,26 @@\n /* Any copyright is dedicated to the Public Domain.\n  * http://creativecommons.org/publicdomain/zero/1.0/ */\n \n+// Tests that the new `box` syntax works with unique pointers and GC pointers.\n+\n+use std::gc::Gc;\n+use std::owned::HEAP;\n+\n+struct Structure {\n+    x: int,\n+    y: int,\n+}\n+\n pub fn main() {\n-    let x: ~int = box 3;\n-    println!(\"{}\", *x);\n+    let x: ~int = box(HEAP) 2;\n+    let y: ~int = box 2;\n+    let z: Gc<int> = box(GC) 2;\n+    let a: Gc<Structure> = box(GC) Structure {\n+        x: 10,\n+        y: 20,\n+    };\n+    let b: ~int = box()(1 + 2);\n+    let c = box()(3 + 4);\n+    let d = box(GC)(5 + 6);\n }\n "}]}