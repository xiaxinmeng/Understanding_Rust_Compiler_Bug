{"sha": "1b00f0b9fa92daa489510b8718ce56130420795f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiMDBmMGI5ZmE5MmRhYTQ4OTUxMGI4NzE4Y2U1NjEzMDQyMDc5NWY=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2018-09-19T00:50:32Z"}, "committer": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2018-09-19T22:01:19Z"}, "message": "Remove spawning from task::Context", "tree": {"sha": "743335040381725afe8a7f702a038b9608cbbcdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/743335040381725afe8a7f702a038b9608cbbcdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b00f0b9fa92daa489510b8718ce56130420795f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b00f0b9fa92daa489510b8718ce56130420795f", "html_url": "https://github.com/rust-lang/rust/commit/1b00f0b9fa92daa489510b8718ce56130420795f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b00f0b9fa92daa489510b8718ce56130420795f/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20dc0c50704ba1fc8c56a88ae2bf05ddb3e419bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/20dc0c50704ba1fc8c56a88ae2bf05ddb3e419bc", "html_url": "https://github.com/rust-lang/rust/commit/20dc0c50704ba1fc8c56a88ae2bf05ddb3e419bc"}], "stats": {"total": 661, "additions": 93, "deletions": 568}, "files": [{"sha": "d4cca387f0689ae43135f7c678a7e3580ef001d9", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 4, "deletions": 67, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/1b00f0b9fa92daa489510b8718ce56130420795f/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b00f0b9fa92daa489510b8718ce56130420795f/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=1b00f0b9fa92daa489510b8718ce56130420795f", "patch": "@@ -60,15 +60,15 @@ use core::borrow;\n use core::cmp::Ordering;\n use core::convert::From;\n use core::fmt;\n-use core::future::{Future, FutureObj, LocalFutureObj, UnsafeFutureObj};\n+use core::future::Future;\n use core::hash::{Hash, Hasher};\n use core::iter::FusedIterator;\n use core::marker::{Unpin, Unsize};\n use core::mem;\n use core::pin::Pin;\n use core::ops::{CoerceUnsized, Deref, DerefMut, Generator, GeneratorState};\n use core::ptr::{self, NonNull, Unique};\n-use core::task::{Context, Poll, Spawn, SpawnErrorKind, SpawnObjError};\n+use core::task::{LocalWaker, Poll};\n \n use raw_vec::RawVec;\n use str::from_boxed_utf8_unchecked;\n@@ -804,70 +804,7 @@ impl<T> Generator for Box<T>\n impl<F: ?Sized + Future + Unpin> Future for Box<F> {\n     type Output = F::Output;\n \n-    fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n-        F::poll(Pin::new(&mut *self), cx)\n-    }\n-}\n-\n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n-unsafe impl<'a, T, F> UnsafeFutureObj<'a, T> for Box<F>\n-    where F: Future<Output = T> + 'a\n-{\n-    fn into_raw(self) -> *mut () {\n-        Box::into_raw(self) as *mut ()\n-    }\n-\n-    unsafe fn poll(ptr: *mut (), cx: &mut Context) -> Poll<T> {\n-        let ptr = ptr as *mut F;\n-        let pin: Pin<&mut F> = Pin::new_unchecked(&mut *ptr);\n-        F::poll(pin, cx)\n-    }\n-\n-    unsafe fn drop(ptr: *mut ()) {\n-        drop(Box::from_raw(ptr as *mut F))\n-    }\n-}\n-\n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n-impl<Sp> Spawn for Box<Sp>\n-    where Sp: Spawn + ?Sized\n-{\n-    fn spawn_obj(\n-        &mut self,\n-        future: FutureObj<'static, ()>,\n-    ) -> Result<(), SpawnObjError> {\n-        (**self).spawn_obj(future)\n-    }\n-\n-    fn status(&self) -> Result<(), SpawnErrorKind> {\n-        (**self).status()\n-    }\n-}\n-\n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n-impl<'a, F: Future<Output = ()> + Send + 'a> From<Box<F>> for FutureObj<'a, ()> {\n-    fn from(boxed: Box<F>) -> Self {\n-        FutureObj::new(boxed)\n-    }\n-}\n-\n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n-impl<'a, F: Future<Output = ()> + 'a> From<Box<F>> for LocalFutureObj<'a, ()> {\n-    fn from(boxed: Box<F>) -> Self {\n-        LocalFutureObj::new(boxed)\n-    }\n-}\n-\n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n-impl<'a, F: Future<Output = ()> + Send + 'a> From<Pin<Box<F>>> for FutureObj<'a, ()> {\n-    fn from(boxed: Pin<Box<F>>) -> Self {\n-        FutureObj::new(boxed)\n-    }\n-}\n-\n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n-impl<'a, F: Future<Output = ()> + 'a> From<Pin<Box<F>>> for LocalFutureObj<'a, ()> {\n-    fn from(boxed: Pin<Box<F>>) -> Self {\n-        LocalFutureObj::new(boxed)\n+    fn poll(mut self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n+        F::poll(Pin::new(&mut *self), lw)\n     }\n }"}, {"sha": "9176e0d32cbf2703c8a7d656614080caf6c8a320", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1b00f0b9fa92daa489510b8718ce56130420795f/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b00f0b9fa92daa489510b8718ce56130420795f/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=1b00f0b9fa92daa489510b8718ce56130420795f", "patch": "@@ -15,7 +15,7 @@\n use marker::Unpin;\n use ops;\n use pin::Pin;\n-use task::{self, Poll};\n+use task::{Poll, LocalWaker};\n \n /// A future represents an asychronous computation.\n ///\n@@ -50,28 +50,28 @@ pub trait Future {\n     ///\n     /// Once a future has finished, clients should not `poll` it again.\n     ///\n-    /// When a future is not ready yet, `poll` returns\n-    /// `Poll::Pending`. The future will *also* register the\n-    /// interest of the current task in the value being produced. For example,\n-    /// if the future represents the availability of data on a socket, then the\n-    /// task is recorded so that when data arrives, it is woken up (via\n-    /// [`cx.waker()`]). Once a task has been woken up,\n-    /// it should attempt to `poll` the future again, which may or may not\n-    /// produce a final value.\n+    /// When a future is not ready yet, `poll` returns `Poll::Pending` and\n+    /// stores a clone of the [`LocalWaker`] to be woken once the future can\n+    /// make progress. For example, a future waiting for a socket to become\n+    /// readable would call `.clone()` on the [`LocalWaker`] and store it.\n+    /// When a signal arrives elsewhere indicating that the socket is readable,\n+    /// `[LocalWaker::wake]` is called and the socket future's task is awoken.\n+    /// Once a task has been woken up, it should attempt to `poll` the future\n+    /// again, which may or may not produce a final value.\n     ///\n-    /// Note that if `Pending` is returned it only means that the *current* task\n-    /// (represented by the argument `cx`) will receive a notification. Tasks\n-    /// from previous calls to `poll` will *not* receive notifications.\n+    /// Note that on multiple calls to `poll`, only the most recent\n+    /// [`LocalWaker`] passed to `poll` should be scheduled to receive a\n+    /// wakeup.\n     ///\n     /// # Runtime characteristics\n     ///\n     /// Futures alone are *inert*; they must be *actively* `poll`ed to make\n     /// progress, meaning that each time the current task is woken up, it should\n     /// actively re-`poll` pending futures that it still has an interest in.\n     ///\n-    /// The `poll` function is not called repeatedly in a tight loop for\n-    /// futures, but only whenever the future itself is ready, as signaled via\n-    /// the `Waker` inside `task::Context`. If you're familiar with the\n+    /// The `poll` function is not called repeatedly in a tight loop-- instead,\n+    /// it should only be called when the future indicates that it is ready to\n+    /// make progress (by calling `wake()`). If you're familiar with the\n     /// `poll(2)` or `select(2)` syscalls on Unix it's worth noting that futures\n     /// typically do *not* suffer the same problems of \"all wakeups must poll\n     /// all events\"; they are more like `epoll(4)`.\n@@ -83,6 +83,16 @@ pub trait Future {\n     /// thread pool (or something similar) to ensure that `poll` can return\n     /// quickly.\n     ///\n+    /// # [`LocalWaker`], [`Waker`] and thread-safety\n+    ///\n+    /// The `poll` function takes a [`LocalWaker`], an object which knows how to\n+    /// awaken the current task. [`LocalWaker`] is not `Send` nor `Sync`, so in\n+    /// order to make thread-safe futures the [`LocalWaker::into_waker`] method\n+    /// should be used to convert the [`LocalWaker`] into a thread-safe version.\n+    /// [`LocalWaker::wake`] implementations have the ability to be more\n+    /// efficient, however, so when thread safety is not necessary,\n+    /// [`LocalWaker`] should be preferred.\n+    ///\n     /// # Panics\n     ///\n     /// Once a future has completed (returned `Ready` from `poll`),\n@@ -92,15 +102,18 @@ pub trait Future {\n     ///\n     /// [`Poll::Pending`]: ../task/enum.Poll.html#variant.Pending\n     /// [`Poll::Ready(val)`]: ../task/enum.Poll.html#variant.Ready\n-    /// [`cx.waker()`]: ../task/struct.Context.html#method.waker\n-    fn poll(self: Pin<&mut Self>, cx: &mut task::Context) -> Poll<Self::Output>;\n+    /// [`LocalWaker`]: ../task/struct.LocalWaker.html\n+    /// [`LocalWaker::into_waker`]: ../task/struct.LocalWaker.html#method.into_waker\n+    /// [`LocalWaker::wake`]: ../task/struct.LocalWaker.html#method.wake\n+    /// [`Waker`]: ../task/struct.Waker.html\n+    fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output>;\n }\n \n impl<'a, F: ?Sized + Future + Unpin> Future for &'a mut F {\n     type Output = F::Output;\n \n-    fn poll(mut self: Pin<&mut Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n-        F::poll(Pin::new(&mut **self), cx)\n+    fn poll(mut self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n+        F::poll(Pin::new(&mut **self), lw)\n     }\n }\n \n@@ -111,7 +124,7 @@ where\n {\n     type Output = <<P as ops::Deref>::Target as Future>::Output;\n \n-    fn poll(self: Pin<&mut Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n-        Pin::get_mut(self).as_mut().poll(cx)\n+    fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n+        Pin::get_mut(self).as_mut().poll(lw)\n     }\n }"}, {"sha": "b335cac6c1d8ca4ca832412a225ee3fd23bd8c08", "filename": "src/libcore/future/future_obj.rs", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/20dc0c50704ba1fc8c56a88ae2bf05ddb3e419bc/src%2Flibcore%2Ffuture%2Ffuture_obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20dc0c50704ba1fc8c56a88ae2bf05ddb3e419bc/src%2Flibcore%2Ffuture%2Ffuture_obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture_obj.rs?ref=20dc0c50704ba1fc8c56a88ae2bf05ddb3e419bc", "patch": "@@ -1,203 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![unstable(feature = \"futures_api\",\n-            reason = \"futures in libcore are unstable\",\n-            issue = \"50547\")]\n-\n-use fmt;\n-use future::Future;\n-use marker::{PhantomData, Unpin};\n-use ops;\n-use pin::Pin;\n-use task::{Context, Poll};\n-\n-/// A custom trait object for polling futures, roughly akin to\n-/// `Box<dyn Future<Output = T> + 'a>`.\n-///\n-/// This custom trait object was introduced for two reasons:\n-/// - Currently it is not possible to take `dyn Trait` by value and\n-///   `Box<dyn Trait>` is not available in no_std contexts.\n-/// - The `Future` trait is currently not object safe: The `Future::poll`\n-///   method makes uses the arbitrary self types feature and traits in which\n-///   this feature is used are currently not object safe due to current compiler\n-///   limitations. (See tracking issue for arbitrary self types for more\n-///   information #44874)\n-pub struct LocalFutureObj<'a, T> {\n-    ptr: *mut (),\n-    poll_fn: unsafe fn(*mut (), &mut Context) -> Poll<T>,\n-    drop_fn: unsafe fn(*mut ()),\n-    _marker: PhantomData<&'a ()>,\n-}\n-\n-impl<'a, T> Unpin for LocalFutureObj<'a, T> {}\n-\n-impl<'a, T> LocalFutureObj<'a, T> {\n-    /// Create a `LocalFutureObj` from a custom trait object representation.\n-    #[inline]\n-    pub fn new<F: UnsafeFutureObj<'a, T> + 'a>(f: F) -> LocalFutureObj<'a, T> {\n-        LocalFutureObj {\n-            ptr: f.into_raw(),\n-            poll_fn: F::poll,\n-            drop_fn: F::drop,\n-            _marker: PhantomData,\n-        }\n-    }\n-\n-    /// Converts the `LocalFutureObj` into a `FutureObj`\n-    /// To make this operation safe one has to ensure that the `UnsafeFutureObj`\n-    /// instance from which this `LocalFutureObj` was created actually\n-    /// implements `Send`.\n-    #[inline]\n-    pub unsafe fn into_future_obj(self) -> FutureObj<'a, T> {\n-        FutureObj(self)\n-    }\n-}\n-\n-impl<'a, T> fmt::Debug for LocalFutureObj<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"LocalFutureObj\")\n-            .finish()\n-    }\n-}\n-\n-impl<'a, T> From<FutureObj<'a, T>> for LocalFutureObj<'a, T> {\n-    #[inline]\n-    fn from(f: FutureObj<'a, T>) -> LocalFutureObj<'a, T> {\n-        f.0\n-    }\n-}\n-\n-impl<'a, T> Future for LocalFutureObj<'a, T> {\n-    type Output = T;\n-\n-    #[inline]\n-    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<T> {\n-        unsafe {\n-            ((*self).poll_fn)((*self).ptr, cx)\n-        }\n-    }\n-}\n-\n-impl<'a, T> Drop for LocalFutureObj<'a, T> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            (self.drop_fn)(self.ptr)\n-        }\n-    }\n-}\n-\n-/// A custom trait object for polling futures, roughly akin to\n-/// `Box<dyn Future<Output = T> + Send + 'a>`.\n-///\n-/// This custom trait object was introduced for two reasons:\n-/// - Currently it is not possible to take `dyn Trait` by value and\n-///   `Box<dyn Trait>` is not available in no_std contexts.\n-/// - The `Future` trait is currently not object safe: The `Future::poll`\n-///   method makes uses the arbitrary self types feature and traits in which\n-///   this feature is used are currently not object safe due to current compiler\n-///   limitations. (See tracking issue for arbitrary self types for more\n-///   information #44874)\n-pub struct FutureObj<'a, T>(LocalFutureObj<'a, T>);\n-\n-impl<'a, T> Unpin for FutureObj<'a, T> {}\n-unsafe impl<'a, T> Send for FutureObj<'a, T> {}\n-\n-impl<'a, T> FutureObj<'a, T> {\n-    /// Create a `FutureObj` from a custom trait object representation.\n-    #[inline]\n-    pub fn new<F: UnsafeFutureObj<'a, T> + Send>(f: F) -> FutureObj<'a, T> {\n-        FutureObj(LocalFutureObj::new(f))\n-    }\n-}\n-\n-impl<'a, T> fmt::Debug for FutureObj<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"FutureObj\")\n-            .finish()\n-    }\n-}\n-\n-impl<'a, T> Future for FutureObj<'a, T> {\n-    type Output = T;\n-\n-    #[inline]\n-    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<T> {\n-        let pinned_field: Pin<&mut LocalFutureObj<'a, T>> = unsafe {\n-            Pin::map_unchecked_mut(self, |x| &mut x.0)\n-        };\n-        LocalFutureObj::poll(pinned_field, cx)\n-    }\n-}\n-\n-/// A custom implementation of a future trait object for `FutureObj`, providing\n-/// a hand-rolled vtable.\n-///\n-/// This custom representation is typically used only in `no_std` contexts,\n-/// where the default `Box`-based implementation is not available.\n-///\n-/// The implementor must guarantee that it is safe to call `poll` repeatedly (in\n-/// a non-concurrent fashion) with the result of `into_raw` until `drop` is\n-/// called.\n-pub unsafe trait UnsafeFutureObj<'a, T>: 'a {\n-    /// Convert an owned instance into a (conceptually owned) void pointer.\n-    fn into_raw(self) -> *mut ();\n-\n-    /// Poll the future represented by the given void pointer.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The trait implementor must guarantee that it is safe to repeatedly call\n-    /// `poll` with the result of `into_raw` until `drop` is called; such calls\n-    /// are not, however, allowed to race with each other or with calls to\n-    /// `drop`.\n-    unsafe fn poll(ptr: *mut (), cx: &mut Context) -> Poll<T>;\n-\n-    /// Drops the future represented by the given void pointer.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The trait implementor must guarantee that it is safe to call this\n-    /// function once per `into_raw` invocation; that call cannot race with\n-    /// other calls to `drop` or `poll`.\n-    unsafe fn drop(ptr: *mut ());\n-}\n-\n-unsafe impl<'a, T, F> UnsafeFutureObj<'a, T> for &'a mut F\n-    where F: Future<Output = T> + Unpin + 'a\n-{\n-    fn into_raw(self) -> *mut () {\n-        self as *mut F as *mut ()\n-    }\n-\n-    unsafe fn poll(ptr: *mut (), cx: &mut Context) -> Poll<T> {\n-        let p: Pin<&mut F> = Pin::new_unchecked(&mut *(ptr as *mut F));\n-        F::poll(p, cx)\n-    }\n-\n-    unsafe fn drop(_ptr: *mut ()) {}\n-}\n-\n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n-unsafe impl<'a, T, P, F> UnsafeFutureObj<'a, T> for Pin<P> where\n-    P: ops::DerefMut<Target = F> + 'a,\n-    F: Future<Output = T> + 'a,\n-{\n-    fn into_raw(mut self) -> *mut () {\n-        unsafe { Pin::get_mut_unchecked(Pin::as_mut(&mut self)) as *mut F as *mut () }\n-    }\n-\n-    unsafe fn poll(ptr: *mut (), cx: &mut Context) -> Poll<T> {\n-        let future: Pin<&mut F> = Pin::new_unchecked(&mut *(ptr as *mut F));\n-        F::poll(future, cx)\n-    }\n-\n-    unsafe fn drop(_ptr: *mut ()) {}\n-}"}, {"sha": "1dc4f361f3adbd558b731e69aba599d8c44add36", "filename": "src/libcore/future/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b00f0b9fa92daa489510b8718ce56130420795f/src%2Flibcore%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b00f0b9fa92daa489510b8718ce56130420795f/src%2Flibcore%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fmod.rs?ref=1b00f0b9fa92daa489510b8718ce56130420795f", "patch": "@@ -16,6 +16,3 @@\n \n mod future;\n pub use self::future::Future;\n-\n-mod future_obj;\n-pub use self::future_obj::{FutureObj, LocalFutureObj, UnsafeFutureObj};"}, {"sha": "5a29c8528ef3a0801c9a467a4f1ec21d5abd267c", "filename": "src/libcore/task/context.rs", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/20dc0c50704ba1fc8c56a88ae2bf05ddb3e419bc/src%2Flibcore%2Ftask%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20dc0c50704ba1fc8c56a88ae2bf05ddb3e419bc/src%2Flibcore%2Ftask%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fcontext.rs?ref=20dc0c50704ba1fc8c56a88ae2bf05ddb3e419bc", "patch": "@@ -1,98 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![unstable(feature = \"futures_api\",\n-            reason = \"futures in libcore are unstable\",\n-            issue = \"50547\")]\n-\n-use fmt;\n-use super::{Spawn, Waker, LocalWaker};\n-\n-/// Information about the currently-running task.\n-///\n-/// Contexts are always tied to the stack, since they are set up specifically\n-/// when performing a single `poll` step on a task.\n-pub struct Context<'a> {\n-    local_waker: &'a LocalWaker,\n-    spawner: &'a mut dyn Spawn,\n-}\n-\n-impl<'a> fmt::Debug for Context<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Context\")\n-            .finish()\n-    }\n-}\n-\n-impl<'a> Context<'a> {\n-    /// Create a new task `Context` with the provided `local_waker`, `waker`,\n-    /// and `spawner`.\n-    #[inline]\n-    pub fn new(\n-        local_waker: &'a LocalWaker,\n-        spawner: &'a mut dyn Spawn,\n-    ) -> Context<'a> {\n-        Context { local_waker, spawner }\n-    }\n-\n-    /// Get the `LocalWaker` associated with the current task.\n-    #[inline]\n-    pub fn local_waker(&self) -> &'a LocalWaker {\n-        self.local_waker\n-    }\n-\n-    /// Get the `Waker` associated with the current task.\n-    #[inline]\n-    pub fn waker(&self) -> &'a Waker {\n-        unsafe { &*(self.local_waker as *const LocalWaker as *const Waker) }\n-    }\n-\n-    /// Get the spawner associated with this task.\n-    ///\n-    /// This method is useful primarily if you want to explicitly handle\n-    /// spawn failures.\n-    #[inline]\n-    pub fn spawner(&mut self) -> &mut dyn Spawn {\n-        self.spawner\n-    }\n-\n-    /// Produce a context like the current one, but using the given waker\n-    /// instead.\n-    ///\n-    /// This advanced method is primarily used when building \"internal\n-    /// schedulers\" within a task, where you want to provide some customized\n-    /// wakeup logic.\n-    #[inline]\n-    pub fn with_waker<'b>(\n-        &'b mut self,\n-        local_waker: &'b LocalWaker,\n-    ) -> Context<'b> {\n-        Context {\n-            local_waker,\n-            spawner: self.spawner,\n-        }\n-    }\n-\n-    /// Produce a context like the current one, but using the given spawner\n-    /// instead.\n-    ///\n-    /// This advanced method is primarily used when building \"internal\n-    /// schedulers\" within a task.\n-    #[inline]\n-    pub fn with_spawner<'b, Sp: Spawn>(\n-        &'b mut self,\n-        spawner: &'b mut Sp,\n-    ) -> Context<'b> {\n-        Context {\n-            local_waker: self.local_waker,\n-            spawner,\n-        }\n-    }\n-}"}, {"sha": "95c9cca292f82171d0a11b2f475fd29cdb430cb5", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b00f0b9fa92daa489510b8718ce56130420795f/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b00f0b9fa92daa489510b8718ce56130420795f/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=1b00f0b9fa92daa489510b8718ce56130420795f", "patch": "@@ -14,12 +14,6 @@\n \n //! Types and Traits for working with asynchronous tasks.\n \n-mod context;\n-pub use self::context::Context;\n-\n-mod spawn;\n-pub use self::spawn::{Spawn, SpawnErrorKind, SpawnObjError, SpawnLocalObjError};\n-\n mod poll;\n pub use self::poll::Poll;\n "}, {"sha": "58ee85d232bc48a0f8a179baf00eef75d50f172b", "filename": "src/libcore/task/spawn.rs", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/20dc0c50704ba1fc8c56a88ae2bf05ddb3e419bc/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20dc0c50704ba1fc8c56a88ae2bf05ddb3e419bc/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=20dc0c50704ba1fc8c56a88ae2bf05ddb3e419bc", "patch": "@@ -1,93 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![unstable(feature = \"futures_api\",\n-            reason = \"futures in libcore are unstable\",\n-            issue = \"50547\")]\n-\n-use fmt;\n-use future::{FutureObj, LocalFutureObj};\n-\n-/// Spawns tasks that poll futures to completion onto its associated task\n-/// executor.\n-///\n-/// The term \"task\" refers to a kind of lightweight \"thread\". Task executors\n-/// are responsible for scheduling the execution of tasks on operating system\n-/// threads.\n-pub trait Spawn {\n-    /// Spawns a new task with the given future. The future will be polled until\n-    /// completion.\n-    ///\n-    /// # Errors\n-    ///\n-    /// The executor may be unable to spawn tasks, either because it has\n-    /// been shut down or is resource-constrained.\n-    fn spawn_obj(\n-        &mut self,\n-        future: FutureObj<'static, ()>,\n-    ) -> Result<(), SpawnObjError>;\n-\n-    /// Determines whether the executor is able to spawn new tasks.\n-    ///\n-    /// # Returns\n-    ///\n-    /// An `Ok` return means the executor is *likely* (but not guaranteed)\n-    /// to accept a subsequent spawn attempt. Likewise, an `Err` return\n-    /// means that `spawn` is likely, but not guaranteed, to yield an error.\n-    #[inline]\n-    fn status(&self) -> Result<(), SpawnErrorKind> {\n-        Ok(())\n-    }\n-}\n-\n-/// Provides the reason that an executor was unable to spawn.\n-pub struct SpawnErrorKind {\n-    _hidden: (),\n-}\n-\n-impl fmt::Debug for SpawnErrorKind {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"SpawnErrorKind\")\n-            .field(&\"shutdown\")\n-            .finish()\n-    }\n-}\n-\n-impl SpawnErrorKind {\n-    /// Spawning is failing because the executor has been shut down.\n-    pub fn shutdown() -> SpawnErrorKind {\n-        SpawnErrorKind { _hidden: () }\n-    }\n-\n-    /// Check whether this error is the `shutdown` error.\n-    pub fn is_shutdown(&self) -> bool {\n-        true\n-    }\n-}\n-\n-/// The result of a failed spawn\n-#[derive(Debug)]\n-pub struct SpawnObjError {\n-    /// The kind of error\n-    pub kind: SpawnErrorKind,\n-\n-    /// The future for which spawning inside a task was attempted\n-    pub future: FutureObj<'static, ()>,\n-}\n-\n-/// The result of a failed spawn\n-#[derive(Debug)]\n-pub struct SpawnLocalObjError {\n-    /// The kind of error\n-    pub kind: SpawnErrorKind,\n-\n-    /// The future for which spawning inside a task was attempted\n-    pub future: LocalFutureObj<'static, ()>,\n-}"}, {"sha": "651db6356ba07e93bd727adb9ed81932a3492fc8", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1b00f0b9fa92daa489510b8718ce56130420795f/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b00f0b9fa92daa489510b8718ce56130420795f/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=1b00f0b9fa92daa489510b8718ce56130420795f", "patch": "@@ -123,6 +123,15 @@ impl LocalWaker {\n         LocalWaker { inner }\n     }\n \n+    /// Converts this `LocalWaker` into a `Waker`.\n+    ///\n+    /// `Waker` is nearly identical to `LocalWaker`, but is threadsafe\n+    /// (implements `Send` and `Sync`).\n+    #[inline]\n+    pub fn into_waker(self) -> Waker {\n+        self.into()\n+    }\n+\n     /// Wake up the task associated with this `LocalWaker`.\n     #[inline]\n     pub fn wake(&self) {"}, {"sha": "1cadbdc66c3986e76e0eb30914f1cd80c3e05c8b", "filename": "src/libstd/future.rs", "status": "modified", "additions": 27, "deletions": 32, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/1b00f0b9fa92daa489510b8718ce56130420795f/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b00f0b9fa92daa489510b8718ce56130420795f/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=1b00f0b9fa92daa489510b8718ce56130420795f", "patch": "@@ -15,7 +15,7 @@ use core::marker::Unpin;\n use core::pin::Pin;\n use core::option::Option;\n use core::ptr::NonNull;\n-use core::task::{self, Poll};\n+use core::task::{LocalWaker, Poll};\n use core::ops::{Drop, Generator, GeneratorState};\n \n #[doc(inline)]\n@@ -42,75 +42,70 @@ impl<T: Generator<Yield = ()>> !Unpin for GenFuture<T> {}\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n impl<T: Generator<Yield = ()>> Future for GenFuture<T> {\n     type Output = T::Return;\n-    fn poll(self: Pin<&mut Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n-        set_task_cx(cx, || match unsafe { Pin::get_mut_unchecked(self).0.resume() } {\n+    fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n+        set_task_waker(lw, || match unsafe { Pin::get_mut_unchecked(self).0.resume() } {\n             GeneratorState::Yielded(()) => Poll::Pending,\n             GeneratorState::Complete(x) => Poll::Ready(x),\n         })\n     }\n }\n \n thread_local! {\n-    static TLS_CX: Cell<Option<NonNull<task::Context<'static>>>> = Cell::new(None);\n+    static TLS_WAKER: Cell<Option<NonNull<LocalWaker>>> = Cell::new(None);\n }\n \n-struct SetOnDrop(Option<NonNull<task::Context<'static>>>);\n+struct SetOnDrop(Option<NonNull<LocalWaker>>);\n \n impl Drop for SetOnDrop {\n     fn drop(&mut self) {\n-        TLS_CX.with(|tls_cx| {\n-            tls_cx.set(self.0.take());\n+        TLS_WAKER.with(|tls_waker| {\n+            tls_waker.set(self.0.take());\n         });\n     }\n }\n \n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n /// Sets the thread-local task context used by async/await futures.\n-pub fn set_task_cx<F, R>(cx: &mut task::Context, f: F) -> R\n+pub fn set_task_waker<F, R>(lw: &LocalWaker, f: F) -> R\n where\n     F: FnOnce() -> R\n {\n-    let old_cx = TLS_CX.with(|tls_cx| {\n-        tls_cx.replace(NonNull::new(\n-            cx\n-                as *mut task::Context\n-                as *mut ()\n-                as *mut task::Context<'static>\n-        ))\n+    let old_waker = TLS_WAKER.with(|tls_waker| {\n+        tls_waker.replace(Some(NonNull::from(lw)))\n     });\n-    let _reset_cx = SetOnDrop(old_cx);\n+    let _reset_waker = SetOnDrop(old_waker);\n     f()\n }\n \n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n-/// Retrieves the thread-local task context used by async/await futures.\n+/// Retrieves the thread-local task waker used by async/await futures.\n ///\n-/// This function acquires exclusive access to the task context.\n+/// This function acquires exclusive access to the task waker.\n ///\n-/// Panics if no task has been set or if the task context has already been\n-/// retrieved by a surrounding call to get_task_cx.\n-pub fn get_task_cx<F, R>(f: F) -> R\n+/// Panics if no waker has been set or if the waker has already been\n+/// retrieved by a surrounding call to get_task_waker.\n+pub fn get_task_waker<F, R>(f: F) -> R\n where\n-    F: FnOnce(&mut task::Context) -> R\n+    F: FnOnce(&LocalWaker) -> R\n {\n-    let cx_ptr = TLS_CX.with(|tls_cx| {\n-        // Clear the entry so that nested `with_get_cx` calls\n+    let waker_ptr = TLS_WAKER.with(|tls_waker| {\n+        // Clear the entry so that nested `get_task_waker` calls\n         // will fail or set their own value.\n-        tls_cx.replace(None)\n+        tls_waker.replace(None)\n     });\n-    let _reset_cx = SetOnDrop(cx_ptr);\n+    let _reset_waker = SetOnDrop(waker_ptr);\n \n-    let mut cx_ptr = cx_ptr.expect(\n-        \"TLS task::Context not set. This is a rustc bug. \\\n+    let mut waker_ptr = waker_ptr.expect(\n+        \"TLS LocalWaker not set. This is a rustc bug. \\\n         Please file an issue on https://github.com/rust-lang/rust.\");\n-    unsafe { f(cx_ptr.as_mut()) }\n+    unsafe { f(waker_ptr.as_mut()) }\n }\n \n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n-/// Polls a future in the current thread-local task context.\n-pub fn poll_in_task_cx<F>(f: Pin<&mut F>) -> Poll<F::Output>\n+/// Polls a future in the current thread-local task waker.\n+pub fn poll_with_tls_waker<F>(f: Pin<&mut F>) -> Poll<F::Output>\n where\n     F: Future\n {\n-    get_task_cx(|cx| F::poll(f, cx))\n+    get_task_waker(|lw| F::poll(f, lw))\n }"}, {"sha": "06056d6ed2040c8a0ccc04802a2fff4bc98dc9b9", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b00f0b9fa92daa489510b8718ce56130420795f/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b00f0b9fa92daa489510b8718ce56130420795f/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=1b00f0b9fa92daa489510b8718ce56130420795f", "patch": "@@ -229,7 +229,7 @@ macro_rules! await {\n         let mut pinned = $e;\n         loop {\n             if let $crate::task::Poll::Ready(x) =\n-                $crate::future::poll_in_task_cx(unsafe {\n+                $crate::future::poll_with_tls_waker(unsafe {\n                     $crate::pin::Pin::new_unchecked(&mut pinned)\n                 })\n             {"}, {"sha": "48a9b2f4a93de558e18ca361cd203d46333c1512", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b00f0b9fa92daa489510b8718ce56130420795f/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b00f0b9fa92daa489510b8718ce56130420795f/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=1b00f0b9fa92daa489510b8718ce56130420795f", "patch": "@@ -22,7 +22,7 @@ use panicking;\n use ptr::{Unique, NonNull};\n use rc::Rc;\n use sync::{Arc, Mutex, RwLock, atomic};\n-use task::{self, Poll};\n+use task::{LocalWaker, Poll};\n use thread::Result;\n \n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n@@ -327,9 +327,9 @@ impl<T: fmt::Debug> fmt::Debug for AssertUnwindSafe<T> {\n impl<'a, F: Future> Future for AssertUnwindSafe<F> {\n     type Output = F::Output;\n \n-    fn poll(self: Pin<&mut Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n+    fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n         let pinned_field = unsafe { Pin::map_unchecked_mut(self, |x| &mut x.0) };\n-        F::poll(pinned_field, cx)\n+        F::poll(pinned_field, lw)\n     }\n }\n "}, {"sha": "0cd9bad03af9ffd64dcca66599953b3ea17e0248", "filename": "src/test/run-pass/async-await.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1b00f0b9fa92daa489510b8718ce56130420795f/src%2Ftest%2Frun-pass%2Fasync-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b00f0b9fa92daa489510b8718ce56130420795f/src%2Ftest%2Frun-pass%2Fasync-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasync-await.rs?ref=1b00f0b9fa92daa489510b8718ce56130420795f", "patch": "@@ -18,10 +18,8 @@ use std::sync::{\n     Arc,\n     atomic::{self, AtomicUsize},\n };\n-use std::future::FutureObj;\n use std::task::{\n-    Context, Poll, Wake,\n-    Spawn, SpawnObjError,\n+    LocalWaker, Poll, Wake,\n     local_waker_from_nonlocal,\n };\n \n@@ -35,24 +33,17 @@ impl Wake for Counter {\n     }\n }\n \n-struct NoopSpawner;\n-impl Spawn for NoopSpawner {\n-    fn spawn_obj(&mut self, _: FutureObj<'static, ()>) -> Result<(), SpawnObjError> {\n-        Ok(())\n-    }\n-}\n-\n struct WakeOnceThenComplete(bool);\n \n fn wake_and_yield_once() -> WakeOnceThenComplete { WakeOnceThenComplete(false) }\n \n impl Future for WakeOnceThenComplete {\n     type Output = ();\n-    fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<()> {\n+    fn poll(mut self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<()> {\n         if self.0 {\n             Poll::Ready(())\n         } else {\n-            cx.waker().wake();\n+            lw.wake();\n             self.0 = true;\n             Poll::Pending\n         }\n@@ -150,13 +141,10 @@ where\n     let mut fut = Box::pinned(f(9));\n     let counter = Arc::new(Counter { wakes: AtomicUsize::new(0) });\n     let waker = local_waker_from_nonlocal(counter.clone());\n-    let spawner = &mut NoopSpawner;\n-    let cx = &mut Context::new(&waker, spawner);\n-\n     assert_eq!(0, counter.wakes.load(atomic::Ordering::SeqCst));\n-    assert_eq!(Poll::Pending, fut.as_mut().poll(cx));\n+    assert_eq!(Poll::Pending, fut.as_mut().poll(&waker));\n     assert_eq!(1, counter.wakes.load(atomic::Ordering::SeqCst));\n-    assert_eq!(Poll::Ready(9), fut.as_mut().poll(cx));\n+    assert_eq!(Poll::Ready(9), fut.as_mut().poll(&waker));\n }\n \n fn main() {"}, {"sha": "18865e4a076223d47f7650cd587254b80ef7ebfb", "filename": "src/test/run-pass/futures-api.rs", "status": "modified", "additions": 10, "deletions": 24, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1b00f0b9fa92daa489510b8718ce56130420795f/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b00f0b9fa92daa489510b8718ce56130420795f/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffutures-api.rs?ref=1b00f0b9fa92daa489510b8718ce56130420795f", "patch": "@@ -18,11 +18,8 @@ use std::sync::{\n     Arc,\n     atomic::{self, AtomicUsize},\n };\n-use std::future::FutureObj;\n use std::task::{\n-    Context, Poll,\n-    Wake, Waker, LocalWaker,\n-    Spawn, SpawnObjError,\n+    Poll, Wake, Waker, LocalWaker,\n     local_waker, local_waker_from_nonlocal,\n };\n \n@@ -41,24 +38,17 @@ impl Wake for Counter {\n     }\n }\n \n-struct NoopSpawner;\n-\n-impl Spawn for NoopSpawner {\n-    fn spawn_obj(&mut self, _: FutureObj<'static, ()>) -> Result<(), SpawnObjError> {\n-        Ok(())\n-    }\n-}\n-\n struct MyFuture;\n \n impl Future for MyFuture {\n     type Output = ();\n-    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n-        // Ensure all the methods work appropriately\n-        cx.waker().wake();\n-        cx.waker().wake();\n-        cx.local_waker().wake();\n-        cx.spawner().spawn_obj(Box::pinned(MyFuture).into()).unwrap();\n+    fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n+        // Wake once locally\n+        lw.wake();\n+        // Wake twice non-locally\n+        let waker = lw.clone().into_waker();\n+        waker.wake();\n+        waker.wake();\n         Poll::Ready(())\n     }\n }\n@@ -69,9 +59,7 @@ fn test_local_waker() {\n         nonlocal_wakes: AtomicUsize::new(0),\n     });\n     let waker = unsafe { local_waker(counter.clone()) };\n-    let spawner = &mut NoopSpawner;\n-    let cx = &mut Context::new(&waker, spawner);\n-    assert_eq!(Poll::Ready(()), Pin::new(&mut MyFuture).poll(cx));\n+    assert_eq!(Poll::Ready(()), Pin::new(&mut MyFuture).poll(&waker));\n     assert_eq!(1, counter.local_wakes.load(atomic::Ordering::SeqCst));\n     assert_eq!(2, counter.nonlocal_wakes.load(atomic::Ordering::SeqCst));\n }\n@@ -82,9 +70,7 @@ fn test_local_as_nonlocal_waker() {\n         nonlocal_wakes: AtomicUsize::new(0),\n     });\n     let waker: LocalWaker = local_waker_from_nonlocal(counter.clone());\n-    let spawner = &mut NoopSpawner;\n-    let cx = &mut Context::new(&waker, spawner);\n-    assert_eq!(Poll::Ready(()), Pin::new(&mut MyFuture).poll(cx));\n+    assert_eq!(Poll::Ready(()), Pin::new(&mut MyFuture).poll(&waker));\n     assert_eq!(0, counter.local_wakes.load(atomic::Ordering::SeqCst));\n     assert_eq!(3, counter.nonlocal_wakes.load(atomic::Ordering::SeqCst));\n }"}]}