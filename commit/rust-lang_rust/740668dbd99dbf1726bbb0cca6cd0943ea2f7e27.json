{"sha": "740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0MDY2OGRiZDk5ZGJmMTcyNmJiYjBjY2E2Y2QwOTQzZWEyZjdlMjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-06T03:56:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-06T03:56:22Z"}, "message": "Auto merge of #57428 - alexreg:associated_type_bounds, r=nikomatsakis,Centril\n\nImplementation of RFC 2289 (associated_type_bounds)\n\nThis PR implements the [`asociated_type_bounds` feature](https://github.com/rust-lang/rfcs/blob/master/text/2289-associated-type-bounds.md).\n\nAssociated type bounds are implemented in:\n   - function/method arguments and return types\n   - structs, enums, unions\n   - associated items in traits\n   - type aliases\n   - type parameter defaults\n   - trait objects\n   - let bindings\n\nCC @nikomatsakis @centril", "tree": {"sha": "7fcf783b5f92803e8ca4985eaa24097e76b6192c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fcf783b5f92803e8ca4985eaa24097e76b6192c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "html_url": "https://github.com/rust-lang/rust/commit/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bec46c9a5399d5e95c05e3428c3abd264780705", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bec46c9a5399d5e95c05e3428c3abd264780705", "html_url": "https://github.com/rust-lang/rust/commit/1bec46c9a5399d5e95c05e3428c3abd264780705"}, {"sha": "ee890331f6e33afe12ef250eb6388db2aab7cbbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee890331f6e33afe12ef250eb6388db2aab7cbbf", "html_url": "https://github.com/rust-lang/rust/commit/ee890331f6e33afe12ef250eb6388db2aab7cbbf"}], "stats": {"total": 5902, "additions": 4847, "deletions": 1055}, "files": [{"sha": "239ff017cc2306b433c9d991336e21c3291d7d74", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -1351,7 +1351,7 @@ impl<'b> BorrowRefMut<'b> {\n         }\n     }\n \n-    // Clone a `BorrowRefMut`.\n+    // Clones a `BorrowRefMut`.\n     //\n     // This is only valid if each `BorrowRefMut` is used to track a mutable\n     // reference to a distinct, nonoverlapping range of the original object."}, {"sha": "8e46830084642b573623723650f280e73671602e", "filename": "src/libcore/ops/unsize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibcore%2Fops%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibcore%2Fops%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Funsize.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -71,7 +71,7 @@ impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n \n /// This is used for object safety, to check that a method's receiver type can be dispatched on.\n ///\n-/// example impl:\n+/// An example implementation of the trait:\n ///\n /// ```\n /// # #![feature(dispatch_from_dyn, unsize)]"}, {"sha": "1c66f8bdf81bdd865b77c3196b06acdfd1ba2c10", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -674,7 +674,14 @@ pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n                                                    type_binding: &'v TypeBinding) {\n     visitor.visit_id(type_binding.hir_id);\n     visitor.visit_ident(type_binding.ident);\n-    visitor.visit_ty(&type_binding.ty);\n+    match type_binding.kind {\n+        TypeBindingKind::Equality { ref ty } => {\n+            visitor.visit_ty(ty);\n+        }\n+        TypeBindingKind::Constraint { ref bounds } => {\n+            walk_list!(visitor, visit_param_bound, bounds);\n+        }\n+    }\n }\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n@@ -934,7 +941,6 @@ pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'\n     visitor.visit_defaultness(defaultness);\n }\n \n-\n pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V, struct_definition: &'v VariantData) {\n     if let Some(ctor_hir_id) = struct_definition.ctor_hir_id() {\n         visitor.visit_id(ctor_hir_id);"}, {"sha": "d6ad335525c147312ff16004f46f492aaefe0e3f", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 266, "deletions": 119, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -17,7 +17,7 @@\n //! 'folding' an existing one), then you create a new ID using `next_id()`.\n //!\n //! You must ensure that IDs are unique. That means that you should only use the\n-//! ID from an AST node in a single HIR node (you can assume that AST node IDs\n+//! ID from an AST node in a single HIR node (you can assume that AST node-IDs\n //! are unique). Every new node must have a unique ID. Avoid cloning HIR nodes.\n //! If you do, you must then set the new node's ID to a fresh one.\n //!\n@@ -69,7 +69,7 @@ use syntax::symbol::{kw, sym, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::Token;\n use syntax::visit::{self, Visitor};\n-use syntax_pos::{edition, Span};\n+use syntax_pos::{DUMMY_SP, edition, Span};\n \n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n@@ -106,6 +106,7 @@ pub struct LoweringContext<'a> {\n     loop_scopes: Vec<NodeId>,\n     is_in_loop_condition: bool,\n     is_in_trait_impl: bool,\n+    is_in_dyn_type: bool,\n \n     /// What to do when we encounter either an \"anonymous lifetime\n     /// reference\". The term \"anonymous\" is meant to encompass both\n@@ -175,6 +176,8 @@ pub trait Resolver {\n     ) -> hir::Path;\n }\n \n+/// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,\n+/// and if so, what meaning it has.\n #[derive(Debug)]\n enum ImplTraitContext<'a> {\n     /// Treat `impl Trait` as shorthand for a new universal generic parameter.\n@@ -189,18 +192,21 @@ enum ImplTraitContext<'a> {\n     /// equivalent to a fresh existential parameter like `existential type T; fn foo() -> T`.\n     ///\n     /// We optionally store a `DefId` for the parent item here so we can look up necessary\n-    /// information later. It is `None` when no information about the context should be stored,\n-    /// e.g., for consts and statics.\n-    Existential(Option<DefId>),\n+    /// information later. It is `None` when no information about the context should be stored\n+    /// (e.g., for consts and statics).\n+    Existential(Option<DefId> /* fn def-ID */),\n \n     /// `impl Trait` is not accepted in this position.\n     Disallowed(ImplTraitPosition),\n }\n \n-/// Position in which `impl Trait` is disallowed. Used for error reporting.\n+/// Position in which `impl Trait` is disallowed.\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n enum ImplTraitPosition {\n+    /// Disallowed in `let` / `const` / `static` bindings.\n     Binding,\n+\n+    /// All other posiitons.\n     Other,\n }\n \n@@ -214,7 +220,7 @@ impl<'a> ImplTraitContext<'a> {\n         use self::ImplTraitContext::*;\n         match self {\n             Universal(params) => Universal(params),\n-            Existential(did) => Existential(*did),\n+            Existential(fn_def_id) => Existential(*fn_def_id),\n             Disallowed(pos) => Disallowed(*pos),\n         }\n     }\n@@ -247,6 +253,8 @@ pub fn lower_crate(\n         catch_scopes: Vec::new(),\n         loop_scopes: Vec::new(),\n         is_in_loop_condition: false,\n+        is_in_trait_impl: false,\n+        is_in_dyn_type: false,\n         anonymous_lifetime_mode: AnonymousLifetimeMode::PassThrough,\n         type_def_lifetime_params: Default::default(),\n         current_module: CRATE_NODE_ID,\n@@ -256,7 +264,6 @@ pub fn lower_crate(\n         is_generator: false,\n         is_async_body: false,\n         current_item: None,\n-        is_in_trait_impl: false,\n         lifetimes_to_define: Vec::new(),\n         is_collecting_in_band_lifetimes: false,\n         in_scope_lifetimes: Vec::new(),\n@@ -670,14 +677,14 @@ impl<'a> LoweringContext<'a> {\n \n     fn insert_item(&mut self, item: hir::Item) {\n         let id = item.hir_id;\n-        // FIXME: Use debug_asset-rt\n+        // FIXME: Use `debug_asset-rt`.\n         assert_eq!(id.local_id, hir::ItemLocalId::from_u32(0));\n         self.items.insert(id, item);\n         self.modules.get_mut(&self.current_module).unwrap().items.insert(id);\n     }\n \n     fn allocate_hir_id_counter(&mut self, owner: NodeId) -> hir::HirId {\n-        // Setup the counter if needed\n+        // Set up the counter if needed.\n         self.item_local_id_counters.entry(owner).or_insert(0);\n         // Always allocate the first `HirId` for the owner itself.\n         let lowered = self.lower_node_id_with_owner(owner, owner);\n@@ -718,7 +725,7 @@ impl<'a> LoweringContext<'a> {\n     {\n         let counter = self.item_local_id_counters\n             .insert(owner, HIR_ID_COUNTER_LOCKED)\n-            .unwrap_or_else(|| panic!(\"No item_local_id_counters entry for {:?}\", owner));\n+            .unwrap_or_else(|| panic!(\"no `item_local_id_counters` entry for {:?}\", owner));\n         let def_index = self.resolver.definitions().opt_def_index(owner).unwrap();\n         self.current_hir_id_owner.push((def_index, counter));\n         let ret = f(self);\n@@ -758,7 +765,7 @@ impl<'a> LoweringContext<'a> {\n             let local_id_counter = this\n                 .item_local_id_counters\n                 .get_mut(&owner)\n-                .expect(\"called lower_node_id_with_owner before allocate_hir_id_counter\");\n+                .expect(\"called `lower_node_id_with_owner` before `allocate_hir_id_counter`\");\n             let local_id = *local_id_counter;\n \n             // We want to be sure not to modify the counter in the map while it\n@@ -771,7 +778,7 @@ impl<'a> LoweringContext<'a> {\n                 .resolver\n                 .definitions()\n                 .opt_def_index(owner)\n-                .expect(\"You forgot to call `create_def_with_parent` or are lowering node ids \\\n+                .expect(\"you forgot to call `create_def_with_parent` or are lowering node-IDs \\\n                          that do not belong to the current owner\");\n \n             hir::HirId {\n@@ -863,7 +870,7 @@ impl<'a> LoweringContext<'a> {\n         result\n     }\n \n-    /// Creates a new hir::GenericParam for every new lifetime and\n+    /// Creates a new `hir::GenericParam` for every new lifetime and\n     /// type parameter encountered while evaluating `f`. Definitions\n     /// are created with the parent provided. If no `parent_id` is\n     /// provided, no definitions will be returned.\n@@ -1197,7 +1204,7 @@ impl<'a> LoweringContext<'a> {\n         assert_eq!(\n             len + 1,\n             self.loop_scopes.len(),\n-            \"Loop scopes should be added and removed in stack order\"\n+            \"loop scopes should be added and removed in stack order\"\n         );\n \n         self.loop_scopes.pop().unwrap();\n@@ -1221,6 +1228,20 @@ impl<'a> LoweringContext<'a> {\n         result\n     }\n \n+    fn with_dyn_type_scope<T, F>(&mut self, in_scope: bool, f: F) -> T\n+    where\n+        F: FnOnce(&mut LoweringContext<'_>) -> T,\n+    {\n+        let was_in_dyn_type = self.is_in_dyn_type;\n+        self.is_in_dyn_type = in_scope;\n+\n+        let result = f(self);\n+\n+        self.is_in_dyn_type = was_in_dyn_type;\n+\n+        result\n+    }\n+\n     fn with_new_scopes<T, F>(&mut self, f: F) -> T\n     where\n         F: FnOnce(&mut LoweringContext<'_>) -> T,\n@@ -1340,20 +1361,118 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_ty_binding(&mut self, b: &TypeBinding,\n-                        itctx: ImplTraitContext<'_>) -> hir::TypeBinding {\n+    /// Given an associated type constraint like one of these:\n+    ///\n+    /// ```\n+    /// T: Iterator<Item: Debug>\n+    ///             ^^^^^^^^^^^\n+    /// T: Iterator<Item = Debug>\n+    ///             ^^^^^^^^^^^^\n+    /// ```\n+    ///\n+    /// returns a `hir::TypeBinding` representing `Item`.\n+    fn lower_assoc_ty_constraint(&mut self,\n+                                 c: &AssocTyConstraint,\n+                                 itctx: ImplTraitContext<'_>)\n+                                 -> hir::TypeBinding {\n+        debug!(\"lower_assoc_ty_constraint(constraint={:?}, itctx={:?})\", c, itctx);\n+\n+        let kind = match c.kind {\n+            AssocTyConstraintKind::Equality { ref ty } => hir::TypeBindingKind::Equality {\n+                ty: self.lower_ty(ty, itctx)\n+            },\n+            AssocTyConstraintKind::Bound { ref bounds } => {\n+                // Piggy-back on the `impl Trait` context to figure out the correct behavior.\n+                let (desugar_to_impl_trait, itctx) = match itctx {\n+                    // We are in the return position:\n+                    //\n+                    //     fn foo() -> impl Iterator<Item: Debug>\n+                    //\n+                    // so desugar to\n+                    //\n+                    //     fn foo() -> impl Iterator<Item = impl Debug>\n+                    ImplTraitContext::Existential(_) => (true, itctx),\n+\n+                    // We are in the argument position, but within a dyn type:\n+                    //\n+                    //     fn foo(x: dyn Iterator<Item: Debug>)\n+                    //\n+                    // so desugar to\n+                    //\n+                    //     fn foo(x: dyn Iterator<Item = impl Debug>)\n+                    ImplTraitContext::Universal(_) if self.is_in_dyn_type => (true, itctx),\n+\n+                    // In `type Foo = dyn Iterator<Item: Debug>` we desugar to\n+                    // `type Foo = dyn Iterator<Item = impl Debug>` but we have to override the\n+                    // \"impl trait context\" to permit `impl Debug` in this position (it desugars\n+                    // then to an existential type).\n+                    //\n+                    // FIXME: this is only needed until `impl Trait` is allowed in type aliases.\n+                    ImplTraitContext::Disallowed(_) if self.is_in_dyn_type =>\n+                        (true, ImplTraitContext::Existential(None)),\n+\n+                    // We are in the argument position, but not within a dyn type:\n+                    //\n+                    //     fn foo(x: impl Iterator<Item: Debug>)\n+                    //\n+                    // so we leave it as is and this gets expanded in astconv to a bound like\n+                    // `<T as Iterator>::Item: Debug` where `T` is the type parameter for the\n+                    // `impl Iterator`.\n+                    _ => (false, itctx),\n+                };\n+\n+                if desugar_to_impl_trait {\n+                    // Desugar `AssocTy: Bounds` into `AssocTy = impl Bounds`. We do this by\n+                    // constructing the HIR for `impl bounds...` and then lowering that.\n+\n+                    let impl_trait_node_id = self.sess.next_node_id();\n+                    let parent_def_index = self.current_hir_id_owner.last().unwrap().0;\n+                    self.resolver.definitions().create_def_with_parent(\n+                        parent_def_index,\n+                        impl_trait_node_id,\n+                        DefPathData::ImplTrait,\n+                        Mark::root(),\n+                        DUMMY_SP\n+                    );\n+\n+                    self.with_dyn_type_scope(false, |this| {\n+                        let ty = this.lower_ty(\n+                            &Ty {\n+                                id: this.sess.next_node_id(),\n+                                node: TyKind::ImplTrait(impl_trait_node_id, bounds.clone()),\n+                                span: DUMMY_SP,\n+                            },\n+                            itctx,\n+                        );\n+\n+                        hir::TypeBindingKind::Equality {\n+                            ty\n+                        }\n+                    })\n+                } else {\n+                    // Desugar `AssocTy: Bounds` into a type binding where the\n+                    // later desugars into a trait predicate.\n+                    let bounds = self.lower_param_bounds(bounds, itctx);\n+\n+                    hir::TypeBindingKind::Constraint {\n+                        bounds\n+                    }\n+                }\n+            }\n+        };\n+\n         hir::TypeBinding {\n-            hir_id: self.lower_node_id(b.id),\n-            ident: b.ident,\n-            ty: self.lower_ty(&b.ty, itctx),\n-            span: b.span,\n+            hir_id: self.lower_node_id(c.id),\n+            ident: c.ident,\n+            kind,\n+            span: c.span,\n         }\n     }\n \n     fn lower_generic_arg(&mut self,\n-                        arg: &ast::GenericArg,\n-                        itctx: ImplTraitContext<'_>)\n-                        -> hir::GenericArg {\n+                         arg: &ast::GenericArg,\n+                         itctx: ImplTraitContext<'_>)\n+                         -> hir::GenericArg {\n         match arg {\n             ast::GenericArg::Lifetime(lt) => GenericArg::Lifetime(self.lower_lifetime(&lt)),\n             ast::GenericArg::Type(ty) => GenericArg::Type(self.lower_ty_direct(&ty, itctx)),\n@@ -1445,23 +1564,26 @@ impl<'a> LoweringContext<'a> {\n             }\n             TyKind::TraitObject(ref bounds, kind) => {\n                 let mut lifetime_bound = None;\n-                let bounds = bounds\n-                    .iter()\n-                    .filter_map(|bound| match *bound {\n-                        GenericBound::Trait(ref ty, TraitBoundModifier::None) => {\n-                            Some(self.lower_poly_trait_ref(ty, itctx.reborrow()))\n-                        }\n-                        GenericBound::Trait(_, TraitBoundModifier::Maybe) => None,\n-                        GenericBound::Outlives(ref lifetime) => {\n-                            if lifetime_bound.is_none() {\n-                                lifetime_bound = Some(self.lower_lifetime(lifetime));\n+                let (bounds, lifetime_bound) = self.with_dyn_type_scope(true, |this| {\n+                    let bounds = bounds\n+                        .iter()\n+                        .filter_map(|bound| match *bound {\n+                            GenericBound::Trait(ref ty, TraitBoundModifier::None) => {\n+                                Some(this.lower_poly_trait_ref(ty, itctx.reborrow()))\n                             }\n-                            None\n-                        }\n-                    })\n-                    .collect();\n-                let lifetime_bound =\n-                    lifetime_bound.unwrap_or_else(|| self.elided_dyn_bound(t.span));\n+                            GenericBound::Trait(_, TraitBoundModifier::Maybe) => None,\n+                            GenericBound::Outlives(ref lifetime) => {\n+                                if lifetime_bound.is_none() {\n+                                    lifetime_bound = Some(this.lower_lifetime(lifetime));\n+                                }\n+                                None\n+                            }\n+                        })\n+                        .collect();\n+                    let lifetime_bound =\n+                        lifetime_bound.unwrap_or_else(|| this.elided_dyn_bound(t.span));\n+                    (bounds, lifetime_bound)\n+                });\n                 if kind != TraitObjectSyntax::Dyn {\n                     self.maybe_lint_bare_trait(t.span, t.id, false);\n                 }\n@@ -1537,7 +1659,7 @@ impl<'a> LoweringContext<'a> {\n                     }\n                 }\n             }\n-            TyKind::Mac(_) => panic!(\"TyMac should have been expanded by now.\"),\n+            TyKind::Mac(_) => bug!(\"`TyMac` should have been expanded by now.\"),\n             TyKind::CVarArgs => {\n                 // Create the implicit lifetime of the \"spoofed\" `VaList`.\n                 let span = self.sess.source_map().next_point(t.span.shrink_to_lo());\n@@ -1563,10 +1685,10 @@ impl<'a> LoweringContext<'a> {\n         // Make sure we know that some funky desugaring has been going on here.\n         // This is a first: there is code in other places like for loop\n         // desugaring that explicitly states that we don't want to track that.\n-        // Not tracking it makes lints in rustc and clippy very fragile as\n+        // Not tracking it makes lints in rustc and clippy very fragile, as\n         // frequently opened issues show.\n         let exist_ty_span = self.mark_span_with_reason(\n-            CompilerDesugaringKind::ExistentialReturnType,\n+            CompilerDesugaringKind::ExistentialType,\n             span,\n             None,\n         );\n@@ -1602,7 +1724,7 @@ impl<'a> LoweringContext<'a> {\n                 origin: hir::ExistTyOrigin::ReturnImplTrait,\n             };\n \n-            trace!(\"exist ty from impl trait def index: {:#?}\", exist_ty_def_index);\n+            trace!(\"exist ty from impl trait def-index: {:#?}\", exist_ty_def_index);\n             let exist_ty_id = lctx.generate_existential_type(\n                 exist_ty_node_id,\n                 exist_ty_item,\n@@ -1615,8 +1737,8 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    /// Registers a new existential type with the proper NodeIds and\n-    /// returns the lowered node ID for the existential type.\n+    /// Registers a new existential type with the proper `NodeId`s and\n+    /// returns the lowered node-ID for the existential type.\n     fn generate_existential_type(\n         &mut self,\n         exist_ty_node_id: NodeId,\n@@ -1650,7 +1772,7 @@ impl<'a> LoweringContext<'a> {\n         parent_index: DefIndex,\n         bounds: &hir::GenericBounds,\n     ) -> (HirVec<hir::GenericArg>, HirVec<hir::GenericParam>) {\n-        // This visitor walks over impl trait bounds and creates defs for all lifetimes which\n+        // This visitor walks over `impl Trait` bounds and creates defs for all lifetimes that\n         // appear in the bounds, excluding lifetimes that are created within the bounds.\n         // E.g., `'a`, `'b`, but not `'c` in `impl for<'c> SomeTrait<'a, 'b, 'c>`.\n         struct ImplTraitLifetimeCollector<'r, 'a: 'r> {\n@@ -1758,8 +1880,7 @@ impl<'a> LoweringContext<'a> {\n                         def_node_id,\n                         DefPathData::LifetimeNs(name.ident().as_interned_str()),\n                         Mark::root(),\n-                        lifetime.span,\n-                    );\n+                        lifetime.span);\n \n                     let (name, kind) = match name {\n                         hir::LifetimeName::Underscore => (\n@@ -1770,7 +1891,7 @@ impl<'a> LoweringContext<'a> {\n                             param_name,\n                             hir::LifetimeParamKind::Explicit,\n                         ),\n-                        _ => bug!(\"expected LifetimeName::Param or ParamName::Plain\"),\n+                        _ => bug!(\"expected `LifetimeName::Param` or `ParamName::Plain`\"),\n                     };\n \n                     self.output_lifetime_params.push(hir::GenericParam {\n@@ -1915,7 +2036,7 @@ impl<'a> LoweringContext<'a> {\n                         {\n                             ParenthesizedGenericArgs::Err\n                         }\n-                        // A warning for now, for compatibility reasons\n+                        // A warning for now, for compatibility reasons.\n                         _ => ParenthesizedGenericArgs::Warn,\n                     };\n \n@@ -2079,11 +2200,14 @@ impl<'a> LoweringContext<'a> {\n                             }\n                         };\n                         err.emit();\n-                        (self.lower_angle_bracketed_parameter_data(\n-                            &data.as_angle_bracketed_args(),\n-                            param_mode,\n-                            itctx).0,\n-                         false)\n+                        (\n+                            self.lower_angle_bracketed_parameter_data(\n+                                &data.as_angle_bracketed_args(),\n+                                param_mode,\n+                                itctx\n+                            ).0,\n+                            false,\n+                        )\n                     }\n                 },\n             }\n@@ -2109,11 +2233,11 @@ impl<'a> LoweringContext<'a> {\n                 let no_ty_args = generic_args.args.len() == expected_lifetimes;\n                 let no_bindings = generic_args.bindings.is_empty();\n                 let (incl_angl_brckt, insertion_span, suggestion) = if no_ty_args && no_bindings {\n-                    // If there are no (non-implicit) generic args or associated-type\n+                    // If there are no (non-implicit) generic args or associated type\n                     // bindings, our suggestion includes the angle brackets.\n                     (true, path_span.shrink_to_hi(), format!(\"<{}>\", anon_lt_suggestion))\n                 } else {\n-                    // Otherwise\u2014sorry, this is kind of gross\u2014we need to infer the\n+                    // Otherwise (sorry, this is kind of gross) we need to infer the\n                     // place to splice in the `'_, ` from the generics that do exist.\n                     let first_generic_span = first_generic_span\n                         .expect(\"already checked that type args or bindings exist\");\n@@ -2191,24 +2315,28 @@ impl<'a> LoweringContext<'a> {\n         param_mode: ParamMode,\n         mut itctx: ImplTraitContext<'_>,\n     ) -> (hir::GenericArgs, bool) {\n-        let &AngleBracketedArgs { ref args, ref bindings, .. } = data;\n+        let &AngleBracketedArgs { ref args, ref constraints, .. } = data;\n         let has_types = args.iter().any(|arg| match arg {\n             ast::GenericArg::Type(_) => true,\n             _ => false,\n         });\n-        (hir::GenericArgs {\n-            args: args.iter().map(|a| self.lower_generic_arg(a, itctx.reborrow())).collect(),\n-            bindings: bindings.iter().map(|b| self.lower_ty_binding(b, itctx.reborrow())).collect(),\n-            parenthesized: false,\n-        },\n-        !has_types && param_mode == ParamMode::Optional)\n+        (\n+            hir::GenericArgs {\n+                args: args.iter().map(|a| self.lower_generic_arg(a, itctx.reborrow())).collect(),\n+                bindings: constraints.iter()\n+                    .map(|b| self.lower_assoc_ty_constraint(b, itctx.reborrow()))\n+                    .collect(),\n+                parenthesized: false,\n+            },\n+            !has_types && param_mode == ParamMode::Optional\n+        )\n     }\n \n     fn lower_parenthesized_parameter_data(\n         &mut self,\n         data: &ParenthesizedArgs,\n     ) -> (hir::GenericArgs, bool) {\n-        // Switch to `PassThrough` mode for anonymous lifetimes: this\n+        // Switch to `PassThrough` mode for anonymous lifetimes; this\n         // means that we permit things like `&Ref<T>`, where `Ref` has\n         // a hidden lifetime parameter. This is needed for backwards\n         // compatibility, even in contexts like an impl header where\n@@ -2231,10 +2359,17 @@ impl<'a> LoweringContext<'a> {\n                             hir::TypeBinding {\n                                 hir_id: this.next_id(),\n                                 ident: Ident::with_empty_ctxt(FN_OUTPUT_NAME),\n-                                ty: output\n-                                    .as_ref()\n-                                    .map(|ty| this.lower_ty(&ty, ImplTraitContext::disallowed()))\n-                                    .unwrap_or_else(|| P(mk_tup(this, hir::HirVec::new(), span))),\n+                                kind: hir::TypeBindingKind::Equality {\n+                                    ty: output\n+                                        .as_ref()\n+                                        .map(|ty| this.lower_ty(\n+                                            &ty,\n+                                            ImplTraitContext::disallowed()\n+                                        ))\n+                                        .unwrap_or_else(||\n+                                            P(mk_tup(this, hir::HirVec::new(), span))\n+                                        ),\n+                                },\n                                 span: output.as_ref().map_or(span, |ty| ty.span),\n                             }\n                         ],\n@@ -2300,16 +2435,16 @@ impl<'a> LoweringContext<'a> {\n \n     // Lowers a function declaration.\n     //\n-    // decl: the unlowered (ast) function declaration.\n-    // fn_def_id: if `Some`, impl Trait arguments are lowered into generic parameters on the\n+    // `decl`: the unlowered (AST) function declaration.\n+    // `fn_def_id`: if `Some`, impl Trait arguments are lowered into generic parameters on the\n     //      given DefId, otherwise impl Trait is disallowed. Must be `Some` if\n-    //      make_ret_async is also `Some`.\n-    // impl_trait_return_allow: determines whether impl Trait can be used in return position.\n-    //      This guards against trait declarations and implementations where impl Trait is\n+    //      `make_ret_async` is also `Some`.\n+    // `impl_trait_return_allow`: determines whether `impl Trait` can be used in return position.\n+    //      This guards against trait declarations and implementations where `impl Trait` is\n     //      disallowed.\n-    // make_ret_async: if `Some`, converts `-> T` into `-> impl Future<Output = T>` in the\n-    //      return type. This is used for `async fn` declarations. The `NodeId` is the id of the\n-    //      return type impl Trait item.\n+    // `make_ret_async`: if `Some`, converts `-> T` into `-> impl Future<Output = T>` in the\n+    //      return type. This is used for `async fn` declarations. The `NodeId` is the ID of the\n+    //      return type `impl Trait` item.\n     fn lower_fn_decl(\n         &mut self,\n         decl: &FnDecl,\n@@ -2350,7 +2485,7 @@ impl<'a> LoweringContext<'a> {\n             );\n             self.lower_async_fn_ret_ty(\n                 &decl.output,\n-                in_band_ty_params.expect(\"make_ret_async but no fn_def_id\").0,\n+                in_band_ty_params.expect(\"`make_ret_async` but no `fn_def_id`\").0,\n                 ret_id,\n                 lt_replacement,\n             )\n@@ -2359,7 +2494,8 @@ impl<'a> LoweringContext<'a> {\n                 FunctionRetTy::Ty(ref ty) => match in_band_ty_params {\n                     Some((def_id, _)) if impl_trait_return_allow => {\n                         hir::Return(self.lower_ty(ty,\n-                            ImplTraitContext::Existential(Some(def_id))))\n+                            ImplTraitContext::Existential(Some(def_id))\n+                        ))\n                     }\n                     _ => {\n                         hir::Return(self.lower_ty(ty, ImplTraitContext::disallowed()))\n@@ -2401,16 +2537,16 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    // Transform `-> T` for `async fn` into -> ExistTy { .. }\n+    // Transforms `-> T` for `async fn` into `-> ExistTy { .. }`\n     // combined with the following definition of `ExistTy`:\n     //\n-    // existential type ExistTy<generics_from_parent_fn>: Future<Output = T>;\n+    //     existential type ExistTy<generics_from_parent_fn>: Future<Output = T>;\n     //\n-    // inputs: lowered types of arguments to the function. Used to collect lifetimes.\n-    // output: unlowered output type (`T` in `-> T`)\n-    // fn_def_id: DefId of the parent function. Used to create child impl trait definition.\n-    // exist_ty_node_id: NodeId of the existential type that should be created.\n-    // elided_lt_replacement: replacement for elided lifetimes in the return type\n+    // `inputs`: lowered types of arguments to the function (used to collect lifetimes)\n+    // `output`: unlowered output type (`T` in `-> T`)\n+    // `fn_def_id`: `DefId` of the parent function (used to create child impl trait definition)\n+    // `exist_ty_node_id`: `NodeId` of the existential type that should be created\n+    // `elided_lt_replacement`: replacement for elided lifetimes in the return type\n     fn lower_async_fn_ret_ty(\n         &mut self,\n         output: &FunctionRetTy,\n@@ -2511,7 +2647,7 @@ impl<'a> LoweringContext<'a> {\n         }))\n     }\n \n-    /// Turns `-> T` into `Future<Output = T>`\n+    /// Transforms `-> T` into `Future<Output = T>`\n     fn lower_async_fn_output_type_to_future_bound(\n         &mut self,\n         output: &FunctionRetTy,\n@@ -2537,7 +2673,9 @@ impl<'a> LoweringContext<'a> {\n             args: hir_vec![],\n             bindings: hir_vec![hir::TypeBinding {\n                 ident: Ident::with_empty_ctxt(FN_OUTPUT_NAME),\n-                ty: output_ty,\n+                kind: hir::TypeBindingKind::Equality {\n+                    ty: output_ty,\n+                },\n                 hir_id: self.next_id(),\n                 span,\n             }],\n@@ -2722,7 +2860,7 @@ impl<'a> LoweringContext<'a> {\n \n                 let kind = hir::GenericParamKind::Type {\n                     default: default.as_ref().map(|x| {\n-                        self.lower_ty(x, ImplTraitContext::disallowed())\n+                        self.lower_ty(x, ImplTraitContext::Existential(None))\n                     }),\n                     synthetic: param.attrs.iter()\n                                           .filter(|attr| attr.check_name(sym::rustc_synthetic))\n@@ -2757,9 +2895,9 @@ impl<'a> LoweringContext<'a> {\n         -> hir::Generics\n     {\n         // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n-        // FIXME: this could probably be done with less rightward drift. Also looks like two control\n-        //        paths where report_error is called are also the only paths that advance to after\n-        //        the match statement, so the error reporting could probably just be moved there.\n+        // FIXME: this could probably be done with less rightward drift. It also looks like two\n+        // control paths where `report_error` is called are the only paths that advance to after the\n+        // match statement, so the error reporting could probably just be moved there.\n         let mut add_bounds: NodeMap<Vec<_>> = Default::default();\n         for pred in &generics.where_clause.predicates {\n             if let WherePredicate::BoundPredicate(ref bound_pred) = *pred {\n@@ -2952,7 +3090,7 @@ impl<'a> LoweringContext<'a> {\n             hir_id: self.lower_node_id(f.id),\n             ident: match f.ident {\n                 Some(ident) => ident,\n-                // FIXME(jseyfried): positional field hygiene\n+                // FIXME(jseyfried): positional field hygiene.\n                 None => Ident::new(sym::integer(index), f.span),\n             },\n             vis: self.lower_visibility(&f.vis, None),\n@@ -2979,7 +3117,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_param_bounds(&mut self, bounds: &[GenericBound], mut itctx: ImplTraitContext<'_>)\n-        -> hir::GenericBounds {\n+                          -> hir::GenericBounds {\n         bounds.iter().map(|bound| self.lower_param_bound(bound, itctx.reborrow())).collect()\n     }\n \n@@ -3157,7 +3295,7 @@ impl<'a> LoweringContext<'a> {\n         match *i {\n             ItemKind::ExternCrate(orig_name) => hir::ItemKind::ExternCrate(orig_name),\n             ItemKind::Use(ref use_tree) => {\n-                // Start with an empty prefix\n+                // Start with an empty prefix.\n                 let prefix = Path {\n                     segments: vec![],\n                     span: use_tree.span,\n@@ -3230,22 +3368,28 @@ impl<'a> LoweringContext<'a> {\n                 self.lower_ty(t, ImplTraitContext::disallowed()),\n                 self.lower_generics(generics, ImplTraitContext::disallowed()),\n             ),\n-            ItemKind::Existential(ref b, ref generics) => hir::ItemKind::Existential(hir::ExistTy {\n-                generics: self.lower_generics(generics, ImplTraitContext::disallowed()),\n-                bounds: self.lower_param_bounds(b, ImplTraitContext::disallowed()),\n-                impl_trait_fn: None,\n-                origin: hir::ExistTyOrigin::ExistentialType,\n-            }),\n-            ItemKind::Enum(ref enum_definition, ref generics) => hir::ItemKind::Enum(\n-                hir::EnumDef {\n-                    variants: enum_definition\n-                        .variants\n-                        .iter()\n-                        .map(|x| self.lower_variant(x))\n-                        .collect(),\n+            ItemKind::Existential(ref b, ref generics) => hir::ItemKind::Existential(\n+                hir::ExistTy {\n+                    generics: self.lower_generics(generics,\n+                        ImplTraitContext::Existential(None)),\n+                    bounds: self.lower_param_bounds(b,\n+                        ImplTraitContext::Existential(None)),\n+                    impl_trait_fn: None,\n+                    origin: hir::ExistTyOrigin::ExistentialType,\n                 },\n-                self.lower_generics(generics, ImplTraitContext::disallowed()),\n             ),\n+            ItemKind::Enum(ref enum_definition, ref generics) => {\n+                hir::ItemKind::Enum(\n+                    hir::EnumDef {\n+                        variants: enum_definition\n+                            .variants\n+                            .iter()\n+                            .map(|x| self.lower_variant(x))\n+                            .collect(),\n+                    },\n+                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                )\n+            },\n             ItemKind::Struct(ref struct_def, ref generics) => {\n                 let struct_def = self.lower_variant_data(struct_def);\n                 hir::ItemKind::Struct(\n@@ -3345,7 +3489,8 @@ impl<'a> LoweringContext<'a> {\n                 self.lower_generics(generics, ImplTraitContext::disallowed()),\n                 self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n             ),\n-            ItemKind::MacroDef(..) | ItemKind::Mac(..) => panic!(\"Shouldn't still be around\"),\n+            ItemKind::MacroDef(..)\n+            | ItemKind::Mac(..) => bug!(\"`TyMac` should have been expanded by now\"),\n         }\n \n         // [1] `defaultness.has_value()` is never called for an `impl`, always `true` in order to\n@@ -3623,16 +3768,18 @@ impl<'a> LoweringContext<'a> {\n                 );\n                 (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Provided(body_id)))\n             }\n-            TraitItemKind::Type(ref bounds, ref default) => (\n-                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n-                hir::TraitItemKind::Type(\n+            TraitItemKind::Type(ref bounds, ref default) => {\n+                let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n+                let node = hir::TraitItemKind::Type(\n                     self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n                     default\n                         .as_ref()\n                         .map(|x| self.lower_ty(x, ImplTraitContext::disallowed())),\n-                ),\n-            ),\n-            TraitItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n+                );\n+\n+                (generics, node)\n+            },\n+            TraitItemKind::Macro(..) => bug!(\"macro item shouldn't exist at this point\"),\n         };\n \n         hir::TraitItem {\n@@ -3707,7 +3854,7 @@ impl<'a> LoweringContext<'a> {\n                     self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n                 ),\n             ),\n-            ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n+            ImplItemKind::Macro(..) => bug!(\"`TyMac` should have been expanded by now\"),\n         };\n \n         hir::ImplItem {\n@@ -5347,7 +5494,7 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    /// Given suffix [\"b\",\"c\",\"d\"], returns path `::std::b::c::d` when\n+    /// Given a suffix `[\"b\", \"c\", \"d\"]`, returns path `::std::b::c::d` when\n     /// `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n     /// The path is also resolved according to `is_value`.\n     fn std_path("}, {"sha": "e66fa13f4fca21cfec4384bc02459a26a4ef7ccc", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -19,7 +19,7 @@ use std::iter::repeat;\n use crate::ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n \n-/// A Visitor that walks over the HIR and collects Nodes into a HIR map\n+/// A visitor that walks over the HIR and collects `Node`s into a HIR map.\n pub(super) struct NodeCollector<'a, 'hir> {\n     /// The crate\n     krate: &'hir Crate,\n@@ -45,7 +45,7 @@ pub(super) struct NodeCollector<'a, 'hir> {\n \n     hcx: StableHashingContext<'a>,\n \n-    // We are collecting DepNode::HirBody hashes here so we can compute the\n+    // We are collecting `DepNode::HirBody` hashes here so we can compute the\n     // crate hash from then later on.\n     hir_body_nodes: Vec<(DefPathHash, Fingerprint)>,\n }\n@@ -109,7 +109,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n         let mut hir_body_nodes = Vec::new();\n \n-        // Allocate DepNodes for the root module\n+        // Allocate `DepNode`s for the root module.\n         let (root_mod_sig_dep_index, root_mod_full_dep_index) = {\n             let Crate {\n                 ref module,"}, {"sha": "3edd75fb725dafbd8fa66855c43135641019bb96", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -239,7 +239,7 @@ impl DefPath {\n                        \"{}[{}]\",\n                        component.data.as_interned_str(),\n                        component.disambiguator)\n-                    .unwrap();\n+                       .unwrap();\n             }\n         }\n \n@@ -263,7 +263,7 @@ impl DefPath {\n                        \"{}[{}]\",\n                        component.data.as_interned_str(),\n                        component.disambiguator)\n-                    .unwrap();\n+                       .unwrap();\n             }\n         }\n         s\n@@ -276,7 +276,7 @@ pub enum DefPathData {\n     // they are treated specially by the `def_path` function.\n     /// The crate root (marker)\n     CrateRoot,\n-    // Catch-all for random DefId things like DUMMY_NODE_ID\n+    // Catch-all for random DefId things like `DUMMY_NODE_ID`\n     Misc,\n     // Different kinds of items and item-like things:\n     /// An impl\n@@ -298,9 +298,9 @@ pub enum DefPathData {\n     AnonConst,\n     /// An `impl Trait` type node\n     ImplTrait,\n-    /// GlobalMetaData identifies a piece of crate metadata that is global to\n-    /// a whole crate (as opposed to just one item). GlobalMetaData components\n-    /// are only supposed to show up right below the crate root.\n+    /// Identifies a piece of crate metadata that is global to a whole crate\n+    /// (as opposed to just one item). `GlobalMetaData` components are only\n+    /// supposed to show up right below the crate root.\n     GlobalMetaData(InternedString),\n }\n \n@@ -397,6 +397,11 @@ impl Definitions {\n         self.node_to_hir_id[node_id]\n     }\n \n+    #[inline]\n+    pub fn def_index_to_node_id(&self, def_index: DefIndex) -> ast::NodeId {\n+        self.as_local_node_id(DefId::local(def_index)).unwrap()\n+    }\n+\n     /// Retrieves the span of the given `DefId` if `DefId` is in the local crate, the span exists\n     /// and it's not `DUMMY_SP`.\n     #[inline]\n@@ -442,7 +447,7 @@ impl Definitions {\n         root_index\n     }\n \n-    /// Add a definition with a parent definition.\n+    /// Adds a definition with a parent definition.\n     pub fn create_def_with_parent(&mut self,\n                                   parent: DefIndex,\n                                   node_id: ast::NodeId,\n@@ -559,7 +564,7 @@ impl DefPathData {\n             GlobalMetaData(name) => {\n                 return name\n             }\n-            // note that this does not show up in user printouts\n+            // Note that this does not show up in user print-outs.\n             CrateRoot => sym::double_braced_crate,\n             Impl => sym::double_braced_impl,\n             Misc => sym::double_braced_misc,"}, {"sha": "978a5556d31bff1c9a838caa63c8b7e8904606cc", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 100, "deletions": 54, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -1,7 +1,8 @@\n use self::collector::NodeCollector;\n pub use self::def_collector::{DefCollector, MacroInvocationData};\n-pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n-                            DisambiguatedDefPathData, DefPathHash};\n+pub use self::definitions::{\n+    Definitions, DefKey, DefPath, DefPathData, DisambiguatedDefPathData, DefPathHash\n+};\n \n use crate::dep_graph::{DepGraph, DepNode, DepKind, DepNodeIndex};\n \n@@ -238,7 +239,7 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     #[inline]\n     pub fn local_def_id_from_hir_id(&self, hir_id: HirId) -> DefId {\n         self.opt_local_def_id_from_hir_id(hir_id).unwrap_or_else(|| {\n@@ -247,7 +248,7 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     #[inline]\n     pub fn opt_local_def_id_from_hir_id(&self, hir_id: HirId) -> Option<DefId> {\n         let node_id = self.hir_to_node_id(hir_id);\n@@ -264,7 +265,7 @@ impl<'hir> Map<'hir> {\n         self.definitions.as_local_node_id(def_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     #[inline]\n     pub fn as_local_hir_id(&self, def_id: DefId) -> Option<HirId> {\n         self.definitions.as_local_hir_id(def_id)\n@@ -287,7 +288,7 @@ impl<'hir> Map<'hir> {\n \n     #[inline]\n     pub fn def_index_to_node_id(&self, def_index: DefIndex) -> NodeId {\n-        self.definitions.as_local_node_id(DefId::local(def_index)).unwrap()\n+        self.definitions.def_index_to_node_id(def_index)\n     }\n \n     #[inline]\n@@ -426,7 +427,7 @@ impl<'hir> Map<'hir> {\n         self.fn_decl_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<FnDecl> {\n         if let Some(entry) = self.find_entry(hir_id) {\n             entry.fn_decl().cloned()\n@@ -455,7 +456,7 @@ impl<'hir> Map<'hir> {\n         self.maybe_body_owned_by_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn maybe_body_owned_by_by_hir_id(&self, hir_id: HirId) -> Option<BodyId> {\n         if let Some(entry) = self.find_entry(hir_id) {\n             if self.dep_graph.is_fully_enabled() {\n@@ -483,7 +484,7 @@ impl<'hir> Map<'hir> {\n         self.body_owner_kind_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn body_owner_kind_by_hir_id(&self, id: HirId) -> BodyOwnerKind {\n         match self.get_by_hir_id(id) {\n             Node::Item(&Item { node: ItemKind::Const(..), .. }) |\n@@ -587,14 +588,13 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    /// Retrieve the Node corresponding to `id`, panicking if it cannot\n-    /// be found.\n+    /// Retrieves the `Node` corresponding to `id`, panicking if it cannot be found.\n     pub fn get(&self, id: NodeId) -> Node<'hir> {\n         let hir_id = self.node_to_hir_id(id);\n         self.get_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn get_by_hir_id(&self, id: HirId) -> Node<'hir> {\n         // read recorded by `find`\n         self.find_by_hir_id(id).unwrap_or_else(||\n@@ -634,7 +634,7 @@ impl<'hir> Map<'hir> {\n         self.find_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn find_by_hir_id(&self, hir_id: HirId) -> Option<Node<'hir>> {\n         let result = self.find_entry(hir_id).and_then(|entry| {\n             if let Node::Crate = entry.node {\n@@ -649,23 +649,23 @@ impl<'hir> Map<'hir> {\n         result\n     }\n \n-    /// Similar to `get_parent`; returns the parent node-id, or own `id` if there is\n-    /// no parent. Note that the parent may be `CRATE_NODE_ID`, which is not itself\n-    /// present in the map -- so passing the return value of get_parent_node to\n-    /// get may actually panic.\n-    /// This function returns the immediate parent in the AST, whereas get_parent\n+    /// Similar to `get_parent`; returns the parent node-ID, or just `hir_id` if there\n+    /// is no parent. Note that the parent may be `CRATE_NODE_ID`, which is not itself\n+    /// present in the map, so passing the return value of `get_parent_node` to\n+    /// `get` may in fact panic.\n+    /// This function returns the immediate parent in the AST, whereas `get_parent`\n     /// returns the enclosing item. Note that this might not be the actual parent\n-    /// node in the AST - some kinds of nodes are not in the map and these will\n-    /// never appear as the parent_node. So you can always walk the `parent_nodes`\n-    /// from a node to the root of the ast (unless you get the same ID back here\n-    /// that can happen if the ID is not in the map itself or is just weird).\n+    /// node in the AST -- some kinds of nodes are not in the map and these will\n+    /// never appear as the parent node. Thus, you can always walk the parent nodes\n+    /// from a node to the root of the AST (unless you get back the same ID here,\n+    /// which can happen if the ID is not in the map itself or is just weird).\n     pub fn get_parent_node(&self, id: NodeId) -> NodeId {\n         let hir_id = self.node_to_hir_id(id);\n         let parent_hir_id = self.get_parent_node_by_hir_id(hir_id);\n         self.hir_to_node_id(parent_hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn get_parent_node_by_hir_id(&self, hir_id: HirId) -> HirId {\n         if self.dep_graph.is_fully_enabled() {\n             let hir_id_owner = hir_id.owner;\n@@ -721,24 +721,24 @@ impl<'hir> Map<'hir> {\n     {\n         let mut id = start_id;\n         loop {\n-            let parent_node = self.get_parent_node_by_hir_id(id);\n-            if parent_node == CRATE_HIR_ID {\n+            let parent_id = self.get_parent_node_by_hir_id(id);\n+            if parent_id == CRATE_HIR_ID {\n                 return Ok(CRATE_HIR_ID);\n             }\n-            if parent_node == id {\n+            if parent_id == id {\n                 return Err(id);\n             }\n \n-            if let Some(entry) = self.find_entry(parent_node) {\n+            if let Some(entry) = self.find_entry(parent_id) {\n                 if let Node::Crate = entry.node {\n                     return Err(id);\n                 }\n                 if found(&entry.node) {\n-                    return Ok(parent_node);\n+                    return Ok(parent_id);\n                 } else if bail_early(&entry.node) {\n-                    return Err(parent_node);\n+                    return Err(parent_id);\n                 }\n-                id = parent_node;\n+                id = parent_id;\n             } else {\n                 return Err(id);\n             }\n@@ -803,7 +803,7 @@ impl<'hir> Map<'hir> {\n         self.hir_to_node_id(parent_hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn get_parent_item(&self, hir_id: HirId) -> HirId {\n         match self.walk_parent_nodes(hir_id, |node| match *node {\n             Node::Item(_) |\n@@ -824,7 +824,7 @@ impl<'hir> Map<'hir> {\n         self.get_module_parent_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn get_module_parent_by_hir_id(&self, id: HirId) -> DefId {\n         self.local_def_id_from_hir_id(self.get_module_parent_node(id))\n     }\n@@ -841,27 +841,72 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    /// Returns the nearest enclosing scope. A scope is an item or block.\n-    /// FIXME: it is not clear to me that all items qualify as scopes -- statics\n-    /// and associated types probably shouldn't, for example. Behavior in this\n-    /// regard should be expected to be highly unstable.\n+    /// Returns the nearest enclosing scope. A scope is roughly an item or block.\n     pub fn get_enclosing_scope(&self, hir_id: HirId) -> Option<HirId> {\n         self.walk_parent_nodes(hir_id, |node| match *node {\n-            Node::Item(_) |\n-            Node::ForeignItem(_) |\n-            Node::TraitItem(_) |\n-            Node::ImplItem(_) |\n+            Node::Item(i) => {\n+                match i.node {\n+                    ItemKind::Fn(..)\n+                    | ItemKind::Mod(..)\n+                    | ItemKind::Enum(..)\n+                    | ItemKind::Struct(..)\n+                    | ItemKind::Union(..)\n+                    | ItemKind::Trait(..)\n+                    | ItemKind::Impl(..) => true,\n+                    _ => false,\n+                }\n+            },\n+            Node::ForeignItem(fi) => {\n+                match fi.node {\n+                    ForeignItemKind::Fn(..) => true,\n+                    _ => false,\n+                }\n+            },\n+            Node::TraitItem(ti) => {\n+                match ti.node {\n+                    TraitItemKind::Method(..) => true,\n+                    _ => false,\n+                }\n+            },\n+            Node::ImplItem(ii) => {\n+                match ii.node {\n+                    ImplItemKind::Method(..) => true,\n+                    _ => false,\n+                }\n+            },\n             Node::Block(_) => true,\n             _ => false,\n         }, |_| false).ok()\n     }\n \n+    /// Returns the defining scope for an existential type definition.\n+    pub fn get_defining_scope(&self, id: HirId) -> Option<HirId> {\n+        let mut scope = id;\n+        loop {\n+            scope = self.get_enclosing_scope(scope)?;\n+            if scope == CRATE_HIR_ID {\n+                return Some(CRATE_HIR_ID);\n+            }\n+            match self.get_by_hir_id(scope) {\n+                Node::Item(i) => {\n+                    match i.node {\n+                        ItemKind::Existential(ExistTy { impl_trait_fn: None, .. }) => {}\n+                        _ => break,\n+                    }\n+                }\n+                Node::Block(_) => {}\n+                _ => break,\n+            }\n+        }\n+        Some(scope)\n+    }\n+\n     pub fn get_parent_did(&self, id: NodeId) -> DefId {\n         let hir_id = self.node_to_hir_id(id);\n         self.get_parent_did_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn get_parent_did_by_hir_id(&self, id: HirId) -> DefId {\n         self.local_def_id_from_hir_id(self.get_parent_item(id))\n     }\n@@ -871,7 +916,7 @@ impl<'hir> Map<'hir> {\n         self.get_foreign_abi_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn get_foreign_abi_by_hir_id(&self, hir_id: HirId) -> Abi {\n         let parent = self.get_parent_item(hir_id);\n         if let Some(entry) = self.find_entry(parent) {\n@@ -890,7 +935,7 @@ impl<'hir> Map<'hir> {\n         self.expect_item_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn expect_item_by_hir_id(&self, id: HirId) -> &'hir Item {\n         match self.find_by_hir_id(id) { // read recorded by `find`\n             Some(Node::Item(item)) => item,\n@@ -946,7 +991,7 @@ impl<'hir> Map<'hir> {\n         self.expect_expr_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn expect_expr_by_hir_id(&self, id: HirId) -> &'hir Expr {\n         match self.find_by_hir_id(id) { // read recorded by find\n             Some(Node::Expr(expr)) => expr,\n@@ -960,7 +1005,7 @@ impl<'hir> Map<'hir> {\n         self.name_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn name_by_hir_id(&self, id: HirId) -> Name {\n         match self.get_by_hir_id(id) {\n             Node::Item(i) => i.ident.name,\n@@ -977,14 +1022,14 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    /// Given a node ID, get a list of attributes associated with the AST\n-    /// corresponding to the Node ID\n+    /// Given a node ID, gets a list of attributes associated with the AST\n+    /// corresponding to the node-ID.\n     pub fn attrs(&self, id: NodeId) -> &'hir [ast::Attribute] {\n         let hir_id = self.node_to_hir_id(id);\n         self.attrs_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn attrs_by_hir_id(&self, id: HirId) -> &'hir [ast::Attribute] {\n         self.read(id); // reveals attributes on the node\n         let attrs = match self.find_entry(id).map(|entry| entry.node) {\n@@ -1053,7 +1098,7 @@ impl<'hir> Map<'hir> {\n         self.span_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn span_by_hir_id(&self, hir_id: HirId) -> Span {\n         self.read(hir_id); // reveals span from node\n         match self.find_entry(hir_id).map(|entry| entry.node) {\n@@ -1101,7 +1146,7 @@ impl<'hir> Map<'hir> {\n         hir_id_to_string(self, self.node_to_hir_id(id), true)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn hir_to_string(&self, id: HirId) -> String {\n         hir_id_to_string(self, id, true)\n     }\n@@ -1110,7 +1155,7 @@ impl<'hir> Map<'hir> {\n         hir_id_to_string(self, self.node_to_hir_id(id), false)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn hir_to_user_string(&self, id: HirId) -> String {\n         hir_id_to_string(self, id, false)\n     }\n@@ -1119,7 +1164,7 @@ impl<'hir> Map<'hir> {\n         print::to_string(self, |s| s.print_node(self.get(id)))\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn hir_to_pretty_string(&self, id: HirId) -> String {\n         print::to_string(self, |s| s.print_node(self.get_by_hir_id(id)))\n     }\n@@ -1451,8 +1496,9 @@ pub fn provide(providers: &mut Providers<'_>) {\n         if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n             tcx.hir().def_kind(node_id)\n         } else {\n-            bug!(\"Calling local def_kind query provider for upstream DefId: {:?}\",\n-                def_id)\n+            bug!(\"calling local def_kind query provider for upstream DefId: {:?}\",\n+                def_id\n+            );\n         }\n     };\n }"}, {"sha": "2aaf5ec775d49f98cb47398834696e74f9298dd5", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 60, "deletions": 27, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -1,4 +1,4 @@\n-// HIR datatypes. See the [rustc guide] for more info.\n+//! HIR datatypes. See the [rustc guide] for more info.\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/hir.html\n \n@@ -121,13 +121,13 @@ impl fmt::Display for HirId {\n     }\n }\n \n-// hack to ensure that we don't try to access the private parts of `ItemLocalId` in this module\n+// Hack to ensure that we don't try to access the private parts of `ItemLocalId` in this module\n mod item_local_id_inner {\n     use rustc_data_structures::indexed_vec::Idx;\n     use rustc_macros::HashStable;\n     newtype_index! {\n-        /// An `ItemLocalId` uniquely identifies something within a given \"item-like\",\n-        /// that is, within a hir::Item, hir::TraitItem, or hir::ImplItem. There is no\n+        /// An `ItemLocalId` uniquely identifies something within a given \"item-like\";\n+        /// that is, within a `hir::Item`, `hir::TraitItem`, or `hir::ImplItem`. There is no\n         /// guarantee that the numerical value of a given `ItemLocalId` corresponds to\n         /// the node's position within the owning item in any way, but there is a\n         /// guarantee that the `LocalItemId`s within an owner occupy a dense range of\n@@ -568,7 +568,6 @@ pub struct GenericParam {\n     pub bounds: GenericBounds,\n     pub span: Span,\n     pub pure_wrt_drop: bool,\n-\n     pub kind: GenericParamKind,\n }\n \n@@ -1566,13 +1565,13 @@ pub enum ExprKind {\n \n     /// A struct or struct-like variant literal expression.\n     ///\n-    /// For example, `Foo {x: 1, y: 2}`, or\n-    /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`.\n+    /// E.g., `Foo {x: 1, y: 2}`, or `Foo {x: 1, .. base}`,\n+    /// where `base` is the `Option<Expr>`.\n     Struct(P<QPath>, HirVec<Field>, Option<P<Expr>>),\n \n     /// An array literal constructed from one repeated element.\n     ///\n-    /// For example, `[1; 5]`. The first expression is the element\n+    /// E.g., `[1; 5]`. The first expression is the element\n     /// to be repeated; the second is the number of times to repeat it.\n     Repeat(P<Expr>, AnonConst),\n \n@@ -1583,7 +1582,7 @@ pub enum ExprKind {\n     Err,\n }\n \n-/// Optionally `Self`-qualified value/type path or associated extension.\n+/// Represents an optionally `Self`-qualified value/type path or associated extension.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum QPath {\n     /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n@@ -1738,7 +1737,7 @@ pub struct TraitItem {\n     pub span: Span,\n }\n \n-/// A trait method's body (or just argument names).\n+/// Represents a trait method's body (or just argument names).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum TraitMethod {\n     /// No default body in the trait, just a signature.\n@@ -1751,13 +1750,12 @@ pub enum TraitMethod {\n /// Represents a trait method or associated constant or type\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum TraitItemKind {\n-    /// An associated constant with an optional value (otherwise `impl`s\n-    /// must contain a value)\n+    /// An associated constant with an optional value (otherwise `impl`s must contain a value).\n     Const(P<Ty>, Option<BodyId>),\n-    /// A method with an optional body\n+    /// A method with an optional body.\n     Method(MethodSig, TraitMethod),\n     /// An associated type with (possibly empty) bounds and optional concrete\n-    /// type\n+    /// type.\n     Type(GenericBounds, Option<P<Ty>>),\n }\n \n@@ -1782,7 +1780,7 @@ pub struct ImplItem {\n     pub span: Span,\n }\n \n-/// Represents different contents within `impl`s\n+/// Represents various kinds of content within an `impl`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ImplItemKind {\n     /// An associated constant of the given type, set to the constant result\n@@ -1796,21 +1794,56 @@ pub enum ImplItemKind {\n     Existential(GenericBounds),\n }\n \n-// Bind a type to an associated type: `A=Foo`.\n+/// Bind a type to an associated type (i.e., `A = Foo`).\n+///\n+/// Bindings like `A: Debug` are represented as a special type `A =\n+/// $::Debug` that is understood by the astconv code.\n+///\n+/// FIXME(alexreg) -- why have a separate type for the binding case,\n+/// wouldn't it be better to make the `ty` field an enum like:\n+///\n+/// ```\n+/// enum TypeBindingKind {\n+///    Equals(...),\n+///    Binding(...),\n+/// }\n+/// ```\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct TypeBinding {\n     pub hir_id: HirId,\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n-    pub ty: P<Ty>,\n+    pub kind: TypeBindingKind,\n     pub span: Span,\n }\n \n+// Represents the two kinds of type bindings.\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+pub enum TypeBindingKind {\n+    /// E.g., `Foo<Bar: Send>`.\n+    Constraint {\n+        bounds: HirVec<GenericBound>,\n+    },\n+    /// E.g., `Foo<Bar = ()>`.\n+    Equality {\n+        ty: P<Ty>,\n+    },\n+}\n+\n+impl TypeBinding {\n+    pub fn ty(&self) -> &Ty {\n+        match self.kind {\n+            TypeBindingKind::Equality { ref ty } => ty,\n+            _ => bug!(\"expected equality type binding for parenthesized generic args\"),\n+        }\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Ty {\n+    pub hir_id: HirId,\n     pub node: TyKind,\n     pub span: Span,\n-    pub hir_id: HirId,\n }\n \n impl fmt::Debug for Ty {\n@@ -1874,7 +1907,7 @@ pub enum TyKind {\n     BareFn(P<BareFnTy>),\n     /// The never type (`!`).\n     Never,\n-    /// A tuple (`(A, B, C, D,...)`).\n+    /// A tuple (`(A, B, C, D, ...)`).\n     Tup(HirVec<Ty>),\n     /// A path to a type definition (`module::module::...::Type`), or an\n     /// associated type (e.g., `<Vec<T> as Trait>::Type` or `<T>::Target`).\n@@ -2236,18 +2269,18 @@ impl StructField {\n     }\n }\n \n-/// Fields and constructor ids of enum variants and structs\n+/// Fields and constructor IDs of enum variants and structs.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum VariantData {\n-    /// Struct variant.\n+    /// A struct variant.\n     ///\n-    /// e.g., `Bar { .. }` as in `enum Foo { Bar { .. } }`.\n+    /// E.g., `Bar { .. }` as in `enum Foo { Bar { .. } }`.\n     Struct(HirVec<StructField>, /* recovered */ bool),\n-    /// Tuple variant.\n+    /// A tuple variant.\n     ///\n     /// E.g., `Bar(..)` as in `enum Foo { Bar(..) }`.\n     Tuple(HirVec<StructField>, HirId),\n-    /// Unit variant.\n+    /// A unit variant.\n     ///\n     /// E.g., `Bar = ..` as in `enum Foo { Bar = .. }`.\n     Unit(HirId),\n@@ -2598,7 +2631,7 @@ impl CodegenFnAttrs {\n         }\n     }\n \n-    /// True if it looks like this symbol needs to be exported, for example:\n+    /// Returns `true` if it looks like this symbol needs to be exported, for example:\n     ///\n     /// * `#[no_mangle]` is present\n     /// * `#[export_name(...)]` is present\n@@ -2607,8 +2640,8 @@ impl CodegenFnAttrs {\n         self.flags.contains(CodegenFnAttrFlags::NO_MANGLE) ||\n             self.export_name.is_some() ||\n             match self.linkage {\n-                // these are private, make sure we don't try to consider\n-                // them external\n+                // These are private, so make sure we don't try to consider\n+                // them external.\n                 None |\n                 Some(Linkage::Internal) |\n                 Some(Linkage::Private) => false,"}, {"sha": "c8615f0ed1b93b0e8440ae89da3e798c115014be", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -1645,7 +1645,7 @@ impl<'a> State<'a> {\n \n             self.space_if_not_bol()?;\n             self.word_space(\"->\")?;\n-            self.print_type(&generic_args.bindings[0].ty)?;\n+            self.print_type(generic_args.bindings[0].ty())?;\n         } else {\n             let start = if colons_before_params { \"::<\" } else { \"<\" };\n             let empty = Cell::new(true);\n@@ -1679,8 +1679,8 @@ impl<'a> State<'a> {\n                 })?;\n             }\n \n-            // FIXME(eddyb) This would leak into error messages, e.g.:\n-            // \"non-exhaustive patterns: `Some::<..>(_)` not covered\".\n+            // FIXME(eddyb): this would leak into error messages (e.g.,\n+            // \"non-exhaustive patterns: `Some::<..>(_)` not covered\").\n             if infer_types && false {\n                 start_or_comma(self)?;\n                 self.s.word(\"..\")?;\n@@ -1690,8 +1690,15 @@ impl<'a> State<'a> {\n                 start_or_comma(self)?;\n                 self.print_ident(binding.ident)?;\n                 self.s.space()?;\n-                self.word_space(\"=\")?;\n-                self.print_type(&binding.ty)?;\n+                match generic_args.bindings[0].kind {\n+                    hir::TypeBindingKind::Equality { ref ty } => {\n+                        self.word_space(\"=\")?;\n+                        self.print_type(ty)?;\n+                    }\n+                    hir::TypeBindingKind::Constraint { ref bounds } => {\n+                        self.print_bounds(\":\", bounds)?;\n+                    }\n+                }\n             }\n \n             if !empty.get() {"}, {"sha": "f2f909b6af156f96b47c2b37e5da513c6a493d83", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -286,7 +286,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod {\n \n         inner_span.hash_stable(hcx, hasher);\n \n-        // Combining the DefPathHashes directly is faster than feeding them\n+        // Combining the `DefPathHash`s directly is faster than feeding them\n         // into the hasher. Because we use a commutative combine, we also don't\n         // have to sort the array.\n         let item_ids_hash = item_ids"}, {"sha": "0cdd9a863ccb846cc5b0a5cb6ce9908229f821e3", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -408,7 +408,7 @@ impl_stable_hash_for!(enum ::syntax_pos::hygiene::CompilerDesugaringKind {\n     Async,\n     Await,\n     QuestionMark,\n-    ExistentialReturnType,\n+    ExistentialType,\n     ForLoop,\n     TryBlock\n });"}, {"sha": "57ab2c9c7e9a9eb812730ee8e26661970e79d2d3", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -914,10 +914,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // variable, and because type variable's can't (at present, at\n         // least) capture any of the things bound by this binder.\n         //\n-        // Really, there is no *particular* reason to do this\n-        // `shallow_resolve` here except as a\n-        // micro-optimization. Naturally I could not\n-        // resist. -nmatsakis\n+        // NOTE(nmatsakis): really, there is no *particular* reason to do this\n+        // `shallow_resolve` here except as a micro-optimization.\n+        // Naturally I could not resist.\n         let two_unbound_type_vars = {\n             let a = self.shallow_resolve(predicate.skip_binder().a);\n             let b = self.shallow_resolve(predicate.skip_binder().b);"}, {"sha": "aa415dbf36d76d20c3316b5bef0b71f97372eec9", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -786,13 +786,13 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                             match tcx.hir().find_by_hir_id(opaque_hir_id)\n                         {\n                             Some(Node::Item(item)) => match item.node {\n-                                // impl trait\n+                                // Anonymous `impl Trait`\n                                 hir::ItemKind::Existential(hir::ExistTy {\n                                     impl_trait_fn: Some(parent),\n                                     origin,\n                                     ..\n                                 }) => (parent == self.parent_def_id, origin),\n-                                // named existential types\n+                                // Named `existential type`\n                                 hir::ItemKind::Existential(hir::ExistTy {\n                                     impl_trait_fn: None,\n                                     origin,\n@@ -858,7 +858,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n             def_id, substs\n         );\n \n-        // Use the same type variable if the exact same Opaque appears more\n+        // Use the same type variable if the exact same opaque type appears more\n         // than once in the return type (e.g., if it's passed to a type alias).\n         if let Some(opaque_defn) = self.opaque_types.get(&def_id) {\n             return opaque_defn.concrete_ty;\n@@ -871,7 +871,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n \n         let predicates_of = tcx.predicates_of(def_id);\n         debug!(\n-            \"instantiate_opaque_types: predicates: {:#?}\",\n+            \"instantiate_opaque_types: predicates={:#?}\",\n             predicates_of,\n         );\n         let bounds = predicates_of.instantiate(tcx, substs);\n@@ -883,15 +883,15 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n             required_region_bounds\n         );\n \n-        // make sure that we are in fact defining the *entire* type\n-        // e.g., `existential type Foo<T: Bound>: Bar;` needs to be\n-        // defined by a function like `fn foo<T: Bound>() -> Foo<T>`.\n+        // Make sure that we are in fact defining the *entire* type\n+        // (e.g., `existential type Foo<T: Bound>: Bar;` needs to be\n+        // defined by a function like `fn foo<T: Bound>() -> Foo<T>`).\n         debug!(\n-            \"instantiate_opaque_types: param_env: {:#?}\",\n+            \"instantiate_opaque_types: param_env={:#?}\",\n             self.param_env,\n         );\n         debug!(\n-            \"instantiate_opaque_types: generics: {:#?}\",\n+            \"instantiate_opaque_types: generics={:#?}\",\n             tcx.generics_of(def_id),\n         );\n \n@@ -925,8 +925,9 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n     }\n }\n \n-/// Returns `true` if `opaque_node_id` is a sibling or a child of a sibling of `def_id`.\n+/// Returns `true` if `opaque_hir_id` is a sibling or a child of a sibling of `def_id`.\n ///\n+/// Example:\n /// ```rust\n /// pub mod foo {\n ///     pub mod bar {\n@@ -939,27 +940,29 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n /// }\n /// ```\n ///\n-/// Here, `def_id` is the `DefId` of the existential type `Baz` and `opaque_node_id` is the\n-/// `NodeId` of the reference to `Baz` (i.e., the return type of both `f1` and `f2`).\n-/// We return `true` if the reference is within the same module as the existential type\n-/// (i.e., `true` for `f1`, `false` for `f2`).\n+/// Here, `def_id` is the `DefId` of the defining use of the existential type (e.g., `f1` or `f2`),\n+/// and `opaque_hir_id` is the `HirId` of the definition of the existential type `Baz`.\n+/// For the above example, this function returns `true` for `f1` and `false` for `f2`.\n pub fn may_define_existential_type(\n     tcx: TyCtxt<'_, '_, '_>,\n     def_id: DefId,\n     opaque_hir_id: hir::HirId,\n ) -> bool {\n-    let mut hir_id = tcx\n-        .hir()\n-        .as_local_hir_id(def_id)\n-        .unwrap();\n-    // named existential types can be defined by any siblings or\n-    // children of siblings\n-    let mod_id = tcx.hir().get_parent_item(opaque_hir_id);\n-    // so we walk up the node tree until we hit the root or the parent\n-    // of the opaque type\n-    while hir_id != mod_id && hir_id != hir::CRATE_HIR_ID {\n+    let mut hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    trace!(\n+        \"may_define_existential_type(def={:?}, opaque_node={:?})\",\n+        tcx.hir().get_by_hir_id(hir_id),\n+        tcx.hir().get_by_hir_id(opaque_hir_id)\n+    );\n+\n+    // Named existential types can be defined by any siblings or children of siblings.\n+    let scope = tcx.hir()\n+        .get_defining_scope(opaque_hir_id)\n+        .expect(\"could not get defining scope\");\n+    // We walk up the node tree until we hit the root or the scope of the opaque type.\n+    while hir_id != scope && hir_id != hir::CRATE_HIR_ID {\n         hir_id = tcx.hir().get_parent_item(hir_id);\n     }\n-    // syntactically we are allowed to define the concrete type\n-    hir_id == mod_id\n+    // Syntactically, we are allowed to define the concrete type if:\n+    hir_id == scope\n }"}, {"sha": "331b74db080bf6234fff770832ff86dfc4277f65", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -1,6 +1,6 @@\n //! Name resolution for lifetimes.\n //!\n-//! Name resolution for lifetimes follows MUCH simpler rules than the\n+//! Name resolution for lifetimes follows *much* simpler rules than the\n //! full resolve. For example, lifetime names are never exported or\n //! used between functions, and they operate in a purely top-down\n //! way. Therefore, we break lifetime name resolution into a separate pass.\n@@ -923,7 +923,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_fn_decl(&mut self, fd: &'tcx hir::FnDecl) {\n         let output = match fd.output {\n             hir::DefaultReturn(_) => None,\n-            hir::Return(ref ty) => Some(ty),\n+            hir::Return(ref ty) => Some(&**ty),\n         };\n         self.visit_fn_like_elision(&fd.inputs, output);\n     }\n@@ -1009,7 +1009,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         trait_ref: &'tcx hir::PolyTraitRef,\n         _modifier: hir::TraitBoundModifier,\n     ) {\n-        debug!(\"visit_poly_trait_ref trait_ref={:?}\", trait_ref);\n+        debug!(\"visit_poly_trait_ref(trait_ref={:?})\", trait_ref);\n \n         if !self.trait_ref_hack || trait_ref.bound_generic_params.iter().any(|param| {\n             match param.kind {\n@@ -1884,7 +1884,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         if generic_args.parenthesized {\n             let was_in_fn_syntax = self.is_in_fn_syntax;\n             self.is_in_fn_syntax = true;\n-            self.visit_fn_like_elision(generic_args.inputs(), Some(&generic_args.bindings[0].ty));\n+            self.visit_fn_like_elision(generic_args.inputs(), Some(generic_args.bindings[0].ty()));\n             self.is_in_fn_syntax = was_in_fn_syntax;\n             return;\n         }\n@@ -2020,7 +2020,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_fn_like_elision(&mut self, inputs: &'tcx [hir::Ty], output: Option<&'tcx P<hir::Ty>>) {\n+    fn visit_fn_like_elision(&mut self, inputs: &'tcx [hir::Ty], output: Option<&'tcx hir::Ty>) {\n         debug!(\"visit_fn_like_elision: enter\");\n         let mut arg_elide = Elide::FreshLateAnon(Cell::new(0));\n         let arg_scope = Scope::Elision {"}, {"sha": "815c68b6b1cb68c7b272836a3606dff124b3ed55", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -124,12 +124,12 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n             // This crate explicitly wants staged API.\n             debug!(\"annotate(id = {:?}, attrs = {:?})\", hir_id, attrs);\n             if let Some(..) = attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp) {\n-                self.tcx.sess.span_err(item_sp, \"`#[deprecated]` cannot be used in staged api, \\\n+                self.tcx.sess.span_err(item_sp, \"`#[deprecated]` cannot be used in staged API; \\\n                                                  use `#[rustc_deprecated]` instead\");\n             }\n             if let Some(mut stab) = attr::find_stability(&self.tcx.sess.parse_sess,\n                                                          attrs, item_sp) {\n-                // Error if prohibited, or can't inherit anything from a container\n+                // Error if prohibited, or can't inherit anything from a container.\n                 if kind == AnnotationKind::Prohibited ||\n                    (kind == AnnotationKind::Container &&\n                     stab.level.is_stable() &&"}, {"sha": "b4615aeb0db151959eb97f8df82caf29eb0dc7b1", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -49,7 +49,8 @@ pub struct ConstEvalErr<'tcx> {\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct FrameInfo<'tcx> {\n-    pub call_site: Span, // this span is in the caller!\n+    /// This span is in the caller.\n+    pub call_site: Span,\n     pub instance: ty::Instance<'tcx>,\n     pub lint_root: Option<hir::HirId>,\n }\n@@ -200,12 +201,12 @@ fn print_backtrace(backtrace: &mut Backtrace) {\n impl<'tcx> From<InterpError<'tcx, u64>> for EvalError<'tcx> {\n     fn from(kind: InterpError<'tcx, u64>) -> Self {\n         let backtrace = match env::var(\"RUST_CTFE_BACKTRACE\") {\n-            // matching RUST_BACKTRACE, we treat \"0\" the same as \"not present\".\n+            // Matching `RUST_BACKTRACE` -- we treat \"0\" the same as \"not present\".\n             Ok(ref val) if val != \"0\" => {\n                 let mut backtrace = Backtrace::new_unresolved();\n \n                 if val == \"immediate\" {\n-                    // Print it now\n+                    // Print it now.\n                     print_backtrace(&mut backtrace);\n                     None\n                 } else {"}, {"sha": "490501bde73e53ea5facc24f05f08f161b426747", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -662,7 +662,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             \"{}\",\n                             message.unwrap_or_else(||\n                                 format!(\"the trait bound `{}` is not satisfied{}\",\n-                                         trait_ref.to_predicate(), post_message)\n+                                        trait_ref.to_predicate(), post_message)\n                             ));\n \n                         let explanation =\n@@ -676,15 +676,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             };\n \n                         if let Some(ref s) = label {\n-                            // If it has a custom \"#[rustc_on_unimplemented]\"\n+                            // If it has a custom `#[rustc_on_unimplemented]`\n                             // error message, let's display it as the label!\n                             err.span_label(span, s.as_str());\n                             err.help(&explanation);\n                         } else {\n                             err.span_label(span, explanation);\n                         }\n                         if let Some(ref s) = note {\n-                            // If it has a custom \"#[rustc_on_unimplemented]\" note, let's display it\n+                            // If it has a custom `#[rustc_on_unimplemented]` note, let's display it\n                             err.note(s.as_str());\n                         }\n "}, {"sha": "7810d65e88cc16315c3049ae0e1f0f798ad45e7c", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -1465,9 +1465,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let predicate = self.infcx()\n             .resolve_vars_if_possible(&obligation.predicate);\n \n-        // OK to skip binder because of the nature of the\n+        // Okay to skip binder because of the nature of the\n         // trait-ref-is-knowable check, which does not care about\n-        // bound regions\n+        // bound regions.\n         let trait_ref = predicate.skip_binder().trait_ref;\n \n         let result = coherence::trait_ref_is_knowable(self.tcx(), trait_ref);\n@@ -1848,12 +1848,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             .iter()\n             .filter_map(|o| o.to_opt_poly_trait_ref());\n \n-        // micro-optimization: filter out predicates relating to different\n-        // traits.\n+        // Micro-optimization: filter out predicates relating to different traits.\n         let matching_bounds =\n             all_bounds.filter(|p| p.def_id() == stack.obligation.predicate.def_id());\n \n-        // keep only those bounds which may apply, and propagate overflow if it occurs\n+        // Keep only those bounds which may apply, and propagate overflow if it occurs.\n         let mut param_candidates = vec![];\n         for bound in matching_bounds {\n             let wc = self.evaluate_where_clause(stack, bound.clone())?;\n@@ -1891,9 +1890,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return Ok(());\n         }\n \n-        // OK to skip binder because the substs on generator types never\n+        // Okay to skip binder because the substs on generator types never\n         // touch bound regions, they just capture the in-scope\n-        // type/region parameters\n+        // type/region parameters.\n         let self_ty = *obligation.self_ty().skip_binder();\n         match self_ty.sty {\n             ty::Generator(..) => {\n@@ -1935,7 +1934,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n         };\n \n-        // OK to skip binder because the substs on closure types never\n+        // Okay to skip binder because the substs on closure types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n         match obligation.self_ty().skip_binder().sty {\n@@ -1985,7 +1984,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return Ok(());\n         }\n \n-        // OK to skip binder because what we are inspecting doesn't involve bound regions\n+        // Okay to skip binder because what we are inspecting doesn't involve bound regions\n         let self_ty = *obligation.self_ty().skip_binder();\n         match self_ty.sty {\n             ty::Infer(ty::TyVar(_)) => {\n@@ -2042,7 +2041,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) -> Result<(), SelectionError<'tcx>> {\n-        // OK to skip binder here because the tests we do below do not involve bound regions\n+        // Okay to skip binder here because the tests we do below do not involve bound regions.\n         let self_ty = *obligation.self_ty().skip_binder();\n         debug!(\"assemble_candidates_from_auto_impls(self_ty={:?})\", self_ty);\n \n@@ -2274,7 +2273,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) -> Result<(), SelectionError<'tcx>> {\n-        // OK to skip binder here because the tests we do below do not involve bound regions\n+        // Okay to skip binder here because the tests we do below do not involve bound regions.\n         let self_ty = *obligation.self_ty().skip_binder();\n         debug!(\"assemble_candidates_for_trait_alias(self_ty={:?})\", self_ty);\n \n@@ -3094,7 +3093,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     ) -> Result<VtableFnPointerData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         debug!(\"confirm_fn_pointer_candidate({:?})\", obligation);\n \n-        // OK to skip binder; it is reintroduced below\n+        // Okay to skip binder; it is reintroduced below.\n         let self_ty = self.infcx\n             .shallow_resolve(*obligation.self_ty().skip_binder());\n         let sig = self_ty.fn_sig(self.tcx());\n@@ -3172,9 +3171,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> Result<VtableGeneratorData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n-        // OK to skip binder because the substs on generator types never\n+        // Okay to skip binder because the substs on generator types never\n         // touch bound regions, they just capture the in-scope\n-        // type/region parameters\n+        // type/region parameters.\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let (generator_def_id, substs) = match self_ty.sty {\n             ty::Generator(id, substs, _) => (id, substs),\n@@ -3229,9 +3228,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             .fn_trait_kind(obligation.predicate.def_id())\n             .unwrap_or_else(|| bug!(\"closure candidate for non-fn trait {:?}\", obligation));\n \n-        // OK to skip binder because the substs on closure types never\n+        // Okay to skip binder because the substs on closure types never\n         // touch bound regions, they just capture the in-scope\n-        // type/region parameters\n+        // type/region parameters.\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let (closure_def_id, substs) = match self_ty.sty {\n             ty::Closure(id, substs) => (id, substs),"}, {"sha": "4d382d6c45a76e1ad8d1269cf6b7b14e4a9ea793", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -10,11 +10,11 @@ use std::fmt;\n use std::rc::Rc;\n use std::collections::{BTreeSet, BTreeMap};\n \n-// structural impls for the structs in traits\n+// Structural impls for the structs in `traits`.\n \n impl<'tcx, T: fmt::Debug> fmt::Debug for Normalized<'tcx, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"Normalized({:?},{:?})\", self.value, self.obligations)\n+        write!(f, \"Normalized({:?}, {:?})\", self.value, self.obligations)\n     }\n }\n \n@@ -23,13 +23,13 @@ impl<'tcx, O: fmt::Debug> fmt::Debug for traits::Obligation<'tcx, O> {\n         if ty::tls::with(|tcx| tcx.sess.verbose()) {\n             write!(\n                 f,\n-                \"Obligation(predicate={:?},cause={:?},param_env={:?},depth={})\",\n+                \"Obligation(predicate={:?}, cause={:?}, param_env={:?}, depth={})\",\n                 self.predicate, self.cause, self.param_env, self.recursion_depth\n             )\n         } else {\n             write!(\n                 f,\n-                \"Obligation(predicate={:?},depth={})\",\n+                \"Obligation(predicate={:?}, depth={})\",\n                 self.predicate, self.recursion_depth\n             )\n         }"}, {"sha": "e60022033cc542d6007e4ca6731b89dd42c01ec8", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -1706,21 +1706,21 @@ impl<'gcx> GlobalCtxt<'gcx> {\n     }\n }\n \n-/// A trait implemented for all X<'a> types which can be safely and\n-/// efficiently converted to X<'tcx> as long as they are part of the\n-/// provided TyCtxt<'tcx>.\n-/// This can be done, for example, for Ty<'tcx> or SubstsRef<'tcx>\n+/// A trait implemented for all `X<'a>` types that can be safely and\n+/// efficiently converted to `X<'tcx>` as long as they are part of the\n+/// provided `TyCtxt<'tcx>`.\n+/// This can be done, for example, for `Ty<'tcx>` or `SubstsRef<'tcx>`\n /// by looking them up in their respective interners.\n ///\n /// However, this is still not the best implementation as it does\n /// need to compare the components, even for interned values.\n-/// It would be more efficient if TypedArena provided a way to\n+/// It would be more efficient if `TypedArena` provided a way to\n /// determine whether the address is in the allocated range.\n ///\n /// None is returned if the value or one of the components is not part\n /// of the provided context.\n-/// For Ty, None can be returned if either the type interner doesn't\n-/// contain the TyKind key or if the address of the interned\n+/// For `Ty`, `None` can be returned if either the type interner doesn't\n+/// contain the `TyKind` key or if the address of the interned\n /// pointer differs. The latter case is possible if a primitive type,\n /// e.g., `()` or `u8`, was interned in a different context.\n pub trait Lift<'tcx>: fmt::Debug {"}, {"sha": "69bf05c66f394eda1df54674e9db5c322226a746", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -1090,7 +1090,7 @@ pub enum Predicate<'tcx> {\n     /// See the `ProjectionPredicate` struct for details.\n     Projection(PolyProjectionPredicate<'tcx>),\n \n-    /// no syntax: `T` well-formed\n+    /// No syntax: `T` well-formed.\n     WellFormed(Ty<'tcx>),\n \n     /// Trait must be object-safe.\n@@ -1245,19 +1245,17 @@ impl<'tcx> TraitPredicate<'tcx> {\n \n impl<'tcx> PolyTraitPredicate<'tcx> {\n     pub fn def_id(&self) -> DefId {\n-        // ok to skip binder since trait def-id does not care about regions\n+        // Ok to skip binder since trait def-ID does not care about regions.\n         self.skip_binder().def_id()\n     }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord,\n          Hash, Debug, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A: B`\n-pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n-pub type RegionOutlivesPredicate<'tcx> = OutlivesPredicate<ty::Region<'tcx>,\n-                                                           ty::Region<'tcx>>;\n-pub type TypeOutlivesPredicate<'tcx> = OutlivesPredicate<Ty<'tcx>,\n-                                                         ty::Region<'tcx>>;\n+pub struct OutlivesPredicate<A, B>(pub A, pub B); // `A: B`\n+pub type PolyOutlivesPredicate<A, B> = ty::Binder<OutlivesPredicate<A, B>>;\n+pub type RegionOutlivesPredicate<'tcx> = OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>;\n+pub type TypeOutlivesPredicate<'tcx> = OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>;\n pub type PolyRegionOutlivesPredicate<'tcx> = ty::Binder<RegionOutlivesPredicate<'tcx>>;\n pub type PolyTypeOutlivesPredicate<'tcx> = ty::Binder<TypeOutlivesPredicate<'tcx>>;\n \n@@ -1314,7 +1312,7 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n     /// Note that this is not the `DefId` of the `TraitRef` containing this\n     /// associated type, which is in `tcx.associated_item(projection_def_id()).container`.\n     pub fn projection_def_id(&self) -> DefId {\n-        // okay to skip binder since trait def-id does not care about regions\n+        // Ok to skip binder since trait def-ID does not care about regions.\n         self.skip_binder().projection_ty.item_def_id\n     }\n }\n@@ -1371,7 +1369,7 @@ impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n     }\n }\n \n-// A custom iterator used by Predicate::walk_tys.\n+// A custom iterator used by `Predicate::walk_tys`.\n enum WalkTysIter<'tcx, I, J, K>\n     where I: Iterator<Item = Ty<'tcx>>,\n           J: Iterator<Item = Ty<'tcx>>,\n@@ -1505,7 +1503,7 @@ impl<'tcx> Predicate<'tcx> {\n ///\n /// Example:\n ///\n-///     struct Foo<T,U:Bar<T>> { ... }\n+///     struct Foo<T, U: Bar<T>> { ... }\n ///\n /// Here, the `GenericPredicates` for `Foo` would contain a list of bounds like\n /// `[[], [U:Bar<T>]]`. Now if there were some particular reference\n@@ -2785,10 +2783,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 e.span\n             }\n             Some(f) => {\n-                bug!(\"Node id {} is not an expr: {:?}\", id, f);\n+                bug!(\"node-ID {} is not an expr: {:?}\", id, f);\n             }\n             None => {\n-                bug!(\"Node id {} is not present in the node map\", id);\n+                bug!(\"node-ID {} is not present in the node map\", id);\n             }\n         }\n     }"}, {"sha": "c2760ccb0c0a23a65191765e7a9fb6ab83dd1248", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -96,12 +96,12 @@ pub(super) struct JobOwner<'a, 'tcx: 'a, Q: QueryDescription<'tcx> + 'a> {\n }\n \n impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n-    /// Either gets a JobOwner corresponding the query, allowing us to\n+    /// Either gets a `JobOwner` corresponding the query, allowing us to\n     /// start executing the query, or it returns with the result of the query.\n     /// If the query is executing elsewhere, this will wait for it.\n     /// If the query panicked, this will silently panic.\n     ///\n-    /// This function is inlined because that results in a noticeable speedup\n+    /// This function is inlined because that results in a noticeable speed-up\n     /// for some compile-time benchmarks.\n     #[inline(always)]\n     pub(super) fn try_get(\n@@ -126,9 +126,9 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n                 Entry::Occupied(entry) => {\n                     match *entry.get() {\n                         QueryResult::Started(ref job) => {\n-                            //For parallel queries, we'll block and wait until the query running\n-                            //in another thread has completed. Record how long we wait in the\n-                            //self-profiler\n+                            // For parallel queries, we'll block and wait until the query running\n+                            // in another thread has completed. Record how long we wait in the\n+                            // self-profiler.\n                             #[cfg(parallel_compiler)]\n                             tcx.sess.profiler(|p| p.query_blocked_start(Q::NAME));\n \n@@ -138,7 +138,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n                     }\n                 }\n                 Entry::Vacant(entry) => {\n-                    // No job entry for this query. Return a new one to be started later\n+                    // No job entry for this query. Return a new one to be started later.\n                     return tls::with_related_context(tcx, |icx| {\n                         // Create the `parent` variable before `info`. This allows LLVM\n                         // to elide the move of `info`\n@@ -161,14 +161,14 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n             mem::drop(lock);\n \n             // If we are single-threaded we know that we have cycle error,\n-            // so we just return the error\n+            // so we just return the error.\n             #[cfg(not(parallel_compiler))]\n             return TryGetJob::Cycle(cold_path(|| {\n                 Q::handle_cycle_error(tcx, job.find_cycle_in_stack(tcx, span))\n             }));\n \n             // With parallel queries we might just have to wait on some other\n-            // thread\n+            // thread.\n             #[cfg(parallel_compiler)]\n             {\n                 let result = job.r#await(tcx, span);\n@@ -636,8 +636,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                           profq_query_msg!(Q::NAME.as_str(), self, key))\n         );\n \n-        // We may be concurrently trying both execute and force a query\n-        // Ensure that only one of them runs the query\n+        // We may be concurrently trying both execute and force a query.\n+        // Ensure that only one of them runs the query.\n         let job = match JobOwner::try_get(self, span, &key) {\n             TryGetJob::NotYetStarted(job) => job,\n             TryGetJob::Cycle(_) |\n@@ -731,7 +731,7 @@ macro_rules! define_queries_inner {\n                 let mut jobs = Vec::new();\n \n                 // We use try_lock here since we are only called from the\n-                // deadlock handler, and this shouldn't be locked\n+                // deadlock handler, and this shouldn't be locked.\n                 $(\n                     jobs.extend(\n                         self.$name.try_lock().unwrap().active.values().filter_map(|v|"}, {"sha": "9b4029f409ba4890c10552dc749df6f48662cec2", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -546,7 +546,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.def_key(def_id).disambiguated_data.data == DefPathData::Ctor\n     }\n \n-    /// Given the `DefId` of a fn or closure, returns the `DefId` of\n+    /// Given the def-ID of a fn or closure, returns the def-ID of\n     /// the innermost fn item that the closure is contained within.\n     /// This is a significant `DefId` because, when we do\n     /// type-checking, we type-check this fn item and all of its"}, {"sha": "2140018223c34cbfc48e443b27e80ab35a1b49ee", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -18,7 +18,7 @@ use crate::dep_graph::{DepNode};\n use lazy_static;\n use crate::session::Session;\n \n-// The name of the associated type for `Fn` return types\n+// The name of the associated type for `Fn` return types.\n pub const FN_OUTPUT_NAME: Symbol = sym::Output;\n \n // Useful type to use with `Result<>` indicate that an error has already\n@@ -45,16 +45,16 @@ fn panic_hook(info: &panic::PanicInfo<'_>) {\n         TyCtxt::try_print_query_stack();\n     }\n \n-        #[cfg(windows)]\n-        unsafe {\n-            if env::var(\"RUSTC_BREAK_ON_ICE\").is_ok() {\n-                extern \"system\" {\n-                    fn DebugBreak();\n-                }\n-                // Trigger a debugger if we crashed during bootstrap\n-                DebugBreak();\n+    #[cfg(windows)]\n+    unsafe {\n+        if env::var(\"RUSTC_BREAK_ON_ICE\").is_ok() {\n+            extern \"system\" {\n+                fn DebugBreak();\n             }\n+            // Trigger a debugger if we crashed during bootstrap.\n+            DebugBreak();\n         }\n+    }\n }\n \n pub fn install_panic_hook() {\n@@ -80,42 +80,42 @@ pub struct QueryMsg {\n }\n \n /// A sequence of these messages induce a trace of query-based incremental compilation.\n-/// FIXME(matthewhammer): Determine whether we should include cycle detection here or not.\n+// FIXME(matthewhammer): Determine whether we should include cycle detection here or not.\n #[derive(Clone,Debug)]\n pub enum ProfileQueriesMsg {\n-    /// begin a timed pass\n+    /// Begin a timed pass.\n     TimeBegin(String),\n-    /// end a timed pass\n+    /// End a timed pass.\n     TimeEnd,\n-    /// begin a task (see dep_graph::graph::with_task)\n+    /// Begin a task (see `dep_graph::graph::with_task`).\n     TaskBegin(DepNode),\n-    /// end a task\n+    /// End a task.\n     TaskEnd,\n-    /// begin a new query\n-    /// can't use `Span` because queries are sent to other thread\n+    /// Begin a new query.\n+    /// Cannot use `Span` because queries are sent to other thread.\n     QueryBegin(SpanData, QueryMsg),\n-    /// query is satisfied by using an already-known value for the given key\n+    /// Query is satisfied by using an already-known value for the given key.\n     CacheHit,\n-    /// query requires running a provider; providers may nest, permitting queries to nest.\n+    /// Query requires running a provider; providers may nest, permitting queries to nest.\n     ProviderBegin,\n-    /// query is satisfied by a provider terminating with a value\n+    /// Query is satisfied by a provider terminating with a value.\n     ProviderEnd,\n-    /// dump a record of the queries to the given path\n+    /// Dump a record of the queries to the given path.\n     Dump(ProfQDumpParams),\n-    /// halt the profiling/monitoring background thread\n+    /// Halt the profiling/monitoring background thread.\n     Halt\n }\n \n-/// If enabled, send a message to the profile-queries thread\n+/// If enabled, send a message to the profile-queries thread.\n pub fn profq_msg(sess: &Session, msg: ProfileQueriesMsg) {\n     if let Some(s) = sess.profile_channel.borrow().as_ref() {\n         s.send(msg).unwrap()\n     } else {\n-        // Do nothing\n+        // Do nothing.\n     }\n }\n \n-/// Set channel for profile queries channel\n+/// Set channel for profile queries channel.\n pub fn profq_set_chan(sess: &Session, s: Sender<ProfileQueriesMsg>) -> bool {\n     let mut channel = sess.profile_channel.borrow_mut();\n     if channel.is_none() {"}, {"sha": "af10404cba395fb75186e29ff232898a93be61df", "filename": "src/librustc_borrowck/dataflow.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdataflow.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -19,7 +19,6 @@ use rustc::hir;\n use rustc::hir::intravisit;\n use rustc::hir::print as pprust;\n \n-\n #[derive(Copy, Clone, Debug)]\n pub enum EntryOrExit {\n     Entry,\n@@ -92,7 +91,7 @@ fn get_cfg_indices<'a>(id: hir::ItemLocalId,\n     index.get(&id).map_or(&[], |v| &v[..])\n }\n \n-impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n+impl<'a, 'tcx, O: DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     fn has_bitset_for_local_id(&self, n: hir::ItemLocalId) -> bool {\n         assert!(n != hir::DUMMY_ITEM_LOCAL_ID);\n         self.local_id_to_index.contains_key(&n)\n@@ -225,7 +224,7 @@ pub enum KillFrom {\n     Execution,\n }\n \n-impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n+impl<'a, 'tcx, O: DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                analysis_name: &'static str,\n                body: Option<&hir::Body>,\n@@ -500,8 +499,8 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     }\n }\n \n-impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n-//                                ^^^^^^^^^^^^^ only needed for pretty printing\n+// N.B. `Clone + 'static` only needed for pretty printing.\n+impl<'a, 'tcx, O: DataFlowOperator + Clone + 'static> DataFlowContext<'a, 'tcx, O> {\n     pub fn propagate(&mut self, cfg: &cfg::CFG, body: &hir::Body) {\n         //! Performs the data flow analysis.\n \n@@ -538,7 +537,7 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n     }\n }\n \n-impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n+impl<'a, 'b, 'tcx, O: DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n     fn walk_cfg(&mut self,\n                 cfg: &cfg::CFG,\n                 nodes_po: &[CFGIndex],\n@@ -547,7 +546,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n                bits_to_string(in_out), self.dfcx.analysis_name);\n         assert!(self.dfcx.bits_per_id > 0);\n \n-        // Iterate over nodes in reverse postorder\n+        // Iterate over nodes in reverse post-order.\n         for &node_index in nodes_po.iter().rev() {\n             let node = cfg.graph.node(node_index);\n             debug!(\"DataFlowContext::walk_cfg idx={:?} id={:?} begin in_out={}\",\n@@ -631,9 +630,9 @@ fn bits_to_string(words: &[usize]) -> String {\n }\n \n #[inline]\n-fn bitwise<Op:BitwiseOperator>(out_vec: &mut [usize],\n-                               in_vec: &[usize],\n-                               op: &Op) -> bool {\n+fn bitwise<Op: BitwiseOperator>(out_vec: &mut [usize],\n+                                in_vec: &[usize],\n+                                op: &Op) -> bool {\n     assert_eq!(out_vec.len(), in_vec.len());\n     let mut changed = false;\n     for (out_elt, in_elt) in out_vec.iter_mut().zip(in_vec) {"}, {"sha": "f32dc4312654036c42182689bf465417c3dc9dda", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -937,8 +937,8 @@ fn codegen_msvc_try(\n     bx.store(ret, dest, i32_align);\n }\n \n-// Definition of the standard \"try\" function for Rust using the GNU-like model\n-// of exceptions (e.g., the normal semantics of LLVM's landingpad and invoke\n+// Definition of the standard `try` function for Rust using the GNU-like model\n+// of exceptions (e.g., the normal semantics of LLVM's `landingpad` and `invoke`\n // instructions).\n //\n // This codegen is a little surprising because we always call a shim"}, {"sha": "0ba5451bd72f52a2e8cfe9a92fd6b324064fbaee", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -1127,10 +1127,10 @@ fn link_args<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n     // For this reason, we have organized the arguments we pass to the linker as\n     // such:\n     //\n-    //  1. The local object that LLVM just generated\n-    //  2. Local native libraries\n-    //  3. Upstream rust libraries\n-    //  4. Upstream native libraries\n+    // 1. The local object that LLVM just generated\n+    // 2. Local native libraries\n+    // 3. Upstream rust libraries\n+    // 4. Upstream native libraries\n     //\n     // The rationale behind this ordering is that those items lower down in the\n     // list can't depend on items higher up in the list. For example nothing can"}, {"sha": "7e5ee25d8ef78dd7ae3385ca2a9f390a78f03a7a", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -967,7 +967,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         bx.range_metadata(llval, 0..2);\n                     }\n                 }\n-                // We store bools as i8 so we need to truncate to i1.\n+                // We store bools as `i8` so we need to truncate to `i1`.\n                 llval = base::to_immediate(bx, llval, arg.layout);\n             }\n         }\n@@ -1097,7 +1097,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         fn_ret: &ArgType<'tcx, Ty<'tcx>>,\n         llargs: &mut Vec<Bx::Value>, is_intrinsic: bool\n     ) -> ReturnDest<'tcx, Bx::Value> {\n-        // If the return is ignored, we can just return a do-nothing ReturnDest\n+        // If the return is ignored, we can just return a do-nothing `ReturnDest`.\n         if fn_ret.is_ignore() {\n             return ReturnDest::Nothing;\n         }\n@@ -1106,8 +1106,8 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 LocalRef::Place(dest) => dest,\n                 LocalRef::UnsizedPlace(_) => bug!(\"return type must be sized\"),\n                 LocalRef::Operand(None) => {\n-                    // Handle temporary places, specifically Operand ones, as\n-                    // they don't have allocas\n+                    // Handle temporary places, specifically `Operand` ones, as\n+                    // they don't have `alloca`s.\n                     return if fn_ret.is_indirect() {\n                         // Odd, but possible, case, we have an operand temporary,\n                         // but the calling convention has an indirect return.\n@@ -1117,8 +1117,8 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         ReturnDest::IndirectOperand(tmp, index)\n                     } else if is_intrinsic {\n                         // Currently, intrinsics always need a location to store\n-                        // the result. so we create a temporary alloca for the\n-                        // result\n+                        // the result, so we create a temporary `alloca` for the\n+                        // result.\n                         let tmp = PlaceRef::alloca(bx, fn_ret.layout, \"tmp_ret\");\n                         tmp.storage_live(bx);\n                         ReturnDest::IndirectOperand(tmp, index)\n@@ -1137,7 +1137,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             if dest.align < dest.layout.align.abi {\n                 // Currently, MIR code generation does not create calls\n                 // that store directly to fields of packed structs (in\n-                // fact, the calls it creates write only to temps),\n+                // fact, the calls it creates write only to temps).\n                 //\n                 // If someone changes that, please update this code path\n                 // to create a temporary.\n@@ -1232,12 +1232,12 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n }\n \n enum ReturnDest<'tcx, V> {\n-    // Do nothing, the return value is indirect or ignored\n+    // Do nothing; the return value is indirect or ignored.\n     Nothing,\n-    // Store the return value to the pointer\n+    // Store the return value to the pointer.\n     Store(PlaceRef<'tcx, V>),\n-    // Stores an indirect return value to an operand local place\n+    // Store an indirect return value to an operand local place.\n     IndirectOperand(PlaceRef<'tcx, V>, mir::Local),\n-    // Stores a direct return value to an operand local place\n+    // Store a direct return value to an operand local place.\n     DirectOperand(mir::Local)\n }"}, {"sha": "27311d0a8fbf1e2480c8a392697fdd9b1eba6d65", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -120,7 +120,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n                 bx.struct_gep(self.llval, bx.cx().backend_field_index(self.layout, ix))\n             };\n             PlaceRef {\n-                // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n+                // HACK(eddyb): have to bitcast pointers until LLVM removes pointee types.\n                 llval: bx.pointercast(llval, bx.cx().type_ptr_to(bx.cx().backend_type(field))),\n                 llextra: if bx.cx().type_has_metadata(field.ty) {\n                     self.llextra\n@@ -134,7 +134,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n \n         // Simple cases, which don't need DST adjustment:\n         //   * no metadata available - just log the case\n-        //   * known alignment - sized types, [T], str or a foreign type\n+        //   * known alignment - sized types, `[T]`, `str` or a foreign type\n         //   * packed struct - there is no alignment padding\n         match field.ty.sty {\n             _ if self.llextra.is_none() => {\n@@ -156,18 +156,19 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n         }\n \n         // We need to get the pointer manually now.\n-        // We do this by casting to a *i8, then offsetting it by the appropriate amount.\n+        // We do this by casting to a `*i8`, then offsetting it by the appropriate amount.\n         // We do this instead of, say, simply adjusting the pointer from the result of a GEP\n         // because the field may have an arbitrary alignment in the LLVM representation\n         // anyway.\n         //\n         // To demonstrate:\n-        //   struct Foo<T: ?Sized> {\n-        //      x: u16,\n-        //      y: T\n-        //   }\n         //\n-        // The type Foo<Foo<Trait>> is represented in LLVM as { u16, { u16, u8 }}, meaning that\n+        //     struct Foo<T: ?Sized> {\n+        //         x: u16,\n+        //         y: T\n+        //     }\n+        //\n+        // The type `Foo<Foo<Trait>>` is represented in LLVM as `{ u16, { u16, u8 }}`, meaning that\n         // the `y` field has 16-bit alignment.\n \n         let meta = self.llextra;\n@@ -180,21 +181,21 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n         // Bump the unaligned offset up to the appropriate alignment using the\n         // following expression:\n         //\n-        //   (unaligned offset + (align - 1)) & -align\n+        //     (unaligned offset + (align - 1)) & -align\n \n-        // Calculate offset\n+        // Calculate offset.\n         let align_sub_1 = bx.sub(unsized_align, bx.cx().const_usize(1u64));\n         let and_lhs = bx.add(unaligned_offset, align_sub_1);\n         let and_rhs = bx.neg(unsized_align);\n         let offset = bx.and(and_lhs, and_rhs);\n \n         debug!(\"struct_field_ptr: DST field offset: {:?}\", offset);\n \n-        // Cast and adjust pointer\n+        // Cast and adjust pointer.\n         let byte_ptr = bx.pointercast(self.llval, bx.cx().type_i8p());\n         let byte_ptr = bx.gep(byte_ptr, &[offset]);\n \n-        // Finally, cast back to the type expected\n+        // Finally, cast back to the type expected.\n         let ll_fty = bx.cx().backend_type(field);\n         debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n \n@@ -235,7 +236,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n                     // We use `i1` for bytes that are always `0` or `1`,\n                     // e.g., `#[repr(i8)] enum E { A, B }`, but we can't\n                     // let LLVM interpret the `i1` as signed, because\n-                    // then `i1 1` (i.e., E::B) is effectively `i8 -1`.\n+                    // then `i1 1` (i.e., `E::B`) is effectively `i8 -1`.\n                     layout::Int(_, signed) => !discr_scalar.is_bool() && signed,\n                     _ => false\n                 };\n@@ -248,9 +249,9 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n             } => {\n                 let niche_llty = bx.cx().immediate_backend_type(discr.layout);\n                 if niche_variants.start() == niche_variants.end() {\n-                    // FIXME(eddyb) Check the actual primitive type here.\n+                    // FIXME(eddyb): check the actual primitive type here.\n                     let niche_llval = if niche_start == 0 {\n-                        // HACK(eddyb) Using `c_null` as it works on all types.\n+                        // HACK(eddyb): using `c_null` as it works on all types.\n                         bx.cx().const_null(niche_llty)\n                     } else {\n                         bx.cx().const_uint_big(niche_llty, niche_start)\n@@ -314,7 +315,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n                 if variant_index != dataful_variant {\n                     if bx.cx().sess().target.target.arch == \"arm\" ||\n                        bx.cx().sess().target.target.arch == \"aarch64\" {\n-                        // Issue #34427: As workaround for LLVM bug on ARM,\n+                        // FIXME(#34427): as workaround for LLVM bug on ARM,\n                         // use memset of 0 before assigning niche value.\n                         let fill_byte = bx.cx().const_u8(0);\n                         let size = bx.cx().const_usize(self.layout.size.bytes());\n@@ -326,9 +327,9 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n                     let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n                     let niche_value = (niche_value as u128)\n                         .wrapping_add(niche_start);\n-                    // FIXME(eddyb) Check the actual primitive type here.\n+                    // FIXME(eddyb): check the actual primitive type here.\n                     let niche_llval = if niche_value == 0 {\n-                        // HACK(eddyb) Using `c_null` as it works on all types.\n+                        // HACK(eddyb): using `c_null` as it works on all types.\n                         bx.cx().const_null(niche_llty)\n                     } else {\n                         bx.cx().const_uint_big(niche_llty, niche_value)\n@@ -429,10 +430,10 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         _ => bug!(\"promoteds should have an allocation: {:?}\", val),\n                     },\n                     Err(_) => {\n-                        // this is unreachable as long as runtime\n+                        // This is unreachable as long as runtime\n                         // and compile-time agree on values\n-                        // With floats that won't always be true\n-                        // so we generate an abort\n+                        // With floats that won't always be true,\n+                        // so we generate an abort.\n                         bx.abort();\n                         let llval = bx.cx().const_undef(\n                             bx.cx().type_ptr_to(bx.cx().backend_type(layout))\n@@ -502,7 +503,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n \n                         // Cast the place pointer type to the new\n-                        // array or slice type (*[%_; new_len]).\n+                        // array or slice type (`*[%_; new_len]`).\n                         subslice.llval = bx.pointercast(subslice.llval,\n                             bx.cx().type_ptr_to(bx.cx().backend_type(subslice.layout)));\n "}, {"sha": "f4f7456a97ad65b746e8eb41296340265e210348", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -717,7 +717,13 @@ impl<'a> ReplaceBodyWithLoop<'a> {\n                                     _ => None,\n                                 });\n                                 any_involves_impl_trait(types.into_iter()) ||\n-                                any_involves_impl_trait(data.bindings.iter().map(|b| &b.ty))\n+                                data.constraints.iter().any(|c| {\n+                                    match c.kind {\n+                                        ast::AssocTyConstraintKind::Bound { .. } => true,\n+                                        ast::AssocTyConstraintKind::Equality { ref ty } =>\n+                                            involves_impl_trait(ty),\n+                                    }\n+                                })\n                             },\n                             Some(&ast::GenericArgs::Parenthesized(ref data)) => {\n                                 any_involves_impl_trait(data.inputs.iter()) ||"}, {"sha": "937085c8ad8e8e1e17ab6e75479cfbb207645353", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -196,7 +196,7 @@ declare_lint_pass!(UnsafeCode => [UNSAFE_CODE]);\n \n impl UnsafeCode {\n     fn report_unsafe(&self, cx: &EarlyContext<'_>, span: Span, desc: &'static str) {\n-        // This comes from a macro that has #[allow_internal_unsafe].\n+        // This comes from a macro that has `#[allow_internal_unsafe]`.\n         if span.allows_unsafe() {\n             return;\n         }\n@@ -216,7 +216,7 @@ impl EarlyLintPass for UnsafeCode {\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         if let ast::ExprKind::Block(ref blk, _) = e.node {\n-            // Don't warn about generated blocks, that'll just pollute the output.\n+            // Don't warn about generated blocks; that'll just pollute the output.\n             if blk.rules == ast::BlockCheckMode::Unsafe(ast::UserProvided) {\n                 self.report_unsafe(cx, blk.span, \"usage of an `unsafe` block\");\n             }\n@@ -335,7 +335,7 @@ impl MissingDoc {\n \n         // Only check publicly-visible items, using the result from the privacy pass.\n         // It's an option so the crate root can also use this function (it doesn't\n-        // have a NodeId).\n+        // have a `NodeId`).\n         if let Some(id) = id {\n             if !cx.access_levels.is_exported(id) {\n                 return;\n@@ -389,7 +389,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ItemKind::Struct(..) => \"a struct\",\n             hir::ItemKind::Union(..) => \"a union\",\n             hir::ItemKind::Trait(.., ref trait_item_refs) => {\n-                // Issue #11592, traits are always considered exported, even when private.\n+                // Issue #11592: traits are always considered exported, even when private.\n                 if let hir::VisibilityKind::Inherited = it.vis.node {\n                     self.private_traits.insert(it.hir_id);\n                     for trait_item_ref in trait_item_refs {\n@@ -401,7 +401,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             }\n             hir::ItemKind::Ty(..) => \"a type alias\",\n             hir::ItemKind::Impl(.., Some(ref trait_ref), _, ref impl_item_refs) => {\n-                // If the trait is private, add the impl items to private_traits so they don't get\n+                // If the trait is private, add the impl items to `private_traits` so they don't get\n                 // reported for missing docs.\n                 let real_trait = trait_ref.path.res.def_id();\n                 if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(real_trait) {\n@@ -1215,7 +1215,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n         use rustc::ty::fold::TypeFoldable;\n         use rustc::ty::Predicate::*;\n \n-\n         if cx.tcx.features().trivial_bounds {\n             let def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n             let predicates = cx.tcx.predicates_of(def_id);\n@@ -1464,7 +1463,7 @@ impl KeywordIdents {\n             _ => return,\n         };\n \n-        // don't lint `r#foo`\n+        // Don't lint `r#foo`.\n         if cx.sess.parse_sess.raw_identifier_spans.borrow().contains(&ident.span) {\n             return;\n         }\n@@ -1717,8 +1716,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n                 );\n                 err.emit();\n             }\n-\n         }\n     }\n-\n }"}, {"sha": "3bf0f7e04d29540ebcbc41131e63bde0303bd621", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -576,7 +576,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Adds a suggestion to errors where a `impl Trait` is returned.\n     ///\n     /// ```text\n-    /// help: to allow this impl Trait to capture borrowed data with lifetime `'1`, add `'_` as\n+    /// help: to allow this `impl Trait` to capture borrowed data with lifetime `'1`, add `'_` as\n     ///       a constraint\n     ///    |\n     /// LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + 'a {\n@@ -652,7 +652,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         diag.span_suggestion(\n                             span,\n                             &format!(\n-                                \"to allow this impl Trait to capture borrowed data with lifetime \\\n+                                \"to allow this `impl Trait` to capture borrowed data with lifetime \\\n                                  `{}`, add `{}` as a constraint\",\n                                 fr_name, suggestable_fr_name,\n                             ),"}, {"sha": "7ca54a430a505531b9d816b77273355a5e701032", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -289,9 +289,9 @@ pub enum BlockFrame {\n     /// Evaluation is currently within a statement.\n     ///\n     /// Examples include:\n-    ///  1. `EXPR;`\n-    ///  2. `let _ = EXPR;`\n-    ///  3. `let x = EXPR;`\n+    /// 1. `EXPR;`\n+    /// 2. `let _ = EXPR;`\n+    /// 3. `let x = EXPR;`\n     Statement {\n         /// If true, then statement discards result from evaluating\n         /// the expression (such as examples 1 and 2 above)."}, {"sha": "2c84364216633f9431aecc7eb103e4f6a3fd1c77", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -90,7 +90,7 @@\n //!\n //! Note though that as a side-effect of creating a codegen units per\n //! source-level module, functions from the same module will be available for\n-//! inlining, even when they are not marked #[inline].\n+//! inlining, even when they are not marked `#[inline]`.\n \n use std::collections::hash_map::Entry;\n use std::cmp;\n@@ -152,7 +152,7 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // In the next step, we use the inlining map to determine which additional\n     // monomorphizations have to go into each codegen unit. These additional\n     // monomorphizations can be drop-glue, functions from external crates, and\n-    // local functions the definition of which is marked with #[inline].\n+    // local functions the definition of which is marked with `#[inline]`.\n     let mut post_inlining = place_inlined_mono_items(initial_partitioning,\n                                                             inlining_map);\n \n@@ -166,7 +166,7 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         internalize_symbols(tcx, &mut post_inlining, inlining_map);\n     }\n \n-    // Finally, sort by codegen unit name, so that we get deterministic results\n+    // Finally, sort by codegen unit name, so that we get deterministic results.\n     let PostInliningPartitioning {\n         codegen_units: mut result,\n         mono_item_placements: _,\n@@ -258,8 +258,8 @@ fn place_root_mono_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         roots.insert(mono_item);\n     }\n \n-    // always ensure we have at least one CGU; otherwise, if we have a\n-    // crate with just types (for example), we could wind up with no CGU\n+    // Always ensure we have at least one CGU; otherwise, if we have a\n+    // crate with just types (for example), we could wind up with no CGU.\n     if codegen_units.is_empty() {\n         let codegen_unit_name = fallback_cgu_name(cgu_name_builder);\n         codegen_units.insert(codegen_unit_name.clone(),\n@@ -300,10 +300,10 @@ fn mono_item_visibility(\n     export_generics: bool,\n ) -> Visibility {\n     let instance = match mono_item {\n-        // This is pretty complicated, go below\n+        // This is pretty complicated; see below.\n         MonoItem::Fn(instance) => instance,\n \n-        // Misc handling for generics and such, but otherwise\n+        // Misc handling for generics and such, but otherwise:\n         MonoItem::Static(def_id) => {\n             return if tcx.is_reachable_non_generic(*def_id) {\n                 *can_be_internalized = false;\n@@ -358,11 +358,10 @@ fn mono_item_visibility(\n \n     let is_generic = instance.substs.non_erasable_generics().next().is_some();\n \n-    // Upstream `DefId` instances get different handling than local ones\n+    // Upstream `DefId` instances get different handling than local ones.\n     if !def_id.is_local() {\n         return if export_generics && is_generic {\n-            // If it is a upstream monomorphization\n-            // and we export generics, we must make\n+            // If it is a upstream monomorphization and we export generics, we must make\n             // it available to downstream crates.\n             *can_be_internalized = false;\n             default_visibility(tcx, def_id, true)\n@@ -374,20 +373,16 @@ fn mono_item_visibility(\n     if is_generic {\n         if export_generics {\n             if tcx.is_unreachable_local_definition(def_id) {\n-                // This instance cannot be used\n-                // from another crate.\n+                // This instance cannot be used from another crate.\n                 Visibility::Hidden\n             } else {\n-                // This instance might be useful in\n-                // a downstream crate.\n+                // This instance might be useful in a downstream crate.\n                 *can_be_internalized = false;\n                 default_visibility(tcx, def_id, true)\n             }\n         } else {\n-            // We are not exporting generics or\n-            // the definition is not reachable\n-            // for downstream crates, we can\n-            // internalize its instantiations.\n+            // We are not exporting generics or the definition is not reachable\n+            // for downstream crates, we can internalize its instantiations.\n             Visibility::Hidden\n         }\n     } else {\n@@ -449,19 +444,19 @@ fn default_visibility(tcx: TyCtxt<'_, '_, '_>, id: DefId, is_generic: bool) -> V\n         return Visibility::Default\n     }\n \n-    // Generic functions never have export level C\n+    // Generic functions never have export-level C.\n     if is_generic {\n         return Visibility::Hidden\n     }\n \n     // Things with export level C don't get instantiated in\n-    // downstream crates\n+    // downstream crates.\n     if !id.is_local() {\n         return Visibility::Hidden\n     }\n \n     // C-export level items remain at `Default`, all other internal\n-    // items become `Hidden`\n+    // items become `Hidden`.\n     match tcx.reachable_non_generics(id.krate).get(&id) {\n         Some(SymbolExportLevel::C) => Visibility::Default,\n         _ => Visibility::Hidden,\n@@ -519,26 +514,26 @@ fn place_inlined_mono_items<'tcx>(initial_partitioning: PreInliningPartitioning<\n     let single_codegen_unit = initial_cgus.len() == 1;\n \n     for old_codegen_unit in initial_cgus {\n-        // Collect all items that need to be available in this codegen unit\n+        // Collect all items that need to be available in this codegen unit.\n         let mut reachable = FxHashSet::default();\n         for root in old_codegen_unit.items().keys() {\n             follow_inlining(*root, inlining_map, &mut reachable);\n         }\n \n         let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name().clone());\n \n-        // Add all monomorphizations that are not already there\n+        // Add all monomorphizations that are not already there.\n         for mono_item in reachable {\n             if let Some(linkage) = old_codegen_unit.items().get(&mono_item) {\n-                // This is a root, just copy it over\n+                // This is a root, just copy it over.\n                 new_codegen_unit.items_mut().insert(mono_item, *linkage);\n             } else {\n                 if roots.contains(&mono_item) {\n                     bug!(\"GloballyShared mono-item inlined into other CGU: \\\n                           {:?}\", mono_item);\n                 }\n \n-                // This is a cgu-private copy\n+                // This is a CGU-private copy.\n                 new_codegen_unit.items_mut().insert(\n                     mono_item,\n                     (Linkage::Internal, Visibility::Default),\n@@ -547,7 +542,7 @@ fn place_inlined_mono_items<'tcx>(initial_partitioning: PreInliningPartitioning<\n \n             if !single_codegen_unit {\n                 // If there is more than one codegen unit, we need to keep track\n-                // in which codegen units each monomorphization is placed:\n+                // in which codegen units each monomorphization is placed.\n                 match mono_item_placements.entry(mono_item) {\n                     Entry::Occupied(e) => {\n                         let placement = e.into_mut();\n@@ -656,8 +651,8 @@ fn internalize_symbols<'a, 'tcx>(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn characteristic_def_id_of_mono_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                 mono_item: MonoItem<'tcx>)\n-                                                 -> Option<DefId> {\n+                                                mono_item: MonoItem<'tcx>)\n+                                                -> Option<DefId> {\n     match mono_item {\n         MonoItem::Fn(instance) => {\n             let def_id = match instance.def {\n@@ -709,10 +704,10 @@ fn compute_codegen_unit_name(tcx: TyCtxt<'_, '_, '_>,\n                              volatile: bool,\n                              cache: &mut CguNameCache)\n                              -> InternedString {\n-    // Find the innermost module that is not nested within a function\n+    // Find the innermost module that is not nested within a function.\n     let mut current_def_id = def_id;\n     let mut cgu_def_id = None;\n-    // Walk backwards from the item we want to find the module for:\n+    // Walk backwards from the item we want to find the module for.\n     loop {\n         if current_def_id.index == CRATE_DEF_INDEX {\n             if cgu_def_id.is_none() {"}, {"sha": "532cec2af159ee8900cab4df34831b3b1a96a78e", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 58, "deletions": 21, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -1,4 +1,4 @@\n-// Validate AST before lowering it to HIR\n+// Validate AST before lowering it to HIR.\n //\n // This pass is supposed to catch things that fit into AST data structures,\n // but not permitted by the language. It runs after expansion when AST is frozen,\n@@ -56,13 +56,17 @@ struct AstValidator<'a> {\n \n     /// Used to ban nested `impl Trait`, e.g., `impl Into<impl Debug>`.\n     /// Nested `impl Trait` _is_ allowed in associated type position,\n-    /// e.g `impl Iterator<Item=impl Debug>`\n+    /// e.g., `impl Iterator<Item = impl Debug>`.\n     outer_impl_trait: Option<OuterImplTrait>,\n \n     /// Used to ban `impl Trait` in path projections like `<impl Iterator>::Item`\n     /// or `Foo::Bar<impl Trait>`\n     is_impl_trait_banned: bool,\n \n+    /// Used to ban associated type bounds (i.e., `Type<AssocType: Bounds>`) in\n+    /// certain positions.\n+    is_assoc_ty_bound_banned: bool,\n+\n     /// rust-lang/rust#57979: the ban of nested `impl Trait` was buggy\n     /// until PRs #57730 and #57981 landed: it would jump directly to\n     /// walk_ty rather than visit_ty (or skip recurring entirely for\n@@ -87,26 +91,43 @@ impl<'a> AstValidator<'a> {\n         self.is_impl_trait_banned = old;\n     }\n \n+    fn with_banned_assoc_ty_bound(&mut self, f: impl FnOnce(&mut Self)) {\n+        let old = mem::replace(&mut self.is_assoc_ty_bound_banned, true);\n+        f(self);\n+        self.is_assoc_ty_bound_banned = old;\n+    }\n+\n     fn with_impl_trait(&mut self, outer: Option<OuterImplTrait>, f: impl FnOnce(&mut Self)) {\n         let old = mem::replace(&mut self.outer_impl_trait, outer);\n         f(self);\n         self.outer_impl_trait = old;\n     }\n \n-    fn visit_assoc_type_binding_from_generic_args(&mut self, type_binding: &'a TypeBinding) {\n-        // rust-lang/rust#57979: bug in old visit_generic_args called\n-        // walk_ty rather than visit_ty, skipping outer `impl Trait`\n-        // if it happened to occur at `type_binding.ty`\n-        if let TyKind::ImplTrait(..) = type_binding.ty.node {\n-            self.warning_period_57979_didnt_record_next_impl_trait = true;\n+    fn visit_assoc_ty_constraint_from_generic_args(&mut self, constraint: &'a AssocTyConstraint) {\n+        match constraint.kind {\n+            AssocTyConstraintKind::Equality { ref ty } => {\n+                // rust-lang/rust#57979: bug in old `visit_generic_args` called\n+                // `walk_ty` rather than `visit_ty`, skipping outer `impl Trait`\n+                // if it happened to occur at `ty`.\n+                if let TyKind::ImplTrait(..) = ty.node {\n+                    self.warning_period_57979_didnt_record_next_impl_trait = true;\n+                }\n+            }\n+            AssocTyConstraintKind::Bound { .. } => {\n+                if self.is_assoc_ty_bound_banned {\n+                    self.err_handler().span_err(constraint.span,\n+                        \"associated type bounds are not allowed within structs, enums, or unions\"\n+                    );\n+                }\n+            }\n         }\n-        self.visit_assoc_type_binding(type_binding);\n+        self.visit_assoc_ty_constraint(constraint);\n     }\n \n     fn visit_ty_from_generic_args(&mut self, ty: &'a Ty) {\n-        // rust-lang/rust#57979: bug in old visit_generic_args called\n-        // walk_ty rather than visit_ty, skippping outer `impl Trait`\n-        // if it happened to occur at `ty`\n+        // rust-lang/rust#57979: bug in old `visit_generic_args` called\n+        // `walk_ty` rather than `visit_ty`, skippping outer `impl Trait`\n+        // if it happened to occur at `ty`.\n         if let TyKind::ImplTrait(..) = ty.node {\n             self.warning_period_57979_didnt_record_next_impl_trait = true;\n         }\n@@ -117,18 +138,18 @@ impl<'a> AstValidator<'a> {\n         let only_recorded_since_pull_request_57730 =\n             self.warning_period_57979_didnt_record_next_impl_trait;\n \n-        // (this flag is designed to be set to true and then only\n+        // (This flag is designed to be set to `true`, and then only\n         // reach the construction point for the outer impl trait once,\n         // so its safe and easiest to unconditionally reset it to\n-        // false)\n+        // false.)\n         self.warning_period_57979_didnt_record_next_impl_trait = false;\n \n         OuterImplTrait {\n             span, only_recorded_since_pull_request_57730,\n         }\n     }\n \n-    // Mirrors visit::walk_ty, but tracks relevant state\n+    // Mirrors `visit::walk_ty`, but tracks relevant state.\n     fn walk_ty(&mut self, t: &'a Ty) {\n         match t.node {\n             TyKind::ImplTrait(..) => {\n@@ -619,15 +640,18 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     // Auto traits cannot have generics, super traits nor contain items.\n                     if !generics.params.is_empty() {\n                         struct_span_err!(self.session, item.span, E0567,\n-                                        \"auto traits cannot have generic parameters\").emit();\n+                            \"auto traits cannot have generic parameters\"\n+                        ).emit();\n                     }\n                     if !bounds.is_empty() {\n                         struct_span_err!(self.session, item.span, E0568,\n-                                        \"auto traits cannot have super traits\").emit();\n+                            \"auto traits cannot have super traits\"\n+                        ).emit();\n                     }\n                     if !trait_items.is_empty() {\n                         struct_span_err!(self.session, item.span, E0380,\n-                                \"auto traits cannot have methods or associated items\").emit();\n+                            \"auto traits cannot have methods or associated items\"\n+                        ).emit();\n                     }\n                 }\n                 self.no_questions_in_bounds(bounds, \"supertraits\", true);\n@@ -699,7 +723,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_foreign_item(self, fi)\n     }\n \n-    // Mirrors visit::walk_generic_args, but tracks relevant state\n+    // Mirrors `visit::walk_generic_args`, but tracks relevant state.\n     fn visit_generic_args(&mut self, _: Span, generic_args: &'a GenericArgs) {\n         match *generic_args {\n             GenericArgs::AngleBracketed(ref data) => {\n@@ -718,10 +742,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     generic_args.span(),\n                 );\n \n-                // Type bindings such as `Item=impl Debug` in `Iterator<Item=Debug>`\n+                // Type bindings such as `Item = impl Debug` in `Iterator<Item = Debug>`\n                 // are allowed to contain nested `impl Trait`.\n                 self.with_impl_trait(None, |this| {\n-                    walk_list!(this, visit_assoc_type_binding_from_generic_args, &data.bindings);\n+                    walk_list!(this, visit_assoc_ty_constraint_from_generic_args,\n+                        &data.constraints);\n                 });\n             }\n             GenericArgs::Parenthesized(ref data) => {\n@@ -814,6 +839,17 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_poly_trait_ref(self, t, m);\n     }\n \n+    fn visit_variant_data(&mut self, s: &'a VariantData, _: Ident,\n+                          _: &'a Generics, _: NodeId, _: Span) {\n+        self.with_banned_assoc_ty_bound(|this| visit::walk_struct_def(this, s))\n+    }\n+\n+    fn visit_enum_def(&mut self, enum_definition: &'a EnumDef,\n+                      generics: &'a Generics, item_id: NodeId, _: Span) {\n+        self.with_banned_assoc_ty_bound(\n+            |this| visit::walk_enum_def(this, enum_definition, generics, item_id))\n+    }\n+\n     fn visit_mac(&mut self, mac: &Spanned<Mac_>) {\n         // when a new macro kind is added but the author forgets to set it up for expansion\n         // because that's the only part that won't cause a compiler error\n@@ -837,6 +873,7 @@ pub fn check_crate(session: &Session, krate: &Crate) -> (bool, bool) {\n         has_global_allocator: false,\n         outer_impl_trait: None,\n         is_impl_trait_banned: false,\n+        is_assoc_ty_bound_banned: false,\n         warning_period_57979_didnt_record_next_impl_trait: false,\n         warning_period_57979_impl_trait_in_proj: false,\n     };"}, {"sha": "6936aedb9de80d48f93482a3423dd8b60961bc28", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -353,9 +353,9 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n         ast_visit::walk_path_segment(self, path_span, path_segment)\n     }\n \n-    fn visit_assoc_type_binding(&mut self, type_binding: &'v ast::TypeBinding) {\n-        self.record(\"TypeBinding\", Id::None, type_binding);\n-        ast_visit::walk_assoc_type_binding(self, type_binding)\n+    fn visit_assoc_ty_constraint(&mut self, constraint: &'v ast::AssocTyConstraint) {\n+        self.record(\"AssocTyConstraint\", Id::None, constraint);\n+        ast_visit::walk_assoc_ty_constraint(self, constraint)\n     }\n \n     fn visit_attribute(&mut self, attr: &'v ast::Attribute) {"}, {"sha": "6d01328cd16e686bb08ed3342bcf96efc8010cfd", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -1040,12 +1040,11 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         if !self.in_body {\n             // Avoid calling `hir_trait_to_predicates` in bodies, it will ICE.\n             // The traits' privacy in bodies is already checked as a part of trait object types.\n-            let (principal, projections) =\n-                rustc_typeck::hir_trait_to_predicates(self.tcx, trait_ref);\n+            let (principal, bounds) = rustc_typeck::hir_trait_to_predicates(self.tcx, trait_ref);\n             if self.visit_trait(*principal.skip_binder()) {\n                 return;\n             }\n-            for (poly_predicate, _) in projections {\n+            for (poly_predicate, _) in bounds.projection_bounds {\n                 let tcx = self.tcx;\n                 if self.visit(poly_predicate.skip_binder().ty) ||\n                    self.visit_trait(poly_predicate.skip_binder().projection_ty.trait_ref(tcx)) {"}, {"sha": "18f3c0285c210238563eda858b33e17861246191", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -2134,7 +2134,7 @@ impl<'a> Resolver<'a> {\n                                       record_used_id: Option<NodeId>,\n                                       path_span: Span)\n                                       -> Option<LexicalScopeBinding<'a>> {\n-        assert!(ns == TypeNS  || ns == ValueNS);\n+        assert!(ns == TypeNS || ns == ValueNS);\n         if ident.name == kw::Invalid {\n             return Some(LexicalScopeBinding::Res(Res::Err));\n         }\n@@ -2529,11 +2529,23 @@ impl<'a> Resolver<'a> {\n         debug!(\"(resolving item) resolving {} ({:?})\", name, item.node);\n \n         match item.node {\n-            ItemKind::Ty(_, ref generics) |\n-            ItemKind::Fn(_, _, ref generics, _) |\n-            ItemKind::Existential(_, ref generics) => {\n-                self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind),\n-                                             |this| visit::walk_item(this, item));\n+            ItemKind::Ty(_, ref generics) => {\n+                self.with_current_self_item(item, |this| {\n+                    this.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n+                        let item_def_id = this.definitions.local_def_id(item.id);\n+                        this.with_self_rib(Res::SelfTy(Some(item_def_id), None), |this| {\n+                            visit::walk_item(this, item)\n+                        })\n+                    })\n+                });\n+            }\n+\n+            ItemKind::Existential(_, ref generics) |\n+            ItemKind::Fn(_, _, ref generics, _) => {\n+                self.with_generic_param_rib(\n+                    HasGenericParams(generics, ItemRibKind),\n+                    |this| visit::walk_item(this, item)\n+                );\n             }\n \n             ItemKind::Enum(_, ref generics) |\n@@ -2967,7 +2979,7 @@ impl<'a> Resolver<'a> {\n         binding_map\n     }\n \n-    // check that all of the arms in an or-pattern have exactly the\n+    // Checks that all of the arms in an or-pattern have exactly the\n     // same set of bindings, with the same binding modes for each.\n     fn check_consistent_bindings(&mut self, pats: &[P<Pat>]) {\n         if pats.is_empty() {\n@@ -2987,7 +2999,7 @@ impl<'a> Resolver<'a> {\n                 let map_j = self.binding_mode_map(&q);\n                 for (&key, &binding_i) in &map_i {\n                     if map_j.is_empty() {                   // Account for missing bindings when\n-                        let binding_error = missing_vars    // map_j has none.\n+                        let binding_error = missing_vars    // `map_j` has none.\n                             .entry(key.name)\n                             .or_insert(BindingError {\n                                 name: key.name,"}, {"sha": "34f817ba570e705d4a7809e95844537e2a5666c0", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 373, "deletions": 101, "changes": 474, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -8,6 +8,7 @@ use crate::hir::def::{CtorOf, Res, DefKind};\n use crate::hir::def_id::DefId;\n use crate::hir::HirVec;\n use crate::lint;\n+use crate::middle::lang_items::SizedTraitLangItem;\n use crate::middle::resolve_lifetime as rl;\n use crate::namespace::Namespace;\n use rustc::lint::builtin::AMBIGUOUS_ASSOCIATED_ITEMS;\n@@ -47,14 +48,14 @@ pub trait AstConv<'gcx, 'tcx> {\n     fn get_type_parameter_bounds(&self, span: Span, def_id: DefId)\n                                  -> &'tcx ty::GenericPredicates<'tcx>;\n \n-    /// What lifetime should we use when a lifetime is omitted (and not elided)?\n+    /// Returns the lifetime to use when a lifetime is omitted (and not elided).\n     fn re_infer(&self, span: Span, _def: Option<&ty::GenericParamDef>)\n                 -> Option<ty::Region<'tcx>>;\n \n-    /// What type should we use when a type is omitted?\n+    /// Returns the type to use when a type is omitted.\n     fn ty_infer(&self, span: Span) -> Ty<'tcx>;\n \n-    /// Same as ty_infer, but with a known type parameter definition.\n+    /// Same as `ty_infer`, but with a known type parameter definition.\n     fn ty_infer_for_def(&self,\n                         _def: &ty::GenericParamDef,\n                         span: Span) -> Ty<'tcx> {\n@@ -86,12 +87,22 @@ pub trait AstConv<'gcx, 'tcx> {\n     fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, span: Span);\n }\n \n+pub enum SizedByDefault {\n+    Yes,\n+    No,\n+}\n+\n struct ConvertedBinding<'tcx> {\n     item_name: ast::Ident,\n-    ty: Ty<'tcx>,\n+    kind: ConvertedBindingKind<'tcx>,\n     span: Span,\n }\n \n+enum ConvertedBindingKind<'tcx> {\n+    Equality(Ty<'tcx>),\n+    Constraint(P<[hir::GenericBound]>),\n+}\n+\n #[derive(PartialEq)]\n enum GenericArgPosition {\n     Type,\n@@ -376,8 +387,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             }\n             err.emit();\n \n-            (provided > required, // `suppress_error`\n-             potential_assoc_types)\n+            (\n+                provided > required, // `suppress_error`\n+                potential_assoc_types,\n+            )\n         };\n \n         if reported_late_bound_region_err.is_none()\n@@ -556,14 +569,29 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     }\n \n     /// Given the type/lifetime/const arguments provided to some path (along with\n-    /// an implicit `Self`, if this is a trait reference) returns the complete\n+    /// an implicit `Self`, if this is a trait reference), returns the complete\n     /// set of substitutions. This may involve applying defaulted type parameters.\n+    /// Also returns back constriants on associated types.\n+    ///\n+    /// Example:\n+    ///\n+    /// ```\n+    /// T: std::ops::Index<usize, Output = u32>\n+    /// ^1 ^^^^^^^^^^^^^^2 ^^^^3  ^^^^^^^^^^^4\n+    /// ```\n+    ///\n+    /// 1. The `self_ty` here would refer to the type `T`.\n+    /// 2. The path in question is the path to the trait `std::ops::Index`,\n+    ///    which will have been resolved to a `def_id`\n+    /// 3. The `generic_args` contains info on the `<...>` contents. The `usize` type\n+    ///    parameters are returned in the `SubstsRef`, the associated type bindings like\n+    ///    `Output = u32` are returned in the `Vec<ConvertedBinding...>` result.\n     ///\n     /// Note that the type listing given here is *exactly* what the user provided.\n-    fn create_substs_for_ast_path(&self,\n+    fn create_substs_for_ast_path<'a>(&self,\n         span: Span,\n         def_id: DefId,\n-        generic_args: &hir::GenericArgs,\n+        generic_args: &'a hir::GenericArgs,\n         infer_types: bool,\n         self_ty: Option<Ty<'tcx>>)\n         -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'tcx>>, Option<Vec<Span>>)\n@@ -686,13 +714,30 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             },\n         );\n \n-        let assoc_bindings = generic_args.bindings.iter().map(|binding| {\n-            ConvertedBinding {\n-                item_name: binding.ident,\n-                ty: self.ast_ty_to_ty(&binding.ty),\n-                span: binding.span,\n-            }\n-        }).collect();\n+        // Convert associated-type bindings or constraints into a separate vector.\n+        // Example: Given this:\n+        //\n+        //     T: Iterator<Item = u32>\n+        //\n+        // The `T` is passed in as a self-type; the `Item = u32` is\n+        // not a \"type parameter\" of the `Iterator` trait, but rather\n+        // a restriction on `<T as Iterator>::Item`, so it is passed\n+        // back separately.\n+        let assoc_bindings = generic_args.bindings.iter()\n+            .map(|binding| {\n+                let kind = match binding.kind {\n+                    hir::TypeBindingKind::Equality { ref ty } =>\n+                        ConvertedBindingKind::Equality(self.ast_ty_to_ty(ty)),\n+                    hir::TypeBindingKind::Constraint { ref bounds } =>\n+                        ConvertedBindingKind::Constraint(bounds.clone()),\n+                };\n+                ConvertedBinding {\n+                    item_name: binding.ident,\n+                    kind,\n+                    span: binding.span,\n+                }\n+            })\n+            .collect();\n \n         debug!(\"create_substs_for_ast_path(generic_params={:?}, self_ty={:?}) -> {:?}\",\n                generic_params, self_ty, substs);\n@@ -708,8 +753,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     /// are disallowed. Otherwise, they are pushed onto the vector given.\n     pub fn instantiate_mono_trait_ref(&self,\n         trait_ref: &hir::TraitRef,\n-        self_ty: Ty<'tcx>)\n-        -> ty::TraitRef<'tcx>\n+        self_ty: Ty<'tcx>\n+    ) -> ty::TraitRef<'tcx>\n     {\n         self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n \n@@ -723,9 +768,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     pub(super) fn instantiate_poly_trait_ref_inner(&self,\n         trait_ref: &hir::TraitRef,\n         self_ty: Ty<'tcx>,\n-        poly_projections: &mut Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>,\n-        speculative: bool)\n-        -> (ty::PolyTraitRef<'tcx>, Option<Vec<Span>>)\n+        bounds: &mut Bounds<'tcx>,\n+        speculative: bool,\n+    ) -> (ty::PolyTraitRef<'tcx>, Option<Vec<Span>>)\n     {\n         let trait_def_id = trait_ref.trait_def_id();\n \n@@ -742,36 +787,59 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         let poly_trait_ref = ty::Binder::bind(ty::TraitRef::new(trait_def_id, substs));\n \n         let mut dup_bindings = FxHashMap::default();\n-        poly_projections.extend(assoc_bindings.iter().filter_map(|binding| {\n-            // specify type to assert that error was already reported in Err case:\n-            let predicate: Result<_, ErrorReported> =\n-                self.ast_type_binding_to_poly_projection_predicate(\n-                    trait_ref.hir_ref_id, poly_trait_ref, binding, speculative, &mut dup_bindings);\n-            // okay to ignore Err because of ErrorReported (see above)\n-            Some((predicate.ok()?, binding.span))\n-        }));\n-\n-        debug!(\"instantiate_poly_trait_ref({:?}, projections={:?}) -> {:?}\",\n-               trait_ref, poly_projections, poly_trait_ref);\n+        for binding in &assoc_bindings {\n+            // Specify type to assert that error was already reported in `Err` case.\n+            let _: Result<_, ErrorReported> =\n+                self.add_predicates_for_ast_type_binding(\n+                    trait_ref.hir_ref_id,\n+                    poly_trait_ref,\n+                    binding,\n+                    bounds,\n+                    speculative,\n+                    &mut dup_bindings\n+                );\n+            // Okay to ignore `Err` because of `ErrorReported` (see above).\n+        }\n+\n+        debug!(\"instantiate_poly_trait_ref({:?}, bounds={:?}) -> {:?}\",\n+               trait_ref, bounds, poly_trait_ref);\n         (poly_trait_ref, potential_assoc_types)\n     }\n \n+    /// Given a trait bound like `Debug`, applies that trait bound the given self-type to construct\n+    /// a full trait reference. The resulting trait reference is returned. This may also generate\n+    /// auxiliary bounds, which are added to `bounds`.\n+    ///\n+    /// Example:\n+    ///\n+    /// ```\n+    /// poly_trait_ref = Iterator<Item = u32>\n+    /// self_ty = Foo\n+    /// ```\n+    ///\n+    /// this would return `Foo: Iterator` and add `<Foo as Iterator>::Item = u32` into `bounds`.\n+    ///\n+    /// **A note on binders:** against our usual convention, there is an implied bounder around\n+    /// the `self_ty` and `poly_trait_ref` parameters here. So they may reference bound regions.\n+    /// If for example you had `for<'a> Foo<'a>: Bar<'a>`, then the `self_ty` would be `Foo<'a>`\n+    /// where `'a` is a bound region at depth 0. Similarly, the `poly_trait_ref` would be\n+    /// `Bar<'a>`. The returned poly-trait-ref will have this binder instantiated explicitly,\n+    /// however.\n     pub fn instantiate_poly_trait_ref(&self,\n         poly_trait_ref: &hir::PolyTraitRef,\n         self_ty: Ty<'tcx>,\n-        poly_projections: &mut Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>)\n-        -> (ty::PolyTraitRef<'tcx>, Option<Vec<Span>>)\n+        bounds: &mut Bounds<'tcx>\n+    ) -> (ty::PolyTraitRef<'tcx>, Option<Vec<Span>>)\n     {\n-        self.instantiate_poly_trait_ref_inner(&poly_trait_ref.trait_ref, self_ty,\n-                                              poly_projections, false)\n+        self.instantiate_poly_trait_ref_inner(&poly_trait_ref.trait_ref, self_ty, bounds, false)\n     }\n \n     fn ast_path_to_mono_trait_ref(&self,\n-                                  span: Span,\n-                                  trait_def_id: DefId,\n-                                  self_ty: Ty<'tcx>,\n-                                  trait_segment: &hir::PathSegment)\n-                                  -> ty::TraitRef<'tcx>\n+        span: Span,\n+        trait_def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+        trait_segment: &hir::PathSegment\n+    ) -> ty::TraitRef<'tcx>\n     {\n         let (substs, assoc_bindings, _) =\n             self.create_substs_for_ast_trait_ref(span,\n@@ -828,15 +896,156 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         })\n     }\n \n-    fn ast_type_binding_to_poly_projection_predicate(\n+    // Returns `true` if a bounds list includes `?Sized`.\n+    pub fn is_unsized(&self, ast_bounds: &[hir::GenericBound], span: Span) -> bool {\n+        let tcx = self.tcx();\n+\n+        // Try to find an unbound in bounds.\n+        let mut unbound = None;\n+        for ab in ast_bounds {\n+            if let &hir::GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = ab {\n+                if unbound.is_none() {\n+                    unbound = Some(ptr.trait_ref.clone());\n+                } else {\n+                    span_err!(\n+                        tcx.sess,\n+                        span,\n+                        E0203,\n+                        \"type parameter has more than one relaxed default \\\n+                        bound, only one is supported\"\n+                    );\n+                }\n+            }\n+        }\n+\n+        let kind_id = tcx.lang_items().require(SizedTraitLangItem);\n+        match unbound {\n+            Some(ref tpb) => {\n+                // FIXME(#8559) currently requires the unbound to be built-in.\n+                if let Ok(kind_id) = kind_id {\n+                    if tpb.path.res != Res::Def(DefKind::Trait, kind_id) {\n+                        tcx.sess.span_warn(\n+                            span,\n+                            \"default bound relaxed for a type parameter, but \\\n+                            this does nothing because the given bound is not \\\n+                            a default. Only `?Sized` is supported\",\n+                        );\n+                    }\n+                }\n+            }\n+            _ if kind_id.is_ok() => {\n+                return false;\n+            }\n+            // No lang item for `Sized`, so we can't add it as a bound.\n+            None => {}\n+        }\n+\n+        true\n+    }\n+\n+    /// This helper takes a *converted* parameter type (`param_ty`)\n+    /// and an *unconverted* list of bounds:\n+    ///\n+    /// ```\n+    /// fn foo<T: Debug>\n+    ///        ^  ^^^^^ `ast_bounds` parameter, in HIR form\n+    ///        |\n+    ///        `param_ty`, in ty form\n+    /// ```\n+    ///\n+    /// It adds these `ast_bounds` into the `bounds` structure.\n+    ///\n+    /// **A note on binders:** there is an implied binder around\n+    /// `param_ty` and `ast_bounds`. See `instantiate_poly_trait_ref`\n+    /// for more details.\n+    fn add_bounds(&self,\n+        param_ty: Ty<'tcx>,\n+        ast_bounds: &[hir::GenericBound],\n+        bounds: &mut Bounds<'tcx>,\n+    ) {\n+        let mut trait_bounds = Vec::new();\n+        let mut region_bounds = Vec::new();\n+\n+        for ast_bound in ast_bounds {\n+            match *ast_bound {\n+                hir::GenericBound::Trait(ref b, hir::TraitBoundModifier::None) =>\n+                    trait_bounds.push(b),\n+                hir::GenericBound::Trait(_, hir::TraitBoundModifier::Maybe) => {}\n+                hir::GenericBound::Outlives(ref l) =>\n+                    region_bounds.push(l),\n+            }\n+        }\n+\n+        for bound in trait_bounds {\n+            let (poly_trait_ref, _) = self.instantiate_poly_trait_ref(\n+                bound,\n+                param_ty,\n+                bounds,\n+            );\n+            bounds.trait_bounds.push((poly_trait_ref, bound.span))\n+        }\n+\n+        bounds.region_bounds.extend(region_bounds\n+            .into_iter()\n+            .map(|r| (self.ast_region_to_region(r, None), r.span))\n+        );\n+    }\n+\n+    /// Translates a list of bounds from the HIR into the `Bounds` data structure.\n+    /// The self-type for the bounds is given by `param_ty`.\n+    ///\n+    /// Example:\n+    ///\n+    /// ```\n+    /// fn foo<T: Bar + Baz>() { }\n+    ///        ^  ^^^^^^^^^ ast_bounds\n+    ///        param_ty\n+    /// ```\n+    ///\n+    /// The `sized_by_default` parameter indicates if, in this context, the `param_ty` should be\n+    /// considered `Sized` unless there is an explicit `?Sized` bound.  This would be true in the\n+    /// example above, but is not true in supertrait listings like `trait Foo: Bar + Baz`.\n+    ///\n+    /// `span` should be the declaration size of the parameter.\n+    pub fn compute_bounds(&self,\n+        param_ty: Ty<'tcx>,\n+        ast_bounds: &[hir::GenericBound],\n+        sized_by_default: SizedByDefault,\n+        span: Span,\n+    ) -> Bounds<'tcx> {\n+        let mut bounds = Bounds::default();\n+\n+        self.add_bounds(param_ty, ast_bounds, &mut bounds);\n+        bounds.trait_bounds.sort_by_key(|(t, _)| t.def_id());\n+\n+        bounds.implicitly_sized = if let SizedByDefault::Yes = sized_by_default {\n+            if !self.is_unsized(ast_bounds, span) {\n+                Some(span)\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        };\n+\n+        bounds\n+    }\n+\n+    /// Given an HIR binding like `Item = Foo` or `Item: Foo`, pushes the corresponding predicates\n+    /// onto `bounds`.\n+    ///\n+    /// **A note on binders:** given something like `T: for<'a> Iterator<Item = &'a u32>`, the\n+    /// `trait_ref` here will be `for<'a> T: Iterator`. The `binding` data however is from *inside*\n+    /// the binder (e.g., `&'a u32`) and hence may reference bound regions.\n+    fn add_predicates_for_ast_type_binding(\n         &self,\n         hir_ref_id: hir::HirId,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n         binding: &ConvertedBinding<'tcx>,\n+        bounds: &mut Bounds<'tcx>,\n         speculative: bool,\n-        dup_bindings: &mut FxHashMap<DefId, Span>)\n-        -> Result<ty::PolyProjectionPredicate<'tcx>, ErrorReported>\n-    {\n+        dup_bindings: &mut FxHashMap<DefId, Span>,\n+    ) -> Result<(), ErrorReported> {\n         let tcx = self.tcx();\n \n         if !speculative {\n@@ -851,40 +1060,43 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             // trait SubTrait: SuperTrait<int> { }\n             // trait SuperTrait<A> { type T; }\n             //\n-            // ... B : SubTrait<T=foo> ...\n+            // ... B: SubTrait<T = foo> ...\n             // ```\n             //\n             // We want to produce `<B as SuperTrait<int>>::T == foo`.\n \n             // Find any late-bound regions declared in `ty` that are not\n-            // declared in the trait-ref. These are not wellformed.\n+            // declared in the trait-ref. These are not well-formed.\n             //\n             // Example:\n             //\n             //     for<'a> <T as Iterator>::Item = &'a str // <-- 'a is bad\n             //     for<'a> <T as FnMut<(&'a u32,)>>::Output = &'a str // <-- 'a is ok\n-            let late_bound_in_trait_ref = tcx.collect_constrained_late_bound_regions(&trait_ref);\n-            let late_bound_in_ty =\n-                tcx.collect_referenced_late_bound_regions(&ty::Binder::bind(binding.ty));\n-            debug!(\"late_bound_in_trait_ref = {:?}\", late_bound_in_trait_ref);\n-            debug!(\"late_bound_in_ty = {:?}\", late_bound_in_ty);\n-            for br in late_bound_in_ty.difference(&late_bound_in_trait_ref) {\n-                let br_name = match *br {\n-                    ty::BrNamed(_, name) => name,\n-                    _ => {\n-                        span_bug!(\n-                            binding.span,\n-                            \"anonymous bound region {:?} in binding but not trait ref\",\n-                            br);\n-                    }\n-                };\n-                struct_span_err!(tcx.sess,\n+            if let ConvertedBindingKind::Equality(ty) = binding.kind {\n+                let late_bound_in_trait_ref =\n+                    tcx.collect_constrained_late_bound_regions(&trait_ref);\n+                let late_bound_in_ty =\n+                    tcx.collect_referenced_late_bound_regions(&ty::Binder::bind(ty));\n+                debug!(\"late_bound_in_trait_ref = {:?}\", late_bound_in_trait_ref);\n+                debug!(\"late_bound_in_ty = {:?}\", late_bound_in_ty);\n+                for br in late_bound_in_ty.difference(&late_bound_in_trait_ref) {\n+                    let br_name = match *br {\n+                        ty::BrNamed(_, name) => name,\n+                        _ => {\n+                            span_bug!(\n                                 binding.span,\n-                                E0582,\n-                                \"binding for associated type `{}` references lifetime `{}`, \\\n-                                 which does not appear in the trait input types\",\n-                                binding.item_name, br_name)\n-                    .emit();\n+                                \"anonymous bound region {:?} in binding but not trait ref\",\n+                                br);\n+                        }\n+                    };\n+                    struct_span_err!(tcx.sess,\n+                                    binding.span,\n+                                    E0582,\n+                                    \"binding for associated type `{}` references lifetime `{}`, \\\n+                                     which does not appear in the trait input types\",\n+                                    binding.item_name, br_name)\n+                        .emit();\n+                }\n             }\n         }\n \n@@ -929,16 +1141,39 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 .or_insert(binding.span);\n         }\n \n-        Ok(candidate.map_bound(|trait_ref| {\n-            ty::ProjectionPredicate {\n-                projection_ty: ty::ProjectionTy::from_ref_and_name(\n-                    tcx,\n-                    trait_ref,\n-                    binding.item_name,\n-                ),\n-                ty: binding.ty,\n+        match binding.kind {\n+            ConvertedBindingKind::Equality(ref ty) => {\n+                // \"Desugar\" a constraint like `T: Iterator<Item = u32>` this to\n+                // the \"projection predicate\" for:\n+                //\n+                // `<T as Iterator>::Item = u32`\n+                bounds.projection_bounds.push((candidate.map_bound(|trait_ref| {\n+                    ty::ProjectionPredicate {\n+                        projection_ty: ty::ProjectionTy::from_ref_and_name(\n+                            tcx,\n+                            trait_ref,\n+                            binding.item_name,\n+                        ),\n+                        ty,\n+                    }\n+                }), binding.span));\n             }\n-        }))\n+            ConvertedBindingKind::Constraint(ref ast_bounds) => {\n+                // \"Desugar\" a constraint like `T: Iterator<Item: Debug>` to\n+                //\n+                // `<T as Iterator>::Item: Debug`\n+                //\n+                // Calling `skip_binder` is okay, because `add_bounds` expects the `param_ty`\n+                // parameter to have a skipped binder.\n+                let param_ty = tcx.mk_projection(assoc_ty.def_id, candidate.skip_binder().substs);\n+                self.add_bounds(\n+                    param_ty,\n+                    ast_bounds,\n+                    bounds,\n+                );\n+            }\n+        }\n+        Ok(())\n     }\n \n     fn ast_path_to_ty(&self,\n@@ -972,7 +1207,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     {\n         let tcx = self.tcx();\n \n-        let mut projection_bounds = Vec::new();\n+        let mut bounds = Bounds::default();\n         let mut potential_assoc_types = Vec::new();\n         let dummy_self = self.tcx().types.trait_object_dummy_self;\n         // FIXME: we want to avoid collecting into a `Vec` here, but simply cloning the iterator is\n@@ -984,7 +1219,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 let (trait_ref, cur_potential_assoc_types) = self.instantiate_poly_trait_ref(\n                     trait_bound,\n                     dummy_self,\n-                    &mut projection_bounds\n+                    &mut bounds,\n                 );\n                 potential_assoc_types.extend(cur_potential_assoc_types.into_iter().flatten());\n                 (trait_ref, trait_bound.span)\n@@ -1072,14 +1307,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     // which is uglier but works. See the discussion in #56288 for alternatives.\n                     if !references_self {\n                         // Include projections defined on supertraits.\n-                        projection_bounds.push((pred, DUMMY_SP))\n+                        bounds.projection_bounds.push((pred, DUMMY_SP))\n                     }\n                 }\n                 _ => ()\n             }\n         }\n \n-        for (projection_bound, _) in &projection_bounds {\n+        for (projection_bound, _) in &bounds.projection_bounds {\n             associated_types.remove(&projection_bound.projection_def_id());\n         }\n \n@@ -1159,7 +1394,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         let existential_trait_refs = regular_traits.iter().map(|i| {\n             i.trait_ref().map_bound(|trait_ref| self.trait_ref_to_existential(trait_ref))\n         });\n-        let existential_projections = projection_bounds.iter().map(|(bound, _)| {\n+        let existential_projections = bounds.projection_bounds.iter().map(|(bound, _)| {\n             bound.map_bound(|b| {\n                 let trait_ref = self.trait_ref_to_existential(b.projection_ty.trait_ref(tcx));\n                 ty::ExistentialProjection {\n@@ -1716,7 +1951,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         let span = path.span;\n         match path.res {\n             Res::Def(DefKind::Existential, did) => {\n-                // Check for desugared impl trait.\n+                // Check for desugared `impl Trait`.\n                 assert!(ty::is_impl_trait_defn(tcx, did).is_none());\n                 let item_segment = path.segments.split_last().unwrap();\n                 self.prohibit_generics(item_segment.1);\n@@ -1767,18 +2002,18 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     &tcx.hir().local_def_id_from_hir_id(hir_id)];\n                 tcx.mk_ty_param(index, tcx.hir().name_by_hir_id(hir_id).as_interned_str())\n             }\n-            Res::SelfTy(_, Some(def_id)) => {\n-                // `Self` in impl (we know the concrete type).\n+            Res::SelfTy(Some(_), None) => {\n+                // `Self` in trait or type alias.\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n-                // Try to evaluate any array length constants\n-                self.normalize_ty(span, tcx.at(span).type_of(def_id))\n+                tcx.mk_self_type()\n             }\n-            Res::SelfTy(Some(_), None) => {\n-                // `Self` in trait.\n+            Res::SelfTy(_, Some(def_id)) => {\n+                // `Self` in impl (we know the concrete type).\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n-                tcx.mk_self_type()\n+                // Try to evaluate any array length constants.\n+                self.normalize_ty(span, tcx.at(span).type_of(def_id))\n             }\n             Res::Def(DefKind::AssocTy, def_id) => {\n                 debug_assert!(path.segments.len() >= 2);\n@@ -1829,7 +2064,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             }\n             hir::TyKind::Rptr(ref region, ref mt) => {\n                 let r = self.ast_region_to_region(region, None);\n-                debug!(\"Ref r={:?}\", r);\n+                debug!(\"ast_ty_to_ty: r={:?}\", r);\n                 let t = self.ast_ty_to_ty(&mt.ty);\n                 tcx.mk_ref(r, ty::TypeAndMut {ty: t, mutbl: mt.mutbl})\n             }\n@@ -1856,7 +2091,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             hir::TyKind::Def(item_id, ref lifetimes) => {\n                 let did = tcx.hir().local_def_id_from_hir_id(item_id.id);\n                 self.impl_trait_ty_to_ty(did, lifetimes)\n-            },\n+            }\n             hir::TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 debug!(\"ast_ty_to_ty: qself={:?} segment={:?}\", qself, segment);\n                 let ty = self.ast_ty_to_ty(qself);\n@@ -1889,9 +2124,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 // handled specially and will not descend into this routine.\n                 self.ty_infer(ast_ty.span)\n             }\n-            hir::TyKind::Err => {\n-                tcx.types.err\n-            }\n             hir::TyKind::CVarArgs(lt) => {\n                 let va_list_did = match tcx.lang_items().va_list() {\n                     Some(did) => did,\n@@ -1901,8 +2133,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 let region = self.ast_region_to_region(&lt, None);\n                 tcx.type_of(va_list_did).subst(tcx, &[region.into()])\n             }\n+            hir::TyKind::Err => {\n+                tcx.types.err\n+            }\n         };\n \n+        debug!(\"ast_ty_to_ty: result_ty={:?}\", result_ty);\n+\n         self.record_ty(ast_ty.hir_id, result_ty, ast_ty.span);\n         result_ty\n     }\n@@ -1979,7 +2216,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     _ => bug!()\n                 }\n             } else {\n-                // Replace all parent lifetimes with 'static.\n+                // Replace all parent lifetimes with `'static`.\n                 match param.kind {\n                     GenericParamDefKind::Lifetime => {\n                         tcx.lifetimes.re_static.into()\n@@ -1988,7 +2225,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 }\n             }\n         });\n-        debug!(\"impl_trait_ty_to_ty: final substs = {:?}\", substs);\n+        debug!(\"impl_trait_ty_to_ty: substs={:?}\", substs);\n \n         let ty = tcx.mk_opaque(def_id, substs);\n         debug!(\"impl_trait_ty_to_ty: {}\", ty);\n@@ -2117,17 +2354,52 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     }\n }\n \n-// A helper struct for conveniently grouping a set of bounds which we pass to\n-// and return from functions in multiple places.\n-#[derive(PartialEq, Eq, Clone, Debug)]\n+/// Collects together a list of bounds that are applied to some type,\n+/// after they've been converted into `ty` form (from the HIR\n+/// representations). These lists of bounds occur in many places in\n+/// Rust's syntax:\n+///\n+/// ```\n+/// trait Foo: Bar + Baz { }\n+///            ^^^^^^^^^ supertrait list bounding the `Self` type parameter\n+///\n+/// fn foo<T: Bar + Baz>() { }\n+///           ^^^^^^^^^ bounding the type parameter `T`\n+///\n+/// impl dyn Bar + Baz\n+///          ^^^^^^^^^ bounding the forgotten dynamic type\n+/// ```\n+///\n+/// Our representation is a bit mixed here -- in some cases, we\n+/// include the self type (e.g., `trait_bounds`) but in others we do\n+#[derive(Default, PartialEq, Eq, Clone, Debug)]\n pub struct Bounds<'tcx> {\n+    /// A list of region bounds on the (implicit) self type. So if you\n+    /// had `T: 'a + 'b` this might would be a list `['a, 'b]` (but\n+    /// the `T` is not explicitly included).\n     pub region_bounds: Vec<(ty::Region<'tcx>, Span)>,\n-    pub implicitly_sized: Option<Span>,\n+\n+    /// A list of trait bounds. So if you had `T: Debug` this would be\n+    /// `T: Debug`. Note that the self-type is explicit here.\n     pub trait_bounds: Vec<(ty::PolyTraitRef<'tcx>, Span)>,\n+\n+    /// A list of projection equality bounds. So if you had `T:\n+    /// Iterator<Item = u32>` this would include `<T as\n+    /// Iterator>::Item => u32`. Note that the self-type is explicit\n+    /// here.\n     pub projection_bounds: Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>,\n+\n+    /// `Some` if there is *no* `?Sized` predicate. The `span`\n+    /// is the location in the source of the `T` declaration which can\n+    /// be cited as the source of the `T: Sized` requirement.\n+    pub implicitly_sized: Option<Span>,\n }\n \n impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n+    /// Converts a bounds list into a flat set of predicates (like\n+    /// where-clauses). Because some of our bounds listings (e.g.,\n+    /// regions) don't include the self-type, you must supply the\n+    /// self-type here (the `param_ty` parameter).\n     pub fn predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, param_ty: Ty<'tcx>)\n                       -> Vec<(ty::Predicate<'tcx>, Span)>\n     {"}, {"sha": "f95021f0cb0883ad475b614f335873a2843fb38c", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -173,7 +173,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             // here, we would coerce from `!` to `?T`.\n             let b = self.shallow_resolve(b);\n             return if self.shallow_resolve(b).is_ty_var() {\n-                // micro-optimization: no need for this if `b` is\n+                // Micro-optimization: no need for this if `b` is\n                 // already resolved in some way.\n                 let diverging_ty = self.next_diverging_ty_var(\n                     TypeVariableOrigin {"}, {"sha": "a111851aa37977bea9140e75053b43a4f72cdecb", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -523,10 +523,10 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// eventually).\n     param_env: ty::ParamEnv<'tcx>,\n \n-    // Number of errors that had been reported when we started\n-    // checking this function. On exit, if we find that *more* errors\n-    // have been reported, we will skip regionck and other work that\n-    // expects the types within the function to be consistent.\n+    /// Number of errors that had been reported when we started\n+    /// checking this function. On exit, if we find that *more* errors\n+    /// have been reported, we will skip regionck and other work that\n+    /// expects the types within the function to be consistent.\n     err_count_on_creation: usize,\n \n     ret_coercion: Option<RefCell<DynamicCoerceMany<'gcx, 'tcx>>>,"}, {"sha": "c3b6fb21e38d64f62f94260ae3e90dbe6446a1a9", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -991,8 +991,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Guarantees that any lifetimes which appear in the type of the node `id` (after applying\n-    /// adjustments) are valid for at least `minimum_lifetime`\n+    /// Guarantees that any lifetimes that appear in the type of the node `id` (after applying\n+    /// adjustments) are valid for at least `minimum_lifetime`.\n     fn type_of_node_must_outlive(\n         &mut self,\n         origin: infer::SubregionOrigin<'tcx>,"}, {"sha": "2b627a692508e65271ff502dedc5fa2a88cb238a", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 64, "deletions": 54, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -20,8 +20,11 @@ use rustc::hir::itemlikevisit::ParItemLikeVisitor;\n use rustc::hir;\n \n /// Helper type of a temporary returned by `.for_item(...)`.\n-/// Necessary because we can't write the following bound:\n-/// `F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(FnCtxt<'b, 'gcx, 'tcx>)`.\n+/// This is necessary because we can't write the following bound:\n+///\n+/// ```rust\n+/// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(FnCtxt<'b, 'gcx, 'tcx>)\n+/// ```\n struct CheckWfFcxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     inherited: super::InheritedBuilder<'a, 'gcx, 'tcx>,\n     id: hir::HirId,\n@@ -42,7 +45,7 @@ impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n             if !inh.tcx.features().trivial_bounds {\n                 // As predicates are cached rather than obligations, this\n                 // needsto be called first so that they are checked with an\n-                // empty param_env.\n+                // empty `param_env`.\n                 check_false_global_bounds(&fcx, span, id);\n             }\n             let wf_tys = f(&fcx, fcx.tcx.global_tcx());\n@@ -56,7 +59,9 @@ impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n /// well-formed, meaning that they do not require any constraints not declared in the struct\n /// definition itself. For example, this definition would be illegal:\n ///\n-///     struct Ref<'a, T> { x: &'a T }\n+/// ```rust\n+/// struct Ref<'a, T> { x: &'a T }\n+/// ```\n ///\n /// because the type did not declare that `T:'a`.\n ///\n@@ -75,7 +80,7 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n         // Right now we check that every default trait implementation\n         // has an implementation of itself. Basically, a case like:\n         //\n-        // `impl Trait for T {}`\n+        //     impl Trait for T {}\n         //\n         // has a requirement of `T: Trait` which was required for default\n         // method implementations. Although this could be improved now that\n@@ -85,7 +90,7 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n         // Since there's such a requirement, we need to check *just* positive\n         // implementations, otherwise things like:\n         //\n-        // impl !Send for T {}\n+        //     impl !Send for T {}\n         //\n         // won't be allowed unless there's an *explicit* implementation of `Send`\n         // for `T`\n@@ -98,7 +103,7 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n             if polarity == hir::ImplPolarity::Positive {\n                 check_impl(tcx, item, self_ty, trait_ref);\n             } else {\n-                // FIXME(#27579) what amount of WF checking do we need for neg impls?\n+                // FIXME(#27579): what amount of WF checking do we need for neg impls?\n                 if trait_ref.is_some() && !is_auto {\n                     span_err!(tcx.sess, item.span, E0192,\n                               \"negative impls are only allowed for \\\n@@ -302,7 +307,8 @@ fn check_type_defn<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         check_where_clauses(tcx, fcx, item.span, def_id, None);\n \n-        vec![] // no implied bounds in a struct def'n\n+        // No implied bounds in a struct definition.\n+        vec![]\n     });\n }\n \n@@ -369,7 +375,8 @@ fn check_item_type<'a, 'tcx>(\n             );\n         }\n \n-        vec![] // no implied bounds in a const etc\n+        // No implied bounds in a const, etc.\n+        vec![]\n     });\n }\n \n@@ -421,6 +428,8 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n     def_id: DefId,\n     return_ty: Option<Ty<'tcx>>,\n ) {\n+    debug!(\"check_where_clauses(def_id={:?}, return_ty={:?})\", def_id, return_ty);\n+\n     let predicates = fcx.tcx.predicates_of(def_id);\n     let generics = tcx.generics_of(def_id);\n \n@@ -434,15 +443,17 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n     };\n \n     // Check that concrete defaults are well-formed. See test `type-check-defaults.rs`.\n-    // For example this forbids the declaration:\n-    // struct Foo<T = Vec<[u32]>> { .. }\n-    // Here the default `Vec<[u32]>` is not WF because `[u32]: Sized` does not hold.\n+    // For example, this forbids the declaration:\n+    //\n+    //     struct Foo<T = Vec<[u32]>> { .. }\n+    //\n+    // Here, the default `Vec<[u32]>` is not WF because `[u32]: Sized` does not hold.\n     for param in &generics.params {\n         if let GenericParamDefKind::Type { .. } = param.kind {\n             if is_our_default(&param) {\n                 let ty = fcx.tcx.type_of(param.def_id);\n-                // ignore dependent defaults -- that is, where the default of one type\n-                // parameter includes another (e.g., <T, U = T>). In those cases, we can't\n+                // Ignore dependent defaults -- that is, where the default of one type\n+                // parameter includes another (e.g., `<T, U = T>`). In those cases, we can't\n                 // be sure if it will error or not as user might always specify the other.\n                 if !ty.needs_subst() {\n                     fcx.register_wf_obligation(ty, fcx.tcx.def_span(param.def_id),\n@@ -468,16 +479,16 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n             }\n \n             GenericParamDefKind::Type { .. } => {\n-                // If the param has a default,\n+                // If the param has a default, ...\n                 if is_our_default(param) {\n                     let default_ty = fcx.tcx.type_of(param.def_id);\n-                    // and it's not a dependent default\n+                    // ... and it's not a dependent default, ...\n                     if !default_ty.needs_subst() {\n-                        // then substitute with the default.\n+                        // ... then substitute it with the default.\n                         return default_ty.into();\n                     }\n                 }\n-                // Mark unwanted params as err.\n+                // Mark unwanted params as error.\n                 fcx.tcx.types.err.into()\n             }\n \n@@ -525,7 +536,7 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n             Some(substituted_pred)\n         }\n     }).map(|pred| {\n-        // convert each of those into an obligation. So if you have\n+        // Convert each of those into an obligation. So if you have\n         // something like `struct Foo<T: Copy = String>`, we would\n         // take that predicate `T: Copy`, substitute to `String: Copy`\n         // (actually that happens in the previous `flat_map` call),\n@@ -595,14 +606,13 @@ fn check_fn_or_method<'a, 'fcx, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n /// ```rust\n /// existential type Foo<A, B>;\n ///\n-/// // ok -- `Foo` is applied to two distinct, generic types.\n+/// // Okay -- `Foo` is applied to two distinct, generic types.\n /// fn a<T, U>() -> Foo<T, U> { .. }\n ///\n-/// // not ok -- `Foo` is applied to `T` twice.\n+/// // Not okay -- `Foo` is applied to `T` twice.\n /// fn b<T>() -> Foo<T, T> { .. }\n ///\n-///\n-/// // not ok -- `Foo` is applied to a non-generic type.\n+/// // Not okay -- `Foo` is applied to a non-generic type.\n /// fn b<T>() -> Foo<T, u32> { .. }\n /// ```\n ///\n@@ -613,25 +623,25 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n     span: Span,\n     ty: Ty<'tcx>,\n ) -> Vec<ty::Predicate<'tcx>> {\n-    trace!(\"check_existential_types: {:?}\", ty);\n+    trace!(\"check_existential_types(ty={:?})\", ty);\n     let mut substituted_predicates = Vec::new();\n     ty.fold_with(&mut ty::fold::BottomUpFolder {\n         tcx: fcx.tcx,\n         ty_op: |ty| {\n             if let ty::Opaque(def_id, substs) = ty.sty {\n                 trace!(\"check_existential_types: opaque_ty, {:?}, {:?}\", def_id, substs);\n                 let generics = tcx.generics_of(def_id);\n-                // only check named existential types defined in this crate\n+                // Only check named existential types defined in this crate.\n                 if generics.parent.is_none() && def_id.is_local() {\n                     let opaque_hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n                     if may_define_existential_type(tcx, fn_def_id, opaque_hir_id) {\n-                        trace!(\"check_existential_types may define. Generics: {:#?}\", generics);\n+                        trace!(\"check_existential_types: may define, generics={:#?}\", generics);\n                         let mut seen: FxHashMap<_, Vec<_>> = FxHashMap::default();\n                         for (subst, param) in substs.iter().zip(&generics.params) {\n                             match subst.unpack() {\n                                 ty::subst::UnpackedKind::Type(ty) => match ty.sty {\n                                     ty::Param(..) => {}\n-                                    // prevent `fn foo() -> Foo<u32>` from being defining\n+                                    // Prevent `fn foo() -> Foo<u32>` from being defining.\n                                     _ => {\n                                         tcx.sess\n                                             .struct_span_err(\n@@ -713,20 +723,19 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n                         }\n                     } // if may_define_existential_type\n \n-                    // now register the bounds on the parameters of the existential type\n-                    // so the parameters given by the function need to fulfill them\n-                    // ```rust\n-                    // existential type Foo<T: Bar>: 'static;\n-                    // fn foo<U>() -> Foo<U> { .. *}\n-                    // ```\n+                    // Now register the bounds on the parameters of the existential type\n+                    // so the parameters given by the function need to fulfill them.\n+                    //\n+                    //     existential type Foo<T: Bar>: 'static;\n+                    //     fn foo<U>() -> Foo<U> { .. *}\n+                    //\n                     // becomes\n-                    // ```rust\n-                    // existential type Foo<T: Bar>: 'static;\n-                    // fn foo<U: Bar>() -> Foo<U> { .. *}\n-                    // ```\n+                    //\n+                    //     existential type Foo<T: Bar>: 'static;\n+                    //     fn foo<U: Bar>() -> Foo<U> { .. *}\n                     let predicates = tcx.predicates_of(def_id);\n                     trace!(\n-                        \"check_existential_types may define. adding predicates: {:#?}\",\n+                        \"check_existential_types: may define, predicates={:#?}\",\n                         predicates,\n                     );\n                     for &(pred, _) in predicates.predicates.iter() {\n@@ -751,7 +760,7 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                                            method: &ty::AssocItem,\n                                            self_ty: Ty<'tcx>)\n {\n-    // check that the method has a valid receiver type, given the type `Self`\n+    // Check that the method has a valid receiver type, given the type `Self`.\n     debug!(\"check_method_receiver({:?}, self_ty={:?})\",\n            method, self_ty);\n \n@@ -783,7 +792,7 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n \n     if fcx.tcx.features().arbitrary_self_types {\n         if !receiver_is_valid(fcx, span, receiver_ty, self_ty, true) {\n-            // report error, arbitrary_self_types was enabled\n+            // Report error; `arbitrary_self_types` was enabled.\n             fcx.tcx.sess.diagnostic().mut_span_err(\n                 span, &format!(\"invalid method receiver type: {:?}\", receiver_ty)\n             ).note(\"type of `self` must be `Self` or a type that dereferences to it\")\n@@ -794,7 +803,7 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n     } else {\n         if !receiver_is_valid(fcx, span, receiver_ty, self_ty, false) {\n             if receiver_is_valid(fcx, span, receiver_ty, self_ty, true) {\n-                // report error, would have worked with arbitrary_self_types\n+                // Report error; would have worked with `arbitrary_self_types`.\n                 feature_gate::feature_err(\n                     &fcx.tcx.sess.parse_sess,\n                     sym::arbitrary_self_types,\n@@ -808,7 +817,7 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                 ).help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n                 .emit();\n             } else {\n-                // report error, would not have worked with arbitrary_self_types\n+                // Report error; would not have worked with `arbitrary_self_types`.\n                 fcx.tcx.sess.diagnostic().mut_span_err(\n                     span, &format!(\"invalid method receiver type: {:?}\", receiver_ty)\n                 ).note(\"type must be `Self` or a type that dereferences to it\")\n@@ -820,10 +829,11 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n     }\n }\n \n-/// returns true if `receiver_ty` would be considered a valid receiver type for `self_ty`. If\n+/// Returns whether `receiver_ty` would be considered a valid receiver type for `self_ty`. If\n /// `arbitrary_self_types` is enabled, `receiver_ty` must transitively deref to `self_ty`, possibly\n /// through a `*const/mut T` raw pointer. If the feature is not enabled, the requirements are more\n-/// strict: `receiver_ty` must implement `Receiver` and directly implement `Deref<Target=self_ty>`.\n+/// strict: `receiver_ty` must implement `Receiver` and directly implement\n+/// `Deref<Target = self_ty>`.\n ///\n /// N.B., there are cases this function returns `true` but causes an error to be emitted,\n /// particularly when `receiver_ty` derefs to a type that is the same as `self_ty` but has the\n@@ -839,7 +849,7 @@ fn receiver_is_valid<'fcx, 'tcx, 'gcx>(\n \n     let can_eq_self = |ty| fcx.infcx.can_eq(fcx.param_env, self_ty, ty).is_ok();\n \n-    // `self: Self` is always valid\n+    // `self: Self` is always valid.\n     if can_eq_self(receiver_ty) {\n         if let Some(mut err) = fcx.demand_eqtype_with_origin(&cause, self_ty, receiver_ty) {\n             err.emit();\n@@ -849,15 +859,15 @@ fn receiver_is_valid<'fcx, 'tcx, 'gcx>(\n \n     let mut autoderef = fcx.autoderef(span, receiver_ty);\n \n-    // the `arbitrary_self_types` feature allows raw pointer receivers like `self: *const Self`\n+    // The `arbitrary_self_types` feature allows raw pointer receivers like `self: *const Self`.\n     if arbitrary_self_types_enabled {\n         autoderef = autoderef.include_raw_pointers();\n     }\n \n-    // the first type is `receiver_ty`, which we know its not equal to `self_ty`. skip it.\n+    // The first type is `receiver_ty`, which we know its not equal to `self_ty`; skip it.\n     autoderef.next();\n \n-    // keep dereferencing `receiver_ty` until we get to `self_ty`\n+    // Keep dereferencing `receiver_ty` until we get to `self_ty`.\n     loop {\n         if let Some((potential_self_ty, _)) = autoderef.next() {\n             debug!(\"receiver_is_valid: potential self type `{:?}` to match `{:?}`\",\n@@ -882,14 +892,14 @@ fn receiver_is_valid<'fcx, 'tcx, 'gcx>(\n             return receiver_ty.references_error();\n         }\n \n-        // without the `arbitrary_self_types` feature, `receiver_ty` must directly deref to\n-        // `self_ty`. Enforce this by only doing one iteration of the loop\n+        // Without the `arbitrary_self_types` feature, `receiver_ty` must directly deref to\n+        // `self_ty`. Enforce this by only doing one iteration of the loop.\n         if !arbitrary_self_types_enabled {\n             return false\n         }\n     }\n \n-    // without `feature(arbitrary_self_types)`, we require that `receiver_ty` implements `Receiver`\n+    // Without `feature(arbitrary_self_types)`, we require that `receiver_ty` implements `Receiver`.\n     if !arbitrary_self_types_enabled {\n         let trait_def_id = match fcx.tcx.lang_items().receiver_trait() {\n             Some(did) => did,\n@@ -968,7 +978,7 @@ fn report_bivariance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut err = error_392(tcx, span, param_name);\n \n     let suggested_marker_id = tcx.lang_items().phantom_data();\n-    // help is available only in presence of lang items\n+    // Help is available only in presence of lang items.\n     if let Some(def_id) = suggested_marker_id {\n         err.help(&format!(\"consider removing `{}` or using a marker such as `{}`\",\n                           param_name,\n@@ -988,12 +998,12 @@ fn reject_shadowing_parameters(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) {\n     }).collect();\n \n     for method_param in &generics.params {\n-        // Shadowing is checked in resolve_lifetime.\n+        // Shadowing is checked in `resolve_lifetime`.\n         if let GenericParamDefKind::Lifetime = method_param.kind {\n             continue\n         }\n         if impl_params.contains_key(&method_param.name) {\n-            // Tighten up the span to focus on only the shadowing type\n+            // Tighten up the span to focus on only the shadowing type.\n             let type_span = tcx.def_span(method_param.def_id);\n \n             // The expectation here is that the original trait declaration is"}, {"sha": "1bc7119b314e95383a54225bf139f44ff6a9454a", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -450,38 +450,38 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             let generics = self.tcx().generics_of(def_id);\n \n             let definition_ty = if generics.parent.is_some() {\n-                // impl trait\n+                // `impl Trait`\n                 self.fcx.infer_opaque_definition_from_instantiation(\n                     def_id,\n                     opaque_defn,\n                     instantiated_ty,\n                 )\n             } else {\n-                // prevent\n+                // Prevent:\n                 // * `fn foo<T>() -> Foo<T>`\n                 // * `fn foo<T: Bound + Other>() -> Foo<T>`\n-                // from being defining\n+                // from being defining.\n \n                 // Also replace all generic params with the ones from the existential type\n-                // definition so\n+                // definition so that\n                 // ```rust\n                 // existential type Foo<T>: 'static;\n                 // fn foo<U>() -> Foo<U> { .. }\n                 // ```\n-                // figures out the concrete type with `U`, but the stored type is with `T`\n+                // figures out the concrete type with `U`, but the stored type is with `T`.\n                 instantiated_ty.fold_with(&mut BottomUpFolder {\n                     tcx: self.tcx().global_tcx(),\n                     ty_op: |ty| {\n                         trace!(\"checking type {:?}\", ty);\n-                        // find a type parameter\n+                        // Find a type parameter.\n                         if let ty::Param(..) = ty.sty {\n-                            // look it up in the substitution list\n+                            // Look it up in the substitution list.\n                             assert_eq!(opaque_defn.substs.len(), generics.params.len());\n                             for (subst, param) in opaque_defn.substs.iter().zip(&generics.params) {\n                                 if let UnpackedKind::Type(subst) = subst.unpack() {\n                                     if subst == ty {\n-                                        // found it in the substitution list, replace with the\n-                                        // parameter from the existential type\n+                                        // Found it in the substitution list; replace with the\n+                                        // parameter from the existential type.\n                                         return self.tcx()\n                                             .global_tcx()\n                                             .mk_ty_param(param.index, param.name);\n@@ -505,16 +505,15 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                     },\n                     lt_op: |region| {\n                         match region {\n-                            // Skip static and bound regions: they don't\n-                            // require substitution.\n+                            // Skip static and bound regions: they don't require substitution.\n                             ty::ReStatic | ty::ReLateBound(..) => region,\n                             _ => {\n                                 trace!(\"checking {:?}\", region);\n                                 for (subst, p) in opaque_defn.substs.iter().zip(&generics.params) {\n                                     if let UnpackedKind::Lifetime(subst) = subst.unpack() {\n                                         if subst == region {\n-                                            // found it in the substitution list, replace with the\n-                                            // parameter from the existential type\n+                                            // Found it in the substitution list; replace with the\n+                                            // parameter from the existential type.\n                                             let reg = ty::EarlyBoundRegion {\n                                                 def_id: p.def_id,\n                                                 index: p.index,\n@@ -586,8 +585,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n             if let ty::Opaque(defin_ty_def_id, _substs) = definition_ty.sty {\n                 if def_id == defin_ty_def_id {\n-                    // Concrete type resolved to the existential type itself\n-                    // Force a cycle error\n+                    // Concrete type resolved to the existential type itself.\n+                    // Force a cycle error.\n                     // FIXME(oli-obk): we could just not insert it into `concrete_existential_types`\n                     // which simply would make this use not a defining use.\n                     self.tcx().at(span).type_of(defin_ty_def_id);"}, {"sha": "2751cd0a37ec0f7fcbce879a32a18c31161d4429", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 87, "deletions": 179, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -1,6 +1,6 @@\n //! \"Collection\" is the process of determining the type and other external\n //! details of each item in Rust. Collection is specifically concerned\n-//! with *interprocedural* things -- for example, for a function\n+//! with *inter-procedural* things -- for example, for a function\n //! definition, collection will figure out the type and signature of the\n //! function, but it will not visit the *body* of the function in any way,\n //! nor examine type annotations on local variables (that's the job of\n@@ -14,11 +14,10 @@\n //! At present, however, we do run collection across all items in the\n //! crate as a kind of pass. This should eventually be factored away.\n \n-use crate::astconv::{AstConv, Bounds};\n+use crate::astconv::{AstConv, Bounds, SizedByDefault};\n use crate::constrained_generic_params as cgp;\n use crate::check::intrinsic::intrisic_operation_unsafety;\n use crate::lint;\n-use crate::middle::lang_items::SizedTraitLangItem;\n use crate::middle::resolve_lifetime as rl;\n use crate::middle::weak_lang_items;\n use rustc::mir::mono::Linkage;\n@@ -233,7 +232,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n     }\n \n     fn set_tainted_by_errors(&self) {\n-        // no obvious place to track this, just let it go\n+        // no obvious place to track this, so just let it go\n     }\n \n     fn record_ty(&self, _hir_id: hir::HirId, _ty: Ty<'tcx>, _span: Span) {\n@@ -447,7 +446,7 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: hir::HirId) {\n             }\n         }\n \n-        // Desugared from `impl Trait` -> visited by the function's return type\n+        // Desugared from `impl Trait`, so visited by the function's return type.\n         hir::ItemKind::Existential(hir::ExistTy {\n             impl_trait_fn: Some(_),\n             ..\n@@ -704,7 +703,8 @@ fn super_predicates_of<'a, 'tcx>(\n \n     // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n     let self_param_ty = tcx.mk_self_type();\n-    let superbounds1 = compute_bounds(&icx, self_param_ty, bounds, SizedByDefault::No, item.span);\n+    let superbounds1 = AstConv::compute_bounds(&icx, self_param_ty, bounds, SizedByDefault::No,\n+        item.span);\n \n     let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n \n@@ -1218,7 +1218,7 @@ pub fn checked_type_of<'a, 'tcx>(\n                     impl_trait_fn: None,\n                     ..\n                 }) => find_existential_constraints(tcx, def_id),\n-                // existential types desugared from impl Trait\n+                // Existential types desugared from `impl Trait`.\n                 ItemKind::Existential(hir::ExistTy {\n                     impl_trait_fn: Some(owner),\n                     ..\n@@ -1472,11 +1472,13 @@ fn find_existential_constraints<'a, 'tcx>(\n ) -> Ty<'tcx> {\n     use rustc::hir::{ImplItem, Item, TraitItem};\n \n+    debug!(\"find_existential_constraints({:?})\", def_id);\n+\n     struct ConstraintLocator<'a, 'tcx: 'a> {\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         def_id: DefId,\n-        // First found type span, actual type, mapping from the existential type's generic\n-        // parameters to the concrete type's generic parameters\n+        // (first found type span, actual type, mapping from the existential type's generic\n+        // parameters to the concrete type's generic parameters)\n         //\n         // The mapping is an index for each use site of a generic parameter in the concrete type\n         //\n@@ -1486,10 +1488,13 @@ fn find_existential_constraints<'a, 'tcx>(\n \n     impl<'a, 'tcx> ConstraintLocator<'a, 'tcx> {\n         fn check(&mut self, def_id: DefId) {\n-            trace!(\"checking {:?}\", def_id);\n-            // don't try to check items that cannot possibly constrain the type\n+            // Don't try to check items that cannot possibly constrain the type.\n             if !self.tcx.has_typeck_tables(def_id) {\n-                trace!(\"no typeck tables for {:?}\", def_id);\n+                debug!(\n+                    \"find_existential_constraints: no constraint for `{:?}` at `{:?}`: no tables\",\n+                    self.def_id,\n+                    def_id,\n+                );\n                 return;\n             }\n             let ty = self\n@@ -1498,22 +1503,32 @@ fn find_existential_constraints<'a, 'tcx>(\n                 .concrete_existential_types\n                 .get(&self.def_id);\n             if let Some(ty::ResolvedOpaqueTy { concrete_type, substs }) = ty {\n-                // FIXME(oli-obk): trace the actual span from inference to improve errors\n+                debug!(\n+                    \"find_existential_constraints: found constraint for `{:?}` at `{:?}`: {:?}\",\n+                    self.def_id,\n+                    def_id,\n+                    ty,\n+                );\n+\n+                // FIXME(oli-obk): trace the actual span from inference to improve errors.\n                 let span = self.tcx.def_span(def_id);\n                 // used to quickly look up the position of a generic parameter\n                 let mut index_map: FxHashMap<ty::ParamTy, usize> = FxHashMap::default();\n-                // skip binder is ok, since we only use this to find generic parameters and their\n-                // positions.\n+                // Skipping binder is ok, since we only use this to find generic parameters and\n+                // their positions.\n                 for (idx, subst) in substs.iter().enumerate() {\n                     if let UnpackedKind::Type(ty) = subst.unpack() {\n                         if let ty::Param(p) = ty.sty {\n                             if index_map.insert(p, idx).is_some() {\n-                                // there was already an entry for `p`, meaning a generic parameter\n-                                // was used twice\n+                                // There was already an entry for `p`, meaning a generic parameter\n+                                // was used twice.\n                                 self.tcx.sess.span_err(\n                                     span,\n-                                    &format!(\"defining existential type use restricts existential \\\n-                                    type by using the generic parameter `{}` twice\", p.name),\n+                                    &format!(\n+                                        \"defining existential type use restricts existential \\\n+                                         type by using the generic parameter `{}` twice\",\n+                                        p.name\n+                                    ),\n                                 );\n                                 return;\n                             }\n@@ -1528,8 +1543,8 @@ fn find_existential_constraints<'a, 'tcx>(\n                         }\n                     }\n                 }\n-                // compute the index within the existential type for each generic parameter used in\n-                // the concrete type\n+                // Compute the index within the existential type for each generic parameter used in\n+                // the concrete type.\n                 let indices = concrete_type\n                     .subst(self.tcx, substs)\n                     .walk()\n@@ -1550,14 +1565,15 @@ fn find_existential_constraints<'a, 'tcx>(\n                     let mut ty = concrete_type.walk().fuse();\n                     let mut p_ty = prev_ty.walk().fuse();\n                     let iter_eq = (&mut ty).zip(&mut p_ty).all(|(t, p)| match (&t.sty, &p.sty) {\n-                        // type parameters are equal to any other type parameter for the purpose of\n+                        // Type parameters are equal to any other type parameter for the purpose of\n                         // concrete type equality, as it is possible to obtain the same type just\n                         // by passing matching parameters to a function.\n                         (ty::Param(_), ty::Param(_)) => true,\n                         _ => t == p,\n                     });\n                     if !iter_eq || ty.next().is_some() || p_ty.next().is_some() {\n-                        // found different concrete types for the existential type\n+                        debug!(\"find_existential_constraints: span={:?}\", span);\n+                        // Found different concrete types for the existential type.\n                         let mut err = self.tcx.sess.struct_span_err(\n                             span,\n                             \"concrete type differs from previous defining existential type use\",\n@@ -1569,7 +1585,7 @@ fn find_existential_constraints<'a, 'tcx>(\n                         err.span_note(prev_span, \"previous use here\");\n                         err.emit();\n                     } else if indices != *prev_indices {\n-                        // found \"same\" concrete types, but the generic parameter order differs\n+                        // Found \"same\" concrete types, but the generic parameter order differs.\n                         let mut err = self.tcx.sess.struct_span_err(\n                             span,\n                             \"concrete type's generic parameters differ from previous defining use\",\n@@ -1597,6 +1613,12 @@ fn find_existential_constraints<'a, 'tcx>(\n                 } else {\n                     self.found = Some((span, concrete_type, indices));\n                 }\n+            } else {\n+                debug!(\n+                    \"find_existential_constraints: no constraint for `{:?}` at `{:?}`\",\n+                    self.def_id,\n+                    def_id,\n+                );\n             }\n         }\n     }\n@@ -1607,15 +1629,15 @@ fn find_existential_constraints<'a, 'tcx>(\n         }\n         fn visit_item(&mut self, it: &'tcx Item) {\n             let def_id = self.tcx.hir().local_def_id_from_hir_id(it.hir_id);\n-            // the existential type itself or its children are not within its reveal scope\n+            // The existential type itself or its children are not within its reveal scope.\n             if def_id != self.def_id {\n                 self.check(def_id);\n                 intravisit::walk_item(self, it);\n             }\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem) {\n             let def_id = self.tcx.hir().local_def_id_from_hir_id(it.hir_id);\n-            // the existential type itself or its children are not within its reveal scope\n+            // The existential type itself or its children are not within its reveal scope.\n             if def_id != self.def_id {\n                 self.check(def_id);\n                 intravisit::walk_impl_item(self, it);\n@@ -1628,26 +1650,28 @@ fn find_existential_constraints<'a, 'tcx>(\n         }\n     }\n \n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let scope = tcx.hir()\n+        .get_defining_scope(hir_id)\n+        .expect(\"could not get defining scope\");\n     let mut locator = ConstraintLocator {\n         def_id,\n         tcx,\n         found: None,\n     };\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let parent = tcx.hir().get_parent_item(hir_id);\n \n-    trace!(\"parent_id: {:?}\", parent);\n+    debug!(\"find_existential_constraints: scope={:?}\", scope);\n \n-    if parent == hir::CRATE_HIR_ID {\n+    if scope == hir::CRATE_HIR_ID {\n         intravisit::walk_crate(&mut locator, tcx.hir().krate());\n     } else {\n-        trace!(\"parent: {:?}\", tcx.hir().get_by_hir_id(parent));\n-        match tcx.hir().get_by_hir_id(parent) {\n+        debug!(\"find_existential_constraints: scope={:?}\", tcx.hir().get_by_hir_id(scope));\n+        match tcx.hir().get_by_hir_id(scope) {\n             Node::Item(ref it) => intravisit::walk_item(&mut locator, it),\n             Node::ImplItem(ref it) => intravisit::walk_impl_item(&mut locator, it),\n             Node::TraitItem(ref it) => intravisit::walk_trait_item(&mut locator, it),\n             other => bug!(\n-                \"{:?} is not a valid parent of an existential type item\",\n+                \"{:?} is not a valid scope for an existential type item\",\n                 other\n             ),\n         }\n@@ -1765,57 +1789,6 @@ fn impl_polarity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> hir::I\n     }\n }\n \n-// Is it marked with ?Sized\n-fn is_unsized<'gcx: 'tcx, 'tcx>(\n-    astconv: &dyn AstConv<'gcx, 'tcx>,\n-    ast_bounds: &[hir::GenericBound],\n-    span: Span,\n-) -> bool {\n-    let tcx = astconv.tcx();\n-\n-    // Try to find an unbound in bounds.\n-    let mut unbound = None;\n-    for ab in ast_bounds {\n-        if let &hir::GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = ab {\n-            if unbound.is_none() {\n-                unbound = Some(ptr.trait_ref.clone());\n-            } else {\n-                span_err!(\n-                    tcx.sess,\n-                    span,\n-                    E0203,\n-                    \"type parameter has more than one relaxed default \\\n-                     bound, only one is supported\"\n-                );\n-            }\n-        }\n-    }\n-\n-    let kind_id = tcx.lang_items().require(SizedTraitLangItem);\n-    match unbound {\n-        Some(ref tpb) => {\n-            // FIXME(#8559) currently requires the unbound to be built-in.\n-            if let Ok(kind_id) = kind_id {\n-                if tpb.path.res != Res::Def(DefKind::Trait, kind_id) {\n-                    tcx.sess.span_warn(\n-                        span,\n-                        \"default bound relaxed for a type parameter, but \\\n-                         this does nothing because the given bound is not \\\n-                         a default. Only `?Sized` is supported\",\n-                    );\n-                }\n-            }\n-        }\n-        _ if kind_id.is_ok() => {\n-            return false;\n-        }\n-        // No lang item for Sized, so we can't add it as a bound.\n-        None => {}\n-    }\n-\n-    true\n-}\n-\n /// Returns the early-bound lifetimes declared in this generics\n /// listing. For anything other than fns/methods, this is just all\n /// the lifetimes that are declared. For fns or methods, we have to\n@@ -1960,8 +1933,8 @@ fn explicit_predicates_of<'a, 'tcx>(\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                 let opaque_ty = tcx.mk_opaque(def_id, substs);\n \n-                // Collect the bounds, i.e., the `A+B+'c` in `impl A+B+'c`.\n-                let bounds = compute_bounds(\n+                // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n+                let bounds = AstConv::compute_bounds(\n                     &icx,\n                     opaque_ty,\n                     bounds,\n@@ -2006,24 +1979,25 @@ fn explicit_predicates_of<'a, 'tcx>(\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                     let opaque_ty = tcx.mk_opaque(def_id, substs);\n \n-                    // Collect the bounds, i.e., the `A+B+'c` in `impl A+B+'c`.\n-                    let bounds = compute_bounds(\n+                    // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n+                    let bounds = AstConv::compute_bounds(\n                         &icx,\n                         opaque_ty,\n                         bounds,\n                         SizedByDefault::Yes,\n                         tcx.def_span(def_id),\n                     );\n \n+                    let bounds_predicates = bounds.predicates(tcx, opaque_ty);\n                     if impl_trait_fn.is_some() {\n-                        // impl Trait\n+                        // opaque types\n                         return tcx.arena.alloc(ty::GenericPredicates {\n                             parent: None,\n-                            predicates: bounds.predicates(tcx, opaque_ty),\n+                            predicates: bounds_predicates,\n                         });\n                     } else {\n                         // named existential types\n-                        predicates.extend(bounds.predicates(tcx, opaque_ty));\n+                        predicates.extend(bounds_predicates);\n                         generics\n                     }\n                 }\n@@ -2093,20 +2067,20 @@ fn explicit_predicates_of<'a, 'tcx>(\n     }\n \n     // Collect the predicates that were written inline by the user on each\n-    // type parameter (e.g., `<T:Foo>`).\n+    // type parameter (e.g., `<T: Foo>`).\n     for param in &ast_generics.params {\n         if let GenericParamKind::Type { .. } = param.kind {\n             let name = param.name.ident().as_interned_str();\n             let param_ty = ty::ParamTy::new(index, name).to_ty(tcx);\n             index += 1;\n \n             let sized = SizedByDefault::Yes;\n-            let bounds = compute_bounds(&icx, param_ty, &param.bounds, sized, param.span);\n+            let bounds = AstConv::compute_bounds(&icx, param_ty, &param.bounds, sized, param.span);\n             predicates.extend(bounds.predicates(tcx, param_ty));\n         }\n     }\n \n-    // Add in the bounds that appear in the where-clause\n+    // Add in the bounds that appear in the where-clause.\n     let where_clause = &ast_generics.where_clause;\n     for predicate in &where_clause.predicates {\n         match predicate {\n@@ -2136,19 +2110,17 @@ fn explicit_predicates_of<'a, 'tcx>(\n                 for bound in bound_pred.bounds.iter() {\n                     match bound {\n                         &hir::GenericBound::Trait(ref poly_trait_ref, _) => {\n-                            let mut projections = Vec::new();\n+                            let mut bounds = Bounds::default();\n \n                             let (trait_ref, _) = AstConv::instantiate_poly_trait_ref(\n                                 &icx,\n                                 poly_trait_ref,\n                                 ty,\n-                                &mut projections,\n+                                &mut bounds,\n                             );\n \n-                            predicates.extend(\n-                                iter::once((trait_ref.to_predicate(), poly_trait_ref.span)).chain(\n-                                    projections.iter().map(|&(p, span)| (p.to_predicate(), span)\n-                            )));\n+                            predicates.push((trait_ref.to_predicate(), poly_trait_ref.span));\n+                            predicates.extend(bounds.predicates(tcx, ty));\n                         }\n \n                         &hir::GenericBound::Outlives(ref lifetime) => {\n@@ -2187,14 +2159,14 @@ fn explicit_predicates_of<'a, 'tcx>(\n             let trait_item = tcx.hir().trait_item(trait_item_ref.id);\n             let bounds = match trait_item.node {\n                 hir::TraitItemKind::Type(ref bounds, _) => bounds,\n-                _ => return vec![].into_iter()\n+                _ => return Vec::new().into_iter()\n             };\n \n             let assoc_ty =\n                 tcx.mk_projection(tcx.hir().local_def_id_from_hir_id(trait_item.hir_id),\n                     self_trait_ref.substs);\n \n-            let bounds = compute_bounds(\n+            let bounds = AstConv::compute_bounds(\n                 &ItemCtxt::new(tcx, def_id),\n                 assoc_ty,\n                 bounds,\n@@ -2236,68 +2208,6 @@ fn explicit_predicates_of<'a, 'tcx>(\n     result\n }\n \n-pub enum SizedByDefault {\n-    Yes,\n-    No,\n-}\n-\n-/// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped `Ty`\n-/// or a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n-/// built-in trait `Send`.\n-pub fn compute_bounds<'gcx: 'tcx, 'tcx>(\n-    astconv: &dyn AstConv<'gcx, 'tcx>,\n-    param_ty: Ty<'tcx>,\n-    ast_bounds: &[hir::GenericBound],\n-    sized_by_default: SizedByDefault,\n-    span: Span,\n-) -> Bounds<'tcx> {\n-    let mut region_bounds = Vec::new();\n-    let mut trait_bounds = Vec::new();\n-\n-    for ast_bound in ast_bounds {\n-        match *ast_bound {\n-            hir::GenericBound::Trait(ref b, hir::TraitBoundModifier::None) => trait_bounds.push(b),\n-            hir::GenericBound::Trait(_, hir::TraitBoundModifier::Maybe) => {}\n-            hir::GenericBound::Outlives(ref l) => region_bounds.push(l),\n-        }\n-    }\n-\n-    let mut projection_bounds = Vec::new();\n-\n-    let mut trait_bounds: Vec<_> = trait_bounds.iter().map(|&bound| {\n-        let (poly_trait_ref, _) = astconv.instantiate_poly_trait_ref(\n-            bound,\n-            param_ty,\n-            &mut projection_bounds,\n-        );\n-        (poly_trait_ref, bound.span)\n-    }).collect();\n-\n-    let region_bounds = region_bounds\n-        .into_iter()\n-        .map(|r| (astconv.ast_region_to_region(r, None), r.span))\n-        .collect();\n-\n-    trait_bounds.sort_by_key(|(t, _)| t.def_id());\n-\n-    let implicitly_sized = if let SizedByDefault::Yes = sized_by_default {\n-        if !is_unsized(astconv, ast_bounds, span) {\n-            Some(span)\n-        } else {\n-            None\n-        }\n-    } else {\n-        None\n-    };\n-\n-    Bounds {\n-        region_bounds,\n-        implicitly_sized,\n-        trait_bounds,\n-        projection_bounds,\n-    }\n-}\n-\n /// Converts a specific `GenericBound` from the AST into a set of\n /// predicates that apply to the self type. A vector is returned\n /// because this can be anywhere from zero predicates (`T: ?Sized` adds no\n@@ -2310,13 +2220,11 @@ fn predicates_from_bound<'tcx>(\n ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n     match *bound {\n         hir::GenericBound::Trait(ref tr, hir::TraitBoundModifier::None) => {\n-            let mut projections = Vec::new();\n-            let (pred, _) = astconv.instantiate_poly_trait_ref(tr, param_ty, &mut projections);\n-            iter::once((pred.to_predicate(), tr.span)).chain(\n-                projections\n-                    .into_iter()\n-                    .map(|(p, span)| (p.to_predicate(), span))\n-            ).collect()\n+            let mut bounds = Bounds::default();\n+            let (pred, _) = astconv.instantiate_poly_trait_ref(tr, param_ty, &mut bounds);\n+            iter::once((pred.to_predicate(), tr.span))\n+                .chain(bounds.predicates(astconv.tcx(), param_ty))\n+                .collect()\n         }\n         hir::GenericBound::Outlives(ref lifetime) => {\n             let region = astconv.ast_region_to_region(lifetime, None);\n@@ -2340,8 +2248,8 @@ fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n     };\n     let fty = AstConv::ty_of_fn(&ItemCtxt::new(tcx, def_id), unsafety, abi, decl);\n \n-    // feature gate SIMD types in FFI, since I (huonw) am not sure the\n-    // ABIs are handled at all correctly.\n+    // Feature gate SIMD types in FFI, since I am not sure that the\n+    // ABIs are handled at all correctly. -huonw\n     if abi != abi::Abi::RustIntrinsic\n         && abi != abi::Abi::PlatformIntrinsic\n         && !tcx.features().simd_ffi\n@@ -2416,13 +2324,13 @@ fn from_target_feature(\n     };\n     let rust_features = tcx.features();\n     for item in list {\n-        // Only `enable = ...` is accepted in the meta item list\n+        // Only `enable = ...` is accepted in the meta-item list.\n         if !item.check_name(sym::enable) {\n             bad_item(item.span());\n             continue;\n         }\n \n-        // Must be of the form `enable = \"...\"` ( a string)\n+        // Must be of the form `enable = \"...\"` (a string).\n         let value = match item.value_str() {\n             Some(value) => value,\n             None => {\n@@ -2431,9 +2339,9 @@ fn from_target_feature(\n             }\n         };\n \n-        // We allow comma separation to enable multiple features\n+        // We allow comma separation to enable multiple features.\n         target_features.extend(value.as_str().split(',').filter_map(|feature| {\n-            // Only allow whitelisted features per platform\n+            // Only allow whitelisted features per platform.\n             let feature_gate = match whitelist.get(feature) {\n                 Some(g) => g,\n                 None => {\n@@ -2457,7 +2365,7 @@ fn from_target_feature(\n                 }\n             };\n \n-            // Only allow features whose feature gates have been enabled\n+            // Only allow features whose feature gates have been enabled.\n             let allowed = match feature_gate.as_ref().map(|s| *s) {\n                 Some(sym::arm_target_feature) => rust_features.arm_target_feature,\n                 Some(sym::aarch64_target_feature) => rust_features.aarch64_target_feature,\n@@ -2545,7 +2453,7 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n             if tcx.is_foreign_item(id) {\n                 codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE;\n             } else {\n-                // `#[ffi_returns_twice]` is only allowed `extern fn`s\n+                // `#[ffi_returns_twice]` is only allowed `extern fn`s.\n                 struct_span_err!(\n                     tcx.sess,\n                     attr.span,"}, {"sha": "30993b86a385fa6c2b4166d64747af2110dd2f4e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -114,6 +114,7 @@ use util::common::time;\n \n use std::iter;\n \n+use astconv::{AstConv, Bounds};\n pub use collect::checked_type_of;\n \n pub struct TypeAndSubsts<'tcx> {\n@@ -379,8 +380,8 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n /// A quasi-deprecated helper used in rustdoc and clippy to get\n /// the type from a HIR node.\n pub fn hir_ty_to_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_ty: &hir::Ty) -> Ty<'tcx> {\n-    // In case there are any projections etc, find the \"environment\"\n-    // def-id that will be used to determine the traits/predicates in\n+    // In case there are any projections, etc., find the \"environment\"\n+    // def-ID that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing.\n     let env_node_id = tcx.hir().get_parent_item(hir_ty.hir_id);\n     let env_def_id = tcx.hir().local_def_id_from_hir_id(env_node_id);\n@@ -390,19 +391,19 @@ pub fn hir_ty_to_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_ty: &hir::Ty) ->\n }\n \n pub fn hir_trait_to_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_trait: &hir::TraitRef)\n-        -> (ty::PolyTraitRef<'tcx>, Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>) {\n-    // In case there are any projections etc, find the \"environment\"\n-    // def-id that will be used to determine the traits/predicates in\n+        -> (ty::PolyTraitRef<'tcx>, Bounds<'tcx>) {\n+    // In case there are any projections, etc., find the \"environment\"\n+    // def-ID that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing.\n     let env_hir_id = tcx.hir().get_parent_item(hir_trait.hir_ref_id);\n     let env_def_id = tcx.hir().local_def_id_from_hir_id(env_hir_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id);\n-    let mut projections = Vec::new();\n-    let (principal, _) = astconv::AstConv::instantiate_poly_trait_ref_inner(\n-        &item_cx, hir_trait, tcx.types.err, &mut projections, true\n+    let mut bounds = Bounds::default();\n+    let (principal, _) = AstConv::instantiate_poly_trait_ref_inner(\n+        &item_cx, hir_trait, tcx.types.err, &mut bounds, true\n     );\n \n-    (principal, projections)\n+    (principal, bounds)\n }\n \n __build_diagnostic_array! { librustc_typeck, DIAGNOSTICS }"}, {"sha": "60d6c33f81afcf910d930682f846411a8f3a8f4a", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -626,7 +626,9 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                                             } => {\n                                                 bindings.push(TypeBinding {\n                                                     name: left_name.clone(),\n-                                                    ty: rhs,\n+                                                    kind: TypeBindingKind::Equality {\n+                                                        ty: rhs,\n+                                                    },\n                                                 });\n                                             }\n                                             &mut GenericArgs::Parenthesized { .. } => {"}, {"sha": "03d16feb483a9c5110bc1e257e5115d2429f58ab", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 57, "deletions": 18, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -1979,7 +1979,7 @@ impl FnDecl {\n                 match &bounds[0] {\n                     GenericBound::TraitBound(PolyTrait { trait_, .. }, ..) => {\n                         let bindings = trait_.bindings().unwrap();\n-                        FunctionRetTy::Return(bindings[0].ty.clone())\n+                        FunctionRetTy::Return(bindings[0].ty().clone())\n                     }\n                     _ => panic!(\"unexpected desugaring of async function\"),\n                 }\n@@ -2443,12 +2443,12 @@ pub struct PolyTrait {\n     pub generic_params: Vec<GenericParamDef>,\n }\n \n-/// A representation of a Type suitable for hyperlinking purposes. Ideally one can get the original\n-/// type out of the AST/TyCtxt given one of these, if more information is needed. Most importantly\n-/// it does not preserve mutability or boxes.\n+/// A representation of a type suitable for hyperlinking purposes. Ideally, one can get the original\n+/// type out of the AST/`TyCtxt` given one of these, if more information is needed. Most\n+/// importantly, it does not preserve mutability or boxes.\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub enum Type {\n-    /// Structs/enums/traits (most that'd be an `hir::TyKind::Path`).\n+    /// Structs/enums/traits (most that would be an `hir::TyKind::Path`).\n     ResolvedPath {\n         path: Path,\n         param_names: Option<Vec<GenericBound>>,\n@@ -2462,7 +2462,7 @@ pub enum Type {\n     /// Primitives are the fixed-size numeric types (plus int/usize/float), char,\n     /// arrays, slices, and tuples.\n     Primitive(PrimitiveType),\n-    /// extern \"ABI\" fn\n+    /// `extern \"ABI\" fn`\n     BareFunction(Box<BareFunctionDecl>),\n     Tuple(Vec<Type>),\n     Slice(Box<Type>),\n@@ -2477,17 +2477,17 @@ pub enum Type {\n         type_: Box<Type>,\n     },\n \n-    // <Type as Trait>::Name\n+    // `<Type as Trait>::Name`\n     QPath {\n         name: String,\n         self_type: Box<Type>,\n         trait_: Box<Type>\n     },\n \n-    // _\n+    // `_`\n     Infer,\n \n-    // impl TraitA+TraitB\n+    // `impl TraitA + TraitB + ...`\n     ImplTrait(Vec<GenericBound>),\n }\n \n@@ -2747,7 +2747,6 @@ impl Clean<Type> for hir::Ty {\n \n         match self.node {\n             TyKind::Never => Never,\n-            TyKind::CVarArgs(_) => CVarArgs,\n             TyKind::Ptr(ref m) => RawPointer(m.mutbl.clean(cx), box m.ty.clean(cx)),\n             TyKind::Rptr(ref l, ref m) => {\n                 let lifetime = if l.is_elided() {\n@@ -2933,12 +2932,13 @@ impl Clean<Type> for hir::Ty {\n                         }\n                         ResolvedPath { path, param_names: Some(bounds), did, is_generic, }\n                     }\n-                    _ => Infer // shouldn't happen\n+                    _ => Infer, // shouldn't happen\n                 }\n             }\n             TyKind::BareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n             TyKind::Infer | TyKind::Err => Infer,\n-            TyKind::Typeof(..) => panic!(\"Unimplemented type {:?}\", self.node),\n+            TyKind::Typeof(..) => panic!(\"unimplemented type {:?}\", self.node),\n+            TyKind::CVarArgs(_) => CVarArgs,\n         }\n     }\n }\n@@ -3054,7 +3054,9 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 for pb in obj.projection_bounds() {\n                     bindings.push(TypeBinding {\n                         name: cx.tcx.associated_item(pb.item_def_id()).ident.name.clean(cx),\n-                        ty: pb.skip_binder().ty.clean(cx)\n+                        kind: TypeBindingKind::Equality {\n+                            ty: pb.skip_binder().ty.clean(cx)\n+                        },\n                     });\n                 }\n \n@@ -3110,7 +3112,9 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                                 Some(TypeBinding {\n                                     name: cx.tcx.associated_item(proj.projection_ty.item_def_id)\n                                                 .ident.name.clean(cx),\n-                                    ty: proj.ty.clean(cx),\n+                                    kind: TypeBindingKind::Equality {\n+                                        ty: proj.ty.clean(cx),\n+                                    },\n                                 })\n                             } else {\n                                 None\n@@ -3495,7 +3499,7 @@ pub enum GenericArgs {\n impl Clean<GenericArgs> for hir::GenericArgs {\n     fn clean(&self, cx: &DocContext<'_>) -> GenericArgs {\n         if self.parenthesized {\n-            let output = self.bindings[0].ty.clean(cx);\n+            let output = self.bindings[0].ty().clean(cx);\n             GenericArgs::Parenthesized {\n                 inputs: self.inputs().clean(cx),\n                 output: if output != Type::Tuple(Vec::new()) { Some(output) } else { None }\n@@ -4343,18 +4347,53 @@ impl Clean<Deprecation> for attr::Deprecation {\n     }\n }\n \n-/// An equality constraint on an associated type, e.g., `A = Bar` in `Foo<A = Bar>`\n+/// An type binding on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or\n+/// `A: Send + Sync` in `Foo<A: Send + Sync>`).\n #[derive(Clone, PartialEq, Eq, RustcDecodable, RustcEncodable, Debug, Hash)]\n pub struct TypeBinding {\n     pub name: String,\n-    pub ty: Type\n+    pub kind: TypeBindingKind,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcDecodable, RustcEncodable, Debug, Hash)]\n+pub enum TypeBindingKind {\n+    Equality {\n+        ty: Type,\n+    },\n+    Constraint {\n+        bounds: Vec<GenericBound>,\n+    },\n+}\n+\n+impl TypeBinding {\n+    pub fn ty(&self) -> &Type {\n+        match self.kind {\n+            TypeBindingKind::Equality { ref ty } => ty,\n+            _ => panic!(\"expected equality type binding for parenthesized generic args\"),\n+        }\n+    }\n }\n \n impl Clean<TypeBinding> for hir::TypeBinding {\n     fn clean(&self, cx: &DocContext<'_>) -> TypeBinding {\n         TypeBinding {\n             name: self.ident.name.clean(cx),\n-            ty: self.ty.clean(cx)\n+            kind: self.kind.clean(cx),\n+        }\n+    }\n+}\n+\n+impl Clean<TypeBindingKind> for hir::TypeBindingKind {\n+    fn clean(&self, cx: &DocContext<'_>) -> TypeBindingKind {\n+        match *self {\n+            hir::TypeBindingKind::Equality { ref ty } =>\n+                TypeBindingKind::Equality {\n+                    ty: ty.clean(cx),\n+                },\n+            hir::TypeBindingKind::Constraint { ref bounds } =>\n+                TypeBindingKind::Constraint {\n+                    bounds: bounds.into_iter().map(|b| b.clean(cx)).collect(),\n+                },\n         }\n     }\n }"}, {"sha": "36e6a6003df0943ed821f854e1a41161a0eb4b18", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -91,7 +91,9 @@ pub fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n                 PP::AngleBracketed { ref mut bindings, .. } => {\n                     bindings.push(clean::TypeBinding {\n                         name: name.clone(),\n-                        ty: rhs.clone(),\n+                        kind: clean::TypeBindingKind::Equality {\n+                            ty: rhs.clone(),\n+                        },\n                     });\n                 }\n                 PP::Parenthesized { ref mut output, .. } => {"}, {"sha": "fa3bc3f5f4f8bda6064f139d92431490ae147a5a", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -18,7 +18,6 @@ use crate::core::DocAccessLevels;\n use crate::html::item_type::ItemType;\n use crate::html::render::{self, cache, CURRENT_LOCATION_KEY};\n \n-\n /// Helper to render an optional visibility with a space after it (if the\n /// visibility is preset)\n #[derive(Copy, Clone)]\n@@ -561,7 +560,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n             if param_names.is_some() {\n                 f.write_str(\"dyn \")?;\n             }\n-            // Paths like T::Output and Self::Output should be rendered with all segments\n+            // Paths like `T::Output` and `Self::Output` should be rendered with all segments.\n             resolved_path(f, did, path, is_generic, use_absolute)?;\n             tybounds(f, param_names)\n         }\n@@ -585,7 +584,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                 &[] => primitive_link(f, PrimitiveType::Unit, \"()\"),\n                 &[ref one] => {\n                     primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n-                    //carry f.alternate() into this display w/o branching manually\n+                    // Carry `f.alternate()` into this display w/o branching manually.\n                     fmt::Display::fmt(one, f)?;\n                     primitive_link(f, PrimitiveType::Tuple, \",)\")\n                 }\n@@ -638,7 +637,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                 \"&amp;\".to_string()\n             };\n             match **ty {\n-                clean::Slice(ref bt) => { // BorrowedRef{ ... Slice(T) } is &[T]\n+                clean::Slice(ref bt) => { // `BorrowedRef{ ... Slice(T) }` is `&[T]`\n                     match **bt {\n                         clean::Generic(_) => {\n                             if f.alternate() {\n@@ -1020,11 +1019,26 @@ impl fmt::Display for clean::ImportSource {\n \n impl fmt::Display for clean::TypeBinding {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if f.alternate() {\n-            write!(f, \"{} = {:#}\", self.name, self.ty)\n-        } else {\n-            write!(f, \"{} = {}\", self.name, self.ty)\n+        f.write_str(&self.name)?;\n+        match self.kind {\n+            clean::TypeBindingKind::Equality { ref ty } => {\n+                if f.alternate() {\n+                    write!(f, \" = {:#}\", ty)?;\n+                } else {\n+                    write!(f, \" = {}\", ty)?;\n+                }\n+            }\n+            clean::TypeBindingKind::Constraint { ref bounds } => {\n+                if !bounds.is_empty() {\n+                    if f.alternate() {\n+                        write!(f, \": {:#}\", GenericBounds(bounds))?;\n+                    } else {\n+                        write!(f, \":&nbsp;{}\", GenericBounds(bounds))?;\n+                    }\n+                }\n+            }\n         }\n+        Ok(())\n     }\n }\n "}, {"sha": "9ef42063f94126cd28a79179836bf8d4a370c4e2", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -171,7 +171,8 @@ fn default_hook(info: &PanicInfo<'_>) {\n         }\n     };\n \n-    let location = info.location().unwrap();  // The current implementation always returns Some\n+    // The current implementation always returns `Some`.\n+    let location = info.location().unwrap();\n \n     let msg = match info.payload().downcast_ref::<&'static str>() {\n         Some(s) => *s,\n@@ -196,7 +197,7 @@ fn default_hook(info: &PanicInfo<'_>) {\n             if let Some(format) = log_backtrace {\n                 let _ = backtrace::print(err, format);\n             } else if FIRST_PANIC.compare_and_swap(true, false, Ordering::SeqCst) {\n-                let _ = writeln!(err, \"note: Run with `RUST_BACKTRACE=1` \\\n+                let _ = writeln!(err, \"note: run with `RUST_BACKTRACE=1` \\\n                                        environment variable to display a backtrace.\");\n             }\n         }"}, {"sha": "bf37ff7ddbd3a2edb852e9a7a14ce41d73ee3264", "filename": "src/libstd/sys_common/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fbacktrace.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -173,7 +173,7 @@ impl<'a, 'b> Printer<'a, 'b> {\n             Some(symbol) => {\n                 match self.format {\n                     PrintFormat::Full => write!(self.out, \"{}\", symbol)?,\n-                    // strip the trailing hash if short mode\n+                    // Strip the trailing hash if short mode.\n                     PrintFormat::Short => write!(self.out, \"{:#}\", symbol)?,\n                 }\n             }"}, {"sha": "598232f9f8f22e4de8bbe1506b3f5791bd8fc685", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -190,9 +190,9 @@ pub struct AngleBracketedArgs {\n     pub span: Span,\n     /// The arguments for this path segment.\n     pub args: Vec<GenericArg>,\n-    /// Bindings (equality constraints) on associated types, if present.\n-    /// E.g., `Foo<A = Bar>`.\n-    pub bindings: Vec<TypeBinding>,\n+    /// Constraints on associated types, if any.\n+    /// E.g., `Foo<A = Bar, B: Baz>`.\n+    pub constraints: Vec<AssocTyConstraint>,\n }\n \n impl Into<Option<P<GenericArgs>>> for AngleBracketedArgs {\n@@ -213,7 +213,7 @@ pub struct ParenthesizedArgs {\n     /// Overall span\n     pub span: Span,\n \n-    /// `(A,B)`\n+    /// `(A, B)`\n     pub inputs: Vec<P<Ty>>,\n \n     /// `C`\n@@ -225,7 +225,7 @@ impl ParenthesizedArgs {\n         AngleBracketedArgs {\n             span: self.span,\n             args: self.inputs.iter().cloned().map(|input| GenericArg::Type(input)).collect(),\n-            bindings: vec![],\n+            constraints: vec![],\n         }\n     }\n }\n@@ -1611,15 +1611,29 @@ impl fmt::Display for UintTy {\n     }\n }\n \n-// Bind a type to an associated type: `A = Foo`.\n+/// A constraint on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or\n+/// `A: TraitA + TraitB` in `Foo<A: TraitA + TraitB>`).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub struct TypeBinding {\n+pub struct AssocTyConstraint {\n     pub id: NodeId,\n     pub ident: Ident,\n-    pub ty: P<Ty>,\n+    pub kind: AssocTyConstraintKind,\n     pub span: Span,\n }\n \n+/// The kinds of an `AssocTyConstraint`.\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub enum AssocTyConstraintKind {\n+    /// E.g., `A = Bar` in `Foo<A = Bar>`.\n+    Equality {\n+        ty: P<Ty>,\n+    },\n+    /// E.g. `A: TraitA + TraitB` in `Foo<A: TraitA + TraitB>`.\n+    Bound {\n+        bounds: GenericBounds,\n+    },\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Ty {\n     pub id: NodeId,\n@@ -1840,7 +1854,7 @@ impl Arg {\n     }\n }\n \n-/// Header (not the body) of a function declaration.\n+/// A header (not the body) of a function declaration.\n ///\n /// E.g., `fn foo(bar: baz)`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "2a03e49996b6cac49adbcf413b2fb138b3e31176", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -10,15 +10,15 @@ use rustc_target::spec::abi::Abi;\n use syntax_pos::{Pos, Span};\n \n pub trait AstBuilder {\n-    // paths\n+    // Paths\n     fn path(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path;\n     fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path;\n     fn path_global(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path;\n     fn path_all(&self, sp: Span,\n                 global: bool,\n                 idents: Vec<ast::Ident>,\n                 args: Vec<ast::GenericArg>,\n-                bindings: Vec<ast::TypeBinding>)\n+                constraints: Vec<ast::AssocTyConstraint>)\n         -> ast::Path;\n \n     fn qpath(&self, self_type: P<ast::Ty>,\n@@ -29,7 +29,7 @@ pub trait AstBuilder {\n                 trait_path: ast::Path,\n                 ident: ast::Ident,\n                 args: Vec<ast::GenericArg>,\n-                bindings: Vec<ast::TypeBinding>)\n+                constraints: Vec<ast::AssocTyConstraint>)\n                 -> (ast::QSelf, ast::Path);\n \n     // types and consts\n@@ -69,7 +69,7 @@ pub trait AstBuilder {\n                     bounds: ast::GenericBounds)\n                     -> ast::GenericParam;\n \n-    // statements\n+    // Statements\n     fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt;\n     fn stmt_semi(&self, expr: P<ast::Expr>) -> ast::Stmt;\n     fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident, ex: P<ast::Expr>) -> ast::Stmt;\n@@ -83,11 +83,11 @@ pub trait AstBuilder {\n     fn stmt_let_type_only(&self, span: Span, ty: P<ast::Ty>) -> ast::Stmt;\n     fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt;\n \n-    // blocks\n+    // Blocks\n     fn block(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Block>;\n     fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block>;\n \n-    // expressions\n+    // Expressions\n     fn expr(&self, span: Span, node: ast::ExprKind) -> P<ast::Expr>;\n     fn expr_path(&self, path: ast::Path) -> P<ast::Expr>;\n     fn expr_qpath(&self, span: Span, qself: ast::QSelf, path: ast::Path) -> P<ast::Expr>;\n@@ -194,12 +194,12 @@ pub trait AstBuilder {\n     fn lambda_stmts_1(&self, span: Span, stmts: Vec<ast::Stmt>,\n                       ident: ast::Ident) -> P<ast::Expr>;\n \n-    // items\n+    // Items\n     fn item(&self, span: Span,\n             name: Ident, attrs: Vec<ast::Attribute> , node: ast::ItemKind) -> P<ast::Item>;\n \n     fn arg(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::Arg;\n-    // FIXME unused self\n+    // FIXME: unused `self`\n     fn fn_decl(&self, inputs: Vec<ast::Arg> , output: ast::FunctionRetTy) -> P<ast::FnDecl>;\n \n     fn item_fn_poly(&self,\n@@ -302,7 +302,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 global: bool,\n                 mut idents: Vec<ast::Ident> ,\n                 args: Vec<ast::GenericArg>,\n-                bindings: Vec<ast::TypeBinding> )\n+                constraints: Vec<ast::AssocTyConstraint> )\n                 -> ast::Path {\n         assert!(!idents.is_empty());\n         let add_root = global && !idents[0].is_path_segment_keyword();\n@@ -314,8 +314,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         segments.extend(idents.into_iter().map(|ident| {\n             ast::PathSegment::from_ident(ident.with_span_pos(span))\n         }));\n-        let args = if !args.is_empty() || !bindings.is_empty() {\n-            ast::AngleBracketedArgs { args, bindings, span }.into()\n+        let args = if !args.is_empty() || !constraints.is_empty() {\n+            ast::AngleBracketedArgs { args, constraints, span }.into()\n         } else {\n             None\n         };\n@@ -346,11 +346,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                  trait_path: ast::Path,\n                  ident: ast::Ident,\n                  args: Vec<ast::GenericArg>,\n-                 bindings: Vec<ast::TypeBinding>)\n+                 constraints: Vec<ast::AssocTyConstraint>)\n                  -> (ast::QSelf, ast::Path) {\n         let mut path = trait_path;\n-        let args = if !args.is_empty() || !bindings.is_empty() {\n-            ast::AngleBracketedArgs { args, bindings, span: ident.span }.into()\n+        let args = if !args.is_empty() || !constraints.is_empty() {\n+            ast::AngleBracketedArgs { args, constraints, span: ident.span }.into()\n         } else {\n             None\n         };\n@@ -552,7 +552,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }\n     }\n \n-    // Generate `let _: Type;`, usually used for type assertions.\n+    // Generates `let _: Type;`, which is usually used for type assertions.\n     fn stmt_let_type_only(&self, span: Span, ty: P<ast::Ty>) -> ast::Stmt {\n         let local = P(ast::Local {\n             pat: self.pat_wild(span),\n@@ -606,7 +606,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr(path.span, ast::ExprKind::Path(None, path))\n     }\n \n-    /// Constructs a QPath expression.\n+    /// Constructs a `QPath` expression.\n     fn expr_qpath(&self, span: Span, qself: ast::QSelf, path: ast::Path) -> P<ast::Expr> {\n         self.expr(span, ast::ExprKind::Path(Some(qself), path))\n     }\n@@ -736,7 +736,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr(sp, ast::ExprKind::Cast(expr, ty))\n     }\n \n-\n     fn expr_some(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let some = self.std_path(&[sym::option, sym::Option, sym::Some]);\n         self.expr_call_global(sp, some, vec![expr])\n@@ -748,12 +747,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_path(none)\n     }\n \n-\n     fn expr_break(&self, sp: Span) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Break(None, None))\n     }\n \n-\n     fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Tup(exprs))\n     }\n@@ -797,22 +794,22 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let binding_pat = self.pat_ident(sp, binding_variable);\n         let binding_expr = self.expr_ident(sp, binding_variable);\n \n-        // Ok(__try_var) pattern\n+        // `Ok(__try_var)` pattern\n         let ok_pat = self.pat_tuple_struct(sp, ok_path, vec![binding_pat.clone()]);\n \n-        // Err(__try_var)  (pattern and expression resp.)\n+        // `Err(__try_var)` (pattern and expression respectively)\n         let err_pat = self.pat_tuple_struct(sp, err_path.clone(), vec![binding_pat]);\n         let err_inner_expr = self.expr_call(sp, self.expr_path(err_path),\n                                             vec![binding_expr.clone()]);\n-        // return Err(__try_var)\n+        // `return Err(__try_var)`\n         let err_expr = self.expr(sp, ast::ExprKind::Ret(Some(err_inner_expr)));\n \n-        // Ok(__try_var) => __try_var\n+        // `Ok(__try_var) => __try_var`\n         let ok_arm = self.arm(sp, vec![ok_pat], binding_expr);\n-        // Err(__try_var) => return Err(__try_var)\n+        // `Err(__try_var) => return Err(__try_var)`\n         let err_arm = self.arm(sp, vec![err_pat], err_expr);\n \n-        // match head { Ok() => ..., Err() => ... }\n+        // `match head { Ok() => ..., Err() => ... }`\n         self.expr_match(sp, head, vec![ok_arm, err_arm])\n     }\n \n@@ -972,7 +969,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }\n     }\n \n-    // FIXME unused self\n+    // FIXME: unused `self`\n     fn fn_decl(&self, inputs: Vec<ast::Arg>, output: ast::FunctionRetTy) -> P<ast::FnDecl> {\n         P(ast::FnDecl {\n             inputs,"}, {"sha": "4a95b6f69a161a7834f4908f868c155c3adc9f38", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -15,7 +15,10 @@\n use AttributeType::*;\n use AttributeGate::*;\n \n-use crate::ast::{self, NodeId, GenericParam, GenericParamKind, PatKind, RangeEnd};\n+use crate::ast::{\n+    self, AssocTyConstraint, AssocTyConstraintKind, NodeId, GenericParam, GenericParamKind,\n+    PatKind, RangeEnd,\n+};\n use crate::attr;\n use crate::early_buffered_lints::BufferedEarlyLintId;\n use crate::source_map::Spanned;\n@@ -554,6 +557,9 @@ declare_features! (\n     // Allows using C-variadics.\n     (active, c_variadic, \"1.34.0\", Some(44930), None),\n \n+    // Allows the user of associated type bounds.\n+    (active, associated_type_bounds, \"1.34.0\", Some(52662), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------\n@@ -1917,7 +1923,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             self.builtin_attributes.get(&ident.name).map(|a| *a)\n         });\n \n-        // check for gated attributes\n+        // Check for gated attributes.\n         self.context.check_attribute(attr, attr_info, false);\n \n         if attr.check_name(sym::doc) {\n@@ -2115,7 +2121,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_fn_ret_ty(&mut self, ret_ty: &'a ast::FunctionRetTy) {\n         if let ast::FunctionRetTy::Ty(ref output_ty) = *ret_ty {\n             if let ast::TyKind::Never = output_ty.node {\n-                // Do nothing\n+                // Do nothing.\n             } else {\n                 self.visit_ty(output_ty)\n             }\n@@ -2171,7 +2177,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n             _ => {}\n         }\n-        visit::walk_expr(self, e);\n+        visit::walk_expr(self, e)\n     }\n \n     fn visit_arm(&mut self, arm: &'a ast::Arm) {\n@@ -2220,15 +2226,27 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             gate_feature_post!(&self, c_variadic, span, \"C-variadic functions are unstable\");\n         }\n \n-        visit::walk_fn(self, fn_kind, fn_decl, span);\n+        visit::walk_fn(self, fn_kind, fn_decl, span)\n     }\n \n     fn visit_generic_param(&mut self, param: &'a GenericParam) {\n-        if let GenericParamKind::Const { .. } = param.kind {\n-            gate_feature_post!(&self, const_generics, param.ident.span,\n-                \"const generics are unstable\");\n+        match param.kind {\n+            GenericParamKind::Const { .. } =>\n+                gate_feature_post!(&self, const_generics, param.ident.span,\n+                    \"const generics are unstable\"),\n+            _ => {}\n+        }\n+        visit::walk_generic_param(self, param)\n+    }\n+\n+    fn visit_assoc_ty_constraint(&mut self, constraint: &'a AssocTyConstraint) {\n+        match constraint.kind {\n+            AssocTyConstraintKind::Bound { .. } =>\n+                gate_feature_post!(&self, associated_type_bounds, constraint.span,\n+                    \"associated type bounds are unstable\"),\n+            _ => {}\n         }\n-        visit::walk_generic_param(self, param);\n+        visit::walk_assoc_ty_constraint(self, constraint)\n     }\n \n     fn visit_trait_item(&mut self, ti: &'a ast::TraitItem) {\n@@ -2266,7 +2284,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n             _ => {}\n         }\n-        visit::walk_trait_item(self, ti);\n+        visit::walk_trait_item(self, ti)\n     }\n \n     fn visit_impl_item(&mut self, ii: &'a ast::ImplItem) {\n@@ -2298,15 +2316,15 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n             _ => {}\n         }\n-        visit::walk_impl_item(self, ii);\n+        visit::walk_impl_item(self, ii)\n     }\n \n     fn visit_vis(&mut self, vis: &'a ast::Visibility) {\n         if let ast::VisibilityKind::Crate(ast::CrateSugar::JustCrate) = vis.node {\n             gate_feature_post!(&self, crate_visibility_modifier, vis.span,\n                                \"`crate` visibility modifier is experimental\");\n         }\n-        visit::walk_vis(self, vis);\n+        visit::walk_vis(self, vis)\n     }\n }\n "}, {"sha": "fb1a7a680baaf532552ccbcca6790bf2bb1e0488", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -163,8 +163,8 @@ pub trait MutVisitor: Sized {\n         noop_visit_lifetime(l, self);\n     }\n \n-    fn visit_ty_binding(&mut self, t: &mut TypeBinding) {\n-        noop_visit_ty_binding(t, self);\n+    fn visit_ty_constraint(&mut self, t: &mut AssocTyConstraint) {\n+        noop_visit_ty_constraint(t, self);\n     }\n \n     fn visit_mod(&mut self, m: &mut Mod) {\n@@ -400,11 +400,20 @@ pub fn noop_visit_guard<T: MutVisitor>(g: &mut Guard, vis: &mut T) {\n     }\n }\n \n-pub fn noop_visit_ty_binding<T: MutVisitor>(TypeBinding { id, ident, ty, span }: &mut TypeBinding,\n-                                            vis: &mut T) {\n+pub fn noop_visit_ty_constraint<T: MutVisitor>(\n+    AssocTyConstraint { id, ident, kind, span }: &mut AssocTyConstraint,\n+    vis: &mut T\n+) {\n     vis.visit_id(id);\n     vis.visit_ident(ident);\n-    vis.visit_ty(ty);\n+    match kind {\n+        AssocTyConstraintKind::Equality { ref mut ty } => {\n+            vis.visit_ty(ty);\n+        }\n+        AssocTyConstraintKind::Bound { ref mut bounds } => {\n+            visit_bounds(bounds, vis);\n+        }\n+    }\n     vis.visit_span(span);\n }\n \n@@ -499,9 +508,9 @@ pub fn noop_visit_generic_arg<T: MutVisitor>(arg: &mut GenericArg, vis: &mut T)\n \n pub fn noop_visit_angle_bracketed_parameter_data<T: MutVisitor>(data: &mut AngleBracketedArgs,\n                                                                 vis: &mut T) {\n-    let AngleBracketedArgs { args, bindings, span } = data;\n+    let AngleBracketedArgs { args, constraints, span } = data;\n     visit_vec(args, |arg| vis.visit_generic_arg(arg));\n-    visit_vec(bindings, |binding| vis.visit_ty_binding(binding));\n+    visit_vec(constraints, |constraint| vis.visit_ty_constraint(constraint));\n     vis.visit_span(span);\n }\n "}, {"sha": "790013f6eb1286f6d81b51bcdd23743e990d5b15", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 60, "deletions": 50, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -27,7 +27,7 @@ use crate::ast::{VariantData, StructField};\n use crate::ast::StrStyle;\n use crate::ast::SelfKind;\n use crate::ast::{TraitItem, TraitRef, TraitObjectSyntax};\n-use crate::ast::{Ty, TyKind, TypeBinding, GenericBounds};\n+use crate::ast::{Ty, TyKind, AssocTyConstraint, AssocTyConstraintKind, GenericBounds};\n use crate::ast::{Visibility, VisibilityKind, WhereClause, CrateSugar};\n use crate::ast::{UseTree, UseTreeKind};\n use crate::ast::{BinOpKind, UnOp};\n@@ -191,24 +191,24 @@ enum PrevTokenKind {\n     Other,\n }\n \n-/* ident is handled by common.rs */\n+// NOTE: `Ident`s are handled by `common.rs`.\n \n #[derive(Clone)]\n pub struct Parser<'a> {\n     pub sess: &'a ParseSess,\n-    /// the current token:\n+    /// The current token.\n     pub token: token::Token,\n-    /// the span of the current token:\n+    /// The span of the current token.\n     pub span: Span,\n-    /// the span of the previous token:\n     meta_var_span: Option<Span>,\n+    /// The span of the previous token.\n     pub prev_span: Span,\n-    /// the previous token kind\n+    /// The kind of the previous troken.\n     prev_token_kind: PrevTokenKind,\n     restrictions: Restrictions,\n-    /// Used to determine the path to externally loaded source files\n+    /// Used to determine the path to externally loaded source files.\n     crate directory: Directory<'a>,\n-    /// Whether to parse sub-modules in other files.\n+    /// `true` to parse sub-modules in other files.\n     pub recurse_into_file_modules: bool,\n     /// Name of the root module this parser originated from. If `None`, then the\n     /// name is not known. This does not change while the parser is descending\n@@ -217,7 +217,7 @@ pub struct Parser<'a> {\n     crate expected_tokens: Vec<TokenType>,\n     crate token_cursor: TokenCursor,\n     desugar_doc_comments: bool,\n-    /// Whether we should configure out of line modules as we parse.\n+    /// `true` we should configure out of line modules as we parse.\n     pub cfg_mods: bool,\n     /// This field is used to keep track of how many left angle brackets we have seen. This is\n     /// required in order to detect extra leading left angle brackets (`<` characters) and error\n@@ -1791,11 +1791,11 @@ impl<'a> Parser<'a> {\n             let lo = self.span;\n             let args = if self.eat_lt() {\n                 // `<'a, T, A = U>`\n-                let (args, bindings) =\n+                let (args, constraints) =\n                     self.parse_generic_args_with_leaning_angle_bracket_recovery(style, lo)?;\n                 self.expect_gt()?;\n                 let span = lo.to(self.prev_span);\n-                AngleBracketedArgs { args, bindings, span }.into()\n+                AngleBracketedArgs { args, constraints, span }.into()\n             } else {\n                 // `(T, U) -> R`\n                 self.bump(); // `(`\n@@ -2680,8 +2680,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    // parse a stream of tokens into a list of TokenTree's,\n-    // up to EOF.\n+    /// Parses a stream of tokens into a list of `TokenTree`s, up to EOF.\n     pub fn parse_all_token_trees(&mut self) -> PResult<'a, Vec<TokenTree>> {\n         let mut tts = Vec::new();\n         while self.token != token::Eof {\n@@ -5077,7 +5076,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         style: PathStyle,\n         lo: Span,\n-    ) -> PResult<'a, (Vec<GenericArg>, Vec<TypeBinding>)> {\n+    ) -> PResult<'a, (Vec<GenericArg>, Vec<AssocTyConstraint>)> {\n         // We need to detect whether there are extra leading left angle brackets and produce an\n         // appropriate error and suggestion. This cannot be implemented by looking ahead at\n         // upcoming tokens for a matching `>` character - if there are unmatched `<` tokens\n@@ -5212,33 +5211,43 @@ impl<'a> Parser<'a> {\n \n     /// Parses (possibly empty) list of lifetime and type arguments and associated type bindings,\n     /// possibly including trailing comma.\n-    fn parse_generic_args(&mut self) -> PResult<'a, (Vec<GenericArg>, Vec<TypeBinding>)> {\n+    fn parse_generic_args(&mut self) -> PResult<'a, (Vec<GenericArg>, Vec<AssocTyConstraint>)> {\n         let mut args = Vec::new();\n-        let mut bindings = Vec::new();\n-        let mut misplaced_assoc_ty_bindings: Vec<Span> = Vec::new();\n-        let mut assoc_ty_bindings: Vec<Span> = Vec::new();\n+        let mut constraints = Vec::new();\n+        let mut misplaced_assoc_ty_constraints: Vec<Span> = Vec::new();\n+        let mut assoc_ty_constraints: Vec<Span> = Vec::new();\n \n         let args_lo = self.span;\n \n         loop {\n             if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n                 // Parse lifetime argument.\n                 args.push(GenericArg::Lifetime(self.expect_lifetime()));\n-                misplaced_assoc_ty_bindings.append(&mut assoc_ty_bindings);\n-            } else if self.check_ident() && self.look_ahead(1, |t| t == &token::Eq) {\n-                // Parse associated type binding.\n+                misplaced_assoc_ty_constraints.append(&mut assoc_ty_constraints);\n+            } else if self.check_ident() && self.look_ahead(1,\n+                    |t| t == &token::Eq || t == &token::Colon) {\n+                // Parse associated type constraint.\n                 let lo = self.span;\n                 let ident = self.parse_ident()?;\n-                self.bump();\n-                let ty = self.parse_ty()?;\n+                let kind = if self.eat(&token::Eq) {\n+                    AssocTyConstraintKind::Equality {\n+                        ty: self.parse_ty()?,\n+                    }\n+                } else if self.eat(&token::Colon) {\n+                    AssocTyConstraintKind::Bound {\n+                        bounds: self.parse_generic_bounds(Some(self.prev_span))?,\n+                    }\n+                } else {\n+                    unreachable!();\n+                };\n                 let span = lo.to(self.prev_span);\n-                bindings.push(TypeBinding {\n+                constraints.push(AssocTyConstraint {\n                     id: ast::DUMMY_NODE_ID,\n                     ident,\n-                    ty,\n+                    kind,\n                     span,\n                 });\n-                assoc_ty_bindings.push(span);\n+                assoc_ty_constraints.push(span);\n             } else if self.check_const_arg() {\n                 // Parse const argument.\n                 let expr = if let token::OpenDelim(token::Brace) = self.token {\n@@ -5262,11 +5271,11 @@ impl<'a> Parser<'a> {\n                     value: expr,\n                 };\n                 args.push(GenericArg::Const(value));\n-                misplaced_assoc_ty_bindings.append(&mut assoc_ty_bindings);\n+                misplaced_assoc_ty_constraints.append(&mut assoc_ty_constraints);\n             } else if self.check_type() {\n                 // Parse type argument.\n                 args.push(GenericArg::Type(self.parse_ty()?));\n-                misplaced_assoc_ty_bindings.append(&mut assoc_ty_bindings);\n+                misplaced_assoc_ty_constraints.append(&mut assoc_ty_constraints);\n             } else {\n                 break\n             }\n@@ -5279,12 +5288,12 @@ impl<'a> Parser<'a> {\n         // FIXME: we would like to report this in ast_validation instead, but we currently do not\n         // preserve ordering of generic parameters with respect to associated type binding, so we\n         // lose that information after parsing.\n-        if misplaced_assoc_ty_bindings.len() > 0 {\n+        if misplaced_assoc_ty_constraints.len() > 0 {\n             let mut err = self.struct_span_err(\n                 args_lo.to(self.prev_span),\n                 \"associated type bindings must be declared after generic parameters\",\n             );\n-            for span in misplaced_assoc_ty_bindings {\n+            for span in misplaced_assoc_ty_constraints {\n                 err.span_label(\n                     span,\n                     \"this associated type binding should be moved after the generic parameters\",\n@@ -5293,7 +5302,7 @@ impl<'a> Parser<'a> {\n             err.emit();\n         }\n \n-        Ok((args, bindings))\n+        Ok((args, constraints))\n     }\n \n     /// Parses an optional where-clause and places it in `generics`.\n@@ -5344,9 +5353,10 @@ impl<'a> Parser<'a> {\n                 // Parse optional `for<'a, 'b>`.\n                 // This `for` is parsed greedily and applies to the whole predicate,\n                 // the bounded type can have its own `for` applying only to it.\n-                // Example 1: for<'a> Trait1<'a>: Trait2<'a /*ok*/>\n-                // Example 2: (for<'a> Trait1<'a>): Trait2<'a /*not ok*/>\n-                // Example 3: for<'a> for<'b> Trait1<'a, 'b>: Trait2<'a /*ok*/, 'b /*not ok*/>\n+                // Examples:\n+                // * `for<'a> Trait1<'a>: Trait2<'a /* ok */>`\n+                // * `(for<'a> Trait1<'a>): Trait2<'a /* not ok */>`\n+                // * `for<'a> for<'b> Trait1<'a, 'b>: Trait2<'a /* ok */, 'b /* not ok */>`\n                 let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n \n                 // Parse type with mandatory colon and (possibly empty) bounds,\n@@ -5478,17 +5488,17 @@ impl<'a> Parser<'a> {\n             this.look_ahead(n + 1, |t| t != &token::ModSep)\n         };\n \n-        // Parse optional self parameter of a method.\n-        // Only a limited set of initial token sequences is considered self parameters, anything\n+        // Parse optional `self` parameter of a method.\n+        // Only a limited set of initial token sequences is considered `self` parameters; anything\n         // else is parsed as a normal function parameter list, so some lookahead is required.\n         let eself_lo = self.span;\n         let (eself, eself_ident, eself_hi) = match self.token {\n             token::BinOp(token::And) => {\n-                // &self\n-                // &mut self\n-                // &'lt self\n-                // &'lt mut self\n-                // &not_self\n+                // `&self`\n+                // `&mut self`\n+                // `&'lt self`\n+                // `&'lt mut self`\n+                // `&not_self`\n                 (if isolated_self(self, 1) {\n                     self.bump();\n                     SelfKind::Region(None, Mutability::Immutable)\n@@ -5514,10 +5524,10 @@ impl<'a> Parser<'a> {\n                 }, expect_ident(self), self.prev_span)\n             }\n             token::BinOp(token::Star) => {\n-                // *self\n-                // *const self\n-                // *mut self\n-                // *not_self\n+                // `*self`\n+                // `*const self`\n+                // `*mut self`\n+                // `*not_self`\n                 // Emit special error for `self` cases.\n                 let msg = \"cannot pass `self` by raw pointer\";\n                 (if isolated_self(self, 1) {\n@@ -5540,8 +5550,8 @@ impl<'a> Parser<'a> {\n             }\n             token::Ident(..) => {\n                 if isolated_self(self, 0) {\n-                    // self\n-                    // self: TYPE\n+                    // `self`\n+                    // `self: TYPE`\n                     let eself_ident = expect_ident(self);\n                     let eself_hi = self.prev_span;\n                     (if self.eat(&token::Colon) {\n@@ -5552,8 +5562,8 @@ impl<'a> Parser<'a> {\n                     }, eself_ident, eself_hi)\n                 } else if self.token.is_keyword(kw::Mut) &&\n                           isolated_self(self, 1) {\n-                    // mut self\n-                    // mut self: TYPE\n+                    // `mut self`\n+                    // `mut self: TYPE`\n                     self.bump();\n                     let eself_ident = expect_ident(self);\n                     let eself_hi = self.prev_span;\n@@ -5580,7 +5590,7 @@ impl<'a> Parser<'a> {\n     {\n         self.expect(&token::OpenDelim(token::Paren))?;\n \n-        // Parse optional self argument\n+        // Parse optional self argument.\n         let self_arg = self.parse_self_arg()?;\n \n         // Parse the rest of the function parameter list."}, {"sha": "57c01e9e3efea2aa8fe72497588151afce4c6214", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -1715,7 +1715,7 @@ impl<'a> State<'a> {\n         match els {\n             Some(_else) => {\n                 match _else.node {\n-                    // \"another else-if\"\n+                    // Another `else if` block.\n                     ast::ExprKind::If(ref i, ref then, ref e) => {\n                         self.cbox(INDENT_UNIT - 1)?;\n                         self.ibox(0)?;\n@@ -1725,7 +1725,7 @@ impl<'a> State<'a> {\n                         self.print_block(then)?;\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n-                    // \"another else-if-let\"\n+                    // Another `else if let` block.\n                     ast::ExprKind::IfLet(ref pats, ref expr, ref then, ref e) => {\n                         self.cbox(INDENT_UNIT - 1)?;\n                         self.ibox(0)?;\n@@ -1738,14 +1738,14 @@ impl<'a> State<'a> {\n                         self.print_block(then)?;\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n-                    // \"final else\"\n+                    // Final `else` block.\n                     ast::ExprKind::Block(ref b, _) => {\n                         self.cbox(INDENT_UNIT - 1)?;\n                         self.ibox(0)?;\n                         self.s.word(\" else \")?;\n                         self.print_block(b)\n                     }\n-                    // BLEAH, constraints would be great here\n+                    // Constraints would be great here!\n                     _ => {\n                         panic!(\"print_if saw if with weird alternative\");\n                     }\n@@ -2450,14 +2450,21 @@ impl<'a> State<'a> {\n \n                 let mut comma = data.args.len() != 0;\n \n-                for binding in data.bindings.iter() {\n+                for constraint in data.constraints.iter() {\n                     if comma {\n                         self.word_space(\",\")?\n                     }\n-                    self.print_ident(binding.ident)?;\n+                    self.print_ident(constraint.ident)?;\n                     self.s.space()?;\n-                    self.word_space(\"=\")?;\n-                    self.print_type(&binding.ty)?;\n+                    match constraint.kind {\n+                        ast::AssocTyConstraintKind::Equality { ref ty } => {\n+                            self.word_space(\"=\")?;\n+                            self.print_type(ty)?;\n+                        }\n+                        ast::AssocTyConstraintKind::Bound { ref bounds } => {\n+                            self.print_type_bounds(\":\", &*bounds)?;\n+                        }\n+                    }\n                     comma = true;\n                 }\n "}, {"sha": "d577243fb3dcd834590e1ddf511549037f0f3821", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -57,7 +57,8 @@ impl<T: 'static> P<T> {\n     {\n         f(*self.ptr)\n     }\n-    /// Equivalent to and_then(|x| x)\n+\n+    /// Equivalent to `and_then(|x| x)`.\n     pub fn into_inner(self) -> T {\n         *self.ptr\n     }"}, {"sha": "f17eb3b39432efccb2d5e87eec22f4f70033558a", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -131,9 +131,9 @@ impl<'ast> Visitor<'ast> for NodeCounter {\n         self.count += 1;\n         walk_generic_args(self, path_span, generic_args)\n     }\n-    fn visit_assoc_type_binding(&mut self, type_binding: &TypeBinding) {\n+    fn visit_assoc_ty_constraint(&mut self, constraint: &AssocTyConstraint) {\n         self.count += 1;\n-        walk_assoc_type_binding(self, type_binding)\n+        walk_assoc_ty_constraint(self, constraint)\n     }\n     fn visit_attribute(&mut self, _attr: &Attribute) {\n         self.count += 1;"}, {"sha": "334709b1521972d300eb69fa1cd6a8bfbdb78a82", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -139,8 +139,8 @@ pub trait Visitor<'ast>: Sized {\n             GenericArg::Const(ct) => self.visit_anon_const(ct),\n         }\n     }\n-    fn visit_assoc_type_binding(&mut self, type_binding: &'ast TypeBinding) {\n-        walk_assoc_type_binding(self, type_binding)\n+    fn visit_assoc_ty_constraint(&mut self, constraint: &'ast AssocTyConstraint) {\n+        walk_assoc_ty_constraint(self, constraint)\n     }\n     fn visit_attribute(&mut self, attr: &'ast Attribute) {\n         walk_attribute(self, attr)\n@@ -404,7 +404,7 @@ pub fn walk_generic_args<'a, V>(visitor: &mut V,\n     match *generic_args {\n         GenericArgs::AngleBracketed(ref data) => {\n             walk_list!(visitor, visit_generic_arg, &data.args);\n-            walk_list!(visitor, visit_assoc_type_binding, &data.bindings);\n+            walk_list!(visitor, visit_assoc_ty_constraint, &data.constraints);\n         }\n         GenericArgs::Parenthesized(ref data) => {\n             walk_list!(visitor, visit_ty, &data.inputs);\n@@ -413,10 +413,17 @@ pub fn walk_generic_args<'a, V>(visitor: &mut V,\n     }\n }\n \n-pub fn walk_assoc_type_binding<'a, V: Visitor<'a>>(visitor: &mut V,\n-                                                   type_binding: &'a TypeBinding) {\n-    visitor.visit_ident(type_binding.ident);\n-    visitor.visit_ty(&type_binding.ty);\n+pub fn walk_assoc_ty_constraint<'a, V: Visitor<'a>>(visitor: &mut V,\n+                                                    constraint: &'a AssocTyConstraint) {\n+    visitor.visit_ident(constraint.ident);\n+    match constraint.kind {\n+        AssocTyConstraintKind::Equality { ref ty } => {\n+            visitor.visit_ty(ty);\n+        }\n+        AssocTyConstraintKind::Bound { ref bounds } => {\n+            walk_list!(visitor, visit_param_bound, bounds);\n+        }\n+    }\n }\n \n pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n@@ -499,7 +506,7 @@ pub fn walk_generic_param<'a, V: Visitor<'a>>(visitor: &mut V, param: &'a Generi\n     walk_list!(visitor, visit_attribute, param.attrs.iter());\n     walk_list!(visitor, visit_param_bound, &param.bounds);\n     match param.kind {\n-        GenericParamKind::Lifetime => {}\n+        GenericParamKind::Lifetime => (),\n         GenericParamKind::Type { ref default } => walk_list!(visitor, visit_ty, default),\n         GenericParamKind::Const { ref ty, .. } => visitor.visit_ty(ty),\n     }"}, {"sha": "ffec667aba5d3ae19c820b260d854fce95a7ac8a", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -922,8 +922,7 @@ impl<'a> MethodDef<'a> {\n                      arg_types: Vec<(Ident, P<ast::Ty>)>,\n                      body: P<Expr>)\n                      -> ast::ImplItem {\n-\n-        // create the generics that aren't for Self\n+        // Create the generics that aren't for `Self`.\n         let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n \n         let args = {"}, {"sha": "de8b689396fb9bb94cd83a461b4f7df78150a512", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -245,8 +245,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         // First up, make sure we're checking a bare function. If we're not then\n         // we're just not interested in this item.\n         //\n-        // If we find one, try to locate a `#[proc_macro_derive]` attribute on\n-        // it.\n+        // If we find one, try to locate a `#[proc_macro_derive]` attribute on it.\n         let is_fn = match item.node {\n             ast::ItemKind::Fn(..) => true,\n             _ => false,\n@@ -259,15 +258,15 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n                 if let Some(prev_attr) = found_attr {\n                     let msg = if attr.path.segments[0].ident.name ==\n                                  prev_attr.path.segments[0].ident.name {\n-                        format!(\"Only one `#[{}]` attribute is allowed on any given function\",\n+                        format!(\"only one `#[{}]` attribute is allowed on any given function\",\n                                 attr.path)\n                     } else {\n                         format!(\"`#[{}]` and `#[{}]` attributes cannot both be applied \\\n                                 to the same function\", attr.path, prev_attr.path)\n                     };\n \n                     self.handler.struct_span_err(attr.span, &msg)\n-                        .span_note(prev_attr.span, \"Previous attribute here\")\n+                        .span_note(prev_attr.span, \"previous attribute here\")\n                         .emit();\n \n                     return;"}, {"sha": "b827416ab53c2523cb76352af134b79198d8a9df", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -714,7 +714,7 @@ pub enum CompilerDesugaringKind {\n     /// Desugaring of an `impl Trait` in return type position\n     /// to an `existential type Foo: Trait;` and replacing the\n     /// `impl Trait` with `Foo`.\n-    ExistentialReturnType,\n+    ExistentialType,\n     Async,\n     Await,\n     ForLoop,\n@@ -728,7 +728,7 @@ impl CompilerDesugaringKind {\n             CompilerDesugaringKind::Await => \"await\",\n             CompilerDesugaringKind::QuestionMark => \"?\",\n             CompilerDesugaringKind::TryBlock => \"try block\",\n-            CompilerDesugaringKind::ExistentialReturnType => \"existential type\",\n+            CompilerDesugaringKind::ExistentialType => \"existential type\",\n             CompilerDesugaringKind::ForLoop => \"for loop\",\n         })\n     }"}, {"sha": "4e080d115d2a8eed7860fecc2513a2cd3e48fd57", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -141,6 +141,7 @@ symbols! {\n         arm_target_feature,\n         asm,\n         associated_consts,\n+        associated_type_bounds,\n         associated_type_defaults,\n         associated_types,\n         async_await,"}, {"sha": "0caf268aa007fb691e9d21f2eab75cde8348faea", "filename": "src/test/run-make-fulldeps/libtest-json/output.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput.json", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput.json?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -2,7 +2,7 @@\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"a\" }\n { \"type\": \"test\", \"name\": \"a\", \"event\": \"ok\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"b\" }\n-{ \"type\": \"test\", \"name\": \"b\", \"event\": \"failed\", \"stdout\": \"thread 'main' panicked at 'assertion failed: false', f.rs:8:5\\nnote: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\\n\" }\n+{ \"type\": \"test\", \"name\": \"b\", \"event\": \"failed\", \"stdout\": \"thread 'main' panicked at 'assertion failed: false', f.rs:8:5\\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\\n\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"c\" }\n { \"type\": \"test\", \"name\": \"c\", \"event\": \"ok\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"d\" }"}, {"sha": "7e819e2b34e3888cdf33cc12f1aca4f89265150d", "filename": "src/test/run-pass-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -1,23 +1,21 @@\n // ignore-cross-compile\n \n-\n // The general idea of this test is to enumerate all \"interesting\" expressions and check that\n-// `parse(print(e)) == e` for all `e`.  Here's what's interesting, for the purposes of this test:\n+// `parse(print(e)) == e` for all `e`. Here's what's interesting, for the purposes of this test:\n //\n-//  1. The test focuses on expression nesting, because interactions between different expression\n-//     types are harder to test manually than single expression types in isolation.\n+// 1. The test focuses on expression nesting, because interactions between different expression\n+//    types are harder to test manually than single expression types in isolation.\n //\n-//  2. The test only considers expressions of at most two nontrivial nodes.  So it will check `x +\n-//     x` and `x + (x - x)` but not `(x * x) + (x - x)`.  The assumption here is that the correct\n-//     handling of an expression might depend on the expression's parent, but doesn't depend on its\n-//     siblings or any more distant ancestors.\n+// 2. The test only considers expressions of at most two nontrivial nodes. So it will check `x +\n+//    x` and `x + (x - x)` but not `(x * x) + (x - x)`. The assumption here is that the correct\n+//    handling of an expression might depend on the expression's parent, but doesn't depend on its\n+//    siblings or any more distant ancestors.\n //\n-// 3. The test only checks certain expression kinds.  The assumption is that similar expression\n-//    types, such as `if` and `while` or `+` and `-`,  will be handled identically in the printer\n-//    and parser.  So if all combinations of exprs involving `if` work correctly, then combinations\n+// 3. The test only checks certain expression kinds. The assumption is that similar expression\n+//    types, such as `if` and `while` or `+` and `-`, will be handled identically in the printer\n+//    and parser. So if all combinations of exprs involving `if` work correctly, then combinations\n //    using `while`, `if let`, and so on will likely work as well.\n \n-\n #![feature(rustc_private)]\n \n extern crate rustc_data_structures;\n@@ -155,9 +153,9 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n }\n \n \n-// Folders for manipulating the placement of `Paren` nodes.  See below for why this is needed.\n+// Folders for manipulating the placement of `Paren` nodes. See below for why this is needed.\n \n-/// MutVisitor that removes all `ExprKind::Paren` nodes.\n+/// `MutVisitor` that removes all `ExprKind::Paren` nodes.\n struct RemoveParens;\n \n impl MutVisitor for RemoveParens {\n@@ -171,7 +169,7 @@ impl MutVisitor for RemoveParens {\n }\n \n \n-/// MutVisitor that inserts `ExprKind::Paren` nodes around every `Expr`.\n+/// `MutVisitor` that inserts `ExprKind::Paren` nodes around every `Expr`.\n struct AddParens;\n \n impl MutVisitor for AddParens {\n@@ -205,8 +203,8 @@ fn run() {\n \n         // We want to know if `parsed` is structurally identical to `e`, ignoring trivial\n         // differences like placement of `Paren`s or the exact ranges of node spans.\n-        // Unfortunately, there is no easy way to make this comparison.  Instead, we add `Paren`s\n-        // everywhere we can, then pretty-print.  This should give an unambiguous representation of\n+        // Unfortunately, there is no easy way to make this comparison. Instead, we add `Paren`s\n+        // everywhere we can, then pretty-print. This should give an unambiguous representation of\n         // each `Expr`, and it bypasses nearly all of the parenthesization logic, so we aren't\n         // relying on the correctness of the very thing we're testing.\n         RemoveParens.visit_expr(&mut e);"}, {"sha": "b161e68abafd0e2e4b638e4609dbda1e44b582cf", "filename": "src/test/run-pass/issues/issue-25700-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Frun-pass%2Fissues%2Fissue-25700-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Frun-pass%2Fissues%2Fissue-25700-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-25700-2.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -18,5 +18,5 @@ fn record_type<Id: AstId>(i: Id::Untyped) -> u8 {\n }\n \n pub fn main() {\n-   assert_eq!(record_type::<u32>(3), 42);\n+    assert_eq!(record_type::<u32>(3), 42);\n }"}, {"sha": "8bc00020652714ac9c4535cfdb5fed2c854078bc", "filename": "src/test/run-pass/multi-panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Frun-pass%2Fmulti-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Frun-pass%2Fmulti-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmulti-panic.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -8,7 +8,7 @@ fn check_for_no_backtrace(test: std::process::Output) {\n     let mut it = err.lines();\n \n     assert_eq!(it.next().map(|l| l.starts_with(\"thread '<unnamed>' panicked at\")), Some(true));\n-    assert_eq!(it.next(), Some(\"note: Run with `RUST_BACKTRACE=1` \\\n+    assert_eq!(it.next(), Some(\"note: run with `RUST_BACKTRACE=1` \\\n                                 environment variable to display a backtrace.\"));\n     assert_eq!(it.next().map(|l| l.starts_with(\"thread 'main' panicked at\")), Some(true));\n     assert_eq!(it.next(), None);"}, {"sha": "39d25eb7fe05bace42367cca5e72504f30e5f680", "filename": "src/test/run-pass/traits/trait-object-auto-dedup.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-object-auto-dedup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-object-auto-dedup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-object-auto-dedup.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -1,14 +1,15 @@\n // run-pass\n+\n #![allow(unused_assignments)]\n+\n // Test that duplicate auto trait bounds in trait objects don't create new types.\n #[allow(unused_assignments)]\n-\n use std::marker::Send as SendAlias;\n \n // A dummy trait for the non-auto trait.\n trait Trait {}\n \n-// A dummy struct to implement Trait, Send, and .\n+// A dummy struct to implement `Trait` and `Send`.\n struct Struct;\n \n impl Trait for Struct {}\n@@ -23,12 +24,12 @@ impl dyn Trait + Send + Send {\n }\n \n fn main() {\n-    // 1. Moving into a variable with more Sends and back.\n+    // 1. Moving into a variable with more `Send`s and back.\n     let mut dyn_trait_send = Box::new(Struct) as Box<dyn Trait + Send>;\n     let dyn_trait_send_send: Box<dyn Trait + Send + Send> = dyn_trait_send;\n     dyn_trait_send = dyn_trait_send_send;\n \n-    // 2. Calling methods with different number of Sends.\n+    // 2. Calling methods with different number of `Send`s.\n     let dyn_trait_send = Box::new(Struct) as Box<dyn Trait + Send>;\n     takes_dyn_trait_send_send(dyn_trait_send);\n "}, {"sha": "e362ecf349e459fb2ed40181613dd29c5328f3f3", "filename": "src/test/rustdoc-ui/failed-doctest-output.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -27,7 +27,7 @@ stderr:\n stderr 1\n stderr 2\n thread 'main' panicked at 'oh no', $DIR/failed-doctest-output.rs:7:1\n-note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n+note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n \n "}, {"sha": "0ea23ad1dbffa7ed4903aabb680dca2c0d9f5008", "filename": "src/test/ui/associated-type-bounds/auxiliary/fn-aux.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fauxiliary%2Ffn-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fauxiliary%2Ffn-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fauxiliary%2Ffn-aux.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,177 @@\n+// Traits:\n+\n+pub trait Alpha {\n+    fn alpha(self) -> usize;\n+}\n+\n+pub trait Beta {\n+    type Gamma;\n+    fn gamma(self) -> Self::Gamma;\n+}\n+\n+pub trait Delta {\n+    fn delta(self) -> usize;\n+}\n+\n+pub trait Epsilon<'a> {\n+    type Zeta;\n+    fn zeta(&'a self) -> Self::Zeta;\n+\n+    fn epsilon(&'a self) -> usize;\n+}\n+\n+pub trait Eta {\n+    fn eta(self) -> usize;\n+}\n+\n+// Assertions:\n+\n+pub fn assert_alpha<T: Alpha>(x: T) -> usize { x.alpha() }\n+pub fn assert_static<T: 'static>(_: T) -> usize { 24 }\n+pub fn assert_delta<T: Delta>(x: T) -> usize { x.delta() }\n+pub fn assert_epsilon_specific<'a, T: 'a + Epsilon<'a>>(x: &'a T) -> usize { x.epsilon() }\n+pub fn assert_epsilon_forall<T: for<'a> Epsilon<'a>>() {}\n+pub fn assert_forall_epsilon_zeta_satisfies_eta<T>(x: T) -> usize\n+where\n+    T: for<'a> Epsilon<'a>,\n+    for<'a> <T as Epsilon<'a>>::Zeta: Eta,\n+{\n+    x.epsilon() + x.zeta().eta()\n+}\n+\n+// Implementations and types:\n+\n+#[derive(Copy, Clone)]\n+pub struct BetaType;\n+\n+#[derive(Copy, Clone)]\n+pub struct GammaType;\n+\n+#[derive(Copy, Clone)]\n+pub struct ZetaType;\n+\n+impl Beta for BetaType {\n+    type Gamma = GammaType;\n+    fn gamma(self) -> Self::Gamma { GammaType }\n+}\n+\n+impl<'a> Beta for &'a BetaType {\n+    type Gamma = GammaType;\n+    fn gamma(self) -> Self::Gamma { GammaType }\n+}\n+\n+impl Beta for GammaType {\n+    type Gamma = Self;\n+    fn gamma(self) -> Self::Gamma { self }\n+}\n+\n+impl Alpha for GammaType {\n+    fn alpha(self) -> usize { 42 }\n+}\n+\n+impl Delta for GammaType {\n+    fn delta(self) -> usize { 1337 }\n+}\n+\n+impl<'a> Epsilon<'a> for GammaType {\n+    type Zeta = ZetaType;\n+    fn zeta(&'a self) -> Self::Zeta { ZetaType }\n+\n+    fn epsilon(&'a self) -> usize { 7331 }\n+}\n+\n+impl Eta for ZetaType {\n+    fn eta(self) -> usize { 7 }\n+}\n+\n+// Desugared forms to check against:\n+\n+pub fn desugared_bound<B>(beta: B) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: Alpha\n+{\n+    let gamma: B::Gamma = beta.gamma();\n+    assert_alpha::<B::Gamma>(gamma)\n+}\n+\n+pub fn desugared_bound_region<B>(beta: B) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: 'static,\n+{\n+    assert_static::<B::Gamma>(beta.gamma())\n+}\n+\n+pub fn desugared_bound_multi<B>(beta: B) -> usize\n+where\n+    B: Copy + Beta,\n+    B::Gamma: Alpha + 'static + Delta,\n+{\n+    assert_alpha::<B::Gamma>(beta.gamma()) +\n+    assert_static::<B::Gamma>(beta.gamma()) +\n+    assert_delta::<B::Gamma>(beta.gamma())\n+}\n+\n+pub fn desugared_bound_region_specific<'a, B>(gamma: &'a B::Gamma) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: 'a + Epsilon<'a>,\n+{\n+    assert_epsilon_specific::<B::Gamma>(gamma)\n+}\n+\n+pub fn desugared_bound_region_forall<B>(beta: B) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: Copy + for<'a> Epsilon<'a>,\n+{\n+    assert_epsilon_forall::<B::Gamma>();\n+    let g1: B::Gamma = beta.gamma();\n+    let g2: B::Gamma = g1;\n+    assert_epsilon_specific::<B::Gamma>(&g1) +\n+    assert_epsilon_specific::<B::Gamma>(&g2)\n+}\n+\n+pub fn desugared_bound_region_forall2<B>(beta: B) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: Copy + for<'a> Epsilon<'a>,\n+    for<'a> <B::Gamma as Epsilon<'a>>::Zeta: Eta,\n+{\n+    let gamma = beta.gamma();\n+    assert_forall_epsilon_zeta_satisfies_eta::<B::Gamma>(gamma)\n+}\n+\n+pub fn desugared_contraint_region_forall<B>(beta: B) -> usize\n+where\n+    for<'a> &'a B: Beta,\n+    for<'a> <&'a B as Beta>::Gamma: Alpha,\n+{\n+    let g1 = beta.gamma();\n+    let g2 = beta.gamma();\n+    assert_alpha(g1) + assert_alpha(g2)\n+}\n+\n+pub fn desugared_bound_nested<B>(beta: B) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: Copy + Alpha + Beta,\n+    <B::Gamma as Beta>::Gamma: Delta,\n+{\n+    let go = beta.gamma();\n+    let gi = go.gamma();\n+    go.alpha() + gi.delta()\n+}\n+\n+pub fn desugared() {\n+    let beta = BetaType;\n+    let gamma = beta.gamma();\n+\n+    assert_eq!(42, desugared_bound(beta));\n+    assert_eq!(24, desugared_bound_region(beta));\n+    assert_eq!(42 + 24 + 1337, desugared_bound_multi(beta));\n+    assert_eq!(7331, desugared_bound_region_specific::<BetaType>(&gamma));\n+    assert_eq!(7331 * 2, desugared_bound_region_forall(beta));\n+    assert_eq!(42 + 1337, desugared_bound_nested(beta));\n+}"}, {"sha": "85d6c5aaf3c6f53bfb36289a7f6b7e5696815aef", "filename": "src/test/ui/associated-type-bounds/auxiliary/fn-dyn-aux.rs", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fauxiliary%2Ffn-dyn-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fauxiliary%2Ffn-dyn-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fauxiliary%2Ffn-dyn-aux.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,182 @@\n+// Traits:\n+\n+pub trait Alpha {\n+    fn alpha(self) -> usize;\n+}\n+\n+pub trait Beta {\n+    type Gamma;\n+    fn gamma(&self) -> Self::Gamma;\n+}\n+\n+pub trait Delta {\n+    fn delta(self) -> usize;\n+}\n+\n+pub trait Epsilon<'a> {\n+    type Zeta;\n+    fn zeta(&'a self) -> Self::Zeta;\n+\n+    fn epsilon(&'a self) -> usize;\n+}\n+\n+pub trait Eta {\n+    fn eta(self) -> usize;\n+}\n+\n+// Assertions:\n+\n+pub fn assert_alpha<T: Alpha>(x: T) -> usize { x.alpha() }\n+pub fn assert_static<T: 'static>(_: T) -> usize { 24 }\n+pub fn assert_delta<T: Delta>(x: T) -> usize { x.delta() }\n+pub fn assert_epsilon_specific<'a, T: 'a + Epsilon<'a>>(x: &'a T) -> usize { x.epsilon() }\n+pub fn assert_epsilon_forall<T: for<'a> Epsilon<'a>>() {}\n+pub fn assert_forall_epsilon_zeta_satisfies_eta<T>(x: T) -> usize\n+where\n+    T: for<'a> Epsilon<'a>,\n+    for<'a> <T as Epsilon<'a>>::Zeta: Eta,\n+{\n+    x.epsilon() + x.zeta().eta()\n+}\n+\n+// Implementations and types:\n+\n+#[derive(Copy, Clone)]\n+pub struct BetaType;\n+\n+#[derive(Copy, Clone)]\n+pub struct GammaType;\n+\n+#[derive(Copy, Clone)]\n+pub struct ZetaType;\n+\n+impl<T> Beta for &(dyn Beta<Gamma = T> + Send) {\n+    type Gamma = T;\n+    fn gamma(&self) -> Self::Gamma { (*self).gamma() }\n+}\n+\n+impl Beta for BetaType {\n+    type Gamma = GammaType;\n+    fn gamma(&self) -> Self::Gamma { GammaType }\n+}\n+\n+impl<'a> Beta for &'a BetaType {\n+    type Gamma = GammaType;\n+    fn gamma(&self) -> Self::Gamma { GammaType }\n+}\n+\n+impl Beta for GammaType {\n+    type Gamma = Self;\n+    fn gamma(&self) -> Self::Gamma { Self }\n+}\n+\n+impl Alpha for GammaType {\n+    fn alpha(self) -> usize { 42 }\n+}\n+\n+impl Delta for GammaType {\n+    fn delta(self) -> usize { 1337 }\n+}\n+\n+impl<'a> Epsilon<'a> for GammaType {\n+    type Zeta = ZetaType;\n+    fn zeta(&'a self) -> Self::Zeta { ZetaType }\n+\n+    fn epsilon(&'a self) -> usize { 7331 }\n+}\n+\n+impl Eta for ZetaType {\n+    fn eta(self) -> usize { 7 }\n+}\n+\n+// Desugared forms to check against:\n+\n+pub fn desugared_bound<B: ?Sized>(beta: &B) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: Alpha\n+{\n+    let gamma: B::Gamma = beta.gamma();\n+    assert_alpha::<B::Gamma>(gamma)\n+}\n+\n+pub fn desugared_bound_region<B: ?Sized>(beta: &B) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: 'static,\n+{\n+    assert_static::<B::Gamma>(beta.gamma())\n+}\n+\n+pub fn desugared_bound_multi<B: ?Sized>(beta: B) -> usize\n+where\n+    B: Copy + Beta,\n+    B::Gamma: Alpha + 'static + Delta,\n+{\n+    assert_alpha::<B::Gamma>(beta.gamma()) +\n+    assert_static::<B::Gamma>(beta.gamma()) +\n+    assert_delta::<B::Gamma>(beta.gamma())\n+}\n+\n+pub fn desugared_bound_region_specific<'a, B: ?Sized>(gamma: &'a B::Gamma) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: 'a + Epsilon<'a>,\n+{\n+    assert_epsilon_specific::<B::Gamma>(gamma)\n+}\n+\n+pub fn desugared_bound_region_forall<B: ?Sized>(beta: &B) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: Copy + for<'a> Epsilon<'a>,\n+{\n+    assert_epsilon_forall::<B::Gamma>();\n+    let g1: B::Gamma = beta.gamma();\n+    let g2: B::Gamma = g1;\n+    assert_epsilon_specific::<B::Gamma>(&g1) +\n+    assert_epsilon_specific::<B::Gamma>(&g2)\n+}\n+\n+pub fn desugared_bound_region_forall2<B: ?Sized>(beta: &B) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: Copy + for<'a> Epsilon<'a>,\n+    for<'a> <B::Gamma as Epsilon<'a>>::Zeta: Eta,\n+{\n+    let gamma = beta.gamma();\n+    assert_forall_epsilon_zeta_satisfies_eta::<B::Gamma>(gamma)\n+}\n+\n+pub fn desugared_contraint_region_forall<B: ?Sized>(beta: &B) -> usize\n+where\n+    for<'a> &'a B: Beta,\n+    for<'a> <&'a B as Beta>::Gamma: Alpha,\n+{\n+    let g1 = beta.gamma();\n+    let g2 = beta.gamma();\n+    assert_alpha(g1) + assert_alpha(g2)\n+}\n+\n+pub fn desugared_bound_nested<B: ?Sized>(beta: &B) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: Copy + Alpha + Beta,\n+    <B::Gamma as Beta>::Gamma: Delta,\n+{\n+    let go = beta.gamma();\n+    let gi = go.gamma();\n+    go.alpha() + gi.delta()\n+}\n+\n+pub fn desugared() {\n+    let beta = BetaType;\n+    let gamma = beta.gamma();\n+\n+    assert_eq!(42, desugared_bound(&beta));\n+    assert_eq!(24, desugared_bound_region(&beta));\n+    assert_eq!(42 + 24 + 1337, desugared_bound_multi(beta));\n+    assert_eq!(7331, desugared_bound_region_specific::<BetaType>(&gamma));\n+    assert_eq!(7331 * 2, desugared_bound_region_forall(&beta));\n+    assert_eq!(42 + 1337, desugared_bound_nested(&beta));\n+}"}, {"sha": "78704a9b512396b3e81de0c5ca67845addb3425b", "filename": "src/test/ui/associated-type-bounds/bad-bounds-on-assoc-in-trait.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,60 @@\n+// compile-fail\n+// ignore-tidy-linelength\n+\n+// NOTE: rustc cannot currently handle bounds of the form `for<'a> <Foo as Bar<'a>>::Assoc: Baz`.\n+// This should hopefully be fixed with Chalk.\n+\n+#![feature(associated_type_bounds)]\n+\n+use std::fmt::Debug;\n+use std::iter::Once;\n+\n+trait Lam<Binder> { type App; }\n+\n+#[derive(Clone)]\n+struct L1;\n+impl<'a> Lam<&'a u8> for L1 { type App = u8; }\n+\n+#[derive(Clone)]\n+struct L2;\n+impl<'a, 'b> Lam<&'a &'b u8> for L2 { type App = u8; }\n+\n+trait Case1 {\n+    type C: Clone + Iterator<Item:\n+        Send + Iterator<Item:\n+            for<'a> Lam<&'a u8, App:\n+                Debug\n+            >\n+        > + Sync>;\n+}\n+\n+pub struct S1;\n+impl Case1 for S1 {\n+//~^ ERROR `<L1 as Lam<&'a u8>>::App` doesn't implement `std::fmt::Debug` [E0277]\n+    type C = Once<Once<L1>>;\n+}\n+\n+fn assume_case1<T: Case1>() {\n+//~^ ERROR `<_ as Lam<&'a u8>>::App` doesn't implement `std::fmt::Debug` [E0277]\n+//~| ERROR `<<T as Case1>::C as std::iter::Iterator>::Item` is not an iterator [E0277]\n+//~| ERROR `<<T as Case1>::C as std::iter::Iterator>::Item` cannot be sent between threads safely [E0277]\n+//~| ERROR `<<T as Case1>::C as std::iter::Iterator>::Item` cannot be shared between threads safely [E0277]\n+    fn assert_a<_0, A>() where A: Iterator<Item = _0>, _0: Debug {}\n+    assert_a::<_, T::A>();\n+\n+    fn assert_b<_0, B>() where B: Iterator<Item = _0>, _0: 'static {}\n+    assert_b::<_, T::B>();\n+\n+    fn assert_c<_0, _1, _2, C>()\n+    where\n+        C: Clone + Iterator<Item = _2>,\n+        _2: Send + Iterator<Item = _1>,\n+        _1: for<'a> Lam<&'a u8, App = _0>,\n+        _0: Debug,\n+    {}\n+    assert_c::<_, _, _, T::C>();\n+}\n+\n+fn main() {\n+    assume_case1(S1);\n+}"}, {"sha": "aebf29cc332ab3e85957dbe16c83f3367ccd886f", "filename": "src/test/ui/associated-type-bounds/bad-bounds-on-assoc-in-trait.stderr", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,85 @@\n+error[E0277]: `<L1 as Lam<&'a u8>>::App` doesn't implement `std::fmt::Debug`\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:32:6\n+   |\n+LL | impl Case1 for S1 {\n+   |      ^^^^^ `<L1 as Lam<&'a u8>>::App` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+   |\n+   = help: the trait `for<'a> std::fmt::Debug` is not implemented for `<L1 as Lam<&'a u8>>::App`\n+\n+error[E0277]: `<<T as Case1>::C as std::iter::Iterator>::Item` is not an iterator\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:37:1\n+   |\n+LL | / fn assume_case1<T: Case1>() {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     assert_c::<_, _, _, T::C>();\n+LL | | }\n+   | |_^ `<<T as Case1>::C as std::iter::Iterator>::Item` is not an iterator\n+   |\n+   = help: the trait `std::iter::Iterator` is not implemented for `<<T as Case1>::C as std::iter::Iterator>::Item`\n+   = help: consider adding a `where <<T as Case1>::C as std::iter::Iterator>::Item: std::iter::Iterator` bound\n+\n+error[E0277]: `<<T as Case1>::C as std::iter::Iterator>::Item` cannot be sent between threads safely\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:37:1\n+   |\n+LL | / fn assume_case1<T: Case1>() {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     assert_c::<_, _, _, T::C>();\n+LL | | }\n+   | |_^ `<<T as Case1>::C as std::iter::Iterator>::Item` cannot be sent between threads safely\n+   |\n+   = help: the trait `std::marker::Send` is not implemented for `<<T as Case1>::C as std::iter::Iterator>::Item`\n+   = help: consider adding a `where <<T as Case1>::C as std::iter::Iterator>::Item: std::marker::Send` bound\n+note: required by `Case1`\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:22:1\n+   |\n+LL | trait Case1 {\n+   | ^^^^^^^^^^^\n+\n+error[E0277]: `<<T as Case1>::C as std::iter::Iterator>::Item` cannot be shared between threads safely\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:37:1\n+   |\n+LL | / fn assume_case1<T: Case1>() {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     assert_c::<_, _, _, T::C>();\n+LL | | }\n+   | |_^ `<<T as Case1>::C as std::iter::Iterator>::Item` cannot be shared between threads safely\n+   |\n+   = help: the trait `std::marker::Sync` is not implemented for `<<T as Case1>::C as std::iter::Iterator>::Item`\n+   = help: consider adding a `where <<T as Case1>::C as std::iter::Iterator>::Item: std::marker::Sync` bound\n+note: required by `Case1`\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:22:1\n+   |\n+LL | trait Case1 {\n+   | ^^^^^^^^^^^\n+\n+error[E0277]: `<_ as Lam<&'a u8>>::App` doesn't implement `std::fmt::Debug`\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:37:1\n+   |\n+LL | / fn assume_case1<T: Case1>() {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     assert_c::<_, _, _, T::C>();\n+LL | | }\n+   | |_^ `<_ as Lam<&'a u8>>::App` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+   |\n+   = help: the trait `for<'a> std::fmt::Debug` is not implemented for `<_ as Lam<&'a u8>>::App`\n+note: required by `Case1`\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:22:1\n+   |\n+LL | trait Case1 {\n+   | ^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "8c9110d03ec16417389387f4ae26dfa71298f928", "filename": "src/test/ui/associated-type-bounds/bounds-on-assoc-in-trait.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbounds-on-assoc-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbounds-on-assoc-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbounds-on-assoc-in-trait.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,51 @@\n+// run-pass\n+\n+#![feature(associated_type_bounds)]\n+\n+use std::fmt::Debug;\n+use std::iter::Empty;\n+use std::ops::Range;\n+\n+trait Lam<Binder> { type App; }\n+\n+#[derive(Clone)]\n+struct L1;\n+impl<'a> Lam<&'a u8> for L1 { type App = u8; }\n+\n+#[derive(Clone)]\n+struct L2;\n+impl<'a, 'b> Lam<&'a &'b u8> for L2 { type App = u8; }\n+\n+trait Case1 {\n+    type A: Iterator<Item: Debug>;\n+\n+    type B: Iterator<Item: 'static>;\n+}\n+\n+pub struct S1;\n+impl Case1 for S1 {\n+    type A = Empty<String>;\n+    type B = Range<u16>;\n+}\n+\n+// Ensure we don't have existential desugaring:\n+\n+pub trait Foo { type Out: Baz<Assoc: Default>; }\n+pub trait Baz { type Assoc; }\n+\n+#[derive(Default)]\n+struct S2;\n+#[derive(Default)]\n+struct S3;\n+struct S4;\n+struct S5;\n+struct S6;\n+struct S7;\n+\n+impl Foo for S6 { type Out = S4; }\n+impl Foo for S7 { type Out = S5; }\n+\n+impl Baz for S4 { type Assoc = S2; }\n+impl Baz for S5 { type Assoc = S3; }\n+\n+fn main() {}"}, {"sha": "bee56d6f689903ae6db4a3a69b111077d6d8a5fe", "filename": "src/test/ui/associated-type-bounds/duplicate.rs", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,161 @@\n+// compile-fail\n+// ignore-tidy-linelength\n+// error-pattern:could not find defining uses\n+\n+#![feature(associated_type_bounds)]\n+#![feature(existential_type)]\n+#![feature(impl_trait_in_bindings)]\n+#![feature(untagged_unions)]\n+\n+use std::iter;\n+\n+struct SI1<T: Iterator<Item: Copy, Item: Send>> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+struct SI2<T: Iterator<Item: Copy, Item: Copy>> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+struct SI3<T: Iterator<Item: 'static, Item: 'static>> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+struct SW1<T> where T: Iterator<Item: Copy, Item: Send> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+struct SW2<T> where T: Iterator<Item: Copy, Item: Copy> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+struct SW3<T> where T: Iterator<Item: 'static, Item: 'static> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+\n+enum EI1<T: Iterator<Item: Copy, Item: Send>> { V(T) }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+enum EI2<T: Iterator<Item: Copy, Item: Copy>> { V(T) }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+enum EI3<T: Iterator<Item: 'static, Item: 'static>> { V(T) }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+enum EW1<T> where T: Iterator<Item: Copy, Item: Send> { V(T) }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+enum EW2<T> where T: Iterator<Item: Copy, Item: Copy> { V(T) }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+enum EW3<T> where T: Iterator<Item: 'static, Item: 'static> { V(T) }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+\n+union UI1<T: Iterator<Item: Copy, Item: Send>> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+union UI2<T: Iterator<Item: Copy, Item: Copy>> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+union UI3<T: Iterator<Item: 'static, Item: 'static>> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+union UW1<T> where T: Iterator<Item: Copy, Item: Send> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+union UW2<T> where T: Iterator<Item: Copy, Item: Copy> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+union UW3<T> where T: Iterator<Item: 'static, Item: 'static> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+\n+fn FI1<T: Iterator<Item: Copy, Item: Send>>() {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn FI2<T: Iterator<Item: Copy, Item: Copy>>() {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn FI3<T: Iterator<Item: 'static, Item: 'static>>() {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn FW1<T>() where T: Iterator<Item: Copy, Item: Send> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn FW2<T>() where T: Iterator<Item: Copy, Item: Copy> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn FW3<T>() where T: Iterator<Item: 'static, Item: 'static> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+\n+fn FRPIT1() -> impl Iterator<Item: Copy, Item: Send> { iter::empty() }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn FRPIT2() -> impl Iterator<Item: Copy, Item: Copy> { iter::empty() }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn FRPIT3() -> impl Iterator<Item: 'static, Item: 'static> { iter::empty() }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn FAPIT1(_: impl Iterator<Item: Copy, Item: Send>) {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn FAPIT2(_: impl Iterator<Item: Copy, Item: Copy>) {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn FAPIT3(_: impl Iterator<Item: 'static, Item: 'static>) {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+\n+const CIT1: impl Iterator<Item: Copy, Item: Send> = iter::empty();\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+const CIT2: impl Iterator<Item: Copy, Item: Copy> = iter::empty();\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+const CIT3: impl Iterator<Item: 'static, Item: 'static> = iter::empty();\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+static SIT1: impl Iterator<Item: Copy, Item: Send> = iter::empty();\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+static SIT2: impl Iterator<Item: Copy, Item: Copy> = iter::empty();\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+static SIT3: impl Iterator<Item: 'static, Item: 'static> = iter::empty();\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+\n+fn lit1() { let _: impl Iterator<Item: Copy, Item: Send> = iter::empty(); }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn lit2() { let _: impl Iterator<Item: Copy, Item: Copy> = iter::empty(); }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn lit3() { let _: impl Iterator<Item: 'static, Item: 'static> = iter::empty(); }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+\n+type TAI1<T: Iterator<Item: Copy, Item: Send>> = T;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+type TAI2<T: Iterator<Item: Copy, Item: Copy>> = T;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+type TAI3<T: Iterator<Item: 'static, Item: 'static>> = T;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+type TAW1<T> where T: Iterator<Item: Copy, Item: Send> = T;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+type TAW2<T> where T: Iterator<Item: Copy, Item: Copy> = T;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+type TAW3<T> where T: Iterator<Item: 'static, Item: 'static> = T;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+\n+existential type ETAI1<T: Iterator<Item: Copy, Item: Send>>: Copy;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+existential type ETAI2<T: Iterator<Item: Copy, Item: Copy>>: Copy;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+existential type ETAI3<T: Iterator<Item: 'static, Item: 'static>>: Copy;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+existential type ETAI4: Iterator<Item: Copy, Item: Send>;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+existential type ETAI5: Iterator<Item: Copy, Item: Copy>;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+existential type ETAI6: Iterator<Item: 'static, Item: 'static>;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+\n+trait TRI1<T: Iterator<Item: Copy, Item: Send>> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRI2<T: Iterator<Item: Copy, Item: Copy>> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRI3<T: Iterator<Item: 'static, Item: 'static>> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRS1: Iterator<Item: Copy, Item: Send> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRS2: Iterator<Item: Copy, Item: Copy> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRS3: Iterator<Item: 'static, Item: 'static> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRW1<T> where T: Iterator<Item: Copy, Item: Send> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRW2<T> where T: Iterator<Item: Copy, Item: Copy> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRW3<T> where T: Iterator<Item: 'static, Item: 'static> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRSW1 where Self: Iterator<Item: Copy, Item: Send> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRSW2 where Self: Iterator<Item: Copy, Item: Copy> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRSW3 where Self: Iterator<Item: 'static, Item: 'static> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRA1 { type A: Iterator<Item: Copy, Item: Send>; }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRA2 { type A: Iterator<Item: Copy, Item: Copy>; }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRA3 { type A: Iterator<Item: 'static, Item: 'static>; }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+\n+type TADyn1 = dyn Iterator<Item: Copy, Item: Send>;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+type TADyn2 = Box<dyn Iterator<Item: Copy, Item: Copy>>;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+type TADyn3 = dyn Iterator<Item: 'static, Item: 'static>;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+\n+fn main() {}"}, {"sha": "68367c916546c8fa038e6d3f0ad948eba7806968", "filename": "src/test/ui/associated-type-bounds/duplicate.stderr", "status": "added", "additions": 632, "deletions": 0, "changes": 632, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,632 @@\n+warning: the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash\n+  --> $DIR/duplicate.rs:7:12\n+   |\n+LL | #![feature(impl_trait_in_bindings)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:12:36\n+   |\n+LL | struct SI1<T: Iterator<Item: Copy, Item: Send>> { f: T }\n+   |                        ----------  ^^^^^^^^^^ re-bound here\n+   |                        |\n+   |                        `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:14:36\n+   |\n+LL | struct SI2<T: Iterator<Item: Copy, Item: Copy>> { f: T }\n+   |                        ----------  ^^^^^^^^^^ re-bound here\n+   |                        |\n+   |                        `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:16:39\n+   |\n+LL | struct SI3<T: Iterator<Item: 'static, Item: 'static>> { f: T }\n+   |                        -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                        |\n+   |                        `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:18:45\n+   |\n+LL | struct SW1<T> where T: Iterator<Item: Copy, Item: Send> { f: T }\n+   |                                 ----------  ^^^^^^^^^^ re-bound here\n+   |                                 |\n+   |                                 `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:20:45\n+   |\n+LL | struct SW2<T> where T: Iterator<Item: Copy, Item: Copy> { f: T }\n+   |                                 ----------  ^^^^^^^^^^ re-bound here\n+   |                                 |\n+   |                                 `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:22:48\n+   |\n+LL | struct SW3<T> where T: Iterator<Item: 'static, Item: 'static> { f: T }\n+   |                                 -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                                 |\n+   |                                 `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:25:34\n+   |\n+LL | enum EI1<T: Iterator<Item: Copy, Item: Send>> { V(T) }\n+   |                      ----------  ^^^^^^^^^^ re-bound here\n+   |                      |\n+   |                      `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:27:34\n+   |\n+LL | enum EI2<T: Iterator<Item: Copy, Item: Copy>> { V(T) }\n+   |                      ----------  ^^^^^^^^^^ re-bound here\n+   |                      |\n+   |                      `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:29:37\n+   |\n+LL | enum EI3<T: Iterator<Item: 'static, Item: 'static>> { V(T) }\n+   |                      -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                      |\n+   |                      `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:31:43\n+   |\n+LL | enum EW1<T> where T: Iterator<Item: Copy, Item: Send> { V(T) }\n+   |                               ----------  ^^^^^^^^^^ re-bound here\n+   |                               |\n+   |                               `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:33:43\n+   |\n+LL | enum EW2<T> where T: Iterator<Item: Copy, Item: Copy> { V(T) }\n+   |                               ----------  ^^^^^^^^^^ re-bound here\n+   |                               |\n+   |                               `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:35:46\n+   |\n+LL | enum EW3<T> where T: Iterator<Item: 'static, Item: 'static> { V(T) }\n+   |                               -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                               |\n+   |                               `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:38:35\n+   |\n+LL | union UI1<T: Iterator<Item: Copy, Item: Send>> { f: T }\n+   |                       ----------  ^^^^^^^^^^ re-bound here\n+   |                       |\n+   |                       `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:40:35\n+   |\n+LL | union UI2<T: Iterator<Item: Copy, Item: Copy>> { f: T }\n+   |                       ----------  ^^^^^^^^^^ re-bound here\n+   |                       |\n+   |                       `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:42:38\n+   |\n+LL | union UI3<T: Iterator<Item: 'static, Item: 'static>> { f: T }\n+   |                       -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                       |\n+   |                       `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:44:44\n+   |\n+LL | union UW1<T> where T: Iterator<Item: Copy, Item: Send> { f: T }\n+   |                                ----------  ^^^^^^^^^^ re-bound here\n+   |                                |\n+   |                                `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:46:44\n+   |\n+LL | union UW2<T> where T: Iterator<Item: Copy, Item: Copy> { f: T }\n+   |                                ----------  ^^^^^^^^^^ re-bound here\n+   |                                |\n+   |                                `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:48:47\n+   |\n+LL | union UW3<T> where T: Iterator<Item: 'static, Item: 'static> { f: T }\n+   |                                -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                                |\n+   |                                `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:51:32\n+   |\n+LL | fn FI1<T: Iterator<Item: Copy, Item: Send>>() {}\n+   |                    ----------  ^^^^^^^^^^ re-bound here\n+   |                    |\n+   |                    `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:53:32\n+   |\n+LL | fn FI2<T: Iterator<Item: Copy, Item: Copy>>() {}\n+   |                    ----------  ^^^^^^^^^^ re-bound here\n+   |                    |\n+   |                    `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:55:35\n+   |\n+LL | fn FI3<T: Iterator<Item: 'static, Item: 'static>>() {}\n+   |                    -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                    |\n+   |                    `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:57:43\n+   |\n+LL | fn FW1<T>() where T: Iterator<Item: Copy, Item: Send> {}\n+   |                               ----------  ^^^^^^^^^^ re-bound here\n+   |                               |\n+   |                               `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:59:43\n+   |\n+LL | fn FW2<T>() where T: Iterator<Item: Copy, Item: Copy> {}\n+   |                               ----------  ^^^^^^^^^^ re-bound here\n+   |                               |\n+   |                               `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:61:46\n+   |\n+LL | fn FW3<T>() where T: Iterator<Item: 'static, Item: 'static> {}\n+   |                               -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                               |\n+   |                               `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:70:40\n+   |\n+LL | fn FAPIT1(_: impl Iterator<Item: Copy, Item: Send>) {}\n+   |                            ----------  ^^^^^^^^^^ re-bound here\n+   |                            |\n+   |                            `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:72:40\n+   |\n+LL | fn FAPIT2(_: impl Iterator<Item: Copy, Item: Copy>) {}\n+   |                            ----------  ^^^^^^^^^^ re-bound here\n+   |                            |\n+   |                            `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:74:43\n+   |\n+LL | fn FAPIT3(_: impl Iterator<Item: 'static, Item: 'static>) {}\n+   |                            -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                            |\n+   |                            `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:64:42\n+   |\n+LL | fn FRPIT1() -> impl Iterator<Item: Copy, Item: Send> { iter::empty() }\n+   |                              ----------  ^^^^^^^^^^ re-bound here\n+   |                              |\n+   |                              `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:66:42\n+   |\n+LL | fn FRPIT2() -> impl Iterator<Item: Copy, Item: Copy> { iter::empty() }\n+   |                              ----------  ^^^^^^^^^^ re-bound here\n+   |                              |\n+   |                              `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:68:45\n+   |\n+LL | fn FRPIT3() -> impl Iterator<Item: 'static, Item: 'static> { iter::empty() }\n+   |                              -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                              |\n+   |                              `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:77:39\n+   |\n+LL | const CIT1: impl Iterator<Item: Copy, Item: Send> = iter::empty();\n+   |                           ----------  ^^^^^^^^^^ re-bound here\n+   |                           |\n+   |                           `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:79:39\n+   |\n+LL | const CIT2: impl Iterator<Item: Copy, Item: Copy> = iter::empty();\n+   |                           ----------  ^^^^^^^^^^ re-bound here\n+   |                           |\n+   |                           `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:81:42\n+   |\n+LL | const CIT3: impl Iterator<Item: 'static, Item: 'static> = iter::empty();\n+   |                           -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                           |\n+   |                           `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:83:40\n+   |\n+LL | static SIT1: impl Iterator<Item: Copy, Item: Send> = iter::empty();\n+   |                            ----------  ^^^^^^^^^^ re-bound here\n+   |                            |\n+   |                            `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:85:40\n+   |\n+LL | static SIT2: impl Iterator<Item: Copy, Item: Copy> = iter::empty();\n+   |                            ----------  ^^^^^^^^^^ re-bound here\n+   |                            |\n+   |                            `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:87:43\n+   |\n+LL | static SIT3: impl Iterator<Item: 'static, Item: 'static> = iter::empty();\n+   |                            -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                            |\n+   |                            `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:90:46\n+   |\n+LL | fn lit1() { let _: impl Iterator<Item: Copy, Item: Send> = iter::empty(); }\n+   |                                  ----------  ^^^^^^^^^^ re-bound here\n+   |                                  |\n+   |                                  `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:92:46\n+   |\n+LL | fn lit2() { let _: impl Iterator<Item: Copy, Item: Copy> = iter::empty(); }\n+   |                                  ----------  ^^^^^^^^^^ re-bound here\n+   |                                  |\n+   |                                  `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:94:49\n+   |\n+LL | fn lit3() { let _: impl Iterator<Item: 'static, Item: 'static> = iter::empty(); }\n+   |                                  -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                                  |\n+   |                                  `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:97:35\n+   |\n+LL | type TAI1<T: Iterator<Item: Copy, Item: Send>> = T;\n+   |                       ----------  ^^^^^^^^^^ re-bound here\n+   |                       |\n+   |                       `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:99:35\n+   |\n+LL | type TAI2<T: Iterator<Item: Copy, Item: Copy>> = T;\n+   |                       ----------  ^^^^^^^^^^ re-bound here\n+   |                       |\n+   |                       `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:101:38\n+   |\n+LL | type TAI3<T: Iterator<Item: 'static, Item: 'static>> = T;\n+   |                       -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                       |\n+   |                       `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:103:44\n+   |\n+LL | type TAW1<T> where T: Iterator<Item: Copy, Item: Send> = T;\n+   |                                ----------  ^^^^^^^^^^ re-bound here\n+   |                                |\n+   |                                `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:105:44\n+   |\n+LL | type TAW2<T> where T: Iterator<Item: Copy, Item: Copy> = T;\n+   |                                ----------  ^^^^^^^^^^ re-bound here\n+   |                                |\n+   |                                `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:107:47\n+   |\n+LL | type TAW3<T> where T: Iterator<Item: 'static, Item: 'static> = T;\n+   |                                -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                                |\n+   |                                `Item` bound here first\n+\n+error: could not find defining uses\n+  --> $DIR/duplicate.rs:110:1\n+   |\n+LL | existential type ETAI1<T: Iterator<Item: Copy, Item: Send>>: Copy;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:110:48\n+   |\n+LL | existential type ETAI1<T: Iterator<Item: Copy, Item: Send>>: Copy;\n+   |                                    ----------  ^^^^^^^^^^ re-bound here\n+   |                                    |\n+   |                                    `Item` bound here first\n+\n+error: could not find defining uses\n+  --> $DIR/duplicate.rs:112:1\n+   |\n+LL | existential type ETAI2<T: Iterator<Item: Copy, Item: Copy>>: Copy;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:112:48\n+   |\n+LL | existential type ETAI2<T: Iterator<Item: Copy, Item: Copy>>: Copy;\n+   |                                    ----------  ^^^^^^^^^^ re-bound here\n+   |                                    |\n+   |                                    `Item` bound here first\n+\n+error: could not find defining uses\n+  --> $DIR/duplicate.rs:114:1\n+   |\n+LL | existential type ETAI3<T: Iterator<Item: 'static, Item: 'static>>: Copy;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:114:51\n+   |\n+LL | existential type ETAI3<T: Iterator<Item: 'static, Item: 'static>>: Copy;\n+   |                                    -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                                    |\n+   |                                    `Item` bound here first\n+\n+error: could not find defining uses\n+  --> $DIR/duplicate.rs:116:1\n+   |\n+LL | existential type ETAI4: Iterator<Item: Copy, Item: Send>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:116:46\n+   |\n+LL | existential type ETAI4: Iterator<Item: Copy, Item: Send>;\n+   |                                  ----------  ^^^^^^^^^^ re-bound here\n+   |                                  |\n+   |                                  `Item` bound here first\n+\n+error: could not find defining uses\n+  --> $DIR/duplicate.rs:118:1\n+   |\n+LL | existential type ETAI5: Iterator<Item: Copy, Item: Copy>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:118:46\n+   |\n+LL | existential type ETAI5: Iterator<Item: Copy, Item: Copy>;\n+   |                                  ----------  ^^^^^^^^^^ re-bound here\n+   |                                  |\n+   |                                  `Item` bound here first\n+\n+error: could not find defining uses\n+  --> $DIR/duplicate.rs:120:1\n+   |\n+LL | existential type ETAI6: Iterator<Item: 'static, Item: 'static>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:120:49\n+   |\n+LL | existential type ETAI6: Iterator<Item: 'static, Item: 'static>;\n+   |                                  -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                                  |\n+   |                                  `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:123:36\n+   |\n+LL | trait TRI1<T: Iterator<Item: Copy, Item: Send>> {}\n+   |                        ----------  ^^^^^^^^^^ re-bound here\n+   |                        |\n+   |                        `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:125:36\n+   |\n+LL | trait TRI2<T: Iterator<Item: Copy, Item: Copy>> {}\n+   |                        ----------  ^^^^^^^^^^ re-bound here\n+   |                        |\n+   |                        `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:127:39\n+   |\n+LL | trait TRI3<T: Iterator<Item: 'static, Item: 'static>> {}\n+   |                        -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                        |\n+   |                        `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:129:34\n+   |\n+LL | trait TRS1: Iterator<Item: Copy, Item: Send> {}\n+   |                      ----------  ^^^^^^^^^^ re-bound here\n+   |                      |\n+   |                      `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:131:34\n+   |\n+LL | trait TRS2: Iterator<Item: Copy, Item: Copy> {}\n+   |                      ----------  ^^^^^^^^^^ re-bound here\n+   |                      |\n+   |                      `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:133:37\n+   |\n+LL | trait TRS3: Iterator<Item: 'static, Item: 'static> {}\n+   |                      -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                      |\n+   |                      `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:135:45\n+   |\n+LL | trait TRW1<T> where T: Iterator<Item: Copy, Item: Send> {}\n+   |                                 ----------  ^^^^^^^^^^ re-bound here\n+   |                                 |\n+   |                                 `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:137:45\n+   |\n+LL | trait TRW2<T> where T: Iterator<Item: Copy, Item: Copy> {}\n+   |                                 ----------  ^^^^^^^^^^ re-bound here\n+   |                                 |\n+   |                                 `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:139:48\n+   |\n+LL | trait TRW3<T> where T: Iterator<Item: 'static, Item: 'static> {}\n+   |                                 -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                                 |\n+   |                                 `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:141:46\n+   |\n+LL | trait TRSW1 where Self: Iterator<Item: Copy, Item: Send> {}\n+   |                                  ----------  ^^^^^^^^^^ re-bound here\n+   |                                  |\n+   |                                  `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:143:46\n+   |\n+LL | trait TRSW2 where Self: Iterator<Item: Copy, Item: Copy> {}\n+   |                                  ----------  ^^^^^^^^^^ re-bound here\n+   |                                  |\n+   |                                  `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:145:49\n+   |\n+LL | trait TRSW3 where Self: Iterator<Item: 'static, Item: 'static> {}\n+   |                                  -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                                  |\n+   |                                  `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:147:43\n+   |\n+LL | trait TRA1 { type A: Iterator<Item: Copy, Item: Send>; }\n+   |                               ----------  ^^^^^^^^^^ re-bound here\n+   |                               |\n+   |                               `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:149:43\n+   |\n+LL | trait TRA2 { type A: Iterator<Item: Copy, Item: Copy>; }\n+   |                               ----------  ^^^^^^^^^^ re-bound here\n+   |                               |\n+   |                               `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:151:46\n+   |\n+LL | trait TRA3 { type A: Iterator<Item: 'static, Item: 'static>; }\n+   |                               -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                               |\n+   |                               `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:154:40\n+   |\n+LL | type TADyn1 = dyn Iterator<Item: Copy, Item: Send>;\n+   |                            ----------  ^^^^^^^^^^ re-bound here\n+   |                            |\n+   |                            `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:156:44\n+   |\n+LL | type TADyn2 = Box<dyn Iterator<Item: Copy, Item: Copy>>;\n+   |                                ----------  ^^^^^^^^^^ re-bound here\n+   |                                |\n+   |                                `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:158:43\n+   |\n+LL | type TADyn3 = dyn Iterator<Item: 'static, Item: 'static>;\n+   |                            -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                            |\n+   |                            `Item` bound here first\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: aborting due to 93 previous errors\n+"}, {"sha": "dc0afaa934a9ee1ec7962ef757e4c833c8b8e8b3", "filename": "src/test/ui/associated-type-bounds/dyn-existential-type.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-existential-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-existential-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-existential-type.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,67 @@\n+// run-pass\n+\n+#![feature(associated_type_bounds)]\n+#![feature(existential_type)]\n+\n+use std::ops::Add;\n+\n+trait Tr1 { type As1; fn mk(&self) -> Self::As1; }\n+trait Tr2<'a> { fn tr2(self) -> &'a Self; }\n+\n+fn assert_copy<T: Copy>(x: T) { let _x = x; let _x = x; }\n+fn assert_static<T: 'static>(_: T) {}\n+fn assert_forall_tr2<T: for<'a> Tr2<'a>>(_: T) {}\n+\n+struct S1;\n+#[derive(Copy, Clone)]\n+struct S2;\n+impl Tr1 for S1 { type As1 = S2; fn mk(&self) -> Self::As1 { S2 } }\n+\n+type Et1 = Box<dyn Tr1<As1: Copy>>;\n+fn def_et1() -> Et1 { Box::new(S1) }\n+pub fn use_et1() { assert_copy(def_et1().mk()); }\n+\n+type Et2 = Box<dyn Tr1<As1: 'static>>;\n+fn def_et2() -> Et2 { Box::new(S1) }\n+pub fn use_et2() { assert_static(def_et2().mk()); }\n+\n+type Et3 = Box<dyn Tr1<As1: Clone + Iterator<Item: Add<u8, Output: Into<u8>>>>>;\n+fn def_et3() -> Et3 {\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = core::ops::Range<u8>;\n+        fn mk(&self) -> Self::As1 { 0..10 }\n+    };\n+    Box::new(A)\n+}\n+pub fn use_et3() {\n+    let _0 = def_et3().mk().clone();\n+    let mut s = 0u8;\n+    for _1 in _0 {\n+        let _2 = _1 + 1u8;\n+        s += _2.into();\n+    }\n+    assert_eq!(s, (0..10).map(|x| x + 1).sum());\n+}\n+\n+type Et4 = Box<dyn Tr1<As1: for<'a> Tr2<'a>>>;\n+fn def_et4() -> Et4 {\n+    #[derive(Copy, Clone)]\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = A;\n+        fn mk(&self) -> A { A }\n+    }\n+    impl<'a> Tr2<'a> for A {\n+        fn tr2(self) -> &'a Self { &A }\n+    }\n+    Box::new(A)\n+}\n+pub fn use_et4() { assert_forall_tr2(def_et4().mk()); }\n+\n+fn main() {\n+    let _ = use_et1();\n+    let _ = use_et2();\n+    let _ = use_et3();\n+    let _ = use_et4();\n+}"}, {"sha": "439304fd309c8d66b0f0eca57bd9632af5260588", "filename": "src/test/ui/associated-type-bounds/dyn-lcsit.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-lcsit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-lcsit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-lcsit.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,69 @@\n+// run-pass\n+\n+#![feature(associated_type_bounds)]\n+#![feature(impl_trait_in_bindings)]\n+\n+#![allow(non_upper_case_globals)]\n+\n+use std::ops::Add;\n+\n+trait Tr1 { type As1; fn mk(&self) -> Self::As1; }\n+trait Tr2<'a> { fn tr2(self) -> &'a Self; }\n+\n+fn assert_copy<T: Copy>(x: T) { let _x = x; let _x = x; }\n+fn assert_static<T: 'static>(_: T) {}\n+fn assert_forall_tr2<T: for<'a> Tr2<'a>>(_: T) {}\n+\n+#[derive(Copy, Clone)]\n+struct S1;\n+#[derive(Copy, Clone)]\n+struct S2;\n+impl Tr1 for S1 { type As1 = S2; fn mk(&self) -> Self::As1 { S2 } }\n+\n+const cdef_et1: &dyn Tr1<As1: Copy> = &S1;\n+const sdef_et1: &dyn Tr1<As1: Copy> = &S1;\n+pub fn use_et1() { assert_copy(cdef_et1.mk()); assert_copy(sdef_et1.mk()); }\n+\n+const cdef_et2: &(dyn Tr1<As1: 'static> + Sync) = &S1;\n+static sdef_et2: &(dyn Tr1<As1: 'static> + Sync) = &S1;\n+pub fn use_et2() { assert_static(cdef_et2.mk()); assert_static(sdef_et2.mk()); }\n+\n+const cdef_et3: &dyn Tr1<As1: Clone + Iterator<Item: Add<u8, Output: Into<u8>>>> = {\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = core::ops::Range<u8>;\n+        fn mk(&self) -> Self::As1 { 0..10 }\n+    };\n+    &A\n+};\n+pub fn use_et3() {\n+    let _0 = cdef_et3.mk().clone();\n+    let mut s = 0u8;\n+    for _1 in _0 {\n+        let _2 = _1 + 1u8;\n+        s += _2.into();\n+    }\n+    assert_eq!(s, (0..10).map(|x| x + 1).sum());\n+}\n+\n+const cdef_et4: &(dyn Tr1<As1: for<'a> Tr2<'a>> + Sync) = {\n+    #[derive(Copy, Clone)]\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = A;\n+        fn mk(&self) -> A { A }\n+    }\n+    impl<'a> Tr2<'a> for A {\n+        fn tr2(self) -> &'a Self { &A }\n+    }\n+    &A\n+};\n+static sdef_et4: &(dyn Tr1<As1: for<'a> Tr2<'a>> + Sync) = cdef_et4;\n+pub fn use_et4() { assert_forall_tr2(cdef_et4.mk()); assert_forall_tr2(sdef_et4.mk()); }\n+\n+fn main() {\n+    let _ = use_et1();\n+    let _ = use_et2();\n+    let _ = use_et3();\n+    let _ = use_et4();\n+}"}, {"sha": "5fe4818ef8fed9bd60bbcc69f7e232291a9e1ee6", "filename": "src/test/ui/associated-type-bounds/dyn-lcsit.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-lcsit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-lcsit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-lcsit.stderr?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,6 @@\n+warning: the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash\n+  --> $DIR/dyn-lcsit.rs:4:12\n+   |\n+LL | #![feature(impl_trait_in_bindings)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^\n+"}, {"sha": "f22a6c44cb84d8994c39a6fab0c65dbce7acdc88", "filename": "src/test/ui/associated-type-bounds/dyn-rpit-and-let.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-rpit-and-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-rpit-and-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-rpit-and-let.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,73 @@\n+// run-pass\n+\n+// FIXME: uncomment let binding types below when `impl_trait_in_bindings` feature is fixed.\n+\n+#![feature(associated_type_bounds)]\n+\n+use std::ops::Add;\n+\n+trait Tr1 { type As1; fn mk(&self) -> Self::As1; }\n+trait Tr2<'a> { fn tr2(self) -> &'a Self; }\n+\n+fn assert_copy<T: Copy>(x: T) { let _x = x; let _x = x; }\n+fn assert_static<T: 'static>(_: T) {}\n+fn assert_forall_tr2<T: for<'a> Tr2<'a>>(_: T) {}\n+\n+struct S1;\n+#[derive(Copy, Clone)]\n+struct S2;\n+impl Tr1 for S1 { type As1 = S2; fn mk(&self) -> Self::As1 { S2 } }\n+\n+fn def_et1() -> Box<dyn Tr1<As1: Copy>> {\n+    let x /* : Box<dyn Tr1<As1: Copy>> */ = Box::new(S1);\n+    x\n+}\n+pub fn use_et1() { assert_copy(def_et1().mk()); }\n+\n+fn def_et2() -> Box<dyn Tr1<As1: Send + 'static>> {\n+    let x /* : Box<dyn Tr1<As1: Send + 'static>> */ = Box::new(S1);\n+    x\n+}\n+pub fn use_et2() { assert_static(def_et2().mk()); }\n+\n+fn def_et3() -> Box<dyn Tr1<As1: Clone + Iterator<Item: Add<u8, Output: Into<u8>>>>> {\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = core::ops::Range<u8>;\n+        fn mk(&self) -> Self::As1 { 0..10 }\n+    };\n+    let x /* : Box<dyn Tr1<As1: Clone + Iterator<Item: Add<u8, Output: Into<u8>>>>> */\n+        = Box::new(A);\n+    x\n+}\n+pub fn use_et3() {\n+    let _0 = def_et3().mk().clone();\n+    let mut s = 0u8;\n+    for _1 in _0 {\n+        let _2 = _1 + 1u8;\n+        s += _2.into();\n+    }\n+    assert_eq!(s, (0..10).map(|x| x + 1).sum());\n+}\n+\n+fn def_et4() -> Box<dyn Tr1<As1: for<'a> Tr2<'a>>> {\n+    #[derive(Copy, Clone)]\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = A;\n+        fn mk(&self) -> A { A }\n+    }\n+    impl<'a> Tr2<'a> for A {\n+        fn tr2(self) -> &'a Self { &A }\n+    }\n+    let x /* : Box<dyn Tr1<As1: for<'a> Tr2<'a>>> */ = Box::new(A);\n+    x\n+}\n+pub fn use_et4() { assert_forall_tr2(def_et4().mk()); }\n+\n+fn main() {\n+    let _ = use_et1();\n+    let _ = use_et2();\n+    let _ = use_et3();\n+    let _ = use_et4();\n+}"}, {"sha": "1b3e978594d69b6e0957119534ab75753b87e47d", "filename": "src/test/ui/associated-type-bounds/entails-sized-object-safety.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fentails-sized-object-safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fentails-sized-object-safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fentails-sized-object-safety.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,26 @@\n+// compile-pass\n+\n+#![feature(associated_type_bounds)]\n+\n+trait Tr1: Sized { type As1; }\n+trait Tr2<'a>: Sized { type As2; }\n+\n+trait ObjTr1 { fn foo() -> Self where Self: Tr1<As1: Copy>; }\n+fn _assert_obj_safe_1(_: Box<dyn ObjTr1>) {}\n+\n+trait ObjTr2 { fn foo() -> Self where Self: Tr1<As1: 'static>; }\n+fn _assert_obj_safe_2(_: Box<dyn ObjTr2>) {}\n+\n+trait ObjTr3 { fn foo() -> Self where Self: Tr1<As1: Into<u8> + 'static + Copy>; }\n+fn _assert_obj_safe_3(_: Box<dyn ObjTr3>) {}\n+\n+trait ObjTr4 { fn foo() -> Self where Self: Tr1<As1: for<'a> Tr2<'a>>; }\n+fn _assert_obj_safe_4(_: Box<dyn ObjTr4>) {}\n+\n+trait ObjTr5 { fn foo() -> Self where for<'a> Self: Tr1<As1: Tr2<'a>>; }\n+fn _assert_obj_safe_5(_: Box<dyn ObjTr5>) {}\n+\n+trait ObjTr6 { fn foo() -> Self where Self: for<'a> Tr1<As1: Tr2<'a, As2: for<'b> Tr2<'b>>>; }\n+fn _assert_obj_safe_6(_: Box<dyn ObjTr6>) {}\n+\n+fn main() {}"}, {"sha": "a6b0bb7070b7a4d6a765441bc164ceec0929af9b", "filename": "src/test/ui/associated-type-bounds/enum-bounds.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fenum-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fenum-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fenum-bounds.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,122 @@\n+// run-pass\n+\n+#![feature(associated_type_bounds)]\n+\n+trait Tr1 { type As1; }\n+trait Tr2 { type As2; }\n+trait Tr3 { type As3; }\n+trait Tr4<'a> { type As4; }\n+trait Tr5 { type As5; }\n+\n+impl Tr1 for &str { type As1 = bool; }\n+impl Tr2 for bool { type As2 = u8; }\n+impl Tr3 for u8 { type As3 = fn() -> u8; }\n+impl Tr1 for () { type As1 = (usize,); }\n+impl<'a> Tr4<'a> for (usize,) { type As4 = u8; }\n+impl Tr5 for bool { type As5 = u16; }\n+\n+enum En1<T: Tr1<As1: Tr2>> {\n+    Outest(T),\n+    Outer(T::As1),\n+    Inner(<T::As1 as Tr2>::As2),\n+}\n+\n+fn wrap_en1_1<T>(x: T) -> En1<T> where T: Tr1, T::As1: Tr2 {\n+    En1::Outest(x)\n+}\n+\n+fn wrap_en1_2<T>(x: T::As1) -> En1<T> where T: Tr1, T::As1: Tr2 {\n+    En1::Outer(x)\n+}\n+\n+fn wrap_en1_3<T>(x: <T::As1 as Tr2>::As2) -> En1<T> where T: Tr1, T::As1: Tr2 {\n+    En1::Inner(x)\n+}\n+\n+enum En2<T: Tr1<As1: Tr2<As2: Tr3>>> {\n+    V0(T),\n+    V1(T::As1),\n+    V2(<T::As1 as Tr2>::As2),\n+    V3(<<T::As1 as Tr2>::As2 as Tr3>::As3),\n+}\n+\n+enum En3<T: Tr1<As1: 'static>> {\n+    V0(T),\n+    V1(&'static T::As1),\n+}\n+\n+enum En4<'x1, 'x2, T: Tr1<As1: for<'l> Tr4<'l>>> {\n+    V0(&'x1 <T::As1 as Tr4<'x1>>::As4),\n+    V1(&'x2 <T::As1 as Tr4<'x2>>::As4),\n+}\n+\n+enum _En5<'x1, 'x2, T: Tr1<As1: for<'l> Tr4<'l, As4: Copy>>> {\n+    _V0(&'x1 <T::As1 as Tr4<'x1>>::As4),\n+    _V1(&'x2 <T::As1 as Tr4<'x2>>::As4),\n+}\n+\n+enum En6<T>\n+where\n+    T: Tr1<As1: Tr2 + 'static + Tr5>,\n+{\n+    V0(T),\n+    V1(<T::As1 as Tr2>::As2),\n+    V2(&'static T::As1),\n+    V3(<T::As1 as Tr5>::As5),\n+}\n+\n+enum _En7<'a, 'b, T> // `<T::As1 as Tr2>::As2: 'a` is implied.\n+where\n+    T: Tr1<As1: Tr2>,\n+{\n+    V0(&'a T),\n+    V1(&'b <T::As1 as Tr2>::As2),\n+}\n+\n+fn _make_en7<'a, 'b, T>(x: _En7<'a, 'b, T>)\n+where\n+    T: Tr1<As1: Tr2>,\n+{\n+    match x {\n+        _En7::V0(x) => {\n+            let _: &'a T = &x;\n+        },\n+        _En7::V1(_) => {},\n+    }\n+}\n+\n+enum EnSelf<T> where Self: Tr1<As1: Tr2> {\n+    V0(T),\n+    V1(<Self as Tr1>::As1),\n+    V2(<<Self as Tr1>::As1 as Tr2>::As2),\n+}\n+\n+impl Tr1 for EnSelf<&'static str> { type As1 = bool; }\n+\n+fn main() {\n+    if let En1::Outest(\"foo\") = wrap_en1_1::<_>(\"foo\") {} else { panic!() };\n+    if let En1::Outer(true) = wrap_en1_2::<&str>(true) {} else { panic!() };\n+    if let En1::Inner(24u8) = wrap_en1_3::<&str>(24u8) {} else { panic!() };\n+\n+    let _ = En2::<_>::V0(\"151571\");\n+    let _ = En2::<&str>::V1(false);\n+    let _ = En2::<&str>::V2(42u8);\n+    let _ = En2::<&str>::V3(|| 12u8);\n+\n+    let _ = En3::<_>::V0(\"deadbeef\");\n+    let _ = En3::<&str>::V1(&true);\n+\n+    let f1 = (1,);\n+    let f2 = (2,);\n+    let _ = En4::<()>::V0(&f1.0);\n+    let _ = En4::<()>::V1(&f2.0);\n+\n+    let _ = En6::<_>::V0(\"bar\");\n+    let _ = En6::<&str>::V1(24u8);\n+    let _ = En6::<&str>::V2(&false);\n+    let _ = En6::<&str>::V3(12u16);\n+\n+    let _ = EnSelf::<_>::V0(\"foo\");\n+    let _ = EnSelf::<&'static str>::V1(true);\n+    let _ = EnSelf::<&'static str>::V2(24u8);\n+}"}, {"sha": "87046aec5c4ab5e5de18bc3189bb2ed21248351c", "filename": "src/test/ui/associated-type-bounds/existential-type.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fexistential-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fexistential-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fexistential-type.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,67 @@\n+// run-pass\n+\n+#![feature(associated_type_bounds)]\n+#![feature(existential_type)]\n+\n+use std::ops::Add;\n+\n+trait Tr1 { type As1; fn mk(self) -> Self::As1; }\n+trait Tr2<'a> { fn tr2(self) -> &'a Self; }\n+\n+fn assert_copy<T: Copy>(x: T) { let _x = x; let _x = x; }\n+fn assert_static<T: 'static>(_: T) {}\n+fn assert_forall_tr2<T: for<'a> Tr2<'a>>(_: T) {}\n+\n+struct S1;\n+#[derive(Copy, Clone)]\n+struct S2;\n+impl Tr1 for S1 { type As1 = S2; fn mk(self) -> Self::As1 { S2 } }\n+\n+existential type Et1: Tr1<As1: Copy>;\n+fn def_et1() -> Et1 { S1 }\n+pub fn use_et1() { assert_copy(def_et1().mk()); }\n+\n+existential type Et2: Tr1<As1: 'static>;\n+fn def_et2() -> Et2 { S1 }\n+pub fn use_et2() { assert_static(def_et2().mk()); }\n+\n+existential type Et3: Tr1<As1: Clone + Iterator<Item: Add<u8, Output: Into<u8>>>>;\n+fn def_et3() -> Et3 {\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = core::ops::Range<u8>;\n+        fn mk(self) -> Self::As1 { 0..10 }\n+    };\n+    A\n+}\n+pub fn use_et3() {\n+    let _0 = def_et3().mk().clone();\n+    let mut s = 0u8;\n+    for _1 in _0 {\n+        let _2 = _1 + 1u8;\n+        s += _2.into();\n+    }\n+    assert_eq!(s, (0..10).map(|x| x + 1).sum());\n+}\n+\n+existential type Et4: Tr1<As1: for<'a> Tr2<'a>>;\n+fn def_et4() -> Et4 {\n+    #[derive(Copy, Clone)]\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = A;\n+        fn mk(self) -> A { A }\n+    }\n+    impl<'a> Tr2<'a> for A {\n+        fn tr2(self) -> &'a Self { &A }\n+    }\n+    A\n+}\n+pub fn use_et4() { assert_forall_tr2(def_et4().mk()); }\n+\n+fn main() {\n+    let _ = use_et1();\n+    let _ = use_et2();\n+    let _ = use_et3();\n+    let _ = use_et4();\n+}"}, {"sha": "7e208b4e70d81bd7ab85b8dd4d0f37c1b328e35e", "filename": "src/test/ui/associated-type-bounds/fn-apit.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-apit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-apit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-apit.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,58 @@\n+// run-pass\n+// aux-build:fn-aux.rs\n+\n+#![feature(associated_type_bounds)]\n+\n+extern crate fn_aux;\n+\n+use fn_aux::*;\n+\n+fn apit_bound(beta: impl Beta<Gamma: Alpha>) -> usize {\n+    desugared_bound(beta)\n+}\n+\n+fn apit_bound_region(beta: impl Beta<Gamma: 'static>) -> usize {\n+    desugared_bound_region(beta)\n+}\n+\n+fn apit_bound_multi(\n+    beta: impl Copy + Beta<Gamma: Alpha + 'static + Delta>\n+) -> usize {\n+    desugared_bound_multi(beta)\n+}\n+\n+fn apit_bound_region_forall(\n+    beta: impl Beta<Gamma: Copy + for<'a> Epsilon<'a>>\n+) -> usize {\n+    desugared_bound_region_forall(beta)\n+}\n+\n+fn apit_bound_region_forall2(\n+    beta: impl Beta<Gamma: Copy + for<'a> Epsilon<'a, Zeta: Eta>>\n+) -> usize {\n+    desugared_bound_region_forall2(beta)\n+}\n+\n+fn apit_bound_nested(\n+    beta: impl Beta<Gamma: Copy + Alpha + Beta<Gamma: Delta>>\n+) -> usize {\n+    desugared_bound_nested(beta)\n+}\n+\n+fn apit_bound_nested2(\n+    beta: impl Beta<Gamma = impl Copy + Alpha + Beta<Gamma: Delta>>\n+) -> usize {\n+    desugared_bound_nested(beta)\n+}\n+\n+fn main() {\n+    let beta = BetaType;\n+    let _gamma = beta.gamma();\n+\n+    assert_eq!(42, apit_bound(beta));\n+    assert_eq!(24, apit_bound_region(beta));\n+    assert_eq!(42 + 24 + 1337, apit_bound_multi(beta));\n+    assert_eq!(7331 * 2, apit_bound_region_forall(beta));\n+    assert_eq!(42 + 1337, apit_bound_nested(beta));\n+    assert_eq!(42 + 1337, apit_bound_nested2(beta));\n+}"}, {"sha": "434bdbe996c63202e4c8c24dd4e8f1e3bcb59dee", "filename": "src/test/ui/associated-type-bounds/fn-aux.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-aux.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,12 @@\n+// run-pass\n+// aux-build:fn-aux.rs\n+\n+#![feature(associated_type_bounds)]\n+\n+extern crate fn_aux;\n+\n+use fn_aux::*;\n+\n+fn main() {\n+    desugared();\n+}"}, {"sha": "9ff4a50e1e6e415b0c00ba56006b6774616dfc5c", "filename": "src/test/ui/associated-type-bounds/fn-dyn-apit.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-dyn-apit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-dyn-apit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-dyn-apit.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,60 @@\n+// run-pass\n+// aux-build:fn-dyn-aux.rs\n+\n+#![feature(associated_type_bounds)]\n+\n+extern crate fn_dyn_aux;\n+\n+use fn_dyn_aux::*;\n+\n+// ATB, APIT (dyn trait):\n+\n+fn dyn_apit_bound(beta: &dyn Beta<Gamma: Alpha>) -> usize {\n+    desugared_bound(beta)\n+}\n+\n+fn dyn_apit_bound_region(beta: &dyn Beta<Gamma: 'static>) -> usize {\n+    desugared_bound_region(beta)\n+}\n+\n+fn dyn_apit_bound_multi(\n+    beta: &(dyn Beta<Gamma: Alpha + 'static + Delta> + Send)\n+) -> usize {\n+    desugared_bound_multi(beta)\n+}\n+\n+fn dyn_apit_bound_region_forall(\n+    beta: &dyn Beta<Gamma: Copy + for<'a> Epsilon<'a>>\n+) -> usize {\n+    desugared_bound_region_forall(beta)\n+}\n+\n+fn dyn_apit_bound_region_forall2(\n+    beta: &dyn Beta<Gamma: Copy + for<'a> Epsilon<'a, Zeta: Eta>>\n+) -> usize {\n+    desugared_bound_region_forall2(beta)\n+}\n+\n+fn dyn_apit_bound_nested(\n+    beta: &dyn Beta<Gamma: Copy + Alpha + Beta<Gamma: Delta>>\n+) -> usize {\n+    desugared_bound_nested(beta)\n+}\n+\n+fn dyn_apit_bound_nested2(\n+    beta: &dyn Beta<Gamma = impl Copy + Alpha + Beta<Gamma: Delta>>\n+) -> usize {\n+    desugared_bound_nested(beta)\n+}\n+\n+fn main() {\n+    let beta = BetaType;\n+    let _gamma = beta.gamma();\n+\n+    assert_eq!(42, dyn_apit_bound(&beta));\n+    assert_eq!(24, dyn_apit_bound_region(&beta));\n+    assert_eq!(42 + 24 + 1337, dyn_apit_bound_multi(&beta));\n+    assert_eq!(7331 * 2, dyn_apit_bound_region_forall(&beta));\n+    assert_eq!(42 + 1337, dyn_apit_bound_nested(&beta));\n+    assert_eq!(42 + 1337, dyn_apit_bound_nested2(&beta));\n+}"}, {"sha": "7b188763b7a5e6f5a494f197bae43bde2b607899", "filename": "src/test/ui/associated-type-bounds/fn-inline.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-inline.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,62 @@\n+// run-pass\n+// aux-build:fn-aux.rs\n+\n+#![feature(associated_type_bounds)]\n+\n+extern crate fn_aux;\n+\n+use fn_aux::*;\n+\n+// ATB, Type parameters, Inline bounds:\n+\n+fn inline_bound<B: Beta<Gamma: Alpha>>(beta: B) -> usize {\n+    desugared_bound(beta)\n+}\n+\n+fn inline_bound_region<B: Beta<Gamma: 'static>>(beta: B) -> usize {\n+    desugared_bound_region(beta)\n+}\n+\n+fn inline_bound_multi<B: Copy + Beta<Gamma: Alpha + 'static + Delta>>(\n+    beta: B\n+) -> usize {\n+    desugared_bound_multi(beta)\n+}\n+\n+fn inline_bound_region_specific<'a, B: Beta<Gamma: 'a + Epsilon<'a>>>(\n+    gamma: &'a B::Gamma\n+) -> usize {\n+    desugared_bound_region_specific::<B>(gamma)\n+}\n+\n+fn inline_bound_region_forall<B: Beta<Gamma: Copy + for<'a> Epsilon<'a>>>(\n+    beta: B\n+) -> usize {\n+    desugared_bound_region_forall(beta)\n+}\n+\n+fn inline_bound_region_forall2<B: Beta<Gamma: Copy + for<'a> Epsilon<'a, Zeta: Eta>>>(\n+    beta: B\n+) -> usize {\n+    desugared_bound_region_forall2(beta)\n+}\n+\n+fn inline_bound_nested<B: Beta<Gamma: Copy + Alpha + Beta<Gamma: Delta>>>(\n+    beta: B\n+) -> usize {\n+    desugared_bound_nested(beta)\n+}\n+\n+fn main() {\n+    let beta = BetaType;\n+    let gamma = beta.gamma();\n+\n+    assert_eq!(42, inline_bound(beta));\n+    assert_eq!(24, inline_bound_region(beta));\n+    assert_eq!(42 + 24 + 1337, inline_bound_multi(beta));\n+    assert_eq!(7331, inline_bound_region_specific::<BetaType>(&gamma));\n+    assert_eq!(7331 * 2, inline_bound_region_forall(beta));\n+    // FIXME: requires lazy normalization.\n+    // assert_eq!(7331 * 2, inline_bound_region_forall2(beta));\n+    assert_eq!(42 + 1337, inline_bound_nested(beta));\n+}"}, {"sha": "60d7149a56f25ba3baca4bb0cfcff8778fe1baa6", "filename": "src/test/ui/associated-type-bounds/fn-where.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-where.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-where.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-where.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,78 @@\n+// run-pass\n+// aux-build:fn-aux.rs\n+\n+#![feature(associated_type_bounds)]\n+\n+extern crate fn_aux;\n+\n+use fn_aux::*;\n+\n+// ATB, Type parameters, Where-clauses:\n+\n+fn where_bound<B>(beta: B) -> usize\n+where\n+    B: Beta<Gamma: Alpha>\n+{\n+    desugared_bound(beta)\n+}\n+\n+fn where_bound_region<B>(beta: B) -> usize\n+where\n+    B: Beta<Gamma: 'static>\n+{\n+    desugared_bound_region(beta)\n+}\n+\n+fn where_bound_multi<B>(beta: B) -> usize\n+where\n+    B: Copy + Beta<Gamma: Alpha + 'static + Delta>,\n+{\n+    desugared_bound_multi(beta)\n+}\n+\n+fn where_bound_region_specific<'a, B>(gamma: &'a B::Gamma) -> usize\n+where\n+    B: Beta<Gamma: 'a + Epsilon<'a>>,\n+{\n+    desugared_bound_region_specific::<B>(gamma)\n+}\n+\n+fn where_bound_region_forall<B>(beta: B) -> usize\n+where\n+    B: Beta<Gamma: Copy + for<'a> Epsilon<'a>>,\n+{\n+    desugared_bound_region_forall(beta)\n+}\n+\n+fn where_bound_region_forall2<B>(beta: B) -> usize\n+where\n+    B: Beta<Gamma: Copy + for<'a> Epsilon<'a, Zeta: Eta>>,\n+{\n+    desugared_bound_region_forall2(beta)\n+}\n+\n+fn where_contraint_region_forall<B>(beta: B) -> usize\n+where\n+    for<'a> &'a B: Beta<Gamma: Alpha>,\n+{\n+    desugared_contraint_region_forall(beta)\n+}\n+\n+fn where_bound_nested<B>(beta: B) -> usize\n+where\n+    B: Beta<Gamma: Copy + Alpha + Beta<Gamma: Delta>>,\n+{\n+    desugared_bound_nested(beta)\n+}\n+\n+fn main() {\n+    let beta = BetaType;\n+    let gamma = beta.gamma();\n+\n+    assert_eq!(42, where_bound(beta));\n+    assert_eq!(24, where_bound_region(beta));\n+    assert_eq!(42 + 24 + 1337, where_bound_multi(beta));\n+    assert_eq!(7331, where_bound_region_specific::<BetaType>(&gamma));\n+    assert_eq!(7331 * 2, where_bound_region_forall::<BetaType>(beta));\n+    assert_eq!(42 + 1337, where_bound_nested::<BetaType>(beta));\n+}"}, {"sha": "23790d416e1f717a73e0c4f0be41de5f43e49cdc", "filename": "src/test/ui/associated-type-bounds/fn-wrap-apit.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-wrap-apit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-wrap-apit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-wrap-apit.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,64 @@\n+// run-pass\n+// aux-build:fn-aux.rs\n+\n+#![feature(associated_type_bounds)]\n+\n+extern crate fn_aux;\n+\n+use fn_aux::*;\n+\n+// ATB, APIT + Wrap:\n+\n+struct Wrap<T>(T);\n+\n+fn wrap_apit_bound(beta: Wrap<impl Beta<Gamma: Alpha>>) -> usize {\n+    desugared_bound(beta.0)\n+}\n+\n+fn wrap_apit_bound_region(beta: Wrap<impl Beta<Gamma: 'static>>) -> usize {\n+    desugared_bound_region(beta.0)\n+}\n+\n+fn wrap_apit_bound_multi(\n+    beta: Wrap<impl Copy + Beta<Gamma: Alpha + 'static + Delta>>\n+) -> usize {\n+    desugared_bound_multi(beta.0)\n+}\n+\n+fn wrap_apit_bound_region_forall(\n+    beta: Wrap<impl Beta<Gamma: Copy + for<'a> Epsilon<'a>>>\n+) -> usize {\n+    desugared_bound_region_forall(beta.0)\n+}\n+\n+fn wrap_apit_bound_region_forall2(\n+    beta: Wrap<impl Beta<Gamma: Copy + for<'a> Epsilon<'a, Zeta: Eta>>>\n+) -> usize {\n+    desugared_bound_region_forall2(beta.0)\n+}\n+\n+fn wrap_apit_bound_nested(\n+    beta: Wrap<impl Beta<Gamma: Copy + Alpha + Beta<Gamma: Delta>>>\n+) -> usize {\n+    desugared_bound_nested(beta.0)\n+}\n+\n+fn wrap_apit_bound_nested2(\n+    beta: Wrap<impl Beta<Gamma = impl Copy + Alpha + Beta<Gamma: Delta>>>\n+) -> usize {\n+    desugared_bound_nested(beta.0)\n+}\n+\n+fn main() {\n+    let beta = BetaType;\n+    let _gamma = beta.gamma();\n+\n+    assert_eq!(42, wrap_apit_bound(Wrap(beta)));\n+    assert_eq!(24, wrap_apit_bound_region(Wrap(beta)));\n+    assert_eq!(42 + 24 + 1337, wrap_apit_bound_multi(Wrap(beta)));\n+    assert_eq!(7331 * 2, wrap_apit_bound_region_forall(Wrap(beta)));\n+    // FIXME: requires lazy normalization.\n+    // assert_eq!(7331 * 2, wrap_apit_bound_region_forall2(Wrap(beta)));\n+    assert_eq!(42 + 1337, wrap_apit_bound_nested(Wrap(beta)));\n+    assert_eq!(42 + 1337, wrap_apit_bound_nested2(Wrap(beta)));\n+}"}, {"sha": "32d099fce759e44d258cf2754d07ada71670e3a5", "filename": "src/test/ui/associated-type-bounds/implied-region-constraints.nll.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fimplied-region-constraints.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fimplied-region-constraints.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fimplied-region-constraints.nll.stderr?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,24 @@\n+error: lifetime may not live long enough\n+  --> $DIR/implied-region-constraints.rs:19:56\n+   |\n+LL | fn _bad_st<'a, 'b, T>(x: St<'a, 'b, T>)\n+   |            --  -- lifetime `'b` defined here\n+   |            |\n+   |            lifetime `'a` defined here\n+...\n+LL |     let _failure_proves_not_implied_outlives_region_b: &'b T = &x.f0;\n+   |                                                        ^^^^^ type annotation requires that `'a` must outlive `'b`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/implied-region-constraints.rs:40:64\n+   |\n+LL | fn _bad_en7<'a, 'b, T>(x: En7<'a, 'b, T>)\n+   |             --  -- lifetime `'b` defined here\n+   |             |\n+   |             lifetime `'a` defined here\n+...\n+LL |             let _failure_proves_not_implied_outlives_region_b: &'b T = &x;\n+   |                                                                ^^^^^ type annotation requires that `'a` must outlive `'b`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "4dbaab50a61db14cc05ae38bf2f7a7408caf3638", "filename": "src/test/ui/associated-type-bounds/implied-region-constraints.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fimplied-region-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fimplied-region-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fimplied-region-constraints.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,47 @@\n+// compile-fail\n+\n+#![feature(associated_type_bounds)]\n+\n+trait Tr1 { type As1; }\n+trait Tr2 { type As2; }\n+\n+struct St<'a, 'b, T: Tr1<As1: Tr2>> { // `T: 'b` is *not* implied!\n+    f0: &'a T, // `T: 'a` is implied.\n+    f1: &'b <T::As1 as Tr2>::As2, // `<T::As1 as Tr2>::As2: 'a` is implied.\n+}\n+\n+fn _bad_st<'a, 'b, T>(x: St<'a, 'b, T>)\n+where\n+    T: Tr1,\n+    T::As1: Tr2,\n+{\n+    // This should fail because `T: 'b` is not implied from `WF(St<'a, 'b, T>)`.\n+    let _failure_proves_not_implied_outlives_region_b: &'b T = &x.f0;\n+    //~^ ERROR lifetime mismatch [E0623]\n+}\n+\n+enum En7<'a, 'b, T> // `<T::As1 as Tr2>::As2: 'a` is implied.\n+where\n+    T: Tr1,\n+    T::As1: Tr2,\n+{\n+    V0(&'a T),\n+    V1(&'b <T::As1 as Tr2>::As2),\n+}\n+\n+fn _bad_en7<'a, 'b, T>(x: En7<'a, 'b, T>)\n+where\n+    T: Tr1,\n+    T::As1: Tr2,\n+{\n+    match x {\n+        En7::V0(x) => {\n+            // Also fails for the same reason as above:\n+            let _failure_proves_not_implied_outlives_region_b: &'b T = &x;\n+            //~^ ERROR lifetime mismatch [E0623]\n+        },\n+        En7::V1(_) => {},\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "9968f3e8bac5ef5b30011efac01feabfef428eb7", "filename": "src/test/ui/associated-type-bounds/implied-region-constraints.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fimplied-region-constraints.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fimplied-region-constraints.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fimplied-region-constraints.stderr?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,20 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/implied-region-constraints.rs:19:64\n+   |\n+LL | fn _bad_st<'a, 'b, T>(x: St<'a, 'b, T>)\n+   |                          ------------- this type is declared with multiple lifetimes...\n+...\n+LL |     let _failure_proves_not_implied_outlives_region_b: &'b T = &x.f0;\n+   |                                                                ^^^^^ ...but data with one lifetime flows into the other here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/implied-region-constraints.rs:40:72\n+   |\n+LL | fn _bad_en7<'a, 'b, T>(x: En7<'a, 'b, T>)\n+   |                           -------------- this type is declared with multiple lifetimes...\n+...\n+LL |             let _failure_proves_not_implied_outlives_region_b: &'b T = &x;\n+   |                                                                        ^^ ...but data with one lifetime flows into the other here\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "1257dc6e94b397d0119ea27c9490d9dee282f3b1", "filename": "src/test/ui/associated-type-bounds/inside-adt.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,36 @@\n+// compile-fail\n+// ignore-tidy-linelength\n+// error-pattern:could not find defining uses\n+\n+#![feature(associated_type_bounds)]\n+#![feature(untagged_unions)]\n+\n+struct S1 { f: dyn Iterator<Item: Copy> }\n+//~^ associated type bounds are not allowed within structs, enums, or unions\n+//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+struct S2 { f: Box<dyn Iterator<Item: Copy>> }\n+//~^ associated type bounds are not allowed within structs, enums, or unions\n+//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+struct S3 { f: dyn Iterator<Item: 'static> }\n+//~^ associated type bounds are not allowed within structs, enums, or unions\n+//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+\n+enum E1 { V(dyn Iterator<Item: Copy>) }\n+//~^ associated type bounds are not allowed within structs, enums, or unions\n+//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+enum E2 { V(Box<dyn Iterator<Item: Copy>>) }\n+//~^ associated type bounds are not allowed within structs, enums, or unions\n+//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+enum E3 { V(dyn Iterator<Item: 'static>) }\n+//~^ associated type bounds are not allowed within structs, enums, or unions\n+//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+\n+union U1 { f: dyn Iterator<Item: Copy> }\n+//~^ associated type bounds are not allowed within structs, enums, or unions\n+//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+union U2 { f: Box<dyn Iterator<Item: Copy>> }\n+//~^ associated type bounds are not allowed within structs, enums, or unions\n+//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+union U3 { f: dyn Iterator<Item: 'static> }\n+//~^ associated type bounds are not allowed within structs, enums, or unions\n+//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]"}, {"sha": "7bdd71b8296ff55359b1e86b958e44f2ba88d64f", "filename": "src/test/ui/associated-type-bounds/inside-adt.stderr", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.stderr?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,79 @@\n+error: associated type bounds are not allowed within structs, enums, or unions\n+  --> $DIR/inside-adt.rs:8:29\n+   |\n+LL | struct S1 { f: dyn Iterator<Item: Copy> }\n+   |                             ^^^^^^^^^^\n+\n+error: associated type bounds are not allowed within structs, enums, or unions\n+  --> $DIR/inside-adt.rs:11:33\n+   |\n+LL | struct S2 { f: Box<dyn Iterator<Item: Copy>> }\n+   |                                 ^^^^^^^^^^\n+\n+error: associated type bounds are not allowed within structs, enums, or unions\n+  --> $DIR/inside-adt.rs:14:29\n+   |\n+LL | struct S3 { f: dyn Iterator<Item: 'static> }\n+   |                             ^^^^^^^^^^^^^\n+\n+error: associated type bounds are not allowed within structs, enums, or unions\n+  --> $DIR/inside-adt.rs:18:26\n+   |\n+LL | enum E1 { V(dyn Iterator<Item: Copy>) }\n+   |                          ^^^^^^^^^^\n+\n+error: associated type bounds are not allowed within structs, enums, or unions\n+  --> $DIR/inside-adt.rs:21:30\n+   |\n+LL | enum E2 { V(Box<dyn Iterator<Item: Copy>>) }\n+   |                              ^^^^^^^^^^\n+\n+error: associated type bounds are not allowed within structs, enums, or unions\n+  --> $DIR/inside-adt.rs:24:26\n+   |\n+LL | enum E3 { V(dyn Iterator<Item: 'static>) }\n+   |                          ^^^^^^^^^^^^^\n+\n+error: associated type bounds are not allowed within structs, enums, or unions\n+  --> $DIR/inside-adt.rs:28:28\n+   |\n+LL | union U1 { f: dyn Iterator<Item: Copy> }\n+   |                            ^^^^^^^^^^\n+\n+error: associated type bounds are not allowed within structs, enums, or unions\n+  --> $DIR/inside-adt.rs:31:32\n+   |\n+LL | union U2 { f: Box<dyn Iterator<Item: Copy>> }\n+   |                                ^^^^^^^^^^\n+\n+error: associated type bounds are not allowed within structs, enums, or unions\n+  --> $DIR/inside-adt.rs:34:28\n+   |\n+LL | union U3 { f: dyn Iterator<Item: 'static> }\n+   |                            ^^^^^^^^^^^^^\n+\n+error[E0601]: `main` function not found in crate `inside_adt`\n+   |\n+   = note: consider adding a `main` function to `$DIR/inside-adt.rs`\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: aborting due to 19 previous errors\n+\n+For more information about this error, try `rustc --explain E0601`."}, {"sha": "85b6e804b4ef63cd2e1ad2f1dc81f6394089f696", "filename": "src/test/ui/associated-type-bounds/lcsit.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Flcsit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Flcsit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Flcsit.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,78 @@\n+// run-pass\n+\n+#![feature(associated_type_bounds)]\n+#![feature(impl_trait_in_bindings)]\n+\n+#![allow(non_upper_case_globals)]\n+\n+use std::ops::Add;\n+\n+trait Tr1 { type As1; fn mk(&self) -> Self::As1; }\n+trait Tr2<'a> { fn tr2(self) -> &'a Self; }\n+\n+fn assert_copy<T: Copy>(x: T) { let _x = x; let _x = x; }\n+fn assert_static<T: 'static>(_: T) {}\n+fn assert_forall_tr2<T: for<'a> Tr2<'a>>(_: T) {}\n+\n+#[derive(Copy, Clone)]\n+struct S1;\n+#[derive(Copy, Clone)]\n+struct S2;\n+impl Tr1 for S1 { type As1 = S2; fn mk(&self) -> Self::As1 { S2 } }\n+\n+const cdef_et1: impl Copy + Tr1<As1: Copy> = {\n+    let x: impl Copy + Tr1<As1: Copy> = S1;\n+    x\n+};\n+static sdef_et1: impl Copy + Tr1<As1: Copy> = cdef_et1;\n+pub fn use_et1() { assert_copy(cdef_et1.mk()); assert_copy(sdef_et1.mk()); }\n+\n+const cdef_et2: impl Tr1<As1: 'static> = {\n+    let x: impl Tr1<As1: 'static> = S1;\n+    x\n+};\n+static sdef_et2: impl Tr1<As1: 'static> = cdef_et2;\n+pub fn use_et2() { assert_static(cdef_et2.mk()); assert_static(sdef_et2.mk()); }\n+\n+const cdef_et3: impl Tr1<As1: Clone + Iterator<Item: Add<u8, Output: Into<u8>>>> = {\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = core::ops::Range<u8>;\n+        fn mk(&self) -> Self::As1 { 0..10 }\n+    };\n+    let x: impl Tr1<As1: Clone + Iterator<Item: Add<u8, Output: Into<u8>>>> = A;\n+    x\n+};\n+pub fn use_et3() {\n+    let _0 = cdef_et3.mk().clone();\n+    let mut s = 0u8;\n+    for _1 in _0 {\n+        let _2 = _1 + 1u8;\n+        s += _2.into();\n+    }\n+    assert_eq!(s, (0..10).map(|x| x + 1).sum());\n+}\n+\n+const cdef_et4: impl Copy + Tr1<As1: for<'a> Tr2<'a>> = {\n+    #[derive(Copy, Clone)]\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = A;\n+        fn mk(&self) -> A { A }\n+    }\n+    impl<'a> Tr2<'a> for A {\n+        fn tr2(self) -> &'a Self { &A }\n+    }\n+    let x: impl Copy + Tr1<As1: for<'a> Tr2<'a>> = A;\n+    x\n+};\n+\n+static sdef_et4: impl Copy + Tr1<As1: for<'a> Tr2<'a>> = cdef_et4;\n+pub fn use_et4() { assert_forall_tr2(cdef_et4.mk()); assert_forall_tr2(sdef_et4.mk()); }\n+\n+fn main() {\n+    let _ = use_et1();\n+    let _ = use_et2();\n+    let _ = use_et3();\n+    let _ = use_et4();\n+}"}, {"sha": "8fda11beddc4fe356ea610b5256912d8fed73d15", "filename": "src/test/ui/associated-type-bounds/lcsit.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Flcsit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Flcsit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Flcsit.stderr?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,6 @@\n+warning: the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash\n+  --> $DIR/lcsit.rs:4:12\n+   |\n+LL | #![feature(impl_trait_in_bindings)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^\n+"}, {"sha": "7b640d5a457dfceb283376a4c64c5b70d354fcf3", "filename": "src/test/ui/associated-type-bounds/rpit.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Frpit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Frpit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Frpit.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,64 @@\n+// run-pass\n+\n+#![feature(associated_type_bounds)]\n+\n+use std::ops::Add;\n+\n+trait Tr1 { type As1; fn mk(self) -> Self::As1; }\n+trait Tr2<'a> { fn tr2(self) -> &'a Self; }\n+\n+fn assert_copy<T: Copy>(x: T) { let _x = x; let _x = x; }\n+fn assert_static<T: 'static>(_: T) {}\n+fn assert_forall_tr2<T: for<'a> Tr2<'a>>(_: T) {}\n+\n+struct S1;\n+#[derive(Copy, Clone)]\n+struct S2;\n+impl Tr1 for S1 { type As1 = S2; fn mk(self) -> Self::As1 { S2 } }\n+\n+fn def_et1() -> impl Tr1<As1: Copy> { S1 }\n+pub fn use_et1() { assert_copy(def_et1().mk()); }\n+\n+fn def_et2() -> impl Tr1<As1: 'static> { S1 }\n+pub fn use_et2() { assert_static(def_et2().mk()); }\n+\n+fn def_et3() -> impl Tr1<As1: Clone + Iterator<Item: Add<u8, Output: Into<u8>>>> {\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = core::ops::Range<u8>;\n+        fn mk(self) -> Self::As1 { 0..10 }\n+    };\n+    A\n+}\n+\n+pub fn use_et3() {\n+    let _0 = def_et3().mk().clone();\n+    let mut s = 0u8;\n+    for _1 in _0 {\n+        let _2 = _1 + 1u8;\n+        s += _2.into();\n+    }\n+    assert_eq!(s, (0..10).map(|x| x + 1).sum());\n+}\n+\n+fn def_et4() -> impl Tr1<As1: for<'a> Tr2<'a>> {\n+    #[derive(Copy, Clone)]\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = A;\n+        fn mk(self) -> A { A }\n+    }\n+    impl<'a> Tr2<'a> for A {\n+        fn tr2(self) -> &'a Self { &A }\n+    }\n+    A\n+}\n+\n+pub fn use_et4() { assert_forall_tr2(def_et4().mk()); }\n+\n+fn main() {\n+    let _ = use_et1();\n+    let _ = use_et2();\n+    let _ = use_et3();\n+    let _ = use_et4();\n+}"}, {"sha": "2d189cd66724a33f51eba3a319bbb8021737c98f", "filename": "src/test/ui/associated-type-bounds/struct-bounds.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fstruct-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fstruct-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fstruct-bounds.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,115 @@\n+// run-pass\n+\n+#![feature(associated_type_bounds)]\n+\n+trait Tr1 { type As1; }\n+trait Tr2 { type As2; }\n+trait Tr3 {}\n+trait Tr4<'a> { type As4; }\n+trait Tr5 { type As5; }\n+\n+impl Tr1 for &str { type As1 = bool; }\n+impl Tr2 for bool { type As2 = u8; }\n+impl Tr3 for u8 {}\n+impl Tr1 for () { type As1 = (usize,); }\n+impl<'a> Tr4<'a> for (usize,) { type As4 = u8; }\n+impl Tr5 for bool { type As5 = u16; }\n+\n+struct St1<T: Tr1<As1: Tr2>> {\n+    outest: T,\n+    outer: T::As1,\n+    inner: <T::As1 as Tr2>::As2,\n+}\n+\n+fn unwrap_1_st1<T: Tr1<As1: Tr2>>(x: St1<T>) -> (T, T::As1, <T::As1 as Tr2>::As2) {\n+    (x.outest, x.outer, x.inner)\n+}\n+\n+fn unwrap_2_st1<T>(x: St1<T>) -> (T, T::As1, <T::As1 as Tr2>::As2)\n+where\n+    T: Tr1,\n+    T::As1: Tr2,\n+{\n+    unwrap_1_st1(x)\n+}\n+\n+struct St2<T: Tr1<As1: Tr2<As2: Tr3>>> {\n+    outest: T,\n+    outer: T::As1,\n+    inner: <T::As1 as Tr2>::As2,\n+}\n+\n+struct St3<T: Tr1<As1: 'static>> {\n+    outest: T,\n+    outer: &'static T::As1,\n+}\n+\n+struct St4<'x1, 'x2, T: Tr1<As1: for<'l> Tr4<'l>>> {\n+    f1: &'x1 <T::As1 as Tr4<'x1>>::As4,\n+    f2: &'x2 <T::As1 as Tr4<'x2>>::As4,\n+}\n+\n+struct St5<'x1, 'x2, T: Tr1<As1: for<'l> Tr4<'l, As4: Copy>>> {\n+    f1: &'x1 <T::As1 as Tr4<'x1>>::As4,\n+    f2: &'x2 <T::As1 as Tr4<'x2>>::As4,\n+}\n+\n+struct St6<T>\n+where\n+    T: Tr1<As1: Tr2 + 'static + Tr5>,\n+{\n+    f0: T,\n+    f1: <T::As1 as Tr2>::As2,\n+    f2: &'static T::As1,\n+    f3: <T::As1 as Tr5>::As5,\n+}\n+\n+struct St7<'a, 'b, T> // `<T::As1 as Tr2>::As2: 'a` is implied.\n+where\n+    T: Tr1<As1: Tr2>,\n+{\n+    f0: &'a T,\n+    f1: &'b <T::As1 as Tr2>::As2,\n+}\n+\n+fn _use_st7<'a, 'b, T>(x: St7<'a, 'b, T>)\n+where\n+    T: Tr1,\n+    T::As1: Tr2,\n+{\n+    let _: &'a T = &x.f0;\n+}\n+\n+struct StSelf<T> where Self: Tr1<As1: Tr2> {\n+    f2: <<Self as Tr1>::As1 as Tr2>::As2,\n+}\n+\n+impl Tr1 for StSelf<&'static str> { type As1 = bool; }\n+\n+fn main() {\n+    let st1 = St1 { outest: \"foo\", outer: true, inner: 42u8 };\n+    assert_eq!((\"foo\", true, 42), unwrap_1_st1(st1));\n+\n+    let _ = St2 { outest: \"foo\", outer: true, inner: 42u8 };\n+\n+    let _ = St3 { outest: \"foo\", outer: &true };\n+\n+    let f1 = (1,);\n+    let f2 = (2,);\n+    let st4 = St4::<()> { f1: &f1.0, f2: &f2.0, };\n+    assert_eq!((&1, &2), (st4.f1, st4.f2));\n+\n+    // FIXME: requires lazy normalization.\n+    /*\n+    let f1 = (1,);\n+    let f2 = (2,);\n+    let st5 = St5::<()> { f1: &f1.0, f2: &f2.0, };\n+    assert_eq!((&1, &2), (st5.f1, st5.f2));\n+    */\n+\n+    let st6 = St6 { f0: \"bar\", f1: 24u8, f2: &true, f3: 12u16, };\n+    assert_eq!((\"bar\", 24, &true, 12), (st6.f0, st6.f1, st6.f2, st6.f3));\n+\n+    let stself = StSelf::<&'static str> { f2: 42u8 };\n+    assert_eq!(stself.f2, 42u8);\n+}"}, {"sha": "a9081d50cfc5dd989c102a8dcca45b83bd9a50c6", "filename": "src/test/ui/associated-type-bounds/trait-params.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftrait-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftrait-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftrait-params.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,116 @@\n+// compile-pass\n+\n+#![feature(associated_type_bounds)]\n+\n+use std::iter::Once;\n+use std::ops::Range;\n+\n+pub trait Three { type A; type B; type C; }\n+pub fn assert_three<T: ?Sized + Three>() {}\n+pub fn assert_iterator<T: Iterator>() {}\n+pub fn assert_copy<T: Copy>() {}\n+pub fn assert_static<T: 'static>() {}\n+pub fn assert_send<T: Send>() {}\n+pub fn assert_forall_into<T: for<'a> Into<&'a u8>>() {}\n+\n+struct A; struct B;\n+impl<'a> Into<&'a u8> for A { fn into(self) -> &'a u8 { &0 } }\n+impl Three for B { type A = Range<u8>; type B = Range<u8>; type C = Range<u8>; }\n+\n+trait Case1<A, B, C, D, E>\n+where\n+    A: Iterator<Item: Copy>,\n+    B: Iterator<Item: 'static>,\n+    C: Iterator<Item: 'static + Copy + Send>,\n+    D: Iterator<Item: for<'a> Into<&'a u8>>,\n+    E: Three<A: Iterator<Item: Copy>, B: Iterator<Item: Copy>, C: Iterator<Item: Copy>>,\n+    Self: Three<A: 'static, B: Copy, C: Send>,\n+{\n+    fn _a() {\n+        assert_iterator::<A>();\n+        assert_copy::<A::Item>();\n+    }\n+    fn _b() {\n+        assert_iterator::<B>();\n+        assert_static::<B::Item>();\n+    }\n+    fn _c() {\n+        assert_iterator::<C>();\n+        assert_copy::<C::Item>();\n+        assert_static::<C::Item>();\n+        assert_send::<C::Item>();\n+    }\n+    fn _d() {\n+        assert_iterator::<D>();\n+        assert_forall_into::<D::Item>();\n+    }\n+    fn _e() {\n+        assert_three::<E>();\n+        assert_iterator::<E::A>();\n+        assert_iterator::<E::B>();\n+        assert_iterator::<E::C>();\n+        assert_copy::<<E::A as Iterator>::Item>();\n+        assert_copy::<<E::B as Iterator>::Item>();\n+        assert_copy::<<E::C as Iterator>::Item>();\n+    }\n+    fn _self() {\n+        assert_three::<Self>();\n+        assert_copy::<Self::B>();\n+        assert_static::<Self::A>();\n+        assert_send::<Self::C>();\n+    }\n+}\n+\n+struct DataCase1;\n+impl Three for DataCase1 { type A = u8; type B = u8; type C = u8; }\n+impl Case1<Range<u8>, Range<u8>, Range<u8>, Once<A>, B> for DataCase1 {}\n+\n+trait Case2<\n+    A: Iterator<Item: Copy>,\n+    B: Iterator<Item: 'static>,\n+    C: Iterator<Item: 'static + Copy + Send>,\n+    D: Iterator<Item: for<'a> Into<&'a u8>>,\n+    E: Three<A: Iterator<Item: Copy>, B: Iterator<Item: Copy>, C: Iterator<Item: Copy>>,\n+>:\n+    Three<A: 'static, B: Copy, C: Send>\n+{\n+    fn _a() {\n+        assert_iterator::<A>();\n+        assert_copy::<A::Item>();\n+    }\n+    fn _b() {\n+        assert_iterator::<B>();\n+        assert_static::<B::Item>();\n+    }\n+    fn _c() {\n+        assert_iterator::<C>();\n+        assert_copy::<C::Item>();\n+        assert_static::<C::Item>();\n+        assert_send::<C::Item>();\n+    }\n+    fn _d() {\n+        assert_iterator::<D>();\n+        assert_forall_into::<D::Item>();\n+    }\n+    fn _e() {\n+        assert_three::<E>();\n+        assert_iterator::<E::A>();\n+        assert_iterator::<E::B>();\n+        assert_iterator::<E::C>();\n+        assert_copy::<<E::A as Iterator>::Item>();\n+        assert_copy::<<E::B as Iterator>::Item>();\n+        assert_copy::<<E::C as Iterator>::Item>();\n+    }\n+    fn _self() {\n+        assert_three::<Self>();\n+        assert_copy::<Self::B>();\n+        assert_static::<Self::A>();\n+        assert_send::<Self::C>();\n+    }\n+}\n+\n+struct DataCase2;\n+impl Three for DataCase2 { type A = u8; type B = u8; type C = u8; }\n+impl Case2<Range<u8>, Range<u8>, Range<u8>, Once<A>, B> for DataCase2 {}\n+\n+fn main() {}"}, {"sha": "1602fdd275a2e9e7e5e16883e680c5efdf6f2f04", "filename": "src/test/ui/associated-type-bounds/type-alias.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftype-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftype-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftype-alias.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,19 @@\n+// compile-pass\n+\n+#![feature(associated_type_bounds)]\n+\n+type _TaWhere1<T> where T: Iterator<Item: Copy> = T;\n+type _TaWhere2<T> where T: Iterator<Item: 'static> = T;\n+type _TaWhere3<T> where T: Iterator<Item: 'static> = T;\n+type _TaWhere4<T> where T: Iterator<Item: 'static + Copy + Send> = T;\n+type _TaWhere5<T> where T: Iterator<Item: for<'a> Into<&'a u8>> = T;\n+type _TaWhere6<T> where T: Iterator<Item: Iterator<Item: Copy>> = T;\n+\n+type _TaInline1<T: Iterator<Item: Copy>> = T;\n+type _TaInline2<T: Iterator<Item: 'static>> = T;\n+type _TaInline3<T: Iterator<Item: 'static>> = T;\n+type _TaInline4<T: Iterator<Item: 'static + Copy + Send>> = T;\n+type _TaInline5<T: Iterator<Item: for<'a> Into<&'a u8>>> = T;\n+type _TaInline6<T: Iterator<Item: Iterator<Item: Copy>>> = T;\n+\n+fn main() {}"}, {"sha": "b93fc393ae32c9a02deff95e015a51f51a4e6e4a", "filename": "src/test/ui/associated-type-bounds/type-alias.stderr", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftype-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftype-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftype-alias.stderr?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,97 @@\n+warning: where clauses are not enforced in type aliases\n+  --> $DIR/type-alias.rs:5:25\n+   |\n+LL | type _TaWhere1<T> where T: Iterator<Item: Copy> = T;\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: #[warn(type_alias_bounds)] on by default\n+   = help: the clause will not be checked when the type alias is used, and should be removed\n+\n+warning: where clauses are not enforced in type aliases\n+  --> $DIR/type-alias.rs:6:25\n+   |\n+LL | type _TaWhere2<T> where T: Iterator<Item: 'static> = T;\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the clause will not be checked when the type alias is used, and should be removed\n+\n+warning: where clauses are not enforced in type aliases\n+  --> $DIR/type-alias.rs:7:25\n+   |\n+LL | type _TaWhere3<T> where T: Iterator<Item: 'static> = T;\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the clause will not be checked when the type alias is used, and should be removed\n+\n+warning: where clauses are not enforced in type aliases\n+  --> $DIR/type-alias.rs:8:25\n+   |\n+LL | type _TaWhere4<T> where T: Iterator<Item: 'static + Copy + Send> = T;\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the clause will not be checked when the type alias is used, and should be removed\n+\n+warning: where clauses are not enforced in type aliases\n+  --> $DIR/type-alias.rs:9:25\n+   |\n+LL | type _TaWhere5<T> where T: Iterator<Item: for<'a> Into<&'a u8>> = T;\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the clause will not be checked when the type alias is used, and should be removed\n+\n+warning: where clauses are not enforced in type aliases\n+  --> $DIR/type-alias.rs:10:25\n+   |\n+LL | type _TaWhere6<T> where T: Iterator<Item: Iterator<Item: Copy>> = T;\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the clause will not be checked when the type alias is used, and should be removed\n+\n+warning: bounds on generic parameters are not enforced in type aliases\n+  --> $DIR/type-alias.rs:12:20\n+   |\n+LL | type _TaInline1<T: Iterator<Item: Copy>> = T;\n+   |                    ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the bound will not be checked when the type alias is used, and should be removed\n+\n+warning: bounds on generic parameters are not enforced in type aliases\n+  --> $DIR/type-alias.rs:13:20\n+   |\n+LL | type _TaInline2<T: Iterator<Item: 'static>> = T;\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the bound will not be checked when the type alias is used, and should be removed\n+\n+warning: bounds on generic parameters are not enforced in type aliases\n+  --> $DIR/type-alias.rs:14:20\n+   |\n+LL | type _TaInline3<T: Iterator<Item: 'static>> = T;\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the bound will not be checked when the type alias is used, and should be removed\n+\n+warning: bounds on generic parameters are not enforced in type aliases\n+  --> $DIR/type-alias.rs:15:20\n+   |\n+LL | type _TaInline4<T: Iterator<Item: 'static + Copy + Send>> = T;\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the bound will not be checked when the type alias is used, and should be removed\n+\n+warning: bounds on generic parameters are not enforced in type aliases\n+  --> $DIR/type-alias.rs:16:20\n+   |\n+LL | type _TaInline5<T: Iterator<Item: for<'a> Into<&'a u8>>> = T;\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the bound will not be checked when the type alias is used, and should be removed\n+\n+warning: bounds on generic parameters are not enforced in type aliases\n+  --> $DIR/type-alias.rs:17:20\n+   |\n+LL | type _TaInline6<T: Iterator<Item: Iterator<Item: Copy>>> = T;\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the bound will not be checked when the type alias is used, and should be removed\n+"}, {"sha": "ce482fff401c886b989c5e4d9bce07d29881523a", "filename": "src/test/ui/associated-type-bounds/union-bounds.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Funion-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fassociated-type-bounds%2Funion-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Funion-bounds.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,123 @@\n+// run-pass\n+\n+#![feature(associated_type_bounds)]\n+#![feature(untagged_unions)]\n+\n+#![allow(unions_with_drop_fields, unused_assignments)]\n+\n+trait Tr1 { type As1; }\n+trait Tr2 { type As2; }\n+trait Tr3 { type As3; }\n+trait Tr4<'a> { type As4; }\n+trait Tr5 { type As5; }\n+\n+impl Tr1 for &str { type As1 = bool; }\n+impl Tr2 for bool { type As2 = u8; }\n+impl Tr3 for u8 { type As3 = fn() -> u8; }\n+impl Tr1 for () { type As1 = (usize,); }\n+impl<'a> Tr4<'a> for (usize,) { type As4 = u8; }\n+impl Tr5 for bool { type As5 = u16; }\n+\n+union Un1<T: Tr1<As1: Tr2>> {\n+    outest: T,\n+    outer: T::As1,\n+    inner: <T::As1 as Tr2>::As2,\n+}\n+\n+union Un2<T: Tr1<As1: Tr2<As2: Tr3>>> {\n+    outest: T,\n+    outer: T::As1,\n+    inner: <T::As1 as Tr2>::As2,\n+}\n+\n+union Un3<T: Tr1<As1: 'static>> {\n+    outest: T,\n+    outer: &'static T::As1,\n+}\n+\n+union Un4<'x1, 'x2, T: Tr1<As1: for<'l> Tr4<'l>>> {\n+    f1: &'x1 <T::As1 as Tr4<'x1>>::As4,\n+    f2: &'x2 <T::As1 as Tr4<'x2>>::As4,\n+}\n+\n+union _Un5<'x1, 'x2, T: Tr1<As1: for<'l> Tr4<'l, As4: Copy>>> {\n+    f1: &'x1 <T::As1 as Tr4<'x1>>::As4,\n+    f2: &'x2 <T::As1 as Tr4<'x2>>::As4,\n+}\n+\n+union Un6<T>\n+where\n+    T: Tr1<As1: Tr2 + 'static + Tr5>,\n+{\n+    f0: T,\n+    f1: <T::As1 as Tr2>::As2,\n+    f2: &'static T::As1,\n+    f3: <T::As1 as Tr5>::As5,\n+}\n+\n+union _Un7<'a, 'b, T> // `<T::As1 as Tr2>::As2: 'a` is implied.\n+where\n+    T: Tr1<As1: Tr2>,\n+{\n+    f0: &'a T,\n+    f1: &'b <T::As1 as Tr2>::As2,\n+}\n+\n+unsafe fn _use_un7<'a, 'b, T>(x: _Un7<'a, 'b, T>)\n+where\n+    T: Tr1,\n+    T::As1: Tr2,\n+{\n+    let _: &'a T = &x.f0;\n+}\n+\n+union UnSelf<T> where Self: Tr1<As1: Tr2> {\n+    f0: T,\n+    f1: <Self as Tr1>::As1,\n+    f2: <<Self as Tr1>::As1 as Tr2>::As2,\n+}\n+\n+impl Tr1 for UnSelf<&'static str> { type As1 = bool; }\n+\n+fn main() {\n+    let mut un1 = Un1 { outest: \"foo\" };\n+    un1 = Un1 { outer: true };\n+    assert_eq!(unsafe { un1.outer }, true);\n+    un1 = Un1 { inner: 42u8 };\n+    assert_eq!(unsafe { un1.inner }, 42u8);\n+\n+    let mut un2 = Un2 { outest: \"bar\" };\n+    assert_eq!(unsafe { un2.outest }, \"bar\");\n+    un2 = Un2 { outer: true };\n+    assert_eq!(unsafe { un2.outer }, true);\n+    un2 = Un2 { inner: 42u8 };\n+    assert_eq!(unsafe { un2.inner }, 42u8);\n+\n+    let mut un3 = Un3 { outest: \"baz\" };\n+    assert_eq!(unsafe { un3.outest }, \"baz\");\n+    un3 = Un3 { outer: &true };\n+    assert_eq!(unsafe { *un3.outer }, true);\n+\n+    let f1 = (1,);\n+    let f2 = (2,);\n+    let mut un4 = Un4::<()> { f1: &f1.0 };\n+    assert_eq!(1, unsafe { *un4.f1 });\n+    un4 = Un4 { f2: &f2.0 };\n+    assert_eq!(2, unsafe { *un4.f2 });\n+\n+    let mut un6 = Un6 { f0: \"bar\" };\n+    assert_eq!(unsafe { un6.f0 }, \"bar\");\n+    un6 = Un6 { f1: 24u8 };\n+    assert_eq!(unsafe { un6.f1 }, 24u8);\n+    un6 = Un6 { f2: &true };\n+    assert_eq!(unsafe { un6.f2 }, &true);\n+    un6 = Un6 { f3: 12u16 };\n+    assert_eq!(unsafe { un6.f3 }, 12u16);\n+\n+    let mut unself = UnSelf::<_> { f0: \"selfish\" };\n+    assert_eq!(unsafe { unself.f0 }, \"selfish\");\n+    unself = UnSelf { f1: true };\n+    assert_eq!(unsafe { unself.f1 }, true);\n+    unself = UnSelf { f2: 24u8 };\n+    assert_eq!(unsafe { unself.f2 }, 24u8);\n+}"}, {"sha": "f667de83b56d4dae87b780c6326089ce604a7b37", "filename": "src/test/ui/deprecation/deprecation-in-staged-api.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-in-staged-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-in-staged-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-in-staged-api.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -1,8 +1,8 @@\n-// #[deprecated] can't be used in staged api\n+// #[deprecated] cannot be used in staged API\n \n #![feature(staged_api)]\n \n #![stable(feature = \"stable_test_feature\", since = \"1.0.0\")]\n \n #[deprecated]\n-fn main() { } //~ERROR `#[deprecated]` cannot be used in staged api\n+fn main() { } //~ ERROR `#[deprecated]` cannot be used in staged API"}, {"sha": "c6881d5a5735f39b3be48b70863276a412c2df93", "filename": "src/test/ui/deprecation/deprecation-in-staged-api.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-in-staged-api.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-in-staged-api.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-in-staged-api.stderr?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -1,4 +1,4 @@\n-error: `#[deprecated]` cannot be used in staged api, use `#[rustc_deprecated]` instead\n+error: `#[deprecated]` cannot be used in staged API; use `#[rustc_deprecated]` instead\n   --> $DIR/deprecation-in-staged-api.rs:8:1\n    |\n LL | fn main() { }"}, {"sha": "04793c67b564d27a02c366c308521b7a5dc7ac5b", "filename": "src/test/ui/existential_types/no_revealing_outside_defining_module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fexistential_types%2Fno_revealing_outside_defining_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fexistential_types%2Fno_revealing_outside_defining_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fno_revealing_outside_defining_module.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -9,7 +9,7 @@ mod boo {\n     }\n }\n \n-// don't actually know the type here\n+// We don't actually know the type here.\n \n fn bomp2() {\n     let _: &str = bomp(); //~ ERROR mismatched types"}, {"sha": "3d75251e15616212c218228ec86194506ec1c04e", "filename": "src/test/ui/feature-gates/feature-gate-associated_type_bounds.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,72 @@\n+#![feature(untagged_unions)]\n+\n+trait Tr1 { type As1; }\n+trait Tr2 { type As2; }\n+\n+struct S1;\n+#[derive(Copy, Clone)]\n+struct S2;\n+impl Tr1 for S1 { type As1 = S2; }\n+\n+trait _Tr3 {\n+    type A: Iterator<Item: Copy>;\n+    //~^ ERROR associated type bounds are unstable\n+\n+    type B: Iterator<Item: 'static>;\n+    //~^ ERROR associated type bounds are unstable\n+}\n+\n+struct _St1<T: Tr1<As1: Tr2>> {\n+//~^ ERROR associated type bounds are unstable\n+    outest: T,\n+    outer: T::As1,\n+    inner: <T::As1 as Tr2>::As2,\n+}\n+\n+enum _En1<T: Tr1<As1: Tr2>> {\n+//~^ ERROR associated type bounds are unstable\n+    Outest(T),\n+    Outer(T::As1),\n+    Inner(<T::As1 as Tr2>::As2),\n+}\n+\n+union _Un1<T: Tr1<As1: Tr2>> {\n+//~^ ERROR associated type bounds are unstable\n+    outest: T,\n+    outer: T::As1,\n+    inner: <T::As1 as Tr2>::As2,\n+}\n+\n+type _TaWhere1<T> where T: Iterator<Item: Copy> = T;\n+//~^ ERROR associated type bounds are unstable\n+\n+fn _apit(_: impl Tr1<As1: Copy>) {}\n+//~^ ERROR associated type bounds are unstable\n+fn _apit_dyn(_: &dyn Tr1<As1: Copy>) {}\n+//~^ ERROR associated type bounds are unstable\n+\n+fn _rpit() -> impl Tr1<As1: Copy> { S1 }\n+//~^ ERROR associated type bounds are unstable\n+\n+fn _rpit_dyn() -> Box<dyn Tr1<As1: Copy>> { Box::new(S1) }\n+//~^ ERROR associated type bounds are unstable\n+\n+const _cdef: impl Tr1<As1: Copy> = S1;\n+//~^ ERROR associated type bounds are unstable\n+//~| ERROR `impl Trait` not allowed outside of function and inherent method return types [E0562]\n+// FIXME: uncomment when `impl_trait_in_bindings` feature is fixed.\n+// const _cdef_dyn: &dyn Tr1<As1: Copy> = &S1;\n+\n+static _sdef: impl Tr1<As1: Copy> = S1;\n+//~^ ERROR associated type bounds are unstable\n+//~| ERROR `impl Trait` not allowed outside of function and inherent method return types [E0562]\n+// FIXME: uncomment when `impl_trait_in_bindings` feature is fixed.\n+// static _sdef_dyn: &dyn Tr1<As1: Copy> = &S1;\n+\n+fn main() {\n+    let _: impl Tr1<As1: Copy> = S1;\n+    //~^ ERROR associated type bounds are unstable\n+    //~| ERROR `impl Trait` not allowed outside of function and inherent method return types [E0562]\n+    // FIXME: uncomment when `impl_trait_in_bindings` feature is fixed.\n+    // let _: &dyn Tr1<As1: Copy> = &S1;\n+}"}, {"sha": "702f61262df69f0a02739b9d59fdbd3e694efd45", "filename": "src/test/ui/feature-gates/feature-gate-associated_type_bounds.stderr", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.stderr?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,145 @@\n+error[E0658]: associated type bounds are unstable\n+  --> $DIR/feature-gate-associated_type_bounds.rs:12:22\n+   |\n+LL |     type A: Iterator<Item: Copy>;\n+   |                      ^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/52662\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable\n+  --> $DIR/feature-gate-associated_type_bounds.rs:15:22\n+   |\n+LL |     type B: Iterator<Item: 'static>;\n+   |                      ^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/52662\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable\n+  --> $DIR/feature-gate-associated_type_bounds.rs:19:20\n+   |\n+LL | struct _St1<T: Tr1<As1: Tr2>> {\n+   |                    ^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/52662\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable\n+  --> $DIR/feature-gate-associated_type_bounds.rs:26:18\n+   |\n+LL | enum _En1<T: Tr1<As1: Tr2>> {\n+   |                  ^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/52662\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable\n+  --> $DIR/feature-gate-associated_type_bounds.rs:33:19\n+   |\n+LL | union _Un1<T: Tr1<As1: Tr2>> {\n+   |                   ^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/52662\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable\n+  --> $DIR/feature-gate-associated_type_bounds.rs:40:37\n+   |\n+LL | type _TaWhere1<T> where T: Iterator<Item: Copy> = T;\n+   |                                     ^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/52662\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable\n+  --> $DIR/feature-gate-associated_type_bounds.rs:43:22\n+   |\n+LL | fn _apit(_: impl Tr1<As1: Copy>) {}\n+   |                      ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/52662\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable\n+  --> $DIR/feature-gate-associated_type_bounds.rs:45:26\n+   |\n+LL | fn _apit_dyn(_: &dyn Tr1<As1: Copy>) {}\n+   |                          ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/52662\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable\n+  --> $DIR/feature-gate-associated_type_bounds.rs:48:24\n+   |\n+LL | fn _rpit() -> impl Tr1<As1: Copy> { S1 }\n+   |                        ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/52662\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable\n+  --> $DIR/feature-gate-associated_type_bounds.rs:51:31\n+   |\n+LL | fn _rpit_dyn() -> Box<dyn Tr1<As1: Copy>> { Box::new(S1) }\n+   |                               ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/52662\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable\n+  --> $DIR/feature-gate-associated_type_bounds.rs:54:23\n+   |\n+LL | const _cdef: impl Tr1<As1: Copy> = S1;\n+   |                       ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/52662\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable\n+  --> $DIR/feature-gate-associated_type_bounds.rs:60:24\n+   |\n+LL | static _sdef: impl Tr1<As1: Copy> = S1;\n+   |                        ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/52662\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable\n+  --> $DIR/feature-gate-associated_type_bounds.rs:67:21\n+   |\n+LL |     let _: impl Tr1<As1: Copy> = S1;\n+   |                     ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/52662\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n+  --> $DIR/feature-gate-associated_type_bounds.rs:54:14\n+   |\n+LL | const _cdef: impl Tr1<As1: Copy> = S1;\n+   |              ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(impl_trait_in_bindings)] to the crate attributes to enable\n+\n+error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n+  --> $DIR/feature-gate-associated_type_bounds.rs:60:15\n+   |\n+LL | static _sdef: impl Tr1<As1: Copy> = S1;\n+   |               ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(impl_trait_in_bindings)] to the crate attributes to enable\n+\n+error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n+  --> $DIR/feature-gate-associated_type_bounds.rs:67:12\n+   |\n+LL |     let _: impl Tr1<As1: Copy> = S1;\n+   |            ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(impl_trait_in_bindings)] to the crate attributes to enable\n+\n+error: aborting due to 16 previous errors\n+\n+Some errors have detailed explanations: E0562, E0658.\n+For more information about an error, try `rustc --explain E0562`."}, {"sha": "b1e4edd998094cb1233ef6457c185030a9663acc", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -5,7 +5,7 @@ LL | fn elided(x: &i32) -> impl Copy { x }\n    |              -        ^^^^^^^^^ opaque type requires that `'1` must outlive `'static`\n    |              |\n    |              let's call the lifetime of this reference `'1`\n-help: to allow this impl Trait to capture borrowed data with lifetime `'1`, add `'_` as a constraint\n+help: to allow this `impl Trait` to capture borrowed data with lifetime `'1`, add `'_` as a constraint\n    |\n LL | fn elided(x: &i32) -> impl Copy + '_ { x }\n    |                       ^^^^^^^^^^^^^^\n@@ -17,7 +17,7 @@ LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n    |             --                 ^^^^^^^^^ opaque type requires that `'a` must outlive `'static`\n    |             |\n    |             lifetime `'a` defined here\n-help: to allow this impl Trait to capture borrowed data with lifetime `'a`, add `'a` as a constraint\n+help: to allow this `impl Trait` to capture borrowed data with lifetime `'a`, add `'a` as a constraint\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy + 'a { x }\n    |                                ^^^^^^^^^^^^^^"}, {"sha": "0736f25cb51bd8bf4bf4a0ec9bc844964698d799", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -5,7 +5,7 @@ LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n    |                         -         ^^^^^^^^^^^^^^^^^^^^^^^ opaque type requires that `'1` must outlive `'static`\n    |                         |\n    |                         let's call the lifetime of this reference `'1`\n-help: to allow this impl Trait to capture borrowed data with lifetime `'1`, add `'_` as a constraint\n+help: to allow this `impl Trait` to capture borrowed data with lifetime `'1`, add `'_` as a constraint\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -17,7 +17,7 @@ LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n    |                    --               ^^^^^^^^^^^^^^^^^^^^^^^ opaque type requires that `'a` must outlive `'static`\n    |                    |\n    |                    lifetime `'a` defined here\n-help: to allow this impl Trait to capture borrowed data with lifetime `'a`, add `'a` as a constraint\n+help: to allow this `impl Trait` to capture borrowed data with lifetime `'a`, add `'a` as a constraint\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> + 'a {\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "c4f6e0212621fba8ae924db16cddf38219ac3ee3", "filename": "src/test/ui/pattern/const-pat-ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.stderr?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -1,5 +1,5 @@\n thread 'rustc' panicked at 'assertion failed: rows.iter().all(|r| r.len() == v.len())', src/librustc_mir/hair/pattern/_match.rs:1085:5\n-note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n+note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n error: internal compiler error: unexpected panic\n "}, {"sha": "7539cbada8b7b5a258d4993fc1ad08fedad63372", "filename": "src/test/ui/symbol-names/basic.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.stderr?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,14 @@\n+error: symbol-name(_ZN5basic4main17hd72940ef9669d526E)\n+  --> $DIR/basic.rs:3:1\n+   |\n+LL | #[rustc_symbol_name]\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: def-path(main)\n+  --> $DIR/basic.rs:4:1\n+   |\n+LL | #[rustc_def_path]\n+   | ^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "20e48782a3a9e5dfeafeab1c854b5cc9234155e6", "filename": "src/test/ui/symbol-names/impl1.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.stderr?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -0,0 +1,26 @@\n+error: symbol-name(_ZN5impl13foo3Foo3bar17he53b9bee7600ed8dE)\n+  --> $DIR/impl1.rs:8:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: def-path(foo::Foo::bar)\n+  --> $DIR/impl1.rs:9:9\n+   |\n+LL |         #[rustc_def_path]\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: symbol-name(_ZN5impl13bar33_$LT$impl$u20$impl1..foo..Foo$GT$3baz17h86c41f0462d901d4E)\n+  --> $DIR/impl1.rs:18:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: def-path(bar::<impl foo::Foo>::baz)\n+  --> $DIR/impl1.rs:19:9\n+   |\n+LL |         #[rustc_def_path]\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "f3cc5becc6f74c5f5515dbae2a5910c8557c4d38", "filename": "src/test/ui/type/type-alias-bounds.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Ftype%2Ftype-alias-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Ftype%2Ftype-alias-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-alias-bounds.rs?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -1,44 +1,44 @@\n-// Test ignored_generic_bounds lint warning about bounds in type aliases\n+// Test `ignored_generic_bounds` lint warning about bounds in type aliases.\n \n // compile-pass\n #![allow(dead_code)]\n \n use std::rc::Rc;\n \n-type SVec<T: Send+Send> = Vec<T>;\n+type SVec<T: Send + Send> = Vec<T>;\n //~^ WARN bounds on generic parameters are not enforced in type aliases [type_alias_bounds]\n type S2Vec<T> where T: Send = Vec<T>;\n //~^ WARN where clauses are not enforced in type aliases [type_alias_bounds]\n-type VVec<'b, 'a: 'b+'b> = (&'b u32, Vec<&'a i32>);\n+type VVec<'b, 'a: 'b + 'b> = (&'b u32, Vec<&'a i32>);\n //~^ WARN bounds on generic parameters are not enforced in type aliases [type_alias_bounds]\n-type WVec<'b, T: 'b+'b> = (&'b u32, Vec<T>);\n+type WVec<'b, T: 'b + 'b> = (&'b u32, Vec<T>);\n //~^ WARN bounds on generic parameters are not enforced in type aliases [type_alias_bounds]\n type W2Vec<'b, T> where T: 'b, T: 'b = (&'b u32, Vec<T>);\n //~^ WARN where clauses are not enforced in type aliases [type_alias_bounds]\n \n-static STATIC : u32 = 0;\n+static STATIC: u32 = 0;\n \n fn foo<'a>(y: &'a i32) {\n     // If any of the bounds above would matter, the code below would be rejected.\n     // This can be seen when replacing the type aliases above by newtype structs.\n     // (The type aliases have no unused parameters to make that a valid transformation.)\n-    let mut x : SVec<_> = Vec::new();\n+    let mut x: SVec<_> = Vec::new();\n     x.push(Rc::new(42)); // is not send\n \n-    let mut x : S2Vec<_> = Vec::new();\n-    x.push(Rc::new(42)); // is not send\n+    let mut x: S2Vec<_> = Vec::new();\n+    x.push(Rc::new(42)); // is not `Send`\n \n-    let mut x : VVec<'static, 'a> = (&STATIC, Vec::new());\n-    x.1.push(y); // 'a: 'static does not hold\n+    let mut x: VVec<'static, 'a> = (&STATIC, Vec::new());\n+    x.1.push(y); // `'a: 'static` does not hold\n \n-    let mut x : WVec<'static, &'a i32> = (&STATIC, Vec::new());\n-    x.1.push(y); // &'a i32: 'static does not hold\n+    let mut x: WVec<'static, &'a i32> = (&STATIC, Vec::new());\n+    x.1.push(y); // `&'a i32: 'static` does not hold\n \n-    let mut x : W2Vec<'static, &'a i32> = (&STATIC, Vec::new());\n-    x.1.push(y); // &'a i32: 'static does not hold\n+    let mut x: W2Vec<'static, &'a i32> = (&STATIC, Vec::new());\n+    x.1.push(y); // `&'a i32: 'static` does not hold\n }\n \n-// Bounds are not checked either, i.e., the definition is not necessarily well-formed\n+// Bounds are not checked either; i.e., the definition is not necessarily well-formed.\n struct Sendable<T: Send>(T);\n type MySendable<T> = Sendable<T>; // no error here!\n \n@@ -47,9 +47,9 @@ trait Bound { type Assoc; }\n type T1<U: Bound> = U::Assoc; //~ WARN not enforced in type aliases\n type T2<U> where U: Bound = U::Assoc;  //~ WARN not enforced in type aliases\n \n-// This errors\n-// type T3<U> = U::Assoc;\n-// Do this instead\n+// This errors:\n+// `type T3<U> = U::Assoc;`\n+// Do this instead:\n type T4<U> = <U as Bound>::Assoc;\n \n // Make sure the help about associatd types is not shown incorrectly"}, {"sha": "177e5f893ed662333786b77d16ea0dd049d03592", "filename": "src/test/ui/type/type-alias-bounds.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Ftype%2Ftype-alias-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/740668dbd99dbf1726bbb0cca6cd0943ea2f7e27/src%2Ftest%2Fui%2Ftype%2Ftype-alias-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-alias-bounds.stderr?ref=740668dbd99dbf1726bbb0cca6cd0943ea2f7e27", "patch": "@@ -1,8 +1,8 @@\n warning: bounds on generic parameters are not enforced in type aliases\n   --> $DIR/type-alias-bounds.rs:8:14\n    |\n-LL | type SVec<T: Send+Send> = Vec<T>;\n-   |              ^^^^ ^^^^\n+LL | type SVec<T: Send + Send> = Vec<T>;\n+   |              ^^^^   ^^^^\n    |\n    = note: #[warn(type_alias_bounds)] on by default\n    = help: the bound will not be checked when the type alias is used, and should be removed\n@@ -18,16 +18,16 @@ LL | type S2Vec<T> where T: Send = Vec<T>;\n warning: bounds on generic parameters are not enforced in type aliases\n   --> $DIR/type-alias-bounds.rs:12:19\n    |\n-LL | type VVec<'b, 'a: 'b+'b> = (&'b u32, Vec<&'a i32>);\n-   |                   ^^ ^^\n+LL | type VVec<'b, 'a: 'b + 'b> = (&'b u32, Vec<&'a i32>);\n+   |                   ^^   ^^\n    |\n    = help: the bound will not be checked when the type alias is used, and should be removed\n \n warning: bounds on generic parameters are not enforced in type aliases\n   --> $DIR/type-alias-bounds.rs:14:18\n    |\n-LL | type WVec<'b, T: 'b+'b> = (&'b u32, Vec<T>);\n-   |                  ^^ ^^\n+LL | type WVec<'b, T: 'b + 'b> = (&'b u32, Vec<T>);\n+   |                  ^^   ^^\n    |\n    = help: the bound will not be checked when the type alias is used, and should be removed\n "}]}