{"sha": "b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1YmFiODVjMWE0MWJjZDc3NThmYjgwOTBhM2NmM2JhMjBlMzNiNDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-05T07:26:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-05T07:26:19Z"}, "message": "auto merge of #10796 : kballard/rust/revert-new-naming, r=alexcrichton\n\nRename the `*::init()` functions back to `*::new()`, since `new` is not\r\ngoing to become a keyword.", "tree": {"sha": "ca9f9e55e2369c253cedd265d7273553370cfb8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca9f9e55e2369c253cedd265d7273553370cfb8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "html_url": "https://github.com/rust-lang/rust/commit/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10c8409c786b8ee43c00fadfa1be6ebbfc846a91", "url": "https://api.github.com/repos/rust-lang/rust/commits/10c8409c786b8ee43c00fadfa1be6ebbfc846a91", "html_url": "https://github.com/rust-lang/rust/commit/10c8409c786b8ee43c00fadfa1be6ebbfc846a91"}, {"sha": "b1705714d5a13e9057db364b685c7cce7cc27982", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1705714d5a13e9057db364b685c7cce7cc27982", "html_url": "https://github.com/rust-lang/rust/commit/b1705714d5a13e9057db364b685c7cce7cc27982"}], "stats": {"total": 1255, "additions": 627, "deletions": 628}, "files": [{"sha": "0f39b29c60a9e80d96b45e767a81ef3289b3c84e", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -103,15 +103,15 @@ pub fn parse_config(args: ~[~str]) -> config {\n     }\n \n     fn opt_path(m: &getopts::Matches, nm: &str) -> Path {\n-        Path::init(m.opt_str(nm).unwrap())\n+        Path::new(m.opt_str(nm).unwrap())\n     }\n \n     config {\n         compile_lib_path: matches.opt_str(\"compile-lib-path\").unwrap(),\n         run_lib_path: matches.opt_str(\"run-lib-path\").unwrap(),\n         rustc_path: opt_path(matches, \"rustc-path\"),\n-        clang_path: matches.opt_str(\"clang-path\").map(|s| Path::init(s)),\n-        llvm_bin_path: matches.opt_str(\"llvm-bin-path\").map(|s| Path::init(s)),\n+        clang_path: matches.opt_str(\"clang-path\").map(|s| Path::new(s)),\n+        llvm_bin_path: matches.opt_str(\"llvm-bin-path\").map(|s| Path::new(s)),\n         src_base: opt_path(matches, \"src-base\"),\n         build_base: opt_path(matches, \"build-base\"),\n         aux_base: opt_path(matches, \"aux-base\"),\n@@ -124,10 +124,10 @@ pub fn parse_config(args: ~[~str]) -> config {\n             } else {\n                 None\n             },\n-        logfile: matches.opt_str(\"logfile\").map(|s| Path::init(s)),\n-        save_metrics: matches.opt_str(\"save-metrics\").map(|s| Path::init(s)),\n+        logfile: matches.opt_str(\"logfile\").map(|s| Path::new(s)),\n+        save_metrics: matches.opt_str(\"save-metrics\").map(|s| Path::new(s)),\n         ratchet_metrics:\n-            matches.opt_str(\"ratchet-metrics\").map(|s| Path::init(s)),\n+            matches.opt_str(\"ratchet-metrics\").map(|s| Path::new(s)),\n         ratchet_noise_percent:\n             matches.opt_str(\"ratchet-noise-percent\").and_then(|s| from_str::<f64>(s)),\n         runtool: matches.opt_str(\"runtool\"),"}, {"sha": "1966701dbdedda584910ab7d685458c09f122650", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -160,10 +160,10 @@ fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n \n fn parse_pp_exact(line: &str, testfile: &Path) -> Option<Path> {\n     match parse_name_value_directive(line, ~\"pp-exact\") {\n-      Some(s) => Some(Path::init(s)),\n+      Some(s) => Some(Path::new(s)),\n       None => {\n         if parse_name_directive(line, \"pp-exact\") {\n-            testfile.filename().map(|s| Path::init(s))\n+            testfile.filename().map(|s| Path::new(s))\n         } else {\n             None\n         }"}, {"sha": "8e2f2dff9fe1201fdc3603da781639a9c694337f", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -45,7 +45,7 @@ pub fn run_metrics(config: config, testfile: ~str, mm: &mut MetricMap) {\n         // We're going to be dumping a lot of info. Start on a new line.\n         print!(\"\\n\\n\");\n     }\n-    let testfile = Path::init(testfile);\n+    let testfile = Path::new(testfile);\n     debug!(\"running {}\", testfile.display());\n     let props = load_props(&testfile);\n     debug!(\"loaded props\");\n@@ -852,7 +852,7 @@ fn aux_output_dir_name(config: &config, testfile: &Path) -> Path {\n }\n \n fn output_testname(testfile: &Path) -> Path {\n-    Path::init(testfile.filestem().unwrap())\n+    Path::new(testfile.filestem().unwrap())\n }\n \n fn output_base_name(config: &config, testfile: &Path) -> Path {"}, {"sha": "e398a10ecf138a4f9f85145e85b6680bc5d5bfb4", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -90,7 +90,7 @@ pub fn glob_with(pattern: &str, options: MatchOptions) -> GlobIterator {\n \n     // calculate root this way to handle volume-relative Windows paths correctly\n     let mut root = os::getcwd();\n-    let pat_root = Path::init(pattern).root_path();\n+    let pat_root = Path::new(pattern).root_path();\n     if pat_root.is_some() {\n         if check_windows_verbatim(pat_root.get_ref()) {\n             // XXX: How do we want to handle verbatim paths? I'm inclined to return nothing,\n@@ -766,9 +766,9 @@ mod test {\n \n     #[test]\n     fn test_matches_path() {\n-        // on windows, (Path::init(\"a/b\").as_str().unwrap() == \"a\\\\b\"), so this\n+        // on windows, (Path::new(\"a/b\").as_str().unwrap() == \"a\\\\b\"), so this\n         // tests that / and \\ are considered equivalent on windows\n-        assert!(Pattern::new(\"a/b\").matches_path(&Path::init(\"a/b\")));\n+        assert!(Pattern::new(\"a/b\").matches_path(&Path::new(\"a/b\")));\n     }\n }\n "}, {"sha": "46a04abebe54f5cb2f7e07f50ba43d821a9df998", "filename": "src/libextra/json.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -91,7 +91,7 @@ pub struct Encoder<'self> {\n impl<'self> Encoder<'self> {\n     /// Creates a new JSON encoder whose output will be written to the writer\n     /// specified.\n-    pub fn init<'a>(wr: &'a mut io::Writer) -> Encoder<'a> {\n+    pub fn new<'a>(wr: &'a mut io::Writer) -> Encoder<'a> {\n         Encoder { wr: wr }\n     }\n }\n@@ -247,7 +247,7 @@ pub struct PrettyEncoder<'self> {\n \n impl<'self> PrettyEncoder<'self> {\n     /// Creates a new encoder whose output will be written to the specified writer\n-    pub fn init<'a>(wr: &'a mut io::Writer) -> PrettyEncoder<'a> {\n+    pub fn new<'a>(wr: &'a mut io::Writer) -> PrettyEncoder<'a> {\n         PrettyEncoder {\n             wr: wr,\n             indent: 0,\n@@ -449,14 +449,14 @@ impl<E: serialize::Encoder> serialize::Encodable<E> for Json {\n impl Json{\n     /// Encodes a json value into a io::writer.  Uses a single line.\n     pub fn to_writer(&self, wr: &mut io::Writer) {\n-        let mut encoder = Encoder::init(wr);\n+        let mut encoder = Encoder::new(wr);\n         self.encode(&mut encoder)\n     }\n \n     /// Encodes a json value into a io::writer.\n     /// Pretty-prints in a more readable format.\n     pub fn to_pretty_writer(&self, wr: &mut io::Writer) {\n-        let mut encoder = PrettyEncoder::init(wr);\n+        let mut encoder = PrettyEncoder::new(wr);\n         self.encode(&mut encoder)\n     }\n \n@@ -477,7 +477,7 @@ pub struct Parser<T> {\n \n impl<T: Iterator<char>> Parser<T> {\n     /// Decode a json value from an Iterator<char>\n-    pub fn init(rdr: T) -> Parser<T> {\n+    pub fn new(rdr: T) -> Parser<T> {\n         let mut p = Parser {\n             rdr: rdr,\n             ch: '\\x00',\n@@ -848,13 +848,13 @@ impl<T : Iterator<char>> Parser<T> {\n /// Decodes a json value from an `&mut io::Reader`\n pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, Error> {\n     let s = str::from_utf8_owned(rdr.read_to_end());\n-    let mut parser = Parser::init(s.chars());\n+    let mut parser = Parser::new(s.chars());\n     parser.parse()\n }\n \n /// Decodes a json value from a string\n pub fn from_str(s: &str) -> Result<Json, Error> {\n-    let mut parser = Parser::init(s.chars());\n+    let mut parser = Parser::new(s.chars());\n     parser.parse()\n }\n \n@@ -865,7 +865,7 @@ pub struct Decoder {\n \n impl Decoder {\n     /// Creates a new decoder instance for decoding the specified JSON value.\n-    pub fn init(json: Json) -> Decoder {\n+    pub fn new(json: Json) -> Decoder {\n         Decoder {\n             stack: ~[json]\n         }\n@@ -1522,14 +1522,14 @@ mod tests {\n         let animal = Dog;\n         assert_eq!(\n             with_str_writer(|wr| {\n-                let mut encoder = Encoder::init(wr);\n+                let mut encoder = Encoder::new(wr);\n                 animal.encode(&mut encoder);\n             }),\n             ~\"\\\"Dog\\\"\"\n         );\n         assert_eq!(\n             with_str_writer(|wr| {\n-                let mut encoder = PrettyEncoder::init(wr);\n+                let mut encoder = PrettyEncoder::new(wr);\n                 animal.encode(&mut encoder);\n             }),\n             ~\"\\\"Dog\\\"\"\n@@ -1538,14 +1538,14 @@ mod tests {\n         let animal = Frog(~\"Henry\", 349);\n         assert_eq!(\n             with_str_writer(|wr| {\n-                let mut encoder = Encoder::init(wr);\n+                let mut encoder = Encoder::new(wr);\n                 animal.encode(&mut encoder);\n             }),\n             ~\"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\"\n         );\n         assert_eq!(\n             with_str_writer(|wr| {\n-                let mut encoder = PrettyEncoder::init(wr);\n+                let mut encoder = PrettyEncoder::new(wr);\n                 animal.encode(&mut encoder);\n             }),\n             ~\"\\\n@@ -1561,14 +1561,14 @@ mod tests {\n     fn test_write_some() {\n         let value = Some(~\"jodhpurs\");\n         let s = with_str_writer(|wr| {\n-            let mut encoder = Encoder::init(wr);\n+            let mut encoder = Encoder::new(wr);\n             value.encode(&mut encoder);\n         });\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n \n         let value = Some(~\"jodhpurs\");\n         let s = with_str_writer(|wr| {\n-            let mut encoder = PrettyEncoder::init(wr);\n+            let mut encoder = PrettyEncoder::new(wr);\n             value.encode(&mut encoder);\n         });\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n@@ -1578,13 +1578,13 @@ mod tests {\n     fn test_write_none() {\n         let value: Option<~str> = None;\n         let s = with_str_writer(|wr| {\n-            let mut encoder = Encoder::init(wr);\n+            let mut encoder = Encoder::new(wr);\n             value.encode(&mut encoder);\n         });\n         assert_eq!(s, ~\"null\");\n \n         let s = with_str_writer(|wr| {\n-            let mut encoder = Encoder::init(wr);\n+            let mut encoder = Encoder::new(wr);\n             value.encode(&mut encoder);\n         });\n         assert_eq!(s, ~\"null\");\n@@ -1633,15 +1633,15 @@ mod tests {\n \n     #[test]\n     fn test_decode_identifiers() {\n-        let mut decoder = Decoder::init(from_str(\"null\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"null\").unwrap());\n         let v: () = Decodable::decode(&mut decoder);\n         assert_eq!(v, ());\n \n-        let mut decoder = Decoder::init(from_str(\"true\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"true\").unwrap());\n         let v: bool = Decodable::decode(&mut decoder);\n         assert_eq!(v, true);\n \n-        let mut decoder = Decoder::init(from_str(\"false\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"false\").unwrap());\n         let v: bool = Decodable::decode(&mut decoder);\n         assert_eq!(v, false);\n     }\n@@ -1676,31 +1676,31 @@ mod tests {\n \n     #[test]\n     fn test_decode_numbers() {\n-        let mut decoder = Decoder::init(from_str(\"3\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"3\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 3.0);\n \n-        let mut decoder = Decoder::init(from_str(\"3.1\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"3.1\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 3.1);\n \n-        let mut decoder = Decoder::init(from_str(\"-1.2\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"-1.2\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, -1.2);\n \n-        let mut decoder = Decoder::init(from_str(\"0.4\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"0.4\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4);\n \n-        let mut decoder = Decoder::init(from_str(\"0.4e5\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"0.4e5\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e5);\n \n-        let mut decoder = Decoder::init(from_str(\"0.4e15\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"0.4e15\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e15);\n \n-        let mut decoder = Decoder::init(from_str(\"0.4e-01\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"0.4e-01\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e-01);\n     }\n@@ -1728,39 +1728,39 @@ mod tests {\n \n     #[test]\n     fn test_decode_str() {\n-        let mut decoder = Decoder::init(from_str(\"\\\"\\\"\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\");\n \n-        let mut decoder = Decoder::init(from_str(\"\\\"foo\\\"\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"\\\"foo\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"foo\");\n \n-        let mut decoder = Decoder::init(from_str(\"\\\"\\\\\\\"\\\"\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\\\\\"\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\\"\");\n \n-        let mut decoder = Decoder::init(from_str(\"\\\"\\\\b\\\"\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\\b\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\x08\");\n \n-        let mut decoder = Decoder::init(from_str(\"\\\"\\\\n\\\"\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\\n\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\n\");\n \n-        let mut decoder = Decoder::init(from_str(\"\\\"\\\\r\\\"\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\\r\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\r\");\n \n-        let mut decoder = Decoder::init(from_str(\"\\\"\\\\t\\\"\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\\t\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\t\");\n \n-        let mut decoder = Decoder::init(from_str(\"\\\"\\\\u12ab\\\"\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\\u12ab\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\u12ab\");\n \n-        let mut decoder = Decoder::init(from_str(\"\\\"\\\\uAB12\\\"\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\\uAB12\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\uAB12\");\n     }\n@@ -1793,27 +1793,27 @@ mod tests {\n \n     #[test]\n     fn test_decode_list() {\n-        let mut decoder = Decoder::init(from_str(\"[]\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"[]\").unwrap());\n         let v: ~[()] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[]);\n \n-        let mut decoder = Decoder::init(from_str(\"[null]\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"[null]\").unwrap());\n         let v: ~[()] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[()]);\n \n-        let mut decoder = Decoder::init(from_str(\"[true]\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"[true]\").unwrap());\n         let v: ~[bool] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[true]);\n \n-        let mut decoder = Decoder::init(from_str(\"[true]\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"[true]\").unwrap());\n         let v: ~[bool] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[true]);\n \n-        let mut decoder = Decoder::init(from_str(\"[3, 1]\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"[3, 1]\").unwrap());\n         let v: ~[int] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[3, 1]);\n \n-        let mut decoder = Decoder::init(from_str(\"[[3], [1, 2]]\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"[[3], [1, 2]]\").unwrap());\n         let v: ~[~[uint]] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[~[3], ~[1, 2]]);\n     }\n@@ -1915,7 +1915,7 @@ mod tests {\n                 { \\\"a\\\": null, \\\"b\\\": 2, \\\"c\\\": [\\\"abc\\\", \\\"xyz\\\"] }\n             ]\n         }\";\n-        let mut decoder = Decoder::init(from_str(s).unwrap());\n+        let mut decoder = Decoder::new(from_str(s).unwrap());\n         let v: Outer = Decodable::decode(&mut decoder);\n         assert_eq!(\n             v,\n@@ -1929,31 +1929,31 @@ mod tests {\n \n     #[test]\n     fn test_decode_option() {\n-        let mut decoder = Decoder::init(from_str(\"null\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"null\").unwrap());\n         let value: Option<~str> = Decodable::decode(&mut decoder);\n         assert_eq!(value, None);\n \n-        let mut decoder = Decoder::init(from_str(\"\\\"jodhpurs\\\"\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"\\\"jodhpurs\\\"\").unwrap());\n         let value: Option<~str> = Decodable::decode(&mut decoder);\n         assert_eq!(value, Some(~\"jodhpurs\"));\n     }\n \n     #[test]\n     fn test_decode_enum() {\n-        let mut decoder = Decoder::init(from_str(\"\\\"Dog\\\"\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"\\\"Dog\\\"\").unwrap());\n         let value: Animal = Decodable::decode(&mut decoder);\n         assert_eq!(value, Dog);\n \n         let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n-        let mut decoder = Decoder::init(from_str(s).unwrap());\n+        let mut decoder = Decoder::new(from_str(s).unwrap());\n         let value: Animal = Decodable::decode(&mut decoder);\n         assert_eq!(value, Frog(~\"Henry\", 349));\n     }\n \n     #[test]\n     fn test_decode_map() {\n         let s = ~\"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n-        let mut decoder = Decoder::init(from_str(s).unwrap());\n+        let mut decoder = Decoder::new(from_str(s).unwrap());\n         let mut map: TreeMap<~str, Animal> = Decodable::decode(&mut decoder);\n \n         assert_eq!(map.pop(&~\"a\"), Some(Dog));\n@@ -1990,7 +1990,7 @@ mod tests {\n             match from_str(to_parse) {\n                 Err(e) => Some(e.to_str()),\n                 Ok(json) => {\n-                    let _: T = Decodable::decode(&mut Decoder::init(json));\n+                    let _: T = Decodable::decode(&mut Decoder::new(json));\n                     None\n                 }\n             }"}, {"sha": "09f8cc0efef4003eac116014d9d8a8bb62e27540", "filename": "src/libextra/terminfo/searcher.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fsearcher.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -29,7 +29,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n \n     // Find search directory\n     match getenv(\"TERMINFO\") {\n-        Some(dir) => dirs_to_search.push(Path::init(dir)),\n+        Some(dir) => dirs_to_search.push(Path::new(dir)),\n         None => {\n             if homedir.is_some() {\n                 // ncurses compatability;\n@@ -38,17 +38,17 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n             match getenv(\"TERMINFO_DIRS\") {\n                 Some(dirs) => for i in dirs.split(':') {\n                     if i == \"\" {\n-                        dirs_to_search.push(Path::init(\"/usr/share/terminfo\"));\n+                        dirs_to_search.push(Path::new(\"/usr/share/terminfo\"));\n                     } else {\n-                        dirs_to_search.push(Path::init(i.to_owned()));\n+                        dirs_to_search.push(Path::new(i.to_owned()));\n                     }\n                 },\n                 // Found nothing, use the default paths\n                 // /usr/share/terminfo is the de facto location, but it seems\n                 // Ubuntu puts it in /lib/terminfo\n                 None => {\n-                    dirs_to_search.push(Path::init(\"/usr/share/terminfo\"));\n-                    dirs_to_search.push(Path::init(\"/lib/terminfo\"));\n+                    dirs_to_search.push(Path::new(\"/usr/share/terminfo\"));\n+                    dirs_to_search.push(Path::new(\"/lib/terminfo\"));\n                 }\n             }\n         }"}, {"sha": "818cc49511fa3b6b3f91f2e309504e026e20f3d5", "filename": "src/libextra/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -276,20 +276,20 @@ pub fn parse_opts(args: &[~str]) -> Option<OptRes> {\n     let run_ignored = matches.opt_present(\"ignored\");\n \n     let logfile = matches.opt_str(\"logfile\");\n-    let logfile = logfile.map(|s| Path::init(s));\n+    let logfile = logfile.map(|s| Path::new(s));\n \n     let run_benchmarks = matches.opt_present(\"bench\");\n     let run_tests = ! run_benchmarks ||\n         matches.opt_present(\"test\");\n \n     let ratchet_metrics = matches.opt_str(\"ratchet-metrics\");\n-    let ratchet_metrics = ratchet_metrics.map(|s| Path::init(s));\n+    let ratchet_metrics = ratchet_metrics.map(|s| Path::new(s));\n \n     let ratchet_noise_percent = matches.opt_str(\"ratchet-noise-percent\");\n     let ratchet_noise_percent = ratchet_noise_percent.map(|s| from_str::<f64>(s).unwrap());\n \n     let save_metrics = matches.opt_str(\"save-metrics\");\n-    let save_metrics = save_metrics.map(|s| Path::init(s));\n+    let save_metrics = save_metrics.map(|s| Path::new(s));\n \n     let test_shard = matches.opt_str(\"test-shard\");\n     let test_shard = opt_shard(test_shard);\n@@ -947,7 +947,7 @@ impl MetricMap {\n         assert!(p.exists());\n         let mut f = File::open(p);\n         let value = json::from_reader(&mut f as &mut io::Reader).unwrap();\n-        let mut decoder = json::Decoder::init(value);\n+        let mut decoder = json::Decoder::new(value);\n         MetricMap(Decodable::decode(&mut decoder))\n     }\n "}, {"sha": "0afc8c08d4c400e341e9169ee85fb8b500013c23", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -191,7 +191,7 @@ impl Database {\n                     Err(e) => fail!(\"Couldn't parse workcache database (from file {}): {}\",\n                                     self.db_filename.display(), e.to_str()),\n                     Ok(r) => {\n-                        let mut decoder = json::Decoder::init(r);\n+                        let mut decoder = json::Decoder::new(r);\n                         self.db_cache = Decodable::decode(&mut decoder);\n                     }\n             }\n@@ -258,7 +258,7 @@ enum Work<'self, T> {\n \n fn json_encode<'self, T:Encodable<json::Encoder<'self>>>(t: &T) -> ~str {\n     let mut writer = MemWriter::new();\n-    let mut encoder = json::Encoder::init(&mut writer as &mut io::Writer);\n+    let mut encoder = json::Encoder::new(&mut writer as &mut io::Writer);\n     t.encode(&mut encoder);\n     str::from_utf8_owned(writer.inner())\n }\n@@ -267,7 +267,7 @@ fn json_encode<'self, T:Encodable<json::Encoder<'self>>>(t: &T) -> ~str {\n fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n     debug!(\"json decoding: {}\", s);\n     let j = json::from_str(s).unwrap();\n-    let mut decoder = json::Decoder::init(j);\n+    let mut decoder = json::Decoder::new(j);\n     Decodable::decode(&mut decoder)\n }\n "}, {"sha": "2dd53f7d514a5ca019eec47c956e6546fe86aee2", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -70,10 +70,10 @@ impl Archive {\n             let loc = TempDir::new(\"rsar\").unwrap();\n             let archive = os::make_absolute(&self.dst);\n             run_ar(self.sess, \"x\", Some(loc.path()), [&archive,\n-                                                      &Path::init(file)]);\n+                                                      &Path::new(file)]);\n             fs::File::open(&loc.path().join(file)).read_to_end()\n         } else {\n-            run_ar(self.sess, \"p\", None, [&self.dst, &Path::init(file)]).output\n+            run_ar(self.sess, \"p\", None, [&self.dst, &Path::new(file)]).output\n         }\n     }\n "}, {"sha": "dae4a9df3da96e9f2aebb1ac8b75bd4b0578c924", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -160,7 +160,7 @@ pub fn get_install_prefix_rpath(target_triple: &str) -> ~str {\n     let install_prefix = env!(\"CFG_PREFIX\");\n \n     let tlib = filesearch::relative_target_lib_path(target_triple);\n-    let mut path = Path::init(install_prefix);\n+    let mut path = Path::new(install_prefix);\n     path.push(&tlib);\n     let path = os::make_absolute(&path);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -195,7 +195,7 @@ mod test {\n     #[test]\n     fn test_prefix_rpath() {\n         let res = get_install_prefix_rpath(\"triple\");\n-        let mut d = Path::init(env!(\"CFG_PREFIX\"));\n+        let mut d = Path::new(env!(\"CFG_PREFIX\"));\n         d.push(\"lib/rustc/triple/lib\");\n         debug!(\"test_prefix_path: {} vs. {}\",\n                res,\n@@ -206,7 +206,7 @@ mod test {\n     #[test]\n     fn test_prefix_rpath_abs() {\n         let res = get_install_prefix_rpath(\"triple\");\n-        assert!(Path::init(res).is_absolute());\n+        assert!(Path::new(res).is_absolute());\n     }\n \n     #[test]\n@@ -230,7 +230,7 @@ mod test {\n     fn test_rpath_relative() {\n       let o = abi::OsLinux;\n       let res = get_rpath_relative_to_output(o,\n-            &Path::init(\"bin/rustc\"), &Path::init(\"lib/libstd.so\"));\n+            &Path::new(\"bin/rustc\"), &Path::new(\"lib/libstd.so\"));\n       assert_eq!(res.as_slice(), \"$ORIGIN/../lib\");\n     }\n \n@@ -239,7 +239,7 @@ mod test {\n     fn test_rpath_relative() {\n         let o = abi::OsFreebsd;\n         let res = get_rpath_relative_to_output(o,\n-            &Path::init(\"bin/rustc\"), &Path::init(\"lib/libstd.so\"));\n+            &Path::new(\"bin/rustc\"), &Path::new(\"lib/libstd.so\"));\n         assert_eq!(res.as_slice(), \"$ORIGIN/../lib\");\n     }\n \n@@ -248,15 +248,15 @@ mod test {\n     fn test_rpath_relative() {\n         let o = abi::OsMacos;\n         let res = get_rpath_relative_to_output(o,\n-                                               &Path::init(\"bin/rustc\"),\n-                                               &Path::init(\"lib/libstd.so\"));\n+                                               &Path::new(\"bin/rustc\"),\n+                                               &Path::new(\"lib/libstd.so\"));\n         assert_eq!(res.as_slice(), \"@loader_path/../lib\");\n     }\n \n     #[test]\n     fn test_get_absolute_rpath() {\n-        let res = get_absolute_rpath(&Path::init(\"lib/libstd.so\"));\n-        let lib = os::make_absolute(&Path::init(\"lib\"));\n+        let res = get_absolute_rpath(&Path::new(\"lib/libstd.so\"));\n+        let lib = os::make_absolute(&Path::new(\"lib\"));\n         debug!(\"test_get_absolute_rpath: {} vs. {}\",\n                res.to_str(), lib.display());\n "}, {"sha": "4559a1230bd1430191be3b21069a19b2cb0f4015", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -725,7 +725,7 @@ pub fn build_session_options(binary: @str,\n         } else if matches.opt_present(\"emit-llvm\") {\n             link::output_type_bitcode\n         } else { link::output_type_exe };\n-    let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| @Path::init(m));\n+    let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| @Path::new(m));\n     let target = matches.opt_str(\"target\").unwrap_or(host_triple());\n     let target_cpu = matches.opt_str(\"target-cpu\").unwrap_or(~\"generic\");\n     let target_feature = matches.opt_str(\"target-feature\").unwrap_or(~\"\");\n@@ -757,7 +757,7 @@ pub fn build_session_options(binary: @str,\n         extra_debuginfo;\n \n     let addl_lib_search_paths = matches.opt_strs(\"L\").map(|s| {\n-        Path::init(s.as_slice())\n+        Path::new(s.as_slice())\n     }).move_iter().collect();\n     let ar = matches.opt_str(\"ar\");\n     let linker = matches.opt_str(\"linker\");"}, {"sha": "438dc03b76621a2802a52aeca8b67e5e712d0b9f", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -249,16 +249,16 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n             let src = str::from_utf8_owned(io::stdin().read_to_end());\n             str_input(src.to_managed())\n         } else {\n-            file_input(Path::init(ifile))\n+            file_input(Path::new(ifile))\n         }\n       }\n       _ => early_error(demitter, \"multiple input filenames provided\")\n     };\n \n     let sopts = build_session_options(binary, matches, demitter);\n     let sess = build_session(sopts, demitter);\n-    let odir = matches.opt_str(\"out-dir\").map(|o| Path::init(o));\n-    let ofile = matches.opt_str(\"o\").map(|o| Path::init(o));\n+    let odir = matches.opt_str(\"out-dir\").map(|o| Path::new(o));\n+    let ofile = matches.opt_str(\"o\").map(|o| Path::new(o));\n     let cfg = build_configuration(sess);\n     let pretty = matches.opt_default(\"pretty\", \"normal\").map(|a| {\n         parse_pretty(sess, a)"}, {"sha": "67b684a2c514c49fe2a3209d72a601b1cab6e275", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -134,7 +134,7 @@ fn visit_view_item(e: @mut Env, i: &ast::view_item) {\n           let meta_items = match path_opt {\n               None => meta_items.clone(),\n               Some((p, _path_str_style)) => {\n-                  let p_path = Path::init(p);\n+                  let p_path = Path::new(p);\n                   match p_path.filestem_str() {\n                       None|Some(\"\") =>\n                           e.sess.span_bug(i.span, \"Bad package path in `extern mod` item\"),"}, {"sha": "456a08f6d08c0b9cb3ade9dfe319ac6645043108", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -145,7 +145,7 @@ pub fn search(filesearch: @FileSearch, pick: pick) {\n \n pub fn relative_target_lib_path(target_triple: &str) -> Path {\n     let dir = libdir();\n-    let mut p = Path::init(dir.as_slice());\n+    let mut p = Path::new(dir.as_slice());\n     assert!(p.is_relative());\n     p.push(\"rustc\");\n     p.push(target_triple);\n@@ -199,7 +199,7 @@ pub fn rust_path() -> ~[Path] {\n         Some(env_path) => {\n             let env_path_components: ~[&str] =\n                 env_path.split_str(PATH_ENTRY_SEPARATOR).collect();\n-            env_path_components.map(|&s| Path::init(s))\n+            env_path_components.map(|&s| Path::new(s))\n         }\n         None => ~[]\n     };"}, {"sha": "0df4820d822c3936b0045bea88e1b1c0ae40de0b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -336,7 +336,7 @@ fn mkdir(path: &Path) {\n /// static HTML tree.\n // FIXME (#9639): The closure should deal with &[u8] instead of &str\n fn clean_srcpath(src: &[u8], f: |&str|) {\n-    let p = Path::init(src);\n+    let p = Path::new(src);\n     if p.as_vec() != bytes!(\".\") {\n         for c in p.str_components().map(|x|x.unwrap()) {\n             if \"..\" == c {\n@@ -411,7 +411,7 @@ impl<'self> DocFolder for SourceCollector<'self> {\n impl<'self> SourceCollector<'self> {\n     /// Renders the given filename into its corresponding HTML source file.\n     fn emit_source(&mut self, filename: &str) -> bool {\n-        let p = Path::init(filename);\n+        let p = Path::new(filename);\n \n         // Read the contents of the file\n         let mut contents = ~[];"}, {"sha": "8d6fd5cd9dc9be0f185e4c2b231cefe336716f84", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -140,13 +140,13 @@ pub fn main_args(args: &[~str]) -> int {\n \n     info!(\"going to format\");\n     let started = time::precise_time_ns();\n-    let output = matches.opt_str(\"o\").map(|s| Path::init(s));\n+    let output = matches.opt_str(\"o\").map(|s| Path::new(s));\n     match matches.opt_str(\"w\") {\n         Some(~\"html\") | None => {\n-            html::render::run(crate, output.unwrap_or(Path::init(\"doc\")))\n+            html::render::run(crate, output.unwrap_or(Path::new(\"doc\")))\n         }\n         Some(~\"json\") => {\n-            json_output(crate, res, output.unwrap_or(Path::init(\"doc.json\")))\n+            json_output(crate, res, output.unwrap_or(Path::new(\"doc.json\")))\n         }\n         Some(s) => {\n             println!(\"unknown output format: {}\", s);\n@@ -194,9 +194,9 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     let mut plugins = matches.opt_strs(\"plugins\");\n \n     // First, parse the crate and extract all relevant information.\n-    let libs = Cell::new(matches.opt_strs(\"L\").map(|s| Path::init(s.as_slice())));\n+    let libs = Cell::new(matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice())));\n     let cfgs = Cell::new(matches.opt_strs(\"cfg\"));\n-    let cr = Cell::new(Path::init(cratefile));\n+    let cr = Cell::new(Path::new(cratefile));\n     info!(\"starting to run rustc\");\n     let (crate, analysis) = do std::task::try {\n         let cr = cr.take();\n@@ -238,7 +238,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n \n     // Load all plugins/passes into a PluginManager\n     let path = matches.opt_str(\"plugin-path\").unwrap_or(~\"/tmp/rustdoc_ng/plugins\");\n-    let mut pm = plugins::PluginManager::new(Path::init(path));\n+    let mut pm = plugins::PluginManager::new(Path::new(path));\n     for pass in passes.iter() {\n         let plugin = match PASSES.iter().position(|&(p, _, _)| p == *pass) {\n             Some(i) => PASSES[i].n1(),\n@@ -262,7 +262,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n /// This input format purely deserializes the json output file. No passes are\n /// run over the deserialized output.\n fn json_input(input: &str) -> Result<Output, ~str> {\n-    let input = match File::open(&Path::init(input)) {\n+    let input = match File::open(&Path::new(input)) {\n         Some(f) => f,\n         None => return Err(format!(\"couldn't open {} for reading\", input)),\n     };\n@@ -283,7 +283,7 @@ fn json_input(input: &str) -> Result<Output, ~str> {\n             }\n             let crate = match obj.pop(&~\"crate\") {\n                 Some(json) => {\n-                    let mut d = json::Decoder::init(json);\n+                    let mut d = json::Decoder::new(json);\n                     Decodable::decode(&mut d)\n                 }\n                 None => return Err(~\"malformed json\"),\n@@ -314,7 +314,7 @@ fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n     let crate_json_str = {\n         let mut w = MemWriter::new();\n         {\n-            let mut encoder = json::Encoder::init(&mut w as &mut io::Writer);\n+            let mut encoder = json::Encoder::new(&mut w as &mut io::Writer);\n             crate.encode(&mut encoder);\n         }\n         str::from_utf8_owned(w.inner())"}, {"sha": "0d0d0b7c4c79d8af2492f83f5c5f12e0589aa0c9", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -56,12 +56,12 @@ pub fn new_default_context(c: workcache::Context, p: Path) -> BuildContext {\n }\n \n fn file_is_fresh(path: &str, in_hash: &str) -> bool {\n-    let path = Path::init(path);\n+    let path = Path::new(path);\n     path.exists() && in_hash == digest_file_with_date(&path)\n }\n \n fn binary_is_fresh(path: &str, in_hash: &str) -> bool {\n-    let path = Path::init(path);\n+    let path = Path::new(path);\n     path.exists() && in_hash == digest_only_date(&path)\n }\n \n@@ -189,7 +189,7 @@ pub fn my_workspace(context: &Context, package_name: &str) -> Path {\n     let pkgid = PkgId::new(package_name);\n     let workspaces = pkg_parent_workspaces(context, &pkgid);\n     if workspaces.is_empty() {\n-        bad_pkg_id.raise((Path::init(package_name), package_name.to_owned()));\n+        bad_pkg_id.raise((Path::new(package_name), package_name.to_owned()));\n     }\n     workspaces[0]\n }"}, {"sha": "8c696b2b84494f0d1425eba33394652ecc10f48e", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -483,7 +483,7 @@ impl CtxMethods for BuildContext {\n                     })\n                 });\n                 // We always *run* the package script\n-                let (cfgs, hook_result) = PkgScript::run_custom(&Path::init(pkg_exe), &sysroot);\n+                let (cfgs, hook_result) = PkgScript::run_custom(&Path::new(pkg_exe), &sysroot);\n                 debug!(\"Command return code = {:?}\", hook_result);\n                 if !hook_result.success() {\n                     fail!(\"Error running custom build command\")\n@@ -509,7 +509,7 @@ impl CtxMethods for BuildContext {\n                 // Find crates inside the workspace\n                 Everything => pkg_src.find_crates(),\n                 // Find only tests\n-                Tests => pkg_src.find_crates_with_filter(|s| { is_test(&Path::init(s)) }),\n+                Tests => pkg_src.find_crates_with_filter(|s| { is_test(&Path::new(s)) }),\n                 // Don't infer any crates -- just build the one that was requested\n                 JustOne(ref p) => {\n                     // We expect that p is relative to the package source's start directory,\n@@ -588,7 +588,7 @@ impl CtxMethods for BuildContext {\n         let result = self.install_no_build(pkg_src.build_workspace(),\n                                            build_inputs,\n                                            &pkg_src.destination_workspace,\n-                                           &id).map(|s| Path::init(s.as_slice()));\n+                                           &id).map(|s| Path::new(s.as_slice()));\n         installed_files = installed_files + result;\n         note(format!(\"Installed package {} to {}\",\n                      id.to_str(),\n@@ -709,10 +709,10 @@ impl CtxMethods for BuildContext {\n     }\n \n     fn init(&self) {\n-        fs::mkdir_recursive(&Path::init(\"src\"), io::UserRWX);\n-        fs::mkdir_recursive(&Path::init(\"bin\"), io::UserRWX);\n-        fs::mkdir_recursive(&Path::init(\"lib\"), io::UserRWX);\n-        fs::mkdir_recursive(&Path::init(\"build\"), io::UserRWX);\n+        fs::mkdir_recursive(&Path::new(\"src\"), io::UserRWX);\n+        fs::mkdir_recursive(&Path::new(\"bin\"), io::UserRWX);\n+        fs::mkdir_recursive(&Path::new(\"lib\"), io::UserRWX);\n+        fs::mkdir_recursive(&Path::new(\"build\"), io::UserRWX);\n     }\n \n     fn uninstall(&self, _id: &str, _vers: Option<~str>)  {\n@@ -894,7 +894,7 @@ pub fn main_args(args: &[~str]) -> int {\n     let mut remaining_args: ~[~str] = remaining_args.map(|s| (*s).clone()).collect();\n     remaining_args.shift();\n     let sroot = match supplied_sysroot {\n-        Some(s) => Path::init(s),\n+        Some(s) => Path::new(s),\n         _ => filesearch::get_or_default_sysroot()\n     };\n "}, {"sha": "04ac30e3732876930c05bf9f855dcc03081babd8", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -58,7 +58,7 @@ impl PkgId {\n             }\n         };\n \n-        let path = Path::init(s);\n+        let path = Path::new(s);\n         if !path.is_relative() {\n             return cond.raise((path, ~\"absolute pkgid\"));\n         }\n@@ -136,8 +136,8 @@ impl Iterator<(Path, Path)> for Prefixes {\n             let last = self.components.pop();\n             self.remaining.unshift(last);\n             // converting to str and then back is a little unfortunate\n-            Some((Path::init(self.components.connect(\"/\")),\n-                  Path::init(self.remaining.connect(\"/\"))))\n+            Some((Path::new(self.components.connect(\"/\")),\n+                  Path::new(self.remaining.connect(\"/\"))))\n         }\n     }\n }"}, {"sha": "b89d4f55258432a0141a34c37051efb8936409ad", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -332,7 +332,7 @@ impl PkgSrc {\n             it.nth(prefix-1); // skip elements\n         }\n         assert!(it.peek().is_some());\n-        let mut sub = Path::init(\".\");\n+        let mut sub = Path::new(\".\");\n         for c in it {\n             sub.push(c);\n         }\n@@ -414,11 +414,11 @@ impl PkgSrc {\n                                                     (k.clone(), p.as_str().unwrap().to_owned()));\n                 prep.exec(proc(exec) {\n                     for &(ref kind, ref p) in inputs.iter() {\n-                        let pth = Path::init(p.clone());\n+                        let pth = Path::new(p.clone());\n                         exec.discover_input(*kind, *p, if *kind == ~\"file\" {\n                                 digest_file_with_date(&pth)\n                             } else if *kind == ~\"binary\" {\n-                                digest_only_date(&Path::init(p.clone()))\n+                                digest_only_date(&Path::new(p.clone()))\n                             } else {\n                                 fail!(\"Bad kind in build_crates\")\n                             });"}, {"sha": "6136be2e8d30bc3adc28de74890dab5cbca03c1e", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -64,23 +64,23 @@ fn fake_ctxt(sysroot: Path, workspace: &Path) -> BuildContext {\n fn fake_pkg() -> PkgId {\n     let sn = ~\"bogus\";\n     PkgId {\n-        path: Path::init(sn.as_slice()),\n+        path: Path::new(sn.as_slice()),\n         short_name: sn,\n         version: NoVersion\n     }\n }\n \n fn git_repo_pkg() -> PkgId {\n     PkgId {\n-        path: Path::init(\"mockgithub.com/catamorphism/test-pkg\"),\n+        path: Path::new(\"mockgithub.com/catamorphism/test-pkg\"),\n         short_name: ~\"test-pkg\",\n         version: NoVersion\n     }\n }\n \n fn git_repo_pkg_with_tag(a_tag: ~str) -> PkgId {\n     PkgId {\n-        path: Path::init(\"mockgithub.com/catamorphism/test-pkg\"),\n+        path: Path::new(\"mockgithub.com/catamorphism/test-pkg\"),\n         short_name: ~\"test-pkg\",\n         version: Tagged(a_tag)\n     }\n@@ -480,7 +480,7 @@ fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~\n fn lib_output_file_name(workspace: &Path, short_name: &str) -> Path {\n     debug!(\"lib_output_file_name: given {} and short name {}\",\n            workspace.display(), short_name);\n-    library_in_workspace(&Path::init(short_name),\n+    library_in_workspace(&Path::new(short_name),\n                          short_name,\n                          Build,\n                          workspace,\n@@ -753,12 +753,12 @@ fn test_package_ids_must_be_relative_path_like() {\n     });\n \n     cond.trap(|(p, e)| {\n-        let abs = os::make_absolute(&Path::init(\"foo/bar/quux\"));\n+        let abs = os::make_absolute(&Path::new(\"foo/bar/quux\"));\n         assert_eq!(p, abs);\n         assert!(\"absolute pkgid\" == e);\n         whatever.clone()\n     }).inside(|| {\n-        let zp = os::make_absolute(&Path::init(\"foo/bar/quux\"));\n+        let zp = os::make_absolute(&Path::new(\"foo/bar/quux\"));\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let z = PkgId::new(zp.as_str().unwrap());\n         assert_eq!(~\"foo-0.1\", z.to_str());\n@@ -769,7 +769,7 @@ fn test_package_ids_must_be_relative_path_like() {\n #[test]\n fn test_package_version() {\n     let local_path = \"mockgithub.com/catamorphism/test_pkg_version\";\n-    let repo = init_git_repo(&Path::init(local_path));\n+    let repo = init_git_repo(&Path::new(local_path));\n     let repo = repo.path();\n     let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test_pkg_version\"]);\n     debug!(\"Writing files in: {}\", repo_subdir.display());\n@@ -809,7 +809,7 @@ fn test_package_version() {\n #[test]\n fn test_package_request_version() {\n     let local_path = \"mockgithub.com/catamorphism/test_pkg_version\";\n-    let repo = init_git_repo(&Path::init(local_path));\n+    let repo = init_git_repo(&Path::new(local_path));\n     let repo = repo.path();\n     let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test_pkg_version\"]);\n     debug!(\"Writing files in: {}\", repo_subdir.display());\n@@ -828,7 +828,7 @@ fn test_package_request_version() {\n \n     command_line_test([~\"install\", format!(\"{}\\\\#0.3\", local_path)], repo);\n \n-    assert!(match installed_library_in_workspace(&Path::init(\"test_pkg_version\"),\n+    assert!(match installed_library_in_workspace(&Path::new(\"test_pkg_version\"),\n                                                  &repo.join(\".rust\")) {\n         Some(p) => {\n             debug!(\"installed: {}\", p.display());\n@@ -842,7 +842,7 @@ fn test_package_request_version() {\n             == repo.join_many([\".rust\", \"bin\", \"test_pkg_version\"]));\n \n     let mut dir = target_build_dir(&repo.join(\".rust\"));\n-    dir.push(&Path::init(\"src/mockgithub.com/catamorphism/test_pkg_version-0.3\"));\n+    dir.push(&Path::new(\"src/mockgithub.com/catamorphism/test_pkg_version-0.3\"));\n     debug!(\"dir = {}\", dir.display());\n     assert!(dir.is_dir());\n     assert!(dir.join(\"version-0.3-file.txt\").exists());\n@@ -859,7 +859,7 @@ fn rustpkg_install_url_2() {\n \n #[test]\n fn rustpkg_library_target() {\n-    let foo_repo = init_git_repo(&Path::init(\"foo\"));\n+    let foo_repo = init_git_repo(&Path::new(\"foo\"));\n     let foo_repo = foo_repo.path();\n     let package_dir = foo_repo.join(\"foo\");\n \n@@ -875,7 +875,7 @@ fn rustpkg_library_target() {\n \n     add_git_tag(&package_dir, ~\"1.0\");\n     command_line_test([~\"install\", ~\"foo\"], foo_repo);\n-    assert_lib_exists(&foo_repo.join(\".rust\"), &Path::init(\"foo\"), ExactRevision(~\"1.0\"));\n+    assert_lib_exists(&foo_repo.join(\".rust\"), &Path::new(\"foo\"), ExactRevision(~\"1.0\"));\n }\n \n #[test]\n@@ -893,12 +893,12 @@ fn package_script_with_default_build() {\n     debug!(\"dir = {}\", dir.display());\n     let mut source = test_sysroot().dir_path();\n     source.pop(); source.pop();\n-    let source = Path::init(file!()).dir_path().join_many(\n+    let source = Path::new(file!()).dir_path().join_many(\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"fancy-lib\", ~\"pkg.rs\"]);\n     debug!(\"package_script_with_default_build: {}\", source.display());\n     fs::copy(&source, &dir.join_many([\"src\", \"fancy-lib-0.1\", \"pkg.rs\"]));\n     command_line_test([~\"install\", ~\"fancy-lib\"], dir);\n-    assert_lib_exists(dir, &Path::init(\"fancy-lib\"), NoVersion);\n+    assert_lib_exists(dir, &Path::new(\"fancy-lib\"), NoVersion);\n     assert!(target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"]).exists());\n     let generated_path = target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"]);\n     debug!(\"generated path = {}\", generated_path.display());\n@@ -929,7 +929,7 @@ fn rustpkg_install_no_arg() {\n               \"fn main() { let _x = (); }\");\n     debug!(\"install_no_arg: dir = {}\", package_dir.display());\n     command_line_test([~\"install\"], &package_dir);\n-    assert_lib_exists(&tmp, &Path::init(\"foo\"), NoVersion);\n+    assert_lib_exists(&tmp, &Path::new(\"foo\"), NoVersion);\n }\n \n #[test]\n@@ -952,7 +952,7 @@ fn rustpkg_clean_no_arg() {\n #[test]\n fn rust_path_test() {\n     let dir_for_path = TempDir::new(\"more_rust\").expect(\"rust_path_test failed\");\n-    let dir = mk_workspace(dir_for_path.path(), &Path::init(\"foo\"), &NoVersion);\n+    let dir = mk_workspace(dir_for_path.path(), &Path::new(\"foo\"), &NoVersion);\n     debug!(\"dir = {}\", dir.display());\n     writeFile(&dir.join(\"main.rs\"), \"fn main() { let _x = (); }\");\n \n@@ -993,9 +993,9 @@ fn rust_path_contents() {\n fn rust_path_parse() {\n     os::setenv(\"RUST_PATH\", \"/a/b/c:/d/e/f:/g/h/i\");\n     let paths = rust_path();\n-    assert!(paths.contains(&Path::init(\"/g/h/i\")));\n-    assert!(paths.contains(&Path::init(\"/d/e/f\")));\n-    assert!(paths.contains(&Path::init(\"/a/b/c\")));\n+    assert!(paths.contains(&Path::new(\"/g/h/i\")));\n+    assert!(paths.contains(&Path::new(\"/d/e/f\")));\n+    assert!(paths.contains(&Path::new(\"/a/b/c\")));\n     os::unsetenv(\"RUST_PATH\");\n }\n \n@@ -1375,8 +1375,8 @@ fn multiple_workspaces() {\n // Copy the exact same package into directory B and install it\n // Set the RUST_PATH to A:B\n // Make a third package that uses foo, make sure we can build/install it\n-    let (a_loc, _pkg_dir) = mk_temp_workspace(&Path::init(\"foo\"), &NoVersion);\n-    let (b_loc, _pkg_dir) = mk_temp_workspace(&Path::init(\"foo\"), &NoVersion);\n+    let (a_loc, _pkg_dir) = mk_temp_workspace(&Path::new(\"foo\"), &NoVersion);\n+    let (b_loc, _pkg_dir) = mk_temp_workspace(&Path::new(\"foo\"), &NoVersion);\n     let (a_loc, b_loc) = (a_loc.path(), b_loc.path());\n     debug!(\"Trying to install foo in {}\", a_loc.display());\n     command_line_test([~\"install\", ~\"foo\"], a_loc);\n@@ -1401,7 +1401,7 @@ fn rust_path_hack_test(hack_flag: bool) {\n    let p_id = PkgId::new(\"foo\");\n    let workspace = create_local_package(&p_id);\n    let workspace = workspace.path();\n-   let dest_workspace = mk_empty_workspace(&Path::init(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n    let dest_workspace = dest_workspace.path();\n    let foo_path = workspace.join_many([\"src\", \"foo-0.1\"]);\n    let rust_path = Some(~[(~\"RUST_PATH\",\n@@ -1410,11 +1410,11 @@ fn rust_path_hack_test(hack_flag: bool) {\n                foo_path.as_str().unwrap()))]);\n    command_line_test_with_env(~[~\"install\"] + if hack_flag { ~[~\"--rust-path-hack\"] } else { ~[] } +\n                                ~[~\"foo\"], dest_workspace, rust_path);\n-   assert_lib_exists(dest_workspace, &Path::init(\"foo\"), NoVersion);\n+   assert_lib_exists(dest_workspace, &Path::new(\"foo\"), NoVersion);\n    assert_executable_exists(dest_workspace, \"foo\");\n    assert_built_library_exists(dest_workspace, \"foo\");\n    assert_built_executable_exists(dest_workspace, \"foo\");\n-   assert!(!lib_exists(workspace, &Path::init(\"foo\"), NoVersion));\n+   assert!(!lib_exists(workspace, &Path::new(\"foo\"), NoVersion));\n    assert!(!executable_exists(workspace, \"foo\"));\n    assert!(!built_library_exists(workspace, \"foo\"));\n    assert!(!built_executable_exists(workspace, \"foo\"));\n@@ -1449,15 +1449,15 @@ fn rust_path_hack_cwd() {\n    fs::mkdir_recursive(&cwd, io::UserRWX);\n    writeFile(&cwd.join(\"lib.rs\"), \"pub fn f() { }\");\n \n-   let dest_workspace = mk_empty_workspace(&Path::init(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n    let dest_workspace = dest_workspace.path();\n    // FIXME (#9639): This needs to handle non-utf8 paths\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", ~\"foo\"], &cwd, rust_path);\n    debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n-   assert_lib_exists(dest_workspace, &Path::init(\"foo\"), NoVersion);\n+   assert_lib_exists(dest_workspace, &Path::new(\"foo\"), NoVersion);\n    assert_built_library_exists(dest_workspace, \"foo\");\n-   assert!(!lib_exists(&cwd, &Path::init(\"foo\"), NoVersion));\n+   assert!(!lib_exists(&cwd, &Path::new(\"foo\"), NoVersion));\n    assert!(!built_library_exists(&cwd, \"foo\"));\n }\n \n@@ -1470,15 +1470,15 @@ fn rust_path_hack_multi_path() {\n    writeFile(&subdir.join(\"lib.rs\"), \"pub fn f() { }\");\n    let name = ~\"foo/bar/quux\";\n \n-   let dest_workspace = mk_empty_workspace(&Path::init(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n    let dest_workspace = dest_workspace.path();\n    // FIXME (#9639): This needs to handle non-utf8 paths\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", name.clone()], &subdir, rust_path);\n    debug!(\"Checking that {} exists in {}\", name, dest_workspace.display());\n-   assert_lib_exists(dest_workspace, &Path::init(\"quux\"), NoVersion);\n+   assert_lib_exists(dest_workspace, &Path::new(\"quux\"), NoVersion);\n    assert_built_library_exists(dest_workspace, name);\n-   assert!(!lib_exists(&subdir, &Path::init(\"quux\"), NoVersion));\n+   assert!(!lib_exists(&subdir, &Path::new(\"quux\"), NoVersion));\n    assert!(!built_library_exists(&subdir, name));\n }\n \n@@ -1491,15 +1491,15 @@ fn rust_path_hack_install_no_arg() {\n    assert!(make_dir_rwx(&source_dir));\n    writeFile(&source_dir.join(\"lib.rs\"), \"pub fn f() { }\");\n \n-   let dest_workspace = mk_empty_workspace(&Path::init(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n    let dest_workspace = dest_workspace.path();\n    // FIXME (#9639): This needs to handle non-utf8 paths\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n    debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n-   assert_lib_exists(dest_workspace, &Path::init(\"foo\"), NoVersion);\n+   assert_lib_exists(dest_workspace, &Path::new(\"foo\"), NoVersion);\n    assert_built_library_exists(dest_workspace, \"foo\");\n-   assert!(!lib_exists(&source_dir, &Path::init(\"foo\"), NoVersion));\n+   assert!(!lib_exists(&source_dir, &Path::new(\"foo\"), NoVersion));\n    assert!(!built_library_exists(cwd, \"foo\"));\n }\n \n@@ -1511,7 +1511,7 @@ fn rust_path_hack_build_no_arg() {\n    assert!(make_dir_rwx(&source_dir));\n    writeFile(&source_dir.join(\"lib.rs\"), \"pub fn f() { }\");\n \n-   let dest_workspace = mk_empty_workspace(&Path::init(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n    let dest_workspace = dest_workspace.path();\n    // FIXME (#9639): This needs to handle non-utf8 paths\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n@@ -1549,7 +1549,7 @@ fn rust_path_hack_build_with_dependency() {\n fn rust_path_install_target() {\n     let dir_for_path = TempDir::new(\n         \"source_workspace\").expect(\"rust_path_install_target failed\");\n-    let mut dir = mk_workspace(dir_for_path.path(), &Path::init(\"foo\"), &NoVersion);\n+    let mut dir = mk_workspace(dir_for_path.path(), &Path::new(\"foo\"), &NoVersion);\n     debug!(\"dir = {}\", dir.display());\n     writeFile(&dir.join(\"main.rs\"), \"fn main() { let _x = (); }\");\n     let dir_to_install_to = TempDir::new(\n@@ -1661,7 +1661,7 @@ fn notrans_flag_fail() {\n                           workspace, None, BAD_FLAG_CODE);\n         assert!(!built_executable_exists(workspace, \"foo\"));\n         assert!(!object_file_exists(workspace, \"foo\"));\n-        assert!(!lib_exists(workspace, &Path::init(\"foo\"), NoVersion));\n+        assert!(!lib_exists(workspace, &Path::new(\"foo\"), NoVersion));\n     }\n }\n \n@@ -1929,17 +1929,17 @@ fn test_recursive_deps() {\n     command_line_test_with_env([~\"install\", ~\"a\"],\n                                a_workspace,\n                                environment);\n-    assert_lib_exists(a_workspace, &Path::init(\"a\"), NoVersion);\n-    assert_lib_exists(b_workspace, &Path::init(\"b\"), NoVersion);\n-    assert_lib_exists(b_workspace, &Path::init(\"c\"), NoVersion);\n+    assert_lib_exists(a_workspace, &Path::new(\"a\"), NoVersion);\n+    assert_lib_exists(b_workspace, &Path::new(\"b\"), NoVersion);\n+    assert_lib_exists(b_workspace, &Path::new(\"c\"), NoVersion);\n }\n \n #[test]\n fn test_install_to_rust_path() {\n     let p_id = PkgId::new(\"foo\");\n     let second_workspace = create_local_package(&p_id);\n     let second_workspace = second_workspace.path();\n-    let first_workspace = mk_empty_workspace(&Path::init(\"p\"), &NoVersion, \"dest\");\n+    let first_workspace = mk_empty_workspace(&Path::new(\"p\"), &NoVersion, \"dest\");\n     let first_workspace = first_workspace.path();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let rust_path = Some(~[(~\"RUST_PATH\",\n@@ -1986,7 +1986,7 @@ fn test_target_specific_install_dir() {\n                        ~\"foo\"],\n                       workspace);\n     assert!(workspace.join_many([~\"lib\", host_triple()]).is_dir());\n-    assert_lib_exists(workspace, &Path::init(\"foo\"), NoVersion);\n+    assert_lib_exists(workspace, &Path::new(\"foo\"), NoVersion);\n     assert!(fs::readdir(&workspace.join(\"lib\")).len() == 1);\n     assert!(workspace.join(\"bin\").is_dir());\n     assert_executable_exists(workspace, \"foo\");\n@@ -2062,7 +2062,7 @@ fn correct_package_name_with_rust_path_hack() {\n     let bar_id = PkgId::new(\"bar\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n-    let dest_workspace = mk_empty_workspace(&Path::init(\"bar\"), &NoVersion, \"dest_workspace\");\n+    let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n     let dest_workspace = dest_workspace.path();\n \n     writeFile(&dest_workspace.join_many([\"src\", \"bar-0.1\", \"main.rs\"]),\n@@ -2332,7 +2332,7 @@ fn test_c_dependency_ok() {\n     writeFile(&dir.join_many([\"src\", \"cdep-0.1\", \"foo.c\"]), \"void f() {}\");\n \n     debug!(\"dir = {}\", dir.display());\n-    let source = Path::init(file!()).dir_path().join_many(\n+    let source = Path::new(file!()).dir_path().join_many(\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n     fs::copy(&source, &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]));\n     command_line_test([~\"build\", ~\"cdep\"], dir);\n@@ -2354,7 +2354,7 @@ fn test_c_dependency_no_rebuilding() {\n     writeFile(&dir.join_many([\"src\", \"cdep-0.1\", \"foo.c\"]), \"void f() {}\");\n \n     debug!(\"dir = {}\", dir.display());\n-    let source = Path::init(file!()).dir_path().join_many(\n+    let source = Path::new(file!()).dir_path().join_many(\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n     fs::copy(&source, &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]));\n     command_line_test([~\"build\", ~\"cdep\"], dir);\n@@ -2388,7 +2388,7 @@ fn test_c_dependency_yes_rebuilding() {\n     let c_file_name = dir.join_many([\"src\", \"cdep-0.1\", \"foo.c\"]);\n     writeFile(&c_file_name, \"void f() {}\");\n \n-    let source = Path::init(file!()).dir_path().join_many(\n+    let source = Path::new(file!()).dir_path().join_many(\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n     let target = dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]);\n     debug!(\"Copying {} -> {}\", source.display(), target.display());"}, {"sha": "e5c14336a1923b3a77f5f303db6d46fea327e84f", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -510,7 +510,7 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                             self.context.install(\n                                 pkg_src,\n                                 &WhatToBuild::new(Inferred,\n-                                                  JustOne(Path::init(lib_crate_filename))));\n+                                                  JustOne(Path::new(lib_crate_filename))));\n                         debug!(\"Installed {}, returned {:?} dependencies and \\\n                                {:?} transitive dependencies\",\n                                lib_name, outputs_disc.len(), inputs_disc.len());\n@@ -548,15 +548,15 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                                 self.exec.discover_input(*what,\n                                                          *dep,\n                                                          digest_file_with_date(\n-                                                             &Path::init(dep.as_slice())));\n+                                                             &Path::new(dep.as_slice())));\n                             } else if *what == ~\"binary\" {\n                                 add_dep(self.deps,\n                                         self.parent_crate.as_str().unwrap().to_owned(),\n                                         (~\"binary\", dep.clone()));\n                                 self.exec.discover_input(*what,\n                                                          *dep,\n                                                          digest_only_date(\n-                                                             &Path::init(dep.as_slice())));\n+                                                             &Path::new(dep.as_slice())));\n                             } else {\n                                 fail!(\"Bad kind: {}\", *what);\n                             }"}, {"sha": "16e2d1adbd0c3093b5c8216078449a91f2bb6138", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -141,7 +141,7 @@ impl FsRequest {\n         }).map(|req| unsafe {\n             let mut paths = ~[];\n             let path = CString::new(path.with_ref(|p| p), false);\n-            let parent = Path::init(path);\n+            let parent = Path::new(path);\n             c_str::from_c_multistring(req.get_ptr() as *libc::c_char,\n                                       Some(req.get_result() as uint),\n                                       |rel| {\n@@ -157,7 +157,7 @@ impl FsRequest {\n             uvll::uv_fs_readlink(loop_.handle, req,\n                                  path.with_ref(|p| p), cb)\n         }).map(|req| {\n-            Path::init(unsafe {\n+            Path::new(unsafe {\n                 CString::new(req.get_ptr() as *libc::c_char, false)\n             })\n         })\n@@ -245,7 +245,7 @@ impl FsRequest {\n \n     pub fn mkstat(&self) -> FileStat {\n         let path = unsafe { uvll::get_path_from_fs_req(self.req) };\n-        let path = unsafe { Path::init(CString::new(path, false)) };\n+        let path = unsafe { Path::new(CString::new(path, false)) };\n         let stat = self.get_stat();\n         fn to_msec(stat: uvll::uv_timespec_t) -> u64 {\n             // Be sure to cast to u64 first to prevent overflowing if the tv_sec"}, {"sha": "967071142e5ee3c93ef84f3ef7ffdb47e0d008f0", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -1082,7 +1082,7 @@ mod test {\n \n         do run_in_bare_thread {\n             let sleepers = SleeperList::new();\n-            let mut pool = BufferPool::init();\n+            let mut pool = BufferPool::new();\n             let (worker1, stealer1) = pool.deque();\n             let (worker2, stealer2) = pool.deque();\n             let queues = ~[stealer1, stealer2];"}, {"sha": "23bf5cdc56489f3538b3a7297f4a907b21d9a63f", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -29,7 +29,7 @@ particular bits of it, etc.\n \n     use std::io::{File, fs};\n \n-    let path = Path::init(\"foo.txt\");\n+    let path = Path::new(\"foo.txt\");\n \n     // create the file, whether it exists or not\n     let mut file = File::create(&path);\n@@ -40,7 +40,7 @@ particular bits of it, etc.\n     file.read_to_end();\n \n     println!(\"{}\", path.stat().size);\n-    fs::symlink(&path, &Path::init(\"bar.txt\"));\n+    fs::symlink(&path, &Path::new(\"bar.txt\"));\n     fs::unlink(&path);\n \n */\n@@ -95,7 +95,7 @@ impl File {\n     ///\n     ///     use std::io::{File, io_error, Open, ReadWrite};\n     ///\n-    ///     let p = Path::init(\"/some/file/path.txt\");\n+    ///     let p = Path::new(\"/some/file/path.txt\");\n     ///\n     ///     io_error::cond.trap(|_| {\n     ///         // hoo-boy...\n@@ -157,7 +157,7 @@ impl File {\n     ///\n     ///     use std::io::File;\n     ///\n-    ///     let contents = File::open(&Path::init(\"foo.txt\")).read_to_end();\n+    ///     let contents = File::open(&Path::new(\"foo.txt\")).read_to_end();\n     pub fn open(path: &Path) -> Option<File> {\n         File::open_mode(path, Open, Read)\n     }\n@@ -172,7 +172,7 @@ impl File {\n     ///\n     ///     use std::io::File;\n     ///\n-    ///     let mut f = File::create(&Path::init(\"foo.txt\"));\n+    ///     let mut f = File::create(&Path::new(\"foo.txt\"));\n     ///     f.write(bytes!(\"This is a sample file\"));\n     pub fn create(path: &Path) -> Option<File> {\n         File::open_mode(path, Truncate, Write)\n@@ -229,7 +229,7 @@ impl File {\n ///\n ///     use std::io::fs;\n ///\n-///     let p = Path::init(\"/some/file/path.txt\");\n+///     let p = Path::new(\"/some/file/path.txt\");\n ///     fs::unlink(&p);\n ///     // if we made it here without failing, then the\n ///     // unlink operation was successful\n@@ -260,7 +260,7 @@ pub fn unlink(path: &Path) {\n ///     use std::io;\n ///     use std::io::fs;\n ///\n-///     let p = Path::init(\"/some/file/path.txt\");\n+///     let p = Path::new(\"/some/file/path.txt\");\n ///     match io::result(|| fs::stat(&p)) {\n ///         Ok(stat) => { /* ... */ }\n ///         Err(e) => { /* handle error */ }\n@@ -277,7 +277,7 @@ pub fn stat(path: &Path) -> FileStat {\n \n fn dummystat() -> FileStat {\n     FileStat {\n-        path: Path::init(\"\"),\n+        path: Path::new(\"\"),\n         size: 0,\n         kind: io::TypeFile,\n         perm: 0,\n@@ -317,7 +317,7 @@ pub fn lstat(path: &Path) -> FileStat {\n ///\n ///     use std::io::fs;\n ///\n-///     fs::rename(&Path::init(\"foo\"), &Path::init(\"bar\"));\n+///     fs::rename(&Path::new(\"foo\"), &Path::new(\"bar\"));\n ///     // Oh boy, nothing was raised!\n ///\n /// # Errors\n@@ -339,7 +339,7 @@ pub fn rename(from: &Path, to: &Path) {\n ///\n ///     use std::io::fs;\n ///\n-///     fs::copy(&Path::init(\"foo.txt\"), &Path::init(\"bar.txt\"));\n+///     fs::copy(&Path::new(\"foo.txt\"), &Path::new(\"bar.txt\"));\n ///     // Oh boy, nothing was raised!\n ///\n /// # Errors\n@@ -386,10 +386,10 @@ pub fn copy(from: &Path, to: &Path) {\n ///     use std::io;\n ///     use std::io::fs;\n ///\n-///     fs::chmod(&Path::init(\"file.txt\"), io::UserFile);\n-///     fs::chmod(&Path::init(\"file.txt\"), io::UserRead | io::UserWrite);\n-///     fs::chmod(&Path::init(\"dir\"),      io::UserDir);\n-///     fs::chmod(&Path::init(\"file.exe\"), io::UserExec);\n+///     fs::chmod(&Path::new(\"file.txt\"), io::UserFile);\n+///     fs::chmod(&Path::new(\"file.txt\"), io::UserRead | io::UserWrite);\n+///     fs::chmod(&Path::new(\"dir\"),      io::UserDir);\n+///     fs::chmod(&Path::new(\"file.exe\"), io::UserExec);\n ///\n /// # Errors\n ///\n@@ -448,7 +448,7 @@ pub fn readlink(path: &Path) -> Option<Path> {\n ///     use std::libc::S_IRWXU;\n ///     use std::io::fs;\n ///\n-///     let p = Path::init(\"/some/dir\");\n+///     let p = Path::new(\"/some/dir\");\n ///     fs::mkdir(&p, S_IRWXU as int);\n ///     // If we got here, our directory exists! Horray!\n ///\n@@ -467,7 +467,7 @@ pub fn mkdir(path: &Path, mode: FilePermission) {\n ///\n ///     use std::io::fs;\n ///\n-///     let p = Path::init(\"/some/dir\");\n+///     let p = Path::new(\"/some/dir\");\n ///     fs::rmdir(&p);\n ///     // good riddance, you mean ol' directory\n ///\n@@ -987,12 +987,12 @@ mod test {\n     })\n \n     test!(fn recursive_mkdir_slash() {\n-        mkdir_recursive(&Path::init(\"/\"), io::UserRWX);\n+        mkdir_recursive(&Path::new(\"/\"), io::UserRWX);\n     })\n \n     test!(fn unicode_path_is_dir() {\n-        assert!(Path::init(\".\").is_dir());\n-        assert!(!Path::init(\"test/stdtest/fs.rs\").is_dir());\n+        assert!(Path::new(\".\").is_dir());\n+        assert!(!Path::new(\"test/stdtest/fs.rs\").is_dir());\n \n         let tmpdir = tmpdir();\n \n@@ -1009,20 +1009,20 @@ mod test {\n     })\n \n     test!(fn unicode_path_exists() {\n-        assert!(Path::init(\".\").exists());\n-        assert!(!Path::init(\"test/nonexistent-bogus-path\").exists());\n+        assert!(Path::new(\".\").exists());\n+        assert!(!Path::new(\"test/nonexistent-bogus-path\").exists());\n \n         let tmpdir = tmpdir();\n         let unicode = tmpdir.clone();\n         let unicode = unicode.join(format!(\"test-\uac01\u4e01\u30fc\u518d\u89c1\"));\n         mkdir(&unicode, io::UserRWX);\n         assert!(unicode.exists());\n-        assert!(!Path::init(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n+        assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n     })\n \n     test!(fn copy_file_does_not_exist() {\n-        let from = Path::init(\"test/nonexistent-bogus-path\");\n-        let to = Path::init(\"test/other-bogus-path\");\n+        let from = Path::new(\"test/nonexistent-bogus-path\");\n+        let to = Path::new(\"test/other-bogus-path\");\n         match io::result(|| copy(&from, &to)) {\n             Ok(..) => fail!(),\n             Err(..) => {"}, {"sha": "edc6728a0c1d7b35773b8e22f9b6cfa59ccbe607", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -450,7 +450,7 @@ pub trait Reader {\n     ///\n     /// # Example\n     ///\n-    ///     let reader = File::open(&Path::init(\"foo.txt\"))\n+    ///     let reader = File::open(&Path::new(\"foo.txt\"))\n     ///     while !reader.eof() {\n     ///         println(reader.read_line());\n     ///     }"}, {"sha": "218040b72d6b9dacd884551f4f2d51f6ce5ac5df", "filename": "src/libstd/io/native/file.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Ffile.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -278,7 +278,6 @@ impl rtio::RtioFileStream for FileDesc {\n         self.seek(orig_pos as i64, io::SeekSet);\n         return ret;\n     }\n-\n     #[cfg(unix)]\n     fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n         super::mkerr_libc(unsafe {\n@@ -481,7 +480,7 @@ pub fn mkdir(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n     fn prune(root: &CString, dirs: ~[Path]) -> ~[Path] {\n         let root = unsafe { CString::new(root.with_ref(|p| p), false) };\n-        let root = Path::init(root);\n+        let root = Path::new(root);\n \n         dirs.move_iter().filter(|path| {\n             path.as_vec() != bytes!(\".\") && path.as_vec() != bytes!(\"..\")\n@@ -506,7 +505,7 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n                 let mut entry_ptr = readdir(dir_ptr);\n                 while (entry_ptr as uint != 0) {\n                     let cstr = CString::new(rust_list_dir_val(entry_ptr), false);\n-                    paths.push(Path::init(cstr));\n+                    paths.push(Path::new(cstr));\n                     entry_ptr = readdir(dir_ptr);\n                 }\n                 closedir(dir_ptr);\n@@ -537,7 +536,7 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n                 fn rust_list_dir_wfd_fp_buf(wfd: *libc::c_void) -> *u16;\n             }\n             let p = CString::new(p.with_ref(|p| p), false);\n-            let p = Path::init(p);\n+            let p = Path::new(p);\n             let star = p.join(\"*\");\n             as_utf16_p(star.as_str().unwrap(), |path_ptr| {\n                 let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n@@ -554,7 +553,7 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n                             let fp_vec = vec::from_buf(\n                                 fp_buf, wcslen(fp_buf) as uint);\n                             let fp_str = str::from_utf16(fp_vec);\n-                            paths.push(Path::init(fp_str));\n+                            paths.push(Path::new(fp_str));\n                         }\n                         more_files = FindNextFileW(find_handle, wfd_ptr as HANDLE);\n                     }\n@@ -684,7 +683,7 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n             }\n         });\n         let ret = match ret {\n-            Some(s) => Ok(Path::init(s)),\n+            Some(s) => Ok(Path::new(s)),\n             None => Err(super::last_error()),\n         };\n         unsafe { libc::CloseHandle(handle) };\n@@ -708,7 +707,7 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n             n => {\n                 assert!(n > 0);\n                 unsafe { vec::raw::set_len(&mut buf, n as uint); }\n-                Ok(Path::init(buf))\n+                Ok(Path::new(buf))\n             }\n         }\n     }\n@@ -771,7 +770,7 @@ fn mkstat(stat: &libc::stat, path: &CString) -> io::FileStat {\n     };\n \n     io::FileStat {\n-        path: Path::init(path),\n+        path: Path::new(path),\n         size: stat.st_size as u64,\n         kind: kind,\n         perm: (stat.st_mode) as io::FilePermission & io::AllPermissions,\n@@ -820,7 +819,7 @@ fn mkstat(stat: &libc::stat, path: &CString) -> io::FileStat {\n     fn gen(_stat: &libc::stat) -> u64 { 0 }\n \n     io::FileStat {\n-        path: Path::init(path),\n+        path: Path::new(path),\n         size: stat.st_size as u64,\n         kind: kind,\n         perm: (stat.st_mode) as io::FilePermission & io::AllPermissions,"}, {"sha": "1b61485273754385bed2aee4a16bd5932ccaae9d", "filename": "src/libstd/io/native/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -95,7 +95,7 @@ impl Process {\n         let (err_pipe, err_fd) = get_io(config.io, &mut ret_io, 2);\n \n         let env = config.env.map(|a| a.to_owned());\n-        let cwd = config.cwd.map(|a| Path::init(a));\n+        let cwd = config.cwd.map(|a| Path::new(a));\n         let res = spawn_process_os(config.program, config.args, env,\n                                    cwd.as_ref(), in_fd, out_fd, err_fd);\n "}, {"sha": "3433176961463ba7b31843facd71fef1cca23a85", "filename": "src/libstd/os.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -64,7 +64,7 @@ pub fn getcwd() -> Path {\n                 fail!()\n             }\n \n-            Path::init(CString::new(buf as *c_char, false))\n+            Path::new(CString::new(buf as *c_char, false))\n         }\n     })\n }\n@@ -81,7 +81,7 @@ pub fn getcwd() -> Path {\n             }\n         }\n     });\n-    Path::init(str::from_utf16(buf))\n+    Path::new(str::from_utf16(buf))\n }\n \n #[cfg(windows)]\n@@ -384,7 +384,7 @@ pub fn self_exe_path() -> Option<Path> {\n     fn load_self() -> Option<~[u8]> {\n         use std::io;\n \n-        match io::result(|| io::fs::readlink(&Path::init(\"/proc/self/exe\"))) {\n+        match io::result(|| io::fs::readlink(&Path::new(\"/proc/self/exe\"))) {\n             Ok(Some(path)) => Some(path.as_vec().to_owned()),\n             Ok(None) | Err(..) => None\n         }\n@@ -418,7 +418,7 @@ pub fn self_exe_path() -> Option<Path> {\n         }\n     }\n \n-    load_self().and_then(|path| Path::init_opt(path).map(|mut p| { p.pop(); p }))\n+    load_self().and_then(|path| Path::new_opt(path).map(|mut p| { p.pop(); p }))\n }\n \n /**\n@@ -437,7 +437,7 @@ pub fn self_exe_path() -> Option<Path> {\n pub fn homedir() -> Option<Path> {\n     // FIXME (#7188): getenv needs a ~[u8] variant\n     return match getenv(\"HOME\") {\n-        Some(ref p) if !p.is_empty() => Path::init_opt(p.as_slice()),\n+        Some(ref p) if !p.is_empty() => Path::new_opt(p.as_slice()),\n         _ => secondary()\n     };\n \n@@ -450,7 +450,7 @@ pub fn homedir() -> Option<Path> {\n     fn secondary() -> Option<Path> {\n         getenv(\"USERPROFILE\").and_then(|p| {\n             if !p.is_empty() {\n-                Path::init_opt(p)\n+                Path::new_opt(p)\n             } else {\n                 None\n             }\n@@ -479,7 +479,7 @@ pub fn tmpdir() -> Path {\n                 if x.is_empty() {\n                     None\n                 } else {\n-                    Path::init_opt(x)\n+                    Path::new_opt(x)\n                 },\n             _ => None\n         }\n@@ -488,9 +488,9 @@ pub fn tmpdir() -> Path {\n     #[cfg(unix)]\n     fn lookup() -> Path {\n         if cfg!(target_os = \"android\") {\n-            Path::init(\"/data/tmp\")\n+            Path::new(\"/data/tmp\")\n         } else {\n-            getenv_nonempty(\"TMPDIR\").unwrap_or(Path::init(\"/tmp\"))\n+            getenv_nonempty(\"TMPDIR\").unwrap_or(Path::new(\"/tmp\"))\n         }\n     }\n \n@@ -499,7 +499,7 @@ pub fn tmpdir() -> Path {\n         getenv_nonempty(\"TMP\").or(\n             getenv_nonempty(\"TEMP\").or(\n                 getenv_nonempty(\"USERPROFILE\").or(\n-                   getenv_nonempty(\"WINDIR\")))).unwrap_or(Path::init(\"C:\\\\Windows\"))\n+                   getenv_nonempty(\"WINDIR\")))).unwrap_or(Path::new(\"C:\\\\Windows\"))\n     }\n }\n \n@@ -1366,13 +1366,13 @@ mod tests {\n \n     #[test]\n     fn test() {\n-        assert!((!Path::init(\"test-path\").is_absolute()));\n+        assert!((!Path::new(\"test-path\").is_absolute()));\n \n         let cwd = getcwd();\n         debug!(\"Current working directory: {}\", cwd.display());\n \n-        debug!(\"{:?}\", make_absolute(&Path::init(\"test-path\")));\n-        debug!(\"{:?}\", make_absolute(&Path::init(\"/usr/bin\")));\n+        debug!(\"{:?}\", make_absolute(&Path::new(\"test-path\")));\n+        debug!(\"{:?}\", make_absolute(&Path::new(\"/usr/bin\")));\n     }\n \n     #[test]\n@@ -1381,7 +1381,7 @@ mod tests {\n         let oldhome = getenv(\"HOME\");\n \n         setenv(\"HOME\", \"/home/MountainView\");\n-        assert_eq!(os::homedir(), Some(Path::init(\"/home/MountainView\")));\n+        assert_eq!(os::homedir(), Some(Path::new(\"/home/MountainView\")));\n \n         setenv(\"HOME\", \"\");\n         assert!(os::homedir().is_none());\n@@ -1402,16 +1402,16 @@ mod tests {\n         assert!(os::homedir().is_none());\n \n         setenv(\"HOME\", \"/home/MountainView\");\n-        assert_eq!(os::homedir(), Some(Path::init(\"/home/MountainView\")));\n+        assert_eq!(os::homedir(), Some(Path::new(\"/home/MountainView\")));\n \n         setenv(\"HOME\", \"\");\n \n         setenv(\"USERPROFILE\", \"/home/MountainView\");\n-        assert_eq!(os::homedir(), Some(Path::init(\"/home/MountainView\")));\n+        assert_eq!(os::homedir(), Some(Path::new(\"/home/MountainView\")));\n \n         setenv(\"HOME\", \"/home/MountainView\");\n         setenv(\"USERPROFILE\", \"/home/PaloAlto\");\n-        assert_eq!(os::homedir(), Some(Path::init(\"/home/MountainView\")));\n+        assert_eq!(os::homedir(), Some(Path::new(\"/home/MountainView\")));\n \n         for s in oldhome.iter() { setenv(\"HOME\", *s) }\n         for s in olduserprofile.iter() { setenv(\"USERPROFILE\", *s) }"}, {"sha": "303bb47099115eebc564fa12f8d9adbc758d4165", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -32,16 +32,16 @@ no restriction on paths beyond disallowing NUL).\n Usage of this module is fairly straightforward. Unless writing platform-specific\n code, `Path` should be used to refer to the platform-native path.\n \n-Creation of a path is typically done with either `Path::init(some_str)` or\n-`Path::init(some_vec)`. This path can be modified with `.push()` and\n+Creation of a path is typically done with either `Path::new(some_str)` or\n+`Path::new(some_vec)`. This path can be modified with `.push()` and\n `.pop()` (and other setters). The resulting Path can either be passed to another\n API that expects a path, or can be turned into a &[u8] with `.as_vec()` or a\n Option<&str> with `.as_str()`. Similarly, attributes of the path can be queried\n with methods such as `.filename()`. There are also methods that return a new\n path instead of modifying the receiver, such as `.join()` or `.dir_path()`.\n \n Paths are always kept in normalized form. This means that creating the path\n-`Path::init(\"a/b/../c\")` will return the path `a/c`. Similarly any attempt\n+`Path::new(\"a/b/../c\")` will return the path `a/c`. Similarly any attempt\n to mutate the path will always leave it in normalized form.\n \n When rendering a path to some form of output, there is a method `.display()`\n@@ -53,7 +53,7 @@ actually operates on the path; it is only intended for display.\n ## Example\n \n ```rust\n-let mut path = Path::from_str(\"/tmp/path\");\n+let mut path = Path::new(\"/tmp/path\");\n debug!(\"path: {}\", path.display());\n path.set_filename(\"foo\");\n path.push(\"bar\");\n@@ -151,24 +151,24 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     ///\n     /// See individual Path impls for additional restrictions.\n     #[inline]\n-    fn init<T: BytesContainer>(path: T) -> Self {\n+    fn new<T: BytesContainer>(path: T) -> Self {\n         if contains_nul(path.container_as_bytes()) {\n             let path = self::null_byte::cond.raise(path.container_into_owned_bytes());\n             assert!(!contains_nul(path));\n-            unsafe { GenericPathUnsafe::init_unchecked(path) }\n+            unsafe { GenericPathUnsafe::new_unchecked(path) }\n         } else {\n-            unsafe { GenericPathUnsafe::init_unchecked(path) }\n+            unsafe { GenericPathUnsafe::new_unchecked(path) }\n         }\n     }\n \n     /// Creates a new Path from a byte vector or string, if possible.\n     /// The resulting Path will always be normalized.\n     #[inline]\n-    fn init_opt<T: BytesContainer>(path: T) -> Option<Self> {\n+    fn new_opt<T: BytesContainer>(path: T) -> Option<Self> {\n         if contains_nul(path.container_as_bytes()) {\n             None\n         } else {\n-            Some(unsafe { GenericPathUnsafe::init_unchecked(path) })\n+            Some(unsafe { GenericPathUnsafe::new_unchecked(path) })\n         }\n     }\n \n@@ -382,7 +382,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// If `self` represents the root of the filesystem hierarchy, returns `self`.\n     fn dir_path(&self) -> Self {\n         // self.dirname() returns a NUL-free vector\n-        unsafe { GenericPathUnsafe::init_unchecked(self.dirname()) }\n+        unsafe { GenericPathUnsafe::new_unchecked(self.dirname()) }\n     }\n \n     /// Returns a Path that represents the filesystem root that `self` is rooted in.\n@@ -510,7 +510,7 @@ pub trait BytesContainer {\n pub trait GenericPathUnsafe {\n     /// Creates a new Path without checking for null bytes.\n     /// The resulting Path will always be normalized.\n-    unsafe fn init_unchecked<T: BytesContainer>(path: T) -> Self;\n+    unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Self;\n \n     /// Replaces the filename portion of the path without checking for null\n     /// bytes.\n@@ -694,11 +694,11 @@ mod tests {\n     #[test]\n     fn test_cstring() {\n         let input = \"/foo/bar/baz\";\n-        let path: PosixPath = PosixPath::init(input.to_c_str());\n+        let path: PosixPath = PosixPath::new(input.to_c_str());\n         assert_eq!(path.as_vec(), input.as_bytes());\n \n         let input = r\"\\foo\\bar\\baz\";\n-        let path: WindowsPath = WindowsPath::init(input.to_c_str());\n+        let path: WindowsPath = WindowsPath::new(input.to_c_str());\n         assert_eq!(path.as_str().unwrap(), input.as_slice());\n     }\n }"}, {"sha": "10ce06f7e0393f002bb6fe96585e09d2657e0d4f", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 171, "deletions": 171, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -68,7 +68,7 @@ impl Eq for Path {\n \n impl FromStr for Path {\n     fn from_str(s: &str) -> Option<Path> {\n-        Path::init_opt(s)\n+        Path::new_opt(s)\n     }\n }\n \n@@ -111,7 +111,7 @@ impl<'self> BytesContainer for &'self Path {\n }\n \n impl GenericPathUnsafe for Path {\n-    unsafe fn init_unchecked<T: BytesContainer>(path: T) -> Path {\n+    unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Path {\n         let path = Path::normalize(path.container_as_bytes());\n         assert!(!path.is_empty());\n         let idx = path.rposition_elem(&sep_byte);\n@@ -218,7 +218,7 @@ impl GenericPath for Path {\n \n     fn root_path(&self) -> Option<Path> {\n         if self.is_absolute() {\n-            Some(Path::init(\"/\"))\n+            Some(Path::new(\"/\"))\n         } else {\n             None\n         }\n@@ -287,7 +287,7 @@ impl GenericPath for Path {\n                     }\n                 }\n             }\n-            Some(Path::init(comps.connect_vec(&sep_byte)))\n+            Some(Path::new(comps.connect_vec(&sep_byte)))\n         }\n     }\n \n@@ -314,14 +314,14 @@ impl Path {\n     ///\n     /// Raises the `null_byte` condition if the vector contains a NUL.\n     #[inline]\n-    pub fn init<T: BytesContainer>(path: T) -> Path {\n-        GenericPath::init(path)\n+    pub fn new<T: BytesContainer>(path: T) -> Path {\n+        GenericPath::new(path)\n     }\n \n     /// Returns a new Path from a byte vector or string, if possible\n     #[inline]\n-    pub fn init_opt<T: BytesContainer>(path: T) -> Option<Path> {\n-        GenericPath::init_opt(path)\n+    pub fn new_opt<T: BytesContainer>(path: T) -> Option<Path> {\n+        GenericPath::new_opt(path)\n     }\n \n     /// Returns a normalized byte vector representation of a path, by removing all empty\n@@ -471,51 +471,51 @@ mod tests {\n     #[test]\n     fn test_paths() {\n         let empty: &[u8] = [];\n-        t!(v: Path::init(empty), b!(\".\"));\n-        t!(v: Path::init(b!(\"/\")), b!(\"/\"));\n-        t!(v: Path::init(b!(\"a/b/c\")), b!(\"a/b/c\"));\n-        t!(v: Path::init(b!(\"a/b/c\", 0xff)), b!(\"a/b/c\", 0xff));\n-        t!(v: Path::init(b!(0xff, \"/../foo\", 0x80)), b!(\"foo\", 0x80));\n-        let p = Path::init(b!(\"a/b/c\", 0xff));\n+        t!(v: Path::new(empty), b!(\".\"));\n+        t!(v: Path::new(b!(\"/\")), b!(\"/\"));\n+        t!(v: Path::new(b!(\"a/b/c\")), b!(\"a/b/c\"));\n+        t!(v: Path::new(b!(\"a/b/c\", 0xff)), b!(\"a/b/c\", 0xff));\n+        t!(v: Path::new(b!(0xff, \"/../foo\", 0x80)), b!(\"foo\", 0x80));\n+        let p = Path::new(b!(\"a/b/c\", 0xff));\n         assert_eq!(p.as_str(), None);\n \n-        t!(s: Path::init(\"\"), \".\");\n-        t!(s: Path::init(\"/\"), \"/\");\n-        t!(s: Path::init(\"hi\"), \"hi\");\n-        t!(s: Path::init(\"hi/\"), \"hi\");\n-        t!(s: Path::init(\"/lib\"), \"/lib\");\n-        t!(s: Path::init(\"/lib/\"), \"/lib\");\n-        t!(s: Path::init(\"hi/there\"), \"hi/there\");\n-        t!(s: Path::init(\"hi/there.txt\"), \"hi/there.txt\");\n-\n-        t!(s: Path::init(\"hi/there/\"), \"hi/there\");\n-        t!(s: Path::init(\"hi/../there\"), \"there\");\n-        t!(s: Path::init(\"../hi/there\"), \"../hi/there\");\n-        t!(s: Path::init(\"/../hi/there\"), \"/hi/there\");\n-        t!(s: Path::init(\"foo/..\"), \".\");\n-        t!(s: Path::init(\"/foo/..\"), \"/\");\n-        t!(s: Path::init(\"/foo/../..\"), \"/\");\n-        t!(s: Path::init(\"/foo/../../bar\"), \"/bar\");\n-        t!(s: Path::init(\"/./hi/./there/.\"), \"/hi/there\");\n-        t!(s: Path::init(\"/./hi/./there/./..\"), \"/hi\");\n-        t!(s: Path::init(\"foo/../..\"), \"..\");\n-        t!(s: Path::init(\"foo/../../..\"), \"../..\");\n-        t!(s: Path::init(\"foo/../../bar\"), \"../bar\");\n-\n-        assert_eq!(Path::init(b!(\"foo/bar\")).into_vec(), b!(\"foo/bar\").to_owned());\n-        assert_eq!(Path::init(b!(\"/foo/../../bar\")).into_vec(),\n+        t!(s: Path::new(\"\"), \".\");\n+        t!(s: Path::new(\"/\"), \"/\");\n+        t!(s: Path::new(\"hi\"), \"hi\");\n+        t!(s: Path::new(\"hi/\"), \"hi\");\n+        t!(s: Path::new(\"/lib\"), \"/lib\");\n+        t!(s: Path::new(\"/lib/\"), \"/lib\");\n+        t!(s: Path::new(\"hi/there\"), \"hi/there\");\n+        t!(s: Path::new(\"hi/there.txt\"), \"hi/there.txt\");\n+\n+        t!(s: Path::new(\"hi/there/\"), \"hi/there\");\n+        t!(s: Path::new(\"hi/../there\"), \"there\");\n+        t!(s: Path::new(\"../hi/there\"), \"../hi/there\");\n+        t!(s: Path::new(\"/../hi/there\"), \"/hi/there\");\n+        t!(s: Path::new(\"foo/..\"), \".\");\n+        t!(s: Path::new(\"/foo/..\"), \"/\");\n+        t!(s: Path::new(\"/foo/../..\"), \"/\");\n+        t!(s: Path::new(\"/foo/../../bar\"), \"/bar\");\n+        t!(s: Path::new(\"/./hi/./there/.\"), \"/hi/there\");\n+        t!(s: Path::new(\"/./hi/./there/./..\"), \"/hi\");\n+        t!(s: Path::new(\"foo/../..\"), \"..\");\n+        t!(s: Path::new(\"foo/../../..\"), \"../..\");\n+        t!(s: Path::new(\"foo/../../bar\"), \"../bar\");\n+\n+        assert_eq!(Path::new(b!(\"foo/bar\")).into_vec(), b!(\"foo/bar\").to_owned());\n+        assert_eq!(Path::new(b!(\"/foo/../../bar\")).into_vec(),\n                    b!(\"/bar\").to_owned());\n \n-        let p = Path::init(b!(\"foo/bar\", 0x80));\n+        let p = Path::new(b!(\"foo/bar\", 0x80));\n         assert_eq!(p.as_str(), None);\n     }\n \n     #[test]\n     fn test_opt_paths() {\n-        assert_eq!(Path::init_opt(b!(\"foo/bar\", 0)), None);\n-        t!(v: Path::init_opt(b!(\"foo/bar\")).unwrap(), b!(\"foo/bar\"));\n-        assert_eq!(Path::init_opt(\"foo/bar\\0\"), None);\n-        t!(s: Path::init_opt(\"foo/bar\").unwrap(), \"foo/bar\");\n+        assert_eq!(Path::new_opt(b!(\"foo/bar\", 0)), None);\n+        t!(v: Path::new_opt(b!(\"foo/bar\")).unwrap(), b!(\"foo/bar\"));\n+        assert_eq!(Path::new_opt(\"foo/bar\\0\"), None);\n+        t!(s: Path::new_opt(\"foo/bar\").unwrap(), \"foo/bar\");\n     }\n \n     #[test]\n@@ -528,7 +528,7 @@ mod tests {\n             assert_eq!(v.as_slice(), b!(\"foo/bar\", 0));\n             (b!(\"/bar\").to_owned())\n         }).inside(|| {\n-            Path::init(b!(\"foo/bar\", 0))\n+            Path::new(b!(\"foo/bar\", 0))\n         });\n         assert!(handled);\n         assert_eq!(p.as_vec(), b!(\"/bar\"));\n@@ -576,12 +576,12 @@ mod tests {\n             cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n             }).inside(|| {\n-                Path::init(b!(\"foo/bar\", 0))\n+                Path::new(b!(\"foo/bar\", 0))\n             });\n         })\n \n         t!(~\"set_filename w/nul\" => {\n-            let mut p = Path::init(b!(\"foo/bar\"));\n+            let mut p = Path::new(b!(\"foo/bar\"));\n             cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n             }).inside(|| {\n@@ -590,7 +590,7 @@ mod tests {\n         })\n \n         t!(~\"push w/nul\" => {\n-            let mut p = Path::init(b!(\"foo/bar\"));\n+            let mut p = Path::new(b!(\"foo/bar\"));\n             cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n             }).inside(|| {\n@@ -604,7 +604,7 @@ mod tests {\n         macro_rules! t(\n             ($path:expr, $disp:ident, $exp:expr) => (\n                 {\n-                    let path = Path::init($path);\n+                    let path = Path::new($path);\n                     assert_eq!(path.$disp().to_str(), ~$exp);\n                 }\n             )\n@@ -620,7 +620,7 @@ mod tests {\n             ($path:expr, $exp:expr) => (\n                 {\n                     let mut called = false;\n-                    let path = Path::init($path);\n+                    let path = Path::new($path);\n                     path.display().with_str(|s| {\n                         assert_eq!(s, $exp);\n                         called = true;\n@@ -631,7 +631,7 @@ mod tests {\n             ($path:expr, $exp:expr, filename) => (\n                 {\n                     let mut called = false;\n-                    let path = Path::init($path);\n+                    let path = Path::new($path);\n                     path.filename_display().with_str(|s| {\n                         assert_eq!(s, $exp);\n                         called = true;\n@@ -654,7 +654,7 @@ mod tests {\n         macro_rules! t(\n             ($path:expr, $exp:expr, $expf:expr) => (\n                 {\n-                    let path = Path::init($path);\n+                    let path = Path::new($path);\n                     let f = format!(\"{}\", path.display());\n                     assert_eq!(f.as_slice(), $exp);\n                     let f = format!(\"{}\", path.filename_display());\n@@ -677,20 +677,20 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    let path = Path::init($path);\n+                    let path = Path::new($path);\n                     assert_eq!(path.$op(), ($exp).as_bytes());\n                 }\n             );\n             (s: $path:expr, $op:ident, $exp:expr, opt) => (\n                 {\n-                    let path = Path::init($path);\n+                    let path = Path::new($path);\n                     let left = path.$op().map(|x| str::from_utf8(x));\n                     assert_eq!(left, $exp);\n                 }\n             );\n             (v: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    let path = Path::init($path);\n+                    let path = Path::new($path);\n                     assert_eq!(path.$op(), $exp);\n                 }\n             );\n@@ -762,7 +762,7 @@ mod tests {\n                 {\n                     let path = ($path);\n                     let join = ($join);\n-                    let mut p1 = Path::init(path);\n+                    let mut p1 = Path::new(path);\n                     let p2 = p1.clone();\n                     p1.push(join);\n                     assert_eq!(p1, p2.join(join));\n@@ -781,8 +781,8 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n-                    let mut p = Path::init($path);\n-                    let push = Path::init($push);\n+                    let mut p = Path::new($path);\n+                    let push = Path::new($push);\n                     p.push(&push);\n                     assert_eq!(p.as_str(), Some($exp));\n                 }\n@@ -804,14 +804,14 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n-                    let mut p = Path::init($path);\n+                    let mut p = Path::new($path);\n                     p.push_many($push);\n                     assert_eq!(p.as_str(), Some($exp));\n                 }\n             );\n             (v: $path:expr, $push:expr, $exp:expr) => (\n                 {\n-                    let mut p = Path::init($path);\n+                    let mut p = Path::new($path);\n                     p.push_many($push);\n                     assert_eq!(p.as_vec(), $exp);\n                 }\n@@ -835,15 +835,15 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $left:expr, $right:expr) => (\n                 {\n-                    let mut p = Path::init($path);\n+                    let mut p = Path::new($path);\n                     let result = p.pop();\n                     assert_eq!(p.as_str(), Some($left));\n                     assert_eq!(result, $right);\n                 }\n             );\n             (v: [$($path:expr),+], [$($left:expr),+], $right:expr) => (\n                 {\n-                    let mut p = Path::init(b!($($path),+));\n+                    let mut p = Path::new(b!($($path),+));\n                     let result = p.pop();\n                     assert_eq!(p.as_vec(), b!($($left),+));\n                     assert_eq!(result, $right);\n@@ -869,30 +869,30 @@ mod tests {\n \n     #[test]\n     fn test_root_path() {\n-        assert_eq!(Path::init(b!(\"a/b/c\")).root_path(), None);\n-        assert_eq!(Path::init(b!(\"/a/b/c\")).root_path(), Some(Path::init(\"/\")));\n+        assert_eq!(Path::new(b!(\"a/b/c\")).root_path(), None);\n+        assert_eq!(Path::new(b!(\"/a/b/c\")).root_path(), Some(Path::new(\"/\")));\n     }\n \n     #[test]\n     fn test_join() {\n-        t!(v: Path::init(b!(\"a/b/c\")).join(b!(\"..\")), b!(\"a/b\"));\n-        t!(v: Path::init(b!(\"/a/b/c\")).join(b!(\"d\")), b!(\"/a/b/c/d\"));\n-        t!(v: Path::init(b!(\"a/\", 0x80, \"/c\")).join(b!(0xff)), b!(\"a/\", 0x80, \"/c/\", 0xff));\n-        t!(s: Path::init(\"a/b/c\").join(\"..\"), \"a/b\");\n-        t!(s: Path::init(\"/a/b/c\").join(\"d\"), \"/a/b/c/d\");\n-        t!(s: Path::init(\"a/b\").join(\"c/d\"), \"a/b/c/d\");\n-        t!(s: Path::init(\"a/b\").join(\"/c/d\"), \"/c/d\");\n-        t!(s: Path::init(\".\").join(\"a/b\"), \"a/b\");\n-        t!(s: Path::init(\"/\").join(\"a/b\"), \"/a/b\");\n+        t!(v: Path::new(b!(\"a/b/c\")).join(b!(\"..\")), b!(\"a/b\"));\n+        t!(v: Path::new(b!(\"/a/b/c\")).join(b!(\"d\")), b!(\"/a/b/c/d\"));\n+        t!(v: Path::new(b!(\"a/\", 0x80, \"/c\")).join(b!(0xff)), b!(\"a/\", 0x80, \"/c/\", 0xff));\n+        t!(s: Path::new(\"a/b/c\").join(\"..\"), \"a/b\");\n+        t!(s: Path::new(\"/a/b/c\").join(\"d\"), \"/a/b/c/d\");\n+        t!(s: Path::new(\"a/b\").join(\"c/d\"), \"a/b/c/d\");\n+        t!(s: Path::new(\"a/b\").join(\"/c/d\"), \"/c/d\");\n+        t!(s: Path::new(\".\").join(\"a/b\"), \"a/b\");\n+        t!(s: Path::new(\"/\").join(\"a/b\"), \"/a/b\");\n     }\n \n     #[test]\n     fn test_join_path() {\n         macro_rules! t(\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n-                    let path = Path::init($path);\n-                    let join = Path::init($join);\n+                    let path = Path::new($path);\n+                    let join = Path::new($join);\n                     let res = path.join(&join);\n                     assert_eq!(res.as_str(), Some($exp));\n                 }\n@@ -914,14 +914,14 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n-                    let path = Path::init($path);\n+                    let path = Path::new($path);\n                     let res = path.join_many($join);\n                     assert_eq!(res.as_str(), Some($exp));\n                 }\n             );\n             (v: $path:expr, $join:expr, $exp:expr) => (\n                 {\n-                    let path = Path::init($path);\n+                    let path = Path::new($path);\n                     let res = path.join_many($join);\n                     assert_eq!(res.as_vec(), $exp);\n                 }\n@@ -943,51 +943,51 @@ mod tests {\n     fn test_with_helpers() {\n         let empty: &[u8] = [];\n \n-        t!(v: Path::init(b!(\"a/b/c\")).with_filename(b!(\"d\")), b!(\"a/b/d\"));\n-        t!(v: Path::init(b!(\"a/b/c\", 0xff)).with_filename(b!(0x80)), b!(\"a/b/\", 0x80));\n-        t!(v: Path::init(b!(\"/\", 0xff, \"/foo\")).with_filename(b!(0xcd)),\n+        t!(v: Path::new(b!(\"a/b/c\")).with_filename(b!(\"d\")), b!(\"a/b/d\"));\n+        t!(v: Path::new(b!(\"a/b/c\", 0xff)).with_filename(b!(0x80)), b!(\"a/b/\", 0x80));\n+        t!(v: Path::new(b!(\"/\", 0xff, \"/foo\")).with_filename(b!(0xcd)),\n               b!(\"/\", 0xff, \"/\", 0xcd));\n-        t!(s: Path::init(\"a/b/c\").with_filename(\"d\"), \"a/b/d\");\n-        t!(s: Path::init(\".\").with_filename(\"foo\"), \"foo\");\n-        t!(s: Path::init(\"/a/b/c\").with_filename(\"d\"), \"/a/b/d\");\n-        t!(s: Path::init(\"/\").with_filename(\"foo\"), \"/foo\");\n-        t!(s: Path::init(\"/a\").with_filename(\"foo\"), \"/foo\");\n-        t!(s: Path::init(\"foo\").with_filename(\"bar\"), \"bar\");\n-        t!(s: Path::init(\"/\").with_filename(\"foo/\"), \"/foo\");\n-        t!(s: Path::init(\"/a\").with_filename(\"foo/\"), \"/foo\");\n-        t!(s: Path::init(\"a/b/c\").with_filename(\"\"), \"a/b\");\n-        t!(s: Path::init(\"a/b/c\").with_filename(\".\"), \"a/b\");\n-        t!(s: Path::init(\"a/b/c\").with_filename(\"..\"), \"a\");\n-        t!(s: Path::init(\"/a\").with_filename(\"\"), \"/\");\n-        t!(s: Path::init(\"foo\").with_filename(\"\"), \".\");\n-        t!(s: Path::init(\"a/b/c\").with_filename(\"d/e\"), \"a/b/d/e\");\n-        t!(s: Path::init(\"a/b/c\").with_filename(\"/d\"), \"a/b/d\");\n-        t!(s: Path::init(\"..\").with_filename(\"foo\"), \"../foo\");\n-        t!(s: Path::init(\"../..\").with_filename(\"foo\"), \"../../foo\");\n-        t!(s: Path::init(\"..\").with_filename(\"\"), \"..\");\n-        t!(s: Path::init(\"../..\").with_filename(\"\"), \"../..\");\n-\n-        t!(v: Path::init(b!(\"hi/there\", 0x80, \".txt\")).with_extension(b!(\"exe\")),\n+        t!(s: Path::new(\"a/b/c\").with_filename(\"d\"), \"a/b/d\");\n+        t!(s: Path::new(\".\").with_filename(\"foo\"), \"foo\");\n+        t!(s: Path::new(\"/a/b/c\").with_filename(\"d\"), \"/a/b/d\");\n+        t!(s: Path::new(\"/\").with_filename(\"foo\"), \"/foo\");\n+        t!(s: Path::new(\"/a\").with_filename(\"foo\"), \"/foo\");\n+        t!(s: Path::new(\"foo\").with_filename(\"bar\"), \"bar\");\n+        t!(s: Path::new(\"/\").with_filename(\"foo/\"), \"/foo\");\n+        t!(s: Path::new(\"/a\").with_filename(\"foo/\"), \"/foo\");\n+        t!(s: Path::new(\"a/b/c\").with_filename(\"\"), \"a/b\");\n+        t!(s: Path::new(\"a/b/c\").with_filename(\".\"), \"a/b\");\n+        t!(s: Path::new(\"a/b/c\").with_filename(\"..\"), \"a\");\n+        t!(s: Path::new(\"/a\").with_filename(\"\"), \"/\");\n+        t!(s: Path::new(\"foo\").with_filename(\"\"), \".\");\n+        t!(s: Path::new(\"a/b/c\").with_filename(\"d/e\"), \"a/b/d/e\");\n+        t!(s: Path::new(\"a/b/c\").with_filename(\"/d\"), \"a/b/d\");\n+        t!(s: Path::new(\"..\").with_filename(\"foo\"), \"../foo\");\n+        t!(s: Path::new(\"../..\").with_filename(\"foo\"), \"../../foo\");\n+        t!(s: Path::new(\"..\").with_filename(\"\"), \"..\");\n+        t!(s: Path::new(\"../..\").with_filename(\"\"), \"../..\");\n+\n+        t!(v: Path::new(b!(\"hi/there\", 0x80, \".txt\")).with_extension(b!(\"exe\")),\n               b!(\"hi/there\", 0x80, \".exe\"));\n-        t!(v: Path::init(b!(\"hi/there.txt\", 0x80)).with_extension(b!(0xff)),\n+        t!(v: Path::new(b!(\"hi/there.txt\", 0x80)).with_extension(b!(0xff)),\n               b!(\"hi/there.\", 0xff));\n-        t!(v: Path::init(b!(\"hi/there\", 0x80)).with_extension(b!(0xff)),\n+        t!(v: Path::new(b!(\"hi/there\", 0x80)).with_extension(b!(0xff)),\n               b!(\"hi/there\", 0x80, \".\", 0xff));\n-        t!(v: Path::init(b!(\"hi/there.\", 0xff)).with_extension(empty), b!(\"hi/there\"));\n-        t!(s: Path::init(\"hi/there.txt\").with_extension(\"exe\"), \"hi/there.exe\");\n-        t!(s: Path::init(\"hi/there.txt\").with_extension(\"\"), \"hi/there\");\n-        t!(s: Path::init(\"hi/there.txt\").with_extension(\".\"), \"hi/there..\");\n-        t!(s: Path::init(\"hi/there.txt\").with_extension(\"..\"), \"hi/there...\");\n-        t!(s: Path::init(\"hi/there\").with_extension(\"txt\"), \"hi/there.txt\");\n-        t!(s: Path::init(\"hi/there\").with_extension(\".\"), \"hi/there..\");\n-        t!(s: Path::init(\"hi/there\").with_extension(\"..\"), \"hi/there...\");\n-        t!(s: Path::init(\"hi/there.\").with_extension(\"txt\"), \"hi/there.txt\");\n-        t!(s: Path::init(\"hi/.foo\").with_extension(\"txt\"), \"hi/.foo.txt\");\n-        t!(s: Path::init(\"hi/there.txt\").with_extension(\".foo\"), \"hi/there..foo\");\n-        t!(s: Path::init(\"/\").with_extension(\"txt\"), \"/\");\n-        t!(s: Path::init(\"/\").with_extension(\".\"), \"/\");\n-        t!(s: Path::init(\"/\").with_extension(\"..\"), \"/\");\n-        t!(s: Path::init(\".\").with_extension(\"txt\"), \".\");\n+        t!(v: Path::new(b!(\"hi/there.\", 0xff)).with_extension(empty), b!(\"hi/there\"));\n+        t!(s: Path::new(\"hi/there.txt\").with_extension(\"exe\"), \"hi/there.exe\");\n+        t!(s: Path::new(\"hi/there.txt\").with_extension(\"\"), \"hi/there\");\n+        t!(s: Path::new(\"hi/there.txt\").with_extension(\".\"), \"hi/there..\");\n+        t!(s: Path::new(\"hi/there.txt\").with_extension(\"..\"), \"hi/there...\");\n+        t!(s: Path::new(\"hi/there\").with_extension(\"txt\"), \"hi/there.txt\");\n+        t!(s: Path::new(\"hi/there\").with_extension(\".\"), \"hi/there..\");\n+        t!(s: Path::new(\"hi/there\").with_extension(\"..\"), \"hi/there...\");\n+        t!(s: Path::new(\"hi/there.\").with_extension(\"txt\"), \"hi/there.txt\");\n+        t!(s: Path::new(\"hi/.foo\").with_extension(\"txt\"), \"hi/.foo.txt\");\n+        t!(s: Path::new(\"hi/there.txt\").with_extension(\".foo\"), \"hi/there..foo\");\n+        t!(s: Path::new(\"/\").with_extension(\"txt\"), \"/\");\n+        t!(s: Path::new(\"/\").with_extension(\".\"), \"/\");\n+        t!(s: Path::new(\"/\").with_extension(\"..\"), \"/\");\n+        t!(s: Path::new(\".\").with_extension(\"txt\"), \".\");\n     }\n \n     #[test]\n@@ -997,19 +997,19 @@ mod tests {\n                 {\n                     let path = $path;\n                     let arg = $arg;\n-                    let mut p1 = Path::init(path);\n+                    let mut p1 = Path::new(path);\n                     p1.$set(arg);\n-                    let p2 = Path::init(path);\n+                    let p2 = Path::new(path);\n                     assert_eq!(p1, p2.$with(arg));\n                 }\n             );\n             (v: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n                 {\n                     let path = $path;\n                     let arg = $arg;\n-                    let mut p1 = Path::init(path);\n+                    let mut p1 = Path::new(path);\n                     p1.$set(arg);\n-                    let p2 = Path::init(path);\n+                    let p2 = Path::new(path);\n                     assert_eq!(p1, p2.$with(arg));\n                 }\n             )\n@@ -1069,47 +1069,47 @@ mod tests {\n             )\n         )\n \n-        t!(v: Path::init(b!(\"a/b/c\")), Some(b!(\"c\")), b!(\"a/b\"), Some(b!(\"c\")), None);\n-        t!(v: Path::init(b!(\"a/b/\", 0xff)), Some(b!(0xff)), b!(\"a/b\"), Some(b!(0xff)), None);\n-        t!(v: Path::init(b!(\"hi/there.\", 0xff)), Some(b!(\"there.\", 0xff)), b!(\"hi\"),\n+        t!(v: Path::new(b!(\"a/b/c\")), Some(b!(\"c\")), b!(\"a/b\"), Some(b!(\"c\")), None);\n+        t!(v: Path::new(b!(\"a/b/\", 0xff)), Some(b!(0xff)), b!(\"a/b\"), Some(b!(0xff)), None);\n+        t!(v: Path::new(b!(\"hi/there.\", 0xff)), Some(b!(\"there.\", 0xff)), b!(\"hi\"),\n               Some(b!(\"there\")), Some(b!(0xff)));\n-        t!(s: Path::init(\"a/b/c\"), Some(\"c\"), Some(\"a/b\"), Some(\"c\"), None);\n-        t!(s: Path::init(\".\"), None, Some(\".\"), None, None);\n-        t!(s: Path::init(\"/\"), None, Some(\"/\"), None, None);\n-        t!(s: Path::init(\"..\"), None, Some(\"..\"), None, None);\n-        t!(s: Path::init(\"../..\"), None, Some(\"../..\"), None, None);\n-        t!(s: Path::init(\"hi/there.txt\"), Some(\"there.txt\"), Some(\"hi\"),\n+        t!(s: Path::new(\"a/b/c\"), Some(\"c\"), Some(\"a/b\"), Some(\"c\"), None);\n+        t!(s: Path::new(\".\"), None, Some(\".\"), None, None);\n+        t!(s: Path::new(\"/\"), None, Some(\"/\"), None, None);\n+        t!(s: Path::new(\"..\"), None, Some(\"..\"), None, None);\n+        t!(s: Path::new(\"../..\"), None, Some(\"../..\"), None, None);\n+        t!(s: Path::new(\"hi/there.txt\"), Some(\"there.txt\"), Some(\"hi\"),\n               Some(\"there\"), Some(\"txt\"));\n-        t!(s: Path::init(\"hi/there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), None);\n-        t!(s: Path::init(\"hi/there.\"), Some(\"there.\"), Some(\"hi\"),\n+        t!(s: Path::new(\"hi/there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), None);\n+        t!(s: Path::new(\"hi/there.\"), Some(\"there.\"), Some(\"hi\"),\n               Some(\"there\"), Some(\"\"));\n-        t!(s: Path::init(\"hi/.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n-        t!(s: Path::init(\"hi/..there\"), Some(\"..there\"), Some(\"hi\"),\n+        t!(s: Path::new(\"hi/.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n+        t!(s: Path::new(\"hi/..there\"), Some(\"..there\"), Some(\"hi\"),\n               Some(\".\"), Some(\"there\"));\n-        t!(s: Path::init(b!(\"a/b/\", 0xff)), None, Some(\"a/b\"), None, None);\n-        t!(s: Path::init(b!(\"a/b/\", 0xff, \".txt\")), None, Some(\"a/b\"), None, Some(\"txt\"));\n-        t!(s: Path::init(b!(\"a/b/c.\", 0x80)), None, Some(\"a/b\"), Some(\"c\"), None);\n-        t!(s: Path::init(b!(0xff, \"/b\")), Some(\"b\"), None, Some(\"b\"), None);\n+        t!(s: Path::new(b!(\"a/b/\", 0xff)), None, Some(\"a/b\"), None, None);\n+        t!(s: Path::new(b!(\"a/b/\", 0xff, \".txt\")), None, Some(\"a/b\"), None, Some(\"txt\"));\n+        t!(s: Path::new(b!(\"a/b/c.\", 0x80)), None, Some(\"a/b\"), Some(\"c\"), None);\n+        t!(s: Path::new(b!(0xff, \"/b\")), Some(\"b\"), None, Some(\"b\"), None);\n     }\n \n     #[test]\n     fn test_dir_path() {\n-        t!(v: Path::init(b!(\"hi/there\", 0x80)).dir_path(), b!(\"hi\"));\n-        t!(v: Path::init(b!(\"hi\", 0xff, \"/there\")).dir_path(), b!(\"hi\", 0xff));\n-        t!(s: Path::init(\"hi/there\").dir_path(), \"hi\");\n-        t!(s: Path::init(\"hi\").dir_path(), \".\");\n-        t!(s: Path::init(\"/hi\").dir_path(), \"/\");\n-        t!(s: Path::init(\"/\").dir_path(), \"/\");\n-        t!(s: Path::init(\"..\").dir_path(), \"..\");\n-        t!(s: Path::init(\"../..\").dir_path(), \"../..\");\n+        t!(v: Path::new(b!(\"hi/there\", 0x80)).dir_path(), b!(\"hi\"));\n+        t!(v: Path::new(b!(\"hi\", 0xff, \"/there\")).dir_path(), b!(\"hi\", 0xff));\n+        t!(s: Path::new(\"hi/there\").dir_path(), \"hi\");\n+        t!(s: Path::new(\"hi\").dir_path(), \".\");\n+        t!(s: Path::new(\"/hi\").dir_path(), \"/\");\n+        t!(s: Path::new(\"/\").dir_path(), \"/\");\n+        t!(s: Path::new(\"..\").dir_path(), \"..\");\n+        t!(s: Path::new(\"../..\").dir_path(), \"../..\");\n     }\n \n     #[test]\n     fn test_is_absolute() {\n         macro_rules! t(\n             (s: $path:expr, $abs:expr, $rel:expr) => (\n                 {\n-                    let path = Path::init($path);\n+                    let path = Path::new($path);\n                     assert_eq!(path.is_absolute(), $abs);\n                     assert_eq!(path.is_relative(), $rel);\n                 }\n@@ -1130,8 +1130,8 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $dest:expr, $exp:expr) => (\n                 {\n-                    let path = Path::init($path);\n-                    let dest = Path::init($dest);\n+                    let path = Path::new($path);\n+                    let dest = Path::new($dest);\n                     assert_eq!(path.is_ancestor_of(&dest), $exp);\n                 }\n             )\n@@ -1164,15 +1164,15 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $child:expr, $exp:expr) => (\n                 {\n-                    let path = Path::init($path);\n-                    let child = Path::init($child);\n+                    let path = Path::new($path);\n+                    let child = Path::new($child);\n                     assert_eq!(path.ends_with_path(&child), $exp);\n                 }\n             );\n             (v: $path:expr, $child:expr, $exp:expr) => (\n                 {\n-                    let path = Path::init($path);\n-                    let child = Path::init($child);\n+                    let path = Path::new($path);\n+                    let child = Path::new($child);\n                     assert_eq!(path.ends_with_path(&child), $exp);\n                 }\n             )\n@@ -1203,8 +1203,8 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $other:expr, $exp:expr) => (\n                 {\n-                    let path = Path::init($path);\n-                    let other = Path::init($other);\n+                    let path = Path::new($path);\n+                    let other = Path::new($other);\n                     let res = path.path_relative_from(&other);\n                     assert_eq!(res.as_ref().and_then(|x| x.as_str()), $exp);\n                 }\n@@ -1248,7 +1248,7 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $exp:expr) => (\n                 {\n-                    let path = Path::init($path);\n+                    let path = Path::new($path);\n                     let comps = path.components().to_owned_vec();\n                     let exp: &[&str] = $exp;\n                     let exps = exp.iter().map(|x| x.as_bytes()).to_owned_vec();\n@@ -1262,7 +1262,7 @@ mod tests {\n             );\n             (v: [$($arg:expr),+], [$([$($exp:expr),*]),*]) => (\n                 {\n-                    let path = Path::init(b!($($arg),+));\n+                    let path = Path::new(b!($($arg),+));\n                     let comps = path.components().to_owned_vec();\n                     let exp: &[&[u8]] = [$(b!($($exp),*)),*];\n                     assert!(comps.as_slice() == exp, \"components: Expected {:?}, found {:?}\",\n@@ -1297,7 +1297,7 @@ mod tests {\n         macro_rules! t(\n             (v: [$($arg:expr),+], $exp:expr) => (\n                 {\n-                    let path = Path::init(b!($($arg),+));\n+                    let path = Path::new(b!($($arg),+));\n                     let comps = path.str_components().to_owned_vec();\n                     let exp: &[Option<&str>] = $exp;\n                     assert!(comps.as_slice() == exp,\n@@ -1327,81 +1327,81 @@ mod bench {\n \n     #[bench]\n     fn join_home_dir(bh: &mut BenchHarness) {\n-        let posix_path = Path::init(\"/\");\n+        let posix_path = Path::new(\"/\");\n         bh.iter(|| {\n             posix_path.join(\"home\");\n         });\n     }\n \n     #[bench]\n     fn join_abs_path_home_dir(bh: &mut BenchHarness) {\n-        let posix_path = Path::init(\"/\");\n+        let posix_path = Path::new(\"/\");\n         bh.iter(|| {\n             posix_path.join(\"/home\");\n         });\n     }\n \n     #[bench]\n     fn join_many_home_dir(bh: &mut BenchHarness) {\n-        let posix_path = Path::init(\"/\");\n+        let posix_path = Path::new(\"/\");\n         bh.iter(|| {\n             posix_path.join_many(&[\"home\"]);\n         });\n     }\n \n     #[bench]\n     fn join_many_abs_path_home_dir(bh: &mut BenchHarness) {\n-        let posix_path = Path::init(\"/\");\n+        let posix_path = Path::new(\"/\");\n         bh.iter(|| {\n             posix_path.join_many(&[\"/home\"]);\n         });\n     }\n \n     #[bench]\n     fn push_home_dir(bh: &mut BenchHarness) {\n-        let mut posix_path = Path::init(\"/\");\n+        let mut posix_path = Path::new(\"/\");\n         bh.iter(|| {\n             posix_path.push(\"home\");\n         });\n     }\n \n     #[bench]\n     fn push_abs_path_home_dir(bh: &mut BenchHarness) {\n-        let mut posix_path = Path::init(\"/\");\n+        let mut posix_path = Path::new(\"/\");\n         bh.iter(|| {\n             posix_path.push(\"/home\");\n         });\n     }\n \n     #[bench]\n     fn push_many_home_dir(bh: &mut BenchHarness) {\n-        let mut posix_path = Path::init(\"/\");\n+        let mut posix_path = Path::new(\"/\");\n         bh.iter(|| {\n             posix_path.push_many(&[\"home\"]);\n         });\n     }\n \n     #[bench]\n     fn push_many_abs_path_home_dir(bh: &mut BenchHarness) {\n-        let mut posix_path = Path::init(\"/\");\n+        let mut posix_path = Path::new(\"/\");\n         bh.iter(|| {\n             posix_path.push_many(&[\"/home\"]);\n         });\n     }\n \n     #[bench]\n     fn ends_with_path_home_dir(bh: &mut BenchHarness) {\n-        let posix_home_path = Path::init(\"/home\");\n+        let posix_home_path = Path::new(\"/home\");\n         bh.iter(|| {\n-            posix_home_path.ends_with_path(&Path::init(\"home\"));\n+            posix_home_path.ends_with_path(&Path::new(\"home\"));\n         });\n     }\n \n     #[bench]\n     fn ends_with_path_missmatch_jome_home(bh: &mut BenchHarness) {\n-        let posix_home_path = Path::init(\"/home\");\n+        let posix_home_path = Path::new(\"/home\");\n         bh.iter(|| {\n-            posix_home_path.ends_with_path(&Path::init(\"jome\"));\n+            posix_home_path.ends_with_path(&Path::new(\"jome\"));\n         });\n     }\n }"}, {"sha": "cc2af54fd105c62fe2db9cf35d30f1f1a3964767", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 172, "deletions": 172, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -93,7 +93,7 @@ impl Eq for Path {\n \n impl FromStr for Path {\n     fn from_str(s: &str) -> Option<Path> {\n-        Path::init_opt(s)\n+        Path::new_opt(s)\n     }\n }\n \n@@ -162,7 +162,7 @@ impl GenericPathUnsafe for Path {\n     ///\n     /// Raises the `str::not_utf8` condition if not valid UTF-8.\n     #[inline]\n-    unsafe fn init_unchecked<T: BytesContainer>(path: T) -> Path {\n+    unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Path {\n         let (prefix, path) = Path::normalize_(path.container_as_str());\n         assert!(!path.is_empty());\n         let mut ret = Path{ repr: path, prefix: prefix, sepidx: None };\n@@ -303,15 +303,15 @@ impl GenericPathUnsafe for Path {\n \n impl GenericPath for Path {\n     #[inline]\n-    fn init_opt<T: BytesContainer>(path: T) -> Option<Path> {\n+    fn new_opt<T: BytesContainer>(path: T) -> Option<Path> {\n         let s = path.container_as_str_opt();\n         match s {\n             None => None,\n             Some(s) => {\n                 if contains_nul(s.as_bytes()) {\n                     None\n                 } else {\n-                    Some(unsafe { GenericPathUnsafe::init_unchecked(s) })\n+                    Some(unsafe { GenericPathUnsafe::new_unchecked(s) })\n                 }\n             }\n         }\n@@ -395,7 +395,7 @@ impl GenericPath for Path {\n     }\n \n     fn dir_path(&self) -> Path {\n-        unsafe { GenericPathUnsafe::init_unchecked(self.dirname_str().unwrap()) }\n+        unsafe { GenericPathUnsafe::new_unchecked(self.dirname_str().unwrap()) }\n     }\n \n     #[inline]\n@@ -426,14 +426,14 @@ impl GenericPath for Path {\n \n     fn root_path(&self) -> Option<Path> {\n         if self.is_absolute() {\n-            Some(Path::init(match self.prefix {\n+            Some(Path::new(match self.prefix {\n                 Some(VerbatimDiskPrefix)|Some(DiskPrefix) => {\n                     self.repr.slice_to(self.prefix_len()+1)\n                 }\n                 _ => self.repr.slice_to(self.prefix_len())\n             }))\n         } else if is_vol_relative(self) {\n-            Some(Path::init(self.repr.slice_to(1)))\n+            Some(Path::new(self.repr.slice_to(1)))\n         } else {\n             None\n         }\n@@ -563,7 +563,7 @@ impl GenericPath for Path {\n                     }\n                 }\n             }\n-            Some(Path::init(comps.connect(\"\\\\\")))\n+            Some(Path::new(comps.connect(\"\\\\\")))\n         }\n     }\n \n@@ -591,14 +591,14 @@ impl Path {\n     /// Raises the `null_byte` condition if the vector contains a NUL.\n     /// Raises the `str::not_utf8` condition if invalid UTF-8.\n     #[inline]\n-    pub fn init<T: BytesContainer>(path: T) -> Path {\n-        GenericPath::init(path)\n+    pub fn new<T: BytesContainer>(path: T) -> Path {\n+        GenericPath::new(path)\n     }\n \n     /// Returns a new Path from a byte vector or string, if possible\n     #[inline]\n-    pub fn init_opt<T: BytesContainer>(path: T) -> Option<Path> {\n-        GenericPath::init_opt(path)\n+    pub fn new_opt<T: BytesContainer>(path: T) -> Option<Path> {\n+        GenericPath::new_opt(path)\n     }\n \n     /// Returns an iterator that yields each component of the path in turn as a Option<&str>.\n@@ -1147,100 +1147,100 @@ mod tests {\n     #[test]\n     fn test_paths() {\n         let empty: &[u8] = [];\n-        t!(v: Path::init(empty), b!(\".\"));\n-        t!(v: Path::init(b!(\"\\\\\")), b!(\"\\\\\"));\n-        t!(v: Path::init(b!(\"a\\\\b\\\\c\")), b!(\"a\\\\b\\\\c\"));\n-\n-        t!(s: Path::init(\"\"), \".\");\n-        t!(s: Path::init(\"\\\\\"), \"\\\\\");\n-        t!(s: Path::init(\"hi\"), \"hi\");\n-        t!(s: Path::init(\"hi\\\\\"), \"hi\");\n-        t!(s: Path::init(\"\\\\lib\"), \"\\\\lib\");\n-        t!(s: Path::init(\"\\\\lib\\\\\"), \"\\\\lib\");\n-        t!(s: Path::init(\"hi\\\\there\"), \"hi\\\\there\");\n-        t!(s: Path::init(\"hi\\\\there.txt\"), \"hi\\\\there.txt\");\n-        t!(s: Path::init(\"/\"), \"\\\\\");\n-        t!(s: Path::init(\"hi/\"), \"hi\");\n-        t!(s: Path::init(\"/lib\"), \"\\\\lib\");\n-        t!(s: Path::init(\"/lib/\"), \"\\\\lib\");\n-        t!(s: Path::init(\"hi/there\"), \"hi\\\\there\");\n-\n-        t!(s: Path::init(\"hi\\\\there\\\\\"), \"hi\\\\there\");\n-        t!(s: Path::init(\"hi\\\\..\\\\there\"), \"there\");\n-        t!(s: Path::init(\"hi/../there\"), \"there\");\n-        t!(s: Path::init(\"..\\\\hi\\\\there\"), \"..\\\\hi\\\\there\");\n-        t!(s: Path::init(\"\\\\..\\\\hi\\\\there\"), \"\\\\hi\\\\there\");\n-        t!(s: Path::init(\"/../hi/there\"), \"\\\\hi\\\\there\");\n-        t!(s: Path::init(\"foo\\\\..\"), \".\");\n-        t!(s: Path::init(\"\\\\foo\\\\..\"), \"\\\\\");\n-        t!(s: Path::init(\"\\\\foo\\\\..\\\\..\"), \"\\\\\");\n-        t!(s: Path::init(\"\\\\foo\\\\..\\\\..\\\\bar\"), \"\\\\bar\");\n-        t!(s: Path::init(\"\\\\.\\\\hi\\\\.\\\\there\\\\.\"), \"\\\\hi\\\\there\");\n-        t!(s: Path::init(\"\\\\.\\\\hi\\\\.\\\\there\\\\.\\\\..\"), \"\\\\hi\");\n-        t!(s: Path::init(\"foo\\\\..\\\\..\"), \"..\");\n-        t!(s: Path::init(\"foo\\\\..\\\\..\\\\..\"), \"..\\\\..\");\n-        t!(s: Path::init(\"foo\\\\..\\\\..\\\\bar\"), \"..\\\\bar\");\n-\n-        assert_eq!(Path::init(b!(\"foo\\\\bar\")).into_vec(), b!(\"foo\\\\bar\").to_owned());\n-        assert_eq!(Path::init(b!(\"\\\\foo\\\\..\\\\..\\\\bar\")).into_vec(),\n+        t!(v: Path::new(empty), b!(\".\"));\n+        t!(v: Path::new(b!(\"\\\\\")), b!(\"\\\\\"));\n+        t!(v: Path::new(b!(\"a\\\\b\\\\c\")), b!(\"a\\\\b\\\\c\"));\n+\n+        t!(s: Path::new(\"\"), \".\");\n+        t!(s: Path::new(\"\\\\\"), \"\\\\\");\n+        t!(s: Path::new(\"hi\"), \"hi\");\n+        t!(s: Path::new(\"hi\\\\\"), \"hi\");\n+        t!(s: Path::new(\"\\\\lib\"), \"\\\\lib\");\n+        t!(s: Path::new(\"\\\\lib\\\\\"), \"\\\\lib\");\n+        t!(s: Path::new(\"hi\\\\there\"), \"hi\\\\there\");\n+        t!(s: Path::new(\"hi\\\\there.txt\"), \"hi\\\\there.txt\");\n+        t!(s: Path::new(\"/\"), \"\\\\\");\n+        t!(s: Path::new(\"hi/\"), \"hi\");\n+        t!(s: Path::new(\"/lib\"), \"\\\\lib\");\n+        t!(s: Path::new(\"/lib/\"), \"\\\\lib\");\n+        t!(s: Path::new(\"hi/there\"), \"hi\\\\there\");\n+\n+        t!(s: Path::new(\"hi\\\\there\\\\\"), \"hi\\\\there\");\n+        t!(s: Path::new(\"hi\\\\..\\\\there\"), \"there\");\n+        t!(s: Path::new(\"hi/../there\"), \"there\");\n+        t!(s: Path::new(\"..\\\\hi\\\\there\"), \"..\\\\hi\\\\there\");\n+        t!(s: Path::new(\"\\\\..\\\\hi\\\\there\"), \"\\\\hi\\\\there\");\n+        t!(s: Path::new(\"/../hi/there\"), \"\\\\hi\\\\there\");\n+        t!(s: Path::new(\"foo\\\\..\"), \".\");\n+        t!(s: Path::new(\"\\\\foo\\\\..\"), \"\\\\\");\n+        t!(s: Path::new(\"\\\\foo\\\\..\\\\..\"), \"\\\\\");\n+        t!(s: Path::new(\"\\\\foo\\\\..\\\\..\\\\bar\"), \"\\\\bar\");\n+        t!(s: Path::new(\"\\\\.\\\\hi\\\\.\\\\there\\\\.\"), \"\\\\hi\\\\there\");\n+        t!(s: Path::new(\"\\\\.\\\\hi\\\\.\\\\there\\\\.\\\\..\"), \"\\\\hi\");\n+        t!(s: Path::new(\"foo\\\\..\\\\..\"), \"..\");\n+        t!(s: Path::new(\"foo\\\\..\\\\..\\\\..\"), \"..\\\\..\");\n+        t!(s: Path::new(\"foo\\\\..\\\\..\\\\bar\"), \"..\\\\bar\");\n+\n+        assert_eq!(Path::new(b!(\"foo\\\\bar\")).into_vec(), b!(\"foo\\\\bar\").to_owned());\n+        assert_eq!(Path::new(b!(\"\\\\foo\\\\..\\\\..\\\\bar\")).into_vec(),\n                    b!(\"\\\\bar\").to_owned());\n \n-        t!(s: Path::init(\"\\\\\\\\a\"), \"\\\\a\");\n-        t!(s: Path::init(\"\\\\\\\\a\\\\\"), \"\\\\a\");\n-        t!(s: Path::init(\"\\\\\\\\a\\\\b\"), \"\\\\\\\\a\\\\b\");\n-        t!(s: Path::init(\"\\\\\\\\a\\\\b\\\\\"), \"\\\\\\\\a\\\\b\");\n-        t!(s: Path::init(\"\\\\\\\\a\\\\b/\"), \"\\\\\\\\a\\\\b\");\n-        t!(s: Path::init(\"\\\\\\\\\\\\b\"), \"\\\\b\");\n-        t!(s: Path::init(\"\\\\\\\\a\\\\\\\\b\"), \"\\\\a\\\\b\");\n-        t!(s: Path::init(\"\\\\\\\\a\\\\b\\\\c\"), \"\\\\\\\\a\\\\b\\\\c\");\n-        t!(s: Path::init(\"\\\\\\\\server\\\\share/path\"), \"\\\\\\\\server\\\\share\\\\path\");\n-        t!(s: Path::init(\"\\\\\\\\server/share/path\"), \"\\\\\\\\server\\\\share\\\\path\");\n-        t!(s: Path::init(\"C:a\\\\b.txt\"), \"C:a\\\\b.txt\");\n-        t!(s: Path::init(\"C:a/b.txt\"), \"C:a\\\\b.txt\");\n-        t!(s: Path::init(\"z:\\\\a\\\\b.txt\"), \"Z:\\\\a\\\\b.txt\");\n-        t!(s: Path::init(\"z:/a/b.txt\"), \"Z:\\\\a\\\\b.txt\");\n-        t!(s: Path::init(\"ab:/a/b.txt\"), \"ab:\\\\a\\\\b.txt\");\n-        t!(s: Path::init(\"C:\\\\\"), \"C:\\\\\");\n-        t!(s: Path::init(\"C:\"), \"C:\");\n-        t!(s: Path::init(\"q:\"), \"Q:\");\n-        t!(s: Path::init(\"C:/\"), \"C:\\\\\");\n-        t!(s: Path::init(\"C:\\\\foo\\\\..\"), \"C:\\\\\");\n-        t!(s: Path::init(\"C:foo\\\\..\"), \"C:\");\n-        t!(s: Path::init(\"C:\\\\a\\\\\"), \"C:\\\\a\");\n-        t!(s: Path::init(\"C:\\\\a/\"), \"C:\\\\a\");\n-        t!(s: Path::init(\"C:\\\\a\\\\b\\\\\"), \"C:\\\\a\\\\b\");\n-        t!(s: Path::init(\"C:\\\\a\\\\b/\"), \"C:\\\\a\\\\b\");\n-        t!(s: Path::init(\"C:a\\\\\"), \"C:a\");\n-        t!(s: Path::init(\"C:a/\"), \"C:a\");\n-        t!(s: Path::init(\"C:a\\\\b\\\\\"), \"C:a\\\\b\");\n-        t!(s: Path::init(\"C:a\\\\b/\"), \"C:a\\\\b\");\n-        t!(s: Path::init(\"\\\\\\\\?\\\\z:\\\\a\\\\b.txt\"), \"\\\\\\\\?\\\\z:\\\\a\\\\b.txt\");\n-        t!(s: Path::init(\"\\\\\\\\?\\\\C:/a/b.txt\"), \"\\\\\\\\?\\\\C:/a/b.txt\");\n-        t!(s: Path::init(\"\\\\\\\\?\\\\C:\\\\a/b.txt\"), \"\\\\\\\\?\\\\C:\\\\a/b.txt\");\n-        t!(s: Path::init(\"\\\\\\\\?\\\\test\\\\a\\\\b.txt\"), \"\\\\\\\\?\\\\test\\\\a\\\\b.txt\");\n-        t!(s: Path::init(\"\\\\\\\\?\\\\foo\\\\bar\\\\\"), \"\\\\\\\\?\\\\foo\\\\bar\\\\\");\n-        t!(s: Path::init(\"\\\\\\\\.\\\\foo\\\\bar\"), \"\\\\\\\\.\\\\foo\\\\bar\");\n-        t!(s: Path::init(\"\\\\\\\\.\\\\\"), \"\\\\\\\\.\\\\\");\n-        t!(s: Path::init(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\"), \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\");\n-        t!(s: Path::init(\"\\\\\\\\?\\\\UNC\\\\server/share\"), \"\\\\\\\\?\\\\UNC\\\\server/share\\\\\");\n-        t!(s: Path::init(\"\\\\\\\\?\\\\UNC\\\\server\"), \"\\\\\\\\?\\\\UNC\\\\server\\\\\");\n-        t!(s: Path::init(\"\\\\\\\\?\\\\UNC\\\\\"), \"\\\\\\\\?\\\\UNC\\\\\\\\\");\n-        t!(s: Path::init(\"\\\\\\\\?\\\\UNC\"), \"\\\\\\\\?\\\\UNC\");\n+        t!(s: Path::new(\"\\\\\\\\a\"), \"\\\\a\");\n+        t!(s: Path::new(\"\\\\\\\\a\\\\\"), \"\\\\a\");\n+        t!(s: Path::new(\"\\\\\\\\a\\\\b\"), \"\\\\\\\\a\\\\b\");\n+        t!(s: Path::new(\"\\\\\\\\a\\\\b\\\\\"), \"\\\\\\\\a\\\\b\");\n+        t!(s: Path::new(\"\\\\\\\\a\\\\b/\"), \"\\\\\\\\a\\\\b\");\n+        t!(s: Path::new(\"\\\\\\\\\\\\b\"), \"\\\\b\");\n+        t!(s: Path::new(\"\\\\\\\\a\\\\\\\\b\"), \"\\\\a\\\\b\");\n+        t!(s: Path::new(\"\\\\\\\\a\\\\b\\\\c\"), \"\\\\\\\\a\\\\b\\\\c\");\n+        t!(s: Path::new(\"\\\\\\\\server\\\\share/path\"), \"\\\\\\\\server\\\\share\\\\path\");\n+        t!(s: Path::new(\"\\\\\\\\server/share/path\"), \"\\\\\\\\server\\\\share\\\\path\");\n+        t!(s: Path::new(\"C:a\\\\b.txt\"), \"C:a\\\\b.txt\");\n+        t!(s: Path::new(\"C:a/b.txt\"), \"C:a\\\\b.txt\");\n+        t!(s: Path::new(\"z:\\\\a\\\\b.txt\"), \"Z:\\\\a\\\\b.txt\");\n+        t!(s: Path::new(\"z:/a/b.txt\"), \"Z:\\\\a\\\\b.txt\");\n+        t!(s: Path::new(\"ab:/a/b.txt\"), \"ab:\\\\a\\\\b.txt\");\n+        t!(s: Path::new(\"C:\\\\\"), \"C:\\\\\");\n+        t!(s: Path::new(\"C:\"), \"C:\");\n+        t!(s: Path::new(\"q:\"), \"Q:\");\n+        t!(s: Path::new(\"C:/\"), \"C:\\\\\");\n+        t!(s: Path::new(\"C:\\\\foo\\\\..\"), \"C:\\\\\");\n+        t!(s: Path::new(\"C:foo\\\\..\"), \"C:\");\n+        t!(s: Path::new(\"C:\\\\a\\\\\"), \"C:\\\\a\");\n+        t!(s: Path::new(\"C:\\\\a/\"), \"C:\\\\a\");\n+        t!(s: Path::new(\"C:\\\\a\\\\b\\\\\"), \"C:\\\\a\\\\b\");\n+        t!(s: Path::new(\"C:\\\\a\\\\b/\"), \"C:\\\\a\\\\b\");\n+        t!(s: Path::new(\"C:a\\\\\"), \"C:a\");\n+        t!(s: Path::new(\"C:a/\"), \"C:a\");\n+        t!(s: Path::new(\"C:a\\\\b\\\\\"), \"C:a\\\\b\");\n+        t!(s: Path::new(\"C:a\\\\b/\"), \"C:a\\\\b\");\n+        t!(s: Path::new(\"\\\\\\\\?\\\\z:\\\\a\\\\b.txt\"), \"\\\\\\\\?\\\\z:\\\\a\\\\b.txt\");\n+        t!(s: Path::new(\"\\\\\\\\?\\\\C:/a/b.txt\"), \"\\\\\\\\?\\\\C:/a/b.txt\");\n+        t!(s: Path::new(\"\\\\\\\\?\\\\C:\\\\a/b.txt\"), \"\\\\\\\\?\\\\C:\\\\a/b.txt\");\n+        t!(s: Path::new(\"\\\\\\\\?\\\\test\\\\a\\\\b.txt\"), \"\\\\\\\\?\\\\test\\\\a\\\\b.txt\");\n+        t!(s: Path::new(\"\\\\\\\\?\\\\foo\\\\bar\\\\\"), \"\\\\\\\\?\\\\foo\\\\bar\\\\\");\n+        t!(s: Path::new(\"\\\\\\\\.\\\\foo\\\\bar\"), \"\\\\\\\\.\\\\foo\\\\bar\");\n+        t!(s: Path::new(\"\\\\\\\\.\\\\\"), \"\\\\\\\\.\\\\\");\n+        t!(s: Path::new(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\"), \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\");\n+        t!(s: Path::new(\"\\\\\\\\?\\\\UNC\\\\server/share\"), \"\\\\\\\\?\\\\UNC\\\\server/share\\\\\");\n+        t!(s: Path::new(\"\\\\\\\\?\\\\UNC\\\\server\"), \"\\\\\\\\?\\\\UNC\\\\server\\\\\");\n+        t!(s: Path::new(\"\\\\\\\\?\\\\UNC\\\\\"), \"\\\\\\\\?\\\\UNC\\\\\\\\\");\n+        t!(s: Path::new(\"\\\\\\\\?\\\\UNC\"), \"\\\\\\\\?\\\\UNC\");\n \n         // I'm not sure whether \\\\.\\foo/bar should normalize to \\\\.\\foo\\bar\n         // as information is sparse and this isn't really googleable.\n         // I'm going to err on the side of not normalizing it, as this skips the filesystem\n-        t!(s: Path::init(\"\\\\\\\\.\\\\foo/bar\"), \"\\\\\\\\.\\\\foo/bar\");\n-        t!(s: Path::init(\"\\\\\\\\.\\\\foo\\\\bar\"), \"\\\\\\\\.\\\\foo\\\\bar\");\n+        t!(s: Path::new(\"\\\\\\\\.\\\\foo/bar\"), \"\\\\\\\\.\\\\foo/bar\");\n+        t!(s: Path::new(\"\\\\\\\\.\\\\foo\\\\bar\"), \"\\\\\\\\.\\\\foo\\\\bar\");\n     }\n \n     #[test]\n     fn test_opt_paths() {\n-        assert_eq!(Path::init_opt(b!(\"foo\\\\bar\", 0)), None);\n-        assert_eq!(Path::init_opt(b!(\"foo\\\\bar\", 0x80)), None);\n-        t!(v: Path::init_opt(b!(\"foo\\\\bar\")).unwrap(), b!(\"foo\\\\bar\"));\n-        assert_eq!(Path::init_opt(\"foo\\\\bar\\0\"), None);\n-        t!(s: Path::init_opt(\"foo\\\\bar\").unwrap(), \"foo\\\\bar\");\n+        assert_eq!(Path::new_opt(b!(\"foo\\\\bar\", 0)), None);\n+        assert_eq!(Path::new_opt(b!(\"foo\\\\bar\", 0x80)), None);\n+        t!(v: Path::new_opt(b!(\"foo\\\\bar\")).unwrap(), b!(\"foo\\\\bar\"));\n+        assert_eq!(Path::new_opt(\"foo\\\\bar\\0\"), None);\n+        t!(s: Path::new_opt(\"foo\\\\bar\").unwrap(), \"foo\\\\bar\");\n     }\n \n     #[test]\n@@ -1253,7 +1253,7 @@ mod tests {\n             assert_eq!(v.as_slice(), b!(\"foo\\\\bar\", 0));\n             (b!(\"\\\\bar\").to_owned())\n         }).inside(|| {\n-            Path::init(b!(\"foo\\\\bar\", 0))\n+            Path::new(b!(\"foo\\\\bar\", 0))\n         });\n         assert!(handled);\n         assert_eq!(p.as_vec(), b!(\"\\\\bar\"));\n@@ -1301,12 +1301,12 @@ mod tests {\n             cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n             }).inside(|| {\n-                Path::init(b!(\"foo\\\\bar\", 0))\n+                Path::new(b!(\"foo\\\\bar\", 0))\n             });\n         })\n \n         t!(~\"set_filename w\\\\nul\" => {\n-            let mut p = Path::init(b!(\"foo\\\\bar\"));\n+            let mut p = Path::new(b!(\"foo\\\\bar\"));\n             cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n             }).inside(|| {\n@@ -1315,7 +1315,7 @@ mod tests {\n         })\n \n         t!(~\"push w\\\\nul\" => {\n-            let mut p = Path::init(b!(\"foo\\\\bar\"));\n+            let mut p = Path::new(b!(\"foo\\\\bar\"));\n             cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n             }).inside(|| {\n@@ -1327,25 +1327,25 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_not_utf8_fail() {\n-        Path::init(b!(\"hello\", 0x80, \".txt\"));\n+        Path::new(b!(\"hello\", 0x80, \".txt\"));\n     }\n \n     #[test]\n     fn test_display_str() {\n-        let path = Path::init(\"foo\");\n+        let path = Path::new(\"foo\");\n         assert_eq!(path.display().to_str(), ~\"foo\");\n-        let path = Path::init(b!(\"\\\\\"));\n+        let path = Path::new(b!(\"\\\\\"));\n         assert_eq!(path.filename_display().to_str(), ~\"\");\n \n         let mut called = false;\n-        let path = Path::init(\"foo\");\n+        let path = Path::new(\"foo\");\n         path.display().with_str(|s| {\n             assert_eq!(s, \"foo\");\n             called = true;\n         });\n         assert!(called);\n         called = false;\n-        let path = Path::init(b!(\"\\\\\"));\n+        let path = Path::new(b!(\"\\\\\"));\n         path.filename_display().with_str(|s| {\n             assert_eq!(s, \"\");\n             called = true;\n@@ -1358,7 +1358,7 @@ mod tests {\n         macro_rules! t(\n             ($path:expr, $exp:expr, $expf:expr) => (\n                 {\n-                    let path = Path::init($path);\n+                    let path = Path::new($path);\n                     let f = format!(\"{}\", path.display());\n                     assert_eq!(f.as_slice(), $exp);\n                     let f = format!(\"{}\", path.filename_display());\n@@ -1377,20 +1377,20 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    let path = Path::init($path);\n+                    let path = Path::new($path);\n                     assert_eq!(path.$op(), Some($exp));\n                 }\n             );\n             (s: $path:expr, $op:ident, $exp:expr, opt) => (\n                 {\n-                    let path = Path::init($path);\n+                    let path = Path::new($path);\n                     let left = path.$op();\n                     assert_eq!(left, $exp);\n                 }\n             );\n             (v: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    let path = Path::init($path);\n+                    let path = Path::new($path);\n                     assert_eq!(path.$op(), $exp);\n                 }\n             )\n@@ -1499,7 +1499,7 @@ mod tests {\n                 {\n                     let path = ($path);\n                     let join = ($join);\n-                    let mut p1 = Path::init(path);\n+                    let mut p1 = Path::new(path);\n                     let p2 = p1.clone();\n                     p1.push(join);\n                     assert_eq!(p1, p2.join(join));\n@@ -1515,14 +1515,14 @@ mod tests {\n         // so there's no need for the full set of prefix tests\n \n         // we do want to check one odd case though to ensure the prefix is re-parsed\n-        let mut p = Path::init(\"\\\\\\\\?\\\\C:\");\n+        let mut p = Path::new(\"\\\\\\\\?\\\\C:\");\n         assert_eq!(prefix(&p), Some(VerbatimPrefix(2)));\n         p.push(\"foo\");\n         assert_eq!(prefix(&p), Some(VerbatimDiskPrefix));\n         assert_eq!(p.as_str(), Some(\"\\\\\\\\?\\\\C:\\\\foo\"));\n \n         // and another with verbatim non-normalized paths\n-        let mut p = Path::init(\"\\\\\\\\?\\\\C:\\\\a\\\\\");\n+        let mut p = Path::new(\"\\\\\\\\?\\\\C:\\\\a\\\\\");\n         p.push(\"foo\");\n         assert_eq!(p.as_str(), Some(\"\\\\\\\\?\\\\C:\\\\a\\\\foo\"));\n     }\n@@ -1532,8 +1532,8 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n-                    let mut p = Path::init($path);\n-                    let push = Path::init($push);\n+                    let mut p = Path::new($path);\n+                    let push = Path::new($push);\n                     p.push(&push);\n                     assert_eq!(p.as_str(), Some($exp));\n                 }\n@@ -1584,14 +1584,14 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n-                    let mut p = Path::init($path);\n+                    let mut p = Path::new($path);\n                     p.push_many($push);\n                     assert_eq!(p.as_str(), Some($exp));\n                 }\n             );\n             (v: $path:expr, $push:expr, $exp:expr) => (\n                 {\n-                    let mut p = Path::init($path);\n+                    let mut p = Path::new($path);\n                     p.push_many($push);\n                     assert_eq!(p.as_vec(), $exp);\n                 }\n@@ -1616,7 +1616,7 @@ mod tests {\n             (s: $path:expr, $left:expr, $right:expr) => (\n                 {\n                     let pstr = $path;\n-                    let mut p = Path::init(pstr);\n+                    let mut p = Path::new(pstr);\n                     let result = p.pop();\n                     let left = $left;\n                     assert!(p.as_str() == Some(left),\n@@ -1627,7 +1627,7 @@ mod tests {\n             );\n             (v: [$($path:expr),+], [$($left:expr),+], $right:expr) => (\n                 {\n-                    let mut p = Path::init(b!($($path),+));\n+                    let mut p = Path::new(b!($($path),+));\n                     let result = p.pop();\n                     assert_eq!(p.as_vec(), b!($($left),+));\n                     assert_eq!(result, $right);\n@@ -1673,28 +1673,28 @@ mod tests {\n \n     #[test]\n     fn test_root_path() {\n-        assert_eq!(Path::init(\"a\\\\b\\\\c\").root_path(), None);\n-        assert_eq!(Path::init(\"\\\\a\\\\b\\\\c\").root_path(), Some(Path::init(\"\\\\\")));\n-        assert_eq!(Path::init(\"C:a\").root_path(), None);\n-        assert_eq!(Path::init(\"C:\\\\a\").root_path(), Some(Path::init(\"C:\\\\\")));\n-        assert_eq!(Path::init(\"\\\\\\\\a\\\\b\\\\c\").root_path(), Some(Path::init(\"\\\\\\\\a\\\\b\")));\n-        assert_eq!(Path::init(\"\\\\\\\\?\\\\a\\\\b\").root_path(), Some(Path::init(\"\\\\\\\\?\\\\a\")));\n-        assert_eq!(Path::init(\"\\\\\\\\?\\\\C:\\\\a\").root_path(), Some(Path::init(\"\\\\\\\\?\\\\C:\\\\\")));\n-        assert_eq!(Path::init(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\").root_path(),\n-                   Some(Path::init(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\")));\n-        assert_eq!(Path::init(\"\\\\\\\\.\\\\a\\\\b\").root_path(), Some(Path::init(\"\\\\\\\\.\\\\a\")));\n+        assert_eq!(Path::new(\"a\\\\b\\\\c\").root_path(), None);\n+        assert_eq!(Path::new(\"\\\\a\\\\b\\\\c\").root_path(), Some(Path::new(\"\\\\\")));\n+        assert_eq!(Path::new(\"C:a\").root_path(), None);\n+        assert_eq!(Path::new(\"C:\\\\a\").root_path(), Some(Path::new(\"C:\\\\\")));\n+        assert_eq!(Path::new(\"\\\\\\\\a\\\\b\\\\c\").root_path(), Some(Path::new(\"\\\\\\\\a\\\\b\")));\n+        assert_eq!(Path::new(\"\\\\\\\\?\\\\a\\\\b\").root_path(), Some(Path::new(\"\\\\\\\\?\\\\a\")));\n+        assert_eq!(Path::new(\"\\\\\\\\?\\\\C:\\\\a\").root_path(), Some(Path::new(\"\\\\\\\\?\\\\C:\\\\\")));\n+        assert_eq!(Path::new(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\").root_path(),\n+                   Some(Path::new(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\")));\n+        assert_eq!(Path::new(\"\\\\\\\\.\\\\a\\\\b\").root_path(), Some(Path::new(\"\\\\\\\\.\\\\a\")));\n     }\n \n     #[test]\n     fn test_join() {\n-        t!(s: Path::init(\"a\\\\b\\\\c\").join(\"..\"), \"a\\\\b\");\n-        t!(s: Path::init(\"\\\\a\\\\b\\\\c\").join(\"d\"), \"\\\\a\\\\b\\\\c\\\\d\");\n-        t!(s: Path::init(\"a\\\\b\").join(\"c\\\\d\"), \"a\\\\b\\\\c\\\\d\");\n-        t!(s: Path::init(\"a\\\\b\").join(\"\\\\c\\\\d\"), \"\\\\c\\\\d\");\n-        t!(s: Path::init(\".\").join(\"a\\\\b\"), \"a\\\\b\");\n-        t!(s: Path::init(\"\\\\\").join(\"a\\\\b\"), \"\\\\a\\\\b\");\n-        t!(v: Path::init(b!(\"a\\\\b\\\\c\")).join(b!(\"..\")), b!(\"a\\\\b\"));\n-        t!(v: Path::init(b!(\"\\\\a\\\\b\\\\c\")).join(b!(\"d\")), b!(\"\\\\a\\\\b\\\\c\\\\d\"));\n+        t!(s: Path::new(\"a\\\\b\\\\c\").join(\"..\"), \"a\\\\b\");\n+        t!(s: Path::new(\"\\\\a\\\\b\\\\c\").join(\"d\"), \"\\\\a\\\\b\\\\c\\\\d\");\n+        t!(s: Path::new(\"a\\\\b\").join(\"c\\\\d\"), \"a\\\\b\\\\c\\\\d\");\n+        t!(s: Path::new(\"a\\\\b\").join(\"\\\\c\\\\d\"), \"\\\\c\\\\d\");\n+        t!(s: Path::new(\".\").join(\"a\\\\b\"), \"a\\\\b\");\n+        t!(s: Path::new(\"\\\\\").join(\"a\\\\b\"), \"\\\\a\\\\b\");\n+        t!(v: Path::new(b!(\"a\\\\b\\\\c\")).join(b!(\"..\")), b!(\"a\\\\b\"));\n+        t!(v: Path::new(b!(\"\\\\a\\\\b\\\\c\")).join(b!(\"d\")), b!(\"\\\\a\\\\b\\\\c\\\\d\"));\n         // full join testing is covered under test_push_path, so no need for\n         // the full set of prefix tests\n     }\n@@ -1704,8 +1704,8 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n-                    let path = Path::init($path);\n-                    let join = Path::init($join);\n+                    let path = Path::new($path);\n+                    let join = Path::new($join);\n                     let res = path.join(&join);\n                     assert_eq!(res.as_str(), Some($exp));\n                 }\n@@ -1729,14 +1729,14 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n-                    let path = Path::init($path);\n+                    let path = Path::new($path);\n                     let res = path.join_many($join);\n                     assert_eq!(res.as_str(), Some($exp));\n                 }\n             );\n             (v: $path:expr, $join:expr, $exp:expr) => (\n                 {\n-                    let path = Path::init($path);\n+                    let path = Path::new($path);\n                     let res = path.join_many($join);\n                     assert_eq!(res.as_vec(), $exp);\n                 }\n@@ -1760,7 +1760,7 @@ mod tests {\n             (s: $path:expr, $op:ident, $arg:expr, $res:expr) => (\n                 {\n                     let pstr = $path;\n-                    let path = Path::init(pstr);\n+                    let path = Path::new(pstr);\n                     let arg = $arg;\n                     let res = path.$op(arg);\n                     let exp = $res;\n@@ -1846,19 +1846,19 @@ mod tests {\n                 {\n                     let path = $path;\n                     let arg = $arg;\n-                    let mut p1 = Path::init(path);\n+                    let mut p1 = Path::new(path);\n                     p1.$set(arg);\n-                    let p2 = Path::init(path);\n+                    let p2 = Path::new(path);\n                     assert_eq!(p1, p2.$with(arg));\n                 }\n             );\n             (v: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n                 {\n                     let path = $path;\n                     let arg = $arg;\n-                    let mut p1 = Path::init(path);\n+                    let mut p1 = Path::new(path);\n                     p1.$set(arg);\n-                    let p2 = Path::init(path);\n+                    let p2 = Path::new(path);\n                     assert_eq!(p1, p2.$with(arg));\n                 }\n             )\n@@ -1919,32 +1919,32 @@ mod tests {\n             )\n         )\n \n-        t!(v: Path::init(b!(\"a\\\\b\\\\c\")), Some(b!(\"c\")), b!(\"a\\\\b\"), Some(b!(\"c\")), None);\n-        t!(s: Path::init(\"a\\\\b\\\\c\"), Some(\"c\"), Some(\"a\\\\b\"), Some(\"c\"), None);\n-        t!(s: Path::init(\".\"), None, Some(\".\"), None, None);\n-        t!(s: Path::init(\"\\\\\"), None, Some(\"\\\\\"), None, None);\n-        t!(s: Path::init(\"..\"), None, Some(\"..\"), None, None);\n-        t!(s: Path::init(\"..\\\\..\"), None, Some(\"..\\\\..\"), None, None);\n-        t!(s: Path::init(\"hi\\\\there.txt\"), Some(\"there.txt\"), Some(\"hi\"),\n+        t!(v: Path::new(b!(\"a\\\\b\\\\c\")), Some(b!(\"c\")), b!(\"a\\\\b\"), Some(b!(\"c\")), None);\n+        t!(s: Path::new(\"a\\\\b\\\\c\"), Some(\"c\"), Some(\"a\\\\b\"), Some(\"c\"), None);\n+        t!(s: Path::new(\".\"), None, Some(\".\"), None, None);\n+        t!(s: Path::new(\"\\\\\"), None, Some(\"\\\\\"), None, None);\n+        t!(s: Path::new(\"..\"), None, Some(\"..\"), None, None);\n+        t!(s: Path::new(\"..\\\\..\"), None, Some(\"..\\\\..\"), None, None);\n+        t!(s: Path::new(\"hi\\\\there.txt\"), Some(\"there.txt\"), Some(\"hi\"),\n               Some(\"there\"), Some(\"txt\"));\n-        t!(s: Path::init(\"hi\\\\there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), None);\n-        t!(s: Path::init(\"hi\\\\there.\"), Some(\"there.\"), Some(\"hi\"),\n+        t!(s: Path::new(\"hi\\\\there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), None);\n+        t!(s: Path::new(\"hi\\\\there.\"), Some(\"there.\"), Some(\"hi\"),\n               Some(\"there\"), Some(\"\"));\n-        t!(s: Path::init(\"hi\\\\.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n-        t!(s: Path::init(\"hi\\\\..there\"), Some(\"..there\"), Some(\"hi\"),\n+        t!(s: Path::new(\"hi\\\\.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n+        t!(s: Path::new(\"hi\\\\..there\"), Some(\"..there\"), Some(\"hi\"),\n               Some(\".\"), Some(\"there\"));\n \n         // these are already tested in test_components, so no need for extended tests\n     }\n \n     #[test]\n     fn test_dir_path() {\n-        t!(s: Path::init(\"hi\\\\there\").dir_path(), \"hi\");\n-        t!(s: Path::init(\"hi\").dir_path(), \".\");\n-        t!(s: Path::init(\"\\\\hi\").dir_path(), \"\\\\\");\n-        t!(s: Path::init(\"\\\\\").dir_path(), \"\\\\\");\n-        t!(s: Path::init(\"..\").dir_path(), \"..\");\n-        t!(s: Path::init(\"..\\\\..\").dir_path(), \"..\\\\..\");\n+        t!(s: Path::new(\"hi\\\\there\").dir_path(), \"hi\");\n+        t!(s: Path::new(\"hi\").dir_path(), \".\");\n+        t!(s: Path::new(\"\\\\hi\").dir_path(), \"\\\\\");\n+        t!(s: Path::new(\"\\\\\").dir_path(), \"\\\\\");\n+        t!(s: Path::new(\"..\").dir_path(), \"..\");\n+        t!(s: Path::new(\"..\\\\..\").dir_path(), \"..\\\\..\");\n \n         // dir_path is just dirname interpreted as a path.\n         // No need for extended tests\n@@ -1955,7 +1955,7 @@ mod tests {\n         macro_rules! t(\n             ($path:expr, $abs:expr, $vol:expr, $cwd:expr, $rel:expr) => (\n                 {\n-                    let path = Path::init($path);\n+                    let path = Path::new($path);\n                     let (abs, vol, cwd, rel) = ($abs, $vol, $cwd, $rel);\n                     let b = path.is_absolute();\n                     assert!(b == abs, \"Path '{}'.is_absolute(): expected {:?}, found {:?}\",\n@@ -1995,8 +1995,8 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $dest:expr, $exp:expr) => (\n                 {\n-                    let path = Path::init($path);\n-                    let dest = Path::init($dest);\n+                    let path = Path::new($path);\n+                    let dest = Path::new($dest);\n                     let exp = $exp;\n                     let res = path.is_ancestor_of(&dest);\n                     assert!(res == exp,\n@@ -2098,8 +2098,8 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $child:expr, $exp:expr) => (\n                 {\n-                    let path = Path::init($path);\n-                    let child = Path::init($child);\n+                    let path = Path::new($path);\n+                    let child = Path::new($child);\n                     assert_eq!(path.ends_with_path(&child), $exp);\n                 }\n             );\n@@ -2130,8 +2130,8 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $other:expr, $exp:expr) => (\n                 {\n-                    let path = Path::init($path);\n-                    let other = Path::init($other);\n+                    let path = Path::new($path);\n+                    let other = Path::new($other);\n                     let res = path.path_relative_from(&other);\n                     let exp = $exp;\n                     assert!(res.as_ref().and_then(|x| x.as_str()) == exp,\n@@ -2264,7 +2264,7 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $exp:expr) => (\n                 {\n-                    let path = Path::init($path);\n+                    let path = Path::new($path);\n                     let comps = path.str_components().map(|x|x.unwrap()).to_owned_vec();\n                     let exp: &[&str] = $exp;\n                     assert!(comps.as_slice() == exp,\n@@ -2279,7 +2279,7 @@ mod tests {\n             );\n             (v: [$($arg:expr),+], $exp:expr) => (\n                 {\n-                    let path = Path::init(b!($($arg),+));\n+                    let path = Path::new(b!($($arg),+));\n                     let comps = path.str_components().map(|x|x.unwrap()).to_owned_vec();\n                     let exp: &[&str] = $exp;\n                     assert!(comps.as_slice() == exp,\n@@ -2339,7 +2339,7 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $exp:expr) => (\n                 {\n-                    let path = Path::init($path);\n+                    let path = Path::new($path);\n                     let comps = path.components().to_owned_vec();\n                     let exp: &[&[u8]] = $exp;\n                     assert!(comps.as_slice() == exp, \"components: Expected {:?}, found {:?}\","}, {"sha": "5558b8b33487bd08bb6e78b8f42dd8eb8bafa90d", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -61,7 +61,7 @@ impl OSRng {\n     #[cfg(unix)]\n     pub fn new() -> OSRng {\n         use path::Path;\n-        let reader = File::open(&Path::init(\"/dev/urandom\"));\n+        let reader = File::open(&Path::new(\"/dev/urandom\"));\n         let reader = reader.expect(\"Error opening /dev/urandom\");\n         let reader_rng = ReaderRng::new(reader);\n "}, {"sha": "3595587f342d40ccc7be9d20cf7b483ad18e019e", "filename": "src/libstd/rt/deque.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Frt%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Frt%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fdeque.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -26,7 +26,7 @@\n //!\n //!     use std::rt::deque::BufferPool;\n //!\n-//!     let mut pool = BufferPool::init();\n+//!     let mut pool = BufferPool::new();\n //!     let (mut worker, mut stealer) = pool.deque();\n //!\n //!     // Only the worker may push/pop\n@@ -139,14 +139,14 @@ struct Buffer<T> {\n impl<T: Send> BufferPool<T> {\n     /// Allocates a new buffer pool which in turn can be used to allocate new\n     /// deques.\n-    pub fn init() -> BufferPool<T> {\n+    pub fn new() -> BufferPool<T> {\n         BufferPool { pool: Exclusive::new(~[]) }\n     }\n \n     /// Allocates a new work-stealing deque which will send/receiving memory to\n     /// and from this buffer pool.\n     pub fn deque(&mut self) -> (Worker<T>, Stealer<T>) {\n-        let (a, b) = UnsafeArc::new2(Deque::init(self.clone()));\n+        let (a, b) = UnsafeArc::new2(Deque::new(self.clone()));\n         (Worker { deque: a }, Stealer { deque: b })\n     }\n \n@@ -155,7 +155,7 @@ impl<T: Send> BufferPool<T> {\n             self.pool.with(|pool| {\n                 match pool.iter().position(|x| x.size() >= (1 << bits)) {\n                     Some(i) => pool.remove(i),\n-                    None => ~Buffer::init(bits)\n+                    None => ~Buffer::new(bits)\n                 }\n             })\n         }\n@@ -221,7 +221,7 @@ impl<T: Send> Clone for Stealer<T> {\n // personally going to heavily comment what's going on here.\n \n impl<T: Send> Deque<T> {\n-    fn init(mut pool: BufferPool<T>) -> Deque<T> {\n+    fn new(mut pool: BufferPool<T>) -> Deque<T> {\n         let buf = pool.alloc(MIN_BITS);\n         Deque {\n             bottom: AtomicInt::new(0),\n@@ -341,7 +341,7 @@ impl<T: Send> Drop for Deque<T> {\n }\n \n impl<T: Send> Buffer<T> {\n-    unsafe fn init(log_size: int) -> Buffer<T> {\n+    unsafe fn new(log_size: int) -> Buffer<T> {\n         let size = (1 << log_size) * mem::size_of::<T>();\n         let buffer = libc::malloc(size as libc::size_t);\n         assert!(!buffer.is_null());\n@@ -375,7 +375,7 @@ impl<T: Send> Buffer<T> {\n     // Again, unsafe because this has incredibly dubious ownership violations.\n     // It is assumed that this buffer is immediately dropped.\n     unsafe fn resize(&self, b: int, t: int, delta: int) -> Buffer<T> {\n-        let mut buf = Buffer::init(self.log_size + delta);\n+        let mut buf = Buffer::new(self.log_size + delta);\n         for i in range(t, b) {\n             buf.put(i, self.get(i));\n         }\n@@ -406,7 +406,7 @@ mod tests {\n \n     #[test]\n     fn smoke() {\n-        let mut pool = BufferPool::init();\n+        let mut pool = BufferPool::new();\n         let (mut w, mut s) = pool.deque();\n         assert_eq!(w.pop(), None);\n         assert_eq!(s.steal(), Empty);\n@@ -421,7 +421,7 @@ mod tests {\n     #[test]\n     fn stealpush() {\n         static AMT: int = 100000;\n-        let mut pool = BufferPool::<int>::init();\n+        let mut pool = BufferPool::<int>::new();\n         let (mut w, s) = pool.deque();\n         let t = do Thread::start {\n             let mut s = s;\n@@ -447,7 +447,7 @@ mod tests {\n     #[test]\n     fn stealpush_large() {\n         static AMT: int = 100000;\n-        let mut pool = BufferPool::<(int, int)>::init();\n+        let mut pool = BufferPool::<(int, int)>::new();\n         let (mut w, s) = pool.deque();\n         let t = do Thread::start {\n             let mut s = s;\n@@ -509,15 +509,15 @@ mod tests {\n \n     #[test]\n     fn run_stampede() {\n-        let mut pool = BufferPool::<~int>::init();\n+        let mut pool = BufferPool::<~int>::new();\n         let (w, s) = pool.deque();\n         stampede(w, s, 8, 10000);\n     }\n \n     #[test]\n     fn many_stampede() {\n         static AMT: uint = 4;\n-        let mut pool = BufferPool::<~int>::init();\n+        let mut pool = BufferPool::<~int>::new();\n         let threads = range(0, AMT).map(|_| {\n             let (w, s) = pool.deque();\n             do Thread::start {\n@@ -536,7 +536,7 @@ mod tests {\n         static NTHREADS: int = 8;\n         static mut DONE: AtomicBool = INIT_ATOMIC_BOOL;\n         static mut HITS: AtomicUint = INIT_ATOMIC_UINT;\n-        let mut pool = BufferPool::<int>::init();\n+        let mut pool = BufferPool::<int>::new();\n         let (mut w, s) = pool.deque();\n \n         let threads = range(0, NTHREADS).map(|_| {\n@@ -595,7 +595,7 @@ mod tests {\n         static AMT: int = 10000;\n         static NTHREADS: int = 4;\n         static mut DONE: AtomicBool = INIT_ATOMIC_BOOL;\n-        let mut pool = BufferPool::<(int, uint)>::init();\n+        let mut pool = BufferPool::<(int, uint)>::new();\n         let (mut w, s) = pool.deque();\n \n         let (threads, hits) = vec::unzip(range(0, NTHREADS).map(|_| {"}, {"sha": "3d0222cefaeccf01eb067d320b0fad977099fc99", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -281,7 +281,7 @@ fn run_(main: proc(), use_main_sched: bool) -> int {\n \n     // Create a work queue for each scheduler, ntimes. Create an extra\n     // for the main thread if that flag is set. We won't steal from it.\n-    let mut pool = deque::BufferPool::init();\n+    let mut pool = deque::BufferPool::new();\n     let arr = vec::from_fn(nscheds, |_| pool.deque());\n     let (workers, stealers) = vec::unzip(arr.move_iter());\n "}, {"sha": "1cd8fcf589de6ff10a66f39a64b9240a09a3e1e4", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -1002,7 +1002,7 @@ mod test {\n         do run_in_bare_thread {\n \n             let sleepers = SleeperList::new();\n-            let mut pool = BufferPool::init();\n+            let mut pool = BufferPool::new();\n             let (normal_worker, normal_stealer) = pool.deque();\n             let (special_worker, special_stealer) = pool.deque();\n             let queues = ~[normal_stealer, special_stealer];\n@@ -1177,7 +1177,7 @@ mod test {\n         do run_in_bare_thread {\n             stress_factor().times(|| {\n                 let sleepers = SleeperList::new();\n-                let mut pool = BufferPool::init();\n+                let mut pool = BufferPool::new();\n                 let (worker, stealer) = pool.deque();\n \n                 let mut sched = ~Scheduler::new("}, {"sha": "2ab543a4c36bbe3253e8d23b599b506b5e2b9a6d", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -36,7 +36,7 @@ use vec::{OwnedVector, MutableVector, ImmutableVector};\n \n pub fn new_test_uv_sched() -> Scheduler {\n \n-    let mut pool = BufferPool::init();\n+    let mut pool = BufferPool::new();\n     let (worker, stealer) = pool.deque();\n \n     let mut sched = Scheduler::new(new_event_loop(),\n@@ -51,7 +51,7 @@ pub fn new_test_uv_sched() -> Scheduler {\n }\n \n pub fn new_test_sched() -> Scheduler {\n-    let mut pool = BufferPool::init();\n+    let mut pool = BufferPool::new();\n     let (worker, stealer) = pool.deque();\n \n     let mut sched = Scheduler::new(basic::event_loop(),\n@@ -228,7 +228,7 @@ pub fn run_in_mt_newsched_task(f: proc()) {\n         let mut handles = ~[];\n         let mut scheds = ~[];\n \n-        let mut pool = BufferPool::<~Task>::init();\n+        let mut pool = BufferPool::<~Task>::new();\n         let workers = range(0, nthreads).map(|_| pool.deque());\n         let (workers, stealers) = vec::unzip(workers);\n \n@@ -381,7 +381,7 @@ pub fn next_test_unix() -> Path {\n     if cfg!(unix) {\n         os::tmpdir().join(rand::task_rng().gen_ascii_str(20))\n     } else {\n-        Path::init(r\"\\\\.\\pipe\\\" + rand::task_rng().gen_ascii_str(20))\n+        Path::new(r\"\\\\.\\pipe\\\" + rand::task_rng().gen_ascii_str(20))\n     }\n }\n "}, {"sha": "d29b7388fe2a038ee3e583d2b5894166ced746d1", "filename": "src/libstd/run.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -506,7 +506,7 @@ mod tests {\n \n         let output = str::from_utf8_owned(prog.finish_with_output().output);\n         let parent_dir = os::getcwd();\n-        let child_dir = Path::init(output.trim());\n+        let child_dir = Path::new(output.trim());\n \n         let parent_stat = parent_dir.stat();\n         let child_stat = child_dir.stat();\n@@ -523,7 +523,7 @@ mod tests {\n         let mut prog = run_pwd(Some(&parent_dir));\n \n         let output = str::from_utf8_owned(prog.finish_with_output().output);\n-        let child_dir = Path::init(output.trim());\n+        let child_dir = Path::new(output.trim());\n \n         let parent_stat = parent_dir.stat();\n         let child_stat = child_dir.stat();"}, {"sha": "2a6e40dc3a0df93870ca30f9c6929a9f794f9f7e", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -122,7 +122,7 @@ mod test {\n     fn test_errors_do_not_crash() {\n         // Open /dev/null as a library to get an error, and make sure\n         // that only causes an error, and not a crash.\n-        let path = GenericPath::init(\"/dev/null\");\n+        let path = GenericPath::new(\"/dev/null\");\n         match DynamicLibrary::open(Some(&path)) {\n             Err(_) => {}\n             Ok(_) => fail!(\"Successfully opened the empty library.\")"}, {"sha": "c0c5c6c6c079c83bca7a706637259008753bdf52", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -82,15 +82,15 @@ pub fn expand_include(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     let file = get_single_str_from_tts(cx, sp, tts, \"include!\");\n     let p = parse::new_sub_parser_from_file(\n         cx.parse_sess(), cx.cfg(),\n-        &res_rel_file(cx, sp, &Path::init(file)), sp);\n+        &res_rel_file(cx, sp, &Path::new(file)), sp);\n     base::MRExpr(p.parse_expr())\n }\n \n // include_str! : read the given file, insert it as a literal string expr\n pub fn expand_include_str(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n-    let file = res_rel_file(cx, sp, &Path::init(file));\n+    let file = res_rel_file(cx, sp, &Path::new(file));\n     let bytes = match io::result(|| File::open(&file).read_to_end()) {\n         Err(e) => {\n             cx.span_fatal(sp, format!(\"couldn't read {}: {}\",\n@@ -112,7 +112,7 @@ pub fn expand_include_bin(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     use std::at_vec;\n \n     let file = get_single_str_from_tts(cx, sp, tts, \"include_bin!\");\n-    let file = res_rel_file(cx, sp, &Path::init(file));\n+    let file = res_rel_file(cx, sp, &Path::new(file));\n     match io::result(|| File::open(&file).read_to_end()) {\n         Err(e) => {\n             cx.span_fatal(sp, format!(\"couldn't read {}: {}\",\n@@ -156,7 +156,7 @@ fn topmost_expn_info(expn_info: @codemap::ExpnInfo) -> @codemap::ExpnInfo {\n fn res_rel_file(cx: @ExtCtxt, sp: codemap::Span, arg: &Path) -> Path {\n     // NB: relative paths are resolved relative to the compilation unit\n     if !arg.is_absolute() {\n-        let mut cu = Path::init(cx.codemap().span_to_filename(sp));\n+        let mut cu = Path::new(cx.codemap().span_to_filename(sp));\n         cu.pop();\n         cu.push(arg);\n         cu"}, {"sha": "612151f83e442cac5807639150915941fa458811", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -344,7 +344,7 @@ mod test {\n     #[cfg(test)]\n     fn to_json_str<'a, E: Encodable<extra::json::Encoder<'a>>>(val: &E) -> ~str {\n         let mut writer = MemWriter::new();\n-        let mut encoder = extra::json::Encoder::init(&mut writer as &mut io::Writer);\n+        let mut encoder = extra::json::Encoder::new(&mut writer as &mut io::Writer);\n         val.encode(&mut encoder);\n         str::from_utf8_owned(writer.inner())\n     }"}, {"sha": "8c4bf5d87ab00c155f6724b1aa854c6ec6678e5b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -4232,10 +4232,10 @@ impl Parser {\n                     outer_attrs: &[ast::Attribute],\n                     id_sp: Span)\n                     -> (ast::item_, ~[ast::Attribute]) {\n-        let mut prefix = Path::init(self.sess.cm.span_to_filename(*self.span));\n+        let mut prefix = Path::new(self.sess.cm.span_to_filename(*self.span));\n         prefix.pop();\n         let mod_path_stack = &*self.mod_path_stack;\n-        let mod_path = Path::init(\".\").join_many(*mod_path_stack);\n+        let mod_path = Path::new(\".\").join_many(*mod_path_stack);\n         let dir_path = prefix.join(&mod_path);\n         let file_path = match ::attr::first_attr_value_str_by_name(\n                 outer_attrs, \"path\") {"}, {"sha": "c7036f8d9db312a11aa70eb012eafc7033809b2c", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -72,7 +72,7 @@ fn shift_push() {\n fn read_line() {\n     use std::io::buffered::BufferedReader;\n \n-    let mut path = Path::init(env!(\"CFG_SRC_DIR\"));\n+    let mut path = Path::new(env!(\"CFG_SRC_DIR\"));\n     path.push(\"src/test/bench/shootout-k-nucleotide.data\");\n \n     for _ in range(0, 3) {"}, {"sha": "098512e9549153b02d2fee1fb631ee49032f8182", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -123,7 +123,7 @@ fn main() {\n     };\n \n     let writer = if os::getenv(\"RUST_BENCH\").is_some() {\n-        let file = File::create(&Path::init(\"./shootout-fasta.data\"));\n+        let file = File::create(&Path::new(\"./shootout-fasta.data\"));\n         @mut file as @mut io::Writer\n     } else {\n         @mut io::stdout() as @mut io::Writer"}, {"sha": "161f23182d1e70e5809e652f2b533a5f2fa515fe", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -35,7 +35,7 @@ fn make_complements() -> [u8, ..256] {\n fn main() {\n     let complements = make_complements();\n     let mut data = if std::os::getenv(\"RUST_BENCH\").is_some() {\n-        File::open(&Path::init(\"shootout-k-nucleotide.data\")).read_to_end()\n+        File::open(&Path::new(\"shootout-k-nucleotide.data\")).read_to_end()\n     } else {\n         stdin().read_to_end()\n     };"}, {"sha": "655bc7771938f1e73c9318cc6b7a995ef58a6e27", "filename": "src/test/run-pass/glob-std.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Ftest%2Frun-pass%2Fglob-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Ftest%2Frun-pass%2Fglob-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fglob-std.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -22,14 +22,14 @@ use std::io;\n pub fn main() {\n     fn mk_file(path: &str, directory: bool) {\n         if directory {\n-            io::fs::mkdir(&Path::init(path), io::UserRWX);\n+            io::fs::mkdir(&Path::new(path), io::UserRWX);\n         } else {\n-            io::File::create(&Path::init(path));\n+            io::File::create(&Path::new(path));\n         }\n     }\n \n     fn abs_path(path: &str) -> Path {\n-        os::getcwd().join(&Path::init(path))\n+        os::getcwd().join(&Path::new(path))\n     }\n \n     fn glob_vec(pattern: &str) -> ~[Path] {"}, {"sha": "02aaee1d01fdab554555e9f3f3206438a5a2844c", "filename": "src/test/run-pass/issue-3424.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Ftest%2Frun-pass%2Fissue-3424.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Ftest%2Frun-pass%2Fissue-3424.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3424.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -23,7 +23,7 @@ fn tester()\n {\n     let loader: rsrc_loader = proc(_path) {result::Ok(~\"more blah\")};\n \n-    let path = path::Path::init(\"blah\");\n+    let path = path::Path::new(\"blah\");\n     assert!(loader(&path).is_ok());\n }\n "}, {"sha": "c1f40d302c865d36aec519831010bf6cf0999b26", "filename": "src/test/run-pass/issue-4016.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4016.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -18,7 +18,7 @@ trait JD : Decodable<json::Decoder> { }\n \n fn exec<T: JD>() {\n     let doc = json::from_str(\"\").unwrap();\n-    let mut decoder = json::Decoder::init(doc);\n+    let mut decoder = json::Decoder::new(doc);\n     let _v: T = Decodable::decode(&mut decoder);\n     fail!()\n }"}, {"sha": "5665bff571e4cd50f6c9567a4fadcd9682e7da59", "filename": "src/test/run-pass/issue-4036.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Ftest%2Frun-pass%2Fissue-4036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Ftest%2Frun-pass%2Fissue-4036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4036.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -17,6 +17,6 @@ use self::extra::serialize;\n \n pub fn main() {\n     let json = json::from_str(\"[1]\").unwrap();\n-    let mut decoder = json::Decoder::init(json);\n+    let mut decoder = json::Decoder::new(json);\n     let _x: ~[int] = serialize::Decodable::decode(&mut decoder);\n }"}, {"sha": "b186a6828106285ff19ce4f31d8a06a985392618", "filename": "src/test/run-pass/stat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Ftest%2Frun-pass%2Fstat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Ftest%2Frun-pass%2Fstat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstat.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -16,7 +16,7 @@ use extra::tempfile;\n use std::io::File;\n \n pub fn main() {\n-    let dir = tempfile::TempDir::new_in(&Path::init(\".\"), \"\").unwrap();\n+    let dir = tempfile::TempDir::new_in(&Path::new(\".\"), \"\").unwrap();\n     let path = dir.path().join(\"file\");\n \n     {"}, {"sha": "3ab0fe1c058d878e38ae018e31264ab7d74748a0", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "patch": "@@ -30,7 +30,7 @@ use std::io::fs;\n \n fn test_tempdir() {\n     let path = {\n-        let p = TempDir::new_in(&Path::init(\".\"), \"foobar\").unwrap();\n+        let p = TempDir::new_in(&Path::new(\".\"), \"foobar\").unwrap();\n         let p = p.path();\n         assert!(p.as_vec().ends_with(bytes!(\"foobar\")));\n         p.clone()\n@@ -83,7 +83,7 @@ fn test_rm_tempdir() {\n // Ideally these would be in std::os but then core would need\n // to depend on std\n fn recursive_mkdir_rel() {\n-    let path = Path::init(\"frob\");\n+    let path = Path::new(\"frob\");\n     let cwd = os::getcwd();\n     debug!(\"recursive_mkdir_rel: Making: {} in cwd {} [{:?}]\", path.display(),\n            cwd.display(), path.exists());\n@@ -94,21 +94,21 @@ fn recursive_mkdir_rel() {\n }\n \n fn recursive_mkdir_dot() {\n-    let dot = Path::init(\".\");\n+    let dot = Path::new(\".\");\n     fs::mkdir_recursive(&dot, io::UserRWX);\n-    let dotdot = Path::init(\"..\");\n+    let dotdot = Path::new(\"..\");\n     fs::mkdir_recursive(&dotdot, io::UserRWX);\n }\n \n fn recursive_mkdir_rel_2() {\n-    let path = Path::init(\"./frob/baz\");\n+    let path = Path::new(\"./frob/baz\");\n     let cwd = os::getcwd();\n     debug!(\"recursive_mkdir_rel_2: Making: {} in cwd {} [{:?}]\", path.display(),\n            cwd.display(), path.exists());\n     fs::mkdir_recursive(&path, io::UserRWX);\n     assert!(path.is_dir());\n     assert!(path.dir_path().is_dir());\n-    let path2 = Path::init(\"quux/blat\");\n+    let path2 = Path::new(\"quux/blat\");\n     debug!(\"recursive_mkdir_rel_2: Making: {} in cwd {}\", path2.display(),\n            cwd.display());\n     fs::mkdir_recursive(&path2, io::UserRWX);"}]}