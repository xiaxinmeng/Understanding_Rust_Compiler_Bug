{"sha": "e350fe4e608b653da47e8012d13ef701613e717b", "node_id": "C_kwDOAAsO6NoAKGUzNTBmZTRlNjA4YjY1M2RhNDdlODAxMmQxM2VmNzAxNjEzZTcxN2I", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-11T07:28:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-11T07:28:44Z"}, "message": "Auto merge of #109001 - matthiaskrgr:rollup-a3agnwp, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #105798 (Relax ordering rules for `asm!` operands)\n - #105962 (Stabilize path_as_mut_os_str)\n - #106085 (use problem matchers for tidy CI)\n - #107711 (Stabilize movbe target feature)\n - #108017 (Add `--no-undefined-version` link flag and fix associated breakage)\n - #108891 (Remove an extraneous include)\n - #108902 (no more do while :<)\n - #108912 (Document tool lints)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "32bb29f8449dd0701a30197fe3222bc13f4a170e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32bb29f8449dd0701a30197fe3222bc13f4a170e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e350fe4e608b653da47e8012d13ef701613e717b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e350fe4e608b653da47e8012d13ef701613e717b", "html_url": "https://github.com/rust-lang/rust/commit/e350fe4e608b653da47e8012d13ef701613e717b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e350fe4e608b653da47e8012d13ef701613e717b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19c53768af6e48514238e4224b5bf5ecd51bc7b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/19c53768af6e48514238e4224b5bf5ecd51bc7b1", "html_url": "https://github.com/rust-lang/rust/commit/19c53768af6e48514238e4224b5bf5ecd51bc7b1"}, {"sha": "030ea0578fb361b66becc898547cec406f3c53ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/030ea0578fb361b66becc898547cec406f3c53ce", "html_url": "https://github.com/rust-lang/rust/commit/030ea0578fb361b66becc898547cec406f3c53ce"}], "stats": {"total": 635, "additions": 267, "deletions": 368}, "files": [{"sha": "8c1579baacb08775c9126449c1dd7274d9a2e6d3", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 4, "deletions": 31, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -203,17 +203,6 @@ pub fn parse_asm_args<'a>(\n         // Validate the order of named, positional & explicit register operands and\n         // clobber_abi/options. We do this at the end once we have the full span\n         // of the argument available.\n-        if !args.options_spans.is_empty() {\n-            diag.struct_span_err(span, \"arguments are not allowed after options\")\n-                .span_labels(args.options_spans.clone(), \"previous options\")\n-                .span_label(span, \"argument\")\n-                .emit();\n-        } else if let Some((_, abi_span)) = args.clobber_abis.last() {\n-            diag.struct_span_err(span, \"arguments are not allowed after clobber_abi\")\n-                .span_label(*abi_span, \"clobber_abi\")\n-                .span_label(span, \"argument\")\n-                .emit();\n-        }\n         if explicit_reg {\n             if name.is_some() {\n                 diag.struct_span_err(span, \"explicit register arguments cannot have names\").emit();\n@@ -227,17 +216,6 @@ pub fn parse_asm_args<'a>(\n                     .emit();\n                 continue;\n             }\n-            if !args.reg_args.is_empty() {\n-                let mut err = diag.struct_span_err(\n-                    span,\n-                    \"named arguments cannot follow explicit register arguments\",\n-                );\n-                err.span_label(span, \"named argument\");\n-                for pos in &args.reg_args {\n-                    err.span_label(args.operands[*pos].1, \"explicit register argument\");\n-                }\n-                err.emit();\n-            }\n             args.named_args.insert(name, slot);\n         } else {\n             if !args.named_args.is_empty() || !args.reg_args.is_empty() {\n@@ -478,15 +456,6 @@ fn parse_clobber_abi<'a>(p: &mut Parser<'a>, args: &mut AsmArgs) -> PResult<'a,\n \n     let full_span = span_start.to(p.prev_token.span);\n \n-    if !args.options_spans.is_empty() {\n-        let mut err = p\n-            .sess\n-            .span_diagnostic\n-            .struct_span_err(full_span, \"clobber_abi is not allowed after options\");\n-        err.span_labels(args.options_spans.clone(), \"options\");\n-        return Err(err);\n-    }\n-\n     match &new_abis[..] {\n         // should have errored above during parsing\n         [] => unreachable!(),\n@@ -699,6 +668,10 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n                                         args.operands[idx].1,\n                                         \"explicit register arguments cannot be used in the asm template\",\n                                     );\n+                                    err.span_help(\n+                                        args.operands[idx].1,\n+                                        \"use the register name directly in the assembly code\",\n+                                    );\n                                 }\n                                 err.emit();\n                                 None"}, {"sha": "2c246ceb37d54fa43940774b79a359f39c346da3", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -4,6 +4,7 @@\n use crate::prelude::*;\n \n use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n+use rustc_codegen_ssa::base::allocator_kind_for_codegen;\n use rustc_session::config::OomStrategy;\n use rustc_span::symbol::sym;\n \n@@ -13,24 +14,15 @@ pub(crate) fn codegen(\n     module: &mut impl Module,\n     unwind_context: &mut UnwindContext,\n ) -> bool {\n-    let any_dynamic_crate = tcx.dependency_formats(()).iter().any(|(_, list)| {\n-        use rustc_middle::middle::dependency_format::Linkage;\n-        list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n-    });\n-    if any_dynamic_crate {\n-        false\n-    } else if let Some(kind) = tcx.allocator_kind(()) {\n-        codegen_inner(\n-            module,\n-            unwind_context,\n-            kind,\n-            tcx.alloc_error_handler_kind(()).unwrap(),\n-            tcx.sess.opts.unstable_opts.oom,\n-        );\n-        true\n-    } else {\n-        false\n-    }\n+    let Some(kind) = allocator_kind_for_codegen(tcx) else { return false };\n+    codegen_inner(\n+        module,\n+        unwind_context,\n+        kind,\n+        tcx.alloc_error_handler_kind(()).unwrap(),\n+        tcx.sess.opts.unstable_opts.oom,\n+    );\n+    true\n }\n \n fn codegen_inner("}, {"sha": "23e2b272410e6b99b950ff52a675adb2b642db92", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -720,6 +720,7 @@ impl<'a> Linker for GccLinker<'a> {\n                 let mut arg = OsString::from(\"--version-script=\");\n                 arg.push(path);\n                 self.linker_arg(arg);\n+                self.linker_arg(\"--no-undefined-version\");\n             }\n         }\n     }"}, {"sha": "7b58e55dbe84a8f24af945bb5089a66dbd6ae5e6", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -1,3 +1,5 @@\n+use crate::base::allocator_kind_for_codegen;\n+\n use std::collections::hash_map::Entry::*;\n \n use rustc_ast::expand::allocator::ALLOCATOR_METHODS;\n@@ -200,7 +202,8 @@ fn exported_symbols_provider_local(\n         ));\n     }\n \n-    if tcx.allocator_kind(()).is_some() {\n+    // Mark allocator shim symbols as exported only if they were generated.\n+    if allocator_kind_for_codegen(tcx).is_some() {\n         for symbol_name in ALLOCATOR_METHODS\n             .iter()\n             .map(|method| format!(\"__rust_{}\", method.name))"}, {"sha": "abc510e360d56657d4c1b5c09f21579b1286fa5f", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -13,6 +13,7 @@ use crate::mir::place::PlaceRef;\n use crate::traits::*;\n use crate::{CachedModuleCodegen, CompiledModule, CrateInfo, MemFlags, ModuleCodegen, ModuleKind};\n \n+use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::{get_resident_set_size, print_time_passes_entry};\n@@ -545,6 +546,23 @@ pub fn collect_debugger_visualizers_transitive(\n         .collect::<BTreeSet<_>>()\n }\n \n+/// Decide allocator kind to codegen. If `Some(_)` this will be the same as\n+/// `tcx.allocator_kind`, but it may be `None` in more cases (e.g. if using\n+/// allocator definitions from a dylib dependency).\n+pub fn allocator_kind_for_codegen(tcx: TyCtxt<'_>) -> Option<AllocatorKind> {\n+    // If the crate doesn't have an `allocator_kind` set then there's definitely\n+    // no shim to generate. Otherwise we also check our dependency graph for all\n+    // our output crate types. If anything there looks like its a `Dynamic`\n+    // linkage, then it's already got an allocator shim and we'll be using that\n+    // one instead. If nothing exists then it's our job to generate the\n+    // allocator!\n+    let any_dynamic_crate = tcx.dependency_formats(()).iter().any(|(_, list)| {\n+        use rustc_middle::middle::dependency_format::Linkage;\n+        list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n+    });\n+    if any_dynamic_crate { None } else { tcx.allocator_kind(()) }\n+}\n+\n pub fn codegen_crate<B: ExtraBackendMethods>(\n     backend: B,\n     tcx: TyCtxt<'_>,\n@@ -615,20 +633,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     );\n \n     // Codegen an allocator shim, if necessary.\n-    //\n-    // If the crate doesn't have an `allocator_kind` set then there's definitely\n-    // no shim to generate. Otherwise we also check our dependency graph for all\n-    // our output crate types. If anything there looks like its a `Dynamic`\n-    // linkage, then it's already got an allocator shim and we'll be using that\n-    // one instead. If nothing exists then it's our job to generate the\n-    // allocator!\n-    let any_dynamic_crate = tcx.dependency_formats(()).iter().any(|(_, list)| {\n-        use rustc_middle::middle::dependency_format::Linkage;\n-        list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n-    });\n-    let allocator_module = if any_dynamic_crate {\n-        None\n-    } else if let Some(kind) = tcx.allocator_kind(()) {\n+    if let Some(kind) = allocator_kind_for_codegen(tcx) {\n         let llmod_id =\n             cgu_name_builder.build_cgu_name(LOCAL_CRATE, &[\"crate\"], Some(\"allocator\")).to_string();\n         let module_llvm = tcx.sess.time(\"write_allocator_module\", || {\n@@ -642,13 +647,10 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n             )\n         });\n \n-        Some(ModuleCodegen { name: llmod_id, module_llvm, kind: ModuleKind::Allocator })\n-    } else {\n-        None\n-    };\n-\n-    if let Some(allocator_module) = allocator_module {\n-        ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, allocator_module);\n+        ongoing_codegen.submit_pre_codegened_module_to_llvm(\n+            tcx,\n+            ModuleCodegen { name: llmod_id, module_llvm, kind: ModuleKind::Allocator },\n+        );\n     }\n \n     // For better throughput during parallel processing by LLVM, we used to sort"}, {"sha": "754b085f1a83229a14c14152b9ded4bfb2841dc4", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -192,7 +192,7 @@ const X86_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"fxsr\", None),\n     (\"gfni\", Some(sym::avx512_target_feature)),\n     (\"lzcnt\", None),\n-    (\"movbe\", Some(sym::movbe_target_feature)),\n+    (\"movbe\", None),\n     (\"pclmulqdq\", None),\n     (\"popcnt\", None),\n     (\"rdrand\", None),\n@@ -394,7 +394,6 @@ pub fn from_target_feature(\n                 Some(sym::sse4a_target_feature) => rust_features.sse4a_target_feature,\n                 Some(sym::tbm_target_feature) => rust_features.tbm_target_feature,\n                 Some(sym::wasm_target_feature) => rust_features.wasm_target_feature,\n-                Some(sym::movbe_target_feature) => rust_features.movbe_target_feature,\n                 Some(sym::rtm_target_feature) => rust_features.rtm_target_feature,\n                 Some(sym::ermsb_target_feature) => rust_features.ermsb_target_feature,\n                 Some(sym::bpf_target_feature) => rust_features.bpf_target_feature,"}, {"sha": "ac93dd555b7a4c5f0d7a54aa51425bf760b7eab8", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -90,7 +90,7 @@ declare_features! (\n     (accepted, clone_closures, \"1.26.0\", Some(44490), None),\n     /// Allows coercing non capturing closures to function pointers.\n     (accepted, closure_to_fn_coercion, \"1.19.0\", Some(39817), None),\n-    /// Allows using `cmpxchg16b` from `core::arch::x86_64`.\n+    /// Allows using the CMPXCHG16B target feature.\n     (accepted, cmpxchg16b_target_feature, \"CURRENT_RUSTC_VERSION\", Some(44839), None),\n     /// Allows usage of the `compile_error!` macro.\n     (accepted, compile_error, \"1.20.0\", Some(40872), None),\n@@ -238,6 +238,8 @@ declare_features! (\n     (accepted, min_const_unsafe_fn, \"1.33.0\", Some(55607), None),\n     /// Allows using `Self` and associated types in struct expressions and patterns.\n     (accepted, more_struct_aliases, \"1.16.0\", Some(37544), None),\n+    /// Allows using the MOVBE target feature.\n+    (accepted, movbe_target_feature, \"CURRENT_RUSTC_VERSION\", Some(44839), None),\n     /// Allows patterns with concurrent by-move and by-ref bindings.\n     /// For example, you can write `Foo(a, ref b)` where `a` is by-move and `b` is by-ref.\n     (accepted, move_ref_pattern, \"1.49.0\", Some(68354), None),"}, {"sha": "2fa7bceb8bc0ad55f03d8c0257785c125ca94729", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -259,7 +259,6 @@ declare_features! (\n     (active, ermsb_target_feature, \"1.49.0\", Some(44839), None),\n     (active, hexagon_target_feature, \"1.27.0\", Some(44839), None),\n     (active, mips_target_feature, \"1.27.0\", Some(44839), None),\n-    (active, movbe_target_feature, \"1.34.0\", Some(44839), None),\n     (active, powerpc_target_feature, \"1.27.0\", Some(44839), None),\n     (active, riscv_target_feature, \"1.45.0\", Some(44839), None),\n     (active, rtm_target_feature, \"1.35.0\", Some(44839), None),"}, {"sha": "a14dc20fca369e701337454e4f0b6ca53245ba16", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -17,6 +17,11 @@ use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n declare_tool_lint! {\n+    /// The `default_hash_type` lint detects use of [`std::collections::HashMap`]/[`std::collections::HashSet`],\n+    /// suggesting the use of `FxHashMap`/`FxHashSet`.\n+    ///\n+    /// This can help as `FxHasher` can perform better than the default hasher. DOS protection is not\n+    /// required as input is assumed to be trusted.\n     pub rustc::DEFAULT_HASH_TYPES,\n     Allow,\n     \"forbid HashMap and HashSet and suggest the FxHash* variants\",\n@@ -67,6 +72,12 @@ fn typeck_results_of_method_fn<'tcx>(\n }\n \n declare_tool_lint! {\n+    /// The `potential_query_instability` lint detects use of methods which can lead to\n+    /// potential query instability, such as iterating over a `HashMap`.\n+    ///\n+    /// Due to the [incremental compilation](https://rustc-dev-guide.rust-lang.org/queries/incremental-compilation.html) model,\n+    /// queries must return deterministic, stable results. `HashMap` iteration order can change between compilations,\n+    /// and will introduce instability if query results expose the order.\n     pub rustc::POTENTIAL_QUERY_INSTABILITY,\n     Allow,\n     \"require explicit opt-in when using potentially unstable methods or functions\",\n@@ -92,13 +103,17 @@ impl LateLintPass<'_> for QueryStability {\n }\n \n declare_tool_lint! {\n+    /// The `usage_of_ty_tykind` lint detects usages of `ty::TyKind::<kind>`,\n+    /// where `ty::<kind>` would suffice.\n     pub rustc::USAGE_OF_TY_TYKIND,\n     Allow,\n     \"usage of `ty::TyKind` outside of the `ty::sty` module\",\n     report_in_external_macro: true\n }\n \n declare_tool_lint! {\n+    /// The `usage_of_qualified_ty` lint detects usages of `ty::TyKind`,\n+    /// where `Ty` should be used instead.\n     pub rustc::USAGE_OF_QUALIFIED_TY,\n     Allow,\n     \"using `ty::{Ty,TyCtxt}` instead of importing it\",\n@@ -254,6 +269,8 @@ fn gen_args(segment: &PathSegment<'_>) -> String {\n }\n \n declare_tool_lint! {\n+    /// The `lint_pass_impl_without_macro` detects manual implementations of a lint\n+    /// pass, without using [`declare_lint_pass`] or [`impl_lint_pass`].\n     pub rustc::LINT_PASS_IMPL_WITHOUT_MACRO,\n     Allow,\n     \"`impl LintPass` without the `declare_lint_pass!` or `impl_lint_pass!` macros\"\n@@ -285,6 +302,8 @@ impl EarlyLintPass for LintPassImpl {\n }\n \n declare_tool_lint! {\n+    /// The `existing_doc_keyword` lint detects use `#[doc()]` keywords\n+    /// that don't exist, e.g. `#[doc(keyword = \"..\")]`.\n     pub rustc::EXISTING_DOC_KEYWORD,\n     Allow,\n     \"Check that documented keywords in std and core actually exist\",\n@@ -325,13 +344,22 @@ impl<'tcx> LateLintPass<'tcx> for ExistingDocKeyword {\n }\n \n declare_tool_lint! {\n+    /// The `untranslatable_diagnostic` lint detects diagnostics created\n+    /// without using translatable Fluent strings.\n+    ///\n+    /// More details on translatable diagnostics can be found [here](https://rustc-dev-guide.rust-lang.org/diagnostics/translation.html).\n     pub rustc::UNTRANSLATABLE_DIAGNOSTIC,\n     Allow,\n     \"prevent creation of diagnostics which cannot be translated\",\n     report_in_external_macro: true\n }\n \n declare_tool_lint! {\n+    /// The `diagnostic_outside_of_impl` lint detects diagnostics created manually,\n+    /// and inside an `IntoDiagnostic`/`AddToDiagnostic` implementation,\n+    /// or a `#[derive(Diagnostic)]`/`#[derive(Subdiagnostic)]` expansion.\n+    ///\n+    /// More details on diagnostics implementations can be found [here](https://rustc-dev-guide.rust-lang.org/diagnostics/diagnostic-structs.html).\n     pub rustc::DIAGNOSTIC_OUTSIDE_OF_IMPL,\n     Allow,\n     \"prevent creation of diagnostics outside of `IntoDiagnostic`/`AddToDiagnostic` impls\",\n@@ -396,6 +424,8 @@ impl LateLintPass<'_> for Diagnostics {\n }\n \n declare_tool_lint! {\n+    /// The `bad_opt_access` lint detects accessing options by field instad of\n+    /// the wrapper function.\n     pub rustc::BAD_OPT_ACCESS,\n     Deny,\n     \"prevent using options by field access when there is a wrapper function\","}, {"sha": "0493d6b05d030483c9f4d3e83c658838eaaecb7e", "filename": "compiler/rustc_llvm/llvm-wrapper/SymbolWrapper.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_llvm%2Fllvm-wrapper%2FSymbolWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_llvm%2Fllvm-wrapper%2FSymbolWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FSymbolWrapper.cpp?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -9,7 +9,6 @@\n \n #include \"llvm/IR/LLVMContext.h\"\n #include \"llvm/Object/ObjectFile.h\"\n-#include \"llvm/ADT/Optional.h\"\n \n using namespace llvm;\n using namespace llvm::sys;"}, {"sha": "9414d9bfa08638d6677682ea563f13116fd5cc3d", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -588,8 +588,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // let PATTERN = ... might not even exist until we do the assignment.\n         // so we set it here instead.\n         if set_match_place {\n-            let mut candidate_ref = &candidate;\n-            while let Some(next) = {\n+            let mut next = Some(&candidate);\n+            while let Some(candidate_ref) = next.take() {\n                 for binding in &candidate_ref.bindings {\n                     let local = self.var_local_id(binding.var_id, OutsideGuard);\n                     // `try_to_place` may fail if it is unable to resolve the given\n@@ -617,9 +617,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n                 // All of the subcandidates should bind the same locals, so we\n                 // only visit the first one.\n-                candidate_ref.subcandidates.get(0)\n-            } {\n-                candidate_ref = next;\n+                next = candidate_ref.subcandidates.get(0)\n             }\n         }\n "}, {"sha": "49028ca4e5ec88287ccba9a35cecb1984cd02257", "filename": "compiler/rustc_mir_transform/src/coverage/graph.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -537,29 +537,29 @@ impl TraverseCoverageGraphWithLoops {\n             \"TraverseCoverageGraphWithLoops::next - context_stack: {:?}\",\n             self.context_stack.iter().rev().collect::<Vec<_>>()\n         );\n-        while let Some(next_bcb) = {\n-            // Strip contexts with empty worklists from the top of the stack\n-            while self.context_stack.last().map_or(false, |context| context.worklist.is_empty()) {\n+\n+        while let Some(context) = self.context_stack.last_mut() {\n+            if let Some(next_bcb) = context.worklist.pop() {\n+                if !self.visited.insert(next_bcb) {\n+                    debug!(\"Already visited: {:?}\", next_bcb);\n+                    continue;\n+                }\n+                debug!(\"Visiting {:?}\", next_bcb);\n+                if self.backedges[next_bcb].len() > 0 {\n+                    debug!(\"{:?} is a loop header! Start a new TraversalContext...\", next_bcb);\n+                    self.context_stack.push(TraversalContext {\n+                        loop_backedges: Some((self.backedges[next_bcb].clone(), next_bcb)),\n+                        worklist: Vec::new(),\n+                    });\n+                }\n+                self.extend_worklist(basic_coverage_blocks, next_bcb);\n+                return Some(next_bcb);\n+            } else {\n+                // Strip contexts with empty worklists from the top of the stack\n                 self.context_stack.pop();\n             }\n-            // Pop the next bcb off of the current context_stack. If none, all BCBs were visited.\n-            self.context_stack.last_mut().map_or(None, |context| context.worklist.pop())\n-        } {\n-            if !self.visited.insert(next_bcb) {\n-                debug!(\"Already visited: {:?}\", next_bcb);\n-                continue;\n-            }\n-            debug!(\"Visiting {:?}\", next_bcb);\n-            if self.backedges[next_bcb].len() > 0 {\n-                debug!(\"{:?} is a loop header! Start a new TraversalContext...\", next_bcb);\n-                self.context_stack.push(TraversalContext {\n-                    loop_backedges: Some((self.backedges[next_bcb].clone(), next_bcb)),\n-                    worklist: Vec::new(),\n-                });\n-            }\n-            self.extend_worklist(basic_coverage_blocks, next_bcb);\n-            return Some(next_bcb);\n         }\n+\n         None\n     }\n "}, {"sha": "dbc18f7827e60ac8d7f9810063b7057af03a919d", "filename": "library/std/src/path.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -1498,7 +1498,6 @@ impl PathBuf {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(path_as_mut_os_str)]\n     /// use std::path::{Path, PathBuf};\n     ///\n     /// let mut path = PathBuf::from(\"/foo\");\n@@ -1510,7 +1509,7 @@ impl PathBuf {\n     /// path.as_mut_os_string().push(\"baz\");\n     /// assert_eq!(path, Path::new(\"/foo/barbaz\"));\n     /// ```\n-    #[unstable(feature = \"path_as_mut_os_str\", issue = \"105021\")]\n+    #[stable(feature = \"path_as_mut_os_str\", since = \"CURRENT_RUSTC_VERSION\")]\n     #[must_use]\n     #[inline]\n     pub fn as_mut_os_string(&mut self) -> &mut OsString {\n@@ -2066,7 +2065,6 @@ impl Path {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(path_as_mut_os_str)]\n     /// use std::path::{Path, PathBuf};\n     ///\n     /// let mut path = PathBuf::from(\"Foo.TXT\");\n@@ -2076,7 +2074,7 @@ impl Path {\n     /// path.as_mut_os_str().make_ascii_lowercase();\n     /// assert_eq!(path, Path::new(\"foo.txt\"));\n     /// ```\n-    #[unstable(feature = \"path_as_mut_os_str\", issue = \"105021\")]\n+    #[stable(feature = \"path_as_mut_os_str\", since = \"CURRENT_RUSTC_VERSION\")]\n     #[must_use]\n     #[inline]\n     pub fn as_mut_os_str(&mut self) -> &mut OsStr {"}, {"sha": "a007bf183ee119fedc868b7f9302c857e75a5f8c", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-llvm-14/Dockerfile", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-14%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-14%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-14%2FDockerfile?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -62,6 +62,4 @@ ENV SCRIPT ../x.py --stage 2 test --exclude src/tools/tidy && \\\n            # work.\n            #\n            ../x.ps1 --stage 2 test tests/ui --pass=check \\\n-                             --host='' --target=i686-unknown-linux-gnu && \\\n-           # Run tidy at the very end, after all the other tests.\n-           python2.7 ../x.py --stage 2 test src/tools/tidy\n+                             --host='' --target=i686-unknown-linux-gnu"}, {"sha": "37561924b7d4f1b0d54dd56d4dfd694889a96bc6", "filename": "src/ci/github-actions/problem_matchers.json", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/src%2Fci%2Fgithub-actions%2Fproblem_matchers.json", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/src%2Fci%2Fgithub-actions%2Fproblem_matchers.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fproblem_matchers.json?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -0,0 +1,15 @@\n+{\n+    \"problemMatcher\": [\n+        {\n+            \"owner\": \"tidy-error-file-line\",\n+            \"pattern\": [\n+                {\n+                    \"regexp\": \"^tidy error: /checkout/(.+):(\\\\d+): (.+)$\",\n+                    \"file\": 1,\n+                    \"line\": 2,\n+                    \"message\": 3\n+                }\n+            ]\n+        }\n+    ]\n+}"}, {"sha": "55e75800d91c4f62e7b5e58bb7387e9a2930725a", "filename": "src/ci/scripts/run-build-from-ci.sh", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/src%2Fci%2Fscripts%2Frun-build-from-ci.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/src%2Fci%2Fscripts%2Frun-build-from-ci.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Frun-build-from-ci.sh?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -10,6 +10,8 @@ source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n export CI=\"true\"\n export SRC=.\n \n+echo \"::add-matcher::src/ci/github-actions/problem_matchers.json\"\n+\n # Remove any preexisting rustup installation since it can interfere\n # with the cargotest step and its auto-detection of things like Clippy in\n # the environment"}, {"sha": "9b8170840bb0723ed8efd6cbe132c6c7258679f9", "filename": "tests/ui/asm/aarch64/parse-error.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/tests%2Fui%2Fasm%2Faarch64%2Fparse-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/tests%2Fui%2Fasm%2Faarch64%2Fparse-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasm%2Faarch64%2Fparse-error.rs?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -37,21 +37,18 @@ fn main() {\n         asm!(\"\", options(nomem, foo));\n         //~^ ERROR expected one of\n         asm!(\"{}\", options(), const foo);\n-        //~^ ERROR arguments are not allowed after options\n-        //~^^ ERROR attempt to use a non-constant value in a constant\n+        //~^ ERROR attempt to use a non-constant value in a constant\n         asm!(\"\", clobber_abi(foo));\n         //~^ ERROR expected string literal\n         asm!(\"\", clobber_abi(\"C\" foo));\n         //~^ ERROR expected one of `)` or `,`, found `foo`\n         asm!(\"\", clobber_abi(\"C\", foo));\n         //~^ ERROR expected string literal\n         asm!(\"{}\", clobber_abi(\"C\"), const foo);\n-        //~^ ERROR arguments are not allowed after clobber_abi\n-        //~^^ ERROR attempt to use a non-constant value in a constant\n+        //~^ ERROR attempt to use a non-constant value in a constant\n         asm!(\"\", options(), clobber_abi(\"C\"));\n-        //~^ ERROR clobber_abi is not allowed after options\n         asm!(\"{}\", options(), clobber_abi(\"C\"), const foo);\n-        //~^ ERROR clobber_abi is not allowed after options\n+        //~^ ERROR attempt to use a non-constant value in a constant\n         asm!(\"{a}\", a = const foo, a = const bar);\n         //~^ ERROR duplicate argument named `a`\n         //~^^ ERROR argument never used\n@@ -60,11 +57,9 @@ fn main() {\n         asm!(\"\", a = in(\"x0\") foo);\n         //~^ ERROR explicit register arguments cannot have names\n         asm!(\"{a}\", in(\"x0\") foo, a = const bar);\n-        //~^ ERROR named arguments cannot follow explicit register arguments\n-        //~^^ ERROR attempt to use a non-constant value in a constant\n+        //~^ ERROR attempt to use a non-constant value in a constant\n         asm!(\"{a}\", in(\"x0\") foo, a = const bar);\n-        //~^ ERROR named arguments cannot follow explicit register arguments\n-        //~^^ ERROR attempt to use a non-constant value in a constant\n+        //~^ ERROR attempt to use a non-constant value in a constant\n         asm!(\"{1}\", in(\"x0\") foo, const bar);\n         //~^ ERROR positional arguments cannot follow named arguments or explicit register arguments\n         //~^^ ERROR attempt to use a non-constant value in a constant\n@@ -106,20 +101,18 @@ global_asm!(\"\", options(nomem FOO));\n global_asm!(\"\", options(nomem, FOO));\n //~^ ERROR expected one of\n global_asm!(\"{}\", options(), const FOO);\n-//~^ ERROR arguments are not allowed after options\n global_asm!(\"\", clobber_abi(FOO));\n //~^ ERROR expected string literal\n global_asm!(\"\", clobber_abi(\"C\" FOO));\n //~^ ERROR expected one of `)` or `,`, found `FOO`\n global_asm!(\"\", clobber_abi(\"C\", FOO));\n //~^ ERROR expected string literal\n global_asm!(\"{}\", clobber_abi(\"C\"), const FOO);\n-//~^ ERROR arguments are not allowed after clobber_abi\n-//~^^ ERROR `clobber_abi` cannot be used with `global_asm!`\n+//~^ ERROR `clobber_abi` cannot be used with `global_asm!`\n global_asm!(\"\", options(), clobber_abi(\"C\"));\n-//~^ ERROR clobber_abi is not allowed after options\n+//~^ ERROR `clobber_abi` cannot be used with `global_asm!`\n global_asm!(\"{}\", options(), clobber_abi(\"C\"), const FOO);\n-//~^ ERROR clobber_abi is not allowed after options\n+//~^ ERROR `clobber_abi` cannot be used with `global_asm!`\n global_asm!(\"{a}\", a = const FOO, a = const BAR);\n //~^ ERROR duplicate argument named `a`\n //~^^ ERROR argument never used"}, {"sha": "46984a1fe1ca094514aa5bba9934d74a111fbdf5", "filename": "tests/ui/asm/aarch64/parse-error.stderr", "status": "modified", "additions": 55, "deletions": 114, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/tests%2Fui%2Fasm%2Faarch64%2Fparse-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/tests%2Fui%2Fasm%2Faarch64%2Fparse-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasm%2Faarch64%2Fparse-error.stderr?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -82,296 +82,228 @@ error: expected one of `)`, `att_syntax`, `may_unwind`, `nomem`, `noreturn`, `no\n LL |         asm!(\"\", options(nomem, foo));\n    |                                 ^^^ expected one of 10 possible tokens\n \n-error: arguments are not allowed after options\n-  --> $DIR/parse-error.rs:39:31\n-   |\n-LL |         asm!(\"{}\", options(), const foo);\n-   |                    ---------  ^^^^^^^^^ argument\n-   |                    |\n-   |                    previous options\n-\n error: expected string literal\n-  --> $DIR/parse-error.rs:42:30\n+  --> $DIR/parse-error.rs:41:30\n    |\n LL |         asm!(\"\", clobber_abi(foo));\n    |                              ^^^ not a string literal\n \n error: expected one of `)` or `,`, found `foo`\n-  --> $DIR/parse-error.rs:44:34\n+  --> $DIR/parse-error.rs:43:34\n    |\n LL |         asm!(\"\", clobber_abi(\"C\" foo));\n    |                                  ^^^ expected one of `)` or `,`\n \n error: expected string literal\n-  --> $DIR/parse-error.rs:46:35\n+  --> $DIR/parse-error.rs:45:35\n    |\n LL |         asm!(\"\", clobber_abi(\"C\", foo));\n    |                                   ^^^ not a string literal\n \n-error: arguments are not allowed after clobber_abi\n-  --> $DIR/parse-error.rs:48:38\n-   |\n-LL |         asm!(\"{}\", clobber_abi(\"C\"), const foo);\n-   |                    ----------------  ^^^^^^^^^ argument\n-   |                    |\n-   |                    clobber_abi\n-\n-error: clobber_abi is not allowed after options\n-  --> $DIR/parse-error.rs:51:29\n-   |\n-LL |         asm!(\"\", options(), clobber_abi(\"C\"));\n-   |                  ---------  ^^^^^^^^^^^^^^^^\n-   |                  |\n-   |                  options\n-\n-error: clobber_abi is not allowed after options\n-  --> $DIR/parse-error.rs:53:31\n-   |\n-LL |         asm!(\"{}\", options(), clobber_abi(\"C\"), const foo);\n-   |                    ---------  ^^^^^^^^^^^^^^^^\n-   |                    |\n-   |                    options\n-\n error: duplicate argument named `a`\n-  --> $DIR/parse-error.rs:55:36\n+  --> $DIR/parse-error.rs:52:36\n    |\n LL |         asm!(\"{a}\", a = const foo, a = const bar);\n    |                     -------------  ^^^^^^^^^^^^^ duplicate argument\n    |                     |\n    |                     previously here\n \n error: argument never used\n-  --> $DIR/parse-error.rs:55:36\n+  --> $DIR/parse-error.rs:52:36\n    |\n LL |         asm!(\"{a}\", a = const foo, a = const bar);\n    |                                    ^^^^^^^^^^^^^ argument never used\n    |\n    = help: if this argument is intentionally unused, consider using it in an asm comment: `\"/* {1} */\"`\n \n error: explicit register arguments cannot have names\n-  --> $DIR/parse-error.rs:60:18\n+  --> $DIR/parse-error.rs:57:18\n    |\n LL |         asm!(\"\", a = in(\"x0\") foo);\n    |                  ^^^^^^^^^^^^^^^^\n \n-error: named arguments cannot follow explicit register arguments\n-  --> $DIR/parse-error.rs:62:35\n-   |\n-LL |         asm!(\"{a}\", in(\"x0\") foo, a = const bar);\n-   |                     ------------  ^^^^^^^^^^^^^ named argument\n-   |                     |\n-   |                     explicit register argument\n-\n-error: named arguments cannot follow explicit register arguments\n-  --> $DIR/parse-error.rs:65:35\n-   |\n-LL |         asm!(\"{a}\", in(\"x0\") foo, a = const bar);\n-   |                     ------------  ^^^^^^^^^^^^^ named argument\n-   |                     |\n-   |                     explicit register argument\n-\n error: positional arguments cannot follow named arguments or explicit register arguments\n-  --> $DIR/parse-error.rs:68:35\n+  --> $DIR/parse-error.rs:63:35\n    |\n LL |         asm!(\"{1}\", in(\"x0\") foo, const bar);\n    |                     ------------  ^^^^^^^^^ positional argument\n    |                     |\n    |                     explicit register argument\n \n error: expected one of `clobber_abi`, `const`, `in`, `inlateout`, `inout`, `lateout`, `options`, `out`, or `sym`, found `\"\"`\n-  --> $DIR/parse-error.rs:71:29\n+  --> $DIR/parse-error.rs:66:29\n    |\n LL |         asm!(\"\", options(), \"\");\n    |                             ^^ expected one of 9 possible tokens\n \n error: expected one of `clobber_abi`, `const`, `in`, `inlateout`, `inout`, `lateout`, `options`, `out`, or `sym`, found `\"{}\"`\n-  --> $DIR/parse-error.rs:73:33\n+  --> $DIR/parse-error.rs:68:33\n    |\n LL |         asm!(\"{}\", in(reg) foo, \"{}\", out(reg) foo);\n    |                                 ^^^^ expected one of 9 possible tokens\n \n error: asm template must be a string literal\n-  --> $DIR/parse-error.rs:75:14\n+  --> $DIR/parse-error.rs:70:14\n    |\n LL |         asm!(format!(\"{{{}}}\", 0), in(reg) foo);\n    |              ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: asm template must be a string literal\n-  --> $DIR/parse-error.rs:77:21\n+  --> $DIR/parse-error.rs:72:21\n    |\n LL |         asm!(\"{1}\", format!(\"{{{}}}\", 0), in(reg) foo, out(reg) bar);\n    |                     ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: _ cannot be used for input operands\n-  --> $DIR/parse-error.rs:79:28\n+  --> $DIR/parse-error.rs:74:28\n    |\n LL |         asm!(\"{}\", in(reg) _);\n    |                            ^\n \n error: _ cannot be used for input operands\n-  --> $DIR/parse-error.rs:81:31\n+  --> $DIR/parse-error.rs:76:31\n    |\n LL |         asm!(\"{}\", inout(reg) _);\n    |                               ^\n \n error: _ cannot be used for input operands\n-  --> $DIR/parse-error.rs:83:35\n+  --> $DIR/parse-error.rs:78:35\n    |\n LL |         asm!(\"{}\", inlateout(reg) _);\n    |                                   ^\n \n error: requires at least a template string argument\n-  --> $DIR/parse-error.rs:90:1\n+  --> $DIR/parse-error.rs:85:1\n    |\n LL | global_asm!();\n    | ^^^^^^^^^^^^^\n \n error: asm template must be a string literal\n-  --> $DIR/parse-error.rs:92:13\n+  --> $DIR/parse-error.rs:87:13\n    |\n LL | global_asm!(FOO);\n    |             ^^^\n \n error: expected token: `,`\n-  --> $DIR/parse-error.rs:94:18\n+  --> $DIR/parse-error.rs:89:18\n    |\n LL | global_asm!(\"{}\" FOO);\n    |                  ^^^ expected `,`\n \n error: expected operand, options, or additional template string\n-  --> $DIR/parse-error.rs:96:19\n+  --> $DIR/parse-error.rs:91:19\n    |\n LL | global_asm!(\"{}\", FOO);\n    |                   ^^^ expected operand, options, or additional template string\n \n error: expected expression, found end of macro arguments\n-  --> $DIR/parse-error.rs:98:24\n+  --> $DIR/parse-error.rs:93:24\n    |\n LL | global_asm!(\"{}\", const);\n    |                        ^ expected expression\n \n error: expected one of `,`, `.`, `?`, or an operator, found `FOO`\n-  --> $DIR/parse-error.rs:100:30\n+  --> $DIR/parse-error.rs:95:30\n    |\n LL | global_asm!(\"{}\", const(reg) FOO);\n    |                              ^^^ expected one of `,`, `.`, `?`, or an operator\n \n error: expected one of `)`, `att_syntax`, or `raw`, found `FOO`\n-  --> $DIR/parse-error.rs:102:25\n+  --> $DIR/parse-error.rs:97:25\n    |\n LL | global_asm!(\"\", options(FOO));\n    |                         ^^^ expected one of `)`, `att_syntax`, or `raw`\n \n error: expected one of `)`, `att_syntax`, or `raw`, found `nomem`\n-  --> $DIR/parse-error.rs:104:25\n+  --> $DIR/parse-error.rs:99:25\n    |\n LL | global_asm!(\"\", options(nomem FOO));\n    |                         ^^^^^ expected one of `)`, `att_syntax`, or `raw`\n \n error: expected one of `)`, `att_syntax`, or `raw`, found `nomem`\n-  --> $DIR/parse-error.rs:106:25\n+  --> $DIR/parse-error.rs:101:25\n    |\n LL | global_asm!(\"\", options(nomem, FOO));\n    |                         ^^^^^ expected one of `)`, `att_syntax`, or `raw`\n \n-error: arguments are not allowed after options\n-  --> $DIR/parse-error.rs:108:30\n-   |\n-LL | global_asm!(\"{}\", options(), const FOO);\n-   |                   ---------  ^^^^^^^^^ argument\n-   |                   |\n-   |                   previous options\n-\n error: expected string literal\n-  --> $DIR/parse-error.rs:110:29\n+  --> $DIR/parse-error.rs:104:29\n    |\n LL | global_asm!(\"\", clobber_abi(FOO));\n    |                             ^^^ not a string literal\n \n error: expected one of `)` or `,`, found `FOO`\n-  --> $DIR/parse-error.rs:112:33\n+  --> $DIR/parse-error.rs:106:33\n    |\n LL | global_asm!(\"\", clobber_abi(\"C\" FOO));\n    |                                 ^^^ expected one of `)` or `,`\n \n error: expected string literal\n-  --> $DIR/parse-error.rs:114:34\n+  --> $DIR/parse-error.rs:108:34\n    |\n LL | global_asm!(\"\", clobber_abi(\"C\", FOO));\n    |                                  ^^^ not a string literal\n \n-error: arguments are not allowed after clobber_abi\n-  --> $DIR/parse-error.rs:116:37\n-   |\n-LL | global_asm!(\"{}\", clobber_abi(\"C\"), const FOO);\n-   |                   ----------------  ^^^^^^^^^ argument\n-   |                   |\n-   |                   clobber_abi\n-\n error: `clobber_abi` cannot be used with `global_asm!`\n-  --> $DIR/parse-error.rs:116:19\n+  --> $DIR/parse-error.rs:110:19\n    |\n LL | global_asm!(\"{}\", clobber_abi(\"C\"), const FOO);\n    |                   ^^^^^^^^^^^^^^^^\n \n-error: clobber_abi is not allowed after options\n-  --> $DIR/parse-error.rs:119:28\n+error: `clobber_abi` cannot be used with `global_asm!`\n+  --> $DIR/parse-error.rs:112:28\n    |\n LL | global_asm!(\"\", options(), clobber_abi(\"C\"));\n-   |                 ---------  ^^^^^^^^^^^^^^^^\n-   |                 |\n-   |                 options\n+   |                            ^^^^^^^^^^^^^^^^\n \n-error: clobber_abi is not allowed after options\n-  --> $DIR/parse-error.rs:121:30\n+error: `clobber_abi` cannot be used with `global_asm!`\n+  --> $DIR/parse-error.rs:114:30\n    |\n LL | global_asm!(\"{}\", options(), clobber_abi(\"C\"), const FOO);\n-   |                   ---------  ^^^^^^^^^^^^^^^^\n-   |                   |\n-   |                   options\n+   |                              ^^^^^^^^^^^^^^^^\n \n error: duplicate argument named `a`\n-  --> $DIR/parse-error.rs:123:35\n+  --> $DIR/parse-error.rs:116:35\n    |\n LL | global_asm!(\"{a}\", a = const FOO, a = const BAR);\n    |                    -------------  ^^^^^^^^^^^^^ duplicate argument\n    |                    |\n    |                    previously here\n \n error: argument never used\n-  --> $DIR/parse-error.rs:123:35\n+  --> $DIR/parse-error.rs:116:35\n    |\n LL | global_asm!(\"{a}\", a = const FOO, a = const BAR);\n    |                                   ^^^^^^^^^^^^^ argument never used\n    |\n    = help: if this argument is intentionally unused, consider using it in an asm comment: `\"/* {1} */\"`\n \n error: expected one of `clobber_abi`, `const`, `options`, or `sym`, found `\"\"`\n-  --> $DIR/parse-error.rs:126:28\n+  --> $DIR/parse-error.rs:119:28\n    |\n LL | global_asm!(\"\", options(), \"\");\n    |                            ^^ expected one of `clobber_abi`, `const`, `options`, or `sym`\n \n error: expected one of `clobber_abi`, `const`, `options`, or `sym`, found `\"{}\"`\n-  --> $DIR/parse-error.rs:128:30\n+  --> $DIR/parse-error.rs:121:30\n    |\n LL | global_asm!(\"{}\", const FOO, \"{}\", const FOO);\n    |                              ^^^^ expected one of `clobber_abi`, `const`, `options`, or `sym`\n \n error: asm template must be a string literal\n-  --> $DIR/parse-error.rs:130:13\n+  --> $DIR/parse-error.rs:123:13\n    |\n LL | global_asm!(format!(\"{{{}}}\", 0), const FOO);\n    |             ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: asm template must be a string literal\n-  --> $DIR/parse-error.rs:132:20\n+  --> $DIR/parse-error.rs:125:20\n    |\n LL | global_asm!(\"{1}\", format!(\"{{{}}}\", 0), const FOO, const BAR);\n    |                    ^^^^^^^^^^^^^^^^^^^^\n@@ -388,7 +320,7 @@ LL |         asm!(\"{}\", options(), const foo);\n    |                                     ^^^ non-constant value\n \n error[E0435]: attempt to use a non-constant value in a constant\n-  --> $DIR/parse-error.rs:48:44\n+  --> $DIR/parse-error.rs:47:44\n    |\n LL |     let mut foo = 0;\n    |     ----------- help: consider using `const` instead of `let`: `const foo`\n@@ -397,7 +329,16 @@ LL |         asm!(\"{}\", clobber_abi(\"C\"), const foo);\n    |                                            ^^^ non-constant value\n \n error[E0435]: attempt to use a non-constant value in a constant\n-  --> $DIR/parse-error.rs:55:31\n+  --> $DIR/parse-error.rs:50:55\n+   |\n+LL |     let mut foo = 0;\n+   |     ----------- help: consider using `const` instead of `let`: `const foo`\n+...\n+LL |         asm!(\"{}\", options(), clobber_abi(\"C\"), const foo);\n+   |                                                       ^^^ non-constant value\n+\n+error[E0435]: attempt to use a non-constant value in a constant\n+  --> $DIR/parse-error.rs:52:31\n    |\n LL |     let mut foo = 0;\n    |     ----------- help: consider using `const` instead of `let`: `const foo`\n@@ -406,7 +347,7 @@ LL |         asm!(\"{a}\", a = const foo, a = const bar);\n    |                               ^^^ non-constant value\n \n error[E0435]: attempt to use a non-constant value in a constant\n-  --> $DIR/parse-error.rs:55:46\n+  --> $DIR/parse-error.rs:52:46\n    |\n LL |     let mut bar = 0;\n    |     ----------- help: consider using `const` instead of `let`: `const bar`\n@@ -415,7 +356,7 @@ LL |         asm!(\"{a}\", a = const foo, a = const bar);\n    |                                              ^^^ non-constant value\n \n error[E0435]: attempt to use a non-constant value in a constant\n-  --> $DIR/parse-error.rs:62:45\n+  --> $DIR/parse-error.rs:59:45\n    |\n LL |     let mut bar = 0;\n    |     ----------- help: consider using `const` instead of `let`: `const bar`\n@@ -424,7 +365,7 @@ LL |         asm!(\"{a}\", in(\"x0\") foo, a = const bar);\n    |                                             ^^^ non-constant value\n \n error[E0435]: attempt to use a non-constant value in a constant\n-  --> $DIR/parse-error.rs:65:45\n+  --> $DIR/parse-error.rs:61:45\n    |\n LL |     let mut bar = 0;\n    |     ----------- help: consider using `const` instead of `let`: `const bar`\n@@ -433,14 +374,14 @@ LL |         asm!(\"{a}\", in(\"x0\") foo, a = const bar);\n    |                                             ^^^ non-constant value\n \n error[E0435]: attempt to use a non-constant value in a constant\n-  --> $DIR/parse-error.rs:68:41\n+  --> $DIR/parse-error.rs:63:41\n    |\n LL |     let mut bar = 0;\n    |     ----------- help: consider using `const` instead of `let`: `const bar`\n ...\n LL |         asm!(\"{1}\", in(\"x0\") foo, const bar);\n    |                                         ^^^ non-constant value\n \n-error: aborting due to 64 previous errors\n+error: aborting due to 57 previous errors\n \n For more information about this error, try `rustc --explain E0435`."}, {"sha": "b16f9a06c2abe5a5f78a81371170abfed5487597", "filename": "tests/ui/asm/bad-template.aarch64_mirunsafeck.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/tests%2Fui%2Fasm%2Fbad-template.aarch64_mirunsafeck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/tests%2Fui%2Fasm%2Fbad-template.aarch64_mirunsafeck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasm%2Fbad-template.aarch64_mirunsafeck.stderr?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -81,6 +81,11 @@ note: explicit register arguments cannot be used in the asm template\n    |\n LL |         asm!(\"{}\", in(\"x0\") foo);\n    |                    ^^^^^^^^^^^^\n+help: use the register name directly in the assembly code\n+  --> $DIR/bad-template.rs:48:20\n+   |\n+LL |         asm!(\"{}\", in(\"x0\") foo);\n+   |                    ^^^^^^^^^^^^\n \n error: asm template modifier must be a single character\n   --> $DIR/bad-template.rs:50:17"}, {"sha": "b16f9a06c2abe5a5f78a81371170abfed5487597", "filename": "tests/ui/asm/bad-template.aarch64_thirunsafeck.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/tests%2Fui%2Fasm%2Fbad-template.aarch64_thirunsafeck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/tests%2Fui%2Fasm%2Fbad-template.aarch64_thirunsafeck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasm%2Fbad-template.aarch64_thirunsafeck.stderr?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -81,6 +81,11 @@ note: explicit register arguments cannot be used in the asm template\n    |\n LL |         asm!(\"{}\", in(\"x0\") foo);\n    |                    ^^^^^^^^^^^^\n+help: use the register name directly in the assembly code\n+  --> $DIR/bad-template.rs:48:20\n+   |\n+LL |         asm!(\"{}\", in(\"x0\") foo);\n+   |                    ^^^^^^^^^^^^\n \n error: asm template modifier must be a single character\n   --> $DIR/bad-template.rs:50:17"}, {"sha": "41ac37c33c2e057676ec24a44404480504e84d5b", "filename": "tests/ui/asm/bad-template.x86_64_mirunsafeck.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/tests%2Fui%2Fasm%2Fbad-template.x86_64_mirunsafeck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/tests%2Fui%2Fasm%2Fbad-template.x86_64_mirunsafeck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasm%2Fbad-template.x86_64_mirunsafeck.stderr?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -81,6 +81,11 @@ note: explicit register arguments cannot be used in the asm template\n    |\n LL |         asm!(\"{}\", in(\"eax\") foo);\n    |                    ^^^^^^^^^^^^^\n+help: use the register name directly in the assembly code\n+  --> $DIR/bad-template.rs:45:20\n+   |\n+LL |         asm!(\"{}\", in(\"eax\") foo);\n+   |                    ^^^^^^^^^^^^^\n \n error: asm template modifier must be a single character\n   --> $DIR/bad-template.rs:50:17"}, {"sha": "41ac37c33c2e057676ec24a44404480504e84d5b", "filename": "tests/ui/asm/bad-template.x86_64_thirunsafeck.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/tests%2Fui%2Fasm%2Fbad-template.x86_64_thirunsafeck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/tests%2Fui%2Fasm%2Fbad-template.x86_64_thirunsafeck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasm%2Fbad-template.x86_64_thirunsafeck.stderr?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -81,6 +81,11 @@ note: explicit register arguments cannot be used in the asm template\n    |\n LL |         asm!(\"{}\", in(\"eax\") foo);\n    |                    ^^^^^^^^^^^^^\n+help: use the register name directly in the assembly code\n+  --> $DIR/bad-template.rs:45:20\n+   |\n+LL |         asm!(\"{}\", in(\"eax\") foo);\n+   |                    ^^^^^^^^^^^^^\n \n error: asm template modifier must be a single character\n   --> $DIR/bad-template.rs:50:17"}, {"sha": "2e714d464ae74a7536dff0f7376a2f8aa22a201f", "filename": "tests/ui/asm/x86_64/parse-error.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/tests%2Fui%2Fasm%2Fx86_64%2Fparse-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/tests%2Fui%2Fasm%2Fx86_64%2Fparse-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasm%2Fx86_64%2Fparse-error.rs?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -37,8 +37,7 @@ fn main() {\n         asm!(\"\", options(nomem, foo));\n         //~^ ERROR expected one of\n         asm!(\"{}\", options(), const foo);\n-        //~^ ERROR arguments are not allowed after options\n-        //~^^ ERROR attempt to use a non-constant value in a constant\n+        //~^ ERROR attempt to use a non-constant value in a constant\n         asm!(\"\", clobber_abi());\n         //~^ ERROR at least one abi must be provided\n         asm!(\"\", clobber_abi(foo));\n@@ -48,12 +47,10 @@ fn main() {\n         asm!(\"\", clobber_abi(\"C\", foo));\n         //~^ ERROR expected string literal\n         asm!(\"{}\", clobber_abi(\"C\"), const foo);\n-        //~^ ERROR arguments are not allowed after clobber_abi\n-        //~^^ ERROR attempt to use a non-constant value in a constant\n+        //~^ ERROR attempt to use a non-constant value in a constant\n         asm!(\"\", options(), clobber_abi(\"C\"));\n-        //~^ ERROR clobber_abi is not allowed after options\n         asm!(\"{}\", options(), clobber_abi(\"C\"), const foo);\n-        //~^ ERROR clobber_abi is not allowed after options\n+        //~^ ERROR attempt to use a non-constant value in a constant\n         asm!(\"{a}\", a = const foo, a = const bar);\n         //~^ ERROR duplicate argument named `a`\n         //~^^ ERROR argument never used\n@@ -62,11 +59,9 @@ fn main() {\n         asm!(\"\", a = in(\"eax\") foo);\n         //~^ ERROR explicit register arguments cannot have names\n         asm!(\"{a}\", in(\"eax\") foo, a = const bar);\n-        //~^ ERROR named arguments cannot follow explicit register arguments\n-        //~^^ ERROR attempt to use a non-constant value in a constant\n+        //~^ ERROR attempt to use a non-constant value in a constant\n         asm!(\"{a}\", in(\"eax\") foo, a = const bar);\n-        //~^ ERROR named arguments cannot follow explicit register arguments\n-        //~^^ ERROR attempt to use a non-constant value in a constant\n+        //~^ ERROR attempt to use a non-constant value in a constant\n         asm!(\"{1}\", in(\"eax\") foo, const bar);\n         //~^ ERROR positional arguments cannot follow named arguments or explicit register arguments\n         //~^^ ERROR attempt to use a non-constant value in a constant\n@@ -108,20 +103,18 @@ global_asm!(\"\", options(nomem FOO));\n global_asm!(\"\", options(nomem, FOO));\n //~^ ERROR expected one of\n global_asm!(\"{}\", options(), const FOO);\n-//~^ ERROR arguments are not allowed after options\n global_asm!(\"\", clobber_abi(FOO));\n //~^ ERROR expected string literal\n global_asm!(\"\", clobber_abi(\"C\" FOO));\n //~^ ERROR expected one of `)` or `,`, found `FOO`\n global_asm!(\"\", clobber_abi(\"C\", FOO));\n //~^ ERROR expected string literal\n global_asm!(\"{}\", clobber_abi(\"C\"), const FOO);\n-//~^ ERROR arguments are not allowed after clobber_abi\n-//~^^ ERROR `clobber_abi` cannot be used with `global_asm!`\n+//~^ ERROR `clobber_abi` cannot be used with `global_asm!`\n global_asm!(\"\", options(), clobber_abi(\"C\"));\n-//~^ ERROR clobber_abi is not allowed after options\n+//~^ ERROR `clobber_abi` cannot be used with `global_asm!`\n global_asm!(\"{}\", options(), clobber_abi(\"C\"), const FOO);\n-//~^ ERROR clobber_abi is not allowed after options\n+//~^ ERROR `clobber_abi` cannot be used with `global_asm!`\n global_asm!(\"\", clobber_abi(\"C\"), clobber_abi(\"C\"));\n //~^ ERROR `clobber_abi` cannot be used with `global_asm!`\n global_asm!(\"{a}\", a = const FOO, a = const BAR);"}, {"sha": "0c9d6f71529c1a180d6f4d0166f14693f3fb6702", "filename": "tests/ui/asm/x86_64/parse-error.stderr", "status": "modified", "additions": 57, "deletions": 116, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/e350fe4e608b653da47e8012d13ef701613e717b/tests%2Fui%2Fasm%2Fx86_64%2Fparse-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e350fe4e608b653da47e8012d13ef701613e717b/tests%2Fui%2Fasm%2Fx86_64%2Fparse-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasm%2Fx86_64%2Fparse-error.stderr?ref=e350fe4e608b653da47e8012d13ef701613e717b", "patch": "@@ -82,308 +82,240 @@ error: expected one of `)`, `att_syntax`, `may_unwind`, `nomem`, `noreturn`, `no\n LL |         asm!(\"\", options(nomem, foo));\n    |                                 ^^^ expected one of 10 possible tokens\n \n-error: arguments are not allowed after options\n-  --> $DIR/parse-error.rs:39:31\n-   |\n-LL |         asm!(\"{}\", options(), const foo);\n-   |                    ---------  ^^^^^^^^^ argument\n-   |                    |\n-   |                    previous options\n-\n error: at least one abi must be provided as an argument to `clobber_abi`\n-  --> $DIR/parse-error.rs:42:30\n+  --> $DIR/parse-error.rs:41:30\n    |\n LL |         asm!(\"\", clobber_abi());\n    |                              ^\n \n error: expected string literal\n-  --> $DIR/parse-error.rs:44:30\n+  --> $DIR/parse-error.rs:43:30\n    |\n LL |         asm!(\"\", clobber_abi(foo));\n    |                              ^^^ not a string literal\n \n error: expected one of `)` or `,`, found `foo`\n-  --> $DIR/parse-error.rs:46:34\n+  --> $DIR/parse-error.rs:45:34\n    |\n LL |         asm!(\"\", clobber_abi(\"C\" foo));\n    |                                  ^^^ expected one of `)` or `,`\n \n error: expected string literal\n-  --> $DIR/parse-error.rs:48:35\n+  --> $DIR/parse-error.rs:47:35\n    |\n LL |         asm!(\"\", clobber_abi(\"C\", foo));\n    |                                   ^^^ not a string literal\n \n-error: arguments are not allowed after clobber_abi\n-  --> $DIR/parse-error.rs:50:38\n-   |\n-LL |         asm!(\"{}\", clobber_abi(\"C\"), const foo);\n-   |                    ----------------  ^^^^^^^^^ argument\n-   |                    |\n-   |                    clobber_abi\n-\n-error: clobber_abi is not allowed after options\n-  --> $DIR/parse-error.rs:53:29\n-   |\n-LL |         asm!(\"\", options(), clobber_abi(\"C\"));\n-   |                  ---------  ^^^^^^^^^^^^^^^^\n-   |                  |\n-   |                  options\n-\n-error: clobber_abi is not allowed after options\n-  --> $DIR/parse-error.rs:55:31\n-   |\n-LL |         asm!(\"{}\", options(), clobber_abi(\"C\"), const foo);\n-   |                    ---------  ^^^^^^^^^^^^^^^^\n-   |                    |\n-   |                    options\n-\n error: duplicate argument named `a`\n-  --> $DIR/parse-error.rs:57:36\n+  --> $DIR/parse-error.rs:54:36\n    |\n LL |         asm!(\"{a}\", a = const foo, a = const bar);\n    |                     -------------  ^^^^^^^^^^^^^ duplicate argument\n    |                     |\n    |                     previously here\n \n error: argument never used\n-  --> $DIR/parse-error.rs:57:36\n+  --> $DIR/parse-error.rs:54:36\n    |\n LL |         asm!(\"{a}\", a = const foo, a = const bar);\n    |                                    ^^^^^^^^^^^^^ argument never used\n    |\n    = help: if this argument is intentionally unused, consider using it in an asm comment: `\"/* {1} */\"`\n \n error: explicit register arguments cannot have names\n-  --> $DIR/parse-error.rs:62:18\n+  --> $DIR/parse-error.rs:59:18\n    |\n LL |         asm!(\"\", a = in(\"eax\") foo);\n    |                  ^^^^^^^^^^^^^^^^^\n \n-error: named arguments cannot follow explicit register arguments\n-  --> $DIR/parse-error.rs:64:36\n-   |\n-LL |         asm!(\"{a}\", in(\"eax\") foo, a = const bar);\n-   |                     -------------  ^^^^^^^^^^^^^ named argument\n-   |                     |\n-   |                     explicit register argument\n-\n-error: named arguments cannot follow explicit register arguments\n-  --> $DIR/parse-error.rs:67:36\n-   |\n-LL |         asm!(\"{a}\", in(\"eax\") foo, a = const bar);\n-   |                     -------------  ^^^^^^^^^^^^^ named argument\n-   |                     |\n-   |                     explicit register argument\n-\n error: positional arguments cannot follow named arguments or explicit register arguments\n-  --> $DIR/parse-error.rs:70:36\n+  --> $DIR/parse-error.rs:65:36\n    |\n LL |         asm!(\"{1}\", in(\"eax\") foo, const bar);\n    |                     -------------  ^^^^^^^^^ positional argument\n    |                     |\n    |                     explicit register argument\n \n error: expected one of `clobber_abi`, `const`, `in`, `inlateout`, `inout`, `lateout`, `options`, `out`, or `sym`, found `\"\"`\n-  --> $DIR/parse-error.rs:73:29\n+  --> $DIR/parse-error.rs:68:29\n    |\n LL |         asm!(\"\", options(), \"\");\n    |                             ^^ expected one of 9 possible tokens\n \n error: expected one of `clobber_abi`, `const`, `in`, `inlateout`, `inout`, `lateout`, `options`, `out`, or `sym`, found `\"{}\"`\n-  --> $DIR/parse-error.rs:75:33\n+  --> $DIR/parse-error.rs:70:33\n    |\n LL |         asm!(\"{}\", in(reg) foo, \"{}\", out(reg) foo);\n    |                                 ^^^^ expected one of 9 possible tokens\n \n error: asm template must be a string literal\n-  --> $DIR/parse-error.rs:77:14\n+  --> $DIR/parse-error.rs:72:14\n    |\n LL |         asm!(format!(\"{{{}}}\", 0), in(reg) foo);\n    |              ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: asm template must be a string literal\n-  --> $DIR/parse-error.rs:79:21\n+  --> $DIR/parse-error.rs:74:21\n    |\n LL |         asm!(\"{1}\", format!(\"{{{}}}\", 0), in(reg) foo, out(reg) bar);\n    |                     ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: _ cannot be used for input operands\n-  --> $DIR/parse-error.rs:81:28\n+  --> $DIR/parse-error.rs:76:28\n    |\n LL |         asm!(\"{}\", in(reg) _);\n    |                            ^\n \n error: _ cannot be used for input operands\n-  --> $DIR/parse-error.rs:83:31\n+  --> $DIR/parse-error.rs:78:31\n    |\n LL |         asm!(\"{}\", inout(reg) _);\n    |                               ^\n \n error: _ cannot be used for input operands\n-  --> $DIR/parse-error.rs:85:35\n+  --> $DIR/parse-error.rs:80:35\n    |\n LL |         asm!(\"{}\", inlateout(reg) _);\n    |                                   ^\n \n error: requires at least a template string argument\n-  --> $DIR/parse-error.rs:92:1\n+  --> $DIR/parse-error.rs:87:1\n    |\n LL | global_asm!();\n    | ^^^^^^^^^^^^^\n \n error: asm template must be a string literal\n-  --> $DIR/parse-error.rs:94:13\n+  --> $DIR/parse-error.rs:89:13\n    |\n LL | global_asm!(FOO);\n    |             ^^^\n \n error: expected token: `,`\n-  --> $DIR/parse-error.rs:96:18\n+  --> $DIR/parse-error.rs:91:18\n    |\n LL | global_asm!(\"{}\" FOO);\n    |                  ^^^ expected `,`\n \n error: expected operand, options, or additional template string\n-  --> $DIR/parse-error.rs:98:19\n+  --> $DIR/parse-error.rs:93:19\n    |\n LL | global_asm!(\"{}\", FOO);\n    |                   ^^^ expected operand, options, or additional template string\n \n error: expected expression, found end of macro arguments\n-  --> $DIR/parse-error.rs:100:24\n+  --> $DIR/parse-error.rs:95:24\n    |\n LL | global_asm!(\"{}\", const);\n    |                        ^ expected expression\n \n error: expected one of `,`, `.`, `?`, or an operator, found `FOO`\n-  --> $DIR/parse-error.rs:102:30\n+  --> $DIR/parse-error.rs:97:30\n    |\n LL | global_asm!(\"{}\", const(reg) FOO);\n    |                              ^^^ expected one of `,`, `.`, `?`, or an operator\n \n error: expected one of `)`, `att_syntax`, or `raw`, found `FOO`\n-  --> $DIR/parse-error.rs:104:25\n+  --> $DIR/parse-error.rs:99:25\n    |\n LL | global_asm!(\"\", options(FOO));\n    |                         ^^^ expected one of `)`, `att_syntax`, or `raw`\n \n error: expected one of `)`, `att_syntax`, or `raw`, found `nomem`\n-  --> $DIR/parse-error.rs:106:25\n+  --> $DIR/parse-error.rs:101:25\n    |\n LL | global_asm!(\"\", options(nomem FOO));\n    |                         ^^^^^ expected one of `)`, `att_syntax`, or `raw`\n \n error: expected one of `)`, `att_syntax`, or `raw`, found `nomem`\n-  --> $DIR/parse-error.rs:108:25\n+  --> $DIR/parse-error.rs:103:25\n    |\n LL | global_asm!(\"\", options(nomem, FOO));\n    |                         ^^^^^ expected one of `)`, `att_syntax`, or `raw`\n \n-error: arguments are not allowed after options\n-  --> $DIR/parse-error.rs:110:30\n-   |\n-LL | global_asm!(\"{}\", options(), const FOO);\n-   |                   ---------  ^^^^^^^^^ argument\n-   |                   |\n-   |                   previous options\n-\n error: expected string literal\n-  --> $DIR/parse-error.rs:112:29\n+  --> $DIR/parse-error.rs:106:29\n    |\n LL | global_asm!(\"\", clobber_abi(FOO));\n    |                             ^^^ not a string literal\n \n error: expected one of `)` or `,`, found `FOO`\n-  --> $DIR/parse-error.rs:114:33\n+  --> $DIR/parse-error.rs:108:33\n    |\n LL | global_asm!(\"\", clobber_abi(\"C\" FOO));\n    |                                 ^^^ expected one of `)` or `,`\n \n error: expected string literal\n-  --> $DIR/parse-error.rs:116:34\n+  --> $DIR/parse-error.rs:110:34\n    |\n LL | global_asm!(\"\", clobber_abi(\"C\", FOO));\n    |                                  ^^^ not a string literal\n \n-error: arguments are not allowed after clobber_abi\n-  --> $DIR/parse-error.rs:118:37\n-   |\n-LL | global_asm!(\"{}\", clobber_abi(\"C\"), const FOO);\n-   |                   ----------------  ^^^^^^^^^ argument\n-   |                   |\n-   |                   clobber_abi\n-\n error: `clobber_abi` cannot be used with `global_asm!`\n-  --> $DIR/parse-error.rs:118:19\n+  --> $DIR/parse-error.rs:112:19\n    |\n LL | global_asm!(\"{}\", clobber_abi(\"C\"), const FOO);\n    |                   ^^^^^^^^^^^^^^^^\n \n-error: clobber_abi is not allowed after options\n-  --> $DIR/parse-error.rs:121:28\n+error: `clobber_abi` cannot be used with `global_asm!`\n+  --> $DIR/parse-error.rs:114:28\n    |\n LL | global_asm!(\"\", options(), clobber_abi(\"C\"));\n-   |                 ---------  ^^^^^^^^^^^^^^^^\n-   |                 |\n-   |                 options\n+   |                            ^^^^^^^^^^^^^^^^\n \n-error: clobber_abi is not allowed after options\n-  --> $DIR/parse-error.rs:123:30\n+error: `clobber_abi` cannot be used with `global_asm!`\n+  --> $DIR/parse-error.rs:116:30\n    |\n LL | global_asm!(\"{}\", options(), clobber_abi(\"C\"), const FOO);\n-   |                   ---------  ^^^^^^^^^^^^^^^^\n-   |                   |\n-   |                   options\n+   |                              ^^^^^^^^^^^^^^^^\n \n error: `clobber_abi` cannot be used with `global_asm!`\n-  --> $DIR/parse-error.rs:125:17\n+  --> $DIR/parse-error.rs:118:17\n    |\n LL | global_asm!(\"\", clobber_abi(\"C\"), clobber_abi(\"C\"));\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n \n error: duplicate argument named `a`\n-  --> $DIR/parse-error.rs:127:35\n+  --> $DIR/parse-error.rs:120:35\n    |\n LL | global_asm!(\"{a}\", a = const FOO, a = const BAR);\n    |                    -------------  ^^^^^^^^^^^^^ duplicate argument\n    |                    |\n    |                    previously here\n \n error: argument never used\n-  --> $DIR/parse-error.rs:127:35\n+  --> $DIR/parse-error.rs:120:35\n    |\n LL | global_asm!(\"{a}\", a = const FOO, a = const BAR);\n    |                                   ^^^^^^^^^^^^^ argument never used\n    |\n    = help: if this argument is intentionally unused, consider using it in an asm comment: `\"/* {1} */\"`\n \n error: expected one of `clobber_abi`, `const`, `options`, or `sym`, found `\"\"`\n-  --> $DIR/parse-error.rs:130:28\n+  --> $DIR/parse-error.rs:123:28\n    |\n LL | global_asm!(\"\", options(), \"\");\n    |                            ^^ expected one of `clobber_abi`, `const`, `options`, or `sym`\n \n error: expected one of `clobber_abi`, `const`, `options`, or `sym`, found `\"{}\"`\n-  --> $DIR/parse-error.rs:132:30\n+  --> $DIR/parse-error.rs:125:30\n    |\n LL | global_asm!(\"{}\", const FOO, \"{}\", const FOO);\n    |                              ^^^^ expected one of `clobber_abi`, `const`, `options`, or `sym`\n \n error: asm template must be a string literal\n-  --> $DIR/parse-error.rs:134:13\n+  --> $DIR/parse-error.rs:127:13\n    |\n LL | global_asm!(format!(\"{{{}}}\", 0), const FOO);\n    |             ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: asm template must be a string literal\n-  --> $DIR/parse-error.rs:136:20\n+  --> $DIR/parse-error.rs:129:20\n    |\n LL | global_asm!(\"{1}\", format!(\"{{{}}}\", 0), const FOO, const BAR);\n    |                    ^^^^^^^^^^^^^^^^^^^^\n@@ -400,7 +332,7 @@ LL |         asm!(\"{}\", options(), const foo);\n    |                                     ^^^ non-constant value\n \n error[E0435]: attempt to use a non-constant value in a constant\n-  --> $DIR/parse-error.rs:50:44\n+  --> $DIR/parse-error.rs:49:44\n    |\n LL |     let mut foo = 0;\n    |     ----------- help: consider using `const` instead of `let`: `const foo`\n@@ -409,7 +341,16 @@ LL |         asm!(\"{}\", clobber_abi(\"C\"), const foo);\n    |                                            ^^^ non-constant value\n \n error[E0435]: attempt to use a non-constant value in a constant\n-  --> $DIR/parse-error.rs:57:31\n+  --> $DIR/parse-error.rs:52:55\n+   |\n+LL |     let mut foo = 0;\n+   |     ----------- help: consider using `const` instead of `let`: `const foo`\n+...\n+LL |         asm!(\"{}\", options(), clobber_abi(\"C\"), const foo);\n+   |                                                       ^^^ non-constant value\n+\n+error[E0435]: attempt to use a non-constant value in a constant\n+  --> $DIR/parse-error.rs:54:31\n    |\n LL |     let mut foo = 0;\n    |     ----------- help: consider using `const` instead of `let`: `const foo`\n@@ -418,7 +359,7 @@ LL |         asm!(\"{a}\", a = const foo, a = const bar);\n    |                               ^^^ non-constant value\n \n error[E0435]: attempt to use a non-constant value in a constant\n-  --> $DIR/parse-error.rs:57:46\n+  --> $DIR/parse-error.rs:54:46\n    |\n LL |     let mut bar = 0;\n    |     ----------- help: consider using `const` instead of `let`: `const bar`\n@@ -427,7 +368,7 @@ LL |         asm!(\"{a}\", a = const foo, a = const bar);\n    |                                              ^^^ non-constant value\n \n error[E0435]: attempt to use a non-constant value in a constant\n-  --> $DIR/parse-error.rs:64:46\n+  --> $DIR/parse-error.rs:61:46\n    |\n LL |     let mut bar = 0;\n    |     ----------- help: consider using `const` instead of `let`: `const bar`\n@@ -436,7 +377,7 @@ LL |         asm!(\"{a}\", in(\"eax\") foo, a = const bar);\n    |                                              ^^^ non-constant value\n \n error[E0435]: attempt to use a non-constant value in a constant\n-  --> $DIR/parse-error.rs:67:46\n+  --> $DIR/parse-error.rs:63:46\n    |\n LL |     let mut bar = 0;\n    |     ----------- help: consider using `const` instead of `let`: `const bar`\n@@ -445,14 +386,14 @@ LL |         asm!(\"{a}\", in(\"eax\") foo, a = const bar);\n    |                                              ^^^ non-constant value\n \n error[E0435]: attempt to use a non-constant value in a constant\n-  --> $DIR/parse-error.rs:70:42\n+  --> $DIR/parse-error.rs:65:42\n    |\n LL |     let mut bar = 0;\n    |     ----------- help: consider using `const` instead of `let`: `const bar`\n ...\n LL |         asm!(\"{1}\", in(\"eax\") foo, const bar);\n    |                                          ^^^ non-constant value\n \n-error: aborting due to 66 previous errors\n+error: aborting due to 59 previous errors\n \n For more information about this error, try `rustc --explain E0435`."}]}