{"sha": "8282f7fe805087f26ed60a6a5cba0abe50637d39", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyODJmN2ZlODA1MDg3ZjI2ZWQ2MGE2YTVjYmEwYWJlNTA2MzdkMzk=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-27T08:50:18Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-27T15:30:54Z"}, "message": "Move expr_binary into trans_expr_dps\n\nIssue #667", "tree": {"sha": "02b9cb47a4b1d5a1d1552854e2d05e8c19c1154a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02b9cb47a4b1d5a1d1552854e2d05e8c19c1154a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8282f7fe805087f26ed60a6a5cba0abe50637d39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8282f7fe805087f26ed60a6a5cba0abe50637d39", "html_url": "https://github.com/rust-lang/rust/commit/8282f7fe805087f26ed60a6a5cba0abe50637d39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8282f7fe805087f26ed60a6a5cba0abe50637d39/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "806e74fbf50febd4509a61dac9abcb7c9c4efd86", "url": "https://api.github.com/repos/rust-lang/rust/commits/806e74fbf50febd4509a61dac9abcb7c9c4efd86", "html_url": "https://github.com/rust-lang/rust/commit/806e74fbf50febd4509a61dac9abcb7c9c4efd86"}], "stats": {"total": 238, "additions": 115, "deletions": 123}, "files": [{"sha": "8650fa514e81de611376ed0b8d49f4f2ac50eba9", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 91, "deletions": 105, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/8282f7fe805087f26ed60a6a5cba0abe50637d39/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8282f7fe805087f26ed60a6a5cba0abe50637d39/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=8282f7fe805087f26ed60a6a5cba0abe50637d39", "patch": "@@ -2158,10 +2158,7 @@ fn trans_lit(cx: @block_ctxt, lit: ast::lit, dest: dest) -> @block_ctxt {\n     alt lit.node {\n       ast::lit_str(s) { ret tvec::trans_str(cx, s, dest); }\n       _ {\n-        let cell = alt dest { by_val(c) { c }\n-                             _ { bcx_ccx(cx).sess.span_note(lit.span, \"here\"); fail; }};\n-        *cell = trans_crate_lit(bcx_ccx(cx), lit);\n-        ret cx;\n+        ret store_in_dest(cx, trans_crate_lit(bcx_ccx(cx), lit), dest);\n       }\n     }\n }\n@@ -2253,8 +2250,9 @@ fn trans_compare(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n // Important to get types for both lhs and rhs, because one might be _|_\n // and the other not.\n fn trans_eager_binop(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n-                     lhs_t: ty::t, rhs: ValueRef, rhs_t: ty::t) -> result {\n-\n+                     lhs_t: ty::t, rhs: ValueRef, rhs_t: ty::t, dest: dest)\n+    -> @block_ctxt {\n+    if dest == ignore { ret cx; }\n     let is_float = false;\n     let intype = lhs_t;\n     if ty::type_is_bot(bcx_tcx(cx), intype) { intype = rhs_t; }\n@@ -2263,45 +2261,47 @@ fn trans_eager_binop(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n       ty::ty_float. { is_float = true; }\n       _ { is_float = false; }\n     }\n-    alt op {\n+    if op == ast::add && ty::type_is_sequence(bcx_tcx(cx), intype) {\n+        ret tvec::trans_add(cx, intype, lhs, rhs, dest);\n+    }\n+    let val = alt op {\n       ast::add. {\n-        if ty::type_is_sequence(bcx_tcx(cx), intype) {\n-            ret tvec::trans_add(cx, intype, lhs, rhs);\n-        }\n-        if is_float {\n-            ret rslt(cx, FAdd(cx, lhs, rhs));\n-        } else { ret rslt(cx, Add(cx, lhs, rhs)); }\n+        if is_float { FAdd(cx, lhs, rhs) }\n+        else { Add(cx, lhs, rhs) }\n       }\n       ast::sub. {\n-        if is_float {\n-            ret rslt(cx, FSub(cx, lhs, rhs));\n-        } else { ret rslt(cx, Sub(cx, lhs, rhs)); }\n+        if is_float { FSub(cx, lhs, rhs) }\n+        else { Sub(cx, lhs, rhs) }\n       }\n       ast::mul. {\n-        if is_float {\n-            ret rslt(cx, FMul(cx, lhs, rhs));\n-        } else { ret rslt(cx, Mul(cx, lhs, rhs)); }\n+        if is_float { FMul(cx, lhs, rhs) }\n+        else { Mul(cx, lhs, rhs) }\n       }\n       ast::div. {\n-        if is_float { ret rslt(cx, FDiv(cx, lhs, rhs)); }\n-        if ty::type_is_signed(bcx_tcx(cx), intype) {\n-            ret rslt(cx, SDiv(cx, lhs, rhs));\n-        } else { ret rslt(cx, UDiv(cx, lhs, rhs)); }\n+        if is_float { FDiv(cx, lhs, rhs) }\n+        else if ty::type_is_signed(bcx_tcx(cx), intype) {\n+            SDiv(cx, lhs, rhs)\n+        } else { UDiv(cx, lhs, rhs) }\n       }\n       ast::rem. {\n-        if is_float { ret rslt(cx, FRem(cx, lhs, rhs)); }\n-        if ty::type_is_signed(bcx_tcx(cx), intype) {\n-            ret rslt(cx, SRem(cx, lhs, rhs));\n-        } else { ret rslt(cx, URem(cx, lhs, rhs)); }\n+        if is_float { FRem(cx, lhs, rhs) }\n+        else if ty::type_is_signed(bcx_tcx(cx), intype) {\n+            SRem(cx, lhs, rhs)\n+        } else { URem(cx, lhs, rhs) }\n+      }\n+      ast::bitor. { Or(cx, lhs, rhs) }\n+      ast::bitand. { And(cx, lhs, rhs) }\n+      ast::bitxor. { Xor(cx, lhs, rhs) }\n+      ast::lsl. { Shl(cx, lhs, rhs) }\n+      ast::lsr. { LShr(cx, lhs, rhs) }\n+      ast::asr. { AShr(cx, lhs, rhs) }\n+      _ {\n+        let cmpr = trans_compare(cx, op, lhs, lhs_t, rhs, rhs_t);\n+        cx = cmpr.bcx;\n+        cmpr.val\n       }\n-      ast::bitor. { ret rslt(cx, Or(cx, lhs, rhs)); }\n-      ast::bitand. { ret rslt(cx, And(cx, lhs, rhs)); }\n-      ast::bitxor. { ret rslt(cx, Xor(cx, lhs, rhs)); }\n-      ast::lsl. { ret rslt(cx, Shl(cx, lhs, rhs)); }\n-      ast::lsr. { ret rslt(cx, LShr(cx, lhs, rhs)); }\n-      ast::asr. { ret rslt(cx, AShr(cx, lhs, rhs)); }\n-      _ { ret trans_compare(cx, op, lhs, lhs_t, rhs, rhs_t); }\n-    }\n+    };\n+    ret store_in_dest(cx, val, dest);\n }\n \n fn trans_assign_op(bcx: @block_ctxt, op: ast::binop, dst: @ast::expr,\n@@ -2334,11 +2334,8 @@ fn trans_assign_op(bcx: @block_ctxt, op: ast::binop, dst: @ast::expr,\n         }\n     }\n     let lhs_val = load_if_immediate(rhs_res.bcx, lhs_res.val, t);\n-    let v = trans_eager_binop(rhs_res.bcx, op, lhs_val, t, rhs_res.val, t);\n-    // FIXME: calculate copy init-ness in typestate.\n-    // This is always a temporary, so can always be safely moved\n-    ret move_val(v.bcx, DROP_EXISTING, lhs_res.val,\n-                 lval_val(v.bcx, v.val), t);\n+    ret trans_eager_binop(rhs_res.bcx, op, lhs_val, t, rhs_res.val, t,\n+                          overwrite(lhs_res.val, t));\n }\n \n fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n@@ -2390,84 +2387,55 @@ fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n     ret {bcx: cx, val: v1, ty: t1};\n }\n \n-fn trans_binary(cx: @block_ctxt, op: ast::binop, a: @ast::expr, b: @ast::expr)\n-   -> result {\n+fn trans_lazy_binop(bcx: @block_ctxt, op: ast::binop, a: @ast::expr,\n+                    b: @ast::expr, dest: dest) -> @block_ctxt {\n+    let is_and = alt op { ast::and. { true } ast::or. { false } };\n+    let lhs_res = trans_expr(bcx, a);\n+    if lhs_res.bcx.unreachable { ret lhs_res.bcx; }\n+    let rhs_cx = new_scope_block_ctxt(lhs_res.bcx, \"rhs\");\n+    let rhs_res = trans_expr(rhs_cx, b);\n+\n+    let lhs_past_cx = new_scope_block_ctxt(lhs_res.bcx, \"lhs\");\n+    // The following line ensures that any cleanups for rhs\n+    // are done within the block for rhs. This is necessary\n+    // because and/or are lazy. So the rhs may never execute,\n+    // and the cleanups can't be pushed into later code.\n+    let rhs_bcx = trans_block_cleanups(rhs_res.bcx, rhs_cx);\n+    if is_and {\n+        CondBr(lhs_res.bcx, lhs_res.val, rhs_cx.llbb, lhs_past_cx.llbb);\n+    } else {\n+        CondBr(lhs_res.bcx, lhs_res.val, lhs_past_cx.llbb, rhs_cx.llbb);\n+    }\n \n+    let join_cx = new_sub_block_ctxt(bcx, \"join\");\n+    Br(lhs_past_cx, join_cx.llbb);\n+    if rhs_bcx.unreachable {\n+        ret store_in_dest(join_cx, C_bool(!is_and), dest);\n+    }\n+    Br(rhs_bcx, join_cx.llbb);\n+    let phi = Phi(join_cx, T_bool(), [C_bool(!is_and), rhs_res.val],\n+                  [lhs_past_cx.llbb, rhs_bcx.llbb]);\n+    ret store_in_dest(join_cx, phi, dest);\n+}\n+\n+fn trans_binary(cx: @block_ctxt, op: ast::binop, a: @ast::expr, b: @ast::expr,\n+                dest: dest) -> @block_ctxt {\n     // First couple cases are lazy:\n     alt op {\n-      ast::and. {\n-        // Lazy-eval and\n-        let lhs_res = trans_expr(cx, a);\n-        let rhs_cx = new_scope_block_ctxt(lhs_res.bcx, \"rhs\");\n-        let rhs_res = trans_expr(rhs_cx, b);\n-\n-        let lhs_false_cx = new_scope_block_ctxt(lhs_res.bcx, \"lhs false\");\n-        let lhs_false_res = rslt(lhs_false_cx, C_bool(false));\n-\n-        // The following line ensures that any cleanups for rhs\n-        // are done within the block for rhs. This is necessary\n-        // because and/or are lazy. So the rhs may never execute,\n-        // and the cleanups can't be pushed into later code.\n-        let rhs_bcx = trans_block_cleanups(rhs_res.bcx, rhs_cx);\n-        CondBr(lhs_res.bcx, lhs_res.val, rhs_cx.llbb, lhs_false_cx.llbb);\n-        ret join_results(cx, T_bool(),\n-                         [lhs_false_res, {bcx: rhs_bcx, val: rhs_res.val}]);\n-      }\n-      ast::or. {\n-        // Lazy-eval or\n-        let lhs_res = trans_expr(cx, a);\n-        let rhs_cx = new_scope_block_ctxt(lhs_res.bcx, \"rhs\");\n-        let rhs_res = trans_expr(rhs_cx, b);\n-        let lhs_true_cx = new_scope_block_ctxt(lhs_res.bcx, \"lhs true\");\n-        let lhs_true_res = rslt(lhs_true_cx, C_bool(true));\n-\n-        // see the and case for an explanation\n-        let rhs_bcx = trans_block_cleanups(rhs_res.bcx, rhs_cx);\n-        CondBr(lhs_res.bcx, lhs_res.val, lhs_true_cx.llbb, rhs_cx.llbb);\n-        ret join_results(cx, T_bool(),\n-                         [lhs_true_res, {bcx: rhs_bcx, val: rhs_res.val}]);\n+      ast::and. | ast::or. {\n+        ret trans_lazy_binop(cx, op, a, b, dest);\n       }\n       _ {\n         // Remaining cases are eager:\n         let lhs = trans_expr(cx, a);\n         let rhs = trans_expr(lhs.bcx, b);\n-\n         ret trans_eager_binop(rhs.bcx, op, lhs.val,\n                               ty::expr_ty(bcx_tcx(cx), a), rhs.val,\n-                              ty::expr_ty(bcx_tcx(cx), b));\n+                              ty::expr_ty(bcx_tcx(cx), b), dest);\n       }\n     }\n }\n \n-fn join_results(parent_cx: @block_ctxt, t: TypeRef, ins: [result]) -> result {\n-    let live: [result] = [];\n-    let vals: [ValueRef] = [];\n-    let bbs: [BasicBlockRef] = [];\n-    for r: result in ins {\n-        if !r.bcx.unreachable {\n-            live += [r];\n-            vals += [r.val];\n-            bbs += [r.bcx.llbb];\n-        }\n-    }\n-    alt std::vec::len::<result>(live) {\n-      0u {\n-        // No incoming edges are live, so we're in dead-code-land.\n-        // Arbitrarily pick the first dead edge, since the caller\n-        // is just going to propagate it outward.\n-        assert (std::vec::len::<result>(ins) >= 1u);\n-        ret ins[0];\n-      }\n-      _ {/* fall through */ }\n-    }\n-    // We have >1 incoming edges. Make a join block and br+phi them into it.\n-\n-    let join_cx = new_sub_block_ctxt(parent_cx, \"join\");\n-    for r: result in live { Br(r.bcx, join_cx.llbb); }\n-    let phi = Phi(join_cx, t, vals, bbs);\n-    ret rslt(join_cx, phi);\n-}\n-\n // FIXME remove once all uses have been converted to join_returns\n fn join_branches(parent_cx: @block_ctxt, ins: [result]) -> @block_ctxt {\n     let out = new_sub_block_ctxt(parent_cx, \"join\");\n@@ -2483,6 +2451,7 @@ tag dest {\n     by_val(@mutable ValueRef);\n     by_ref(@mutable ValueRef);\n     save_in(ValueRef);\n+    overwrite(ValueRef, ty::t);\n     ignore;\n }\n \n@@ -2529,6 +2498,20 @@ fn join_returns(parent_cx: @block_ctxt, in_cxs: [@block_ctxt],\n     ret out;\n }\n \n+// Used to put an immediate value in a dest\n+fn store_in_dest(bcx: @block_ctxt, val: ValueRef, dest: dest) -> @block_ctxt {\n+    alt dest {\n+      ignore. {}\n+      by_val(cell) { *cell = val; }\n+      save_in(addr) { Store(bcx, val, addr); }\n+      overwrite(addr, tp) {\n+        bcx = drop_ty(bcx, addr, tp);\n+        Store(bcx, val, addr);\n+      }\n+    }\n+    ret bcx;\n+}\n+\n // Wrapper through which legacy non-DPS code can use DPS functions\n fn dps_to_result(bcx: @block_ctxt,\n                  work: block(@block_ctxt, dest) -> @block_ctxt,\n@@ -4135,7 +4118,6 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n fn trans_expr(cx: @block_ctxt, e: @ast::expr) -> result {\n     // Fixme Fill in cx.sp\n     alt e.node {\n-      ast::expr_binary(op, x, y) { ret trans_binary(cx, op, x, y); }\n       ast::expr_fn(f) {\n         let ccx = bcx_ccx(cx);\n         let fty = node_id_type(ccx, e.id);\n@@ -4267,6 +4249,7 @@ fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n       ast::expr_tup(args) { ret trans_tup(bcx, args, e.id, dest); }\n       ast::expr_lit(lit) { ret trans_lit(bcx, *lit, dest); }\n       ast::expr_vec(args, _) { ret tvec::trans_vec(bcx, args, e.id, dest); }\n+      ast::expr_binary(op, x, y) { ret trans_binary(bcx, op, x, y, dest); }\n \n       ast::expr_break. {\n         assert dest == ignore;\n@@ -4399,6 +4382,9 @@ fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n             *cell = val;\n           }\n           save_in(loc) { bcx = move_val_if_temp(bcx, INIT, loc, lv, ty); }\n+          overwrite(loc, _) {\n+            bcx = move_val_if_temp(bcx, DROP_EXISTING, loc, lv, ty);\n+          }\n           ignore. {}\n         }\n         ret bcx;"}, {"sha": "87adda1f18fd62a4d39081c4cd8fa4a7d52bb34a", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8282f7fe805087f26ed60a6a5cba0abe50637d39/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8282f7fe805087f26ed60a6a5cba0abe50637d39/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=8282f7fe805087f26ed60a6a5cba0abe50637d39", "patch": "@@ -36,9 +36,10 @@ fn trans_opt(bcx: @block_ctxt, o: opt) -> result {\n       lit(l) {\n         alt l.node {\n           ast::lit_str(s) {\n-            let {bcx, val: dst} =\n-                trans::alloc_ty(bcx, ty::mk_str(bcx_tcx(bcx)));\n+            let strty = ty::mk_str(bcx_tcx(bcx));\n+            let {bcx, val: dst} = trans::alloc_ty(bcx, strty);\n             bcx = trans_vec::trans_str(bcx, s, trans::save_in(dst));\n+            add_clean_temp(bcx, dst, strty);\n             ret rslt(bcx, dst);\n           }\n           _ {"}, {"sha": "aa5f9fc7ea2794400b897f5733d154b06f87fba1", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8282f7fe805087f26ed60a6a5cba0abe50637d39/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8282f7fe805087f26ed60a6a5cba0abe50637d39/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=8282f7fe805087f26ed60a6a5cba0abe50637d39", "patch": "@@ -100,9 +100,14 @@ fn make_drop_glue(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t) ->\n     ret next_cx;\n }\n \n-// FIXME handle dest == ignore\n fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n              dest: dest) -> @block_ctxt {\n+    if dest == trans::ignore {\n+        for arg in args {\n+            bcx = trans::trans_expr_dps(bcx, arg, trans::ignore);\n+        }\n+        ret bcx;\n+    }\n     let vec_ty = node_id_type(bcx_ccx(bcx), id);\n     let {bcx: bcx,\n          val: vptrptr,\n@@ -113,17 +118,20 @@ fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n \n     // Store the individual elements.\n     let dataptr = get_dataptr(bcx, vptrptr, llunitty);\n-    let i = 0u;\n+    add_clean_temp_mem(bcx, vptrptr, vec_ty);\n+    let i = 0u, temp_cleanups = [vptrptr];\n     for e in args {\n         let lv = trans_lval(bcx, e);\n         bcx = lv.bcx;\n-        let lleltptr =\n-            if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n-                InBoundsGEP(bcx, dataptr, [Mul(bcx, C_uint(i), llunitsz)])\n-            } else { InBoundsGEP(bcx, dataptr, [C_uint(i)]) };\n+        let lleltptr = if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n+            InBoundsGEP(bcx, dataptr, [Mul(bcx, C_uint(i), llunitsz)])\n+        } else { InBoundsGEP(bcx, dataptr, [C_uint(i)]) };\n         bcx = move_val_if_temp(bcx, INIT, lleltptr, lv, unit_ty);\n+        add_clean_temp_mem(bcx, lleltptr, unit_ty);\n+        temp_cleanups += [lleltptr];\n         i += 1u;\n     }\n+    for clean in temp_cleanups { revoke_clean(bcx, clean); }\n     ret bcx;\n }\n fn trans_str(bcx: @block_ctxt, s: str, dest: dest) -> @block_ctxt {\n@@ -213,12 +221,11 @@ fn trans_append_literal(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n }\n \n fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n-             rhsptr: ValueRef) -> result {\n-    let strings =\n-        alt ty::struct(bcx_tcx(bcx), vec_ty) {\n-          ty::ty_str. { true }\n-          ty::ty_vec(_) { false }\n-        };\n+             rhsptr: ValueRef, dest: dest) -> @block_ctxt {\n+    let strings = alt ty::struct(bcx_tcx(bcx), vec_ty) {\n+      ty::ty_str. { true }\n+      ty::ty_vec(_) { false }\n+    };\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let llunitty = type_of_or_i8(bcx, unit_ty);\n     let {bcx: bcx, val: llunitsz} = size_of(bcx, unit_ty);\n@@ -229,9 +236,8 @@ fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n     let new_fill = Add(bcx, lhs_fill, rhs_fill);\n     let {bcx: bcx, val: new_vec_ptr} = alloc_raw(bcx, new_fill, new_fill);\n     new_vec_ptr = PointerCast(bcx, new_vec_ptr, T_ptr(T_vec(llunitty)));\n-    let {bcx: bcx, val: new_vec_ptr_ptr} = alloc_ty(bcx, vec_ty);\n+    let new_vec_ptr_ptr = alt dest { trans::save_in(a) { a } };\n     Store(bcx, new_vec_ptr, new_vec_ptr_ptr);\n-    add_clean_temp(bcx, new_vec_ptr_ptr, vec_ty);\n \n     let write_ptr_ptr =\n         do_spill_noroot(bcx, get_dataptr(bcx, new_vec_ptr_ptr, llunitty));\n@@ -252,8 +258,7 @@ fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n              }(_, _, _, write_ptr_ptr, unit_ty, llunitsz);\n \n     let bcx = iter_vec_raw(bcx, lhsptr, vec_ty, lhs_fill, copy_fn);\n-    let bcx = iter_vec_raw(bcx, rhsptr, vec_ty, rhs_fill, copy_fn);\n-    ret rslt(bcx, new_vec_ptr_ptr);\n+    ret iter_vec_raw(bcx, rhsptr, vec_ty, rhs_fill, copy_fn);\n }\n \n type val_and_ty_fn = fn(@block_ctxt, ValueRef, ty::t) -> result;"}]}