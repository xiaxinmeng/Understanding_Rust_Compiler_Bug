{"sha": "55bb1c08d3baaae57777453f7c3b054f74059b88", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1YmIxYzA4ZDNiYWFhZTU3Nzc3NDUzZjdjM2IwNTRmNzQwNTliODg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-07-10T16:30:57Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2017-07-28T13:46:23Z"}, "message": "Add documentation for generators", "tree": {"sha": "95a5b594c008111ba3f48643594c21510a1fd365", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95a5b594c008111ba3f48643594c21510a1fd365"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55bb1c08d3baaae57777453f7c3b054f74059b88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55bb1c08d3baaae57777453f7c3b054f74059b88", "html_url": "https://github.com/rust-lang/rust/commit/55bb1c08d3baaae57777453f7c3b054f74059b88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55bb1c08d3baaae57777453f7c3b054f74059b88/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc9b4deeb525235e9ac0d20d0bb00c88641540e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc9b4deeb525235e9ac0d20d0bb00c88641540e5", "html_url": "https://github.com/rust-lang/rust/commit/bc9b4deeb525235e9ac0d20d0bb00c88641540e5"}], "stats": {"total": 324, "additions": 320, "deletions": 4}, "files": [{"sha": "8d9d9846a2332a3a6bf947a468cca65100cdadf9", "filename": "src/doc/unstable-book/src/language-features/generators.md", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/55bb1c08d3baaae57777453f7c3b054f74059b88/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "raw_url": "https://github.com/rust-lang/rust/raw/55bb1c08d3baaae57777453f7c3b054f74059b88/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md?ref=55bb1c08d3baaae57777453f7c3b054f74059b88", "patch": "@@ -0,0 +1,232 @@\n+# `generators`\n+\n+The tracking issue for this feature is: [#43122]\n+\n+[#34511]: https://github.com/rust-lang/rust/issues/43122\n+\n+------------------------\n+\n+The `generators` feature gate in Rust allows you to define generator or\n+coroutine literals. A generator is a \"resumable function\" that syntactically\n+resembles a closure but compiles to much different semantics in the compiler\n+itself.\n+\n+Generators are an extra-unstable feature in the compiler right now. Added in\n+[RFC 2033] they're mostly intended right now as a information/constraint\n+gathering phase. The intent is that experimentation can happen on the nightly\n+compiler before actual stabilization. A further RFC will be required to\n+stabilize generators/coroutines and will likely contain at least a few small\n+tweaks to the overall design.\n+\n+[RFC 2033]: https://github.com/rust-lang/rfcs/pull/2033\n+\n+A syntactical example of a generator is:\n+\n+```rust\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::{Generator, State};\n+\n+fn main() {\n+    let mut generator = || {\n+        yield 1;\n+        return \"foo\"\n+    };\n+\n+    match generator.resume(()) {\n+        State::Yielded(1) => {}\n+        _ => panic!(\"unexpected return from resume\"),\n+    }\n+    match generator.resume(()) {\n+        State::Complete(\"foo\") => {}\n+        _ => panic!(\"unexpected return from resume\"),\n+    }\n+}\n+```\n+\n+Generators are closure-like literals which can contain a `yield` statement. The\n+`yield` statement takes an optional expression of a value to yield out of the\n+generator. All generator literals implement the `Generator` trait in the\n+`std::ops` module. The `Generator` trait has one main method, `resume`, which\n+resumes execution of the closure at the previous suspension point.\n+\n+An example of the control flow of generators is that the following example\n+prints all numbers in order:\n+\n+```rust\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::Generator;\n+\n+fn main() {\n+    let mut generator = || {\n+        println!(\"2\");\n+        yield;\n+        println!(\"4\");\n+    };\n+\n+    println!(\"1\");\n+    drop(generator.resume(()));\n+    println!(\"3\");\n+    drop(generator.resume(()));\n+    println!(\"5\");\n+}\n+```\n+\n+At this time the main intended use case of generators is an implementation\n+primitive for async/await syntax, but generators will likely be extended to\n+ergonomic implementations of iterators and other primitives in the future.\n+Feedback on the design and usage is always appreciated!\n+\n+### The `Generator` trait\n+\n+The `Generator` trait in `std::ops` currently looks like:\n+\n+```\n+pub trait Generator<Arg = ()> {\n+    type Yield;\n+    type Return;\n+    fn resume(&mut self, arg: Arg) -> State<Self::Yield, Self::Return>;\n+}\n+```\n+\n+The `Generator::Yield` type is the type of values that can be yielded with the\n+`yield` statement. The `Generator::Return` type is the returned type of the\n+generator. This is typically the last expression in a generator's definition or\n+any value passed to `return` in a generator. The `resume` function is the entry\n+point for executing the `Generator` itself.\n+\n+The return value of `resume`, `State`, looks like:\n+\n+```\n+pub enum State<Y, R> {\n+    Yielded(Y),\n+    Complete(R),\n+}\n+```\n+\n+The `Yielded` variant indicates that the generator can later be resumed. This\n+corresponds to a `yield` point in a generator. The `Complete` variant indicates\n+that the generator is complete and cannot be resumed again. Calling `resume`\n+after a generator has returned `Complete` will likely result in a panic of the\n+program.\n+\n+### Closure-like semantics\n+\n+The closure-like syntax for generators alludes to the fact that they also have\n+closure-like semantics. Namely:\n+\n+* When created, a generator executes no code. A closure literal does not\n+  actually execute any of the closure's code on construction, and similarly a\n+  generator literal does not execute any code inside the generator when\n+  constructed.\n+\n+* Generators can capture outer variables by reference or by move, and this can\n+  be tweaked with the `move` keyword at the beginning of the closure. Like\n+  closures all generators will have an implicit environment which is inferred by\n+  the compiler. Outer variables can be moved into a generator for use as the\n+  generator progresses.\n+\n+* Generator literals produce a value with a unique type which implements the\n+  `std::ops::Generator` trait. This allows actual execution of the genrator\n+  through the `Generator::resume` method as well as also naming it in return\n+  types and such.\n+\n+* Traits like `Send` and `Sync` are automatically implemented for a `Generator`\n+  depending on the captured variables of the environment. Note, though, that\n+  generators, like closures, do not implement traits like `Copy` or `Clone`\n+  automatically.\n+\n+* Whenever a generator is dropped it will drop all captured environment\n+  variables.\n+\n+### Generators as state machines\n+\n+In the compiler generators are currently compiled as state machines. Each\n+`yield` expression will correspond to a different state that stores all live\n+variables over that suspension point. Resumption of a generator will dispatch on\n+the current state and then execute internally until a `yield` is reached, at\n+which point all state is saved off in the generator and a value is returned.\n+\n+Let's take a look at an example to see what's going on here:\n+\n+```rust\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::Generator;\n+\n+fn main() {\n+    let ret = \"foo\";\n+    let mut generator = move || {\n+        yield 1;\n+        return ret\n+    };\n+\n+    drop(generator.resume(()))\n+    drop(generator.resume(()))\n+}\n+```\n+\n+This generator literal will compile down to something similar to:\n+\n+```rust\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::{Generator, State};\n+\n+fn main() {\n+    let ret = \"foo\";\n+    let mut generator = {\n+        enum __Generator {\n+            Start(&'static str),\n+            Yield1(&'static str),\n+            Done,\n+        }\n+\n+        impl Generator for __Generator {\n+            type Yield = i32;\n+            type Return = &'static str;\n+\n+            fn resume(&mut self, arg: ()) -> State<i32, &'static str> {\n+                use std::mem;\n+                match mem::replace(self, __Generator::Done) {\n+                    __Generator::Start(s) => {\n+                        *self = __Generator::Yield1(s);\n+                        State::Yielded(1)\n+                    }\n+\n+                    __Generator::Yield1(s) => {\n+                        *self = __Generator::Done;\n+                        State::Complete(s)\n+                    }\n+\n+                    __Generator::Done => {\n+                        panic!(\"generator resumed after completion\")\n+                    }\n+                }\n+            }\n+        }\n+\n+        __Generator::Start(ret) : impl Generator<Yield = i32, Return = &'static str>\n+    };\n+\n+    drop(generator.resume(()))\n+    drop(generator.resume(()))\n+}\n+```\n+\n+Notably here we can see that the compiler is generating a fresh type,\n+`__Generator` in this case. This type has a number of states (represented here\n+as an `enum`) corresponding to each of the conceptual states of the generator.\n+At the beginning we're closing over our outer variable `foo` and then that\n+variable is also live over the `yield` point, so it's stored in both states.\n+\n+When the generator starts it'll immediately yield 1, but it saves off its state\n+just before it does so indicating that it has reached the yield point. Upon\n+resuming again we'll execute the `return ret` which returns the `Complete`\n+state.\n+\n+Here we can also note that the `Done` state, if resumed, panics immediately as\n+it's invalid to resume a completed generator. It's also worth noting that this\n+is just a rough desugaring, not a normative specification for what the compiler\n+does."}, {"sha": "4d125573afce7b02d70d492e975cada1330ace85", "filename": "src/libcore/ops/generator.rs", "status": "modified", "additions": 88, "deletions": 4, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/55bb1c08d3baaae57777453f7c3b054f74059b88/src%2Flibcore%2Fops%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55bb1c08d3baaae57777453f7c3b054f74059b88/src%2Flibcore%2Fops%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fgenerator.rs?ref=55bb1c08d3baaae57777453f7c3b054f74059b88", "patch": "@@ -9,33 +9,117 @@\n // except according to those terms.\n \n /// The result of a generator resumption.\n+///\n+/// This enum is returned from the `Generator::resume` method and indicates the\n+/// possible return values of a generator. Currently this corresponds to either\n+/// a suspension point (`Yielded`) or a termination point (`Complete`).\n #[derive(Debug)]\n #[cfg_attr(not(stage0), lang = \"generator_state\")]\n-#[unstable(feature = \"generator_trait\", issue = \"0\")]\n+#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n pub enum State<Y, R> {\n     /// The generator suspended with a value.\n+    ///\n+    /// This state indicates that a generator has been suspended, and typically\n+    /// corresponds to a `yield` statement. The value provided in this variant\n+    /// corresponds to the expression passed to `yield` and allows generators to\n+    /// provide a value each time they yield.\n     Yielded(Y),\n \n     /// The generator completed with a return value.\n+    ///\n+    /// This state indicates that a generator has finished execution with the\n+    /// provided value. Once a generator has returned `Complete` it is\n+    /// considered a programmer error to call `resume` again.\n     Complete(R),\n }\n \n /// The trait implemented by builtin generator types.\n+///\n+/// Generators, also commonly referred to as coroutines, are currently an\n+/// experimental language feature in Rust. Added in [RFC 2033] generators are\n+/// currently intended to primarily provide a building block for async/await\n+/// syntax but will likely extend to also providing an ergonomic definition for\n+/// iterators and other primitives.\n+///\n+/// The syntax and semantics for generators is unstable and will require a\n+/// further RFC for stabilization. At this time, though, the syntax is\n+/// closure-like:\n+///\n+/// ```rust\n+/// #![feature(generators, generator_trait)]\n+///\n+/// use std::ops::{Generator, State};\n+///\n+/// fn main() {\n+///     let mut generator = || {\n+///         yield 1;\n+///         return \"foo\"\n+///     };\n+///\n+///     match generator.resume(()) {\n+///         State::Yielded(1) => {}\n+///         _ => panic!(\"unexpected return from resume\"),\n+///     }\n+///     match generator.resume(()) {\n+///         State::Complete(\"foo\") => {}\n+///         _ => panic!(\"unexpected return from resume\"),\n+///     }\n+/// }\n+/// ```\n+///\n+/// More documentation of generators can be found in the unstable book.\n+///\n+/// [RFC 2033]: https://github.com/rust-lang/rfcs/pull/2033\n #[cfg_attr(not(stage0), lang = \"generator\")]\n-#[unstable(feature = \"generator_trait\", issue = \"0\")]\n+#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n #[fundamental]\n pub trait Generator<Arg = ()> {\n     /// The type of value this generator yields.\n+    ///\n+    /// This associated type corresponds to the `yield` expression and the\n+    /// values which are allowed to be returned each time a generator yields.\n+    /// For example an iterator-as-a-generator would likely have this type as\n+    /// `T`, the type being iterated over.\n     type Yield;\n \n     /// The type of value this generator returns.\n+    ///\n+    /// This corresponds to the type returned from a generator either with a\n+    /// `return` statement or implicitly as the last expression of a generator\n+    /// literal. For example futures would use this as `Result<T, E>` as it\n+    /// represents a completed future.\n     type Return;\n \n-    /// This resumes the execution of the generator.\n+    /// Resumes the execution of this generator.\n+    ///\n+    /// This function will resume execution of the generator or start execution\n+    /// if it hasn't already. This call will return back into the generator's\n+    /// last suspension point, resuming execution from the latest `yield`. The\n+    /// generator will continue executing until it either yields or returns, at\n+    /// which point this function will return.\n+    ///\n+    /// # Return value\n+    ///\n+    /// The `State` enum returned from this function indicates what state the\n+    /// generator is in upon returning. If the `Yielded` variant is returned\n+    /// then the generator has reached a suspension point and a value has been\n+    /// yielded out. Generators in this state are available for resumption at a\n+    /// later point.\n+    ///\n+    /// If `Complete` is returned then the generator has completely finished\n+    /// with the value provided. It is invalid for the generator to be resumed\n+    /// again.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function may panic if it is called after the `Complete` variant has\n+    /// been returned previously. While generator literals in the language are\n+    /// guaranteed to panic on resuming after `Complete`, this is not guaranteed\n+    /// for all implementations of the `Generator` trait.\n     fn resume(&mut self, arg: Arg) -> State<Self::Yield, Self::Return>;\n }\n \n-#[unstable(feature = \"generator_trait\", issue = \"0\")]\n+#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n impl<'a, T, U> Generator<U> for &'a mut T\n     where T: Generator<U> + ?Sized\n {"}]}