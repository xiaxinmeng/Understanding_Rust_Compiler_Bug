{"sha": "1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyNDZkNDA2N2ZkYzAzNGQwNjRkZmI3OGY4OGMyYzNjMDc5YzNmNGY=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2015-01-09T03:10:57Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-03-03T11:10:19Z"}, "message": "Add `core::num::wrapping` and fix overflow errors.\n\nMany of the core rust libraries have places that rely on integer\nwrapping behaviour. These places have been altered to use the wrapping_*\nmethods:\n\n * core::hash::sip - A number of macros\n * core::str - The `maximal_suffix` method in `TwoWaySearcher`\n * rustc::util::nodemap - Implementation of FnvHash\n * rustc_back::sha2 - A number of macros and other places\n * rand::isaac - Isaac64Rng, changed to use the Wrapping helper type\n\nSome places had \"benign\" underflow. This is when underflow or overflow\noccurs, but the unspecified value is not used due to other conditions.\n\n * collections::bit::Bitv - underflow when `self.nbits` is zero.\n * collections::hash::{map,table} - Underflow when searching an empty\n   table. Did cause undefined behaviour in this case due to an\n   out-of-bounds ptr::offset based on the underflowed index. However the\n   resulting pointers would never be read from.\n * syntax::ext::deriving::encodable - Underflow when calculating the\n   index of the last field in a variant with no fields.\n\nThese cases were altered to avoid the underflow, often by moving the\nunderflowing operation to a place where underflow could not happen.\n\nThere was one case that relied on the fact that unsigned arithmetic and\ntwo's complement arithmetic are identical with wrapping semantics. This\nwas changed to use the wrapping_* methods.\n\nFinally, the calculation of variant discriminants could overflow if the\npreceeding discriminant was `U64_MAX`. The logic in `rustc::middle::ty`\nfor this was altered to avoid the overflow completely, while the\nremaining places were changed to use wrapping methods. This is because\n`rustc::middle::ty::enum_variants` now throws an error when the\ncalculated discriminant value overflows a `u64`.\n\nThis behaviour can be triggered by the following code:\n\n```\nenum Foo {\n  A = U64_MAX,\n  B\n}\n```\n\nThis commit also implements the remaining integer operators for\nWrapped<T>.", "tree": {"sha": "a126ed9a0c48d2b6a486f311aa6d0924bbbb69aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a126ed9a0c48d2b6a486f311aa6d0924bbbb69aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "html_url": "https://github.com/rust-lang/rust/commit/1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdfff9db35d037c51dfd5c2bac2174f651294adb", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdfff9db35d037c51dfd5c2bac2174f651294adb", "html_url": "https://github.com/rust-lang/rust/commit/cdfff9db35d037c51dfd5c2bac2174f651294adb"}], "stats": {"total": 381, "additions": 286, "deletions": 95}, "files": [{"sha": "05bf5f8e42cef4f6296b23afc187eeba5482b2ae", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "patch": "@@ -818,19 +818,19 @@ impl BitVec {\n         let full_value = if value { !0 } else { 0 };\n \n         // Correct the old tail word, setting or clearing formerly unused bits\n-        let old_last_word = blocks_for_bits(self.nbits) - 1;\n+        let num_cur_blocks = blocks_for_bits(self.nbits);\n         if self.nbits % u32::BITS as usize > 0 {\n             let mask = mask_for_bits(self.nbits);\n             if value {\n-                self.storage[old_last_word] |= !mask;\n+                self.storage[num_cur_blocks - 1] |= !mask;\n             } else {\n                 // Extra bits are already zero by invariant.\n             }\n         }\n \n         // Fill in words after the old tail word\n         let stop_idx = cmp::min(self.storage.len(), new_nblocks);\n-        for idx in old_last_word + 1..stop_idx {\n+        for idx in num_cur_blocks..stop_idx {\n             self.storage[idx] = full_value;\n         }\n "}, {"sha": "df0008c500b8e86d94597c81bfe47d0f2d2956dc", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "patch": "@@ -14,7 +14,7 @@\n \n use prelude::*;\n use default::Default;\n-\n+use num::wrapping::WrappingOps;\n use super::Hasher;\n \n /// An implementation of SipHash 2-4.\n@@ -71,17 +71,17 @@ macro_rules! u8to64_le {\n \n macro_rules! rotl {\n     ($x:expr, $b:expr) =>\n-    (($x << $b) | ($x >> (64 - $b)))\n+    (($x << $b) | ($x >> (64.wrapping_sub($b))))\n }\n \n macro_rules! compress {\n     ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>\n     ({\n-        $v0 += $v1; $v1 = rotl!($v1, 13); $v1 ^= $v0;\n+        $v0 = $v0.wrapping_add($v1); $v1 = rotl!($v1, 13); $v1 ^= $v0;\n         $v0 = rotl!($v0, 32);\n-        $v2 += $v3; $v3 = rotl!($v3, 16); $v3 ^= $v2;\n-        $v0 += $v3; $v3 = rotl!($v3, 21); $v3 ^= $v0;\n-        $v2 += $v1; $v1 = rotl!($v1, 17); $v1 ^= $v2;\n+        $v2 = $v2.wrapping_add($v3); $v3 = rotl!($v3, 16); $v3 ^= $v2;\n+        $v0 = $v0.wrapping_add($v3); $v3 = rotl!($v3, 21); $v3 ^= $v0;\n+        $v2 = $v2.wrapping_add($v1); $v1 = rotl!($v1, 17); $v1 ^= $v2;\n         $v2 = rotl!($v2, 32);\n     })\n }"}, {"sha": "3ed059520b12f074aa40e01f524dc2d03cc18a3a", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "patch": "@@ -30,6 +30,9 @@ use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n use str::{FromStr, StrExt};\n \n+#[unstable(feature = \"core\", reason = \"may be removed or relocated\")]\n+pub mod wrapping;\n+\n /// A built-in signed or unsigned integer.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Int"}, {"sha": "30478a8f09f30fc1e66b764b56af3d1338c3dbf0", "filename": "src/libcore/num/wrapping.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "patch": "@@ -0,0 +1,153 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![allow(missing_docs)]\n+\n+use ops::*;\n+\n+#[cfg(not(stage0))]\n+use intrinsics::{overflowing_add, overflowing_sub, overflowing_mul};\n+\n+pub trait WrappingOps {\n+    fn wrapping_add(self, rhs: Self) -> Self;\n+    fn wrapping_sub(self, rhs: Self) -> Self;\n+    fn wrapping_mul(self, rhs: Self) -> Self;\n+}\n+\n+#[cfg(not(stage0))]\n+macro_rules! wrapping_impl {\n+    ($($t:ty)*) => ($(\n+        impl WrappingOps for $t {\n+            #[inline(always)]\n+            fn wrapping_add(self, rhs: $t) -> $t {\n+                unsafe {\n+                    overflowing_add(self, rhs)\n+                }\n+            }\n+            #[inline(always)]\n+            fn wrapping_sub(self, rhs: $t) -> $t {\n+                unsafe {\n+                    overflowing_sub(self, rhs)\n+                }\n+            }\n+            #[inline(always)]\n+            fn wrapping_mul(self, rhs: $t) -> $t {\n+                unsafe {\n+                    overflowing_mul(self, rhs)\n+                }\n+            }\n+        }\n+    )*)\n+}\n+\n+#[cfg(stage0)]\n+macro_rules! wrapping_impl {\n+    ($($t:ty)*) => ($(\n+        impl WrappingOps for $t {\n+            #[inline(always)]\n+            fn wrapping_add(self, rhs: $t) -> $t {\n+                self + rhs\n+            }\n+            #[inline(always)]\n+            fn wrapping_sub(self, rhs: $t) -> $t {\n+                self - rhs\n+            }\n+            #[inline(always)]\n+            fn wrapping_mul(self, rhs: $t) -> $t {\n+                self * rhs\n+            }\n+        }\n+    )*)\n+}\n+\n+wrapping_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n+\n+#[unstable(feature = \"core\", reason = \"may be removed, renamed, or relocated\")]\n+#[derive(PartialEq,Eq,PartialOrd,Ord,Clone,Copy)]\n+pub struct Wrapping<T>(pub T);\n+\n+impl<T:WrappingOps> Add for Wrapping<T> {\n+    type Output = Wrapping<T>;\n+\n+    #[inline(always)]\n+    fn add(self, other: Wrapping<T>) -> Wrapping<T> {\n+        Wrapping(self.0.wrapping_add(other.0))\n+    }\n+}\n+\n+impl<T:WrappingOps> Sub for Wrapping<T> {\n+    type Output = Wrapping<T>;\n+\n+    #[inline(always)]\n+    fn sub(self, other: Wrapping<T>) -> Wrapping<T> {\n+        Wrapping(self.0.wrapping_sub(other.0))\n+    }\n+}\n+\n+impl<T:WrappingOps> Mul for Wrapping<T> {\n+    type Output = Wrapping<T>;\n+\n+    #[inline(always)]\n+    fn mul(self, other: Wrapping<T>) -> Wrapping<T> {\n+        Wrapping(self.0.wrapping_mul(other.0))\n+    }\n+}\n+\n+impl<T:WrappingOps+Not<Output=T>> Not for Wrapping<T> {\n+    type Output = Wrapping<T>;\n+\n+    fn not(self) -> Wrapping<T> {\n+        Wrapping(!self.0)\n+    }\n+}\n+\n+impl<T:WrappingOps+BitXor<Output=T>> BitXor for Wrapping<T> {\n+    type Output = Wrapping<T>;\n+\n+    #[inline(always)]\n+    fn bitxor(self, other: Wrapping<T>) -> Wrapping<T> {\n+        Wrapping(self.0 ^ other.0)\n+    }\n+}\n+\n+impl<T:WrappingOps+BitOr<Output=T>> BitOr for Wrapping<T> {\n+    type Output = Wrapping<T>;\n+\n+    #[inline(always)]\n+    fn bitor(self, other: Wrapping<T>) -> Wrapping<T> {\n+        Wrapping(self.0 | other.0)\n+    }\n+}\n+\n+impl<T:WrappingOps+BitAnd<Output=T>> BitAnd for Wrapping<T> {\n+    type Output = Wrapping<T>;\n+\n+    #[inline(always)]\n+    fn bitand(self, other: Wrapping<T>) -> Wrapping<T> {\n+        Wrapping(self.0 & other.0)\n+    }\n+}\n+\n+impl<T:WrappingOps+Shl<uint,Output=T>> Shl<uint> for Wrapping<T> {\n+    type Output = Wrapping<T>;\n+\n+    #[inline(always)]\n+    fn shl(self, other: uint) -> Wrapping<T> {\n+        Wrapping(self.0 << other)\n+    }\n+}\n+\n+impl<T:WrappingOps+Shr<uint,Output=T>> Shr<uint> for Wrapping<T> {\n+    type Output = Wrapping<T>;\n+\n+    #[inline(always)]\n+    fn shr(self, other: uint) -> Wrapping<T> {\n+        Wrapping(self.0 >> other)\n+    }\n+}"}, {"sha": "a7a0690640921210bb6d7ae797320639e510727b", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "patch": "@@ -830,6 +830,7 @@ impl TwoWaySearcher {\n     #[inline]\n     #[allow(dead_code)]\n     fn maximal_suffix(arr: &[u8], reversed: bool) -> (usize, usize) {\n+        use num::wrapping::WrappingOps;\n         let mut left = -1; // Corresponds to i in the paper\n         let mut right = 0; // Corresponds to j in the paper\n         let mut offset = 1; // Corresponds to k in the paper\n@@ -839,17 +840,17 @@ impl TwoWaySearcher {\n             let a;\n             let b;\n             if reversed {\n-                a = arr[left + offset];\n+                a = arr[left.wrapping_add(offset)];\n                 b = arr[right + offset];\n             } else {\n                 a = arr[right + offset];\n-                b = arr[left + offset];\n+                b = arr[left.wrapping_add(offset)];\n             }\n             if a < b {\n                 // Suffix is smaller, period is entire prefix so far.\n                 right += offset;\n                 offset = 1;\n-                period = right - left;\n+                period = right.wrapping_sub(left);\n             } else if a == b {\n                 // Advance through repetition of the current period.\n                 if offset == period {\n@@ -866,7 +867,7 @@ impl TwoWaySearcher {\n                 period = 1;\n             }\n         }\n-        (left + 1, period)\n+        (left.wrapping_add(1), period)\n     }\n }\n "}, {"sha": "04c67b16a7c59a1533431dba06ab331c84a7900c", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "patch": "@@ -14,6 +14,7 @@\n \n use core::prelude::{PartialOrd};\n use core::num::Int;\n+use core::num::wrapping::WrappingOps;\n \n use Rng;\n use distributions::{Sample, IndependentSample};\n@@ -97,7 +98,7 @@ macro_rules! integer_impl {\n             // bijection.\n \n             fn construct_range(low: $ty, high: $ty) -> Range<$ty> {\n-                let range = high as $unsigned - low as $unsigned;\n+                let range = (high as $unsigned).wrapping_sub(low as $unsigned);\n                 let unsigned_max: $unsigned = Int::max_value();\n \n                 // this is the largest number that fits into $unsigned"}, {"sha": "63eb8417655ee14608e52d1536c2019dfec897bf", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "patch": "@@ -304,22 +304,22 @@ impl Isaac64Rng {\n     fn init(&mut self, use_rsl: bool) {\n         macro_rules! init {\n             ($var:ident) => (\n-                let mut $var = 0x9e3779b97f4a7c13;\n+                let mut $var = Wrapping(0x9e3779b97f4a7c13);\n             )\n         }\n         init!(a); init!(b); init!(c); init!(d);\n         init!(e); init!(f); init!(g); init!(h);\n \n         macro_rules! mix {\n             () => {{\n-                a-=e; f^=h>>9;  h+=a;\n-                b-=f; g^=a<<9;  a+=b;\n-                c-=g; h^=b>>23; b+=c;\n-                d-=h; a^=c<<15; c+=d;\n-                e-=a; b^=d>>14; d+=e;\n-                f-=b; c^=e<<20; e+=f;\n-                g-=c; d^=f>>17; f+=g;\n-                h-=d; e^=g<<14; g+=h;\n+                a=a-e; f=f^h>>9;  h=h+a;\n+                b=b-f; g=g^a<<9;  a=a+b;\n+                c=c-g; h=h^b>>23; b=b+c;\n+                d=d-h; a=a^c<<15; c=c+d;\n+                e=e-a; b=b^d>>14; d=d+e;\n+                f=f-b; c=c^e<<20; e=e+f;\n+                g=g-c; d=d^f>>17; f=f+g;\n+                h=h-d; e=e^g<<14; g=g+h;\n             }}\n         }\n \n@@ -331,15 +331,15 @@ impl Isaac64Rng {\n             macro_rules! memloop {\n                 ($arr:expr) => {{\n                     for i in (0..RAND_SIZE_64 / 8).map(|i| i * 8) {\n-                        a+=$arr[i  ]; b+=$arr[i+1];\n-                        c+=$arr[i+2]; d+=$arr[i+3];\n-                        e+=$arr[i+4]; f+=$arr[i+5];\n-                        g+=$arr[i+6]; h+=$arr[i+7];\n+                        a=a+Wrapping($arr[i  ]); b=b+Wrapping($arr[i+1]);\n+                        c=c+Wrapping($arr[i+2]); d=d+Wrapping($arr[i+3]);\n+                        e=e+Wrapping($arr[i+4]); f=f+Wrapping($arr[i+5]);\n+                        g=g+Wrapping($arr[i+6]); h=h+Wrapping($arr[i+7]);\n                         mix!();\n-                        self.mem[i  ]=a; self.mem[i+1]=b;\n-                        self.mem[i+2]=c; self.mem[i+3]=d;\n-                        self.mem[i+4]=e; self.mem[i+5]=f;\n-                        self.mem[i+6]=g; self.mem[i+7]=h;\n+                        self.mem[i  ]=a.0; self.mem[i+1]=b.0;\n+                        self.mem[i+2]=c.0; self.mem[i+3]=d.0;\n+                        self.mem[i+4]=e.0; self.mem[i+5]=f.0;\n+                        self.mem[i+6]=g.0; self.mem[i+7]=h.0;\n                     }\n                 }}\n             }\n@@ -349,10 +349,10 @@ impl Isaac64Rng {\n         } else {\n             for i in (0..RAND_SIZE_64 / 8).map(|i| i * 8) {\n                 mix!();\n-                self.mem[i  ]=a; self.mem[i+1]=b;\n-                self.mem[i+2]=c; self.mem[i+3]=d;\n-                self.mem[i+4]=e; self.mem[i+5]=f;\n-                self.mem[i+6]=g; self.mem[i+7]=h;\n+                self.mem[i  ]=a.0; self.mem[i+1]=b.0;\n+                self.mem[i+2]=c.0; self.mem[i+3]=d.0;\n+                self.mem[i+4]=e.0; self.mem[i+5]=f.0;\n+                self.mem[i+6]=g.0; self.mem[i+7]=h.0;\n             }\n         }\n \n@@ -363,8 +363,8 @@ impl Isaac64Rng {\n     fn isaac64(&mut self) {\n         self.c += 1;\n         // abbreviations\n-        let mut a = self.a;\n-        let mut b = self.b + self.c;\n+        let mut a = Wrapping(self.a);\n+        let mut b = Wrapping(self.b) + Wrapping(self.c);\n         const MIDPOINT: uint =  RAND_SIZE_64 / 2;\n         const MP_VEC: [(uint, uint); 2] = [(0,MIDPOINT), (MIDPOINT, 0)];\n         macro_rules! ind {\n@@ -383,13 +383,13 @@ impl Isaac64Rng {\n                         let mix = if $j == 0 {!mix} else {mix};\n \n                         unsafe {\n-                            let x = *self.mem.get_unchecked(base + mr_offset);\n-                            a = mix + *self.mem.get_unchecked(base + m2_offset);\n-                            let y = ind!(x) + a + b;\n-                            *self.mem.get_unchecked_mut(base + mr_offset) = y;\n+                            let x = Wrapping(*self.mem.get_unchecked(base + mr_offset));\n+                            a = mix + Wrapping(*self.mem.get_unchecked(base + m2_offset));\n+                            let y = Wrapping(ind!(x.0)) + a + b;\n+                            *self.mem.get_unchecked_mut(base + mr_offset) = y.0;\n \n-                            b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                            *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n+                            b = Wrapping(ind!(y.0 >> RAND_SIZE_64_LEN)) + x;\n+                            *self.rsl.get_unchecked_mut(base + mr_offset) = b.0;\n                         }\n                     }}\n                 }\n@@ -401,13 +401,13 @@ impl Isaac64Rng {\n                         let mix = if $j == 0 {!mix} else {mix};\n \n                         unsafe {\n-                            let x = *self.mem.get_unchecked(base + mr_offset);\n-                            a = mix + *self.mem.get_unchecked(base + m2_offset);\n-                            let y = ind!(x) + a + b;\n-                            *self.mem.get_unchecked_mut(base + mr_offset) = y;\n+                            let x = Wrapping(*self.mem.get_unchecked(base + mr_offset));\n+                            a = mix + Wrapping(*self.mem.get_unchecked(base + m2_offset));\n+                            let y = Wrapping(ind!(x.0)) + a + b;\n+                            *self.mem.get_unchecked_mut(base + mr_offset) = y.0;\n \n-                            b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                            *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n+                            b = Wrapping(ind!(y.0 >> RAND_SIZE_64_LEN)) + x;\n+                            *self.rsl.get_unchecked_mut(base + mr_offset) = b.0;\n                         }\n                     }}\n                 }\n@@ -419,8 +419,8 @@ impl Isaac64Rng {\n             }\n         }\n \n-        self.a = a;\n-        self.b = b;\n+        self.a = a.0;\n+        self.b = b.0;\n         self.cnt = RAND_SIZE_64;\n     }\n }"}, {"sha": "e32fcaec04734b49730de759492641242d8449fc", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "patch": "@@ -783,7 +783,7 @@ pub fn get_enum_variants<'tcx>(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::Nod\n             _         => { /* empty */ }\n         }\n         let old_disr_val = disr_val;\n-        disr_val += 1;\n+        disr_val = disr_val.wrapping_add(1);\n         Rc::new(ty::VariantInfo {\n             args: arg_tys,\n             arg_names: arg_names,"}, {"sha": "8152a2bf16dd1f773a56d949ef14dfd587dfcecd", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "patch": "@@ -347,7 +347,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n \n         ecx.tcx.map.with_path(variant.node.id, |path| encode_path(rbml_w, path));\n         rbml_w.end_tag();\n-        disr_val += 1;\n+        disr_val = disr_val.wrapping_add(1);\n         i += 1;\n     }\n }"}, {"sha": "33c0fb8b031ef4e8c05a8c6c414b244fd1b8955d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "patch": "@@ -204,7 +204,9 @@ impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n     pub fn tr_id(&self, id: ast::NodeId) -> ast::NodeId {\n         // from_id_range should be non-empty\n         assert!(!self.from_id_range.empty());\n-        (id - self.from_id_range.min + self.to_id_range.min)\n+        // Use wrapping arithmetic because otherwise it introduces control flow.\n+        // Maybe we should just have the control flow? -- aatch\n+        (id.wrapping_sub(self.from_id_range.min).wrapping_add(self.to_id_range.min))\n     }\n \n     /// Translates an EXTERNAL def-id, converting the crate number from the one used in the encoded"}, {"sha": "b6d1fc5a3694856140f9e64f5711562e806260a2", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "patch": "@@ -5333,6 +5333,7 @@ pub fn type_is_empty(cx: &ctxt, ty: Ty) -> bool {\n \n pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                            -> Rc<Vec<Rc<VariantInfo<'tcx>>>> {\n+    use std::num::Int; // For checked_add\n     memoized(&cx.enum_var_cache, id, |id: ast::DefId| {\n         if ast::LOCAL_CRATE != id.krate {\n             Rc::new(csearch::get_enum_variants(cx, id))\n@@ -5349,11 +5350,7 @@ pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                             let mut last_discriminant: Option<Disr> = None;\n                             Rc::new(enum_definition.variants.iter().map(|variant| {\n \n-                                let mut discriminant = match last_discriminant {\n-                                    Some(val) => val + 1,\n-                                    None => INITIAL_DISCRIMINANT_VALUE\n-                                };\n-\n+                                let mut discriminant = INITIAL_DISCRIMINANT_VALUE;\n                                 if let Some(ref e) = variant.node.disr_expr {\n                                     // Preserve all values, and prefer signed.\n                                     let ty = Some(cx.types.i64);\n@@ -5373,7 +5370,19 @@ pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                                       \"expected constant: {}\", err);\n                                         }\n                                     }\n-                                };\n+                                } else {\n+                                    if let Some(val) = last_discriminant {\n+                                        if let Some(v) = val.checked_add(1) {\n+                                            discriminant = v\n+                                        } else {\n+                                            cx.sess.span_err(\n+                                                variant.span,\n+                                                &format!(\"Discriminant overflowed!\"));\n+                                        }\n+                                    } else {\n+                                        discriminant = INITIAL_DISCRIMINANT_VALUE;\n+                                    }\n+                                }\n \n                                 last_discriminant = Some(discriminant);\n                                 Rc::new(VariantInfo::from_ast_variant(cx, &**variant,"}, {"sha": "0f69aa941a31e67b51080dd3051068f5f5362aee", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "patch": "@@ -57,7 +57,7 @@ impl Hasher for FnvHasher {\n         let FnvHasher(mut hash) = *self;\n         for byte in bytes {\n             hash = hash ^ (*byte as u64);\n-            hash = hash * 0x100000001b3;\n+            hash = hash.wrapping_mul(0x100000001b3);\n         }\n         *self = FnvHasher(hash);\n     }"}, {"sha": "8acb6851f111d752e4755a15afeb9267a6bff913", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "patch": "@@ -347,17 +347,19 @@ impl Engine256State {\n         // Sha-512 and Sha-256 use basically the same calculations which are implemented\n         // by these macros. Inlining the calculations seems to result in better generated code.\n         macro_rules! schedule_round { ($t:expr) => (\n-                w[$t] = sigma1(w[$t - 2]) + w[$t - 7] + sigma0(w[$t - 15]) + w[$t - 16];\n-                )\n+            w[$t] = sigma1(w[$t - 2]).wrapping_add(w[$t - 7])\n+                .wrapping_add(sigma0(w[$t - 15])).wrapping_add(w[$t - 16]);\n+            )\n         }\n \n         macro_rules! sha2_round {\n             ($A:ident, $B:ident, $C:ident, $D:ident,\n              $E:ident, $F:ident, $G:ident, $H:ident, $K:ident, $t:expr) => (\n                 {\n-                    $H += sum1($E) + ch($E, $F, $G) + $K[$t] + w[$t];\n-                    $D += $H;\n-                    $H += sum0($A) + maj($A, $B, $C);\n+                    $H = $H.wrapping_add(sum1($E)).wrapping_add(ch($E, $F, $G))\n+                        .wrapping_add($K[$t]).wrapping_add(w[$t]);\n+                    $D = $D.wrapping_add($H);\n+                    $H = $H.wrapping_add(sum0($A)).wrapping_add(maj($A, $B, $C));\n                 }\n              )\n         }\n@@ -397,14 +399,14 @@ impl Engine256State {\n             sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n         }\n \n-        self.h0 += a;\n-        self.h1 += b;\n-        self.h2 += c;\n-        self.h3 += d;\n-        self.h4 += e;\n-        self.h5 += f;\n-        self.h6 += g;\n-        self.h7 += h;\n+        self.h0 = self.h0.wrapping_add(a);\n+        self.h1 = self.h1.wrapping_add(b);\n+        self.h2 = self.h2.wrapping_add(c);\n+        self.h3 = self.h3.wrapping_add(d);\n+        self.h4 = self.h4.wrapping_add(e);\n+        self.h5 = self.h5.wrapping_add(f);\n+        self.h6 = self.h6.wrapping_add(g);\n+        self.h7 = self.h7.wrapping_add(h);\n     }\n }\n "}, {"sha": "10771935e22a4b274b5a87ecf9a45f8fb82610ad", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "patch": "@@ -4554,6 +4554,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                           id: ast::NodeId,\n                           hint: attr::ReprAttr)\n                           -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n+        use std::num::Int;\n \n         let rty = ty::node_id_to_type(ccx.tcx, id);\n         let mut variants: Vec<Rc<ty::VariantInfo>> = Vec::new();\n@@ -4565,7 +4566,13 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             // If the discriminant value is specified explicitly in the enum check whether the\n             // initialization expression is valid, otherwise use the last value plus one.\n             let mut current_disr_val = match prev_disr_val {\n-                Some(prev_disr_val) => prev_disr_val + 1,\n+                Some(prev_disr_val) => {\n+                    if let Some(v) = prev_disr_val.checked_add(1) {\n+                        v\n+                    } else {\n+                        ty::INITIAL_DISCRIMINANT_VALUE\n+                    }\n+                }\n                 None => ty::INITIAL_DISCRIMINANT_VALUE\n             };\n "}, {"sha": "8eb29a8327a52710c6479f026e35bc4a698b516e", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "patch": "@@ -314,6 +314,13 @@ fn search_hashed<K, V, M, F>(table: M,\n     M: Deref<Target=RawTable<K, V>>,\n     F: FnMut(&K) -> bool,\n {\n+    // This is the only function where capacity can be zero. To avoid\n+    // undefined behaviour when Bucket::new gets the raw bucket in this\n+    // case, immediately return the appropriate search result.\n+    if table.capacity() == 0 {\n+        return TableRef(table);\n+    }\n+\n     let size = table.size();\n     let mut probe = Bucket::new(table, hash);\n     let ib = probe.index();"}, {"sha": "908b5267b69d67be1673413c8c0f559ad7de83b9", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "patch": "@@ -224,6 +224,9 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> Bucket<K, V, M> {\n     }\n \n     pub fn at_index(table: M, ib_index: usize) -> Bucket<K, V, M> {\n+        // if capacity is 0, then the RawBucket will be populated with bogus pointers.\n+        // This is an uncommon case though, so avoid it in release builds.\n+        debug_assert!(table.capacity() > 0, \"Table should have capacity at this point\");\n         let ib_index = ib_index & (table.capacity() - 1);\n         Bucket {\n             raw: unsafe {\n@@ -368,10 +371,11 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> FullBucket<K, V, M> {\n     /// In the cited blog posts above, this is called the \"distance to\n     /// initial bucket\", or DIB. Also known as \"probe count\".\n     pub fn distance(&self) -> usize {\n+        use core::num::wrapping::WrappingOps;\n         // Calculates the distance one has to travel when going from\n         // `hash mod capacity` onwards to `idx mod capacity`, wrapping around\n         // if the destination is not reached before the end of the table.\n-        (self.idx - self.hash().inspect() as usize) & (self.table.capacity() - 1)\n+        (self.idx.wrapping_sub(self.hash().inspect() as usize)) & (self.table.capacity() - 1)\n     }\n \n     #[inline]"}, {"sha": "d4428282b148e3d16398dc883daf903bac6c74df", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "patch": "@@ -30,6 +30,7 @@ pub use core::num::{from_uint, from_u8, from_u16, from_u32, from_u64};\n pub use core::num::{from_f32, from_f64};\n pub use core::num::{FromStrRadix, from_str_radix};\n pub use core::num::{FpCategory, ParseIntError, ParseFloatError};\n+pub use core::num::wrapping;\n \n use option::Option;\n "}, {"sha": "60e1354482c8f4626eb1872e3a5fb909afe65cf4", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "patch": "@@ -58,3 +58,5 @@\n #[doc(no_inline)] pub use old_io::{Buffer, Writer, Reader, Seek, BufferPrelude};\n // NB: remove when range syntax lands\n #[doc(no_inline)] pub use iter::range;\n+\n+#[doc(no_inline)] pub use num::wrapping::{Wrapping, WrappingOps};"}, {"sha": "94b7d1b4d8cb0658c115a2daf86ab2c32298bbd6", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1246d4067fdc034d064dfb78f88c2c3c079c3f4f/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=1246d4067fdc034d064dfb78f88c2c3c079c3f4f", "patch": "@@ -240,25 +240,24 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             let encoder = cx.expr_ident(trait_span, blkarg);\n             let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\");\n             let mut stmts = Vec::new();\n-            let last = fields.len() - 1;\n-            for (i, &FieldInfo { ref self_, span, .. }) in fields.iter().enumerate() {\n-                let enc = cx.expr_method_call(span, self_.clone(),\n-                                              encode, vec!(blkencoder.clone()));\n-                let lambda = cx.lambda_expr_1(span, enc, blkarg);\n-                let call = cx.expr_method_call(span, blkencoder.clone(),\n-                                               emit_variant_arg,\n-                                               vec!(cx.expr_usize(span, i),\n-                                                 lambda));\n-                let call = if i != last {\n-                    cx.expr_try(span, call)\n-                } else {\n-                    cx.expr(span, ExprRet(Some(call)))\n-                };\n-                stmts.push(cx.stmt_expr(call));\n-            }\n-\n-            // enums with no fields need to return Ok()\n-            if stmts.len() == 0 {\n+            if fields.len() > 0 {\n+                let last = fields.len() - 1;\n+                for (i, &FieldInfo { ref self_, span, .. }) in fields.iter().enumerate() {\n+                    let enc = cx.expr_method_call(span, self_.clone(),\n+                                                  encode, vec!(blkencoder.clone()));\n+                    let lambda = cx.lambda_expr_1(span, enc, blkarg);\n+                    let call = cx.expr_method_call(span, blkencoder.clone(),\n+                                                   emit_variant_arg,\n+                                                   vec!(cx.expr_usize(span, i),\n+                                                        lambda));\n+                    let call = if i != last {\n+                        cx.expr_try(span, call)\n+                    } else {\n+                        cx.expr(span, ExprRet(Some(call)))\n+                    };\n+                    stmts.push(cx.stmt_expr(call));\n+                }\n+            } else {\n                 let ret_ok = cx.expr(trait_span,\n                                      ExprRet(Some(cx.expr_ok(trait_span,\n                                                              cx.expr_tuple(trait_span, vec![])))));"}]}