{"sha": "af57acef1cd1651861be0bfe77b4f4dd3066ce02", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmNTdhY2VmMWNkMTY1MTg2MWJlMGJmZTc3YjRmNGRkMzA2NmNlMDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-17T13:15:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-17T13:15:40Z"}, "message": "Auto merge of #46709 - Zoxc:par-merge, r=arielb1\n\nAdd sync module to rustc_data_structures\n\nThis PR is split out from https://github.com/rust-lang/rust/pull/45912, since github apparently can't handle such large PRs.\n\nr? @arielb1", "tree": {"sha": "a3f3a22dfff0f3578a7530805eb275205483ac68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3f3a22dfff0f3578a7530805eb275205483ac68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af57acef1cd1651861be0bfe77b4f4dd3066ce02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af57acef1cd1651861be0bfe77b4f4dd3066ce02", "html_url": "https://github.com/rust-lang/rust/commit/af57acef1cd1651861be0bfe77b4f4dd3066ce02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af57acef1cd1651861be0bfe77b4f4dd3066ce02/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53a6d14e5bb8b1915a5f0b9371bbf0da934ed052", "url": "https://api.github.com/repos/rust-lang/rust/commits/53a6d14e5bb8b1915a5f0b9371bbf0da934ed052", "html_url": "https://github.com/rust-lang/rust/commit/53a6d14e5bb8b1915a5f0b9371bbf0da934ed052"}, {"sha": "970c613e4a785325469d4f694a16505d5deac17a", "url": "https://api.github.com/repos/rust-lang/rust/commits/970c613e4a785325469d4f694a16505d5deac17a", "html_url": "https://github.com/rust-lang/rust/commit/970c613e4a785325469d4f694a16505d5deac17a"}], "stats": {"total": 2410, "additions": 2391, "deletions": 19}, "files": [{"sha": "54a58854f0a279a837764413ae5032a3065279cf", "filename": "src/Cargo.lock", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -1313,6 +1313,27 @@ dependencies = [\n  \"unwind 0.0.0\",\n ]\n \n+[[package]]\n+name = \"parking_lot\"\n+version = \"0.5.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot_core 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"parking_lot_core\"\n+version = \"0.2.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.34 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand 0.3.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"percent-encoding\"\n version = \"1.0.1\"\n@@ -1649,7 +1670,6 @@ dependencies = [\n  \"graphviz 0.0.0\",\n  \"jobserver 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_apfloat 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n@@ -1773,8 +1793,12 @@ dependencies = [\n name = \"rustc_data_structures\"\n version = \"0.0.0\"\n dependencies = [\n+ \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot_core 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\",\n+ \"stable_deref_trait 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1786,7 +1810,6 @@ dependencies = [\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_allocator 0.0.0\",\n  \"rustc_back 0.0.0\",\n@@ -1874,7 +1897,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"flate2 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc_macro 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n@@ -1993,7 +2015,6 @@ dependencies = [\n  \"jobserver 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_allocator 0.0.0\",\n@@ -2020,7 +2041,6 @@ dependencies = [\n  \"ar 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n@@ -2228,6 +2248,11 @@ name = \"smallvec\"\n version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"smallvec\"\n+version = \"0.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"socket2\"\n version = \"0.2.4\"\n@@ -2820,6 +2845,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum openssl-sys 0.9.22 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5483bdc56756041ba6aa37c9cb59cc2219f012a2a1377d97ad35556ac6676ee7\"\n \"checksum os_pipe 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"998bfbb3042e715190fe2a41abfa047d7e8cb81374d2977d7f100eacd8619cb1\"\n \"checksum owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cdf84f41639e037b484f93433aa3897863b561ed65c6e59c7073d7c561710f37\"\n+\"checksum parking_lot 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3e7f7c9857874e54afeb950eebeae662b1e51a2493666d2ea4c0a5d91dcf0412\"\n+\"checksum parking_lot_core 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"12d20aac4f67aa75f681aded784bac91f910ba3f2af1812573cdcf687414e122\"\n \"checksum percent-encoding 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"31010dd2e1ac33d5b46a5b413495239882813e0369f8ed8a5e266f173602f831\"\n \"checksum pest 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a6dda33d67c26f0aac90d324ab2eb7239c819fc7b2552fe9faa4fe88441edc8\"\n \"checksum phf 0.7.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cb325642290f28ee14d8c6201159949a872f220c62af6e110a56ea914fbe42fc\"\n@@ -2871,6 +2898,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum shell-escape 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dd5cc96481d54583947bfe88bf30c23d53f883c6cd0145368b69989d97b84ef8\"\n \"checksum siphasher 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0df90a788073e8d0235a67e50441d47db7c8ad9debd91cbf43736a2a92d36537\"\n \"checksum smallvec 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4f8266519bc1d17d0b5b16f6c21295625d562841c708f6376f49028a43e9c11e\"\n+\"checksum smallvec 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"44db0ecb22921ef790d17ae13a3f6d15784183ff5f2a01aa32098c7498d2b4b9\"\n \"checksum socket2 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"36b4896961171cd3317c7e9603d88f379f8c6e45342212235d356496680c68fd\"\n \"checksum stable_deref_trait 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15132e0e364248108c5e2c02e3ab539be8d6f5d52a01ca9bbf27ed657316f02b\"\n \"checksum string_cache 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"413fc7852aeeb5472f1986ef755f561ddf0c789d3d796e65f0b6fe293ecd4ef8\""}, {"sha": "37336a56d76c2071e7d51dc3e6594682396e3189", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -265,6 +265,10 @@ fn main() {\n         }\n     }\n \n+    if env::var_os(\"RUSTC_PARALLEL_QUERIES\").is_some() {\n+        cmd.arg(\"--cfg\").arg(\"parallel_queries\");\n+    }\n+\n     let color = match env::var(\"RUSTC_COLOR\") {\n         Ok(s) => usize::from_str(&s).expect(\"RUSTC_COLOR should be an integer\"),\n         Err(_) => 0,"}, {"sha": "4c76230ced8bc96242083264e4b41ffa44d2e11f", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -561,6 +561,9 @@ pub fn rustc_cargo(build: &Build,\n     if let Some(ref s) = build.config.rustc_default_linker {\n         cargo.env(\"CFG_DEFAULT_LINKER\", s);\n     }\n+    if build.config.rustc_parallel_queries {\n+        cargo.env(\"RUSTC_PARALLEL_QUERIES\", \"1\");\n+    }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]"}, {"sha": "87b1db33a7a851243a07170bb15db9d85cd57e27", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -87,6 +87,7 @@ pub struct Config {\n     pub rust_debuginfo_lines: bool,\n     pub rust_debuginfo_only_std: bool,\n     pub rust_rpath: bool,\n+    pub rustc_parallel_queries: bool,\n     pub rustc_default_linker: Option<String>,\n     pub rust_optimize_tests: bool,\n     pub rust_debuginfo_tests: bool,\n@@ -266,6 +267,7 @@ struct Rust {\n     debuginfo: Option<bool>,\n     debuginfo_lines: Option<bool>,\n     debuginfo_only_std: Option<bool>,\n+    experimental_parallel_queries: Option<bool>,\n     debug_jemalloc: Option<bool>,\n     use_jemalloc: Option<bool>,\n     backtrace: Option<bool>,\n@@ -474,6 +476,7 @@ impl Config {\n             set(&mut config.rust_dist_src, rust.dist_src);\n             set(&mut config.quiet_tests, rust.quiet_tests);\n             set(&mut config.test_miri, rust.test_miri);\n+            config.rustc_parallel_queries = rust.experimental_parallel_queries.unwrap_or(false);\n             config.rustc_default_linker = rust.default_linker.clone();\n             config.musl_root = rust.musl_root.clone().map(PathBuf::from);\n             config.save_toolstates = rust.save_toolstates.clone().map(PathBuf::from);"}, {"sha": "3a4b30294db742ecb1aef76c1726f722ea4a4a6b", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -15,7 +15,6 @@ fmt_macros = { path = \"../libfmt_macros\" }\n graphviz = { path = \"../libgraphviz\" }\n jobserver = \"0.1\"\n log = \"0.3\"\n-owning_ref = \"0.3.3\"\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_math = { path = \"../librustc_const_math\" }"}, {"sha": "8dc927c451b89a7f75326e050b78fae3e79dcab9", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -77,7 +77,6 @@ extern crate getopts;\n extern crate graphviz;\n #[cfg(windows)]\n extern crate libc;\n-extern crate owning_ref;\n extern crate rustc_back;\n #[macro_use] extern crate rustc_data_structures;\n extern crate serialize;"}, {"sha": "9708afd204593e313d94570d74b4380ee8096858", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -38,7 +38,7 @@ use std::any::Any;\n use std::collections::BTreeMap;\n use std::path::{Path, PathBuf};\n use std::rc::Rc;\n-use owning_ref::ErasedBoxRef;\n+use rustc_data_structures::owning_ref::ErasedBoxRef;\n use syntax::ast;\n use syntax::ext::base::SyntaxExtension;\n use syntax::symbol::Symbol;"}, {"sha": "82075ce1f1f792ec36640d80df829cb5412e3b0b", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -11,3 +11,10 @@ crate-type = [\"dylib\"]\n [dependencies]\n log = \"0.3\"\n serialize = { path = \"../libserialize\" }\n+cfg-if = \"0.1.2\"\n+stable_deref_trait = \"1.0.0\"\n+parking_lot_core = \"0.2.8\"\n+\n+[dependencies.parking_lot]\n+version = \"0.5\"\n+features = [\"nightly\"]\n\\ No newline at end of file"}, {"sha": "24048e606df4739b02e11779568426e7118a1e1d", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -31,7 +31,10 @@\n #![feature(i128)]\n #![feature(conservative_impl_trait)]\n #![feature(specialization)]\n+#![feature(optin_builtin_traits)]\n #![feature(underscore_lifetimes)]\n+#![feature(macro_vis_matcher)]\n+#![feature(allow_internal_unstable)]\n \n #![cfg_attr(unix, feature(libc))]\n #![cfg_attr(test, feature(test))]\n@@ -42,6 +45,10 @@ extern crate log;\n extern crate serialize as rustc_serialize; // used by deriving\n #[cfg(unix)]\n extern crate libc;\n+extern crate parking_lot;\n+#[macro_use]\n+extern crate cfg_if;\n+extern crate stable_deref_trait;\n \n pub use rustc_serialize::hex::ToHex;\n \n@@ -67,6 +74,8 @@ pub mod tuple_slice;\n pub mod veccell;\n pub mod control_flow_graph;\n pub mod flock;\n+pub mod sync;\n+pub mod owning_ref;\n \n // See comments in src/librustc/lib.rs\n #[doc(hidden)]"}, {"sha": "dff72d1e43251989d52b6bec53c8588f7f4df47b", "filename": "src/librustc_data_structures/owning_ref/LICENSE", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_data_structures%2Fowning_ref%2FLICENSE", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_data_structures%2Fowning_ref%2FLICENSE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fowning_ref%2FLICENSE?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -0,0 +1,21 @@\n+The MIT License (MIT)\n+\n+Copyright (c) 2015 Marvin L\u00f6bel\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE."}, {"sha": "23e0733748b4acbfa1490144305c6761b238bf10", "filename": "src/librustc_data_structures/owning_ref/mod.rs", "status": "added", "additions": 1902, "deletions": 0, "changes": 1902, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -0,0 +1,1902 @@\n+#![warn(missing_docs)]\n+\n+/*!\n+# An owning reference.\n+\n+This crate provides the _owning reference_ types `OwningRef` and `OwningRefMut`\n+that enables it to bundle a reference together with the owner of the data it points to.\n+This allows moving and dropping of a `OwningRef` without needing to recreate the reference.\n+\n+This can sometimes be useful because Rust borrowing rules normally prevent\n+moving a type that has been moved from. For example, this kind of code gets rejected:\n+\n+```rust,ignore\n+fn return_owned_and_referenced<'a>() -> (Vec<u8>, &'a [u8]) {\n+    let v = vec![1, 2, 3, 4];\n+    let s = &v[1..3];\n+    (v, s)\n+}\n+```\n+\n+Even though, from a memory-layout point of view, this can be entirely safe\n+if the new location of the vector still lives longer than the lifetime `'a`\n+of the reference because the backing allocation of the vector does not change.\n+\n+This library enables this safe usage by keeping the owner and the reference\n+bundled together in a wrapper type that ensure that lifetime constraint:\n+\n+```rust\n+# extern crate owning_ref;\n+# use owning_ref::OwningRef;\n+# fn main() {\n+fn return_owned_and_referenced() -> OwningRef<Vec<u8>, [u8]> {\n+    let v = vec![1, 2, 3, 4];\n+    let or = OwningRef::new(v);\n+    let or = or.map(|v| &v[1..3]);\n+    or\n+}\n+# }\n+```\n+\n+It works by requiring owner types to dereference to stable memory locations\n+and preventing mutable access to root containers, which in practice requires heap allocation\n+as provided by `Box<T>`, `Rc<T>`, etc.\n+\n+Also provided are typedefs for common owner type combinations,\n+which allow for less verbose type signatures. For example, `BoxRef<T>` instead of `OwningRef<Box<T>, T>`.\n+\n+The crate also provides the more advanced `OwningHandle` type,\n+which allows more freedom in bundling a dependent handle object\n+along with the data it depends on, at the cost of some unsafe needed in the API.\n+See the documentation around `OwningHandle` for more details.\n+\n+# Examples\n+\n+## Basics\n+\n+```\n+extern crate owning_ref;\n+use owning_ref::BoxRef;\n+\n+fn main() {\n+    // Create an array owned by a Box.\n+    let arr = Box::new([1, 2, 3, 4]) as Box<[i32]>;\n+\n+    // Transfer into a BoxRef.\n+    let arr: BoxRef<[i32]> = BoxRef::new(arr);\n+    assert_eq!(&*arr, &[1, 2, 3, 4]);\n+\n+    // We can slice the array without losing ownership or changing type.\n+    let arr: BoxRef<[i32]> = arr.map(|arr| &arr[1..3]);\n+    assert_eq!(&*arr, &[2, 3]);\n+\n+    // Also works for Arc, Rc, String and Vec!\n+}\n+```\n+\n+## Caching a reference to a struct field\n+\n+```\n+extern crate owning_ref;\n+use owning_ref::BoxRef;\n+\n+fn main() {\n+    struct Foo {\n+        tag: u32,\n+        x: u16,\n+        y: u16,\n+        z: u16,\n+    }\n+    let foo = Foo { tag: 1, x: 100, y: 200, z: 300 };\n+\n+    let or = BoxRef::new(Box::new(foo)).map(|foo| {\n+        match foo.tag {\n+            0 => &foo.x,\n+            1 => &foo.y,\n+            2 => &foo.z,\n+            _ => panic!(),\n+        }\n+    });\n+\n+    assert_eq!(*or, 200);\n+}\n+```\n+\n+## Caching a reference to an entry in a vector\n+\n+```\n+extern crate owning_ref;\n+use owning_ref::VecRef;\n+\n+fn main() {\n+    let v = VecRef::new(vec![1, 2, 3, 4, 5]).map(|v| &v[3]);\n+    assert_eq!(*v, 4);\n+}\n+```\n+\n+## Caching a subslice of a String\n+\n+```\n+extern crate owning_ref;\n+use owning_ref::StringRef;\n+\n+fn main() {\n+    let s = StringRef::new(\"hello world\".to_owned())\n+        .map(|s| s.split(' ').nth(1).unwrap());\n+\n+    assert_eq!(&*s, \"world\");\n+}\n+```\n+\n+## Reference counted slices that share ownership of the backing storage\n+\n+```\n+extern crate owning_ref;\n+use owning_ref::RcRef;\n+use std::rc::Rc;\n+\n+fn main() {\n+    let rc: RcRef<[i32]> = RcRef::new(Rc::new([1, 2, 3, 4]) as Rc<[i32]>);\n+    assert_eq!(&*rc, &[1, 2, 3, 4]);\n+\n+    let rc_a: RcRef<[i32]> = rc.clone().map(|s| &s[0..2]);\n+    let rc_b = rc.clone().map(|s| &s[1..3]);\n+    let rc_c = rc.clone().map(|s| &s[2..4]);\n+    assert_eq!(&*rc_a, &[1, 2]);\n+    assert_eq!(&*rc_b, &[2, 3]);\n+    assert_eq!(&*rc_c, &[3, 4]);\n+\n+    let rc_c_a = rc_c.clone().map(|s| &s[1]);\n+    assert_eq!(&*rc_c_a, &4);\n+}\n+```\n+\n+## Atomic reference counted slices that share ownership of the backing storage\n+\n+```\n+extern crate owning_ref;\n+use owning_ref::ArcRef;\n+use std::sync::Arc;\n+\n+fn main() {\n+    use std::thread;\n+\n+    fn par_sum(rc: ArcRef<[i32]>) -> i32 {\n+        if rc.len() == 0 {\n+            return 0;\n+        } else if rc.len() == 1 {\n+            return rc[0];\n+        }\n+        let mid = rc.len() / 2;\n+        let left = rc.clone().map(|s| &s[..mid]);\n+        let right = rc.map(|s| &s[mid..]);\n+\n+        let left = thread::spawn(move || par_sum(left));\n+        let right = thread::spawn(move || par_sum(right));\n+\n+        left.join().unwrap() + right.join().unwrap()\n+    }\n+\n+    let rc: Arc<[i32]> = Arc::new([1, 2, 3, 4]);\n+    let rc: ArcRef<[i32]> = rc.into();\n+\n+    assert_eq!(par_sum(rc), 10);\n+}\n+```\n+\n+## References into RAII locks\n+\n+```\n+extern crate owning_ref;\n+use owning_ref::RefRef;\n+use std::cell::{RefCell, Ref};\n+\n+fn main() {\n+    let refcell = RefCell::new((1, 2, 3, 4));\n+    // Also works with Mutex and RwLock\n+\n+    let refref = {\n+        let refref = RefRef::new(refcell.borrow()).map(|x| &x.3);\n+        assert_eq!(*refref, 4);\n+\n+        // We move the RAII lock and the reference to one of\n+        // the subfields in the data it guards here:\n+        refref\n+    };\n+\n+    assert_eq!(*refref, 4);\n+\n+    drop(refref);\n+\n+    assert_eq!(*refcell.borrow(), (1, 2, 3, 4));\n+}\n+```\n+\n+## Mutable reference\n+\n+When the owned container implements `DerefMut`, it is also possible to make\n+a _mutable owning reference_. (E.g. with `Box`, `RefMut`, `MutexGuard`)\n+\n+```\n+extern crate owning_ref;\n+use owning_ref::RefMutRefMut;\n+use std::cell::{RefCell, RefMut};\n+\n+fn main() {\n+    let refcell = RefCell::new((1, 2, 3, 4));\n+\n+    let mut refmut_refmut = {\n+        let mut refmut_refmut = RefMutRefMut::new(refcell.borrow_mut()).map_mut(|x| &mut x.3);\n+        assert_eq!(*refmut_refmut, 4);\n+        *refmut_refmut *= 2;\n+\n+        refmut_refmut\n+    };\n+\n+    assert_eq!(*refmut_refmut, 8);\n+    *refmut_refmut *= 2;\n+\n+    drop(refmut_refmut);\n+\n+    assert_eq!(*refcell.borrow(), (1, 2, 3, 16));\n+}\n+```\n+*/\n+\n+pub use stable_deref_trait::{StableDeref as StableAddress, CloneStableDeref as CloneStableAddress};\n+\n+/// An owning reference.\n+///\n+/// This wraps an owner `O` and a reference `&T` pointing\n+/// at something reachable from `O::Target` while keeping\n+/// the ability to move `self` around.\n+///\n+/// The owner is usually a pointer that points at some base type.\n+///\n+/// For more details and examples, see the module and method docs.\n+pub struct OwningRef<O, T: ?Sized> {\n+    owner: O,\n+    reference: *const T,\n+}\n+\n+/// An mutable owning reference.\n+///\n+/// This wraps an owner `O` and a reference `&mut T` pointing\n+/// at something reachable from `O::Target` while keeping\n+/// the ability to move `self` around.\n+///\n+/// The owner is usually a pointer that points at some base type.\n+///\n+/// For more details and examples, see the module and method docs.\n+pub struct OwningRefMut<O, T: ?Sized> {\n+    owner: O,\n+    reference: *mut T,\n+}\n+\n+/// Helper trait for an erased concrete type an owner dereferences to.\n+/// This is used in form of a trait object for keeping\n+/// something around to (virtually) call the destructor.\n+pub trait Erased {}\n+impl<T> Erased for T {}\n+\n+/// Helper trait for erasing the concrete type of what an owner derferences to,\n+/// for example `Box<T> -> Box<Erased>`. This would be unneeded with\n+/// higher kinded types support in the language.\n+pub unsafe trait IntoErased<'a> {\n+    /// Owner with the dereference type substituted to `Erased`.\n+    type Erased;\n+    /// Perform the type erasure.\n+    fn into_erased(self) -> Self::Erased;\n+}\n+\n+/// Helper trait for erasing the concrete type of what an owner derferences to,\n+/// for example `Box<T> -> Box<Erased + Send + Sync>`. This would be unneeded with\n+/// higher kinded types support in the language.\n+pub unsafe trait IntoErasedSendSync<'a>: Send + Sync {\n+    /// Owner with the dereference type substituted to `Erased + Send + Sync`.\n+    type Erased: Send + Sync;\n+    /// Perform the type erasure.\n+    fn into_erased_send_sync(self) -> Self::Erased;\n+}\n+\n+/////////////////////////////////////////////////////////////////////////////\n+// OwningRef\n+/////////////////////////////////////////////////////////////////////////////\n+\n+impl<O, T: ?Sized> OwningRef<O, T> {\n+    /// Creates a new owning reference from a owner\n+    /// initialized to the direct dereference of it.\n+    ///\n+    /// # Example\n+    /// ```\n+    /// extern crate owning_ref;\n+    /// use owning_ref::OwningRef;\n+    ///\n+    /// fn main() {\n+    ///     let owning_ref = OwningRef::new(Box::new(42));\n+    ///     assert_eq!(*owning_ref, 42);\n+    /// }\n+    /// ```\n+    pub fn new(o: O) -> Self\n+        where O: StableAddress,\n+              O: Deref<Target = T>,\n+    {\n+        OwningRef {\n+            reference: &*o,\n+            owner: o,\n+        }\n+    }\n+\n+    /// Like `new`, but doesn\u2019t require `O` to implement the `StableAddress` trait.\n+    /// Instead, the caller is responsible to make the same promises as implementing the trait.\n+    ///\n+    /// This is useful for cases where coherence rules prevents implementing the trait\n+    /// without adding a dependency to this crate in a third-party library.\n+    pub unsafe fn new_assert_stable_address(o: O) -> Self\n+        where O: Deref<Target = T>,\n+    {\n+        OwningRef {\n+            reference: &*o,\n+            owner: o,\n+        }\n+    }\n+\n+    /// Converts `self` into a new owning reference that points at something reachable\n+    /// from the previous one.\n+    ///\n+    /// This can be a reference to a field of `U`, something reachable from a field of\n+    /// `U`, or even something unrelated with a `'static` lifetime.\n+    ///\n+    /// # Example\n+    /// ```\n+    /// extern crate owning_ref;\n+    /// use owning_ref::OwningRef;\n+    ///\n+    /// fn main() {\n+    ///     let owning_ref = OwningRef::new(Box::new([1, 2, 3, 4]));\n+    ///\n+    ///     // create a owning reference that points at the\n+    ///     // third element of the array.\n+    ///     let owning_ref = owning_ref.map(|array| &array[2]);\n+    ///     assert_eq!(*owning_ref, 3);\n+    /// }\n+    /// ```\n+    pub fn map<F, U: ?Sized>(self, f: F) -> OwningRef<O, U>\n+        where O: StableAddress,\n+              F: FnOnce(&T) -> &U\n+    {\n+        OwningRef {\n+            reference: f(&self),\n+            owner: self.owner,\n+        }\n+    }\n+\n+    /// Tries to convert `self` into a new owning reference that points\n+    /// at something reachable from the previous one.\n+    ///\n+    /// This can be a reference to a field of `U`, something reachable from a field of\n+    /// `U`, or even something unrelated with a `'static` lifetime.\n+    ///\n+    /// # Example\n+    /// ```\n+    /// extern crate owning_ref;\n+    /// use owning_ref::OwningRef;\n+    ///\n+    /// fn main() {\n+    ///     let owning_ref = OwningRef::new(Box::new([1, 2, 3, 4]));\n+    ///\n+    ///     // create a owning reference that points at the\n+    ///     // third element of the array.\n+    ///     let owning_ref = owning_ref.try_map(|array| {\n+    ///         if array[2] == 3 { Ok(&array[2]) } else { Err(()) }\n+    ///     });\n+    ///     assert_eq!(*owning_ref.unwrap(), 3);\n+    /// }\n+    /// ```\n+    pub fn try_map<F, U: ?Sized, E>(self, f: F) -> Result<OwningRef<O, U>, E>\n+        where O: StableAddress,\n+              F: FnOnce(&T) -> Result<&U, E>\n+    {\n+        Ok(OwningRef {\n+            reference: f(&self)?,\n+            owner: self.owner,\n+        })\n+    }\n+\n+    /// Converts `self` into a new owning reference with a different owner type.\n+    ///\n+    /// The new owner type needs to still contain the original owner in some way\n+    /// so that the reference into it remains valid. This function is marked unsafe\n+    /// because the user needs to manually uphold this guarantee.\n+    pub unsafe fn map_owner<F, P>(self, f: F) -> OwningRef<P, T>\n+        where O: StableAddress,\n+              P: StableAddress,\n+              F: FnOnce(O) -> P\n+    {\n+        OwningRef {\n+            reference: self.reference,\n+            owner: f(self.owner),\n+        }\n+    }\n+\n+    /// Converts `self` into a new owning reference where the owner is wrapped\n+    /// in an additional `Box<O>`.\n+    ///\n+    /// This can be used to safely erase the owner of any `OwningRef<O, T>`\n+    /// to a `OwningRef<Box<Erased>, T>`.\n+    pub fn map_owner_box(self) -> OwningRef<Box<O>, T> {\n+        OwningRef {\n+            reference: self.reference,\n+            owner: Box::new(self.owner),\n+        }\n+    }\n+\n+    /// Erases the concrete base type of the owner with a trait object.\n+    ///\n+    /// This allows mixing of owned references with different owner base types.\n+    ///\n+    /// # Example\n+    /// ```\n+    /// extern crate owning_ref;\n+    /// use owning_ref::{OwningRef, Erased};\n+    ///\n+    /// fn main() {\n+    ///     // NB: Using the concrete types here for explicitnes.\n+    ///     // For less verbose code type aliases like `BoxRef` are provided.\n+    ///\n+    ///     let owning_ref_a: OwningRef<Box<[i32; 4]>, [i32; 4]>\n+    ///         = OwningRef::new(Box::new([1, 2, 3, 4]));\n+    ///\n+    ///     let owning_ref_b: OwningRef<Box<Vec<(i32, bool)>>, Vec<(i32, bool)>>\n+    ///         = OwningRef::new(Box::new(vec![(0, false), (1, true)]));\n+    ///\n+    ///     let owning_ref_a: OwningRef<Box<[i32; 4]>, i32>\n+    ///         = owning_ref_a.map(|a| &a[0]);\n+    ///\n+    ///     let owning_ref_b: OwningRef<Box<Vec<(i32, bool)>>, i32>\n+    ///         = owning_ref_b.map(|a| &a[1].0);\n+    ///\n+    ///     let owning_refs: [OwningRef<Box<Erased>, i32>; 2]\n+    ///         = [owning_ref_a.erase_owner(), owning_ref_b.erase_owner()];\n+    ///\n+    ///     assert_eq!(*owning_refs[0], 1);\n+    ///     assert_eq!(*owning_refs[1], 1);\n+    /// }\n+    /// ```\n+    pub fn erase_owner<'a>(self) -> OwningRef<O::Erased, T>\n+        where O: IntoErased<'a>,\n+    {\n+        OwningRef {\n+            reference: self.reference,\n+            owner: self.owner.into_erased(),\n+        }\n+    }\n+\n+    /// Erases the concrete base type of the owner with a trait object which implements `Send` and `Sync`.\n+    ///\n+    /// This allows mixing of owned references with different owner base types.\n+    pub fn erase_send_sync_owner<'a>(self) -> OwningRef<O::Erased, T>\n+        where O: IntoErasedSendSync<'a>,\n+    {\n+        OwningRef {\n+            reference: self.reference,\n+            owner: self.owner.into_erased_send_sync(),\n+        }\n+    }\n+\n+    // TODO: wrap_owner\n+\n+    // FIXME: Naming convention?\n+    /// A getter for the underlying owner.\n+    pub fn owner(&self) -> &O {\n+        &self.owner\n+    }\n+\n+    // FIXME: Naming convention?\n+    /// Discards the reference and retrieves the owner.\n+    pub fn into_inner(self) -> O {\n+        self.owner\n+    }\n+}\n+\n+impl<O, T: ?Sized> OwningRefMut<O, T> {\n+    /// Creates a new owning reference from a owner\n+    /// initialized to the direct dereference of it.\n+    ///\n+    /// # Example\n+    /// ```\n+    /// extern crate owning_ref;\n+    /// use owning_ref::OwningRefMut;\n+    ///\n+    /// fn main() {\n+    ///     let owning_ref_mut = OwningRefMut::new(Box::new(42));\n+    ///     assert_eq!(*owning_ref_mut, 42);\n+    /// }\n+    /// ```\n+    pub fn new(mut o: O) -> Self\n+        where O: StableAddress,\n+              O: DerefMut<Target = T>,\n+    {\n+        OwningRefMut {\n+            reference: &mut *o,\n+            owner: o,\n+        }\n+    }\n+\n+    /// Like `new`, but doesn\u2019t require `O` to implement the `StableAddress` trait.\n+    /// Instead, the caller is responsible to make the same promises as implementing the trait.\n+    ///\n+    /// This is useful for cases where coherence rules prevents implementing the trait\n+    /// without adding a dependency to this crate in a third-party library.\n+    pub unsafe fn new_assert_stable_address(mut o: O) -> Self\n+        where O: DerefMut<Target = T>,\n+    {\n+        OwningRefMut {\n+            reference: &mut *o,\n+            owner: o,\n+        }\n+    }\n+\n+    /// Converts `self` into a new _shared_ owning reference that points at\n+    /// something reachable from the previous one.\n+    ///\n+    /// This can be a reference to a field of `U`, something reachable from a field of\n+    /// `U`, or even something unrelated with a `'static` lifetime.\n+    ///\n+    /// # Example\n+    /// ```\n+    /// extern crate owning_ref;\n+    /// use owning_ref::OwningRefMut;\n+    ///\n+    /// fn main() {\n+    ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n+    ///\n+    ///     // create a owning reference that points at the\n+    ///     // third element of the array.\n+    ///     let owning_ref = owning_ref_mut.map(|array| &array[2]);\n+    ///     assert_eq!(*owning_ref, 3);\n+    /// }\n+    /// ```\n+    pub fn map<F, U: ?Sized>(mut self, f: F) -> OwningRef<O, U>\n+        where O: StableAddress,\n+              F: FnOnce(&mut T) -> &U\n+    {\n+        OwningRef {\n+            reference: f(&mut self),\n+            owner: self.owner,\n+        }\n+    }\n+\n+    /// Converts `self` into a new _mutable_ owning reference that points at\n+    /// something reachable from the previous one.\n+    ///\n+    /// This can be a reference to a field of `U`, something reachable from a field of\n+    /// `U`, or even something unrelated with a `'static` lifetime.\n+    ///\n+    /// # Example\n+    /// ```\n+    /// extern crate owning_ref;\n+    /// use owning_ref::OwningRefMut;\n+    ///\n+    /// fn main() {\n+    ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n+    ///\n+    ///     // create a owning reference that points at the\n+    ///     // third element of the array.\n+    ///     let owning_ref_mut = owning_ref_mut.map_mut(|array| &mut array[2]);\n+    ///     assert_eq!(*owning_ref_mut, 3);\n+    /// }\n+    /// ```\n+    pub fn map_mut<F, U: ?Sized>(mut self, f: F) -> OwningRefMut<O, U>\n+        where O: StableAddress,\n+              F: FnOnce(&mut T) -> &mut U\n+    {\n+        OwningRefMut {\n+            reference: f(&mut self),\n+            owner: self.owner,\n+        }\n+    }\n+\n+    /// Tries to convert `self` into a new _shared_ owning reference that points\n+    /// at something reachable from the previous one.\n+    ///\n+    /// This can be a reference to a field of `U`, something reachable from a field of\n+    /// `U`, or even something unrelated with a `'static` lifetime.\n+    ///\n+    /// # Example\n+    /// ```\n+    /// extern crate owning_ref;\n+    /// use owning_ref::OwningRefMut;\n+    ///\n+    /// fn main() {\n+    ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n+    ///\n+    ///     // create a owning reference that points at the\n+    ///     // third element of the array.\n+    ///     let owning_ref = owning_ref_mut.try_map(|array| {\n+    ///         if array[2] == 3 { Ok(&array[2]) } else { Err(()) }\n+    ///     });\n+    ///     assert_eq!(*owning_ref.unwrap(), 3);\n+    /// }\n+    /// ```\n+    pub fn try_map<F, U: ?Sized, E>(mut self, f: F) -> Result<OwningRef<O, U>, E>\n+        where O: StableAddress,\n+              F: FnOnce(&mut T) -> Result<&U, E>\n+    {\n+        Ok(OwningRef {\n+            reference: f(&mut self)?,\n+            owner: self.owner,\n+        })\n+    }\n+\n+    /// Tries to convert `self` into a new _mutable_ owning reference that points\n+    /// at something reachable from the previous one.\n+    ///\n+    /// This can be a reference to a field of `U`, something reachable from a field of\n+    /// `U`, or even something unrelated with a `'static` lifetime.\n+    ///\n+    /// # Example\n+    /// ```\n+    /// extern crate owning_ref;\n+    /// use owning_ref::OwningRefMut;\n+    ///\n+    /// fn main() {\n+    ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n+    ///\n+    ///     // create a owning reference that points at the\n+    ///     // third element of the array.\n+    ///     let owning_ref_mut = owning_ref_mut.try_map_mut(|array| {\n+    ///         if array[2] == 3 { Ok(&mut array[2]) } else { Err(()) }\n+    ///     });\n+    ///     assert_eq!(*owning_ref_mut.unwrap(), 3);\n+    /// }\n+    /// ```\n+    pub fn try_map_mut<F, U: ?Sized, E>(mut self, f: F) -> Result<OwningRefMut<O, U>, E>\n+        where O: StableAddress,\n+              F: FnOnce(&mut T) -> Result<&mut U, E>\n+    {\n+        Ok(OwningRefMut {\n+            reference: f(&mut self)?,\n+            owner: self.owner,\n+        })\n+    }\n+\n+    /// Converts `self` into a new owning reference with a different owner type.\n+    ///\n+    /// The new owner type needs to still contain the original owner in some way\n+    /// so that the reference into it remains valid. This function is marked unsafe\n+    /// because the user needs to manually uphold this guarantee.\n+    pub unsafe fn map_owner<F, P>(self, f: F) -> OwningRefMut<P, T>\n+        where O: StableAddress,\n+              P: StableAddress,\n+              F: FnOnce(O) -> P\n+    {\n+        OwningRefMut {\n+            reference: self.reference,\n+            owner: f(self.owner),\n+        }\n+    }\n+\n+    /// Converts `self` into a new owning reference where the owner is wrapped\n+    /// in an additional `Box<O>`.\n+    ///\n+    /// This can be used to safely erase the owner of any `OwningRefMut<O, T>`\n+    /// to a `OwningRefMut<Box<Erased>, T>`.\n+    pub fn map_owner_box(self) -> OwningRefMut<Box<O>, T> {\n+        OwningRefMut {\n+            reference: self.reference,\n+            owner: Box::new(self.owner),\n+        }\n+    }\n+\n+    /// Erases the concrete base type of the owner with a trait object.\n+    ///\n+    /// This allows mixing of owned references with different owner base types.\n+    ///\n+    /// # Example\n+    /// ```\n+    /// extern crate owning_ref;\n+    /// use owning_ref::{OwningRefMut, Erased};\n+    ///\n+    /// fn main() {\n+    ///     // NB: Using the concrete types here for explicitnes.\n+    ///     // For less verbose code type aliases like `BoxRef` are provided.\n+    ///\n+    ///     let owning_ref_mut_a: OwningRefMut<Box<[i32; 4]>, [i32; 4]>\n+    ///         = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n+    ///\n+    ///     let owning_ref_mut_b: OwningRefMut<Box<Vec<(i32, bool)>>, Vec<(i32, bool)>>\n+    ///         = OwningRefMut::new(Box::new(vec![(0, false), (1, true)]));\n+    ///\n+    ///     let owning_ref_mut_a: OwningRefMut<Box<[i32; 4]>, i32>\n+    ///         = owning_ref_mut_a.map_mut(|a| &mut a[0]);\n+    ///\n+    ///     let owning_ref_mut_b: OwningRefMut<Box<Vec<(i32, bool)>>, i32>\n+    ///         = owning_ref_mut_b.map_mut(|a| &mut a[1].0);\n+    ///\n+    ///     let owning_refs_mut: [OwningRefMut<Box<Erased>, i32>; 2]\n+    ///         = [owning_ref_mut_a.erase_owner(), owning_ref_mut_b.erase_owner()];\n+    ///\n+    ///     assert_eq!(*owning_refs_mut[0], 1);\n+    ///     assert_eq!(*owning_refs_mut[1], 1);\n+    /// }\n+    /// ```\n+    pub fn erase_owner<'a>(self) -> OwningRefMut<O::Erased, T>\n+        where O: IntoErased<'a>,\n+    {\n+        OwningRefMut {\n+            reference: self.reference,\n+            owner: self.owner.into_erased(),\n+        }\n+    }\n+\n+    // TODO: wrap_owner\n+\n+    // FIXME: Naming convention?\n+    /// A getter for the underlying owner.\n+    pub fn owner(&self) -> &O {\n+        &self.owner\n+    }\n+\n+    // FIXME: Naming convention?\n+    /// Discards the reference and retrieves the owner.\n+    pub fn into_inner(self) -> O {\n+        self.owner\n+    }\n+}\n+\n+/////////////////////////////////////////////////////////////////////////////\n+// OwningHandle\n+/////////////////////////////////////////////////////////////////////////////\n+\n+use std::ops::{Deref, DerefMut};\n+\n+/// `OwningHandle` is a complement to `OwningRef`. Where `OwningRef` allows\n+/// consumers to pass around an owned object and a dependent reference,\n+/// `OwningHandle` contains an owned object and a dependent _object_.\n+///\n+/// `OwningHandle` can encapsulate a `RefMut` along with its associated\n+/// `RefCell`, or an `RwLockReadGuard` along with its associated `RwLock`.\n+/// However, the API is completely generic and there are no restrictions on\n+/// what types of owning and dependent objects may be used.\n+///\n+/// `OwningHandle` is created by passing an owner object (which dereferences\n+/// to a stable address) along with a callback which receives a pointer to\n+/// that stable location. The callback may then dereference the pointer and\n+/// mint a dependent object, with the guarantee that the returned object will\n+/// not outlive the referent of the pointer.\n+///\n+/// Since the callback needs to dereference a raw pointer, it requires `unsafe`\n+/// code. To avoid forcing this unsafety on most callers, the `ToHandle` trait is\n+/// implemented for common data structures. Types that implement `ToHandle` can\n+/// be wrapped into an `OwningHandle` without passing a callback.\n+pub struct OwningHandle<O, H>\n+    where O: StableAddress, H: Deref,\n+{\n+    handle: H,\n+    _owner: O,\n+}\n+\n+impl<O, H> Deref for OwningHandle<O, H>\n+    where O: StableAddress, H: Deref,\n+{\n+    type Target = H::Target;\n+    fn deref(&self) -> &H::Target {\n+        self.handle.deref()\n+    }\n+}\n+\n+unsafe impl<O, H> StableAddress for OwningHandle<O, H>\n+    where O: StableAddress, H: StableAddress,\n+{}\n+\n+impl<O, H> DerefMut for OwningHandle<O, H>\n+    where O: StableAddress, H: DerefMut,\n+{\n+    fn deref_mut(&mut self) -> &mut H::Target {\n+        self.handle.deref_mut()\n+    }\n+}\n+\n+/// Trait to implement the conversion of owner to handle for common types.\n+pub trait ToHandle {\n+    /// The type of handle to be encapsulated by the OwningHandle.\n+    type Handle: Deref;\n+\n+    /// Given an appropriately-long-lived pointer to ourselves, create a\n+    /// handle to be encapsulated by the `OwningHandle`.\n+    unsafe fn to_handle(x: *const Self) -> Self::Handle;\n+}\n+\n+/// Trait to implement the conversion of owner to mutable handle for common types.\n+pub trait ToHandleMut {\n+    /// The type of handle to be encapsulated by the OwningHandle.\n+    type HandleMut: DerefMut;\n+\n+    /// Given an appropriately-long-lived pointer to ourselves, create a\n+    /// mutable handle to be encapsulated by the `OwningHandle`.\n+    unsafe fn to_handle_mut(x: *const Self) -> Self::HandleMut;\n+}\n+\n+impl<O, H> OwningHandle<O, H>\n+    where O: StableAddress, O::Target: ToHandle<Handle = H>, H: Deref,\n+{\n+    /// Create a new `OwningHandle` for a type that implements `ToHandle`. For types\n+    /// that don't implement `ToHandle`, callers may invoke `new_with_fn`, which accepts\n+    /// a callback to perform the conversion.\n+    pub fn new(o: O) -> Self {\n+        OwningHandle::new_with_fn(o, |x| unsafe { O::Target::to_handle(x) })\n+    }\n+}\n+\n+impl<O, H> OwningHandle<O, H>\n+    where O: StableAddress, O::Target: ToHandleMut<HandleMut = H>, H: DerefMut,\n+{\n+    /// Create a new mutable `OwningHandle` for a type that implements `ToHandleMut`.\n+    pub fn new_mut(o: O) -> Self {\n+        OwningHandle::new_with_fn(o, |x| unsafe { O::Target::to_handle_mut(x) })\n+    }\n+}\n+\n+impl<O, H> OwningHandle<O, H>\n+    where O: StableAddress, H: Deref,\n+{\n+    /// Create a new OwningHandle. The provided callback will be invoked with\n+    /// a pointer to the object owned by `o`, and the returned value is stored\n+    /// as the object to which this `OwningHandle` will forward `Deref` and\n+    /// `DerefMut`.\n+    pub fn new_with_fn<F>(o: O, f: F) -> Self\n+        where F: FnOnce(*const O::Target) -> H\n+    {\n+        let h: H;\n+        {\n+            h = f(o.deref() as *const O::Target);\n+        }\n+\n+        OwningHandle {\n+          handle: h,\n+          _owner: o,\n+        }\n+    }\n+\n+    /// Create a new OwningHandle. The provided callback will be invoked with\n+    /// a pointer to the object owned by `o`, and the returned value is stored\n+    /// as the object to which this `OwningHandle` will forward `Deref` and\n+    /// `DerefMut`.\n+    pub fn try_new<F, E>(o: O, f: F) -> Result<Self, E>\n+        where F: FnOnce(*const O::Target) -> Result<H, E>\n+    {\n+        let h: H;\n+        {\n+            h = f(o.deref() as *const O::Target)?;\n+        }\n+\n+        Ok(OwningHandle {\n+          handle: h,\n+          _owner: o,\n+        })\n+    }\n+}\n+\n+/////////////////////////////////////////////////////////////////////////////\n+// std traits\n+/////////////////////////////////////////////////////////////////////////////\n+\n+use std::convert::From;\n+use std::fmt::{self, Debug};\n+use std::marker::{Send, Sync};\n+use std::cmp::{Eq, PartialEq, Ord, PartialOrd, Ordering};\n+use std::hash::{Hash, Hasher};\n+use std::borrow::Borrow;\n+\n+impl<O, T: ?Sized> Deref for OwningRef<O, T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        unsafe {\n+            &*self.reference\n+        }\n+    }\n+}\n+\n+impl<O, T: ?Sized> Deref for OwningRefMut<O, T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        unsafe {\n+            &*self.reference\n+        }\n+    }\n+}\n+\n+impl<O, T: ?Sized> DerefMut for OwningRefMut<O, T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        unsafe {\n+            &mut *self.reference\n+        }\n+    }\n+}\n+\n+unsafe impl<O, T: ?Sized> StableAddress for OwningRef<O, T> {}\n+\n+impl<O, T: ?Sized> AsRef<T> for OwningRef<O, T> {\n+    fn as_ref(&self) -> &T {\n+        &*self\n+    }\n+}\n+\n+impl<O, T: ?Sized> AsRef<T> for OwningRefMut<O, T> {\n+    fn as_ref(&self) -> &T {\n+        &*self\n+    }\n+}\n+\n+impl<O, T: ?Sized> AsMut<T> for OwningRefMut<O, T> {\n+    fn as_mut(&mut self) -> &mut T {\n+        &mut *self\n+    }\n+}\n+\n+impl<O, T: ?Sized> Borrow<T> for OwningRef<O, T> {\n+    fn borrow(&self) -> &T {\n+        &*self\n+    }\n+}\n+\n+impl<O, T: ?Sized> From<O> for OwningRef<O, T>\n+    where O: StableAddress,\n+          O: Deref<Target = T>,\n+{\n+    fn from(owner: O) -> Self {\n+        OwningRef::new(owner)\n+    }\n+}\n+\n+impl<O, T: ?Sized> From<O> for OwningRefMut<O, T>\n+    where O: StableAddress,\n+          O: DerefMut<Target = T>\n+{\n+    fn from(owner: O) -> Self {\n+        OwningRefMut::new(owner)\n+    }\n+}\n+\n+impl<O, T: ?Sized> From<OwningRefMut<O, T>> for OwningRef<O, T>\n+    where O: StableAddress,\n+          O: DerefMut<Target = T>\n+{\n+    fn from(other: OwningRefMut<O, T>) -> Self {\n+        OwningRef {\n+            owner: other.owner,\n+            reference: other.reference,\n+        }\n+    }\n+}\n+\n+// ^ FIXME: Is a Into impl for calling into_inner() possible as well?\n+\n+impl<O, T: ?Sized> Debug for OwningRef<O, T>\n+    where O: Debug,\n+          T: Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        write!(f,\n+               \"OwningRef {{ owner: {:?}, reference: {:?} }}\",\n+               self.owner(),\n+               &**self)\n+    }\n+}\n+\n+impl<O, T: ?Sized> Debug for OwningRefMut<O, T>\n+    where O: Debug,\n+          T: Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        write!(f,\n+               \"OwningRefMut {{ owner: {:?}, reference: {:?} }}\",\n+               self.owner(),\n+               &**self)\n+    }\n+}\n+\n+impl<O, T: ?Sized> Clone for OwningRef<O, T>\n+    where O: CloneStableAddress,\n+{\n+    fn clone(&self) -> Self {\n+        OwningRef {\n+            owner: self.owner.clone(),\n+            reference: self.reference,\n+        }\n+    }\n+}\n+\n+unsafe impl<O, T: ?Sized> CloneStableAddress for OwningRef<O, T>\n+    where O: CloneStableAddress {}\n+\n+unsafe impl<O, T: ?Sized> Send for OwningRef<O, T>\n+    where O: Send, for<'a> (&'a T): Send {}\n+unsafe impl<O, T: ?Sized> Sync for OwningRef<O, T>\n+    where O: Sync, for<'a> (&'a T): Sync {}\n+\n+unsafe impl<O, T: ?Sized> Send for OwningRefMut<O, T>\n+    where O: Send, for<'a> (&'a mut T): Send {}\n+unsafe impl<O, T: ?Sized> Sync for OwningRefMut<O, T>\n+    where O: Sync, for<'a> (&'a mut T): Sync {}\n+\n+impl Debug for Erased {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        write!(f, \"<Erased>\",)\n+    }\n+}\n+\n+impl<O, T: ?Sized> PartialEq for OwningRef<O, T> where T: PartialEq {\n+    fn eq(&self, other: &Self) -> bool {\n+        (&*self as &T).eq(&*other as &T)\n+     }\n+}\n+\n+impl<O, T: ?Sized> Eq for OwningRef<O, T> where T: Eq {}\n+\n+impl<O, T: ?Sized> PartialOrd for OwningRef<O, T> where T: PartialOrd {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        (&*self as &T).partial_cmp(&*other as &T)\n+    }\n+}\n+\n+impl<O, T: ?Sized> Ord for OwningRef<O, T> where T: Ord {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        (&*self as &T).cmp(&*other as &T)\n+    }\n+}\n+\n+impl<O, T: ?Sized> Hash for OwningRef<O, T> where T: Hash {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        (&*self as &T).hash(state);\n+    }\n+}\n+\n+impl<O, T: ?Sized> PartialEq for OwningRefMut<O, T> where T: PartialEq {\n+    fn eq(&self, other: &Self) -> bool {\n+        (&*self as &T).eq(&*other as &T)\n+     }\n+}\n+\n+impl<O, T: ?Sized> Eq for OwningRefMut<O, T> where T: Eq {}\n+\n+impl<O, T: ?Sized> PartialOrd for OwningRefMut<O, T> where T: PartialOrd {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        (&*self as &T).partial_cmp(&*other as &T)\n+    }\n+}\n+\n+impl<O, T: ?Sized> Ord for OwningRefMut<O, T> where T: Ord {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        (&*self as &T).cmp(&*other as &T)\n+    }\n+}\n+\n+impl<O, T: ?Sized> Hash for OwningRefMut<O, T> where T: Hash {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        (&*self as &T).hash(state);\n+    }\n+}\n+\n+/////////////////////////////////////////////////////////////////////////////\n+// std types integration and convenience type defs\n+/////////////////////////////////////////////////////////////////////////////\n+\n+use std::boxed::Box;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+use std::sync::{MutexGuard, RwLockReadGuard, RwLockWriteGuard};\n+use std::cell::{Ref, RefCell, RefMut};\n+\n+impl<T: 'static> ToHandle for RefCell<T> {\n+    type Handle = Ref<'static, T>;\n+    unsafe fn to_handle(x: *const Self) -> Self::Handle { (*x).borrow() }\n+}\n+\n+impl<T: 'static> ToHandleMut for RefCell<T> {\n+    type HandleMut = RefMut<'static, T>;\n+    unsafe fn to_handle_mut(x: *const Self) -> Self::HandleMut { (*x).borrow_mut() }\n+}\n+\n+// NB: Implementing ToHandle{,Mut} for Mutex and RwLock requires a decision\n+// about which handle creation to use (i.e. read() vs try_read()) as well as\n+// what to do with error results.\n+\n+/// Typedef of a owning reference that uses a `Box` as the owner.\n+pub type BoxRef<T, U = T> = OwningRef<Box<T>, U>;\n+/// Typedef of a owning reference that uses a `Vec` as the owner.\n+pub type VecRef<T, U = T> = OwningRef<Vec<T>, U>;\n+/// Typedef of a owning reference that uses a `String` as the owner.\n+pub type StringRef = OwningRef<String, str>;\n+\n+/// Typedef of a owning reference that uses a `Rc` as the owner.\n+pub type RcRef<T, U = T> = OwningRef<Rc<T>, U>;\n+/// Typedef of a owning reference that uses a `Arc` as the owner.\n+pub type ArcRef<T, U = T> = OwningRef<Arc<T>, U>;\n+\n+/// Typedef of a owning reference that uses a `Ref` as the owner.\n+pub type RefRef<'a, T, U = T> = OwningRef<Ref<'a, T>, U>;\n+/// Typedef of a owning reference that uses a `RefMut` as the owner.\n+pub type RefMutRef<'a, T, U = T> = OwningRef<RefMut<'a, T>, U>;\n+/// Typedef of a owning reference that uses a `MutexGuard` as the owner.\n+pub type MutexGuardRef<'a, T, U = T> = OwningRef<MutexGuard<'a, T>, U>;\n+/// Typedef of a owning reference that uses a `RwLockReadGuard` as the owner.\n+pub type RwLockReadGuardRef<'a, T, U = T> = OwningRef<RwLockReadGuard<'a, T>, U>;\n+/// Typedef of a owning reference that uses a `RwLockWriteGuard` as the owner.\n+pub type RwLockWriteGuardRef<'a, T, U = T> = OwningRef<RwLockWriteGuard<'a, T>, U>;\n+\n+/// Typedef of a mutable owning reference that uses a `Box` as the owner.\n+pub type BoxRefMut<T, U = T> = OwningRefMut<Box<T>, U>;\n+/// Typedef of a mutable owning reference that uses a `Vec` as the owner.\n+pub type VecRefMut<T, U = T> = OwningRefMut<Vec<T>, U>;\n+/// Typedef of a mutable owning reference that uses a `String` as the owner.\n+pub type StringRefMut = OwningRefMut<String, str>;\n+\n+/// Typedef of a mutable owning reference that uses a `RefMut` as the owner.\n+pub type RefMutRefMut<'a, T, U = T> = OwningRefMut<RefMut<'a, T>, U>;\n+/// Typedef of a mutable owning reference that uses a `MutexGuard` as the owner.\n+pub type MutexGuardRefMut<'a, T, U = T> = OwningRefMut<MutexGuard<'a, T>, U>;\n+/// Typedef of a mutable owning reference that uses a `RwLockWriteGuard` as the owner.\n+pub type RwLockWriteGuardRefMut<'a, T, U = T> = OwningRef<RwLockWriteGuard<'a, T>, U>;\n+\n+unsafe impl<'a, T: 'a> IntoErased<'a> for Box<T> {\n+    type Erased = Box<Erased + 'a>;\n+    fn into_erased(self) -> Self::Erased {\n+        self\n+    }\n+}\n+unsafe impl<'a, T: 'a> IntoErased<'a> for Rc<T> {\n+    type Erased = Rc<Erased + 'a>;\n+    fn into_erased(self) -> Self::Erased {\n+        self\n+    }\n+}\n+unsafe impl<'a, T: 'a> IntoErased<'a> for Arc<T> {\n+    type Erased = Arc<Erased + 'a>;\n+    fn into_erased(self) -> Self::Erased {\n+        self\n+    }\n+}\n+\n+unsafe impl<'a, T: Send + Sync + 'a> IntoErasedSendSync<'a> for Box<T> {\n+    type Erased = Box<Erased + Send + Sync + 'a>;\n+    fn into_erased_send_sync(self) -> Self::Erased {\n+        self\n+    }\n+}\n+\n+unsafe impl<'a, T: Send + Sync + 'a> IntoErasedSendSync<'a> for Arc<T> {\n+    type Erased = Arc<Erased + Send + Sync + 'a>;\n+    fn into_erased_send_sync(self) -> Self::Erased {\n+        self\n+    }\n+}\n+\n+/// Typedef of a owning reference that uses an erased `Box` as the owner.\n+pub type ErasedBoxRef<U> = OwningRef<Box<Erased>, U>;\n+/// Typedef of a owning reference that uses an erased `Rc` as the owner.\n+pub type ErasedRcRef<U> = OwningRef<Rc<Erased>, U>;\n+/// Typedef of a owning reference that uses an erased `Arc` as the owner.\n+pub type ErasedArcRef<U> = OwningRef<Arc<Erased>, U>;\n+\n+/// Typedef of a mutable owning reference that uses an erased `Box` as the owner.\n+pub type ErasedBoxRefMut<U> = OwningRefMut<Box<Erased>, U>;\n+\n+#[cfg(test)]\n+mod tests {\n+    mod owning_ref {\n+        use super::super::OwningRef;\n+        use super::super::{RcRef, BoxRef, Erased, ErasedBoxRef};\n+        use std::cmp::{PartialEq, Ord, PartialOrd, Ordering};\n+        use std::hash::{Hash, Hasher};\n+        use std::collections::hash_map::DefaultHasher;\n+        use std::collections::HashMap;\n+        use std::rc::Rc;\n+\n+        #[derive(Debug, PartialEq)]\n+        struct Example(u32, String, [u8; 3]);\n+        fn example() -> Example {\n+            Example(42, \"hello world\".to_string(), [1, 2, 3])\n+        }\n+\n+        #[test]\n+        fn new_deref() {\n+            let or: OwningRef<Box<()>, ()> = OwningRef::new(Box::new(()));\n+            assert_eq!(&*or, &());\n+        }\n+\n+        #[test]\n+        fn into() {\n+            let or: OwningRef<Box<()>, ()> = Box::new(()).into();\n+            assert_eq!(&*or, &());\n+        }\n+\n+        #[test]\n+        fn map_offset_ref() {\n+            let or: BoxRef<Example> = Box::new(example()).into();\n+            let or: BoxRef<_, u32> = or.map(|x| &x.0);\n+            assert_eq!(&*or, &42);\n+\n+            let or: BoxRef<Example> = Box::new(example()).into();\n+            let or: BoxRef<_, u8> = or.map(|x| &x.2[1]);\n+            assert_eq!(&*or, &2);\n+        }\n+\n+        #[test]\n+        fn map_heap_ref() {\n+            let or: BoxRef<Example> = Box::new(example()).into();\n+            let or: BoxRef<_, str> = or.map(|x| &x.1[..5]);\n+            assert_eq!(&*or, \"hello\");\n+        }\n+\n+        #[test]\n+        fn map_static_ref() {\n+            let or: BoxRef<()> = Box::new(()).into();\n+            let or: BoxRef<_, str> = or.map(|_| \"hello\");\n+            assert_eq!(&*or, \"hello\");\n+        }\n+\n+        #[test]\n+        fn map_chained() {\n+            let or: BoxRef<String> = Box::new(example().1).into();\n+            let or: BoxRef<_, str> = or.map(|x| &x[1..5]);\n+            let or: BoxRef<_, str> = or.map(|x| &x[..2]);\n+            assert_eq!(&*or, \"el\");\n+        }\n+\n+        #[test]\n+        fn map_chained_inference() {\n+            let or = BoxRef::new(Box::new(example().1))\n+                .map(|x| &x[..5])\n+                .map(|x| &x[1..3]);\n+            assert_eq!(&*or, \"el\");\n+        }\n+\n+        #[test]\n+        fn owner() {\n+            let or: BoxRef<String> = Box::new(example().1).into();\n+            let or = or.map(|x| &x[..5]);\n+            assert_eq!(&*or, \"hello\");\n+            assert_eq!(&**or.owner(), \"hello world\");\n+        }\n+\n+        #[test]\n+        fn into_inner() {\n+            let or: BoxRef<String> = Box::new(example().1).into();\n+            let or = or.map(|x| &x[..5]);\n+            assert_eq!(&*or, \"hello\");\n+            let s = *or.into_inner();\n+            assert_eq!(&s, \"hello world\");\n+        }\n+\n+        #[test]\n+        fn fmt_debug() {\n+            let or: BoxRef<String> = Box::new(example().1).into();\n+            let or = or.map(|x| &x[..5]);\n+            let s = format!(\"{:?}\", or);\n+            assert_eq!(&s, \"OwningRef { owner: \\\"hello world\\\", reference: \\\"hello\\\" }\");\n+        }\n+\n+        #[test]\n+        fn erased_owner() {\n+            let o1: BoxRef<Example, str> = BoxRef::new(Box::new(example()))\n+                .map(|x| &x.1[..]);\n+\n+            let o2: BoxRef<String, str> = BoxRef::new(Box::new(example().1))\n+                .map(|x| &x[..]);\n+\n+            let os: Vec<ErasedBoxRef<str>> = vec![o1.erase_owner(), o2.erase_owner()];\n+            assert!(os.iter().all(|e| &e[..] == \"hello world\"));\n+        }\n+\n+        #[test]\n+        fn raii_locks() {\n+            use super::super::{RefRef, RefMutRef};\n+            use std::cell::RefCell;\n+            use super::super::{MutexGuardRef, RwLockReadGuardRef, RwLockWriteGuardRef};\n+            use std::sync::{Mutex, RwLock};\n+\n+            {\n+                let a = RefCell::new(1);\n+                let a = {\n+                    let a = RefRef::new(a.borrow());\n+                    assert_eq!(*a, 1);\n+                    a\n+                };\n+                assert_eq!(*a, 1);\n+                drop(a);\n+            }\n+            {\n+                let a = RefCell::new(1);\n+                let a = {\n+                    let a = RefMutRef::new(a.borrow_mut());\n+                    assert_eq!(*a, 1);\n+                    a\n+                };\n+                assert_eq!(*a, 1);\n+                drop(a);\n+            }\n+            {\n+                let a = Mutex::new(1);\n+                let a = {\n+                    let a = MutexGuardRef::new(a.lock().unwrap());\n+                    assert_eq!(*a, 1);\n+                    a\n+                };\n+                assert_eq!(*a, 1);\n+                drop(a);\n+            }\n+            {\n+                let a = RwLock::new(1);\n+                let a = {\n+                    let a = RwLockReadGuardRef::new(a.read().unwrap());\n+                    assert_eq!(*a, 1);\n+                    a\n+                };\n+                assert_eq!(*a, 1);\n+                drop(a);\n+            }\n+            {\n+                let a = RwLock::new(1);\n+                let a = {\n+                    let a = RwLockWriteGuardRef::new(a.write().unwrap());\n+                    assert_eq!(*a, 1);\n+                    a\n+                };\n+                assert_eq!(*a, 1);\n+                drop(a);\n+            }\n+        }\n+\n+        #[test]\n+        fn eq() {\n+            let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n+            let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n+            assert_eq!(or1.eq(&or2), true);\n+        }\n+\n+        #[test]\n+        fn cmp() {\n+            let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n+            let or2: BoxRef<[u8]> = BoxRef::new(vec![4, 5, 6].into_boxed_slice());\n+            assert_eq!(or1.cmp(&or2), Ordering::Less);\n+        }\n+\n+        #[test]\n+        fn partial_cmp() {\n+            let or1: BoxRef<[u8]> = BoxRef::new(vec![4, 5, 6].into_boxed_slice());\n+            let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n+            assert_eq!(or1.partial_cmp(&or2), Some(Ordering::Greater));\n+        }\n+\n+        #[test]\n+        fn hash() {\n+            let mut h1 = DefaultHasher::new();\n+            let mut h2 = DefaultHasher::new();\n+\n+            let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n+            let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n+\n+            or1.hash(&mut h1);\n+            or2.hash(&mut h2);\n+\n+            assert_eq!(h1.finish(), h2.finish());\n+        }\n+\n+        #[test]\n+        fn borrow() {\n+            let mut hash = HashMap::new();\n+            let     key  = RcRef::<String>::new(Rc::new(\"foo-bar\".to_string())).map(|s| &s[..]);\n+\n+            hash.insert(key.clone().map(|s| &s[..3]), 42);\n+            hash.insert(key.clone().map(|s| &s[4..]), 23);\n+\n+            assert_eq!(hash.get(\"foo\"), Some(&42));\n+            assert_eq!(hash.get(\"bar\"), Some(&23));\n+        }\n+\n+        #[test]\n+        fn total_erase() {\n+            let a: OwningRef<Vec<u8>, [u8]>\n+                = OwningRef::new(vec![]).map(|x| &x[..]);\n+            let b: OwningRef<Box<[u8]>, [u8]>\n+                = OwningRef::new(vec![].into_boxed_slice()).map(|x| &x[..]);\n+\n+            let c: OwningRef<Rc<Vec<u8>>, [u8]> = unsafe {a.map_owner(Rc::new)};\n+            let d: OwningRef<Rc<Box<[u8]>>, [u8]> = unsafe {b.map_owner(Rc::new)};\n+\n+            let e: OwningRef<Rc<Erased>, [u8]> = c.erase_owner();\n+            let f: OwningRef<Rc<Erased>, [u8]> = d.erase_owner();\n+\n+            let _g = e.clone();\n+            let _h = f.clone();\n+        }\n+\n+        #[test]\n+        fn total_erase_box() {\n+            let a: OwningRef<Vec<u8>, [u8]>\n+                = OwningRef::new(vec![]).map(|x| &x[..]);\n+            let b: OwningRef<Box<[u8]>, [u8]>\n+                = OwningRef::new(vec![].into_boxed_slice()).map(|x| &x[..]);\n+\n+            let c: OwningRef<Box<Vec<u8>>, [u8]> = a.map_owner_box();\n+            let d: OwningRef<Box<Box<[u8]>>, [u8]> = b.map_owner_box();\n+\n+            let _e: OwningRef<Box<Erased>, [u8]> = c.erase_owner();\n+            let _f: OwningRef<Box<Erased>, [u8]> = d.erase_owner();\n+        }\n+\n+        #[test]\n+        fn try_map1() {\n+            use std::any::Any;\n+\n+            let x = Box::new(123_i32);\n+            let y: Box<Any> = x;\n+\n+            OwningRef::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_ok();\n+        }\n+\n+        #[test]\n+        fn try_map2() {\n+            use std::any::Any;\n+\n+            let x = Box::new(123_i32);\n+            let y: Box<Any> = x;\n+\n+            OwningRef::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_err();\n+        }\n+    }\n+\n+    mod owning_handle {\n+        use super::super::OwningHandle;\n+        use super::super::RcRef;\n+        use std::rc::Rc;\n+        use std::cell::RefCell;\n+        use std::sync::Arc;\n+        use std::sync::RwLock;\n+\n+        #[test]\n+        fn owning_handle() {\n+            use std::cell::RefCell;\n+            let cell = Rc::new(RefCell::new(2));\n+            let cell_ref = RcRef::new(cell);\n+            let mut handle = OwningHandle::new_with_fn(cell_ref, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n+            assert_eq!(*handle, 2);\n+            *handle = 3;\n+            assert_eq!(*handle, 3);\n+        }\n+\n+        #[test]\n+        fn try_owning_handle_ok() {\n+            use std::cell::RefCell;\n+            let cell = Rc::new(RefCell::new(2));\n+            let cell_ref = RcRef::new(cell);\n+            let mut handle = OwningHandle::try_new::<_, ()>(cell_ref, |x| {\n+                Ok(unsafe {\n+                    x.as_ref()\n+                }.unwrap().borrow_mut())\n+            }).unwrap();\n+            assert_eq!(*handle, 2);\n+            *handle = 3;\n+            assert_eq!(*handle, 3);\n+        }\n+\n+        #[test]\n+        fn try_owning_handle_err() {\n+            use std::cell::RefCell;\n+            let cell = Rc::new(RefCell::new(2));\n+            let cell_ref = RcRef::new(cell);\n+            let handle = OwningHandle::try_new::<_, ()>(cell_ref, |x| {\n+                if false {\n+                    return Ok(unsafe {\n+                        x.as_ref()\n+                    }.unwrap().borrow_mut())\n+                }\n+                Err(())\n+            });\n+            assert!(handle.is_err());\n+        }\n+\n+        #[test]\n+        fn nested() {\n+            use std::cell::RefCell;\n+            use std::sync::{Arc, RwLock};\n+\n+            let result = {\n+                let complex = Rc::new(RefCell::new(Arc::new(RwLock::new(\"someString\"))));\n+                let curr = RcRef::new(complex);\n+                let curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n+                let mut curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().try_write().unwrap());\n+                assert_eq!(*curr, \"someString\");\n+                *curr = \"someOtherString\";\n+                curr\n+            };\n+            assert_eq!(*result, \"someOtherString\");\n+        }\n+\n+        #[test]\n+        fn owning_handle_safe() {\n+            use std::cell::RefCell;\n+            let cell = Rc::new(RefCell::new(2));\n+            let cell_ref = RcRef::new(cell);\n+            let handle = OwningHandle::new(cell_ref);\n+            assert_eq!(*handle, 2);\n+        }\n+\n+        #[test]\n+        fn owning_handle_mut_safe() {\n+            use std::cell::RefCell;\n+            let cell = Rc::new(RefCell::new(2));\n+            let cell_ref = RcRef::new(cell);\n+            let mut handle = OwningHandle::new_mut(cell_ref);\n+            assert_eq!(*handle, 2);\n+            *handle = 3;\n+            assert_eq!(*handle, 3);\n+        }\n+\n+        #[test]\n+        fn owning_handle_safe_2() {\n+            let result = {\n+                let complex = Rc::new(RefCell::new(Arc::new(RwLock::new(\"someString\"))));\n+                let curr = RcRef::new(complex);\n+                let curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n+                let mut curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().try_write().unwrap());\n+                assert_eq!(*curr, \"someString\");\n+                *curr = \"someOtherString\";\n+                curr\n+            };\n+            assert_eq!(*result, \"someOtherString\");\n+        }\n+    }\n+\n+    mod owning_ref_mut {\n+        use super::super::{OwningRefMut, BoxRefMut, Erased, ErasedBoxRefMut};\n+        use super::super::BoxRef;\n+        use std::cmp::{PartialEq, Ord, PartialOrd, Ordering};\n+        use std::hash::{Hash, Hasher};\n+        use std::collections::hash_map::DefaultHasher;\n+        use std::collections::HashMap;\n+\n+        #[derive(Debug, PartialEq)]\n+        struct Example(u32, String, [u8; 3]);\n+        fn example() -> Example {\n+            Example(42, \"hello world\".to_string(), [1, 2, 3])\n+        }\n+\n+        #[test]\n+        fn new_deref() {\n+            let or: OwningRefMut<Box<()>, ()> = OwningRefMut::new(Box::new(()));\n+            assert_eq!(&*or, &());\n+        }\n+\n+        #[test]\n+        fn new_deref_mut() {\n+            let mut or: OwningRefMut<Box<()>, ()> = OwningRefMut::new(Box::new(()));\n+            assert_eq!(&mut *or, &mut ());\n+        }\n+\n+        #[test]\n+        fn mutate() {\n+            let mut or: OwningRefMut<Box<usize>, usize> = OwningRefMut::new(Box::new(0));\n+            assert_eq!(&*or, &0);\n+            *or = 1;\n+            assert_eq!(&*or, &1);\n+        }\n+\n+        #[test]\n+        fn into() {\n+            let or: OwningRefMut<Box<()>, ()> = Box::new(()).into();\n+            assert_eq!(&*or, &());\n+        }\n+\n+        #[test]\n+        fn map_offset_ref() {\n+            let or: BoxRefMut<Example> = Box::new(example()).into();\n+            let or: BoxRef<_, u32> = or.map(|x| &mut x.0);\n+            assert_eq!(&*or, &42);\n+\n+            let or: BoxRefMut<Example> = Box::new(example()).into();\n+            let or: BoxRef<_, u8> = or.map(|x| &mut x.2[1]);\n+            assert_eq!(&*or, &2);\n+        }\n+\n+        #[test]\n+        fn map_heap_ref() {\n+            let or: BoxRefMut<Example> = Box::new(example()).into();\n+            let or: BoxRef<_, str> = or.map(|x| &mut x.1[..5]);\n+            assert_eq!(&*or, \"hello\");\n+        }\n+\n+        #[test]\n+        fn map_static_ref() {\n+            let or: BoxRefMut<()> = Box::new(()).into();\n+            let or: BoxRef<_, str> = or.map(|_| \"hello\");\n+            assert_eq!(&*or, \"hello\");\n+        }\n+\n+        #[test]\n+        fn map_mut_offset_ref() {\n+            let or: BoxRefMut<Example> = Box::new(example()).into();\n+            let or: BoxRefMut<_, u32> = or.map_mut(|x| &mut x.0);\n+            assert_eq!(&*or, &42);\n+\n+            let or: BoxRefMut<Example> = Box::new(example()).into();\n+            let or: BoxRefMut<_, u8> = or.map_mut(|x| &mut x.2[1]);\n+            assert_eq!(&*or, &2);\n+        }\n+\n+        #[test]\n+        fn map_mut_heap_ref() {\n+            let or: BoxRefMut<Example> = Box::new(example()).into();\n+            let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x.1[..5]);\n+            assert_eq!(&*or, \"hello\");\n+        }\n+\n+        #[test]\n+        fn map_mut_static_ref() {\n+            static mut MUT_S: [u8; 5] = *b\"hello\";\n+\n+            let mut_s: &'static mut [u8] = unsafe { &mut MUT_S };\n+\n+            let or: BoxRefMut<()> = Box::new(()).into();\n+            let or: BoxRefMut<_, [u8]> = or.map_mut(move |_| mut_s);\n+            assert_eq!(&*or, b\"hello\");\n+        }\n+\n+        #[test]\n+        fn map_mut_chained() {\n+            let or: BoxRefMut<String> = Box::new(example().1).into();\n+            let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x[1..5]);\n+            let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x[..2]);\n+            assert_eq!(&*or, \"el\");\n+        }\n+\n+        #[test]\n+        fn map_chained_inference() {\n+            let or = BoxRefMut::new(Box::new(example().1))\n+                .map_mut(|x| &mut x[..5])\n+                .map_mut(|x| &mut x[1..3]);\n+            assert_eq!(&*or, \"el\");\n+        }\n+\n+        #[test]\n+        fn try_map_mut() {\n+            let or: BoxRefMut<String> = Box::new(example().1).into();\n+            let or: Result<BoxRefMut<_, str>, ()> = or.try_map_mut(|x| Ok(&mut x[1..5]));\n+            assert_eq!(&*or.unwrap(), \"ello\");\n+\n+            let or: BoxRefMut<String> = Box::new(example().1).into();\n+            let or: Result<BoxRefMut<_, str>, ()> = or.try_map_mut(|_| Err(()));\n+            assert!(or.is_err());\n+        }\n+\n+        #[test]\n+        fn owner() {\n+            let or: BoxRefMut<String> = Box::new(example().1).into();\n+            let or = or.map_mut(|x| &mut x[..5]);\n+            assert_eq!(&*or, \"hello\");\n+            assert_eq!(&**or.owner(), \"hello world\");\n+        }\n+\n+        #[test]\n+        fn into_inner() {\n+            let or: BoxRefMut<String> = Box::new(example().1).into();\n+            let or = or.map_mut(|x| &mut x[..5]);\n+            assert_eq!(&*or, \"hello\");\n+            let s = *or.into_inner();\n+            assert_eq!(&s, \"hello world\");\n+        }\n+\n+        #[test]\n+        fn fmt_debug() {\n+            let or: BoxRefMut<String> = Box::new(example().1).into();\n+            let or = or.map_mut(|x| &mut x[..5]);\n+            let s = format!(\"{:?}\", or);\n+            assert_eq!(&s,\n+                       \"OwningRefMut { owner: \\\"hello world\\\", reference: \\\"hello\\\" }\");\n+        }\n+\n+        #[test]\n+        fn erased_owner() {\n+            let o1: BoxRefMut<Example, str> = BoxRefMut::new(Box::new(example()))\n+                .map_mut(|x| &mut x.1[..]);\n+\n+            let o2: BoxRefMut<String, str> = BoxRefMut::new(Box::new(example().1))\n+                .map_mut(|x| &mut x[..]);\n+\n+            let os: Vec<ErasedBoxRefMut<str>> = vec![o1.erase_owner(), o2.erase_owner()];\n+            assert!(os.iter().all(|e| &e[..] == \"hello world\"));\n+        }\n+\n+        #[test]\n+        fn raii_locks() {\n+            use super::super::RefMutRefMut;\n+            use std::cell::RefCell;\n+            use super::super::{MutexGuardRefMut, RwLockWriteGuardRefMut};\n+            use std::sync::{Mutex, RwLock};\n+\n+            {\n+                let a = RefCell::new(1);\n+                let a = {\n+                    let a = RefMutRefMut::new(a.borrow_mut());\n+                    assert_eq!(*a, 1);\n+                    a\n+                };\n+                assert_eq!(*a, 1);\n+                drop(a);\n+            }\n+            {\n+                let a = Mutex::new(1);\n+                let a = {\n+                    let a = MutexGuardRefMut::new(a.lock().unwrap());\n+                    assert_eq!(*a, 1);\n+                    a\n+                };\n+                assert_eq!(*a, 1);\n+                drop(a);\n+            }\n+            {\n+                let a = RwLock::new(1);\n+                let a = {\n+                    let a = RwLockWriteGuardRefMut::new(a.write().unwrap());\n+                    assert_eq!(*a, 1);\n+                    a\n+                };\n+                assert_eq!(*a, 1);\n+                drop(a);\n+            }\n+        }\n+\n+        #[test]\n+        fn eq() {\n+            let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n+            let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n+            assert_eq!(or1.eq(&or2), true);\n+        }\n+\n+        #[test]\n+        fn cmp() {\n+            let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n+            let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![4, 5, 6].into_boxed_slice());\n+            assert_eq!(or1.cmp(&or2), Ordering::Less);\n+        }\n+\n+        #[test]\n+        fn partial_cmp() {\n+            let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![4, 5, 6].into_boxed_slice());\n+            let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n+            assert_eq!(or1.partial_cmp(&or2), Some(Ordering::Greater));\n+        }\n+\n+        #[test]\n+        fn hash() {\n+            let mut h1 = DefaultHasher::new();\n+            let mut h2 = DefaultHasher::new();\n+\n+            let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n+            let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n+\n+            or1.hash(&mut h1);\n+            or2.hash(&mut h2);\n+\n+            assert_eq!(h1.finish(), h2.finish());\n+        }\n+\n+        #[test]\n+        fn borrow() {\n+            let mut hash = HashMap::new();\n+            let     key1 = BoxRefMut::<String>::new(Box::new(\"foo\".to_string())).map(|s| &s[..]);\n+            let     key2 = BoxRefMut::<String>::new(Box::new(\"bar\".to_string())).map(|s| &s[..]);\n+\n+            hash.insert(key1, 42);\n+            hash.insert(key2, 23);\n+\n+            assert_eq!(hash.get(\"foo\"), Some(&42));\n+            assert_eq!(hash.get(\"bar\"), Some(&23));\n+        }\n+\n+        #[test]\n+        fn total_erase() {\n+            let a: OwningRefMut<Vec<u8>, [u8]>\n+                = OwningRefMut::new(vec![]).map_mut(|x| &mut x[..]);\n+            let b: OwningRefMut<Box<[u8]>, [u8]>\n+                = OwningRefMut::new(vec![].into_boxed_slice()).map_mut(|x| &mut x[..]);\n+\n+            let c: OwningRefMut<Box<Vec<u8>>, [u8]> = unsafe {a.map_owner(Box::new)};\n+            let d: OwningRefMut<Box<Box<[u8]>>, [u8]> = unsafe {b.map_owner(Box::new)};\n+\n+            let _e: OwningRefMut<Box<Erased>, [u8]> = c.erase_owner();\n+            let _f: OwningRefMut<Box<Erased>, [u8]> = d.erase_owner();\n+        }\n+\n+        #[test]\n+        fn total_erase_box() {\n+            let a: OwningRefMut<Vec<u8>, [u8]>\n+                = OwningRefMut::new(vec![]).map_mut(|x| &mut x[..]);\n+            let b: OwningRefMut<Box<[u8]>, [u8]>\n+                = OwningRefMut::new(vec![].into_boxed_slice()).map_mut(|x| &mut x[..]);\n+\n+            let c: OwningRefMut<Box<Vec<u8>>, [u8]> = a.map_owner_box();\n+            let d: OwningRefMut<Box<Box<[u8]>>, [u8]> = b.map_owner_box();\n+\n+            let _e: OwningRefMut<Box<Erased>, [u8]> = c.erase_owner();\n+            let _f: OwningRefMut<Box<Erased>, [u8]> = d.erase_owner();\n+        }\n+\n+        #[test]\n+        fn try_map1() {\n+            use std::any::Any;\n+\n+            let x = Box::new(123_i32);\n+            let y: Box<Any> = x;\n+\n+            OwningRefMut::new(y).try_map_mut(|x| x.downcast_mut::<i32>().ok_or(())).is_ok();\n+        }\n+\n+        #[test]\n+        fn try_map2() {\n+            use std::any::Any;\n+\n+            let x = Box::new(123_i32);\n+            let y: Box<Any> = x;\n+\n+            OwningRefMut::new(y).try_map_mut(|x| x.downcast_mut::<i32>().ok_or(())).is_err();\n+        }\n+\n+        #[test]\n+        fn try_map3() {\n+            use std::any::Any;\n+\n+            let x = Box::new(123_i32);\n+            let y: Box<Any> = x;\n+\n+            OwningRefMut::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_ok();\n+        }\n+\n+        #[test]\n+        fn try_map4() {\n+            use std::any::Any;\n+\n+            let x = Box::new(123_i32);\n+            let y: Box<Any> = x;\n+\n+            OwningRefMut::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_err();\n+        }\n+\n+        #[test]\n+        fn into_owning_ref() {\n+            use super::super::BoxRef;\n+\n+            let or: BoxRefMut<()> = Box::new(()).into();\n+            let or: BoxRef<()> = or.into();\n+            assert_eq!(&*or, &());\n+        }\n+\n+        struct Foo {\n+            u: u32,\n+        }\n+        struct Bar {\n+            f: Foo,\n+        }\n+\n+        #[test]\n+        fn ref_mut() {\n+            use std::cell::RefCell;\n+\n+            let a = RefCell::new(Bar { f: Foo { u: 42 } });\n+            let mut b = OwningRefMut::new(a.borrow_mut());\n+            assert_eq!(b.f.u, 42);\n+            b.f.u = 43;\n+            let mut c = b.map_mut(|x| &mut x.f);\n+            assert_eq!(c.u, 43);\n+            c.u = 44;\n+            let mut d = c.map_mut(|x| &mut x.u);\n+            assert_eq!(*d, 44);\n+            *d = 45;\n+            assert_eq!(*d, 45);\n+        }\n+    }\n+}"}, {"sha": "b1ab4eaa069246d9c0a602a6b3a44673ef0dd855", "filename": "src/librustc_data_structures/sync.rs", "status": "added", "additions": 403, "deletions": 0, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -0,0 +1,403 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This mdoule defines types which are thread safe if cfg!(parallel_queries) is true.\n+//!\n+//! `Lrc` is an alias of either Rc or Arc.\n+//!\n+//! `Lock` is a mutex.\n+//! It internally uses `parking_lot::Mutex` if cfg!(parallel_queries) is true,\n+//! `RefCell` otherwise.\n+//!\n+//! `RwLock` is a read-write lock.\n+//! It internally uses `parking_lot::RwLock` if cfg!(parallel_queries) is true,\n+//! `RefCell` otherwise.\n+//!\n+//! `LockCell` is a thread safe version of `Cell`, with `set` and `get` operations.\n+//! It can never deadlock. It uses `Cell` when\n+//! cfg!(parallel_queries) is false, otherwise it is a `Lock`.\n+//!\n+//! `MTLock` is a mutex which disappears if cfg!(parallel_queries) is false.\n+//!\n+//! `rustc_global!` gives us a way to declare variables which are intended to be\n+//! global for the current rustc session. This currently maps to thread-locals,\n+//! since rustdoc uses the rustc libraries in multiple threads.\n+//! These globals should eventually be moved into the `Session` structure.\n+//!\n+//! `rustc_erase_owner!` erases a OwningRef owner into Erased or Erased + Send + Sync\n+//! depending on the value of cfg!(parallel_queries).\n+\n+use std::cmp::Ordering;\n+use std::fmt::Debug;\n+use std::fmt::Formatter;\n+use std::fmt;\n+use owning_ref::{Erased, OwningRef};\n+\n+cfg_if! {\n+    if #[cfg(not(parallel_queries))] {\n+        pub auto trait Send {}\n+        pub auto trait Sync {}\n+\n+        impl<T: ?Sized> Send for T {}\n+        impl<T: ?Sized> Sync for T {}\n+\n+        #[macro_export]\n+        macro_rules! rustc_erase_owner {\n+            ($v:expr) => {\n+                $v.erase_owner()\n+            }\n+        }\n+\n+        pub type MetadataRef = OwningRef<Box<Erased>, [u8]>;\n+\n+        pub use std::rc::Rc as Lrc;\n+        pub use std::cell::Ref as ReadGuard;\n+        pub use std::cell::RefMut as WriteGuard;\n+        pub use std::cell::RefMut as LockGuard;\n+\n+        pub use std::cell::RefCell as RwLock;\n+        use std::cell::RefCell as InnerLock;\n+\n+        use std::cell::Cell;\n+\n+        #[derive(Debug)]\n+        pub struct MTLock<T>(T);\n+\n+        impl<T> MTLock<T> {\n+            #[inline(always)]\n+            pub fn new(inner: T) -> Self {\n+                MTLock(inner)\n+            }\n+\n+            #[inline(always)]\n+            pub fn into_inner(self) -> T {\n+                self.0\n+            }\n+\n+            #[inline(always)]\n+            pub fn get_mut(&mut self) -> &mut T {\n+                &mut self.0\n+            }\n+\n+            #[inline(always)]\n+            pub fn lock(&self) -> &T {\n+                &self.0\n+            }\n+\n+            #[inline(always)]\n+            pub fn borrow(&self) -> &T {\n+                &self.0\n+            }\n+\n+            #[inline(always)]\n+            pub fn borrow_mut(&self) -> &T {\n+                &self.0\n+            }\n+        }\n+\n+        // FIXME: Probably a bad idea (in the threaded case)\n+        impl<T: Clone> Clone for MTLock<T> {\n+            #[inline]\n+            fn clone(&self) -> Self {\n+                MTLock(self.0.clone())\n+            }\n+        }\n+\n+        pub struct LockCell<T>(Cell<T>);\n+\n+        impl<T> LockCell<T> {\n+            #[inline(always)]\n+            pub fn new(inner: T) -> Self {\n+                LockCell(Cell::new(inner))\n+            }\n+\n+            #[inline(always)]\n+            pub fn into_inner(self) -> T {\n+                self.0.into_inner()\n+            }\n+\n+            #[inline(always)]\n+            pub fn set(&self, new_inner: T) {\n+                self.0.set(new_inner);\n+            }\n+\n+            #[inline(always)]\n+            pub fn get(&self) -> T where T: Copy {\n+                self.0.get()\n+            }\n+\n+            #[inline(always)]\n+            pub fn set_mut(&mut self, new_inner: T) {\n+                self.0.set(new_inner);\n+            }\n+\n+            #[inline(always)]\n+            pub fn get_mut(&mut self) -> T where T: Copy {\n+                self.0.get()\n+            }\n+        }\n+\n+        impl<T> LockCell<Option<T>> {\n+            #[inline(always)]\n+            pub fn take(&self) -> Option<T> {\n+                unsafe { (*self.0.as_ptr()).take() }\n+            }\n+        }\n+    } else {\n+        pub use std::marker::Send as Send;\n+        pub use std::marker::Sync as Sync;\n+\n+        pub use parking_lot::RwLockReadGuard as ReadGuard;\n+        pub use parking_lot::RwLockWriteGuard as WriteGuard;\n+\n+        pub use parking_lot::MutexGuard as LockGuard;\n+\n+        use parking_lot;\n+\n+        pub use std::sync::Arc as Lrc;\n+\n+        pub use self::Lock as MTLock;\n+\n+        use parking_lot::Mutex as InnerLock;\n+\n+        pub type MetadataRef = OwningRef<Box<Erased + Send + Sync>, [u8]>;\n+\n+        /// This makes locks panic if they are already held.\n+        /// It is only useful when you are running in a single thread\n+        const ERROR_CHECKING: bool = false;\n+\n+        #[macro_export]\n+        macro_rules! rustc_erase_owner {\n+            ($v:expr) => {{\n+                let v = $v;\n+                ::rustc_data_structures::sync::assert_send_sync_val(&v);\n+                v.erase_send_sync_owner()\n+            }}\n+        }\n+\n+        pub struct LockCell<T>(Lock<T>);\n+\n+        impl<T> LockCell<T> {\n+            #[inline(always)]\n+            pub fn new(inner: T) -> Self {\n+                LockCell(Lock::new(inner))\n+            }\n+\n+            #[inline(always)]\n+            pub fn into_inner(self) -> T {\n+                self.0.into_inner()\n+            }\n+\n+            #[inline(always)]\n+            pub fn set(&self, new_inner: T) {\n+                *self.0.lock() = new_inner;\n+            }\n+\n+            #[inline(always)]\n+            pub fn get(&self) -> T where T: Copy {\n+                *self.0.lock()\n+            }\n+\n+            #[inline(always)]\n+            pub fn set_mut(&mut self, new_inner: T) {\n+                *self.0.get_mut() = new_inner;\n+            }\n+\n+            #[inline(always)]\n+            pub fn get_mut(&mut self) -> T where T: Copy {\n+                *self.0.get_mut()\n+            }\n+        }\n+\n+        impl<T> LockCell<Option<T>> {\n+            #[inline(always)]\n+            pub fn take(&self) -> Option<T> {\n+                self.0.lock().take()\n+            }\n+        }\n+\n+        #[derive(Debug)]\n+        pub struct RwLock<T>(parking_lot::RwLock<T>);\n+\n+        impl<T> RwLock<T> {\n+            #[inline(always)]\n+            pub fn new(inner: T) -> Self {\n+                RwLock(parking_lot::RwLock::new(inner))\n+            }\n+\n+            #[inline(always)]\n+            pub fn borrow(&self) -> ReadGuard<T> {\n+                if ERROR_CHECKING {\n+                    self.0.try_read().expect(\"lock was already held\")\n+                } else {\n+                    self.0.read()\n+                }\n+            }\n+\n+            #[inline(always)]\n+            pub fn borrow_mut(&self) -> WriteGuard<T> {\n+                if ERROR_CHECKING {\n+                    self.0.try_write().expect(\"lock was already held\")\n+                } else {\n+                    self.0.write()\n+                }\n+            }\n+        }\n+\n+        // FIXME: Probably a bad idea\n+        impl<T: Clone> Clone for RwLock<T> {\n+            #[inline]\n+            fn clone(&self) -> Self {\n+                RwLock::new(self.borrow().clone())\n+            }\n+        }\n+    }\n+}\n+\n+pub fn assert_sync<T: ?Sized + Sync>() {}\n+pub fn assert_send_sync_val<T: ?Sized + Sync + Send>(_t: &T) {}\n+\n+#[macro_export]\n+#[allow_internal_unstable]\n+macro_rules! rustc_global {\n+    // empty (base case for the recursion)\n+    () => {};\n+\n+    // process multiple declarations\n+    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr; $($rest:tt)*) => (\n+        thread_local!($(#[$attr])* $vis static $name: $t = $init);\n+        rustc_global!($($rest)*);\n+    );\n+\n+    // handle a single declaration\n+    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr) => (\n+        thread_local!($(#[$attr])* $vis static $name: $t = $init);\n+    );\n+}\n+\n+#[macro_export]\n+macro_rules! rustc_access_global {\n+    ($name:path, $callback:expr) => {\n+        $name.with($callback)\n+    }\n+}\n+\n+impl<T: Copy + Debug> Debug for LockCell<T> {\n+    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n+        f.debug_struct(\"LockCell\")\n+            .field(\"value\", &self.get())\n+            .finish()\n+    }\n+}\n+\n+impl<T:Default> Default for LockCell<T> {\n+    /// Creates a `LockCell<T>`, with the `Default` value for T.\n+    #[inline]\n+    fn default() -> LockCell<T> {\n+        LockCell::new(Default::default())\n+    }\n+}\n+\n+impl<T:PartialEq + Copy> PartialEq for LockCell<T> {\n+    #[inline]\n+    fn eq(&self, other: &LockCell<T>) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+impl<T:Eq + Copy> Eq for LockCell<T> {}\n+\n+impl<T:PartialOrd + Copy> PartialOrd for LockCell<T> {\n+    #[inline]\n+    fn partial_cmp(&self, other: &LockCell<T>) -> Option<Ordering> {\n+        self.get().partial_cmp(&other.get())\n+    }\n+\n+    #[inline]\n+    fn lt(&self, other: &LockCell<T>) -> bool {\n+        self.get() < other.get()\n+    }\n+\n+    #[inline]\n+    fn le(&self, other: &LockCell<T>) -> bool {\n+        self.get() <= other.get()\n+    }\n+\n+    #[inline]\n+    fn gt(&self, other: &LockCell<T>) -> bool {\n+        self.get() > other.get()\n+    }\n+\n+    #[inline]\n+    fn ge(&self, other: &LockCell<T>) -> bool {\n+        self.get() >= other.get()\n+    }\n+}\n+\n+impl<T:Ord + Copy> Ord for LockCell<T> {\n+    #[inline]\n+    fn cmp(&self, other: &LockCell<T>) -> Ordering {\n+        self.get().cmp(&other.get())\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct Lock<T>(InnerLock<T>);\n+\n+impl<T> Lock<T> {\n+    #[inline(always)]\n+    pub fn new(inner: T) -> Self {\n+        Lock(InnerLock::new(inner))\n+    }\n+\n+    #[inline(always)]\n+    pub fn into_inner(self) -> T {\n+        self.0.into_inner()\n+    }\n+\n+    #[inline(always)]\n+    pub fn get_mut(&mut self) -> &mut T {\n+        self.0.get_mut()\n+    }\n+\n+    #[cfg(parallel_queries)]\n+    #[inline(always)]\n+    pub fn lock(&self) -> LockGuard<T> {\n+        if ERROR_CHECKING {\n+            self.0.try_lock().expect(\"lock was already held\")\n+        } else {\n+            self.0.lock()\n+        }\n+    }\n+\n+    #[cfg(not(parallel_queries))]\n+    #[inline(always)]\n+    pub fn lock(&self) -> LockGuard<T> {\n+        self.0.borrow_mut()\n+    }\n+\n+    #[inline(always)]\n+    pub fn borrow(&self) -> LockGuard<T> {\n+        self.lock()\n+    }\n+\n+    #[inline(always)]\n+    pub fn borrow_mut(&self) -> LockGuard<T> {\n+        self.lock()\n+    }\n+}\n+\n+// FIXME: Probably a bad idea\n+impl<T: Clone> Clone for Lock<T> {\n+    #[inline]\n+    fn clone(&self) -> Self {\n+        Lock::new(self.borrow().clone())\n+    }\n+}"}, {"sha": "04c0f9b35184ec2e3600ca17ca312107d80d5a1d", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -12,7 +12,6 @@ crate-type = [\"dylib\"]\n arena = { path = \"../libarena\" }\n graphviz = { path = \"../libgraphviz\" }\n log = { version = \"0.3\", features = [\"release_max_level_info\"] }\n-owning_ref = \"0.3.3\"\n env_logger = { version = \"0.4\", default-features = false }\n rustc = { path = \"../librustc\" }\n rustc_allocator = { path = \"../librustc_allocator\" }"}, {"sha": "3d61bc102e2512097c55c146b61f4fce01bb2307", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -11,7 +11,6 @@ crate-type = [\"dylib\"]\n [dependencies]\n flate2 = \"0.2\"\n log = \"0.3\"\n-owning_ref = \"0.3.3\"\n proc_macro = { path = \"../libproc_macro\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }"}, {"sha": "87e41cae60d66f408a044b5f75a85a4185e396db", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -24,7 +24,7 @@ use rustc::util::nodemap::{FxHashMap, FxHashSet, NodeMap};\n \n use std::cell::{RefCell, Cell};\n use std::rc::Rc;\n-use owning_ref::ErasedBoxRef;\n+use rustc_data_structures::owning_ref::ErasedBoxRef;\n use syntax::{ast, attr};\n use syntax::ext::base::SyntaxExtension;\n use syntax::symbol::Symbol;"}, {"sha": "a65ddcecf8874fb6841bc52607402d9196b17385", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -31,7 +31,6 @@ extern crate syntax;\n extern crate syntax_pos;\n extern crate flate2;\n extern crate serialize as rustc_serialize; // used by deriving\n-extern crate owning_ref;\n extern crate rustc_errors as errors;\n extern crate syntax_ext;\n extern crate proc_macro;"}, {"sha": "90c469eea843dca2532655c8ba5e93689adb4163", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -243,7 +243,7 @@ use std::path::{Path, PathBuf};\n use std::time::Instant;\n \n use flate2::read::DeflateDecoder;\n-use owning_ref::{ErasedBoxRef, OwningRef};\n+use rustc_data_structures::owning_ref::{ErasedBoxRef, OwningRef};\n \n pub struct CrateMismatch {\n     path: PathBuf,"}, {"sha": "131cf59a571842b11c775c2929b9754bc0143924", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -15,7 +15,6 @@ flate2 = \"0.2\"\n jobserver = \"0.1.5\"\n log = \"0.3\"\n num_cpus = \"1.0\"\n-owning_ref = \"0.3.3\"\n rustc = { path = \"../librustc\" }\n rustc-demangle = \"0.1.4\"\n rustc_allocator = { path = \"../librustc_allocator\" }"}, {"sha": "f6cc1215699c6f3611f4768ed886be407ad2babf", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -40,7 +40,6 @@ use syntax_pos::symbol::Symbol;\n extern crate bitflags;\n extern crate flate2;\n extern crate libc;\n-extern crate owning_ref;\n #[macro_use] extern crate rustc;\n extern crate jobserver;\n extern crate num_cpus;"}, {"sha": "d57624da0c68df76c053593855bce55843fb9347", "filename": "src/librustc_trans/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_trans%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_trans%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmetadata.rs?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -15,7 +15,7 @@ use llvm;\n use llvm::{False, ObjectFile, mk_section_iter};\n use llvm::archive_ro::ArchiveRO;\n \n-use owning_ref::{ErasedBoxRef, OwningRef};\n+use rustc_data_structures::owning_ref::{ErasedBoxRef, OwningRef};\n use std::path::Path;\n use std::ptr;\n use std::slice;"}, {"sha": "cab44778baabe04ceed2d7d22a08aa5998cc6a3c", "filename": "src/librustc_trans_utils/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_trans_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_trans_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2FCargo.toml?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -12,7 +12,6 @@ test = false\n [dependencies]\n ar = \"0.3.0\"\n flate2 = \"0.2\"\n-owning_ref = \"0.3.3\"\n log = \"0.3\"\n \n syntax = { path = \"../libsyntax\" }"}, {"sha": "3a42462e41e56013fa973355335a4aafa1d76ac1", "filename": "src/librustc_trans_utils/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_trans_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_trans_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flib.rs?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -29,7 +29,6 @@\n \n extern crate ar;\n extern crate flate2;\n-extern crate owning_ref;\n #[macro_use]\n extern crate log;\n "}, {"sha": "800c3063c025c5e254de6918b023049bb5140ff3", "filename": "src/librustc_trans_utils/trans_crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Ftrans_crate.rs?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -28,7 +28,7 @@ use std::fs::File;\n use std::path::Path;\n use std::sync::mpsc;\n \n-use owning_ref::{ErasedBoxRef, OwningRef};\n+use rustc_data_structures::owning_ref::{ErasedBoxRef, OwningRef};\n use ar::{Archive, Builder, Header};\n use flate2::Compression;\n use flate2::write::DeflateEncoder;"}, {"sha": "61d71986b03ebc544f2f07fafe6c2f11409516de", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af57acef1cd1651861be0bfe77b4f4dd3066ce02/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=af57acef1cd1651861be0bfe77b4f4dd3066ce02", "patch": "@@ -56,6 +56,7 @@ fn filter_dirs(path: &Path) -> bool {\n         \"src/llvm\",\n         \"src/libbacktrace\",\n         \"src/libcompiler_builtins\",\n+        \"src/librustc_data_structures/owning_ref\",\n         \"src/compiler-rt\",\n         \"src/liblibc\",\n         \"src/vendor\","}]}