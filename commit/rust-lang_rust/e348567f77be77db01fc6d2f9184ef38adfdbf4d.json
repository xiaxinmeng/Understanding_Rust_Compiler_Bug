{"sha": "e348567f77be77db01fc6d2f9184ef38adfdbf4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzNDg1NjdmNzdiZTc3ZGIwMWZjNmQyZjkxODRlZjM4YWRmZGJmNGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-12T04:45:18Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-27T23:57:50Z"}, "message": "new, simpler approach to the iter library", "tree": {"sha": "506459b46a38cfb7b0f4d53cc37caeb5bc12e34b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/506459b46a38cfb7b0f4d53cc37caeb5bc12e34b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e348567f77be77db01fc6d2f9184ef38adfdbf4d", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e348567f77be77db01fc6d2f9184ef38adfdbf4d", "html_url": "https://github.com/rust-lang/rust/commit/e348567f77be77db01fc6d2f9184ef38adfdbf4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e348567f77be77db01fc6d2f9184ef38adfdbf4d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5eca3c2210964e8987fea250224544b22a6f6520", "url": "https://api.github.com/repos/rust-lang/rust/commits/5eca3c2210964e8987fea250224544b22a6f6520", "html_url": "https://github.com/rust-lang/rust/commit/5eca3c2210964e8987fea250224544b22a6f6520"}], "stats": {"total": 480, "additions": 320, "deletions": 160}, "files": [{"sha": "fa423809404ea05a0564d5e173183ac276282423", "filename": "src/libcore/core.rc", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=e348567f77be77db01fc6d2f9184ef38adfdbf4d", "patch": "@@ -42,6 +42,9 @@ export extfmt;\n export tuple;\n export to_str;\n \n+// NDM seems to be necessary for resolve to work\n+export vec_iter, option_iter;\n+\n // FIXME: This creates some APIs that I do not want to commit to. It is\n // currently exported for the uv code in std, but when that code moves into\n // core this should become unexported\n@@ -144,16 +147,25 @@ mod f64;\n mod str;\n mod ptr;\n mod vec;\n+#[path=\"iter-trait\"]\n+mod vec_iter {\n+    #[path = \"vec.rs\"]\n+    mod inst;\n+}\n mod bool;\n mod tuple;\n \n-\n // Ubiquitous-utility-type modules\n \n mod either;\n mod iter;\n mod logging;\n mod option;\n+#[path=\"iter-trait\"]\n+mod option_iter {\n+    #[path = \"option.rs\"]\n+    mod inst;\n+}\n mod result;\n mod to_str;\n \n@@ -195,5 +207,4 @@ mod cmath;\n // indent-tabs-mode: nil\n // c-basic-offset: 4\n // buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:"}, {"sha": "8681f7d2a1ca787e36a011d4d17a670f62148270", "filename": "src/libcore/core.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=e348567f77be77db01fc6d2f9184ef38adfdbf4d", "patch": "@@ -7,7 +7,9 @@ import option = option::option;\n import path = path::path;\n import str::extensions;\n import vec::extensions;\n+import vec_iter::extensions;\n import option::extensions;\n+import option_iter::extensions;\n import ptr::extensions;\n \n export path, option, some, none, unreachable;"}, {"sha": "8c23bb0ac54f520740b6c42aa5eadab09745da6e", "filename": "src/libcore/iter-trait.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=e348567f77be77db01fc6d2f9184ef38adfdbf4d", "patch": "@@ -0,0 +1,35 @@\n+// This makes use of a clever hack that brson came up with to\n+// workaround our lack of traits and lack of macros.  See core.{rc,rs} for\n+// how this file is used.\n+\n+import inst::{IMPL_T, EACH, SIZE_HINT};\n+export extensions;\n+\n+impl extensions<A> of iter::base_iter<A> for IMPL_T<A> {\n+    fn each(blk: fn(A) -> bool) { EACH(self, blk) }\n+    fn size_hint() -> option<uint> { SIZE_HINT(self) }\n+    fn eachi(blk: fn(uint, A) -> bool) { iter::eachi(self, blk) }\n+    fn all(blk: fn(A) -> bool) -> bool { iter::all(self, blk) }\n+    fn any(blk: fn(A) -> bool) -> bool { iter::any(self, blk) }\n+    fn foldl<B>(+b0: B, blk: fn(B, A) -> B) -> B {\n+        iter::foldl(self, b0, blk)\n+    }\n+    fn contains(x: A) -> bool { iter::contains(self, x) }\n+    fn count(x: A) -> uint { iter::count(self, x) }\n+}\n+\n+impl extensions<A:copy> for IMPL_T<A> {\n+    fn filter_to_vec(pred: fn(A) -> bool) -> [A] {\n+        iter::filter_to_vec(self, pred)\n+    }\n+    fn map_to_vec<B>(op: fn(A) -> B) -> [B] { iter::map_to_vec(self, op) }\n+    fn to_vec() -> [A] { iter::to_vec(self) }\n+\n+    // FIXME--bug in resolve prevents this from working\n+    // fn flat_map_to_vec<B:copy,IB:base_iter<B>>(op: fn(A) -> IB) -> [B] {\n+    //     iter::flat_map_to_vec(self, op)\n+    // }\n+\n+    fn min() -> A { iter::min(self) }\n+    fn max() -> A { iter::max(self) }\n+}"}, {"sha": "530de27c614c62cf0301466a7479d68b670848aa", "filename": "src/libcore/iter-trait/option.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Flibcore%2Fiter-trait%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Flibcore%2Fiter-trait%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Foption.rs?ref=e348567f77be77db01fc6d2f9184ef38adfdbf4d", "patch": "@@ -0,0 +1,15 @@\n+type IMPL_T<A> = option<A>;\n+\n+fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n+    alt self {\n+      none { }\n+      some(a) { f(a); }\n+    }\n+}\n+\n+fn SIZE_HINT<A>(self: IMPL_T<A>) -> option<uint> {\n+    alt self {\n+      none { some(0u) }\n+      some(_) { some(1u) }\n+    }\n+}"}, {"sha": "62f9458303b70065edf94ffc378a6bf4b90c2110", "filename": "src/libcore/iter-trait/vec.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Flibcore%2Fiter-trait%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Flibcore%2Fiter-trait%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fvec.rs?ref=e348567f77be77db01fc6d2f9184ef38adfdbf4d", "patch": "@@ -0,0 +1,9 @@\n+type IMPL_T<A> = [const A];\n+\n+fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n+    vec::each(self, f)\n+}\n+\n+fn SIZE_HINT<A>(self: IMPL_T<A>) -> option<uint> {\n+    some(vec::len(self))\n+}"}, {"sha": "80ccfc1422ed19694530874605ce8d744f11d6d8", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 51, "deletions": 83, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=e348567f77be77db01fc6d2f9184ef38adfdbf4d", "patch": "@@ -1,115 +1,81 @@\n-iface iterable<A> {\n-    fn iter(blk: fn(A));\n+iface base_iter<A> {\n+    fn each(blk: fn(A) -> bool);\n+    fn size_hint() -> option<uint>;\n }\n \n-impl<A> of iterable<A> for fn@(fn(A)) {\n-    fn iter(blk: fn(A)) {\n-        self(blk);\n-    }\n-}\n-\n-// accomodate the fact that int/uint are passed by value by default:\n-impl of iterable<int> for fn@(fn(int)) {\n-    fn iter(blk: fn(&&int)) {\n-        self {|i| blk(i)}\n-    }\n-}\n-\n-impl of iterable<uint> for fn@(fn(uint)) {\n-    fn iter(blk: fn(&&uint)) {\n-        self {|i| blk(i)}\n-    }\n-}\n-\n-impl<A> of iterable<A> for [A] {\n-    fn iter(blk: fn(A)) {\n-        vec::iter(self, blk)\n-    }\n-}\n-\n-impl<A> of iterable<A> for option<A> {\n-    fn iter(blk: fn(A)) {\n-        option::iter(self, blk)\n-    }\n-}\n-\n-impl of iterable<char> for str {\n-    fn iter(blk: fn(&&char)) {\n-        str::chars_iter(self) { |ch| blk(ch) }\n-    }\n-}\n-\n-fn enumerate<A,IA:iterable<A>>(self: IA, blk: fn(uint, A)) {\n+fn eachi<A,IA:base_iter<A>>(self: IA, blk: fn(uint, A) -> bool) {\n     let mut i = 0u;\n-    self.iter {|a|\n-        blk(i, a);\n+    for self.each {|a|\n+        if !blk(i, a) { break; }\n         i += 1u;\n     }\n }\n \n-// Here: we have to use fn@ for predicates and map functions, because\n-// we will be binding them up into a closure.  Disappointing.  A true\n-// region type system might be able to do better than this.\n-\n-fn filter<A,IA:iterable<A>>(self: IA, prd: fn@(A) -> bool, blk: fn(A)) {\n-    self.iter {|a|\n-        if prd(a) { blk(a) }\n+fn all<A,IA:base_iter<A>>(self: IA, blk: fn(A) -> bool) -> bool {\n+    for self.each {|a|\n+        if !blk(a) { ret false; }\n     }\n+    ret true;\n }\n \n-fn filter_map<A,B,IA:iterable<A>>(self: IA, cnv: fn@(A) -> option<B>,\n-                                  blk: fn(B)) {\n-    self.iter {|a|\n-        alt cnv(a) {\n-          some(b) { blk(b) }\n-          none { }\n-        }\n+fn any<A,IA:base_iter<A>>(self: IA, blk: fn(A) -> bool) -> bool {\n+    for self.each {|a|\n+        if blk(a) { ret true; }\n     }\n+    ret false;\n }\n \n-fn map<A,B,IA:iterable<A>>(self: IA, cnv: fn@(A) -> B, blk: fn(B)) {\n-    self.iter {|a|\n-        let b = cnv(a);\n-        blk(b);\n+fn filter_to_vec<A:copy,IA:base_iter<A>>(self: IA,\n+                                         prd: fn(A) -> bool) -> [A] {\n+    let mut result = [];\n+    self.size_hint().iter {|hint| vec::reserve(result, hint); }\n+    for self.each {|a|\n+        if prd(a) { vec::push(result, a); }\n     }\n+    ret result;\n }\n \n-fn flat_map<A,B,IA:iterable<A>,IB:iterable<B>>(\n-    self: IA, cnv: fn@(A) -> IB, blk: fn(B)) {\n-    self.iter {|a|\n-        cnv(a).iter(blk)\n+fn map_to_vec<A:copy,B,IA:base_iter<A>>(self: IA, op: fn(A) -> B) -> [B] {\n+    let mut result = [];\n+    self.size_hint().iter {|hint| vec::reserve(result, hint); }\n+    for self.each {|a|\n+        vec::push(result, op(a));\n     }\n+    ret result;\n }\n \n-fn foldl<A,B,IA:iterable<A>>(self: IA, +b0: B, blk: fn(B, A) -> B) -> B {\n-    let mut b <- b0;\n-    self.iter {|a|\n-        b <- blk(b, a);\n+fn flat_map_to_vec<A:copy,B:copy,IA:base_iter<A>,IB:base_iter<B>>(\n+    self: IA, op: fn(A) -> IB) -> [B] {\n+\n+    let mut result = [];\n+    for self.each {|a|\n+        for op(a).each {|b|\n+            vec::push(result, b);\n+        }\n     }\n-    ret b;\n+    ret result;\n }\n \n-fn foldr<A:copy,B,IA:iterable<A>>(\n-    self: IA, +b0: B, blk: fn(A, B) -> B) -> B {\n-\n+fn foldl<A,B,IA:base_iter<A>>(self: IA, +b0: B, blk: fn(B, A) -> B) -> B {\n     let mut b <- b0;\n-    reversed(self) {|a|\n-        b <- blk(a, b);\n+    for self.each {|a|\n+        b = blk(b, a);\n     }\n     ret b;\n }\n \n-fn to_vec<A:copy,IA:iterable<A>>(self: IA) -> [A] {\n+fn to_vec<A:copy,IA:base_iter<A>>(self: IA) -> [A] {\n     foldl::<A,[A],IA>(self, [], {|r, a| r + [a]})\n }\n \n-// FIXME: This could be made more efficient with an riterable interface\n-// #2005\n-fn reversed<A:copy,IA:iterable<A>>(self: IA, blk: fn(A)) {\n-    vec::riter(to_vec(self), blk)\n+fn contains<A,IA:base_iter<A>>(self: IA, x: A) -> bool {\n+    for self.each {|a|\n+        if a == x { ret true; }\n+    }\n+    ret false;\n }\n \n-fn count<A,IA:iterable<A>>(self: IA, x: A) -> uint {\n+fn count<A,IA:base_iter<A>>(self: IA, x: A) -> uint {\n     foldl(self, 0u) {|count, value|\n         if value == x {\n             count + 1u\n@@ -127,7 +93,7 @@ fn repeat(times: uint, blk: fn()) {\n     }\n }\n \n-fn min<A:copy,IA:iterable<A>>(self: IA) -> A {\n+fn min<A:copy,IA:base_iter<A>>(self: IA) -> A {\n     alt foldl::<A,option<A>,IA>(self, none) {|a, b|\n         alt a {\n           some(a_) if a_ < b {\n@@ -143,7 +109,7 @@ fn min<A:copy,IA:iterable<A>>(self: IA) -> A {\n     }\n }\n \n-fn max<A:copy,IA:iterable<A>>(self: IA) -> A {\n+fn max<A:copy,IA:base_iter<A>>(self: IA) -> A {\n     alt foldl::<A,option<A>,IA>(self, none) {|a, b|\n         alt a {\n           some(a_) if a_ > b {\n@@ -159,6 +125,7 @@ fn max<A:copy,IA:iterable<A>>(self: IA) -> A {\n     }\n }\n \n+/*\n #[test]\n fn test_enumerate() {\n     enumerate([\"0\", \"1\", \"2\"]) {|i,j|\n@@ -296,4 +263,5 @@ fn test_foldr() {\n     }\n     let sum = foldr([1, 2, 3, 4], 0, sub);\n     assert sum == -2;\n-}\n\\ No newline at end of file\n+}\n+*/"}, {"sha": "3cf4bc9232168fb950ba7ad35c14e92b37cbe43b", "filename": "src/libcore/option.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=e348567f77be77db01fc6d2f9184ef38adfdbf4d", "patch": "@@ -101,23 +101,6 @@ impl extensions<T:copy> for option<T> {\n     #[doc = \"Performs an operation on the contained value or does nothing\"]\n     fn iter(f: fn(T)) { iter(self, f) }\n \n-    #[doc = \"Converts `none` to a zero-element list and `some` to a \\\n-             one-element list.\"]\n-    fn to_vec() -> [T] {\n-        alt self {\n-          some(t) { [t] }\n-          none { [] }\n-        }\n-    }\n-\n-    #[doc = \"Performs an operation on the contained value or does nothing\"]\n-    fn each(f: fn(T) -> bool) {\n-        alt self {\n-          none { /* ok */ }\n-          some(e) { f(e); }\n-        }\n-    }\n-\n     #[doc = \"\n     Gets the value out of an option\n "}, {"sha": "ad1c3f2344ab916d57d7d96a5afe74417be4a313", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 15, "deletions": 50, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=e348567f77be77db01fc6d2f9184ef38adfdbf4d", "patch": "@@ -494,7 +494,7 @@ holds.\n Apply function `f` to each element of `v` and return a vector containing\n only those elements for which `f` returned true.\n \"]\n-fn filter<T: copy>(v: [T], f: fn(T) -> bool) -> [T] {\n+fn filter<T: copy>(v: [const T], f: fn(T) -> bool) -> [T] {\n     let mut result = [];\n     for each(v) {|elem|\n         if f(elem) { result += [elem]; }\n@@ -970,23 +970,6 @@ fn unpack_slice<T,U>(s: [const T]/&, f: fn(*T, uint) -> U) -> U unsafe {\n \n #[doc = \"Extension methods for vectors\"]\n impl extensions<T> for [const T] {\n-    #[doc = \"\n-    Return true if a vector contains an element with the given value\n-    \"]\n-    #[inline]\n-    fn contains(x: T) -> bool { contains(self, x) }\n-    #[doc = \"Returns the number of elements that are equal to a given value\"]\n-    #[inline]\n-    fn count(x: T) -> uint { count(self, x) }\n-    #[doc = \"Iterates over a vector, with option to break\"]\n-    #[inline]\n-    fn each<T>(f: fn(T) -> bool) { each(self, f) }\n-    #[doc = \"Iterates over a vector's elements and indices\"]\n-    #[inline]\n-    fn eachi<T>(f: fn(uint, T) -> bool) { eachi(self, f) }\n-    #[doc = \"Reduce a vector from left to right\"]\n-    #[inline]\n-    fn foldl<U: copy>(z: U, p: fn(U, T) -> U) -> U { foldl(z, self, p) }\n     #[doc = \"Reduce a vector from right to left\"]\n     #[inline]\n     fn foldr<U: copy>(z: U, p: fn(T, U) -> U) -> U { foldr(self, z, p) }\n@@ -1059,6 +1042,15 @@ impl extensions<T> for [const T] {\n \n #[doc = \"Extension methods for vectors\"]\n impl extensions<T: copy> for [const T] {\n+    #[doc = \"\n+    Construct a new vector from the elements of a vector for which some\n+    predicate holds.\n+\n+    Apply function `f` to each element of `v` and return a vector containing\n+    only those elements for which `f` returned true.\n+    \"]\n+    #[inline]\n+    fn filter(f: fn(T) -> bool) -> [T] { filter(self, f) }\n     #[doc = \"\n     Search for the first element that matches a given predicate\n \n@@ -1099,19 +1091,16 @@ impl extensions<T: copy> for [const T] {\n #[doc = \"Extension methods for vectors\"]\n impl extensions<T> for [T] {\n     #[doc = \"\n-    Return true if a predicate matches all elements\n-\n-    If the vector contains no elements then true is returned.\n+    Apply a function to each element of a vector and return the results\n     \"]\n     #[inline]\n-    fn all(f: fn(T) -> bool) -> bool { all(self, f) }\n+    fn map<U>(f: fn(T) -> U) -> [U] { map(self, f) }\n     #[doc = \"\n-    Return true if a predicate matches any elements\n-\n-    If the vector contains no elements then false is returned.\n+    Apply a function to each element of a vector and return a concatenation\n+    of each result vector\n     \"]\n     #[inline]\n-    fn any(f: fn(T) -> bool) -> bool { any(self, f) }\n+    fn flat_map<U>(f: fn(T) -> [U]) -> [U] { flat_map(self, f) }\n     #[doc = \"\n     Apply a function to each element of a vector and return the results\n \n@@ -1122,32 +1111,8 @@ impl extensions<T> for [T] {\n     fn filter_map<U: copy>(f: fn(T) -> option<U>) -> [U] {\n         filter_map(self, f)\n     }\n-    #[doc = \"\n-    Apply a function eo each element of a vector and return a concatenation\n-    of each result vector\n-    \"]\n-    #[inline]\n-    fn flat_map<U>(f: fn(T) -> [U]) -> [U] { flat_map(self, f) }\n-    #[doc = \"\n-    Apply a function to each element of a vector and return the results\n-    \"]\n-    #[inline]\n-    fn map<U>(f: fn(T) -> U) -> [U] { map(self, f) }\n }\n \n-#[doc = \"Extension methods for vectors\"]\n-impl extensions<T: copy> for [T] {\n-    #[doc = \"\n-    Construct a new vector from the elements of a vector for which some\n-    predicate holds.\n-\n-    Apply function `f` to each element of `v` and return a vector containing\n-    only those elements for which `f` returned true.\n-    \"]\n-   #[inline]\n-    fn filter(f: fn(T) -> bool) -> [T] { filter(self, f) }\n- }\n-\n #[doc = \"Unsafe operations\"]\n mod unsafe {\n     // FIXME: This should have crate visibility (#1893 blocks that)"}, {"sha": "bd0d8d916ddf00ccd765a852bb46bc68804a9e14", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=e348567f77be77db01fc6d2f9184ef38adfdbf4d", "patch": "@@ -7,14 +7,14 @@ fn start(+token: int) {\n     import iter::*;\n \n     let p = comm::port();\n-    let ch = iter::foldl(bind int::range(2, n_threads + 1, _),\n-                         comm::chan(p)) { |ch, i|\n+    let mut ch = comm::chan(p);\n+    int::range(2, n_threads + 1) { |i|\n         let id = n_threads + 2 - i;\n         let to_child = task::spawn_listener::<int> {|p|\n             roundtrip(id, p, ch)\n         };\n-        to_child\n-    };\n+        ch = to_child;\n+    }\n     comm::send(ch, token);\n     roundtrip(1, p, ch);\n }"}, {"sha": "8b59d12783b6906f3e515076ac2f5f0219c28496", "filename": "src/test/compile-fail/lub-in-args.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Fcompile-fail%2Flub-in-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Fcompile-fail%2Flub-in-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-in-args.rs?ref=e348567f77be77db01fc6d2f9184ef38adfdbf4d", "patch": "@@ -0,0 +1,17 @@\n+fn two_args<T>(x: T, y: T) { }\n+\n+fn main() {\n+    let x: [mut int] = [mut 3];\n+    let y: [int] = [3];\n+    let a: @mut int = @mut 3;\n+    let b: @int = @3;\n+\n+    // NOTE:\n+    //\n+    // The fact that this test fails to compile reflects a known\n+    // shortcoming of the current inference algorithm.  These errors\n+    // are *not* desirable.\n+\n+    two_args(x, y); //! ERROR (values differ in mutability)\n+    two_args(a, b); //! ERROR (values differ in mutability)\n+}\n\\ No newline at end of file"}, {"sha": "eba99e3d86caff9cef4c7591ccce1de73d5daac0", "filename": "src/test/run-pass/issue-2185.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fissue-2185.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fissue-2185.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2185.rs?ref=e348567f77be77db01fc6d2f9184ef38adfdbf4d", "patch": "@@ -1,10 +1,40 @@\n-import iter::*;\n+// This test had to do with an outdated version of the iterable iface.\n+// However, the condition it was testing seemed complex enough to\n+// warrant still having a test, so I inlined the old definitions.\n+\n+iface iterable<A> {\n+    fn iter(blk: fn(A));\n+}\n+\n+impl<A> of iterable<A> for fn@(fn(A)) {\n+    fn iter(blk: fn(A)) { self(blk); }\n+}\n+\n+impl of iterable<uint> for fn@(fn(uint)) {\n+    fn iter(blk: fn(&&uint)) { self { |i| blk(i) } }\n+}\n+\n+fn filter<A,IA:iterable<A>>(self: IA, prd: fn@(A) -> bool, blk: fn(A)) {\n+    self.iter {|a|\n+        if prd(a) { blk(a) }\n+    }\n+}\n+\n+fn foldl<A,B,IA:iterable<A>>(self: IA, +b0: B, blk: fn(B, A) -> B) -> B {\n+    let mut b <- b0;\n+    self.iter { |a|\n+        b <- blk(b, a);\n+    }\n+    ret b;\n+}\n \n fn main() {\n     let range = bind uint::range(0u, 1000u, _);\n-    let filt = bind iter::filter(range, {|&&n: uint|\n-        n % 3u != 0u && n % 5u != 0u }, _);\n-    let sum = iter::foldl(filt, 0u) {|accum, &&n: uint| accum + n };\n+    let filt = bind filter(\n+        range,\n+        {|&&n: uint| n % 3u != 0u && n % 5u != 0u },\n+        _);\n+    let sum = foldl(filt, 0u) {|accum, &&n: uint| accum + n };\n \n     io::println(#fmt(\"%u\", sum));\n }\n\\ No newline at end of file"}, {"sha": "1de45c97d197ba77c8e9446372ce83de490794e3", "filename": "src/test/run-pass/iter-all.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fiter-all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fiter-all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-all.rs?ref=e348567f77be77db01fc6d2f9184ef38adfdbf4d", "patch": "@@ -0,0 +1,11 @@\n+fn is_even(&&x: uint) -> bool { (x % 2u) == 0u }\n+\n+fn main() {\n+    assert ![1u, 2u].all(is_even);\n+    assert [2u, 4u].all(is_even);\n+    assert [].all(is_even);\n+\n+    assert !some(1u).all(is_even);\n+    assert some(2u).all(is_even);\n+    assert none.all(is_even);\n+}\n\\ No newline at end of file"}, {"sha": "40cd8a18039e305d8020c3a64f70d8c40f789544", "filename": "src/test/run-pass/iter-any.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fiter-any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fiter-any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-any.rs?ref=e348567f77be77db01fc6d2f9184ef38adfdbf4d", "patch": "@@ -0,0 +1,11 @@\n+fn is_even(&&x: uint) -> bool { (x % 2u) == 0u }\n+\n+fn main() {\n+    assert ![1u, 3u].any(is_even);\n+    assert [1u, 2u].any(is_even);\n+    assert ![].any(is_even);\n+\n+    assert !some(1u).any(is_even);\n+    assert some(2u).any(is_even);\n+    assert !none.any(is_even);\n+}\n\\ No newline at end of file"}, {"sha": "5af80d47a109d1c6adef9f1ab3364c5cfec8b1cb", "filename": "src/test/run-pass/iter-contains.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fiter-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fiter-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-contains.rs?ref=e348567f77be77db01fc6d2f9184ef38adfdbf4d", "patch": "@@ -0,0 +1,10 @@\n+fn main() {\n+    assert [].contains(22u) == false;\n+    assert [1u, 3u].contains(22u) == false;\n+    assert [22u, 1u, 3u].contains(22u) == true;\n+    assert [1u, 22u, 3u].contains(22u) == true;\n+    assert [1u, 3u, 22u].contains(22u) == true;\n+    assert none.contains(22u) == false;\n+    assert some(1u).contains(22u) == false;\n+    assert some(22u).contains(22u) == true;\n+}\n\\ No newline at end of file"}, {"sha": "54c9c1e2b7323d37b9f2c0ef5b7a3b8c4a7dafd8", "filename": "src/test/run-pass/iter-count.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fiter-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fiter-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-count.rs?ref=e348567f77be77db01fc6d2f9184ef38adfdbf4d", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+    assert [].count(22u) == 0u;\n+    assert [1u, 3u].count(22u) == 0u;\n+    assert [22u, 1u, 3u].count(22u) == 1u;\n+    assert [22u, 1u, 22u].count(22u) == 2u;\n+    assert none.count(22u) == 0u;\n+    assert some(1u).count(22u) == 0u;\n+    assert some(22u).count(22u) == 1u;\n+}\n\\ No newline at end of file"}, {"sha": "30efd24a55fd988e09ce4e0f670c48c3981cf2a5", "filename": "src/test/run-pass/iter-eachi.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fiter-eachi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fiter-eachi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-eachi.rs?ref=e348567f77be77db01fc6d2f9184ef38adfdbf4d", "patch": "@@ -0,0 +1,18 @@\n+fn main() {\n+    let mut c = 0u;\n+    for [1u, 2u, 3u, 4u, 5u].eachi { |i, v|\n+        assert (i + 1u) == v;\n+        c += 1u;\n+    }\n+    assert c == 5u;\n+\n+    for none::<uint>.eachi { |i, v| fail; }\n+\n+    let mut c = 0u;\n+    for some(1u).eachi { |i, v|\n+        assert (i + 1u) == v;\n+        c += 1u;\n+    }\n+    assert c == 1u;\n+\n+}\n\\ No newline at end of file"}, {"sha": "91b4eeffe7d10c162e44aff411b9588f2bdab300", "filename": "src/test/run-pass/iter-filter-to-vec.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fiter-filter-to-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fiter-filter-to-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-filter-to-vec.rs?ref=e348567f77be77db01fc6d2f9184ef38adfdbf4d", "patch": "@@ -0,0 +1,9 @@\n+fn is_even(&&x: uint) -> bool { (x % 2u) == 0u }\n+\n+fn main() {\n+    assert [1u, 3u].filter_to_vec(is_even) == [];\n+    assert [1u, 2u, 3u].filter_to_vec(is_even) == [2u];\n+    assert none.filter_to_vec(is_even) == [];\n+    assert some(1u).filter_to_vec(is_even) == [];\n+    assert some(2u).filter_to_vec(is_even) == [2u];\n+}\n\\ No newline at end of file"}, {"sha": "d4395b487f44245594fd9ead2cb557af8a1da95d", "filename": "src/test/run-pass/iter-flat-map-to-vec.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fiter-flat-map-to-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fiter-flat-map-to-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-flat-map-to-vec.rs?ref=e348567f77be77db01fc6d2f9184ef38adfdbf4d", "patch": "@@ -0,0 +1,21 @@\n+// xfail-test -- flat_map_to_vec currently disable\n+\n+fn repeat(&&x: uint) -> [uint] { [x, x] }\n+\n+fn incd_if_even(&&x: uint) -> option<uint> {\n+    if (x % 2u) == 0u {some(x + 1u)} else {none}\n+}\n+\n+fn main() {\n+    assert [1u, 3u].flat_map_to_vec(repeat) == [1u, 1u, 3u, 3u];\n+    assert [].flat_map_to_vec(repeat) == [];\n+    assert none.flat_map_to_vec(repeat) == [];\n+    assert some(1u).flat_map_to_vec(repeat) == [1u, 1u];\n+    assert some(2u).flat_map_to_vec(repeat) == [2u, 2u];\n+\n+    assert [1u, 2u, 5u].flat_map_to_vec(incd_if_even) == [3u];\n+    assert [].flat_map_to_vec(incd_if_even) == [];\n+    assert none.flat_map_to_vec(incd_if_even) == [];\n+    assert some(1u).flat_map_to_vec(incd_if_even) == [];\n+    assert some(2u).flat_map_to_vec(incd_if_even) == [3u];\n+}\n\\ No newline at end of file"}, {"sha": "9f5fafcd5bc92fdc40d1fae0e61c787ea3121964", "filename": "src/test/run-pass/iter-foldl.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fiter-foldl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fiter-foldl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-foldl.rs?ref=e348567f77be77db01fc6d2f9184ef38adfdbf4d", "patch": "@@ -0,0 +1,9 @@\n+fn add(&&x: float, &&y: uint) -> float { x + (y as float) }\n+\n+fn main() {\n+    assert [1u, 3u].foldl(20f, add) == 24f;\n+    assert [].foldl(20f, add) == 20f;\n+    assert none.foldl(20f, add) == 20f;\n+    assert some(1u).foldl(20f, add) == 21f;\n+    assert some(2u).foldl(20f, add) == 22f;\n+}\n\\ No newline at end of file"}, {"sha": "ea98196fbdd657987676893be2e9c9e384d34153", "filename": "src/test/run-pass/iter-map-to-vec.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fiter-map-to-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fiter-map-to-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-map-to-vec.rs?ref=e348567f77be77db01fc6d2f9184ef38adfdbf4d", "patch": "@@ -0,0 +1,9 @@\n+fn inc(&&x: uint) -> uint { x + 1u }\n+\n+fn main() {\n+    assert [1u, 3u].map_to_vec(inc) == [2u, 4u];\n+    assert [1u, 2u, 3u].map_to_vec(inc) == [2u, 3u, 4u];\n+    assert none.map_to_vec(inc) == [];\n+    assert some(1u).map_to_vec(inc) == [2u];\n+    assert some(2u).map_to_vec(inc) == [3u];\n+}\n\\ No newline at end of file"}, {"sha": "338ba795111b2ea96ad2a328380fa5af91ae002d", "filename": "src/test/run-pass/iter-min-max.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fiter-min-max.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fiter-min-max.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-min-max.rs?ref=e348567f77be77db01fc6d2f9184ef38adfdbf4d", "patch": "@@ -0,0 +1,11 @@\n+fn is_even(&&x: uint) -> bool { (x % 2u) == 0u }\n+\n+fn main() {\n+    assert [1u, 3u].min() == 1u;\n+    assert [3u, 1u].min() == 1u;\n+    assert some(1u).min() == 1u;\n+\n+    assert [1u, 3u].max() == 3u;\n+    assert [3u, 1u].max() == 3u;\n+    assert some(3u).max() == 3u;\n+}\n\\ No newline at end of file"}, {"sha": "1f7afdb1c7be7bd9da2e2c1373b2860a845e429d", "filename": "src/test/run-pass/iter-to-vec.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fiter-to-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e348567f77be77db01fc6d2f9184ef38adfdbf4d/src%2Ftest%2Frun-pass%2Fiter-to-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-to-vec.rs?ref=e348567f77be77db01fc6d2f9184ef38adfdbf4d", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    assert [1u, 3u].to_vec() == [1u, 3u];\n+    assert [].to_vec() == [];\n+    assert none.to_vec() == [];\n+    assert some(1u).to_vec() == [1u];\n+    assert some(2u).to_vec() == [2u];\n+}\n\\ No newline at end of file"}]}