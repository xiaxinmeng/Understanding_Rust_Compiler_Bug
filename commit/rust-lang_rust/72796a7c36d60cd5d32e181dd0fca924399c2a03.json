{"sha": "72796a7c36d60cd5d32e181dd0fca924399c2a03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyNzk2YTdjMzZkNjBjZDVkMzJlMTgxZGQwZmNhOTI0Mzk5YzJhMDM=", "commit": {"author": {"name": "lukaslueg", "email": "lukas.lueg@gmail.com", "date": "2021-04-06T16:23:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-06T16:23:21Z"}, "message": "Merge branch 'master' into stab_peek_mut", "tree": {"sha": "157b3a3527632082291a2c17b39d22ab5395cfe1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/157b3a3527632082291a2c17b39d22ab5395cfe1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72796a7c36d60cd5d32e181dd0fca924399c2a03", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgbIr5CRBK7hj4Ov3rIwAAdHIIABMRiiUKYLNxkD7eyJzC3pns\nBkdMmLZBRTPA/IXdVFfI8FXwqSlWH8WUsoJOw2shxluc6OXqg+zfSC0V2Psjuhu+\ncCmUEgepm7+qR3U8WjiX7TeTcrK2Om2iPCr3SQ9eI4ibiK30F13Q1/i2QRlugdtA\nvWe/E3m7lDAWCKCM9W9meE+BesVZstxQJcyver6+3JjM2IiNtL0fBsvIkn0+GZEK\nyleJume0uuQ3dPmup++vg7/pMiOsGEzPmZ0KNKpyDSo01hhjylADy9vWxLuvMS0q\nj1bqyc8k03SAj8LAnFV1wWNQvamDrefrUanzz3m66UoRhWnHXaDQoCOac0lfcf8=\n=52jJ\n-----END PGP SIGNATURE-----\n", "payload": "tree 157b3a3527632082291a2c17b39d22ab5395cfe1\nparent 7f32fda78c60bb5b05e610a1c0c0fecaff07f497\nparent 5c897d430dcbec6b10a9925f7de054dbc0ad3c52\nauthor lukaslueg <lukas.lueg@gmail.com> 1617726201 +0200\ncommitter GitHub <noreply@github.com> 1617726201 +0200\n\nMerge branch 'master' into stab_peek_mut"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72796a7c36d60cd5d32e181dd0fca924399c2a03", "html_url": "https://github.com/rust-lang/rust/commit/72796a7c36d60cd5d32e181dd0fca924399c2a03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72796a7c36d60cd5d32e181dd0fca924399c2a03/comments", "author": {"login": "lukaslueg", "id": 3148704, "node_id": "MDQ6VXNlcjMxNDg3MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3148704?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lukaslueg", "html_url": "https://github.com/lukaslueg", "followers_url": "https://api.github.com/users/lukaslueg/followers", "following_url": "https://api.github.com/users/lukaslueg/following{/other_user}", "gists_url": "https://api.github.com/users/lukaslueg/gists{/gist_id}", "starred_url": "https://api.github.com/users/lukaslueg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lukaslueg/subscriptions", "organizations_url": "https://api.github.com/users/lukaslueg/orgs", "repos_url": "https://api.github.com/users/lukaslueg/repos", "events_url": "https://api.github.com/users/lukaslueg/events{/privacy}", "received_events_url": "https://api.github.com/users/lukaslueg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f32fda78c60bb5b05e610a1c0c0fecaff07f497", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f32fda78c60bb5b05e610a1c0c0fecaff07f497", "html_url": "https://github.com/rust-lang/rust/commit/7f32fda78c60bb5b05e610a1c0c0fecaff07f497"}, {"sha": "5c897d430dcbec6b10a9925f7de054dbc0ad3c52", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c897d430dcbec6b10a9925f7de054dbc0ad3c52", "html_url": "https://github.com/rust-lang/rust/commit/5c897d430dcbec6b10a9925f7de054dbc0ad3c52"}], "stats": {"total": 53540, "additions": 16303, "deletions": 37237}, "files": [{"sha": "51a670b5fbefdaf7904f1d304ea482b0543bc9a9", "filename": ".gitattributes", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -9,6 +9,7 @@\n src/etc/installer/gfx/* binary\n src/vendor/** -text\n Cargo.lock linguist-generated=false\n+config.toml.example linguist-language=TOML\n \n # Older git versions try to fix line endings on images and fonts, this prevents it.\n *.png binary"}, {"sha": "1019710dc979335b0395ff2308fc958d038492fd", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -286,7 +286,7 @@ Xuefeng Wu <benewu@gmail.com> Xuefeng Wu <xfwu@thoughtworks.com>\n Xuefeng Wu <benewu@gmail.com> XuefengWu <benewu@gmail.com>\n York Xiang <bombless@126.com>\n Youngsoo Son <ysson83@gmail.com> <ysoo.son@samsung.com>\n-Yuki Okushi <huyuumi.dev@gmail.com>\n+Yuki Okushi <jtitor@2k36.org> <huyuumi.dev@gmail.com>\n Zach Pomerantz <zmp@umich.edu>\n Zack Corr <zack@z0w0.me> <zackcorr95@gmail.com>\n Zack Slayton <zack.slayton@gmail.com>"}, {"sha": "2b7fbf1b647d23bd4784cd9af06c240b091355bc", "filename": "Cargo.lock", "status": "modified", "additions": 127, "deletions": 95, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,5 +1,7 @@\n # This file is automatically @generated by Cargo.\n # It is not intended for manual editing.\n+version = 3\n+\n [[package]]\n name = \"addr2line\"\n version = \"0.14.0\"\n@@ -252,11 +254,11 @@ checksum = \"e3b5ca7a04898ad4bcd41c90c5285445ff5b791899bb1b0abdd2a2aa791211d7\"\n \n [[package]]\n name = \"bytecount\"\n-version = \"0.6.0\"\n+version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b0017894339f586ccb943b01b9555de56770c11cda818e7e3d8bd93f4ed7f46e\"\n+checksum = \"72feb31ffc86498dacdbd0fcebb56138e7177a8cc5cea4516031d15ae85a742e\"\n dependencies = [\n- \"packed_simd\",\n+ \"packed_simd_2\",\n ]\n \n [[package]]\n@@ -279,19 +281,18 @@ checksum = \"81a18687293a1546b67c246452202bbbf143d239cb43494cc163da14979082da\"\n \n [[package]]\n name = \"cargo\"\n-version = \"0.53.0\"\n+version = \"0.54.0\"\n dependencies = [\n  \"anyhow\",\n  \"atty\",\n  \"bytesize\",\n  \"cargo-platform\",\n  \"cargo-test-macro\",\n  \"cargo-test-support\",\n+ \"cargo-util\",\n  \"clap\",\n- \"core-foundation\",\n  \"crates-io\",\n  \"crossbeam-utils 0.8.0\",\n- \"crypto-hash\",\n  \"curl\",\n  \"curl-sys\",\n  \"env_logger 0.8.1\",\n@@ -313,7 +314,6 @@ dependencies = [\n  \"libgit2-sys\",\n  \"log\",\n  \"memchr\",\n- \"miow 0.3.6\",\n  \"num_cpus\",\n  \"opener\",\n  \"openssl\",\n@@ -322,7 +322,6 @@ dependencies = [\n  \"rand 0.8.3\",\n  \"rustc-workspace-hack\",\n  \"rustfix\",\n- \"same-file\",\n  \"semver 0.10.0\",\n  \"serde\",\n  \"serde_ignored\",\n@@ -396,8 +395,9 @@ version = \"0.1.0\"\n name = \"cargo-test-support\"\n version = \"0.1.0\"\n dependencies = [\n- \"cargo\",\n+ \"anyhow\",\n  \"cargo-test-macro\",\n+ \"cargo-util\",\n  \"filetime\",\n  \"flate2\",\n  \"git2\",\n@@ -410,6 +410,26 @@ dependencies = [\n  \"url 2.1.1\",\n ]\n \n+[[package]]\n+name = \"cargo-util\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"core-foundation\",\n+ \"crypto-hash\",\n+ \"filetime\",\n+ \"hex 0.4.2\",\n+ \"jobserver\",\n+ \"libc\",\n+ \"log\",\n+ \"miow 0.3.6\",\n+ \"same-file\",\n+ \"shell-escape\",\n+ \"tempfile\",\n+ \"walkdir\",\n+ \"winapi 0.3.9\",\n+]\n+\n [[package]]\n name = \"cargo_metadata\"\n version = \"0.8.2\"\n@@ -562,7 +582,7 @@ dependencies = [\n  \"cargo_metadata 0.12.0\",\n  \"clippy-mini-macro-test\",\n  \"clippy_lints\",\n- \"compiletest_rs 0.6.0\",\n+ \"compiletest_rs\",\n  \"derive-new\",\n  \"quote\",\n  \"regex\",\n@@ -572,7 +592,7 @@ dependencies = [\n  \"serde\",\n  \"syn\",\n  \"tempfile\",\n- \"tester 0.9.0\",\n+ \"tester\",\n ]\n \n [[package]]\n@@ -610,15 +630,6 @@ dependencies = [\n  \"unicode-normalization\",\n ]\n \n-[[package]]\n-name = \"cloudabi\"\n-version = \"0.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4344512281c643ae7638bbabc3af17a11307803ec8f0fcad9fae512a8bf36467\"\n-dependencies = [\n- \"bitflags\",\n-]\n-\n [[package]]\n name = \"cmake\"\n version = \"0.1.44\"\n@@ -689,28 +700,6 @@ dependencies = [\n  \"winapi 0.3.9\",\n ]\n \n-[[package]]\n-name = \"compiletest_rs\"\n-version = \"0.5.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9f737835bfbbe29ed1ff82d5137520338d7ed5bf1a1d4b9c1c7c58bb45b8fa29\"\n-dependencies = [\n- \"diff\",\n- \"filetime\",\n- \"getopts\",\n- \"libc\",\n- \"log\",\n- \"miow 0.3.6\",\n- \"regex\",\n- \"rustfix\",\n- \"serde\",\n- \"serde_derive\",\n- \"serde_json\",\n- \"tempfile\",\n- \"tester 0.7.0\",\n- \"winapi 0.3.9\",\n-]\n-\n [[package]]\n name = \"compiletest_rs\"\n version = \"0.6.0\"\n@@ -730,7 +719,7 @@ dependencies = [\n  \"serde_derive\",\n  \"serde_json\",\n  \"tempfile\",\n- \"tester 0.9.0\",\n+ \"tester\",\n  \"winapi 0.3.9\",\n ]\n \n@@ -1083,6 +1072,26 @@ dependencies = [\n  \"log\",\n ]\n \n+[[package]]\n+name = \"enum-iterator\"\n+version = \"0.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c79a6321a1197d7730510c7e3f6cb80432dfefecb32426de8cea0aa19b4bb8d7\"\n+dependencies = [\n+ \"enum-iterator-derive\",\n+]\n+\n+[[package]]\n+name = \"enum-iterator-derive\"\n+version = \"0.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1e94aa31f7c0dc764f57896dc615ddd76fc13b0d5dca7eb6cc5e018a5a09ec06\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"env_logger\"\n version = \"0.6.2\"\n@@ -1428,6 +1437,18 @@ dependencies = [\n  \"wasi\",\n ]\n \n+[[package]]\n+name = \"getset\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"24b328c01a4d71d2d8173daa93562a73ab0fe85616876f02500f53d82948c504\"\n+dependencies = [\n+ \"proc-macro-error\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"gimli\"\n version = \"0.23.0\"\n@@ -1721,17 +1742,6 @@ version = \"0.4.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dc6f3ad7b9d11a0c00842ff8de1b60ee58661048eb8049ed33c73594f359d7e6\"\n \n-[[package]]\n-name = \"jemalloc-sys\"\n-version = \"0.3.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0d3b9f3f5c9b31aa0f5ed3260385ac205db665baa41d49bb8338008ae94ede45\"\n-dependencies = [\n- \"cc\",\n- \"fs_extra\",\n- \"libc\",\n-]\n-\n [[package]]\n name = \"jobserver\"\n version = \"0.1.21\"\n@@ -1920,6 +1930,12 @@ dependencies = [\n  \"pkg-config\",\n ]\n \n+[[package]]\n+name = \"libm\"\n+version = \"0.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7fc7aa29613bd6a620df431842069224d8bc9011086b1db4c0e0cd47fa03ec9a\"\n+\n [[package]]\n name = \"libnghttp2-sys\"\n version = \"0.1.4+1.41.0\"\n@@ -2298,13 +2314,13 @@ name = \"miri\"\n version = \"0.1.0\"\n dependencies = [\n  \"colored\",\n- \"compiletest_rs 0.5.0\",\n- \"env_logger 0.7.1\",\n+ \"compiletest_rs\",\n+ \"env_logger 0.8.1\",\n  \"getrandom 0.2.0\",\n  \"hex 0.4.2\",\n  \"libc\",\n  \"log\",\n- \"rand 0.7.3\",\n+ \"rand 0.8.3\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n  \"shell-escape\",\n@@ -2463,12 +2479,13 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"packed_simd\"\n-version = \"0.3.3\"\n+name = \"packed_simd_2\"\n+version = \"0.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a85ea9fc0d4ac0deb6fe7911d38786b32fc11119afd9e9d38b84ff691ce64220\"\n+checksum = \"3278e0492f961fd4ae70909f56b2723a7e8d01a228427294e19cdfdebda89a17\"\n dependencies = [\n  \"cfg-if 0.1.10\",\n+ \"libm\",\n ]\n \n [[package]]\n@@ -2511,9 +2528,9 @@ dependencies = [\n \n [[package]]\n name = \"parking_lot\"\n-version = \"0.11.0\"\n+version = \"0.11.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a4893845fa2ca272e647da5d0e46660a314ead9c2fdd9a883aabc32e481a8733\"\n+checksum = \"6d7744ac029df22dca6284efe4e898991d28e3085c706c972bcd7da4a27a15eb\"\n dependencies = [\n  \"instant\",\n  \"lock_api\",\n@@ -2522,15 +2539,14 @@ dependencies = [\n \n [[package]]\n name = \"parking_lot_core\"\n-version = \"0.8.0\"\n+version = \"0.8.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c361aa727dd08437f2f1447be8b59a33b0edd15e0fcee698f935613d9efbca9b\"\n+checksum = \"fa7a782938e745763fe6907fc6ba86946d72f49fe7e21de074e08128a99fb018\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n- \"cloudabi\",\n+ \"cfg-if 1.0.0\",\n  \"instant\",\n  \"libc\",\n- \"redox_syscall 0.1.57\",\n+ \"redox_syscall 0.2.5\",\n  \"smallvec 1.6.1\",\n  \"winapi 0.3.9\",\n ]\n@@ -2769,9 +2785,9 @@ checksum = \"bc881b2c22681370c6a780e47af9840ef841837bc98118431d4e1868bd0c1086\"\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.19\"\n+version = \"1.0.24\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"04f5f085b5d71e2188cb8271e5da0161ad52c3f227a661a3c135fdf28e258b12\"\n+checksum = \"1e0704ee1a7e00d7bb417d0770ea303c1bccbabf0ef1667dae92b5967f5f8a71\"\n dependencies = [\n  \"unicode-xid\",\n ]\n@@ -3569,9 +3585,10 @@ checksum = \"08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2\"\n name = \"rustc-main\"\n version = \"0.0.0\"\n dependencies = [\n- \"jemalloc-sys\",\n  \"rustc_codegen_ssa\",\n  \"rustc_driver\",\n+ \"tikv-jemalloc-sys\",\n+ \"tikv-jemallocator\",\n ]\n \n [[package]]\n@@ -3795,7 +3812,6 @@ dependencies = [\n  \"itertools 0.9.0\",\n  \"jobserver\",\n  \"libc\",\n- \"memmap2\",\n  \"pathdiff\",\n  \"rustc_apfloat\",\n  \"rustc_ast\",\n@@ -3830,6 +3846,7 @@ dependencies = [\n  \"jobserver\",\n  \"libc\",\n  \"measureme\",\n+ \"memmap2\",\n  \"parking_lot\",\n  \"rustc-hash\",\n  \"rustc-rayon\",\n@@ -4129,7 +4146,6 @@ name = \"rustc_metadata\"\n version = \"0.0.0\"\n dependencies = [\n  \"libc\",\n- \"memmap2\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n@@ -4575,11 +4591,11 @@ dependencies = [\n \n [[package]]\n name = \"rustc_version\"\n-version = \"0.2.3\"\n+version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\"\n+checksum = \"f0dfe2087c51c460008730de8b57e6a320782fbfb312e1f4d520e6c6fae155ee\"\n dependencies = [\n- \"semver 0.9.0\",\n+ \"semver 0.11.0\",\n ]\n \n [[package]]\n@@ -4797,18 +4813,18 @@ dependencies = [\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.118\"\n+version = \"1.0.125\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"06c64263859d87aa2eb554587e2d23183398d617427327cf2b3d0ed8c69e4800\"\n+checksum = \"558dc50e1a5a5fa7112ca2ce4effcb321b0300c0d4ccf0776a9f60cd89031171\"\n dependencies = [\n  \"serde_derive\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.118\"\n+version = \"1.0.125\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c84d3526699cd55261af4b941e4e725444df67aa4f9e6a3564f18030d12672df\"\n+checksum = \"b093b7a2bb58203b5da3056c05b4ec1fed827dcfdb37347a8841695263b3d06d\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -5104,9 +5120,9 @@ dependencies = [\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.38\"\n+version = \"1.0.65\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e69abc24912995b3038597a7a593be5053eb0fb44f3cc5beec0deb421790c1f4\"\n+checksum = \"f3a1d708c221c5a612956ef9f75b37e454e88d1f7b899fbd3a18d4252012d663\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -5225,17 +5241,6 @@ dependencies = [\n  \"term 0.0.0\",\n ]\n \n-[[package]]\n-name = \"tester\"\n-version = \"0.7.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ee72ec31009a42b53de9a6b7d8f462b493ab3b1e4767bda1fcdbb52127f13b6c\"\n-dependencies = [\n- \"getopts\",\n- \"libc\",\n- \"term 0.6.1\",\n-]\n-\n [[package]]\n name = \"tester\"\n version = \"0.9.0\"\n@@ -5292,6 +5297,7 @@ name = \"tidy\"\n version = \"0.1.0\"\n dependencies = [\n  \"cargo_metadata 0.11.1\",\n+ \"crossbeam-utils 0.8.0\",\n  \"lazy_static\",\n  \"regex\",\n  \"walkdir\",\n@@ -5301,6 +5307,27 @@ dependencies = [\n name = \"tier-check\"\n version = \"0.1.0\"\n \n+[[package]]\n+name = \"tikv-jemalloc-sys\"\n+version = \"0.4.1+5.2.1-patched\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8a26331b05179d4cb505c8d6814a7e18d298972f0a551b0e3cefccff927f86d3\"\n+dependencies = [\n+ \"cc\",\n+ \"fs_extra\",\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"tikv-jemallocator\"\n+version = \"0.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3c14a5a604eb8715bc5785018a37d00739b180bcf609916ddf4393d33d49ccdf\"\n+dependencies = [\n+ \"libc\",\n+ \"tikv-jemalloc-sys\",\n+]\n+\n [[package]]\n name = \"time\"\n version = \"0.1.43\"\n@@ -5648,12 +5675,17 @@ checksum = \"f1bddf1187be692e79c5ffeab891132dfb0f236ed36a43c7ed39f1165ee20191\"\n \n [[package]]\n name = \"vergen\"\n-version = \"3.1.0\"\n+version = \"5.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4ce50d8996df1f85af15f2cd8d33daae6e479575123ef4314a51a70a230739cb\"\n+checksum = \"dfbc87f9a7a9d61b15d51d1d3547284f67b6b4f1494ce3fc5814c101f35a5183\"\n dependencies = [\n- \"bitflags\",\n+ \"anyhow\",\n  \"chrono\",\n+ \"enum-iterator\",\n+ \"getset\",\n+ \"git2\",\n+ \"rustversion\",\n+ \"thiserror\",\n ]\n \n [[package]]"}, {"sha": "2fcb94cf0a63dd337b35f467ee262f28644dd092", "filename": "RELEASES.md", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -35,7 +35,7 @@ Compiler\n - [Added tier 3 support for `i386-unknown-linux-gnu` and `i486-unknown-linux-gnu` targets.][80662]\n - [The `target-cpu=native` option will now detect individual features of CPUs.][80749]\n \n-\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n information on Rust's tiered platform support.\n \n Libraries\n@@ -183,7 +183,7 @@ Compiler\n - [The `x86_64-unknown-freebsd` is now built with the full toolset.][79484]\n - [Dropped support for all cloudabi targets.][78439]\n \n-\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n information on Rust's tiered platform support.\n \n Libraries\n@@ -360,7 +360,7 @@ Compiler\n - [Output from threads spawned in tests is now captured.][78227]\n - [Change os and vendor values to \"none\" and \"unknown\" for some targets][78951]\n \n-\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n information on Rust's tiered platform support.\n \n Libraries\n@@ -465,7 +465,7 @@ Compiler\n   Note: If you're using cargo you must explicitly pass the `--target` flag.\n - [Added tier 2\\* support for `aarch64-unknown-linux-musl`.][76420]\n \n-\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n information on Rust's tiered platform support.\n \n Libraries\n@@ -604,7 +604,7 @@ Compiler\n - [Upgrade the FreeBSD toolchain to version 11.4][75204]\n - [`RUST_BACKTRACE`'s output is now more compact.][75048]\n \n-\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n information on Rust's tiered platform support.\n \n Libraries\n@@ -889,7 +889,7 @@ Compiler\n - [Added tier 3 support for the `thumbv7a-uwp-windows-msvc` target.][72133]\n - [Upgraded to LLVM 10.][67759]\n \n-\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n information on Rust's tiered platform support.\n \n \n@@ -1398,7 +1398,7 @@ Compiler\n    pointing to the location where they were called, rather than\n    `core`'s internals. ][67887]\n \n-\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n information on Rust's tiered platform support.\n \n Libraries\n@@ -1496,7 +1496,7 @@ Compiler\n - [You can now provide `--extern` flag without a path, indicating that it is\n   available from the search path or specified with an `-L` flag.][64882]\n \n-\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n information on Rust's tiered platform support.\n \n [argfile-docs]: https://doc.rust-lang.org/nightly/rustc/command-line-arguments.html#path-load-command-line-flags-from-a-path\n@@ -1620,7 +1620,7 @@ Compiler\n - [Added tier 3 support for the `mips64-unknown-linux-muslabi64`, and\n   `mips64el-unknown-linux-muslabi64` targets.][65843]\n \n-\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n   information on Rust's tiered platform support.\n \n Libraries\n@@ -1770,7 +1770,7 @@ Compiler\n   output of successful tests.][62600]\n \n \n-\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n information on Rust's tiered platform support.\n \n Libraries\n@@ -1864,7 +1864,7 @@ Compiler\n - [Added tier 3 support for the `riscv32i-unknown-none-elf` target.][62784]\n - [Upgraded to LLVM 9.][62592]\n \n-\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n information on Rust's tiered platform support.\n \n Libraries\n@@ -1951,7 +1951,7 @@ Compatibility Notes\n [`Duration::mul_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.mul_f32\n [`Duration::mul_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.mul_f64\n [`any::type_name`]: https://doc.rust-lang.org/std/any/fn.type_name.html\n-[forge-platform-support]: https://forge.rust-lang.org/release/platform-support.html\n+[platform-support-doc]: https://doc.rust-lang.org/nightly/rustc/platform-support.html\n [pipeline-internals]: https://internals.rust-lang.org/t/evaluating-pipelined-rustc-compilation/10199\n \n Version 1.37.0 (2019-08-15)"}, {"sha": "ca6055c46a6473e846dfd2c85e4b808c6ced8ddc", "filename": "compiler/rustc/Cargo.toml", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc%2FCargo.toml?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -11,12 +11,16 @@ rustc_driver = { path = \"../rustc_driver\" }\n # crate is intended to be used by codegen backends, which may not be in-tree.\n rustc_codegen_ssa = { path = \"../rustc_codegen_ssa\" }\n \n-[dependencies.jemalloc-sys]\n-version = '0.3.0'\n+[dependencies.tikv-jemalloc-sys]\n+version = '0.4.0'\n optional = true\n features = ['unprefixed_malloc_on_supported_platforms']\n \n+[dependencies.tikv-jemallocator]\n+version = '0.4.0'\n+optional = true\n+\n [features]\n-jemalloc = ['jemalloc-sys']\n+jemalloc = ['tikv-jemalloc-sys', 'tikv-jemallocator']\n llvm = ['rustc_driver/llvm']\n max_level_info = ['rustc_driver/max_level_info']"}, {"sha": "c80fab99496bc0d250ab4065b0eea235e9bbb142", "filename": "compiler/rustc/src/main.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc%2Fsrc%2Fmain.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,3 +1,16 @@\n+// Configure jemalloc as the `global_allocator` when configured. This is\n+// so that we use the sized deallocation apis jemalloc provides\n+// (namely `sdallocx`).\n+//\n+// The symbol overrides documented below are also performed so that we can\n+// ensure that we use a consistent allocator across the rustc <-> llvm boundary\n+#[cfg(feature = \"jemalloc\")]\n+#[global_allocator]\n+static ALLOC: tikv_jemallocator::Jemalloc = tikv_jemallocator::Jemalloc;\n+\n+#[cfg(feature = \"tikv-jemalloc-sys\")]\n+use tikv_jemalloc_sys as jemalloc_sys;\n+\n fn main() {\n     // Pull in jemalloc when enabled.\n     //\n@@ -7,7 +20,7 @@ fn main() {\n     // dynamic libraries. That means to pull in jemalloc we actually need to\n     // reference allocation symbols one way or another (as this file is the only\n     // object code in the rustc executable).\n-    #[cfg(feature = \"jemalloc-sys\")]\n+    #[cfg(feature = \"tikv-jemalloc-sys\")]\n     {\n         use std::os::raw::{c_int, c_void};\n "}, {"sha": "96277950cfe1a0fbf9489172436ddc6c49f18480", "filename": "compiler/rustc_apfloat/src/ieee.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -2273,6 +2273,7 @@ impl Loss {\n mod sig {\n     use super::{limbs_for_bits, ExpInt, Limb, Loss, LIMB_BITS};\n     use core::cmp::Ordering;\n+    use core::iter;\n     use core::mem;\n \n     pub(super) fn is_all_zeros(limbs: &[Limb]) -> bool {\n@@ -2483,7 +2484,7 @@ mod sig {\n     pub(super) fn add(a: &mut [Limb], b: &[Limb], mut c: Limb) -> Limb {\n         assert!(c <= 1);\n \n-        for (a, &b) in a.iter_mut().zip(b) {\n+        for (a, &b) in iter::zip(a, b) {\n             let (r, overflow) = a.overflowing_add(b);\n             let (r, overflow2) = r.overflowing_add(c);\n             *a = r;\n@@ -2497,7 +2498,7 @@ mod sig {\n     pub(super) fn sub(a: &mut [Limb], b: &[Limb], mut c: Limb) -> Limb {\n         assert!(c <= 1);\n \n-        for (a, &b) in a.iter_mut().zip(b) {\n+        for (a, &b) in iter::zip(a, b) {\n             let (r, overflow) = a.overflowing_sub(b);\n             let (r, overflow2) = r.overflowing_sub(c);\n             *a = r;"}, {"sha": "c648147d108fb4c0e14e440bf0e720db31dcc2cd", "filename": "compiler/rustc_apfloat/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -33,6 +33,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![no_std]\n #![forbid(unsafe_code)]\n+#![feature(iter_zip)]\n #![feature(nll)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n "}, {"sha": "c3e4945c4464cfadf866398839075ea2d82b5811", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -236,26 +236,6 @@ impl<T> TypedArena<T> {\n         start_ptr\n     }\n \n-    /// Allocates a slice of objects that are copied into the `TypedArena`, returning a mutable\n-    /// reference to it. Will panic if passed a zero-sized types.\n-    ///\n-    /// Panics:\n-    ///\n-    ///  - Zero-sized types\n-    ///  - Zero-length slices\n-    #[inline]\n-    pub fn alloc_slice(&self, slice: &[T]) -> &mut [T]\n-    where\n-        T: Copy,\n-    {\n-        unsafe {\n-            let len = slice.len();\n-            let start_ptr = self.alloc_raw_slice(len);\n-            slice.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n-            slice::from_raw_parts_mut(start_ptr, len)\n-        }\n-    }\n-\n     #[inline]\n     pub fn alloc_from_iter<I: IntoIterator<Item = T>>(&self, iter: I) -> &mut [T] {\n         assert!(mem::size_of::<T>() != 0);"}, {"sha": "2cffddfcd0b95ff42bcaba15772114a086cbdd99", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -762,14 +762,6 @@ pub enum Mutability {\n }\n \n impl Mutability {\n-    /// Returns `MutMutable` only if both `self` and `other` are mutable.\n-    pub fn and(self, other: Self) -> Self {\n-        match self {\n-            Mutability::Mut => other,\n-            Mutability::Not => Mutability::Not,\n-        }\n-    }\n-\n     pub fn invert(self) -> Self {\n         match self {\n             Mutability::Mut => Mutability::Not,\n@@ -1722,13 +1714,6 @@ impl FloatTy {\n             FloatTy::F64 => sym::f64,\n         }\n     }\n-\n-    pub fn bit_width(self) -> u64 {\n-        match self {\n-            FloatTy::F32 => 32,\n-            FloatTy::F64 => 64,\n-        }\n-    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n@@ -1764,29 +1749,6 @@ impl IntTy {\n             IntTy::I128 => sym::i128,\n         }\n     }\n-\n-    pub fn bit_width(&self) -> Option<u64> {\n-        Some(match *self {\n-            IntTy::Isize => return None,\n-            IntTy::I8 => 8,\n-            IntTy::I16 => 16,\n-            IntTy::I32 => 32,\n-            IntTy::I64 => 64,\n-            IntTy::I128 => 128,\n-        })\n-    }\n-\n-    pub fn normalize(&self, target_width: u32) -> Self {\n-        match self {\n-            IntTy::Isize => match target_width {\n-                16 => IntTy::I16,\n-                32 => IntTy::I32,\n-                64 => IntTy::I64,\n-                _ => unreachable!(),\n-            },\n-            _ => *self,\n-        }\n-    }\n }\n \n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, Debug)]\n@@ -1822,29 +1784,6 @@ impl UintTy {\n             UintTy::U128 => sym::u128,\n         }\n     }\n-\n-    pub fn bit_width(&self) -> Option<u64> {\n-        Some(match *self {\n-            UintTy::Usize => return None,\n-            UintTy::U8 => 8,\n-            UintTy::U16 => 16,\n-            UintTy::U32 => 32,\n-            UintTy::U64 => 64,\n-            UintTy::U128 => 128,\n-        })\n-    }\n-\n-    pub fn normalize(&self, target_width: u32) -> Self {\n-        match self {\n-            UintTy::Usize => match target_width {\n-                16 => UintTy::U16,\n-                32 => UintTy::U32,\n-                64 => UintTy::U64,\n-                _ => unreachable!(),\n-            },\n-            _ => *self,\n-        }\n-    }\n }\n \n /// A constraint on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or\n@@ -2215,9 +2154,6 @@ pub struct FnDecl {\n }\n \n impl FnDecl {\n-    pub fn get_self(&self) -> Option<ExplicitSelf> {\n-        self.inputs.get(0).and_then(Param::to_self)\n-    }\n     pub fn has_self(&self) -> bool {\n         self.inputs.get(0).map_or(false, Param::is_self)\n     }"}, {"sha": "0fbe4d0120caff421751c9a8671224d133905cab", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -100,16 +100,7 @@ impl NestedMetaItem {\n         self.meta_item().map_or(false, |meta_item| meta_item.is_word())\n     }\n \n-    /// Returns `true` if `self` is a `MetaItem` and the meta item is a `ValueString`.\n-    pub fn is_value_str(&self) -> bool {\n-        self.value_str().is_some()\n-    }\n-\n-    /// Returns `true` if `self` is a `MetaItem` and the meta item is a list.\n-    pub fn is_meta_item_list(&self) -> bool {\n-        self.meta_item_list().is_some()\n-    }\n-\n+    /// See [`MetaItem::name_value_literal_span`].\n     pub fn name_value_literal_span(&self) -> Option<Span> {\n         self.meta_item()?.name_value_literal_span()\n     }\n@@ -165,31 +156,6 @@ impl Attribute {\n             false\n         }\n     }\n-\n-    pub fn is_meta_item_list(&self) -> bool {\n-        self.meta_item_list().is_some()\n-    }\n-\n-    /// Indicates if the attribute is a `ValueString`.\n-    pub fn is_value_str(&self) -> bool {\n-        self.value_str().is_some()\n-    }\n-\n-    /// This is used in case you want the value span instead of the whole attribute. Example:\n-    ///\n-    /// ```text\n-    /// #[doc(alias = \"foo\")]\n-    /// ```\n-    ///\n-    /// In here, it'll return a span for `\"foo\"`.\n-    pub fn name_value_literal_span(&self) -> Option<Span> {\n-        match self.kind {\n-            AttrKind::Normal(ref item, _) => {\n-                item.meta(self.span).and_then(|meta| meta.name_value_literal_span())\n-            }\n-            AttrKind::DocComment(..) => None,\n-        }\n-    }\n }\n \n impl MetaItem {\n@@ -236,10 +202,6 @@ impl MetaItem {\n         self.path == name\n     }\n \n-    pub fn is_value_str(&self) -> bool {\n-        self.value_str().is_some()\n-    }\n-\n     /// This is used in case you want the value span instead of the whole attribute. Example:\n     ///\n     /// ```text"}, {"sha": "032a4e6c78211a15d89694173a08e448fd2003bd", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -14,6 +14,7 @@\n #![feature(const_fn_transmute)]\n #![feature(const_panic)]\n #![feature(crate_visibility_modifier)]\n+#![feature(iter_zip)]\n #![feature(label_break_value)]\n #![feature(nll)]\n #![cfg_attr(bootstrap, feature(or_patterns))]"}, {"sha": "06d49c7524a58189bcd2645155792a00fb9ff4f0", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -89,10 +89,6 @@ impl TokenTree {\n         }\n     }\n \n-    pub fn joint(self) -> TokenStream {\n-        TokenStream::new(vec![(self, Spacing::Joint)])\n-    }\n-\n     pub fn token(kind: TokenKind, span: Span) -> TokenTree {\n         TokenTree::Token(Token::new(kind, span))\n     }\n@@ -278,14 +274,6 @@ impl TokenStream {\n         self.0.len()\n     }\n \n-    pub fn span(&self) -> Option<Span> {\n-        match &**self.0 {\n-            [] => None,\n-            [(tt, _)] => Some(tt.span()),\n-            [(tt_start, _), .., (tt_end, _)] => Some(tt_start.span().to(tt_end.span())),\n-        }\n-    }\n-\n     pub fn from_streams(mut streams: SmallVec<[TokenStream; 2]>) -> TokenStream {\n         match streams.len() {\n             0 => TokenStream::default(),\n@@ -325,10 +313,6 @@ impl TokenStream {\n         }\n     }\n \n-    pub fn trees_ref(&self) -> CursorRef<'_> {\n-        CursorRef::new(self)\n-    }\n-\n     pub fn trees(&self) -> Cursor {\n         self.clone().into_trees()\n     }\n@@ -341,7 +325,7 @@ impl TokenStream {\n     pub fn eq_unspanned(&self, other: &TokenStream) -> bool {\n         let mut t1 = self.trees();\n         let mut t2 = other.trees();\n-        for (t1, t2) in t1.by_ref().zip(t2.by_ref()) {\n+        for (t1, t2) in iter::zip(&mut t1, &mut t2) {\n             if !t1.eq_unspanned(&t2) {\n                 return false;\n             }\n@@ -427,10 +411,6 @@ pub struct CursorRef<'t> {\n }\n \n impl<'t> CursorRef<'t> {\n-    fn new(stream: &TokenStream) -> CursorRef<'_> {\n-        CursorRef { stream, index: 0 }\n-    }\n-\n     fn next_with_spacing(&mut self) -> Option<&'t TreeAndSpacing> {\n         self.stream.0.get(self.index).map(|tree| {\n             self.index += 1;"}, {"sha": "d5a9d7ee6e3666f3fb3800ddc4afa3f081441611", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 50, "deletions": 32, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1499,46 +1499,64 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // previous iteration.\n                 required_features.clear();\n \n-                // Validate register classes against currently enabled target\n-                // features. We check that at least one type is available for\n-                // the current target.\n                 let reg_class = reg.reg_class();\n                 if reg_class == asm::InlineAsmRegClass::Err {\n                     continue;\n                 }\n-                for &(_, feature) in reg_class.supported_types(asm_arch.unwrap()) {\n-                    if let Some(feature) = feature {\n-                        if self.sess.target_features.contains(&Symbol::intern(feature)) {\n+\n+                // We ignore target feature requirements for clobbers: if the\n+                // feature is disabled then the compiler doesn't care what we\n+                // do with the registers.\n+                //\n+                // Note that this is only possible for explicit register\n+                // operands, which cannot be used in the asm string.\n+                let is_clobber = matches!(\n+                    op,\n+                    hir::InlineAsmOperand::Out {\n+                        reg: asm::InlineAsmRegOrRegClass::Reg(_),\n+                        late: _,\n+                        expr: None\n+                    }\n+                );\n+\n+                if !is_clobber {\n+                    // Validate register classes against currently enabled target\n+                    // features. We check that at least one type is available for\n+                    // the current target.\n+                    for &(_, feature) in reg_class.supported_types(asm_arch.unwrap()) {\n+                        if let Some(feature) = feature {\n+                            if self.sess.target_features.contains(&Symbol::intern(feature)) {\n+                                required_features.clear();\n+                                break;\n+                            } else {\n+                                required_features.push(feature);\n+                            }\n+                        } else {\n                             required_features.clear();\n                             break;\n-                        } else {\n-                            required_features.push(feature);\n                         }\n-                    } else {\n-                        required_features.clear();\n-                        break;\n                     }\n-                }\n-                // We are sorting primitive strs here and can use unstable sort here\n-                required_features.sort_unstable();\n-                required_features.dedup();\n-                match &required_features[..] {\n-                    [] => {}\n-                    [feature] => {\n-                        let msg = format!(\n-                            \"register class `{}` requires the `{}` target feature\",\n-                            reg_class.name(),\n-                            feature\n-                        );\n-                        sess.struct_span_err(op_sp, &msg).emit();\n-                    }\n-                    features => {\n-                        let msg = format!(\n-                            \"register class `{}` requires at least one target feature: {}\",\n-                            reg_class.name(),\n-                            features.join(\", \")\n-                        );\n-                        sess.struct_span_err(op_sp, &msg).emit();\n+                    // We are sorting primitive strs here and can use unstable sort here\n+                    required_features.sort_unstable();\n+                    required_features.dedup();\n+                    match &required_features[..] {\n+                        [] => {}\n+                        [feature] => {\n+                            let msg = format!(\n+                                \"register class `{}` requires the `{}` target feature\",\n+                                reg_class.name(),\n+                                feature\n+                            );\n+                            sess.struct_span_err(op_sp, &msg).emit();\n+                        }\n+                        features => {\n+                            let msg = format!(\n+                                \"register class `{}` requires at least one target feature: {}\",\n+                                reg_class.name(),\n+                                features.join(\", \")\n+                            );\n+                            sess.struct_span_err(op_sp, &msg).emit();\n+                        }\n                     }\n                 }\n "}, {"sha": "ea01632d75d6a975d19eea985306df7af3d101e8", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -18,6 +18,7 @@ use rustc_target::spec::abi;\n use smallvec::{smallvec, SmallVec};\n use tracing::debug;\n \n+use std::iter;\n use std::mem;\n \n pub(super) struct ItemLowerer<'a, 'lowering, 'hir> {\n@@ -206,7 +207,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             UseTreeKind::Glob => {}\n             UseTreeKind::Simple(_, id1, id2) => {\n                 for (_, &id) in\n-                    self.expect_full_res_from_use(base_id).skip(1).zip([id1, id2].iter())\n+                    iter::zip(self.expect_full_res_from_use(base_id).skip(1), &[id1, id2])\n                 {\n                     vec.push(id);\n                 }\n@@ -537,7 +538,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // won't be dealing with macros in the rest of the compiler.\n                 // Essentially a single `use` which imports two names is desugared into\n                 // two imports.\n-                for (res, &new_node_id) in resolutions.zip([id1, id2].iter()) {\n+                for (res, &new_node_id) in iter::zip(resolutions, &[id1, id2]) {\n                     let ident = *ident;\n                     let mut path = path.clone();\n                     for seg in &mut path.segments {"}, {"sha": "4e375e00682b3446b81dc47ca11cbe3cc140bf40", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -33,6 +33,7 @@\n #![feature(crate_visibility_modifier)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(box_patterns)]\n+#![feature(iter_zip)]\n #![recursion_limit = \"256\"]\n \n use rustc_ast::node_id::NodeMap;\n@@ -568,7 +569,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n \n         hir::Crate {\n-            item: hir::CrateItem { module, span: c.span },\n+            item: module,\n             exported_macros: self.arena.alloc_from_iter(self.exported_macros),\n             non_exported_macro_attrs: self.arena.alloc_from_iter(self.non_exported_macro_attrs),\n             items: self.items,"}, {"sha": "3724438cc6ed250abf556617e291616f80827a3c", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -313,7 +313,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                     include => external_doc\n                     cfg => doc_cfg\n                     masked => doc_masked\n-                    spotlight => doc_spotlight\n+                    notable_trait => doc_notable_trait\n                     keyword => doc_keyword\n                 );\n             }"}, {"sha": "976725b308e02d6f2631b79db7f29c519acd4e93", "filename": "compiler/rustc_ast_pretty/src/pprust/mod.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -22,10 +22,6 @@ pub fn token_to_string(token: &Token) -> String {\n     State::new().token_to_string(token)\n }\n \n-pub fn token_to_string_ext(token: &Token, convert_dollar_crate: bool) -> String {\n-    State::new().token_to_string_ext(token, convert_dollar_crate)\n-}\n-\n pub fn ty_to_string(ty: &ast::Ty) -> String {\n     State::new().ty_to_string(ty)\n }\n@@ -50,18 +46,10 @@ pub fn tts_to_string(tokens: &TokenStream) -> String {\n     State::new().tts_to_string(tokens)\n }\n \n-pub fn stmt_to_string(stmt: &ast::Stmt) -> String {\n-    State::new().stmt_to_string(stmt)\n-}\n-\n pub fn item_to_string(i: &ast::Item) -> String {\n     State::new().item_to_string(i)\n }\n \n-pub fn generic_params_to_string(generic_params: &[ast::GenericParam]) -> String {\n-    State::new().generic_params_to_string(generic_params)\n-}\n-\n pub fn path_to_string(p: &ast::Path) -> String {\n     State::new().path_to_string(p)\n }\n@@ -74,26 +62,14 @@ pub fn vis_to_string(v: &ast::Visibility) -> String {\n     State::new().vis_to_string(v)\n }\n \n-pub fn block_to_string(blk: &ast::Block) -> String {\n-    State::new().block_to_string(blk)\n-}\n-\n pub fn meta_list_item_to_string(li: &ast::NestedMetaItem) -> String {\n     State::new().meta_list_item_to_string(li)\n }\n \n-pub fn attr_item_to_string(ai: &ast::AttrItem) -> String {\n-    State::new().attr_item_to_string(ai)\n-}\n-\n pub fn attribute_to_string(attr: &ast::Attribute) -> String {\n     State::new().attribute_to_string(attr)\n }\n \n-pub fn param_to_string(arg: &ast::Param) -> String {\n-    State::new().param_to_string(arg)\n-}\n-\n pub fn to_string(f: impl FnOnce(&mut State<'_>)) -> String {\n     State::new().to_string(f)\n }"}, {"sha": "627c0584b6114c7af1fd81fd628533b2e7b314c4", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -2292,10 +2292,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_usize(&mut self, i: usize) {\n-        self.s.word(i.to_string())\n-    }\n-\n     crate fn print_name(&mut self, name: Symbol) {\n         self.s.word(name.to_string());\n         self.ann.post(self, AnnNode::Name(&name))"}, {"sha": "20971ebb95748888568d994fbf31286e33ea2282", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -862,18 +862,6 @@ pub fn find_repr_attrs(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n         if let Some(items) = attr.meta_item_list() {\n             sess.mark_attr_used(attr);\n             for item in items {\n-                if !item.is_meta_item() {\n-                    handle_errors(\n-                        &sess.parse_sess,\n-                        item.span(),\n-                        AttrError::UnsupportedLiteral(\n-                            \"meta item in `repr` must be an identifier\",\n-                            false,\n-                        ),\n-                    );\n-                    continue;\n-                }\n-\n                 let mut recognised = false;\n                 if item.is_word() {\n                     let hint = match item.name_or_empty() {\n@@ -890,23 +878,6 @@ pub fn find_repr_attrs(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n                         acc.push(h);\n                     }\n                 } else if let Some((name, value)) = item.name_value_literal() {\n-                    let parse_alignment = |node: &ast::LitKind| -> Result<u32, &'static str> {\n-                        if let ast::LitKind::Int(literal, ast::LitIntType::Unsuffixed) = node {\n-                            if literal.is_power_of_two() {\n-                                // rustc_middle::ty::layout::Align restricts align to <= 2^29\n-                                if *literal <= 1 << 29 {\n-                                    Ok(*literal as u32)\n-                                } else {\n-                                    Err(\"larger than 2^29\")\n-                                }\n-                            } else {\n-                                Err(\"not a power of two\")\n-                            }\n-                        } else {\n-                            Err(\"not an unsuffixed integer\")\n-                        }\n-                    };\n-\n                     let mut literal_error = None;\n                     if name == sym::align {\n                         recognised = true;\n@@ -966,13 +937,7 @@ pub fn find_repr_attrs(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n                 }\n                 if !recognised {\n                     // Not a word we recognize\n-                    struct_span_err!(\n-                        diagnostic,\n-                        item.span(),\n-                        E0552,\n-                        \"unrecognized representation hint\"\n-                    )\n-                    .emit();\n+                    diagnostic.delay_span_bug(item.span(), \"unrecognized representation hint\");\n                 }\n             }\n         }\n@@ -1080,3 +1045,16 @@ fn allow_unstable<'a>(\n         name\n     })\n }\n+\n+pub fn parse_alignment(node: &ast::LitKind) -> Result<u32, &'static str> {\n+    if let ast::LitKind::Int(literal, ast::LitIntType::Unsuffixed) = node {\n+        if literal.is_power_of_two() {\n+            // rustc_middle::ty::layout::Align restricts align to <= 2^29\n+            if *literal <= 1 << 29 { Ok(*literal as u32) } else { Err(\"larger than 2^29\") }\n+        } else {\n+            Err(\"not a power of two\")\n+        }\n+    } else {\n+        Err(\"not an unsuffixed integer\")\n+    }\n+}"}, {"sha": "1bb050a40cee23c813d617f5d024bded7b38a3e6", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,6 +1,6 @@\n use crate::cfg_eval::cfg_eval;\n \n-use rustc_ast::{self as ast, token, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n+use rustc_ast::{self as ast, attr, token, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, Indeterminate, MultiItemModifier};\n use rustc_feature::AttributeTemplate;\n@@ -26,32 +26,39 @@ impl MultiItemModifier for Expander {\n             return ExpandResult::Ready(vec![item]);\n         }\n \n-        let template =\n-            AttributeTemplate { list: Some(\"Trait1, Trait2, ...\"), ..Default::default() };\n-        let attr = ecx.attribute(meta_item.clone());\n-        validate_attr::check_builtin_attribute(&sess.parse_sess, &attr, sym::derive, template);\n+        let result =\n+            ecx.resolver.resolve_derives(ecx.current_expansion.id, ecx.force_mode, &|| {\n+                let template =\n+                    AttributeTemplate { list: Some(\"Trait1, Trait2, ...\"), ..Default::default() };\n+                let attr = attr::mk_attr_outer(meta_item.clone());\n+                validate_attr::check_builtin_attribute(\n+                    &sess.parse_sess,\n+                    &attr,\n+                    sym::derive,\n+                    template,\n+                );\n \n-        let derives: Vec<_> = attr\n-            .meta_item_list()\n-            .unwrap_or_default()\n-            .into_iter()\n-            .filter_map(|nested_meta| match nested_meta {\n-                NestedMetaItem::MetaItem(meta) => Some(meta),\n-                NestedMetaItem::Literal(lit) => {\n-                    // Reject `#[derive(\"Debug\")]`.\n-                    report_unexpected_literal(sess, &lit);\n-                    None\n-                }\n-            })\n-            .map(|meta| {\n-                // Reject `#[derive(Debug = \"value\", Debug(abc))]`, but recover the paths.\n-                report_path_args(sess, &meta);\n-                meta.path\n-            })\n-            .collect();\n+                attr.meta_item_list()\n+                    .unwrap_or_default()\n+                    .into_iter()\n+                    .filter_map(|nested_meta| match nested_meta {\n+                        NestedMetaItem::MetaItem(meta) => Some(meta),\n+                        NestedMetaItem::Literal(lit) => {\n+                            // Reject `#[derive(\"Debug\")]`.\n+                            report_unexpected_literal(sess, &lit);\n+                            None\n+                        }\n+                    })\n+                    .map(|meta| {\n+                        // Reject `#[derive(Debug = \"value\", Debug(abc))]`, but recover the paths.\n+                        report_path_args(sess, &meta);\n+                        meta.path\n+                    })\n+                    .map(|path| (path, None))\n+                    .collect()\n+            });\n \n-        // FIXME: Try to cache intermediate results to avoid collecting same paths multiple times.\n-        match ecx.resolver.resolve_derives(ecx.current_expansion.id, derives, ecx.force_mode) {\n+        match result {\n             Ok(()) => ExpandResult::Ready(cfg_eval(ecx, item)),\n             Err(Indeterminate) => ExpandResult::Retry(item),\n         }"}, {"sha": "04753926c3e2a7d7bd5d2cee60d201a6fc4a5377", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1034,7 +1034,7 @@ impl<'a> MethodDef<'a> {\n         // make a series of nested matches, to destructure the\n         // structs. This is actually right-to-left, but it shouldn't\n         // matter.\n-        for (arg_expr, pat) in self_args.iter().zip(patterns) {\n+        for (arg_expr, pat) in iter::zip(self_args, patterns) {\n             body = cx.expr_match(\n                 trait_.span,\n                 arg_expr.clone(),\n@@ -1351,7 +1351,7 @@ impl<'a> MethodDef<'a> {\n             let mut discriminant_test = cx.expr_bool(sp, true);\n \n             let mut first_ident = None;\n-            for (&ident, self_arg) in vi_idents.iter().zip(&self_args) {\n+            for (&ident, self_arg) in iter::zip(&vi_idents, &self_args) {\n                 let self_addr = cx.expr_addr_of(sp, self_arg.clone());\n                 let variant_value =\n                     deriving::call_intrinsic(cx, sp, sym::discriminant_value, vec![self_addr]);\n@@ -1571,9 +1571,7 @@ impl<'a> TraitDef<'a> {\n         let subpats = self.create_subpatterns(cx, paths, mutbl, use_temporaries);\n         let pattern = match *struct_def {\n             VariantData::Struct(..) => {\n-                let field_pats = subpats\n-                    .into_iter()\n-                    .zip(&ident_exprs)\n+                let field_pats = iter::zip(subpats, &ident_exprs)\n                     .map(|(pat, &(sp, ident, ..))| {\n                         if ident.is_none() {\n                             cx.span_bug(sp, \"a braced struct with unnamed fields in `derive`\");"}, {"sha": "d7926ed0e0bce1805d7afaee040aec8fd70f81ed", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -7,6 +7,7 @@\n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n+#![feature(iter_zip)]\n #![feature(nll)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(proc_macro_internals)]"}, {"sha": "8c94a0aa5e6ebe7beba14d52e5ed817053529f8e", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/bootstrap_rustc.yml", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7f32fda78c60bb5b05e610a1c0c0fecaff07f497/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fbootstrap_rustc.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7f32fda78c60bb5b05e610a1c0c0fecaff07f497/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fbootstrap_rustc.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fbootstrap_rustc.yml?ref=7f32fda78c60bb5b05e610a1c0c0fecaff07f497", "patch": "@@ -1,44 +0,0 @@\n-name: Bootstrap rustc using cg_clif\n-\n-on:\n-  - push\n-\n-jobs:\n-  bootstrap_rustc:\n-    runs-on: ubuntu-latest\n-\n-    steps:\n-    - uses: actions/checkout@v2\n-\n-    - name: Cache cargo installed crates\n-      uses: actions/cache@v2\n-      with:\n-        path: ~/.cargo/bin\n-        key: ${{ runner.os }}-cargo-installed-crates\n-\n-    - name: Cache cargo registry and index\n-      uses: actions/cache@v2\n-      with:\n-        path: |\n-            ~/.cargo/registry\n-            ~/.cargo/git\n-        key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n-\n-    - name: Cache cargo target dir\n-      uses: actions/cache@v2\n-      with:\n-        path: target\n-        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n-\n-    - name: Prepare dependencies\n-      run: |\n-        git config --global user.email \"user@example.com\"\n-        git config --global user.name \"User\"\n-        ./prepare.sh\n-\n-    - name: Test\n-      run: |\n-        # Enable backtraces for easier debugging\n-        export RUST_BACKTRACE=1\n-\n-        ./scripts/test_bootstrap.sh"}, {"sha": "2ac516381cf7af9fe8c097fea65951fbe3c8040d", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -7,11 +7,18 @@ on:\n jobs:\n   build:\n     runs-on: ${{ matrix.os }}\n+    timeout-minutes: 60\n \n     strategy:\n       fail-fast: false\n       matrix:\n-        os: [ubuntu-latest, macos-latest]\n+        include:\n+          - os: ubuntu-latest\n+          - os: macos-latest\n+          # cross-compile from Linux to Windows using mingw\n+          - os: ubuntu-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-pc-windows-gnu\n \n     steps:\n     - uses: actions/checkout@v2\n@@ -36,13 +43,21 @@ jobs:\n         path: target\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n \n+    - name: Install MinGW toolchain and wine\n+      if: matrix.os == 'ubuntu-latest' && matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n+      run: |\n+        sudo apt-get install -y gcc-mingw-w64-x86-64 wine-stable\n+        rustup target add x86_64-pc-windows-gnu\n+\n     - name: Prepare dependencies\n       run: |\n         git config --global user.email \"user@example.com\"\n         git config --global user.name \"User\"\n         ./prepare.sh\n \n     - name: Test\n+      env:\n+        TARGET_TRIPLE: ${{ matrix.env.TARGET_TRIPLE }}\n       run: |\n         # Enable backtraces for easier debugging\n         export RUST_BACKTRACE=1\n@@ -51,12 +66,16 @@ jobs:\n         export COMPILE_RUNS=2\n         export RUN_RUNS=2\n \n+        # Enable extra checks\n+        export CG_CLIF_ENABLE_VERIFIER=1\n+\n         ./test.sh\n \n     - name: Package prebuilt cg_clif\n       run: tar cvfJ cg_clif.tar.xz build\n \n     - name: Upload prebuilt cg_clif\n+      if: matrix.env.TARGET_TRIPLE != 'x86_64-pc-windows-gnu'\n       uses: actions/upload-artifact@v2\n       with:\n         name: cg_clif-${{ runner.os }}"}, {"sha": "e01a92598bab745b4df24ef41bb5e50ccfef4701", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/rustc.yml", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -0,0 +1,82 @@\n+name: Various rustc tests\n+\n+on:\n+  - push\n+\n+jobs:\n+  bootstrap_rustc:\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+    - uses: actions/checkout@v2\n+\n+    - name: Cache cargo installed crates\n+      uses: actions/cache@v2\n+      with:\n+        path: ~/.cargo/bin\n+        key: ${{ runner.os }}-cargo-installed-crates\n+\n+    - name: Cache cargo registry and index\n+      uses: actions/cache@v2\n+      with:\n+        path: |\n+            ~/.cargo/registry\n+            ~/.cargo/git\n+        key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo target dir\n+      uses: actions/cache@v2\n+      with:\n+        path: target\n+        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n+\n+    - name: Prepare dependencies\n+      run: |\n+        git config --global user.email \"user@example.com\"\n+        git config --global user.name \"User\"\n+        ./prepare.sh\n+\n+    - name: Test\n+      run: |\n+        # Enable backtraces for easier debugging\n+        export RUST_BACKTRACE=1\n+\n+        ./scripts/test_bootstrap.sh\n+  rustc_test_suite:\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+    - uses: actions/checkout@v2\n+\n+    - name: Cache cargo installed crates\n+      uses: actions/cache@v2\n+      with:\n+        path: ~/.cargo/bin\n+        key: ${{ runner.os }}-cargo-installed-crates\n+\n+    - name: Cache cargo registry and index\n+      uses: actions/cache@v2\n+      with:\n+        path: |\n+            ~/.cargo/registry\n+            ~/.cargo/git\n+        key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo target dir\n+      uses: actions/cache@v2\n+      with:\n+        path: target\n+        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n+\n+    - name: Prepare dependencies\n+      run: |\n+        git config --global user.email \"user@example.com\"\n+        git config --global user.name \"User\"\n+        ./prepare.sh\n+\n+    - name: Test\n+      run: |\n+        # Enable backtraces for easier debugging\n+        export RUST_BACKTRACE=1\n+\n+        ./scripts/test_rustc_tests.sh"}, {"sha": "0cd576e160f86724a703bd954acb0efe3abca756", "filename": "compiler/rustc_codegen_cranelift/.vscode/settings.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -2,7 +2,7 @@\n     // source for rustc_* is not included in the rust-src component; disable the errors about this\n     \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\", \"macro-error\"],\n     \"rust-analyzer.assist.importMergeBehavior\": \"last\",\n-    \"rust-analyzer.cargo.loadOutDirsFromCheck\": true,\n+    \"rust-analyzer.cargo.runBuildScripts\": true,\n     \"rust-analyzer.linkedProjects\": [\n         \"./Cargo.toml\",\n         //\"./build_sysroot/sysroot_src/src/libstd/Cargo.toml\","}, {"sha": "dc1cd336e1599e65c65a0becbfaee6a8b4dfb99d", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -39,16 +39,16 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.70.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n+version = \"0.72.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.70.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n+version = \"0.72.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n dependencies = [\n  \"byteorder\",\n  \"cranelift-bforest\",\n@@ -65,27 +65,27 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.70.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n+version = \"0.72.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.70.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n+version = \"0.72.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.70.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n+version = \"0.72.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.70.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n+version = \"0.72.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -95,8 +95,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.70.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n+version = \"0.72.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -113,8 +113,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.70.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n+version = \"0.72.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -125,17 +125,17 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.70.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n+version = \"0.72.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"target-lexicon\",\n ]\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.70.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n+version = \"0.72.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\","}, {"sha": "60946ab28085854440b9db785bf5b59f23a94302", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -16,7 +16,7 @@ cranelift-jit = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch\n cranelift-object = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n target-lexicon = \"0.11.0\"\n gimli = { version = \"0.23.0\", default-features = false, features = [\"write\"]}\n-object = { version = \"0.23.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n+object = { version = \"0.23.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n indexmap = \"1.0.2\"\n@@ -75,3 +75,6 @@ debug = false\n [profile.release.package.syn]\n opt-level = 0\n debug = false\n+\n+[package.metadata.rust-analyzer]\n+rustc_private = true"}, {"sha": "ffe1d9a1e65806b1f3b28381296d265881c1ce75", "filename": "compiler/rustc_codegen_cranelift/Readme.md", "status": "modified", "additions": 21, "deletions": 55, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FReadme.md?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -34,70 +34,19 @@ rustc_codegen_cranelift can be used as a near-drop-in replacement for `cargo bui\n \n Assuming `$cg_clif_dir` is the directory you cloned this repo into and you followed the instructions (`prepare.sh` and `build.sh` or `test.sh`).\n \n-### Cargo\n-\n In the directory with your project (where you can do the usual `cargo build`), run:\n \n ```bash\n-$ $cg_clif_dir/build/cargo.sh run\n-```\n-\n-This should build and run your project with rustc_codegen_cranelift instead of the usual LLVM backend.\n-\n-### Rustc\n-\n-> You should prefer using the Cargo method.\n-\n-```bash\n-$ $cg_clif_dir/build/bin/cg_clif my_crate.rs\n-```\n-\n-### Jit mode\n-\n-In jit mode cg_clif will immediately execute your code without creating an executable file.\n-\n-> This requires all dependencies to be available as dynamic library.\n-> The jit mode will probably need cargo integration to make this possible.\n-\n-```bash\n-$ $cg_clif_dir/build/cargo.sh jit\n-```\n-\n-or\n-\n-```bash\n-$ $cg_clif_dir/build/bin/cg_clif -Cllvm-args=mode=jit -Cprefer-dynamic my_crate.rs\n-```\n-\n-There is also an experimental lazy jit mode. In this mode functions are only compiled once they are\n-first called. It currently does not work with multi-threaded programs. When a not yet compiled\n-function is called from another thread than the main thread, you will get an ICE.\n-\n-```bash\n-$ $cg_clif_dir/build/cargo.sh lazy-jit\n+$ $cg_clif_dir/build/cargo.sh build\n ```\n \n-### Shell\n-\n-These are a few functions that allow you to easily run rust code from the shell using cg_clif as jit.\n-\n-```bash\n-function jit_naked() {\n-    echo \"$@\" | $cg_clif_dir/build/bin/cg_clif - -Cllvm-args=mode=jit -Cprefer-dynamic\n-}\n-\n-function jit() {\n-    jit_naked \"fn main() { $@ }\"\n-}\n+This will build your project with rustc_codegen_cranelift instead of the usual LLVM backend.\n \n-function jit_calc() {\n-    jit 'println!(\"0x{:x}\", ' $@ ');';\n-}\n-```\n+For additional ways to use rustc_codegen_cranelift like the JIT mode see [usage.md](docs/usage.md).\n \n ## Env vars\n \n-[see env_vars.md](docs/env_vars.md)\n+See [env_vars.md](docs/env_vars.md) for all env vars used by rustc_codegen_cranelift.\n \n ## Not yet supported\n \n@@ -106,3 +55,20 @@ function jit_calc() {\n       `llvm_asm!` will remain unimplemented forever. `asm!` doesn't yet support reg classes. You\n       have to specify specific registers instead.\n * SIMD ([tracked here](https://github.com/bjorn3/rustc_codegen_cranelift/issues/171), some basic things work)\n+\n+## License\n+\n+Licensed under either of\n+\n+  * Apache License, Version 2.0 ([LICENSE-APACHE](LICENSE-APACHE) or\n+    http://www.apache.org/licenses/LICENSE-2.0)\n+  * MIT license ([LICENSE-MIT](LICENSE-MIT) or\n+    http://opensource.org/licenses/MIT)\n+\n+at your option.\n+\n+### Contribution\n+\n+Unless you explicitly state otherwise, any contribution intentionally submitted\n+for inclusion in the work by you shall be dual licensed as above, without any\n+additional terms or conditions."}, {"sha": "76bc1884334afe4ea539ca65be6b5f8c32f5203d", "filename": "compiler/rustc_codegen_cranelift/build.sh", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fbuild.sh", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fbuild.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild.sh?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -55,6 +55,7 @@ ln target/$CHANNEL/*rustc_codegen_cranelift* \"$target_dir\"/lib\n ln rust-toolchain scripts/config.sh scripts/cargo.sh \"$target_dir\"\n \n mkdir -p \"$target_dir/lib/rustlib/$TARGET_TRIPLE/lib/\"\n+mkdir -p \"$target_dir/lib/rustlib/$HOST_TRIPLE/lib/\"\n if [[ \"$TARGET_TRIPLE\" == \"x86_64-pc-windows-gnu\" ]]; then\n     cp $(rustc --print sysroot)/lib/rustlib/$TARGET_TRIPLE/lib/*.o \"$target_dir/lib/rustlib/$TARGET_TRIPLE/lib/\"\n fi\n@@ -64,12 +65,18 @@ case \"$build_sysroot\" in\n         ;;\n     \"llvm\")\n         cp -r $(rustc --print sysroot)/lib/rustlib/$TARGET_TRIPLE/lib \"$target_dir/lib/rustlib/$TARGET_TRIPLE/\"\n+        if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n+            cp -r $(rustc --print sysroot)/lib/rustlib/$HOST_TRIPLE/lib \"$target_dir/lib/rustlib/$HOST_TRIPLE/\"\n+        fi\n         ;;\n     \"clif\")\n         echo \"[BUILD] sysroot\"\n         dir=$(pwd)\n         cd \"$target_dir\"\n         time \"$dir/build_sysroot/build_sysroot.sh\"\n+        if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n+            time TARGET_TRIPLE=\"$HOST_TRIPLE\" \"$dir/build_sysroot/build_sysroot.sh\"\n+        fi\n         cp lib/rustlib/*/lib/libstd-* lib/\n         ;;\n     *)"}, {"sha": "09c5d7590ab864cc14604bde034da57cf041f3d7", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -16,9 +16,9 @@ dependencies = [\n \n [[package]]\n name = \"adler\"\n-version = \"0.2.3\"\n+version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ee2a4ec343196209d6594e19543ae87a39f96d5534d7174822a3ad825dd6ed7e\"\n+checksum = \"f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-core\",\n@@ -110,9 +110,9 @@ dependencies = [\n \n [[package]]\n name = \"hashbrown\"\n-version = \"0.9.1\"\n+version = \"0.11.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d7afe4a420e3fe79967a00898cc1f4db7c8a49a9333a29f8a4bd76a253d5cd04\"\n+checksum = \"ab5ef0d4909ef3724cc8cce6ccc8572c5c817592e9285f5464f8e86f8bd3726e\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n@@ -132,18 +132,18 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.86\"\n+version = \"0.2.91\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b7282d924be3275cec7f6756ff4121987bc6481325397dde6ba3e7802b1a8b1c\"\n+checksum = \"8916b1f6ca17130ec6568feccee27c156ad12037880833a3b842a823236502e7\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n [[package]]\n name = \"miniz_oxide\"\n-version = \"0.4.3\"\n+version = \"0.4.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0f2d26ec3309788e423cfbf68ad1800f061638098d76a83681af979dc4eda19d\"\n+checksum = \"a92518e98c078586bc6c934028adcca4c92a53d6a958196de835170a01d84e4b\"\n dependencies = [\n  \"adler\",\n  \"autocfg\","}, {"sha": "0354304e55bf77477039d6737749d845128ac80c", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/build_sysroot.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fbuild_sysroot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fbuild_sysroot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fbuild_sysroot.sh?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -28,7 +28,7 @@ export __CARGO_DEFAULT_LIB_METADATA=\"cg_clif\"\n if [[ \"$1\" != \"--debug\" ]]; then\n     sysroot_channel='release'\n     # FIXME Enable incremental again once rust-lang/rust#74946 is fixed\n-    CARGO_INCREMENTAL=0 RUSTFLAGS=\"$RUSTFLAGS -Zmir-opt-level=2\" cargo build --target \"$TARGET_TRIPLE\" --release\n+    CARGO_INCREMENTAL=0 RUSTFLAGS=\"$RUSTFLAGS -Zmir-opt-level=3\" cargo build --target \"$TARGET_TRIPLE\" --release\n else\n     sysroot_channel='debug'\n     cargo build --target \"$TARGET_TRIPLE\""}, {"sha": "f7fde1b4f3a873bbfc694a4bdaeb8cd5fe03fdb3", "filename": "compiler/rustc_codegen_cranelift/docs/env_vars.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fenv_vars.md", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fenv_vars.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fenv_vars.md?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -8,5 +8,8 @@\n     to make it possible to use incremental mode for all analyses performed by rustc without caching\n     object files when their content should have been changed by a change to cg_clif.</dd>\n     <dt>CG_CLIF_DISPLAY_CG_TIME</dt>\n-    <dd>If \"1\", display the time it took to perform codegen for a crate</dd>\n+    <dd>If \"1\", display the time it took to perform codegen for a crate.</dd>\n+    <dt>CG_CLIF_ENABLE_VERIFIER</dt>\n+    <dd>Enable the Cranelift ir verifier for all compilation passes. If not set it will only run once\n+    before passing the clif ir to Cranelift for compilation.</dt>\n </dl>"}, {"sha": "3eee3b554e3b62ccd06db4acbb819c5c760983e4", "filename": "compiler/rustc_codegen_cranelift/docs/usage.md", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fusage.md", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fusage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fusage.md?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -0,0 +1,66 @@\n+# Usage\n+\n+rustc_codegen_cranelift can be used as a near-drop-in replacement for `cargo build` or `cargo run` for existing projects.\n+\n+Assuming `$cg_clif_dir` is the directory you cloned this repo into and you followed the instructions (`prepare.sh` and `build.sh` or `test.sh`).\n+\n+## Cargo\n+\n+In the directory with your project (where you can do the usual `cargo build`), run:\n+\n+```bash\n+$ $cg_clif_dir/build/cargo.sh build\n+```\n+\n+This will build your project with rustc_codegen_cranelift instead of the usual LLVM backend.\n+\n+## Rustc\n+\n+> You should prefer using the Cargo method.\n+\n+```bash\n+$ $cg_clif_dir/build/bin/cg_clif my_crate.rs\n+```\n+\n+## Jit mode\n+\n+In jit mode cg_clif will immediately execute your code without creating an executable file.\n+\n+> This requires all dependencies to be available as dynamic library.\n+> The jit mode will probably need cargo integration to make this possible.\n+\n+```bash\n+$ $cg_clif_dir/build/cargo.sh jit\n+```\n+\n+or\n+\n+```bash\n+$ $cg_clif_dir/build/bin/cg_clif -Cllvm-args=mode=jit -Cprefer-dynamic my_crate.rs\n+```\n+\n+There is also an experimental lazy jit mode. In this mode functions are only compiled once they are\n+first called. It currently does not work with multi-threaded programs. When a not yet compiled\n+function is called from another thread than the main thread, you will get an ICE.\n+\n+```bash\n+$ $cg_clif_dir/build/cargo.sh lazy-jit\n+```\n+\n+## Shell\n+\n+These are a few functions that allow you to easily run rust code from the shell using cg_clif as jit.\n+\n+```bash\n+function jit_naked() {\n+    echo \"$@\" | $cg_clif_dir/build/bin/cg_clif - -Cllvm-args=mode=jit -Cprefer-dynamic\n+}\n+\n+function jit() {\n+    jit_naked \"fn main() { $@ }\"\n+}\n+\n+function jit_calc() {\n+    jit 'println!(\"0x{:x}\", ' $@ ');';\n+}\n+```"}, {"sha": "c4834c804087199822e4552a19874744235992ef", "filename": "compiler/rustc_codegen_cranelift/example/mini_core.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -621,6 +621,7 @@ struct PanicLocation {\n }\n \n #[no_mangle]\n+#[cfg(not(windows))]\n pub fn get_tls() -> u8 {\n     #[thread_local]\n     static A: u8 = 42;"}, {"sha": "ea37ca98b59a79c160036bea3dffec96ea517117", "filename": "compiler/rustc_codegen_cranelift/example/mini_core_hello_world.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,7 +1,4 @@\n-#![feature(\n-    no_core, start, lang_items, box_syntax, never_type, linkage,\n-    extern_types, thread_local\n-)]\n+#![feature(no_core, lang_items, box_syntax, never_type, linkage, extern_types, thread_local)]\n #![no_core]\n #![allow(dead_code, non_camel_case_types)]\n \n@@ -239,7 +236,7 @@ fn main() {\n \n     assert_eq!(((|()| 42u8) as fn(()) -> u8)(()), 42);\n \n-    #[cfg(not(jit))]\n+    #[cfg(not(any(jit, windows)))]\n     {\n         extern {\n             #[linkage = \"extern_weak\"]\n@@ -292,7 +289,7 @@ fn main() {\n \n     from_decimal_string();\n \n-    #[cfg(not(jit))]\n+    #[cfg(not(any(jit, windows)))]\n     test_tls();\n \n     #[cfg(all(not(jit), target_os = \"linux\"))]"}, {"sha": "64c097261c908bf6909aec2789646e998552f4ee", "filename": "compiler/rustc_codegen_cranelift/prepare.sh", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fprepare.sh", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fprepare.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fprepare.sh?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,7 +1,6 @@\n #!/usr/bin/env bash\n set -e\n \n-rustup component add rust-src rustc-dev llvm-tools-preview\n ./build_sysroot/prepare_sysroot_src.sh\n cargo install hyperfine || echo \"Skipping hyperfine install\"\n "}, {"sha": "2917fc7ee396dfed8a04634a10b48dc4ccb4a926", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1 +1,3 @@\n-nightly-2021-03-05\n+[toolchain]\n+channel = \"nightly-2021-03-29\"\n+components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "1daa5a78f7bd25e6396d21b3e92d7fe336171f83", "filename": "compiler/rustc_codegen_cranelift/scripts/cargo.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -4,7 +4,7 @@ dir=$(dirname \"$0\")\n source \"$dir/config.sh\"\n \n # read nightly compiler from rust-toolchain file\n-TOOLCHAIN=$(cat \"$dir/rust-toolchain\")\n+TOOLCHAIN=$(cat \"$dir/rust-toolchain\" | grep channel | sed \"s/channel = \\\"\\(.*\\)\\\"/\\1/\")\n \n cmd=$1\n shift || true"}, {"sha": "99b302ee1d94b3cf044132fccd3401031b9c2c42", "filename": "compiler/rustc_codegen_cranelift/scripts/config.sh", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fconfig.sh", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fconfig.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fconfig.sh?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -2,15 +2,7 @@\n \n set -e\n \n-unamestr=$(uname)\n-if [[ \"$unamestr\" == 'Linux' || \"$unamestr\" == 'FreeBSD' ]]; then\n-   dylib_ext='so'\n-elif [[ \"$unamestr\" == 'Darwin' ]]; then\n-   dylib_ext='dylib'\n-else\n-   echo \"Unsupported os\"\n-   exit 1\n-fi\n+dylib=$(echo \"\" | rustc --print file-names --crate-type dylib --crate-name rustc_codegen_cranelift -)\n \n if echo \"$RUSTC_WRAPPER\" | grep sccache; then\n echo\n@@ -24,10 +16,10 @@ dir=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\"; pwd)\n export RUSTC=$dir\"/bin/cg_clif\"\n \n export RUSTDOCFLAGS=$linker' -Cpanic=abort -Zpanic-abort-tests '\\\n-'-Zcodegen-backend='$dir'/lib/librustc_codegen_cranelift.'$dylib_ext' --sysroot '$dir\n+'-Zcodegen-backend='$dir'/lib/'$dylib' --sysroot '$dir\n \n # FIXME fix `#[linkage = \"extern_weak\"]` without this\n-if [[ \"$unamestr\" == 'Darwin' ]]; then\n+if [[ \"$(uname)\" == 'Darwin' ]]; then\n    export RUSTFLAGS=\"$RUSTFLAGS -Clink-arg=-undefined -Clink-arg=dynamic_lookup\"\n fi\n "}, {"sha": "fa7557653d879a161e77afdaddb0dc1822fc374f", "filename": "compiler/rustc_codegen_cranelift/scripts/rustup.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -8,7 +8,7 @@ case $1 in\n \n         echo \"=> Installing new nightly\"\n         rustup toolchain install --profile minimal \"nightly-${TOOLCHAIN}\" # Sanity check to see if the nightly exists\n-        echo \"nightly-${TOOLCHAIN}\" > rust-toolchain\n+        sed -i \"s/\\\"nightly-.*\\\"/\\\"nightly-${TOOLCHAIN}\\\"/\" rust-toolchain\n         rustup component add rustfmt || true\n \n         echo \"=> Uninstalling all old nighlies\""}, {"sha": "e8bedf625f79684574d2f94c7bd1f350a623e479", "filename": "compiler/rustc_codegen_cranelift/scripts/setup_rust_fork.sh", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -0,0 +1,68 @@\n+#!/bin/bash\n+set -e\n+\n+./build.sh\n+source build/config.sh\n+\n+echo \"[SETUP] Rust fork\"\n+git clone https://github.com/rust-lang/rust.git || true\n+pushd rust\n+git fetch\n+git checkout -- .\n+git checkout \"$(rustc -V | cut -d' ' -f3 | tr -d '(')\"\n+\n+git apply - <<EOF\n+diff --git a/Cargo.toml b/Cargo.toml\n+index 5bd1147cad5..10d68a2ff14 100644\n+--- a/Cargo.toml\n++++ b/Cargo.toml\n+@@ -111,5 +111,7 @@ rustc-std-workspace-std = { path = 'library/rustc-std-workspace-std' }\n+ rustc-std-workspace-alloc = { path = 'library/rustc-std-workspace-alloc' }\n+ rustc-std-workspace-std = { path = 'library/rustc-std-workspace-std' }\n+\n++compiler_builtins = { path = \"../build_sysroot/compiler-builtins\" }\n++\n+ [patch.\"https://github.com/rust-lang/rust-clippy\"]\n+ clippy_lints = { path = \"src/tools/clippy/clippy_lints\" }\n+diff --git a/compiler/rustc_data_structures/Cargo.toml b/compiler/rustc_data_structures/Cargo.toml\n+index 23e689fcae7..5f077b765b6 100644\n+--- a/compiler/rustc_data_structures/Cargo.toml\n++++ b/compiler/rustc_data_structures/Cargo.toml\n+@@ -32,7 +32,6 @@ tempfile = \"3.0.5\"\n+\n+ [dependencies.parking_lot]\n+ version = \"0.11\"\n+-features = [\"nightly\"]\n+\n+ [target.'cfg(windows)'.dependencies]\n+ winapi = { version = \"0.3\", features = [\"fileapi\", \"psapi\"] }\n+diff --git a/library/alloc/Cargo.toml b/library/alloc/Cargo.toml\n+index d95b5b7f17f..00b6f0e3635 100644\n+--- a/library/alloc/Cargo.toml\n++++ b/library/alloc/Cargo.toml\n+@@ -8,7 +8,7 @@ edition = \"2018\"\n+\n+ [dependencies]\n+ core = { path = \"../core\" }\n+-compiler_builtins = { version = \"0.1.39\", features = ['rustc-dep-of-std'] }\n++compiler_builtins = { version = \"0.1.39\", features = ['rustc-dep-of-std', 'no-asm'] }\n+\n+ [dev-dependencies]\n+ rand = \"0.7\"\n+EOF\n+\n+cat > config.toml <<EOF\n+[llvm]\n+ninja = false\n+\n+[build]\n+rustc = \"$(pwd)/../build/bin/cg_clif\"\n+cargo = \"$(rustup which cargo)\"\n+full-bootstrap = true\n+local-rebuild = true\n+\n+[rust]\n+codegen-backends = [\"cranelift\"]\n+deny-warnings = false\n+EOF\n+popd"}, {"sha": "791d457993de3a3d42ad77c2e9a843ea719b4d39", "filename": "compiler/rustc_codegen_cranelift/scripts/test_bootstrap.sh", "status": "modified", "additions": 1, "deletions": 61, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_bootstrap.sh", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_bootstrap.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_bootstrap.sh?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -3,70 +3,10 @@ set -e\n \n cd \"$(dirname \"$0\")/../\"\n \n-./build.sh\n-source build/config.sh\n+source ./scripts/setup_rust_fork.sh\n \n echo \"[TEST] Bootstrap of rustc\"\n-git clone https://github.com/rust-lang/rust.git || true\n pushd rust\n-git fetch\n-git checkout -- .\n-git checkout \"$(rustc -V | cut -d' ' -f3 | tr -d '(')\"\n-\n-git apply - <<EOF\n-diff --git a/Cargo.toml b/Cargo.toml\n-index 5bd1147cad5..10d68a2ff14 100644\n---- a/Cargo.toml\n-+++ b/Cargo.toml\n-@@ -111,5 +111,7 @@ rustc-std-workspace-std = { path = 'library/rustc-std-workspace-std' }\n- rustc-std-workspace-alloc = { path = 'library/rustc-std-workspace-alloc' }\n- rustc-std-workspace-std = { path = 'library/rustc-std-workspace-std' }\n- \n-+compiler_builtins = { path = \"../build_sysroot/compiler-builtins\" }\n-+\n- [patch.\"https://github.com/rust-lang/rust-clippy\"]\n- clippy_lints = { path = \"src/tools/clippy/clippy_lints\" }\n-diff --git a/compiler/rustc_data_structures/Cargo.toml b/compiler/rustc_data_structures/Cargo.toml\n-index 23e689fcae7..5f077b765b6 100644\n---- a/compiler/rustc_data_structures/Cargo.toml\n-+++ b/compiler/rustc_data_structures/Cargo.toml\n-@@ -32,7 +32,6 @@ tempfile = \"3.0.5\"\n-\n- [dependencies.parking_lot]\n- version = \"0.11\"\n--features = [\"nightly\"]\n-\n- [target.'cfg(windows)'.dependencies]\n- winapi = { version = \"0.3\", features = [\"fileapi\", \"psapi\"] }\n-diff --git a/library/alloc/Cargo.toml b/library/alloc/Cargo.toml\n-index d95b5b7f17f..00b6f0e3635 100644\n---- a/library/alloc/Cargo.toml\n-+++ b/library/alloc/Cargo.toml\n-@@ -8,7 +8,7 @@ edition = \"2018\"\n- \n- [dependencies]\n- core = { path = \"../core\" }\n--compiler_builtins = { version = \"0.1.39\", features = ['rustc-dep-of-std'] }\n-+compiler_builtins = { version = \"0.1.39\", features = ['rustc-dep-of-std', 'no-asm'] }\n- \n- [dev-dependencies]\n- rand = \"0.7\"\n-EOF\n-\n-cat > config.toml <<EOF\n-[llvm]\n-ninja = false\n-\n-[build]\n-rustc = \"$(pwd)/../build/bin/cg_clif\"\n-cargo = \"$(rustup which cargo)\"\n-full-bootstrap = true\n-local-rebuild = true\n-\n-[rust]\n-codegen-backends = [\"cranelift\"]\n-EOF\n-\n rm -r compiler/rustc_codegen_cranelift/{Cargo.*,src}\n cp ../Cargo.* compiler/rustc_codegen_cranelift/\n cp -r ../src compiler/rustc_codegen_cranelift/src"}, {"sha": "fbc3feceec7ac56e4f208458296bdbe0dc2cac6d", "filename": "compiler/rustc_codegen_cranelift/scripts/test_rustc_tests.sh", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -0,0 +1,87 @@\n+#!/bin/bash\n+set -e\n+\n+cd $(dirname \"$0\")/../\n+\n+source ./scripts/setup_rust_fork.sh\n+\n+echo \"[TEST] Test suite of rustc\"\n+pushd rust\n+\n+cargo install ripgrep\n+\n+rm -r src/test/ui/{extern/,panics/,unsized-locals/,thinlto/,simd*,*lto*.rs,linkage*,unwind-*.rs} || true\n+for test in $(rg --files-with-matches \"asm!|catch_unwind|should_panic|lto\" src/test/ui); do\n+  rm $test\n+done\n+\n+for test in $(rg -i --files-with-matches \"//(\\[\\w+\\])?~|// error-pattern:|// build-fail|// run-fail|-Cllvm-args\" src/test/ui); do\n+  rm $test\n+done\n+\n+git checkout -- src/test/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n+\n+# these all depend on unwinding support\n+rm src/test/ui/backtrace.rs\n+rm src/test/ui/array-slice-vec/box-of-array-of-drop-*.rs\n+rm src/test/ui/array-slice-vec/slice-panic-*.rs\n+rm src/test/ui/array-slice-vec/nested-vec-3.rs\n+rm src/test/ui/cleanup-rvalue-temp-during-incomplete-alloc.rs\n+rm src/test/ui/issues/issue-26655.rs\n+rm src/test/ui/issues/issue-29485.rs\n+rm src/test/ui/issues/issue-30018-panic.rs\n+rm src/test/ui/multi-panic.rs\n+rm src/test/ui/sepcomp/sepcomp-unwind.rs\n+rm src/test/ui/structs-enums/unit-like-struct-drop-run.rs\n+rm src/test/ui/terminate-in-initializer.rs\n+rm src/test/ui/threads-sendsync/task-stderr.rs\n+rm src/test/ui/numbers-arithmetic/int-abs-overflow.rs\n+rm src/test/ui/drop/drop-trait-enum.rs\n+rm src/test/ui/numbers-arithmetic/issue-8460.rs\n+\n+rm src/test/ui/issues/issue-28950.rs # depends on stack size optimizations\n+rm src/test/ui/init-large-type.rs # same\n+rm src/test/ui/sse2.rs # cpuid not supported, so sse2 not detected\n+rm src/test/ui/issues/issue-33992.rs # unsupported linkages\n+rm src/test/ui/issues/issue-51947.rs # same\n+rm src/test/ui/numbers-arithmetic/saturating-float-casts.rs # intrinsic gives different but valid result\n+rm src/test/ui/mir/mir_misc_casts.rs # depends on deduplication of constants\n+rm src/test/ui/mir/mir_raw_fat_ptr.rs # same\n+rm src/test/ui/async-await/async-fn-size-moved-locals.rs # -Cpanic=abort shrinks some generator by one byte\n+rm src/test/ui/async-await/async-fn-size-uninit-locals.rs # same\n+rm src/test/ui/generator/size-moved-locals.rs # same\n+rm src/test/ui/fn/dyn-fn-alignment.rs # wants a 256 byte alignment\n+rm src/test/ui/test-attrs/test-fn-signature-verification-for-explicit-return-type.rs # \"Cannot run dynamic test fn out-of-process\"\n+rm src/test/ui/intrinsics/intrinsic-nearby.rs # unimplemented nearbyintf32 and nearbyintf64 intrinsics\n+\n+rm src/test/incremental/hashes/inline_asm.rs # inline asm\n+rm src/test/incremental/issue-72386.rs # same\n+rm src/test/incremental/change_crate_dep_kind.rs # requires -Cpanic=unwind\n+rm src/test/incremental/issue-49482.rs # same\n+rm src/test/incremental/issue-54059.rs # same\n+rm src/test/incremental/lto.rs # requires lto\n+\n+rm src/test/pretty/asm.rs # inline asm\n+rm src/test/pretty/raw-str-nonexpr.rs # same\n+\n+rm -r src/test/run-pass-valgrind/unsized-locals\n+\n+rm src/test/ui/json-bom-plus-crlf-multifile.rs # differing warning\n+rm src/test/ui/json-bom-plus-crlf.rs # same\n+rm src/test/ui/type-alias-impl-trait/cross_crate_ice*.rs # requires removed aux dep\n+\n+rm src/test/ui/allocator/no_std-alloc-error-handler-default.rs # missing rust_oom definition\n+rm src/test/ui/cfg/cfg-panic.rs\n+rm src/test/ui/default-alloc-error-hook.rs\n+rm -r src/test/ui/hygiene/\n+\n+rm -r src/test/ui/polymorphization/ # polymorphization not yet supported\n+rm src/test/codegen-units/polymorphization/unused_type_parameters.rs # same\n+\n+rm -r src/test/run-make/fmt-write-bloat/ # tests an optimization\n+rm src/test/ui/abi/mir/mir_codegen_calls_variadic.rs # requires float varargs\n+rm src/test/ui/abi/variadic-ffi.rs # requires callee side vararg support\n+\n+echo \"[TEST] rustc test suite\"\n+RUST_TEST_NOCAPTURE=1 COMPILETEST_FORCE_STAGE0=1 ./x.py test --stage 0 src/test/{codegen-units,run-make,run-pass-valgrind,ui}\n+popd"}, {"sha": "3afcea8f06bd6c257b6ec97077d17ee7496ed565", "filename": "compiler/rustc_codegen_cranelift/scripts/tests.sh", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -71,14 +71,20 @@ function base_sysroot_tests() {\n     echo \"[AOT] mod_bench\"\n     $MY_RUSTC example/mod_bench.rs --crate-type bin --target \"$TARGET_TRIPLE\"\n     $RUN_WRAPPER ./target/out/mod_bench\n+}\n \n+function extended_sysroot_tests() {\n     pushd rand\n-    rm -r ./target || true\n-    ../build/cargo.sh test --workspace\n+    cargo clean\n+    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n+        echo \"[TEST] rust-random/rand\"\n+        ../build/cargo.sh test --workspace\n+    else\n+        echo \"[AOT] rust-random/rand\"\n+        ../build/cargo.sh build --workspace --target $TARGET_TRIPLE --tests\n+    fi\n     popd\n-}\n \n-function extended_sysroot_tests() {\n     pushd simple-raytracer\n     if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n         echo \"[BENCH COMPILE] ebobby/simple-raytracer\"\n@@ -92,27 +98,40 @@ function extended_sysroot_tests() {\n     else\n         echo \"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\"\n         echo \"[COMPILE] ebobby/simple-raytracer\"\n-        ../cargo.sh build\n+        ../build/cargo.sh build --target $TARGET_TRIPLE\n         echo \"[BENCH RUN] ebobby/simple-raytracer (skipped)\"\n     fi\n     popd\n \n     pushd build_sysroot/sysroot_src/library/core/tests\n     echo \"[TEST] libcore\"\n-    rm -r ./target || true\n-    ../../../../../build/cargo.sh test\n+    cargo clean\n+    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n+        ../../../../../build/cargo.sh test\n+    else\n+        ../../../../../build/cargo.sh build --target $TARGET_TRIPLE --tests\n+    fi\n     popd\n \n     pushd regex\n     echo \"[TEST] rust-lang/regex example shootout-regex-dna\"\n-    ../build/cargo.sh clean\n+    cargo clean\n     # Make sure `[codegen mono items] start` doesn't poison the diff\n-    ../build/cargo.sh build --example shootout-regex-dna\n-    cat examples/regexdna-input.txt | ../build/cargo.sh run --example shootout-regex-dna | grep -v \"Spawned thread\" > res.txt\n-    diff -u res.txt examples/regexdna-output.txt\n+    ../build/cargo.sh build --example shootout-regex-dna --target $TARGET_TRIPLE\n+    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n+        cat examples/regexdna-input.txt \\\n+            | ../build/cargo.sh run --example shootout-regex-dna --target $TARGET_TRIPLE \\\n+            | grep -v \"Spawned thread\" > res.txt\n+        diff -u res.txt examples/regexdna-output.txt\n+    fi\n \n-    echo \"[TEST] rust-lang/regex tests\"\n-    ../build/cargo.sh test --tests -- --exclude-should-panic --test-threads 1 -Zunstable-options -q\n+    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n+        echo \"[TEST] rust-lang/regex tests\"\n+        ../build/cargo.sh test --tests -- --exclude-should-panic --test-threads 1 -Zunstable-options -q\n+    else\n+        echo \"[AOT] rust-lang/regex tests\"\n+        ../build/cargo.sh build --tests --target $TARGET_TRIPLE\n+    fi\n     popd\n }\n "}, {"sha": "5fbaed7283a6781400a2ca0628cc731ae49edb8e", "filename": "compiler/rustc_codegen_cranelift/src/abi/comments.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -11,9 +11,11 @@ use cranelift_codegen::entity::EntityRef;\n use crate::prelude::*;\n \n pub(super) fn add_args_header_comment(fx: &mut FunctionCx<'_, '_, '_>) {\n-    fx.add_global_comment(\n-        \"kind  loc.idx   param    pass mode                            ty\".to_string(),\n-    );\n+    if fx.clif_comments.enabled() {\n+        fx.add_global_comment(\n+            \"kind  loc.idx   param    pass mode                            ty\".to_string(),\n+        );\n+    }\n }\n \n pub(super) fn add_arg_comment<'tcx>(\n@@ -25,6 +27,10 @@ pub(super) fn add_arg_comment<'tcx>(\n     arg_abi_mode: PassMode,\n     arg_layout: TyAndLayout<'tcx>,\n ) {\n+    if !fx.clif_comments.enabled() {\n+        return;\n+    }\n+\n     let local = if let Some(local) = local {\n         Cow::Owned(format!(\"{:?}\", local))\n     } else {\n@@ -59,17 +65,22 @@ pub(super) fn add_arg_comment<'tcx>(\n }\n \n pub(super) fn add_locals_header_comment(fx: &mut FunctionCx<'_, '_, '_>) {\n-    fx.add_global_comment(String::new());\n-    fx.add_global_comment(\n-        \"kind  local ty                              size align (abi,pref)\".to_string(),\n-    );\n+    if fx.clif_comments.enabled() {\n+        fx.add_global_comment(String::new());\n+        fx.add_global_comment(\n+            \"kind  local ty                              size align (abi,pref)\".to_string(),\n+        );\n+    }\n }\n \n pub(super) fn add_local_place_comments<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     place: CPlace<'tcx>,\n     local: Local,\n ) {\n+    if !fx.clif_comments.enabled() {\n+        return;\n+    }\n     let TyAndLayout { ty, layout } = place.layout();\n     let rustc_target::abi::Layout { size, align, abi: _, variants: _, fields: _, largest_niche: _ } =\n         layout;\n@@ -90,7 +101,7 @@ pub(super) fn add_local_place_comments<'tcx>(\n             } else {\n                 Cow::Borrowed(\"\")\n             };\n-            match ptr.base_and_offset() {\n+            match ptr.debug_base_and_offset() {\n                 (crate::pointer::PointerBase::Addr(addr), offset) => {\n                     (\"reuse\", format!(\"storage={}{}{}\", addr, offset, meta).into())\n                 }"}, {"sha": "0e7829eaa26acd3c5946edb9d25b06f0b28a7789", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,6 +1,5 @@\n //! Handling of everything related to the calling convention. Also fills `fx.local_map`.\n \n-#[cfg(debug_assertions)]\n mod comments;\n mod pass_mode;\n mod returning;\n@@ -75,8 +74,9 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         let func_id = import_function(self.tcx, self.cx.module, inst);\n         let func_ref = self.cx.module.declare_func_in_func(func_id, &mut self.bcx.func);\n \n-        #[cfg(debug_assertions)]\n-        self.add_comment(func_ref, format!(\"{:?}\", inst));\n+        if self.clif_comments.enabled() {\n+            self.add_comment(func_ref, format!(\"{:?}\", inst));\n+        }\n \n         func_ref\n     }\n@@ -92,8 +92,7 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         let func_id = self.cx.module.declare_function(&name, Linkage::Import, &sig).unwrap();\n         let func_ref = self.cx.module.declare_func_in_func(func_id, &mut self.bcx.func);\n         let call_inst = self.bcx.ins().call(func_ref, args);\n-        #[cfg(debug_assertions)]\n-        {\n+        if self.clif_comments.enabled() {\n             self.add_comment(call_inst, format!(\"easy_call {}\", name));\n         }\n         let results = self.bcx.inst_results(call_inst);\n@@ -149,7 +148,6 @@ fn make_local_place<'tcx>(\n         CPlace::new_stack_slot(fx, layout)\n     };\n \n-    #[cfg(debug_assertions)]\n     self::comments::add_local_place_comments(fx, place, local);\n \n     place\n@@ -163,7 +161,6 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n \n     let ssa_analyzed = crate::analyze::analyze(fx);\n \n-    #[cfg(debug_assertions)]\n     self::comments::add_args_header_comment(fx);\n \n     let mut block_params_iter = fx.bcx.func.dfg.block_params(start_block).to_vec().into_iter();\n@@ -228,7 +225,6 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n     fx.fn_abi = Some(fn_abi);\n     assert!(block_params_iter.next().is_none(), \"arg_value left behind\");\n \n-    #[cfg(debug_assertions)]\n     self::comments::add_locals_header_comment(fx);\n \n     for (local, arg_kind, ty) in func_params {\n@@ -256,7 +252,6 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n                         CPlace::for_ptr(addr, val.layout())\n                     };\n \n-                    #[cfg(debug_assertions)]\n                     self::comments::add_local_place_comments(fx, place, local);\n \n                     assert_eq!(fx.local_map.push(place), local);\n@@ -392,8 +387,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     let (func_ref, first_arg) = match instance {\n         // Trait object call\n         Some(Instance { def: InstanceDef::Virtual(_, idx), .. }) => {\n-            #[cfg(debug_assertions)]\n-            {\n+            if fx.clif_comments.enabled() {\n                 let nop_inst = fx.bcx.ins().nop();\n                 fx.add_comment(\n                     nop_inst,\n@@ -414,8 +408,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n \n         // Indirect call\n         None => {\n-            #[cfg(debug_assertions)]\n-            {\n+            if fx.clif_comments.enabled() {\n                 let nop_inst = fx.bcx.ins().nop();\n                 fx.add_comment(nop_inst, \"indirect call\");\n             }\n@@ -477,10 +470,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     // FIXME find a cleaner way to support varargs\n     if fn_sig.c_variadic {\n         if !matches!(fn_sig.abi, Abi::C { .. }) {\n-            fx.tcx.sess.span_fatal(\n-                span,\n-                &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi),\n-            );\n+            fx.tcx.sess.span_fatal(span, &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi));\n         }\n         let sig_ref = fx.bcx.func.dfg.call_signature(call_inst).unwrap();\n         let abi_params = call_args"}, {"sha": "7c275965199e056567512a0b71118943b80838cc", "filename": "compiler/rustc_codegen_cranelift/src/abi/pass_mode.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -208,7 +208,7 @@ pub(super) fn from_casted_value<'tcx>(\n     });\n     let ptr = Pointer::new(fx.bcx.ins().stack_addr(pointer_ty(fx.tcx), stack_slot, 0));\n     let mut offset = 0;\n-    let mut block_params_iter = block_params.into_iter().copied();\n+    let mut block_params_iter = block_params.iter().copied();\n     for param in abi_params {\n         let val = ptr.offset_i64(fx, offset).store(\n             fx,\n@@ -248,8 +248,8 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n /// as necessary.\n pub(super) fn cvalue_for_param<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    #[cfg_attr(not(debug_assertions), allow(unused_variables))] local: Option<mir::Local>,\n-    #[cfg_attr(not(debug_assertions), allow(unused_variables))] local_field: Option<usize>,\n+    local: Option<mir::Local>,\n+    local_field: Option<usize>,\n     arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n     block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> Option<CValue<'tcx>> {\n@@ -263,7 +263,6 @@ pub(super) fn cvalue_for_param<'tcx>(\n         })\n         .collect::<SmallVec<[_; 2]>>();\n \n-    #[cfg(debug_assertions)]\n     crate::abi::comments::add_arg_comment(\n         fx,\n         \"arg\","}, {"sha": "e1c53224b4f841751bba96f80a37b99fbcdd9e93", "filename": "compiler/rustc_codegen_cranelift/src/abi/returning.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -84,10 +84,6 @@ pub(super) fn codegen_return_param<'tcx>(\n         }\n     };\n \n-    #[cfg(not(debug_assertions))]\n-    let _ = ret_param;\n-\n-    #[cfg(debug_assertions)]\n     crate::abi::comments::add_arg_comment(\n         fx,\n         \"ret\",\n@@ -146,7 +142,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx, T>(\n                 let results = fx\n                     .bcx\n                     .inst_results(call_inst)\n-                    .into_iter()\n+                    .iter()\n                     .copied()\n                     .collect::<SmallVec<[Value; 2]>>();\n                 let result ="}, {"sha": "f60645a9f97bc9eed7559924b480ff6d2de29427", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -3,6 +3,7 @@\n \n use crate::prelude::*;\n \n+use cranelift_codegen::binemit::{NullStackMapSink, NullTrapSink};\n use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n use rustc_span::symbol::sym;\n \n@@ -92,7 +93,7 @@ fn codegen_inner(\n             bcx.finalize();\n         }\n         module\n-            .define_function(func_id, &mut ctx, &mut cranelift_codegen::binemit::NullTrapSink {})\n+            .define_function(func_id, &mut ctx, &mut NullTrapSink {}, &mut NullStackMapSink {})\n             .unwrap();\n         unwind_context.add_function(func_id, &ctx, module.isa());\n     }\n@@ -132,7 +133,7 @@ fn codegen_inner(\n         bcx.finalize();\n     }\n     module\n-        .define_function(func_id, &mut ctx, &mut cranelift_codegen::binemit::NullTrapSink {})\n+        .define_function(func_id, &mut ctx, &mut NullTrapSink {}, &mut NullStackMapSink {})\n         .unwrap();\n     unwind_context.add_function(func_id, &ctx, module.isa());\n }"}, {"sha": "b34a29c25b92e7a56b1259bd23eca71b5ff33485", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 28, "deletions": 35, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,17 +1,14 @@\n //! Codegen of a single function\n \n+use cranelift_codegen::binemit::{NullStackMapSink, NullTrapSink};\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::layout::FnAbiExt;\n use rustc_target::abi::call::FnAbi;\n \n use crate::prelude::*;\n \n-pub(crate) fn codegen_fn<'tcx>(\n-    cx: &mut crate::CodegenCx<'_, 'tcx>,\n-    instance: Instance<'tcx>,\n-    linkage: Linkage,\n-) {\n+pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: Instance<'tcx>) {\n     let tcx = cx.tcx;\n \n     let _inst_guard =\n@@ -23,7 +20,7 @@ pub(crate) fn codegen_fn<'tcx>(\n     // Declare function\n     let name = tcx.symbol_name(instance).name.to_string();\n     let sig = get_function_sig(tcx, cx.module.isa().triple(), instance);\n-    let func_id = cx.module.declare_function(&name, linkage, &sig).unwrap();\n+    let func_id = cx.module.declare_function(&name, Linkage::Local, &sig).unwrap();\n \n     cx.cached_context.clear();\n \n@@ -131,7 +128,7 @@ pub(crate) fn codegen_fn<'tcx>(\n     let module = &mut cx.module;\n     tcx.sess.time(\"define function\", || {\n         module\n-            .define_function(func_id, context, &mut cranelift_codegen::binemit::NullTrapSink {})\n+            .define_function(func_id, context, &mut NullTrapSink {}, &mut NullStackMapSink {})\n             .unwrap()\n     });\n \n@@ -219,8 +216,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n             codegen_stmt(fx, block, stmt);\n         }\n \n-        #[cfg(debug_assertions)]\n-        {\n+        if fx.clif_comments.enabled() {\n             let mut terminator_head = \"\\n\".to_string();\n             bb_data.terminator().kind.fmt_head(&mut terminator_head).unwrap();\n             let inst = fx.bcx.func.layout.last_inst(block).unwrap();\n@@ -433,12 +429,14 @@ fn codegen_stmt<'tcx>(\n \n     fx.set_debug_loc(stmt.source_info);\n \n-    #[cfg(false_debug_assertions)]\n+    #[cfg(disabled)]\n     match &stmt.kind {\n         StatementKind::StorageLive(..) | StatementKind::StorageDead(..) => {} // Those are not very useful\n         _ => {\n-            let inst = fx.bcx.func.layout.last_inst(cur_block).unwrap();\n-            fx.add_comment(inst, format!(\"{:?}\", stmt));\n+            if fx.clif_comments.enabled() {\n+                let inst = fx.bcx.func.layout.last_inst(cur_block).unwrap();\n+                fx.add_comment(inst, format!(\"{:?}\", stmt));\n+            }\n         }\n     }\n \n@@ -464,16 +462,16 @@ fn codegen_stmt<'tcx>(\n                     let val = crate::constant::codegen_tls_ref(fx, def_id, lval.layout());\n                     lval.write_cvalue(fx, val);\n                 }\n-                Rvalue::BinaryOp(bin_op, box (ref lhs, ref rhs)) => {\n-                    let lhs = codegen_operand(fx, lhs);\n-                    let rhs = codegen_operand(fx, rhs);\n+                Rvalue::BinaryOp(bin_op, ref lhs_rhs) => {\n+                    let lhs = codegen_operand(fx, &lhs_rhs.0);\n+                    let rhs = codegen_operand(fx, &lhs_rhs.1);\n \n                     let res = crate::num::codegen_binop(fx, bin_op, lhs, rhs);\n                     lval.write_cvalue(fx, res);\n                 }\n-                Rvalue::CheckedBinaryOp(bin_op, box (ref lhs, ref rhs)) => {\n-                    let lhs = codegen_operand(fx, lhs);\n-                    let rhs = codegen_operand(fx, rhs);\n+                Rvalue::CheckedBinaryOp(bin_op, ref lhs_rhs) => {\n+                    let lhs = codegen_operand(fx, &lhs_rhs.0);\n+                    let rhs = codegen_operand(fx, &lhs_rhs.1);\n \n                     let res = if !fx.tcx.sess.overflow_checks() {\n                         let val =\n@@ -659,7 +657,9 @@ fn codegen_stmt<'tcx>(\n                         .val\n                         .try_to_bits(fx.tcx.data_layout.pointer_size)\n                         .unwrap();\n-                    if fx.clif_type(operand.layout().ty) == Some(types::I8) {\n+                    if operand.layout().size.bytes() == 0 {\n+                        // Do nothing for ZST's\n+                    } else if fx.clif_type(operand.layout().ty) == Some(types::I8) {\n                         let times = fx.bcx.ins().iconst(fx.pointer_type, times as i64);\n                         // FIXME use emit_small_memset where possible\n                         let addr = lval.to_ptr().get_addr(fx);\n@@ -832,25 +832,18 @@ fn codegen_stmt<'tcx>(\n             }\n         }\n         StatementKind::Coverage { .. } => fx.tcx.sess.fatal(\"-Zcoverage is unimplemented\"),\n-        StatementKind::CopyNonOverlapping(box rustc_middle::mir::CopyNonOverlapping {\n-          src,\n-          dst,\n-          count,\n-        }) => {\n-            let dst = codegen_operand(fx, dst);\n+        StatementKind::CopyNonOverlapping(inner) => {\n+            let dst = codegen_operand(fx, &inner.dst);\n             let pointee = dst\n-              .layout()\n-              .pointee_info_at(fx, rustc_target::abi::Size::ZERO)\n-              .expect(\"Expected pointer\");\n+                .layout()\n+                .pointee_info_at(fx, rustc_target::abi::Size::ZERO)\n+                .expect(\"Expected pointer\");\n             let dst = dst.load_scalar(fx);\n-            let src = codegen_operand(fx, src).load_scalar(fx);\n-            let count = codegen_operand(fx, count).load_scalar(fx);\n+            let src = codegen_operand(fx, &inner.src).load_scalar(fx);\n+            let count = codegen_operand(fx, &inner.count).load_scalar(fx);\n             let elem_size: u64 = pointee.size.bytes();\n-            let bytes = if elem_size != 1 {\n-               fx.bcx.ins().imul_imm(count, elem_size as i64)\n-            } else {\n-               count\n-            };\n+            let bytes =\n+                if elem_size != 1 { fx.bcx.ins().imul_imm(count, elem_size as i64) } else { count };\n             fx.bcx.call_memcpy(fx.cx.module.target_config(), dst, src, bytes);\n         }\n     }"}, {"sha": "ffe1922ab9056dc3c82a303e21d8d147b7243a2c", "filename": "compiler/rustc_codegen_cranelift/src/codegen_i128.rs", "status": "modified", "additions": 70, "deletions": 19, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -32,18 +32,56 @@ pub(crate) fn maybe_codegen<'tcx>(\n         BinOp::Add | BinOp::Sub if !checked => None,\n         BinOp::Mul if !checked => {\n             let val_ty = if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n-            Some(fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty))\n+            if fx.tcx.sess.target.is_like_windows {\n+                let ret_place = CPlace::new_stack_slot(fx, lhs.layout());\n+                let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n+                let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n+                assert!(lhs_extra.is_none());\n+                assert!(rhs_extra.is_none());\n+                let args =\n+                    [ret_place.to_ptr().get_addr(fx), lhs_ptr.get_addr(fx), rhs_ptr.get_addr(fx)];\n+                fx.lib_call(\n+                    \"__multi3\",\n+                    vec![\n+                        AbiParam::special(pointer_ty(fx.tcx), ArgumentPurpose::StructReturn),\n+                        AbiParam::new(pointer_ty(fx.tcx)),\n+                        AbiParam::new(pointer_ty(fx.tcx)),\n+                    ],\n+                    vec![],\n+                    &args,\n+                );\n+                Some(ret_place.to_cvalue(fx))\n+            } else {\n+                Some(fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty))\n+            }\n         }\n         BinOp::Add | BinOp::Sub | BinOp::Mul => {\n             assert!(checked);\n             let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n             let out_place = CPlace::new_stack_slot(fx, fx.layout_of(out_ty));\n-            let param_types = vec![\n-                AbiParam::special(pointer_ty(fx.tcx), ArgumentPurpose::StructReturn),\n-                AbiParam::new(types::I128),\n-                AbiParam::new(types::I128),\n-            ];\n-            let args = [out_place.to_ptr().get_addr(fx), lhs.load_scalar(fx), rhs.load_scalar(fx)];\n+            let (param_types, args) = if fx.tcx.sess.target.is_like_windows {\n+                let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n+                let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n+                assert!(lhs_extra.is_none());\n+                assert!(rhs_extra.is_none());\n+                (\n+                    vec![\n+                        AbiParam::special(pointer_ty(fx.tcx), ArgumentPurpose::StructReturn),\n+                        AbiParam::new(pointer_ty(fx.tcx)),\n+                        AbiParam::new(pointer_ty(fx.tcx)),\n+                    ],\n+                    [out_place.to_ptr().get_addr(fx), lhs_ptr.get_addr(fx), rhs_ptr.get_addr(fx)],\n+                )\n+            } else {\n+                (\n+                    vec![\n+                        AbiParam::special(pointer_ty(fx.tcx), ArgumentPurpose::StructReturn),\n+                        AbiParam::new(types::I128),\n+                        AbiParam::new(types::I128),\n+                    ],\n+                    [out_place.to_ptr().get_addr(fx), lhs.load_scalar(fx), rhs.load_scalar(fx)],\n+                )\n+            };\n             let name = match (bin_op, is_signed) {\n                 (BinOp::Add, false) => \"__rust_u128_addo\",\n                 (BinOp::Add, true) => \"__rust_i128_addo\",\n@@ -57,20 +95,33 @@ pub(crate) fn maybe_codegen<'tcx>(\n             Some(out_place.to_cvalue(fx))\n         }\n         BinOp::Offset => unreachable!(\"offset should only be used on pointers, not 128bit ints\"),\n-        BinOp::Div => {\n+        BinOp::Div | BinOp::Rem => {\n             assert!(!checked);\n-            if is_signed {\n-                Some(fx.easy_call(\"__divti3\", &[lhs, rhs], fx.tcx.types.i128))\n-            } else {\n-                Some(fx.easy_call(\"__udivti3\", &[lhs, rhs], fx.tcx.types.u128))\n-            }\n-        }\n-        BinOp::Rem => {\n-            assert!(!checked);\n-            if is_signed {\n-                Some(fx.easy_call(\"__modti3\", &[lhs, rhs], fx.tcx.types.i128))\n+            let name = match (bin_op, is_signed) {\n+                (BinOp::Div, false) => \"__udivti3\",\n+                (BinOp::Div, true) => \"__divti3\",\n+                (BinOp::Rem, false) => \"__umodti3\",\n+                (BinOp::Rem, true) => \"__modti3\",\n+                _ => unreachable!(),\n+            };\n+            if fx.tcx.sess.target.is_like_windows {\n+                let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n+                let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n+                assert!(lhs_extra.is_none());\n+                assert!(rhs_extra.is_none());\n+                let args = [lhs_ptr.get_addr(fx), rhs_ptr.get_addr(fx)];\n+                let ret = fx.lib_call(\n+                    name,\n+                    vec![AbiParam::new(pointer_ty(fx.tcx)), AbiParam::new(pointer_ty(fx.tcx))],\n+                    vec![AbiParam::new(types::I64X2)],\n+                    &args,\n+                )[0];\n+                // FIXME use bitcast instead of store to get from i64x2 to i128\n+                let ret_place = CPlace::new_stack_slot(fx, lhs.layout());\n+                ret_place.to_ptr().store(fx, ret, MemFlags::trusted());\n+                Some(ret_place.to_cvalue(fx))\n             } else {\n-                Some(fx.easy_call(\"__umodti3\", &[lhs, rhs], fx.tcx.types.u128))\n+                Some(fx.easy_call(name, &[lhs, rhs], lhs.layout().ty))\n             }\n         }\n         BinOp::Lt | BinOp::Le | BinOp::Eq | BinOp::Ge | BinOp::Gt | BinOp::Ne => {"}, {"sha": "b5874f62535cab275ff566754c398196b32b36e0", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -361,8 +361,7 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         let _ = self.cx.module.define_data(msg_id, &data_ctx);\n \n         let local_msg_id = self.cx.module.declare_data_in_func(msg_id, self.bcx.func);\n-        #[cfg(debug_assertions)]\n-        {\n+        if self.clif_comments.enabled() {\n             self.add_comment(local_msg_id, msg);\n         }\n         self.bcx.ins().global_value(self.pointer_type, local_msg_id)"}, {"sha": "177f850afb398ef6c90e8d1e161920ec56d846e0", "filename": "compiler/rustc_codegen_cranelift/src/compiler_builtins.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcompiler_builtins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcompiler_builtins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcompiler_builtins.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -0,0 +1,41 @@\n+macro builtin_functions($register:ident; $(fn $name:ident($($arg_name:ident: $arg_ty:ty),*) -> $ret_ty:ty;)*) {\n+    #[cfg(feature = \"jit\")]\n+    #[allow(improper_ctypes)]\n+    extern \"C\" {\n+        $(fn $name($($arg_name: $arg_ty),*) -> $ret_ty;)*\n+    }\n+\n+    #[cfg(feature = \"jit\")]\n+    pub(crate) fn $register(builder: &mut cranelift_jit::JITBuilder) {\n+        for &(name, val) in &[$((stringify!($name), $name as *const u8)),*] {\n+            builder.symbol(name, val);\n+        }\n+    }\n+}\n+\n+builtin_functions! {\n+    register_functions_for_jit;\n+\n+    // integers\n+    fn __multi3(a: i128, b: i128) -> i128;\n+    fn __udivti3(n: u128, d: u128) -> u128;\n+    fn __divti3(n: i128, d: i128) -> i128;\n+    fn __umodti3(n: u128, d: u128) -> u128;\n+    fn __modti3(n: i128, d: i128) -> i128;\n+    fn __rust_u128_addo(a: u128, b: u128) -> (u128, bool);\n+    fn __rust_i128_addo(a: i128, b: i128) -> (i128, bool);\n+    fn __rust_u128_subo(a: u128, b: u128) -> (u128, bool);\n+    fn __rust_i128_subo(a: i128, b: i128) -> (i128, bool);\n+    fn __rust_u128_mulo(a: u128, b: u128) -> (u128, bool);\n+    fn __rust_i128_mulo(a: i128, b: i128) -> (i128, bool);\n+\n+    // floats\n+    fn __floattisf(i: i128) -> f32;\n+    fn __floattidf(i: i128) -> f64;\n+    fn __floatuntisf(i: u128) -> f32;\n+    fn __floatuntidf(i: u128) -> f64;\n+    fn __fixsfti(f: f32) -> i128;\n+    fn __fixdfti(f: f64) -> i128;\n+    fn __fixunssfti(f: f32) -> u128;\n+    fn __fixunsdfti(f: f64) -> u128;\n+}"}, {"sha": "fcd41c844659d0bb937d2d70c044b9abcb08ca00", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -85,8 +85,9 @@ pub(crate) fn codegen_tls_ref<'tcx>(\n ) -> CValue<'tcx> {\n     let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n     let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-    #[cfg(debug_assertions)]\n-    fx.add_comment(local_data_id, format!(\"tls {:?}\", def_id));\n+    if fx.clif_comments.enabled() {\n+        fx.add_comment(local_data_id, format!(\"tls {:?}\", def_id));\n+    }\n     let tls_ptr = fx.bcx.ins().tls_value(fx.pointer_type, local_data_id);\n     CValue::by_val(tls_ptr, layout)\n }\n@@ -98,8 +99,9 @@ fn codegen_static_ref<'tcx>(\n ) -> CPlace<'tcx> {\n     let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n     let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-    #[cfg(debug_assertions)]\n-    fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n+    if fx.clif_comments.enabled() {\n+        fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n+    }\n     let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n     assert!(!layout.is_unsized(), \"unsized statics aren't supported\");\n     assert!(\n@@ -122,7 +124,9 @@ pub(crate) fn codegen_constant<'tcx>(\n     };\n     let const_val = match const_.val {\n         ConstKind::Value(const_val) => const_val,\n-        ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted }) if fx.tcx.is_static(def.did) => {\n+        ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted })\n+            if fx.tcx.is_static(def.did) =>\n+        {\n             assert!(substs.is_empty());\n             assert!(promoted.is_none());\n \n@@ -183,8 +187,9 @@ pub(crate) fn codegen_const_value<'tcx>(\n                                 data_id_for_alloc_id(fx.cx.module, ptr.alloc_id, alloc.mutability);\n                             let local_data_id =\n                                 fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-                            #[cfg(debug_assertions)]\n-                            fx.add_comment(local_data_id, format!(\"{:?}\", ptr.alloc_id));\n+                            if fx.clif_comments.enabled() {\n+                                fx.add_comment(local_data_id, format!(\"{:?}\", ptr.alloc_id));\n+                            }\n                             fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                         }\n                         Some(GlobalAlloc::Function(instance)) => {\n@@ -199,8 +204,9 @@ pub(crate) fn codegen_const_value<'tcx>(\n                             let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n                             let local_data_id =\n                                 fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-                            #[cfg(debug_assertions)]\n-                            fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n+                            if fx.clif_comments.enabled() {\n+                                fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n+                            }\n                             fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                         }\n                         None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n@@ -241,8 +247,9 @@ fn pointer_for_allocation<'tcx>(\n     let data_id = data_id_for_alloc_id(fx.cx.module, alloc_id, alloc.mutability);\n \n     let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-    #[cfg(debug_assertions)]\n-    fx.add_comment(local_data_id, format!(\"{:?}\", alloc_id));\n+    if fx.clif_comments.enabled() {\n+        fx.add_comment(local_data_id, format!(\"{:?}\", alloc_id));\n+    }\n     let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n     crate::pointer::Pointer::new(global_ptr)\n }"}, {"sha": "8578ab33ced680bb50340819c7aa2939ff6b9bef", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/line_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -39,11 +39,11 @@ fn osstr_as_utf8_bytes(path: &OsStr) -> &[u8] {\n     #[cfg(unix)]\n     {\n         use std::os::unix::ffi::OsStrExt;\n-        return path.as_bytes();\n+        path.as_bytes()\n     }\n     #[cfg(not(unix))]\n     {\n-        return path.to_str().unwrap().as_bytes();\n+        path.to_str().unwrap().as_bytes()\n     }\n }\n "}, {"sha": "ed3bdedddced505b5d47c1b2c678bdda14bbe7d0", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -119,11 +119,10 @@ fn module_codegen(\n         tcx.sess.opts.debuginfo != DebugInfo::None,\n     );\n     super::predefine_mono_items(&mut cx, &mono_items);\n-    for (mono_item, (linkage, visibility)) in mono_items {\n-        let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n+    for (mono_item, _) in mono_items {\n         match mono_item {\n             MonoItem::Fn(inst) => {\n-                cx.tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, inst, linkage));\n+                cx.tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, inst));\n             }\n             MonoItem::Static(def_id) => {\n                 crate::constant::codegen_static(&mut cx.constants_cx, def_id)\n@@ -163,6 +162,21 @@ pub(super) fn run_aot(\n     metadata: EncodedMetadata,\n     need_metadata_module: bool,\n ) -> Box<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)> {\n+    use rustc_span::symbol::sym;\n+\n+    let crate_attrs = tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n+    let subsystem = tcx.sess.first_attr_value_str_by_name(crate_attrs, sym::windows_subsystem);\n+    let windows_subsystem = subsystem.map(|subsystem| {\n+        if subsystem != sym::windows && subsystem != sym::console {\n+            tcx.sess.fatal(&format!(\n+                \"invalid windows subsystem `{}`, only \\\n+                                    `windows` and `console` are allowed\",\n+                subsystem\n+            ));\n+        }\n+        subsystem.to_string()\n+    });\n+\n     let mut work_products = FxHashMap::default();\n \n     let cgus = if tcx.sess.opts.output_types.should_codegen() {\n@@ -280,7 +294,7 @@ pub(super) fn run_aot(\n             allocator_module,\n             metadata_module,\n             metadata,\n-            windows_subsystem: None, // Windows is not yet supported\n+            windows_subsystem,\n             linker_info: LinkerInfo::new(tcx),\n             crate_info: CrateInfo::new(tcx),\n         },"}, {"sha": "dbe1ff083f0db24d12f9846c5cdf7147a4866bd1", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 59, "deletions": 30, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -5,8 +5,10 @@ use std::cell::RefCell;\n use std::ffi::CString;\n use std::os::raw::{c_char, c_int};\n \n+use cranelift_codegen::binemit::{NullStackMapSink, NullTrapSink};\n use rustc_codegen_ssa::CrateInfo;\n use rustc_middle::mir::mono::MonoItem;\n+use rustc_session::config::EntryFnType;\n \n use cranelift_jit::{JITBuilder, JITModule};\n \n@@ -28,20 +30,11 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n     let mut jit_builder =\n         JITBuilder::with_isa(crate::build_isa(tcx.sess), cranelift_module::default_libcall_names());\n     jit_builder.hotswap(matches!(backend_config.codegen_mode, CodegenMode::JitLazy));\n+    crate::compiler_builtins::register_functions_for_jit(&mut jit_builder);\n     jit_builder.symbols(imported_symbols);\n     let mut jit_module = JITModule::new(jit_builder);\n     assert_eq!(pointer_ty(tcx), jit_module.target_config().pointer_type());\n \n-    let sig = Signature {\n-        params: vec![\n-            AbiParam::new(jit_module.target_config().pointer_type()),\n-            AbiParam::new(jit_module.target_config().pointer_type()),\n-        ],\n-        returns: vec![AbiParam::new(jit_module.target_config().pointer_type() /*isize*/)],\n-        call_conv: CallConv::triple_default(&crate::target_triple(tcx.sess)),\n-    };\n-    let main_func_id = jit_module.declare_function(\"main\", Linkage::Import, &sig).unwrap();\n-\n     let (_, cgus) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n     let mono_items = cgus\n         .iter()\n@@ -55,15 +48,12 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n \n     super::time(tcx, \"codegen mono items\", || {\n         super::predefine_mono_items(&mut cx, &mono_items);\n-        for (mono_item, (linkage, visibility)) in mono_items {\n-            let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n+        for (mono_item, _) in mono_items {\n             match mono_item {\n                 MonoItem::Fn(inst) => match backend_config.codegen_mode {\n                     CodegenMode::Aot => unreachable!(),\n                     CodegenMode::Jit => {\n-                        cx.tcx\n-                            .sess\n-                            .time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, inst, linkage));\n+                        cx.tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, inst));\n                     }\n                     CodegenMode::JitLazy => codegen_shim(&mut cx, inst),\n                 },\n@@ -86,24 +76,17 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n         tcx.sess.fatal(\"Inline asm is not supported in JIT mode\");\n     }\n \n-    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut jit_module, &mut unwind_context);\n     crate::allocator::codegen(tcx, &mut jit_module, &mut unwind_context);\n \n     tcx.sess.abort_if_errors();\n \n     jit_module.finalize_definitions();\n-\n     let _unwind_register_guard = unsafe { unwind_context.register_jit(&jit_module) };\n \n-    let finalized_main: *const u8 = jit_module.get_finalized_function(main_func_id);\n-\n     println!(\n         \"Rustc codegen cranelift will JIT run the executable, because -Cllvm-args=mode=jit was passed\"\n     );\n \n-    let f: extern \"C\" fn(c_int, *const *const c_char) -> c_int =\n-        unsafe { ::std::mem::transmute(finalized_main) };\n-\n     let args = ::std::env::var(\"CG_CLIF_JIT_ARGS\").unwrap_or_else(|_| String::new());\n     let args = std::iter::once(&*tcx.crate_name(LOCAL_CRATE).as_str().to_string())\n         .chain(args.split(' '))\n@@ -118,12 +101,58 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n     BACKEND_CONFIG.with(|tls_backend_config| {\n         assert!(tls_backend_config.borrow_mut().replace(backend_config).is_none())\n     });\n-    CURRENT_MODULE\n-        .with(|current_module| assert!(current_module.borrow_mut().replace(jit_module).is_none()));\n \n-    let ret = f(args.len() as c_int, argv.as_ptr());\n+    let (main_def_id, entry_ty) = tcx.entry_fn(LOCAL_CRATE).unwrap();\n+    let instance = Instance::mono(tcx, main_def_id.to_def_id()).polymorphize(tcx);\n+\n+    match entry_ty {\n+        EntryFnType::Main => {\n+            // FIXME set program arguments somehow\n \n-    std::process::exit(ret);\n+            let main_sig = Signature {\n+                params: vec![],\n+                returns: vec![],\n+                call_conv: CallConv::triple_default(&crate::target_triple(tcx.sess)),\n+            };\n+            let main_func_id = jit_module\n+                .declare_function(tcx.symbol_name(instance).name, Linkage::Import, &main_sig)\n+                .unwrap();\n+            let finalized_main: *const u8 = jit_module.get_finalized_function(main_func_id);\n+\n+            CURRENT_MODULE.with(|current_module| {\n+                assert!(current_module.borrow_mut().replace(jit_module).is_none())\n+            });\n+\n+            let f: extern \"C\" fn() = unsafe { ::std::mem::transmute(finalized_main) };\n+            f();\n+            std::process::exit(0);\n+        }\n+        EntryFnType::Start => {\n+            let start_sig = Signature {\n+                params: vec![\n+                    AbiParam::new(jit_module.target_config().pointer_type()),\n+                    AbiParam::new(jit_module.target_config().pointer_type()),\n+                ],\n+                returns: vec![AbiParam::new(\n+                    jit_module.target_config().pointer_type(), /*isize*/\n+                )],\n+                call_conv: CallConv::triple_default(&crate::target_triple(tcx.sess)),\n+            };\n+            let start_func_id = jit_module\n+                .declare_function(tcx.symbol_name(instance).name, Linkage::Import, &start_sig)\n+                .unwrap();\n+            let finalized_start: *const u8 = jit_module.get_finalized_function(start_func_id);\n+\n+            CURRENT_MODULE.with(|current_module| {\n+                assert!(current_module.borrow_mut().replace(jit_module).is_none())\n+            });\n+\n+            let f: extern \"C\" fn(c_int, *const *const c_char) -> c_int =\n+                unsafe { ::std::mem::transmute(finalized_start) };\n+            let ret = f(args.len() as c_int, argv.as_ptr());\n+            std::process::exit(ret);\n+        }\n+    }\n }\n \n #[no_mangle]\n@@ -144,8 +173,7 @@ extern \"C\" fn __clif_jit_fn(instance_ptr: *const Instance<'static>) -> *const u8\n             jit_module.prepare_for_function_redefine(func_id).unwrap();\n \n             let mut cx = crate::CodegenCx::new(tcx, backend_config, jit_module, false);\n-            tcx.sess\n-                .time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, instance, Linkage::Export));\n+            tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, instance));\n \n             let (global_asm, _debug_context, unwind_context) = cx.finalize();\n             assert!(global_asm.is_empty());\n@@ -220,7 +248,7 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n     imported_symbols\n }\n \n-pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'_, 'tcx>, inst: Instance<'tcx>) {\n+fn codegen_shim<'tcx>(cx: &mut CodegenCx<'_, 'tcx>, inst: Instance<'tcx>) {\n     let tcx = cx.tcx;\n \n     let pointer_type = cx.module.target_config().pointer_type();\n@@ -267,7 +295,8 @@ pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'_, 'tcx>, inst: Instance<'t\n         .define_function(\n             func_id,\n             &mut Context::for_function(trampoline),\n-            &mut cranelift_codegen::binemit::NullTrapSink {},\n+            &mut NullTrapSink {},\n+            &mut NullStackMapSink {},\n         )\n         .unwrap();\n }"}, {"sha": "d49182a07b79e5d6074d7e1d6e016c3498a9544d", "filename": "compiler/rustc_codegen_cranelift/src/driver/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -44,13 +44,19 @@ fn predefine_mono_items<'tcx>(\n     mono_items: &[(MonoItem<'tcx>, (RLinkage, Visibility))],\n ) {\n     cx.tcx.sess.time(\"predefine functions\", || {\n+        let is_compiler_builtins = cx.tcx.is_compiler_builtins(LOCAL_CRATE);\n         for &(mono_item, (linkage, visibility)) in mono_items {\n             match mono_item {\n                 MonoItem::Fn(instance) => {\n                     let name = cx.tcx.symbol_name(instance).name.to_string();\n                     let _inst_guard = crate::PrintOnPanic(|| format!(\"{:?} {}\", instance, name));\n                     let sig = get_function_sig(cx.tcx, cx.module.isa().triple(), instance);\n-                    let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n+                    let linkage = crate::linkage::get_clif_linkage(\n+                        mono_item,\n+                        linkage,\n+                        visibility,\n+                        is_compiler_builtins,\n+                    );\n                     cx.module.declare_function(&name, linkage, &sig).unwrap();\n                 }\n                 MonoItem::Static(_) | MonoItem::GlobalAsm(_) => {}"}, {"sha": "1fb5e86aed7df4d74400ede3062e23cd6c7265d4", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -20,6 +20,10 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     if template.is_empty() {\n         // Black box\n         return;\n+    } else if template[0] == InlineAsmTemplatePiece::String(\"int $$0x29\".to_string()) {\n+        let true_ = fx.bcx.ins().iconst(types::I32, 1);\n+        fx.bcx.ins().trapnz(true_, TrapCode::User(1));\n+        return;\n     }\n \n     let mut slot_size = Size::from_bytes(0);\n@@ -193,8 +197,9 @@ fn call_inline_asm<'tcx>(\n         offset: None,\n         size: u32::try_from(slot_size.bytes()).unwrap(),\n     });\n-    #[cfg(debug_assertions)]\n-    fx.add_comment(stack_slot, \"inline asm scratch slot\");\n+    if fx.clif_comments.enabled() {\n+        fx.add_comment(stack_slot, \"inline asm scratch slot\");\n+    }\n \n     let inline_asm_func = fx\n         .cx\n@@ -210,8 +215,9 @@ fn call_inline_asm<'tcx>(\n         )\n         .unwrap();\n     let inline_asm_func = fx.cx.module.declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n-    #[cfg(debug_assertions)]\n-    fx.add_comment(inline_asm_func, asm_name);\n+    if fx.clif_comments.enabled() {\n+        fx.add_comment(inline_asm_func, asm_name);\n+    }\n \n     for (_reg, offset, value) in inputs {\n         fx.bcx.ins().stack_store(value, stack_slot, i32::try_from(offset.bytes()).unwrap());"}, {"sha": "c7ce32b385e9434a29fd4410e2b8b308112d867c", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -88,7 +88,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 let idx_bytes = match idx_const {\n                     ConstValue::ByRef { alloc, offset } => {\n                         let ptr = Pointer::new(AllocId(0 /* dummy */), offset);\n-                        let size = Size::from_bytes(4 * u64::from(ret_lane_count) /* size_of([u32; ret_lane_count]) */);\n+                        let size = Size::from_bytes(4 * ret_lane_count /* size_of([u32; ret_lane_count]) */);\n                         alloc.get_bytes(fx, ptr, size).unwrap()\n                     }\n                     _ => unreachable!(\"{:?}\", idx_const),"}, {"sha": "720d2a1253445e07b2fac3f48b31d89af64a1b6c", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,13 +1,4 @@\n-#![feature(\n-    rustc_private,\n-    decl_macro,\n-    type_alias_impl_trait,\n-    associated_type_bounds,\n-    never_type,\n-    try_blocks,\n-    box_patterns,\n-    hash_drain_filter\n-)]\n+#![feature(rustc_private, decl_macro, never_type, hash_drain_filter)]\n #![warn(rust_2018_idioms)]\n #![warn(unused_lifetimes)]\n #![warn(unreachable_pub)]\n@@ -57,6 +48,7 @@ mod base;\n mod cast;\n mod codegen_i128;\n mod common;\n+mod compiler_builtins;\n mod constant;\n mod debuginfo;\n mod discriminant;\n@@ -224,8 +216,10 @@ pub struct CraneliftCodegenBackend {\n \n impl CodegenBackend for CraneliftCodegenBackend {\n     fn init(&self, sess: &Session) {\n-        if sess.lto() != rustc_session::config::Lto::No && sess.opts.cg.embed_bitcode {\n-            sess.warn(\"LTO is not supported. You may get a linker error.\");\n+        use rustc_session::config::Lto;\n+        match sess.lto() {\n+            Lto::No | Lto::ThinLocal => {}\n+            Lto::Thin | Lto::Fat => sess.warn(\"LTO is not supported. You may get a linker error.\"),\n         }\n     }\n \n@@ -240,9 +234,9 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         vec![]\n     }\n \n-    fn codegen_crate<'tcx>(\n+    fn codegen_crate(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n+        tcx: TyCtxt<'_>,\n         metadata: EncodedMetadata,\n         need_metadata_module: bool,\n     ) -> Box<dyn Any> {\n@@ -252,9 +246,7 @@ impl CodegenBackend for CraneliftCodegenBackend {\n             BackendConfig::from_opts(&tcx.sess.opts.cg.llvm_args)\n                 .unwrap_or_else(|err| tcx.sess.fatal(&err))\n         };\n-        let res = driver::codegen_crate(tcx, metadata, need_metadata_module, config);\n-\n-        res\n+        driver::codegen_crate(tcx, metadata, need_metadata_module, config)\n     }\n \n     fn join_codegen(\n@@ -300,9 +292,9 @@ fn build_isa(sess: &Session) -> Box<dyn isa::TargetIsa + 'static> {\n     let mut flags_builder = settings::builder();\n     flags_builder.enable(\"is_pic\").unwrap();\n     flags_builder.set(\"enable_probestack\", \"false\").unwrap(); // __cranelift_probestack is not provided\n-    flags_builder\n-        .set(\"enable_verifier\", if cfg!(debug_assertions) { \"true\" } else { \"false\" })\n-        .unwrap();\n+    let enable_verifier =\n+        cfg!(debug_assertions) || std::env::var(\"CG_CLIF_ENABLE_VERIFIER\").is_ok();\n+    flags_builder.set(\"enable_verifier\", if enable_verifier { \"true\" } else { \"false\" }).unwrap();\n \n     let tls_model = match target_triple.binary_format {\n         BinaryFormat::Elf => \"elf_gd\",\n@@ -314,18 +306,17 @@ fn build_isa(sess: &Session) -> Box<dyn isa::TargetIsa + 'static> {\n \n     flags_builder.set(\"enable_simd\", \"true\").unwrap();\n \n+    flags_builder.set(\"enable_llvm_abi_extensions\", \"true\").unwrap();\n+\n     use rustc_session::config::OptLevel;\n     match sess.opts.optimize {\n         OptLevel::No => {\n             flags_builder.set(\"opt_level\", \"none\").unwrap();\n         }\n         OptLevel::Less | OptLevel::Default => {}\n-        OptLevel::Aggressive => {\n+        OptLevel::Size | OptLevel::SizeMin | OptLevel::Aggressive => {\n             flags_builder.set(\"opt_level\", \"speed_and_size\").unwrap();\n         }\n-        OptLevel::Size | OptLevel::SizeMin => {\n-            sess.warn(\"Optimizing for size is not supported. Just ignoring the request\");\n-        }\n     }\n \n     let flags = settings::Flags::new(flags_builder);"}, {"sha": "a564a59f7251061cd8a9363136db637220f6afbf", "filename": "compiler/rustc_codegen_cranelift/src/linkage.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flinkage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flinkage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flinkage.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -6,8 +6,10 @@ pub(crate) fn get_clif_linkage(\n     mono_item: MonoItem<'_>,\n     linkage: RLinkage,\n     visibility: Visibility,\n+    is_compiler_builtins: bool,\n ) -> Linkage {\n     match (linkage, visibility) {\n+        (RLinkage::External, Visibility::Default) if is_compiler_builtins => Linkage::Hidden,\n         (RLinkage::External, Visibility::Default) => Linkage::Export,\n         (RLinkage::Internal, Visibility::Default) => Linkage::Local,\n         (RLinkage::External, Visibility::Hidden) => Linkage::Hidden,"}, {"sha": "a6266f507765fdf663f9ab1b4525d12115a00cfd", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,3 +1,4 @@\n+use cranelift_codegen::binemit::{NullStackMapSink, NullTrapSink};\n use rustc_hir::LangItem;\n use rustc_session::config::EntryFnType;\n \n@@ -100,12 +101,8 @@ pub(crate) fn maybe_create_entry_wrapper(\n             bcx.seal_all_blocks();\n             bcx.finalize();\n         }\n-        m.define_function(\n-            cmain_func_id,\n-            &mut ctx,\n-            &mut cranelift_codegen::binemit::NullTrapSink {},\n-        )\n-        .unwrap();\n+        m.define_function(cmain_func_id, &mut ctx, &mut NullTrapSink {}, &mut NullStackMapSink {})\n+            .unwrap();\n         unwind_context.add_function(cmain_func_id, &ctx, m.isa());\n     }\n }"}, {"sha": "dbdc8cbad44c45aea7ad1c22e410aac69945f16d", "filename": "compiler/rustc_codegen_cranelift/src/metadata.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,10 +1,10 @@\n //! Reading and writing of the rustc metadata for rlibs and dylibs\n \n-use std::convert::TryFrom;\n use std::fs::File;\n use std::path::Path;\n \n use rustc_codegen_ssa::METADATA_FILENAME;\n+use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::owning_ref::OwningRef;\n use rustc_data_structures::rustc_erase_owner;\n use rustc_data_structures::sync::MetadataRef;\n@@ -17,38 +17,43 @@ use crate::backend::WriteMetadata;\n \n pub(crate) struct CraneliftMetadataLoader;\n \n+fn load_metadata_with(\n+    path: &Path,\n+    f: impl for<'a> FnOnce(&'a [u8]) -> Result<&'a [u8], String>,\n+) -> Result<MetadataRef, String> {\n+    let file = File::open(path).map_err(|e| format!(\"{:?}\", e))?;\n+    let data = unsafe { Mmap::map(file) }.map_err(|e| format!(\"{:?}\", e))?;\n+    let metadata = OwningRef::new(data).try_map(f)?;\n+    return Ok(rustc_erase_owner!(metadata.map_owner_box()));\n+}\n+\n impl MetadataLoader for CraneliftMetadataLoader {\n     fn get_rlib_metadata(&self, _target: &Target, path: &Path) -> Result<MetadataRef, String> {\n-        let mut archive = ar::Archive::new(File::open(path).map_err(|e| format!(\"{:?}\", e))?);\n-        // Iterate over all entries in the archive:\n-        while let Some(entry_result) = archive.next_entry() {\n-            let mut entry = entry_result.map_err(|e| format!(\"{:?}\", e))?;\n-            if entry.header().identifier() == METADATA_FILENAME.as_bytes() {\n-                let mut buf = Vec::with_capacity(\n-                    usize::try_from(entry.header().size())\n-                        .expect(\"Rlib metadata file too big to load into memory.\"),\n-                );\n-                ::std::io::copy(&mut entry, &mut buf).map_err(|e| format!(\"{:?}\", e))?;\n-                let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf);\n-                return Ok(rustc_erase_owner!(buf.map_owner_box()));\n+        load_metadata_with(path, |data| {\n+            let archive = object::read::archive::ArchiveFile::parse(&*data)\n+                .map_err(|e| format!(\"{:?}\", e))?;\n+\n+            for entry_result in archive.members() {\n+                let entry = entry_result.map_err(|e| format!(\"{:?}\", e))?;\n+                if entry.name() == METADATA_FILENAME.as_bytes() {\n+                    return Ok(entry.data());\n+                }\n             }\n-        }\n \n-        Err(\"couldn't find metadata entry\".to_string())\n+            Err(\"couldn't find metadata entry\".to_string())\n+        })\n     }\n \n     fn get_dylib_metadata(&self, _target: &Target, path: &Path) -> Result<MetadataRef, String> {\n         use object::{Object, ObjectSection};\n-        let file = std::fs::read(path).map_err(|e| format!(\"read:{:?}\", e))?;\n-        let file = object::File::parse(&file).map_err(|e| format!(\"parse: {:?}\", e))?;\n-        let buf = file\n-            .section_by_name(\".rustc\")\n-            .ok_or(\"no .rustc section\")?\n-            .data()\n-            .map_err(|e| format!(\"failed to read .rustc section: {:?}\", e))?\n-            .to_owned();\n-        let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf);\n-        Ok(rustc_erase_owner!(buf.map_owner_box()))\n+\n+        load_metadata_with(path, |data| {\n+            let file = object::File::parse(&data).map_err(|e| format!(\"parse: {:?}\", e))?;\n+            file.section_by_name(\".rustc\")\n+                .ok_or(\"no .rustc section\")?\n+                .data()\n+                .map_err(|e| format!(\"failed to read .rustc section: {:?}\", e))\n+        })\n     }\n }\n "}, {"sha": "2ebf30da2d8ba930e973995dac9bc173eea636da", "filename": "compiler/rustc_codegen_cranelift/src/num.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -166,13 +166,11 @@ pub(crate) fn codegen_int_binop<'tcx>(\n         BinOp::Shl => {\n             let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n             let actual_shift = fx.bcx.ins().band_imm(rhs, i64::from(lhs_ty.bits() - 1));\n-            let actual_shift = clif_intcast(fx, actual_shift, types::I8, false);\n             fx.bcx.ins().ishl(lhs, actual_shift)\n         }\n         BinOp::Shr => {\n             let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n             let actual_shift = fx.bcx.ins().band_imm(rhs, i64::from(lhs_ty.bits() - 1));\n-            let actual_shift = clif_intcast(fx, actual_shift, types::I8, false);\n             if signed {\n                 fx.bcx.ins().sshr(lhs, actual_shift)\n             } else {\n@@ -387,7 +385,7 @@ pub(crate) fn codegen_ptr_binop<'tcx>(\n                 let lhs = in_lhs.load_scalar(fx);\n                 let rhs = in_rhs.load_scalar(fx);\n \n-                return codegen_compare_bin_op(fx, bin_op, false, lhs, rhs);\n+                codegen_compare_bin_op(fx, bin_op, false, lhs, rhs)\n             }\n             BinOp::Offset => {\n                 let pointee_ty = in_lhs.layout().ty.builtin_deref(true).unwrap().ty;\n@@ -396,10 +394,10 @@ pub(crate) fn codegen_ptr_binop<'tcx>(\n                 let ptr_diff = fx.bcx.ins().imul_imm(offset, pointee_size as i64);\n                 let base_val = base.load_scalar(fx);\n                 let res = fx.bcx.ins().iadd(base_val, ptr_diff);\n-                return CValue::by_val(res, base.layout());\n+                CValue::by_val(res, base.layout())\n             }\n             _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs, in_rhs),\n-        };\n+        }\n     } else {\n         let (lhs_ptr, lhs_extra) = in_lhs.load_scalar_pair(fx);\n         let (rhs_ptr, rhs_extra) = in_rhs.load_scalar_pair(fx);"}, {"sha": "8bb02a3e5585482b4e88a0135524f494a74ff184", "filename": "compiler/rustc_codegen_cranelift/src/optimize/stack2reg.rs", "status": "modified", "additions": 47, "deletions": 42, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fstack2reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fstack2reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fstack2reg.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -181,7 +181,6 @@ impl<'a> OptimizeContext<'a> {\n \n pub(super) fn optimize_function(\n     ctx: &mut Context,\n-    #[cfg_attr(not(debug_assertions), allow(unused_variables))]\n     clif_comments: &mut crate::pretty_clif::CommentWriter,\n ) {\n     combine_stack_addr_with_load_store(&mut ctx.func);\n@@ -192,8 +191,7 @@ pub(super) fn optimize_function(\n \n     remove_unused_stack_addr_and_stack_load(&mut opt_ctx);\n \n-    #[cfg(debug_assertions)]\n-    {\n+    if clif_comments.enabled() {\n         for (&OrdStackSlot(stack_slot), usage) in &opt_ctx.stack_slot_usage_map {\n             clif_comments.add_comment(stack_slot, format!(\"used by: {:?}\", usage));\n         }\n@@ -209,25 +207,27 @@ pub(super) fn optimize_function(\n         for load in users.stack_load.clone().into_iter() {\n             let potential_stores = users.potential_stores_for_load(&opt_ctx.ctx, load);\n \n-            #[cfg(debug_assertions)]\n-            for &store in &potential_stores {\n-                clif_comments.add_comment(\n-                    load,\n-                    format!(\n-                        \"Potential store -> load forwarding {} -> {} ({:?}, {:?})\",\n-                        opt_ctx.ctx.func.dfg.display_inst(store, None),\n-                        opt_ctx.ctx.func.dfg.display_inst(load, None),\n-                        spatial_overlap(&opt_ctx.ctx.func, store, load),\n-                        temporal_order(&opt_ctx.ctx, store, load),\n-                    ),\n-                );\n+            if clif_comments.enabled() {\n+                for &store in &potential_stores {\n+                    clif_comments.add_comment(\n+                        load,\n+                        format!(\n+                            \"Potential store -> load forwarding {} -> {} ({:?}, {:?})\",\n+                            opt_ctx.ctx.func.dfg.display_inst(store, None),\n+                            opt_ctx.ctx.func.dfg.display_inst(load, None),\n+                            spatial_overlap(&opt_ctx.ctx.func, store, load),\n+                            temporal_order(&opt_ctx.ctx, store, load),\n+                        ),\n+                    );\n+                }\n             }\n \n             match *potential_stores {\n                 [] => {\n-                    #[cfg(debug_assertions)]\n-                    clif_comments\n-                        .add_comment(load, \"[BUG?] Reading uninitialized memory\".to_string());\n+                    if clif_comments.enabled() {\n+                        clif_comments\n+                            .add_comment(load, \"[BUG?] Reading uninitialized memory\".to_string());\n+                    }\n                 }\n                 [store]\n                     if spatial_overlap(&opt_ctx.ctx.func, store, load) == SpatialOverlap::Full\n@@ -237,9 +237,12 @@ pub(super) fn optimize_function(\n                     // Only one store could have been the origin of the value.\n                     let stored_value = opt_ctx.ctx.func.dfg.inst_args(store)[0];\n \n-                    #[cfg(debug_assertions)]\n-                    clif_comments\n-                        .add_comment(load, format!(\"Store to load forward {} -> {}\", store, load));\n+                    if clif_comments.enabled() {\n+                        clif_comments.add_comment(\n+                            load,\n+                            format!(\"Store to load forward {} -> {}\", store, load),\n+                        );\n+                    }\n \n                     users.change_load_to_alias(&mut opt_ctx.ctx.func, load, stored_value);\n                 }\n@@ -250,33 +253,35 @@ pub(super) fn optimize_function(\n         for store in users.stack_store.clone().into_iter() {\n             let potential_loads = users.potential_loads_of_store(&opt_ctx.ctx, store);\n \n-            #[cfg(debug_assertions)]\n-            for &load in &potential_loads {\n-                clif_comments.add_comment(\n-                    store,\n-                    format!(\n-                        \"Potential load from store {} <- {} ({:?}, {:?})\",\n-                        opt_ctx.ctx.func.dfg.display_inst(load, None),\n-                        opt_ctx.ctx.func.dfg.display_inst(store, None),\n-                        spatial_overlap(&opt_ctx.ctx.func, store, load),\n-                        temporal_order(&opt_ctx.ctx, store, load),\n-                    ),\n-                );\n+            if clif_comments.enabled() {\n+                for &load in &potential_loads {\n+                    clif_comments.add_comment(\n+                        store,\n+                        format!(\n+                            \"Potential load from store {} <- {} ({:?}, {:?})\",\n+                            opt_ctx.ctx.func.dfg.display_inst(load, None),\n+                            opt_ctx.ctx.func.dfg.display_inst(store, None),\n+                            spatial_overlap(&opt_ctx.ctx.func, store, load),\n+                            temporal_order(&opt_ctx.ctx, store, load),\n+                        ),\n+                    );\n+                }\n             }\n \n             if potential_loads.is_empty() {\n                 // Never loaded; can safely remove all stores and the stack slot.\n                 // FIXME also remove stores when there is always a next store before a load.\n \n-                #[cfg(debug_assertions)]\n-                clif_comments.add_comment(\n-                    store,\n-                    format!(\n-                        \"Remove dead stack store {} of {}\",\n-                        opt_ctx.ctx.func.dfg.display_inst(store, None),\n-                        stack_slot.0\n-                    ),\n-                );\n+                if clif_comments.enabled() {\n+                    clif_comments.add_comment(\n+                        store,\n+                        format!(\n+                            \"Remove dead stack store {} of {}\",\n+                            opt_ctx.ctx.func.dfg.display_inst(store, None),\n+                            stack_slot.0\n+                        ),\n+                    );\n+                }\n \n                 users.remove_dead_store(&mut opt_ctx.ctx.func, store);\n             }"}, {"sha": "31d827f83bfab94543e32a1ffbe0f3918b6d62fd", "filename": "compiler/rustc_codegen_cranelift/src/pointer.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -39,8 +39,7 @@ impl Pointer {\n         Pointer { base: PointerBase::Dangling(align), offset: Offset32::new(0) }\n     }\n \n-    #[cfg(debug_assertions)]\n-    pub(crate) fn base_and_offset(self) -> (PointerBase, Offset32) {\n+    pub(crate) fn debug_base_and_offset(self) -> (PointerBase, Offset32) {\n         (self.base, self.offset)\n     }\n "}, {"sha": "d22ea3772eee7b24457c1bac4b550ea2d3e3a769", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -69,13 +69,15 @@ use crate::prelude::*;\n \n #[derive(Debug)]\n pub(crate) struct CommentWriter {\n+    enabled: bool,\n     global_comments: Vec<String>,\n     entity_comments: FxHashMap<AnyEntity, String>,\n }\n \n impl CommentWriter {\n     pub(crate) fn new<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Self {\n-        let global_comments = if cfg!(debug_assertions) {\n+        let enabled = should_write_ir(tcx);\n+        let global_comments = if enabled {\n             vec![\n                 format!(\"symbol {}\", tcx.symbol_name(instance).name),\n                 format!(\"instance {:?}\", instance),\n@@ -86,13 +88,17 @@ impl CommentWriter {\n             vec![]\n         };\n \n-        CommentWriter { global_comments, entity_comments: FxHashMap::default() }\n+        CommentWriter { enabled, global_comments, entity_comments: FxHashMap::default() }\n     }\n }\n \n-#[cfg(debug_assertions)]\n impl CommentWriter {\n+    pub(crate) fn enabled(&self) -> bool {\n+        self.enabled\n+    }\n+\n     pub(crate) fn add_global_comment<S: Into<String>>(&mut self, comment: S) {\n+        debug_assert!(self.enabled);\n         self.global_comments.push(comment.into());\n     }\n \n@@ -101,6 +107,8 @@ impl CommentWriter {\n         entity: E,\n         comment: S,\n     ) {\n+        debug_assert!(self.enabled);\n+\n         use std::collections::hash_map::Entry;\n         match self.entity_comments.entry(entity.into()) {\n             Entry::Occupied(mut occ) => {\n@@ -179,7 +187,6 @@ impl FuncWriter for &'_ CommentWriter {\n     }\n }\n \n-#[cfg(debug_assertions)]\n impl FunctionCx<'_, '_, '_> {\n     pub(crate) fn add_global_comment<S: Into<String>>(&mut self, comment: S) {\n         self.clif_comments.add_global_comment(comment);\n@@ -198,8 +205,8 @@ pub(crate) fn should_write_ir(tcx: TyCtxt<'_>) -> bool {\n     tcx.sess.opts.output_types.contains_key(&OutputType::LlvmAssembly)\n }\n \n-pub(crate) fn write_ir_file<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub(crate) fn write_ir_file(\n+    tcx: TyCtxt<'_>,\n     name: &str,\n     write: impl FnOnce(&mut dyn Write) -> std::io::Result<()>,\n ) {\n@@ -217,10 +224,7 @@ pub(crate) fn write_ir_file<'tcx>(\n \n     let clif_file_name = clif_output_dir.join(name);\n \n-    let res: std::io::Result<()> = try {\n-        let mut file = std::fs::File::create(clif_file_name)?;\n-        write(&mut file)?;\n-    };\n+    let res = std::fs::File::create(clif_file_name).and_then(|mut file| write(&mut file));\n     if let Err(err) = res {\n         tcx.sess.warn(&format!(\"error writing ir file: {}\", err));\n     }"}, {"sha": "1ab0703e981e73f7f5724b5e5e085696474cc8a4", "filename": "compiler/rustc_codegen_cranelift/src/trap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -17,8 +17,7 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, '_>, msg: &str) {\n         )\n         .unwrap();\n     let puts = fx.cx.module.declare_func_in_func(puts, &mut fx.bcx.func);\n-    #[cfg(debug_assertions)]\n-    {\n+    if fx.clif_comments.enabled() {\n         fx.add_comment(puts, \"puts\");\n     }\n "}, {"sha": "b97d39009847a01cfb9f0dd09c02b39a8b8045b4", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -2,7 +2,6 @@\n \n use crate::prelude::*;\n \n-use cranelift_codegen::entity::EntityRef;\n use cranelift_codegen::ir::immediates::Offset32;\n \n fn codegen_field<'tcx>(\n@@ -414,7 +413,7 @@ impl<'tcx> CPlace<'tcx> {\n         self,\n         fx: &mut FunctionCx<'_, '_, 'tcx>,\n         from: CValue<'tcx>,\n-        #[cfg_attr(not(debug_assertions), allow(unused_variables))] method: &'static str,\n+        method: &'static str,\n     ) {\n         fn transmute_value<'tcx>(\n             fx: &mut FunctionCx<'_, '_, 'tcx>,\n@@ -462,8 +461,7 @@ impl<'tcx> CPlace<'tcx> {\n \n         assert_eq!(self.layout().size, from.layout().size);\n \n-        #[cfg(debug_assertions)]\n-        {\n+        if fx.clif_comments.enabled() {\n             use cranelift_codegen::cursor::{Cursor, CursorPosition};\n             let cur_block = match fx.bcx.cursor().position() {\n                 CursorPosition::After(block) => block,\n@@ -707,6 +705,19 @@ pub(crate) fn assert_assignable<'tcx>(\n             }\n             // dyn for<'r> Trait<'r> -> dyn Trait<'_> is allowed\n         }\n+        (&ty::Adt(adt_def_a, substs_a), &ty::Adt(adt_def_b, substs_b))\n+            if adt_def_a.did == adt_def_b.did =>\n+        {\n+            let mut types_a = substs_a.types();\n+            let mut types_b = substs_b.types();\n+            loop {\n+                match (types_a.next(), types_b.next()) {\n+                    (Some(a), Some(b)) => assert_assignable(fx, a, b),\n+                    (None, None) => return,\n+                    (Some(_), None) | (None, Some(_)) => panic!(\"{:#?}/{:#?}\", from_ty, to_ty),\n+                }\n+            }\n+        }\n         _ => {\n             assert_eq!(\n                 from_ty, to_ty,"}, {"sha": "84b091d8d4d79ec4d15710ad20356a9bd21f658b", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -14,7 +14,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::{bug, span_bug};\n-use rustc_span::{Pos, Span};\n+use rustc_span::{Pos, Span, Symbol};\n use rustc_target::abi::*;\n use rustc_target::asm::*;\n \n@@ -125,15 +125,39 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n \n         // Collect the types of output operands\n         let mut constraints = vec![];\n+        let mut clobbers = vec![];\n         let mut output_types = vec![];\n         let mut op_idx = FxHashMap::default();\n         for (idx, op) in operands.iter().enumerate() {\n             match *op {\n                 InlineAsmOperandRef::Out { reg, late, place } => {\n+                    let is_target_supported = |reg_class: InlineAsmRegClass| {\n+                        for &(_, feature) in reg_class.supported_types(asm_arch) {\n+                            if let Some(feature) = feature {\n+                                if self.tcx.sess.target_features.contains(&Symbol::intern(feature))\n+                                {\n+                                    return true;\n+                                }\n+                            } else {\n+                                // Register class is unconditionally supported\n+                                return true;\n+                            }\n+                        }\n+                        false\n+                    };\n+\n                     let mut layout = None;\n                     let ty = if let Some(ref place) = place {\n                         layout = Some(&place.layout);\n                         llvm_fixup_output_type(self.cx, reg.reg_class(), &place.layout)\n+                    } else if !is_target_supported(reg.reg_class()) {\n+                        // We turn discarded outputs into clobber constraints\n+                        // if the target feature needed by the register class is\n+                        // disabled. This is necessary otherwise LLVM will try\n+                        // to actually allocate a register for the dummy output.\n+                        assert!(matches!(reg, InlineAsmRegOrRegClass::Reg(_)));\n+                        clobbers.push(format!(\"~{}\", reg_to_llvm(reg, None)));\n+                        continue;\n                     } else {\n                         // If the output is discarded, we don't really care what\n                         // type is used. We're just using this to tell LLVM to\n@@ -244,6 +268,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             }\n         }\n \n+        constraints.append(&mut clobbers);\n         if !options.contains(InlineAsmOptions::PRESERVES_FLAGS) {\n             match asm_arch {\n                 InlineAsmArch::AArch64 | InlineAsmArch::Arm => {"}, {"sha": "e06c1c825f6eb38eeede6fb605db01b3c36d5657", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -11,9 +11,9 @@ use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::ty::layout::HasTyCtxt;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_session::config::{OptLevel, SanitizerSet};\n+use rustc_session::config::OptLevel;\n use rustc_session::Session;\n-use rustc_target::spec::StackProbeType;\n+use rustc_target::spec::{SanitizerSet, StackProbeType};\n \n use crate::attributes;\n use crate::llvm::AttributePlace::Function;\n@@ -254,6 +254,7 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n         attributes::emit_uwtable(llfn, true);\n     }\n \n+    // FIXME: none of these three functions interact with source level attributes.\n     set_frame_pointer_elimination(cx, llfn);\n     set_instrument_function(cx, llfn);\n     set_probestack(cx, llfn);\n@@ -279,6 +280,9 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n     if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::CMSE_NONSECURE_ENTRY) {\n         llvm::AddFunctionAttrString(llfn, Function, cstr!(\"cmse_nonsecure_entry\"));\n     }\n+    if let Some(align) = codegen_fn_attrs.alignment {\n+        llvm::set_alignment(llfn, align as usize);\n+    }\n     sanitize(cx, codegen_fn_attrs.no_sanitize, llfn);\n \n     // Always annotate functions with the target-cpu they are compiled for.\n@@ -317,7 +321,7 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n     // Note that currently the `wasm-import-module` doesn't do anything, but\n     // eventually LLVM 7 should read this and ferry the appropriate import\n     // module to the output file.\n-    if cx.tcx.sess.target.arch == \"wasm32\" {\n+    if cx.tcx.sess.target.is_like_wasm {\n         if let Some(module) = wasm_import_module(cx.tcx, instance.def_id()) {\n             llvm::AddFunctionAttrStringValue(\n                 llfn,"}, {"sha": "4226ed7d99be13cd1731e63dccd408d1659eccb2", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -24,6 +24,7 @@ use tracing::{debug, info};\n use std::ffi::{CStr, CString};\n use std::fs::File;\n use std::io;\n+use std::iter;\n use std::path::Path;\n use std::ptr;\n use std::slice;\n@@ -916,9 +917,7 @@ impl ThinLTOKeysMap {\n         modules: &[llvm::ThinLTOModule],\n         names: &[CString],\n     ) -> Self {\n-        let keys = modules\n-            .iter()\n-            .zip(names.iter())\n+        let keys = iter::zip(modules, names)\n             .map(|(module, name)| {\n                 let key = build_string(|rust_str| unsafe {\n                     llvm::LLVMRustComputeLTOCacheKey(rust_str, module.identifier, data.0);"}, {"sha": "b628ae3ae3afccbc6afa3eda3e80e8a5438555c1", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -23,11 +23,11 @@ use rustc_fs_util::{link_or_copy, path_to_c_string};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{self, Lto, OutputType, Passes, SanitizerSet, SwitchWithOptPath};\n+use rustc_session::config::{self, Lto, OutputType, Passes, SwitchWithOptPath};\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::InnerSpan;\n-use rustc_target::spec::{CodeModel, RelocModel, SplitDebuginfo};\n+use rustc_target::spec::{CodeModel, RelocModel, SanitizerSet, SplitDebuginfo};\n use tracing::debug;\n \n use libc::{c_char, c_int, c_uint, c_void, size_t};\n@@ -170,10 +170,7 @@ pub fn target_machine_factory(\n     // On the wasm target once the `atomics` feature is enabled that means that\n     // we're no longer single-threaded, or otherwise we don't want LLVM to\n     // lower atomic operations to single-threaded operations.\n-    if singlethread\n-        && sess.target.llvm_target.contains(\"wasm32\")\n-        && sess.target_features.contains(&sym::atomics)\n-    {\n+    if singlethread && sess.target.is_like_wasm && sess.target_features.contains(&sym::atomics) {\n         singlethread = false;\n     }\n \n@@ -548,6 +545,15 @@ pub(crate) unsafe fn optimize(\n                     llvm::LLVMRustAddPass(fpm, find_pass(\"lint\").unwrap());\n                     continue;\n                 }\n+                if pass_name == \"insert-gcov-profiling\" || pass_name == \"instrprof\" {\n+                    // Instrumentation must be inserted before optimization,\n+                    // otherwise LLVM may optimize some functions away which\n+                    // breaks llvm-cov.\n+                    //\n+                    // This mirrors what Clang does in lib/CodeGen/BackendUtil.cpp.\n+                    llvm::LLVMRustAddPass(mpm, find_pass(pass_name).unwrap());\n+                    continue;\n+                }\n \n                 if let Some(pass) = find_pass(pass_name) {\n                     extra_passes.push(pass);\n@@ -1041,7 +1047,7 @@ pub unsafe fn with_llvm_pmb(\n     // thresholds copied from clang.\n     match (opt_level, opt_size, inline_threshold) {\n         (.., Some(t)) => {\n-            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, t as u32);\n+            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, t);\n         }\n         (llvm::CodeGenOptLevel::Aggressive, ..) => {\n             llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 275);"}, {"sha": "6f6c649bb0b18a1cbf7b6d4e4f3effba8ecc9825", "filename": "compiler/rustc_codegen_llvm/src/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -32,8 +32,9 @@ use rustc_middle::middle::cstore::EncodedMetadata;\n use rustc_middle::middle::exported_symbols;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{DebugInfo, SanitizerSet};\n+use rustc_session::config::DebugInfo;\n use rustc_span::symbol::Symbol;\n+use rustc_target::spec::SanitizerSet;\n \n use std::ffi::CString;\n use std::time::Instant;"}, {"sha": "896e56a9a1e3a6410d128cb6fccccad337e47464", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -21,6 +21,7 @@ use rustc_target::abi::{self, Align, Size};\n use rustc_target::spec::{HasTargetSpec, Target};\n use std::borrow::Cow;\n use std::ffi::CStr;\n+use std::iter;\n use std::ops::{Deref, Range};\n use std::ptr;\n use tracing::debug;\n@@ -1352,18 +1353,14 @@ impl Builder<'a, 'll, 'tcx> {\n \n         let param_tys = self.cx.func_params_types(fn_ty);\n \n-        let all_args_match = param_tys\n-            .iter()\n-            .zip(args.iter().map(|&v| self.val_ty(v)))\n+        let all_args_match = iter::zip(&param_tys, args.iter().map(|&v| self.val_ty(v)))\n             .all(|(expected_ty, actual_ty)| *expected_ty == actual_ty);\n \n         if all_args_match {\n             return Cow::Borrowed(args);\n         }\n \n-        let casted_args: Vec<_> = param_tys\n-            .into_iter()\n-            .zip(args.iter())\n+        let casted_args: Vec<_> = iter::zip(param_tys, args)\n             .enumerate()\n             .map(|(i, (expected_ty, &actual_val))| {\n                 let actual_ty = self.val_ty(actual_val);"}, {"sha": "b26969a50120f1de8369b073739933d77ffafbfa", "filename": "compiler/rustc_codegen_llvm/src/callee.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -14,6 +14,7 @@ use tracing::debug;\n \n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::{self, Instance, TypeFoldable};\n+use rustc_target::spec::RelocModel;\n \n /// Codegens a reference to a fn/method item, monomorphizing and\n /// inlining as it goes.\n@@ -170,17 +171,19 @@ pub fn get_fn(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) -> &'ll Value\n                     }\n                 }\n             }\n-        }\n \n-        // MinGW: For backward compatibility we rely on the linker to decide whether it\n-        // should use dllimport for functions.\n-        if cx.use_dll_storage_attrs\n-            && tcx.is_dllimport_foreign_item(instance_def_id)\n-            && tcx.sess.target.env != \"gnu\"\n-        {\n-            unsafe {\n+            // MinGW: For backward compatibility we rely on the linker to decide whether it\n+            // should use dllimport for functions.\n+            if cx.use_dll_storage_attrs\n+                && tcx.is_dllimport_foreign_item(instance_def_id)\n+                && tcx.sess.target.env != \"gnu\"\n+            {\n                 llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport);\n             }\n+\n+            if cx.tcx.sess.relocation_model() == RelocModel::Static {\n+                llvm::LLVMRustSetDSOLocal(llfn, true);\n+            }\n         }\n \n         llfn"}, {"sha": "afc2bdbfd52ecf5e81a1ebf91ad2b5a35b81ebb5", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -250,13 +250,9 @@ fn add_unused_function_coverage(\n             // Insert at least one real counter so the LLVM CoverageMappingReader will find expected\n             // definitions.\n             function_coverage.add_counter(UNUSED_FUNCTION_COUNTER_ID, code_region.clone());\n+        } else {\n+            function_coverage.add_unreachable_region(code_region.clone());\n         }\n-        // Add a Zero Counter for every code region.\n-        //\n-        // Even though the first coverage region already has an actual Counter, `llvm-cov` will not\n-        // always report it. Re-adding an unreachable region (zero counter) for the same region\n-        // seems to help produce the expected coverage.\n-        function_coverage.add_unreachable_region(code_region.clone());\n     }\n \n     if let Some(coverage_context) = cx.coverage_context() {"}, {"sha": "e6fa852155b5123b927228bc94baa38336404750", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1083,9 +1083,9 @@ pub fn compile_unit_metadata(\n             );\n         }\n \n-        // Insert `llvm.ident` metadata on the wasm32 targets since that will\n+        // Insert `llvm.ident` metadata on the wasm targets since that will\n         // get hooked up to the \"producer\" sections `processed-by` information.\n-        if tcx.sess.opts.target_triple.triple().starts_with(\"wasm32\") {\n+        if tcx.sess.target.is_like_wasm {\n             let name_metadata = llvm::LLVMMDStringInContext(\n                 debug_context.llcontext,\n                 rustc_producer.as_ptr().cast(),\n@@ -1962,9 +1962,7 @@ fn prepare_enum_metadata(\n \n     let discriminant_type_metadata = |discr: Primitive| {\n         let enumerators_metadata: Vec<_> = match enum_type.kind() {\n-            ty::Adt(def, _) => def\n-                .discriminants(tcx)\n-                .zip(&def.variants)\n+            ty::Adt(def, _) => iter::zip(def.discriminants(tcx), &def.variants)\n                 .map(|((_, discr), v)| {\n                     let name = v.ident.as_str();\n                     let is_unsigned = match discr.ty.kind() {\n@@ -2336,9 +2334,7 @@ fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> &'ll DIAr\n         if substs.types().next().is_some() {\n             let generics = cx.tcx.generics_of(def.did);\n             let names = get_parameter_names(cx, generics);\n-            let template_params: Vec<_> = substs\n-                .iter()\n-                .zip(names)\n+            let template_params: Vec<_> = iter::zip(substs, names)\n                 .filter_map(|(kind, name)| {\n                     if let GenericArgKind::Type(ty) = kind.unpack() {\n                         let actual_type ="}, {"sha": "e157a38aa03d5838e58bb37f421e6b25f0a4ef3a", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -37,6 +37,7 @@ use rustc_target::abi::{LayoutOf, Primitive, Size};\n use libc::c_uint;\n use smallvec::SmallVec;\n use std::cell::RefCell;\n+use std::iter;\n use tracing::debug;\n \n mod create_scope_map;\n@@ -448,9 +449,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             // Again, only create type information if full debuginfo is enabled\n             let template_params: Vec<_> = if cx.sess().opts.debuginfo == DebugInfo::Full {\n                 let names = get_parameter_names(cx, generics);\n-                substs\n-                    .iter()\n-                    .zip(names)\n+                iter::zip(substs, names)\n                     .filter_map(|(kind, name)| {\n                         if let GenericArgKind::Type(ty) = kind.unpack() {\n                             let actual_type ="}, {"sha": "5ca4b226c38fba32a404b06182947fa1428fac09", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -11,6 +11,7 @@\n #![feature(extended_key_value_attributes)]\n #![feature(extern_types)]\n #![feature(in_band_lifetimes)]\n+#![feature(iter_zip)]\n #![feature(nll)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![recursion_limit = \"256\"]"}, {"sha": "70f78c07c65ddcdfcd325ff264bc80f42a7314ac", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 14, "deletions": 31, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -190,33 +190,6 @@ pub enum RealPredicate {\n     RealPredicateTrue = 15,\n }\n \n-impl RealPredicate {\n-    pub fn from_generic(realpred: rustc_codegen_ssa::common::RealPredicate) -> Self {\n-        match realpred {\n-            rustc_codegen_ssa::common::RealPredicate::RealPredicateFalse => {\n-                RealPredicate::RealPredicateFalse\n-            }\n-            rustc_codegen_ssa::common::RealPredicate::RealOEQ => RealPredicate::RealOEQ,\n-            rustc_codegen_ssa::common::RealPredicate::RealOGT => RealPredicate::RealOGT,\n-            rustc_codegen_ssa::common::RealPredicate::RealOGE => RealPredicate::RealOGE,\n-            rustc_codegen_ssa::common::RealPredicate::RealOLT => RealPredicate::RealOLT,\n-            rustc_codegen_ssa::common::RealPredicate::RealOLE => RealPredicate::RealOLE,\n-            rustc_codegen_ssa::common::RealPredicate::RealONE => RealPredicate::RealONE,\n-            rustc_codegen_ssa::common::RealPredicate::RealORD => RealPredicate::RealORD,\n-            rustc_codegen_ssa::common::RealPredicate::RealUNO => RealPredicate::RealUNO,\n-            rustc_codegen_ssa::common::RealPredicate::RealUEQ => RealPredicate::RealUEQ,\n-            rustc_codegen_ssa::common::RealPredicate::RealUGT => RealPredicate::RealUGT,\n-            rustc_codegen_ssa::common::RealPredicate::RealUGE => RealPredicate::RealUGE,\n-            rustc_codegen_ssa::common::RealPredicate::RealULT => RealPredicate::RealULT,\n-            rustc_codegen_ssa::common::RealPredicate::RealULE => RealPredicate::RealULE,\n-            rustc_codegen_ssa::common::RealPredicate::RealUNE => RealPredicate::RealUNE,\n-            rustc_codegen_ssa::common::RealPredicate::RealPredicateTrue => {\n-                RealPredicate::RealPredicateTrue\n-            }\n-        }\n-    }\n-}\n-\n /// LLVMTypeKind\n #[derive(Copy, Clone, PartialEq, Debug)]\n #[repr(C)]\n@@ -711,7 +684,7 @@ pub mod coverageinfo {\n     }\n \n     impl CounterMappingRegion {\n-        pub fn code_region(\n+        crate fn code_region(\n             counter: coverage_map::Counter,\n             file_id: u32,\n             start_line: u32,\n@@ -731,7 +704,10 @@ pub mod coverageinfo {\n             }\n         }\n \n-        pub fn expansion_region(\n+        // This function might be used in the future; the LLVM API is still evolving, as is coverage\n+        // support.\n+        #[allow(dead_code)]\n+        crate fn expansion_region(\n             file_id: u32,\n             expanded_file_id: u32,\n             start_line: u32,\n@@ -751,7 +727,10 @@ pub mod coverageinfo {\n             }\n         }\n \n-        pub fn skipped_region(\n+        // This function might be used in the future; the LLVM API is still evolving, as is coverage\n+        // support.\n+        #[allow(dead_code)]\n+        crate fn skipped_region(\n             file_id: u32,\n             start_line: u32,\n             start_col: u32,\n@@ -770,7 +749,10 @@ pub mod coverageinfo {\n             }\n         }\n \n-        pub fn gap_region(\n+        // This function might be used in the future; the LLVM API is still evolving, as is coverage\n+        // support.\n+        #[allow(dead_code)]\n+        crate fn gap_region(\n             counter: coverage_map::Counter,\n             file_id: u32,\n             start_line: u32,\n@@ -1031,6 +1013,7 @@ extern \"C\" {\n     pub fn LLVMSetSection(Global: &Value, Section: *const c_char);\n     pub fn LLVMRustGetVisibility(Global: &Value) -> Visibility;\n     pub fn LLVMRustSetVisibility(Global: &Value, Viz: Visibility);\n+    pub fn LLVMRustSetDSOLocal(Global: &Value, is_dso_local: bool);\n     pub fn LLVMGetAlignment(Global: &Value) -> c_uint;\n     pub fn LLVMSetAlignment(Global: &Value, Bytes: c_uint);\n     pub fn LLVMSetDLLStorageClass(V: &Value, C: DLLStorageClass);"}, {"sha": "fc1f364e9c6bc9baee49a661c6b8a4a4dd31774c", "filename": "compiler/rustc_codegen_llvm/src/mono_item.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -10,7 +10,9 @@ pub use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n use rustc_middle::ty::layout::FnAbiExt;\n use rustc_middle::ty::{self, Instance, TypeFoldable};\n+use rustc_session::config::CrateType;\n use rustc_target::abi::LayoutOf;\n+use rustc_target::spec::RelocModel;\n use tracing::debug;\n \n impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n@@ -35,6 +37,9 @@ impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         unsafe {\n             llvm::LLVMRustSetLinkage(g, base::linkage_to_llvm(linkage));\n             llvm::LLVMRustSetVisibility(g, base::visibility_to_llvm(visibility));\n+            if self.should_assume_dso_local(linkage, visibility) {\n+                llvm::LLVMRustSetDSOLocal(g, true);\n+            }\n         }\n \n         self.instances.borrow_mut().insert(instance, g);\n@@ -79,6 +84,42 @@ impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n         attributes::from_fn_attrs(self, lldecl, instance);\n \n+        unsafe {\n+            if self.should_assume_dso_local(linkage, visibility) {\n+                llvm::LLVMRustSetDSOLocal(lldecl, true);\n+            }\n+        }\n+\n         self.instances.borrow_mut().insert(instance, lldecl);\n     }\n }\n+\n+impl CodegenCx<'ll, 'tcx> {\n+    /// Whether a definition (NB: not declaration!) can be assumed to be local to a group of\n+    /// libraries that form a single DSO or executable.\n+    pub(crate) unsafe fn should_assume_dso_local(\n+        &self,\n+        linkage: Linkage,\n+        visibility: Visibility,\n+    ) -> bool {\n+        if matches!(linkage, Linkage::Internal | Linkage::Private) {\n+            return true;\n+        }\n+\n+        if visibility != Visibility::Default && linkage != Linkage::ExternalWeak {\n+            return true;\n+        }\n+\n+        // Static relocation model should force copy relocations everywhere.\n+        if self.tcx.sess.relocation_model() == RelocModel::Static {\n+            return true;\n+        }\n+\n+        // Symbols from executables can't really be imported any further.\n+        if self.tcx.sess.crate_types().iter().all(|ty| *ty == CrateType::Executable) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+}"}, {"sha": "7c1aaebb9abaf65da8105b4be2d71203a8914016", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -11,7 +11,6 @@ test = false\n bitflags = \"1.2.1\"\n cc = \"1.0.1\"\n itertools = \"0.9\"\n-memmap2 = \"0.2.1\"\n tracing = \"0.1\"\n libc = \"0.2.50\"\n jobserver = \"0.1.11\""}, {"sha": "ea75943d6f3147c768b278fffd438c96a0c1020f", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -6,7 +6,7 @@ use rustc_hir::def_id::CrateNum;\n use rustc_middle::middle::cstore::{EncodedMetadata, LibSource};\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_session::config::{self, CFGuard, CrateType, DebugInfo};\n-use rustc_session::config::{OutputFilenames, OutputType, PrintRequest, SanitizerSet};\n+use rustc_session::config::{OutputFilenames, OutputType, PrintRequest};\n use rustc_session::output::{check_file_is_writeable, invalid_output_for_target, out_filename};\n use rustc_session::search_paths::PathKind;\n use rustc_session::utils::NativeLibKind;\n@@ -16,7 +16,7 @@ use rustc_session::{filesearch, Session};\n use rustc_span::symbol::Symbol;\n use rustc_target::spec::crt_objects::{CrtObjects, CrtObjectsFallback};\n use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor, SplitDebuginfo};\n-use rustc_target::spec::{PanicStrategy, RelocModel, RelroLevel, Target};\n+use rustc_target::spec::{PanicStrategy, RelocModel, RelroLevel, SanitizerSet, Target};\n \n use super::archive::ArchiveBuilder;\n use super::command::Command;\n@@ -922,28 +922,20 @@ fn link_sanitizer_runtime(sess: &Session, linker: &mut dyn Linker, name: &str) {\n         .map(|channel| format!(\"-{}\", channel))\n         .unwrap_or_default();\n \n-    match sess.opts.target_triple.triple() {\n-        \"aarch64-apple-darwin\" | \"x86_64-apple-darwin\" => {\n-            // On Apple platforms, the sanitizer is always built as a dylib, and\n-            // LLVM will link to `@rpath/*.dylib`, so we need to specify an\n-            // rpath to the library as well (the rpath should be absolute, see\n-            // PR #41352 for details).\n-            let filename = format!(\"rustc{}_rt.{}\", channel, name);\n-            let path = find_sanitizer_runtime(&sess, &filename);\n-            let rpath = path.to_str().expect(\"non-utf8 component in path\");\n-            linker.args(&[\"-Wl,-rpath\", \"-Xlinker\", rpath]);\n-            linker.link_dylib(Symbol::intern(&filename));\n-        }\n-        \"aarch64-fuchsia\"\n-        | \"aarch64-unknown-linux-gnu\"\n-        | \"x86_64-fuchsia\"\n-        | \"x86_64-unknown-freebsd\"\n-        | \"x86_64-unknown-linux-gnu\" => {\n-            let filename = format!(\"librustc{}_rt.{}.a\", channel, name);\n-            let path = find_sanitizer_runtime(&sess, &filename).join(&filename);\n-            linker.link_whole_rlib(&path);\n-        }\n-        _ => {}\n+    if sess.target.is_like_osx {\n+        // On Apple platforms, the sanitizer is always built as a dylib, and\n+        // LLVM will link to `@rpath/*.dylib`, so we need to specify an\n+        // rpath to the library as well (the rpath should be absolute, see\n+        // PR #41352 for details).\n+        let filename = format!(\"rustc{}_rt.{}\", channel, name);\n+        let path = find_sanitizer_runtime(&sess, &filename);\n+        let rpath = path.to_str().expect(\"non-utf8 component in path\");\n+        linker.args(&[\"-Wl,-rpath\", \"-Xlinker\", rpath]);\n+        linker.link_dylib(Symbol::intern(&filename));\n+    } else {\n+        let filename = format!(\"librustc{}_rt.{}.a\", channel, name);\n+        let path = find_sanitizer_runtime(&sess, &filename).join(&filename);\n+        linker.link_whole_rlib(&path);\n     }\n }\n \n@@ -1419,15 +1411,10 @@ fn add_link_script(cmd: &mut dyn Linker, sess: &Session, tmpdir: &Path, crate_ty\n     }\n }\n \n-/// Add arbitrary \"user defined\" args defined from command line and by `#[link_args]` attributes.\n+/// Add arbitrary \"user defined\" args defined from command line.\n /// FIXME: Determine where exactly these args need to be inserted.\n-fn add_user_defined_link_args(\n-    cmd: &mut dyn Linker,\n-    sess: &Session,\n-    codegen_results: &CodegenResults,\n-) {\n+fn add_user_defined_link_args(cmd: &mut dyn Linker, sess: &Session) {\n     cmd.args(&sess.opts.cg.link_args);\n-    cmd.args(&*codegen_results.crate_info.link_args);\n }\n \n /// Add arbitrary \"late link\" args defined by the target spec.\n@@ -1651,6 +1638,16 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n         cmd.add_eh_frame_header();\n     }\n \n+    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n+    // Make the binary compatible with data execution prevention schemes.\n+    cmd.add_no_exec();\n+\n+    // NO-OPT-OUT, OBJECT-FILES-NO\n+    // Avoid linking to dynamic libraries unless they satisfy some undefined symbols\n+    // at the point at which they are specified on the command line.\n+    // Must be passed before any dynamic libraries.\n+    cmd.add_as_needed();\n+\n     // NO-OPT-OUT, OBJECT-FILES-NO\n     if crt_objects_fallback {\n         cmd.no_crt_objects();\n@@ -1759,7 +1756,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     add_rpath_args(cmd, sess, codegen_results, out_filename);\n \n     // OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n-    add_user_defined_link_args(cmd, sess, codegen_results);\n+    add_user_defined_link_args(cmd, sess);\n \n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n     cmd.finalize();"}, {"sha": "77d8ab49ff258d2b2acaac870182fefc5c759f4a", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -130,6 +130,8 @@ pub trait Linker {\n     fn group_end(&mut self);\n     fn linker_plugin_lto(&mut self);\n     fn add_eh_frame_header(&mut self) {}\n+    fn add_no_exec(&mut self) {}\n+    fn add_as_needed(&mut self) {}\n     fn finalize(&mut self);\n }\n \n@@ -184,7 +186,7 @@ impl<'a> GccLinker<'a> {\n         // * On OSX they have their own linker, not binutils'\n         // * For WebAssembly the only functional linker is LLD, which doesn't\n         //   support hint flags\n-        !self.sess.target.is_like_osx && self.sess.target.arch != \"wasm32\"\n+        !self.sess.target.is_like_osx && !self.sess.target.is_like_wasm\n     }\n \n     // Some platforms take hints about whether a library is static or dynamic.\n@@ -641,6 +643,20 @@ impl<'a> Linker for GccLinker<'a> {\n     fn add_eh_frame_header(&mut self) {\n         self.linker_arg(\"--eh-frame-hdr\");\n     }\n+\n+    fn add_no_exec(&mut self) {\n+        if self.sess.target.is_like_windows {\n+            self.linker_arg(\"--nxcompat\");\n+        } else if self.sess.target.linker_is_gnu {\n+            self.linker_arg(\"-znoexecstack\");\n+        }\n+    }\n+\n+    fn add_as_needed(&mut self) {\n+        if self.sess.target.linker_is_gnu {\n+            self.linker_arg(\"--as-needed\");\n+        }\n+    }\n }\n \n pub struct MsvcLinker<'a> {\n@@ -878,6 +894,10 @@ impl<'a> Linker for MsvcLinker<'a> {\n     fn linker_plugin_lto(&mut self) {\n         // Do nothing\n     }\n+\n+    fn add_no_exec(&mut self) {\n+        self.cmd.arg(\"/NXCOMPAT\");\n+    }\n }\n \n pub struct EmLinker<'a> {"}, {"sha": "0ff05229466ac92847e5b7574551428015b0da62", "filename": "compiler/rustc_codegen_ssa/src/back/lto.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flto.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -2,6 +2,7 @@ use super::write::CodegenContext;\n use crate::traits::*;\n use crate::ModuleCodegen;\n \n+use rustc_data_structures::memmap::Mmap;\n use rustc_errors::FatalError;\n \n use std::ffi::CString;\n@@ -93,7 +94,7 @@ impl<B: WriteBackendMethods> LtoModuleCodegen<B> {\n pub enum SerializedModule<M: ModuleBufferMethods> {\n     Local(M),\n     FromRlib(Vec<u8>),\n-    FromUncompressedFile(memmap2::Mmap),\n+    FromUncompressedFile(Mmap),\n }\n \n impl<M: ModuleBufferMethods> SerializedModule<M> {"}, {"sha": "b8f277c8ff5e3e2de517daa74ddccc3b05ebfcfe", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -15,7 +15,8 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::Instance;\n use rustc_middle::ty::{SymbolName, TyCtxt};\n-use rustc_session::config::{CrateType, SanitizerSet};\n+use rustc_session::config::CrateType;\n+use rustc_target::spec::SanitizerSet;\n \n pub fn threshold(tcx: TyCtxt<'_>) -> SymbolExportLevel {\n     crates_export_threshold(&tcx.sess.crate_types())"}, {"sha": "04d06864ee14fea4ad950454a08f26a71c709534", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -10,6 +10,7 @@ use crate::{\n use crate::traits::*;\n use jobserver::{Acquired, Client};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::profiling::TimingGuard;\n use rustc_data_structures::profiling::VerboseTimingGuard;\n@@ -27,12 +28,12 @@ use rustc_middle::middle::exported_symbols::SymbolExportLevel;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::cgu_reuse_tracker::CguReuseTracker;\n use rustc_session::config::{self, CrateType, Lto, OutputFilenames, OutputType};\n-use rustc_session::config::{Passes, SanitizerSet, SwitchWithOptPath};\n+use rustc_session::config::{Passes, SwitchWithOptPath};\n use rustc_session::Session;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, FileName, InnerSpan, Pos, Span};\n-use rustc_target::spec::{MergeFunctions, PanicStrategy};\n+use rustc_target::spec::{MergeFunctions, PanicStrategy, SanitizerSet};\n \n use std::any::Any;\n use std::fs;\n@@ -106,7 +107,7 @@ pub struct ModuleConfig {\n     pub vectorize_loop: bool,\n     pub vectorize_slp: bool,\n     pub merge_functions: bool,\n-    pub inline_threshold: Option<usize>,\n+    pub inline_threshold: Option<u32>,\n     pub new_llvm_pass_manager: bool,\n     pub emit_lifetime_markers: bool,\n }\n@@ -1958,7 +1959,7 @@ pub fn submit_pre_lto_module_to_llvm<B: ExtraBackendMethods>(\n         .unwrap_or_else(|e| panic!(\"failed to open bitcode file `{}`: {}\", bc_path.display(), e));\n \n     let mmap = unsafe {\n-        memmap2::Mmap::map(&file).unwrap_or_else(|e| {\n+        Mmap::map(file).unwrap_or_else(|e| {\n             panic!(\"failed to mmap bitcode file `{}`: {}\", bc_path.display(), e)\n         })\n     };"}, {"sha": "318eed76acf2b0558dbdb918540f9ec7cfc5f907", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -754,7 +754,6 @@ impl CrateInfo {\n             is_no_builtins: Default::default(),\n             native_libraries: Default::default(),\n             used_libraries: tcx.native_libraries(LOCAL_CRATE).iter().map(Into::into).collect(),\n-            link_args: tcx.link_args(LOCAL_CRATE),\n             crate_name: Default::default(),\n             used_crates_dynamic: cstore::used_crates(tcx, LinkagePreference::RequireDynamic),\n             used_crates_static: cstore::used_crates(tcx, LinkagePreference::RequireStatic),"}, {"sha": "962c01c2ee7a6fd25cb9633523056319f21643ac", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/ffi.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -24,21 +24,39 @@ pub enum CounterKind {\n pub struct Counter {\n     // Important: The layout (order and types of fields) must match its C++ counterpart.\n     pub kind: CounterKind,\n-    pub id: u32,\n+    id: u32,\n }\n \n impl Counter {\n+    /// Constructs a new `Counter` of kind `Zero`. For this `CounterKind`, the\n+    /// `id` is not used.\n     pub fn zero() -> Self {\n         Self { kind: CounterKind::Zero, id: 0 }\n     }\n \n+    /// Constructs a new `Counter` of kind `CounterValueReference`, and converts\n+    /// the given 1-based counter_id to the required 0-based equivalent for\n+    /// the `Counter` encoding.\n     pub fn counter_value_reference(counter_id: CounterValueReference) -> Self {\n-        Self { kind: CounterKind::CounterValueReference, id: counter_id.into() }\n+        Self { kind: CounterKind::CounterValueReference, id: counter_id.zero_based_index() }\n     }\n \n+    /// Constructs a new `Counter` of kind `Expression`.\n     pub fn expression(mapped_expression_index: MappedExpressionIndex) -> Self {\n         Self { kind: CounterKind::Expression, id: mapped_expression_index.into() }\n     }\n+\n+    /// Returns true if the `Counter` kind is `Zero`.\n+    pub fn is_zero(&self) -> bool {\n+        matches!(self.kind, CounterKind::Zero)\n+    }\n+\n+    /// An explicitly-named function to get the ID value, making it more obvious\n+    /// that the stored value is now 0-based.\n+    pub fn zero_based_id(&self) -> u32 {\n+        debug_assert!(!self.is_zero(), \"`id` is undefined for CounterKind::Zero\");\n+        self.id\n+    }\n }\n \n /// Aligns with [llvm::coverage::CounterExpression::ExprKind](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L147)"}, {"sha": "4458fd686788f3857315da62dc20e015dda11d67", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/map.rs", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -163,9 +163,7 @@ impl<'tcx> FunctionCoverage<'tcx> {\n         self.counters.iter_enumerated().filter_map(|(index, entry)| {\n             // Option::map() will return None to filter out missing counters. This may happen\n             // if, for example, a MIR-instrumented counter is removed during an optimization.\n-            entry.as_ref().map(|region| {\n-                (Counter::counter_value_reference(index as CounterValueReference), region)\n-            })\n+            entry.as_ref().map(|region| (Counter::counter_value_reference(index), region))\n         })\n     }\n \n@@ -206,9 +204,15 @@ impl<'tcx> FunctionCoverage<'tcx> {\n             if id == ExpressionOperandId::ZERO {\n                 Some(Counter::zero())\n             } else if id.index() < self.counters.len() {\n+                debug_assert!(\n+                    id.index() > 0,\n+                    \"ExpressionOperandId indexes for counters are 1-based, but this id={}\",\n+                    id.index()\n+                );\n                 // Note: Some codegen-injected Counters may be only referenced by `Expression`s,\n                 // and may not have their own `CodeRegion`s,\n                 let index = CounterValueReference::from(id.index());\n+                // Note, the conversion to LLVM `Counter` adjusts the index to be zero-based.\n                 Some(Counter::counter_value_reference(index))\n             } else {\n                 let index = self.expression_index(u32::from(id));\n@@ -233,19 +237,60 @@ impl<'tcx> FunctionCoverage<'tcx> {\n             let optional_region = &expression.region;\n             let Expression { lhs, op, rhs, .. } = *expression;\n \n-            if let Some(Some((lhs_counter, rhs_counter))) =\n-                id_to_counter(&new_indexes, lhs).map(|lhs_counter| {\n+            if let Some(Some((lhs_counter, mut rhs_counter))) = id_to_counter(&new_indexes, lhs)\n+                .map(|lhs_counter| {\n                     id_to_counter(&new_indexes, rhs).map(|rhs_counter| (lhs_counter, rhs_counter))\n                 })\n             {\n+                if lhs_counter.is_zero() && op.is_subtract() {\n+                    // The left side of a subtraction was probably optimized out. As an example,\n+                    // a branch condition might be evaluated as a constant expression, and the\n+                    // branch could be removed, dropping unused counters in the process.\n+                    //\n+                    // Since counters are unsigned, we must assume the result of the expression\n+                    // can be no more and no less than zero. An expression known to evaluate to zero\n+                    // does not need to be added to the coverage map.\n+                    //\n+                    // Coverage test `loops_branches.rs` includes multiple variations of branches\n+                    // based on constant conditional (literal `true` or `false`), and demonstrates\n+                    // that the expected counts are still correct.\n+                    debug!(\n+                        \"Expression subtracts from zero (assume unreachable): \\\n+                        original_index={:?}, lhs={:?}, op={:?}, rhs={:?}, region={:?}\",\n+                        original_index, lhs, op, rhs, optional_region,\n+                    );\n+                    rhs_counter = Counter::zero();\n+                }\n                 debug_assert!(\n-                    (lhs_counter.id as usize)\n-                        < usize::max(self.counters.len(), self.expressions.len())\n+                    lhs_counter.is_zero()\n+                        // Note: with `as usize` the ID _could_ overflow/wrap if `usize = u16`\n+                        || ((lhs_counter.zero_based_id() as usize)\n+                            <= usize::max(self.counters.len(), self.expressions.len())),\n+                    \"lhs id={} > both counters.len()={} and expressions.len()={}\n+                    ({:?} {:?} {:?})\",\n+                    lhs_counter.zero_based_id(),\n+                    self.counters.len(),\n+                    self.expressions.len(),\n+                    lhs_counter,\n+                    op,\n+                    rhs_counter,\n                 );\n+\n                 debug_assert!(\n-                    (rhs_counter.id as usize)\n-                        < usize::max(self.counters.len(), self.expressions.len())\n+                    rhs_counter.is_zero()\n+                        // Note: with `as usize` the ID _could_ overflow/wrap if `usize = u16`\n+                        || ((rhs_counter.zero_based_id() as usize)\n+                            <= usize::max(self.counters.len(), self.expressions.len())),\n+                    \"rhs id={} > both counters.len()={} and expressions.len()={}\n+                    ({:?} {:?} {:?})\",\n+                    rhs_counter.zero_based_id(),\n+                    self.counters.len(),\n+                    self.expressions.len(),\n+                    lhs_counter,\n+                    op,\n+                    rhs_counter,\n                 );\n+\n                 // Both operands exist. `Expression` operands exist in `self.expressions` and have\n                 // been assigned a `new_index`.\n                 let mapped_expression_index =\n@@ -268,11 +313,15 @@ impl<'tcx> FunctionCoverage<'tcx> {\n                     expression_regions.push((Counter::expression(mapped_expression_index), region));\n                 }\n             } else {\n-                debug!(\n-                    \"Ignoring expression with one or more missing operands: \\\n-                    original_index={:?}, lhs={:?}, op={:?}, rhs={:?}, region={:?}\",\n-                    original_index, lhs, op, rhs, optional_region,\n-                )\n+                bug!(\n+                    \"expression has one or more missing operands \\\n+                      original_index={:?}, lhs={:?}, op={:?}, rhs={:?}, region={:?}\",\n+                    original_index,\n+                    lhs,\n+                    op,\n+                    rhs,\n+                    optional_region,\n+                );\n             }\n         }\n         (counter_expressions, expression_regions.into_iter())"}, {"sha": "f0f45b067b35261a81230ae8436f634e47cf4ac7", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -8,6 +8,7 @@\n #![feature(nll)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(associated_type_bounds)]\n+#![feature(iter_zip)]\n #![recursion_limit = \"256\"]\n #![feature(box_syntax)]\n \n@@ -138,7 +139,6 @@ pub struct CrateInfo {\n     pub native_libraries: FxHashMap<CrateNum, Vec<NativeLib>>,\n     pub crate_name: FxHashMap<CrateNum, String>,\n     pub used_libraries: Vec<NativeLib>,\n-    pub link_args: Lrc<Vec<String>>,\n     pub used_crate_source: FxHashMap<CrateNum, Lrc<CrateSource>>,\n     pub used_crates_static: Vec<(CrateNum, LibSource)>,\n     pub used_crates_dynamic: Vec<(CrateNum, LibSource)>,"}, {"sha": "621ec0519c956fd5af19f145524b5c0527b99cda", "filename": "compiler/rustc_codegen_ssa/src/mir/coverageinfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     let fn_name = bx.get_pgo_func_name_var(instance);\n                     let hash = bx.const_u64(function_source_hash);\n                     let num_counters = bx.const_u32(coverageinfo.num_counters);\n-                    let index = bx.const_u32(u32::from(id));\n+                    let index = bx.const_u32(id.zero_based_index());\n                     debug!(\n                         \"codegen intrinsic instrprof.increment(fn_name={:?}, hash={:?}, num_counters={:?}, index={:?})\",\n                         fn_name, hash, num_counters, index,"}, {"sha": "91df67b53d21fb6192ebb162a72a327a3c0d587d", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -282,9 +282,7 @@ fn create_funclets<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>>,\n     IndexVec<mir::BasicBlock, Option<Bx::Funclet>>,\n ) {\n-    block_bxs\n-        .iter_enumerated()\n-        .zip(cleanup_kinds)\n+    iter::zip(block_bxs.iter_enumerated(), cleanup_kinds)\n         .map(|((bb, &llbb), cleanup_kind)| {\n             match *cleanup_kind {\n                 CleanupKind::Funclet if base::wants_msvc_seh(bx.sess()) => {}"}, {"sha": "4e987908b4ea7b5cda6559f7a35afa11879c066e", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -26,6 +26,7 @@ const ARM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"vfp2\", Some(sym::arm_target_feature)),\n     (\"vfp3\", Some(sym::arm_target_feature)),\n     (\"vfp4\", Some(sym::arm_target_feature)),\n+    (\"fp-armv8\", Some(sym::arm_target_feature)),\n     // This is needed for inline assembly, but shouldn't be stabilized as-is\n     // since it should be enabled per-function using #[instruction_set], not\n     // #[target_feature].\n@@ -160,7 +161,7 @@ pub fn supported_target_features(sess: &Session) -> &'static [(&'static str, Opt\n         \"mips\" | \"mips64\" => MIPS_ALLOWED_FEATURES,\n         \"powerpc\" | \"powerpc64\" => POWERPC_ALLOWED_FEATURES,\n         \"riscv32\" | \"riscv64\" => RISCV_ALLOWED_FEATURES,\n-        \"wasm32\" => WASM_ALLOWED_FEATURES,\n+        \"wasm32\" | \"wasm64\" => WASM_ALLOWED_FEATURES,\n         _ => &[],\n     }\n }"}, {"sha": "d32598e716e1df0c3a05fdb636e9f231f024526d", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -36,3 +36,6 @@ features = [\"nightly\"]\n \n [target.'cfg(windows)'.dependencies]\n winapi = { version = \"0.3\", features = [\"fileapi\", \"psapi\"] }\n+\n+[target.'cfg(not(target_arch = \"wasm32\"))'.dependencies]\n+memmap2 = \"0.2.1\""}, {"sha": "adbb98fa750476f7a66b72fd5322af51898315e1", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -84,6 +84,7 @@ pub mod snapshot_map;\n pub mod stable_map;\n pub mod svh;\n pub use ena::snapshot_vec;\n+pub mod memmap;\n pub mod sorted_map;\n pub mod stable_set;\n #[macro_use]"}, {"sha": "26b26415eea0f85c0088385ed7da2096b0330a52", "filename": "compiler/rustc_data_structures/src/memmap.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -0,0 +1,47 @@\n+use std::fs::File;\n+use std::io;\n+use std::ops::Deref;\n+\n+use crate::owning_ref::StableAddress;\n+\n+/// A trivial wrapper for [`memmap2::Mmap`] that implements [`StableAddress`].\n+#[cfg(not(target_arch = \"wasm32\"))]\n+pub struct Mmap(memmap2::Mmap);\n+\n+#[cfg(target_arch = \"wasm32\")]\n+pub struct Mmap(Vec<u8>);\n+\n+#[cfg(not(target_arch = \"wasm32\"))]\n+impl Mmap {\n+    #[inline]\n+    pub unsafe fn map(file: File) -> io::Result<Self> {\n+        memmap2::Mmap::map(&file).map(Mmap)\n+    }\n+}\n+\n+#[cfg(target_arch = \"wasm32\")]\n+impl Mmap {\n+    #[inline]\n+    pub unsafe fn map(mut file: File) -> io::Result<Self> {\n+        use std::io::Read;\n+\n+        let mut data = Vec::new();\n+        file.read_to_end(&mut data)?;\n+        Ok(Mmap(data))\n+    }\n+}\n+\n+impl Deref for Mmap {\n+    type Target = [u8];\n+\n+    #[inline]\n+    fn deref(&self) -> &[u8] {\n+        &*self.0\n+    }\n+}\n+\n+// SAFETY: On architectures other than WASM, mmap is used as backing storage. The address of this\n+// memory map is stable. On WASM, `Vec<u8>` is used as backing storage. The `Mmap` type doesn't\n+// export any function that can cause the `Vec` to be re-allocated. As such the address of the\n+// bytes inside this `Vec` is stable.\n+unsafe impl StableAddress for Mmap {}"}, {"sha": "d44ccd368b3cbb507c630fca26432c7a7da39da2", "filename": "compiler/rustc_data_structures/src/tagged_ptr/drop.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -42,18 +42,9 @@ where\n     pub fn pointer_ref(&self) -> &P::Target {\n         self.raw.pointer_ref()\n     }\n-    pub fn pointer_mut(&mut self) -> &mut P::Target\n-    where\n-        P: std::ops::DerefMut,\n-    {\n-        self.raw.pointer_mut()\n-    }\n     pub fn tag(&self) -> T {\n         self.raw.tag()\n     }\n-    pub fn set_tag(&mut self, tag: T) {\n-        self.raw.set_tag(tag);\n-    }\n }\n \n impl<P, T, const COMPARE_PACKED: bool> std::ops::Deref for TaggedPtr<P, T, COMPARE_PACKED>"}, {"sha": "00e304734983ff15a0cb3e78dd76a8649f692508", "filename": "compiler/rustc_data_structures/src/thin_vec.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,5 +1,7 @@\n use crate::stable_hasher::{HashStable, StableHasher};\n \n+use std::iter::FromIterator;\n+\n /// A vector type optimized for cases where this size is usually 0 (cf. `SmallVector`).\n /// The `Option<Box<..>>` wrapping allows us to represent a zero sized vector with `None`,\n /// which uses only a single (null) pointer.\n@@ -10,6 +12,14 @@ impl<T> ThinVec<T> {\n     pub fn new() -> Self {\n         ThinVec(None)\n     }\n+\n+    pub fn iter(&self) -> std::slice::Iter<'_, T> {\n+        self.into_iter()\n+    }\n+\n+    pub fn iter_mut(&mut self) -> std::slice::IterMut<'_, T> {\n+        self.into_iter()\n+    }\n }\n \n impl<T> From<Vec<T>> for ThinVec<T> {\n@@ -46,6 +56,42 @@ impl<T> ::std::ops::DerefMut for ThinVec<T> {\n     }\n }\n \n+impl<T> FromIterator<T> for ThinVec<T> {\n+    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n+        // `Vec::from_iter()` should not allocate if the iterator is empty.\n+        let vec: Vec<_> = iter.into_iter().collect();\n+        if vec.is_empty() { ThinVec(None) } else { ThinVec(Some(Box::new(vec))) }\n+    }\n+}\n+\n+impl<T> IntoIterator for ThinVec<T> {\n+    type Item = T;\n+    type IntoIter = std::vec::IntoIter<T>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        // This is still performant because `Vec::new()` does not allocate.\n+        self.0.map_or_else(Vec::new, |ptr| *ptr).into_iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a ThinVec<T> {\n+    type Item = &'a T;\n+    type IntoIter = std::slice::Iter<'a, T>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.as_ref().iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a mut ThinVec<T> {\n+    type Item = &'a mut T;\n+    type IntoIter = std::slice::IterMut<'a, T>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.as_mut().iter_mut()\n+    }\n+}\n+\n impl<T> Extend<T> for ThinVec<T> {\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         match *self {\n@@ -80,3 +126,6 @@ impl<T> Default for ThinVec<T> {\n         Self(None)\n     }\n }\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "5abfd939373c7668ff5657be21343c220f18cba3", "filename": "compiler/rustc_data_structures/src/thin_vec/tests.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec%2Ftests.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -0,0 +1,42 @@\n+use super::*;\n+\n+impl<T> ThinVec<T> {\n+    fn into_vec(self) -> Vec<T> {\n+        self.into()\n+    }\n+}\n+\n+#[test]\n+fn test_from_iterator() {\n+    assert_eq!(std::iter::empty().collect::<ThinVec<String>>().into_vec(), Vec::<String>::new());\n+    assert_eq!(std::iter::once(42).collect::<ThinVec<_>>().into_vec(), vec![42]);\n+    assert_eq!(vec![1, 2].into_iter().collect::<ThinVec<_>>().into_vec(), vec![1, 2]);\n+    assert_eq!(vec![1, 2, 3].into_iter().collect::<ThinVec<_>>().into_vec(), vec![1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_into_iterator_owned() {\n+    assert_eq!(ThinVec::new().into_iter().collect::<Vec<String>>(), Vec::<String>::new());\n+    assert_eq!(ThinVec::from(vec![1]).into_iter().collect::<Vec<_>>(), vec![1]);\n+    assert_eq!(ThinVec::from(vec![1, 2]).into_iter().collect::<Vec<_>>(), vec![1, 2]);\n+    assert_eq!(ThinVec::from(vec![1, 2, 3]).into_iter().collect::<Vec<_>>(), vec![1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_into_iterator_ref() {\n+    assert_eq!(ThinVec::new().iter().collect::<Vec<&String>>(), Vec::<&String>::new());\n+    assert_eq!(ThinVec::from(vec![1]).iter().collect::<Vec<_>>(), vec![&1]);\n+    assert_eq!(ThinVec::from(vec![1, 2]).iter().collect::<Vec<_>>(), vec![&1, &2]);\n+    assert_eq!(ThinVec::from(vec![1, 2, 3]).iter().collect::<Vec<_>>(), vec![&1, &2, &3]);\n+}\n+\n+#[test]\n+fn test_into_iterator_ref_mut() {\n+    assert_eq!(ThinVec::new().iter_mut().collect::<Vec<&mut String>>(), Vec::<&mut String>::new());\n+    assert_eq!(ThinVec::from(vec![1]).iter_mut().collect::<Vec<_>>(), vec![&mut 1]);\n+    assert_eq!(ThinVec::from(vec![1, 2]).iter_mut().collect::<Vec<_>>(), vec![&mut 1, &mut 2]);\n+    assert_eq!(\n+        ThinVec::from(vec![1, 2, 3]).iter_mut().collect::<Vec<_>>(),\n+        vec![&mut 1, &mut 2, &mut 3],\n+    );\n+}"}, {"sha": "10317f1afff673e3db6f0355fcc26591205c2dde", "filename": "compiler/rustc_data_structures/src/work_queue.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -41,10 +41,4 @@ impl<T: Idx> WorkQueue<T> {\n             None\n         }\n     }\n-\n-    /// Returns `true` if nothing is enqueued.\n-    #[inline]\n-    pub fn is_empty(&self) -> bool {\n-        self.deque.is_empty()\n-    }\n }"}, {"sha": "3d26c94ec77a26879d3e94979c2e48c599dddd47", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -146,6 +146,7 @@ impl<'a, 'b> RunCompiler<'a, 'b> {\n     pub fn new(at_args: &'a [String], callbacks: &'b mut (dyn Callbacks + Send)) -> Self {\n         Self { at_args, callbacks, file_loader: None, emitter: None, make_codegen_backend: None }\n     }\n+    /// Used by cg_clif.\n     pub fn set_make_codegen_backend(\n         &mut self,\n         make_codegen_backend: Option<\n@@ -155,10 +156,12 @@ impl<'a, 'b> RunCompiler<'a, 'b> {\n         self.make_codegen_backend = make_codegen_backend;\n         self\n     }\n+    /// Used by RLS.\n     pub fn set_emitter(&mut self, emitter: Option<Box<dyn Write + Send>>) -> &mut Self {\n         self.emitter = emitter;\n         self\n     }\n+    /// Used by RLS.\n     pub fn set_file_loader(\n         &mut self,\n         file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n@@ -792,7 +795,7 @@ pub fn version(binary: &str, matches: &getopts::Matches) {\n         println!(\"host: {}\", config::host_triple());\n         println!(\"release: {}\", unw(util::release_str()));\n         if cfg!(feature = \"llvm\") {\n-            get_builtin_codegen_backend(\"llvm\")().print_version();\n+            get_builtin_codegen_backend(&None, \"llvm\")().print_version();\n         }\n     }\n }\n@@ -1086,7 +1089,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n \n     if cg_flags.iter().any(|x| *x == \"passes=list\") {\n         if cfg!(feature = \"llvm\") {\n-            get_builtin_codegen_backend(\"llvm\")().print_passes();\n+            get_builtin_codegen_backend(&None, \"llvm\")().print_passes();\n         }\n         return None;\n     }"}, {"sha": "e0c140b143be89326b7f743ecfd5a1413ae5cc35", "filename": "compiler/rustc_driver/src/pretty.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -108,13 +108,6 @@ trait HirPrinterSupport<'hir>: pprust_hir::PpAnn {\n     /// (Rust does not yet support upcasting from a trait object to\n     /// an object for one of its super-traits.)\n     fn pp_ann(&self) -> &dyn pprust_hir::PpAnn;\n-\n-    /// Computes an user-readable representation of a path, if possible.\n-    fn node_path(&self, id: hir::HirId) -> Option<String> {\n-        self.hir_map().and_then(|map| map.def_path_from_hir_id(id)).map(|path| {\n-            path.data.into_iter().map(|elem| elem.data.to_string()).collect::<Vec<_>>().join(\"::\")\n-        })\n-    }\n }\n \n struct NoAnn<'hir> {\n@@ -327,10 +320,6 @@ impl<'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'tcx> {\n     fn pp_ann(&self) -> &dyn pprust_hir::PpAnn {\n         self\n     }\n-\n-    fn node_path(&self, id: hir::HirId) -> Option<String> {\n-        Some(self.tcx.def_path_str(self.tcx.hir().local_def_id(id).to_def_id()))\n-    }\n }\n \n impl<'tcx> pprust_hir::PpAnn for TypedAnnotation<'tcx> {"}, {"sha": "f2432f61653530d35b95e8f36c97b23b6ed52b9b", "filename": "compiler/rustc_error_codes/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,5 +1,4 @@\n-#![cfg_attr(bootstrap, deny(invalid_codeblock_attributes))]\n-#![cfg_attr(not(bootstrap), deny(rustdoc::invalid_codeblock_attributes))]\n+#![deny(rustdoc::invalid_codeblock_attributes)]\n //! This library is used to gather all error codes into one place,\n //! the goal being to make their maintenance easier.\n "}, {"sha": "b2f6a0c10142df0645e35d21f3b6ad9e3a18d5b5", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 10, "deletions": 50, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -69,10 +69,6 @@ impl DiagnosticStyledString {\n     pub fn highlighted<S: Into<String>>(t: S) -> DiagnosticStyledString {\n         DiagnosticStyledString(vec![StringPart::Highlighted(t.into())])\n     }\n-\n-    pub fn content(&self) -> String {\n-        self.0.iter().map(|x| x.content()).collect::<String>()\n-    }\n }\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -81,14 +77,6 @@ pub enum StringPart {\n     Highlighted(String),\n }\n \n-impl StringPart {\n-    pub fn content(&self) -> &str {\n-        match self {\n-            &StringPart::Normal(ref s) | &StringPart::Highlighted(ref s) => s,\n-        }\n-    }\n-}\n-\n impl Diagnostic {\n     pub fn new(level: Level, message: &str) -> Self {\n         Diagnostic::new_with_code(level, None, message)\n@@ -156,7 +144,7 @@ impl Diagnostic {\n         self\n     }\n \n-    pub fn note_expected_found(\n+    crate fn note_expected_found(\n         &mut self,\n         expected_label: &dyn fmt::Display,\n         expected: DiagnosticStyledString,\n@@ -166,7 +154,7 @@ impl Diagnostic {\n         self.note_expected_found_extra(expected_label, expected, found_label, found, &\"\", &\"\")\n     }\n \n-    pub fn note_unsuccessful_coercion(\n+    crate fn note_unsuccessful_coercion(\n         &mut self,\n         expected: DiagnosticStyledString,\n         found: DiagnosticStyledString,\n@@ -256,33 +244,33 @@ impl Diagnostic {\n \n     /// Prints the span with a note above it.\n     /// This is like [`Diagnostic::note()`], but it gets its own span.\n-    pub fn span_note<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n+    crate fn span_note<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n         self.sub(Level::Note, msg, sp.into(), None);\n         self\n     }\n \n     /// Add a warning attached to this diagnostic.\n-    pub fn warn(&mut self, msg: &str) -> &mut Self {\n+    crate fn warn(&mut self, msg: &str) -> &mut Self {\n         self.sub(Level::Warning, msg, MultiSpan::new(), None);\n         self\n     }\n \n     /// Prints the span with a warning above it.\n     /// This is like [`Diagnostic::warn()`], but it gets its own span.\n-    pub fn span_warn<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n+    crate fn span_warn<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n         self.sub(Level::Warning, msg, sp.into(), None);\n         self\n     }\n \n     /// Add a help message attached to this diagnostic.\n-    pub fn help(&mut self, msg: &str) -> &mut Self {\n+    crate fn help(&mut self, msg: &str) -> &mut Self {\n         self.sub(Level::Help, msg, MultiSpan::new(), None);\n         self\n     }\n \n     /// Prints the span with some help above it.\n     /// This is like [`Diagnostic::help()`], but it gets its own span.\n-    pub fn span_help<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n+    crate fn span_help<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n         self.sub(Level::Help, msg, sp.into(), None);\n         self\n     }\n@@ -311,36 +299,6 @@ impl Diagnostic {\n         self\n     }\n \n-    /// Show multiple suggestions that have multiple parts.\n-    /// See also [`Diagnostic::multipart_suggestion()`].\n-    pub fn multipart_suggestions(\n-        &mut self,\n-        msg: &str,\n-        suggestions: Vec<Vec<(Span, String)>>,\n-        applicability: Applicability,\n-    ) -> &mut Self {\n-        assert!(!suggestions.is_empty());\n-        for s in &suggestions {\n-            assert!(!s.is_empty());\n-        }\n-        self.suggestions.push(CodeSuggestion {\n-            substitutions: suggestions\n-                .into_iter()\n-                .map(|suggestion| Substitution {\n-                    parts: suggestion\n-                        .into_iter()\n-                        .map(|(span, snippet)| SubstitutionPart { snippet, span })\n-                        .collect(),\n-                })\n-                .collect(),\n-            msg: msg.to_owned(),\n-            style: SuggestionStyle::ShowCode,\n-            applicability,\n-            tool_metadata: Default::default(),\n-        });\n-        self\n-    }\n-\n     /// Prints out a message with for a multipart suggestion without showing the suggested code.\n     ///\n     /// This is intended to be used for suggestions that are obvious in what the changes need to\n@@ -567,7 +525,7 @@ impl Diagnostic {\n         self.code.clone()\n     }\n \n-    pub fn set_primary_message<M: Into<String>>(&mut self, msg: M) -> &mut Self {\n+    crate fn set_primary_message<M: Into<String>>(&mut self, msg: M) -> &mut Self {\n         self.message[0] = (msg.into(), Style::NoStyle);\n         self\n     }\n@@ -582,6 +540,8 @@ impl Diagnostic {\n \n     /// Convenience function for internal use, clients should use one of the\n     /// public methods above.\n+    ///\n+    /// Used by `proc_macro_server` for implementing `server::Diagnostic`.\n     pub fn sub(\n         &mut self,\n         level: Level,"}, {"sha": "282877d5dd10962f9c7be3e66e0e96189d9529fc", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -157,19 +157,6 @@ impl<'a> DiagnosticBuilder<'a> {\n         buffered_diagnostics.extend(self.into_diagnostic().map(|(diag, _)| diag));\n     }\n \n-    /// Convenience function for internal use, clients should use one of the\n-    /// span_* methods instead.\n-    pub fn sub<S: Into<MultiSpan>>(\n-        &mut self,\n-        level: Level,\n-        message: &str,\n-        span: Option<S>,\n-    ) -> &mut Self {\n-        let span = span.map(|s| s.into()).unwrap_or_else(MultiSpan::new);\n-        self.0.diagnostic.sub(level, message, span, None);\n-        self\n-    }\n-\n     /// Delay emission of this diagnostic as a bug.\n     ///\n     /// This can be useful in contexts where an error indicates a bug but\n@@ -270,20 +257,6 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n-    /// See [`Diagnostic::multipart_suggestions()`].\n-    pub fn multipart_suggestions(\n-        &mut self,\n-        msg: &str,\n-        suggestions: Vec<Vec<(Span, String)>>,\n-        applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.multipart_suggestions(msg, suggestions, applicability);\n-        self\n-    }\n-\n     /// See [`Diagnostic::tool_only_multipart_suggestion()`].\n     pub fn tool_only_multipart_suggestion(\n         &mut self,"}, {"sha": "a58caf2667b063422046e32ebdf2ed020ce5f1eb", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -195,6 +195,9 @@ pub trait Emitter {\n \n     fn emit_future_breakage_report(&mut self, _diags: Vec<(FutureBreakage, Diagnostic)>) {}\n \n+    /// Emit list of unused externs\n+    fn emit_unused_externs(&mut self, _lint_level: &str, _unused_externs: &[&str]) {}\n+\n     /// Checks if should show explanations about \"rustc --explain\"\n     fn should_show_explain(&self) -> bool {\n         true\n@@ -1258,7 +1261,7 @@ impl EmitterWriter {\n                 buffer.append(0, \": \", header_style);\n             }\n             for &(ref text, _) in msg.iter() {\n-                buffer.append(0, text, header_style);\n+                buffer.append(0, &replace_tabs(text), header_style);\n             }\n         }\n \n@@ -2214,9 +2217,7 @@ pub fn is_case_difference(sm: &SourceMap, suggested: &str, sp: Span) -> bool {\n     };\n     let ascii_confusables = &['c', 'f', 'i', 'k', 'o', 's', 'u', 'v', 'w', 'x', 'y', 'z'];\n     // All the chars that differ in capitalization are confusable (above):\n-    let confusable = found\n-        .chars()\n-        .zip(suggested.chars())\n+    let confusable = iter::zip(found.chars(), suggested.chars())\n         .filter(|(f, s)| f != s)\n         .all(|(f, s)| (ascii_confusables.contains(&f) || ascii_confusables.contains(&s)));\n     confusable && found.to_lowercase() == suggested.to_lowercase()"}, {"sha": "40277006462d2b55cebe960d4ee8a6451311b6a6", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -159,6 +159,19 @@ impl Emitter for JsonEmitter {\n         }\n     }\n \n+    fn emit_unused_externs(&mut self, lint_level: &str, unused_externs: &[&str]) {\n+        let data = UnusedExterns { lint_level, unused_extern_names: unused_externs };\n+        let result = if self.pretty {\n+            writeln!(&mut self.dst, \"{}\", as_pretty_json(&data))\n+        } else {\n+            writeln!(&mut self.dst, \"{}\", as_json(&data))\n+        }\n+        .and_then(|_| self.dst.flush());\n+        if let Err(e) = result {\n+            panic!(\"failed to print unused externs: {:?}\", e);\n+        }\n+    }\n+\n     fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n         Some(&self.sm)\n     }\n@@ -322,6 +335,18 @@ struct FutureIncompatReport {\n     future_incompat_report: Vec<FutureBreakageItem>,\n }\n \n+// NOTE: Keep this in sync with the equivalent structs in rustdoc's\n+// doctest component (as well as cargo).\n+// We could unify this struct the one in rustdoc but they have different\n+// ownership semantics, so doing so would create wasteful allocations.\n+#[derive(Encodable)]\n+struct UnusedExterns<'a, 'b, 'c> {\n+    /// The severity level of the unused dependencies lint\n+    lint_level: &'a str,\n+    /// List of unused externs by their names.\n+    unused_extern_names: &'b [&'c str],\n+}\n+\n impl Diagnostic {\n     fn from_errors_diagnostic(diag: &crate::Diagnostic, je: &JsonEmitter) -> Diagnostic {\n         let sugg = diag.suggestions.iter().map(|sugg| Diagnostic {\n@@ -493,7 +518,7 @@ impl DiagnosticSpanLine {\n         h_end: usize,\n     ) -> DiagnosticSpanLine {\n         DiagnosticSpanLine {\n-            text: sf.get_line(index).map_or(String::new(), |l| l.into_owned()),\n+            text: sf.get_line(index).map_or_else(String::new, |l| l.into_owned()),\n             highlight_start: h_start,\n             highlight_end: h_end,\n         }"}, {"sha": "0d1f55a6b00eee194ff4eadb5936338ca86db0bc", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -6,6 +6,7 @@\n #![feature(crate_visibility_modifier)]\n #![feature(backtrace)]\n #![feature(extended_key_value_attributes)]\n+#![feature(iter_zip)]\n #![feature(nll)]\n \n #[macro_use]\n@@ -690,10 +691,6 @@ impl Handler {\n         db\n     }\n \n-    pub fn failure(&self, msg: &str) {\n-        self.inner.borrow_mut().failure(msg);\n-    }\n-\n     pub fn fatal(&self, msg: &str) -> FatalError {\n         self.inner.borrow_mut().fatal(msg)\n     }\n@@ -768,6 +765,10 @@ impl Handler {\n         self.inner.borrow_mut().emitter.emit_future_breakage_report(diags)\n     }\n \n+    pub fn emit_unused_externs(&self, lint_level: &str, unused_externs: &[&str]) {\n+        self.inner.borrow_mut().emit_unused_externs(lint_level, unused_externs)\n+    }\n+\n     pub fn delay_as_bug(&self, diagnostic: Diagnostic) {\n         self.inner.borrow_mut().delay_as_bug(diagnostic)\n     }\n@@ -842,6 +843,10 @@ impl HandlerInner {\n         self.emitter.emit_artifact_notification(path, artifact_type);\n     }\n \n+    fn emit_unused_externs(&mut self, lint_level: &str, unused_externs: &[&str]) {\n+        self.emitter.emit_unused_externs(lint_level, unused_externs);\n+    }\n+\n     fn treat_err_as_bug(&self) -> bool {\n         self.flags.treat_err_as_bug.map_or(false, |c| self.err_count() >= c.get())\n     }"}, {"sha": "da764d993bbdb2ad7996a963677f2e696d16f771", "filename": "compiler/rustc_errors/src/registry.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_errors%2Fsrc%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_errors%2Fsrc%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fregistry.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -13,10 +13,6 @@ impl Registry {\n         Registry { long_descriptions: long_descriptions.iter().copied().collect() }\n     }\n \n-    /// This will panic if an invalid error code is passed in\n-    pub fn find_description(&self, code: &str) -> Option<&'static str> {\n-        self.long_descriptions[code]\n-    }\n     /// Returns `InvalidErrorCode` if the code requested does not exist in the\n     /// registry. Otherwise, returns an `Option` where `None` means the error\n     /// code is valid but has no extended information."}, {"sha": "3fe02bd0ceecf22bba43524631b7a32fa617eeb2", "filename": "compiler/rustc_errors/src/snippet.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -121,16 +121,6 @@ impl Annotation {\n         matches!(self.annotation_type, AnnotationType::MultilineLine(_))\n     }\n \n-    pub fn is_multiline(&self) -> bool {\n-        matches!(\n-            self.annotation_type,\n-            AnnotationType::Multiline(_)\n-                | AnnotationType::MultilineStart(_)\n-                | AnnotationType::MultilineLine(_)\n-                | AnnotationType::MultilineEnd(_)\n-        )\n-    }\n-\n     pub fn len(&self) -> usize {\n         // Account for usize underflows\n         if self.end_col > self.start_col {"}, {"sha": "ec122e7be6e8efd52462a4ca5f5ec2685b9ec639", "filename": "compiler/rustc_errors/src/styled_buffer.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_errors%2Fsrc%2Fstyled_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_errors%2Fsrc%2Fstyled_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fstyled_buffer.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,6 +1,7 @@\n // Code for creating styled buffers\n \n use crate::snippet::{Style, StyledString};\n+use std::iter;\n \n #[derive(Debug)]\n pub struct StyledBuffer {\n@@ -20,11 +21,11 @@ impl StyledBuffer {\n         let mut output: Vec<Vec<StyledString>> = vec![];\n         let mut styled_vec: Vec<StyledString> = vec![];\n \n-        for (row, row_style) in self.text.iter().zip(&self.styles) {\n+        for (row, row_style) in iter::zip(&self.text, &self.styles) {\n             let mut current_style = Style::NoStyle;\n             let mut current_text = String::new();\n \n-            for (&c, &s) in row.iter().zip(row_style) {\n+            for (&c, &s) in iter::zip(row, row_style) {\n                 if s != current_style {\n                     if !current_text.is_empty() {\n                         styled_vec.push(StyledString { text: current_text, style: current_style });"}, {"sha": "a2035ee3c6ec9b93d9858f6a5087d765033afee6", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -868,6 +868,8 @@ impl SyntaxExtension {\n /// Error type that denotes indeterminacy.\n pub struct Indeterminate;\n \n+pub type DeriveResolutions = Vec<(ast::Path, Option<Lrc<SyntaxExtension>>)>;\n+\n pub trait ResolverExpand {\n     fn next_node_id(&mut self) -> NodeId;\n \n@@ -904,15 +906,12 @@ pub trait ResolverExpand {\n     fn resolve_derives(\n         &mut self,\n         expn_id: ExpnId,\n-        derives: Vec<ast::Path>,\n         force: bool,\n+        derive_paths: &dyn Fn() -> DeriveResolutions,\n     ) -> Result<(), Indeterminate>;\n     /// Take resolutions for paths inside the `#[derive(...)]` attribute with the given `ExpnId`\n     /// back from resolver.\n-    fn take_derive_resolutions(\n-        &mut self,\n-        expn_id: ExpnId,\n-    ) -> Option<Vec<(Lrc<SyntaxExtension>, ast::Path)>>;\n+    fn take_derive_resolutions(&mut self, expn_id: ExpnId) -> Option<DeriveResolutions>;\n     /// Path resolution logic for `#[cfg_accessible(path)]`.\n     fn cfg_accessible(&mut self, expn_id: ExpnId, path: &ast::Path) -> Result<bool, Indeterminate>;\n }"}, {"sha": "cb8b9398283ef963b2cc68acd2f76b27d17887bc", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -253,17 +253,6 @@ impl<'a> ExtCtxt<'a> {\n         let pathexpr = self.expr_path(self.path_global(sp, fn_path));\n         self.expr_call(sp, pathexpr, args)\n     }\n-    pub fn expr_method_call(\n-        &self,\n-        span: Span,\n-        expr: P<ast::Expr>,\n-        ident: Ident,\n-        mut args: Vec<P<ast::Expr>>,\n-    ) -> P<ast::Expr> {\n-        args.insert(0, expr);\n-        let segment = ast::PathSegment::from_ident(ident.with_span_pos(span));\n-        self.expr(span, ast::ExprKind::MethodCall(segment, args, span))\n-    }\n     pub fn expr_block(&self, b: P<ast::Block>) -> P<ast::Expr> {\n         self.expr(b.span, ast::ExprKind::Block(b, None))\n     }"}, {"sha": "b732e4493742b4f0dbbc6b8f4c3044570d43f2c4", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -206,30 +206,36 @@ ast_fragments! {\n     }\n }\n \n+pub enum SupportsMacroExpansion {\n+    No,\n+    Yes { supports_inner_attrs: bool },\n+}\n+\n impl AstFragmentKind {\n     crate fn dummy(self, span: Span) -> AstFragment {\n         self.make_from(DummyResult::any(span)).expect(\"couldn't create a dummy AST fragment\")\n     }\n \n-    /// Fragment supports macro expansion and not just inert attributes, `cfg` and `cfg_attr`.\n-    pub fn supports_macro_expansion(self) -> bool {\n+    pub fn supports_macro_expansion(self) -> SupportsMacroExpansion {\n         match self {\n             AstFragmentKind::OptExpr\n             | AstFragmentKind::Expr\n-            | AstFragmentKind::Pat\n-            | AstFragmentKind::Ty\n             | AstFragmentKind::Stmts\n-            | AstFragmentKind::Items\n+            | AstFragmentKind::Ty\n+            | AstFragmentKind::Pat => SupportsMacroExpansion::Yes { supports_inner_attrs: false },\n+            AstFragmentKind::Items\n             | AstFragmentKind::TraitItems\n             | AstFragmentKind::ImplItems\n-            | AstFragmentKind::ForeignItems => true,\n+            | AstFragmentKind::ForeignItems => {\n+                SupportsMacroExpansion::Yes { supports_inner_attrs: true }\n+            }\n             AstFragmentKind::Arms\n             | AstFragmentKind::Fields\n             | AstFragmentKind::FieldPats\n             | AstFragmentKind::GenericParams\n             | AstFragmentKind::Params\n             | AstFragmentKind::StructFields\n-            | AstFragmentKind::Variants => false,\n+            | AstFragmentKind::Variants => SupportsMacroExpansion::No,\n         }\n     }\n \n@@ -509,7 +515,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                             invocations.reserve(derives.len());\n                             derives\n                                 .into_iter()\n-                                .map(|(_exts, path)| {\n+                                .map(|(path, _exts)| {\n                                     // FIXME: Consider using the derive resolutions (`_exts`)\n                                     // instead of enqueuing the derives to be resolved again later.\n                                     let expn_id = ExpnId::fresh(None);\n@@ -729,7 +735,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                                     });\n                                 }\n                             };\n-                            fragment_kind.expect_from_annotatables(items)\n+                            if fragment_kind == AstFragmentKind::Expr && items.is_empty() {\n+                                let msg =\n+                                    \"removing an expression is not supported in this position\";\n+                                self.cx.span_err(span, msg);\n+                                fragment_kind.dummy(span)\n+                            } else {\n+                                fragment_kind.expect_from_annotatables(items)\n+                            }\n                         }\n                         Err(mut err) => {\n                             err.emit();"}, {"sha": "5fb85867501673b5e03c36c74e75f3e8a5c3c2c0", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -2,6 +2,7 @@\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(destructuring_assignment)]\n+#![feature(iter_zip)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(proc_macro_diagnostic)]\n #![feature(proc_macro_internals)]"}, {"sha": "3497e5ad543a1fcb6cb2b3f5d8df86086543f41d", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -116,6 +116,8 @@ use rustc_span::{symbol::MacroRulesNormalizedIdent, MultiSpan, Span};\n \n use smallvec::SmallVec;\n \n+use std::iter;\n+\n /// Stack represented as linked list.\n ///\n /// Those are used for environments because they grow incrementally and are not mutable.\n@@ -204,7 +206,7 @@ pub(super) fn check_meta_variables(\n         sess.span_diagnostic.span_bug(span, \"length mismatch between LHSes and RHSes\")\n     }\n     let mut valid = true;\n-    for (lhs, rhs) in lhses.iter().zip(rhses.iter()) {\n+    for (lhs, rhs) in iter::zip(lhses, rhses) {\n         let mut binders = Binders::default();\n         check_binders(sess, node_id, lhs, &Stack::Empty, &mut binders, &Stack::Empty, &mut valid);\n         check_occurrences(sess, node_id, rhs, &Stack::Empty, &binders, &Stack::Empty, &mut valid);"}, {"sha": "bc45c57596e151688af1b0418da3fa203baadf99", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -18,7 +18,8 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_feature::Features;\n-use rustc_lint_defs::builtin::SEMICOLON_IN_EXPRESSIONS_FROM_MACROS;\n+use rustc_lint_defs::builtin::{OR_PATTERNS_BACK_COMPAT, SEMICOLON_IN_EXPRESSIONS_FROM_MACROS};\n+use rustc_lint_defs::BuiltinLintDiagnostics;\n use rustc_parse::parser::Parser;\n use rustc_session::parse::ParseSess;\n use rustc_session::Session;\n@@ -951,8 +952,32 @@ fn check_matcher_core(\n         // Now `last` holds the complete set of NT tokens that could\n         // end the sequence before SUFFIX. Check that every one works with `suffix`.\n         for token in &last.tokens {\n-            if let TokenTree::MetaVarDecl(_, name, Some(kind)) = *token {\n+            if let TokenTree::MetaVarDecl(span, name, Some(kind)) = *token {\n                 for next_token in &suffix_first.tokens {\n+                    // Check if the old pat is used and the next token is `|`.\n+                    if let NonterminalKind::Pat2015 { inferred: true } = kind {\n+                        if let TokenTree::Token(token) = next_token {\n+                            if let BinOp(token) = token.kind {\n+                                if let token::BinOpToken::Or = token {\n+                                    // It is suggestion to use pat2015, for example: $x:pat -> $x:pat2015.\n+                                    let suggestion = quoted_tt_to_string(&TokenTree::MetaVarDecl(\n+                                        span,\n+                                        name,\n+                                        Some(NonterminalKind::Pat2015 { inferred: false }),\n+                                    ));\n+                                    sess.buffer_lint_with_diagnostic(\n+                                        &OR_PATTERNS_BACK_COMPAT,\n+                                        span,\n+                                        ast::CRATE_NODE_ID,\n+                                        &*format!(\"the meaning of the `pat` fragment specifier is changing in Rust 2021, which may affect this macro\",),\n+                                        BuiltinLintDiagnostics::OrPatternsBackCompat(\n+                                            span, suggestion,\n+                                        ),\n+                                    );\n+                                }\n+                            }\n+                        }\n+                    }\n                     match is_in_follow(next_token, kind) {\n                         IsInFollow::Yes => {}\n                         IsInFollow::No(possible) => {\n@@ -1080,7 +1105,7 @@ fn is_in_follow(tok: &mbe::TokenTree, kind: NonterminalKind) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            NonterminalKind::Pat2015 { .. } | NonterminalKind::Pat2021 { .. } => {\n+            NonterminalKind::Pat2015 { .. } => {\n                 const TOKENS: &[&str] = &[\"`=>`\", \"`,`\", \"`=`\", \"`|`\", \"`if`\", \"`in`\"];\n                 match tok {\n                     TokenTree::Token(token) => match token.kind {\n@@ -1091,6 +1116,17 @@ fn is_in_follow(tok: &mbe::TokenTree, kind: NonterminalKind) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n+            NonterminalKind::Pat2021 { .. } => {\n+                const TOKENS: &[&str] = &[\"`=>`\", \"`,`\", \"`=`\", \"`if`\", \"`in`\"];\n+                match tok {\n+                    TokenTree::Token(token) => match token.kind {\n+                        FatArrow | Comma | Eq => IsInFollow::Yes,\n+                        Ident(name, false) if name == kw::If || name == kw::In => IsInFollow::Yes,\n+                        _ => IsInFollow::No(TOKENS),\n+                    },\n+                    _ => IsInFollow::No(TOKENS),\n+                }\n+            }\n             NonterminalKind::Path | NonterminalKind::Ty => {\n                 const TOKENS: &[&str] = &[\n                     \"`{`\", \"`[`\", \"`=>`\", \"`,`\", \"`>`\", \"`=`\", \"`:`\", \"`;`\", \"`|`\", \"`as`\","}, {"sha": "8b546e7e4a343a1bb39fe177457bd85459ca8fd6", "filename": "compiler/rustc_expand/src/tokenstream/tests.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_expand%2Fsrc%2Ftokenstream%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_expand%2Fsrc%2Ftokenstream%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ftokenstream%2Ftests.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,7 +1,7 @@\n use crate::tests::string_to_stream;\n \n use rustc_ast::token;\n-use rustc_ast::tokenstream::{TokenStream, TokenStreamBuilder, TokenTree};\n+use rustc_ast::tokenstream::{Spacing, TokenStream, TokenStreamBuilder, TokenTree};\n use rustc_span::with_default_session_globals;\n use rustc_span::{BytePos, Span, Symbol};\n use smallvec::smallvec;\n@@ -14,6 +14,10 @@ fn sp(a: u32, b: u32) -> Span {\n     Span::with_root_ctxt(BytePos(a), BytePos(b))\n }\n \n+fn joint(tree: TokenTree) -> TokenStream {\n+    TokenStream::new(vec![(tree, Spacing::Joint)])\n+}\n+\n #[test]\n fn test_concat() {\n     with_default_session_globals(|| {\n@@ -99,8 +103,8 @@ fn test_is_empty() {\n fn test_dotdotdot() {\n     with_default_session_globals(|| {\n         let mut builder = TokenStreamBuilder::new();\n-        builder.push(TokenTree::token(token::Dot, sp(0, 1)).joint());\n-        builder.push(TokenTree::token(token::Dot, sp(1, 2)).joint());\n+        builder.push(joint(TokenTree::token(token::Dot, sp(0, 1))));\n+        builder.push(joint(TokenTree::token(token::Dot, sp(1, 2))));\n         builder.push(TokenTree::token(token::Dot, sp(2, 3)));\n         let stream = builder.build();\n         assert!(stream.eq_unspanned(&string_to_ts(\"...\")));"}, {"sha": "f006351647e40972b2f0273d5b28695b5aa92cc8", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -276,7 +276,7 @@ declare_features! (\n     /// The smallest useful subset of `const_generics`.\n     (accepted, min_const_generics, \"1.51.0\", Some(74878), None),\n     /// The `unsafe_op_in_unsafe_fn` lint (allowed by default): no longer treat an unsafe function as an unsafe block.\n-    (accepted, unsafe_block_in_unsafe_fn, \"1.51.0\", Some(71668), None),\n+    (accepted, unsafe_block_in_unsafe_fn, \"1.52.0\", Some(71668), None),\n     /// Allows the use of or-patterns (e.g., `0 | 1`).\n     (accepted, or_patterns, \"1.53.0\", Some(54883), None),\n "}, {"sha": "93de4891ec7d2d1e4f53e0f32358892204f0fdd3", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -216,6 +216,10 @@ declare_features! (\n     /// Renamed from `optin_builtin_traits`.\n     (active, auto_traits, \"1.50.0\", Some(13231), None),\n \n+    /// Allows `#[doc(notable_trait)]`.\n+    /// Renamed from `doc_spotlight`.\n+    (active, doc_notable_trait, \"1.52.0\", Some(45040), None),\n+\n     // no-tracking-issue-end\n \n     // -------------------------------------------------------------------------\n@@ -254,9 +258,6 @@ declare_features! (\n     // feature-group-start: actual feature gates\n     // -------------------------------------------------------------------------\n \n-    /// Allows using the `#[link_args]` attribute.\n-    (active, link_args, \"1.0.0\", Some(29596), None),\n-\n     /// Allows defining identifiers beyond ASCII.\n     (active, non_ascii_idents, \"1.0.0\", Some(55467), None),\n \n@@ -374,9 +375,6 @@ declare_features! (\n     /// Allows `#[doc(masked)]`.\n     (active, doc_masked, \"1.21.0\", Some(44027), None),\n \n-    /// Allows `#[doc(spotlight)]`.\n-    (active, doc_spotlight, \"1.22.0\", Some(45040), None),\n-\n     /// Allows `#[doc(include = \"some-file\")]`.\n     (active, external_doc, \"1.22.0\", Some(44732), None),\n \n@@ -644,6 +642,9 @@ declare_features! (\n     /// Allows `extern \"C-unwind\" fn` to enable unwinding across ABI boundaries.\n     (active, c_unwind, \"1.52.0\", Some(74990), None),\n \n+    /// Allows using `#[repr(align(...))]` on function items\n+    (active, fn_align, \"1.53.0\", Some(82232), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "7df9b3f0a796059025305ad316c331599f5b7e12", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -279,11 +279,6 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n \n     // Linking:\n     gated!(naked, AssumedUsed, template!(Word), naked_functions, experimental!(naked)),\n-    gated!(\n-        link_args, Normal, template!(NameValueStr: \"args\"),\n-        \"the `link_args` attribute is experimental and not portable across platforms, \\\n-        it is recommended to use `#[link(name = \\\"foo\\\")] instead\",\n-    ),\n     gated!(\n         link_ordinal, AssumedUsed, template!(List: \"ordinal\"), raw_dylib,\n         experimental!(link_ordinal)"}, {"sha": "e1491576616627d13dc538b5442d163c3be065ea", "filename": "compiler/rustc_feature/src/removed.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -80,6 +80,11 @@ declare_features! (\n      Some(\"subsumed by `#![feature(allocator_internals)]`\")),\n     /// Allows identifying crates that contain sanitizer runtimes.\n     (removed, sanitizer_runtime, \"1.17.0\", None, None, None),\n+    /// Allows `#[doc(spotlight)]`.\n+    /// The attribute was renamed to `#[doc(notable_trait)]`\n+    /// and the feature to `doc_notable_trait`.\n+    (removed, doc_spotlight, \"1.22.0\", Some(45040), None,\n+     Some(\"renamed to `doc_notable_trait`\")),\n     (removed, proc_macro_mod, \"1.27.0\", Some(54727), None,\n      Some(\"subsumed by `#![feature(proc_macro_hygiene)]`\")),\n     (removed, proc_macro_expr, \"1.27.0\", Some(54727), None,\n@@ -123,6 +128,10 @@ declare_features! (\n     /// Allows comparing raw pointers during const eval.\n     (removed, const_compare_raw_pointers, \"1.46.0\", Some(53020), None,\n      Some(\"cannot be allowed in const eval in any meaningful way\")),\n+    /// Allows using the `#[link_args]` attribute.\n+    (removed, link_args, \"1.53.0\", Some(29596), None,\n+     Some(\"removed in favor of using `-C link-arg=ARG` on command line, \\\n+           which is available from cargo build scripts with `cargo:rustc-link-arg` now\")),\n \n     // -------------------------------------------------------------------------\n     // feature-group-end: removed features"}, {"sha": "db70beb59141b52682b0bbe9b3caa154472768bb", "filename": "compiler/rustc_graphviz/src/lib.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -413,10 +413,6 @@ impl<'a> Id<'a> {\n     pub fn as_slice(&'a self) -> &'a str {\n         &*self.name\n     }\n-\n-    pub fn name(self) -> Cow<'a, str> {\n-        self.name\n-    }\n }\n \n /// Each instance of a type that implements `Label<C>` maps to a\n@@ -484,10 +480,6 @@ impl<'a> LabelText<'a> {\n         LabelStr(s.into())\n     }\n \n-    pub fn escaped<S: Into<Cow<'a, str>>>(s: S) -> LabelText<'a> {\n-        EscStr(s.into())\n-    }\n-\n     pub fn html<S: Into<Cow<'a, str>>>(s: S) -> LabelText<'a> {\n         HtmlStr(s.into())\n     }\n@@ -543,11 +535,6 @@ impl<'a> LabelText<'a> {\n         }\n     }\n \n-    /// Puts `prefix` on a line above this label, with a blank line separator.\n-    pub fn prefix_line(self, prefix: LabelText<'_>) -> LabelText<'static> {\n-        prefix.suffix_line(self)\n-    }\n-\n     /// Puts `suffix` on a line below this label, with a blank line separator.\n     pub fn suffix_line(self, suffix: LabelText<'_>) -> LabelText<'static> {\n         let mut prefix = self.pre_escaped_content().into_owned();\n@@ -602,11 +589,6 @@ pub enum RenderOption {\n     DarkTheme,\n }\n \n-/// Returns vec holding all the default render options.\n-pub fn default_options() -> Vec<RenderOption> {\n-    vec![]\n-}\n-\n /// Renders directed graph `g` into the writer `w` in DOT syntax.\n /// (Simple wrapper around `render_opts` that passes a default set of options.)\n pub fn render<'a, N, E, G, W>(g: &'a G, w: &mut W) -> io::Result<()>"}, {"sha": "a297bac86c410406c116d5679130ff033a3df6b1", "filename": "compiler/rustc_graphviz/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_graphviz%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_graphviz%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_graphviz%2Fsrc%2Ftests.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -111,7 +111,7 @@ impl<'a> Labeller<'a> for LabelledGraph {\n     fn node_label(&'a self, n: &Node) -> LabelText<'a> {\n         match self.node_labels[*n] {\n             Some(l) => LabelStr(l.into()),\n-            None => LabelStr(id_name(n).name()),\n+            None => LabelStr(id_name(n).name),\n         }\n     }\n     fn edge_label(&'a self, e: &&'a Edge) -> LabelText<'a> {"}, {"sha": "0f77de9fb250fed5d7764b0404e8ce07f9d9d68f", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -87,6 +87,7 @@ impl DefPathTable {\n         hash\n     }\n \n+    /// Used by librustdoc for fake DefIds.\n     pub fn num_def_ids(&self) -> usize {\n         self.index_to_key.len()\n     }\n@@ -319,12 +320,6 @@ impl Definitions {\n         self.table.def_path_hash(id.local_def_index)\n     }\n \n-    #[inline]\n-    pub fn def_path_hash_to_def_id(&self, def_path_hash: DefPathHash) -> LocalDefId {\n-        let local_def_index = self.table.def_path_hash_to_index[&def_path_hash];\n-        LocalDefId { local_def_index }\n-    }\n-\n     /// Returns the path from the crate root to `index`. The root\n     /// nodes are not included in the path (i.e., this will be an\n     /// empty vector for the crate root). For an inlined item, this"}, {"sha": "6317808e7fbe0b87e6b6ed288322c17b7d3f008f", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,5 +1,5 @@\n // ignore-tidy-filelength\n-use crate::def::{CtorKind, DefKind, Namespace, Res};\n+use crate::def::{CtorKind, DefKind, Res};\n use crate::def_id::DefId;\n crate use crate::hir_id::HirId;\n use crate::{itemlikevisit, LangItem};\n@@ -402,7 +402,7 @@ pub enum TraitBoundModifier {\n /// `typeck::collect::compute_bounds` matches these against\n /// the \"special\" built-in traits (see `middle::lang_items`) and\n /// detects `Copy`, `Send` and `Sync`.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Clone, Debug, HashStable_Generic)]\n pub enum GenericBound<'hir> {\n     Trait(PolyTraitRef<'hir>, TraitBoundModifier),\n     // FIXME(davidtwco): Introduce `PolyTraitRef::LangItem`\n@@ -625,13 +625,6 @@ pub struct ModuleItems {\n     pub foreign_items: BTreeSet<ForeignItemId>,\n }\n \n-/// A type representing only the top-level module.\n-#[derive(Encodable, Debug, HashStable_Generic)]\n-pub struct CrateItem<'hir> {\n-    pub module: Mod<'hir>,\n-    pub span: Span,\n-}\n-\n /// The top-level data structure that stores the entire contents of\n /// the crate currently being compiled.\n ///\n@@ -640,7 +633,7 @@ pub struct CrateItem<'hir> {\n /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/hir.html\n #[derive(Debug)]\n pub struct Crate<'hir> {\n-    pub item: CrateItem<'hir>,\n+    pub item: Mod<'hir>,\n     pub exported_macros: &'hir [MacroDef<'hir>],\n     // Attributes from non-exported macros, kept only for collecting the library feature list.\n     pub non_exported_macro_attrs: &'hir [Attribute],\n@@ -2118,15 +2111,6 @@ pub enum ImplItemKind<'hir> {\n     TyAlias(&'hir Ty<'hir>),\n }\n \n-impl ImplItemKind<'_> {\n-    pub fn namespace(&self) -> Namespace {\n-        match self {\n-            ImplItemKind::TyAlias(..) => Namespace::TypeNS,\n-            ImplItemKind::Const(..) | ImplItemKind::Fn(..) => Namespace::ValueNS,\n-        }\n-    }\n-}\n-\n // The name of the associated type for `Fn` return types.\n pub const FN_OUTPUT_NAME: Symbol = sym::Output;\n \n@@ -2215,6 +2199,9 @@ impl PrimTy {\n         Self::Str,\n     ];\n \n+    /// Like [`PrimTy::name`], but returns a &str instead of a symbol.\n+    ///\n+    /// Used by rustdoc.\n     pub fn name_str(self) -> &'static str {\n         match self {\n             PrimTy::Int(i) => i.name_str(),\n@@ -2569,7 +2556,7 @@ pub enum UseKind {\n /// that the `ref_id` is for. Note that `ref_id`'s value is not the `HirId` of the\n /// trait being referred to but just a unique `HirId` that serves as a key\n /// within the resolution map.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Clone, Debug, HashStable_Generic)]\n pub struct TraitRef<'hir> {\n     pub path: &'hir Path<'hir>,\n     // Don't hash the `ref_id`. It is tracked via the thing it is used to access.\n@@ -2588,7 +2575,7 @@ impl TraitRef<'_> {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Clone, Debug, HashStable_Generic)]\n pub struct PolyTraitRef<'hir> {\n     /// The `'a` in `for<'a> Foo<&'a T>`.\n     pub bound_generic_params: &'hir [GenericParam<'hir>],\n@@ -2989,7 +2976,7 @@ pub enum Node<'hir> {\n     GenericParam(&'hir GenericParam<'hir>),\n     Visibility(&'hir Visibility<'hir>),\n \n-    Crate(&'hir CrateItem<'hir>),\n+    Crate(&'hir Mod<'hir>),\n }\n \n impl<'hir> Node<'hir> {"}, {"sha": "0b25ebc27bd3f9d671432daa8da9548b0a5633ae", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -63,6 +63,7 @@ pub const CRATE_HIR_ID: HirId = HirId {\n     local_id: ItemLocalId::from_u32(0),\n };\n \n+/// N.B. This collection is currently unused, but will be used by #72015 and future PRs.\n #[derive(Clone, Default, Debug, Encodable, Decodable)]\n pub struct HirIdVec<T> {\n     map: IndexVec<LocalDefId, IndexVec<ItemLocalId, T>>,"}, {"sha": "d766a68e1945595cb1057ad7dc6cb329a033e090", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -478,7 +478,7 @@ pub trait Visitor<'v>: Sized {\n \n /// Walks the contents of a crate. See also `Crate::visit_all_items`.\n pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate<'v>) {\n-    visitor.visit_mod(&krate.item.module, krate.item.span, CRATE_HIR_ID);\n+    visitor.visit_mod(&krate.item, krate.item.inner, CRATE_HIR_ID);\n     walk_list!(visitor, visit_macro_def, krate.exported_macros);\n     for (&id, attrs) in krate.attrs.iter() {\n         for a in *attrs {"}, {"sha": "b1f78a83e7407a01451ee175414f5fcafacc78e2", "filename": "compiler/rustc_hir/src/pat_util.rs", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,6 +1,7 @@\n use crate::def::{CtorOf, DefKind, Res};\n use crate::def_id::DefId;\n use crate::hir::{self, HirId, PatKind};\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n@@ -89,26 +90,6 @@ impl hir::Pat<'_> {\n         })\n     }\n \n-    /// Checks if the pattern contains any patterns that bind something to\n-    /// an ident, e.g., `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n-    pub fn contains_bindings(&self) -> bool {\n-        self.satisfies(|p| matches!(p.kind, PatKind::Binding(..)))\n-    }\n-\n-    /// Checks if the pattern satisfies the given predicate on some sub-pattern.\n-    fn satisfies(&self, pred: impl Fn(&hir::Pat<'_>) -> bool) -> bool {\n-        let mut satisfies = false;\n-        self.walk_short(|p| {\n-            if pred(p) {\n-                satisfies = true;\n-                false // Found one, can short circuit now.\n-            } else {\n-                true\n-            }\n-        });\n-        satisfies\n-    }\n-\n     pub fn simple_ident(&self) -> Option<Ident> {\n         match self.kind {\n             PatKind::Binding(\n@@ -138,8 +119,10 @@ impl hir::Pat<'_> {\n             }\n             _ => true,\n         });\n-        variants.sort();\n-        variants.dedup();\n+        // We remove duplicates by inserting into a `FxHashSet` to avoid re-ordering\n+        // the bounds\n+        let mut duplicates = FxHashSet::default();\n+        variants.retain(|def_id| duplicates.insert(*def_id));\n         variants\n     }\n "}, {"sha": "2d499e194e199e99beb084d2df81049b7deb0d33", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -170,7 +170,7 @@ pub fn print_crate<'a>(\n     // When printing the AST, we sometimes need to inject `#[no_std]` here.\n     // Since you can't compile the HIR, it's not necessary.\n \n-    s.print_mod(&krate.item.module, s.attrs(hir::CRATE_HIR_ID));\n+    s.print_mod(&krate.item, s.attrs(hir::CRATE_HIR_ID));\n     s.print_remaining_comments();\n     s.s.eof()\n }\n@@ -221,10 +221,6 @@ pub fn bounds_to_string<'b>(bounds: impl IntoIterator<Item = &'b hir::GenericBou\n     to_string(NO_ANN, |s| s.print_bounds(\"\", bounds))\n }\n \n-pub fn param_to_string(arg: &hir::Param<'_>) -> String {\n-    to_string(NO_ANN, |s| s.print_param(arg))\n-}\n-\n pub fn ty_to_string(ty: &hir::Ty<'_>) -> String {\n     to_string(NO_ANN, |s| s.print_type(ty))\n }\n@@ -1701,21 +1697,10 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_usize(&mut self, i: usize) {\n-        self.s.word(i.to_string())\n-    }\n-\n     pub fn print_name(&mut self, name: Symbol) {\n         self.print_ident(Ident::with_dummy_span(name))\n     }\n \n-    pub fn print_for_decl(&mut self, loc: &hir::Local<'_>, coll: &hir::Expr<'_>) {\n-        self.print_local_decl(loc);\n-        self.s.space();\n-        self.word_space(\"in\");\n-        self.print_expr(coll)\n-    }\n-\n     pub fn print_path(&mut self, path: &hir::Path<'_>, colons_before_params: bool) {\n         self.maybe_print_comment(path.span.lo());\n \n@@ -2430,24 +2415,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_opt_abi_and_extern_if_nondefault(&mut self, opt_abi: Option<Abi>) {\n-        match opt_abi {\n-            Some(Abi::Rust) => {}\n-            Some(abi) => {\n-                self.word_nbsp(\"extern\");\n-                self.word_nbsp(abi.to_string())\n-            }\n-            None => {}\n-        }\n-    }\n-\n-    pub fn print_extern_opt_abi(&mut self, opt_abi: Option<Abi>) {\n-        if let Some(abi) = opt_abi {\n-            self.word_nbsp(\"extern\");\n-            self.word_nbsp(abi.to_string())\n-        }\n-    }\n-\n     pub fn print_fn_header_info(&mut self, header: hir::FnHeader, vis: &hir::Visibility<'_>) {\n         self.s.word(visibility_qualified(vis, \"\"));\n "}, {"sha": "b5680beae142d503f6afef41bc540a6b0926e4f4", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -40,8 +40,9 @@ use rustc_graphviz as dot;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc_middle::dep_graph::debug::{DepNodeFilter, EdgeFilter};\n-use rustc_middle::dep_graph::{DepGraphQuery, DepKind, DepNode, DepNodeExt};\n+use rustc_middle::dep_graph::{\n+    DepGraphQuery, DepKind, DepNode, DepNodeExt, DepNodeFilter, EdgeFilter,\n+};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::{sym, Symbol};\n@@ -54,7 +55,7 @@ use std::io::{BufWriter, Write};\n pub fn assert_dep_graph(tcx: TyCtxt<'_>) {\n     tcx.dep_graph.with_ignore(|| {\n         if tcx.sess.opts.debugging_opts.dump_dep_graph {\n-            dump_graph(tcx);\n+            tcx.dep_graph.with_query(dump_graph);\n         }\n \n         if !tcx.sess.opts.debugging_opts.query_dep_graph {\n@@ -200,29 +201,29 @@ fn check_paths<'tcx>(tcx: TyCtxt<'tcx>, if_this_changed: &Sources, then_this_wou\n         }\n         return;\n     }\n-    let query = tcx.dep_graph.query();\n-    for &(_, source_def_id, ref source_dep_node) in if_this_changed {\n-        let dependents = query.transitive_predecessors(source_dep_node);\n-        for &(target_span, ref target_pass, _, ref target_dep_node) in then_this_would_need {\n-            if !dependents.contains(&target_dep_node) {\n-                tcx.sess.span_err(\n-                    target_span,\n-                    &format!(\n-                        \"no path from `{}` to `{}`\",\n-                        tcx.def_path_str(source_def_id),\n-                        target_pass\n-                    ),\n-                );\n-            } else {\n-                tcx.sess.span_err(target_span, \"OK\");\n+    tcx.dep_graph.with_query(|query| {\n+        for &(_, source_def_id, ref source_dep_node) in if_this_changed {\n+            let dependents = query.transitive_predecessors(source_dep_node);\n+            for &(target_span, ref target_pass, _, ref target_dep_node) in then_this_would_need {\n+                if !dependents.contains(&target_dep_node) {\n+                    tcx.sess.span_err(\n+                        target_span,\n+                        &format!(\n+                            \"no path from `{}` to `{}`\",\n+                            tcx.def_path_str(source_def_id),\n+                            target_pass\n+                        ),\n+                    );\n+                } else {\n+                    tcx.sess.span_err(target_span, \"OK\");\n+                }\n             }\n         }\n-    }\n+    });\n }\n \n-fn dump_graph(tcx: TyCtxt<'_>) {\n+fn dump_graph(query: &DepGraphQuery) {\n     let path: String = env::var(\"RUST_DEP_GRAPH\").unwrap_or_else(|_| \"dep_graph\".to_string());\n-    let query = tcx.dep_graph.query();\n \n     let nodes = match env::var(\"RUST_DEP_GRAPH_FILTER\") {\n         Ok(string) => {"}, {"sha": "f089cbcfca6e5f150a2bdc40776eb3ab0d1bbc6f", "filename": "compiler/rustc_incremental/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -14,7 +14,7 @@ mod assert_dep_graph;\n pub mod assert_module_sources;\n mod persist;\n \n-pub use assert_dep_graph::assert_dep_graph;\n+use assert_dep_graph::assert_dep_graph;\n pub use persist::copy_cgu_workproduct_to_incr_comp_cache_dir;\n pub use persist::delete_workproduct_files;\n pub use persist::finalize_session_directory;\n@@ -26,4 +26,4 @@ pub use persist::prepare_session_directory;\n pub use persist::save_dep_graph;\n pub use persist::save_work_product_index;\n pub use persist::LoadResult;\n-pub use persist::{load_dep_graph, DepGraphFuture};\n+pub use persist::{build_dep_graph, load_dep_graph, DepGraphFuture};"}, {"sha": "e7bd488af8ebf69cbd654ce5c4a0baa78b488099", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 2, "deletions": 38, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -14,7 +14,6 @@\n //! the required condition is not met.\n \n use rustc_ast::{self as ast, Attribute, NestedMetaItem};\n-use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -74,16 +73,6 @@ const BASE_STRUCT: &[&str] =\n     &[label_strs::generics_of, label_strs::predicates_of, label_strs::type_of];\n \n /// Trait definition `DepNode`s.\n-const BASE_TRAIT_DEF: &[&str] = &[\n-    label_strs::associated_item_def_ids,\n-    label_strs::generics_of,\n-    label_strs::object_safety_violations,\n-    label_strs::predicates_of,\n-    label_strs::specialization_graph_of,\n-    label_strs::trait_def,\n-    label_strs::trait_impls_of,\n-];\n-\n /// Extra `DepNode`s for functions and methods.\n const EXTRA_ASSOCIATED: &[&str] = &[label_strs::associated_item];\n \n@@ -118,10 +107,6 @@ const LABELS_IMPL: &[&[&str]] = &[BASE_HIR, BASE_IMPL];\n /// Abstract data type (struct, enum, union) `DepNode`s.\n const LABELS_ADT: &[&[&str]] = &[BASE_HIR, BASE_STRUCT];\n \n-/// Trait definition `DepNode`s.\n-#[allow(dead_code)]\n-const LABELS_TRAIT: &[&[&str]] = &[BASE_HIR, BASE_TRAIT_DEF];\n-\n // FIXME: Struct/Enum/Unions Fields (there is currently no way to attach these)\n //\n // Fields are kind of separate from their containers, as they can change independently from\n@@ -395,39 +380,18 @@ impl DirtyCleanVisitor<'tcx> {\n     fn assert_dirty(&self, item_span: Span, dep_node: DepNode) {\n         debug!(\"assert_dirty({:?})\", dep_node);\n \n-        let current_fingerprint = self.get_fingerprint(&dep_node);\n-        let prev_fingerprint = self.tcx.dep_graph.prev_fingerprint_of(&dep_node);\n-\n-        if current_fingerprint == prev_fingerprint {\n+        if self.tcx.dep_graph.is_green(&dep_node) {\n             let dep_node_str = self.dep_node_str(&dep_node);\n             self.tcx\n                 .sess\n                 .span_err(item_span, &format!(\"`{}` should be dirty but is not\", dep_node_str));\n         }\n     }\n \n-    fn get_fingerprint(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n-        if self.tcx.dep_graph.dep_node_exists(dep_node) {\n-            let dep_node_index = self.tcx.dep_graph.dep_node_index_of(dep_node);\n-            Some(self.tcx.dep_graph.fingerprint_of(dep_node_index))\n-        } else {\n-            None\n-        }\n-    }\n-\n     fn assert_clean(&self, item_span: Span, dep_node: DepNode) {\n         debug!(\"assert_clean({:?})\", dep_node);\n \n-        let current_fingerprint = self.get_fingerprint(&dep_node);\n-        let prev_fingerprint = self.tcx.dep_graph.prev_fingerprint_of(&dep_node);\n-\n-        // if the node wasn't previously evaluated and now is (or vice versa),\n-        // then the node isn't actually clean or dirty.\n-        if (current_fingerprint == None) ^ (prev_fingerprint == None) {\n-            return;\n-        }\n-\n-        if current_fingerprint != prev_fingerprint {\n+        if self.tcx.dep_graph.is_red(&dep_node) {\n             let dep_node_str = self.dep_node_str(&dep_node);\n             self.tcx\n                 .sess"}, {"sha": "30c6c408bc7c00f033a830945c6abf7f360e4e58", "filename": "compiler/rustc_incremental/src/persist/fs.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -122,6 +122,7 @@ mod tests;\n \n const LOCK_FILE_EXT: &str = \".lock\";\n const DEP_GRAPH_FILENAME: &str = \"dep-graph.bin\";\n+const STAGING_DEP_GRAPH_FILENAME: &str = \"dep-graph.part.bin\";\n const WORK_PRODUCTS_FILENAME: &str = \"work-products.bin\";\n const QUERY_CACHE_FILENAME: &str = \"query-cache.bin\";\n \n@@ -134,6 +135,9 @@ const INT_ENCODE_BASE: usize = base_n::CASE_INSENSITIVE;\n pub fn dep_graph_path(sess: &Session) -> PathBuf {\n     in_incr_comp_dir_sess(sess, DEP_GRAPH_FILENAME)\n }\n+pub fn staging_dep_graph_path(sess: &Session) -> PathBuf {\n+    in_incr_comp_dir_sess(sess, STAGING_DEP_GRAPH_FILENAME)\n+}\n pub fn dep_graph_path_from(incr_comp_session_dir: &Path) -> PathBuf {\n     in_incr_comp_dir(incr_comp_session_dir, DEP_GRAPH_FILENAME)\n }"}, {"sha": "259e540c6125e15b0bb3c2346b1383d2b4683d34", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -5,7 +5,7 @@ use rustc_hir::definitions::Definitions;\n use rustc_middle::dep_graph::{PreviousDepGraph, SerializedDepGraph, WorkProduct, WorkProductId};\n use rustc_middle::ty::query::OnDiskCache;\n use rustc_serialize::opaque::Decoder;\n-use rustc_serialize::Decodable as RustcDecodable;\n+use rustc_serialize::Decodable;\n use rustc_session::Session;\n use std::path::Path;\n \n@@ -120,7 +120,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n             // Decode the list of work_products\n             let mut work_product_decoder = Decoder::new(&work_products_data[..], start_pos);\n             let work_products: Vec<SerializedWorkProduct> =\n-                RustcDecodable::decode(&mut work_product_decoder).unwrap_or_else(|e| {\n+                Decodable::decode(&mut work_product_decoder).unwrap_or_else(|e| {\n                     let msg = format!(\n                         \"Error decoding `work-products` from incremental \\\n                                     compilation session directory: {}\","}, {"sha": "1336189bc0d26118586dcf1f891d2798c95f2005", "filename": "compiler/rustc_incremental/src/persist/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -18,6 +18,7 @@ pub use fs::prepare_session_directory;\n pub use load::load_query_result_cache;\n pub use load::LoadResult;\n pub use load::{load_dep_graph, DepGraphFuture};\n+pub use save::build_dep_graph;\n pub use save::save_dep_graph;\n pub use save::save_work_product_index;\n pub use work_product::copy_cgu_workproduct_to_incr_comp_cache_dir;"}, {"sha": "d558af3c1d558cffffeb7451b0dcee9f483b063f", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 82, "deletions": 23, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,6 +1,6 @@\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::join;\n-use rustc_middle::dep_graph::{DepGraph, WorkProduct, WorkProductId};\n+use rustc_middle::dep_graph::{DepGraph, PreviousDepGraph, WorkProduct, WorkProductId};\n use rustc_middle::ty::TyCtxt;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_serialize::Encodable as RustcEncodable;\n@@ -15,6 +15,9 @@ use super::file_format;\n use super::fs::*;\n use super::work_product;\n \n+/// Save and dump the DepGraph.\n+///\n+/// No query must be invoked after this function.\n pub fn save_dep_graph(tcx: TyCtxt<'_>) {\n     debug!(\"save_dep_graph()\");\n     tcx.dep_graph.with_ignore(|| {\n@@ -29,23 +32,41 @@ pub fn save_dep_graph(tcx: TyCtxt<'_>) {\n \n         let query_cache_path = query_cache_path(sess);\n         let dep_graph_path = dep_graph_path(sess);\n+        let staging_dep_graph_path = staging_dep_graph_path(sess);\n+\n+        sess.time(\"assert_dep_graph\", || crate::assert_dep_graph(tcx));\n+        sess.time(\"check_dirty_clean\", || dirty_clean::check_dirty_clean_annotations(tcx));\n+\n+        if sess.opts.debugging_opts.incremental_info {\n+            tcx.dep_graph.print_incremental_info()\n+        }\n \n         join(\n             move || {\n                 sess.time(\"incr_comp_persist_result_cache\", || {\n                     save_in(sess, query_cache_path, \"query cache\", |e| encode_query_cache(tcx, e));\n                 });\n             },\n-            || {\n+            move || {\n                 sess.time(\"incr_comp_persist_dep_graph\", || {\n-                    save_in(sess, dep_graph_path, \"dependency graph\", |e| {\n-                        sess.time(\"incr_comp_encode_dep_graph\", || encode_dep_graph(tcx, e))\n-                    });\n+                    if let Err(err) = tcx.dep_graph.encode(&tcx.sess.prof) {\n+                        sess.err(&format!(\n+                            \"failed to write dependency graph to `{}`: {}\",\n+                            staging_dep_graph_path.display(),\n+                            err\n+                        ));\n+                    }\n+                    if let Err(err) = fs::rename(&staging_dep_graph_path, &dep_graph_path) {\n+                        sess.err(&format!(\n+                            \"failed to move dependency graph from `{}` to `{}`: {}\",\n+                            staging_dep_graph_path.display(),\n+                            dep_graph_path.display(),\n+                            err\n+                        ));\n+                    }\n                 });\n             },\n         );\n-\n-        dirty_clean::check_dirty_clean_annotations(tcx);\n     })\n }\n \n@@ -92,7 +113,7 @@ pub fn save_work_product_index(\n     });\n }\n \n-fn save_in<F>(sess: &Session, path_buf: PathBuf, name: &str, encode: F)\n+pub(crate) fn save_in<F>(sess: &Session, path_buf: PathBuf, name: &str, encode: F)\n where\n     F: FnOnce(&mut FileEncoder) -> FileEncodeResult,\n {\n@@ -144,21 +165,6 @@ where\n     debug!(\"save: data written to disk successfully\");\n }\n \n-fn encode_dep_graph(tcx: TyCtxt<'_>, encoder: &mut FileEncoder) -> FileEncodeResult {\n-    // First encode the commandline arguments hash\n-    tcx.sess.opts.dep_tracking_hash().encode(encoder)?;\n-\n-    if tcx.sess.opts.debugging_opts.incremental_info {\n-        tcx.dep_graph.print_incremental_info();\n-    }\n-\n-    // There is a tiny window between printing the incremental info above and encoding the dep\n-    // graph below in which the dep graph could change, thus making the printed incremental info\n-    // slightly out of date. If this matters to you, please feel free to submit a patch. :)\n-\n-    tcx.sess.time(\"incr_comp_encode_serialized_dep_graph\", || tcx.dep_graph.encode(encoder))\n-}\n-\n fn encode_work_product_index(\n     work_products: &FxHashMap<WorkProductId, WorkProduct>,\n     encoder: &mut FileEncoder,\n@@ -177,3 +183,56 @@ fn encode_work_product_index(\n fn encode_query_cache(tcx: TyCtxt<'_>, encoder: &mut FileEncoder) -> FileEncodeResult {\n     tcx.sess.time(\"incr_comp_serialize_result_cache\", || tcx.serialize_query_result_cache(encoder))\n }\n+\n+pub fn build_dep_graph(\n+    sess: &Session,\n+    prev_graph: PreviousDepGraph,\n+    prev_work_products: FxHashMap<WorkProductId, WorkProduct>,\n+) -> Option<DepGraph> {\n+    if sess.opts.incremental.is_none() {\n+        // No incremental compilation.\n+        return None;\n+    }\n+\n+    // Stream the dep-graph to an alternate file, to avoid overwriting anything in case of errors.\n+    let path_buf = staging_dep_graph_path(sess);\n+\n+    let mut encoder = match FileEncoder::new(&path_buf) {\n+        Ok(encoder) => encoder,\n+        Err(err) => {\n+            sess.err(&format!(\n+                \"failed to create dependency graph at `{}`: {}\",\n+                path_buf.display(),\n+                err\n+            ));\n+            return None;\n+        }\n+    };\n+\n+    if let Err(err) = file_format::write_file_header(&mut encoder, sess.is_nightly_build()) {\n+        sess.err(&format!(\n+            \"failed to write dependency graph header to `{}`: {}\",\n+            path_buf.display(),\n+            err\n+        ));\n+        return None;\n+    }\n+\n+    // First encode the commandline arguments hash\n+    if let Err(err) = sess.opts.dep_tracking_hash().encode(&mut encoder) {\n+        sess.err(&format!(\n+            \"failed to write dependency graph hash `{}`: {}\",\n+            path_buf.display(),\n+            err\n+        ));\n+        return None;\n+    }\n+\n+    Some(DepGraph::new(\n+        prev_graph,\n+        prev_work_products,\n+        encoder,\n+        sess.opts.debugging_opts.query_dep_graph,\n+        sess.opts.debugging_opts.incremental_info,\n+    ))\n+}"}, {"sha": "cfea5092bc30655f7cac2acf11e1bb7e99a9e9a1", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -356,7 +356,7 @@ where\n {\n     assert_eq!(out_vec.len(), in_vec.len());\n     let mut changed = false;\n-    for (out_elem, in_elem) in out_vec.iter_mut().zip(in_vec.iter()) {\n+    for (out_elem, in_elem) in iter::zip(out_vec, in_vec) {\n         let old_val = *out_elem;\n         let new_val = op(old_val, *in_elem);\n         *out_elem = new_val;\n@@ -842,7 +842,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n         let (write_start, write_end) = self.range(write);\n         let words = &mut self.words[..];\n         let mut changed = false;\n-        for (read_index, write_index) in (read_start..read_end).zip(write_start..write_end) {\n+        for (read_index, write_index) in iter::zip(read_start..read_end, write_start..write_end) {\n             let word = words[write_index];\n             let new_word = word | words[read_index];\n             words[write_index] = new_word;\n@@ -858,7 +858,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n         assert_eq!(with.domain_size(), self.num_columns);\n         let (write_start, write_end) = self.range(write);\n         let mut changed = false;\n-        for (read_index, write_index) in (0..with.words().len()).zip(write_start..write_end) {\n+        for (read_index, write_index) in iter::zip(0..with.words().len(), write_start..write_end) {\n             let word = self.words[write_index];\n             let new_word = word | with.words()[read_index];\n             self.words[write_index] = new_word;"}, {"sha": "3ced3920cfdfe82118fa0914c970dd0bf98c8b97", "filename": "compiler/rustc_index/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_index%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_index%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -2,6 +2,7 @@\n #![feature(const_fn)]\n #![feature(const_panic)]\n #![feature(extend_one)]\n+#![feature(iter_zip)]\n #![feature(unboxed_closures)]\n #![feature(test)]\n #![feature(fn_traits)]"}, {"sha": "1b1a59a254e6fbd0bfb41e745037e49cb667babf", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -124,15 +124,17 @@ macro_rules! newtype_index {\n \n             #[inline]\n             $v const fn from_usize(value: usize) -> Self {\n-                assert!(value <= ($max as usize));\n+                // FIXME: replace with `assert!(value <= ($max as usize));` once `const_panic` is stable\n+                [()][(value > ($max as usize)) as usize];\n                 unsafe {\n                     Self::from_u32_unchecked(value as u32)\n                 }\n             }\n \n             #[inline]\n             $v const fn from_u32(value: u32) -> Self {\n-                assert!(value <= $max);\n+                // FIXME: replace with `assert!(value <= $max);` once `const_panic` is stable\n+                [()][(value > $max) as usize];\n                 unsafe {\n                     Self::from_u32_unchecked(value)\n                 }"}, {"sha": "c68705da413f829401cb03eb7b78d9346d04a16c", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -293,7 +293,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T>(&mut self, t: ty::Binder<T>) -> ty::Binder<T>\n+    fn fold_binder<T>(&mut self, t: ty::Binder<'tcx, T>) -> ty::Binder<'tcx, T>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -621,7 +621,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         let var = self.canonical_var(info, r.into());\n-        let br = ty::BoundRegion { kind: ty::BrAnon(var.as_u32()) };\n+        let br = ty::BoundRegion { var, kind: ty::BrAnon(var.as_u32()) };\n         let region = ty::ReLateBound(self.binder_index, br);\n         self.tcx().mk_region(region)\n     }"}, {"sha": "b8ecc949588fb0658d3e79b7c416018d220773c1", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -27,6 +27,7 @@ use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n use rustc_middle::ty::{self, BoundVar, Const, ToPredicate, Ty, TyCtxt};\n use std::fmt::Debug;\n+use std::iter;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// This method is meant to be invoked as the final step of a canonical query\n@@ -418,7 +419,8 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n         // In terms of our example above, we are iterating over pairs like:\n         // [(?A, Vec<?0>), ('static, '?1), (?B, ?0)]\n-        for (original_value, result_value) in original_values.var_values.iter().zip(result_values) {\n+        for (original_value, result_value) in iter::zip(&original_values.var_values, result_values)\n+        {\n             match result_value.unpack() {\n                 GenericArgKind::Type(result_value) => {\n                     // e.g., here `result_value` might be `?0` in the example above...\n@@ -437,7 +439,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n                         // We only allow a `ty::INNERMOST` index in substitutions.\n                         assert_eq!(debruijn, ty::INNERMOST);\n-                        opt_values[br.assert_bound_var()] = Some(*original_value);\n+                        opt_values[br.var] = Some(*original_value);\n                     }\n                 }\n                 GenericArgKind::Const(result_value) => {"}, {"sha": "553a11d4393f94ba0f3e1e14fdd1e8463745265a", "filename": "compiler/rustc_infer/src/infer/canonical/substitute.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -71,11 +71,10 @@ where\n     if var_values.var_values.is_empty() {\n         value\n     } else {\n-        let fld_r =\n-            |br: ty::BoundRegion| match var_values.var_values[br.assert_bound_var()].unpack() {\n-                GenericArgKind::Lifetime(l) => l,\n-                r => bug!(\"{:?} is a region but value is {:?}\", br, r),\n-            };\n+        let fld_r = |br: ty::BoundRegion| match var_values.var_values[br.var].unpack() {\n+            GenericArgKind::Lifetime(l) => l,\n+            r => bug!(\"{:?} is a region but value is {:?}\", br, r),\n+        };\n \n         let fld_t = |bound_ty: ty::BoundTy| match var_values.var_values[bound_ty.var].unpack() {\n             GenericArgKind::Type(ty) => ty,"}, {"sha": "debf108253793964800bbadce78277f02d66ca06", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -543,15 +543,11 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n         true\n     }\n \n-    fn visit_ct_substs(&self) -> bool {\n-        true\n-    }\n-\n     fn binders<T>(\n         &mut self,\n-        a: ty::Binder<T>,\n-        b: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>,\n     {\n@@ -737,6 +733,16 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                     }\n                 }\n             }\n+            ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted })\n+                if self.tcx().lazy_normalization() =>\n+            {\n+                assert_eq!(promoted, None);\n+                let substs = self.relate_with_variance(ty::Variance::Invariant, substs, substs)?;\n+                Ok(self.tcx().mk_const(ty::Const {\n+                    ty: c.ty,\n+                    val: ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted }),\n+                }))\n+            }\n             _ => relate::super_relate_consts(self, c, c),\n         }\n     }\n@@ -822,10 +828,6 @@ impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n         true\n     }\n \n-    fn visit_ct_substs(&self) -> bool {\n-        true\n-    }\n-\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _variance: ty::Variance,\n@@ -838,9 +840,9 @@ impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: ty::Binder<T>,\n-        b: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>,\n     {\n@@ -959,6 +961,16 @@ impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n                     }\n                 }\n             }\n+            ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted })\n+                if self.tcx().lazy_normalization() =>\n+            {\n+                assert_eq!(promoted, None);\n+                let substs = self.relate_with_variance(ty::Variance::Invariant, substs, substs)?;\n+                Ok(self.tcx().mk_const(ty::Const {\n+                    ty: c.ty,\n+                    val: ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted }),\n+                }))\n+            }\n             _ => relate::super_relate_consts(self, c, c),\n         }\n     }"}, {"sha": "45ba50bb6349cc9d177d81f6534601508bebdf87", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -124,9 +124,9 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: ty::Binder<T>,\n-        b: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>,\n     {"}, {"sha": "a91bd9ce2ff7474c085d5e189401fcc9e76f9e6f", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -73,7 +73,7 @@ use rustc_middle::ty::{\n use rustc_span::{sym, BytePos, DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n use std::ops::ControlFlow;\n-use std::{cmp, fmt};\n+use std::{cmp, fmt, iter};\n \n mod note;\n \n@@ -514,7 +514,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n             fn print_dyn_existential(\n                 self,\n-                _predicates: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n+                _predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n             ) -> Result<Self::DynExistential, Self::Error> {\n                 Err(NonTrivialPath)\n             }\n@@ -963,7 +963,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             ty::GenericParamDefKind::Const { has_default: true } => Some(param.def_id),\n             _ => None,\n         });\n-        for (def_id, actual) in default_params.zip(substs.iter().rev()) {\n+        for (def_id, actual) in iter::zip(default_params, substs.iter().rev()) {\n             match actual.unpack() {\n                 GenericArgKind::Const(c) => {\n                     if self.tcx.const_param_default(def_id).subst(self.tcx, substs) != c {\n@@ -1040,7 +1040,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let len1 = sig1.inputs().len();\n         let len2 = sig2.inputs().len();\n         if len1 == len2 {\n-            for (i, (l, r)) in sig1.inputs().iter().zip(sig2.inputs().iter()).enumerate() {\n+            for (i, (l, r)) in iter::zip(sig1.inputs(), sig2.inputs()).enumerate() {\n                 let (x1, x2) = self.cmp(l, r);\n                 (values.0).0.extend(x1.0);\n                 (values.1).0.extend(x2.0);\n@@ -1161,12 +1161,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     let common_len = cmp::min(len1, len2);\n                     let remainder1: Vec<_> = sub1.types().skip(common_len).collect();\n                     let remainder2: Vec<_> = sub2.types().skip(common_len).collect();\n-                    let common_default_params = remainder1\n-                        .iter()\n-                        .rev()\n-                        .zip(remainder2.iter().rev())\n-                        .filter(|(a, b)| a == b)\n-                        .count();\n+                    let common_default_params =\n+                        iter::zip(remainder1.iter().rev(), remainder2.iter().rev())\n+                            .filter(|(a, b)| a == b)\n+                            .count();\n                     let len = sub1.len() - common_default_params;\n                     let consts_offset = len - sub1.consts().count();\n \n@@ -1297,12 +1295,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                     const SEPARATOR: &str = \"::\";\n                     let separator_len = SEPARATOR.len();\n-                    let split_idx: usize = t1_str\n-                        .split(SEPARATOR)\n-                        .zip(t2_str.split(SEPARATOR))\n-                        .take_while(|(mod1_str, mod2_str)| mod1_str == mod2_str)\n-                        .map(|(mod_str, _)| mod_str.len() + separator_len)\n-                        .sum();\n+                    let split_idx: usize =\n+                        iter::zip(t1_str.split(SEPARATOR), t2_str.split(SEPARATOR))\n+                            .take_while(|(mod1_str, mod2_str)| mod1_str == mod2_str)\n+                            .map(|(mod_str, _)| mod_str.len() + separator_len)\n+                            .sum();\n \n                     debug!(\n                         \"cmp: separator_len={}, split_idx={}, min_len={}\",\n@@ -1907,7 +1904,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         .find_map(|(path, msg)| (&path_str == path).then_some(msg))\n                     {\n                         let mut show_suggestion = true;\n-                        for (exp_ty, found_ty) in exp_substs.types().zip(found_substs.types()) {\n+                        for (exp_ty, found_ty) in\n+                            iter::zip(exp_substs.types(), found_substs.types())\n+                        {\n                             match *exp_ty.kind() {\n                                 ty::Ref(_, exp_ty, _) => {\n                                     match (exp_ty.kind(), found_ty.kind()) {"}, {"sha": "d9a1193aac4bafc0f02516e3480ea48a2f1dd3c1", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -287,6 +287,7 @@ pub struct InferenceDiagnosticsData {\n pub struct InferenceDiagnosticsParentData {\n     pub prefix: &'static str,\n     pub name: String,\n+    pub def_id: DefId,\n }\n \n pub enum UnderspecifiedArgKind {\n@@ -328,6 +329,7 @@ impl InferenceDiagnosticsParentData {\n         Some(InferenceDiagnosticsParentData {\n             prefix: tcx.def_kind(parent_def_id).descr(parent_def_id),\n             name: parent_name,\n+            def_id: parent_def_id,\n         })\n     }\n }\n@@ -754,12 +756,30 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             if let (UnderspecifiedArgKind::Const { .. }, Some(parent_data)) =\n                 (&arg_data.kind, &arg_data.parent)\n             {\n-                err.span_suggestion_verbose(\n-                    span,\n-                    \"consider specifying the const argument\",\n-                    format!(\"{}::<{}>\", parent_data.name, arg_data.name),\n-                    Applicability::MaybeIncorrect,\n-                );\n+                let has_impl_trait =\n+                    self.tcx.generics_of(parent_data.def_id).params.iter().any(|param| {\n+                        matches!(\n+                            param.kind,\n+                            ty::GenericParamDefKind::Type {\n+                                synthetic: Some(\n+                                    hir::SyntheticTyParamKind::ImplTrait\n+                                        | hir::SyntheticTyParamKind::FromAttr,\n+                                ),\n+                                ..\n+                            }\n+                        )\n+                    });\n+\n+                // (#83606): Do not emit a suggestion if the parent has an `impl Trait`\n+                // as an argument otherwise it will cause the E0282 error.\n+                if !has_impl_trait {\n+                    err.span_suggestion_verbose(\n+                        span,\n+                        \"consider specifying the const argument\",\n+                        format!(\"{}::<{}>\", parent_data.name, arg_data.name),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n             }\n \n             err.span_label("}, {"sha": "58eb1e9aa12cb0aa4e61980155ace21c0ca33b8b", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -115,7 +115,7 @@ impl Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                     // error. We will then search the function parameters for a bound\n                     // region at the right depth with the same index\n                     (\n-                        Some(rl::Region::LateBoundAnon(debruijn_index, anon_index)),\n+                        Some(rl::Region::LateBoundAnon(debruijn_index, _, anon_index)),\n                         ty::BrAnon(br_index),\n                     ) => {\n                         debug!(\n@@ -143,7 +143,7 @@ impl Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                     // error. We will then search the function parameters for a bound\n                     // region at the right depth with the same index\n                     (\n-                        Some(rl::Region::LateBound(debruijn_index, id, _)),\n+                        Some(rl::Region::LateBound(debruijn_index, _, id, _)),\n                         ty::BrNamed(def_id, _),\n                     ) => {\n                         debug!(\n@@ -162,8 +162,8 @@ impl Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                             rl::Region::Static\n                             | rl::Region::Free(_, _)\n                             | rl::Region::EarlyBound(_, _, _)\n-                            | rl::Region::LateBound(_, _, _)\n-                            | rl::Region::LateBoundAnon(_, _),\n+                            | rl::Region::LateBound(_, _, _, _)\n+                            | rl::Region::LateBoundAnon(_, _, _),\n                         )\n                         | None,\n                         _,\n@@ -217,7 +217,10 @@ impl Visitor<'tcx> for TyPathVisitor<'tcx> {\n     fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n         match (self.tcx.named_region(lifetime.hir_id), self.bound_region) {\n             // the lifetime of the TyPath!\n-            (Some(rl::Region::LateBoundAnon(debruijn_index, anon_index)), ty::BrAnon(br_index)) => {\n+            (\n+                Some(rl::Region::LateBoundAnon(debruijn_index, _, anon_index)),\n+                ty::BrAnon(br_index),\n+            ) => {\n                 if debruijn_index == self.current_index && anon_index == br_index {\n                     self.found_it = true;\n                     return;\n@@ -232,7 +235,7 @@ impl Visitor<'tcx> for TyPathVisitor<'tcx> {\n                 }\n             }\n \n-            (Some(rl::Region::LateBound(debruijn_index, id, _)), ty::BrNamed(def_id, _)) => {\n+            (Some(rl::Region::LateBound(debruijn_index, _, id, _)), ty::BrNamed(def_id, _)) => {\n                 debug!(\"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\", debruijn_index,);\n                 debug!(\"id={:?}\", id);\n                 debug!(\"def_id={:?}\", def_id);\n@@ -246,8 +249,8 @@ impl Visitor<'tcx> for TyPathVisitor<'tcx> {\n                 Some(\n                     rl::Region::Static\n                     | rl::Region::EarlyBound(_, _, _)\n-                    | rl::Region::LateBound(_, _, _)\n-                    | rl::Region::LateBoundAnon(_, _)\n+                    | rl::Region::LateBound(_, _, _, _)\n+                    | rl::Region::LateBoundAnon(_, _, _)\n                     | rl::Region::Free(_, _),\n                 )\n                 | None,"}, {"sha": "02662043dba798088284696de403c25f30476984", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -85,9 +85,9 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: ty::Binder<T>,\n-        b: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>,\n     {"}, {"sha": "d460222df8ad0f82508f7ae52cdd6fa9f63c029d", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -11,10 +11,10 @@ use rustc_middle::ty::{self, Binder, TypeFoldable};\n impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n     pub fn higher_ranked_sub<T>(\n         &mut self,\n-        a: Binder<T>,\n-        b: Binder<T>,\n+        a: Binder<'tcx, T>,\n+        b: Binder<'tcx, T>,\n         a_is_expected: bool,\n-    ) -> RelateResult<'tcx, Binder<T>>\n+    ) -> RelateResult<'tcx, Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>,\n     {\n@@ -50,7 +50,10 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n \n             debug!(\"higher_ranked_sub: OK result={:?}\", result);\n \n-            Ok(ty::Binder::bind(result))\n+            // We related `a_prime` and `b_prime`, which just had any bound vars\n+            // replaced with placeholders or infer vars, respectively. Relating\n+            // them should not introduce new bound vars.\n+            Ok(ty::Binder::dummy(result))\n         })\n     }\n }\n@@ -66,7 +69,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// the [rustc dev guide].\n     ///\n     /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/hrtb.html\n-    pub fn replace_bound_vars_with_placeholders<T>(&self, binder: ty::Binder<T>) -> T\n+    pub fn replace_bound_vars_with_placeholders<T>(&self, binder: ty::Binder<'tcx, T>) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {"}, {"sha": "4fa8f2f1a6a426c82ec5bb6f9348a54a2e23f164", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -85,9 +85,9 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: ty::Binder<T>,\n-        b: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>,\n     {"}, {"sha": "eaec6b46bcd1456c30b15262808f3c684e1a0b7a", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1266,15 +1266,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.resolve_vars_if_possible(t).to_string()\n     }\n \n-    pub fn tys_to_string(&self, ts: &[Ty<'tcx>]) -> String {\n-        let tstrs: Vec<String> = ts.iter().map(|t| self.ty_to_string(*t)).collect();\n-        format!(\"({})\", tstrs.join(\", \"))\n-    }\n-\n-    pub fn trait_ref_to_string(&self, t: ty::TraitRef<'tcx>) -> String {\n-        self.resolve_vars_if_possible(t).print_only_trait_path().to_string()\n-    }\n-\n     /// If `TyVar(vid)` resolves to a type, return that type. Else, return the\n     /// universe index of `TyVar(vid)`.\n     pub fn probe_ty_var(&self, vid: TyVid) -> Result<Ty<'tcx>, ty::UniverseIndex> {\n@@ -1415,7 +1406,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,\n-        value: ty::Binder<T>,\n+        value: ty::Binder<'tcx, T>,\n     ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n     where\n         T: TypeFoldable<'tcx>,\n@@ -1704,14 +1695,6 @@ impl<'tcx> TypeTrace<'tcx> {\n     ) -> TypeTrace<'tcx> {\n         TypeTrace { cause: cause.clone(), values: Consts(ExpectedFound::new(a_is_expected, a, b)) }\n     }\n-\n-    pub fn dummy(tcx: TyCtxt<'tcx>) -> TypeTrace<'tcx> {\n-        let err = tcx.ty_error();\n-        TypeTrace {\n-            cause: ObligationCause::dummy(),\n-            values: Types(ExpectedFound { expected: err, found: err }),\n-        }\n-    }\n }\n \n impl<'tcx> SubregionOrigin<'tcx> {"}, {"sha": "fc9ea07866c214bdb1c56a4a2e23563f9c478dce", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -157,7 +157,7 @@ where\n \n     fn create_scope(\n         &mut self,\n-        value: ty::Binder<impl Relate<'tcx>>,\n+        value: ty::Binder<'tcx, impl Relate<'tcx>>,\n         universally_quantified: UniversallyQuantified,\n     ) -> BoundRegionScope<'tcx> {\n         let mut scope = BoundRegionScope::default();\n@@ -608,9 +608,9 @@ where\n \n     fn binders<T>(\n         &mut self,\n-        a: ty::Binder<T>,\n-        b: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>,\n     {\n@@ -744,7 +744,7 @@ struct ScopeInstantiator<'me, 'tcx> {\n impl<'me, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx> {\n     fn visit_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n-        t: &ty::Binder<T>,\n+        t: &ty::Binder<'tcx, T>,\n     ) -> ControlFlow<Self::BreakTy> {\n         self.target_index.shift_in(1);\n         t.super_visit_with(self);\n@@ -997,9 +997,9 @@ where\n \n     fn binders<T>(\n         &mut self,\n-        a: ty::Binder<T>,\n-        _: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n+        a: ty::Binder<'tcx, T>,\n+        _: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>,\n     {"}, {"sha": "9e04773c5fa2056c9bb4865d9051e938b5a0f86b", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -92,11 +92,6 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n         &self.region_bound_pairs_map\n     }\n \n-    /// Returns ownership of the `free_region_map`.\n-    pub fn into_free_region_map(self) -> FreeRegionMap<'tcx> {\n-        self.free_region_map\n-    }\n-\n     /// This is a hack to support the old-skool regionck, which\n     /// processes region constraints from the main function and the\n     /// closure together. In that context, when we enter a closure, we"}, {"sha": "3e2978fd170aea36526f911f1faa6486dc38a1cf", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -186,28 +186,6 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             }\n         }\n     }\n-\n-    /// Processes a single ad-hoc region obligation that was not\n-    /// registered in advance.\n-    pub fn type_must_outlive(\n-        &self,\n-        region_bound_pairs: &RegionBoundPairs<'tcx>,\n-        implicit_region_bound: Option<ty::Region<'tcx>>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        origin: infer::SubregionOrigin<'tcx>,\n-        ty: Ty<'tcx>,\n-        region: ty::Region<'tcx>,\n-    ) {\n-        let outlives = &mut TypeOutlives::new(\n-            self,\n-            self.tcx,\n-            region_bound_pairs,\n-            implicit_region_bound,\n-            param_env,\n-        );\n-        let ty = self.resolve_vars_if_possible(ty);\n-        outlives.type_must_outlive(origin, ty, region);\n-    }\n }\n \n /// The `TypeOutlives` struct has the job of \"lowering\" a `T: 'a`"}, {"sha": "9ffcddfae99443d1bfc75dbf84b07edef719c48c", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -309,31 +309,6 @@ pub struct RegionSnapshot {\n     any_unifications: bool,\n }\n \n-/// When working with placeholder regions, we often wish to find all of\n-/// the regions that are either reachable from a placeholder region, or\n-/// which can reach a placeholder region, or both. We call such regions\n-/// *tainted* regions. This struct allows you to decide what set of\n-/// tainted regions you want.\n-#[derive(Debug)]\n-pub struct TaintDirections {\n-    incoming: bool,\n-    outgoing: bool,\n-}\n-\n-impl TaintDirections {\n-    pub fn incoming() -> Self {\n-        TaintDirections { incoming: true, outgoing: false }\n-    }\n-\n-    pub fn outgoing() -> Self {\n-        TaintDirections { incoming: false, outgoing: true }\n-    }\n-\n-    pub fn both() -> Self {\n-        TaintDirections { incoming: true, outgoing: true }\n-    }\n-}\n-\n impl<'tcx> RegionConstraintStorage<'tcx> {\n     pub fn new() -> Self {\n         Self::default()\n@@ -472,11 +447,6 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         self.var_infos[vid].universe\n     }\n \n-    /// Returns the origin for the given variable.\n-    pub fn var_origin(&self, vid: RegionVid) -> RegionVariableOrigin {\n-        self.var_infos[vid].origin\n-    }\n-\n     fn add_constraint(&mut self, constraint: Constraint<'tcx>, origin: SubregionOrigin<'tcx>) {\n         // cannot add constraints once regions are resolved\n         debug!(\"RegionConstraintCollector: add_constraint({:?})\", constraint);\n@@ -795,16 +765,6 @@ impl<'tcx> VerifyBound<'tcx> {\n             VerifyBound::AnyBound(vec![self, vb])\n         }\n     }\n-\n-    pub fn and(self, vb: VerifyBound<'tcx>) -> VerifyBound<'tcx> {\n-        if self.must_hold() && vb.must_hold() {\n-            self\n-        } else if self.cannot_hold() && vb.cannot_hold() {\n-            self\n-        } else {\n-            VerifyBound::AllBounds(vec![self, vb])\n-        }\n-    }\n }\n \n impl<'tcx> RegionConstraintData<'tcx> {"}, {"sha": "48b8ee17594e3bd10708b88b8978a2417fb75572", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,5 +1,6 @@\n use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use super::{FixupError, FixupResult, InferCtxt, Span};\n+use rustc_middle::mir;\n use rustc_middle::ty::fold::{TypeFolder, TypeVisitor};\n use rustc_middle::ty::{self, Const, InferConst, Ty, TyCtxt, TypeFoldable};\n \n@@ -46,6 +47,10 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticVarResolver<'a, 'tcx> {\n             ct.super_fold_with(self)\n         }\n     }\n+\n+    fn fold_mir_const(&mut self, constant: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx> {\n+        constant.super_fold_with(self)\n+    }\n }\n \n /// The opportunistic region resolver opportunistically resolves regions"}, {"sha": "bf5f328233dfd7832ba421924214d53fec58df8d", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -162,9 +162,9 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: ty::Binder<T>,\n-        b: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>,\n     {"}, {"sha": "683c1df783e63e2d85e1cb4126755bfb6f43484e", "filename": "compiler/rustc_infer/src/infer/type_variable.rs", "status": "modified", "additions": 2, "deletions": 54, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -146,9 +146,7 @@ impl<'tcx> TypeVariableValue<'tcx> {\n     }\n }\n \n-pub(crate) struct Instantiate {\n-    vid: ty::TyVid,\n-}\n+pub(crate) struct Instantiate;\n \n pub(crate) struct Delegate;\n \n@@ -224,7 +222,7 @@ impl<'tcx> TypeVariableTable<'_, 'tcx> {\n         // Hack: we only need this so that `types_escaping_snapshot`\n         // can see what has been unified; see the Delegate impl for\n         // more details.\n-        self.undo_log.push(Instantiate { vid });\n+        self.undo_log.push(Instantiate);\n     }\n \n     /// Creates a new type variable.\n@@ -346,56 +344,6 @@ impl<'tcx> TypeVariableTable<'_, 'tcx> {\n         )\n     }\n \n-    /// Finds the set of type variables that existed *before* `s`\n-    /// but which have only been unified since `s` started, and\n-    /// return the types with which they were unified. So if we had\n-    /// a type variable `V0`, then we started the snapshot, then we\n-    /// created a type variable `V1`, unified `V0` with `T0`, and\n-    /// unified `V1` with `T1`, this function would return `{T0}`.\n-    pub fn types_escaping_snapshot(&mut self, s: &super::Snapshot<'tcx>) -> Vec<Ty<'tcx>> {\n-        let mut new_elem_threshold = u32::MAX;\n-        let mut escaping_types = Vec::new();\n-        let actions_since_snapshot = self.undo_log.actions_since_snapshot(s);\n-        debug!(\"actions_since_snapshot.len() = {}\", actions_since_snapshot.len());\n-        for i in 0..actions_since_snapshot.len() {\n-            let actions_since_snapshot = self.undo_log.actions_since_snapshot(s);\n-            match actions_since_snapshot[i] {\n-                super::UndoLog::TypeVariables(UndoLog::Values(sv::UndoLog::NewElem(index))) => {\n-                    // if any new variables were created during the\n-                    // snapshot, remember the lower index (which will\n-                    // always be the first one we see). Note that this\n-                    // action must precede those variables being\n-                    // specified.\n-                    new_elem_threshold = cmp::min(new_elem_threshold, index as u32);\n-                    debug!(\"NewElem({}) new_elem_threshold={}\", index, new_elem_threshold);\n-                }\n-\n-                super::UndoLog::TypeVariables(UndoLog::Values(sv::UndoLog::Other(\n-                    Instantiate { vid, .. },\n-                ))) => {\n-                    if vid.index < new_elem_threshold {\n-                        // quick check to see if this variable was\n-                        // created since the snapshot started or not.\n-                        let mut eq_relations = ut::UnificationTable::with_log(\n-                            &mut self.storage.eq_relations,\n-                            &mut *self.undo_log,\n-                        );\n-                        let escaping_type = match eq_relations.probe_value(vid) {\n-                            TypeVariableValue::Unknown { .. } => bug!(),\n-                            TypeVariableValue::Known { value } => value,\n-                        };\n-                        escaping_types.push(escaping_type);\n-                    }\n-                    debug!(\"SpecifyVar({:?}) new_elem_threshold={}\", vid, new_elem_threshold);\n-                }\n-\n-                _ => {}\n-            }\n-        }\n-\n-        escaping_types\n-    }\n-\n     /// Returns indices of all variables that are not yet\n     /// instantiated.\n     pub fn unsolved_variables(&mut self) -> Vec<ty::TyVid> {"}, {"sha": "f41e872e00488aef6c9469b8b124107c27bd4781", "filename": "compiler/rustc_infer/src/infer/undo_log.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -165,10 +165,6 @@ impl<'tcx> InferCtxtInner<'tcx> {\n }\n \n impl<'tcx> InferCtxtUndoLogs<'tcx> {\n-    pub fn actions_since_snapshot(&self, snapshot: &Snapshot<'tcx>) -> &[UndoLog<'tcx>] {\n-        &self.logs[snapshot.undo_len..]\n-    }\n-\n     pub fn start_snapshot(&mut self) -> Snapshot<'tcx> {\n         self.num_open_snapshots += 1;\n         Snapshot { undo_len: self.logs.len(), _marker: PhantomData }"}, {"sha": "d352214b57926f908eb36a59c4ac7cec7a4f71fc", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -19,6 +19,7 @@\n #![feature(const_fn)]\n #![feature(const_panic)]\n #![feature(extend_one)]\n+#![feature(iter_zip)]\n #![feature(never_type)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(in_band_lifetimes)]"}, {"sha": "0ac4b6b25bbfe54804ae045cd29dfdb8ff922f65", "filename": "compiler/rustc_infer/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -9,6 +9,7 @@ use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::Symbol;\n use rustc_span::{MultiSpan, Span};\n use std::fmt;\n+use std::iter;\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_extra_impl_obligation(\n@@ -94,7 +95,7 @@ pub fn report_object_safety_error(\n         note_span\n             .push_span_label(trait_span, \"this trait cannot be made into an object...\".to_string());\n     }\n-    for (span, msg) in multi_span.into_iter().zip(messages.into_iter()) {\n+    for (span, msg) in iter::zip(multi_span, messages) {\n         note_span.push_span_label(span, msg);\n     }\n     err.span_note("}, {"sha": "a33234a91faff47333f0c07dd49e7e7398d5ab52", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -128,7 +128,7 @@ impl<'tcx> FulfillmentError<'tcx> {\n }\n \n impl<'tcx> TraitObligation<'tcx> {\n-    pub fn self_ty(&self) -> ty::Binder<Ty<'tcx>> {\n+    pub fn self_ty(&self) -> ty::Binder<'tcx, Ty<'tcx>> {\n         self.predicate.map_bound(|p| p.self_ty())\n     }\n }"}, {"sha": "02e62a2cee951d62044871a00e208ab5901a75e4", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -15,8 +15,8 @@ use rustc_expand::base::ExtCtxt;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n use rustc_hir::Crate;\n-use rustc_index::vec::IndexVec;\n use rustc_lint::LintStore;\n+use rustc_metadata::creader::CStore;\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepGraph;\n use rustc_middle::middle;\n@@ -788,13 +788,7 @@ pub fn create_global_ctxt<'tcx>(\n         callback(sess, &mut local_providers, &mut extern_providers);\n     }\n \n-    let queries = {\n-        let crates = resolver_outputs.cstore.crates_untracked();\n-        let max_cnum = crates.iter().map(|c| c.as_usize()).max().unwrap_or(0);\n-        let mut providers = IndexVec::from_elem_n(extern_providers, max_cnum + 1);\n-        providers[LOCAL_CRATE] = local_providers;\n-        queries.get_or_init(|| TcxQueries::new(providers, extern_providers))\n-    };\n+    let queries = queries.get_or_init(|| TcxQueries::new(local_providers, extern_providers));\n \n     let gcx = sess.time(\"setup_global_ctxt\", || {\n         global_ctxt.get_or_init(|| {\n@@ -838,6 +832,12 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n                 });\n \n                 sess.time(\"looking_for_derive_registrar\", || proc_macro_decls::find(tcx));\n+\n+                let cstore = tcx\n+                    .cstore_as_any()\n+                    .downcast_ref::<CStore>()\n+                    .expect(\"`tcx.cstore` is not a `CStore`\");\n+                cstore.report_unused_deps(tcx);\n             },\n             {\n                 par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n@@ -1028,9 +1028,6 @@ pub fn start_codegen<'tcx>(\n         rustc_symbol_mangling::test::report_symbol_names(tcx);\n     }\n \n-    tcx.sess.time(\"assert_dep_graph\", || rustc_incremental::assert_dep_graph(tcx));\n-    tcx.sess.time(\"serialize_dep_graph\", || rustc_incremental::save_dep_graph(tcx));\n-\n     info!(\"Post-codegen\\n{:?}\", tcx.debug_stats());\n \n     if tcx.sess.opts.output_types.contains_key(&OutputType::Mir) {"}, {"sha": "01853eab530dad437b644270e2f5086354aa7391", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -207,7 +207,13 @@ impl<'tcx> Queries<'tcx> {\n                                 })\n                                 .open(self.session())\n                         });\n-                    DepGraph::new(prev_graph, prev_work_products)\n+\n+                    rustc_incremental::build_dep_graph(\n+                        self.session(),\n+                        prev_graph,\n+                        prev_work_products,\n+                    )\n+                    .unwrap_or_else(DepGraph::new_disabled)\n                 }\n             })\n         })\n@@ -435,6 +441,9 @@ impl Compiler {\n             if self.session().opts.debugging_opts.query_stats {\n                 gcx.enter(rustc_query_impl::print_stats);\n             }\n+\n+            self.session()\n+                .time(\"serialize_dep_graph\", || gcx.enter(rustc_incremental::save_dep_graph));\n         }\n \n         _timer = Some(self.session().timer(\"free_global_ctxt\"));"}, {"sha": "2270b2b33e2bab2476bb9cb0399b9bacb9487249", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -8,7 +8,7 @@ use rustc_session::config::{build_configuration, build_session_options, to_crate\n use rustc_session::config::{rustc_optgroups, ErrorOutputType, ExternLocation, Options, Passes};\n use rustc_session::config::{CFGuard, ExternEntry, LinkerPluginLto, LtoCli, SwitchWithOptPath};\n use rustc_session::config::{\n-    Externs, OutputType, OutputTypes, SanitizerSet, SymbolManglingVersion, WasiExecModel,\n+    Externs, OutputType, OutputTypes, SymbolManglingVersion, WasiExecModel,\n };\n use rustc_session::lint::Level;\n use rustc_session::search_paths::SearchPath;\n@@ -18,7 +18,7 @@ use rustc_span::edition::{Edition, DEFAULT_EDITION};\n use rustc_span::symbol::sym;\n use rustc_span::SourceFileHashAlgorithm;\n use rustc_target::spec::{CodeModel, LinkerFlavor, MergeFunctions, PanicStrategy};\n-use rustc_target::spec::{RelocModel, RelroLevel, SplitDebuginfo, TlsModel};\n+use rustc_target::spec::{RelocModel, RelroLevel, SanitizerSet, SplitDebuginfo, TlsModel};\n use std::collections::{BTreeMap, BTreeSet};\n use std::iter::FromIterator;\n use std::num::NonZeroUsize;\n@@ -471,7 +471,6 @@ fn test_debugging_options_tracking_hash() {\n     untracked!(ast_json, true);\n     untracked!(ast_json_noexpand, true);\n     untracked!(borrowck, String::from(\"other\"));\n-    untracked!(borrowck_stats, true);\n     untracked!(deduplicate_diagnostics, true);\n     untracked!(dep_tasks, true);\n     untracked!(dont_buffer_diagnostics, true);"}, {"sha": "59488fc80a5e2e312b889bbe4b64926c11011ad5", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -265,7 +265,7 @@ pub fn get_codegen_backend(sopts: &config::Options) -> Box<dyn CodegenBackend> {\n \n         let backend = match codegen_name {\n             filename if filename.contains('.') => load_backend_from_dylib(filename.as_ref()),\n-            codegen_name => get_builtin_codegen_backend(codegen_name),\n+            codegen_name => get_builtin_codegen_backend(&sopts.maybe_sysroot, codegen_name),\n         };\n \n         unsafe {\n@@ -390,15 +390,21 @@ fn sysroot_candidates() -> Vec<PathBuf> {\n     }\n }\n \n-pub fn get_builtin_codegen_backend(backend_name: &str) -> fn() -> Box<dyn CodegenBackend> {\n+pub fn get_builtin_codegen_backend(\n+    maybe_sysroot: &Option<PathBuf>,\n+    backend_name: &str,\n+) -> fn() -> Box<dyn CodegenBackend> {\n     match backend_name {\n         #[cfg(feature = \"llvm\")]\n         \"llvm\" => rustc_codegen_llvm::LlvmCodegenBackend::new,\n-        _ => get_codegen_sysroot(backend_name),\n+        _ => get_codegen_sysroot(maybe_sysroot, backend_name),\n     }\n }\n \n-pub fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend> {\n+pub fn get_codegen_sysroot(\n+    maybe_sysroot: &Option<PathBuf>,\n+    backend_name: &str,\n+) -> fn() -> Box<dyn CodegenBackend> {\n     // For now we only allow this function to be called once as it'll dlopen a\n     // few things, which seems to work best if we only do that once. In\n     // general this assertion never trips due to the once guard in `get_codegen_backend`,\n@@ -413,8 +419,9 @@ pub fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend\n     let target = session::config::host_triple();\n     let sysroot_candidates = sysroot_candidates();\n \n-    let sysroot = sysroot_candidates\n+    let sysroot = maybe_sysroot\n         .iter()\n+        .chain(sysroot_candidates.iter())\n         .map(|sysroot| {\n             let libdir = filesearch::relative_target_lib_path(&sysroot, &target);\n             sysroot.join(libdir).with_file_name(\"codegen-backends\")\n@@ -450,8 +457,10 @@ pub fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend\n \n     let mut file: Option<PathBuf> = None;\n \n-    let expected_name =\n-        format!(\"rustc_codegen_{}-{}\", backend_name, release_str().expect(\"CFG_RELEASE\"));\n+    let expected_names = &[\n+        format!(\"rustc_codegen_{}-{}\", backend_name, release_str().expect(\"CFG_RELEASE\")),\n+        format!(\"rustc_codegen_{}\", backend_name),\n+    ];\n     for entry in d.filter_map(|e| e.ok()) {\n         let path = entry.path();\n         let filename = match path.file_name().and_then(|s| s.to_str()) {\n@@ -462,7 +471,7 @@ pub fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend\n             continue;\n         }\n         let name = &filename[DLL_PREFIX.len()..filename.len() - DLL_SUFFIX.len()];\n-        if name != expected_name {\n+        if !expected_names.iter().any(|expected| expected == name) {\n             continue;\n         }\n         if let Some(ref prev) = file {"}, {"sha": "3f16bb9f442ee064b671b2f2ec1fe49602da88d8", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -481,7 +481,7 @@ fn has_doc(sess: &Session, attr: &ast::Attribute) -> bool {\n         return false;\n     }\n \n-    if attr.is_value_str() {\n+    if attr.value_str().is_some() {\n         return true;\n     }\n \n@@ -565,7 +565,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     }\n \n     fn check_crate(&mut self, cx: &LateContext<'_>, krate: &hir::Crate<'_>) {\n-        self.check_missing_docs_attrs(cx, hir::CRATE_HIR_ID, krate.item.span, \"the\", \"crate\");\n+        self.check_missing_docs_attrs(cx, hir::CRATE_HIR_ID, krate.item.inner, \"the\", \"crate\");\n \n         for macro_def in krate.exported_macros {\n             let attrs = cx.tcx.hir().attrs(macro_def.hir_id());"}, {"sha": "b3a19bfbf7532469f2773d190cab06b0a93b46aa", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -45,6 +45,7 @@ use rustc_target::abi::LayoutOf;\n use tracing::debug;\n \n use std::cell::Cell;\n+use std::iter;\n use std::slice;\n \n /// Information about the registered lints.\n@@ -176,6 +177,7 @@ impl LintStore {\n         self.early_passes.push(Box::new(pass));\n     }\n \n+    /// Used by clippy.\n     pub fn register_pre_expansion_pass(\n         &mut self,\n         pass: impl Fn() -> EarlyLintPassObject + 'static + sync::Send + sync::Sync,\n@@ -707,6 +709,9 @@ pub trait LintContext: Sized {\n                 BuiltinLintDiagnostics::ProcMacroBackCompat(note) => {\n                     db.note(&note);\n                 }\n+                BuiltinLintDiagnostics::OrPatternsBackCompat(span,suggestion) => {\n+                    db.span_suggestion(span, \"use pat2015 to preserve semantics\", suggestion, Applicability::MachineApplicable);\n+                }\n             }\n             // Rewrap `db`, and pass control to the user.\n             decorate(LintDiagnosticBuilder::new(db));\n@@ -861,10 +866,12 @@ impl<'tcx> LateContext<'tcx> {\n     ///     // The given `def_id` is that of an `Option` type\n     /// }\n     /// ```\n+    ///\n+    /// Used by clippy, but should be replaced by diagnostic items eventually.\n     pub fn match_def_path(&self, def_id: DefId, path: &[Symbol]) -> bool {\n         let names = self.get_def_path(def_id);\n \n-        names.len() == path.len() && names.into_iter().zip(path.iter()).all(|(a, &b)| a == b)\n+        names.len() == path.len() && iter::zip(names, path).all(|(a, &b)| a == b)\n     }\n \n     /// Gets the absolute path of `def_id` as a vector of `Symbol`.\n@@ -905,7 +912,7 @@ impl<'tcx> LateContext<'tcx> {\n \n             fn print_dyn_existential(\n                 self,\n-                _predicates: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n+                _predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n             ) -> Result<Self::DynExistential, Self::Error> {\n                 Ok(())\n             }"}, {"sha": "863023fa7b54d25e01f099df0d0711affcb7cd8f", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -564,10 +564,6 @@ impl<'s> LintLevelsBuilder<'s> {\n         self.id_to_set.insert(id, self.cur);\n     }\n \n-    pub fn build(self) -> LintLevelSets {\n-        self.sets\n-    }\n-\n     pub fn build_map(self) -> LintLevelMap {\n         LintLevelMap { sets: self.sets, id_to_set: self.id_to_set }\n     }"}, {"sha": "e2724b52453a52c8488e2a929772406111f4326f", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -33,6 +33,7 @@\n #![feature(box_patterns)]\n #![feature(crate_visibility_modifier)]\n #![feature(iter_order_by)]\n+#![feature(iter_zip)]\n #![feature(never_type)]\n #![feature(nll)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n@@ -325,6 +326,7 @@ fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n     store.register_renamed(\"exceeding_bitshifts\", \"arithmetic_overflow\");\n     store.register_renamed(\"redundant_semicolon\", \"redundant_semicolons\");\n     store.register_renamed(\"overlapping_patterns\", \"overlapping_range_endpoints\");\n+    store.register_renamed(\"safe_packed_borrows\", \"unaligned_references\");\n \n     // These were moved to tool lints, but rustc still sees them when compiling normally, before\n     // tool lints are registered, so `check_tool_name_for_backwards_compat` doesn't work. Use"}, {"sha": "9c94bab04e98f6401458c9856c5d66f4a92ef8d0", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -17,6 +17,7 @@ use rustc_target::abi::{Integer, LayoutOf, TagEncoding, VariantIdx, Variants};\n use rustc_target::spec::abi::Abi as SpecAbi;\n \n use std::cmp;\n+use std::iter;\n use std::ops::ControlFlow;\n use tracing::debug;\n \n@@ -1255,7 +1256,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         let sig = self.cx.tcx.fn_sig(def_id);\n         let sig = self.cx.tcx.erase_late_bound_regions(sig);\n \n-        for (input_ty, input_hir) in sig.inputs().iter().zip(decl.inputs) {\n+        for (input_ty, input_hir) in iter::zip(sig.inputs(), decl.inputs) {\n             self.check_type_for_ffi_and_report_errors(input_hir.span, input_ty, false, false);\n         }\n \n@@ -1355,10 +1356,7 @@ impl<'tcx> LateLintPass<'tcx> for VariantSizeDifferences {\n                 layout\n             );\n \n-            let (largest, slargest, largest_index) = enum_definition\n-                .variants\n-                .iter()\n-                .zip(variants)\n+            let (largest, slargest, largest_index) = iter::zip(enum_definition.variants, variants)\n                 .map(|(variant, variant_layout)| {\n                     // Subtract the size of the enum tag.\n                     let bytes = variant_layout.size.bytes().saturating_sub(tag_size);"}, {"sha": "27724b4965c3cd0201b22d900fe2551ba4aff00b", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 48, "deletions": 56, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -547,7 +547,7 @@ declare_lint! {\n     /// Also consider if you intended to use an _inner attribute_ (with a `!`\n     /// such as `#![allow(unused)]`) which applies to the item the attribute\n     /// is within, or an _outer attribute_ (without a `!` such as\n-    /// `#[allow(unsued)]`) which applies to the item *following* the\n+    /// `#[allow(unused)]`) which applies to the item *following* the\n     /// attribute.\n     ///\n     /// [attributes]: https://doc.rust-lang.org/reference/attributes.html\n@@ -1057,6 +1057,7 @@ declare_lint! {\n     ///     unsafe {\n     ///         let foo = Foo { field1: 0, field2: 0 };\n     ///         let _ = &foo.field1;\n+    ///         println!(\"{}\", foo.field1); // An implicit `&` is added here, triggering the lint.\n     ///     }\n     /// }\n     /// ```\n@@ -1065,20 +1066,20 @@ declare_lint! {\n     ///\n     /// ### Explanation\n     ///\n-    /// Creating a reference to an insufficiently aligned packed field is\n-    /// [undefined behavior] and should be disallowed.\n-    ///\n-    /// This lint is \"allow\" by default because there is no stable\n-    /// alternative, and it is not yet certain how widespread existing code\n-    /// will trigger this lint.\n-    ///\n-    /// See [issue #27060] for more discussion.\n+    /// Creating a reference to an insufficiently aligned packed field is [undefined behavior] and\n+    /// should be disallowed. Using an `unsafe` block does not change anything about this. Instead,\n+    /// the code should do a copy of the data in the packed field or use raw pointers and unaligned\n+    /// accesses. See [issue #82523] for more information.\n     ///\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n-    /// [issue #27060]: https://github.com/rust-lang/rust/issues/27060\n+    /// [issue #82523]: https://github.com/rust-lang/rust/issues/82523\n     pub UNALIGNED_REFERENCES,\n-    Allow,\n+    Warn,\n     \"detects unaligned references to fields of packed structs\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #82523 <https://github.com/rust-lang/rust/issues/82523>\",\n+        edition: None,\n+    };\n     report_in_external_macro\n }\n \n@@ -1150,49 +1151,6 @@ declare_lint! {\n     \"detects attempts to mutate a `const` item\",\n }\n \n-declare_lint! {\n-    /// The `safe_packed_borrows` lint detects borrowing a field in the\n-    /// interior of a packed structure with alignment other than 1.\n-    ///\n-    /// ### Example\n-    ///\n-    /// ```rust\n-    /// #[repr(packed)]\n-    /// pub struct Unaligned<T>(pub T);\n-    ///\n-    /// pub struct Foo {\n-    ///     start: u8,\n-    ///     data: Unaligned<u32>,\n-    /// }\n-    ///\n-    /// fn main() {\n-    ///     let x = Foo { start: 0, data: Unaligned(1) };\n-    ///     let y = &x.data.0;\n-    /// }\n-    /// ```\n-    ///\n-    /// {{produces}}\n-    ///\n-    /// ### Explanation\n-    ///\n-    /// This type of borrow is unsafe and can cause errors on some platforms\n-    /// and violates some assumptions made by the compiler. This was\n-    /// previously allowed unintentionally. This is a [future-incompatible]\n-    /// lint to transition this to a hard error in the future. See [issue\n-    /// #46043] for more details, including guidance on how to solve the\n-    /// problem.\n-    ///\n-    /// [issue #46043]: https://github.com/rust-lang/rust/issues/46043\n-    /// [future-incompatible]: ../index.md#future-incompatible-lints\n-    pub SAFE_PACKED_BORROWS,\n-    Warn,\n-    \"safe borrows of fields of packed structs were erroneously allowed\",\n-    @future_incompatible = FutureIncompatibleInfo {\n-        reference: \"issue #46043 <https://github.com/rust-lang/rust/issues/46043>\",\n-        edition: None,\n-    };\n-}\n-\n declare_lint! {\n     /// The `patterns_in_fns_without_body` lint detects `mut` identifier\n     /// patterns as a parameter in functions without a body.\n@@ -1977,7 +1935,7 @@ declare_lint! {\n     Warn,\n     \"detects proc macro derives using inaccessible names from parent modules\",\n     @future_incompatible = FutureIncompatibleInfo {\n-        reference: \"issue #50504 <https://github.com/rust-lang/rust/issues/50504>\",\n+        reference: \"issue #83583 <https://github.com/rust-lang/rust/issues/83583>\",\n         edition: None,\n     };\n }\n@@ -2953,7 +2911,6 @@ declare_lint_pass! {\n         RENAMED_AND_REMOVED_LINTS,\n         UNALIGNED_REFERENCES,\n         CONST_ITEM_MUTATION,\n-        SAFE_PACKED_BORROWS,\n         PATTERNS_IN_FNS_WITHOUT_BODY,\n         MISSING_FRAGMENT_SPECIFIER,\n         LATE_BOUND_LIFETIME_ARGUMENTS,\n@@ -3002,6 +2959,7 @@ declare_lint_pass! {\n         DISJOINT_CAPTURE_DROP_REORDER,\n         LEGACY_DERIVE_HELPERS,\n         PROC_MACRO_BACK_COMPAT,\n+        OR_PATTERNS_BACK_COMPAT,\n     ]\n }\n \n@@ -3179,3 +3137,37 @@ declare_lint! {\n         })\n     };\n }\n+\n+declare_lint! {\n+    /// The `or_patterns_back_compat` lint detects usage of old versions of or-patterns.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(or_patterns_back_compat)]\n+    /// macro_rules! match_any {\n+    ///     ( $expr:expr , $( $( $pat:pat )|+ => $expr_arm:expr ),+ ) => {\n+    ///         match $expr {\n+    ///             $(\n+    ///                 $( $pat => $expr_arm, )+\n+    ///             )+\n+    ///         }\n+    ///     };\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let result: Result<i64, i32> = Err(42);\n+    ///     let int: i64 = match_any!(result, Ok(i) | Err(i) => i.into());\n+    ///     assert_eq!(int, 42);\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// In Rust 2021, the pat matcher will match new patterns, which include the | character.\n+    pub OR_PATTERNS_BACK_COMPAT,\n+    Allow,\n+    \"detects usage of old versions of or-patterns\",\n+}"}, {"sha": "70475563a4abe4921881c11bfe2f5ace6428c0a0", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -267,6 +267,7 @@ pub enum BuiltinLintDiagnostics {\n     LegacyDeriveHelpers(Span),\n     ExternDepSpec(String, ExternDepSpec),\n     ProcMacroBackCompat(String),\n+    OrPatternsBackCompat(Span, String),\n }\n \n /// Lints that are buffered up early on in the `Session` before the"}, {"sha": "d6db69c748fb568aaa339ae8e01046920d3156b0", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1636,6 +1636,10 @@ extern \"C\" void LLVMRustSetVisibility(LLVMValueRef V,\n   LLVMSetVisibility(V, fromRust(RustVisibility));\n }\n \n+extern \"C\" void LLVMRustSetDSOLocal(LLVMValueRef Global, bool is_dso_local) {\n+  unwrap<GlobalValue>(Global)->setDSOLocal(is_dso_local);\n+}\n+\n struct LLVMRustModuleBuffer {\n   std::string data;\n };"}, {"sha": "842d2a977189d53e6a7e0102ef8a9e7e9823cd57", "filename": "compiler/rustc_macros/src/symbols/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_macros%2Fsrc%2Fsymbols%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_macros%2Fsrc%2Fsymbols%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsymbols%2Ftests.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -43,7 +43,7 @@ fn test_symbols_macro(input: TokenStream, expected_errors: &[&str]) {\n         \"Macro generated a different number of errors than expected\"\n     );\n \n-    for (found_error, &expected_error) in found_errors.iter().zip(expected_errors.iter()) {\n+    for (found_error, &expected_error) in found_errors.iter().zip(expected_errors) {\n         let found_error_str = format!(\"{}\", found_error);\n         assert_eq!(found_error_str, expected_error);\n     }"}, {"sha": "29fa0b7006992acf4d7b6295075ced47a07575fb", "filename": "compiler/rustc_metadata/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2FCargo.toml?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -11,7 +11,6 @@ doctest = false\n libc = \"0.2\"\n snap = \"1\"\n tracing = \"0.1\"\n-memmap2 = \"0.2.1\"\n smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_attr = { path = \"../rustc_attr\" }"}, {"sha": "26db3a5f39d7c80e8ee0aa1b2960a13c5ecfc3b9", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -46,6 +46,9 @@ pub struct CStore {\n     /// This map is used to verify we get no hash conflicts between\n     /// `StableCrateId` values.\n     stable_crate_ids: FxHashMap<StableCrateId, CrateNum>,\n+\n+    /// Unused externs of the crate\n+    unused_externs: Vec<Symbol>,\n }\n \n pub struct CrateLoader<'a> {\n@@ -190,6 +193,27 @@ impl CStore {\n     crate fn has_global_allocator(&self) -> bool {\n         self.has_global_allocator\n     }\n+\n+    pub fn report_unused_deps(&self, tcx: TyCtxt<'_>) {\n+        // We put the check for the option before the lint_level_at_node call\n+        // because the call mutates internal state and introducing it\n+        // leads to some ui tests failing.\n+        if !tcx.sess.opts.json_unused_externs {\n+            return;\n+        }\n+        let level = tcx\n+            .lint_level_at_node(lint::builtin::UNUSED_CRATE_DEPENDENCIES, rustc_hir::CRATE_HIR_ID)\n+            .0;\n+        if level != lint::Level::Allow {\n+            let unused_externs =\n+                self.unused_externs.iter().map(|ident| ident.to_ident_string()).collect::<Vec<_>>();\n+            let unused_externs = unused_externs.iter().map(String::as_str).collect::<Vec<&str>>();\n+            tcx.sess\n+                .parse_sess\n+                .span_diagnostic\n+                .emit_unused_externs(level.as_str(), &unused_externs);\n+        }\n+    }\n }\n \n impl<'a> CrateLoader<'a> {\n@@ -217,6 +241,7 @@ impl<'a> CrateLoader<'a> {\n                 allocator_kind: None,\n                 has_global_allocator: false,\n                 stable_crate_ids,\n+                unused_externs: Vec::new(),\n             },\n             used_extern_options: Default::default(),\n         }\n@@ -350,16 +375,13 @@ impl<'a> CrateLoader<'a> {\n         let Library { source, metadata } = lib;\n         let crate_root = metadata.get_root();\n         let host_hash = host_lib.as_ref().map(|lib| lib.metadata.get_root().hash());\n-        self.verify_no_symbol_conflicts(&crate_root)?;\n \n         let private_dep =\n             self.sess.opts.externs.get(&name.as_str()).map_or(false, |e| e.is_private_dep);\n \n         // Claim this crate number and cache it\n         let cnum = self.cstore.alloc_new_crate_num();\n \n-        self.verify_no_stable_crate_id_hash_conflicts(&crate_root, cnum)?;\n-\n         info!(\n             \"register crate `{}` (cnum = {}. private_dep = {})\",\n             crate_root.name(),\n@@ -394,6 +416,14 @@ impl<'a> CrateLoader<'a> {\n             None\n         };\n \n+        // Perform some verification *after* resolve_crate_deps() above is\n+        // known to have been successful. It seems that - in error cases - the\n+        // cstore can be in a temporarily invalid state between cnum allocation\n+        // and dependency resolution and the verification code would produce\n+        // ICEs in that case (see #83045).\n+        self.verify_no_symbol_conflicts(&crate_root)?;\n+        self.verify_no_stable_crate_id_hash_conflicts(&crate_root, cnum)?;\n+\n         let crate_metadata = CrateMetadata::new(\n             self.sess,\n             metadata,\n@@ -899,11 +929,17 @@ impl<'a> CrateLoader<'a> {\n                 // Don't worry about pathless `--extern foo` sysroot references\n                 continue;\n             }\n-            if self.used_extern_options.contains(&Symbol::intern(name)) {\n+            let name_interned = Symbol::intern(name);\n+            if self.used_extern_options.contains(&name_interned) {\n                 continue;\n             }\n \n             // Got a real unused --extern\n+            if self.sess.opts.json_unused_externs {\n+                self.cstore.unused_externs.push(name_interned);\n+                continue;\n+            }\n+\n             let diag = match self.sess.opts.extern_dep_specs.get(name) {\n                 Some(loc) => BuiltinLintDiagnostics::ExternDepSpec(name.clone(), loc.into()),\n                 None => {\n@@ -936,9 +972,9 @@ impl<'a> CrateLoader<'a> {\n         self.inject_allocator_crate(krate);\n         self.inject_panic_runtime(krate);\n \n-        info!(\"{:?}\", CrateDump(&self.cstore));\n-\n         self.report_unused_deps(krate);\n+\n+        info!(\"{:?}\", CrateDump(&self.cstore));\n     }\n \n     pub fn process_extern_crate("}, {"sha": "c4d9e3f77f071676abde7df7be011382ceb65b21", "filename": "compiler/rustc_metadata/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -26,7 +26,6 @@ pub use rmeta::{provide, provide_extern};\n \n mod dependency_format;\n mod foreign_modules;\n-mod link_args;\n mod native_libs;\n mod rmeta;\n "}, {"sha": "9e1ac33368c7fdad810b923f1455f56feebe34f9", "filename": "compiler/rustc_metadata/src/link_args.rs", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7f32fda78c60bb5b05e610a1c0c0fecaff07f497/compiler%2Frustc_metadata%2Fsrc%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f32fda78c60bb5b05e610a1c0c0fecaff07f497/compiler%2Frustc_metadata%2Fsrc%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flink_args.rs?ref=7f32fda78c60bb5b05e610a1c0c0fecaff07f497", "patch": "@@ -1,57 +0,0 @@\n-use rustc_hir as hir;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_middle::ty::TyCtxt;\n-use rustc_span::symbol::{sym, Symbol};\n-use rustc_target::spec::abi::Abi;\n-\n-crate fn collect(tcx: TyCtxt<'_>) -> Vec<String> {\n-    let mut collector = Collector { tcx, args: Vec::new() };\n-    tcx.hir().krate().visit_all_item_likes(&mut collector);\n-\n-    for attr in tcx.hir().attrs(hir::CRATE_HIR_ID).iter() {\n-        if attr.has_name(sym::link_args) {\n-            if let Some(linkarg) = attr.value_str() {\n-                collector.add_link_args(linkarg);\n-            }\n-        }\n-    }\n-\n-    collector.args\n-}\n-\n-struct Collector<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    args: Vec<String>,\n-}\n-\n-impl<'tcx> ItemLikeVisitor<'tcx> for Collector<'tcx> {\n-    fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n-        let abi = match it.kind {\n-            hir::ItemKind::ForeignMod { abi, .. } => abi,\n-            _ => return,\n-        };\n-        if abi == Abi::Rust || abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-            return;\n-        }\n-\n-        // First, add all of the custom #[link_args] attributes\n-        let sess = &self.tcx.sess;\n-        for m in\n-            self.tcx.hir().attrs(it.hir_id()).iter().filter(|a| sess.check_name(a, sym::link_args))\n-        {\n-            if let Some(linkarg) = m.value_str() {\n-                self.add_link_args(linkarg);\n-            }\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, _it: &'tcx hir::TraitItem<'tcx>) {}\n-    fn visit_impl_item(&mut self, _it: &'tcx hir::ImplItem<'tcx>) {}\n-    fn visit_foreign_item(&mut self, _it: &'tcx hir::ForeignItem<'tcx>) {}\n-}\n-\n-impl<'tcx> Collector<'tcx> {\n-    fn add_link_args(&mut self, args: Symbol) {\n-        self.args.extend(args.as_str().split(' ').filter(|s| !s.is_empty()).map(|s| s.to_string()))\n-    }\n-}"}, {"sha": "7f6311861c1b28177421870b8be7ef36774d8d53", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -216,6 +216,7 @@ use crate::creader::Library;\n use crate::rmeta::{rustc_version, MetadataBlob, METADATA_HEADER};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::owning_ref::OwningRef;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n@@ -232,7 +233,6 @@ use rustc_target::spec::{Target, TargetTriple};\n \n use snap::read::FrameDecoder;\n use std::io::{Read, Result as IoResult, Write};\n-use std::ops::Deref;\n use std::path::{Path, PathBuf};\n use std::{cmp, fmt, fs};\n use tracing::{debug, info, warn};\n@@ -727,19 +727,6 @@ impl<'a> CrateLocator<'a> {\n     }\n }\n \n-/// A trivial wrapper for `Mmap` that implements `StableDeref`.\n-struct StableDerefMmap(memmap2::Mmap);\n-\n-impl Deref for StableDerefMmap {\n-    type Target = [u8];\n-\n-    fn deref(&self) -> &[u8] {\n-        self.0.deref()\n-    }\n-}\n-\n-unsafe impl stable_deref_trait::StableDeref for StableDerefMmap {}\n-\n fn get_metadata_section(\n     target: &Target,\n     flavor: CrateFlavor,\n@@ -779,11 +766,11 @@ fn get_metadata_section(\n             // mmap the file, because only a small fraction of it is read.\n             let file = std::fs::File::open(filename)\n                 .map_err(|_| format!(\"failed to open rmeta metadata: '{}'\", filename.display()))?;\n-            let mmap = unsafe { memmap2::Mmap::map(&file) };\n+            let mmap = unsafe { Mmap::map(file) };\n             let mmap = mmap\n                 .map_err(|_| format!(\"failed to mmap rmeta metadata: '{}'\", filename.display()))?;\n \n-            rustc_erase_owner!(OwningRef::new(StableDerefMmap(mmap)).map_owner_box())\n+            rustc_erase_owner!(OwningRef::new(mmap).map_owner_box())\n         }\n     };\n     let blob = MetadataBlob::new(raw_bytes);"}, {"sha": "bebee9dac3b739d33353300c49e5824e04baaf6e", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,6 +1,5 @@\n use crate::creader::{CStore, LoadedMacro};\n use crate::foreign_modules;\n-use crate::link_args;\n use crate::native_libs;\n use crate::rmeta::{self, encoder};\n \n@@ -295,10 +294,6 @@ pub fn provide(providers: &mut Providers) {\n                 foreign_modules::collect(tcx).into_iter().map(|m| (m.def_id, m)).collect();\n             Lrc::new(modules)\n         },\n-        link_args: |tcx, cnum| {\n-            assert_eq!(cnum, LOCAL_CRATE);\n-            Lrc::new(link_args::collect(tcx))\n-        },\n \n         // Returns a map from a sufficiently visible external item (i.e., an\n         // external item that is visible from at least one local module) to a"}, {"sha": "a5157854e15c0511749fab3f82903d9b671b73ee", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -427,7 +427,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_info_for_items(&mut self) {\n         let krate = self.tcx.hir().krate();\n-        self.encode_info_for_mod(CRATE_DEF_ID, &krate.item.module);\n+        self.encode_info_for_mod(CRATE_DEF_ID, &krate.item);\n \n         // Proc-macro crates only export proc-macro items, which are looked\n         // up using `proc_macro_data`"}, {"sha": "d2fe9af34fb625a8a88ae9e94cd4f89f661ddaec", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -8,8 +8,8 @@ use rustc_session::Session;\n mod dep_node;\n \n pub use rustc_query_system::dep_graph::{\n-    debug, hash_result, DepContext, DepNodeColor, DepNodeIndex, SerializedDepNodeIndex,\n-    WorkProduct, WorkProductId,\n+    debug::DepNodeFilter, hash_result, DepContext, DepNodeColor, DepNodeIndex,\n+    SerializedDepNodeIndex, WorkProduct, WorkProductId,\n };\n \n crate use dep_node::make_compile_codegen_unit;\n@@ -20,6 +20,7 @@ pub type TaskDeps = rustc_query_system::dep_graph::TaskDeps<DepKind>;\n pub type DepGraphQuery = rustc_query_system::dep_graph::DepGraphQuery<DepKind>;\n pub type PreviousDepGraph = rustc_query_system::dep_graph::PreviousDepGraph<DepKind>;\n pub type SerializedDepGraph = rustc_query_system::dep_graph::SerializedDepGraph<DepKind>;\n+pub type EdgeFilter = rustc_query_system::dep_graph::debug::EdgeFilter<DepKind>;\n \n impl rustc_query_system::dep_graph::DepKind for DepKind {\n     const NULL: Self = DepKind::Null;"}, {"sha": "d155276051e4ab5eb845375ccc8b25eaee379b15", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 31, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -459,7 +459,7 @@ impl<'hir> Map<'hir> {\n         let hir_id = self.local_def_id_to_hir_id(module);\n         match self.get_entry(hir_id).node {\n             Node::Item(&Item { span, kind: ItemKind::Mod(ref m), .. }) => (m, span, hir_id),\n-            Node::Crate(item) => (&item.module, item.span, hir_id),\n+            Node::Crate(item) => (&item, item.inner, hir_id),\n             node => panic!(\"not a module: {:?}\", node),\n         }\n     }\n@@ -550,24 +550,6 @@ impl<'hir> Map<'hir> {\n         ParentHirIterator { current_id, map: self }\n     }\n \n-    /// Checks if the node is an argument. An argument is a local variable whose\n-    /// immediate parent is an item or a closure.\n-    pub fn is_argument(&self, id: HirId) -> bool {\n-        match self.find(id) {\n-            Some(Node::Binding(_)) => (),\n-            _ => return false,\n-        }\n-        matches!(\n-            self.find(self.get_parent_node(id)),\n-            Some(\n-                Node::Item(_)\n-                    | Node::TraitItem(_)\n-                    | Node::ImplItem(_)\n-                    | Node::Expr(Expr { kind: ExprKind::Closure(..), .. }),\n-            )\n-        )\n-    }\n-\n     /// Checks if the node is left-hand side of an assignment.\n     pub fn is_lhs(&self, id: HirId) -> bool {\n         match self.find(self.get_parent_node(id)) {\n@@ -779,17 +761,6 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn expect_variant_data(&self, id: HirId) -> &'hir VariantData<'hir> {\n-        match self.find(id) {\n-            Some(\n-                Node::Ctor(vd)\n-                | Node::Item(Item { kind: ItemKind::Struct(vd, _) | ItemKind::Union(vd, _), .. }),\n-            ) => vd,\n-            Some(Node::Variant(variant)) => &variant.data,\n-            _ => bug!(\"expected struct or variant, found {}\", self.node_to_string(id)),\n-        }\n-    }\n-\n     pub fn expect_variant(&self, id: HirId) -> &'hir Variant<'hir> {\n         match self.find(id) {\n             Some(Node::Variant(variant)) => variant,\n@@ -897,7 +868,7 @@ impl<'hir> Map<'hir> {\n             Node::Visibility(v) => bug!(\"unexpected Visibility {:?}\", v),\n             Node::Local(local) => local.span,\n             Node::MacroDef(macro_def) => macro_def.span,\n-            Node::Crate(item) => item.span,\n+            Node::Crate(item) => item.inner,\n         };\n         Some(span)\n     }"}, {"sha": "b2fef731b7e2059f8bcde6c5d3db8053f71400d4", "filename": "compiler/rustc_middle/src/ich/hcx.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -119,11 +119,6 @@ impl<'a> StableHashingContext<'a> {\n         Self::new_with_or_without_spans(sess, krate, definitions, cstore, always_ignore_spans)\n     }\n \n-    #[inline]\n-    pub fn sess(&self) -> &'a Session {\n-        self.sess\n-    }\n-\n     #[inline]\n     pub fn while_hashing_hir_bodies<F: FnOnce(&mut Self)>(&mut self, hash_bodies: bool, f: F) {\n         let prev_hash_bodies = self.hash_bodies;"}, {"sha": "8e53e4ba948058bdd4351b7a93227ddf27aea74a", "filename": "compiler/rustc_middle/src/ich/impls_ty.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_ty.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -70,16 +70,16 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionKind {\n             ty::ReEmpty(universe) => {\n                 universe.hash_stable(hcx, hasher);\n             }\n-            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrAnon(i) }) => {\n+            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrAnon(i), .. }) => {\n                 db.hash_stable(hcx, hasher);\n                 i.hash_stable(hcx, hasher);\n             }\n-            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrNamed(def_id, name) }) => {\n+            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrNamed(def_id, name), .. }) => {\n                 db.hash_stable(hcx, hasher);\n                 def_id.hash_stable(hcx, hasher);\n                 name.hash_stable(hcx, hasher);\n             }\n-            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrEnv }) => {\n+            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrEnv, .. }) => {\n                 db.hash_stable(hcx, hasher);\n             }\n             ty::ReEarlyBound(ty::EarlyBoundRegion { def_id, index, name }) => {\n@@ -118,12 +118,13 @@ impl<'tcx> HashStable<StableHashingContext<'tcx>> for ty::BoundVar {\n     }\n }\n \n-impl<'a, T> HashStable<StableHashingContext<'a>> for ty::Binder<T>\n+impl<'a, 'tcx, T> HashStable<StableHashingContext<'a>> for ty::Binder<'tcx, T>\n where\n     T: HashStable<StableHashingContext<'a>>,\n {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.as_ref().skip_binder().hash_stable(hcx, hasher);\n+        self.bound_vars().hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "5df2f91f09fff253a70b0179873d7a35631dd988", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -27,6 +27,7 @@ use crate::ty::{self, BoundVar, List, Region, TyCtxt};\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use smallvec::SmallVec;\n+use std::iter;\n use std::ops::Index;\n \n /// A \"canonicalized\" type `V` is one where all free inference\n@@ -227,20 +228,12 @@ impl Certainty {\n             Certainty::Ambiguous => false,\n         }\n     }\n-\n-    pub fn is_ambiguous(&self) -> bool {\n-        !self.is_proven()\n-    }\n }\n \n impl<'tcx, R> QueryResponse<'tcx, R> {\n     pub fn is_proven(&self) -> bool {\n         self.certainty.is_proven()\n     }\n-\n-    pub fn is_ambiguous(&self) -> bool {\n-        !self.is_proven()\n-    }\n }\n \n impl<'tcx, R> Canonical<'tcx, QueryResponse<'tcx, R>> {\n@@ -284,7 +277,7 @@ impl<'tcx, V> Canonical<'tcx, V> {\n }\n \n pub type QueryOutlivesConstraint<'tcx> =\n-    ty::Binder<ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>>;\n+    ty::Binder<'tcx, ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>>;\n \n TrivialTypeFoldableAndLiftImpls! {\n     for <'tcx> {\n@@ -315,16 +308,14 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n         use crate::ty::subst::GenericArgKind;\n \n         CanonicalVarValues {\n-            var_values: self\n-                .var_values\n-                .iter()\n-                .zip(0..)\n+            var_values: iter::zip(&self.var_values, 0..)\n                 .map(|(kind, i)| match kind.unpack() {\n                     GenericArgKind::Type(..) => {\n                         tcx.mk_ty(ty::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i).into())).into()\n                     }\n                     GenericArgKind::Lifetime(..) => {\n-                        let br = ty::BoundRegion { kind: ty::BrAnon(i) };\n+                        let br =\n+                            ty::BoundRegion { var: ty::BoundVar::from_u32(i), kind: ty::BrAnon(i) };\n                         tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)).into()\n                     }\n                     GenericArgKind::Const(ct) => tcx"}, {"sha": "641cf23781e2c7407a568b64aea61e1810ca8694", "filename": "compiler/rustc_middle/src/infer/unify_key.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -97,13 +97,6 @@ impl<'tcx> ConstVariableValue<'tcx> {\n             ConstVariableValue::Known { value } => Some(value),\n         }\n     }\n-\n-    pub fn is_unknown(&self) -> bool {\n-        match *self {\n-            ConstVariableValue::Unknown { .. } => true,\n-            ConstVariableValue::Known { .. } => false,\n-        }\n-    }\n }\n \n #[derive(Copy, Clone, Debug)]"}, {"sha": "bd0749792db8bbffee6b24741bc5c3b0aa998669", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -51,6 +51,7 @@\n #![feature(exclusive_range_pattern)]\n #![feature(control_flow_enum)]\n #![feature(associated_type_defaults)]\n+#![feature(iter_zip)]\n #![recursion_limit = \"512\"]\n \n #[macro_use]"}, {"sha": "7024d9a3d21dbdb63c6042512822dfd009051b9a", "filename": "compiler/rustc_middle/src/middle/codegen_fn_attrs.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcodegen_fn_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcodegen_fn_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcodegen_fn_attrs.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,7 +1,7 @@\n use crate::mir::mono::Linkage;\n use rustc_attr::{InlineAttr, InstructionSetAttr, OptimizeAttr};\n-use rustc_session::config::SanitizerSet;\n use rustc_span::symbol::Symbol;\n+use rustc_target::spec::SanitizerSet;\n \n #[derive(Clone, TyEncodable, TyDecodable, HashStable, Debug)]\n pub struct CodegenFnAttrs {\n@@ -38,6 +38,9 @@ pub struct CodegenFnAttrs {\n     /// be generated against a specific instruction set. Only usable on architectures which allow\n     /// switching between multiple instruction sets.\n     pub instruction_set: Option<InstructionSetAttr>,\n+    /// The `#[repr(align(...))]` attribute. Indicates the value of which the function should be\n+    /// aligned to.\n+    pub alignment: Option<u32>,\n }\n \n bitflags! {\n@@ -103,6 +106,7 @@ impl CodegenFnAttrs {\n             link_section: None,\n             no_sanitize: SanitizerSet::empty(),\n             instruction_set: None,\n+            alignment: None,\n         }\n     }\n "}, {"sha": "5440e63543d40a83e9d8973fcb572f486a4ca3b6", "filename": "compiler/rustc_middle/src/middle/region.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -430,6 +430,8 @@ impl ScopeTree {\n \n     /// Returns `true` if `subscope` is equal to or is lexically nested inside `superscope`, and\n     /// `false` otherwise.\n+    ///\n+    /// Used by clippy.\n     pub fn is_subscope_of(&self, subscope: Scope, superscope: Scope) -> bool {\n         let mut s = subscope;\n         debug!(\"is_subscope_of({:?}, {:?})\", subscope, superscope);"}, {"sha": "aa6488b329eba76cb14311993556a37c8102d42e", "filename": "compiler/rustc_middle/src/middle/resolve_lifetime.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -39,8 +39,13 @@ impl LifetimeDefOrigin {\n pub enum Region {\n     Static,\n     EarlyBound(/* index */ u32, /* lifetime decl */ DefId, LifetimeDefOrigin),\n-    LateBound(ty::DebruijnIndex, /* lifetime decl */ DefId, LifetimeDefOrigin),\n-    LateBoundAnon(ty::DebruijnIndex, /* anon index */ u32),\n+    LateBound(\n+        ty::DebruijnIndex,\n+        /* late-bound index */ u32,\n+        /* lifetime decl */ DefId,\n+        LifetimeDefOrigin,\n+    ),\n+    LateBoundAnon(ty::DebruijnIndex, /* late-bound index */ u32, /* anon index */ u32),\n     Free(DefId, /* lifetime decl */ DefId),\n }\n \n@@ -78,4 +83,6 @@ pub struct ResolveLifetimes {\n     /// be late-bound if (a) it does NOT appear in a where-clause and\n     /// (b) it DOES appear in the arguments.\n     pub late_bound: FxHashMap<LocalDefId, FxHashSet<ItemLocalId>>,\n+\n+    pub late_bound_vars: FxHashMap<LocalDefId, FxHashMap<ItemLocalId, Vec<ty::BoundVariableKind>>>,\n }"}, {"sha": "fc9a2970e00aeb41f7ebe215ab21eb93ea42e586", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -29,12 +29,6 @@ pub enum StabilityLevel {\n     Stable,\n }\n \n-impl StabilityLevel {\n-    pub fn from_attr_level(level: &attr::StabilityLevel) -> Self {\n-        if level.is_stable() { Stable } else { Unstable }\n-    }\n-}\n-\n /// An entry in the `depr_map`.\n #[derive(Clone, HashStable, Debug)]\n pub struct DeprecationEntry {"}, {"sha": "ddb1a84fe7bdffbd368cf8028572c4916a27f704", "filename": "compiler/rustc_middle/src/mir/coverage.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -41,8 +41,16 @@ rustc_index::newtype_index! {\n }\n \n impl CounterValueReference {\n-    // Counters start at 1 to reserve 0 for ExpressionOperandId::ZERO.\n+    /// Counters start at 1 to reserve 0 for ExpressionOperandId::ZERO.\n     pub const START: Self = Self::from_u32(1);\n+\n+    /// Returns explicitly-requested zero-based version of the counter id, used\n+    /// during codegen. LLVM expects zero-based indexes.\n+    pub fn zero_based_index(&self) -> u32 {\n+        let one_based_index = self.as_u32();\n+        debug_assert!(one_based_index > 0);\n+        one_based_index - 1\n+    }\n }\n \n rustc_index::newtype_index! {\n@@ -117,17 +125,9 @@ impl CoverageKind {\n         }\n     }\n \n-    pub fn is_counter(&self) -> bool {\n-        matches!(self, Self::Counter { .. })\n-    }\n-\n     pub fn is_expression(&self) -> bool {\n         matches!(self, Self::Expression { .. })\n     }\n-\n-    pub fn is_unreachable(&self) -> bool {\n-        *self == Self::Unreachable\n-    }\n }\n \n impl Debug for CoverageKind {\n@@ -183,3 +183,13 @@ pub enum Op {\n     Subtract,\n     Add,\n }\n+\n+impl Op {\n+    pub fn is_add(&self) -> bool {\n+        matches!(self, Self::Add)\n+    }\n+\n+    pub fn is_subtract(&self) -> bool {\n+        matches!(self, Self::Subtract)\n+    }\n+}"}, {"sha": "888777a9418b3909dbc50a7869593f194e553b87", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -307,16 +307,6 @@ impl<'tcx, Tag> Scalar<Tag> {\n             .unwrap_or_else(|| bug!(\"Signed value {:#x} does not fit in {} bits\", i, size.bits()))\n     }\n \n-    #[inline]\n-    pub fn from_i8(i: i8) -> Self {\n-        Self::from_int(i, Size::from_bits(8))\n-    }\n-\n-    #[inline]\n-    pub fn from_i16(i: i16) -> Self {\n-        Self::from_int(i, Size::from_bits(16))\n-    }\n-\n     #[inline]\n     pub fn from_i32(i: i32) -> Self {\n         Self::from_int(i, Size::from_bits(32))"}, {"sha": "a7e9fc468b4fdfc0bfb50aee29205cb397dfd87e", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -379,24 +379,6 @@ impl<'tcx> Body<'tcx> {\n         }\n     }\n \n-    /// Returns an iterator over all temporaries.\n-    #[inline]\n-    pub fn temps_iter<'a>(&'a self) -> impl Iterator<Item = Local> + 'a {\n-        (self.arg_count + 1..self.local_decls.len()).filter_map(move |index| {\n-            let local = Local::new(index);\n-            if self.local_decls[local].is_user_variable() { None } else { Some(local) }\n-        })\n-    }\n-\n-    /// Returns an iterator over all user-declared locals.\n-    #[inline]\n-    pub fn vars_iter<'a>(&'a self) -> impl Iterator<Item = Local> + 'a {\n-        (self.arg_count + 1..self.local_decls.len()).filter_map(move |index| {\n-            let local = Local::new(index);\n-            self.local_decls[local].is_user_variable().then_some(local)\n-        })\n-    }\n-\n     /// Returns an iterator over all user-declared mutable locals.\n     #[inline]\n     pub fn mut_vars_iter<'a>(&'a self) -> impl Iterator<Item = Local> + 'a {\n@@ -1500,7 +1482,7 @@ pub enum StatementKind<'tcx> {\n     ///\n     /// Note that this also is emitted for regular `let` bindings to ensure that locals that are\n     /// never accessed still get some sanity checks for, e.g., `let x: ! = ..;`\n-    FakeRead(FakeReadCause, Box<Place<'tcx>>),\n+    FakeRead(Box<(FakeReadCause, Place<'tcx>)>),\n \n     /// Write the discriminant for a variant to the enum Place.\n     SetDiscriminant { place: Box<Place<'tcx>>, variant_index: VariantIdx },\n@@ -1593,7 +1575,12 @@ pub enum FakeReadCause {\n \n     /// `let x: !; match x {}` doesn't generate any read of x so we need to\n     /// generate a read of x to check that it is initialized and safe.\n-    ForMatchedPlace,\n+    ///\n+    /// If a closure pattern matches a Place starting with an Upvar, then we introduce a\n+    /// FakeRead for that Place outside the closure, in such a case this option would be\n+    /// Some(closure_def_id).\n+    /// Otherwise, the value of the optional DefId will be None.\n+    ForMatchedPlace(Option<DefId>),\n \n     /// A fake read of the RefWithinGuard version of a bind-by-value variable\n     /// in a match guard to ensure that it's value hasn't change by the time\n@@ -1612,7 +1599,12 @@ pub enum FakeReadCause {\n     /// but in some cases it can affect the borrow checker, as in #53695.\n     /// Therefore, we insert a \"fake read\" here to ensure that we get\n     /// appropriate errors.\n-    ForLet,\n+    ///\n+    /// If a closure pattern matches a Place starting with an Upvar, then we introduce a\n+    /// FakeRead for that Place outside the closure, in such a case this option would be\n+    /// Some(closure_def_id).\n+    /// Otherwise, the value of the optional DefId will be None.\n+    ForLet(Option<DefId>),\n \n     /// If we have an index expression like\n     ///\n@@ -1636,7 +1628,9 @@ impl Debug for Statement<'_> {\n         use self::StatementKind::*;\n         match self.kind {\n             Assign(box (ref place, ref rv)) => write!(fmt, \"{:?} = {:?}\", place, rv),\n-            FakeRead(ref cause, ref place) => write!(fmt, \"FakeRead({:?}, {:?})\", cause, place),\n+            FakeRead(box (ref cause, ref place)) => {\n+                write!(fmt, \"FakeRead({:?}, {:?})\", cause, place)\n+            }\n             Retag(ref kind, ref place) => write!(\n                 fmt,\n                 \"Retag({}{:?})\",\n@@ -2329,7 +2323,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             CtorKind::Fn => fmt_tuple(fmt, &name),\n                             CtorKind::Fictive => {\n                                 let mut struct_fmt = fmt.debug_struct(&name);\n-                                for (field, place) in variant_def.fields.iter().zip(places) {\n+                                for (field, place) in iter::zip(&variant_def.fields, places) {\n                                     struct_fmt.field(&field.ident.as_str(), place);\n                                 }\n                                 struct_fmt.finish()\n@@ -2353,7 +2347,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n                             if let Some(upvars) = tcx.upvars_mentioned(def_id) {\n-                                for (&var_id, place) in upvars.keys().zip(places) {\n+                                for (&var_id, place) in iter::zip(upvars.keys(), places) {\n                                     let var_name = tcx.hir().name(var_id);\n                                     struct_fmt.field(&var_name.as_str(), place);\n                                 }\n@@ -2372,7 +2366,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n                             if let Some(upvars) = tcx.upvars_mentioned(def_id) {\n-                                for (&var_id, place) in upvars.keys().zip(places) {\n+                                for (&var_id, place) in iter::zip(upvars.keys(), places) {\n                                     let var_name = tcx.hir().name(var_id);\n                                     struct_fmt.field(&var_name.as_str(), place);\n                                 }\n@@ -2410,7 +2404,8 @@ pub struct Constant<'tcx> {\n     pub literal: ConstantKind<'tcx>,\n }\n \n-#[derive(Clone, Copy, PartialEq, PartialOrd, TyEncodable, TyDecodable, Hash, HashStable, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, TyEncodable, TyDecodable, Hash, HashStable, Debug)]\n+#[derive(Lift)]\n pub enum ConstantKind<'tcx> {\n     /// This constant came from the type system\n     Ty(&'tcx ty::Const<'tcx>),\n@@ -2709,7 +2704,13 @@ impl<'tcx> Display for Constant<'tcx> {\n             ty::FnDef(..) => {}\n             _ => write!(fmt, \"const \")?,\n         }\n-        match self.literal {\n+        Display::fmt(&self.literal, fmt)\n+    }\n+}\n+\n+impl<'tcx> Display for ConstantKind<'tcx> {\n+    fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n+        match *self {\n             ConstantKind::Ty(c) => pretty_print_const(c, fmt, true),\n             ConstantKind::Val(val, ty) => pretty_print_const_value(val, ty, fmt, true),\n         }"}, {"sha": "6c2468b9ffe0b1c937d2a1fc53d5fb331d35668d", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -84,14 +84,7 @@ impl<'tcx> MonoItem<'tcx> {\n             .debugging_opts\n             .inline_in_all_cgus\n             .unwrap_or_else(|| tcx.sess.opts.optimize != OptLevel::No)\n-            && !tcx.sess.link_dead_code()\n-            && !tcx.sess.instrument_coverage();\n-        // Disabled for `-Z instrument-coverage` because some LLVM optimizations can sometimes\n-        // break coverage results. A test that failed at certain optimization levels is now\n-        // validated at that optimization level (via `compile-flags` directive):\n-        //   * `src/test/run-make-fulldeps/coverage/closure.rs` broke with `-C opt-level=2`, and\n-        //     also required disabling `internalize_symbols` in\n-        //     `rustc_mir/monomorphize/partitioning/mod.rs`\n+            && !tcx.sess.link_dead_code();\n \n         match *self {\n             MonoItem::Fn(ref instance) => {"}, {"sha": "ad3baccf1549616b5ebd694f4728de2255dfb9cb", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -23,15 +23,9 @@ pub enum UnsafetyViolationKind {\n     General,\n     /// Permitted both in `const fn`s and regular `fn`s.\n     GeneralAndConstFn,\n-    /// Borrow of packed field.\n-    /// Has to be handled as a lint for backwards compatibility.\n-    BorrowPacked,\n     /// Unsafe operation in an `unsafe fn` but outside an `unsafe` block.\n     /// Has to be handled as a lint for backwards compatibility.\n     UnsafeFn,\n-    /// Borrow of packed field in an `unsafe fn` but outside an `unsafe` block.\n-    /// Has to be handled as a lint for backwards compatibility.\n-    UnsafeFnBorrowPacked,\n }\n \n #[derive(Copy, Clone, PartialEq, TyEncodable, TyDecodable, HashStable, Debug)]"}, {"sha": "c8db4aeb449b87e66b1a99e78572f7046a1dce98", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -67,7 +67,7 @@ impl SwitchTargets {\n     ///\n     /// Note that this may yield 0 elements. Only the `otherwise` branch is mandatory.\n     pub fn iter(&self) -> SwitchTargetsIter<'_> {\n-        SwitchTargetsIter { inner: self.values.iter().zip(self.targets.iter()) }\n+        SwitchTargetsIter { inner: iter::zip(&self.values, &self.targets) }\n     }\n \n     /// Returns a slice with all possible jump targets (including the fallback target)."}, {"sha": "725448584dd29cbe3d763067bbbf5394afc2da06", "filename": "compiler/rustc_middle/src/mir/traversal.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -264,10 +264,6 @@ impl<'a, 'tcx> ReversePostorder<'a, 'tcx> {\n \n         ReversePostorder { body, blocks, idx: len }\n     }\n-\n-    pub fn reset(&mut self) {\n-        self.idx = self.blocks.len();\n-    }\n }\n \n pub fn reverse_postorder<'a, 'tcx>(body: &'a Body<'tcx>) -> ReversePostorder<'a, 'tcx> {"}, {"sha": "f3124e5bf424ef41897c62e9bd88aea4fb0c7cf0", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -348,6 +348,11 @@ impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ConstantKind<'tcx> {\n+    #[inline(always)]\n+    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        folder.fold_mir_const(self)\n+    }\n+\n     fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         match self {\n             ConstantKind::Ty(c) => ConstantKind::Ty(c.fold_with(folder)),"}, {"sha": "fd504f8c5d5acae6a65770544419e4ed96e8b3c6", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -380,7 +380,7 @@ macro_rules! make_mir_visitor {\n                     ) => {\n                         self.visit_assign(place, rvalue, location);\n                     }\n-                    StatementKind::FakeRead(_, place) => {\n+                    StatementKind::FakeRead(box (_, place)) => {\n                         self.visit_place(\n                             place,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect),\n@@ -1247,12 +1247,6 @@ impl PlaceContext {\n         matches!(self, PlaceContext::MutatingUse(..))\n     }\n \n-    /// Returns `true` if this place context represents a use that does not change the value.\n-    #[inline]\n-    pub fn is_nonmutating_use(&self) -> bool {\n-        matches!(self, PlaceContext::NonMutatingUse(..))\n-    }\n-\n     /// Returns `true` if this place context represents a use.\n     #[inline]\n     pub fn is_use(&self) -> bool {"}, {"sha": "bac69e282a521672ae81467f3ae72581e2aac37c", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1253,11 +1253,6 @@ rustc_queries! {\n         desc { |tcx| \"native_library_kind({})\", tcx.def_path_str(def_id) }\n     }\n \n-    query link_args(_: CrateNum) -> Lrc<Vec<String>> {\n-        eval_always\n-        desc { \"looking up link arguments for a crate\" }\n-    }\n-\n     /// Does lifetime resolution, but does not descend into trait items. This\n     /// should only be used for resolving lifetimes of on trait definitions,\n     /// and is used to avoid cycles. Importantly, `resolve_lifetimes` still visits\n@@ -1290,6 +1285,10 @@ rustc_queries! {\n         -> Option<Vec<ObjectLifetimeDefault>> {\n         desc { \"looking up lifetime defaults for a region on an item\" }\n     }\n+    query late_bound_vars_map(_: LocalDefId)\n+        -> Option<&'tcx FxHashMap<ItemLocalId, Vec<ty::BoundVariableKind>>> {\n+        desc { \"looking up late bound vars\" }\n+    }\n \n     query visibility(def_id: DefId) -> ty::Visibility {\n         eval_always\n@@ -1482,6 +1481,13 @@ rustc_queries! {\n         desc { \"normalizing `{}`\", goal.value }\n     }\n \n+    /// Do not call this query directly: invoke `normalize_erasing_regions` instead.\n+    query normalize_mir_const_after_erasing_regions(\n+        goal: ParamEnvAnd<'tcx, mir::ConstantKind<'tcx>>\n+    ) -> mir::ConstantKind<'tcx> {\n+        desc { \"normalizing `{}`\", goal.value }\n+    }\n+\n     query implied_outlives_bounds(\n         goal: CanonicalTyGoal<'tcx>\n     ) -> Result<"}, {"sha": "00dec3b355f8f840129dfba9bf59f8fb3a218358", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -323,6 +323,9 @@ pub enum ObligationCauseCode<'tcx> {\n \n     /// #[feature(trivial_bounds)] is not enabled\n     TrivialBound,\n+\n+    /// If `X` is the concrete type of an opaque type `impl Y`, then `X` must implement `Y`\n+    OpaqueType,\n }\n \n impl ObligationCauseCode<'_> {\n@@ -341,7 +344,7 @@ impl ObligationCauseCode<'_> {\n \n // `ObligationCauseCode` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(ObligationCauseCode<'_>, 32);\n+static_assert_size!(ObligationCauseCode<'_>, 40);\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum StatementAsExpression {"}, {"sha": "eac3ab7282f527158ac1e207bc438c60e9c53562", "filename": "compiler/rustc_middle/src/traits/query.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -44,24 +44,12 @@ pub mod type_op {\n         pub b: Ty<'tcx>,\n     }\n \n-    impl<'tcx> Eq<'tcx> {\n-        pub fn new(a: Ty<'tcx>, b: Ty<'tcx>) -> Self {\n-            Self { a, b }\n-        }\n-    }\n-\n     #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n     pub struct Subtype<'tcx> {\n         pub sub: Ty<'tcx>,\n         pub sup: Ty<'tcx>,\n     }\n \n-    impl<'tcx> Subtype<'tcx> {\n-        pub fn new(sub: Ty<'tcx>, sup: Ty<'tcx>) -> Self {\n-            Self { sub, sup }\n-        }\n-    }\n-\n     #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n     pub struct ProvePredicate<'tcx> {\n         pub predicate: Predicate<'tcx>,"}, {"sha": "8e2c79701af90d76d48d6979e23a08c4f7fd35ea", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -112,9 +112,9 @@ impl TypeRelation<'tcx> for Match<'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: ty::Binder<T>,\n-        b: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>,\n     {"}, {"sha": "52cb6b301b070eb715772e6417315f86cdff6c9d", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -6,7 +6,6 @@ use crate::ty;\n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_hir::lang_items::LangItem;\n use rustc_span::Span;\n \n use super::{Ty, TyCtxt};\n@@ -113,14 +112,6 @@ impl<'tcx> ClosureKind {\n     // This is the initial value used when doing upvar inference.\n     pub const LATTICE_BOTTOM: ClosureKind = ClosureKind::Fn;\n \n-    pub fn trait_did(&self, tcx: TyCtxt<'tcx>) -> DefId {\n-        match *self {\n-            ClosureKind::Fn => tcx.require_lang_item(LangItem::Fn, None),\n-            ClosureKind::FnMut => tcx.require_lang_item(LangItem::FnMut, None),\n-            ClosureKind::FnOnce => tcx.require_lang_item(LangItem::FnOnce, None),\n-        }\n-    }\n-\n     /// Returns `true` if a type that impls this closure kind\n     /// must also implement `other`.\n     pub fn extends(self, other: ty::ClosureKind) -> bool {\n@@ -377,12 +368,4 @@ impl BorrowKind {\n             UniqueImmBorrow => hir::Mutability::Mut,\n         }\n     }\n-\n-    pub fn to_user_str(&self) -> &'static str {\n-        match *self {\n-            MutBorrow => \"mutable\",\n-            ImmBorrow => \"immutable\",\n-            UniqueImmBorrow => \"uniquely immutable\",\n-        }\n-    }\n }"}, {"sha": "d7767dc39cb32a6f9db613fb345d708fea963606", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -120,8 +120,9 @@ impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Binder<ty::PredicateKind<'tcx>> {\n+impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Binder<'tcx, ty::PredicateKind<'tcx>> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+        self.bound_vars().encode(e)?;\n         encode_with_shorthand(e, &self.skip_binder(), TyEncoder::predicate_shorthands)\n     }\n }\n@@ -188,7 +189,7 @@ pub trait TyDecoder<'tcx>: Decoder {\n }\n \n #[inline]\n-pub fn decode_arena_allocable<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable<D>>(\n+fn decode_arena_allocable<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable<D>>(\n     decoder: &mut D,\n ) -> Result<&'tcx T, D::Error>\n where\n@@ -198,7 +199,7 @@ where\n }\n \n #[inline]\n-pub fn decode_arena_allocable_slice<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable<D>>(\n+fn decode_arena_allocable_slice<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable<D>>(\n     decoder: &mut D,\n ) -> Result<&'tcx [T], D::Error>\n where\n@@ -226,18 +227,22 @@ impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Binder<ty::PredicateKind<'tcx>> {\n-    fn decode(decoder: &mut D) -> Result<ty::Binder<ty::PredicateKind<'tcx>>, D::Error> {\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Binder<'tcx, ty::PredicateKind<'tcx>> {\n+    fn decode(decoder: &mut D) -> Result<ty::Binder<'tcx, ty::PredicateKind<'tcx>>, D::Error> {\n+        let bound_vars = Decodable::decode(decoder)?;\n         // Handle shorthands first, if we have an usize > 0x80.\n-        Ok(ty::Binder::bind(if decoder.positioned_at_shorthand() {\n-            let pos = decoder.read_usize()?;\n-            assert!(pos >= SHORTHAND_OFFSET);\n-            let shorthand = pos - SHORTHAND_OFFSET;\n-\n-            decoder.with_position(shorthand, ty::PredicateKind::decode)?\n-        } else {\n-            ty::PredicateKind::decode(decoder)?\n-        }))\n+        Ok(ty::Binder::bind_with_vars(\n+            if decoder.positioned_at_shorthand() {\n+                let pos = decoder.read_usize()?;\n+                assert!(pos >= SHORTHAND_OFFSET);\n+                let shorthand = pos - SHORTHAND_OFFSET;\n+\n+                decoder.with_position(shorthand, ty::PredicateKind::decode)?\n+            } else {\n+                ty::PredicateKind::decode(decoder)?\n+            },\n+            bound_vars,\n+        ))\n     }\n }\n \n@@ -319,7 +324,7 @@ impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::List<Ty<'tcx>> {\n }\n \n impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D>\n-    for ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>\n+    for ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>\n {\n     fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n         let len = decoder.read_usize()?;\n@@ -379,15 +384,23 @@ impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [mir::abstract_const::N\n     }\n }\n \n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::List<ty::BoundVariableKind> {\n+    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n+        let len = decoder.read_usize()?;\n+        Ok(decoder.tcx().mk_bound_variable_kinds((0..len).map(|_| Decodable::decode(decoder)))?)\n+    }\n+}\n+\n impl_decodable_via_ref! {\n     &'tcx ty::TypeckResults<'tcx>,\n     &'tcx ty::List<Ty<'tcx>>,\n-    &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n+    &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n     &'tcx Allocation,\n     &'tcx mir::Body<'tcx>,\n     &'tcx mir::UnsafetyCheckResult,\n     &'tcx mir::BorrowCheckResult<'tcx>,\n-    &'tcx mir::coverage::CodeRegion\n+    &'tcx mir::coverage::CodeRegion,\n+    &'tcx ty::List<ty::BoundVariableKind>\n }\n \n #[macro_export]\n@@ -488,14 +501,16 @@ macro_rules! implement_ty_decoder {\n macro_rules! impl_binder_encode_decode {\n     ($($t:ty),+ $(,)?) => {\n         $(\n-            impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Binder<$t> {\n+            impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Binder<'tcx, $t> {\n                 fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+                    self.bound_vars().encode(e)?;\n                     self.as_ref().skip_binder().encode(e)\n                 }\n             }\n-            impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Binder<$t> {\n+            impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Binder<'tcx, $t> {\n                 fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n-                    Ok(ty::Binder::bind(Decodable::decode(decoder)?))\n+                    let bound_vars = Decodable::decode(decoder)?;\n+                    Ok(ty::Binder::bind_with_vars(Decodable::decode(decoder)?, bound_vars))\n                 }\n             }\n         )*"}, {"sha": "bb2b00cbaea818bc3c794ec20bca334f873d40f9", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 52, "deletions": 22, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -87,14 +87,16 @@ pub struct CtxtInterners<'tcx> {\n     substs: InternedSet<'tcx, InternalSubsts<'tcx>>,\n     canonical_var_infos: InternedSet<'tcx, List<CanonicalVarInfo<'tcx>>>,\n     region: InternedSet<'tcx, RegionKind>,\n-    poly_existential_predicates: InternedSet<'tcx, List<ty::Binder<ExistentialPredicate<'tcx>>>>,\n+    poly_existential_predicates:\n+        InternedSet<'tcx, List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>>>,\n     predicate: InternedSet<'tcx, PredicateInner<'tcx>>,\n     predicates: InternedSet<'tcx, List<Predicate<'tcx>>>,\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n     place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n     const_: InternedSet<'tcx, Const<'tcx>>,\n     /// Const allocations.\n     allocation: InternedSet<'tcx, Allocation>,\n+    bound_variable_kinds: InternedSet<'tcx, List<ty::BoundVariableKind>>,\n }\n \n impl<'tcx> CtxtInterners<'tcx> {\n@@ -113,6 +115,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n             place_elems: Default::default(),\n             const_: Default::default(),\n             allocation: Default::default(),\n+            bound_variable_kinds: Default::default(),\n         }\n     }\n \n@@ -136,7 +139,10 @@ impl<'tcx> CtxtInterners<'tcx> {\n     }\n \n     #[inline(never)]\n-    fn intern_predicate(&self, kind: Binder<PredicateKind<'tcx>>) -> &'tcx PredicateInner<'tcx> {\n+    fn intern_predicate(\n+        &self,\n+        kind: Binder<'tcx, PredicateKind<'tcx>>,\n+    ) -> &'tcx PredicateInner<'tcx> {\n         self.predicate\n             .intern(kind, |kind| {\n                 let flags = super::flags::FlagComputation::for_predicate(kind);\n@@ -449,7 +455,7 @@ pub struct TypeckResults<'tcx> {\n \n     /// Stores the type, expression, span and optional scope span of all types\n     /// that are live across the yield of this generator (if a generator).\n-    pub generator_interior_types: ty::Binder<Vec<GeneratorInteriorTypeCause<'tcx>>>,\n+    pub generator_interior_types: ty::Binder<'tcx, Vec<GeneratorInteriorTypeCause<'tcx>>>,\n \n     /// We sometimes treat byte string literals (which are of type `&[u8; N]`)\n     /// as `&[u8]`, depending on the pattern  in which they are used.\n@@ -789,7 +795,7 @@ impl CanonicalUserType<'tcx> {\n                     return false;\n                 }\n \n-                user_substs.substs.iter().zip(BoundVar::new(0)..).all(|(kind, cvar)| {\n+                iter::zip(user_substs.substs, BoundVar::new(0)..).all(|(kind, cvar)| {\n                     match kind.unpack() {\n                         GenericArgKind::Type(ty) => match ty.kind() {\n                             ty::Bound(debruijn, b) => {\n@@ -804,7 +810,7 @@ impl CanonicalUserType<'tcx> {\n                             ty::ReLateBound(debruijn, br) => {\n                                 // We only allow a `ty::INNERMOST` index in substitutions.\n                                 assert_eq!(*debruijn, ty::INNERMOST);\n-                                cvar == br.assert_bound_var()\n+                                cvar == br.var\n                             }\n                             _ => false,\n                         },\n@@ -1616,10 +1622,11 @@ nop_lift! {allocation; &'a Allocation => &'tcx Allocation}\n nop_lift! {predicate; &'a PredicateInner<'a> => &'tcx PredicateInner<'tcx>}\n \n nop_list_lift! {type_list; Ty<'a> => Ty<'tcx>}\n-nop_list_lift! {poly_existential_predicates; ty::Binder<ExistentialPredicate<'a>> => ty::Binder<ExistentialPredicate<'tcx>>}\n+nop_list_lift! {poly_existential_predicates; ty::Binder<'a, ExistentialPredicate<'a>> => ty::Binder<'tcx, ExistentialPredicate<'tcx>>}\n nop_list_lift! {predicates; Predicate<'a> => Predicate<'tcx>}\n nop_list_lift! {canonical_var_infos; CanonicalVarInfo<'a> => CanonicalVarInfo<'tcx>}\n nop_list_lift! {projs; ProjectionKind => ProjectionKind}\n+nop_list_lift! {bound_variable_kinds; ty::BoundVariableKind => ty::BoundVariableKind}\n \n // This is the impl for `&'a InternalSubsts<'a>`.\n nop_list_lift! {substs; GenericArg<'a> => GenericArg<'tcx>}\n@@ -1965,8 +1972,8 @@ impl<'tcx> Hash for Interned<'tcx, PredicateInner<'tcx>> {\n     }\n }\n \n-impl<'tcx> Borrow<Binder<PredicateKind<'tcx>>> for Interned<'tcx, PredicateInner<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a Binder<PredicateKind<'tcx>> {\n+impl<'tcx> Borrow<Binder<'tcx, PredicateKind<'tcx>>> for Interned<'tcx, PredicateInner<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a Binder<'tcx, PredicateKind<'tcx>> {\n         &self.0.kind\n     }\n }\n@@ -2072,10 +2079,11 @@ slice_interners!(\n     substs: _intern_substs(GenericArg<'tcx>),\n     canonical_var_infos: _intern_canonical_var_infos(CanonicalVarInfo<'tcx>),\n     poly_existential_predicates:\n-        _intern_poly_existential_predicates(ty::Binder<ExistentialPredicate<'tcx>>),\n+        _intern_poly_existential_predicates(ty::Binder<'tcx, ExistentialPredicate<'tcx>>),\n     predicates: _intern_predicates(Predicate<'tcx>),\n     projs: _intern_projs(ProjectionKind),\n     place_elems: _intern_place_elems(PlaceElem<'tcx>),\n+    bound_variable_kinds: _intern_bound_variable_kinds(ty::BoundVariableKind),\n );\n \n impl<'tcx> TyCtxt<'tcx> {\n@@ -2158,7 +2166,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_predicate(self, binder: Binder<PredicateKind<'tcx>>) -> Predicate<'tcx> {\n+    pub fn mk_predicate(self, binder: Binder<'tcx, PredicateKind<'tcx>>) -> Predicate<'tcx> {\n         let inner = self.interners.intern_predicate(binder);\n         Predicate { inner }\n     }\n@@ -2167,7 +2175,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn reuse_or_mk_predicate(\n         self,\n         pred: Predicate<'tcx>,\n-        binder: Binder<PredicateKind<'tcx>>,\n+        binder: Binder<'tcx, PredicateKind<'tcx>>,\n     ) -> Predicate<'tcx> {\n         if pred.kind() != binder { self.mk_predicate(binder) } else { pred }\n     }\n@@ -2288,11 +2296,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_ptr(TypeAndMut { ty, mutbl: hir::Mutability::Not })\n     }\n \n-    #[inline]\n-    pub fn mk_nil_ptr(self) -> Ty<'tcx> {\n-        self.mk_imm_ptr(self.mk_unit())\n-    }\n-\n     #[inline]\n     pub fn mk_array(self, ty: Ty<'tcx>, n: u64) -> Ty<'tcx> {\n         self.mk_ty(Array(ty, ty::Const::from_usize(self, n)))\n@@ -2339,7 +2342,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     #[inline]\n     pub fn mk_dynamic(\n         self,\n-        obj: &'tcx List<ty::Binder<ExistentialPredicate<'tcx>>>,\n+        obj: &'tcx List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>>,\n         reg: ty::Region<'tcx>,\n     ) -> Ty<'tcx> {\n         self.mk_ty(Dynamic(obj, reg))\n@@ -2366,7 +2369,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_generator_witness(self, types: ty::Binder<&'tcx List<Ty<'tcx>>>) -> Ty<'tcx> {\n+    pub fn mk_generator_witness(self, types: ty::Binder<'tcx, &'tcx List<Ty<'tcx>>>) -> Ty<'tcx> {\n         self.mk_ty(GeneratorWitness(types))\n     }\n \n@@ -2471,8 +2474,8 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     pub fn intern_poly_existential_predicates(\n         self,\n-        eps: &[ty::Binder<ExistentialPredicate<'tcx>>],\n-    ) -> &'tcx List<ty::Binder<ExistentialPredicate<'tcx>>> {\n+        eps: &[ty::Binder<'tcx, ExistentialPredicate<'tcx>>],\n+    ) -> &'tcx List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>> {\n         assert!(!eps.is_empty());\n         assert!(\n             eps.array_windows()\n@@ -2517,6 +2520,13 @@ impl<'tcx> TyCtxt<'tcx> {\n         if ts.is_empty() { List::empty() } else { self._intern_canonical_var_infos(ts) }\n     }\n \n+    pub fn intern_bound_variable_kinds(\n+        self,\n+        ts: &[ty::BoundVariableKind],\n+    ) -> &'tcx List<ty::BoundVariableKind> {\n+        if ts.is_empty() { List::empty() } else { self._intern_bound_variable_kinds(ts) }\n+    }\n+\n     pub fn mk_fn_sig<I>(\n         self,\n         inputs: I,\n@@ -2538,8 +2548,8 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     pub fn mk_poly_existential_predicates<\n         I: InternAs<\n-            [ty::Binder<ExistentialPredicate<'tcx>>],\n-            &'tcx List<ty::Binder<ExistentialPredicate<'tcx>>>,\n+            [ty::Binder<'tcx, ExistentialPredicate<'tcx>>],\n+            &'tcx List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>>,\n         >,\n     >(\n         self,\n@@ -2577,6 +2587,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_substs(iter::once(self_ty.into()).chain(rest.iter().cloned()))\n     }\n \n+    pub fn mk_bound_variable_kinds<\n+        I: InternAs<[ty::BoundVariableKind], &'tcx List<ty::BoundVariableKind>>,\n+    >(\n+        self,\n+        iter: I,\n+    ) -> I::Output {\n+        iter.intern_with(|xs| self.intern_bound_variable_kinds(xs))\n+    }\n+\n     /// Walks upwards from `id` to find a node which might change lint levels with attributes.\n     /// It stops at `bound` and just returns it if reached.\n     pub fn maybe_lint_level_root_bounded(self, mut id: HirId, bound: HirId) -> HirId {\n@@ -2653,6 +2672,17 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn object_lifetime_defaults(self, id: HirId) -> Option<Vec<ObjectLifetimeDefault>> {\n         self.object_lifetime_defaults_map(id.owner)\n     }\n+\n+    pub fn late_bound_vars(self, id: HirId) -> &'tcx List<ty::BoundVariableKind> {\n+        self.mk_bound_variable_kinds(\n+            self.late_bound_vars_map(id.owner)\n+                .and_then(|map| map.get(&id.local_id).cloned())\n+                .unwrap_or_else(|| {\n+                    bug!(\"No bound vars found for {:?} ({:?})\", self.hir().node_to_string(id), id)\n+                })\n+                .iter(),\n+        )\n+    }\n }\n \n impl TyCtxtAt<'tcx> {"}, {"sha": "759d1a017aa2a0cf5e192cce45405ff8e502a862", "filename": "compiler/rustc_middle/src/ty/erase_regions.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,3 +1,4 @@\n+use crate::mir;\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n use crate::ty::{self, Ty, TyCtxt, TypeFlags};\n \n@@ -43,7 +44,7 @@ impl TypeFolder<'tcx> for RegionEraserVisitor<'tcx> {\n         if ty.needs_infer() { ty.super_fold_with(self) } else { self.tcx.erase_regions_ty(ty) }\n     }\n \n-    fn fold_binder<T>(&mut self, t: ty::Binder<T>) -> ty::Binder<T>\n+    fn fold_binder<T>(&mut self, t: ty::Binder<'tcx, T>) -> ty::Binder<'tcx, T>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -65,4 +66,8 @@ impl TypeFolder<'tcx> for RegionEraserVisitor<'tcx> {\n             _ => self.tcx.lifetimes.re_erased,\n         }\n     }\n+\n+    fn fold_mir_const(&mut self, c: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx> {\n+        c.super_fold_with(self)\n+    }\n }"}, {"sha": "d295b17d902aa4c6f5cf26ad22287f5dae0aaf66", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -57,7 +57,9 @@ pub enum TypeError<'tcx> {\n     CyclicTy(Ty<'tcx>),\n     CyclicConst(&'tcx ty::Const<'tcx>),\n     ProjectionMismatched(ExpectedFound<DefId>),\n-    ExistentialMismatch(ExpectedFound<&'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>>),\n+    ExistentialMismatch(\n+        ExpectedFound<&'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>>,\n+    ),\n     ObjectUnsafeCoercion(DefId),\n     ConstMismatch(ExpectedFound<&'tcx ty::Const<'tcx>>),\n \n@@ -509,13 +511,18 @@ impl<T> Trait<T> for X {\n                             \"consider constraining the associated type `{}` to `{}`\",\n                             values.found, values.expected,\n                         );\n-                        if !self.suggest_constraint(\n+                        if !(self.suggest_constraining_opaque_associated_type(\n+                            db,\n+                            &msg,\n+                            proj_ty,\n+                            values.expected,\n+                        ) || self.suggest_constraint(\n                             db,\n                             &msg,\n                             body_owner_def_id,\n                             proj_ty,\n                             values.expected,\n-                        ) {\n+                        )) {\n                             db.help(&msg);\n                             db.note(\n                                 \"for more information, visit \\\n@@ -699,20 +706,7 @@ impl<T> Trait<T> for X {\n             }\n         }\n \n-        if let ty::Opaque(def_id, _) = *proj_ty.self_ty().kind() {\n-            // When the expected `impl Trait` is not defined in the current item, it will come from\n-            // a return type. This can occur when dealing with `TryStream` (#71035).\n-            if self.constrain_associated_type_structured_suggestion(\n-                db,\n-                self.def_span(def_id),\n-                &assoc,\n-                proj_ty.trait_ref_and_own_substs(self).1,\n-                values.found,\n-                &msg,\n-            ) {\n-                return;\n-            }\n-        }\n+        self.suggest_constraining_opaque_associated_type(db, &msg, proj_ty, values.found);\n \n         if self.point_at_associated_type(db, body_owner_def_id, values.found) {\n             return;\n@@ -750,6 +744,30 @@ fn foo(&self) -> Self::T { String::new() }\n         }\n     }\n \n+    /// When the expected `impl Trait` is not defined in the current item, it will come from\n+    /// a return type. This can occur when dealing with `TryStream` (#71035).\n+    fn suggest_constraining_opaque_associated_type(\n+        self,\n+        db: &mut DiagnosticBuilder<'_>,\n+        msg: &str,\n+        proj_ty: &ty::ProjectionTy<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> bool {\n+        let assoc = self.associated_item(proj_ty.item_def_id);\n+        if let ty::Opaque(def_id, _) = *proj_ty.self_ty().kind() {\n+            self.constrain_associated_type_structured_suggestion(\n+                db,\n+                self.def_span(def_id),\n+                &assoc,\n+                proj_ty.trait_ref_and_own_substs(self).1,\n+                ty,\n+                &msg,\n+            )\n+        } else {\n+            false\n+        }\n+    }\n+\n     fn point_at_methods_that_satisfy_associated_type(\n         self,\n         db: &mut DiagnosticBuilder<'_>,"}, {"sha": "01bc5cc761ca67275c4fe9bf64e23cf6982b570d", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -22,7 +22,7 @@ impl FlagComputation {\n         result\n     }\n \n-    pub fn for_predicate(binder: ty::Binder<ty::PredicateKind<'_>>) -> FlagComputation {\n+    pub fn for_predicate(binder: ty::Binder<'tcx, ty::PredicateKind<'_>>) -> FlagComputation {\n         let mut result = FlagComputation::new();\n         result.add_predicate(binder);\n         result\n@@ -53,7 +53,7 @@ impl FlagComputation {\n \n     /// Adds the flags/depth from a set of types that appear within the current type, but within a\n     /// region binder.\n-    fn bound_computation<T, F>(&mut self, value: ty::Binder<T>, f: F)\n+    fn bound_computation<T, F>(&mut self, value: ty::Binder<'_, T>, f: F)\n     where\n         F: FnOnce(&mut Self, T),\n     {\n@@ -204,7 +204,7 @@ impl FlagComputation {\n         }\n     }\n \n-    fn add_predicate(&mut self, binder: ty::Binder<ty::PredicateKind<'_>>) {\n+    fn add_predicate(&mut self, binder: ty::Binder<'tcx, ty::PredicateKind<'_>>) {\n         self.bound_computation(binder, |computation, atom| computation.add_predicate_atom(atom));\n     }\n "}, {"sha": "13f2d83ddf3ba5cdddd1e9faf9afe9e3616f492b", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 270, "deletions": 21, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -30,11 +30,13 @@\n //!\n //! These methods return true to indicate that the visitor has found what it is\n //! looking for, and does not need to visit anything else.\n+use crate::mir;\n use crate::ty::{self, flags::FlagComputation, Binder, Ty, TyCtxt, TypeFlags};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n \n use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::sso::SsoHashSet;\n use std::collections::BTreeMap;\n use std::fmt;\n use std::ops::ControlFlow;\n@@ -161,7 +163,7 @@ impl TypeFoldable<'tcx> for hir::Constness {\n pub trait TypeFolder<'tcx>: Sized {\n     fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;\n \n-    fn fold_binder<T>(&mut self, t: Binder<T>) -> Binder<T>\n+    fn fold_binder<T>(&mut self, t: Binder<'tcx, T>) -> Binder<'tcx, T>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -179,12 +181,19 @@ pub trait TypeFolder<'tcx>: Sized {\n     fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         c.super_fold_with(self)\n     }\n+\n+    fn fold_mir_const(&mut self, c: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx> {\n+        bug!(\"most type folders should not be folding MIR datastructures: {:?}\", c)\n+    }\n }\n \n pub trait TypeVisitor<'tcx>: Sized {\n     type BreakTy = !;\n \n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> ControlFlow<Self::BreakTy> {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: &Binder<'tcx, T>,\n+    ) -> ControlFlow<Self::BreakTy> {\n         t.super_visit_with(self)\n     }\n \n@@ -322,7 +331,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n             fn visit_binder<T: TypeFoldable<'tcx>>(\n                 &mut self,\n-                t: &Binder<T>,\n+                t: &Binder<'tcx, T>,\n             ) -> ControlFlow<Self::BreakTy> {\n                 self.outer_index.shift_in(1);\n                 let result = t.as_ref().skip_binder().visit_with(self);\n@@ -400,7 +409,10 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: ty::Binder<T>) -> ty::Binder<T> {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: ty::Binder<'tcx, T>,\n+    ) -> ty::Binder<'tcx, T> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n@@ -460,7 +472,10 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BoundVarReplacer<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: ty::Binder<T>) -> ty::Binder<T> {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: ty::Binder<'tcx, T>,\n+    ) -> ty::Binder<'tcx, T> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n@@ -538,7 +553,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// contain escaping bound types.\n     pub fn replace_late_bound_regions<T, F>(\n         self,\n-        value: Binder<T>,\n+        value: Binder<'tcx, T>,\n         mut fld_r: F,\n     ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n     where\n@@ -588,7 +603,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// types.\n     pub fn replace_bound_vars<T, F, G, H>(\n         self,\n-        value: Binder<T>,\n+        value: Binder<'tcx, T>,\n         mut fld_r: F,\n         fld_t: G,\n         fld_c: H,\n@@ -607,7 +622,11 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Replaces any late-bound regions bound in `value` with\n     /// free variants attached to `all_outlive_scope`.\n-    pub fn liberate_late_bound_regions<T>(self, all_outlive_scope: DefId, value: ty::Binder<T>) -> T\n+    pub fn liberate_late_bound_regions<T>(\n+        self,\n+        all_outlive_scope: DefId,\n+        value: ty::Binder<'tcx, T>,\n+    ) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -620,13 +639,49 @@ impl<'tcx> TyCtxt<'tcx> {\n         .0\n     }\n \n+    pub fn shift_bound_var_indices<T>(self, bound_vars: usize, value: T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        self.replace_escaping_bound_vars(\n+            value,\n+            |r| {\n+                self.mk_region(ty::ReLateBound(\n+                    ty::INNERMOST,\n+                    ty::BoundRegion {\n+                        var: ty::BoundVar::from_usize(r.var.as_usize() + bound_vars),\n+                        kind: r.kind,\n+                    },\n+                ))\n+            },\n+            |t| {\n+                self.mk_ty(ty::Bound(\n+                    ty::INNERMOST,\n+                    ty::BoundTy {\n+                        var: ty::BoundVar::from_usize(t.var.as_usize() + bound_vars),\n+                        kind: t.kind,\n+                    },\n+                ))\n+            },\n+            |c, ty| {\n+                self.mk_const(ty::Const {\n+                    val: ty::ConstKind::Bound(\n+                        ty::INNERMOST,\n+                        ty::BoundVar::from_usize(c.as_usize() + bound_vars),\n+                    ),\n+                    ty,\n+                })\n+            },\n+        )\n+    }\n+\n     /// Returns a set of all late-bound regions that are constrained\n     /// by `value`, meaning that if we instantiate those LBR with\n     /// variables and equate `value` with something else, those\n     /// variables will also be equated.\n     pub fn collect_constrained_late_bound_regions<T>(\n         self,\n-        value: &Binder<T>,\n+        value: &Binder<'tcx, T>,\n     ) -> FxHashSet<ty::BoundRegionKind>\n     where\n         T: TypeFoldable<'tcx>,\n@@ -637,7 +692,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Returns a set of all late-bound regions that appear in `value` anywhere.\n     pub fn collect_referenced_late_bound_regions<T>(\n         self,\n-        value: &Binder<T>,\n+        value: &Binder<'tcx, T>,\n     ) -> FxHashSet<ty::BoundRegionKind>\n     where\n         T: TypeFoldable<'tcx>,\n@@ -647,7 +702,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     fn collect_late_bound_regions<T>(\n         self,\n-        value: &Binder<T>,\n+        value: &Binder<'tcx, T>,\n         just_constraint: bool,\n     ) -> FxHashSet<ty::BoundRegionKind>\n     where\n@@ -661,7 +716,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Replaces any late-bound regions bound in `value` with `'erased`. Useful in codegen but also\n     /// method lookup and a few other places where precise region relationships are not required.\n-    pub fn erase_late_bound_regions<T>(self, value: Binder<T>) -> T\n+    pub fn erase_late_bound_regions<T>(self, value: Binder<'tcx, T>) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -676,20 +731,205 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// `FnSig`s or `TraitRef`s which are equivalent up to region naming will become\n     /// structurally identical. For example, `for<'a, 'b> fn(&'a isize, &'b isize)` and\n     /// `for<'a, 'b> fn(&'b isize, &'a isize)` will become identical after anonymization.\n-    pub fn anonymize_late_bound_regions<T>(self, sig: Binder<T>) -> Binder<T>\n+    pub fn anonymize_late_bound_regions<T>(self, sig: Binder<'tcx, T>) -> Binder<'tcx, T>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         let mut counter = 0;\n-        Binder::bind(\n-            self.replace_late_bound_regions(sig, |_| {\n-                let br = ty::BoundRegion { kind: ty::BrAnon(counter) };\n+        let inner = self\n+            .replace_late_bound_regions(sig, |_| {\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_u32(counter),\n+                    kind: ty::BrAnon(counter),\n+                };\n                 let r = self.mk_region(ty::ReLateBound(ty::INNERMOST, br));\n                 counter += 1;\n                 r\n             })\n-            .0,\n-        )\n+            .0;\n+        let bound_vars = self.mk_bound_variable_kinds(\n+            (0..counter).map(|i| ty::BoundVariableKind::Region(ty::BrAnon(i))),\n+        );\n+        Binder::bind_with_vars(inner, bound_vars)\n+    }\n+}\n+\n+pub struct BoundVarsCollector<'tcx> {\n+    binder_index: ty::DebruijnIndex,\n+    vars: BTreeMap<u32, ty::BoundVariableKind>,\n+    // We may encounter the same variable at different levels of binding, so\n+    // this can't just be `Ty`\n+    visited: SsoHashSet<(ty::DebruijnIndex, Ty<'tcx>)>,\n+}\n+\n+impl<'tcx> BoundVarsCollector<'tcx> {\n+    pub fn new() -> Self {\n+        BoundVarsCollector {\n+            binder_index: ty::INNERMOST,\n+            vars: BTreeMap::new(),\n+            visited: SsoHashSet::default(),\n+        }\n+    }\n+\n+    pub fn into_vars(self, tcx: TyCtxt<'tcx>) -> &'tcx ty::List<ty::BoundVariableKind> {\n+        let max = self.vars.iter().map(|(k, _)| *k).max().unwrap_or_else(|| 0);\n+        for i in 0..max {\n+            if let None = self.vars.get(&i) {\n+                panic!(\"Unknown variable: {:?}\", i);\n+            }\n+        }\n+\n+        tcx.mk_bound_variable_kinds(self.vars.into_iter().map(|(_, v)| v))\n+    }\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n+    type BreakTy = ();\n+\n+    fn visit_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: &Binder<'tcx, T>,\n+    ) -> ControlFlow<Self::BreakTy> {\n+        self.binder_index.shift_in(1);\n+        let result = t.super_visit_with(self);\n+        self.binder_index.shift_out(1);\n+        result\n+    }\n+\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        if t.outer_exclusive_binder < self.binder_index\n+            || !self.visited.insert((self.binder_index, t))\n+        {\n+            return ControlFlow::CONTINUE;\n+        }\n+        use std::collections::btree_map::Entry;\n+        match *t.kind() {\n+            ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n+                match self.vars.entry(bound_ty.var.as_u32()) {\n+                    Entry::Vacant(entry) => {\n+                        entry.insert(ty::BoundVariableKind::Ty(bound_ty.kind));\n+                    }\n+                    Entry::Occupied(entry) => match entry.get() {\n+                        ty::BoundVariableKind::Ty(_) => {}\n+                        _ => bug!(\"Conflicting bound vars\"),\n+                    },\n+                }\n+            }\n+\n+            _ => (),\n+        };\n+\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        match r {\n+            ty::ReLateBound(index, _br) if *index == self.binder_index => {\n+                // If you hit this, you should be using `Binder::bind_with_vars` or `Binder::rebind`\n+                bug!(\"Trying to collect bound vars with a bound region: {:?} {:?}\", index, _br)\n+            }\n+\n+            _ => (),\n+        };\n+\n+        r.super_visit_with(self)\n+    }\n+}\n+\n+pub struct ValidateBoundVars<'tcx> {\n+    bound_vars: &'tcx ty::List<ty::BoundVariableKind>,\n+    binder_index: ty::DebruijnIndex,\n+    // We may encounter the same variable at different levels of binding, so\n+    // this can't just be `Ty`\n+    visited: SsoHashSet<(ty::DebruijnIndex, Ty<'tcx>)>,\n+}\n+\n+impl<'tcx> ValidateBoundVars<'tcx> {\n+    pub fn new(bound_vars: &'tcx ty::List<ty::BoundVariableKind>) -> Self {\n+        ValidateBoundVars {\n+            bound_vars,\n+            binder_index: ty::INNERMOST,\n+            visited: SsoHashSet::default(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for ValidateBoundVars<'tcx> {\n+    type BreakTy = ();\n+\n+    fn visit_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: &Binder<'tcx, T>,\n+    ) -> ControlFlow<Self::BreakTy> {\n+        self.binder_index.shift_in(1);\n+        let result = t.super_visit_with(self);\n+        self.binder_index.shift_out(1);\n+        result\n+    }\n+\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        if t.outer_exclusive_binder < self.binder_index\n+            || !self.visited.insert((self.binder_index, t))\n+        {\n+            return ControlFlow::BREAK;\n+        }\n+        match *t.kind() {\n+            ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n+                if self.bound_vars.len() <= bound_ty.var.as_usize() {\n+                    bug!(\"Not enough bound vars: {:?} not found in {:?}\", t, self.bound_vars);\n+                }\n+                let list_var = self.bound_vars[bound_ty.var.as_usize()];\n+                match list_var {\n+                    ty::BoundVariableKind::Ty(kind) => {\n+                        if kind != bound_ty.kind {\n+                            bug!(\n+                                \"Mismatched type kinds: {:?} doesn't var in list {:?}\",\n+                                bound_ty.kind,\n+                                list_var\n+                            );\n+                        }\n+                    }\n+                    _ => {\n+                        bug!(\"Mismatched bound variable kinds! Expected type, found {:?}\", list_var)\n+                    }\n+                }\n+            }\n+\n+            _ => (),\n+        };\n+\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        match r {\n+            ty::ReLateBound(index, br) if *index == self.binder_index => {\n+                if self.bound_vars.len() <= br.var.as_usize() {\n+                    bug!(\"Not enough bound vars: {:?} not found in {:?}\", *br, self.bound_vars);\n+                }\n+                let list_var = self.bound_vars[br.var.as_usize()];\n+                match list_var {\n+                    ty::BoundVariableKind::Region(kind) => {\n+                        if kind != br.kind {\n+                            bug!(\n+                                \"Mismatched region kinds: {:?} doesn't match var ({:?}) in list ({:?})\",\n+                                br.kind,\n+                                list_var,\n+                                self.bound_vars\n+                            );\n+                        }\n+                    }\n+                    _ => bug!(\n+                        \"Mismatched bound variable kinds! Expected region, found {:?}\",\n+                        list_var\n+                    ),\n+                }\n+            }\n+\n+            _ => (),\n+        };\n+\n+        r.super_visit_with(self)\n     }\n }\n \n@@ -719,7 +959,10 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: ty::Binder<T>) -> ty::Binder<T> {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: ty::Binder<'tcx, T>,\n+    ) -> ty::Binder<'tcx, T> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n@@ -828,7 +1071,10 @@ struct HasEscapingVarsVisitor {\n impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n     type BreakTy = FoundEscapingVars;\n \n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> ControlFlow<Self::BreakTy> {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: &Binder<'tcx, T>,\n+    ) -> ControlFlow<Self::BreakTy> {\n         self.outer_index.shift_in(1);\n         let result = t.super_visit_with(self);\n         self.outer_index.shift_out(1);\n@@ -974,7 +1220,10 @@ impl LateBoundRegionsCollector {\n }\n \n impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> ControlFlow<Self::BreakTy> {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: &Binder<'tcx, T>,\n+    ) -> ControlFlow<Self::BreakTy> {\n         self.current_index.shift_in(1);\n         let result = t.super_visit_with(self);\n         self.current_index.shift_out(1);"}, {"sha": "41d953216e0dd1425d2b59d465c4720c2e57ebdf", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -216,9 +216,10 @@ impl<'tcx> InstanceDef<'tcx> {\n             // drops of `Option::None` before LTO. We also respect the intent of\n             // `#[inline]` on `Drop::drop` implementations.\n             return ty.ty_adt_def().map_or(true, |adt_def| {\n-                adt_def.destructor(tcx).map_or(adt_def.is_enum(), |dtor| {\n-                    tcx.codegen_fn_attrs(dtor.did).requests_inline()\n-                })\n+                adt_def.destructor(tcx).map_or_else(\n+                    || adt_def.is_enum(),\n+                    |dtor| tcx.codegen_fn_attrs(dtor.did).requests_inline(),\n+                )\n             });\n         }\n         tcx.codegen_fn_attrs(self.def_id()).requests_inline()\n@@ -482,6 +483,7 @@ impl<'tcx> Instance<'tcx> {\n         if let Some(substs) = self.substs_for_mir_body() { v.subst(tcx, substs) } else { *v }\n     }\n \n+    #[inline(always)]\n     pub fn subst_mir_and_normalize_erasing_regions<T>(\n         &self,\n         tcx: TyCtxt<'tcx>,"}, {"sha": "e7bbdc3ccebdf4adfd4e2c3554488109a5a0b59e", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,3 +1,4 @@\n+// ignore-tidy-filelength\n use crate::ich::StableHashingContext;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::mir::{GeneratorLayout, GeneratorSavedLocal};\n@@ -1251,13 +1252,13 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 } else {\n                     // Try to use a ScalarPair for all tagged enums.\n                     let mut common_prim = None;\n-                    for (field_layouts, layout_variant) in variants.iter().zip(&layout_variants) {\n+                    for (field_layouts, layout_variant) in iter::zip(&variants, &layout_variants) {\n                         let offsets = match layout_variant.fields {\n                             FieldsShape::Arbitrary { ref offsets, .. } => offsets,\n                             _ => bug!(),\n                         };\n                         let mut fields =\n-                            field_layouts.iter().zip(offsets).filter(|p| !p.0.is_zst());\n+                            iter::zip(field_layouts, offsets).filter(|p| !p.0.is_zst());\n                         let (field, offset) = match (fields.next(), fields.next()) {\n                             (None, None) => continue,\n                             (Some(pair), None) => pair,\n@@ -1626,7 +1627,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 const INVALID_FIELD_IDX: u32 = !0;\n                 let mut combined_inverse_memory_index =\n                     vec![INVALID_FIELD_IDX; promoted_memory_index.len() + memory_index.len()];\n-                let mut offsets_and_memory_index = offsets.into_iter().zip(memory_index);\n+                let mut offsets_and_memory_index = iter::zip(offsets, memory_index);\n                 let combined_offsets = variant_fields\n                     .iter()\n                     .enumerate()\n@@ -2481,21 +2482,42 @@ impl<'tcx> ty::Instance<'tcx> {\n             ty::Closure(def_id, substs) => {\n                 let sig = substs.as_closure().sig();\n \n-                let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n-                sig.map_bound(|sig| {\n+                let bound_vars = tcx.mk_bound_variable_kinds(\n+                    sig.bound_vars()\n+                        .iter()\n+                        .chain(iter::once(ty::BoundVariableKind::Region(ty::BrEnv))),\n+                );\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_usize(bound_vars.len() - 1),\n+                    kind: ty::BoundRegionKind::BrEnv,\n+                };\n+                let env_region = ty::ReLateBound(ty::INNERMOST, br);\n+                let env_ty = tcx.closure_env_ty(def_id, substs, env_region).unwrap();\n+\n+                let sig = sig.skip_binder();\n+                ty::Binder::bind_with_vars(\n                     tcx.mk_fn_sig(\n-                        iter::once(env_ty.skip_binder()).chain(sig.inputs().iter().cloned()),\n+                        iter::once(env_ty).chain(sig.inputs().iter().cloned()),\n                         sig.output(),\n                         sig.c_variadic,\n                         sig.unsafety,\n                         sig.abi,\n-                    )\n-                })\n+                    ),\n+                    bound_vars,\n+                )\n             }\n             ty::Generator(_, substs, _) => {\n                 let sig = substs.as_generator().poly_sig();\n \n-                let br = ty::BoundRegion { kind: ty::BrEnv };\n+                let bound_vars = tcx.mk_bound_variable_kinds(\n+                    sig.bound_vars()\n+                        .iter()\n+                        .chain(iter::once(ty::BoundVariableKind::Region(ty::BrEnv))),\n+                );\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_usize(bound_vars.len() - 1),\n+                    kind: ty::BoundRegionKind::BrEnv,\n+                };\n                 let env_region = ty::ReLateBound(ty::INNERMOST, br);\n                 let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n \n@@ -2504,21 +2526,21 @@ impl<'tcx> ty::Instance<'tcx> {\n                 let pin_substs = tcx.intern_substs(&[env_ty.into()]);\n                 let env_ty = tcx.mk_adt(pin_adt_ref, pin_substs);\n \n-                sig.map_bound(|sig| {\n-                    let state_did = tcx.require_lang_item(LangItem::GeneratorState, None);\n-                    let state_adt_ref = tcx.adt_def(state_did);\n-                    let state_substs =\n-                        tcx.intern_substs(&[sig.yield_ty.into(), sig.return_ty.into()]);\n-                    let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n-\n+                let sig = sig.skip_binder();\n+                let state_did = tcx.require_lang_item(LangItem::GeneratorState, None);\n+                let state_adt_ref = tcx.adt_def(state_did);\n+                let state_substs = tcx.intern_substs(&[sig.yield_ty.into(), sig.return_ty.into()]);\n+                let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n+                ty::Binder::bind_with_vars(\n                     tcx.mk_fn_sig(\n                         [env_ty, sig.resume_ty].iter(),\n                         &ret_ty,\n                         false,\n                         hir::Unsafety::Normal,\n                         rustc_target::spec::abi::Abi::Rust,\n-                    )\n-                })\n+                    ),\n+                    bound_vars,\n+                )\n             }\n             _ => bug!(\"unexpected type {:?} in Instance::fn_sig\", ty),\n         }"}, {"sha": "6574c9382604b1ec894007c6a265f4081bcf0c56", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 51, "deletions": 42, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -67,12 +67,12 @@ pub use self::sty::BoundRegionKind::*;\n pub use self::sty::RegionKind::*;\n pub use self::sty::TyKind::*;\n pub use self::sty::{\n-    Binder, BoundRegion, BoundRegionKind, BoundTy, BoundTyKind, BoundVar, CanonicalPolyFnSig,\n-    ClosureSubsts, ClosureSubstsParts, ConstVid, EarlyBoundRegion, ExistentialPredicate,\n-    ExistentialProjection, ExistentialTraitRef, FnSig, FreeRegion, GenSig, GeneratorSubsts,\n-    GeneratorSubstsParts, ParamConst, ParamTy, PolyExistentialProjection, PolyExistentialTraitRef,\n-    PolyFnSig, PolyGenSig, PolyTraitRef, ProjectionTy, Region, RegionKind, RegionVid, TraitRef,\n-    TyKind, TypeAndMut, UpvarSubsts,\n+    Binder, BoundRegion, BoundRegionKind, BoundTy, BoundTyKind, BoundVar, BoundVariableKind,\n+    CanonicalPolyFnSig, ClosureSubsts, ClosureSubstsParts, ConstVid, EarlyBoundRegion,\n+    ExistentialPredicate, ExistentialProjection, ExistentialTraitRef, FnSig, FreeRegion, GenSig,\n+    GeneratorSubsts, GeneratorSubstsParts, ParamConst, ParamTy, PolyExistentialProjection,\n+    PolyExistentialTraitRef, PolyFnSig, PolyGenSig, PolyTraitRef, ProjectionTy, Region, RegionKind,\n+    RegionVid, TraitRef, TyKind, TypeAndMut, UpvarSubsts,\n };\n pub use self::trait_def::TraitDef;\n \n@@ -302,7 +302,7 @@ impl<'tcx> TyS<'tcx> {\n \n // `TyS` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(TyS<'_>, 32);\n+static_assert_size!(TyS<'_>, 40);\n \n impl<'tcx> Ord for TyS<'tcx> {\n     fn cmp(&self, other: &TyS<'tcx>) -> Ordering {\n@@ -359,14 +359,14 @@ impl ty::EarlyBoundRegion {\n \n #[derive(Debug)]\n crate struct PredicateInner<'tcx> {\n-    kind: Binder<PredicateKind<'tcx>>,\n+    kind: Binder<'tcx, PredicateKind<'tcx>>,\n     flags: TypeFlags,\n     /// See the comment for the corresponding field of [TyS].\n     outer_exclusive_binder: ty::DebruijnIndex,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(PredicateInner<'_>, 40);\n+static_assert_size!(PredicateInner<'_>, 48);\n \n #[derive(Clone, Copy, Lift)]\n pub struct Predicate<'tcx> {\n@@ -389,9 +389,9 @@ impl Hash for Predicate<'_> {\n impl<'tcx> Eq for Predicate<'tcx> {}\n \n impl<'tcx> Predicate<'tcx> {\n-    /// Gets the inner `Binder<PredicateKind<'tcx>>`.\n+    /// Gets the inner `Binder<'tcx, PredicateKind<'tcx>>`.\n     #[inline]\n-    pub fn kind(self) -> Binder<PredicateKind<'tcx>> {\n+    pub fn kind(self) -> Binder<'tcx, PredicateKind<'tcx>> {\n         self.inner.kind\n     }\n }\n@@ -543,10 +543,33 @@ impl<'tcx> Predicate<'tcx> {\n         // substitution code expects equal binding levels in the values\n         // from the substitution and the value being substituted into, and\n         // this trick achieves that).\n-        let substs = trait_ref.skip_binder().substs;\n-        let pred = self.kind().skip_binder();\n-        let new = pred.subst(tcx, substs);\n-        tcx.reuse_or_mk_predicate(self, ty::Binder::bind(new))\n+\n+        // Working through the second example:\n+        // trait_ref: for<'x> T: Foo1<'^0.0>; substs: [T, '^0.0]\n+        // predicate: for<'b> Self: Bar1<'a, '^0.0>; substs: [Self, 'a, '^0.0]\n+        // We want to end up with:\n+        //     for<'x, 'b> T: Bar1<'^0.0, '^0.1>\n+        // To do this:\n+        // 1) We must shift all bound vars in predicate by the length\n+        //    of trait ref's bound vars. So, we would end up with predicate like\n+        //    Self: Bar1<'a, '^0.1>\n+        // 2) We can then apply the trait substs to this, ending up with\n+        //    T: Bar1<'^0.0, '^0.1>\n+        // 3) Finally, to create the final bound vars, we concatenate the bound\n+        //    vars of the trait ref with those of the predicate:\n+        //    ['x, 'b]\n+        let bound_pred = self.kind();\n+        let pred_bound_vars = bound_pred.bound_vars();\n+        let trait_bound_vars = trait_ref.bound_vars();\n+        // 1) Self: Bar1<'a, '^0.0> -> Self: Bar1<'a, '^0.1>\n+        let shifted_pred =\n+            tcx.shift_bound_var_indices(trait_bound_vars.len(), bound_pred.skip_binder());\n+        // 2) Self: Bar1<'a, '^0.1> -> T: Bar1<'^0.0, '^0.1>\n+        let new = shifted_pred.subst(tcx, trait_ref.skip_binder().substs);\n+        // 3) ['x] + ['b] -> ['x, 'b]\n+        let bound_vars =\n+            tcx.mk_bound_variable_kinds(trait_bound_vars.iter().chain(pred_bound_vars));\n+        tcx.reuse_or_mk_predicate(self, ty::Binder::bind_with_vars(new, bound_vars))\n     }\n }\n \n@@ -556,7 +579,7 @@ pub struct TraitPredicate<'tcx> {\n     pub trait_ref: TraitRef<'tcx>,\n }\n \n-pub type PolyTraitPredicate<'tcx> = ty::Binder<TraitPredicate<'tcx>>;\n+pub type PolyTraitPredicate<'tcx> = ty::Binder<'tcx, TraitPredicate<'tcx>>;\n \n impl<'tcx> TraitPredicate<'tcx> {\n     pub fn def_id(self) -> DefId {\n@@ -574,7 +597,7 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n         self.skip_binder().def_id()\n     }\n \n-    pub fn self_ty(self) -> ty::Binder<Ty<'tcx>> {\n+    pub fn self_ty(self) -> ty::Binder<'tcx, Ty<'tcx>> {\n         self.map_bound(|trait_ref| trait_ref.self_ty())\n     }\n }\n@@ -584,8 +607,8 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n pub struct OutlivesPredicate<A, B>(pub A, pub B); // `A: B`\n pub type RegionOutlivesPredicate<'tcx> = OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>;\n pub type TypeOutlivesPredicate<'tcx> = OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>;\n-pub type PolyRegionOutlivesPredicate<'tcx> = ty::Binder<RegionOutlivesPredicate<'tcx>>;\n-pub type PolyTypeOutlivesPredicate<'tcx> = ty::Binder<TypeOutlivesPredicate<'tcx>>;\n+pub type PolyRegionOutlivesPredicate<'tcx> = ty::Binder<'tcx, RegionOutlivesPredicate<'tcx>>;\n+pub type PolyTypeOutlivesPredicate<'tcx> = ty::Binder<'tcx, TypeOutlivesPredicate<'tcx>>;\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n@@ -594,7 +617,7 @@ pub struct SubtypePredicate<'tcx> {\n     pub a: Ty<'tcx>,\n     pub b: Ty<'tcx>,\n }\n-pub type PolySubtypePredicate<'tcx> = ty::Binder<SubtypePredicate<'tcx>>;\n+pub type PolySubtypePredicate<'tcx> = ty::Binder<'tcx, SubtypePredicate<'tcx>>;\n \n /// This kind of predicate has no *direct* correspondent in the\n /// syntax, but it roughly corresponds to the syntactic forms:\n@@ -615,25 +638,15 @@ pub struct ProjectionPredicate<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n-pub type PolyProjectionPredicate<'tcx> = Binder<ProjectionPredicate<'tcx>>;\n+pub type PolyProjectionPredicate<'tcx> = Binder<'tcx, ProjectionPredicate<'tcx>>;\n \n impl<'tcx> PolyProjectionPredicate<'tcx> {\n-    /// Returns the `DefId` of the associated item being projected.\n-    pub fn item_def_id(&self) -> DefId {\n-        self.skip_binder().projection_ty.item_def_id\n-    }\n-\n     /// Returns the `DefId` of the trait of the associated item being projected.\n     #[inline]\n     pub fn trait_def_id(&self, tcx: TyCtxt<'tcx>) -> DefId {\n         self.skip_binder().projection_ty.trait_def_id(tcx)\n     }\n \n-    #[inline]\n-    pub fn projection_self_ty(&self) -> Binder<Ty<'tcx>> {\n-        self.map_bound(|predicate| predicate.projection_ty.self_ty())\n-    }\n-\n     /// Get the [PolyTraitRef] required for this projection to be well formed.\n     /// Note that for generic associated types the predicates of the associated\n     /// type also need to be checked.\n@@ -647,7 +660,7 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n         self.map_bound(|predicate| predicate.projection_ty.trait_ref(tcx))\n     }\n \n-    pub fn ty(&self) -> Binder<Ty<'tcx>> {\n+    pub fn ty(&self) -> Binder<'tcx, Ty<'tcx>> {\n         self.map_bound(|predicate| predicate.ty)\n     }\n \n@@ -681,7 +694,7 @@ pub trait ToPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx>;\n }\n \n-impl ToPredicate<'tcx> for Binder<PredicateKind<'tcx>> {\n+impl ToPredicate<'tcx> for Binder<'tcx, PredicateKind<'tcx>> {\n     #[inline(always)]\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         tcx.mk_predicate(self)\n@@ -704,11 +717,11 @@ impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<TraitRef<'tcx>> {\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitRef<'tcx>> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        ConstnessAnd {\n-            value: self.value.map_bound(|trait_ref| ty::TraitPredicate { trait_ref }),\n-            constness: self.constness,\n-        }\n-        .to_predicate(tcx)\n+        self.value\n+            .map_bound(|trait_ref| {\n+                PredicateKind::Trait(ty::TraitPredicate { trait_ref }, self.constness)\n+            })\n+            .to_predicate(tcx)\n     }\n }\n \n@@ -1039,10 +1052,6 @@ impl WithOptConstParam<DefId> {\n         None\n     }\n \n-    pub fn expect_local(self) -> WithOptConstParam<LocalDefId> {\n-        self.as_local().unwrap()\n-    }\n-\n     pub fn is_local(self) -> bool {\n         self.did.is_local()\n     }"}, {"sha": "a4f736654af44f5438c3bcc12fb6cb5b15b3f803", "filename": "compiler/rustc_middle/src/ty/normalize_erasing_regions.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -7,6 +7,7 @@\n //! `normalize_generic_arg_after_erasing_regions` query for each type\n //! or constant found within. (This underlying query is what is cached.)\n \n+use crate::mir;\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n use crate::ty::subst::{Subst, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt};\n@@ -38,7 +39,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    /// If you have a `Binder<T>`, you can do this to strip out the\n+    /// If you have a `Binder<'tcx, T>`, you can do this to strip out the\n     /// late-bound regions and then normalize the result, yielding up\n     /// a `T` (with regions erased). This is appropriate when the\n     /// binder is being instantiated at the call site.\n@@ -49,7 +50,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn normalize_erasing_late_bound_regions<T>(\n         self,\n         param_env: ty::ParamEnv<'tcx>,\n-        value: ty::Binder<T>,\n+        value: ty::Binder<'tcx, T>,\n     ) -> T\n     where\n         T: TypeFoldable<'tcx>,\n@@ -101,4 +102,10 @@ impl TypeFolder<'tcx> for NormalizeAfterErasingRegionsFolder<'tcx> {\n         let arg = self.param_env.and(c.into());\n         self.tcx.normalize_generic_arg_after_erasing_regions(arg).expect_const()\n     }\n+\n+    #[inline]\n+    fn fold_mir_const(&mut self, c: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx> {\n+        let arg = self.param_env.and(c);\n+        self.tcx.normalize_mir_const_after_erasing_regions(arg)\n+    }\n }"}, {"sha": "13e2122a619dcf3bd097c8ad56cfd207c385c5bc", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -63,7 +63,7 @@ pub trait Printer<'tcx>: Sized {\n \n     fn print_dyn_existential(\n         self,\n-        predicates: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n+        predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n     ) -> Result<Self::DynExistential, Self::Error>;\n \n     fn print_const(self, ct: &'tcx ty::Const<'tcx>) -> Result<Self::Const, Self::Error>;\n@@ -346,7 +346,7 @@ impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for Ty<'tcx> {\n }\n \n impl<'tcx, P: Printer<'tcx>> Print<'tcx, P>\n-    for &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>\n+    for &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>\n {\n     type Output = P::DynExistential;\n     type Error = P::Error;"}, {"sha": "f697cd5193021346926c0e71ab13609889e65a6f", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 61, "deletions": 33, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -4,6 +4,7 @@ use crate::ty::subst::{GenericArg, GenericArgKind, Subst};\n use crate::ty::{self, ConstInt, DefIdTree, ParamConst, ScalarInt, Ty, TyCtxt, TypeFoldable};\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sso::SsoHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::{self, CtorKind, DefKind, Namespace};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdSet, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -19,6 +20,7 @@ use std::char;\n use std::collections::BTreeMap;\n use std::convert::TryFrom;\n use std::fmt::{self, Write as _};\n+use std::iter;\n use std::ops::{ControlFlow, Deref, DerefMut};\n \n // `pretty` is a separate module only for organization.\n@@ -201,7 +203,7 @@ pub trait PrettyPrinter<'tcx>:\n         self.print_def_path(def_id, substs)\n     }\n \n-    fn in_binder<T>(self, value: &ty::Binder<T>) -> Result<Self, Self::Error>\n+    fn in_binder<T>(self, value: &ty::Binder<'tcx, T>) -> Result<Self, Self::Error>\n     where\n         T: Print<'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>,\n     {\n@@ -210,7 +212,7 @@ pub trait PrettyPrinter<'tcx>:\n \n     fn wrap_binder<T, F: Fn(&T, Self) -> Result<Self, fmt::Error>>(\n         self,\n-        value: &ty::Binder<T>,\n+        value: &ty::Binder<'tcx, T>,\n         f: F,\n     ) -> Result<Self, Self::Error>\n     where\n@@ -764,7 +766,7 @@ pub trait PrettyPrinter<'tcx>:\n \n     fn pretty_print_dyn_existential(\n         mut self,\n-        predicates: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n+        predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n         // Generate the main trait ref, including associated types.\n         let mut first = true;\n@@ -1223,7 +1225,7 @@ pub trait PrettyPrinter<'tcx>:\n                             CtorKind::Fictive => {\n                                 p!(\" {{ \");\n                                 let mut first = true;\n-                                for (field_def, field) in variant_def.fields.iter().zip(fields) {\n+                                for (field_def, field) in iter::zip(&variant_def.fields, fields) {\n                                     if !first {\n                                         p!(\", \");\n                                     }\n@@ -1420,7 +1422,8 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n     }\n \n     fn print_type(mut self, ty: Ty<'tcx>) -> Result<Self::Type, Self::Error> {\n-        if self.tcx.sess.type_length_limit().value_within_limit(self.printed_type_count) {\n+        let type_length_limit = self.tcx.sess.type_length_limit();\n+        if type_length_limit.value_within_limit(self.printed_type_count) {\n             self.printed_type_count += 1;\n             self.pretty_print_type(ty)\n         } else {\n@@ -1431,7 +1434,7 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n \n     fn print_dyn_existential(\n         self,\n-        predicates: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n+        predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n         self.pretty_print_dyn_existential(predicates)\n     }\n@@ -1570,7 +1573,7 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n         Ok(self)\n     }\n \n-    fn in_binder<T>(self, value: &ty::Binder<T>) -> Result<Self, Self::Error>\n+    fn in_binder<T>(self, value: &ty::Binder<'tcx, T>) -> Result<Self, Self::Error>\n     where\n         T: Print<'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>,\n     {\n@@ -1579,7 +1582,7 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n \n     fn wrap_binder<T, C: Fn(&T, Self) -> Result<Self, Self::Error>>(\n         self,\n-        value: &ty::Binder<T>,\n+        value: &ty::Binder<'tcx, T>,\n         f: C,\n     ) -> Result<Self, Self::Error>\n     where\n@@ -1635,7 +1638,7 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n                 data.name != kw::Empty && data.name != kw::UnderscoreLifetime\n             }\n \n-            ty::ReLateBound(_, ty::BoundRegion { kind: br })\n+            ty::ReLateBound(_, ty::BoundRegion { kind: br, .. })\n             | ty::ReFree(ty::FreeRegion { bound_region: br, .. })\n             | ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n                 if let ty::BrNamed(_, name) = br {\n@@ -1714,7 +1717,7 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n                     return Ok(self);\n                 }\n             }\n-            ty::ReLateBound(_, ty::BoundRegion { kind: br })\n+            ty::ReLateBound(_, ty::BoundRegion { kind: br, .. })\n             | ty::ReFree(ty::FreeRegion { bound_region: br, .. })\n             | ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n                 if let ty::BrNamed(_, name) = br {\n@@ -1762,7 +1765,7 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n     pub fn name_all_regions<T>(\n         mut self,\n-        value: &ty::Binder<T>,\n+        value: &ty::Binder<'tcx, T>,\n     ) -> Result<(Self, (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)), fmt::Error>\n     where\n         T: Print<'tcx, Self, Output = Self, Error = fmt::Error> + TypeFoldable<'tcx>,\n@@ -1820,7 +1823,8 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n                     ty::BrNamed(DefId::local(CRATE_DEF_INDEX), name)\n                 }\n             };\n-            self.tcx.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion { kind }))\n+            self.tcx\n+                .mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion { var: br.var, kind }))\n         });\n         start_or_continue(&mut self, \"\", \"> \")?;\n \n@@ -1829,7 +1833,7 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n         Ok((self, new_value))\n     }\n \n-    pub fn pretty_in_binder<T>(self, value: &ty::Binder<T>) -> Result<Self, fmt::Error>\n+    pub fn pretty_in_binder<T>(self, value: &ty::Binder<'tcx, T>) -> Result<Self, fmt::Error>\n     where\n         T: Print<'tcx, Self, Output = Self, Error = fmt::Error> + TypeFoldable<'tcx>,\n     {\n@@ -1843,7 +1847,7 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n \n     pub fn pretty_wrap_binder<T, C: Fn(&T, Self) -> Result<Self, fmt::Error>>(\n         self,\n-        value: &ty::Binder<T>,\n+        value: &ty::Binder<'tcx, T>,\n         f: C,\n     ) -> Result<Self, fmt::Error>\n     where\n@@ -1857,28 +1861,52 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n         Ok(inner)\n     }\n \n-    fn prepare_late_bound_region_info<T>(&mut self, value: &ty::Binder<T>)\n+    fn prepare_late_bound_region_info<T>(&mut self, value: &ty::Binder<'tcx, T>)\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        struct LateBoundRegionNameCollector<'a>(&'a mut FxHashSet<Symbol>);\n-        impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector<'_> {\n+        debug!(\"prepare_late_bound_region_info(value: {:?})\", value);\n+\n+        struct LateBoundRegionNameCollector<'a, 'tcx> {\n+            used_region_names: &'a mut FxHashSet<Symbol>,\n+            type_collector: SsoHashSet<Ty<'tcx>>,\n+        }\n+\n+        impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector<'_, 'tcx> {\n+            type BreakTy = ();\n+\n             fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                if let ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name) }) = *r {\n-                    self.0.insert(name);\n+                debug!(\"LateBoundRegionNameCollector::visit_region(r: {:?}, address: {:p})\", r, &r);\n+                if let ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name), .. }) = *r {\n+                    self.used_region_names.insert(name);\n                 }\n                 r.super_visit_with(self)\n             }\n+\n+            // We collect types in order to prevent really large types from compiling for\n+            // a really long time. See issue #83150 for why this is necessary.\n+            fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+                debug!(\"LateBoundRegionNameCollector::visit_ty(ty: {:?}\", ty);\n+                let not_previously_inserted = self.type_collector.insert(ty);\n+                if not_previously_inserted {\n+                    ty.super_visit_with(self)\n+                } else {\n+                    ControlFlow::CONTINUE\n+                }\n+            }\n         }\n \n         self.used_region_names.clear();\n-        let mut collector = LateBoundRegionNameCollector(&mut self.used_region_names);\n+        let mut collector = LateBoundRegionNameCollector {\n+            used_region_names: &mut self.used_region_names,\n+            type_collector: SsoHashSet::new(),\n+        };\n         value.visit_with(&mut collector);\n         self.region_index = 0;\n     }\n }\n \n-impl<'tcx, T, P: PrettyPrinter<'tcx>> Print<'tcx, P> for ty::Binder<T>\n+impl<'tcx, T, P: PrettyPrinter<'tcx>> Print<'tcx, P> for ty::Binder<'tcx, T>\n where\n     T: Print<'tcx, P, Output = P, Error = P::Error> + TypeFoldable<'tcx>,\n {\n@@ -1965,28 +1993,28 @@ impl ty::TraitRef<'tcx> {\n     }\n }\n \n-impl ty::Binder<ty::TraitRef<'tcx>> {\n-    pub fn print_only_trait_path(self) -> ty::Binder<TraitRefPrintOnlyTraitPath<'tcx>> {\n+impl ty::Binder<'tcx, ty::TraitRef<'tcx>> {\n+    pub fn print_only_trait_path(self) -> ty::Binder<'tcx, TraitRefPrintOnlyTraitPath<'tcx>> {\n         self.map_bound(|tr| tr.print_only_trait_path())\n     }\n }\n \n forward_display_to_print! {\n     Ty<'tcx>,\n-    &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n+    &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n     &'tcx ty::Const<'tcx>,\n \n     // HACK(eddyb) these are exhaustive instead of generic,\n     // because `for<'tcx>` isn't possible yet.\n-    ty::Binder<ty::ExistentialPredicate<'tcx>>,\n-    ty::Binder<ty::TraitRef<'tcx>>,\n-    ty::Binder<TraitRefPrintOnlyTraitPath<'tcx>>,\n-    ty::Binder<ty::FnSig<'tcx>>,\n-    ty::Binder<ty::TraitPredicate<'tcx>>,\n-    ty::Binder<ty::SubtypePredicate<'tcx>>,\n-    ty::Binder<ty::ProjectionPredicate<'tcx>>,\n-    ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>,\n-    ty::Binder<ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>>,\n+    ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>,\n+    ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+    ty::Binder<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+    ty::Binder<'tcx, ty::FnSig<'tcx>>,\n+    ty::Binder<'tcx, ty::TraitPredicate<'tcx>>,\n+    ty::Binder<'tcx, ty::SubtypePredicate<'tcx>>,\n+    ty::Binder<'tcx, ty::ProjectionPredicate<'tcx>>,\n+    ty::Binder<'tcx, ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>,\n+    ty::Binder<'tcx, ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>>,\n \n     ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>,\n     ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>"}, {"sha": "416199b384000e72d9498df7f2a054205c1aa4c0", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -525,7 +525,7 @@ impl<'sess> OnDiskCache<'sess> {\n     ) {\n         let mut current_diagnostics = self.current_diagnostics.borrow_mut();\n \n-        let x = current_diagnostics.entry(dep_node_index).or_insert(Vec::new());\n+        let x = current_diagnostics.entry(dep_node_index).or_default();\n \n         x.extend(Into::<Vec<_>>::into(diagnostics));\n     }"}, {"sha": "ca60339da0d00b9d138030dcf8c444994e52eba8", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 22, "deletions": 38, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -33,15 +33,6 @@ pub trait TypeRelation<'tcx>: Sized {\n     /// relation. Just affects error messages.\n     fn a_is_expected(&self) -> bool;\n \n-    /// Whether we should look into the substs of unevaluated constants\n-    /// even if `feature(const_evaluatable_checked)` is active.\n-    ///\n-    /// This is needed in `combine` to prevent accidentially creating\n-    /// infinite types as we abuse `TypeRelation` to walk a type there.\n-    fn visit_ct_substs(&self) -> bool {\n-        false\n-    }\n-\n     fn with_cause<F, R>(&mut self, _cause: Cause, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R,\n@@ -102,9 +93,9 @@ pub trait TypeRelation<'tcx>: Sized {\n \n     fn binders<T>(\n         &mut self,\n-        a: ty::Binder<T>,\n-        b: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>;\n }\n@@ -149,7 +140,7 @@ pub fn relate_substs<R: TypeRelation<'tcx>>(\n ) -> RelateResult<'tcx, SubstsRef<'tcx>> {\n     let tcx = relation.tcx();\n \n-    let params = a_subst.iter().zip(b_subst).enumerate().map(|(i, (a, b))| {\n+    let params = iter::zip(a_subst, b_subst).enumerate().map(|(i, (a, b))| {\n         let variance = variances.map_or(ty::Invariant, |v| v[i]);\n         relation.relate_with_variance(variance, a, b)\n     });\n@@ -179,12 +170,8 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n             return Err(TypeError::ArgCount);\n         }\n \n-        let inputs_and_output = a\n-            .inputs()\n-            .iter()\n-            .cloned()\n-            .zip(b.inputs().iter().cloned())\n-            .map(|x| (x, false))\n+        let inputs_and_output = iter::zip(a.inputs(), b.inputs())\n+            .map(|(&a, &b)| ((a, b), false))\n             .chain(iter::once(((a.output(), b.output()), true)))\n             .map(|((a, b), is_output)| {\n                 if is_output {\n@@ -308,7 +295,7 @@ impl<'tcx> Relate<'tcx> for GeneratorWitness<'tcx> {\n     ) -> RelateResult<'tcx, GeneratorWitness<'tcx>> {\n         assert_eq!(a.0.len(), b.0.len());\n         let tcx = relation.tcx();\n-        let types = tcx.mk_type_list(a.0.iter().zip(b.0).map(|(a, b)| relation.relate(a, b)))?;\n+        let types = tcx.mk_type_list(iter::zip(a.0, b.0).map(|(a, b)| relation.relate(a, b)))?;\n         Ok(GeneratorWitness(types))\n     }\n }\n@@ -432,9 +419,9 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n                     let sz_a = sz_a.try_eval_usize(tcx, relation.param_env());\n                     let sz_b = sz_b.try_eval_usize(tcx, relation.param_env());\n                     match (sz_a, sz_b) {\n-                        (Some(sz_a_val), Some(sz_b_val)) => Err(TypeError::FixedArraySize(\n-                            expected_found(relation, sz_a_val, sz_b_val),\n-                        )),\n+                        (Some(sz_a_val), Some(sz_b_val)) if sz_a_val != sz_b_val => Err(\n+                            TypeError::FixedArraySize(expected_found(relation, sz_a_val, sz_b_val)),\n+                        ),\n                         _ => Err(err),\n                     }\n                 }\n@@ -449,7 +436,7 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n         (&ty::Tuple(as_), &ty::Tuple(bs)) => {\n             if as_.len() == bs.len() {\n                 Ok(tcx.mk_tup(\n-                    as_.iter().zip(bs).map(|(a, b)| relation.relate(a.expect_ty(), b.expect_ty())),\n+                    iter::zip(as_, bs).map(|(a, b)| relation.relate(a.expect_ty(), b.expect_ty())),\n                 )?)\n             } else if !(as_.is_empty() || bs.is_empty()) {\n                 Err(TypeError::TupleSize(expected_found(relation, as_.len(), bs.len())))\n@@ -532,7 +519,7 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n         }\n \n         (ty::ConstKind::Unevaluated(au), ty::ConstKind::Unevaluated(bu))\n-            if tcx.features().const_evaluatable_checked && !relation.visit_ct_substs() =>\n+            if tcx.features().const_evaluatable_checked =>\n         {\n             tcx.try_unify_abstract_consts(((au.def, au.substs), (bu.def, bu.substs)))\n         }\n@@ -593,9 +580,7 @@ fn check_const_value_eq<R: TypeRelation<'tcx>>(\n \n             // Both the variant and each field have to be equal.\n             if a_destructured.variant == b_destructured.variant {\n-                for (a_field, b_field) in\n-                    a_destructured.fields.iter().zip(b_destructured.fields.iter())\n-                {\n+                for (a_field, b_field) in iter::zip(a_destructured.fields, b_destructured.fields) {\n                     relation.consts(a_field, b_field)?;\n                 }\n \n@@ -609,7 +594,7 @@ fn check_const_value_eq<R: TypeRelation<'tcx>>(\n     })\n }\n \n-impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>> {\n+impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: Self,\n@@ -631,13 +616,12 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'\n             return Err(TypeError::ExistentialMismatch(expected_found(relation, a, b)));\n         }\n \n-        let v = a_v.into_iter().zip(b_v.into_iter()).map(|(ep_a, ep_b)| {\n+        let v = iter::zip(a_v, b_v).map(|(ep_a, ep_b)| {\n             use crate::ty::ExistentialPredicate::*;\n             match (ep_a.skip_binder(), ep_b.skip_binder()) {\n-                (Trait(a), Trait(b)) => Ok(ty::Binder::bind(Trait(\n-                    relation.relate(ep_a.rebind(a), ep_b.rebind(b))?.skip_binder(),\n-                ))),\n-                (Projection(a), Projection(b)) => Ok(ty::Binder::bind(Projection(\n+                (Trait(a), Trait(b)) => Ok(ep_a\n+                    .rebind(Trait(relation.relate(ep_a.rebind(a), ep_b.rebind(b))?.skip_binder()))),\n+                (Projection(a), Projection(b)) => Ok(ep_a.rebind(Projection(\n                     relation.relate(ep_a.rebind(a), ep_b.rebind(b))?.skip_binder(),\n                 ))),\n                 (AutoTrait(a), AutoTrait(b)) if a == b => Ok(ep_a.rebind(AutoTrait(a))),\n@@ -700,12 +684,12 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::Const<'tcx> {\n     }\n }\n \n-impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for ty::Binder<T> {\n+impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for ty::Binder<'tcx, T> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: ty::Binder<T>,\n-        b: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>> {\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>> {\n         relation.binders(a, b)\n     }\n }"}, {"sha": "a969626b370f5d2dc6320f245d05112343aa60e8", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -454,10 +454,16 @@ impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n     }\n }\n \n-impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n-    type Lifted = ty::Binder<T::Lifted>;\n+impl<'a, 'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<'a, T>\n+where\n+    <T as Lift<'tcx>>::Lifted: TypeFoldable<'tcx>,\n+{\n+    type Lifted = ty::Binder<'tcx, T::Lifted>;\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        self.map_bound(|v| tcx.lift(v)).transpose()\n+        let bound_vars = tcx.lift(self.bound_vars());\n+        tcx.lift(self.skip_binder())\n+            .zip(bound_vars)\n+            .map(|(value, vars)| ty::Binder::bind_with_vars(value, vars))\n     }\n }\n \n@@ -749,7 +755,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<[T]> {\n     }\n }\n \n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<'tcx, T> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         self.map_bound(|ty| ty.fold_with(folder))\n     }\n@@ -767,7 +773,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         ty::util::fold_list(self, folder, |tcx, v| tcx.intern_poly_existential_predicates(v))\n     }"}, {"sha": "e352d0bc756976d039daa460450ac0e10a6aa19c", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 90, "deletions": 134, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -5,6 +5,8 @@\n use self::TyKind::*;\n \n use crate::infer::canonical::Canonical;\n+use crate::ty::fold::BoundVarsCollector;\n+use crate::ty::fold::ValidateBoundVars;\n use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n use crate::ty::InferTy::{self, *};\n use crate::ty::{\n@@ -62,22 +64,10 @@ pub enum BoundRegionKind {\n #[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, PartialOrd, Ord)]\n #[derive(HashStable)]\n pub struct BoundRegion {\n+    pub var: BoundVar,\n     pub kind: BoundRegionKind,\n }\n \n-impl BoundRegion {\n-    /// When canonicalizing, we replace unbound inference variables and free\n-    /// regions with anonymous late bound regions. This method asserts that\n-    /// we have an anonymous late bound region, which hence may refer to\n-    /// a canonical variable.\n-    pub fn assert_bound_var(&self) -> BoundVar {\n-        match self.kind {\n-            BoundRegionKind::BrAnon(var) => BoundVar::from_u32(var),\n-            _ => bug!(\"bound region is not anonymous\"),\n-        }\n-    }\n-}\n-\n impl BoundRegionKind {\n     pub fn is_named(&self) -> bool {\n         match *self {\n@@ -160,8 +150,8 @@ pub enum TyKind<'tcx> {\n     /// ```\n     FnPtr(PolyFnSig<'tcx>),\n \n-    /// A trait, defined with `trait`.\n-    Dynamic(&'tcx List<Binder<ExistentialPredicate<'tcx>>>, ty::Region<'tcx>),\n+    /// A trait object. Written as `dyn for<'b> Trait<'b, Assoc = u32> + Send + 'a`.\n+    Dynamic(&'tcx List<Binder<'tcx, ExistentialPredicate<'tcx>>>, ty::Region<'tcx>),\n \n     /// The anonymous type of a closure. Used to represent the type of\n     /// `|a| a`.\n@@ -173,7 +163,7 @@ pub enum TyKind<'tcx> {\n \n     /// A type representing the types stored inside a generator.\n     /// This should only appear in GeneratorInteriors.\n-    GeneratorWitness(Binder<&'tcx List<Ty<'tcx>>>),\n+    GeneratorWitness(Binder<'tcx, &'tcx List<Ty<'tcx>>>),\n \n     /// The never type `!`.\n     Never,\n@@ -232,7 +222,7 @@ impl TyKind<'tcx> {\n \n // `TyKind` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(TyKind<'_>, 24);\n+static_assert_size!(TyKind<'_>, 32);\n \n /// A closure can be modeled as a struct that looks like:\n ///\n@@ -747,7 +737,7 @@ impl<'tcx> ExistentialPredicate<'tcx> {\n     }\n }\n \n-impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n+impl<'tcx> Binder<'tcx, ExistentialPredicate<'tcx>> {\n     pub fn with_self_ty(&self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> ty::Predicate<'tcx> {\n         use crate::ty::ToPredicate;\n         match self.skip_binder() {\n@@ -768,7 +758,7 @@ impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n     }\n }\n \n-impl<'tcx> List<ty::Binder<ExistentialPredicate<'tcx>>> {\n+impl<'tcx> List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>> {\n     /// Returns the \"principal `DefId`\" of this set of existential predicates.\n     ///\n     /// A Rust trait object type consists (in addition to a lifetime bound)\n@@ -794,7 +784,7 @@ impl<'tcx> List<ty::Binder<ExistentialPredicate<'tcx>>> {\n     /// is `{Send, Sync}`, while there is no principal. These trait objects\n     /// have a \"trivial\" vtable consisting of just the size, alignment,\n     /// and destructor.\n-    pub fn principal(&self) -> Option<ty::Binder<ExistentialTraitRef<'tcx>>> {\n+    pub fn principal(&self) -> Option<ty::Binder<'tcx, ExistentialTraitRef<'tcx>>> {\n         self[0]\n             .map_bound(|this| match this {\n                 ExistentialPredicate::Trait(tr) => Some(tr),\n@@ -810,7 +800,7 @@ impl<'tcx> List<ty::Binder<ExistentialPredicate<'tcx>>> {\n     #[inline]\n     pub fn projection_bounds<'a>(\n         &'a self,\n-    ) -> impl Iterator<Item = ty::Binder<ExistentialProjection<'tcx>>> + 'a {\n+    ) -> impl Iterator<Item = ty::Binder<'tcx, ExistentialProjection<'tcx>>> + 'a {\n         self.iter().filter_map(|predicate| {\n             predicate\n                 .map_bound(|pred| match pred {\n@@ -875,10 +865,10 @@ impl<'tcx> TraitRef<'tcx> {\n     }\n }\n \n-pub type PolyTraitRef<'tcx> = Binder<TraitRef<'tcx>>;\n+pub type PolyTraitRef<'tcx> = Binder<'tcx, TraitRef<'tcx>>;\n \n impl<'tcx> PolyTraitRef<'tcx> {\n-    pub fn self_ty(&self) -> Binder<Ty<'tcx>> {\n+    pub fn self_ty(&self) -> Binder<'tcx, Ty<'tcx>> {\n         self.map_bound_ref(|tr| tr.self_ty())\n     }\n \n@@ -931,7 +921,7 @@ impl<'tcx> ExistentialTraitRef<'tcx> {\n     }\n }\n \n-pub type PolyExistentialTraitRef<'tcx> = Binder<ExistentialTraitRef<'tcx>>;\n+pub type PolyExistentialTraitRef<'tcx> = Binder<'tcx, ExistentialTraitRef<'tcx>>;\n \n impl<'tcx> PolyExistentialTraitRef<'tcx> {\n     pub fn def_id(&self) -> DefId {\n@@ -947,52 +937,56 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n+#[derive(HashStable)]\n+pub enum BoundVariableKind {\n+    Ty(BoundTyKind),\n+    Region(BoundRegionKind),\n+    Const,\n+}\n+\n /// Binder is a binder for higher-ranked lifetimes or types. It is part of the\n /// compiler's representation for things like `for<'a> Fn(&'a isize)`\n /// (which would be represented by the type `PolyTraitRef ==\n-/// Binder<TraitRef>`). Note that when we instantiate,\n+/// Binder<'tcx, TraitRef>`). Note that when we instantiate,\n /// erase, or otherwise \"discharge\" these bound vars, we change the\n-/// type from `Binder<T>` to just `T` (see\n+/// type from `Binder<'tcx, T>` to just `T` (see\n /// e.g., `liberate_late_bound_regions`).\n ///\n /// `Decodable` and `Encodable` are implemented for `Binder<T>` using the `impl_binder_encode_decode!` macro.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n-pub struct Binder<T>(T);\n+pub struct Binder<'tcx, T>(T, &'tcx List<BoundVariableKind>);\n \n-impl<T> Binder<T> {\n+impl<'tcx, T> Binder<'tcx, T>\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n     /// Wraps `value` in a binder, asserting that `value` does not\n     /// contain any bound vars that would be bound by the\n     /// binder. This is commonly used to 'inject' a value T into a\n     /// different binding level.\n-    pub fn dummy<'tcx>(value: T) -> Binder<T>\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n+    pub fn dummy(value: T) -> Binder<'tcx, T> {\n         debug_assert!(!value.has_escaping_bound_vars());\n-        Binder(value)\n+        Binder(value, ty::List::empty())\n     }\n \n     /// Wraps `value` in a binder, binding higher-ranked vars (if any).\n-    pub fn bind(value: T) -> Binder<T> {\n-        Binder(value)\n+    pub fn bind(value: T, tcx: TyCtxt<'tcx>) -> Binder<'tcx, T> {\n+        let mut collector = BoundVarsCollector::new();\n+        value.visit_with(&mut collector);\n+        Binder(value, collector.into_vars(tcx))\n     }\n \n-    /// Wraps `value` in a binder without actually binding any currently\n-    /// unbound variables.\n-    ///\n-    /// Note that this will shift all debrujin indices of escaping bound variables\n-    /// by 1 to avoid accidential captures.\n-    pub fn wrap_nonbinding(tcx: TyCtxt<'tcx>, value: T) -> Binder<T>\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        if value.has_escaping_bound_vars() {\n-            Binder::bind(super::fold::shift_vars(tcx, value, 1))\n-        } else {\n-            Binder::dummy(value)\n+    pub fn bind_with_vars(value: T, vars: &'tcx List<BoundVariableKind>) -> Binder<'tcx, T> {\n+        if cfg!(debug_assertions) {\n+            let mut validator = ValidateBoundVars::new(vars);\n+            value.visit_with(&mut validator);\n         }\n+        Binder(value, vars)\n     }\n+}\n \n+impl<'tcx, T> Binder<'tcx, T> {\n     /// Skips the binder and returns the \"bound\" value. This is a\n     /// risky thing to do because it's easy to get confused about\n     /// De Bruijn indices and the like. It is usually better to\n@@ -1013,22 +1007,39 @@ impl<T> Binder<T> {\n         self.0\n     }\n \n-    pub fn as_ref(&self) -> Binder<&T> {\n-        Binder(&self.0)\n+    pub fn bound_vars(&self) -> &'tcx List<BoundVariableKind> {\n+        self.1\n     }\n \n-    pub fn map_bound_ref<F, U>(&self, f: F) -> Binder<U>\n+    pub fn as_ref(&self) -> Binder<'tcx, &T> {\n+        Binder(&self.0, self.1)\n+    }\n+\n+    pub fn map_bound_ref_unchecked<F, U>(&self, f: F) -> Binder<'tcx, U>\n+    where\n+        F: FnOnce(&T) -> U,\n+    {\n+        let value = f(&self.0);\n+        Binder(value, self.1)\n+    }\n+\n+    pub fn map_bound_ref<F, U: TypeFoldable<'tcx>>(&self, f: F) -> Binder<'tcx, U>\n     where\n         F: FnOnce(&T) -> U,\n     {\n         self.as_ref().map_bound(f)\n     }\n \n-    pub fn map_bound<F, U>(self, f: F) -> Binder<U>\n+    pub fn map_bound<F, U: TypeFoldable<'tcx>>(self, f: F) -> Binder<'tcx, U>\n     where\n         F: FnOnce(T) -> U,\n     {\n-        Binder(f(self.0))\n+        let value = f(self.0);\n+        if cfg!(debug_assertions) {\n+            let mut validator = ValidateBoundVars::new(self.1);\n+            value.visit_with(&mut validator);\n+        }\n+        Binder(value, self.1)\n     }\n \n     /// Wraps a `value` in a binder, using the same bound variables as the\n@@ -1040,8 +1051,15 @@ impl<T> Binder<T> {\n     /// don't actually track bound vars. However, semantically, it is different\n     /// because bound vars aren't allowed to change here, whereas they are\n     /// in `bind`. This may be (debug) asserted in the future.\n-    pub fn rebind<U>(&self, value: U) -> Binder<U> {\n-        Binder(value)\n+    pub fn rebind<U>(&self, value: U) -> Binder<'tcx, U>\n+    where\n+        U: TypeFoldable<'tcx>,\n+    {\n+        if cfg!(debug_assertions) {\n+            let mut validator = ValidateBoundVars::new(self.bound_vars());\n+            value.visit_with(&mut validator);\n+        }\n+        Binder(value, self.1)\n     }\n \n     /// Unwraps and returns the value within, but only if it contains\n@@ -1054,45 +1072,32 @@ impl<T> Binder<T> {\n     /// binders, but that would require adjusting the debruijn\n     /// indices, and given the shallow binding structure we often use,\n     /// would not be that useful.)\n-    pub fn no_bound_vars<'tcx>(self) -> Option<T>\n+    pub fn no_bound_vars(self) -> Option<T>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         if self.0.has_escaping_bound_vars() { None } else { Some(self.skip_binder()) }\n     }\n \n-    /// Given two things that have the same binder level,\n-    /// and an operation that wraps on their contents, executes the operation\n-    /// and then wraps its result.\n-    ///\n-    /// `f` should consider bound regions at depth 1 to be free, and\n-    /// anything it produces with bound regions at depth 1 will be\n-    /// bound in the resulting return value.\n-    pub fn fuse<U, F, R>(self, u: Binder<U>, f: F) -> Binder<R>\n-    where\n-        F: FnOnce(T, U) -> R,\n-    {\n-        Binder(f(self.0, u.0))\n-    }\n-\n     /// Splits the contents into two things that share the same binder\n     /// level as the original, returning two distinct binders.\n     ///\n     /// `f` should consider bound regions at depth 1 to be free, and\n     /// anything it produces with bound regions at depth 1 will be\n     /// bound in the resulting return values.\n-    pub fn split<U, V, F>(self, f: F) -> (Binder<U>, Binder<V>)\n+    pub fn split<U, V, F>(self, f: F) -> (Binder<'tcx, U>, Binder<'tcx, V>)\n     where\n         F: FnOnce(T) -> (U, V),\n     {\n         let (u, v) = f(self.0);\n-        (Binder(u), Binder(v))\n+        (Binder(u, self.1), Binder(v, self.1))\n     }\n }\n \n-impl<T> Binder<Option<T>> {\n-    pub fn transpose(self) -> Option<Binder<T>> {\n-        self.0.map(Binder)\n+impl<'tcx, T> Binder<'tcx, Option<T>> {\n+    pub fn transpose(self) -> Option<Binder<'tcx, T>> {\n+        let bound_vars = self.1;\n+        self.0.map(|v| Binder(v, bound_vars))\n     }\n }\n \n@@ -1155,19 +1160,7 @@ pub struct GenSig<'tcx> {\n     pub return_ty: Ty<'tcx>,\n }\n \n-pub type PolyGenSig<'tcx> = Binder<GenSig<'tcx>>;\n-\n-impl<'tcx> PolyGenSig<'tcx> {\n-    pub fn resume_ty(&self) -> ty::Binder<Ty<'tcx>> {\n-        self.map_bound_ref(|sig| sig.resume_ty)\n-    }\n-    pub fn yield_ty(&self) -> ty::Binder<Ty<'tcx>> {\n-        self.map_bound_ref(|sig| sig.yield_ty)\n-    }\n-    pub fn return_ty(&self) -> ty::Binder<Ty<'tcx>> {\n-        self.map_bound_ref(|sig| sig.return_ty)\n-    }\n-}\n+pub type PolyGenSig<'tcx> = Binder<'tcx, GenSig<'tcx>>;\n \n /// Signature of a function type, which we have arbitrarily\n /// decided to use to refer to the input/output types.\n@@ -1205,22 +1198,22 @@ impl<'tcx> FnSig<'tcx> {\n     }\n }\n \n-pub type PolyFnSig<'tcx> = Binder<FnSig<'tcx>>;\n+pub type PolyFnSig<'tcx> = Binder<'tcx, FnSig<'tcx>>;\n \n impl<'tcx> PolyFnSig<'tcx> {\n     #[inline]\n-    pub fn inputs(&self) -> Binder<&'tcx [Ty<'tcx>]> {\n-        self.map_bound_ref(|fn_sig| fn_sig.inputs())\n+    pub fn inputs(&self) -> Binder<'tcx, &'tcx [Ty<'tcx>]> {\n+        self.map_bound_ref_unchecked(|fn_sig| fn_sig.inputs())\n     }\n     #[inline]\n-    pub fn input(&self, index: usize) -> ty::Binder<Ty<'tcx>> {\n+    pub fn input(&self, index: usize) -> ty::Binder<'tcx, Ty<'tcx>> {\n         self.map_bound_ref(|fn_sig| fn_sig.inputs()[index])\n     }\n-    pub fn inputs_and_output(&self) -> ty::Binder<&'tcx List<Ty<'tcx>>> {\n+    pub fn inputs_and_output(&self) -> ty::Binder<'tcx, &'tcx List<Ty<'tcx>>> {\n         self.map_bound_ref(|fn_sig| fn_sig.inputs_and_output)\n     }\n     #[inline]\n-    pub fn output(&self) -> ty::Binder<Ty<'tcx>> {\n+    pub fn output(&self) -> ty::Binder<'tcx, Ty<'tcx>> {\n         self.map_bound_ref(|fn_sig| fn_sig.output())\n     }\n     pub fn c_variadic(&self) -> bool {\n@@ -1234,7 +1227,7 @@ impl<'tcx> PolyFnSig<'tcx> {\n     }\n }\n \n-pub type CanonicalPolyFnSig<'tcx> = Canonical<'tcx, Binder<FnSig<'tcx>>>;\n+pub type CanonicalPolyFnSig<'tcx> = Canonical<'tcx, Binder<'tcx, FnSig<'tcx>>>;\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n@@ -1248,10 +1241,6 @@ impl<'tcx> ParamTy {\n         ParamTy { index, name }\n     }\n \n-    pub fn for_self() -> ParamTy {\n-        ParamTy::new(0, kw::SelfUpper)\n-    }\n-\n     pub fn for_def(def: &ty::GenericParamDef) -> ParamTy {\n         ParamTy::new(def.index, def.name)\n     }\n@@ -1269,18 +1258,14 @@ pub struct ParamConst {\n     pub name: Symbol,\n }\n \n-impl<'tcx> ParamConst {\n+impl ParamConst {\n     pub fn new(index: u32, name: Symbol) -> ParamConst {\n         ParamConst { index, name }\n     }\n \n     pub fn for_def(def: &ty::GenericParamDef) -> ParamConst {\n         ParamConst::new(def.index, def.name)\n     }\n-\n-    pub fn to_const(self, tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        tcx.mk_const_param(self.index, self.name, ty)\n-    }\n }\n \n pub type Region<'tcx> = &'tcx RegionKind;\n@@ -1486,7 +1471,7 @@ pub struct ExistentialProjection<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n-pub type PolyExistentialProjection<'tcx> = Binder<ExistentialProjection<'tcx>>;\n+pub type PolyExistentialProjection<'tcx> = Binder<'tcx, ExistentialProjection<'tcx>>;\n \n impl<'tcx> ExistentialProjection<'tcx> {\n     /// Extracts the underlying existential trait reference from this projection.\n@@ -1580,35 +1565,6 @@ impl RegionKind {\n         }\n     }\n \n-    /// Adjusts any De Bruijn indices so as to make `to_binder` the\n-    /// innermost binder. That is, if we have something bound at `to_binder`,\n-    /// it will now be bound at INNERMOST. This is an appropriate thing to do\n-    /// when moving a region out from inside binders:\n-    ///\n-    /// ```\n-    ///             for<'a>   fn(for<'b>   for<'c>   fn(&'a u32), _)\n-    /// // Binder:  D3           D2        D1            ^^\n-    /// ```\n-    ///\n-    /// Here, the region `'a` would have the De Bruijn index D3,\n-    /// because it is the bound 3 binders out. However, if we wanted\n-    /// to refer to that region `'a` in the second argument (the `_`),\n-    /// those two binders would not be in scope. In that case, we\n-    /// might invoke `shift_out_to_binder(D3)`. This would adjust the\n-    /// De Bruijn index of `'a` to D1 (the innermost binder).\n-    ///\n-    /// If we invoke `shift_out_to_binder` and the region is in fact\n-    /// bound by one of the binders we are shifting out of, that is an\n-    /// error (and should fail an assertion failure).\n-    pub fn shifted_out_to_binder(&self, to_binder: ty::DebruijnIndex) -> RegionKind {\n-        match *self {\n-            ty::ReLateBound(debruijn, r) => {\n-                ty::ReLateBound(debruijn.shifted_out_to_binder(to_binder), r)\n-            }\n-            r => r,\n-        }\n-    }\n-\n     pub fn type_flags(&self) -> TypeFlags {\n         let mut flags = TypeFlags::empty();\n "}, {"sha": "c84ca61122fe2faf19a12a76da17549fc04ec344", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,5 +1,6 @@\n // Type substitutions.\n \n+use crate::mir;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::sty::{ClosureSubsts, GeneratorSubsts};\n@@ -448,7 +449,10 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: ty::Binder<T>) -> ty::Binder<T> {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: ty::Binder<'tcx, T>,\n+    ) -> ty::Binder<'tcx, T> {\n         self.binders_passed += 1;\n         let t = t.super_fold_with(self);\n         self.binders_passed -= 1;\n@@ -503,6 +507,11 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n             c.super_fold_with(self)\n         }\n     }\n+\n+    #[inline]\n+    fn fold_mir_const(&mut self, c: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx> {\n+        c.super_fold_with(self)\n+    }\n }\n \n impl<'a, 'tcx> SubstFolder<'a, 'tcx> {"}, {"sha": "33065bc3a7bd3f29f18fc37480fb0cd73c4abe9f", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -69,6 +69,12 @@ pub struct TraitImpls {\n     non_blanket_impls: FxHashMap<fast_reject::SimplifiedType, Vec<DefId>>,\n }\n \n+impl TraitImpls {\n+    pub fn blanket_impls(&self) -> &[DefId] {\n+        self.blanket_impls.as_slice()\n+    }\n+}\n+\n impl<'tcx> TraitDef {\n     pub fn new(\n         def_id: DefId,"}, {"sha": "7d09ca5152ffe51220243af0fe977162a9894fc5", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -21,7 +21,7 @@ use rustc_macros::HashStable;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Integer, Size, TargetDataLayout};\n use smallvec::SmallVec;\n-use std::{cmp, fmt};\n+use std::{cmp, fmt, iter};\n \n #[derive(Copy, Clone, Debug)]\n pub struct Discr<'tcx> {\n@@ -414,9 +414,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             _ => bug!(),\n         };\n \n-        let result = item_substs\n-            .iter()\n-            .zip(impl_substs.iter())\n+        let result = iter::zip(item_substs, impl_substs)\n             .filter(|&(_, k)| {\n                 match k.unpack() {\n                     GenericArgKind::Lifetime(&ty::RegionKind::ReEarlyBound(ref ebr)) => {\n@@ -501,18 +499,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         self,\n         closure_def_id: DefId,\n         closure_substs: SubstsRef<'tcx>,\n-    ) -> Option<ty::Binder<Ty<'tcx>>> {\n+        env_region: ty::RegionKind,\n+    ) -> Option<Ty<'tcx>> {\n         let closure_ty = self.mk_closure(closure_def_id, closure_substs);\n-        let br = ty::BoundRegion { kind: ty::BrEnv };\n-        let env_region = ty::ReLateBound(ty::INNERMOST, br);\n         let closure_kind_ty = closure_substs.as_closure().kind_ty();\n         let closure_kind = closure_kind_ty.to_opt_closure_kind()?;\n         let env_ty = match closure_kind {\n             ty::ClosureKind::Fn => self.mk_imm_ref(self.mk_region(env_region), closure_ty),\n             ty::ClosureKind::FnMut => self.mk_mut_ref(self.mk_region(env_region), closure_ty),\n             ty::ClosureKind::FnOnce => closure_ty,\n         };\n-        Some(ty::Binder::bind(env_ty))\n+        Some(env_ty)\n     }\n \n     /// Returns `true` if the node pointed to by `def_id` is a `static` item.\n@@ -701,7 +698,6 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// optimization as well as the rules around static values. Note\n     /// that the `Freeze` trait is not exposed to end users and is\n     /// effectively an implementation detail.\n-    // FIXME: use `TyCtxtAt` instead of separate `Span`.\n     pub fn is_freeze(&'tcx self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n         self.is_trivially_freeze() || tcx_at.is_freeze_raw(param_env.and(self))\n     }"}, {"sha": "d5deec820889ac05595d459789de888bf53970de", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1728,7 +1728,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         impl<'tcx> Visitor<'tcx> for FakeReadCauseFinder<'tcx> {\n             fn visit_statement(&mut self, statement: &Statement<'tcx>, _: Location) {\n                 match statement {\n-                    Statement { kind: StatementKind::FakeRead(cause, box place), .. }\n+                    Statement { kind: StatementKind::FakeRead(box (cause, place)), .. }\n                         if *place == self.place =>\n                     {\n                         self.cause = Some(*cause);"}, {"sha": "2a388b8a72bb05b4aa3ff9a7099ccfcae3850e85", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -515,7 +515,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let block = &self.body.basic_blocks()[location.block];\n \n                 let kind = if let Some(&Statement {\n-                    kind: StatementKind::FakeRead(FakeReadCause::ForLet, _),\n+                    kind: StatementKind::FakeRead(box (FakeReadCause::ForLet(_), _)),\n                     ..\n                 }) = block.statements.get(location.statement_index)\n                 {"}, {"sha": "577d7d53814ee1d362a084d421919f8ce5c5ff06", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -7,8 +7,8 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItemGroup;\n use rustc_hir::GeneratorKind;\n use rustc_middle::mir::{\n-    AggregateKind, Constant, Field, Local, LocalInfo, LocalKind, Location, Operand, Place,\n-    PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind,\n+    AggregateKind, Constant, FakeReadCause, Field, Local, LocalInfo, LocalKind, Location, Operand,\n+    Place, PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind,\n };\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::{self, DefIdTree, Instance, Ty, TyCtxt};\n@@ -18,6 +18,7 @@ use rustc_span::{\n     Span,\n };\n use rustc_target::abi::VariantIdx;\n+use std::iter;\n \n use super::borrow_set::BorrowData;\n use super::MirBorrowckCtxt;\n@@ -501,7 +502,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // lifetimes without names with the value `'0`.\n         match ty.kind() {\n             ty::Ref(\n-                ty::RegionKind::ReLateBound(_, ty::BoundRegion { kind: br })\n+                ty::RegionKind::ReLateBound(_, ty::BoundRegion { kind: br, .. })\n                 | ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }),\n                 _,\n                 _,\n@@ -522,7 +523,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let region = match ty.kind() {\n             ty::Ref(region, _, _) => {\n                 match region {\n-                    ty::RegionKind::ReLateBound(_, ty::BoundRegion { kind: br })\n+                    ty::RegionKind::ReLateBound(_, ty::BoundRegion { kind: br, .. })\n                     | ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }) => {\n                         printer.region_highlight_mode.highlighting_bound_region(*br, counter)\n                     }\n@@ -794,6 +795,24 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n         }\n \n+        // StatementKind::FakeRead only contains a def_id if they are introduced as a result\n+        // of pattern matching within a closure.\n+        if let StatementKind::FakeRead(box (cause, ref place)) = stmt.kind {\n+            match cause {\n+                FakeReadCause::ForMatchedPlace(Some(closure_def_id))\n+                | FakeReadCause::ForLet(Some(closure_def_id)) => {\n+                    debug!(\"move_spans: def_id={:?} place={:?}\", closure_def_id, place);\n+                    let places = &[Operand::Move(*place)];\n+                    if let Some((args_span, generator_kind, var_span)) =\n+                        self.closure_span(closure_def_id, moved_place, places)\n+                    {\n+                        return ClosureUse { generator_kind, args_span, var_span };\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+\n         let normal_ret =\n             if moved_place.projection.iter().any(|p| matches!(p, ProjectionElem::Downcast(..))) {\n                 PatUse(stmt.source_info.span)\n@@ -970,13 +989,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let expr = &self.infcx.tcx.hir().expect_expr(hir_id).kind;\n         debug!(\"closure_span: hir_id={:?} expr={:?}\", hir_id, expr);\n         if let hir::ExprKind::Closure(.., body_id, args_span, _) = expr {\n-            for (captured_place, place) in self\n-                .infcx\n-                .tcx\n-                .typeck(def_id.expect_local())\n-                .closure_min_captures_flattened(def_id)\n-                .zip(places)\n-            {\n+            for (captured_place, place) in iter::zip(\n+                self.infcx.tcx.typeck(def_id.expect_local()).closure_min_captures_flattened(def_id),\n+                places,\n+            ) {\n                 let upvar_hir_id = captured_place.get_root_variable();\n                 //FIXME(project-rfc-2229#8): Use better span from captured_place\n                 let span = self.infcx.tcx.upvars_mentioned(local_did)?[&upvar_hir_id].span;"}, {"sha": "3629c813bc7a05252a0b620a4eb2fb711d6299e9", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -157,7 +157,7 @@ impl OutlivesSuggestionBuilder {\n         debug!(\"Collected {:?}: {:?}\", fr, outlived_fr);\n \n         // Add to set of constraints for final help note.\n-        self.constraints_to_add.entry(fr).or_insert(Vec::new()).push(outlived_fr);\n+        self.constraints_to_add.entry(fr).or_default().push(outlived_fr);\n     }\n \n     /// Emit an intermediate note on the given `Diagnostic` if the involved regions are"}, {"sha": "1f168c612f16726f78b3f98ded96658f6be6926e", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,4 +1,5 @@\n use std::fmt::{self, Display};\n+use std::iter;\n \n use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n@@ -536,7 +537,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                 // just worry about trying to match up the rustc type\n                 // with the HIR types:\n                 (ty::Tuple(elem_tys), hir::TyKind::Tup(elem_hir_tys)) => {\n-                    search_stack.extend(elem_tys.iter().map(|k| k.expect_ty()).zip(*elem_hir_tys));\n+                    search_stack\n+                        .extend(iter::zip(elem_tys.iter().map(|k| k.expect_ty()), *elem_hir_tys));\n                 }\n \n                 (ty::Slice(elem_ty), hir::TyKind::Slice(elem_hir_ty))\n@@ -611,7 +613,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         args: &'hir hir::GenericArgs<'hir>,\n         search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty<'hir>)>,\n     ) -> Option<&'hir hir::Lifetime> {\n-        for (kind, hir_arg) in substs.iter().zip(args.args) {\n+        for (kind, hir_arg) in iter::zip(substs, args.args) {\n             match (kind.unpack(), hir_arg) {\n                 (GenericArgKind::Lifetime(r), hir::GenericArg::Lifetime(lt)) => {\n                     if r.to_region_vid() == needle_fr {"}, {"sha": "9374741f83749ec8507ebf8842c617e1628c1060", "filename": "compiler/rustc_mir/src/borrow_check/invalidation.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Finvalidation.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -5,6 +5,7 @@ use rustc_middle::mir::{BorrowKind, Mutability, Operand};\n use rustc_middle::mir::{InlineAsmOperand, Terminator, TerminatorKind};\n use rustc_middle::mir::{Statement, StatementKind};\n use rustc_middle::ty::TyCtxt;\n+use std::iter;\n \n use crate::dataflow::indexes::BorrowIndex;\n \n@@ -62,14 +63,14 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n \n                 self.mutate_place(location, *lhs, Shallow(None), JustWrite);\n             }\n-            StatementKind::FakeRead(_, _) => {\n+            StatementKind::FakeRead(box (_, _)) => {\n                 // Only relevant for initialized/liveness/safety checks.\n             }\n             StatementKind::SetDiscriminant { place, variant_index: _ } => {\n                 self.mutate_place(location, **place, Shallow(None), JustWrite);\n             }\n             StatementKind::LlvmInlineAsm(asm) => {\n-                for (o, output) in asm.asm.outputs.iter().zip(asm.outputs.iter()) {\n+                for (o, output) in iter::zip(&asm.asm.outputs, &*asm.outputs) {\n                     if o.is_indirect {\n                         // FIXME(eddyb) indirect inline asm outputs should\n                         // be encoded through MIR place derefs instead."}, {"sha": "71db6abde43512abd716ca9817815b0af1026cbd", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -25,6 +25,7 @@ use either::Either;\n use smallvec::SmallVec;\n use std::cell::RefCell;\n use std::collections::BTreeMap;\n+use std::iter;\n use std::mem;\n use std::rc::Rc;\n \n@@ -573,7 +574,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n \n                 self.mutate_place(location, (*lhs, span), Shallow(None), JustWrite, flow_state);\n             }\n-            StatementKind::FakeRead(_, box ref place) => {\n+            StatementKind::FakeRead(box (_, ref place)) => {\n                 // Read for match doesn't access any memory and is used to\n                 // assert that a place is safe and live. So we don't have to\n                 // do any checks here.\n@@ -595,7 +596,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                 self.mutate_place(location, (**place, span), Shallow(None), JustWrite, flow_state);\n             }\n             StatementKind::LlvmInlineAsm(ref asm) => {\n-                for (o, output) in asm.asm.outputs.iter().zip(asm.outputs.iter()) {\n+                for (o, output) in iter::zip(&asm.asm.outputs, &*asm.outputs) {\n                     if o.is_indirect {\n                         // FIXME(eddyb) indirect inline asm outputs should\n                         // be encoded through MIR place derefs instead."}, {"sha": "3654b51949e70a03ec9d8e3d07c3bd055be45f35", "filename": "compiler/rustc_mir/src/borrow_check/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fplaces_conflict.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -5,6 +5,7 @@ use rustc_hir as hir;\n use rustc_middle::mir::{Body, BorrowKind, Local, Place, PlaceElem, PlaceRef, ProjectionElem};\n use rustc_middle::ty::{self, TyCtxt};\n use std::cmp::max;\n+use std::iter;\n \n /// When checking if a place conflicts with another place, this enum is used to influence decisions\n /// where a place might be equal or disjoint with another place, such as if `a[i] == a[j]`.\n@@ -139,7 +140,7 @@ fn place_components_conflict<'tcx>(\n \n     // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n     for (i, (borrow_c, &access_c)) in\n-        borrow_place.projection.iter().zip(access_place.projection.iter()).enumerate()\n+        iter::zip(borrow_place.projection, access_place.projection).enumerate()\n     {\n         debug!(\"borrow_conflicts_with_place: borrow_c = {:?}\", borrow_c);\n         let borrow_proj_base = &borrow_place.projection[..i];"}, {"sha": "1bb447d1057815e7764d9342d2f56311813e506e", "filename": "compiler/rustc_mir/src/borrow_check/type_check/input_output.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -70,6 +70,12 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n         // Equate expected input tys with those in the MIR.\n         for (argument_index, &normalized_input_ty) in normalized_input_tys.iter().enumerate() {\n+            if argument_index + 1 >= body.local_decls.len() {\n+                self.tcx()\n+                    .sess\n+                    .delay_span_bug(body.span, \"found more normalized_input_ty than local_decls\");\n+                break;\n+            }\n             // In MIR, argument N is stored in local N+1.\n             let local = Local::new(argument_index + 1);\n "}, {"sha": "3248554e2042744efe4b5b4eebe0bac611cbd672", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1770,7 +1770,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         if args.len() < sig.inputs().len() || (args.len() > sig.inputs().len() && !sig.c_variadic) {\n             span_mirbug!(self, term, \"call to {:?} with wrong # of args\", sig);\n         }\n-        for (n, (fn_arg, op_arg)) in sig.inputs().iter().zip(args).enumerate() {\n+        for (n, (fn_arg, op_arg)) in iter::zip(sig.inputs(), args).enumerate() {\n             let op_arg_ty = op_arg.ty(body, self.tcx());\n             let op_arg_ty = self.normalize(op_arg_ty, term_location);\n             let category = if from_hir_call {\n@@ -2028,7 +2028,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                             traits::ObligationCauseCode::RepeatVec(is_const_fn),\n                                         ),\n                                         self.param_env,\n-                                        ty::Binder::bind(ty::TraitRef::new(\n+                                        ty::Binder::dummy(ty::TraitRef::new(\n                                             self.tcx().require_lang_item(\n                                                 LangItem::Copy,\n                                                 Some(self.last_span),"}, {"sha": "c2ac1e289ce4e1d1a0451600f3bd9434a73b9afb", "filename": "compiler/rustc_mir/src/borrow_check/universal_regions.rs", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -580,7 +580,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n         let global_mapping = iter::once((tcx.lifetimes.re_static, fr_static));\n         let subst_mapping =\n-            identity_substs.regions().zip(fr_substs.regions().map(|r| r.to_region_vid()));\n+            iter::zip(identity_substs.regions(), fr_substs.regions().map(|r| r.to_region_vid()));\n \n         UniversalRegionIndices { indices: global_mapping.chain(subst_mapping).collect() }\n     }\n@@ -589,31 +589,45 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         &self,\n         indices: &UniversalRegionIndices<'tcx>,\n         defining_ty: DefiningTy<'tcx>,\n-    ) -> ty::Binder<&'tcx ty::List<Ty<'tcx>>> {\n+    ) -> ty::Binder<'tcx, &'tcx ty::List<Ty<'tcx>>> {\n         let tcx = self.infcx.tcx;\n         match defining_ty {\n             DefiningTy::Closure(def_id, substs) => {\n                 assert_eq!(self.mir_def.did.to_def_id(), def_id);\n                 let closure_sig = substs.as_closure().sig();\n                 let inputs_and_output = closure_sig.inputs_and_output();\n-                let closure_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n-                ty::Binder::fuse(closure_ty, inputs_and_output, |closure_ty, inputs_and_output| {\n-                    // The \"inputs\" of the closure in the\n-                    // signature appear as a tuple.  The MIR side\n-                    // flattens this tuple.\n-                    let (&output, tuplized_inputs) = inputs_and_output.split_last().unwrap();\n-                    assert_eq!(tuplized_inputs.len(), 1, \"multiple closure inputs\");\n-                    let inputs = match tuplized_inputs[0].kind() {\n-                        ty::Tuple(inputs) => inputs,\n-                        _ => bug!(\"closure inputs not a tuple: {:?}\", tuplized_inputs[0]),\n-                    };\n+                let bound_vars = tcx.mk_bound_variable_kinds(\n+                    inputs_and_output\n+                        .bound_vars()\n+                        .iter()\n+                        .chain(iter::once(ty::BoundVariableKind::Region(ty::BrEnv))),\n+                );\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_usize(bound_vars.len() - 1),\n+                    kind: ty::BrEnv,\n+                };\n+                let env_region = ty::ReLateBound(ty::INNERMOST, br);\n+                let closure_ty = tcx.closure_env_ty(def_id, substs, env_region).unwrap();\n+\n+                // The \"inputs\" of the closure in the\n+                // signature appear as a tuple.  The MIR side\n+                // flattens this tuple.\n+                let (&output, tuplized_inputs) =\n+                    inputs_and_output.skip_binder().split_last().unwrap();\n+                assert_eq!(tuplized_inputs.len(), 1, \"multiple closure inputs\");\n+                let inputs = match tuplized_inputs[0].kind() {\n+                    ty::Tuple(inputs) => inputs,\n+                    _ => bug!(\"closure inputs not a tuple: {:?}\", tuplized_inputs[0]),\n+                };\n \n+                ty::Binder::bind_with_vars(\n                     tcx.mk_type_list(\n                         iter::once(closure_ty)\n                             .chain(inputs.iter().map(|k| k.expect_ty()))\n                             .chain(iter::once(output)),\n-                    )\n-                })\n+                    ),\n+                    bound_vars,\n+                )\n             }\n \n             DefiningTy::Generator(def_id, substs, movability) => {\n@@ -657,7 +671,7 @@ trait InferCtxtExt<'tcx> {\n         &self,\n         origin: NllRegionVariableOrigin,\n         all_outlive_scope: LocalDefId,\n-        value: ty::Binder<T>,\n+        value: ty::Binder<'tcx, T>,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     ) -> T\n     where\n@@ -686,7 +700,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n         &self,\n         origin: NllRegionVariableOrigin,\n         all_outlive_scope: LocalDefId,\n-        value: ty::Binder<T>,\n+        value: ty::Binder<'tcx, T>,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     ) -> T\n     where"}, {"sha": "d51adc8864de59c80d7316b3324ffc557cc5e0d7", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -5,6 +5,7 @@ use crate::interpret::{\n     Immediate, InternKind, InterpCx, InterpResult, MPlaceTy, MemoryKind, OpTy, RefTracking, Scalar,\n     ScalarMaybeUninit, StackPopCleanup,\n };\n+use crate::util::pretty::display_allocation;\n \n use rustc_errors::ErrorReported;\n use rustc_hir::def::DefKind;\n@@ -360,6 +361,15 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n                     \"it is undefined behavior to use this value\",\n                     |mut diag| {\n                         diag.note(note_on_undefined_behavior_error());\n+                        diag.note(&format!(\n+                            \"the raw bytes of the constant ({}\",\n+                            display_allocation(\n+                                *ecx.tcx,\n+                                ecx.tcx\n+                                    .global_alloc(mplace.ptr.assert_ptr().alloc_id)\n+                                    .unwrap_memory()\n+                            )\n+                        ));\n                         diag.emit();\n                     },\n                 ))"}, {"sha": "3f14efc920f0edb3ad9e48033e696b0ae07e96d3", "filename": "compiler/rustc_mir/src/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -110,7 +110,7 @@ fn const_to_valtree_inner<'tcx>(\n \n             let variant = ecx.read_discriminant(&place.into()).unwrap().1;\n \n-            branches(def.variants[variant].fields.len(), Some(variant))\n+            branches(def.variants[variant].fields.len(), def.is_enum().then_some(variant))\n         }\n \n         ty::Never"}, {"sha": "c000e49c14bc1b72483803e310601e420be49193", "filename": "compiler/rustc_mir/src/dataflow/framework/cursor.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fcursor.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -64,10 +64,6 @@ where\n         }\n     }\n \n-    pub fn body(&self) -> &'mir mir::Body<'tcx> {\n-        self.body\n-    }\n-\n     /// Returns the underlying `Results`.\n     pub fn results(&self) -> &Results<'tcx, A> {\n         &self.results.borrow()"}, {"sha": "f937b31f4cfc9d00afb13f31958ec9ba856e8e4c", "filename": "compiler/rustc_mir/src/dataflow/framework/lattice.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Flattice.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -40,6 +40,7 @@\n \n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n+use std::iter;\n \n /// A [partially ordered set][poset] that has a [least upper bound][lub] for any pair of elements\n /// in the set.\n@@ -110,7 +111,7 @@ impl<I: Idx, T: JoinSemiLattice> JoinSemiLattice for IndexVec<I, T> {\n         assert_eq!(self.len(), other.len());\n \n         let mut changed = false;\n-        for (a, b) in self.iter_mut().zip(other.iter()) {\n+        for (a, b) in iter::zip(self, other) {\n             changed |= a.join(b);\n         }\n         changed\n@@ -122,7 +123,7 @@ impl<I: Idx, T: MeetSemiLattice> MeetSemiLattice for IndexVec<I, T> {\n         assert_eq!(self.len(), other.len());\n \n         let mut changed = false;\n-        for (a, b) in self.iter_mut().zip(other.iter()) {\n+        for (a, b) in iter::zip(self, other) {\n             changed |= a.meet(b);\n         }\n         changed"}, {"sha": "c92cff1433f1a50ef520de7fb21089063fea738d", "filename": "compiler/rustc_mir/src/dataflow/impls/borrows.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrows.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -11,6 +11,7 @@ use crate::borrow_check::{\n use crate::dataflow::{self, fmt::DebugWithContext, GenKill};\n \n use std::fmt;\n+use std::iter;\n \n rustc_index::newtype_index! {\n     pub struct BorrowIndex {\n@@ -292,7 +293,7 @@ impl<'tcx> dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n             }\n \n             mir::StatementKind::LlvmInlineAsm(ref asm) => {\n-                for (output, kind) in asm.outputs.iter().zip(&asm.asm.outputs) {\n+                for (output, kind) in iter::zip(&*asm.outputs, &asm.asm.outputs) {\n                     if !kind.is_indirect && !kind.is_rw {\n                         self.kill_borrows_on_place(trans, *output);\n                     }"}, {"sha": "538d8921869c3e7267fe0f53ad2c40f12e426cb9", "filename": "compiler/rustc_mir/src/dataflow/move_paths/builder.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -4,6 +4,7 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::{self, TyCtxt};\n use smallvec::{smallvec, SmallVec};\n \n+use std::iter;\n use std::mem;\n \n use super::abs_domain::Lift;\n@@ -292,11 +293,11 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 }\n                 self.gather_rvalue(rval);\n             }\n-            StatementKind::FakeRead(_, place) => {\n-                self.create_move_path(**place);\n+            StatementKind::FakeRead(box (_, place)) => {\n+                self.create_move_path(*place);\n             }\n             StatementKind::LlvmInlineAsm(ref asm) => {\n-                for (output, kind) in asm.outputs.iter().zip(&asm.asm.outputs) {\n+                for (output, kind) in iter::zip(&*asm.outputs, &asm.asm.outputs) {\n                     if !kind.is_indirect {\n                         self.gather_init(output.as_ref(), InitKind::Deep);\n                     }"}, {"sha": "2d83d6cfbdc5ed9c2249655b57f4aaaff8a7014f", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -232,6 +232,8 @@ impl<'mir, 'tcx, Tag, Extra> Frame<'mir, 'tcx, Tag, Extra> {\n     /// this frame (can happen e.g. during frame initialization, and during unwinding on\n     /// frames without cleanup code).\n     /// We basically abuse `Result` as `Either`.\n+    ///\n+    /// Used by priroda.\n     pub fn current_loc(&self) -> Result<mir::Location, Span> {\n         self.loc\n     }\n@@ -459,11 +461,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ty.size.truncate(value)\n     }\n \n-    #[inline]\n-    pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_sized(self.tcx, self.param_env)\n-    }\n-\n     #[inline]\n     pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n         ty.is_freeze(self.tcx, self.param_env)\n@@ -527,6 +524,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n+    #[inline(always)]\n     pub fn layout_of_local(\n         &self,\n         frame: &Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,"}, {"sha": "d74ef66a4b236d740170d2d95cb946375be99eed", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -171,8 +171,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 let val =\n                     self.tcx.const_eval_global_id(self.param_env, gid, Some(self.tcx.span))?;\n-                let const_ = ty::Const { val: ty::ConstKind::Value(val), ty };\n-                let val = self.const_to_op(&const_, None)?;\n+                let val = self.const_val_to_op(val, ty, Some(dest.layout))?;\n                 self.copy_op(&val, dest)?;\n             }\n "}, {"sha": "ae5e78ee33f472ef04eec379c512cb5997154fea", "filename": "compiler/rustc_mir/src/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n \n     fn print_dyn_existential(\n         mut self,\n-        predicates: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n+        predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n         let mut first = true;\n         for p in predicates {"}, {"sha": "50a205676fe0c2faaa701aec1288a06777bbf652", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -77,14 +77,6 @@ impl<'tcx, Tag> Immediate<Tag> {\n     pub fn to_scalar(self) -> InterpResult<'tcx, Scalar<Tag>> {\n         self.to_scalar_or_uninit().check_init()\n     }\n-\n-    #[inline]\n-    pub fn to_scalar_pair(self) -> InterpResult<'tcx, (Scalar<Tag>, Scalar<Tag>)> {\n-        match self {\n-            Immediate::Scalar(..) => bug!(\"Got a thin pointer where a scalar pair was expected\"),\n-            Immediate::ScalarPair(a, b) => Ok((a.check_init()?, b.check_init()?)),\n-        }\n-    }\n }\n \n // ScalarPair needs a type to interpret, so we often have an immediate and a type together\n@@ -578,7 +570,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         match val {\n             mir::ConstantKind::Ty(ct) => self.const_to_op(ct, layout),\n-            mir::ConstantKind::Val(val, ty) => self.const_val_to_op(*val, ty, None),\n+            mir::ConstantKind::Val(val, ty) => self.const_val_to_op(*val, ty, layout),\n         }\n     }\n "}, {"sha": "b0db4f9e649b31b437a8461b7677540414095381", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -18,6 +18,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(decl_macro)]\n #![feature(exact_size_is_empty)]\n #![feature(exhaustive_patterns)]\n+#![feature(iter_zip)]\n #![feature(never_type)]\n #![feature(map_try_insert)]\n #![feature(min_specialization)]"}, {"sha": "1fda71d74bbf5a1a100f8a62527625fe5e8b4c46", "filename": "compiler/rustc_mir/src/monomorphize/collector.rs", "status": "modified", "additions": 45, "deletions": 6, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -59,11 +59,15 @@\n //!\n //! ### Discovering roots\n //!\n-//! The roots of the mono item graph correspond to the non-generic\n+//! The roots of the mono item graph correspond to the public non-generic\n //! syntactic items in the source code. We find them by walking the HIR of the\n-//! crate, and whenever we hit upon a function, method, or static item, we\n-//! create a mono item consisting of the items DefId and, since we only\n-//! consider non-generic items, an empty type-substitution set.\n+//! crate, and whenever we hit upon a public function, method, or static item,\n+//! we create a mono item consisting of the items DefId and, since we only\n+//! consider non-generic items, an empty type-substitution set. (In eager\n+//! collection mode, during incremental compilation, all non-generic functions\n+//! are considered as roots, as well as when the `-Clink-dead-code` option is\n+//! specified. Functions marked `#[no_mangle]` and functions called by inlinable\n+//! functions also always act as roots.)\n //!\n //! ### Finding neighbor nodes\n //! Given a mono item node, we can discover neighbors by inspecting its\n@@ -184,7 +188,6 @@ use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::bit_set::GrowableBitSet;\n-use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::interpret::{AllocId, ConstValue};\n use rustc_middle::mir::interpret::{ErrorHandled, GlobalAlloc, Scalar};\n use rustc_middle::mir::mono::{InstantiationMode, MonoItem};\n@@ -193,6 +196,7 @@ use rustc_middle::mir::{self, Local, Location};\n use rustc_middle::ty::adjustment::{CustomCoerceUnsized, PointerCast};\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::{self, GenericParamDefKind, Instance, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::{middle::codegen_fn_attrs::CodegenFnAttrFlags, mir::visit::TyContext};\n use rustc_session::config::EntryFnType;\n use rustc_span::source_map::{dummy_spanned, respan, Span, Spanned, DUMMY_SP};\n use smallvec::SmallVec;\n@@ -638,6 +642,35 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         self.super_rvalue(rvalue, location);\n     }\n \n+    /// This does not walk the constant, as it has been handled entirely here and trying\n+    /// to walk it would attempt to evaluate the `ty::Const` inside, which doesn't necessarily\n+    /// work, as some constants cannot be represented in the type system.\n+    fn visit_constant(&mut self, constant: &mir::Constant<'tcx>, location: Location) {\n+        let literal = self.monomorphize(constant.literal);\n+        let val = match literal {\n+            mir::ConstantKind::Val(val, _) => val,\n+            mir::ConstantKind::Ty(ct) => match ct.val {\n+                ty::ConstKind::Value(val) => val,\n+                ty::ConstKind::Unevaluated(ct) => {\n+                    let param_env = ty::ParamEnv::reveal_all();\n+                    match self.tcx.const_eval_resolve(param_env, ct, None) {\n+                        // The `monomorphize` call should have evaluated that constant already.\n+                        Ok(val) => val,\n+                        Err(ErrorHandled::Reported(ErrorReported) | ErrorHandled::Linted) => return,\n+                        Err(ErrorHandled::TooGeneric) => span_bug!(\n+                            self.body.source_info(location).span,\n+                            \"collection encountered polymorphic constant: {:?}\",\n+                            literal\n+                        ),\n+                    }\n+                }\n+                _ => return,\n+            },\n+        };\n+        collect_const_value(self.tcx, val, self.output);\n+        self.visit_ty(literal.ty(), TyContext::Location(location));\n+    }\n+\n     fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, location: Location) {\n         debug!(\"visiting const {:?} @ {:?}\", *constant, location);\n \n@@ -648,7 +681,13 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             ty::ConstKind::Value(val) => collect_const_value(self.tcx, val, self.output),\n             ty::ConstKind::Unevaluated(unevaluated) => {\n                 match self.tcx.const_eval_resolve(param_env, unevaluated, None) {\n-                    Ok(val) => collect_const_value(self.tcx, val, self.output),\n+                    // The `monomorphize` call should have evaluated that constant already.\n+                    Ok(val) => span_bug!(\n+                        self.body.source_info(location).span,\n+                        \"collection encountered the unevaluated constant {} which evaluated to {:?}\",\n+                        substituted_constant,\n+                        val\n+                    ),\n                     Err(ErrorHandled::Reported(ErrorReported) | ErrorHandled::Linted) => {}\n                     Err(ErrorHandled::TooGeneric) => span_bug!(\n                         self.body.source_info(location).span,"}, {"sha": "9ca4b6687f1b54b934eaf0319653cb4c39d1c735", "filename": "compiler/rustc_mir/src/monomorphize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -8,14 +8,14 @@ pub mod collector;\n pub mod partitioning;\n pub mod polymorphize;\n \n-pub fn custom_coerce_unsize_info<'tcx>(\n+fn custom_coerce_unsize_info<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     source_ty: Ty<'tcx>,\n     target_ty: Ty<'tcx>,\n ) -> CustomCoerceUnsized {\n     let def_id = tcx.require_lang_item(LangItem::CoerceUnsized, None);\n \n-    let trait_ref = ty::Binder::bind(ty::TraitRef {\n+    let trait_ref = ty::Binder::dummy(ty::TraitRef {\n         def_id,\n         substs: tcx.mk_substs_trait(source_ty, &[target_ty.into()]),\n     });"}, {"sha": "dc2379fd92b834cba2dc31d3919230fbbede99f1", "filename": "compiler/rustc_mir/src/monomorphize/partitioning/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -196,13 +196,7 @@ pub fn partition<'tcx>(\n \n     // Next we try to make as many symbols \"internal\" as possible, so LLVM has\n     // more freedom to optimize.\n-    if !tcx.sess.link_dead_code() && !tcx.sess.instrument_coverage() {\n-        // Disabled for `-Z instrument-coverage` because some LLVM optimizations can sometimes\n-        // break coverage results. Tests that failed at certain optimization levels are now\n-        // validated at those optimization levels (via `compile-flags` directive); for example:\n-        //   * `src/test/run-make-fulldeps/coverage/async.rs` broke with `-C opt-level=1`\n-        //   * `src/test/run-make-fulldeps/coverage/closure.rs` broke with `-C opt-level=2`, and\n-        //     also required disabling `generate_gcu_internal_copies` in `rustc_middle/mir/mono.rs`\n+    if !tcx.sess.link_dead_code() {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_internalize_symbols\");\n         partitioner.internalize_symbols(cx, &mut post_inlining);\n     }"}, {"sha": "ce5e41d3e7c866289896035965f68414bea0f1f6", "filename": "compiler/rustc_mir/src/transform/check_consts/validation.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -850,9 +850,12 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                     let obligation = Obligation::new(\n                         ObligationCause::dummy(),\n                         param_env,\n-                        Binder::bind(TraitPredicate {\n-                            trait_ref: TraitRef::from_method(tcx, trait_id, substs),\n-                        }),\n+                        Binder::bind(\n+                            TraitPredicate {\n+                                trait_ref: TraitRef::from_method(tcx, trait_id, substs),\n+                            },\n+                            tcx,\n+                        ),\n                     );\n \n                     let implsrc = tcx.infer_ctxt().enter(|infcx| {"}, {"sha": "13b7221046bda4deb87d7eddd1b0f3f7d9480984", "filename": "compiler/rustc_mir/src/transform/check_packed_ref.rs", "status": "modified", "additions": 69, "deletions": 20, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_packed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_packed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_packed_ref.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,11 +1,18 @@\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::*;\n+use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint::builtin::UNALIGNED_REFERENCES;\n+use rustc_span::symbol::sym;\n \n use crate::transform::MirPass;\n use crate::util;\n \n+pub(crate) fn provide(providers: &mut Providers) {\n+    *providers = Providers { unsafe_derive_on_repr_packed, ..*providers };\n+}\n+\n pub struct CheckPackedRef;\n \n impl<'tcx> MirPass<'tcx> for CheckPackedRef {\n@@ -24,6 +31,41 @@ struct PackedRefChecker<'a, 'tcx> {\n     source_info: SourceInfo,\n }\n \n+fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n+    let lint_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+\n+    tcx.struct_span_lint_hir(UNALIGNED_REFERENCES, lint_hir_id, tcx.def_span(def_id), |lint| {\n+        // FIXME: when we make this a hard error, this should have its\n+        // own error code.\n+        let message = if tcx.generics_of(def_id).own_requires_monomorphization() {\n+            \"`#[derive]` can't be used on a `#[repr(packed)]` struct with \\\n+             type or const parameters (error E0133)\"\n+                .to_string()\n+        } else {\n+            \"`#[derive]` can't be used on a `#[repr(packed)]` struct that \\\n+             does not derive Copy (error E0133)\"\n+                .to_string()\n+        };\n+        lint.build(&message).emit()\n+    });\n+}\n+\n+fn builtin_derive_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n+    debug!(\"builtin_derive_def_id({:?})\", def_id);\n+    if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n+        if tcx.has_attr(impl_def_id, sym::automatically_derived) {\n+            debug!(\"builtin_derive_def_id({:?}) - is {:?}\", def_id, impl_def_id);\n+            Some(impl_def_id)\n+        } else {\n+            debug!(\"builtin_derive_def_id({:?}) - not automatically derived\", def_id);\n+            None\n+        }\n+    } else {\n+        debug!(\"builtin_derive_def_id({:?}) - not a method\", def_id);\n+        None\n+    }\n+}\n+\n impl<'a, 'tcx> Visitor<'tcx> for PackedRefChecker<'a, 'tcx> {\n     fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n         // Make sure we know where in the MIR we are.\n@@ -40,26 +82,33 @@ impl<'a, 'tcx> Visitor<'tcx> for PackedRefChecker<'a, 'tcx> {\n     fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, _location: Location) {\n         if context.is_borrow() {\n             if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n-                let source_info = self.source_info;\n-                let lint_root = self.body.source_scopes[source_info.scope]\n-                    .local_data\n-                    .as_ref()\n-                    .assert_crate_local()\n-                    .lint_root;\n-                self.tcx.struct_span_lint_hir(\n-                    UNALIGNED_REFERENCES,\n-                    lint_root,\n-                    source_info.span,\n-                    |lint| {\n-                        lint.build(\"reference to packed field is unaligned\")\n-                            .note(\n-                                \"fields of packed structs are not properly aligned, and creating \\\n-                                a misaligned reference is undefined behavior (even if that \\\n-                                reference is never dereferenced)\",\n-                            )\n-                            .emit()\n-                    },\n-                );\n+                let def_id = self.body.source.instance.def_id();\n+                if let Some(impl_def_id) = builtin_derive_def_id(self.tcx, def_id) {\n+                    // If a method is defined in the local crate,\n+                    // the impl containing that method should also be.\n+                    self.tcx.ensure().unsafe_derive_on_repr_packed(impl_def_id.expect_local());\n+                } else {\n+                    let source_info = self.source_info;\n+                    let lint_root = self.body.source_scopes[source_info.scope]\n+                        .local_data\n+                        .as_ref()\n+                        .assert_crate_local()\n+                        .lint_root;\n+                    self.tcx.struct_span_lint_hir(\n+                        UNALIGNED_REFERENCES,\n+                        lint_root,\n+                        source_info.span,\n+                        |lint| {\n+                            lint.build(\"reference to packed field is unaligned\")\n+                                .note(\n+                                    \"fields of packed structs are not properly aligned, and creating \\\n+                                    a misaligned reference is undefined behavior (even if that \\\n+                                    reference is never dereferenced)\",\n+                                )\n+                                .emit()\n+                        },\n+                    );\n+                }\n             }\n         }\n     }"}, {"sha": "09da9b2e4d6ffd29a9cd470b06094f8069da3952", "filename": "compiler/rustc_mir/src/transform/check_unsafety.rs", "status": "modified", "additions": 7, "deletions": 123, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -10,14 +10,12 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_session::lint::builtin::{SAFE_PACKED_BORROWS, UNSAFE_OP_IN_UNSAFE_FN, UNUSED_UNSAFE};\n+use rustc_session::lint::builtin::{UNSAFE_OP_IN_UNSAFE_FN, UNUSED_UNSAFE};\n use rustc_session::lint::Level;\n-use rustc_span::symbol::sym;\n \n use std::ops::Bound;\n \n use crate::const_eval::is_min_const_fn;\n-use crate::util;\n \n pub struct UnsafetyChecker<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n@@ -182,18 +180,6 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             self.check_mut_borrowing_layout_constrained_field(*place, context.is_mutating_use());\n         }\n \n-        // Check for borrows to packed fields.\n-        // `is_disaligned` already traverses the place to consider all projections after the last\n-        // `Deref`, so this only needs to be called once at the top level.\n-        if context.is_borrow() {\n-            if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n-                self.require_unsafe(\n-                    UnsafetyViolationKind::BorrowPacked,\n-                    UnsafetyViolationDetails::BorrowOfPackedField,\n-                );\n-            }\n-        }\n-\n         // Some checks below need the extra metainfo of the local declaration.\n         let decl = &self.body.local_decls[place.local];\n \n@@ -317,25 +303,15 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n             // `unsafe` blocks are required in safe code\n             Safety::Safe => {\n                 for violation in violations {\n-                    let mut violation = *violation;\n                     match violation.kind {\n                         UnsafetyViolationKind::GeneralAndConstFn\n                         | UnsafetyViolationKind::General => {}\n-                        UnsafetyViolationKind::BorrowPacked => {\n-                            if self.min_const_fn {\n-                                // const fns don't need to be backwards compatible and can\n-                                // emit these violations as a hard error instead of a backwards\n-                                // compat lint\n-                                violation.kind = UnsafetyViolationKind::General;\n-                            }\n-                        }\n-                        UnsafetyViolationKind::UnsafeFn\n-                        | UnsafetyViolationKind::UnsafeFnBorrowPacked => {\n+                        UnsafetyViolationKind::UnsafeFn => {\n                             bug!(\"`UnsafetyViolationKind::UnsafeFn` in an `Safe` context\")\n                         }\n                     }\n-                    if !self.violations.contains(&violation) {\n-                        self.violations.push(violation)\n+                    if !self.violations.contains(violation) {\n+                        self.violations.push(*violation)\n                     }\n                 }\n                 false\n@@ -345,11 +321,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                 for violation in violations {\n                     let mut violation = *violation;\n \n-                    if violation.kind == UnsafetyViolationKind::BorrowPacked {\n-                        violation.kind = UnsafetyViolationKind::UnsafeFnBorrowPacked;\n-                    } else {\n-                        violation.kind = UnsafetyViolationKind::UnsafeFn;\n-                    }\n+                    violation.kind = UnsafetyViolationKind::UnsafeFn;\n                     if !self.violations.contains(&violation) {\n                         self.violations.push(violation)\n                     }\n@@ -369,8 +341,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                             // these unsafe things are stable in const fn\n                             UnsafetyViolationKind::GeneralAndConstFn => {}\n                             // these things are forbidden in const fns\n-                            UnsafetyViolationKind::General\n-                            | UnsafetyViolationKind::BorrowPacked => {\n+                            UnsafetyViolationKind::General => {\n                                 let mut violation = *violation;\n                                 // const fns don't need to be backwards compatible and can\n                                 // emit these violations as a hard error instead of a backwards\n@@ -380,8 +351,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                                     self.violations.push(violation)\n                                 }\n                             }\n-                            UnsafetyViolationKind::UnsafeFn\n-                            | UnsafetyViolationKind::UnsafeFnBorrowPacked => bug!(\n+                            UnsafetyViolationKind::UnsafeFn => bug!(\n                                 \"`UnsafetyViolationKind::UnsafeFn` in an `ExplicitUnsafe` context\"\n                             ),\n                         }\n@@ -464,7 +434,6 @@ pub(crate) fn provide(providers: &mut Providers) {\n                 ty::WithOptConstParam { did, const_param_did: Some(param_did) },\n             )\n         },\n-        unsafe_derive_on_repr_packed,\n         ..*providers\n     };\n }\n@@ -544,25 +513,6 @@ fn unsafety_check_result<'tcx>(\n     })\n }\n \n-fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    let lint_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-\n-    tcx.struct_span_lint_hir(SAFE_PACKED_BORROWS, lint_hir_id, tcx.def_span(def_id), |lint| {\n-        // FIXME: when we make this a hard error, this should have its\n-        // own error code.\n-        let message = if tcx.generics_of(def_id).own_requires_monomorphization() {\n-            \"`#[derive]` can't be used on a `#[repr(packed)]` struct with \\\n-             type or const parameters (error E0133)\"\n-                .to_string()\n-        } else {\n-            \"`#[derive]` can't be used on a `#[repr(packed)]` struct that \\\n-             does not derive Copy (error E0133)\"\n-                .to_string()\n-        };\n-        lint.build(&message).emit()\n-    });\n-}\n-\n /// Returns the `HirId` for an enclosing scope that is also `unsafe`.\n fn is_enclosed(\n     tcx: TyCtxt<'_>,\n@@ -609,22 +559,6 @@ fn report_unused_unsafe(tcx: TyCtxt<'_>, used_unsafe: &FxHashSet<hir::HirId>, id\n     });\n }\n \n-fn builtin_derive_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n-    debug!(\"builtin_derive_def_id({:?})\", def_id);\n-    if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n-        if tcx.has_attr(impl_def_id, sym::automatically_derived) {\n-            debug!(\"builtin_derive_def_id({:?}) - is {:?}\", def_id, impl_def_id);\n-            Some(impl_def_id)\n-        } else {\n-            debug!(\"builtin_derive_def_id({:?}) - not automatically derived\", def_id);\n-            None\n-        }\n-    } else {\n-        debug!(\"builtin_derive_def_id({:?}) - not a method\", def_id);\n-        None\n-    }\n-}\n-\n pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     debug!(\"check_unsafety({:?})\", def_id);\n \n@@ -657,27 +591,6 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                 .note(note)\n                 .emit();\n             }\n-            UnsafetyViolationKind::BorrowPacked => {\n-                if let Some(impl_def_id) = builtin_derive_def_id(tcx, def_id.to_def_id()) {\n-                    // If a method is defined in the local crate,\n-                    // the impl containing that method should also be.\n-                    tcx.ensure().unsafe_derive_on_repr_packed(impl_def_id.expect_local());\n-                } else {\n-                    tcx.struct_span_lint_hir(\n-                        SAFE_PACKED_BORROWS,\n-                        lint_root,\n-                        source_info.span,\n-                        |lint| {\n-                            lint.build(&format!(\n-                                \"{} is unsafe and requires unsafe{} block (error E0133)\",\n-                                description, unsafe_fn_msg,\n-                            ))\n-                            .note(note)\n-                            .emit()\n-                        },\n-                    )\n-                }\n-            }\n             UnsafetyViolationKind::UnsafeFn => tcx.struct_span_lint_hir(\n                 UNSAFE_OP_IN_UNSAFE_FN,\n                 lint_root,\n@@ -692,35 +605,6 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                     .emit();\n                 },\n             ),\n-            UnsafetyViolationKind::UnsafeFnBorrowPacked => {\n-                // When `unsafe_op_in_unsafe_fn` is disallowed, the behavior of safe and unsafe functions\n-                // should be the same in terms of warnings and errors. Therefore, with `#[warn(safe_packed_borrows)]`,\n-                // a safe packed borrow should emit a warning *but not an error* in an unsafe function,\n-                // just like in a safe function, even if `unsafe_op_in_unsafe_fn` is `deny`.\n-                //\n-                // Also, `#[warn(unsafe_op_in_unsafe_fn)]` can't cause any new errors. Therefore, with\n-                // `#[deny(safe_packed_borrows)]` and `#[warn(unsafe_op_in_unsafe_fn)]`, a packed borrow\n-                // should only issue a warning for the sake of backwards compatibility.\n-                //\n-                // The solution those 2 expectations is to always take the minimum of both lints.\n-                // This prevent any new errors (unless both lints are explicitly set to `deny`).\n-                let lint = if tcx.lint_level_at_node(SAFE_PACKED_BORROWS, lint_root).0\n-                    <= tcx.lint_level_at_node(UNSAFE_OP_IN_UNSAFE_FN, lint_root).0\n-                {\n-                    SAFE_PACKED_BORROWS\n-                } else {\n-                    UNSAFE_OP_IN_UNSAFE_FN\n-                };\n-                tcx.struct_span_lint_hir(&lint, lint_root, source_info.span, |lint| {\n-                    lint.build(&format!(\n-                        \"{} is unsafe and requires unsafe block (error E0133)\",\n-                        description,\n-                    ))\n-                    .span_label(source_info.span, description)\n-                    .note(note)\n-                    .emit();\n-                })\n-            }\n         }\n     }\n "}, {"sha": "0e9728df73ca749520a62b7e873487f15d3fa3f3", "filename": "compiler/rustc_mir/src/transform/coverage/debug.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -121,6 +121,7 @@ use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::{self, BasicBlock, TerminatorKind};\n use rustc_middle::ty::TyCtxt;\n \n+use std::iter;\n use std::lazy::SyncOnceCell;\n \n pub const NESTED_INDENT: &str = \"    \";\n@@ -703,9 +704,7 @@ pub(super) fn dump_coverage_graphviz(\n         let edge_counters = from_terminator\n             .successors()\n             .map(|&successor_bb| graphviz_data.get_edge_counter(from_bcb, successor_bb));\n-        edge_labels\n-            .iter()\n-            .zip(edge_counters)\n+        iter::zip(&edge_labels, edge_counters)\n             .map(|(label, some_counter)| {\n                 if let Some(counter) = some_counter {\n                     format!(\"{}\\n{}\", label, debug_counters.format_counter(counter))"}, {"sha": "324d826b375c1976d9a23b3a8e1e1a2e16a42272", "filename": "compiler/rustc_mir/src/transform/coverage/spans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -683,10 +683,10 @@ pub(super) fn filtered_statement_span(\n         // and `_1` is the `Place` for `somenum`.\n         //\n         // If and when the Issue is resolved, remove this special case match pattern:\n-        StatementKind::FakeRead(cause, _) if cause == FakeReadCause::ForGuardBinding => None,\n+        StatementKind::FakeRead(box (cause, _)) if cause == FakeReadCause::ForGuardBinding => None,\n \n         // Retain spans from all other statements\n-        StatementKind::FakeRead(_, _) // Not including `ForGuardBinding`\n+        StatementKind::FakeRead(box (_, _)) // Not including `ForGuardBinding`\n         | StatementKind::CopyNonOverlapping(..)\n         | StatementKind::Assign(_)\n         | StatementKind::SetDiscriminant { .. }"}, {"sha": "c41e71e09a4efc7d64186850460538b2b254d0cb", "filename": "compiler/rustc_mir/src/transform/deduplicate_blocks.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdeduplicate_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdeduplicate_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdeduplicate_blocks.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,7 +1,7 @@\n //! This pass finds basic blocks that are completely equal,\n //! and replaces all uses with just one of them.\n \n-use std::{collections::hash_map::Entry, hash::Hash, hash::Hasher};\n+use std::{collections::hash_map::Entry, hash::Hash, hash::Hasher, iter};\n \n use crate::transform::MirPass;\n \n@@ -115,11 +115,7 @@ impl<'tcx, 'a> PartialEq for BasicBlockHashable<'tcx, 'a> {\n     fn eq(&self, other: &Self) -> bool {\n         self.basic_block_data.statements.len() == other.basic_block_data.statements.len()\n             && &self.basic_block_data.terminator().kind == &other.basic_block_data.terminator().kind\n-            && self\n-                .basic_block_data\n-                .statements\n-                .iter()\n-                .zip(&other.basic_block_data.statements)\n+            && iter::zip(&self.basic_block_data.statements, &other.basic_block_data.statements)\n                 .all(|(x, y)| statement_eq(&x.kind, &y.kind))\n     }\n }"}, {"sha": "f7a9835353e5cff77c14c762641f2bf99103e088", "filename": "compiler/rustc_mir/src/transform/match_branches.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,6 +1,7 @@\n use crate::transform::MirPass;\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n+use std::iter;\n \n use super::simplify::simplify_cfg;\n \n@@ -83,7 +84,7 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n             if first_stmts.len() != scnd_stmts.len() {\n                 continue;\n             }\n-            for (f, s) in first_stmts.iter().zip(scnd_stmts.iter()) {\n+            for (f, s) in iter::zip(first_stmts, scnd_stmts) {\n                 match (&f.kind, &s.kind) {\n                     // If two statements are exactly the same, we can optimize.\n                     (f_s, s_s) if f_s == s_s => {}\n@@ -113,7 +114,7 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n             // and bb_idx has a different terminator from both of them.\n             let (from, first, second) = bbs.pick3_mut(bb_idx, first, second);\n \n-            let new_stmts = first.statements.iter().zip(second.statements.iter()).map(|(f, s)| {\n+            let new_stmts = iter::zip(&first.statements, &second.statements).map(|(f, s)| {\n                 match (&f.kind, &s.kind) {\n                     (f_s, s_s) if f_s == s_s => (*f).clone(),\n "}, {"sha": "5c49ee69edc51622a24aec74be2f1bf6733e583e", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -59,6 +59,7 @@ pub use rustc_middle::mir::MirSource;\n \n pub(crate) fn provide(providers: &mut Providers) {\n     self::check_unsafety::provide(providers);\n+    self::check_packed_ref::provide(providers);\n     *providers = Providers {\n         mir_keys,\n         mir_const,"}, {"sha": "5d4ca871faa2e46d3e0d189649afee1fdf465fb1", "filename": "compiler/rustc_mir/src/util/alignment.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Falignment.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,5 +1,6 @@\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, TyCtxt};\n+use rustc_target::abi::Align;\n \n /// Returns `true` if this place is allowed to be less aligned\n /// than its containing struct (because it is within a packed\n@@ -14,17 +15,25 @@ where\n     L: HasLocalDecls<'tcx>,\n {\n     debug!(\"is_disaligned({:?})\", place);\n-    if !is_within_packed(tcx, local_decls, place) {\n-        debug!(\"is_disaligned({:?}) - not within packed\", place);\n-        return false;\n-    }\n+    let pack = match is_within_packed(tcx, local_decls, place) {\n+        None => {\n+            debug!(\"is_disaligned({:?}) - not within packed\", place);\n+            return false;\n+        }\n+        Some(pack) => pack,\n+    };\n \n     let ty = place.ty(local_decls, tcx).ty;\n     match tcx.layout_raw(param_env.and(ty)) {\n-        Ok(layout) if layout.align.abi.bytes() == 1 => {\n-            // if the alignment is 1, the type can't be further\n-            // disaligned.\n-            debug!(\"is_disaligned({:?}) - align = 1\", place);\n+        Ok(layout) if layout.align.abi <= pack => {\n+            // If the packed alignment is greater or equal to the field alignment, the type won't be\n+            // further disaligned.\n+            debug!(\n+                \"is_disaligned({:?}) - align = {}, packed = {}; not disaligned\",\n+                place,\n+                layout.align.abi.bytes(),\n+                pack.bytes()\n+            );\n             false\n         }\n         _ => {\n@@ -34,7 +43,11 @@ where\n     }\n }\n \n-fn is_within_packed<'tcx, L>(tcx: TyCtxt<'tcx>, local_decls: &L, place: Place<'tcx>) -> bool\n+fn is_within_packed<'tcx, L>(\n+    tcx: TyCtxt<'tcx>,\n+    local_decls: &L,\n+    place: Place<'tcx>,\n+) -> Option<Align>\n where\n     L: HasLocalDecls<'tcx>,\n {\n@@ -45,13 +58,13 @@ where\n             ProjectionElem::Field(..) => {\n                 let ty = place_base.ty(local_decls, tcx).ty;\n                 match ty.kind() {\n-                    ty::Adt(def, _) if def.repr.packed() => return true,\n+                    ty::Adt(def, _) => return def.repr.pack,\n                     _ => {}\n                 }\n             }\n             _ => {}\n         }\n     }\n \n-    false\n+    None\n }"}, {"sha": "21c18b28e258ba2d389099d61a2100d3f1cf43a5", "filename": "compiler/rustc_mir/src/util/generic_graphviz.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgeneric_graphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgeneric_graphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgeneric_graphviz.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -40,22 +40,6 @@ impl<\n         }\n     }\n \n-    pub fn new_subgraph(\n-        graph: &'a G,\n-        graphviz_name: &str,\n-        node_content_fn: NodeContentFn,\n-        edge_labels_fn: EdgeLabelsFn,\n-    ) -> Self {\n-        Self {\n-            graph,\n-            is_subgraph: true,\n-            graphviz_name: graphviz_name.to_owned(),\n-            graph_label: None,\n-            node_content_fn,\n-            edge_labels_fn,\n-        }\n-    }\n-\n     pub fn set_graph_label(&mut self, graph_label: &str) {\n         self.graph_label = Some(graph_label.to_owned());\n     }"}, {"sha": "d09195f53aecc6c0cde6c071debcfd738ad569a9", "filename": "compiler/rustc_mir/src/util/patch.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpatch.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -13,7 +13,6 @@ pub struct MirPatch<'tcx> {\n     new_locals: Vec<LocalDecl<'tcx>>,\n     resume_block: BasicBlock,\n     next_local: usize,\n-    make_nop: Vec<Location>,\n }\n \n impl<'tcx> MirPatch<'tcx> {\n@@ -25,7 +24,6 @@ impl<'tcx> MirPatch<'tcx> {\n             new_locals: vec![],\n             next_local: body.local_decls.len(),\n             resume_block: START_BLOCK,\n-            make_nop: vec![],\n         };\n \n         // make sure the MIR we create has a resume block. It is\n@@ -117,15 +115,7 @@ impl<'tcx> MirPatch<'tcx> {\n         self.add_statement(loc, StatementKind::Assign(box (place, rv)));\n     }\n \n-    pub fn make_nop(&mut self, loc: Location) {\n-        self.make_nop.push(loc);\n-    }\n-\n     pub fn apply(self, body: &mut Body<'tcx>) {\n-        debug!(\"MirPatch: make nops at: {:?}\", self.make_nop);\n-        for loc in self.make_nop {\n-            body.make_statement_nop(loc);\n-        }\n         debug!(\n             \"MirPatch: {:?} new temps, starting from index {}: {:?}\",\n             self.new_locals.len(),"}, {"sha": "3b88aec16b26a638fabc287466c3d7fcf78880e2", "filename": "compiler/rustc_mir/src/util/pretty.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -452,7 +452,11 @@ impl Visitor<'tcx> for ExtraComments<'tcx> {\n                 match literal {\n                     ConstantKind::Ty(literal) => self.push(&format!(\"+ literal: {:?}\", literal)),\n                     ConstantKind::Val(val, ty) => {\n-                        self.push(&format!(\"+ literal: {:?}, {}\", val, ty))\n+                        // To keep the diffs small, we render this almost like we render ty::Const\n+                        self.push(&format!(\n+                            \"+ literal: Const {{ ty: {}, val: Value({:?}) }}\",\n+                            ty, val\n+                        ))\n                     }\n                 }\n             }\n@@ -465,7 +469,21 @@ impl Visitor<'tcx> for ExtraComments<'tcx> {\n         if use_verbose(ty) {\n             self.push(\"ty::Const\");\n             self.push(&format!(\"+ ty: {:?}\", ty));\n-            self.push(&format!(\"+ val: {:?}\", val));\n+            let val = match val {\n+                ty::ConstKind::Param(p) => format!(\"Param({})\", p),\n+                ty::ConstKind::Infer(infer) => format!(\"Infer({:?})\", infer),\n+                ty::ConstKind::Bound(idx, var) => format!(\"Bound({:?}, {:?})\", idx, var),\n+                ty::ConstKind::Placeholder(ph) => format!(\"PlaceHolder({:?})\", ph),\n+                ty::ConstKind::Unevaluated(uv) => format!(\n+                    \"Unevaluated({}, {:?}, {:?})\",\n+                    self.tcx.def_path_str(uv.def.did),\n+                    uv.substs,\n+                    uv.promoted\n+                ),\n+                ty::ConstKind::Value(val) => format!(\"Value({:?})\", val),\n+                ty::ConstKind::Error(_) => format!(\"Error\"),\n+            };\n+            self.push(&format!(\"+ val: {}\", val));\n         }\n     }\n "}, {"sha": "fd4a783d12a003bb6f843f09892c6300eb525c62", "filename": "compiler/rustc_mir_build/src/build/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcfg.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -80,7 +80,7 @@ impl<'tcx> CFG<'tcx> {\n         cause: FakeReadCause,\n         place: Place<'tcx>,\n     ) {\n-        let kind = StatementKind::FakeRead(cause, box place);\n+        let kind = StatementKind::FakeRead(box (cause, place));\n         let stmt = Statement { source_info, kind };\n         self.push(block, stmt);\n     }"}, {"sha": "589a4467dcae1023d9170f09fe27020e62adf284", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -17,6 +17,8 @@ use rustc_target::abi::VariantIdx;\n \n use rustc_index::vec::Idx;\n \n+use std::iter;\n+\n /// The \"outermost\" place that holds this value.\n #[derive(Copy, Clone, Debug, PartialEq)]\n crate enum PlaceBase {\n@@ -140,7 +142,7 @@ fn is_ancestor_or_same_capture(\n         return false;\n     }\n \n-    proj_possible_ancestor.iter().zip(proj_capture).all(|(a, b)| a == b)\n+    iter::zip(proj_possible_ancestor, proj_capture).all(|(a, b)| a == b)\n }\n \n /// Computes the index of a capture within the desugared closure provided the closure's"}, {"sha": "822fbd91c947ea49ccbef8daf36b43fbc4e09522", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -179,24 +179,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 //     match x { _ => () } // fake read of `x`\n                 // };\n                 // ```\n-                // FIXME(RFC2229): Remove feature gate once diagnostics are improved\n-                if this.tcx.features().capture_disjoint_fields {\n-                    for (thir_place, cause, hir_id) in fake_reads.into_iter() {\n-                        let place_builder =\n-                            unpack!(block = this.as_place_builder(block, thir_place));\n-\n-                        if let Ok(place_builder_resolved) =\n-                            place_builder.try_upvars_resolved(this.tcx, this.typeck_results)\n-                        {\n-                            let mir_place =\n-                                place_builder_resolved.into_place(this.tcx, this.typeck_results);\n-                            this.cfg.push_fake_read(\n-                                block,\n-                                this.source_info(this.tcx.hir().span(*hir_id)),\n-                                *cause,\n-                                mir_place,\n-                            );\n-                        }\n+                for (thir_place, cause, hir_id) in fake_reads.into_iter() {\n+                    let place_builder = unpack!(block = this.as_place_builder(block, thir_place));\n+\n+                    if let Ok(place_builder_resolved) =\n+                        place_builder.try_upvars_resolved(this.tcx, this.typeck_results)\n+                    {\n+                        let mir_place =\n+                            place_builder_resolved.into_place(this.tcx, this.typeck_results);\n+                        this.cfg.push_fake_read(\n+                            block,\n+                            this.source_info(this.tcx.hir().span(*hir_id)),\n+                            *cause,\n+                            mir_place,\n+                        );\n                     }\n                 }\n "}, {"sha": "80a5bff8cadd984563e3cec906c009d4a776a14e", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -10,6 +10,7 @@ use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, CanonicalUserTypeAnnotation};\n+use std::iter;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n@@ -110,60 +111,49 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             ExprKind::LogicalOp { op, lhs, rhs } => {\n                 // And:\n                 //\n-                // [block: If(lhs)] -true-> [else_block: If(rhs)] -true-> [true_block]\n-                //        |                          | (false)\n-                //        +----------false-----------+------------------> [false_block]\n+                // [block: If(lhs)] -true-> [else_block: dest = (rhs)]\n+                //        | (false)\n+                //  [shortcurcuit_block: dest = false]\n                 //\n                 // Or:\n                 //\n-                // [block: If(lhs)] -false-> [else_block: If(rhs)] -true-> [true_block]\n-                //        | (true)                   | (false)\n-                //  [true_block]               [false_block]\n+                // [block: If(lhs)] -false-> [else_block: dest = (rhs)]\n+                //        | (true)\n+                //  [shortcurcuit_block: dest = true]\n \n-                let (true_block, false_block, mut else_block, join_block) = (\n-                    this.cfg.start_new_block(),\n+                let (shortcircuit_block, mut else_block, join_block) = (\n                     this.cfg.start_new_block(),\n                     this.cfg.start_new_block(),\n                     this.cfg.start_new_block(),\n                 );\n \n                 let lhs = unpack!(block = this.as_local_operand(block, lhs));\n                 let blocks = match op {\n-                    LogicalOp::And => (else_block, false_block),\n-                    LogicalOp::Or => (true_block, else_block),\n+                    LogicalOp::And => (else_block, shortcircuit_block),\n+                    LogicalOp::Or => (shortcircuit_block, else_block),\n                 };\n                 let term = TerminatorKind::if_(this.tcx, lhs, blocks.0, blocks.1);\n                 this.cfg.terminate(block, source_info, term);\n \n-                let rhs = unpack!(else_block = this.as_local_operand(else_block, rhs));\n-                let term = TerminatorKind::if_(this.tcx, rhs, true_block, false_block);\n-                this.cfg.terminate(else_block, source_info, term);\n-\n                 this.cfg.push_assign_constant(\n-                    true_block,\n+                    shortcircuit_block,\n                     source_info,\n                     destination,\n                     Constant {\n                         span: expr_span,\n                         user_ty: None,\n-                        literal: ty::Const::from_bool(this.tcx, true).into(),\n+                        literal: match op {\n+                            LogicalOp::And => ty::Const::from_bool(this.tcx, false).into(),\n+                            LogicalOp::Or => ty::Const::from_bool(this.tcx, true).into(),\n+                        },\n                     },\n                 );\n+                this.cfg.goto(shortcircuit_block, source_info, join_block);\n \n-                this.cfg.push_assign_constant(\n-                    false_block,\n-                    source_info,\n-                    destination,\n-                    Constant {\n-                        span: expr_span,\n-                        user_ty: None,\n-                        literal: ty::Const::from_bool(this.tcx, false).into(),\n-                    },\n-                );\n+                let rhs = unpack!(else_block = this.as_local_operand(else_block, rhs));\n+                this.cfg.push_assign(else_block, source_info, destination, Rvalue::Use(rhs));\n+                this.cfg.goto(else_block, source_info, join_block);\n \n-                // Link up both branches:\n-                this.cfg.goto(true_block, source_info, join_block);\n-                this.cfg.goto(false_block, source_info, join_block);\n                 join_block.unit()\n             }\n             ExprKind::Loop { body } => {\n@@ -286,9 +276,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     // MIR does not natively support FRU, so for each\n                     // base-supplied field, generate an operand that\n                     // reads it from the base.\n-                    field_names\n-                        .into_iter()\n-                        .zip(field_types.into_iter())\n+                    iter::zip(field_names, *field_types)\n                         .map(|(n, ty)| match fields_map.get(&n) {\n                             Some(v) => v.clone(),\n                             None => {"}, {"sha": "0e422dc3c6378837608f27cd030bd0982514c0bd", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // uninhabited value. If we get never patterns, those will check that\n         // the place is initialized, and so this read would only be used to\n         // check safety.\n-        let cause_matched_place = FakeReadCause::ForMatchedPlace;\n+        let cause_matched_place = FakeReadCause::ForMatchedPlace(None);\n         let source_info = self.source_info(scrutinee_span);\n \n         if let Ok(scrutinee_builder) =\n@@ -400,7 +400,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n                 let source_info = self.source_info(irrefutable_pat.span);\n-                self.cfg.push_fake_read(block, source_info, FakeReadCause::ForLet, place);\n+                self.cfg.push_fake_read(block, source_info, FakeReadCause::ForLet(None), place);\n \n                 self.schedule_drop_for_binding(var, irrefutable_pat.span, OutsideGuard);\n                 block.unit()\n@@ -435,7 +435,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n                 let pattern_source_info = self.source_info(irrefutable_pat.span);\n-                let cause_let = FakeReadCause::ForLet;\n+                let cause_let = FakeReadCause::ForLet(None);\n                 self.cfg.push_fake_read(block, pattern_source_info, cause_let, place);\n \n                 let ty_source_info = self.source_info(user_ty_span);"}, {"sha": "c90f94c6d63fbc3e547dc952afc0bfea2bdb3b1d", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -252,8 +252,13 @@ fn liberated_closure_env_ty(\n         _ => bug!(\"closure expr does not have closure type: {:?}\", closure_ty),\n     };\n \n-    let closure_env_ty = tcx.closure_env_ty(closure_def_id, closure_substs).unwrap();\n-    tcx.erase_late_bound_regions(closure_env_ty)\n+    let bound_vars =\n+        tcx.mk_bound_variable_kinds(std::iter::once(ty::BoundVariableKind::Region(ty::BrEnv)));\n+    let br =\n+        ty::BoundRegion { var: ty::BoundVar::from_usize(bound_vars.len() - 1), kind: ty::BrEnv };\n+    let env_region = ty::ReLateBound(ty::INNERMOST, br);\n+    let closure_env_ty = tcx.closure_env_ty(closure_def_id, closure_substs, env_region).unwrap();\n+    tcx.erase_late_bound_regions(ty::Binder::bind_with_vars(closure_env_ty, bound_vars))\n }\n \n #[derive(Debug, PartialEq, Eq)]"}, {"sha": "23bc1da09b5554975b1ac01a183f0a69ce621d83", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -9,6 +9,7 @@\n #![feature(control_flow_enum)]\n #![feature(crate_visibility_modifier)]\n #![feature(bool_to_option)]\n+#![feature(iter_zip)]\n #![feature(once_cell)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![recursion_limit = \"256\"]"}, {"sha": "c0624c805a685f7162d6f3cfc629eb4b4fcdd1eb", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -246,6 +246,18 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n             })\n     }\n \n+    fn field_pats(\n+        &self,\n+        vals: impl Iterator<Item = &'tcx ty::Const<'tcx>>,\n+    ) -> Result<Vec<FieldPat<'tcx>>, FallbackToConstRef> {\n+        vals.enumerate()\n+            .map(|(idx, val)| {\n+                let field = Field::new(idx);\n+                Ok(FieldPat { field, pattern: self.recur(val, false)? })\n+            })\n+            .collect()\n+    }\n+\n     // Recursive helper for `to_pat`; invoke that (instead of calling this directly).\n     fn recur(\n         &self,\n@@ -257,16 +269,6 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         let tcx = self.tcx();\n         let param_env = self.param_env;\n \n-        let field_pats = |vals: &[&'tcx ty::Const<'tcx>]| -> Result<_, _> {\n-            vals.iter()\n-                .enumerate()\n-                .map(|(idx, val)| {\n-                    let field = Field::new(idx);\n-                    Ok(FieldPat { field, pattern: self.recur(val, false)? })\n-                })\n-                .collect()\n-        };\n-\n         let kind = match cv.ty.kind() {\n             ty::Float(_) => {\n                 tcx.struct_span_lint_hir(\n@@ -361,12 +363,12 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                     variant_index: destructured\n                         .variant\n                         .expect(\"destructed const of adt without variant id\"),\n-                    subpatterns: field_pats(destructured.fields)?,\n+                    subpatterns: self.field_pats(destructured.fields.iter().copied())?,\n                 }\n             }\n             ty::Tuple(_) | ty::Adt(_, _) => {\n                 let destructured = tcx.destructure_const(param_env.and(cv));\n-                PatKind::Leaf { subpatterns: field_pats(destructured.fields)? }\n+                PatKind::Leaf { subpatterns: self.field_pats(destructured.fields.iter().copied())? }\n             }\n             ty::Array(..) => PatKind::Array {\n                 prefix: tcx"}, {"sha": "36a0fda645805d747280f9f3849eaf824977ae1d", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -98,21 +98,46 @@ impl<'a> Parser<'a> {\n         }\n         impl CreateTokenStream for LazyTokenStreamImpl {\n             fn create_token_stream(&self) -> TokenStream {\n-                // The token produced by the final call to `next` or `next_desugared`\n-                // was not actually consumed by the callback. The combination\n-                // of chaining the initial token and using `take` produces the desired\n-                // result - we produce an empty `TokenStream` if no calls were made,\n-                // and omit the final token otherwise.\n+                if self.num_calls == 0 {\n+                    return TokenStream::new(vec![]);\n+                }\n+\n                 let mut cursor_snapshot = self.cursor_snapshot.clone();\n-                let tokens = std::iter::once(self.start_token.clone())\n-                    .chain((0..self.num_calls).map(|_| {\n-                        if self.desugar_doc_comments {\n+                // Don't skip `None` delimiters, since we want to pass them to\n+                // proc macros. Normally, we'll end up capturing `TokenKind::Interpolated`,\n+                // which gets converted to a `None`-delimited group when we invoke\n+                // a proc-macro. However, it's possible to already have a `None`-delimited\n+                // group in the stream (such as when parsing the output of a proc-macro,\n+                // or in certain unusual cases with cross-crate `macro_rules!` macros).\n+                cursor_snapshot.skip_none_delims = false;\n+\n+                // The token produced by the final call to `next` or `next_desugared`\n+                // was not actually consumed by the callback.\n+                let num_calls = self.num_calls - 1;\n+                let mut i = 0;\n+                let tokens =\n+                    std::iter::once(self.start_token.clone()).chain(std::iter::from_fn(|| {\n+                        if i >= num_calls {\n+                            return None;\n+                        }\n+\n+                        let token = if self.desugar_doc_comments {\n                             cursor_snapshot.next_desugared()\n                         } else {\n                             cursor_snapshot.next()\n+                        };\n+\n+                        // When the `LazyTokenStreamImpl` was original produced, we did *not*\n+                        // include `NoDelim` tokens in `num_calls`, since they are normally ignored\n+                        // by the parser. Therefore, we only increment our counter for other types of tokens.\n+                        if !matches!(\n+                            token.0.kind,\n+                            token::OpenDelim(token::NoDelim) | token::CloseDelim(token::NoDelim)\n+                        ) {\n+                            i += 1;\n                         }\n-                    }))\n-                    .take(self.num_calls);\n+                        Some(token)\n+                    }));\n \n                 make_token_stream(tokens, self.append_unglued_token.clone())\n             }"}, {"sha": "fe190bfe9d981905df8a756f8555b9f497881a0c", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -92,6 +92,21 @@ impl<'a> Parser<'a> {\n         self.parse_expr_res(Restrictions::empty(), None)\n     }\n \n+    /// Parses an expression, forcing tokens to be collected\n+    pub fn parse_expr_force_collect(&mut self) -> PResult<'a, P<Expr>> {\n+        // If we have outer attributes, then the call to `collect_tokens_trailing_token`\n+        // will be made for us.\n+        if matches!(self.token.kind, TokenKind::Pound | TokenKind::DocComment(..)) {\n+            self.parse_expr()\n+        } else {\n+            // If we don't have outer attributes, then we need to ensure\n+            // that collection happens by using `collect_tokens_no_attrs`.\n+            // Expression don't support custom inner attributes, so `parse_expr`\n+            // will never try to collect tokens if we don't have outer attributes.\n+            self.collect_tokens_no_attrs(|this| this.parse_expr())\n+        }\n+    }\n+\n     pub(super) fn parse_anon_const_expr(&mut self) -> PResult<'a, AnonConst> {\n         self.parse_expr().map(|value| AnonConst { id: DUMMY_NODE_ID, value })\n     }"}, {"sha": "748a8e2bb490fbefa6e749c7686c4ac83729ec4b", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -172,6 +172,13 @@ struct TokenCursor {\n     // appended to the captured stream when\n     // we evaluate a `LazyTokenStream`\n     append_unglued_token: Option<TreeAndSpacing>,\n+    // If `true`, skip the delimiters for `None`-delimited groups,\n+    // and just yield the inner tokens. This is `true` during\n+    // normal parsing, since the parser code is not currently prepared\n+    // to handle `None` delimiters. When capturing a `TokenStream`,\n+    // however, we want to handle `None`-delimiters, since\n+    // proc-macros always see `None`-delimited groups.\n+    skip_none_delims: bool,\n }\n \n #[derive(Clone)]\n@@ -184,13 +191,13 @@ struct TokenCursorFrame {\n }\n \n impl TokenCursorFrame {\n-    fn new(span: DelimSpan, delim: DelimToken, tts: TokenStream) -> Self {\n+    fn new(span: DelimSpan, delim: DelimToken, tts: TokenStream, skip_none_delims: bool) -> Self {\n         TokenCursorFrame {\n             delim,\n             span,\n-            open_delim: delim == token::NoDelim,\n+            open_delim: delim == token::NoDelim && skip_none_delims,\n             tree_cursor: tts.into_trees(),\n-            close_delim: delim == token::NoDelim,\n+            close_delim: delim == token::NoDelim && skip_none_delims,\n         }\n     }\n }\n@@ -218,7 +225,7 @@ impl TokenCursor {\n                     return (token, spacing);\n                 }\n                 TokenTree::Delimited(sp, delim, tts) => {\n-                    let frame = TokenCursorFrame::new(sp, delim, tts);\n+                    let frame = TokenCursorFrame::new(sp, delim, tts, self.skip_none_delims);\n                     self.stack.push(mem::replace(&mut self.frame, frame));\n                 }\n             }\n@@ -276,6 +283,7 @@ impl TokenCursor {\n                         .cloned()\n                         .collect::<TokenStream>()\n                 },\n+                self.skip_none_delims,\n             ),\n         ));\n \n@@ -371,12 +379,19 @@ impl<'a> Parser<'a> {\n             prev_token: Token::dummy(),\n             restrictions: Restrictions::empty(),\n             expected_tokens: Vec::new(),\n+            // Skip over the delimiters for `None`-delimited groups\n             token_cursor: TokenCursor {\n-                frame: TokenCursorFrame::new(DelimSpan::dummy(), token::NoDelim, tokens),\n+                frame: TokenCursorFrame::new(\n+                    DelimSpan::dummy(),\n+                    token::NoDelim,\n+                    tokens,\n+                    /* skip_none_delims */ true,\n+                ),\n                 stack: Vec::new(),\n                 num_next_calls: 0,\n                 desugar_doc_comments,\n                 append_unglued_token: None,\n+                skip_none_delims: true,\n             },\n             desugar_doc_comments,\n             unmatched_angle_bracket_count: 0,\n@@ -987,7 +1002,7 @@ impl<'a> Parser<'a> {\n                     }\n \n                     // Collect tokens because they are used during lowering to HIR.\n-                    let expr = self.collect_tokens_no_attrs(|this| this.parse_expr())?;\n+                    let expr = self.parse_expr_force_collect()?;\n                     let span = expr.span;\n \n                     match &expr.kind {"}, {"sha": "0c49d10358356148945116e9bd56720bbf23ff92", "filename": "compiler/rustc_parse/src/parser/nonterminal.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -128,22 +128,7 @@ impl<'a> Parser<'a> {\n                 })?)\n             }\n \n-            // If there are attributes present, then `parse_expr` will end up collecting tokens,\n-            // turning the outer `collect_tokens_no_attrs` into a no-op due to the already present\n-            // tokens. If there are *not* attributes present, then the outer\n-            // `collect_tokens_no_attrs` will ensure that we will end up collecting tokens for the\n-            // expressions.\n-            //\n-            // This is less efficient than it could be, since the outer `collect_tokens_no_attrs`\n-            // still needs to snapshot the `TokenCursor` before calling `parse_expr`, even when\n-            // `parse_expr` will end up collecting tokens. Ideally, this would work more like\n-            // `parse_item`, and take in a `ForceCollect` parameter. However, this would require\n-            // adding a `ForceCollect` parameter in a bunch of places in expression parsing\n-            // for little gain. If the perf impact from this turns out to be noticeable, we should\n-            // revisit this apporach.\n-            NonterminalKind::Expr => {\n-                token::NtExpr(self.collect_tokens_no_attrs(|this| this.parse_expr())?)\n-            }\n+            NonterminalKind::Expr => token::NtExpr(self.parse_expr_force_collect()?),\n             NonterminalKind::Literal => {\n                 // The `:literal` matcher does not support attributes\n                 token::NtLiteral("}, {"sha": "50db69f42099144d5e035cb4717e85c8f9ceb08f", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -213,11 +213,13 @@ impl<'a> Iterator for Parser<'a> {\n                         Some(String(self.string(pos + 1)))\n                     } else {\n                         let arg = self.argument();\n-                        if let Some(end) = self.must_consume('}') {\n-                            let start = self.to_span_index(pos);\n-                            let end = self.to_span_index(end + 1);\n+                        if let Some(rbrace_byte_idx) = self.must_consume('}') {\n+                            let lbrace_inner_offset = self.to_span_index(pos);\n+                            let rbrace_inner_offset = self.to_span_index(rbrace_byte_idx);\n                             if self.is_literal {\n-                                self.arg_places.push(start.to(end));\n+                                self.arg_places.push(\n+                                    lbrace_inner_offset.to(InnerOffset(rbrace_inner_offset.0 + 1)),\n+                                );\n                             }\n                         }\n                         Some(NextArgument(arg))\n@@ -735,25 +737,24 @@ fn find_skips_from_snippet(\n     };\n \n     fn find_skips(snippet: &str, is_raw: bool) -> Vec<usize> {\n-        let mut eat_ws = false;\n         let mut s = snippet.char_indices().peekable();\n         let mut skips = vec![];\n         while let Some((pos, c)) = s.next() {\n             match (c, s.peek()) {\n                 // skip whitespace and empty lines ending in '\\\\'\n                 ('\\\\', Some((next_pos, '\\n'))) if !is_raw => {\n-                    eat_ws = true;\n                     skips.push(pos);\n                     skips.push(*next_pos);\n                     let _ = s.next();\n-                }\n-                ('\\\\', Some((next_pos, '\\n' | 'n' | 't'))) if eat_ws => {\n-                    skips.push(pos);\n-                    skips.push(*next_pos);\n-                    let _ = s.next();\n-                }\n-                (' ' | '\\n' | '\\t', _) if eat_ws => {\n-                    skips.push(pos);\n+\n+                    while let Some((pos, c)) = s.peek() {\n+                        if matches!(c, ' ' | '\\n' | '\\t') {\n+                            skips.push(*pos);\n+                            let _ = s.next();\n+                        } else {\n+                            break;\n+                        }\n+                    }\n                 }\n                 ('\\\\', Some((next_pos, 'n' | 't' | 'r' | '0' | '\\\\' | '\\'' | '\\\"'))) => {\n                     skips.push(*next_pos);\n@@ -804,10 +805,6 @@ fn find_skips_from_snippet(\n                         }\n                     }\n                 }\n-                _ if eat_ws => {\n-                    // `take_while(|c| c.is_whitespace())`\n-                    eat_ws = false;\n-                }\n                 _ => {}\n             }\n         }"}, {"sha": "df292b141760dc3d76693e5f8deb7bfe956e5a15", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 57, "deletions": 11, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n \n use rustc_ast::{Attribute, Lit, LitKind, NestedMetaItem};\n-use rustc_errors::{pluralize, struct_span_err};\n+use rustc_errors::{pluralize, struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n@@ -648,10 +648,10 @@ impl CheckAttrVisitor<'tcx> {\n                         | sym::masked\n                         | sym::no_default_passes\n                         | sym::no_inline\n+                        | sym::notable_trait\n                         | sym::passes\n                         | sym::plugins\n                         | sym::primitive\n-                        | sym::spotlight\n                         | sym::test => {}\n \n                         _ => {\n@@ -660,11 +660,23 @@ impl CheckAttrVisitor<'tcx> {\n                                 hir_id,\n                                 i_meta.span,\n                                 |lint| {\n-                                    let msg = format!(\n+                                    let mut diag = lint.build(&format!(\n                                         \"unknown `doc` attribute `{}`\",\n                                         rustc_ast_pretty::pprust::path_to_string(&i_meta.path),\n-                                    );\n-                                    lint.build(&msg).emit();\n+                                    ));\n+                                    if i_meta.has_name(sym::spotlight) {\n+                                        diag.note(\n+                                            \"`doc(spotlight)` was renamed to `doc(notable_trait)`\",\n+                                        );\n+                                        diag.span_suggestion_short(\n+                                            i_meta.span,\n+                                            \"use `notable_trait` instead\",\n+                                            String::from(\"notable_trait\"),\n+                                            Applicability::MachineApplicable,\n+                                        );\n+                                        diag.note(\"`doc(spotlight)` is now a no-op\");\n+                                    }\n+                                    diag.emit();\n                                 },\n                             );\n                             is_valid = false;\n@@ -1115,17 +1127,41 @@ impl CheckAttrVisitor<'tcx> {\n         let mut is_transparent = false;\n \n         for hint in &hints {\n+            if !hint.is_meta_item() {\n+                struct_span_err!(\n+                    self.tcx.sess,\n+                    hint.span(),\n+                    E0565,\n+                    \"meta item in `repr` must be an identifier\"\n+                )\n+                .emit();\n+                continue;\n+            }\n+\n             let (article, allowed_targets) = match hint.name_or_empty() {\n-                _ if !matches!(target, Target::Struct | Target::Enum | Target::Union) => {\n-                    (\"a\", \"struct, enum, or union\")\n-                }\n-                name @ sym::C | name @ sym::align => {\n-                    is_c |= name == sym::C;\n+                sym::C => {\n+                    is_c = true;\n                     match target {\n                         Target::Struct | Target::Union | Target::Enum => continue,\n                         _ => (\"a\", \"struct, enum, or union\"),\n                     }\n                 }\n+                sym::align => {\n+                    if let (Target::Fn, true) = (target, !self.tcx.features().fn_align) {\n+                        feature_err(\n+                            &self.tcx.sess.parse_sess,\n+                            sym::fn_align,\n+                            hint.span(),\n+                            \"`repr(align)` attributes on functions are unstable\",\n+                        )\n+                        .emit();\n+                    }\n+\n+                    match target {\n+                        Target::Struct | Target::Union | Target::Enum | Target::Fn => continue,\n+                        _ => (\"a\", \"struct, enum, function, or union\"),\n+                    }\n+                }\n                 sym::packed => {\n                     if target != Target::Struct && target != Target::Union {\n                         (\"a\", \"struct or union\")\n@@ -1182,7 +1218,17 @@ impl CheckAttrVisitor<'tcx> {\n                         continue;\n                     }\n                 }\n-                _ => continue,\n+                _ => {\n+                    struct_span_err!(\n+                        self.tcx.sess,\n+                        hint.span(),\n+                        E0552,\n+                        \"unrecognized representation hint\"\n+                    )\n+                    .emit();\n+\n+                    continue;\n+                }\n             };\n \n             struct_span_err!("}, {"sha": "e53f821e6daff53d683b12cc5832af23320c0cf5", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -171,7 +171,7 @@ fn configure_main(\n }\n \n fn no_main_err(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) {\n-    let sp = tcx.hir().krate().item.span;\n+    let sp = tcx.hir().krate().item.inner;\n     if *tcx.sess.parse_sess.reached_eof.borrow() {\n         // There's an unclosed brace that made the parser reach `Eof`, we shouldn't complain about\n         // the missing `fn main()` then as it might have been hidden inside an unclosed block."}, {"sha": "933e8ad1d727c4719baf896de0cdd220785d0091", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -9,6 +9,7 @@\n #![feature(const_panic)]\n #![feature(crate_visibility_modifier)]\n #![feature(in_band_lifetimes)]\n+#![feature(iter_zip)]\n #![feature(nll)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![recursion_limit = \"256\"]"}, {"sha": "f24309fa950217e2a45a0105712c08de80c0e30c", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -103,6 +103,7 @@ use rustc_span::Span;\n use std::collections::VecDeque;\n use std::io;\n use std::io::prelude::*;\n+use std::iter;\n use std::rc::Rc;\n \n mod rwu_table;\n@@ -1093,7 +1094,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 let ia = &asm.inner;\n                 let outputs = asm.outputs_exprs;\n                 let inputs = asm.inputs_exprs;\n-                let succ = ia.outputs.iter().zip(outputs).rev().fold(succ, |succ, (o, output)| {\n+                let succ = iter::zip(&ia.outputs, outputs).rev().fold(succ, |succ, (o, output)| {\n                     // see comment on places\n                     // in propagate_through_place_components()\n                     if o.is_indirect {\n@@ -1344,7 +1345,7 @@ fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr<'tcx>) {\n             }\n \n             // Output operands must be places\n-            for (o, output) in asm.inner.outputs.iter().zip(asm.outputs_exprs) {\n+            for (o, output) in iter::zip(&asm.inner.outputs, asm.outputs_exprs) {\n                 if !o.is_indirect {\n                     this.check_place(output);\n                 }"}, {"sha": "6d5983f53dc3947556a6aeea712e48404c67b0a8", "filename": "compiler/rustc_passes/src/liveness/rwu_table.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_passes%2Fsrc%2Fliveness%2Frwu_table.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_passes%2Fsrc%2Fliveness%2Frwu_table.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness%2Frwu_table.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,4 +1,5 @@\n use crate::liveness::{LiveNode, Variable};\n+use std::iter;\n \n #[derive(Clone, Copy)]\n pub(super) struct RWU {\n@@ -91,7 +92,7 @@ impl RWUTable {\n \n         let mut changed = false;\n         let (dst_row, src_row) = self.pick2_rows_mut(dst, src);\n-        for (dst_word, src_word) in dst_row.iter_mut().zip(src_row.iter()) {\n+        for (dst_word, src_word) in iter::zip(dst_row, &*src_row) {\n             let old = *dst_word;\n             let new = *dst_word | src_word;\n             *dst_word = new;"}, {"sha": "9c4f9b1198cf20c66f847902bd288cb8b6907f47", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -22,6 +22,7 @@ use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n use std::cmp::Ordering;\n+use std::iter;\n use std::mem::replace;\n use std::num::NonZeroU32;\n \n@@ -214,7 +215,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             {\n                 // Explicit version of iter::order::lt to handle parse errors properly\n                 for (dep_v, stab_v) in\n-                    dep_since.as_str().split('.').zip(stab_since.as_str().split('.'))\n+                    iter::zip(dep_since.as_str().split('.'), stab_since.as_str().split('.'))\n                 {\n                     match stab_v.parse::<u64>() {\n                         Err(_) => {\n@@ -685,7 +686,7 @@ fn new_index(tcx: TyCtxt<'tcx>) -> Index<'tcx> {\n \n         annotator.annotate(\n             hir::CRATE_HIR_ID,\n-            krate.item.span,\n+            krate.item.inner,\n             AnnotationKind::Required,\n             InheritDeprecation::Yes,\n             InheritConstStability::No,\n@@ -884,7 +885,7 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n     if tcx.stability().staged_api[&LOCAL_CRATE] {\n         let krate = tcx.hir().krate();\n         let mut missing = MissingStabilityAnnotations { tcx, access_levels };\n-        missing.check_missing_stability(hir::CRATE_HIR_ID, krate.item.span);\n+        missing.check_missing_stability(hir::CRATE_HIR_ID, krate.item.inner);\n         intravisit::walk_crate(&mut missing, krate);\n         krate.visit_all_item_likes(&mut missing.as_deep_visitor());\n     }"}, {"sha": "1fdb37398f996676491645e7531305919f366caf", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -255,6 +255,15 @@ impl<'tcx> Key for GenericArg<'tcx> {\n     }\n }\n \n+impl<'tcx> Key for mir::ConstantKind<'tcx> {\n+    fn query_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n impl<'tcx> Key for &'tcx ty::Const<'tcx> {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE"}, {"sha": "00d886000faa239d9eeff99f024801107376dd5f", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -19,8 +19,7 @@ extern crate tracing;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::{DiagnosticBuilder, Handler};\n-use rustc_hir::def_id::CrateNum;\n-use rustc_index::vec::IndexVec;\n+use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::dep_graph;\n use rustc_middle::ich::StableHashingContext;\n use rustc_middle::ty::query::{query_keys, query_storage, query_stored, query_values};"}, {"sha": "4194b28dc7d681fc485c0e765a55430a7745f6dc", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -390,13 +390,12 @@ macro_rules! define_queries {\n \n             #[inline]\n             fn compute(tcx: QueryCtxt<'tcx>, key: Self::Key) -> Self::Value {\n-                let provider = tcx.queries.providers.get(key.query_crate())\n-                    // HACK(eddyb) it's possible crates may be loaded after\n-                    // the query engine is created, and because crate loading\n-                    // is not yet integrated with the query engine, such crates\n-                    // would be missing appropriate entries in `providers`.\n-                    .unwrap_or(&tcx.queries.fallback_extern_providers)\n-                    .$name;\n+                let is_local = key.query_crate() == LOCAL_CRATE;\n+                let provider = if is_local {\n+                    tcx.queries.local_providers.$name\n+                } else {\n+                    tcx.queries.extern_providers.$name\n+                };\n                 provider(*tcx, key)\n             }\n \n@@ -478,10 +477,7 @@ macro_rules! define_queries {\n                         return\n                     }\n \n-                    debug_assert!(tcx.dep_graph\n-                                     .node_color(dep_node)\n-                                     .map(|c| c.is_green())\n-                                     .unwrap_or(false));\n+                    debug_assert!(tcx.dep_graph.is_green(dep_node));\n \n                     let key = recover(*tcx, dep_node).unwrap_or_else(|| panic!(\"Failed to recover key for {:?} with hash {}\", dep_node, dep_node.hash));\n                     if queries::$name::cache_on_disk(tcx, &key, None) {\n@@ -507,8 +503,8 @@ macro_rules! define_queries_struct {\n     (tcx: $tcx:tt,\n      input: ($(([$($modifiers:tt)*] [$($attr:tt)*] [$name:ident]))*)) => {\n         pub struct Queries<$tcx> {\n-            providers: IndexVec<CrateNum, Providers>,\n-            fallback_extern_providers: Box<Providers>,\n+            local_providers: Box<Providers>,\n+            extern_providers: Box<Providers>,\n \n             $($(#[$attr])*  $name: QueryState<\n                 crate::dep_graph::DepKind,\n@@ -518,12 +514,12 @@ macro_rules! define_queries_struct {\n \n         impl<$tcx> Queries<$tcx> {\n             pub fn new(\n-                providers: IndexVec<CrateNum, Providers>,\n-                fallback_extern_providers: Providers,\n+                local_providers: Providers,\n+                extern_providers: Providers,\n             ) -> Self {\n                 Queries {\n-                    providers,\n-                    fallback_extern_providers: Box::new(fallback_extern_providers),\n+                    local_providers: Box::new(local_providers),\n+                    extern_providers: Box::new(extern_providers),\n                     $($name: Default::default()),*\n                 }\n             }"}, {"sha": "d592812f79b6b8f333e2e6e12092abf75760aeb1", "filename": "compiler/rustc_query_system/src/cache.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -3,7 +3,6 @@\n use crate::dep_graph::{DepContext, DepNodeIndex};\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::HashMapExt;\n use rustc_data_structures::sync::Lock;\n \n use std::hash::Hash;\n@@ -34,13 +33,6 @@ impl<Key: Eq + Hash, Value: Clone> Cache<Key, Value> {\n     pub fn insert(&self, key: Key, dep_node: DepNodeIndex, value: Value) {\n         self.hashmap.borrow_mut().insert(key, WithDepNode::new(dep_node, value));\n     }\n-\n-    pub fn insert_same(&self, key: Key, dep_node: DepNodeIndex, value: Value)\n-    where\n-        Value: Eq,\n-    {\n-        self.hashmap.borrow_mut().insert_same(key, WithDepNode::new(dep_node, value));\n-    }\n }\n \n #[derive(Clone, Eq, PartialEq)]"}, {"sha": "a544ac2c343aeeab2d5fbd4e9e60061a1f88cdd0", "filename": "compiler/rustc_query_system/src/dep_graph/debug.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdebug.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,6 +1,8 @@\n //! Code for debugging the dep-graph.\n \n-use super::{DepKind, DepNode};\n+use super::{DepKind, DepNode, DepNodeIndex};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::Lock;\n use std::error::Error;\n \n /// A dep-node filter goes from a user-defined string to a query over\n@@ -34,25 +36,28 @@ impl DepNodeFilter {\n \n /// A filter like `F -> G` where `F` and `G` are valid dep-node\n /// filters. This can be used to test the source/target independently.\n-pub struct EdgeFilter {\n+pub struct EdgeFilter<K: DepKind> {\n     pub source: DepNodeFilter,\n     pub target: DepNodeFilter,\n+    pub index_to_node: Lock<FxHashMap<DepNodeIndex, DepNode<K>>>,\n }\n \n-impl EdgeFilter {\n-    pub fn new(test: &str) -> Result<EdgeFilter, Box<dyn Error>> {\n+impl<K: DepKind> EdgeFilter<K> {\n+    pub fn new(test: &str) -> Result<EdgeFilter<K>, Box<dyn Error>> {\n         let parts: Vec<_> = test.split(\"->\").collect();\n         if parts.len() != 2 {\n             Err(format!(\"expected a filter like `a&b -> c&d`, not `{}`\", test).into())\n         } else {\n             Ok(EdgeFilter {\n                 source: DepNodeFilter::new(parts[0]),\n                 target: DepNodeFilter::new(parts[1]),\n+                index_to_node: Lock::new(FxHashMap::default()),\n             })\n         }\n     }\n \n-    pub fn test<K: DepKind>(&self, source: &DepNode<K>, target: &DepNode<K>) -> bool {\n+    #[cfg(debug_assertions)]\n+    pub fn test(&self, source: &DepNode<K>, target: &DepNode<K>) -> bool {\n         self.source.test(source) && self.target.test(target)\n     }\n }"}, {"sha": "7a0fc320663f764d1aedd0cfb48f19dd3b72effe", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 214, "deletions": 745, "changes": 959, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,31 +1,33 @@\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::QueryInvocationId;\n+use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sharded::{self, Sharded};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::sync::{AtomicU32, AtomicU64, Lock, LockGuard, Lrc, Ordering};\n+use rustc_data_structures::steal::Steal;\n+use rustc_data_structures::sync::{AtomicU32, AtomicU64, Lock, Lrc, Ordering};\n use rustc_data_structures::unlikely;\n use rustc_errors::Diagnostic;\n-use rustc_index::vec::{Idx, IndexVec};\n-use rustc_serialize::{Encodable, Encoder};\n+use rustc_index::vec::IndexVec;\n+use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n \n use parking_lot::{Condvar, Mutex};\n use smallvec::{smallvec, SmallVec};\n use std::collections::hash_map::Entry;\n-use std::env;\n use std::hash::Hash;\n use std::marker::PhantomData;\n use std::mem;\n-use std::ops::Range;\n use std::sync::atomic::Ordering::Relaxed;\n \n-use super::debug::EdgeFilter;\n use super::prev::PreviousDepGraph;\n use super::query::DepGraphQuery;\n-use super::serialized::SerializedDepNodeIndex;\n+use super::serialized::{GraphEncoder, SerializedDepNodeIndex};\n use super::{DepContext, DepKind, DepNode, HasDepContext, WorkProductId};\n use crate::query::QueryContext;\n \n+#[cfg(debug_assertions)]\n+use {super::debug::EdgeFilter, std::env};\n+\n #[derive(Clone)]\n pub struct DepGraph<K: DepKind> {\n     data: Option<Lrc<DepGraphData<K>>>,\n@@ -109,14 +111,22 @@ impl<K: DepKind> DepGraph<K> {\n     pub fn new(\n         prev_graph: PreviousDepGraph<K>,\n         prev_work_products: FxHashMap<WorkProductId, WorkProduct>,\n+        encoder: FileEncoder,\n+        record_graph: bool,\n+        record_stats: bool,\n     ) -> DepGraph<K> {\n         let prev_graph_node_count = prev_graph.node_count();\n \n         DepGraph {\n             data: Some(Lrc::new(DepGraphData {\n                 previous_work_products: prev_work_products,\n                 dep_node_debug: Default::default(),\n-                current: CurrentDepGraph::new(prev_graph_node_count),\n+                current: CurrentDepGraph::new(\n+                    prev_graph_node_count,\n+                    encoder,\n+                    record_graph,\n+                    record_stats,\n+                ),\n                 emitting_diagnostics: Default::default(),\n                 emitting_diagnostics_cond_var: Condvar::new(),\n                 previous: prev_graph,\n@@ -136,62 +146,10 @@ impl<K: DepKind> DepGraph<K> {\n         self.data.is_some()\n     }\n \n-    pub fn query(&self) -> DepGraphQuery<K> {\n-        let data = self.data.as_ref().unwrap();\n-        let previous = &data.previous;\n-\n-        // Note locking order: `prev_index_to_index`, then `data`.\n-        let prev_index_to_index = data.current.prev_index_to_index.lock();\n-        let data = data.current.data.lock();\n-        let node_count = data.hybrid_indices.len();\n-        let edge_count = self.edge_count(&data);\n-\n-        let mut nodes = Vec::with_capacity(node_count);\n-        let mut edge_list_indices = Vec::with_capacity(node_count);\n-        let mut edge_list_data = Vec::with_capacity(edge_count);\n-\n-        // See `DepGraph`'s `Encodable` implementation for notes on the approach used here.\n-\n-        edge_list_data.extend(data.unshared_edges.iter().map(|i| i.index()));\n-\n-        for &hybrid_index in data.hybrid_indices.iter() {\n-            match hybrid_index.into() {\n-                HybridIndex::New(new_index) => {\n-                    nodes.push(data.new.nodes[new_index]);\n-                    let edges = &data.new.edges[new_index];\n-                    edge_list_indices.push((edges.start.index(), edges.end.index()));\n-                }\n-                HybridIndex::Red(red_index) => {\n-                    nodes.push(previous.index_to_node(data.red.node_indices[red_index]));\n-                    let edges = &data.red.edges[red_index];\n-                    edge_list_indices.push((edges.start.index(), edges.end.index()));\n-                }\n-                HybridIndex::LightGreen(lg_index) => {\n-                    nodes.push(previous.index_to_node(data.light_green.node_indices[lg_index]));\n-                    let edges = &data.light_green.edges[lg_index];\n-                    edge_list_indices.push((edges.start.index(), edges.end.index()));\n-                }\n-                HybridIndex::DarkGreen(prev_index) => {\n-                    nodes.push(previous.index_to_node(prev_index));\n-\n-                    let edges_iter = previous\n-                        .edge_targets_from(prev_index)\n-                        .iter()\n-                        .map(|&dst| prev_index_to_index[dst].unwrap().index());\n-\n-                    let start = edge_list_data.len();\n-                    edge_list_data.extend(edges_iter);\n-                    let end = edge_list_data.len();\n-                    edge_list_indices.push((start, end));\n-                }\n-            }\n+    pub fn with_query(&self, f: impl Fn(&DepGraphQuery<K>)) {\n+        if let Some(data) = &self.data {\n+            data.current.encoder.borrow().with_query(f)\n         }\n-\n-        debug_assert_eq!(nodes.len(), node_count);\n-        debug_assert_eq!(edge_list_indices.len(), node_count);\n-        debug_assert_eq!(edge_list_data.len(), edge_count);\n-\n-        DepGraphQuery::new(&nodes[..], &edge_list_indices[..], &edge_list_data[..])\n     }\n \n     pub fn assert_ignored(&self) {\n@@ -283,56 +241,16 @@ impl<K: DepKind> DepGraph<K> {\n             let print_status = cfg!(debug_assertions) && dcx.sess().opts.debugging_opts.dep_tasks;\n \n             // Intern the new `DepNode`.\n-            let dep_node_index = if let Some(prev_index) = data.previous.node_to_index_opt(&key) {\n-                // Determine the color and index of the new `DepNode`.\n-                let (color, dep_node_index) = if let Some(current_fingerprint) = current_fingerprint\n-                {\n-                    if current_fingerprint == data.previous.fingerprint_by_index(prev_index) {\n-                        if print_status {\n-                            eprintln!(\"[task::green] {:?}\", key);\n-                        }\n-\n-                        // This is a light green node: it existed in the previous compilation,\n-                        // its query was re-executed, and it has the same result as before.\n-                        let dep_node_index =\n-                            data.current.intern_light_green_node(&data.previous, prev_index, edges);\n-\n-                        (DepNodeColor::Green(dep_node_index), dep_node_index)\n-                    } else {\n-                        if print_status {\n-                            eprintln!(\"[task::red] {:?}\", key);\n-                        }\n-\n-                        // This is a red node: it existed in the previous compilation, its query\n-                        // was re-executed, but it has a different result from before.\n-                        let dep_node_index = data.current.intern_red_node(\n-                            &data.previous,\n-                            prev_index,\n-                            edges,\n-                            current_fingerprint,\n-                        );\n-\n-                        (DepNodeColor::Red, dep_node_index)\n-                    }\n-                } else {\n-                    if print_status {\n-                        eprintln!(\"[task::unknown] {:?}\", key);\n-                    }\n-\n-                    // This is a red node, effectively: it existed in the previous compilation\n-                    // session, its query was re-executed, but it doesn't compute a result hash\n-                    // (i.e. it represents a `no_hash` query), so we have no way of determining\n-                    // whether or not the result was the same as before.\n-                    let dep_node_index = data.current.intern_red_node(\n-                        &data.previous,\n-                        prev_index,\n-                        edges,\n-                        Fingerprint::ZERO,\n-                    );\n-\n-                    (DepNodeColor::Red, dep_node_index)\n-                };\n+            let (dep_node_index, prev_and_color) = data.current.intern_node(\n+                dcx.profiler(),\n+                &data.previous,\n+                key,\n+                edges,\n+                current_fingerprint,\n+                print_status,\n+            );\n \n+            if let Some((prev_index, color)) = prev_and_color {\n                 debug_assert!(\n                     data.colors.get(prev_index).is_none(),\n                     \"DepGraph::with_task() - Duplicate DepNodeColor \\\n@@ -341,20 +259,7 @@ impl<K: DepKind> DepGraph<K> {\n                 );\n \n                 data.colors.insert(prev_index, color);\n-                dep_node_index\n-            } else {\n-                if print_status {\n-                    eprintln!(\"[task::new] {:?}\", key);\n-                }\n-\n-                // This is a new node: it didn't exist in the previous compilation session.\n-                data.current.intern_new_node(\n-                    &data.previous,\n-                    key,\n-                    edges,\n-                    current_fingerprint.unwrap_or(Fingerprint::ZERO),\n-                )\n-            };\n+            }\n \n             (result, dep_node_index)\n         } else {\n@@ -368,7 +273,12 @@ impl<K: DepKind> DepGraph<K> {\n \n     /// Executes something within an \"anonymous\" task, that is, a task the\n     /// `DepNode` of which is determined by the list of inputs it read from.\n-    pub fn with_anon_task<OP, R>(&self, dep_kind: K, op: OP) -> (R, DepNodeIndex)\n+    pub fn with_anon_task<Ctxt: DepContext<DepKind = K>, OP, R>(\n+        &self,\n+        cx: Ctxt,\n+        dep_kind: K,\n+        op: OP,\n+    ) -> (R, DepNodeIndex)\n     where\n         OP: FnOnce() -> R,\n     {\n@@ -396,7 +306,7 @@ impl<K: DepKind> DepGraph<K> {\n             };\n \n             let dep_node_index = data.current.intern_new_node(\n-                &data.previous,\n+                cx.profiler(),\n                 target_dep_node,\n                 task_deps.reads,\n                 Fingerprint::ZERO,\n@@ -451,7 +361,7 @@ impl<K: DepKind> DepGraph<K> {\n                         {\n                             if let Some(target) = task_deps.node {\n                                 if let Some(ref forbidden_edge) = data.current.forbidden_edge {\n-                                    let src = self.dep_node_of(dep_node_index);\n+                                    let src = forbidden_edge.index_to_node.lock()[&dep_node_index];\n                                     if forbidden_edge.test(&src, &target) {\n                                         panic!(\"forbidden edge {:?} -> {:?} created\", src, target)\n                                     }\n@@ -488,38 +398,6 @@ impl<K: DepKind> DepGraph<K> {\n         self.data.is_some() && self.dep_node_index_of_opt(dep_node).is_some()\n     }\n \n-    #[inline]\n-    pub fn dep_node_of(&self, dep_node_index: DepNodeIndex) -> DepNode<K> {\n-        let data = self.data.as_ref().unwrap();\n-        let previous = &data.previous;\n-        let data = data.current.data.lock();\n-\n-        match data.hybrid_indices[dep_node_index].into() {\n-            HybridIndex::New(new_index) => data.new.nodes[new_index],\n-            HybridIndex::Red(red_index) => previous.index_to_node(data.red.node_indices[red_index]),\n-            HybridIndex::LightGreen(light_green_index) => {\n-                previous.index_to_node(data.light_green.node_indices[light_green_index])\n-            }\n-            HybridIndex::DarkGreen(prev_index) => previous.index_to_node(prev_index),\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn fingerprint_of(&self, dep_node_index: DepNodeIndex) -> Fingerprint {\n-        let data = self.data.as_ref().unwrap();\n-        let previous = &data.previous;\n-        let data = data.current.data.lock();\n-\n-        match data.hybrid_indices[dep_node_index].into() {\n-            HybridIndex::New(new_index) => data.new.fingerprints[new_index],\n-            HybridIndex::Red(red_index) => data.red.fingerprints[red_index],\n-            HybridIndex::LightGreen(light_green_index) => {\n-                previous.fingerprint_by_index(data.light_green.node_indices[light_green_index])\n-            }\n-            HybridIndex::DarkGreen(prev_index) => previous.fingerprint_by_index(prev_index),\n-        }\n-    }\n-\n     pub fn prev_fingerprint_of(&self, dep_node: &DepNode<K>) -> Option<Fingerprint> {\n         self.data.as_ref().unwrap().previous.fingerprint_of(dep_node)\n     }\n@@ -554,29 +432,13 @@ impl<K: DepKind> DepGraph<K> {\n         self.data.as_ref()?.dep_node_debug.borrow().get(&dep_node).cloned()\n     }\n \n-    fn edge_count(&self, node_data: &LockGuard<'_, DepNodeData<K>>) -> usize {\n-        let data = self.data.as_ref().unwrap();\n-        let previous = &data.previous;\n-\n-        let mut edge_count = node_data.unshared_edges.len();\n-\n-        for &hybrid_index in node_data.hybrid_indices.iter() {\n-            if let HybridIndex::DarkGreen(prev_index) = hybrid_index.into() {\n-                edge_count += previous.edge_targets_from(prev_index).len()\n-            }\n-        }\n-\n-        edge_count\n-    }\n-\n-    pub fn node_color(&self, dep_node: &DepNode<K>) -> Option<DepNodeColor> {\n+    fn node_color(&self, dep_node: &DepNode<K>) -> Option<DepNodeColor> {\n         if let Some(ref data) = self.data {\n             if let Some(prev_index) = data.previous.node_to_index_opt(dep_node) {\n                 return data.colors.get(prev_index);\n             } else {\n-                // This is a node that did not exist in the previous compilation\n-                // session, so we consider it to be red.\n-                return Some(DepNodeColor::Red);\n+                // This is a node that did not exist in the previous compilation session.\n+                return None;\n             }\n         }\n \n@@ -775,11 +637,13 @@ impl<K: DepKind> DepGraph<K> {\n \n         // There may be multiple threads trying to mark the same dep node green concurrently\n \n-        let dep_node_index = {\n-            // We allocating an entry for the node in the current dependency graph and\n-            // adding all the appropriate edges imported from the previous graph\n-            data.current.intern_dark_green_node(&data.previous, prev_dep_node_index)\n-        };\n+        // We allocating an entry for the node in the current dependency graph and\n+        // adding all the appropriate edges imported from the previous graph\n+        let dep_node_index = data.current.promote_node_and_deps_to_current(\n+            tcx.dep_context().profiler(),\n+            &data.previous,\n+            prev_dep_node_index,\n+        );\n \n         // ... emitting any stored diagnostic ...\n \n@@ -862,6 +726,12 @@ impl<K: DepKind> DepGraph<K> {\n         }\n     }\n \n+    // Returns true if the given node has been marked as red during the\n+    // current compilation session. Used in various assertions\n+    pub fn is_red(&self, dep_node: &DepNode<K>) -> bool {\n+        self.node_color(dep_node) == Some(DepNodeColor::Red)\n+    }\n+\n     // Returns true if the given node has been marked as green during the\n     // current compilation session. Used in various assertions\n     pub fn is_green(&self, dep_node: &DepNode<K>) -> bool {\n@@ -911,106 +781,20 @@ impl<K: DepKind> DepGraph<K> {\n     }\n \n     pub fn print_incremental_info(&self) {\n-        #[derive(Clone)]\n-        struct Stat<Kind: DepKind> {\n-            kind: Kind,\n-            node_counter: u64,\n-            edge_counter: u64,\n+        if let Some(data) = &self.data {\n+            data.current.encoder.borrow().print_incremental_info(\n+                data.current.total_read_count.load(Relaxed),\n+                data.current.total_duplicate_read_count.load(Relaxed),\n+            )\n         }\n+    }\n \n-        let data = self.data.as_ref().unwrap();\n-        let prev = &data.previous;\n-        let current = &data.current;\n-        let data = current.data.lock();\n-\n-        let mut stats: FxHashMap<_, Stat<K>> = FxHashMap::with_hasher(Default::default());\n-\n-        for &hybrid_index in data.hybrid_indices.iter() {\n-            let (kind, edge_count) = match hybrid_index.into() {\n-                HybridIndex::New(new_index) => {\n-                    let kind = data.new.nodes[new_index].kind;\n-                    let edge_range = &data.new.edges[new_index];\n-                    (kind, edge_range.end.as_usize() - edge_range.start.as_usize())\n-                }\n-                HybridIndex::Red(red_index) => {\n-                    let kind = prev.index_to_node(data.red.node_indices[red_index]).kind;\n-                    let edge_range = &data.red.edges[red_index];\n-                    (kind, edge_range.end.as_usize() - edge_range.start.as_usize())\n-                }\n-                HybridIndex::LightGreen(lg_index) => {\n-                    let kind = prev.index_to_node(data.light_green.node_indices[lg_index]).kind;\n-                    let edge_range = &data.light_green.edges[lg_index];\n-                    (kind, edge_range.end.as_usize() - edge_range.start.as_usize())\n-                }\n-                HybridIndex::DarkGreen(prev_index) => {\n-                    let kind = prev.index_to_node(prev_index).kind;\n-                    let edge_count = prev.edge_targets_from(prev_index).len();\n-                    (kind, edge_count)\n-                }\n-            };\n-\n-            let stat = stats.entry(kind).or_insert(Stat { kind, node_counter: 0, edge_counter: 0 });\n-            stat.node_counter += 1;\n-            stat.edge_counter += edge_count as u64;\n-        }\n-\n-        let total_node_count = data.hybrid_indices.len();\n-        let total_edge_count = self.edge_count(&data);\n-\n-        // Drop the lock guard.\n-        std::mem::drop(data);\n-\n-        let mut stats: Vec<_> = stats.values().cloned().collect();\n-        stats.sort_by_key(|s| -(s.node_counter as i64));\n-\n-        const SEPARATOR: &str = \"[incremental] --------------------------------\\\n-                                 ----------------------------------------------\\\n-                                 ------------\";\n-\n-        eprintln!(\"[incremental]\");\n-        eprintln!(\"[incremental] DepGraph Statistics\");\n-        eprintln!(\"{}\", SEPARATOR);\n-        eprintln!(\"[incremental]\");\n-        eprintln!(\"[incremental] Total Node Count: {}\", total_node_count);\n-        eprintln!(\"[incremental] Total Edge Count: {}\", total_edge_count);\n-\n-        if cfg!(debug_assertions) {\n-            let total_edge_reads = current.total_read_count.load(Relaxed);\n-            let total_duplicate_edge_reads = current.total_duplicate_read_count.load(Relaxed);\n-\n-            eprintln!(\"[incremental] Total Edge Reads: {}\", total_edge_reads);\n-            eprintln!(\"[incremental] Total Duplicate Edge Reads: {}\", total_duplicate_edge_reads);\n-        }\n-\n-        eprintln!(\"[incremental]\");\n-\n-        eprintln!(\n-            \"[incremental]  {:<36}| {:<17}| {:<12}| {:<17}|\",\n-            \"Node Kind\", \"Node Frequency\", \"Node Count\", \"Avg. Edge Count\"\n-        );\n-\n-        eprintln!(\n-            \"[incremental] -------------------------------------\\\n-                  |------------------\\\n-                  |-------------\\\n-                  |------------------|\"\n-        );\n-\n-        for stat in stats {\n-            let node_kind_ratio = (100.0 * (stat.node_counter as f64)) / (total_node_count as f64);\n-            let node_kind_avg_edges = (stat.edge_counter as f64) / (stat.node_counter as f64);\n-\n-            eprintln!(\n-                \"[incremental]  {:<36}|{:>16.1}% |{:>12} |{:>17.1} |\",\n-                format!(\"{:?}\", stat.kind),\n-                node_kind_ratio,\n-                stat.node_counter,\n-                node_kind_avg_edges,\n-            );\n+    pub fn encode(&self, profiler: &SelfProfilerRef) -> FileEncodeResult {\n+        if let Some(data) = &self.data {\n+            data.current.encoder.steal().finish(profiler)\n+        } else {\n+            Ok(())\n         }\n-\n-        eprintln!(\"{}\", SEPARATOR);\n-        eprintln!(\"[incremental]\");\n     }\n \n     fn next_virtual_depnode_index(&self) -> DepNodeIndex {\n@@ -1019,142 +803,6 @@ impl<K: DepKind> DepGraph<K> {\n     }\n }\n \n-impl<E: Encoder, K: DepKind + Encodable<E>> Encodable<E> for DepGraph<K> {\n-    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n-        // We used to serialize the dep graph by creating and serializing a `SerializedDepGraph`\n-        // using data copied from the `DepGraph`. But copying created a large memory spike, so we\n-        // now serialize directly from the `DepGraph` as if it's a `SerializedDepGraph`. Because we\n-        // deserialize that data into a `SerializedDepGraph` in the next compilation session, we\n-        // need `DepGraph`'s `Encodable` and `SerializedDepGraph`'s `Decodable` implementations to\n-        // be in sync. If you update this encoding, be sure to update the decoding, and vice-versa.\n-\n-        let data = self.data.as_ref().unwrap();\n-        let prev = &data.previous;\n-\n-        // Note locking order: `prev_index_to_index`, then `data`.\n-        let prev_index_to_index = data.current.prev_index_to_index.lock();\n-        let data = data.current.data.lock();\n-        let new = &data.new;\n-        let red = &data.red;\n-        let lg = &data.light_green;\n-\n-        let node_count = data.hybrid_indices.len();\n-        let edge_count = self.edge_count(&data);\n-\n-        // `rustc_middle::ty::query::OnDiskCache` expects nodes to be encoded in `DepNodeIndex`\n-        // order. The edges in `edge_list_data` don't need to be in a particular order, as long as\n-        // each node references its edges as a contiguous range within it. Therefore, we can encode\n-        // `edge_list_data` directly from `unshared_edges`. It meets the above requirements, as\n-        // each non-dark-green node already knows the range of edges to reference within it, which\n-        // they'll encode in `edge_list_indices`. Dark green nodes, however, don't have their edges\n-        // in `unshared_edges`, so need to add them to `edge_list_data`.\n-\n-        use HybridIndex::*;\n-\n-        // Encoded values (nodes, etc.) are explicitly typed below to avoid inadvertently\n-        // serializing data in the wrong format (i.e. one incompatible with `SerializedDepGraph`).\n-        e.emit_struct(\"SerializedDepGraph\", 4, |e| {\n-            e.emit_struct_field(\"nodes\", 0, |e| {\n-                // `SerializedDepGraph` expects this to be encoded as a sequence of `DepNode`s.\n-                e.emit_seq(node_count, |e| {\n-                    for (seq_index, &hybrid_index) in data.hybrid_indices.iter().enumerate() {\n-                        let node: DepNode<K> = match hybrid_index.into() {\n-                            New(i) => new.nodes[i],\n-                            Red(i) => prev.index_to_node(red.node_indices[i]),\n-                            LightGreen(i) => prev.index_to_node(lg.node_indices[i]),\n-                            DarkGreen(prev_index) => prev.index_to_node(prev_index),\n-                        };\n-\n-                        e.emit_seq_elt(seq_index, |e| node.encode(e))?;\n-                    }\n-\n-                    Ok(())\n-                })\n-            })?;\n-\n-            e.emit_struct_field(\"fingerprints\", 1, |e| {\n-                // `SerializedDepGraph` expects this to be encoded as a sequence of `Fingerprints`s.\n-                e.emit_seq(node_count, |e| {\n-                    for (seq_index, &hybrid_index) in data.hybrid_indices.iter().enumerate() {\n-                        let fingerprint: Fingerprint = match hybrid_index.into() {\n-                            New(i) => new.fingerprints[i],\n-                            Red(i) => red.fingerprints[i],\n-                            LightGreen(i) => prev.fingerprint_by_index(lg.node_indices[i]),\n-                            DarkGreen(prev_index) => prev.fingerprint_by_index(prev_index),\n-                        };\n-\n-                        e.emit_seq_elt(seq_index, |e| fingerprint.encode(e))?;\n-                    }\n-\n-                    Ok(())\n-                })\n-            })?;\n-\n-            e.emit_struct_field(\"edge_list_indices\", 2, |e| {\n-                // `SerializedDepGraph` expects this to be encoded as a sequence of `(u32, u32)`s.\n-                e.emit_seq(node_count, |e| {\n-                    // Dark green node edges start after the unshared (all other nodes') edges.\n-                    let mut dark_green_edge_index = data.unshared_edges.len();\n-\n-                    for (seq_index, &hybrid_index) in data.hybrid_indices.iter().enumerate() {\n-                        let edge_indices: (u32, u32) = match hybrid_index.into() {\n-                            New(i) => (new.edges[i].start.as_u32(), new.edges[i].end.as_u32()),\n-                            Red(i) => (red.edges[i].start.as_u32(), red.edges[i].end.as_u32()),\n-                            LightGreen(i) => (lg.edges[i].start.as_u32(), lg.edges[i].end.as_u32()),\n-                            DarkGreen(prev_index) => {\n-                                let edge_count = prev.edge_targets_from(prev_index).len();\n-                                let start = dark_green_edge_index as u32;\n-                                dark_green_edge_index += edge_count;\n-                                let end = dark_green_edge_index as u32;\n-                                (start, end)\n-                            }\n-                        };\n-\n-                        e.emit_seq_elt(seq_index, |e| edge_indices.encode(e))?;\n-                    }\n-\n-                    assert_eq!(dark_green_edge_index, edge_count);\n-\n-                    Ok(())\n-                })\n-            })?;\n-\n-            e.emit_struct_field(\"edge_list_data\", 3, |e| {\n-                // `SerializedDepGraph` expects this to be encoded as a sequence of\n-                // `SerializedDepNodeIndex`.\n-                e.emit_seq(edge_count, |e| {\n-                    for (seq_index, &edge) in data.unshared_edges.iter().enumerate() {\n-                        let serialized_edge = SerializedDepNodeIndex::new(edge.index());\n-                        e.emit_seq_elt(seq_index, |e| serialized_edge.encode(e))?;\n-                    }\n-\n-                    let mut seq_index = data.unshared_edges.len();\n-\n-                    for &hybrid_index in data.hybrid_indices.iter() {\n-                        if let DarkGreen(prev_index) = hybrid_index.into() {\n-                            for &edge in prev.edge_targets_from(prev_index) {\n-                                // Dark green node edges are stored in the previous graph\n-                                // and must be converted to edges in the current graph,\n-                                // and then serialized as `SerializedDepNodeIndex`.\n-                                let serialized_edge = SerializedDepNodeIndex::new(\n-                                    prev_index_to_index[edge].as_ref().unwrap().index(),\n-                                );\n-\n-                                e.emit_seq_elt(seq_index, |e| serialized_edge.encode(e))?;\n-                                seq_index += 1;\n-                            }\n-                        }\n-                    }\n-\n-                    assert_eq!(seq_index, edge_count);\n-\n-                    Ok(())\n-                })\n-            })\n-        })\n-    }\n-}\n-\n /// A \"work product\" is an intermediate result that we save into the\n /// incremental directory for later re-use. The primary example are\n /// the object files that we save for each partition at code\n@@ -1193,216 +841,20 @@ pub struct WorkProduct {\n     pub saved_file: Option<String>,\n }\n \n-// The maximum value of the follow index types leaves the upper two bits unused\n-// so that we can store multiple index types in `CompressedHybridIndex`, and use\n-// those bits to encode which index type it contains.\n-\n-// Index type for `NewDepNodeData`.\n-rustc_index::newtype_index! {\n-    struct NewDepNodeIndex {\n-        MAX = 0x7FFF_FFFF\n-    }\n-}\n-\n-// Index type for `RedDepNodeData`.\n-rustc_index::newtype_index! {\n-    struct RedDepNodeIndex {\n-        MAX = 0x7FFF_FFFF\n-    }\n-}\n-\n-// Index type for `LightGreenDepNodeData`.\n-rustc_index::newtype_index! {\n-    struct LightGreenDepNodeIndex {\n-        MAX = 0x7FFF_FFFF\n-    }\n-}\n-\n-/// Compressed representation of `HybridIndex` enum. Bits unused by the\n-/// contained index types are used to encode which index type it contains.\n-#[derive(Copy, Clone)]\n-struct CompressedHybridIndex(u32);\n-\n-impl CompressedHybridIndex {\n-    const NEW_TAG: u32 = 0b0000_0000_0000_0000_0000_0000_0000_0000;\n-    const RED_TAG: u32 = 0b0100_0000_0000_0000_0000_0000_0000_0000;\n-    const LIGHT_GREEN_TAG: u32 = 0b1000_0000_0000_0000_0000_0000_0000_0000;\n-    const DARK_GREEN_TAG: u32 = 0b1100_0000_0000_0000_0000_0000_0000_0000;\n-\n-    const TAG_MASK: u32 = 0b1100_0000_0000_0000_0000_0000_0000_0000;\n-    const INDEX_MASK: u32 = !Self::TAG_MASK;\n-}\n-\n-impl From<NewDepNodeIndex> for CompressedHybridIndex {\n-    #[inline]\n-    fn from(index: NewDepNodeIndex) -> Self {\n-        CompressedHybridIndex(Self::NEW_TAG | index.as_u32())\n-    }\n-}\n-\n-impl From<RedDepNodeIndex> for CompressedHybridIndex {\n-    #[inline]\n-    fn from(index: RedDepNodeIndex) -> Self {\n-        CompressedHybridIndex(Self::RED_TAG | index.as_u32())\n-    }\n-}\n-\n-impl From<LightGreenDepNodeIndex> for CompressedHybridIndex {\n-    #[inline]\n-    fn from(index: LightGreenDepNodeIndex) -> Self {\n-        CompressedHybridIndex(Self::LIGHT_GREEN_TAG | index.as_u32())\n-    }\n-}\n-\n-impl From<SerializedDepNodeIndex> for CompressedHybridIndex {\n-    #[inline]\n-    fn from(index: SerializedDepNodeIndex) -> Self {\n-        CompressedHybridIndex(Self::DARK_GREEN_TAG | index.as_u32())\n-    }\n-}\n-\n-/// Contains an index into one of several node data collections. Elsewhere, we\n-/// store `CompressedHyridIndex` instead of this to save space, but convert to\n-/// this type during processing to take advantage of the enum match ergonomics.\n-enum HybridIndex {\n-    New(NewDepNodeIndex),\n-    Red(RedDepNodeIndex),\n-    LightGreen(LightGreenDepNodeIndex),\n-    DarkGreen(SerializedDepNodeIndex),\n-}\n-\n-impl From<CompressedHybridIndex> for HybridIndex {\n-    #[inline]\n-    fn from(hybrid_index: CompressedHybridIndex) -> Self {\n-        let index = hybrid_index.0 & CompressedHybridIndex::INDEX_MASK;\n-\n-        match hybrid_index.0 & CompressedHybridIndex::TAG_MASK {\n-            CompressedHybridIndex::NEW_TAG => HybridIndex::New(NewDepNodeIndex::from_u32(index)),\n-            CompressedHybridIndex::RED_TAG => HybridIndex::Red(RedDepNodeIndex::from_u32(index)),\n-            CompressedHybridIndex::LIGHT_GREEN_TAG => {\n-                HybridIndex::LightGreen(LightGreenDepNodeIndex::from_u32(index))\n-            }\n-            CompressedHybridIndex::DARK_GREEN_TAG => {\n-                HybridIndex::DarkGreen(SerializedDepNodeIndex::from_u32(index))\n-            }\n-            _ => unreachable!(),\n-        }\n-    }\n-}\n-\n // Index type for `DepNodeData`'s edges.\n rustc_index::newtype_index! {\n     struct EdgeIndex { .. }\n }\n \n-/// Data for nodes in the current graph, divided into different collections\n-/// based on their presence in the previous graph, and if present, their color.\n-/// We divide nodes this way because different types of nodes are able to share\n-/// more or less data with the previous graph.\n-///\n-/// To enable more sharing, we distinguish between two kinds of green nodes.\n-/// Light green nodes are nodes in the previous graph that have been marked\n-/// green because we re-executed their queries and the results were the same as\n-/// in the previous session. Dark green nodes are nodes in the previous graph\n-/// that have been marked green because we were able to mark all of their\n-/// dependencies green.\n-///\n-/// Both light and dark green nodes can share the dep node and fingerprint with\n-/// the previous graph, but for light green nodes, we can't be sure that the\n-/// edges may be shared without comparing them against the previous edges, so we\n-/// store them directly (an approach in which we compare edges with the previous\n-/// edges to see if they can be shared was evaluated, but was not found to be\n-/// very profitable).\n-///\n-/// For dark green nodes, we can share everything with the previous graph, which\n-/// is why the `HybridIndex::DarkGreen` enum variant contains the index of the\n-/// node in the previous graph, and why we don't have a separate collection for\n-/// dark green node data--the collection is the `PreviousDepGraph` itself.\n-///\n-/// (Note that for dark green nodes, the edges in the previous graph\n-/// (`SerializedDepNodeIndex`s) must be converted to edges in the current graph\n-/// (`DepNodeIndex`s). `CurrentDepGraph` contains `prev_index_to_index`, which\n-/// can perform this conversion. It should always be possible, as by definition,\n-/// a dark green node is one whose dependencies from the previous session have\n-/// all been marked green--which means `prev_index_to_index` contains them.)\n-///\n-/// Node data is stored in parallel vectors to eliminate the padding between\n-/// elements that would be needed to satisfy alignment requirements of the\n-/// structure that would contain all of a node's data. We could group tightly\n-/// packing subsets of node data together and use fewer vectors, but for\n-/// consistency's sake, we use separate vectors for each piece of data.\n-struct DepNodeData<K> {\n-    /// Data for nodes not in previous graph.\n-    new: NewDepNodeData<K>,\n-\n-    /// Data for nodes in previous graph that have been marked red.\n-    red: RedDepNodeData,\n-\n-    /// Data for nodes in previous graph that have been marked light green.\n-    light_green: LightGreenDepNodeData,\n-\n-    // Edges for all nodes other than dark-green ones. Edges for each node\n-    // occupy a contiguous region of this collection, which a node can reference\n-    // using two indices. Storing edges this way rather than using an `EdgesVec`\n-    // for each node reduces memory consumption by a not insignificant amount\n-    // when compiling large crates. The downside is that we have to copy into\n-    // this collection the edges from the `EdgesVec`s that are built up during\n-    // query execution. But this is mostly balanced out by the more efficient\n-    // implementation of `DepGraph::serialize` enabled by this representation.\n-    unshared_edges: IndexVec<EdgeIndex, DepNodeIndex>,\n-\n-    /// Mapping from `DepNodeIndex` to an index into a collection above.\n-    /// Indicates which of the above collections contains a node's data.\n-    ///\n-    /// This collection is wasteful in time and space during incr-full builds,\n-    /// because for those, all nodes are new. However, the waste is relatively\n-    /// small, and the maintenance cost of avoiding using this for incr-full\n-    /// builds is somewhat high and prone to bugginess. It does not seem worth\n-    /// it at the time of this writing, but we may want to revisit the idea.\n-    hybrid_indices: IndexVec<DepNodeIndex, CompressedHybridIndex>,\n-}\n-\n-/// Data for nodes not in previous graph. Since we cannot share any data with\n-/// the previous graph, so we must store all of such a node's data here.\n-struct NewDepNodeData<K> {\n-    nodes: IndexVec<NewDepNodeIndex, DepNode<K>>,\n-    edges: IndexVec<NewDepNodeIndex, Range<EdgeIndex>>,\n-    fingerprints: IndexVec<NewDepNodeIndex, Fingerprint>,\n-}\n-\n-/// Data for nodes in previous graph that have been marked red. We can share the\n-/// dep node with the previous graph, but the edges may be different, and the\n-/// fingerprint is known to be different, so we store the latter two directly.\n-struct RedDepNodeData {\n-    node_indices: IndexVec<RedDepNodeIndex, SerializedDepNodeIndex>,\n-    edges: IndexVec<RedDepNodeIndex, Range<EdgeIndex>>,\n-    fingerprints: IndexVec<RedDepNodeIndex, Fingerprint>,\n-}\n-\n-/// Data for nodes in previous graph that have been marked green because we\n-/// re-executed their queries and the results were the same as in the previous\n-/// session. We can share the dep node and the fingerprint with the previous\n-/// graph, but the edges may be different, so we store them directly.\n-struct LightGreenDepNodeData {\n-    node_indices: IndexVec<LightGreenDepNodeIndex, SerializedDepNodeIndex>,\n-    edges: IndexVec<LightGreenDepNodeIndex, Range<EdgeIndex>>,\n-}\n-\n /// `CurrentDepGraph` stores the dependency graph for the current session. It\n /// will be populated as we run queries or tasks. We never remove nodes from the\n /// graph: they are only added.\n ///\n-/// The nodes in it are identified by a `DepNodeIndex`. Internally, this maps to\n-/// a `HybridIndex`, which identifies which collection in the `data` field\n-/// contains a node's data. Which collection is used for a node depends on\n-/// whether the node was present in the `PreviousDepGraph`, and if so, the color\n-/// of the node. Each type of node can share more or less data with the previous\n-/// graph. When possible, we can store just the index of the node in the\n-/// previous graph, rather than duplicating its data in our own collections.\n-/// This is important, because these graph structures are some of the largest in\n-/// the compiler.\n+/// The nodes in it are identified by a `DepNodeIndex`. We avoid keeping the nodes\n+/// in memory.  This is important, because these graph structures are some of the\n+/// largest in the compiler.\n ///\n-/// For the same reason, we also avoid storing `DepNode`s more than once as map\n+/// For this reason, we avoid storing `DepNode`s more than once as map\n /// keys. The `new_node_to_index` map only contains nodes not in the previous\n /// graph, and we map nodes in the previous graph to indices via a two-step\n /// mapping. `PreviousDepGraph` maps from `DepNode` to `SerializedDepNodeIndex`,\n@@ -1417,15 +869,15 @@ struct LightGreenDepNodeData {\n /// `new_node_to_index` and `data`, or `prev_index_to_index` and `data`. When\n /// manipulating both, we acquire `new_node_to_index` or `prev_index_to_index`\n /// first, and `data` second.\n-pub(super) struct CurrentDepGraph<K> {\n-    data: Lock<DepNodeData<K>>,\n+pub(super) struct CurrentDepGraph<K: DepKind> {\n+    encoder: Steal<GraphEncoder<K>>,\n     new_node_to_index: Sharded<FxHashMap<DepNode<K>, DepNodeIndex>>,\n     prev_index_to_index: Lock<IndexVec<SerializedDepNodeIndex, Option<DepNodeIndex>>>,\n \n     /// Used to trap when a specific edge is added to the graph.\n     /// This is used for debug purposes and is only active with `debug_assertions`.\n-    #[allow(dead_code)]\n-    forbidden_edge: Option<EdgeFilter>,\n+    #[cfg(debug_assertions)]\n+    forbidden_edge: Option<EdgeFilter<K>>,\n \n     /// Anonymous `DepNode`s are nodes whose IDs we compute from the list of\n     /// their edges. This has the beneficial side-effect that multiple anonymous\n@@ -1447,78 +899,42 @@ pub(super) struct CurrentDepGraph<K> {\n }\n \n impl<K: DepKind> CurrentDepGraph<K> {\n-    fn new(prev_graph_node_count: usize) -> CurrentDepGraph<K> {\n+    fn new(\n+        prev_graph_node_count: usize,\n+        encoder: FileEncoder,\n+        record_graph: bool,\n+        record_stats: bool,\n+    ) -> CurrentDepGraph<K> {\n         use std::time::{SystemTime, UNIX_EPOCH};\n \n         let duration = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();\n         let nanos = duration.as_secs() * 1_000_000_000 + duration.subsec_nanos() as u64;\n         let mut stable_hasher = StableHasher::new();\n         nanos.hash(&mut stable_hasher);\n \n-        let forbidden_edge = if cfg!(debug_assertions) {\n-            match env::var(\"RUST_FORBID_DEP_GRAPH_EDGE\") {\n-                Ok(s) => match EdgeFilter::new(&s) {\n-                    Ok(f) => Some(f),\n-                    Err(err) => panic!(\"RUST_FORBID_DEP_GRAPH_EDGE invalid: {}\", err),\n-                },\n-                Err(_) => None,\n-            }\n-        } else {\n-            None\n+        #[cfg(debug_assertions)]\n+        let forbidden_edge = match env::var(\"RUST_FORBID_DEP_GRAPH_EDGE\") {\n+            Ok(s) => match EdgeFilter::new(&s) {\n+                Ok(f) => Some(f),\n+                Err(err) => panic!(\"RUST_FORBID_DEP_GRAPH_EDGE invalid: {}\", err),\n+            },\n+            Err(_) => None,\n         };\n \n-        // Pre-allocate the dep node structures. We over-allocate a little so\n-        // that we hopefully don't have to re-allocate during this compilation\n-        // session. The over-allocation for new nodes is 2% plus a small\n-        // constant to account for the fact that in very small crates 2% might\n-        // not be enough. The allocation for red and green node data doesn't\n-        // include a constant, as we don't want to allocate anything for these\n-        // structures during full incremental builds, where they aren't used.\n-        //\n-        // These estimates are based on the distribution of node and edge counts\n-        // seen in rustc-perf benchmarks, adjusted somewhat to account for the\n-        // fact that these benchmarks aren't perfectly representative.\n-        //\n-        // FIXME Use a collection type that doesn't copy node and edge data and\n-        // grow multiplicatively on reallocation. Without such a collection or\n-        // solution having the same effect, there is a performance hazard here\n-        // in both time and space, as growing these collections means copying a\n-        // large amount of data and doubling already large buffer capacities. A\n-        // solution for this will also mean that it's less important to get\n-        // these estimates right.\n-        let new_node_count_estimate = (prev_graph_node_count * 2) / 100 + 200;\n-        let red_node_count_estimate = (prev_graph_node_count * 3) / 100;\n-        let light_green_node_count_estimate = (prev_graph_node_count * 25) / 100;\n-        let total_node_count_estimate = prev_graph_node_count + new_node_count_estimate;\n-\n-        let average_edges_per_node_estimate = 6;\n-        let unshared_edge_count_estimate = average_edges_per_node_estimate\n-            * (new_node_count_estimate + red_node_count_estimate + light_green_node_count_estimate);\n-\n         // We store a large collection of these in `prev_index_to_index` during\n         // non-full incremental builds, and want to ensure that the element size\n         // doesn't inadvertently increase.\n         static_assert_size!(Option<DepNodeIndex>, 4);\n \n+        let new_node_count_estimate = 102 * prev_graph_node_count / 100 + 200;\n+\n         CurrentDepGraph {\n-            data: Lock::new(DepNodeData {\n-                new: NewDepNodeData {\n-                    nodes: IndexVec::with_capacity(new_node_count_estimate),\n-                    edges: IndexVec::with_capacity(new_node_count_estimate),\n-                    fingerprints: IndexVec::with_capacity(new_node_count_estimate),\n-                },\n-                red: RedDepNodeData {\n-                    node_indices: IndexVec::with_capacity(red_node_count_estimate),\n-                    edges: IndexVec::with_capacity(red_node_count_estimate),\n-                    fingerprints: IndexVec::with_capacity(red_node_count_estimate),\n-                },\n-                light_green: LightGreenDepNodeData {\n-                    node_indices: IndexVec::with_capacity(light_green_node_count_estimate),\n-                    edges: IndexVec::with_capacity(light_green_node_count_estimate),\n-                },\n-                unshared_edges: IndexVec::with_capacity(unshared_edge_count_estimate),\n-                hybrid_indices: IndexVec::with_capacity(total_node_count_estimate),\n-            }),\n+            encoder: Steal::new(GraphEncoder::new(\n+                encoder,\n+                prev_graph_node_count,\n+                record_graph,\n+                record_stats,\n+            )),\n             new_node_to_index: Sharded::new(|| {\n                 FxHashMap::with_capacity_and_hasher(\n                     new_node_count_estimate / sharded::SHARDS,\n@@ -1527,89 +943,143 @@ impl<K: DepKind> CurrentDepGraph<K> {\n             }),\n             prev_index_to_index: Lock::new(IndexVec::from_elem_n(None, prev_graph_node_count)),\n             anon_id_seed: stable_hasher.finish(),\n+            #[cfg(debug_assertions)]\n             forbidden_edge,\n             total_read_count: AtomicU64::new(0),\n             total_duplicate_read_count: AtomicU64::new(0),\n         }\n     }\n \n+    #[cfg(debug_assertions)]\n+    fn record_edge(&self, dep_node_index: DepNodeIndex, key: DepNode<K>) {\n+        if let Some(forbidden_edge) = &self.forbidden_edge {\n+            forbidden_edge.index_to_node.lock().insert(dep_node_index, key);\n+        }\n+    }\n+\n+    /// Writes the node to the current dep-graph and allocates a `DepNodeIndex` for it.\n+    /// Assumes that this is a node that has no equivalent in the previous dep-graph.\n     fn intern_new_node(\n         &self,\n-        prev_graph: &PreviousDepGraph<K>,\n-        dep_node: DepNode<K>,\n+        profiler: &SelfProfilerRef,\n+        key: DepNode<K>,\n         edges: EdgesVec,\n-        fingerprint: Fingerprint,\n+        current_fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n-        debug_assert!(\n-            prev_graph.node_to_index_opt(&dep_node).is_none(),\n-            \"node in previous graph should be interned using one \\\n-            of `intern_red_node`, `intern_light_green_node`, etc.\"\n-        );\n-\n-        match self.new_node_to_index.get_shard_by_value(&dep_node).lock().entry(dep_node) {\n+        match self.new_node_to_index.get_shard_by_value(&key).lock().entry(key) {\n             Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n-                let data = &mut *self.data.lock();\n-                let new_index = data.new.nodes.push(dep_node);\n-                add_edges(&mut data.unshared_edges, &mut data.new.edges, edges);\n-                data.new.fingerprints.push(fingerprint);\n-                let dep_node_index = data.hybrid_indices.push(new_index.into());\n+                let dep_node_index =\n+                    self.encoder.borrow().send(profiler, key, current_fingerprint, edges);\n                 entry.insert(dep_node_index);\n+                #[cfg(debug_assertions)]\n+                self.record_edge(dep_node_index, key);\n                 dep_node_index\n             }\n         }\n     }\n \n-    fn intern_red_node(\n+    fn intern_node(\n         &self,\n+        profiler: &SelfProfilerRef,\n         prev_graph: &PreviousDepGraph<K>,\n-        prev_index: SerializedDepNodeIndex,\n+        key: DepNode<K>,\n         edges: EdgesVec,\n-        fingerprint: Fingerprint,\n-    ) -> DepNodeIndex {\n-        self.debug_assert_not_in_new_nodes(prev_graph, prev_index);\n+        fingerprint: Option<Fingerprint>,\n+        print_status: bool,\n+    ) -> (DepNodeIndex, Option<(SerializedDepNodeIndex, DepNodeColor)>) {\n+        let print_status = cfg!(debug_assertions) && print_status;\n+\n+        if let Some(prev_index) = prev_graph.node_to_index_opt(&key) {\n+            // Determine the color and index of the new `DepNode`.\n+            if let Some(fingerprint) = fingerprint {\n+                if fingerprint == prev_graph.fingerprint_by_index(prev_index) {\n+                    if print_status {\n+                        eprintln!(\"[task::green] {:?}\", key);\n+                    }\n \n-        let mut prev_index_to_index = self.prev_index_to_index.lock();\n+                    // This is a green node: it existed in the previous compilation,\n+                    // its query was re-executed, and it has the same result as before.\n+                    let mut prev_index_to_index = self.prev_index_to_index.lock();\n+\n+                    let dep_node_index = match prev_index_to_index[prev_index] {\n+                        Some(dep_node_index) => dep_node_index,\n+                        None => {\n+                            let dep_node_index =\n+                                self.encoder.borrow().send(profiler, key, fingerprint, edges);\n+                            prev_index_to_index[prev_index] = Some(dep_node_index);\n+                            dep_node_index\n+                        }\n+                    };\n \n-        match prev_index_to_index[prev_index] {\n-            Some(dep_node_index) => dep_node_index,\n-            None => {\n-                let data = &mut *self.data.lock();\n-                let red_index = data.red.node_indices.push(prev_index);\n-                add_edges(&mut data.unshared_edges, &mut data.red.edges, edges);\n-                data.red.fingerprints.push(fingerprint);\n-                let dep_node_index = data.hybrid_indices.push(red_index.into());\n-                prev_index_to_index[prev_index] = Some(dep_node_index);\n-                dep_node_index\n-            }\n-        }\n-    }\n+                    #[cfg(debug_assertions)]\n+                    self.record_edge(dep_node_index, key);\n+                    (dep_node_index, Some((prev_index, DepNodeColor::Green(dep_node_index))))\n+                } else {\n+                    if print_status {\n+                        eprintln!(\"[task::red] {:?}\", key);\n+                    }\n \n-    fn intern_light_green_node(\n-        &self,\n-        prev_graph: &PreviousDepGraph<K>,\n-        prev_index: SerializedDepNodeIndex,\n-        edges: EdgesVec,\n-    ) -> DepNodeIndex {\n-        self.debug_assert_not_in_new_nodes(prev_graph, prev_index);\n+                    // This is a red node: it existed in the previous compilation, its query\n+                    // was re-executed, but it has a different result from before.\n+                    let mut prev_index_to_index = self.prev_index_to_index.lock();\n+\n+                    let dep_node_index = match prev_index_to_index[prev_index] {\n+                        Some(dep_node_index) => dep_node_index,\n+                        None => {\n+                            let dep_node_index =\n+                                self.encoder.borrow().send(profiler, key, fingerprint, edges);\n+                            prev_index_to_index[prev_index] = Some(dep_node_index);\n+                            dep_node_index\n+                        }\n+                    };\n \n-        let mut prev_index_to_index = self.prev_index_to_index.lock();\n+                    #[cfg(debug_assertions)]\n+                    self.record_edge(dep_node_index, key);\n+                    (dep_node_index, Some((prev_index, DepNodeColor::Red)))\n+                }\n+            } else {\n+                if print_status {\n+                    eprintln!(\"[task::unknown] {:?}\", key);\n+                }\n \n-        match prev_index_to_index[prev_index] {\n-            Some(dep_node_index) => dep_node_index,\n-            None => {\n-                let data = &mut *self.data.lock();\n-                let light_green_index = data.light_green.node_indices.push(prev_index);\n-                add_edges(&mut data.unshared_edges, &mut data.light_green.edges, edges);\n-                let dep_node_index = data.hybrid_indices.push(light_green_index.into());\n-                prev_index_to_index[prev_index] = Some(dep_node_index);\n-                dep_node_index\n+                // This is a red node, effectively: it existed in the previous compilation\n+                // session, its query was re-executed, but it doesn't compute a result hash\n+                // (i.e. it represents a `no_hash` query), so we have no way of determining\n+                // whether or not the result was the same as before.\n+                let mut prev_index_to_index = self.prev_index_to_index.lock();\n+\n+                let dep_node_index = match prev_index_to_index[prev_index] {\n+                    Some(dep_node_index) => dep_node_index,\n+                    None => {\n+                        let dep_node_index =\n+                            self.encoder.borrow().send(profiler, key, Fingerprint::ZERO, edges);\n+                        prev_index_to_index[prev_index] = Some(dep_node_index);\n+                        dep_node_index\n+                    }\n+                };\n+\n+                #[cfg(debug_assertions)]\n+                self.record_edge(dep_node_index, key);\n+                (dep_node_index, Some((prev_index, DepNodeColor::Red)))\n+            }\n+        } else {\n+            if print_status {\n+                eprintln!(\"[task::new] {:?}\", key);\n             }\n+\n+            let fingerprint = fingerprint.unwrap_or(Fingerprint::ZERO);\n+\n+            // This is a new node: it didn't exist in the previous compilation session.\n+            let dep_node_index = self.intern_new_node(profiler, key, edges, fingerprint);\n+\n+            (dep_node_index, None)\n         }\n     }\n \n-    fn intern_dark_green_node(\n+    fn promote_node_and_deps_to_current(\n         &self,\n+        profiler: &SelfProfilerRef,\n         prev_graph: &PreviousDepGraph<K>,\n         prev_index: SerializedDepNodeIndex,\n     ) -> DepNodeIndex {\n@@ -1620,9 +1090,20 @@ impl<K: DepKind> CurrentDepGraph<K> {\n         match prev_index_to_index[prev_index] {\n             Some(dep_node_index) => dep_node_index,\n             None => {\n-                let mut data = self.data.lock();\n-                let dep_node_index = data.hybrid_indices.push(prev_index.into());\n+                let key = prev_graph.index_to_node(prev_index);\n+                let dep_node_index = self.encoder.borrow().send(\n+                    profiler,\n+                    key,\n+                    prev_graph.fingerprint_by_index(prev_index),\n+                    prev_graph\n+                        .edge_targets_from(prev_index)\n+                        .iter()\n+                        .map(|i| prev_index_to_index[*i].unwrap())\n+                        .collect(),\n+                );\n                 prev_index_to_index[prev_index] = Some(dep_node_index);\n+                #[cfg(debug_assertions)]\n+                self.record_edge(dep_node_index, key);\n                 dep_node_index\n             }\n         }\n@@ -1642,18 +1123,6 @@ impl<K: DepKind> CurrentDepGraph<K> {\n     }\n }\n \n-#[inline]\n-fn add_edges<I: Idx>(\n-    edges: &mut IndexVec<EdgeIndex, DepNodeIndex>,\n-    edge_indices: &mut IndexVec<I, Range<EdgeIndex>>,\n-    new_edges: EdgesVec,\n-) {\n-    let start = edges.next_index();\n-    edges.extend(new_edges);\n-    let end = edges.next_index();\n-    edge_indices.push(start..end);\n-}\n-\n /// The capacity of the `reads` field `SmallVec`\n const TASK_DEPS_READS_CAP: usize = 8;\n type EdgesVec = SmallVec<[DepNodeIndex; TASK_DEPS_READS_CAP]>;"}, {"sha": "1b6ecf3e637f3ff5e753aaa59ec39b6df63bce07", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -13,6 +13,7 @@ pub use serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n \n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sync::Lock;\n+use rustc_serialize::{opaque::FileEncoder, Encodable};\n use rustc_session::Session;\n \n use std::fmt;\n@@ -59,7 +60,7 @@ impl<T: DepContext> HasDepContext for T {\n }\n \n /// Describe the different families of dependency nodes.\n-pub trait DepKind: Copy + fmt::Debug + Eq + Hash {\n+pub trait DepKind: Copy + fmt::Debug + Eq + Hash + Send + Encodable<FileEncoder> + 'static {\n     const NULL: Self;\n \n     /// Return whether this kind always require evaluation."}, {"sha": "6303bbf53b9c45ffc7187c4db9dc64c4dbfa085a", "filename": "compiler/rustc_query_system/src/dep_graph/prev.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fprev.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -35,11 +35,6 @@ impl<K: DepKind> PreviousDepGraph<K> {\n         self.data.nodes[dep_node_index]\n     }\n \n-    #[inline]\n-    pub fn node_to_index(&self, dep_node: &DepNode<K>) -> SerializedDepNodeIndex {\n-        self.index[dep_node]\n-    }\n-\n     #[inline]\n     pub fn node_to_index_opt(&self, dep_node: &DepNode<K>) -> Option<SerializedDepNodeIndex> {\n         self.index.get(dep_node).cloned()"}, {"sha": "27b3b5e13667e44bd47b52e2f93fab83538373f1", "filename": "compiler/rustc_query_system/src/dep_graph/query.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,38 +1,43 @@\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph::implementation::{Direction, Graph, NodeIndex, INCOMING};\n+use rustc_index::vec::IndexVec;\n \n-use super::{DepKind, DepNode};\n+use super::{DepKind, DepNode, DepNodeIndex};\n \n pub struct DepGraphQuery<K> {\n     pub graph: Graph<DepNode<K>, ()>,\n     pub indices: FxHashMap<DepNode<K>, NodeIndex>,\n+    pub dep_index_to_index: IndexVec<DepNodeIndex, Option<NodeIndex>>,\n }\n \n impl<K: DepKind> DepGraphQuery<K> {\n-    pub fn new(\n-        nodes: &[DepNode<K>],\n-        edge_list_indices: &[(usize, usize)],\n-        edge_list_data: &[usize],\n-    ) -> DepGraphQuery<K> {\n-        let mut graph = Graph::with_capacity(nodes.len(), edge_list_data.len());\n-        let mut indices = FxHashMap::default();\n-        for node in nodes {\n-            indices.insert(*node, graph.add_node(*node));\n-        }\n+    pub fn new(prev_node_count: usize) -> DepGraphQuery<K> {\n+        let node_count = prev_node_count + prev_node_count / 4;\n+        let edge_count = 6 * node_count;\n \n-        for (source, &(start, end)) in edge_list_indices.iter().enumerate() {\n-            for &target in &edge_list_data[start..end] {\n-                let source = indices[&nodes[source]];\n-                let target = indices[&nodes[target]];\n-                graph.add_edge(source, target, ());\n-            }\n-        }\n+        let graph = Graph::with_capacity(node_count, edge_count);\n+        let indices = FxHashMap::default();\n+        let dep_index_to_index = IndexVec::new();\n \n-        DepGraphQuery { graph, indices }\n+        DepGraphQuery { graph, indices, dep_index_to_index }\n     }\n \n-    pub fn contains_node(&self, node: &DepNode<K>) -> bool {\n-        self.indices.contains_key(&node)\n+    pub fn push(&mut self, index: DepNodeIndex, node: DepNode<K>, edges: &[DepNodeIndex]) {\n+        let source = self.graph.add_node(node);\n+        if index.index() >= self.dep_index_to_index.len() {\n+            self.dep_index_to_index.resize(index.index() + 1, None);\n+        }\n+        self.dep_index_to_index[index] = Some(source);\n+        self.indices.insert(node, source);\n+\n+        for &target in edges.iter() {\n+            let target = self.dep_index_to_index[target];\n+            // We may miss the edges that are pushed while the `DepGraphQuery` is being accessed.\n+            // Skip them to issues.\n+            if let Some(target) = target {\n+                self.graph.add_edge(source, target, ());\n+            }\n+        }\n     }\n \n     pub fn nodes(&self) -> Vec<&DepNode<K>> {"}, {"sha": "6f3d1fb71994e11b78a72a63c7af61c8d44128ec", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 249, "deletions": 69, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -1,9 +1,28 @@\n //! The data that we will serialize and deserialize.\n+//!\n+//! The dep-graph is serialized as a sequence of NodeInfo, with the dependencies\n+//! specified inline.  The total number of nodes and edges are stored as the last\n+//! 16 bytes of the file, so we can find them easily at decoding time.\n+//!\n+//! The serialisation is performed on-demand when each node is emitted. Using this\n+//! scheme, we do not need to keep the current graph in memory.\n+//!\n+//! The deserisalisation is performed manually, in order to convert from the stored\n+//! sequence of NodeInfos to the different arrays in SerializedDepGraph.  Since the\n+//! node and edge count are stored at the end of the file, all the arrays can be\n+//! pre-allocated with the right length.\n \n-use super::{DepKind, DepNode};\n+use super::query::DepGraphQuery;\n+use super::{DepKind, DepNode, DepNodeIndex};\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_index::vec::IndexVec;\n-use rustc_serialize::{Decodable, Decoder};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::profiling::SelfProfilerRef;\n+use rustc_data_structures::sync::Lock;\n+use rustc_index::vec::{Idx, IndexVec};\n+use rustc_serialize::opaque::{self, FileEncodeResult, FileEncoder, IntEncodedWithFixedSize};\n+use rustc_serialize::{Decodable, Decoder, Encodable};\n+use smallvec::SmallVec;\n+use std::convert::TryInto;\n \n // The maximum value of `SerializedDepNodeIndex` leaves the upper two bits\n // unused so that we can store multiple index types in `CompressedHybridIndex`,\n@@ -50,78 +69,239 @@ impl<K: DepKind> SerializedDepGraph<K> {\n     }\n }\n \n-impl<D: Decoder, K: DepKind + Decodable<D>> Decodable<D> for SerializedDepGraph<K> {\n-    fn decode(d: &mut D) -> Result<SerializedDepGraph<K>, D::Error> {\n-        // We used to serialize the dep graph by creating and serializing a `SerializedDepGraph`\n-        // using data copied from the `DepGraph`. But copying created a large memory spike, so we\n-        // now serialize directly from the `DepGraph` as if it's a `SerializedDepGraph`. Because we\n-        // deserialize that data into a `SerializedDepGraph` in the next compilation session, we\n-        // need `DepGraph`'s `Encodable` and `SerializedDepGraph`'s `Decodable` implementations to\n-        // be in sync. If you update this decoding, be sure to update the encoding, and vice-versa.\n-        //\n-        // We mimic the sequence of `Encode` and `Encodable` method calls used by the `DepGraph`'s\n-        // `Encodable` implementation with the corresponding sequence of `Decode` and `Decodable`\n-        // method calls. E.g. `Decode::read_struct` pairs with `Encode::emit_struct`, `DepNode`'s\n-        // `decode` pairs with `DepNode`'s `encode`, and so on. Any decoding methods not associated\n-        // with corresponding encoding methods called in `DepGraph`'s `Encodable` implementation\n-        // are off limits, because we'd be relying on their implementation details.\n-        //\n-        // For example, because we know it happens to do the right thing, its tempting to just use\n-        // `IndexVec`'s `Decodable` implementation to decode into some of the collections below,\n-        // even though `DepGraph` doesn't use its `Encodable` implementation. But the `IndexVec`\n-        // implementation could change, and we'd have a bug.\n-        //\n-        // Variables below are explicitly typed so that anyone who changes the `SerializedDepGraph`\n-        // representation without updating this function will encounter a compilation error, and\n-        // know to update this and possibly the `DepGraph` `Encodable` implementation accordingly\n-        // (the latter should serialize data in a format compatible with our representation).\n-\n-        d.read_struct(\"SerializedDepGraph\", 4, |d| {\n-            let nodes: IndexVec<SerializedDepNodeIndex, DepNode<K>> =\n-                d.read_struct_field(\"nodes\", 0, |d| {\n-                    d.read_seq(|d, len| {\n-                        let mut v = IndexVec::with_capacity(len);\n-                        for i in 0..len {\n-                            v.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n-                        }\n-                        Ok(v)\n-                    })\n-                })?;\n+impl<'a, K: DepKind + Decodable<opaque::Decoder<'a>>> Decodable<opaque::Decoder<'a>>\n+    for SerializedDepGraph<K>\n+{\n+    #[instrument(skip(d))]\n+    fn decode(d: &mut opaque::Decoder<'a>) -> Result<SerializedDepGraph<K>, String> {\n+        let start_position = d.position();\n \n-            let fingerprints: IndexVec<SerializedDepNodeIndex, Fingerprint> =\n-                d.read_struct_field(\"fingerprints\", 1, |d| {\n-                    d.read_seq(|d, len| {\n-                        let mut v = IndexVec::with_capacity(len);\n-                        for i in 0..len {\n-                            v.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n-                        }\n-                        Ok(v)\n-                    })\n-                })?;\n+        // The last 16 bytes are the node count and edge count.\n+        debug!(\"position: {:?}\", d.position());\n+        d.set_position(d.data.len() - 2 * IntEncodedWithFixedSize::ENCODED_SIZE);\n+        debug!(\"position: {:?}\", d.position());\n \n-            let edge_list_indices: IndexVec<SerializedDepNodeIndex, (u32, u32)> = d\n-                .read_struct_field(\"edge_list_indices\", 2, |d| {\n-                    d.read_seq(|d, len| {\n-                        let mut v = IndexVec::with_capacity(len);\n-                        for i in 0..len {\n-                            v.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n-                        }\n-                        Ok(v)\n-                    })\n-                })?;\n+        let node_count = IntEncodedWithFixedSize::decode(d)?.0 as usize;\n+        let edge_count = IntEncodedWithFixedSize::decode(d)?.0 as usize;\n+        debug!(?node_count, ?edge_count);\n+\n+        debug!(\"position: {:?}\", d.position());\n+        d.set_position(start_position);\n+        debug!(\"position: {:?}\", d.position());\n+\n+        let mut nodes = IndexVec::with_capacity(node_count);\n+        let mut fingerprints = IndexVec::with_capacity(node_count);\n+        let mut edge_list_indices = IndexVec::with_capacity(node_count);\n+        let mut edge_list_data = Vec::with_capacity(edge_count);\n+\n+        for _index in 0..node_count {\n+            d.read_struct(\"NodeInfo\", 3, |d| {\n+                let dep_node: DepNode<K> = d.read_struct_field(\"node\", 0, Decodable::decode)?;\n+                let _i: SerializedDepNodeIndex = nodes.push(dep_node);\n+                debug_assert_eq!(_i.index(), _index);\n \n-            let edge_list_data: Vec<SerializedDepNodeIndex> =\n-                d.read_struct_field(\"edge_list_data\", 3, |d| {\n+                let fingerprint: Fingerprint =\n+                    d.read_struct_field(\"fingerprint\", 1, Decodable::decode)?;\n+                let _i: SerializedDepNodeIndex = fingerprints.push(fingerprint);\n+                debug_assert_eq!(_i.index(), _index);\n+\n+                d.read_struct_field(\"edges\", 2, |d| {\n                     d.read_seq(|d, len| {\n-                        let mut v = Vec::with_capacity(len);\n-                        for i in 0..len {\n-                            v.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+                        let start = edge_list_data.len().try_into().unwrap();\n+                        for e in 0..len {\n+                            let edge = d.read_seq_elt(e, Decodable::decode)?;\n+                            edge_list_data.push(edge);\n                         }\n-                        Ok(v)\n+                        let end = edge_list_data.len().try_into().unwrap();\n+                        let _i: SerializedDepNodeIndex = edge_list_indices.push((start, end));\n+                        debug_assert_eq!(_i.index(), _index);\n+                        Ok(())\n                     })\n-                })?;\n+                })\n+            })?;\n+        }\n+\n+        Ok(SerializedDepGraph { nodes, fingerprints, edge_list_indices, edge_list_data })\n+    }\n+}\n+\n+#[derive(Debug, Encodable, Decodable)]\n+pub struct NodeInfo<K: DepKind> {\n+    node: DepNode<K>,\n+    fingerprint: Fingerprint,\n+    edges: SmallVec<[DepNodeIndex; 8]>,\n+}\n+\n+struct Stat<K: DepKind> {\n+    kind: K,\n+    node_counter: u64,\n+    edge_counter: u64,\n+}\n+\n+struct EncoderState<K: DepKind> {\n+    encoder: FileEncoder,\n+    total_node_count: usize,\n+    total_edge_count: usize,\n+    result: FileEncodeResult,\n+    stats: Option<FxHashMap<K, Stat<K>>>,\n+}\n+\n+impl<K: DepKind> EncoderState<K> {\n+    fn new(encoder: FileEncoder, record_stats: bool) -> Self {\n+        Self {\n+            encoder,\n+            total_edge_count: 0,\n+            total_node_count: 0,\n+            result: Ok(()),\n+            stats: if record_stats { Some(FxHashMap::default()) } else { None },\n+        }\n+    }\n+\n+    #[instrument(skip(self, record_graph))]\n+    fn encode_node(\n+        &mut self,\n+        node: &NodeInfo<K>,\n+        record_graph: &Option<Lock<DepGraphQuery<K>>>,\n+    ) -> DepNodeIndex {\n+        let index = DepNodeIndex::new(self.total_node_count);\n+        self.total_node_count += 1;\n+\n+        let edge_count = node.edges.len();\n+        self.total_edge_count += edge_count;\n+\n+        if let Some(record_graph) = &record_graph {\n+            // Do not ICE when a query is called from within `with_query`.\n+            if let Some(record_graph) = &mut record_graph.try_lock() {\n+                record_graph.push(index, node.node, &node.edges);\n+            }\n+        }\n+\n+        if let Some(stats) = &mut self.stats {\n+            let kind = node.node.kind;\n+\n+            let stat = stats.entry(kind).or_insert(Stat { kind, node_counter: 0, edge_counter: 0 });\n+            stat.node_counter += 1;\n+            stat.edge_counter += edge_count as u64;\n+        }\n+\n+        debug!(?index, ?node);\n+        let encoder = &mut self.encoder;\n+        if self.result.is_ok() {\n+            self.result = node.encode(encoder);\n+        }\n+        index\n+    }\n+\n+    fn finish(self) -> FileEncodeResult {\n+        let Self { mut encoder, total_node_count, total_edge_count, result, stats: _ } = self;\n+        let () = result?;\n+\n+        let node_count = total_node_count.try_into().unwrap();\n+        let edge_count = total_edge_count.try_into().unwrap();\n+\n+        debug!(?node_count, ?edge_count);\n+        debug!(\"position: {:?}\", encoder.position());\n+        IntEncodedWithFixedSize(node_count).encode(&mut encoder)?;\n+        IntEncodedWithFixedSize(edge_count).encode(&mut encoder)?;\n+        debug!(\"position: {:?}\", encoder.position());\n+        // Drop the encoder so that nothing is written after the counts.\n+        encoder.flush()\n+    }\n+}\n+\n+pub struct GraphEncoder<K: DepKind> {\n+    status: Lock<EncoderState<K>>,\n+    record_graph: Option<Lock<DepGraphQuery<K>>>,\n+}\n+\n+impl<K: DepKind + Encodable<FileEncoder>> GraphEncoder<K> {\n+    pub fn new(\n+        encoder: FileEncoder,\n+        prev_node_count: usize,\n+        record_graph: bool,\n+        record_stats: bool,\n+    ) -> Self {\n+        let record_graph =\n+            if record_graph { Some(Lock::new(DepGraphQuery::new(prev_node_count))) } else { None };\n+        let status = Lock::new(EncoderState::new(encoder, record_stats));\n+        GraphEncoder { status, record_graph }\n+    }\n+\n+    pub(crate) fn with_query(&self, f: impl Fn(&DepGraphQuery<K>)) {\n+        if let Some(record_graph) = &self.record_graph {\n+            f(&record_graph.lock())\n+        }\n+    }\n+\n+    pub(crate) fn print_incremental_info(\n+        &self,\n+        total_read_count: u64,\n+        total_duplicate_read_count: u64,\n+    ) {\n+        let status = self.status.lock();\n+        if let Some(record_stats) = &status.stats {\n+            let mut stats: Vec<_> = record_stats.values().collect();\n+            stats.sort_by_key(|s| -(s.node_counter as i64));\n+\n+            const SEPARATOR: &str = \"[incremental] --------------------------------\\\n+                                     ----------------------------------------------\\\n+                                     ------------\";\n+\n+            eprintln!(\"[incremental]\");\n+            eprintln!(\"[incremental] DepGraph Statistics\");\n+            eprintln!(\"{}\", SEPARATOR);\n+            eprintln!(\"[incremental]\");\n+            eprintln!(\"[incremental] Total Node Count: {}\", status.total_node_count);\n+            eprintln!(\"[incremental] Total Edge Count: {}\", status.total_edge_count);\n+\n+            if cfg!(debug_assertions) {\n+                eprintln!(\"[incremental] Total Edge Reads: {}\", total_read_count);\n+                eprintln!(\n+                    \"[incremental] Total Duplicate Edge Reads: {}\",\n+                    total_duplicate_read_count\n+                );\n+            }\n+\n+            eprintln!(\"[incremental]\");\n+            eprintln!(\n+                \"[incremental]  {:<36}| {:<17}| {:<12}| {:<17}|\",\n+                \"Node Kind\", \"Node Frequency\", \"Node Count\", \"Avg. Edge Count\"\n+            );\n+            eprintln!(\"{}\", SEPARATOR);\n+\n+            for stat in stats {\n+                let node_kind_ratio =\n+                    (100.0 * (stat.node_counter as f64)) / (status.total_node_count as f64);\n+                let node_kind_avg_edges = (stat.edge_counter as f64) / (stat.node_counter as f64);\n+\n+                eprintln!(\n+                    \"[incremental]  {:<36}|{:>16.1}% |{:>12} |{:>17.1} |\",\n+                    format!(\"{:?}\", stat.kind),\n+                    node_kind_ratio,\n+                    stat.node_counter,\n+                    node_kind_avg_edges,\n+                );\n+            }\n+\n+            eprintln!(\"{}\", SEPARATOR);\n+            eprintln!(\"[incremental]\");\n+        }\n+    }\n+\n+    pub(crate) fn send(\n+        &self,\n+        profiler: &SelfProfilerRef,\n+        node: DepNode<K>,\n+        fingerprint: Fingerprint,\n+        edges: SmallVec<[DepNodeIndex; 8]>,\n+    ) -> DepNodeIndex {\n+        let _prof_timer = profiler.generic_activity(\"incr_comp_encode_dep_graph\");\n+        let node = NodeInfo { node, fingerprint, edges };\n+        self.status.lock().encode_node(&node, &self.record_graph)\n+    }\n \n-            Ok(SerializedDepGraph { nodes, fingerprints, edge_list_indices, edge_list_data })\n-        })\n+    pub fn finish(self, profiler: &SelfProfilerRef) -> FileEncodeResult {\n+        let _prof_timer = profiler.generic_activity(\"incr_comp_encode_dep_graph\");\n+        self.status.into_inner().finish()\n     }\n }"}, {"sha": "071144f38e702f2459a45f58fd5f10e57b6dff85", "filename": "compiler/rustc_query_system/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Flib.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -2,7 +2,9 @@\n #![feature(const_fn)]\n #![feature(const_panic)]\n #![feature(core_intrinsics)]\n+#![feature(drain_filter)]\n #![feature(hash_raw_entry)]\n+#![feature(iter_zip)]\n #![feature(min_specialization)]\n #![feature(stmt_expr_attributes)]\n "}, {"sha": "21f580db04f282920a808ba01f686dbd79e3163e", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72796a7c36d60cd5d32e181dd0fca924399c2a03/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=72796a7c36d60cd5d32e181dd0fca924399c2a03", "patch": "@@ -22,7 +22,7 @@ use {\n     rustc_data_structures::{jobserver, OnDrop},\n     rustc_rayon_core as rayon_core,\n     rustc_span::DUMMY_SP,\n-    std::iter::FromIterator,\n+    std::iter::{self, FromIterator},\n     std::{mem, process},\n };\n \n@@ -463,7 +463,7 @@ fn remove_cycle<D: DepKind>(\n         spans.rotate_right(1);\n \n         // Zip them back together\n-        let mut stack: Vec<_> = spans.into_iter().zip(queries).collect();\n+        let mut stack: Vec<_> = iter::zip(spans, queries).collect();\n \n         // Remove the queries in our cycle from the list of jobs to look at\n         for r in &stack {"}]}