{"sha": "cec1f38c309b743b29a386ce71db1b1035ccd89d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlYzFmMzhjMzA5Yjc0M2IyOWEzODZjZTcxZGIxYjEwMzVjY2Q4OWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-22T03:36:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-22T03:36:35Z"}, "message": "auto merge of #5077 : jbclements/rust/increase-monomorphization-depth-limit, r=catamorphism\n\nIt appears that using deriving_eq/auto_encode on ASTs bumps up against the \"gee this looks like infinite unfolding\" limit of 10 in monomorphization. Increasing it to 30 seems to solve this problem for me....\r\n\r\nAlso, commenting and a few renames.", "tree": {"sha": "6480b50424049e04700df24ef9ad1ed4dfef63fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6480b50424049e04700df24ef9ad1ed4dfef63fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cec1f38c309b743b29a386ce71db1b1035ccd89d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cec1f38c309b743b29a386ce71db1b1035ccd89d", "html_url": "https://github.com/rust-lang/rust/commit/cec1f38c309b743b29a386ce71db1b1035ccd89d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cec1f38c309b743b29a386ce71db1b1035ccd89d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7924ce18f05b386d390a61ea63934cbe464e510", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7924ce18f05b386d390a61ea63934cbe464e510", "html_url": "https://github.com/rust-lang/rust/commit/e7924ce18f05b386d390a61ea63934cbe464e510"}, {"sha": "1869df30a66243f6f44e37a4f6c8b3d1f098dc94", "url": "https://api.github.com/repos/rust-lang/rust/commits/1869df30a66243f6f44e37a4f6c8b3d1f098dc94", "html_url": "https://github.com/rust-lang/rust/commit/1869df30a66243f6f44e37a4f6c8b3d1f098dc94"}], "stats": {"total": 102, "additions": 77, "deletions": 25}, "files": [{"sha": "9be316b30223af77fe2838ce9fa856d1f70ee7c7", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cec1f38c309b743b29a386ce71db1b1035ccd89d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cec1f38c309b743b29a386ce71db1b1035ccd89d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=cec1f38c309b743b29a386ce71db1b1035ccd89d", "patch": "@@ -137,9 +137,9 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n \n     let depth = option::get_or_default(ccx.monomorphizing.find(&fn_id), 0u);\n     // Random cut-off -- code that needs to instantiate the same function\n-    // recursively more than ten times can probably safely be assumed to be\n+    // recursively more than thirty times can probably safely be assumed to be\n     // causing an infinite expansion.\n-    if depth > 10 {\n+    if depth > 30 {\n         ccx.sess.span_fatal(\n             span, ~\"overly deep expansion of inlined function\");\n     }"}, {"sha": "d16b1282c7c0beb5337bf360ecccd7d5c265eae6", "filename": "src/libstd/json.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cec1f38c309b743b29a386ce71db1b1035ccd89d/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cec1f38c309b743b29a386ce71db1b1035ccd89d/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=cec1f38c309b743b29a386ce71db1b1035ccd89d", "patch": "@@ -1294,8 +1294,6 @@ mod tests {\n         }\n     }\n \n-    // testing both auto_encode's calling patterns\n-    // and json... not sure where to put these tests.\n     #[test]\n     fn test_write_enum () {\n         let bw = @io::BytesWriter();"}, {"sha": "87e1dd2d22cb5af98b0c9d6d09291518aec58389", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cec1f38c309b743b29a386ce71db1b1035ccd89d/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cec1f38c309b743b29a386ce71db1b1035ccd89d/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=cec1f38c309b743b29a386ce71db1b1035ccd89d", "patch": "@@ -26,17 +26,9 @@ use std::term;\n pub type Emitter = fn@(cmsp: Option<(@codemap::CodeMap, span)>,\n                    msg: &str, lvl: level);\n \n-\n-pub trait span_handler {\n-    fn span_fatal(@mut self, sp: span, msg: &str) -> !;\n-    fn span_err(@mut self, sp: span, msg: &str);\n-    fn span_warn(@mut self, sp: span, msg: &str);\n-    fn span_note(@mut self, sp: span, msg: &str);\n-    fn span_bug(@mut self, sp: span, msg: &str) -> !;\n-    fn span_unimpl(@mut self, sp: span, msg: &str) -> !;\n-    fn handler(@mut self) -> handler;\n-}\n-\n+// a handler deals with errors; certain errors\n+// (fatal, bug, unimpl) may cause immediate exit,\n+// others log errors for later reporting.\n pub trait handler {\n     fn fatal(@mut self, msg: &str) -> !;\n     fn err(@mut self, msg: &str);\n@@ -45,6 +37,7 @@ pub trait handler {\n     fn abort_if_errors(@mut self);\n     fn warn(@mut self, msg: &str);\n     fn note(@mut self, msg: &str);\n+    // used to indicate a bug in the compiler:\n     fn bug(@mut self, msg: &str) -> !;\n     fn unimpl(@mut self, msg: &str) -> !;\n     fn emit(@mut self,\n@@ -53,6 +46,19 @@ pub trait handler {\n             lvl: level);\n }\n \n+// a span-handler is like a handler but also\n+// accepts span information for source-location\n+// reporting.\n+pub trait span_handler {\n+    fn span_fatal(@mut self, sp: span, msg: &str) -> !;\n+    fn span_err(@mut self, sp: span, msg: &str);\n+    fn span_warn(@mut self, sp: span, msg: &str);\n+    fn span_note(@mut self, sp: span, msg: &str);\n+    fn span_bug(@mut self, sp: span, msg: &str) -> !;\n+    fn span_unimpl(@mut self, sp: span, msg: &str) -> !;\n+    fn handler(@mut self) -> handler;\n+}\n+\n struct HandlerT {\n     err_count: uint,\n     emit: Emitter,"}, {"sha": "4f64d7bed3124c98d025df54046dde747cb025da", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cec1f38c309b743b29a386ce71db1b1035ccd89d/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cec1f38c309b743b29a386ce71db1b1035ccd89d/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=cec1f38c309b743b29a386ce71db1b1035ccd89d", "patch": "@@ -18,6 +18,7 @@ use parse::token;\n \n use core::either::{Either, Left, Right};\n \n+// a parser that can parse attributes.\n pub trait parser_attr {\n     fn parse_outer_attributes() -> ~[ast::attribute];\n     fn parse_attribute(style: ast::attr_style) -> ast::attribute;\n@@ -81,6 +82,9 @@ impl parser_attr for Parser {\n     // attribute of the next item (since we can't know whether the attribute\n     // is an inner attribute of the containing item or an outer attribute of\n     // the first contained item until we see the semi).\n+\n+    // you can make the 'next' field an Option, but the result is going to be\n+    // more useful as a vector.\n     fn parse_inner_attrs_and_next() ->\n         (~[ast::attribute], ~[ast::attribute]) {\n         let mut inner_attrs: ~[ast::attribute] = ~[];"}, {"sha": "4f330ea86b0b654ed17ab55b8dfb464781257620", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cec1f38c309b743b29a386ce71db1b1035ccd89d/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cec1f38c309b743b29a386ce71db1b1035ccd89d/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=cec1f38c309b743b29a386ce71db1b1035ccd89d", "patch": "@@ -74,11 +74,18 @@ pub fn new_parse_sess_special_handler(sh: span_handler, cm: @codemap::CodeMap)\n     }\n }\n \n+// a bunch of utility functions of the form parse_<thing>_from_<source>\n+// where <thing> includes crate, expr, item, stmt, tts, and one that\n+// uses a HOF to parse anything, and <source> includes file and\n+// source_str.\n+\n+// this appears to be the main entry point for rust parsing by\n+// rustc and crate:\n pub fn parse_crate_from_file(input: &Path, cfg: ast::crate_cfg,\n                          sess: @mut ParseSess) -> @ast::crate {\n-    let p = new_crate_parser_from_file(sess, cfg, input);\n-    let r = p.parse_crate_mod(cfg);\n-    return r;\n+    let p = new_parser_from_file(sess, cfg, input);\n+    p.parse_crate_mod(cfg)\n+    // why is there no p.abort_if_errors here?\n }\n \n pub fn parse_crate_from_source_str(name: ~str,\n@@ -174,7 +181,9 @@ pub fn new_parser_from_source_str(sess: @mut ParseSess, cfg: ast::crate_cfg,\n     return Parser(sess, cfg, srdr as reader);\n }\n \n-pub fn new_parser_from_file(sess: @mut ParseSess,\n+// Read the entire source file, return a parser\n+// that draws from that string\n+pub fn new_parser_result_from_file(sess: @mut ParseSess,\n                             cfg: ast::crate_cfg,\n                             path: &Path)\n                          -> Result<Parser, ~str> {\n@@ -194,9 +203,9 @@ pub fn new_parser_from_file(sess: @mut ParseSess,\n \n /// Create a new parser for an entire crate, handling errors as appropriate\n /// if the file doesn't exist\n-pub fn new_crate_parser_from_file(sess: @mut ParseSess, cfg: ast::crate_cfg,\n+pub fn new_parser_from_file(sess: @mut ParseSess, cfg: ast::crate_cfg,\n                               path: &Path) -> Parser {\n-    match new_parser_from_file(sess, cfg, path) {\n+    match new_parser_result_from_file(sess, cfg, path) {\n         Ok(parser) => parser,\n         Err(e) => {\n             sess.span_diagnostic.handler().fatal(e)\n@@ -208,7 +217,7 @@ pub fn new_crate_parser_from_file(sess: @mut ParseSess, cfg: ast::crate_cfg,\n /// error messages correctly when the file does not exist.\n pub fn new_sub_parser_from_file(sess: @mut ParseSess, cfg: ast::crate_cfg,\n                             path: &Path, sp: span) -> Parser {\n-    match new_parser_from_file(sess, cfg, path) {\n+    match new_parser_result_from_file(sess, cfg, path) {\n         Ok(parser) => parser,\n         Err(e) => {\n             sess.span_diagnostic.span_fatal(sp, e)"}, {"sha": "c7c8836126bdb96ace584711ea47f2b207b9d047", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cec1f38c309b743b29a386ce71db1b1035ccd89d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cec1f38c309b743b29a386ce71db1b1035ccd89d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=cec1f38c309b743b29a386ce71db1b1035ccd89d", "patch": "@@ -110,6 +110,7 @@ type arg_or_capture_item = Either<arg, ()>;\n type item_info = (ident, item_, Option<~[attribute]>);\n \n pub enum item_or_view_item {\n+    // indicates a failure to parse any kind of item:\n     iovi_none,\n     iovi_item(@item),\n     iovi_foreign_item(@foreign_item),\n@@ -2666,7 +2667,8 @@ pub impl Parser {\n                           _ => None\n                         }\n                       }\n-                      _ => fail!()\n+                      _ => self.bug(\n+                          ~\"is_ident() said this would be an identifier\")\n                     };\n \n                     match maybe_bound {\n@@ -3204,9 +3206,12 @@ pub impl Parser {\n         self.eat_keyword(~\"static\")\n     }\n \n+    // given a termination token and a vector of already-parsed\n+    // attributes (of length 0 or 1), parse all of the items in a module\n     fn parse_mod_items(term: token::Token,\n                        +first_item_attrs: ~[attribute]) -> _mod {\n-        // Shouldn't be any view items since we've already parsed an item attr\n+        // parse all of the items up to closing or an attribute.\n+        // view items are legal here.\n         let ParsedItemsAndViewItems {\n             attrs_remaining: attrs_remaining,\n             view_items: view_items,\n@@ -3217,6 +3222,9 @@ pub impl Parser {\n                                             true);\n         let mut items: ~[@item] = starting_items;\n \n+        // looks like this code depends on the invariant that\n+        // outer attributes can't occur on view items (or macros\n+        // invocations?)\n         let mut first = true;\n         while self.token != term {\n             let mut attrs = self.parse_outer_attributes();\n@@ -3751,6 +3759,8 @@ pub impl Parser {\n         }\n     }\n \n+    // parse one of the items or view items allowed by the\n+    // flags; on failure, return iovi_none.\n     fn parse_item_or_view_item(+attrs: ~[attribute], items_allowed: bool,\n                                foreign_items_allowed: bool,\n                                macros_allowed: bool)\n@@ -3770,14 +3780,17 @@ pub impl Parser {\n         }\n \n         if items_allowed && self.eat_keyword(~\"const\") {\n+            // CONST ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_const();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if foreign_items_allowed && self.is_keyword(~\"const\") {\n+            // FOREIGN CONST ITEM\n             let item = self.parse_item_foreign_const(visibility, attrs);\n             return iovi_foreign_item(item);\n         } else if items_allowed &&\n+            // FUNCTION ITEM (not sure about lookahead condition...)\n             self.is_keyword(~\"fn\") &&\n             !self.fn_expr_lookahead(self.look_ahead(1u)) {\n             self.bump();\n@@ -3786,6 +3799,7 @@ pub impl Parser {\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if items_allowed && self.eat_keyword(~\"pure\") {\n+            // PURE FUNCTION ITEM\n             self.expect_keyword(~\"fn\");\n             let (ident, item_, extra_attrs) = self.parse_item_fn(pure_fn);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n@@ -3794,10 +3808,12 @@ pub impl Parser {\n         } else if foreign_items_allowed &&\n             (self.is_keyword(~\"fn\") || self.is_keyword(~\"pure\") ||\n              self.is_keyword(~\"unsafe\")) {\n+            // FOREIGN FUNCTION ITEM (no items allowed)\n                 let item = self.parse_item_foreign_fn(attrs);\n                 return iovi_foreign_item(item);\n         } else if items_allowed && self.is_keyword(~\"unsafe\")\n             && self.look_ahead(1u) != token::LBRACE {\n+            // UNSAFE FUNCTION ITEM (where items are allowed)\n             self.bump();\n             self.expect_keyword(~\"fn\");\n             let (ident, item_, extra_attrs) = self.parse_item_fn(unsafe_fn);\n@@ -3806,46 +3822,55 @@ pub impl Parser {\n                                           maybe_append(attrs, extra_attrs)));\n         } else if self.eat_keyword(~\"extern\") {\n             if items_allowed && self.eat_keyword(~\"fn\") {\n+                // EXTERN FUNCTION ITEM\n                 let (ident, item_, extra_attrs) =\n                     self.parse_item_fn(extern_fn);\n                 return iovi_item(self.mk_item(lo, self.last_span.hi, ident,\n                                               item_, visibility,\n                                               maybe_append(attrs,\n                                                            extra_attrs)));\n             }\n+            // EXTERN MODULE ITEM\n             return self.parse_item_foreign_mod(lo, visibility, attrs,\n                                                items_allowed);\n         } else if items_allowed && self.eat_keyword(~\"mod\") {\n+            // MODULE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_mod(attrs);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if items_allowed && self.eat_keyword(~\"type\") {\n+            // TYPE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_type();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if items_allowed && self.eat_keyword(~\"enum\") {\n+            // ENUM ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_enum();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if items_allowed && self.eat_keyword(~\"trait\") {\n+            // TRAIT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_trait();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if items_allowed && self.eat_keyword(~\"impl\") {\n+            // IMPL ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_impl();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if items_allowed && self.eat_keyword(~\"struct\") {\n+            // STRUCT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_struct();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if self.eat_keyword(~\"use\") {\n+            // USE ITEM\n             let view_item = self.parse_use();\n             self.expect(token::SEMI);\n             return iovi_view_item(@ast::view_item {\n@@ -3859,6 +3884,7 @@ pub impl Parser {\n                 && (is_plain_ident(self.look_ahead(2))\n                     || self.look_ahead(2) == token::LPAREN\n                     || self.look_ahead(2) == token::LBRACE) {\n+            // MACRO INVOCATION ITEM\n             if attrs.len() > 0 {\n                 self.fatal(~\"attrs on macros are not yet supported\");\n             }\n@@ -3875,6 +3901,7 @@ pub impl Parser {\n             } else {\n                 token::special_idents::invalid // no special identifier\n             };\n+            // eat a matched-delimiter token tree:\n             let tts = match self.token {\n               token::LPAREN | token::LBRACE => {\n                 let ket = token::flip_delimiter(copy self.token);\n@@ -3884,6 +3911,7 @@ pub impl Parser {\n               }\n               _ => self.fatal(~\"expected open delimiter\")\n             };\n+            // single-variant-enum... :\n             let m = ast::mac_invoc_tt(pth, tts);\n             let m: ast::mac = codemap::spanned { node: m,\n                                              span: mk_sp(self.span.lo,\n@@ -3892,6 +3920,7 @@ pub impl Parser {\n             return iovi_item(self.mk_item(lo, self.last_span.hi, id, item_,\n                                           visibility, attrs));\n         } else {\n+            // FAILURE TO PARSE ITEM\n             if visibility != inherited {\n                 let mut s = ~\"unmatched visibility `\";\n                 s += if visibility == public { ~\"pub\" } else { ~\"priv\" };\n@@ -4030,6 +4059,7 @@ pub impl Parser {\n                 self.token_is_keyword(~\"mod\", next_tok))\n     }\n \n+    // parse a view item.\n     fn parse_view_item(+attrs: ~[attribute], vis: visibility) -> @view_item {\n         let lo = self.span.lo;\n         let node = if self.eat_keyword(~\"use\") {\n@@ -4040,7 +4070,7 @@ pub impl Parser {\n             let metadata = self.parse_optional_meta();\n             view_item_extern_mod(ident, metadata, self.get_id())\n         } else {\n-            fail!();\n+            self.bug(~\"expected view item\");\n         };\n         self.expect(token::SEMI);\n         @ast::view_item { node: node,\n@@ -4049,6 +4079,8 @@ pub impl Parser {\n                           span: mk_sp(lo, self.last_span.hi) }\n     }\n \n+    // Parses a sequence of items. Stops when it finds program\n+    // text that can't be parsed as an item\n     fn parse_items_and_view_items(+first_item_attrs: ~[attribute],\n                                   mode: view_item_parse_mode,\n                                   macros_allowed: bool)\n@@ -4114,8 +4146,11 @@ pub impl Parser {\n     // Parses a source module as a crate\n     fn parse_crate_mod(_cfg: crate_cfg) -> @crate {\n         let lo = self.span.lo;\n+        // parse the crate's inner attrs, maybe (oops) one\n+        // of the attrs of an item:\n         let (inner, next) = self.parse_inner_attrs_and_next();\n         let first_item_outer_attrs = next;\n+        // parse the items inside the crate:\n         let m = self.parse_mod_items(token::EOF, first_item_outer_attrs);\n         @spanned(lo, self.span.lo,\n                  ast::crate_ { module: m,"}]}