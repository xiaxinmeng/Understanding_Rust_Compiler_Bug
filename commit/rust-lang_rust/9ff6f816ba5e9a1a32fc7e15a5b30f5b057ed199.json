{"sha": "9ff6f816ba5e9a1a32fc7e15a5b30f5b057ed199", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmZjZmODE2YmE1ZTlhMWEzMmZjN2UxNWE1YjMwZjViMDU3ZWQxOTk=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-15T10:16:41Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-15T12:29:57Z"}, "message": "Fix handling of loops and conditionals in alias.rs\n\nIt now threads information about invalidated aliases through the AST\nproperly. This makes it more permissive for conditionals (invalidating\nan alias in one branch doesn't prevent you from using it in another),\nand less permissive for loops (it now properly notices when a loop\ninvalidates an alias that it might still use in another iteration).\n\nCloses #1144", "tree": {"sha": "55b0431d74aa9ac957749886fcf357bde0d66309", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55b0431d74aa9ac957749886fcf357bde0d66309"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ff6f816ba5e9a1a32fc7e15a5b30f5b057ed199", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ff6f816ba5e9a1a32fc7e15a5b30f5b057ed199", "html_url": "https://github.com/rust-lang/rust/commit/9ff6f816ba5e9a1a32fc7e15a5b30f5b057ed199", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ff6f816ba5e9a1a32fc7e15a5b30f5b057ed199/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81d9717864f925c12229098fe7570b53bf8824cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/81d9717864f925c12229098fe7570b53bf8824cd", "html_url": "https://github.com/rust-lang/rust/commit/81d9717864f925c12229098fe7570b53bf8824cd"}], "stats": {"total": 231, "additions": 169, "deletions": 62}, "files": [{"sha": "a1fd65c44e7cbc31f0462df3efb7a38f6d577a51", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9ff6f816ba5e9a1a32fc7e15a5b30f5b057ed199/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff6f816ba5e9a1a32fc7e15a5b30f5b057ed199/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=9ff6f816ba5e9a1a32fc7e15a5b30f5b057ed199", "patch": "@@ -76,6 +76,7 @@ obj session(targ_cfg: @config,\n         codemap::emit_error(none, msg, parse_sess.cm);\n         err_count += 1u;\n     }\n+    fn has_errors() -> bool { err_count > 0u }\n     fn abort_if_errors() {\n         if err_count > 0u { self.fatal(\"aborting due to previous errors\"); }\n     }"}, {"sha": "351381b0aa4cd46454c1c07a8988a469e988e884", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 149, "deletions": 62, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/9ff6f816ba5e9a1a32fc7e15a5b30f5b057ed199/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff6f816ba5e9a1a32fc7e15a5b30f5b057ed199/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=9ff6f816ba5e9a1a32fc7e15a5b30f5b057ed199", "patch": "@@ -4,15 +4,20 @@ import ast::{ident, fn_ident, node_id};\n import syntax::codemap::span;\n import syntax::visit;\n import visit::vt;\n-import std::{vec, option};\n+import std::{vec, option, list};\n import std::option::{some, none, is_none};\n+import list::list;\n \n // This is not an alias-analyser (though it would merit from becoming one, or\n // getting input from one, to be more precise). It is a pass that checks\n // whether aliases are used in a safe way.\n \n-tag valid { valid; overwritten(span, ast::path); val_taken(span, ast::path); }\n tag copied { not_allowed; copied; not_copied; }\n+tag invalid_reason { overwritten; val_taken; }\n+type invalid = {reason: invalid_reason,\n+                node_id: node_id,\n+                sp: span, path:\n+                ast::path};\n \n tag unsafe_ty { contains(ty::t); mut_contains(ty::t); }\n \n@@ -21,18 +26,19 @@ type binding = @{node_id: node_id,\n                  root_var: option::t<node_id>,\n                  local_id: uint,\n                  unsafe_tys: [unsafe_ty],\n-                 mutable ok: valid,\n                  mutable copied: copied};\n \n tag ret_info { by_ref(bool, node_id); other; }\n // FIXME it may be worthwhile to use a linked list of bindings instead\n-type scope = {bs: [binding], ret_info: ret_info};\n+type scope = {bs: [binding],\n+              ret_info: ret_info,\n+              invalid: @mutable list<@invalid>};\n \n fn mk_binding(cx: ctx, id: node_id, span: span, root_var: option::t<node_id>,\n               unsafe_tys: [unsafe_ty]) -> binding {\n     ret @{node_id: id, span: span, root_var: root_var,\n           local_id: local_id_of_node(cx, id),\n-          unsafe_tys: unsafe_tys, mutable ok: valid,\n+          unsafe_tys: unsafe_tys,\n           mutable copied: not_copied};\n }\n \n@@ -41,18 +47,21 @@ tag local_info { local(uint); }\n type copy_map = std::map::hashmap<node_id, ()>;\n \n type ctx = {tcx: ty::ctxt,\n-            copy_map: copy_map};\n+            copy_map: copy_map,\n+            mutable silent: bool};\n \n fn check_crate(tcx: ty::ctxt, crate: @ast::crate) -> copy_map {\n     // Stores information about object fields and function\n     // arguments that's otherwise not easily available.\n     let cx = @{tcx: tcx,\n-               copy_map: std::map::new_int_hash()};\n+               copy_map: std::map::new_int_hash(),\n+               mutable silent: false};\n     let v = @{visit_fn: bind visit_fn(cx, _, _, _, _, _, _, _),\n               visit_expr: bind visit_expr(cx, _, _, _),\n               visit_block: bind visit_block(cx, _, _, _)\n               with *visit::default_visitor::<scope>()};\n-    visit::visit_crate(*crate, {bs: [], ret_info: other}, visit::mk_vt(v));\n+    let sc = {bs: [], ret_info: other, invalid: @mutable list::nil};\n+    visit::visit_crate(*crate, sc, visit::mk_vt(v));\n     tcx.sess.abort_if_errors();\n     ret cx.copy_map;\n }\n@@ -64,30 +73,30 @@ fn visit_fn(cx: @ctx, f: ast::_fn, _tp: [ast::ty_param], sp: span,\n     for arg in args {\n         if arg.mode == ast::by_val &&\n            ty::type_has_dynamic_size(cx.tcx, arg.ty) {\n-            cx.tcx.sess.span_err\n-                (sp, \"can not pass a dynamically-sized type by value\");\n+            err(*cx, sp, \"can not pass a dynamically-sized type by value\");\n         }\n     }\n \n-    let bs = alt f.proto {\n-      // Blocks need to obey any restrictions from the enclosing scope.\n-      ast::proto_block. | ast::proto_shared(_) { sc.bs }\n-      // Non capturing functions start out fresh.\n-      _ { [] }\n-    };\n     if ast_util::ret_by_ref(f.decl.cf) && !is_none(f.body.node.expr) {\n         // FIXME this will be easier to lift once have DPS\n-        cx.tcx.sess.span_err(option::get(f.body.node.expr).span,\n-                             \"reference-returning functions may not \" +\n-                             \"return implicitly\");\n+        err(*cx, option::get(f.body.node.expr).span,\n+            \"reference-returning functions may not return implicitly\");\n     }\n     let ret_info = alt f.decl.cf {\n       ast::return_ref(mut, n_arg) {\n         by_ref(mut, f.decl.inputs[n_arg - 1u].id)\n       }\n       _ { other }\n     };\n-    v.visit_block(f.body, {bs: bs, ret_info: ret_info}, v);\n+    // Blocks need to obey any restrictions from the enclosing scope, and may\n+    // be called multiple times.\n+    if f.proto == ast::proto_block {\n+        let sc = {ret_info: ret_info with sc};\n+        check_loop(*cx, sc) {|| v.visit_block(f.body, sc, v);}\n+    } else {\n+        let sc = {bs: [], ret_info: ret_info, invalid: @mutable list::nil};\n+        v.visit_block(f.body, sc, v);\n+    }\n }\n \n fn visit_expr(cx: @ctx, ex: @ast::expr, sc: scope, v: vt<scope>) {\n@@ -98,7 +107,10 @@ fn visit_expr(cx: @ctx, ex: @ast::expr, sc: scope, v: vt<scope>) {\n         handled = false;\n       }\n       ast::expr_alt(input, arms) { check_alt(*cx, input, arms, sc, v); }\n-      ast::expr_for(decl, seq, blk) { check_for(*cx, decl, seq, blk, sc, v); }\n+      ast::expr_for(decl, seq, blk) {\n+        v.visit_expr(seq, sc, v);\n+        check_loop(*cx, sc) {|| check_for(*cx, decl, seq, blk, sc, v); }\n+      }\n       ast::expr_path(pt) {\n         check_var(*cx, ex, pt, ex.id, false, sc);\n         handled = false;\n@@ -126,6 +138,10 @@ fn visit_expr(cx: @ctx, ex: @ast::expr, sc: scope, v: vt<scope>) {\n         }\n         handled = false;\n       }\n+      ast::expr_if(c, then, els) { check_if(c, then, els, sc, v); }\n+      ast::expr_while(_, _) | ast::expr_do_while(_, _) {\n+        check_loop(*cx, sc) {|| visit::visit_expr(ex, sc, v); }\n+      }\n       _ { handled = false; }\n     }\n     if !handled { visit::visit_expr(ex, sc, v); }\n@@ -169,14 +185,13 @@ fn add_bindings_for_let(cx: ctx, &bs: [binding], loc: @ast::local) {\n     alt loc.node.init {\n       some(init) {\n         if init.op == ast::init_move {\n-            cx.tcx.sess.span_err\n-                (loc.span, \"can not move into a by-reference binding\");\n+            err(cx, loc.span, \"can not move into a by-reference binding\");\n         }\n         let root = expr_root(cx, init.expr, false);\n         let root_var = path_def_id(cx, root.ex);\n         if is_none(root_var) {\n-            cx.tcx.sess.span_err(loc.span, \"a reference binding can't be \\\n-                                            rooted in a temporary\");\n+            err(cx, loc.span, \"a reference binding can't be \\\n+                               rooted in a temporary\");\n         }\n         for proot in pattern_roots(cx.tcx, root.mut, loc.node.pat) {\n             let bnd = mk_binding(cx, proot.id, proot.span, root_var,\n@@ -187,8 +202,7 @@ fn add_bindings_for_let(cx: ctx, &bs: [binding], loc: @ast::local) {\n         }\n       }\n       _ {\n-        cx.tcx.sess.span_err\n-            (loc.span, \"by-reference bindings must be initialized\");\n+        err(cx, loc.span, \"by-reference bindings must be initialized\");\n       }\n     }\n }\n@@ -240,7 +254,6 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr]) -> [binding] {\n                        root_var: root_var,\n                        local_id: 0u,\n                        unsafe_tys: unsafe_set(root.mut),\n-                       mutable ok: valid,\n                        mutable copied: alt arg_t.mode {\n                          ast::by_move. { copied }\n                          ast::by_mut_ref. { not_allowed }\n@@ -257,10 +270,8 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr]) -> [binding] {\n         let i = 0u;\n         for b in bindings {\n             if vec::len(b.unsafe_tys) > 0u && cant_copy(cx, b) {\n-                cx.tcx.sess.span_err(f.span,\n-                                     #fmt[\"function may alias with argument \\\n-                                           %u, which is not immutably rooted\",\n-                                          i]);\n+                err(cx, f.span, #fmt[\"function may alias with argument \\\n+                                     %u, which is not immutably rooted\", i]);\n             }\n             i += 1u;\n         }\n@@ -275,11 +286,9 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr]) -> [binding] {\n                        ty_can_unsafely_include(cx, unsafe_ty, arg_t.ty,\n                                                mut_alias) &&\n                        cant_copy(cx, b) {\n-                    cx.tcx.sess.span_err\n-                        (args[i].span,\n-                         #fmt[\"argument %u may alias with argument %u, \\\n-                              which is not immutably rooted\",\n-                                              i, j]);\n+                    err(cx, args[i].span,\n+                        #fmt[\"argument %u may alias with argument %u, \\\n+                             which is not immutably rooted\", i, j]);\n                 }\n                 i += 1u;\n             }\n@@ -295,10 +304,9 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr]) -> [binding] {\n                 alt b.root_var {\n                   some(root) {\n                     if node == root && cant_copy(cx, b) {\n-                        cx.tcx.sess.span_err\n-                            (args[arg].span,\n-                             \"passing a mutable reference to a \\\n-                              variable that roots another reference\");\n+                        err(cx, args[arg].span,\n+                            \"passing a mutable reference to a \\\n+                             variable that roots another reference\");\n                         break;\n                     }\n                   }\n@@ -365,8 +373,7 @@ fn check_ret_ref(cx: ctx, sc: scope, mut: bool, arg_node_id: node_id,\n     if mut_field && !mut { bad = some(\"a mutable field\"); }\n     alt bad {\n       some(name) {\n-        cx.tcx.sess.span_err(expr.span, \"can not return a reference to \" +\n-                             name);\n+        err(cx, expr.span, \"can not return a reference to \" + name);\n       }\n       _ {}\n     }\n@@ -375,6 +382,8 @@ fn check_ret_ref(cx: ctx, sc: scope, mut: bool, arg_node_id: node_id,\n fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n              v: vt<scope>) {\n     v.visit_expr(input, sc, v);\n+    let orig_invalid = *sc.invalid;\n+    let all_invalid = orig_invalid;\n     let root = expr_root(cx, input, true);\n     for a: ast::arm in arms {\n         let new_bs = sc.bs;\n@@ -403,13 +412,15 @@ fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n             new_bs += [mk_binding(cx, info.id, info.span, root_var,\n                                   copy info.unsafe_tys)];\n         }\n+        *sc.invalid = orig_invalid;\n         visit::visit_arm(a, {bs: new_bs with sc}, v);\n+        all_invalid = append_invalid(all_invalid, *sc.invalid, orig_invalid);\n     }\n+    *sc.invalid = all_invalid;\n }\n \n fn check_for(cx: ctx, local: @ast::local, seq: @ast::expr, blk: ast::blk,\n              sc: scope, v: vt<scope>) {\n-    v.visit_expr(seq, sc, v);\n     let root = expr_root(cx, seq, false);\n \n     // If this is a mutable vector, don't allow it to be touched.\n@@ -444,7 +455,9 @@ fn check_var(cx: ctx, ex: @ast::expr, p: ast::path, id: ast::node_id,\n         if my_local_id < b.local_id {\n             for unsafe_ty in b.unsafe_tys {\n                 if ty_can_unsafely_include(cx, unsafe_ty, var_t, assign) {\n-                    b.ok = val_taken(ex.span, p);\n+                    let inv = @{reason: val_taken, node_id: b.node_id,\n+                                sp: ex.span, path: p};\n+                    *sc.invalid = list::cons(inv, @*sc.invalid);\n                 }\n             }\n         } else if b.node_id == my_defnum {\n@@ -459,7 +472,11 @@ fn check_lval(cx: @ctx, dest: @ast::expr, sc: scope, v: vt<scope>) {\n         let def = cx.tcx.def_map.get(dest.id);\n         let dnum = ast_util::def_id_of_def(def).node;\n         for b in sc.bs {\n-            if b.root_var == some(dnum) { b.ok = overwritten(dest.span, p); }\n+            if b.root_var == some(dnum) {\n+                let inv = @{reason: overwritten, node_id: b.node_id,\n+                            sp: dest.span, path: p};\n+                *sc.invalid = list::cons(inv, @*sc.invalid);\n+            }\n         }\n       }\n       _ { visit_expr(cx, dest, sc, v); }\n@@ -472,33 +489,52 @@ fn check_assign(cx: @ctx, dest: @ast::expr, src: @ast::expr, sc: scope,\n     check_lval(cx, dest, sc, v);\n }\n \n+fn check_if(c: @ast::expr, then: ast::blk, els: option::t<@ast::expr>,\n+            sc: scope, v: vt<scope>) {\n+    v.visit_expr(c, sc, v);\n+    let orig_invalid = *sc.invalid;\n+    v.visit_block(then, sc, v);\n+    let then_invalid = *sc.invalid;\n+    *sc.invalid = orig_invalid;\n+    visit::visit_expr_opt(els, sc, v);\n+    *sc.invalid = append_invalid(*sc.invalid, then_invalid, orig_invalid);\n+}\n+\n+fn check_loop(cx: ctx, sc: scope, checker: block()) {\n+    let orig_invalid = filter_invalid(*sc.invalid, sc.bs);\n+    checker();\n+    let new_invalid = filter_invalid(*sc.invalid, sc.bs);\n+    // Have to check contents of loop again if it invalidated an alias\n+    if list::len(orig_invalid) < list::len(new_invalid) {\n+        let old_silent = cx.silent;\n+        cx.silent = true;\n+        checker();\n+        cx.silent = old_silent;\n+    }\n+    *sc.invalid = new_invalid;\n+}\n+\n fn test_scope(cx: ctx, sc: scope, b: binding, p: ast::path) {\n-    let prob = b.ok;\n+    let prob = find_invalid(b.node_id, *sc.invalid);\n     alt b.root_var {\n       some(dn) {\n         for other in sc.bs {\n+            if !is_none(prob) { break; }\n             if other.node_id == dn {\n-                prob = other.ok;\n-                if prob != valid { break; }\n+                prob = find_invalid(other.node_id, *sc.invalid);\n             }\n         }\n       }\n       _ {}\n     }\n-    if prob != valid && cant_copy(cx, b) {\n-        let msg = alt prob {\n-          overwritten(sp, wpt) {\n-            {span: sp, msg: \"overwriting \" + ast_util::path_name(wpt)}\n-          }\n-          val_taken(sp, vpt) {\n-            {span: sp,\n-             msg: \"taking the value of \" + ast_util::path_name(vpt)}\n-          }\n+    if !is_none(prob) && cant_copy(cx, b) {\n+        let i = option::get(prob);\n+        let msg = alt i.reason {\n+          overwritten. { \"overwriting \" + ast_util::path_name(i.path) }\n+          val_taken. { \"taking the value of \" + ast_util::path_name(i.path) }\n         };\n-        cx.tcx.sess.span_err(msg.span,\n-                             msg.msg + \" will invalidate reference \" +\n-                                 ast_util::path_name(p) +\n-                                 \", which is still used\");\n+        err(cx, i.sp, msg + \" will invalidate reference \" +\n+            ast_util::path_name(p) + \", which is still used\");\n     }\n }\n \n@@ -700,6 +736,57 @@ fn unsafe_set(from: option::t<unsafe_ty>) -> [unsafe_ty] {\n     alt from { some(t) { [t] } _ { [] } }\n }\n \n+fn find_invalid(id: node_id, lst: list<@invalid>)\n+    -> option::t<@invalid> {\n+    let cur = lst;\n+    while true {\n+        alt cur {\n+          list::nil. { break; }\n+          list::cons(head, tail) {\n+            if head.node_id == id { ret some(head); }\n+            cur = *tail;\n+          }\n+        }\n+    }\n+    ret none;\n+}\n+\n+fn append_invalid(dest: list<@invalid>, src: list<@invalid>,\n+                  stop: list<@invalid>) -> list<@invalid> {\n+    let cur = src, dest = dest;\n+    while cur != stop {\n+        alt cur {\n+          list::cons(head, tail) {\n+            if is_none(find_invalid(head.node_id, dest)) {\n+                dest = list::cons(head, @dest);\n+            }\n+            cur = *tail;\n+          }\n+        }\n+    }\n+    ret dest;\n+}\n+\n+fn filter_invalid(src: list<@invalid>, bs: [binding]) -> list<@invalid> {\n+    let out = list::nil, cur = src;\n+    while cur != list::nil {\n+        alt cur {\n+          list::cons(head, tail) {\n+            let p = vec::position_pred({|b| b.node_id == head.node_id}, bs);\n+            if !is_none(p) { out = list::cons(head, @out); }\n+            cur = *tail;\n+          }\n+        }\n+    }\n+    ret out;\n+}\n+\n+fn err(cx: ctx, sp: span, err: str) {\n+    if !cx.silent || !cx.tcx.sess.has_errors() {\n+        cx.tcx.sess.span_err(sp, err);\n+    }\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "a873fbf4358ed6828358b50522e0738112eda0d2", "filename": "src/test/compile-fail/reference-in-loop.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9ff6f816ba5e9a1a32fc7e15a5b30f5b057ed199/src%2Ftest%2Fcompile-fail%2Freference-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff6f816ba5e9a1a32fc7e15a5b30f5b057ed199/src%2Ftest%2Fcompile-fail%2Freference-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freference-in-loop.rs?ref=9ff6f816ba5e9a1a32fc7e15a5b30f5b057ed199", "patch": "@@ -0,0 +1,10 @@\n+// error-pattern: overwriting x will invalidate reference y\n+\n+fn main() {\n+    let x = [];\n+    let &y = x;\n+    while true {\n+        log_err y;\n+        x = [1];\n+    }\n+}"}, {"sha": "7c5d0c660f74ab41ad29d5bd723ba71a62c9ed58", "filename": "src/test/run-pass/reference-branch.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9ff6f816ba5e9a1a32fc7e15a5b30f5b057ed199/src%2Ftest%2Frun-pass%2Freference-branch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff6f816ba5e9a1a32fc7e15a5b30f5b057ed199/src%2Ftest%2Frun-pass%2Freference-branch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freference-branch.rs?ref=9ff6f816ba5e9a1a32fc7e15a5b30f5b057ed199", "patch": "@@ -0,0 +1,9 @@\n+// Ensures that invalidating a reference in one branch doesn't\n+// influence other branches.\n+\n+fn main() {\n+    let x = [];\n+    let &y = x;\n+    if true { x = [1]; }\n+    else { log_err y; }\n+}"}]}